/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#if defined(INCLUDE_INT)

#include <bcm_int/control.h>

#include <bcm_int/ltsw/xgs/int.h>
#include <bcm_int/ltsw/int.h>
#include <bcm_int/ltsw/int_int.h>
#include <bcm_int/ltsw/mbcm/int.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/ha.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/cosq_thd.h>
#include <bcm_int/ltsw/index_table_mgmt.h>

#include <sal/sal_types.h>
#include <bcmltd/chip/bcmltd_str.h>
#include <shr/shr_types.h>
#include <shr/shr_bitop.h>
#include <shr/shr_debug.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_INT

/*! Max metadata profile number. */
#define INT_MAX_METADATA_PROFILE_NUM 8

/*! Max metadata narrow field number. */
#define INT_MAX_METADATA_FIELD_NARROW_NUM 12

/*! Max metadata wide field number. */
#define INT_MAX_METADATA_FIELD_WIDE_NUM 12

/*!
 * \brief INT metadata profile.
 */
typedef struct int_metadata_profile_s {

    /*! Metadata field select profile ID. */
    uint8_t select_profile_id;

    /*! Metadata field construct profile ID. */
    uint8_t construct_profile_id;

} int_metadata_profile_t;

/*!
 * \brief INT metadata select field entry.
 */
typedef struct int_metadata_select_field_entry_s {

    /*! Index of the chunk on the bus, starting from the MSB of the bus. */
    uint8_t chunk_index;

    /*! Starting bit position of the field within the chunk, from the MSB of the chunk. */
    uint8_t start;

    /*! Size of the field in bits. */
    uint8_t size;

    /*! Number of bits of the field to barrel shift towards LSB. */
    uint8_t shift;

} int_metadata_select_field_entry_t;

/*!
 * \brief INT metadata select profile.
 */
typedef struct int_metadata_select_profile_s {

    /*! Metadata select profile field entry. */
    int_metadata_select_field_entry_t *field;

} int_metadata_select_profile_t;

/*!
 * \brief INT metadata construct field entry.
 */
typedef struct int_metadata_construct_field_entry_s {

    /*! The relative offset of the field within metadata, starting from the MSB of metadata, with byte as granularity. */
    uint8_t offset;

} int_metadata_construct_field_entry_t;

/*!
 * \brief INT metadata construct profile.
 */
typedef struct int_metadata_construct_profile_s {

    /*! Metadata construct profile field entry. */
    int_metadata_construct_field_entry_t *field;

} int_metadata_construct_profile_t;

/******************************************************************************
 * Private functions
 */


#define XGS_MAX_OPAQUE_DATA_NUM             3

typedef struct int_switch_control_s {
    const char *ltname;
    const char *field_str;
} int_switch_control_t;

static int_switch_control_t int_sc_info[bcmiIntControlCount] =
{
    [bcmiIntControlEgressTimeDelta] =            {DEVICE_TS_CONTROLs, LATENCY_ADJUSTs},
    [bcmiIntControlSwitchId] =                   {MON_INBAND_TELEMETRY_METADATA_FIELD_CONTROLs, SWITCH_IDENTIFIERs},
    [bcmiIntControlIfaVersion] =                 {MON_INBAND_TELEMETRY_IFA_PARSEs, VERSIONs},
    [bcmiIntControlIfaProtocol] =                {MON_INBAND_TELEMETRY_IFA_PARSEs, IP_PROTOs},
    [bcmiIntControlIoamGreProtocolParse] =       {MON_INBAND_TELEMETRY_IOAM_PARSEs, GRE_ENCAPs},
    [bcmiIntControlIoamGreProtocol] =            {MON_INBAND_TELEMETRY_IOAM_PARSEs, GRE_PROTOs},
    [bcmiIntControlIoamOptionIncrementalParse] = {MON_INBAND_TELEMETRY_IOAM_PARSEs, IPV6_ENCAPs},
    [bcmiIntControlIoamOptionIncremental] =      {MON_INBAND_TELEMETRY_IOAM_PARSEs, INCREMENTAL_TRACE_OPTIONs},
    [bcmiIntControlIntDpVersion] =               {MON_INBAND_TELEMETRY_DATAPLANE_PARSEs, VERSIONs},
    [bcmiIntControlIntDpUseProbeMarker1] =       {MON_INBAND_TELEMETRY_DATAPLANE_PARSEs, USE_PROBE_MARKER_1s},
    [bcmiIntControlIntDpProbeMarker1] =          {MON_INBAND_TELEMETRY_DATAPLANE_PARSEs, PROBE_MARKER_1s},
    [bcmiIntControlIntDpUseProbeMarker2] =       {MON_INBAND_TELEMETRY_DATAPLANE_PARSEs, USE_PROBE_MARKER_2s},
    [bcmiIntControlIntDpProbeMarker2] =          {MON_INBAND_TELEMETRY_DATAPLANE_PARSEs, PROBE_MARKER_2s},
    [bcmiIntControlIntTurnAroundCpuEnable] =     {MON_INBAND_TELEMETRY_DATAPLANE_CONTROLs, TURNAROUND_COPY_TO_CPUs},
    [bcmiIntControlIntHopLimitCpuEnable] =       {MON_INBAND_TELEMETRY_DATAPLANE_CONTROLs, HOPLIMIT_COPY_TO_CPUs},
};

typedef struct xgs_ltsw_int_info_s {

    /*! Used bitmap for INT vector match ID. */
    SHR_BITDCL *vector_match_bmp;

    /*! Store vector match criteria for INT. */
    bcmi_ltsw_int_vector_match_t *vector_match;

    /*! Store vector match priority. */
    int *vector_match_priority;

    /*! Vector match number. */
    uint32_t vector_match_num;

    /*! Store type for INT action. */
    bcmi_ltsw_int_action_profile_type_t *action_type;

    /*! Used bitmap for INT metadata field entry. */
    SHR_BITDCL *metadata_field_bmp[INT_MAX_METADATA_PROFILE_NUM][bcmintIntMdFieldEntryCount];

    /*! Used bitmap for INT metadata ID. */
    SHR_BITDCL *metadata_bmp;

} xgs_ltsw_int_info_t;

static xgs_ltsw_int_info_t xgs_ltsw_int_info[BCM_MAX_NUM_UNITS] = {{ 0 }};

static bcmint_int_md_field_info_t *int_metadata_field_info[BCM_MAX_NUM_UNITS] = {NULL};

#define XGS_INT_INFO(unit) (&xgs_ltsw_int_info[unit])

/* INT vector match used bitmap. */
#define XGS_INT_VECTOR_MATCH_BMP(unit) (XGS_INT_INFO(unit)->vector_match_bmp)

/* Get INT vector match used bitmap. */
#define XGS_INT_VECTOR_MATCH_BMP_USED_GET(unit, id) \
            (SHR_BITGET(XGS_INT_VECTOR_MATCH_BMP(unit), id))

/* Set  INT vector match used bitmap. */
#define XGS_INT_VECTOR_MATCH_BMP_USED_SET(unit, id) \
            (SHR_BITSET(XGS_INT_VECTOR_MATCH_BMP(unit), id))

/* Clear  INT vector match used bitmap. */
#define XGS_INT_VECTOR_MATCH_BMP_USED_CLR(unit, id) \
            (SHR_BITCLR(XGS_INT_VECTOR_MATCH_BMP(unit), id))

/* INT vector match priority. */
#define XGS_INT_VECTOR_MATCH_PRI(unit, id) \
    (XGS_INT_INFO(unit)->vector_match_priority[id])

#define XGS_INT_VECTOR_MATCH(_u, _id) \
    xgs_ltsw_int_info[_u].vector_match[_id]

/* INT action profile type. */
#define XGS_INT_ACTION_TYPE(unit, id) \
    (XGS_INT_INFO(unit)->action_type[id])

/* INT action used bitmap. */
#define XGS_INT_ACTION_BMP(unit, type) (XGS_INT_INFO(unit)->action_bmp[type])

/* INT metadata field entry used bitmap. */
#define XGS_INT_METADATA_FIELD_BMP(unit, pid, type) \
            (XGS_INT_INFO(unit)->metadata_field_bmp[pid][type])

/* Get INT metadata field entry used bitmap. */
#define XGS_INT_METADATA_FIELD_BMP_USED_GET(unit, pid, type, id) \
            (SHR_BITGET(XGS_INT_METADATA_FIELD_BMP(unit, pid, type), id))

/* Set  INT metadata field entry used bitmap.*/
#define XGS_INT_METADATA_FIELD_BMP_USED_SET(unit, pid, type, id) \
            (SHR_BITSET(XGS_INT_METADATA_FIELD_BMP(unit, pid, type), id))

/* Clear  INT metadata field entry used bitmap.*/
#define XGS_INT_METADATA_FIELD_BMP_USED_CLR(unit, pid, type, id) \
            (SHR_BITCLR(XGS_INT_METADATA_FIELD_BMP(unit, pid, type), id))

/* INT metadata used bitmap. */
#define XGS_INT_METADATA_BMP(unit) (XGS_INT_INFO(unit)->metadata_bmp)

/* Get INT metadata used bitmap. */
#define XGS_INT_METADATA_BMP_USED_GET(unit, id) \
            (SHR_BITGET(XGS_INT_METADATA_BMP(unit), id))

/* Set  INT metadata used bitmap. */
#define XGS_INT_METADATA_BMP_USED_SET(unit, id) \
            (SHR_BITSET(XGS_INT_METADATA_BMP(unit), id))

/* Clear  INT metadata used bitmap. */
#define XGS_INT_METADATA_BMP_USED_CLR(unit, id) \
            (SHR_BITCLR(XGS_INT_METADATA_BMP(unit), id))

/*!
 * \brief Set INT-DP UDP destination port1.
 *
 * \param [in] unit Unit Number.
 * \param [in] value Value to set.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_control_intdp_l4dstport1_set(int unit, uint32_t value)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint64_t value_tmp = 0;
    int dunit, rv;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_INBAND_TELEMETRY_DATAPLANE_PARSEs,
                              &entry_hdl));

    value_tmp = 1;
    rv = bcmlt_entry_field_array_add(entry_hdl, USE_L4_DST_PORTs, 0,
                                     &value_tmp, 1);
    if (rv == SHR_E_NOT_FOUND) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    } else if (SHR_FAILURE(rv)){
        SHR_ERR_EXIT(rv);
    }

    value_tmp = value;
    rv = bcmlt_entry_field_array_add(entry_hdl, L4_DST_PORTs, 0,
                                     &value_tmp, 1);

    if (rv == SHR_E_NOT_FOUND) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    } else if (SHR_FAILURE(rv)){
        SHR_ERR_EXIT(rv);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get INT-DP UDP destination port1.
 *
 * \param [in] unit Unit Number.
 * \param [out] value Get value.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_control_intdp_l4dstport1_get(int unit, uint32_t *value)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmlt_field_def_t fld_def;
    uint64_t field_value;
    uint32_t cnt = 0;
    int dunit, rv;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_INBAND_TELEMETRY_DATAPLANE_PARSEs,
                              &entry_hdl));

    rv = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL);
    if (rv == SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_def_get(unit,
                                   MON_INBAND_TELEMETRY_DATAPLANE_PARSEs,
                                   L4_DST_PORTs,
                                   &fld_def));
        *value = fld_def.def;
        SHR_EXIT();
    }

    rv = bcmlt_entry_field_array_get(entry_hdl, USE_L4_DST_PORTs, 0,
                                     &field_value, 1, &cnt);
    if (rv == SHR_E_NOT_FOUND) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    } else if (SHR_FAILURE(rv)){
        SHR_ERR_EXIT(rv);
    }

    if(field_value) {
        rv = bcmlt_entry_field_array_get(entry_hdl, L4_DST_PORTs, 0,
                                         &field_value, 1, &cnt);
        if (rv == SHR_E_NOT_FOUND) {
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
        } else if (SHR_FAILURE(rv)){
            SHR_ERR_EXIT(rv);
        }
        *value = field_value;
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set INT-DP UDP destination port2.
 *
 * \param [in] unit Unit Number.
 * \param [in] value Value to set.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_control_intdp_l4dstport2_set(int unit, uint32_t value)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint64_t value_tmp = 0;
    int dunit, rv;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_INBAND_TELEMETRY_DATAPLANE_PARSEs,
                              &entry_hdl));

    value_tmp = 1;
    rv = bcmlt_entry_field_array_add(entry_hdl, USE_L4_DST_PORTs, 1,
                                     &value_tmp, 1);
    if (rv == SHR_E_NOT_FOUND) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    } else if (SHR_FAILURE(rv)){
        SHR_ERR_EXIT(rv);
    }

    value_tmp = value;
    rv = bcmlt_entry_field_array_add(entry_hdl, L4_DST_PORTs, 1,
                                     &value_tmp, 1);
    if (rv == SHR_E_NOT_FOUND) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    } else if (SHR_FAILURE(rv)){
        SHR_ERR_EXIT(rv);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get INT-DP UDP destination port2.
 *
 * \param [in] unit Unit Number.
 * \param [out] value Get value.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_control_intdp_l4dstport2_get(int unit, uint32_t *value)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmlt_field_def_t fld_def;
    uint64_t field_value;
    uint32_t cnt = 0;
    int dunit, rv;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_INBAND_TELEMETRY_DATAPLANE_PARSEs,
                              &entry_hdl));

    rv = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL);
    if (rv == SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_def_get(unit,
                                   MON_INBAND_TELEMETRY_DATAPLANE_PARSEs,
                                   L4_DST_PORTs,
                                   &fld_def));
        *value = fld_def.def;
        SHR_EXIT();
    }

    rv = bcmlt_entry_field_array_get(entry_hdl, USE_L4_DST_PORTs, 1,
                                     &field_value, 1, &cnt);
    if (rv == SHR_E_NOT_FOUND) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    } else if (SHR_FAILURE(rv)){
        SHR_ERR_EXIT(rv);
    }

    if(field_value) {
        rv = bcmlt_entry_field_array_get(entry_hdl, L4_DST_PORTs, 1,
                                         &field_value, 1, &cnt);
        if (rv == SHR_E_NOT_FOUND) {
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
        } else if (SHR_FAILURE(rv)){
            SHR_ERR_EXIT(rv);
        }
        *value = field_value;
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set IOAM type value.
 *
 * \param [in] unit Unit Number.
 * \param [in] value Value to set.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_control_ioam_type_set(int unit, uint32_t value)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit, rv;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_INBAND_TELEMETRY_IOAM_PARSEs,
                              &entry_hdl));

    if (value == bcmSwitchIoamTypeIncrementalTrace) {
        rv = bcmlt_entry_field_symbol_add(entry_hdl, IOAM_TYPEs,
                                          "INCREMENTAL_TRACE");
        if (rv == SHR_E_NOT_FOUND) {
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
        } else if (SHR_FAILURE(rv)){
            SHR_ERR_EXIT(rv);
        }
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get IOAM type value.
 *
 * \param [in] unit Unit Number.
 * \param [out] value Get value.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_control_ioam_type_get(int unit, uint32_t *value)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    const char* symbol = NULL;
    bcmlt_field_def_t fld_def;
    int dunit, rv;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_INBAND_TELEMETRY_IOAM_PARSEs,
                              &entry_hdl));

    rv = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL);
    if (rv == SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_def_get(unit,
                                   MON_INBAND_TELEMETRY_IOAM_PARSEs,
                                   IOAM_TYPEs,
                                   &fld_def));
        if (!sal_strcmp(fld_def.sym_def, "INCREMENTAL_TRACE")) {
            *value = bcmSwitchIoamTypeIncrementalTrace;
        } else {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        SHR_EXIT();
    }

    rv = bcmlt_entry_field_symbol_get(entry_hdl, IOAM_TYPEs, &symbol);
    if (rv == SHR_E_NOT_FOUND) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    } else if (SHR_FAILURE(rv)){
        SHR_ERR_EXIT(rv);
    }

    if (!sal_strcmp(symbol, "INCREMENTAL_TRACE")) {
        *value = bcmSwitchIoamTypeIncrementalTrace;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set vector match miss action.
 *
 * \param [in] unit Unit Number.
 * \param [in] value Value to set.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_control_vec_match_miss_set(int unit, uint32_t value)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit, rv;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_INBAND_TELEMETRY_VECTOR_MATCH_CONTROLs,
                              &entry_hdl));

    if (value == BCM_SWITCH_INT_VECTOR_MATCH_MISS_DROP) {
        rv = bcmlt_entry_field_symbol_add(entry_hdl, MISS_ACTIONs,
                                          "DROP");
        if (rv == SHR_E_NOT_FOUND) {
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
        } else if (SHR_FAILURE(rv)){
            SHR_ERR_EXIT(rv);
        }
    } else if (value == BCM_SWITCH_INT_VECTOR_MATCH_MISS_FORWARD) {
        rv = bcmlt_entry_field_symbol_add(entry_hdl, MISS_ACTIONs,
                                          "FORWARD");
        if (rv == SHR_E_NOT_FOUND) {
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
        } else if (SHR_FAILURE(rv)){
            SHR_ERR_EXIT(rv);
        }
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get vector match miss action.
 *
 * \param [in] unit Unit Number.
 * \param [out] value Get value.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_control_vec_match_miss_get(int unit, uint32_t *value)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    const char* symbol = NULL;
    bcmlt_field_def_t fld_def;
    int dunit, rv;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_INBAND_TELEMETRY_VECTOR_MATCH_CONTROLs,
                              &entry_hdl));

    rv = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL);
    if (rv == SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_def_get(unit,
                                   MON_INBAND_TELEMETRY_VECTOR_MATCH_CONTROLs,
                                   MISS_ACTIONs,
                                   &fld_def));
        if (!sal_strcmp(fld_def.sym_def, "DROP")) {
            *value = BCM_SWITCH_INT_VECTOR_MATCH_MISS_DROP;
        } else if (!sal_strcmp(fld_def.sym_def, "FORWARD")) {
            *value = BCM_SWITCH_INT_VECTOR_MATCH_MISS_FORWARD;
        } else {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        SHR_EXIT();
    }

    rv = bcmlt_entry_field_symbol_get(entry_hdl, MISS_ACTIONs, &symbol);
    if (rv == SHR_E_NOT_FOUND) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    } else if (SHR_FAILURE(rv)){
        SHR_ERR_EXIT(rv);
    }

    if (!sal_strcmp(symbol, "DROP")) {
        *value = BCM_SWITCH_INT_VECTOR_MATCH_MISS_DROP;
    } else if (!sal_strcmp(symbol, "FORWARD")) {
        *value = BCM_SWITCH_INT_VECTOR_MATCH_MISS_FORWARD;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set int controls.
 *
 * \param [in] unit Unit Number.
 * \param [in] control Enum value of the INT control.
 * \param [in] value Value to set.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_control_set(
    int unit,
    bcmi_ltsw_int_control_t control,
    uint32_t value)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit, rv;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, int_sc_info[control].ltname, &entry_hdl));

    rv = bcmlt_entry_field_add(entry_hdl, int_sc_info[control].field_str,
                               value);
    if (rv == SHR_E_NOT_FOUND) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    } else if (SHR_FAILURE(rv)){
        SHR_ERR_EXIT(rv);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief get int controls.
 *
 * \param [in] unit Unit Number.
 * \param [in] control Enum value of the INT control.
 * \param [out] value Get value.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_control_get(
    int unit,
    bcmi_ltsw_int_control_t control,
    uint32_t *value)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmlt_field_def_t fld_def;
    uint64_t field_value;
    int dunit, rv;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, int_sc_info[control].ltname, &entry_hdl));

    rv = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL);
    if (rv == SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_def_get(unit, int_sc_info[control].ltname,
                                   int_sc_info[control].field_str,
                                   &fld_def));
        *value = fld_def.def;
        SHR_EXIT();
    }

    rv = bcmlt_entry_field_get(entry_hdl, int_sc_info[control].field_str,
                               &field_value);
    if (rv == SHR_E_NOT_FOUND) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    } else if (SHR_FAILURE(rv)){
        SHR_ERR_EXIT(rv);
    }
    *value = field_value;

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Check INT vector match parameter.
 *
 * \param [in] unit Unit Number.
 * \param [in] vector_match Vector match criteria.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_vector_match_param_check(int unit,
                             bcmi_ltsw_int_vector_match_t *vector_match)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(vector_match, SHR_E_PARAM);

    if ((vector_match->type <= bcmiIntVectorMatchTypeNone) ||
        (vector_match->type >= bcmiIntVectorMatchTypeCount)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add IFA vector match table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table index.
 * \param [in] vector_match Vector match criteria.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_vector_match_ifa_table_add(
    int unit,
    int index,
    bcmi_ltsw_int_vector_match_t *vector_match)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t idx_min, idx_max;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit,
             MON_INBAND_TELEMETRY_IFA_VECTOR_MATCHs,
             MON_INBAND_TELEMETRY_IFA_VECTOR_MATCH_IDs,
             &idx_min, &idx_max));
    if ((index < idx_min) || (index > idx_max)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_NULL_CHECK(vector_match, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_INBAND_TELEMETRY_IFA_VECTOR_MATCHs,
                              &entry_hdl));

    /*  Add MON_INBAND_TELEMETRY_IFA_VECTOR_MATCH fields. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
                               MON_INBAND_TELEMETRY_IFA_VECTOR_MATCH_IDs,
                               index));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, GNSs, vector_match->base_hdr_ns_id));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, GNS_MASKs,
                               vector_match->base_hdr_ns_id_mask));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, LNSs, vector_match->md_hdr_temp_id));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, LNS_MASKs,
                               vector_match->md_hdr_temp_id_mask));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, REQUEST_VECTORs,
                               vector_match->request_vector));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, REQUEST_VECTOR_MASKs,
                               vector_match->request_vector_mask));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
                               MON_INBAND_TELEMETRY_METADATA_PROFILE_IDs,
                               vector_match->metadata_profile_id));

    /* Operation commit. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete IFA vector match table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_vector_match_ifa_table_delete(int unit, int index)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit = 0;
    uint64_t idx_min, idx_max;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit,
             MON_INBAND_TELEMETRY_IFA_VECTOR_MATCHs,
             MON_INBAND_TELEMETRY_IFA_VECTOR_MATCH_IDs,
             &idx_min, &idx_max));
    if ((index < idx_min) || (index > idx_max)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_INBAND_TELEMETRY_IFA_VECTOR_MATCHs,
                              &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
                               MON_INBAND_TELEMETRY_IFA_VECTOR_MATCH_IDs,
                               index));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl,
                              BCMLT_OPCODE_DELETE, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Add IOAM vector match table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table index.
 * \param [in] vector_match Vectoer match criteria.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_vector_match_ioam_table_add(
    int unit,
    int index,
    bcmi_ltsw_int_vector_match_t *vector_match)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t idx_min, idx_max;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit,
             MON_INBAND_TELEMETRY_IOAM_VECTOR_MATCHs,
             MON_INBAND_TELEMETRY_IOAM_VECTOR_MATCH_IDs,
             &idx_min, &idx_max));
    if ((index < idx_min) || (index > idx_max)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_NULL_CHECK(vector_match, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_INBAND_TELEMETRY_IOAM_VECTOR_MATCHs,
                              &entry_hdl));

    /*  Add MON_INBAND_TELEMETRY_IOAM_VECTOR_MATCH fields. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
                               MON_INBAND_TELEMETRY_IOAM_VECTOR_MATCH_IDs,
                               index));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, NAMESPACE_IDs,
                               vector_match->base_hdr_ns_id));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, NAMESPACE_ID_MASKs,
                               vector_match->base_hdr_ns_id_mask));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, IOAM_TRACE_TYPEs,
                               vector_match->request_vector));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, IOAM_TRACE_TYPE_MASKs,
                               vector_match->request_vector_mask));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
                               MON_INBAND_TELEMETRY_METADATA_PROFILE_IDs,
                               vector_match->metadata_profile_id));
    /* Operation commit. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete IOAM vector match table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_vector_match_ioam_table_delete(int unit, int index)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit = 0;
    uint64_t idx_min, idx_max;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit,
             MON_INBAND_TELEMETRY_IOAM_VECTOR_MATCHs,
             MON_INBAND_TELEMETRY_IOAM_VECTOR_MATCH_IDs,
             &idx_min, &idx_max));
    if ((index < idx_min) || (index > idx_max)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_INBAND_TELEMETRY_IOAM_VECTOR_MATCHs,
                              &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
                               MON_INBAND_TELEMETRY_IOAM_VECTOR_MATCH_IDs,
                               index));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl,
                              BCMLT_OPCODE_DELETE, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Add INT-DP vector match table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table index.
 * \param [in] vector_match Vector match criteria.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_vector_match_dp_table_add(
    int unit,
    int index,
    bcmi_ltsw_int_vector_match_t *vector_match)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t idx_min, idx_max;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit,
             MON_INBAND_TELEMETRY_DATAPLANE_VECTOR_MATCHs,
             MON_INBAND_TELEMETRY_DATAPLANE_VECTOR_MATCH_IDs,
             &idx_min, &idx_max));
    if ((index < idx_min) || (index > idx_max)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_NULL_CHECK(vector_match, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit,
                              MON_INBAND_TELEMETRY_DATAPLANE_VECTOR_MATCHs,
                              &entry_hdl));

    /*  Add MON_INBAND_TELEMETRY_DATAPLANE_VECTOR_MATCH fields. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
                               MON_INBAND_TELEMETRY_DATAPLANE_VECTOR_MATCH_IDs,
                               index));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, REQUEST_VECTORs,
                               vector_match->request_vector));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, REQUEST_VECTOR_MASKs,
                               vector_match->request_vector_mask));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
                               MON_INBAND_TELEMETRY_METADATA_PROFILE_IDs,
                               vector_match->metadata_profile_id));
    /* Operation commit. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete INT-DP vector match table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_vector_match_dp_table_delete(int unit, int index)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit = 0;
    uint64_t idx_min, idx_max;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit,
             MON_INBAND_TELEMETRY_DATAPLANE_VECTOR_MATCHs,
             MON_INBAND_TELEMETRY_DATAPLANE_VECTOR_MATCH_IDs,
             &idx_min, &idx_max));
    if ((index < idx_min) || (index > idx_max)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit,
                              MON_INBAND_TELEMETRY_DATAPLANE_VECTOR_MATCHs,
                              &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
                               MON_INBAND_TELEMETRY_DATAPLANE_VECTOR_MATCH_IDs,
                               index));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl,
                              BCMLT_OPCODE_DELETE, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Add vector match table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table index.
 * \param [in] vector_match Vector match criteria.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_vector_match_table_add(
    int unit,
    int index,
    bcmi_ltsw_int_vector_match_t *vector_match)
{
    SHR_FUNC_ENTER(unit);

    if (vector_match->type == bcmiIntVectorMatchTypeIfa) {
        SHR_IF_ERR_VERBOSE_EXIT
            (int_vector_match_ifa_table_add(unit, index, vector_match));
    } else if (vector_match->type == bcmiIntVectorMatchTypeIoam) {
        SHR_IF_ERR_VERBOSE_EXIT
            (int_vector_match_ioam_table_add(unit, index, vector_match));
    } else if (vector_match->type == bcmiIntVectorMatchTypeIntDp) {
        SHR_IF_ERR_VERBOSE_EXIT
            (int_vector_match_dp_table_add(unit, index, vector_match));
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    sal_memcpy(&(XGS_INT_VECTOR_MATCH(unit, index)), vector_match,
               sizeof(bcmi_ltsw_int_vector_match_t));
    XGS_INT_VECTOR_MATCH_PRI(unit, index) =
        XGS_INT_VECTOR_MATCH(unit, index).priority;
    XGS_INT_VECTOR_MATCH_BMP_USED_SET(unit, index);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete vector match table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] type Match type.
 * \param [in] index Table index.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_vector_match_table_delete(int unit, int type, int index)
{
    SHR_FUNC_ENTER(unit);

    if (type == bcmiIntVectorMatchTypeIfa) {
        SHR_IF_ERR_VERBOSE_EXIT
            (int_vector_match_ifa_table_delete(unit, index));
    } else if (type == bcmiIntVectorMatchTypeIoam) {
        SHR_IF_ERR_VERBOSE_EXIT
            (int_vector_match_ioam_table_delete(unit, index));
    } else if (type == bcmiIntVectorMatchTypeIntDp) {
        SHR_IF_ERR_VERBOSE_EXIT
            (int_vector_match_dp_table_delete(unit, index));
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    sal_memset(&(XGS_INT_VECTOR_MATCH(unit, index)), 0,
               sizeof(bcmi_ltsw_int_vector_match_t));
    XGS_INT_VECTOR_MATCH_PRI(unit, index) = 0;
    XGS_INT_VECTOR_MATCH_BMP_USED_CLR(unit, index);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get match table entry.
 *
 * \param [in] unit Unit Number.
 * \param [in] index Table index.
 * \param [out] match Match criteria.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_vector_match_table_get(int unit, int index,
                           bcmi_ltsw_int_vector_match_t *vector_match)
{
    /* Get from db directly. */
    sal_memcpy(vector_match, &(XGS_INT_VECTOR_MATCH(unit, index)),
               sizeof(bcmi_ltsw_int_vector_match_t));

    return SHR_E_NONE;
}

/*!
 * \brief Move and add INT vector match per priority.
 *
 * \param [in] unit Unit Number.
 * \param [in] id Match ID.
 * \param [in] vector_match Vector match criteria.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_vector_match_table_move_add(int unit,
                                bcmi_ltsw_int_vector_match_t *vector_match)
{
    xgs_ltsw_int_info_t *int_info = XGS_INT_INFO(unit);
    bcmi_ltsw_int_vector_match_t *vector_match_tmp;
    int i, pre_empty_id = -1;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(vector_match, SHR_E_PARAM);

    /* Shift up to find the position. */
    for (i = 0; i < int_info->vector_match_num; i++) {
        if (!XGS_INT_VECTOR_MATCH_BMP_USED_GET(unit, i)) {
            /* Mark the lastest empty entry. */
            pre_empty_id = i;
            continue;
        }

        vector_match_tmp = &(int_info->vector_match[i]);

        /* Skip the entries of other types. */
        if ((vector_match->type != vector_match_tmp->type)) {
            continue;
        }

        if (pre_empty_id != -1) {
            if (vector_match->priority > vector_match_tmp->priority) {
                /* Find the position to insert. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (int_vector_match_table_add(unit, pre_empty_id,
                                                vector_match));
                SHR_EXIT();
            } else {
                /* Shift up the entry if the last empty one is not the right position. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (int_vector_match_table_add(unit, pre_empty_id,
                                                vector_match_tmp));
                SHR_IF_ERR_VERBOSE_EXIT
                    (int_vector_match_table_delete(unit, vector_match_tmp->type,
                                                   i));
                pre_empty_id = i;
            }
        } else if (vector_match->priority > vector_match_tmp->priority) {
            /* Find the right position but there is no empty entry to shift up. */
            break;
        }
    }

    if (i >= int_info->vector_match_num) {
        if (pre_empty_id != -1) {
            /* Insert into the last empty entry. */
            SHR_IF_ERR_VERBOSE_EXIT
                (int_vector_match_table_add(unit, pre_empty_id, vector_match));
            SHR_EXIT();
        } else {
            /* No empty entry left. */
            SHR_ERR_EXIT(SHR_E_RESOURCE);
        }
    }

    /* Shift down to find the position. */
    pre_empty_id = -1;
    for (i = int_info->vector_match_num - 1; i >= 0; i--) {
        if (!XGS_INT_VECTOR_MATCH_BMP_USED_GET(unit, i)) {
            /* Mark the lastest empty entry. */
            pre_empty_id = i;
            continue;
        }

        vector_match_tmp = &(int_info->vector_match[i]);

        /* Skip the entries of other types. */
        if ((vector_match->type != vector_match_tmp->type)) {
            continue;
        }

        if (pre_empty_id != -1) {
            if (vector_match->priority <= vector_match_tmp->priority) {
                /* Find the position to insert. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (int_vector_match_table_add(unit, pre_empty_id,
                                                vector_match));
                SHR_EXIT();
            } else {
                /* Shift down the entry if the last empty one is not the right position. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (int_vector_match_table_add(unit, pre_empty_id,
                                                vector_match_tmp));
                SHR_IF_ERR_VERBOSE_EXIT
                    (int_vector_match_table_delete(unit, vector_match_tmp->type,
                                                   i));
                pre_empty_id = i;
            }
        } else if (vector_match->priority <= vector_match_tmp->priority){
            /* Find the right position but there is no empty entry to shift down. */
            SHR_ERR_EXIT(SHR_E_RESOURCE);
        }
    }

    if (i < 0) {
        if (pre_empty_id != -1) {
            /* Insert into the last empty entry. */
            SHR_IF_ERR_VERBOSE_EXIT
                (int_vector_match_table_add(unit, pre_empty_id, vector_match));
            SHR_EXIT();
        } else {
            /* No empty entry left. */
            SHR_ERR_EXIT(SHR_E_RESOURCE);
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Find a given INT vector match.
 *
 * \param [in] unit Unit Number.
 * \param [in] vector_match Vector match criteria.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_vector_match_find(int unit, bcmi_ltsw_int_vector_match_t *vector_match)
{
    xgs_ltsw_int_info_t *int_info = XGS_INT_INFO(unit);
    bcmi_ltsw_int_vector_match_t *vector_match_tmp;
    int i;

    for (i = 0; i < int_info->vector_match_num; i++) {
        if (!XGS_INT_VECTOR_MATCH_BMP_USED_GET(unit, i)) {
            continue;
        }

        vector_match_tmp = &(int_info->vector_match[i]);

        if ((vector_match->type != vector_match_tmp->type)) {
            continue;
        }

        if ((vector_match->request_vector !=
             vector_match_tmp->request_vector) ||
            (vector_match->request_vector_mask !=
             vector_match_tmp->request_vector_mask) ||
            (vector_match->md_hdr_temp_id !=
             vector_match_tmp->md_hdr_temp_id) ||
            (vector_match->md_hdr_temp_id_mask !=
             vector_match_tmp->md_hdr_temp_id_mask) ||
            (vector_match->base_hdr_ns_id !=
             vector_match_tmp->base_hdr_ns_id) ||
            (vector_match->base_hdr_ns_id_mask !=
             vector_match_tmp->base_hdr_ns_id_mask)) {
            continue;
        }

        return i;
    }

    return -1;
}

/*!
 * \brief Add a match for INT.
 *
 * \param [in] unit Unit Number.
 * \param [in] vector_match Vector match criteria.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_vector_match_add(int unit, uint32 options,
                     bcmi_ltsw_int_vector_match_t *vector_match)
{
    int id;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(vector_match, SHR_E_PARAM);

    /* Validate metadata parameter. */
    SHR_IF_ERR_VERBOSE_EXIT
        (int_vector_match_param_check(unit, vector_match));

    /* Check whether the vector match already exists. */
    id = int_vector_match_find(unit, vector_match);
    if (id != -1) {
        if (!(options & BCMI_LTSW_INT_VECTOR_MATCH_OPTIONS_REPLACE)) {
            SHR_ERR_EXIT(SHR_E_EXISTS);
        }
        if (XGS_INT_VECTOR_MATCH(unit, id).priority == vector_match->priority) {
            /* No need to change the position. */
            SHR_IF_ERR_VERBOSE_EXIT
                (int_vector_match_table_add(unit, id, vector_match));
            SHR_EXIT();
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (int_vector_match_table_move_add(unit, vector_match));

    if (id != -1) {
        SHR_IF_ERR_VERBOSE_EXIT
            (int_vector_match_table_delete(unit, vector_match->type, id));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the vector match for INT.
 *
 * \param [in] unit Unit Number.
 * \param [in] vector_match Vector matchcriteria
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
int_vector_match_get(int unit, bcmi_ltsw_int_vector_match_t *vector_match)
{
    int id;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(vector_match, SHR_E_PARAM);

    /* Validate vector match parameter. */
    SHR_IF_ERR_VERBOSE_EXIT
        (int_vector_match_param_check(unit, vector_match));

    /* Check whether the vector match exists. */
    id = int_vector_match_find(unit, vector_match);
    if (id == -1) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    /* Get INT match table entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (int_vector_match_table_get(unit, id, vector_match));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete the vector  match for INT.
 *
 * \param [in] unit Unit Number.
 * \param [in] vector_match Vector match criteria
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_vector_match_delete(int unit, bcmi_ltsw_int_vector_match_t *vector_match)
{
    int id;

    SHR_FUNC_ENTER(unit);

    /* Validate vector match parameter. */
    SHR_IF_ERR_VERBOSE_EXIT
        (int_vector_match_param_check(unit, vector_match));

    /* Check whether the match exists. */
    id = int_vector_match_find(unit, vector_match);
    if (id == -1) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    /* Delete INT vector match table entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (int_vector_match_table_delete(unit, vector_match->type, id));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete all vector matches for INT.
 *
 * \param [in] unit Unit Number.
 * \param [in] type Vector match type.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_vector_match_delete_all(int unit, bcmi_ltsw_int_vector_match_type_t type)
{
    xgs_ltsw_int_info_t *int_info = XGS_INT_INFO(unit);
    bcmi_ltsw_int_vector_match_t *vector_match_tmp;
    int i;

    SHR_FUNC_ENTER(unit);

    for (i = 0; i < int_info->vector_match_num; i++) {
        if (!XGS_INT_VECTOR_MATCH_BMP_USED_GET(unit, i)) {
            continue;
        }

        vector_match_tmp = &(int_info->vector_match[i]);

        if ((type != vector_match_tmp->type)) {
            continue;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (int_vector_match_table_delete(unit, type, i));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Traverse all vector matches for IFA.
 *
 * \param [in] unit Unit Number.
 * \param [in] trav_fn A pointer to the callback function to call for each vector match
 * \param [in] cb A pointer to the callback function to call for construct ifa info from int.
 * \param [in] user_data Pointer to user data to supply in the callback
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_vector_match_ifa_traverse(
    int unit,
    bcm_int_ifa_vector_match_traverse_cb trav_fn,
    bcmi_ltsw_int_ifa_vector_match_from_int_cb_f cb,
    void *user_data)
{
    xgs_ltsw_int_info_t *int_info = XGS_INT_INFO(unit);
    bcmi_ltsw_int_vector_match_t *vector_match_tmp;
    bcm_int_ifa_vector_match_t ifa_vector_match;
    int rv = SHR_E_NONE;
    int i;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(trav_fn, SHR_E_PARAM);
    SHR_NULL_CHECK(cb, SHR_E_PARAM);

    for (i = 0; i < int_info->vector_match_num; i++) {
        if (!XGS_INT_VECTOR_MATCH_BMP_USED_GET(unit, i)) {
            continue;
        }

        vector_match_tmp = &(int_info->vector_match[i]);

        if ((bcmiIntVectorMatchTypeIfa != vector_match_tmp->type)) {
            continue;
        }

        bcm_int_ifa_vector_match_t_init(&ifa_vector_match);
        SHR_IF_ERR_VERBOSE_EXIT(cb(unit, vector_match_tmp, &ifa_vector_match));
        rv = trav_fn(unit, &ifa_vector_match, user_data);
        if (SHR_FAILURE(rv) && bcmi_ltsw_dev_cb_err_abort(unit)) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Traverse all vector matches for IOAM.
 *
 * \param [in] unit Unit Number.
 * \param [in] trav_fn A pointer to the callback function to call for each vector match
 * \param [in] cb A pointer to the callback function to call for construct ioam info from int.
 * \param [in] user_data Pointer to user data to supply in the callback
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_vector_match_ioam_traverse(
    int unit,
    bcm_int_ioam_vector_match_traverse_cb trav_fn,
    bcmi_ltsw_int_ioam_vector_match_from_int_cb_f cb,
    void *user_data)
{
    xgs_ltsw_int_info_t *int_info = XGS_INT_INFO(unit);
    bcmi_ltsw_int_vector_match_t *vector_match_tmp;
    bcm_int_ioam_vector_match_t ioam_vector_match;
    int rv = SHR_E_NONE;
    int i;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(trav_fn, SHR_E_PARAM);
    SHR_NULL_CHECK(cb, SHR_E_PARAM);

    for (i = 0; i < int_info->vector_match_num; i++) {
        if (!XGS_INT_VECTOR_MATCH_BMP_USED_GET(unit, i)) {
            continue;
        }

        vector_match_tmp = &(int_info->vector_match[i]);

        if ((bcmiIntVectorMatchTypeIoam != vector_match_tmp->type)) {
            continue;
        }

        bcm_int_ioam_vector_match_t_init(&ioam_vector_match);
        SHR_IF_ERR_VERBOSE_EXIT(cb(unit, vector_match_tmp, &ioam_vector_match));
        rv = trav_fn(unit, &ioam_vector_match, user_data);
        if (SHR_FAILURE(rv) && bcmi_ltsw_dev_cb_err_abort(unit)) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Traverse all vector matches for INT-DP.
 *
 * \param [in] unit Unit Number.
 * \param [in] trav_fn A pointer to the callback function to call for each vector match
 * \param [in] cb A pointer to the callback function to call for construct int-dp info from int.
 * \param [in] user_data Pointer to user data to supply in the callback
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_vector_match_dp_traverse(
    int unit,
    bcm_int_dp_vector_match_traverse_cb trav_fn,
    bcmi_ltsw_int_dp_vector_match_from_int_cb_f cb,
    void *user_data)
{
    xgs_ltsw_int_info_t *int_info = XGS_INT_INFO(unit);
    bcmi_ltsw_int_vector_match_t *vector_match_tmp;
    bcm_int_dp_vector_match_t int_dp_vector_match;
    int rv = SHR_E_NONE;
    int i;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(trav_fn, SHR_E_PARAM);
    SHR_NULL_CHECK(cb, SHR_E_PARAM);

    for (i = 0; i < int_info->vector_match_num; i++) {
        if (!XGS_INT_VECTOR_MATCH_BMP_USED_GET(unit, i)) {
            continue;
        }

        vector_match_tmp = &(int_info->vector_match[i]);

        if ((bcmiIntVectorMatchTypeIntDp != vector_match_tmp->type)) {
            continue;
        }

        bcm_int_dp_vector_match_t_init(&int_dp_vector_match);
        SHR_IF_ERR_VERBOSE_EXIT(cb(unit, vector_match_tmp,
                                &int_dp_vector_match));
        rv = trav_fn(unit, &int_dp_vector_match, user_data);
        if (SHR_FAILURE(rv) && bcmi_ltsw_dev_cb_err_abort(unit)) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover vector match database.
 *
 * \param [in] unit Unit Number.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
int_vector_match_recover(int unit)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint64_t value = 0;
    int dunit, rv, idx;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_INBAND_TELEMETRY_IFA_VECTOR_MATCHs,
                              &entry_hdl));
    while ((rv = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl,
                                   MON_INBAND_TELEMETRY_IFA_VECTOR_MATCH_IDs,
                                   &value));
        idx = value;
        XGS_INT_VECTOR_MATCH(unit, idx).type = bcmiIntVectorMatchTypeIfa;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, GNSs, &value));
        XGS_INT_VECTOR_MATCH(unit, idx).base_hdr_ns_id = value;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, GNS_MASKs, &value));
        XGS_INT_VECTOR_MATCH(unit, idx).base_hdr_ns_id_mask = value;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, LNSs, &value));
        XGS_INT_VECTOR_MATCH(unit, idx).md_hdr_temp_id = value;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, LNS_MASKs, &value));
        XGS_INT_VECTOR_MATCH(unit, idx).md_hdr_temp_id_mask = value;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, REQUEST_VECTORs, &value));
        XGS_INT_VECTOR_MATCH(unit, idx).request_vector = value;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, REQUEST_VECTOR_MASKs, &value));
        XGS_INT_VECTOR_MATCH(unit, idx).request_vector_mask = value;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl,
                                   MON_INBAND_TELEMETRY_METADATA_PROFILE_IDs,
                                   &value));
        XGS_INT_VECTOR_MATCH(unit, idx).metadata_profile_id = value;

        XGS_INT_VECTOR_MATCH(unit, idx).priority =
            XGS_INT_VECTOR_MATCH_PRI(unit, idx);

        XGS_INT_VECTOR_MATCH_BMP_USED_SET(unit, idx);
    }

    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_INBAND_TELEMETRY_IOAM_VECTOR_MATCHs,
                              &entry_hdl));
    while ((rv = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl,
                                   MON_INBAND_TELEMETRY_IOAM_VECTOR_MATCH_IDs,
                                   &value));
        idx = value;
        XGS_INT_VECTOR_MATCH(unit, idx).type = bcmiIntVectorMatchTypeIoam;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, NAMESPACE_IDs, &value));
        XGS_INT_VECTOR_MATCH(unit, idx).base_hdr_ns_id = value;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, NAMESPACE_ID_MASKs, &value));
        XGS_INT_VECTOR_MATCH(unit, idx).base_hdr_ns_id_mask = value;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, IOAM_TRACE_TYPEs, &value));
        XGS_INT_VECTOR_MATCH(unit, idx).request_vector = value;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, IOAM_TRACE_TYPE_MASKs, &value));
        XGS_INT_VECTOR_MATCH(unit, idx).request_vector_mask = value;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl,
                                   MON_INBAND_TELEMETRY_METADATA_PROFILE_IDs,
                                   &value));
        XGS_INT_VECTOR_MATCH(unit, idx).metadata_profile_id = value;

        XGS_INT_VECTOR_MATCH(unit, idx).priority =
            XGS_INT_VECTOR_MATCH_PRI(unit, idx);

        XGS_INT_VECTOR_MATCH_BMP_USED_SET(unit, idx);
    }

    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit,
                              MON_INBAND_TELEMETRY_DATAPLANE_VECTOR_MATCHs,
                              &entry_hdl));
    while ((rv = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl,
                 MON_INBAND_TELEMETRY_DATAPLANE_VECTOR_MATCH_IDs,
                 &value));
        idx = value;
        XGS_INT_VECTOR_MATCH(unit, idx).type = bcmiIntVectorMatchTypeIntDp;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, REQUEST_VECTORs, &value));
        XGS_INT_VECTOR_MATCH(unit, idx).request_vector = value;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, REQUEST_VECTOR_MASKs, &value));
        XGS_INT_VECTOR_MATCH(unit, idx).request_vector_mask = value;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl,
                                   MON_INBAND_TELEMETRY_METADATA_PROFILE_IDs,
                                   &value));
        XGS_INT_VECTOR_MATCH(unit, idx).metadata_profile_id = value;

        XGS_INT_VECTOR_MATCH(unit, idx).priority =
            XGS_INT_VECTOR_MATCH_PRI(unit, idx);

        XGS_INT_VECTOR_MATCH_BMP_USED_SET(unit, idx);
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Check INT action profile parameter.
 *
 * \param [in] unit Unit Number.
 * \param [in] profile Action profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_action_profile_param_check(
    int unit,
    bcmi_ltsw_int_action_profile_t *profile)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(profile, SHR_E_PARAM);

    if ((profile->timestamp_mode < 0) ||
        (profile->timestamp_mode >= bcmIntTimestampCount)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if ((profile->residence_time_format < 0) ||
        (profile->residence_time_format >= bcmIntResidenceTimeCount) ||
        ((profile->residence_time_format == bcmIntResidenceTime32Bits) &&
        (profile->type != bcmiIntActionProfileTypeIoam))) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if ((profile->header_operation_mode < 0) ||
        (profile->header_operation_mode >= bcmIntHeaderOperationCount)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if ((profile->o_bit_update_mode < 0) ||
        (profile->o_bit_update_mode >= bcmIntIoamObitUpdateCount)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get MON_INBAND_TELEMETRY_ACTION_PROFILE entries from LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Entry index.
 * \param [out] entry Entry returned of bcmi_ltsw_int_action_profile_t type.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
int_action_profile_get(int unit, int index, void *entry)
{
    bcmi_ltsw_int_action_profile_t *action_profile = entry;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    const char* symbol = NULL;
    int dunit = 0;
    uint64_t value = 0;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(action_profile, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_INBAND_TELEMETRY_ACTION_PROFILEs,
                              &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
                               MON_INBAND_TELEMETRY_ACTION_PROFILE_IDs,
                               index));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_get(entry_hdl, TIMESTAMP_MODEs, &symbol));
    if (!sal_strcmp(symbol, "PTP")) {
        action_profile->timestamp_mode = bcmIntTimestampPtp;
    } else if (!sal_strcmp(symbol, "NTP")) {
        action_profile->timestamp_mode = bcmIntTimestampNtp;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_get(entry_hdl, RESIDENCE_TIME_FORMATs,
                                      &symbol));
    if (!sal_strcmp(symbol, "FMT_48_BITS")) {
        action_profile->residence_time_format = bcmIntResidenceTime48Bits;
    } else if (!sal_strcmp(symbol, "FMT_32_BITS")) {
        action_profile->residence_time_format = bcmIntResidenceTime32Bits;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_get(entry_hdl, METADATA_INSERT_MODEs,
                                      &symbol));
    if (!sal_strcmp(symbol, "INSERT_NONE")) {
        action_profile->header_operation_mode = bcmIntHeaderOperationNone;
    } else if (!sal_strcmp(symbol, "INSERT_METADATA_ONLY")) {
        action_profile->header_operation_mode =
            bcmIntHeaderOperationMetadataInsert;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_get(entry_hdl, O_BIT_UPDATE_MODEs,
                                      &symbol));
    if (!sal_strcmp(symbol, "SKIP_UPDATE")) {
        action_profile->o_bit_update_mode = bcmIntIoamObitUpdateSkip;
    } else if (!sal_strcmp(symbol, "SET_IF_OVERFLOW")) {
        action_profile->o_bit_update_mode = bcmIntIoamObitUpdateOverflow;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, UPDATE_IP_LENGTHs, &value));
    if (value) {
        action_profile->flags |=
            BCMI_LTSW_INT_ACTION_PROFILE_FLAGS_IP_LENGTH_UPDATE;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, UPDATE_UDP_LENGTHs, &value));
    if (value) {
        action_profile->flags |=
            BCMI_LTSW_INT_ACTION_PROFILE_FLAGS_UDP_LENGTH_UPDATE;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl,
                               MON_INBAND_TELEMETRY_METADATA_PROFILE_IDs,
                               &value));
    action_profile->metadata_profile_id = value;

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Insert MON_INBAND_TELEMETRY_ACTION_PROFILE entries into LT.
 *
 * \param [in] unit Unit number.
 * \param [in] flags Operation flags, BCMI_LTSW_IDX_TBL_OP_xxx.
 * \param [in] index Entry index.
 * \param [in] entry Entry content of bcmi_ltsw_int_action_profile_t type.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
int_action_profile_insert(int unit, uint32_t flags, int index, void *entry)
{
    bcmi_ltsw_int_action_profile_t *action_profile = entry;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t value = 0;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(action_profile, SHR_E_PARAM);

    /* Validate action parameter. */
    SHR_IF_ERR_VERBOSE_EXIT
        (int_action_profile_param_check(unit, action_profile));

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_INBAND_TELEMETRY_ACTION_PROFILEs,
                              &entry_hdl));

    /*  Add MON_INBAND_TELEMETRY_ACTION_PROFILE fields. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
                               MON_INBAND_TELEMETRY_ACTION_PROFILE_IDs,
                               index));

    if (action_profile->timestamp_mode == bcmIntTimestampPtp) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, TIMESTAMP_MODEs, "PTP"));
    } else if (action_profile->timestamp_mode == bcmIntTimestampNtp) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, TIMESTAMP_MODEs, "NTP"));
    }

    if (action_profile->residence_time_format == bcmIntResidenceTime48Bits) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, RESIDENCE_TIME_FORMATs,
                                          "FMT_48_BITS"));
    } else if (action_profile->residence_time_format == bcmIntResidenceTime32Bits){
        /* Only supported by IOAM. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, RESIDENCE_TIME_FORMATs,
                                          "FMT_32_BITS"));
    }

    if (action_profile->header_operation_mode == bcmIntHeaderOperationNone) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, METADATA_INSERT_MODEs,
                                          "INSERT_NONE"));
    } else if (action_profile->header_operation_mode == bcmIntHeaderOperationMetadataInsert) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, METADATA_INSERT_MODEs,
                                          "INSERT_METADATA_ONLY"));
    }

    /* Only supported by IOAM. */
    if (action_profile->o_bit_update_mode == bcmIntIoamObitUpdateSkip) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, O_BIT_UPDATE_MODEs,
                                          "SKIP_UPDATE"));
    } else if (action_profile->o_bit_update_mode ==
               bcmIntIoamObitUpdateOverflow) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, O_BIT_UPDATE_MODEs,
                                          "SET_IF_OVERFLOW"));
    }

    value = (action_profile->flags &
             BCMI_LTSW_INT_ACTION_PROFILE_FLAGS_IP_LENGTH_UPDATE) ? 1 : 0;
    SHR_IF_ERR_VERBOSE_EXIT
       (bcmlt_entry_field_add(entry_hdl, UPDATE_IP_LENGTHs, value));

    /* Only supported by INT-DP */
    value = (action_profile->flags &
             BCMI_LTSW_INT_ACTION_PROFILE_FLAGS_UDP_LENGTH_UPDATE) ? 1 : 0;
    SHR_IF_ERR_VERBOSE_EXIT
       (bcmlt_entry_field_add(entry_hdl, UPDATE_UDP_LENGTHs, value));

    if (action_profile->metadata_profile_id != 0) {
        SHR_IF_ERR_VERBOSE_EXIT
           (bcmlt_entry_field_add(entry_hdl, USE_METADATA_PROFILEs, 1));
        SHR_IF_ERR_VERBOSE_EXIT
           (bcmlt_entry_field_add(entry_hdl,
                                  MON_INBAND_TELEMETRY_METADATA_PROFILE_IDs,
                                  action_profile->metadata_profile_id));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
           (bcmlt_entry_field_add(entry_hdl, USE_METADATA_PROFILEs, 0));
        SHR_IF_ERR_VERBOSE_EXIT
           (bcmlt_entry_field_add(entry_hdl,
                                  MON_INBAND_TELEMETRY_METADATA_PROFILE_IDs,
                                  0));
    }

    /* Operation commit. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete MON_INBAND_TELEMETRY_ACTION_PROFILE entries from LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Entry index.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
int_action_profile_del(int unit, int index)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_INBAND_TELEMETRY_ACTION_PROFILEs,
                              &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
                               MON_INBAND_TELEMETRY_ACTION_PROFILE_IDs,
                               index));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl,
                              BCMLT_OPCODE_DELETE, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Traverse all action profiles for IFA.
 *
 * \param [in] unit Unit number.
 * \param [in] trav_fn A pointer to the callback function to call for each action profile.
 * \param [in] cb A pointer to the callback function to call for construct ifa info from int.
 * \param [in] user_data Pointer to user data to supply in the callback.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
int_action_profile_ifa_traverse(
    int unit,
    bcm_int_ifa_action_profile_traverse_cb trav_fn,
    bcmi_ltsw_int_ifa_action_profile_from_int_cb_f cb,
    void *user_data)
{
    bcmi_ltsw_int_action_profile_t action_profile_tmp;
    bcm_int_ifa_action_profile_t ifa_action_profile;
    int rv = SHR_E_NONE;
    uint64_t idx_min, idx_max;
    int idx;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(trav_fn, SHR_E_PARAM);
    SHR_NULL_CHECK(cb, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit,
                                       MON_INBAND_TELEMETRY_ACTION_PROFILEs,
                                       MON_INBAND_TELEMETRY_ACTION_PROFILE_IDs,
                                       &idx_min, &idx_max));

    for (idx = idx_min; idx <= idx_max; idx++) {
        if (bcmi_ltsw_idx_tbl_entry_get_by_idx(unit,
            BCMI_LTSW_IDX_TBL_OP_SKIP_INDEX_ZERO,
            BCMI_LTSW_IDX_TBL_ID_INT_ACTION_PROFILE,
            BCMI_INT_ACTION_PROFILE_USER_ID_IFA,
            NULL, idx)) {
            continue;
        }

        sal_memset(&action_profile_tmp, 0,
                   sizeof(bcmi_ltsw_int_action_profile_t));
        rv = int_action_profile_get(unit, idx, &action_profile_tmp);
        if (SHR_FAILURE(rv)) {
            if (rv != SHR_E_NOT_FOUND) {
                break;
            }
            continue;
        }
        bcm_int_ifa_action_profile_t_init(&ifa_action_profile);
        SHR_IF_ERR_VERBOSE_EXIT(cb(unit, &action_profile_tmp,
                                &ifa_action_profile));
        rv = trav_fn(unit, &idx, &ifa_action_profile, user_data);
        if (SHR_FAILURE(rv) && bcmi_ltsw_dev_cb_err_abort(unit)) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Traverse all action profiles for IOAM.
 *
 * \param [in] unit Unit number.
 * \param [in] trav_fn A pointer to the callback function to call for each action profile.
 * \param [in] cb A pointer to the callback function to call for construct ioam info from int.
 * \param [in] user_data Pointer to user data to supply in the callback.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
int_action_profile_ioam_traverse(
    int unit,
    bcm_int_ioam_action_profile_traverse_cb trav_fn,
    bcmi_ltsw_int_ioam_action_profile_from_int_cb_f cb,
    void *user_data)
{
    bcmi_ltsw_int_action_profile_t action_profile_tmp;
    bcm_int_ioam_action_profile_t ioam_action_profile;
    int rv = SHR_E_NONE;
    uint64_t idx_min, idx_max;
    int idx;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(trav_fn, SHR_E_PARAM);
    SHR_NULL_CHECK(cb, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit,
                                       MON_INBAND_TELEMETRY_ACTION_PROFILEs,
                                       MON_INBAND_TELEMETRY_ACTION_PROFILE_IDs,
                                       &idx_min, &idx_max));

    for (idx = idx_min; idx <= idx_max; idx++) {
        if (bcmi_ltsw_idx_tbl_entry_get_by_idx(unit,
            BCMI_LTSW_IDX_TBL_OP_SKIP_INDEX_ZERO,
            BCMI_LTSW_IDX_TBL_ID_INT_ACTION_PROFILE,
            BCMI_INT_ACTION_PROFILE_USER_ID_IOAM,
            NULL, idx)) {
            continue;
        }

        sal_memset(&action_profile_tmp, 0,
                   sizeof(bcmi_ltsw_int_action_profile_t));
        rv = int_action_profile_get(unit, idx, &action_profile_tmp);
        if (SHR_FAILURE(rv)) {
            if (rv != SHR_E_NOT_FOUND) {
                break;
            }
            continue;
        }
        bcm_int_ioam_action_profile_t_init(&ioam_action_profile);
        SHR_IF_ERR_VERBOSE_EXIT(cb(unit, &action_profile_tmp,
                                &ioam_action_profile));
        rv = trav_fn(unit, &idx, &ioam_action_profile, user_data);
        if (SHR_FAILURE(rv) && bcmi_ltsw_dev_cb_err_abort(unit)) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Traverse all action profiles for INT-DP.
 *
 * \param [in] unit Unit number.
 * \param [in] trav_fn A pointer to the callback function to call for each action profile.
 * \param [in] cb A pointer to the callback function to call for construct int-dp info from int.
 * \param [in] user_data Pointer to user data to supply in the callback.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
int_action_profile_dp_traverse(
    int unit,
    bcm_int_dp_action_profile_traverse_cb trav_fn,
    bcmi_ltsw_int_dp_action_profile_from_int_cb_f cb,
    void *user_data)
{
    bcmi_ltsw_int_action_profile_t action_profile_tmp;
    bcm_int_dp_action_profile_t int_dp_action_profile;
    int rv = SHR_E_NONE;
    uint64_t idx_min, idx_max;
    int idx;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(trav_fn, SHR_E_PARAM);
    SHR_NULL_CHECK(cb, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit,
                                       MON_INBAND_TELEMETRY_ACTION_PROFILEs,
                                       MON_INBAND_TELEMETRY_ACTION_PROFILE_IDs,
                                       &idx_min, &idx_max));

    for (idx = idx_min; idx <= idx_max; idx++) {
        if (bcmi_ltsw_idx_tbl_entry_get_by_idx(unit,
            BCMI_LTSW_IDX_TBL_OP_SKIP_INDEX_ZERO,
            BCMI_LTSW_IDX_TBL_ID_INT_ACTION_PROFILE,
            BCMI_INT_ACTION_PROFILE_USER_ID_INT_DP,
            NULL, idx)) {
            continue;
        }

        sal_memset(&action_profile_tmp, 0,
                   sizeof(bcmi_ltsw_int_action_profile_t));
        rv = int_action_profile_get(unit, idx, &action_profile_tmp);
        if (SHR_FAILURE(rv)) {
            if (rv != SHR_E_NOT_FOUND) {
                break;
            }
            continue;
        }
        bcm_int_dp_action_profile_t_init(&int_dp_action_profile);
        SHR_IF_ERR_VERBOSE_EXIT(cb(unit, &action_profile_tmp,
                                &int_dp_action_profile));
        rv = trav_fn(unit, &idx, &int_dp_action_profile, user_data);
        if (SHR_FAILURE(rv) && bcmi_ltsw_dev_cb_err_abort(unit)) {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILE entries from LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Entry index.
 * \param [out] entry Entry returned of bcm_int_opaque_data_profile_t type.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
int_opaque_data_profile_get(int unit, int index, void *entry)
{
    bcm_int_opaque_data_profile_t *profile = entry;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit = 0, i;
    uint64_t value[XGS_MAX_OPAQUE_DATA_NUM] = {0};
    uint32_t cnt = 0;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(profile, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILEs,
                              &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
                               MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILE_IDs,
                               index));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_get(entry_hdl, OPAQUE_DATAs, 0,
                                     value, XGS_MAX_OPAQUE_DATA_NUM, &cnt));

    for (i = 0; i < cnt; i++) {
        profile->opaque_data[i] = value[i];
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Insert MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILE entries into LT.
 *
 * \param [in] unit Unit number.
 * \param [in] flags Operation flags, BCMI_LTSW_IDX_TBL_OP_xxx.
 * \param [in] index Entry index.
 * \param [in] entry Entry content of bcm_int_opaque_data_profile_t type.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
int_opaque_data_profile_insert(
    int unit,
    uint32_t flags,
    int index,
    void *entry)
{
    bcm_int_opaque_data_profile_t *profile = entry;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit, i;
    uint64_t value[XGS_MAX_OPAQUE_DATA_NUM] = {0};

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(profile, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILEs,
                              &entry_hdl));

    /*  Add MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILE fields. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
                               MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILE_IDs,
                               index));

    for (i = 0; i < XGS_MAX_OPAQUE_DATA_NUM; i++) {
        value[i] = profile->opaque_data[i];
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_add(entry_hdl, OPAQUE_DATAs, 0,
                                     value, XGS_MAX_OPAQUE_DATA_NUM));

    /* Operation commit. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILE entries from LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Entry index.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
int_opaque_data_profile_del(int unit, int index)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILEs,
                              &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
                               MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILE_IDs,
                               index));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl,
                              BCMLT_OPCODE_DELETE, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Traverse all opaque data profiles INT metadata construction.
 *
 * \param [in] unit Unit number.
 * \param [in] cb A pointer to the callback function to call for each opaque data profile.
 * \param [in] user_data Pointer to user data to supply in the callback.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
int_opaque_data_profile_traverse(
    int unit,
    bcm_int_opaque_data_profile_traverse_cb cb,
    void *user_data)
{
    bcm_int_opaque_data_profile_t profile;
    int idx, rv = SHR_E_NONE;
    uint64_t idx_min, idx_max;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(cb, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit,
             MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILEs,
             MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILE_IDs,
             &idx_min, &idx_max));

    for (idx = idx_min; idx <= idx_max; idx++) {
        if (bcmi_ltsw_idx_tbl_entry_get_by_idx(unit,
            BCMI_LTSW_IDX_TBL_OP_SKIP_INDEX_ZERO,
            BCMI_LTSW_IDX_TBL_ID_INT_OPAQUE_DATA_PROFILE,
            BCMI_INT_OPAQUE_DATA_PROFILE_USER_ID_INT,
            NULL, idx)) {
            continue;
        }

        bcm_int_opaque_data_profile_t_init(&profile);
        rv = int_opaque_data_profile_get(unit, idx, &profile);
        if (SHR_FAILURE(rv)) {
            if (rv != SHR_E_NOT_FOUND) {
                break;
            }
            continue;
        }
        if (cb) {
            rv = (*cb) (unit, &idx, &profile, user_data);
            if (SHR_FAILURE(rv) && bcmi_ltsw_dev_cb_err_abort(unit)) {
                break;
            }
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Check INT cosq config parameter.
 *
 * \param [in] unit Unit Number.
 * \param [in] profile Action profile.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_cosq_stat_config_check(
    int unit,
    bcm_int_cosq_stat_config_t *config)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(config, SHR_E_PARAM);

    if ((config->report_mode < 0) ||
        (config->report_mode >= bcmIntCosqStatReportCount)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Insert MON_INBAND_TELEMETRY_TM_STATS_CONTROL entries into LT.
 *
 * \param [in] unit Unit Number
 * \param [in] config Cosq stat configurations.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
int_cosq_stat_config_set(
    int unit,
    bcm_int_cosq_stat_config_t *config)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit = 0, cells = 0;

    SHR_FUNC_ENTER(unit);

    /* Validate action parameter. */
    SHR_IF_ERR_VERBOSE_EXIT
        (int_cosq_stat_config_check(unit, config));

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_INBAND_TELEMETRY_TM_STATS_CONTROLs,
                              &entry_hdl));

    /*  Add MON_INBAND_TELEMETRY_TM_STATS_CONTROL fields. */
    if (config->report_mode == bcmIntCosqStatReportQueueBased) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, USAGE_CELLSs,
                                          "QUEUE_BASED"));
    } else if (config->report_mode == bcmIntCosqStatReportPortBased) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, USAGE_CELLSs,
                                          "PORT_BASED"));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, USE_MAX_USAGE_CELLSs,
                               config->max_bytes_enable ? 1 : 0));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_thd_byte_to_cell(unit, config->max_bytes, &cells));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, MAX_USAGE_CELLSs, cells));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_thd_byte_to_cell(unit, config->current_bytes, &cells));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, CURRENT_USAGE_CELLSs, cells));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_thd_byte_to_cell(unit, config->current_available_bytes,
                                         &cells));
    SHR_IF_ERR_VERBOSE_EXIT
         (bcmlt_entry_field_add(entry_hdl, CURRENT_AVAILABLE_CELLSs, cells));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_thd_byte_to_cell(unit, config->min_available_bytes,
                                         &cells));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, MIN_AVAILABLE_CELLSs, cells));

    /* Operation commit. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Insert MON_INBAND_TELEMETRY_TM_STATS_CONTROL entries into LT.
 *
 * \param [in] unit Unit Number
 * \param [out] config Cosq stat configurations.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
int_cosq_stat_config_get(
    int unit,
    bcm_int_cosq_stat_config_t *config)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    const char *lt_name = MON_INBAND_TELEMETRY_TM_STATS_CONTROLs;
    bcmlt_field_def_t fld_def;
    const char* symbol = NULL;
    int dunit = 0, rv, bytes = 0;
    uint64_t value = 0;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(config, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, lt_name, &entry_hdl));

    rv = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL);

    if (rv == SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_def_get(unit, lt_name, USAGE_CELLSs, &fld_def));
        if (!sal_strcmp(fld_def.sym_def, "QUEUE_BASED")) {
            config->report_mode = bcmIntCosqStatReportQueueBased;
        } else if (!sal_strcmp(fld_def.sym_def, "PORT_BASED")) {
            config->report_mode = bcmIntCosqStatReportPortBased;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_def_get(unit, lt_name, USE_MAX_USAGE_CELLSs,
                                   &fld_def));
        config->max_bytes_enable = fld_def.def;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_def_get(unit, lt_name, MAX_USAGE_CELLSs,
                                   &fld_def));
        SHR_IF_ERR_VERBOSE_EXIT
           (bcmi_ltsw_cosq_thd_cell_to_byte(unit, fld_def.def, &bytes));
        config->max_bytes = bytes;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_def_get(unit, lt_name, CURRENT_USAGE_CELLSs,
                                   &fld_def));
        SHR_IF_ERR_VERBOSE_EXIT
           (bcmi_ltsw_cosq_thd_cell_to_byte(unit, fld_def.def, &bytes));
        config->current_bytes = bytes;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_def_get(unit, lt_name, CURRENT_AVAILABLE_CELLSs,
                                   &fld_def));
        SHR_IF_ERR_VERBOSE_EXIT
           (bcmi_ltsw_cosq_thd_cell_to_byte(unit, fld_def.def, &bytes));
        config->current_available_bytes = bytes;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_def_get(unit, lt_name, MIN_AVAILABLE_CELLSs,
                                   &fld_def));
        SHR_IF_ERR_VERBOSE_EXIT
           (bcmi_ltsw_cosq_thd_cell_to_byte(unit, fld_def.def, &bytes));
        config->min_available_bytes = bytes;

        SHR_EXIT();
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_get(entry_hdl, USAGE_CELLSs, &symbol));
    if (!sal_strcmp(symbol, "QUEUE_BASED")) {
        config->report_mode = bcmIntCosqStatReportQueueBased;
    } else if (!sal_strcmp(symbol, "PORT_BASED")) {
        config->report_mode = bcmIntCosqStatReportPortBased;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, USE_MAX_USAGE_CELLSs, &value));
    config->max_bytes_enable = value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, MAX_USAGE_CELLSs, &value));
    SHR_IF_ERR_VERBOSE_EXIT
       (bcmi_ltsw_cosq_thd_cell_to_byte(unit, value, &bytes));
    config->max_bytes = bytes;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, CURRENT_USAGE_CELLSs, &value));
    SHR_IF_ERR_VERBOSE_EXIT
       (bcmi_ltsw_cosq_thd_cell_to_byte(unit, value, &bytes));
    config->current_bytes = bytes;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, CURRENT_AVAILABLE_CELLSs, &value));
    SHR_IF_ERR_VERBOSE_EXIT
       (bcmi_ltsw_cosq_thd_cell_to_byte(unit, value, &bytes));
    config->current_available_bytes = bytes;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, MIN_AVAILABLE_CELLSs, &value));
    SHR_IF_ERR_VERBOSE_EXIT
       (bcmi_ltsw_cosq_thd_cell_to_byte(unit, value, &bytes));
    config->min_available_bytes = bytes;

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get MON_INBAND_TELEMETRY_METADATA_PROFILE entries from LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Entry index.
 * \param [out] entry Entry returned of int_metadata_profile_t type.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
int_md_attr_profile_get(int unit, int index, void *entry)
{
    int_metadata_profile_t *profile = entry;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit = 0;
    uint64_t value = 0;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(profile, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_INBAND_TELEMETRY_METADATA_PROFILEs,
                              &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
                               MON_INBAND_TELEMETRY_METADATA_PROFILE_IDs,
                               index));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl,
                               MON_INBAND_TELEMETRY_METADATA_SELECT_PROFILE_IDs,
                               &value));
    profile->select_profile_id = value;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl,
                               MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_PROFILE_IDs,
                               &value));
    profile->construct_profile_id = value;

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Insert MON_INBAND_TELEMETRY_METADATA_PROFILE entries into LT.
 *
 * \param [in] unit Unit number.
 * \param [in] flags Operation flags, BCMI_LTSW_IDX_TBL_OP_xxx.
 * \param [in] index Entry index.
 * \param [in] entry Entry content of int_metadata_profile_t type.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
int_md_attr_profile_insert(
    int unit,
    uint32_t flags,
    int index,
    void *entry)
{
    int_metadata_profile_t *profile = entry;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(profile, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_INBAND_TELEMETRY_METADATA_PROFILEs,
                              &entry_hdl));

    /*  Add MON_INBAND_TELEMETRY_METADATA_PROFILE fields. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
                               MON_INBAND_TELEMETRY_METADATA_PROFILE_IDs,
                               index));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
                               MON_INBAND_TELEMETRY_METADATA_SELECT_PROFILE_IDs,
                               profile->select_profile_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
             MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_PROFILE_IDs,
             profile->construct_profile_id));
    /* Operation commit. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete MON_INBAND_TELEMETRY_METADATA_PROFILE entries from LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Entry index.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
int_md_attr_profile_del(int unit, int index)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_INBAND_TELEMETRY_METADATA_PROFILEs,
                              &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
                               MON_INBAND_TELEMETRY_METADATA_PROFILE_IDs,
                               index));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl,
                              BCMLT_OPCODE_DELETE, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get MON_INBAND_TELEMETRY_METADATA_SELECT_NARROW_PROFILE
 *            entries from LT.
 *
 * \param [in] unit Unit number.
 * \param [in] profile_id Metadata select profile ID.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
int_md_sel_narrow_profile_create(
    int unit,
    int profile_id)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit = 0, count = INT_MAX_METADATA_FIELD_NARROW_NUM;
    uint64_t value[INT_MAX_METADATA_FIELD_NARROW_NUM] = {0};

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit,
         MON_INBAND_TELEMETRY_METADATA_SELECT_NARROW_PROFILEs, &entry_hdl));

    /*  Add MON_INBAND_TELEMETRY_METADATA_SELECT_NARROW_PROFILE fields. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
         MON_INBAND_TELEMETRY_METADATA_SELECT_PROFILE_IDs, profile_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_add(entry_hdl, CHUNK_INDEXs, 0,
                                     value, count));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_add(entry_hdl, STARTs, 0,
                                     value, count));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_add(entry_hdl, SIZEs, 0,
                                     value, count));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_add(entry_hdl, SHIFTs, 0,
                                     value, count));

    /* Operation commit. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get MON_INBAND_TELEMETRY_METADATA_SELECT_NARROW_PROFILE
 *            entries from LT.
 *
 * \param [in] unit Unit number.
 * \param [in] profile_id Metadata select profile ID.
 * \param [out] profile returned of bcmi_ltsw_int_metadata_select_profile_t type.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
int_md_sel_narrow_profile_get(
    int unit,
    int profile_id,
    int_metadata_select_profile_t *profile)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit = 0, i;
    uint64_t value = 0;
    uint32_t cnt = 0;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(profile, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit,
             MON_INBAND_TELEMETRY_METADATA_SELECT_NARROW_PROFILEs,
             &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
             MON_INBAND_TELEMETRY_METADATA_SELECT_PROFILE_IDs,
             profile_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    for (i = 0; i < INT_MAX_METADATA_FIELD_NARROW_NUM; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_get(entry_hdl, CHUNK_INDEXs, i,
                                         &value, 1, &cnt));
        profile->field[i].chunk_index = value;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_get(entry_hdl, STARTs, i,
                                         &value, 1, &cnt));
        profile->field[i].start = value;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_get(entry_hdl, SIZEs, i,
                                         &value, 1, &cnt));
        profile->field[i].size = value;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_get(entry_hdl, SHIFTs, i,
                                         &value, 1, &cnt));
        profile->field[i].shift = value;
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set MON_INBAND_TELEMETRY_METADATA_SELECT_NARROW_PROFILE
 *            entries into LT.
 *
 * \param [in] unit Unit number.
 * \param [in] profile_id Metadata select profile ID.
 * \param [out] profile returned of bcmi_ltsw_int_metadata_select_profile_t type.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
int_md_sel_narrow_profile_set(
    int unit,
    int profile_id,
    int field_entry_id,
    int_metadata_select_field_entry_t *field_entry)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit = 0;
    uint64_t value = 0;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(field_entry, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit,
             MON_INBAND_TELEMETRY_METADATA_SELECT_NARROW_PROFILEs,
             &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
             MON_INBAND_TELEMETRY_METADATA_SELECT_PROFILE_IDs,
             profile_id));

    value = field_entry->chunk_index;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_add(entry_hdl, CHUNK_INDEXs, field_entry_id,
                                     &value, 1));

    value = field_entry->start;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_add(entry_hdl, STARTs, field_entry_id,
                                     &value, 1));

    value = field_entry->size;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_add(entry_hdl, SIZEs, field_entry_id,
                                     &value, 1));

    value = field_entry->shift;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_add(entry_hdl, SHIFTs, field_entry_id,
                                     &value, 1));

    /* Operation commit. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete MON_INBAND_TELEMETRY_METADATA_SELECT_NARROW_PROFILE
 *            entries from LT.
 *
 * \param [in] unit Unit number.
 * \param [in] profile_id Metadata select profile ID.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
int_md_sel_narrow_profile_delete(
    int unit,
    int profile_id)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit,
             MON_INBAND_TELEMETRY_METADATA_SELECT_NARROW_PROFILEs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
             MON_INBAND_TELEMETRY_METADATA_SELECT_PROFILE_IDs,
             profile_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl,
                              BCMLT_OPCODE_DELETE, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Get MON_INBAND_TELEMETRY_METADATA_SELECT_WIDE_PROFILE
 *            entries from LT.
 *
 * \param [in] unit Unit number.
 * \param [in] profile_id Metadata select profile ID.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
int_md_sel_wide_profile_create(
    int unit,
    int profile_id)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit, count = INT_MAX_METADATA_FIELD_WIDE_NUM;
    uint64_t value[INT_MAX_METADATA_FIELD_WIDE_NUM] = {0};

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit,
         MON_INBAND_TELEMETRY_METADATA_SELECT_WIDE_PROFILEs, &entry_hdl));

    /*  Add MON_INBAND_TELEMETRY_METADATA_SELECT_WIDE_PROFILE fields. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
         MON_INBAND_TELEMETRY_METADATA_SELECT_PROFILE_IDs, profile_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_add(entry_hdl, CHUNK_INDEXs, 0,
                                     value, count));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_add(entry_hdl, STARTs, 0,
                                     value, count));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_add(entry_hdl, SIZEs, 0,
                                     value, count));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_add(entry_hdl, SHIFTs, 0,
                                     value, count));

    /* Operation commit. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get MON_INBAND_TELEMETRY_METADATA_SELECT_WIDE_PROFILE
 *            entries from LT.
 *
 * \param [in] unit Unit number.
 * \param [in] profile_id Metadata select profile ID.
 * \param [out] profile returned of bcmi_ltsw_int_metadata_select_profile_t type.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
int_md_sel_wide_profile_get(
    int unit,
    int profile_id,
    int_metadata_select_profile_t *profile)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit = 0, i;
    uint64_t value = 0;
    uint32_t cnt = 0;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(profile, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit,
             MON_INBAND_TELEMETRY_METADATA_SELECT_WIDE_PROFILEs,
             &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
             MON_INBAND_TELEMETRY_METADATA_SELECT_PROFILE_IDs,
             profile_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    for (i = 0; i < INT_MAX_METADATA_FIELD_WIDE_NUM; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_get(entry_hdl, CHUNK_INDEXs, i,
                                         &value, 1, &cnt));
        profile->field[i].chunk_index = value;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_get(entry_hdl, STARTs, i,
                                         &value, 1, &cnt));
        profile->field[i].start = value;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_get(entry_hdl, SIZEs, i,
                                         &value, 1, &cnt));
        profile->field[i].size = value;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_get(entry_hdl, SHIFTs, i,
                                         &value, 1, &cnt));
        profile->field[i].shift = value;
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set MON_INBAND_TELEMETRY_METADATA_SELECT_WIDE_PROFILE
 *            entries into LT.
 *
 * \param [in] unit Unit number.
 * \param [in] profile_id Metadata select profile ID.
 * \param [out] profile returned of bcmi_ltsw_int_metadata_select_profile_t type.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
int_md_sel_wide_profile_set(
    int unit,
    int profile_id,
    int field_entry_id,
    int_metadata_select_field_entry_t *field_entry)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit = 0;
    uint64_t value = 0;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(field_entry, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit,
             MON_INBAND_TELEMETRY_METADATA_SELECT_WIDE_PROFILEs,
             &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
             MON_INBAND_TELEMETRY_METADATA_SELECT_PROFILE_IDs,
             profile_id));

    value = field_entry->chunk_index;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_add(entry_hdl, CHUNK_INDEXs, field_entry_id,
                                     &value, 1));

    value = field_entry->start;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_add(entry_hdl, STARTs, field_entry_id,
                                     &value, 1));

    value = field_entry->size;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_add(entry_hdl, SIZEs, field_entry_id,
                                     &value, 1));

    value = field_entry->shift;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_add(entry_hdl, SHIFTs, field_entry_id,
                                     &value, 1));

    /* Operation commit. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete MON_INBAND_TELEMETRY_METADATA_SELECT_WIDE_PROFILE
 *            entries from LT.
 *
 * \param [in] unit Unit number.
 * \param [in] profile_id Metadata select profile ID.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
int_md_sel_wide_profile_delete(
    int unit,
    int profile_id)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit,
             MON_INBAND_TELEMETRY_METADATA_SELECT_WIDE_PROFILEs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
             MON_INBAND_TELEMETRY_METADATA_SELECT_PROFILE_IDs,
             profile_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl,
                              BCMLT_OPCODE_DELETE, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Insert MON_INBAND_TELEMETRY_METADATA_SELECT_NARROW_PROFILE &
 *            MON_INBAND_TELEMETRY_METADATA_SELECT_WIDE_PROFILE
 *            entries into LT.
 *
 * \param [in] unit Unit number.
 * \param [in] flags Operation flags, BCMI_LTSW_IDX_TBL_OP_xxx.
 * \param [in] index Entry index.
 * \param [in] entry NULL.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
int_md_sel_profile_insert(
    int unit,
    uint32_t flags,
    int index,
    void *entry)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (int_md_sel_narrow_profile_create(unit, index));

    SHR_IF_ERR_VERBOSE_EXIT
        (int_md_sel_wide_profile_create(unit, index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete MON_INBAND_TELEMETRY_METADATA_SELECT_NARROW_PROFILE &
 *            MON_INBAND_TELEMETRY_METADATA_SELECT_WIDE_PROFILE
 *            entries from LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Entry index.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
int_md_sel_profile_delete(
    int unit,
    int index)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (int_md_sel_narrow_profile_delete(unit, index));

    SHR_IF_ERR_VERBOSE_EXIT
        (int_md_sel_wide_profile_delete(unit, index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_NARROW_PROFILE
 *            entries from LT.
 *
 * \param [in] unit Unit number.
 * \param [in] profile_id Metadata construct profile ID.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
int_md_const_narrow_profile_create(
    int unit,
    int profile_id)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit, count = INT_MAX_METADATA_FIELD_NARROW_NUM;
    uint64_t value[INT_MAX_METADATA_FIELD_NARROW_NUM] = {0};

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit,
         MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_NARROW_PROFILEs, &entry_hdl));

    /*  Add MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_NARROW_PROFILE fields. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
         MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_PROFILE_IDs, profile_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_add(entry_hdl, ENABLEs, 0,
                                     value, count));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_add(entry_hdl, OFFSETs, 0,
                                     value, count));

    /* Operation commit. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_NARROW_PROFILE
 *            entries from LT.
 *
 * \param [in] unit Unit number.
 * \param [in] profile_id Metadata construct profile ID.
 * \param [out] profile returned of bcmi_ltsw_int_metadata_construct_profile_t type.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
int_md_const_narrow_profile_get(
    int unit,
    int profile_id,
    int_metadata_construct_profile_t *profile)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit = 0, i;
    uint64_t value = 0;
    uint32_t cnt = 0;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(profile, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit,
             MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_NARROW_PROFILEs,
             &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
             MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_PROFILE_IDs,
             profile_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    for (i = 0; i < INT_MAX_METADATA_FIELD_NARROW_NUM; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_get(entry_hdl, OFFSETs, i,
                                         &value, 1, &cnt));
        profile->field[i].offset = value;
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_NARROW_PROFILE
 *            entries into LT.
 *
 * \param [in] unit Unit number.
 * \param [in] profile_id Metadata construct profile ID.
 * \param [in] field_entry_id Metadata field entry ID.
 * \param [in] profile returned of bcmi_ltsw_int_metadata_construct_profile_t type.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
int_md_const_narrow_profile_set(
    int unit,
    int profile_id,
    int field_entry_id,
    int_metadata_construct_field_entry_t *field_entry)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit = 0;
    uint64_t value = 0;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(field_entry, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit,
             MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_NARROW_PROFILEs,
             &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
             MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_PROFILE_IDs,
             profile_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    value = 1;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_add(entry_hdl, ENABLEs, field_entry_id,
                                     &value, 1));

    value = field_entry->offset;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_add(entry_hdl, OFFSETs, field_entry_id,
                                     &value, 1));

    /* Operation commit. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_NARROW_PROFILE
 *            entries from LT.
 *
 * \param [in] unit Unit number.
 * \param [in] profile_id Metadata select profile ID.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
int_md_const_narrow_profile_delete(
    int unit,
    int profile_id)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit,
             MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_NARROW_PROFILEs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
             MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_PROFILE_IDs,
             profile_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl,
                              BCMLT_OPCODE_DELETE, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Get MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_WIDE_PROFILE
 *            entries from LT.
 *
 * \param [in] unit Unit number.
 * \param [in] profile_id Metadata construct profile ID.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
int_md_const_wide_profile_create(
    int unit,
    int profile_id)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit, count = INT_MAX_METADATA_FIELD_WIDE_NUM;
    uint64_t value[INT_MAX_METADATA_FIELD_WIDE_NUM] = {0};

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit,
         MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_WIDE_PROFILEs, &entry_hdl));

    /*  Add MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_WIDE_PROFILE fields. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
         MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_PROFILE_IDs, profile_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_add(entry_hdl, ENABLEs, 0,
                                     value, count));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_add(entry_hdl, OFFSETs, 0,
                                     value, count));

    /* Operation commit. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_WIDE_PROFILE
 *            entries from LT.
 *
 * \param [in] unit Unit number.
 * \param [in] profile_id Metadata construct profile ID.
 * \param [out] profile returned of bcmi_ltsw_int_metadata_construct_profile_t type.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
int_md_const_wide_profile_get(
    int unit,
    int profile_id,
    int_metadata_construct_profile_t *profile)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit = 0, i;
    uint64_t value = 0;
    uint32_t cnt = 0;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(profile, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit,
             MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_WIDE_PROFILEs,
             &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
             MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_PROFILE_IDs,
             profile_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    for (i = 0; i < INT_MAX_METADATA_FIELD_WIDE_NUM; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_array_get(entry_hdl, OFFSETs, i,
                                         &value, 1, &cnt));
        profile->field[i].offset = value;
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_WIDE_PROFILE
 *            entries into LT.
 *
 * \param [in] unit Unit number.
 * \param [in] profile_id Metadata construct profile ID.
 * \param [in] field_entry_id Metadata field entry ID.
 * \param [in] profile returned of bcmi_ltsw_int_metadata_construct_profile_t type.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
int_md_const_wide_profile_set(
    int unit,
    int profile_id,
    int field_entry_id,
    int_metadata_construct_field_entry_t *field_entry)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit = 0;
    uint64_t value = 0;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(field_entry, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit,
             MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_WIDE_PROFILEs,
             &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
             MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_PROFILE_IDs,
             profile_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    value = 1;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_add(entry_hdl, ENABLEs, field_entry_id,
                                     &value, 1));

    value = field_entry->offset;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_array_add(entry_hdl, OFFSETs, field_entry_id,
                                     &value, 1));

    /* Operation commit. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_WIDE_PROFILEs
 *            entries from LT.
 *
 * \param [in] unit Unit number.
 * \param [in] profile_id Metadata select profile ID.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
int_md_const_wide_profile_delete(
    int unit,
    int profile_id)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit = 0;

    SHR_FUNC_ENTER(unit);

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit,
             MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_WIDE_PROFILEs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl,
             MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_PROFILE_IDs,
             profile_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl,
                              BCMLT_OPCODE_DELETE, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

/*!
 * \brief Insert MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_NARROW_PROFILE &
 *            MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_WIDE_PROFILE
 *            entries into LT.
 *
 * \param [in] unit Unit number.
 * \param [in] flags Operation flags, BCMI_LTSW_IDX_TBL_OP_xxx.
 * \param [in] index Entry index.
 * \param [in] entry NULL.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
int_md_const_profile_insert(
    int unit,
    uint32_t flags,
    int index,
    void *entry)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (int_md_const_narrow_profile_create(unit, index));

    SHR_IF_ERR_VERBOSE_EXIT
        (int_md_const_wide_profile_create(unit, index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_NARROW_PROFILE &
 *            MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_WIDE_PROFILE
 *            entries from LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Entry index.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
int_md_const_profile_delete(
    int unit,
    int index)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (int_md_const_narrow_profile_delete(unit, index));

    SHR_IF_ERR_VERBOSE_EXIT
        (int_md_const_wide_profile_delete(unit, index));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Allocate a metadata field entry ID.
 *
 * \param [in] unit Unit Number.
 * \param [in] type Field entry type.
 * \param [out] id Metadata field entry ID.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_md_field_entry_id_alloc(
    int unit,
    int profile_id,
    bcmint_int_md_field_entry_type_t type,
    int *id)
{
    SHR_BITDCL *bitmap = XGS_INT_METADATA_FIELD_BMP(unit, profile_id, type);
    int i = 0;
    uint32_t size = 0;

    SHR_FUNC_ENTER(unit);

    if (type == bcmintIntMdFieldEntryNarrow) {
        size = INT_MAX_METADATA_FIELD_NARROW_NUM;
    } else if (type == bcmintIntMdFieldEntryWide) {
        size = INT_MAX_METADATA_FIELD_WIDE_NUM;
    }

    for (i = 0; i < size; i++) {
        if (!SHR_BITGET(bitmap, i)) {
            break;
        }
    }
    if (i >= size) {
        SHR_ERR_EXIT(SHR_E_RESOURCE);
    }
    *id = i;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Check INT metadata field parameter.
 *
 * \param [in] unit Unit Number.
 * \param [in] field_entry Metadata field entry
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_md_field_param_check(
    int unit,
    bcm_int_metadata_field_entry_t *field_entry)
{
    bcm_int_metadata_field_t field;
    bcmint_int_md_field_entry_type_t type;
    uint8 size, start;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(field_entry, SHR_E_PARAM);

    field = field_entry->select.field;
    if ((field < 0) || (field >= bcmIntMetadataCount) ||
        !int_metadata_field_info[unit][field].valid) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    type = int_metadata_field_info[unit][field].default_type;
    size = int_metadata_field_info[unit][field].size;
    start = int_metadata_field_info[unit][field].select_info[type].start;
    if ((field_entry->select.size <= 0) || (field_entry->select.shift < 0) ||
        (field_entry->select.start < start) ||
        ((field_entry->select.start + field_entry->select.size) >
        (start + size))) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (field_entry->construct.offset < 0) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Retrieve field type per chunk index.
 *
 * \param [in] unit Unit Number.
 * \param [in] type Field entry type.
 * \param [in] chunk_index Chunk index.
 * \param [out] field Metadata field.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_md_field_type_get(
    int unit,
    bcmint_int_md_field_entry_type_t type,
    uint8_t chunk_index,
    bcm_int_metadata_field_t *field)
{
    int i;

    SHR_FUNC_ENTER(unit);

    for (i = 0; i < bcmIntMetadataCount; i++) {
        if (int_metadata_field_info[unit][i].select_info[type].chunk_index ==
            chunk_index) {
            *field = i;
            SHR_EXIT();
        }
    }

    SHR_ERR_EXIT(SHR_E_NOT_FOUND);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Find teh field entry ID for the given fied entry.
 *
 * \param [in] unit Unit Number
 * \param [in] profile_id Metadata profile ID
 * \param [in] field_entry Metadata field entry
 * \param [out] field_entry_id Metadata field entry ID
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_md_field_find(
    int unit,
    int profile_id,
    bcm_int_metadata_field_entry_t *field_entry,
    int *field_entry_id)
{
    bcm_int_metadata_field_t field;
    int_metadata_profile_t profile;
    int_metadata_select_profile_t select_profile;
    int_metadata_construct_profile_t construct_profile;
    bcmint_int_md_field_entry_type_t type;
    int i, alloc_size;
    int max_count = 0;

    SHR_FUNC_ENTER(unit);

    sal_memset(&profile, 0, sizeof(int_metadata_profile_t));
    sal_memset(&select_profile, 0, sizeof(int_metadata_select_profile_t));
    sal_memset(&construct_profile, 0, sizeof(int_metadata_construct_profile_t));

    SHR_NULL_CHECK(field_entry, SHR_E_PARAM);

    field = field_entry->select.field;
    type = int_metadata_field_info[unit][field].default_type;

    SHR_IF_ERR_VERBOSE_EXIT
        (int_md_attr_profile_get(unit, profile_id, &profile));

    if (type == bcmintIntMdFieldEntryNarrow) {
        max_count = INT_MAX_METADATA_FIELD_NARROW_NUM;
        alloc_size = max_count * sizeof(int_metadata_select_field_entry_t);
        select_profile.field = sal_alloc(alloc_size, "ltswIntMdSelectNarrow");
        SHR_NULL_CHECK(select_profile.field, SHR_E_MEMORY);
        sal_memset(select_profile.field, 0, alloc_size);
        SHR_IF_ERR_VERBOSE_EXIT
            (int_md_sel_narrow_profile_get(unit, profile.select_profile_id,
                                           &select_profile));

        alloc_size = max_count * sizeof(int_metadata_construct_field_entry_t);
        construct_profile.field =
            sal_alloc(alloc_size, "ltswIntMdConstructNarrow");
        SHR_NULL_CHECK(construct_profile.field, SHR_E_MEMORY);
        sal_memset(construct_profile.field, 0, alloc_size);
        SHR_IF_ERR_VERBOSE_EXIT
            (int_md_const_narrow_profile_get(unit, profile.construct_profile_id,
                                             &construct_profile));
    } else if (type == bcmintIntMdFieldEntryWide) {
        max_count = INT_MAX_METADATA_FIELD_WIDE_NUM;
        alloc_size = max_count * sizeof(int_metadata_select_field_entry_t);
        select_profile.field = sal_alloc(alloc_size, "ltswIntMdSelectWide");
        SHR_NULL_CHECK(select_profile.field, SHR_E_MEMORY);
        sal_memset(select_profile.field, 0, alloc_size);
        SHR_IF_ERR_VERBOSE_EXIT
            (int_md_sel_wide_profile_get(unit, profile.select_profile_id,
                                         &select_profile));

        alloc_size = max_count * sizeof(int_metadata_construct_field_entry_t);
        construct_profile.field =
            sal_alloc(alloc_size, "ltswIntMdConstructWide");
        SHR_NULL_CHECK(construct_profile.field, SHR_E_MEMORY);
        sal_memset(construct_profile.field, 0, alloc_size);
        SHR_IF_ERR_VERBOSE_EXIT
            (int_md_const_wide_profile_get(unit, profile.construct_profile_id,
                                           &construct_profile));
    }

    for (i = 0; i < max_count; i++) {
        if (!XGS_INT_METADATA_FIELD_BMP_USED_GET(unit,
                                                 profile_id,
                                                 type, i)) {
            continue;
        }

        if (int_metadata_field_info[unit][field].select_info[type].chunk_index !=
            select_profile.field[i].chunk_index) {
            continue;
        }

        if (field_entry->select.start != select_profile.field[i].start) {
            continue;
        }

        if (field_entry->select.size != select_profile.field[i].size) {
            continue;
        }

        if (field_entry->select.shift != select_profile.field[i].shift) {
            continue;
        }

        if (field_entry->construct.offset !=
            construct_profile.field[i].offset) {
            continue;
        }

        *field_entry_id = i;
        SHR_EXIT();
    }

exit:
    SHR_FREE(select_profile.field);
    SHR_FREE(construct_profile.field);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Add a match for INT.
 *
 * \param [in] unit Unit Number
 * \param [in] profile_id Metadata profile ID
 * \param [in] field_entry Metadata field entry
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_md_field_add(
    int unit,
    int profile_id,
    bcm_int_metadata_field_entry_t *field_entry)
{
    bcm_int_metadata_field_t field;
    int_metadata_profile_t profile;
    int_metadata_select_field_entry_t select_field_entry;
    int_metadata_construct_field_entry_t construct_field_entry;
    bcmint_int_md_field_entry_type_t type;
    int id = -1;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(field_entry, SHR_E_PARAM);

    /* Validate metadata parameter. */
    SHR_IF_ERR_VERBOSE_EXIT
        (int_md_field_param_check(unit, field_entry));

    /* Check whether the metadata field already exists. */
    SHR_IF_ERR_VERBOSE_EXIT
        (int_md_field_find(unit, profile_id, field_entry, &id));
    if (id != -1) {
        SHR_ERR_EXIT(SHR_E_EXISTS);
    } else {
        /* Allocate a metadata field entry. */
        field = field_entry->select.field;
        type = int_metadata_field_info[unit][field].default_type;
        SHR_IF_ERR_VERBOSE_EXIT
            (int_md_field_entry_id_alloc(unit, profile_id, type, &id));
    }

    sal_memset(&profile, 0, sizeof(int_metadata_profile_t));
    sal_memset(&select_field_entry, 0,
               sizeof(int_metadata_select_field_entry_t));
    sal_memset(&construct_field_entry, 0,
               sizeof(int_metadata_construct_field_entry_t));

    select_field_entry.chunk_index =
        int_metadata_field_info[unit][field].select_info[type].chunk_index;
    select_field_entry.start = field_entry->select.start;
    select_field_entry.size = field_entry->select.size;
    select_field_entry.shift = field_entry->select.shift;

    construct_field_entry.offset = field_entry->construct.offset;

    SHR_IF_ERR_VERBOSE_EXIT
        (int_md_attr_profile_get(unit, profile_id, &profile));

    if (type == bcmintIntMdFieldEntryNarrow) {
        SHR_IF_ERR_VERBOSE_EXIT
            (int_md_sel_narrow_profile_set(unit, profile.select_profile_id,
                                           id, &select_field_entry));
        SHR_IF_ERR_VERBOSE_EXIT
            (int_md_const_narrow_profile_set(unit, profile.construct_profile_id,
                                             id, &construct_field_entry));
    } else if (type == bcmintIntMdFieldEntryWide) {
        SHR_IF_ERR_VERBOSE_EXIT
            (int_md_sel_wide_profile_set(unit, profile.select_profile_id,
                                         id, &select_field_entry));
        SHR_IF_ERR_VERBOSE_EXIT
            (int_md_const_wide_profile_set(unit, profile.construct_profile_id,
                                           id, &construct_field_entry));
    }

    XGS_INT_METADATA_FIELD_BMP_USED_SET(unit, profile_id, type, id);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get MON_INBAND_TELEMETRY_METADATA_PROFILE entries from LT.
 *
 * \param [in] unit Unit number.
 * \param [in] index Entry index.
 * \param [in] array_size Metadata field array size.
 * \param [out] entry_array Metadata field entry array.
 * \param [out] field_count Metadata field count.
 *
 * \return SHR_E_NONE on success and error code otherwise.
 */
static int
int_md_profile_get(
    int unit,
    int profile_id,
    int array_size,
    bcm_int_metadata_field_entry_t *entry_array,
    int *field_count)
{
    int i, count, alloc_size;
    int_metadata_profile_t profile;
    int_metadata_select_profile_t select_profile;
    int_metadata_construct_profile_t construct_profile;
    bcm_int_metadata_field_t field = 0;

    SHR_FUNC_ENTER(unit);

    sal_memset(&profile, 0, sizeof(int_metadata_profile_t));
    sal_memset(&select_profile, 0, sizeof(int_metadata_select_profile_t));
    sal_memset(&construct_profile, 0, sizeof(int_metadata_construct_profile_t));

    if (array_size == 0) {
        SHR_BITCOUNT_RANGE(XGS_INT_METADATA_FIELD_BMP(unit, profile_id,
                           bcmintIntMdFieldEntryNarrow), count, 0,
                           INT_MAX_METADATA_FIELD_NARROW_NUM);
        *field_count = count;
        SHR_BITCOUNT_RANGE(XGS_INT_METADATA_FIELD_BMP(unit, profile_id,
                           bcmintIntMdFieldEntryWide), count, 0,
                           INT_MAX_METADATA_FIELD_WIDE_NUM);
        *field_count += count;
        SHR_EXIT();
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (int_md_attr_profile_get(unit, profile_id, &profile));

    alloc_size = INT_MAX_METADATA_FIELD_NARROW_NUM *
        sizeof(int_metadata_select_field_entry_t);
    select_profile.field = sal_alloc(alloc_size, "ltswIntMdSelectNarrow");
    SHR_NULL_CHECK(select_profile.field, SHR_E_MEMORY);
    sal_memset(select_profile.field, 0, alloc_size);
    SHR_IF_ERR_VERBOSE_EXIT
        (int_md_sel_narrow_profile_get(unit, profile.select_profile_id,
                                       &select_profile));

    alloc_size = INT_MAX_METADATA_FIELD_NARROW_NUM *
        sizeof(int_metadata_construct_field_entry_t);
    construct_profile.field =
        sal_alloc(alloc_size, "ltswIntMdConstructNarrow");
    SHR_NULL_CHECK(construct_profile.field, SHR_E_MEMORY);
    sal_memset(construct_profile.field, 0, alloc_size);
    SHR_IF_ERR_VERBOSE_EXIT
        (int_md_const_narrow_profile_get(unit, profile.construct_profile_id,
                                         &construct_profile));

    count = 0;
    for (i = 0;
         ((i < INT_MAX_METADATA_FIELD_NARROW_NUM) && (count < array_size));
         i++) {

         if (!XGS_INT_METADATA_FIELD_BMP_USED_GET(unit,
                                                  profile_id,
                                                  bcmintIntMdFieldEntryNarrow,
                                                  i)) {
             continue;
         }

         SHR_IF_ERR_VERBOSE_EXIT
             (int_md_field_type_get(unit, bcmintIntMdFieldEntryNarrow,
                                    select_profile.field[i].chunk_index,
                                    &field));
         entry_array[count].select.field = field;
         entry_array[count].select.size =
             select_profile.field[i].size;
         entry_array[count].select.shift =
             select_profile.field[i].shift;
         entry_array[count].construct.offset =
             construct_profile.field[i].offset;
         count++;
    }

    if (count >= array_size) {
        SHR_EXIT();
    }

    SHR_FREE(select_profile.field);
    SHR_FREE(construct_profile.field);

    sal_memset(&select_profile, 0, sizeof(int_metadata_select_profile_t));
    sal_memset(&construct_profile, 0, sizeof(int_metadata_construct_profile_t));
    alloc_size = INT_MAX_METADATA_FIELD_WIDE_NUM *
        sizeof(int_metadata_select_field_entry_t);
    select_profile.field = sal_alloc(alloc_size, "ltswIntMdSelectWide");
    SHR_NULL_CHECK(select_profile.field, SHR_E_MEMORY);
    sal_memset(select_profile.field, 0, alloc_size);
    SHR_IF_ERR_VERBOSE_EXIT
        (int_md_sel_wide_profile_get(unit, profile.select_profile_id,
                                     &select_profile));

    alloc_size = INT_MAX_METADATA_FIELD_WIDE_NUM *
        sizeof(int_metadata_construct_field_entry_t);
    construct_profile.field =
        sal_alloc(alloc_size, "ltswIntMdConstructWide");
    SHR_NULL_CHECK(construct_profile.field, SHR_E_MEMORY);
    sal_memset(construct_profile.field, 0, alloc_size);
    SHR_IF_ERR_VERBOSE_EXIT
        (int_md_const_wide_profile_get(unit, profile.construct_profile_id,
                                       &construct_profile));

    for (i = 0;
         ((i < INT_MAX_METADATA_FIELD_WIDE_NUM) && (count < array_size));
         i++) {

         if (!XGS_INT_METADATA_FIELD_BMP_USED_GET(unit,
                                                  profile_id,
                                                  bcmintIntMdFieldEntryWide,
                                                  i)) {
             continue;
         }

         SHR_IF_ERR_VERBOSE_EXIT
             (int_md_field_type_get(unit, bcmintIntMdFieldEntryWide,
                                    select_profile.field[i].chunk_index,
                                    &field));
         entry_array[count].select.field = field;
         entry_array[count].select.size =
             select_profile.field[i].size;
         entry_array[count].select.shift =
             select_profile.field[i].shift;
         entry_array[count].construct.offset =
             construct_profile.field[i].offset;
         count++;
    }

exit:
    SHR_FREE(select_profile.field);
    SHR_FREE(construct_profile.field);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Traverse all metadata profiles.
 *
 * \param [in] unit Unit number.
 * \param [in] cb A pointer to the callback function to call for each metadata profile.
 * \param [in] user_data Pointer to user data to supply in the callback.
 *
 * \retval SHR_E_NONE Success.
 * \retval !SHR_E_NONE Failure.
 */
static int
int_md_profile_traverse(
    int unit,
    bcm_int_metadata_profile_traverse_cb cb,
    void *user_data)
{
    bcm_int_metadata_field_entry_t entry_array[INT_MAX_METADATA_FIELD_NARROW_NUM + INT_MAX_METADATA_FIELD_WIDE_NUM];
    int idx, rv = SHR_E_NONE, cnt, i;
    uint64_t idx_min, idx_max;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(cb, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit,
             MON_INBAND_TELEMETRY_METADATA_PROFILEs,
             MON_INBAND_TELEMETRY_METADATA_PROFILE_IDs,
             &idx_min, &idx_max));

    for (idx = idx_min; idx <= idx_max; idx++) {
        if (bcmi_ltsw_idx_tbl_entry_get_by_idx(unit,
            BCMI_LTSW_IDX_TBL_OP_SKIP_INDEX_ZERO,
            BCMI_LTSW_IDX_TBL_ID_INT_METADATA_PROFILE,
            BCMI_INT_METADATA_PROFILE_USER_ID_INT,
            NULL, idx)) {
            continue;
        }

        sal_memset(entry_array, 0, sizeof(bcm_int_metadata_field_entry_t) *
                   (INT_MAX_METADATA_FIELD_NARROW_NUM + INT_MAX_METADATA_FIELD_WIDE_NUM));
        rv = int_md_profile_get(unit, idx, 0, entry_array, &cnt);
        if (SHR_FAILURE(rv)) {
            if (rv != SHR_E_NOT_FOUND) {
                break;
            }
            continue;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (int_md_profile_get(unit, idx, cnt, entry_array, &cnt));
        if (cb) {
            for (i = 0; i < cnt; i++) {
                rv = (*cb) (unit, &idx, &entry_array[i], user_data);
                if (SHR_FAILURE(rv) && bcmi_ltsw_dev_cb_err_abort(unit)) {
                    break;
                }
            }
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete the metadata field from the metadata profile.
 *
 * \param [in] unit Unit Number
 * \param [in] profile_id Metadata profile ID
 * \param [in] field_entry Metadata field entry
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_md_field_delete(
    int unit,
    int profile_id,
    bcm_int_metadata_field_entry_t *field_entry)
{
    bcm_int_metadata_field_t field;
    int_metadata_profile_t profile;
    int_metadata_select_field_entry_t select_field_entry;
    int_metadata_construct_field_entry_t construct_field_entry;
    bcmint_int_md_field_entry_type_t type;
    int id = -1;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(field_entry, SHR_E_PARAM);

    /* Check whether the metadata field already exists. */
    SHR_IF_ERR_VERBOSE_EXIT
        (int_md_field_find(unit, profile_id, field_entry, &id));
    if (id == -1) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    sal_memset(&profile, 0, sizeof(int_metadata_profile_t));
    sal_memset(&select_field_entry, 0,
               sizeof(int_metadata_select_field_entry_t));
    sal_memset(&construct_field_entry, 0,
               sizeof(int_metadata_construct_field_entry_t));

    SHR_IF_ERR_VERBOSE_EXIT
        (int_md_attr_profile_get(unit, profile_id, &profile));

    field = field_entry->select.field;
    type = int_metadata_field_info[unit][field].default_type;
    if (type == bcmintIntMdFieldEntryNarrow) {
        SHR_IF_ERR_VERBOSE_EXIT
            (int_md_sel_narrow_profile_set(unit, profile.select_profile_id,
                                           id, &select_field_entry));
        SHR_IF_ERR_VERBOSE_EXIT
            (int_md_const_narrow_profile_set(unit, profile.construct_profile_id,
                                             id, &construct_field_entry));
    } else if (type == bcmintIntMdFieldEntryWide) {
        SHR_IF_ERR_VERBOSE_EXIT
            (int_md_sel_wide_profile_set(unit, profile.select_profile_id,
                                         id, &select_field_entry));
        SHR_IF_ERR_VERBOSE_EXIT
            (int_md_const_wide_profile_set(unit, profile.construct_profile_id,
                                           id, &construct_field_entry));
    }

    XGS_INT_METADATA_FIELD_BMP_USED_CLR(unit, profile_id, type, id);

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Delete all the metadata field from the metadata profile.
 *
 * \param [in] unit Unit Number
 * \param [in] profile_id Metadata profile ID
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_md_field_delete_all(
    int unit,
    int profile_id)
{
    int_metadata_profile_t profile;

    SHR_FUNC_ENTER(unit);

    sal_memset(&profile, 0, sizeof(int_metadata_profile_t));
    SHR_IF_ERR_VERBOSE_EXIT
        (int_md_attr_profile_get(unit, profile_id, &profile));

    SHR_IF_ERR_VERBOSE_EXIT
        (int_md_sel_profile_insert(unit, 0, profile.select_profile_id, NULL));

    SHR_IF_ERR_VERBOSE_EXIT
        (int_md_const_profile_insert(unit, 0, profile.construct_profile_id,
                                     NULL));

    sal_memset(XGS_INT_METADATA_FIELD_BMP(unit, profile_id,
               bcmintIntMdFieldEntryNarrow), 0,
               SHR_BITALLOCSIZE(INT_MAX_METADATA_FIELD_NARROW_NUM));
    sal_memset(XGS_INT_METADATA_FIELD_BMP(unit, profile_id,
               bcmintIntMdFieldEntryWide), 0,
               SHR_BITALLOCSIZE(INT_MAX_METADATA_FIELD_WIDE_NUM));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize INT metadata information.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_md_info_init(int unit)
{
    int dunit = 0;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint64_t value = 0;
    int i;
    const char *field_info_id = NULL;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmint_int_md_field_info_get(unit, &int_metadata_field_info[unit]));

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_INBAND_TELEMETRY_METADATA_FIELD_INFOs,
         &entry_hdl));

    for (i = 0; i < bcmIntMetadataCount; i++) {
        if (!int_metadata_field_info[unit][i].valid) {
            continue;
        }

        if (i == bcmIntMetadataQueueIdProfileIdCutThrough) {
            int_metadata_field_info[unit][i].size = 10;
            int_metadata_field_info[unit][i].select_info[bcmintIntMdFieldEntryNarrow].chunk_index = 35;
            int_metadata_field_info[unit][i].select_info[bcmintIntMdFieldEntryNarrow].start = 6;
            int_metadata_field_info[unit][i].select_info[bcmintIntMdFieldEntryWide].chunk_index = 17;
            int_metadata_field_info[unit][i].select_info[bcmintIntMdFieldEntryWide].start = 22;
            continue;
        }

        if (i == bcmIntMetadataCngQueueIdProfileIdCutThrough) {
            int_metadata_field_info[unit][i].size = 12;
            int_metadata_field_info[unit][i].select_info[bcmintIntMdFieldEntryNarrow].chunk_index = 41;
            int_metadata_field_info[unit][i].select_info[bcmintIntMdFieldEntryNarrow].start = 4;
            int_metadata_field_info[unit][i].select_info[bcmintIntMdFieldEntryWide].chunk_index = 20;
            int_metadata_field_info[unit][i].select_info[bcmintIntMdFieldEntryWide].start = 20;
            continue;
        }

        field_info_id = int_metadata_field_info[unit][i].info_id;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl,
             MON_INBAND_TELEMETRY_METADATA_FIELD_INFO_IDs, field_info_id));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                                  BCMLT_PRIORITY_NORMAL));

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, SIZEs, &value));
        int_metadata_field_info[unit][i].size = value;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, NARROW_INDEXs, &value));
        int_metadata_field_info[unit][i].select_info[bcmintIntMdFieldEntryNarrow].chunk_index = value;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, NARROW_STARTs, &value));
        int_metadata_field_info[unit][i].select_info[bcmintIntMdFieldEntryNarrow].start = value;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, WIDE_INDEXs, &value));
        int_metadata_field_info[unit][i].select_info[bcmintIntMdFieldEntryWide].chunk_index = value;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, WIDE_STARTs, &value));
        int_metadata_field_info[unit][i].select_info[bcmintIntMdFieldEntryWide].start = value;
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief De-initialize INT database.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_db_deinit(int unit)
{
    int i, j;
    xgs_ltsw_int_info_t *int_info = NULL;
    int warmboot; /* during warmboot */

    SHR_FUNC_ENTER(unit);

    warmboot = bcmi_warmboot_get(unit);

    int_info = XGS_INT_INFO(unit);

    if (!warmboot) {
        SHR_IF_ERR_EXIT_EXCEPT_IF
            (bcmi_ltsw_idx_tbl_unregister(unit,
                 BCMI_LTSW_IDX_TBL_ID_INT_ACTION_PROFILE,
                 BCMI_INT_ACTION_PROFILE_USER_ID_IFA),
                 SHR_E_NOT_FOUND);

        SHR_IF_ERR_EXIT_EXCEPT_IF
            (bcmi_ltsw_idx_tbl_unregister(unit,
                 BCMI_LTSW_IDX_TBL_ID_INT_ACTION_PROFILE,
                 BCMI_INT_ACTION_PROFILE_USER_ID_IOAM),
                 SHR_E_NOT_FOUND);

        SHR_IF_ERR_EXIT_EXCEPT_IF
            (bcmi_ltsw_idx_tbl_unregister(unit,
                 BCMI_LTSW_IDX_TBL_ID_INT_ACTION_PROFILE,
                 BCMI_INT_ACTION_PROFILE_USER_ID_INT_DP),
                 SHR_E_NOT_FOUND);

        SHR_IF_ERR_EXIT_EXCEPT_IF
            (bcmi_ltsw_idx_tbl_unregister(unit,
                 BCMI_LTSW_IDX_TBL_ID_INT_OPAQUE_DATA_PROFILE,
                 BCMI_INT_OPAQUE_DATA_PROFILE_USER_ID_INT),
                 SHR_E_NOT_FOUND);

        SHR_IF_ERR_EXIT_EXCEPT_IF
            (bcmi_ltsw_idx_tbl_unregister(unit,
                 BCMI_LTSW_IDX_TBL_ID_INT_METADATA_PROFILE,
                 BCMI_INT_METADATA_PROFILE_USER_ID_INT),
                 SHR_E_NOT_FOUND);

        SHR_IF_ERR_EXIT_EXCEPT_IF
            (bcmi_ltsw_idx_tbl_unregister(unit,
                 BCMI_LTSW_IDX_TBL_ID_INT_METADATA_SELECT_PROFILE,
                 BCMI_INT_METADATA_SELECT_PROFILE_USER_ID_INT),
                 SHR_E_NOT_FOUND);

        SHR_IF_ERR_EXIT_EXCEPT_IF
            (bcmi_ltsw_idx_tbl_unregister(unit,
                 BCMI_LTSW_IDX_TBL_ID_INT_METADATA_CONSTRUCT_PROFILE,
                 BCMI_INT_METADATA_CONSTRUCT_PROFILE_USER_ID_INT),
                 SHR_E_NOT_FOUND);

        if (int_info->vector_match_bmp) {
            (void)bcmi_ltsw_ha_mem_free(unit, int_info->vector_match_bmp);
        }
        if (int_info->vector_match_priority) {
            (void)bcmi_ltsw_ha_mem_free(unit, int_info->vector_match_priority);
        }
        SHR_FREE(int_info->vector_match);
        if (int_info->action_type) {
            (void)bcmi_ltsw_ha_mem_free(unit, int_info->action_type);
        }
        for (i = 0; i < INT_MAX_METADATA_PROFILE_NUM; i++) {
            for (j = 0; j < bcmintIntMdFieldEntryCount; j++) {
                if (int_info->metadata_field_bmp[i][j]) {
                    (void)bcmi_ltsw_ha_mem_free(unit,
                              int_info->metadata_field_bmp[i][j]);
                }
            }
        }
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Recover INT database.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_db_recover(int unit)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit, rv, user_id = -1, idx;
    uint64_t value = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (int_vector_match_recover(unit));

    dunit = bcmi_ltsw_dev_dunit(unit);
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_INBAND_TELEMETRY_ACTION_PROFILEs,
                              &entry_hdl));
    while ((rv = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl,
                                   MON_INBAND_TELEMETRY_ACTION_PROFILE_IDs,
                                   &value));
        idx = value;
        if (XGS_INT_ACTION_TYPE(unit, idx) == bcmiIntActionProfileTypeIfa) {
            user_id = BCMI_INT_ACTION_PROFILE_USER_ID_IFA;
        } else if (XGS_INT_ACTION_TYPE(unit, idx) == bcmiIntActionProfileTypeIoam) {
            user_id = BCMI_INT_ACTION_PROFILE_USER_ID_IOAM;
        } else if (XGS_INT_ACTION_TYPE(unit, idx) == bcmiIntActionProfileTypeIntDp) {
            user_id = BCMI_INT_ACTION_PROFILE_USER_ID_INT_DP;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_entry_ref_increase(unit,
                 BCMI_LTSW_IDX_TBL_ID_INT_ACTION_PROFILE,
                 user_id,
                 idx));
    }

    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILEs,
                              &entry_hdl));
    while ((rv = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl,
                 MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILE_IDs,
                 &value));
        idx = value;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_entry_ref_increase(unit,
                 BCMI_LTSW_IDX_TBL_ID_INT_OPAQUE_DATA_PROFILE,
                 BCMI_INT_OPAQUE_DATA_PROFILE_USER_ID_INT,
                 idx));
    }

    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, MON_INBAND_TELEMETRY_METADATA_PROFILEs,
                              &entry_hdl));
    while ((rv = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl,
                 MON_INBAND_TELEMETRY_METADATA_PROFILE_IDs,
                 &value));
        idx = value;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_entry_ref_increase(unit,
                 BCMI_LTSW_IDX_TBL_ID_INT_METADATA_PROFILE,
                 BCMI_INT_METADATA_PROFILE_USER_ID_INT,
                 idx));
    }

    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit,
             MON_INBAND_TELEMETRY_METADATA_SELECT_NARROW_PROFILEs,
             &entry_hdl));
    while ((rv = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl,
                 MON_INBAND_TELEMETRY_METADATA_SELECT_PROFILE_IDs,
                 &value));
        idx = value;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_entry_ref_increase(unit,
                 BCMI_LTSW_IDX_TBL_ID_INT_METADATA_SELECT_PROFILE,
                 BCMI_INT_METADATA_SELECT_PROFILE_USER_ID_INT,
                 idx));
    }

    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit,
             MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_NARROW_PROFILEs,
             &entry_hdl));
    while ((rv = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_TRAVERSE,
                                      BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl,
                 MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_PROFILE_IDs,
                 &value));
        idx = value;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_idx_tbl_entry_ref_increase(unit,
                 BCMI_LTSW_IDX_TBL_ID_INT_METADATA_CONSTRUCT_PROFILE,
                 BCMI_INT_METADATA_CONSTRUCT_PROFILE_USER_ID_INT,
                 idx));
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize INT database.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
int_db_init(int unit)
{
    int i, j;
    uint64_t idx_min, idx_max;
    bcmi_ltsw_idx_tbl_user_info_t user_info;
    bcmi_ltsw_idx_tbl_lt_info_t lt_info;
    xgs_ltsw_int_info_t *int_info = NULL;
    int warmboot; /* during warmboot */
    uint32_t alloc_size = 0, req_size = 0, size = 0;

    SHR_FUNC_ENTER(unit);

    warmboot = bcmi_warmboot_get(unit);

    int_info = XGS_INT_INFO(unit);

    /* Init INT vector match used bitmap. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_capacity_get(unit, MON_INBAND_TELEMETRY_IFA_VECTOR_MATCHs,
                              &size));
    int_info->vector_match_num = size;
    req_size = SHR_BITALLOCSIZE(size);
    alloc_size = req_size;
    int_info->vector_match_bmp =
        bcmi_ltsw_ha_mem_alloc(unit, BCMI_HA_COMP_ID_INT,
                               BCMINT_INT_VECTOR_MATCH_BMP_SUB_COMP_ID,
                               "bcmIntVectorMatchBmp",
                               &alloc_size);

    SHR_NULL_CHECK(int_info->vector_match_bmp, SHR_E_MEMORY);
    SHR_IF_ERR_VERBOSE_EXIT
        ((alloc_size < req_size) ? SHR_E_MEMORY : SHR_E_NONE);

    if (!warmboot) {
        sal_memset(int_info->vector_match_bmp, 0, alloc_size);
    }

    /* Init INT vector match priority. */
    req_size = sizeof(int) * int_info->vector_match_num;
    alloc_size = req_size;
    int_info->vector_match_priority =
        bcmi_ltsw_ha_mem_alloc(unit, BCMI_HA_COMP_ID_INT,
                               BCMINT_INT_VECTOR_MATCH_PRI_SUB_COMP_ID,
                               "bcmIntVectorMatchPri",
                               &alloc_size);

    SHR_NULL_CHECK(int_info->vector_match_priority, SHR_E_MEMORY);
    SHR_IF_ERR_VERBOSE_EXIT
        ((alloc_size < req_size) ? SHR_E_MEMORY : SHR_E_NONE);

    if (!warmboot) {
        sal_memset(int_info->vector_match_priority, 0, alloc_size);
    }

    /* Init INT vector match. */
    if (int_info->vector_match_num > 0) {
        size = sizeof(bcmi_ltsw_int_vector_match_t) * int_info->vector_match_num;
        SHR_ALLOC(int_info->vector_match, size, "bcmIntVectorMatch");
        SHR_NULL_CHECK(int_info->vector_match, SHR_E_MEMORY);
        sal_memset(int_info->vector_match, 0, size);
    }

    /* Init INT action profile. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit,
             MON_INBAND_TELEMETRY_ACTION_PROFILEs,
             MON_INBAND_TELEMETRY_ACTION_PROFILE_IDs,
             &idx_min, &idx_max));

    sal_memset(&lt_info, 0, sizeof(lt_info));
    /* Max number of users of this LT. */
    lt_info.user_cnt  = BCMI_INT_ACTION_PROFILE_USER_ID_CNT;
    lt_info.tbl_name  = MON_INBAND_TELEMETRY_ACTION_PROFILEs;
    lt_info.idx_field = MON_INBAND_TELEMETRY_ACTION_PROFILE_IDs;

    sal_memset(&user_info, 0, sizeof(user_info));
    user_info.valid       = 1;
    user_info.idx_min     = (uint32_t)idx_min;
    user_info.idx_max     = (uint32_t)idx_max;
    user_info.func_hash   = NULL;
    user_info.func_cmp    = NULL;
    user_info.func_insert = int_action_profile_insert;
    user_info.func_del    = int_action_profile_del;

    /* Register index table management for IFA action profile. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_register(unit,
                                    BCMI_LTSW_IDX_TBL_ID_INT_ACTION_PROFILE,
                                    BCMI_INT_ACTION_PROFILE_USER_ID_IFA,
                                    &lt_info, &user_info));

    /* Register index table management for IOAM action profile.. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_register(unit,
                                    BCMI_LTSW_IDX_TBL_ID_INT_ACTION_PROFILE,
                                    BCMI_INT_ACTION_PROFILE_USER_ID_IOAM,
                                    &lt_info, &user_info));

    /* Register index table management for INT-DP action profile. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_register(unit,
                                    BCMI_LTSW_IDX_TBL_ID_INT_ACTION_PROFILE,
                                    BCMI_INT_ACTION_PROFILE_USER_ID_INT_DP,
                                    &lt_info, &user_info));

    /* Init INT action type. */
    req_size =
        sizeof(bcmi_ltsw_int_action_profile_type_t) * (idx_max - idx_min + 1);
    alloc_size = req_size;
    int_info->action_type =
        bcmi_ltsw_ha_mem_alloc(unit, BCMI_HA_COMP_ID_INT,
                               BCMINT_INT_ACTION_TYPE_SUB_COMP_ID,
                               "bcmIntActionType",
                               &alloc_size);

    SHR_NULL_CHECK(int_info->action_type, SHR_E_MEMORY);
    SHR_IF_ERR_VERBOSE_EXIT
        ((alloc_size < req_size) ? SHR_E_MEMORY : SHR_E_NONE);

    if (!warmboot) {
        sal_memset(int_info->action_type, 0, alloc_size);
    }

    /* Init INT opaque data profile. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit,
             MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILEs,
             MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILE_IDs,
             &idx_min, &idx_max));

    sal_memset(&lt_info, 0, sizeof(lt_info));
    /* Max number of users of this LT. */
    lt_info.user_cnt  = BCMI_INT_OPAQUE_DATA_PROFILE_USER_ID_CNT;
    lt_info.tbl_name  = MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILEs;
    lt_info.idx_field = MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILE_IDs;

    sal_memset(&user_info, 0, sizeof(user_info));
    user_info.valid       = 1;
    user_info.idx_min     = (uint32_t)idx_min;
    user_info.idx_max     = (uint32_t)idx_max;
    user_info.func_hash   = NULL;
    user_info.func_cmp    = NULL;
    user_info.func_insert = int_opaque_data_profile_insert;
    user_info.func_del    = int_opaque_data_profile_del;


    /* Register index table management for INT opaque data profile. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_register(unit,
                                    BCMI_LTSW_IDX_TBL_ID_INT_OPAQUE_DATA_PROFILE,
                                    BCMI_INT_OPAQUE_DATA_PROFILE_USER_ID_INT,
                                    &lt_info, &user_info));

    /* Init INT metadata profile. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit,
             MON_INBAND_TELEMETRY_METADATA_PROFILEs,
             MON_INBAND_TELEMETRY_METADATA_PROFILE_IDs,
             &idx_min, &idx_max));

    sal_memset(&lt_info, 0, sizeof(lt_info));
    /* Max number of users of this LT. */
    lt_info.user_cnt  = BCMI_INT_METADATA_PROFILE_USER_ID_CNT;
    lt_info.tbl_name  = MON_INBAND_TELEMETRY_METADATA_PROFILEs;
    lt_info.idx_field = MON_INBAND_TELEMETRY_METADATA_PROFILE_IDs;

    sal_memset(&user_info, 0, sizeof(user_info));
    user_info.valid       = 1;
    user_info.idx_min     = (uint32_t)idx_min;
    user_info.idx_max     = (uint32_t)idx_max;
    user_info.func_hash   = NULL;
    user_info.func_cmp    = NULL;
    user_info.func_insert = int_md_attr_profile_insert;
    user_info.func_del    = int_md_attr_profile_del;


    /* Register index table management for INT metadata profile. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_register(unit,
                                    BCMI_LTSW_IDX_TBL_ID_INT_METADATA_PROFILE,
                                    BCMI_INT_METADATA_PROFILE_USER_ID_INT,
                                    &lt_info, &user_info));

    sal_memset(&lt_info, 0, sizeof(lt_info));
    /* Max number of users of this LT. */
    lt_info.user_cnt  = BCMI_INT_METADATA_SELECT_PROFILE_USER_ID_CNT;
    lt_info.tbl_name  = MON_INBAND_TELEMETRY_METADATA_SELECT_NARROW_PROFILEs;
    lt_info.idx_field = MON_INBAND_TELEMETRY_METADATA_SELECT_PROFILE_IDs;

    sal_memset(&user_info, 0, sizeof(user_info));
    user_info.valid       = 1;
    user_info.idx_min     = (uint32_t)idx_min;
    user_info.idx_max     = (uint32_t)idx_max;
    user_info.func_hash   = NULL;
    user_info.func_cmp    = NULL;
    user_info.func_insert = int_md_sel_profile_insert;
    user_info.func_del    = int_md_sel_profile_delete;

    /* Register index table management for INT metadata select profile. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_register(unit,
             BCMI_LTSW_IDX_TBL_ID_INT_METADATA_SELECT_PROFILE,
             BCMI_INT_METADATA_SELECT_PROFILE_USER_ID_INT,
             &lt_info, &user_info));

    sal_memset(&lt_info, 0, sizeof(lt_info));
    /* Max number of users of this LT. */
    lt_info.user_cnt  = BCMI_INT_METADATA_CONSTRUCT_PROFILE_USER_ID_CNT;
    lt_info.tbl_name  = MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_NARROW_PROFILEs;
    lt_info.idx_field = MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_PROFILE_IDs;

    sal_memset(&user_info, 0, sizeof(user_info));
    user_info.valid       = 1;
    user_info.idx_min     = (uint32_t)idx_min;
    user_info.idx_max     = (uint32_t)idx_max;
    user_info.func_hash   = NULL;
    user_info.func_cmp    = NULL;
    user_info.func_insert = int_md_const_profile_insert;
    user_info.func_del    = int_md_const_profile_delete;

    /* Register index table management for INT metadata construct profile. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_register(unit,
             BCMI_LTSW_IDX_TBL_ID_INT_METADATA_CONSTRUCT_PROFILE,
             BCMI_INT_METADATA_CONSTRUCT_PROFILE_USER_ID_INT,
             &lt_info, &user_info));

    /* Init INT metadata field entry used bitmap. */
    for (i = 0; i < INT_MAX_METADATA_PROFILE_NUM; i++) {
        for (j = 0; j < bcmintIntMdFieldEntryCount; j++) {
            if (j == bcmintIntMdFieldEntryNarrow) {
                req_size = SHR_BITALLOCSIZE(INT_MAX_METADATA_FIELD_NARROW_NUM);
            } else {
                req_size = SHR_BITALLOCSIZE(INT_MAX_METADATA_FIELD_WIDE_NUM);
            }
            alloc_size = req_size;
            int_info->metadata_field_bmp[i][j] =
                bcmi_ltsw_ha_mem_alloc(unit, BCMI_HA_COMP_ID_INT,
                BCMINT_INT_METADATA_FIELD_BMP_SUB_COMP_ID +
                (bcmintIntMdFieldEntryCount * i) + j,
                "bcmIntMetadataFieldBmp",
                &alloc_size);
            SHR_NULL_CHECK(int_info->metadata_field_bmp[i][j], SHR_E_MEMORY);
            SHR_IF_ERR_VERBOSE_EXIT
                ((alloc_size < req_size) ? SHR_E_MEMORY : SHR_E_NONE);

            if (!warmboot) {
                sal_memset(int_info->metadata_field_bmp[i][j], 0, alloc_size);
            }
        }
    }

    /* Recover INT database. */
    if (warmboot) {
        SHR_IF_ERR_VERBOSE_EXIT(int_db_recover(unit));
    }

exit:
    if (SHR_FUNC_ERR()) {
        int_db_deinit(unit);
    }
    SHR_FUNC_EXIT();
}


/******************************************************************************
 * Public functions
 */

int
xgs_ltsw_int_init(int unit)
{
    int warmboot; /* during warmboot */

    SHR_FUNC_ENTER(unit);

    warmboot = bcmi_warmboot_get(unit);

    if (!warmboot) {
        /* Reset all LTs */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, MON_INBAND_TELEMETRY_IFA_PARSEs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, MON_INBAND_TELEMETRY_IOAM_PARSEs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, MON_INBAND_TELEMETRY_DATAPLANE_PARSEs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, MON_INBAND_TELEMETRY_VECTOR_MATCH_CONTROLs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, MON_INBAND_TELEMETRY_IFA_VECTOR_MATCHs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, MON_INBAND_TELEMETRY_IOAM_VECTOR_MATCHs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, MON_INBAND_TELEMETRY_DATAPLANE_VECTOR_MATCHs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, MON_INBAND_TELEMETRY_ACTION_PROFILEs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILEs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, MON_INBAND_TELEMETRY_TM_STATS_CONTROLs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, MON_INBAND_TELEMETRY_METADATA_FIELD_CONTROLs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, MON_INBAND_TELEMETRY_METADATA_PROFILEs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit,
                 MON_INBAND_TELEMETRY_METADATA_SELECT_NARROW_PROFILEs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit,
                 MON_INBAND_TELEMETRY_METADATA_SELECT_WIDE_PROFILEs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit,
                 MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_NARROW_PROFILEs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit,
                 MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_WIDE_PROFILEs));
    }

    /* Initialize INT database. */
    SHR_IF_ERR_VERBOSE_EXIT(int_db_init(unit));

    /* Initialize INT metadata information. */
    SHR_IF_ERR_VERBOSE_EXIT(int_md_info_init(unit));

exit:
    if (SHR_FUNC_ERR()) {
        SHR_IF_ERR_CONT
            (xgs_ltsw_int_detach(unit));
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_int_detach(int unit)
{
    int warmboot;

    SHR_FUNC_ENTER(unit);

    warmboot = bcmi_warmboot_get(unit);
    /* Do not clear LT entries when "exit clean". */
    if (!warmboot) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, MON_INBAND_TELEMETRY_ACTION_PROFILEs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, MON_INBAND_TELEMETRY_OPAQUE_DATA_PROFILEs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, MON_INBAND_TELEMETRY_METADATA_PROFILEs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit,
                 MON_INBAND_TELEMETRY_METADATA_SELECT_NARROW_PROFILEs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit,
                 MON_INBAND_TELEMETRY_METADATA_SELECT_WIDE_PROFILEs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit,
                 MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_NARROW_PROFILEs));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit,
                 MON_INBAND_TELEMETRY_METADATA_CONSTRUCT_WIDE_PROFILEs));
    }

    SHR_IF_ERR_VERBOSE_EXIT(int_db_deinit(unit));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_int_control_set(
    int unit,
    bcmi_ltsw_int_control_t control,
    uint32_t value)
{
    SHR_FUNC_ENTER(unit);

    switch (control) {
        case bcmiIntControlIntDpL4DestPort1:
            SHR_IF_ERR_VERBOSE_EXIT
                (int_control_intdp_l4dstport1_set(unit, value));
            break;
        case bcmiIntControlIntDpL4DestPort2:
            SHR_IF_ERR_VERBOSE_EXIT
                (int_control_intdp_l4dstport2_set(unit, value));
            break;
        case bcmiIntControlIoamType:
            SHR_IF_ERR_VERBOSE_EXIT
                (int_control_ioam_type_set(unit, value));
            break;
        case bcmiIntControlVectorMatchMissAction:
            SHR_IF_ERR_VERBOSE_EXIT
                (int_control_vec_match_miss_set(unit, value));
            break;
        case bcmiIntControlEgressTimeDelta:
        case bcmiIntControlSwitchId:
        case bcmiIntControlIfaVersion:
        case bcmiIntControlIfaProtocol:
        case bcmiIntControlIoamGreProtocolParse:
        case bcmiIntControlIoamGreProtocol:
        case bcmiIntControlIoamOptionIncrementalParse:
        case bcmiIntControlIoamOptionIncremental:
        case bcmiIntControlIntDpVersion:
        case bcmiIntControlIntDpUseProbeMarker1:
        case bcmiIntControlIntDpProbeMarker1:
        case bcmiIntControlIntDpUseProbeMarker2:
        case bcmiIntControlIntDpProbeMarker2:
        case bcmiIntControlIntTurnAroundCpuEnable:
        case bcmiIntControlIntHopLimitCpuEnable:
            SHR_IF_ERR_VERBOSE_EXIT
                (int_control_set(unit, control, value));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_int_control_get(
    int unit,
    bcmi_ltsw_int_control_t control,
    uint32_t *value)
{
    SHR_FUNC_ENTER(unit);

    switch (control) {
        case bcmiIntControlIntDpL4DestPort1:
            SHR_IF_ERR_VERBOSE_EXIT
                (int_control_intdp_l4dstport1_get(unit, value));
            break;
        case bcmiIntControlIntDpL4DestPort2:
            SHR_IF_ERR_VERBOSE_EXIT
                (int_control_intdp_l4dstport2_get(unit, value));
            break;
        case bcmiIntControlIoamType:
            SHR_IF_ERR_VERBOSE_EXIT
                (int_control_ioam_type_get(unit, value));
            break;
        case bcmiIntControlVectorMatchMissAction:
            SHR_IF_ERR_VERBOSE_EXIT
                (int_control_vec_match_miss_get(unit, value));
            break;
        case bcmiIntControlEgressTimeDelta:
        case bcmiIntControlSwitchId:
        case bcmiIntControlIfaVersion:
        case bcmiIntControlIfaProtocol:
        case bcmiIntControlIoamGreProtocolParse:
        case bcmiIntControlIoamGreProtocol:
        case bcmiIntControlIoamOptionIncrementalParse:
        case bcmiIntControlIoamOptionIncremental:
        case bcmiIntControlIntDpVersion:
        case bcmiIntControlIntDpUseProbeMarker1:
        case bcmiIntControlIntDpProbeMarker1:
        case bcmiIntControlIntDpUseProbeMarker2:
        case bcmiIntControlIntDpProbeMarker2:
        case bcmiIntControlIntTurnAroundCpuEnable:
        case bcmiIntControlIntHopLimitCpuEnable:
            SHR_IF_ERR_VERBOSE_EXIT
                (int_control_get(unit, control, value));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_int_vector_match_add(
    int unit,
    uint32 options,
    bcmi_ltsw_int_vector_match_t *vector_match)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (int_vector_match_add(unit, options, vector_match));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_int_vector_match_get(
    int unit,
    bcmi_ltsw_int_vector_match_t *vector_match)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (int_vector_match_get(unit, vector_match));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_int_vector_match_del(
    int unit,
    bcmi_ltsw_int_vector_match_t *vector_match)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (int_vector_match_delete(unit, vector_match));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_int_vector_match_del_all(
    int unit,
    bcmi_ltsw_int_vector_match_type_t type)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (int_vector_match_delete_all(unit, type));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_int_vector_match_ifa_traverse(
    int unit,
    bcm_int_ifa_vector_match_traverse_cb trav_fn,
    bcmi_ltsw_int_ifa_vector_match_from_int_cb_f cb,
    void *user_data)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (int_vector_match_ifa_traverse(unit, trav_fn, cb, user_data));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_int_vector_match_ioam_traverse(
    int unit,
    bcm_int_ioam_vector_match_traverse_cb trav_fn,
    bcmi_ltsw_int_ioam_vector_match_from_int_cb_f cb,
    void *user_data)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (int_vector_match_ioam_traverse(unit, trav_fn, cb, user_data));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_int_vector_match_dp_traverse(
    int unit,
    bcm_int_dp_vector_match_traverse_cb trav_fn,
    bcmi_ltsw_int_dp_vector_match_from_int_cb_f cb,
    void *user_data)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (int_vector_match_dp_traverse(unit, trav_fn, cb, user_data));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_int_action_profile_create(
    int unit,
    uint32 flags,
    int *profile_id,
    bcmi_ltsw_int_action_profile_t *profile)
{
    int user_id = -1;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(profile, SHR_E_PARAM);

    if (profile->type == bcmiIntActionProfileTypeIfa) {
        user_id = BCMI_INT_ACTION_PROFILE_USER_ID_IFA;
    } else if (profile->type == bcmiIntActionProfileTypeIoam) {
        user_id = BCMI_INT_ACTION_PROFILE_USER_ID_IOAM;
    } else if (profile->type == bcmiIntActionProfileTypeIntDp) {
        user_id = BCMI_INT_ACTION_PROFILE_USER_ID_INT_DP;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_alloc(unit, flags,
                                       BCMI_LTSW_IDX_TBL_ID_INT_ACTION_PROFILE,
                                       user_id, profile, profile_id));
    XGS_INT_ACTION_TYPE(unit, *profile_id) = profile->type;

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_int_action_profile_get(
    int unit,
    uint32 flags,
    int profile_id,
    bcmi_ltsw_int_action_profile_t *profile)
{
    int user_id = -1;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(profile, SHR_E_PARAM);

    if (profile->type == bcmiIntActionProfileTypeIfa) {
        user_id = BCMI_INT_ACTION_PROFILE_USER_ID_IFA;
    } else if (profile->type == bcmiIntActionProfileTypeIoam) {
        user_id = BCMI_INT_ACTION_PROFILE_USER_ID_IOAM;
    } else if (profile->type == bcmiIntActionProfileTypeIntDp) {
        user_id = BCMI_INT_ACTION_PROFILE_USER_ID_INT_DP;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_get_by_idx(unit, flags,
             BCMI_LTSW_IDX_TBL_ID_INT_ACTION_PROFILE,
             user_id, profile, profile_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (int_action_profile_get(unit, profile_id, profile));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_int_action_profile_del(
    int unit,
    uint32 flags,
    bcmi_ltsw_int_action_profile_type_t type,
    int profile_id)
{
    int user_id = -1;

    SHR_FUNC_ENTER(unit);

    if (type == bcmiIntActionProfileTypeIfa) {
        user_id = BCMI_INT_ACTION_PROFILE_USER_ID_IFA;
    } else if (type == bcmiIntActionProfileTypeIoam) {
        user_id = BCMI_INT_ACTION_PROFILE_USER_ID_IOAM;
    } else if (type == bcmiIntActionProfileTypeIntDp) {
        user_id = BCMI_INT_ACTION_PROFILE_USER_ID_INT_DP;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_free(unit, flags,
                                      BCMI_LTSW_IDX_TBL_ID_INT_ACTION_PROFILE,
                                      user_id, profile_id));
    XGS_INT_ACTION_TYPE(unit, profile_id) = bcmiIntActionProfileTypeNone;

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_int_action_profile_ifa_traverse(
    int unit,
    bcm_int_ifa_action_profile_traverse_cb trav_fn,
    bcmi_ltsw_int_ifa_action_profile_from_int_cb_f cb,
    void *user_data)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (int_action_profile_ifa_traverse(unit, trav_fn, cb, user_data));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_int_action_profile_ioam_traverse(
    int unit,
    bcm_int_ioam_action_profile_traverse_cb trav_fn,
    bcmi_ltsw_int_ioam_action_profile_from_int_cb_f cb,
    void *user_data)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (int_action_profile_ioam_traverse(unit, trav_fn, cb, user_data));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_int_action_profile_dp_traverse(
    int unit,
    bcm_int_dp_action_profile_traverse_cb trav_fn,
    bcmi_ltsw_int_dp_action_profile_from_int_cb_f cb,
    void *user_data)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (int_action_profile_dp_traverse(unit, trav_fn, cb, user_data));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_int_opaque_data_profile_create(
    int unit,
    uint32 flags,
    int *profile_id,
    bcm_int_opaque_data_profile_t *profile)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(profile, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_alloc(unit, flags,
             BCMI_LTSW_IDX_TBL_ID_INT_OPAQUE_DATA_PROFILE,
             BCMI_INT_OPAQUE_DATA_PROFILE_USER_ID_INT,
             profile, profile_id));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_int_opaque_data_profile_get(
    int unit,
    uint32 flags,
    int profile_id,
    bcm_int_opaque_data_profile_t *profile)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(profile, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_get_by_idx(unit, flags,
             BCMI_LTSW_IDX_TBL_ID_INT_OPAQUE_DATA_PROFILE,
             BCMI_INT_OPAQUE_DATA_PROFILE_USER_ID_INT,
             profile, profile_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (int_opaque_data_profile_get(unit, profile_id, profile));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_int_opaque_data_profile_del(
    int unit,
    uint32 flags,
    int profile_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_free(unit, flags,
             BCMI_LTSW_IDX_TBL_ID_INT_OPAQUE_DATA_PROFILE,
             BCMI_INT_OPAQUE_DATA_PROFILE_USER_ID_INT,
             profile_id));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_int_opaque_data_profile_traverse(
    int unit,
    bcm_int_opaque_data_profile_traverse_cb cb,
    void *user_data)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (int_opaque_data_profile_traverse(unit, cb, user_data));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_int_cosq_stat_config_set(
    int unit,
    bcm_int_cosq_stat_config_t *config)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (int_cosq_stat_config_set(unit, config));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_int_cosq_stat_config_get(
    int unit,
    bcm_int_cosq_stat_config_t *config)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (int_cosq_stat_config_get(unit, config));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_int_metadata_profile_create(
    int unit,
    uint32 flags,
    int *profile_id)
{
    int_metadata_profile_t profile;
    int_metadata_select_profile_t select_profile;
    int_metadata_construct_profile_t construct_profile;

    SHR_FUNC_ENTER(unit);

    /* The index of metadata select and construct profile are the same as metadata
     * profile in current design.
     */
    sal_memset(&profile, 0, sizeof(int_metadata_profile_t));
    sal_memset(&select_profile, 0, sizeof(int_metadata_select_profile_t));
    sal_memset(&construct_profile, 0, sizeof(int_metadata_construct_profile_t));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_alloc(unit, flags,
             BCMI_LTSW_IDX_TBL_ID_INT_METADATA_SELECT_PROFILE,
             BCMI_INT_METADATA_SELECT_PROFILE_USER_ID_INT,
             &select_profile, profile_id));
    profile.select_profile_id = *profile_id;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_alloc(unit, flags,
             BCMI_LTSW_IDX_TBL_ID_INT_METADATA_CONSTRUCT_PROFILE,
             BCMI_INT_METADATA_CONSTRUCT_PROFILE_USER_ID_INT,
             &construct_profile, profile_id));
    profile.construct_profile_id = *profile_id;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_alloc(unit, flags,
             BCMI_LTSW_IDX_TBL_ID_INT_METADATA_PROFILE,
             BCMI_INT_METADATA_PROFILE_USER_ID_INT,
             &profile, profile_id));

exit:
    if (SHR_FUNC_ERR()) {
        if (profile.select_profile_id) {
            (void)bcmi_ltsw_idx_tbl_entry_free(unit, flags,
                      BCMI_LTSW_IDX_TBL_ID_INT_METADATA_SELECT_PROFILE,
                      BCMI_INT_METADATA_SELECT_PROFILE_USER_ID_INT,
                      profile.select_profile_id);
        }
        if (profile.construct_profile_id) {
            (void)bcmi_ltsw_idx_tbl_entry_free(unit, flags,
                      BCMI_LTSW_IDX_TBL_ID_INT_METADATA_CONSTRUCT_PROFILE,
                      BCMI_INT_METADATA_CONSTRUCT_PROFILE_USER_ID_INT,
                      profile.construct_profile_id);
        }
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_int_metadata_profile_get(
    int unit,
    uint32 flags,
    int profile_id,
    int array_size,
    bcm_int_metadata_field_entry_t *entry_array,
    int *field_count)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_get_by_idx(unit, flags,
             BCMI_LTSW_IDX_TBL_ID_INT_METADATA_PROFILE,
             BCMI_INT_METADATA_PROFILE_USER_ID_INT,
             NULL, profile_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (int_md_profile_get(unit, profile_id, array_size,
                            entry_array, field_count));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_int_metadata_profile_del(
    int unit,
    uint32 flags,
    int profile_id)
{
    int_metadata_profile_t profile;

    SHR_FUNC_ENTER(unit);

    sal_memset(&profile, 0, sizeof(int_metadata_profile_t));
    SHR_IF_ERR_VERBOSE_EXIT
        (int_md_attr_profile_get(unit, profile_id, &profile));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_free(unit, flags,
             BCMI_LTSW_IDX_TBL_ID_INT_METADATA_SELECT_PROFILE,
             BCMI_INT_METADATA_SELECT_PROFILE_USER_ID_INT,
             profile.select_profile_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_free(unit, flags,
             BCMI_LTSW_IDX_TBL_ID_INT_METADATA_CONSTRUCT_PROFILE,
             BCMI_INT_METADATA_CONSTRUCT_PROFILE_USER_ID_INT,
             profile.construct_profile_id));

    sal_memset(XGS_INT_METADATA_FIELD_BMP(unit, profile_id,
               bcmintIntMdFieldEntryNarrow), 0,
               SHR_BITALLOCSIZE(INT_MAX_METADATA_FIELD_NARROW_NUM));
    sal_memset(XGS_INT_METADATA_FIELD_BMP(unit, profile_id,
               bcmintIntMdFieldEntryWide), 0,
               SHR_BITALLOCSIZE(INT_MAX_METADATA_FIELD_WIDE_NUM));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_free(unit, flags,
                                      BCMI_LTSW_IDX_TBL_ID_INT_METADATA_PROFILE,
                                      BCMI_INT_METADATA_PROFILE_USER_ID_INT,
                                      profile_id));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_int_metadata_profile_traverse(
    int unit,
    bcm_int_metadata_profile_traverse_cb cb,
    void *user_data)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (int_md_profile_traverse(unit, cb, user_data));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_int_metadata_field_add(
    int unit,
    int profile_id,
    bcm_int_metadata_field_entry_t *field_entry)
{
    uint32_t flags = 0;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(field_entry, SHR_E_PARAM);

    flags = BCMI_LTSW_IDX_TBL_OP_SKIP_INDEX_ZERO;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_get_by_idx(unit, flags,
             BCMI_LTSW_IDX_TBL_ID_INT_METADATA_PROFILE,
             BCMI_INT_METADATA_PROFILE_USER_ID_INT,
             NULL, profile_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (int_md_field_add(unit, profile_id, field_entry));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_int_metadata_field_delete(
    int unit,
    int profile_id,
    bcm_int_metadata_field_entry_t *field_entry)
{
    uint32_t flags = 0;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(field_entry, SHR_E_PARAM);

    flags = BCMI_LTSW_IDX_TBL_OP_SKIP_INDEX_ZERO;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_get_by_idx(unit, flags,
             BCMI_LTSW_IDX_TBL_ID_INT_METADATA_PROFILE,
             BCMI_INT_METADATA_PROFILE_USER_ID_INT,
             NULL, profile_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (int_md_field_delete(unit, profile_id, field_entry));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_int_metadata_field_delete_all(
    int unit,
    int profile_id)
{
    uint32_t flags = 0;

    SHR_FUNC_ENTER(unit);

    flags = BCMI_LTSW_IDX_TBL_OP_SKIP_INDEX_ZERO;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_idx_tbl_entry_get_by_idx(unit, flags,
             BCMI_LTSW_IDX_TBL_ID_INT_METADATA_PROFILE,
             BCMI_INT_METADATA_PROFILE_USER_ID_INT,
             NULL, profile_id));

    SHR_IF_ERR_VERBOSE_EXIT
        (int_md_field_delete_all(unit, profile_id));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_int_metadata_field_select_info_get(
    int unit,
    bcm_int_metadata_field_t field,
    bcm_int_metadata_field_select_info_t *field_select_info)
{
    bcmint_int_md_field_entry_type_t type;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(field_select_info, SHR_E_PARAM);

    if (field < 0 || field >= bcmIntMetadataCount) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (!int_metadata_field_info[unit][field].valid) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    type = int_metadata_field_info[unit][field].default_type;
    field_select_info->start =
        int_metadata_field_info[unit][field].select_info[type].start;
    field_select_info->size =
        int_metadata_field_info[unit][field].size;

exit:
    SHR_FUNC_EXIT();
}

#endif /* INCLUDE_INT */

