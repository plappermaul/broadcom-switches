/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm_int/control.h>

#include <bcm_int/ltsw/xgs/uft.h>
#include <bcm_int/ltsw/uft.h>
#include <bcm_int/ltsw/uft_int.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/property.h>

#include <sal/sal_libc.h>
#include <bcmltd/chip/bcmltd_str.h>
#include <bcmltd/chip/bcmltd_device_constants.h>
#include <shr/shr_types.h>
#include <shr/shr_debug.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_UFT

/******************************************************************************
 * Private functions
 */


/*! Max UFT L2 entries. */
#define UFT_L2_ENTRY_LIMIT 0x20000

/*!
 * \brief UFT bank info.
 */
typedef struct hash_uft_bank_info_s {

    /*! Bank ID. */
    int bank_id;

    /*! List of EM groups which may contain this bank. */
    int groups[DEVICE_EM_GROUP_CNT_MAX];

    /*! Count of EM groups. */
    int group_cnt;

    /*! Bank is fixed. */
    bool is_fixed;

    /*! Bank is valid. */
    bool valid;

} hash_uft_bank_info_t;

/*!
 * \brief EM group info.
 */
typedef struct hash_uft_group_info_s {

    /*! Group ID. */
    int group_id;

    /*! List of dedicated banks which attached to this group. */
    int fixed_banks[DEVICE_EM_BANK_CNT_MAX];

    /*! Count of dedicated banks. */
    int fixed_cnt;

    /*! List of variable banks which attached to this group. */
    int var_banks[DEVICE_EM_BANK_CNT_MAX];

    /*! Count of variable banks. */
    int var_cnt;

    /*! Group is valid. */
    bool valid;

} hash_uft_group_info_t;

/*!
 * \brief UFT dev info.
 */
typedef struct hash_uft_dev_info_s {

    /*! Hash dev info initialized. */
    bool inited;

    /*! Maximum number of UFT banks. */
    int max_banks;

    /*! Maximum number of EM groups. */
    int max_groups;

    /*! UFT bank info. */
    hash_uft_bank_info_t *bank_info;

    /*! UFT group info. */
    hash_uft_group_info_t *group_info;

    /*! List of variable banks for HASH/ALPM level 3 groups. */
    int hash_banks[DEVICE_EM_BANK_CNT_MAX];

    /*! Count of variable banks. */
    int hash_cnt;

    /*! Using L2_UFT_GROUP instead of L2_HASH_GROUP. */
    bool l2_uft_group_used;
} hash_uft_dev_info_t;

/*!
 * \brief UFT dev info.
 */
static hash_uft_dev_info_t xgs_ltsw_uft_dev_info[BCM_MAX_NUM_UNITS];

static bcmint_uft_var_db_t *uft_var_db[BCM_MAX_NUM_UNITS] = {NULL};

/*!
 * \brief Convert an ID to a string.
 *
 * \param [in] name_id_map Strings to IDs mapping table.
 * \param [in] map_len Size of the mapping table.
 * \param [in] id The ID to convert.
 *
 * \retval Non-NULL Pionter to a string matching ID.
 * \retval NULL String not found for provided ID.
 */
static const char*
hash_id2name(const shr_enum_map_t *name_id_map, int map_len, int id)
{
    int idx;

    if (name_id_map == NULL) {
        return NULL;
    }

    for (idx = 0; idx < map_len; idx++) {
        if (name_id_map[idx].val == id) {
            return name_id_map[idx].name;
        }
    }

    return NULL;
}

/*!
 * \brief Convert a string to an ID.
 *
 * \param [in] name_id_map Strings to IDs mapping table.
 * \param [in] map_len Size of the mapping table.
 * \param [in] name Pointer to a string to convert.
 *
 * \retval Non-negative integer value matching string.
 * \retval -1 ID not found for provided string.
 */
static int
hash_name2id(const shr_enum_map_t *name_id_map, int map_len, const char *name)
{
    int idx;

    if (name_id_map == NULL || name == NULL) {
        return -1;
    }

    for (idx = 0; idx < map_len; idx++) {
        if (sal_strcasecmp(name_id_map[idx].name, name) == 0) {
            return name_id_map[idx].val;
        }
    }

    return -1;
}

/*!
 * \brief Find the EM group to which this logical table is mapped.
 *
 * \param [in] unit Unit number.
 * \param [in] table_id Logical table ID.
 * \param [out] group_id EM group ID.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
hash_uft_group_get(int unit, const char *table_id, int *group_id)
{
    hash_uft_dev_info_t *dev_info = &xgs_ltsw_uft_dev_info[unit];
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    const char *group_array[DEVICE_EM_GROUP_CNT_MAX];
    uint32_t group_cnt = 0;
    const shr_enum_map_t *group_id_map = NULL;
    const bcmint_uft_table_map_t *table_map = NULL;
    int id, group_id_map_count = 0;
    int i = 0, table_map_count = 0;
    const char *l2_table_id = NULL;
    bool is_found = FALSE;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, TABLE_EM_INFOs, &entry_hdl));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_symbol_add(entry_hdl, TABLE_IDs, table_id));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_array_symbol_get(entry_hdl, DEVICE_EM_GROUP_IDs,
                                            0, group_array,
                                            DEVICE_EM_GROUP_CNT_MAX,
                                            &group_cnt));
    group_id_map = uft_var_db[unit]->group_id_map;
    group_id_map_count = uft_var_db[unit]->group_id_map_count;
    table_map = uft_var_db[unit]->table_map;
    table_map_count = uft_var_db[unit]->table_map_count;
    for (i = 0; i < table_map_count; i++) {
        if (table_map[i].hash_table == bcmHashTableL2) {
            l2_table_id = table_map[i].table;
            is_found = TRUE;
            break;
        }
    }
    if (is_found == FALSE) {
        SHR_ERR_EXIT(SHR_E_INTERNAL);
    }
    for (i = 0; i < group_cnt; i++) {
        if ((sal_strcmp(table_id, l2_table_id) == 0) &&
            (((sal_strcmp(group_array[i], "L2_HASH_GROUP") == 0) &&
            (dev_info->l2_uft_group_used == 1)) ||
            ((sal_strcmp(group_array[i], "L2_UFT_GROUP") == 0) &&
            (dev_info->l2_uft_group_used == 0)))) {
            continue;
        }
        id = hash_name2id(group_id_map, group_id_map_count,
                          group_array[i]);
        if (id < 0) {
            break;
        }
        *group_id = id;
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the EM group bank num.
 *
 * \param [in] unit Unit number.
 * \param [in] hash_table Hash table.
 * \param [out] num_bank num of bank.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
hash_uft_group_bank_num_get(
    int unit,
    bcm_switch_hash_table_t hash_table,
    int *num_bank)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int i;
    const char *table_id = NULL;
    const char *group_str = NULL;
    const shr_enum_map_t *group_id_map = NULL;
    const bcmint_uft_table_map_t *table_map = NULL;
    int group_id, table_map_count = 0, group_id_map_count = 0;
    bool is_found = false;
    uint64_t value;

    SHR_FUNC_ENTER(unit);

    table_map = uft_var_db[unit]->table_map;
    table_map_count = uft_var_db[unit]->table_map_count;
    for (i = 0; i < table_map_count; i++) {
        if (table_map[i].hash_table == hash_table) {
            table_id = table_map[i].table;
            is_found = TRUE;
            break;
        }
    }

    if (is_found == FALSE) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (hash_uft_group_get(unit, table_id, &group_id));

    group_id_map = uft_var_db[unit]->group_id_map;
    group_id_map_count = uft_var_db[unit]->group_id_map_count;
    group_str = hash_id2name(group_id_map, group_id_map_count, group_id);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, DEVICE_EM_GROUPs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(entry_hdl, DEVICE_EM_GROUP_IDs, group_str));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, NUM_BANKSs, &value));
    *num_bank = (int)value;

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Enable or disable robust hash.
 *
 * \param [in] unit Unit number.
 * \param [in] bank_num Bank number.
 * \param [in] enable 1 to enable, 0 to disable.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
hash_bank_robust_enable_set(
    int unit,
    bcm_switch_hash_table_t hash_table,
    int enable)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    const char *group_str = NULL;
    const char *table_id = NULL;
    const shr_enum_map_t *group_id_map = NULL;
    const bcmint_uft_table_map_t *table_map = NULL;
    int i = 0, table_map_count = 0, group_id_map_count = 0;
    bool is_found = FALSE;
    int group_id;
    uint64_t value = 0;

    SHR_FUNC_ENTER(unit);

    table_map = uft_var_db[unit]->table_map;
    table_map_count = uft_var_db[unit]->table_map_count;
    for (i = 0; i < table_map_count; i++) {
        if (table_map[i].hash_table == hash_table) {
            table_id = table_map[i].table;
            is_found = TRUE;
            break;
        }
    }
    if (is_found == FALSE) {
        SHR_ERR_EXIT(SHR_E_INTERNAL);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (hash_uft_group_get(unit, table_id, &group_id));

    group_id_map = uft_var_db[unit]->group_id_map;
    group_id_map_count = uft_var_db[unit]->group_id_map_count;
    group_str = hash_id2name(group_id_map, group_id_map_count, group_id);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, DEVICE_EM_GROUPs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(entry_hdl, DEVICE_EM_GROUP_IDs, group_str));
    value = (unsigned int)enable;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, ROBUSTs, value));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set hash offset into the hash vector.
 *
 * \param [in] unit Unit number.
 * \param [in] hash_table Hash table.
 * \param [in] bank_num Bank number.
 * \param [in] hash_offset Hash offset.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
hash_bank_offset_set(
    int unit,
    bcm_switch_hash_table_t hash_table,
    int bank_num,
    uint32_t hash_offset)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    const char *table_id = NULL;
    const char *group_str = NULL;
    const char *bank_str = NULL;
    const shr_enum_map_t *group_id_map = NULL;
    const bcmint_uft_table_map_t *table_map = NULL;
    int group_id, table_map_count = 0, group_id_map_count = 0;
    int i = 0;
    bool is_found = FALSE;
    int num_bank;
    int fix_num_bank;
    const char *bank_array[DEVICE_EM_BANK_CNT_MAX];
    uint32_t bank_cnt;

    SHR_FUNC_ENTER(unit);

    table_map = uft_var_db[unit]->table_map;
    table_map_count = uft_var_db[unit]->table_map_count;
    for (i = 0; i < table_map_count; i++) {
        if (table_map[i].hash_table == hash_table) {
            table_id = table_map[i].table;
            is_found = TRUE;
            break;
        }
    }

    if (is_found == FALSE) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (hash_uft_group_get(unit, table_id, &group_id));

    group_id_map = uft_var_db[unit]->group_id_map;
    group_id_map_count = uft_var_db[unit]->group_id_map_count;
    group_str = hash_id2name(group_id_map, group_id_map_count, group_id);

    SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, DEVICE_EM_GROUPs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(entry_hdl, DEVICE_EM_GROUP_IDs, group_str));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, NUM_BANKSs, (uint64_t *)&num_bank));

    if (num_bank) {
        SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_symbol_get(entry_hdl, DEVICE_EM_BANK_IDs,
                                                    0, bank_array,
                                                    DEVICE_EM_BANK_CNT_MAX,
                                                    &bank_cnt));
        bank_str = bank_array[bank_num];
    }

    (void)bcmlt_entry_free(entry_hdl);
    entry_hdl = BCMLT_INVALID_HDL;

    SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, DEVICE_EM_GROUP_INFOs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(entry_hdl, DEVICE_EM_GROUP_IDs,
                                      group_str));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, NUM_FIXED_BANKSs,
                               (uint64_t *)&fix_num_bank));

    if (fix_num_bank) {
        SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_symbol_get(entry_hdl, FIXED_DEVICE_EM_BANK_IDs,
                                                    0, bank_array,
                                                    DEVICE_EM_BANK_CNT_MAX,
                                                    &bank_cnt));
        bank_str = bank_array[bank_num];
    }

    (void)bcmlt_entry_free(entry_hdl);
    entry_hdl = BCMLT_INVALID_HDL;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, DEVICE_EM_BANKs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(entry_hdl, DEVICE_EM_BANK_IDs, bank_str));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, OFFSETs, (uint64_t)hash_offset));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get hash offset from the hash vector.
 *
 * \param [in] unit Unit number.
 * \param [in] hash_table Hash table.
 * \param [in] bank_num Bank number.
 * \param [out] hash_offset Hash offset.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
hash_bank_offset_get(
    int unit,
    bcm_switch_hash_table_t hash_table,
    int bank_num,
    uint32_t *hash_offset)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    const char *table_id = NULL;
    const char *group_str = NULL;
    const char *bank_str = NULL;
    const shr_enum_map_t *group_id_map = NULL;
    const bcmint_uft_table_map_t *table_map = NULL;
    int group_id, table_map_count = 0, group_id_map_count = 0;
    int i = 0;
    bool is_found = FALSE;
    int num_bank;
    int fix_num_bank;
    const char *bank_array[DEVICE_EM_BANK_CNT_MAX];
    uint32_t bank_cnt;

    SHR_FUNC_ENTER(unit);

    table_map = uft_var_db[unit]->table_map;
    table_map_count = uft_var_db[unit]->table_map_count;
    for (i = 0; i < table_map_count; i++) {
        if (table_map[i].hash_table == hash_table) {
            table_id = table_map[i].table;
            is_found = TRUE;
            break;
        }
    }

    if (is_found == FALSE) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (hash_uft_group_get(unit, table_id, &group_id));

    group_id_map = uft_var_db[unit]->group_id_map;
    group_id_map_count = uft_var_db[unit]->group_id_map_count;
    group_str = hash_id2name(group_id_map, group_id_map_count, group_id);

    SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, DEVICE_EM_GROUPs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(entry_hdl, DEVICE_EM_GROUP_IDs, group_str));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, NUM_BANKSs, (uint64_t *)&num_bank));

    if (num_bank) {
        SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_symbol_get(entry_hdl, DEVICE_EM_BANK_IDs,
                                                    0, bank_array,
                                                    DEVICE_EM_BANK_CNT_MAX,
                                                    &bank_cnt));
        bank_str = bank_array[bank_num];
    }

    (void)bcmlt_entry_free(entry_hdl);
    entry_hdl = BCMLT_INVALID_HDL;

    SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, DEVICE_EM_GROUP_INFOs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(entry_hdl, DEVICE_EM_GROUP_IDs,
                                      group_str));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, NUM_FIXED_BANKSs,
                               (uint64_t *)&fix_num_bank));

    if (fix_num_bank) {
        SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_array_symbol_get(entry_hdl, FIXED_DEVICE_EM_BANK_IDs,
                                                    0, bank_array,
                                                    DEVICE_EM_BANK_CNT_MAX,
                                                    &bank_cnt));
        bank_str = bank_array[bank_num];
    }

    (void)bcmlt_entry_free(entry_hdl);
    entry_hdl = BCMLT_INVALID_HDL;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, DEVICE_EM_BANKs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_symbol_add(entry_hdl, DEVICE_EM_BANK_IDs, bank_str));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, OFFSETs, (uint64_t *)hash_offset));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}


/*!
 * \brief Configure the maximum number of table entries for a logical table.
 *
 * \param [in] unit Unit number.
 * \param [in] table_id Logical table ID.
 * \param [in] max_entries Maximum number of table entries.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
hash_uft_table_max_entries_set(int unit, const char *table_id, int max_entries)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, TABLE_CONTROLs, &entry_hdl));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_symbol_add(entry_hdl, TABLE_IDs, table_id));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_add(entry_hdl, MAX_ENTRIESs, max_entries));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_UPDATE,
                            BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get the table size for a logical table.
 *
 * \param [in] unit Unit number.
 * \param [in] table_id Logical table ID.
 * \param [in] entry_limit The greatest number of table entries.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
hash_uft_table_size_get(int unit, const char *table_id, uint64_t *table_size)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, TABLE_INFOs, &entry_hdl));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_symbol_add(entry_hdl, TABLE_IDs, table_id));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_EXIT
        (bcmlt_entry_field_get(entry_hdl, ENTRY_LIMITs, table_size));
exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Reserve hash banks for exact match FP tables.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
hash_uft_em_table_config_set(int unit)
{
    hash_uft_dev_info_t *dev_info = &xgs_ltsw_uft_dev_info[unit];
    hash_uft_group_info_t *group_info = NULL;
    int i, group_id, table_map_count = 0;
    int fp_num_banks = 0, l2_num_banks = 0, alpm_num_banks = 0, num_entries = 0;
    bool is_found = FALSE;
    const bcmint_uft_table_map_t *table_map = NULL;
    const char *l2_table_id = NULL;
    uint64_t table_size = 0;

    SHR_FUNC_ENTER(unit);

    /* Reserve variable banks for field process EM table. */
    num_entries = bcmi_ltsw_property_get(unit, BCMI_CPN_FPEM_MEM_ENTRIES, 0);
    fp_num_banks = (num_entries + (32 * 1024 - 1)) / (32 * 1024);

    /* Reserve variable banks for L2 entry table. */
    table_map = uft_var_db[unit]->table_map;
    table_map_count = uft_var_db[unit]->table_map_count;
    for (i = 0; i < table_map_count; i++) {
        if (table_map[i].hash_table == bcmHashTableL2) {
            l2_table_id = table_map[i].table;
            is_found = TRUE;
            break;
        }
    }
    if (is_found == FALSE) {
        SHR_ERR_EXIT(SHR_E_INTERNAL);
    }
    SHR_IF_ERR_EXIT
        (hash_uft_table_size_get(unit, l2_table_id, &table_size));
    num_entries = bcmi_ltsw_property_get(unit, BCMI_CPN_L2_MEM_ENTRIES,
                                         table_size);
    if (num_entries <= table_size) {
        dev_info->l2_uft_group_used = 0;
    } else if (num_entries <= UFT_L2_ENTRY_LIMIT) {
        l2_num_banks = (num_entries + (32 * 1024 - 1)) / (32 * 1024);
        dev_info->l2_uft_group_used = 1;
    } else {
        LOG_ERROR(BSL_LOG_MODULE,
                  (BSL_META_U(unit,
                              "Error configuration: %s: %d. "
                              "The maximum number of entries exceeds the entry limit = %d.\n"),
                  BCMI_CPN_L2_MEM_ENTRIES, num_entries, (int)table_size));
        SHR_ERR_EXIT(SHR_E_CONFIG);
    }

    if ((fp_num_banks + l2_num_banks) > 4) {
        LOG_ERROR(BSL_LOG_MODULE,
                  (BSL_META_U(unit,
                              "Hash: Insufficient banks for FP exact match and L2 table.\n")));
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (((fp_num_banks) < 2) && ((fp_num_banks) != 0)) {
        LOG_ERROR(BSL_LOG_MODULE,
                  (BSL_META_U(unit,
                              "Hash: At least 2 banks for FP exact match table.\n")));
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (((l2_num_banks) < 2) && ((l2_num_banks) != 0)) {
        LOG_ERROR(BSL_LOG_MODULE,
                  (BSL_META_U(unit,
                              "Hash: At least 2 banks for L2 table.\n")));
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (fp_num_banks > 0) {
        SHR_IF_ERR_EXIT
            (hash_uft_group_get(unit, FP_EM_ENTRYs, &group_id));
        group_info = dev_info->group_info + group_id;
        sal_memcpy(group_info->var_banks,
                   &dev_info->hash_banks[0],
                   fp_num_banks * sizeof(int));
        group_info->var_cnt = fp_num_banks;
    }

    if (l2_num_banks > 0) {
        SHR_IF_ERR_EXIT
            (hash_uft_group_get(unit, l2_table_id, &group_id));
        group_info = dev_info->group_info + group_id;
        sal_memcpy(group_info->var_banks,
                   &dev_info->hash_banks[fp_num_banks],
                   l2_num_banks * sizeof(int));
        group_info->var_cnt = l2_num_banks;
    }

    alpm_num_banks = 8 - fp_num_banks - l2_num_banks;
    SHR_IF_ERR_EXIT
        (hash_uft_group_get(unit, L3_IPV4_UC_ROUTEs, &group_id));
    group_info = dev_info->group_info + group_id;
    sal_memcpy(group_info->var_banks,
               &dev_info->hash_banks[fp_num_banks + l2_num_banks],
               alpm_num_banks * sizeof(int));
    group_info->var_cnt = alpm_num_banks;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize bank-specific data.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
hash_uft_bank_info_init(int unit)
{
    int rv = SHR_E_NONE;
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    hash_uft_dev_info_t *dev_info = &xgs_ltsw_uft_dev_info[unit];
    hash_uft_bank_info_t *bank_info = NULL;
    int bank_id = 0, group_id = 0;
    const char *group_array[DEVICE_EM_GROUP_CNT_MAX];
    const char *bank_str;
    const shr_enum_map_t *bank_id_map = NULL, *group_id_map = NULL;
    uint32_t group_cnt = 0;
    int i, bank_id_map_count = 0, group_id_map_count = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, DEVICE_EM_BANK_INFOs, &entry_hdl));

    bank_id_map = uft_var_db[unit]->bank_id_map;
    bank_id_map_count = uft_var_db[unit]->bank_id_map_count;
    group_id_map = uft_var_db[unit]->group_id_map;
    group_id_map_count = uft_var_db[unit]->group_id_map_count;
    while ((rv = bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_TRAVERSE,
                                    BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_symbol_get(entry_hdl, DEVICE_EM_BANK_IDs,
                                          &bank_str));
        bank_id = hash_name2id(bank_id_map, bank_id_map_count, bank_str);
        if (bank_id < 0) {
            LOG_WARN(BSL_LOG_MODULE,
                     (BSL_META_U(unit, "EM bank [%s] unsupported.\n"),
                      bank_str));
            continue;
        }
        bank_info = dev_info->bank_info + bank_id;
        bank_info->bank_id = bank_id;
        bank_info->valid = TRUE;
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_array_symbol_get(entry_hdl, DEVICE_EM_GROUP_IDs,
                                                0, group_array,
                                                DEVICE_EM_GROUP_CNT_MAX,
                                                &group_cnt));

        for (i = 0; i < group_cnt; i++) {
            group_id = hash_name2id(group_id_map, group_id_map_count,
                                    group_array[i]);
            if (group_id < 0) {
                break;
            }
            bank_info->groups[i] = group_id;
            bank_info->group_cnt++;
        }
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize group-specific data.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
hash_uft_group_info_init(int unit)
{
    int rv = SHR_E_NONE;
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    hash_uft_dev_info_t *dev_info = &xgs_ltsw_uft_dev_info[unit];
    hash_uft_group_info_t *group_info = NULL;
    hash_uft_bank_info_t *bank_info = NULL;
    int bank_id = 0, group_id = 0;
    int i = 0, bank_id_map_count = 0, group_id_map_count = 0;
    const char *bank_array[DEVICE_EM_BANK_CNT_MAX];
    const char *group_str;
    const shr_enum_map_t *bank_id_map = NULL, *group_id_map = NULL;
    uint32_t bank_cnt = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, DEVICE_EM_GROUP_INFOs, &entry_hdl));

    bank_id_map = uft_var_db[unit]->bank_id_map;
    bank_id_map_count = uft_var_db[unit]->bank_id_map_count;
    group_id_map = uft_var_db[unit]->group_id_map;
    group_id_map_count = uft_var_db[unit]->group_id_map_count;
    while ((rv = bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_TRAVERSE,
                                    BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_symbol_get(entry_hdl, DEVICE_EM_GROUP_IDs,
                                          &group_str));
        group_id = hash_name2id(group_id_map, group_id_map_count, group_str);
        if (group_id < 0) {
            LOG_WARN(BSL_LOG_MODULE,
                     (BSL_META_U(unit, "EM group [%s] unsupported.\n"),
                      group_str));
            continue;
        }

        group_info = dev_info->group_info + group_id;
        group_info->group_id = group_id;
        group_info->valid = TRUE;

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_array_symbol_get(entry_hdl,
                                                FIXED_DEVICE_EM_BANK_IDs,
                                                0, bank_array,
                                                DEVICE_EM_BANK_CNT_MAX,
                                                &bank_cnt));
        for (i = 0; i < bank_cnt; i++) {
            bank_id = hash_name2id(bank_id_map, bank_id_map_count,
                                   bank_array[i]);
            if (bank_id < 0) {
                break;
            }
            group_info->fixed_banks[i] = bank_id;
            group_info->fixed_cnt++;
            bank_info = dev_info->bank_info + bank_id;
            bank_info->is_fixed = TRUE;
        }
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Clean up UFT resources.
 *
 * \param [in] unit Unit number.
 *
 * \retval None.
 */
static void
hash_uft_info_cleanup(int unit)
{
    hash_uft_dev_info_t *dev_info = &xgs_ltsw_uft_dev_info[unit];

    SHR_FREE(dev_info->group_info);
    SHR_FREE(dev_info->bank_info);
    sal_memset(dev_info, 0, sizeof(hash_uft_dev_info_t));

    return;
}

/*!
 * \brief Initialize UFT resource manager.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
hash_uft_info_init(int unit)
{
    hash_uft_dev_info_t *dev_info = &xgs_ltsw_uft_dev_info[unit];
    hash_uft_bank_info_t *bank_info = NULL;
    int alloc_sz = 0;
    int i = 0, group_id_map_count = 0, bank_id_map_count = 0;

    SHR_FUNC_ENTER(unit);

    /* Allocate buffer for group info. */
    group_id_map_count = uft_var_db[unit]->group_id_map_count;
    alloc_sz = sizeof(hash_uft_group_info_t) * group_id_map_count;
    SHR_ALLOC(dev_info->group_info, alloc_sz, "bcmLtswHashGroupInfo");
    SHR_NULL_CHECK(dev_info->group_info, SHR_E_MEMORY);
    sal_memset(dev_info->group_info, 0, alloc_sz);

    /* Allocate buffer for bank info. */
    bank_id_map_count = uft_var_db[unit]->bank_id_map_count;
    alloc_sz = sizeof(hash_uft_bank_info_t) * bank_id_map_count;
    SHR_ALLOC(dev_info->bank_info, alloc_sz, "bcmLtswHashBankInfo");
    SHR_NULL_CHECK(dev_info->bank_info, SHR_E_MEMORY);
    sal_memset(dev_info->bank_info, 0, alloc_sz);

    dev_info->max_banks = bank_id_map_count;
    dev_info->max_groups = group_id_map_count;

    SHR_IF_ERR_EXIT
        (hash_uft_bank_info_init(unit));

    SHR_IF_ERR_EXIT
        (hash_uft_group_info_init(unit));

    /* Initialize the variable banks lists. */
    for (i = 0; i < dev_info->max_banks; i++) {
        bank_info = dev_info->bank_info + i;
        if (!bank_info->valid || bank_info->is_fixed) {
            continue;
        }
        dev_info->hash_banks[dev_info->hash_cnt] = bank_info->bank_id;
        dev_info->hash_cnt++;
    }

    SHR_IF_ERR_EXIT
        (hash_uft_em_table_config_set(unit));

    dev_info->inited = TRUE;

exit:
    if (SHR_FUNC_ERR()) {
        hash_uft_info_cleanup(unit);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Enable the usage of variable banks.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
hash_uft_banks_enable(int unit)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    hash_uft_dev_info_t *dev_info = &xgs_ltsw_uft_dev_info[unit];
    hash_uft_group_info_t *group_info = NULL;
    const shr_enum_map_t *bank_id_map = NULL, *group_id_map = NULL;
    int group_id = 0, group_id_map_count = 0, bank_id_map_count = 0;
    int i = 0, j = 0;
    const char *group_str;
    const char *bank_array[DEVICE_EM_BANK_CNT_MAX];
    uint32_t bank_cnt = 0;

    SHR_FUNC_ENTER(unit);

    bank_id_map = uft_var_db[unit]->bank_id_map;
    bank_id_map_count = uft_var_db[unit]->bank_id_map_count;
    group_id_map = uft_var_db[unit]->group_id_map;
    group_id_map_count = uft_var_db[unit]->group_id_map_count;
    for (i = 0; i < dev_info->max_groups; i++) {
        group_info = dev_info->group_info + i;
        if (!group_info->valid || group_info->var_cnt < 1) {
            continue;
        }
        group_id = group_info->group_id;
        SHR_IF_ERR_EXIT
            (bcmlt_entry_allocate(dunit, DEVICE_EM_GROUPs, &entry_hdl));
        group_str = hash_id2name(group_id_map, group_id_map_count, group_id);
        if (group_str == NULL) {
            SHR_ERR_EXIT(SHR_E_INTERNAL);
        }

        for (j = 0; j < group_info->var_cnt; j++) {
            bank_array[j] = hash_id2name(bank_id_map, bank_id_map_count,
                                         group_info->var_banks[j]);
            if (bank_array[j] == NULL) {
                SHR_ERR_EXIT(SHR_E_INTERNAL);
            }
        }
        bank_cnt = group_info->var_cnt;

        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, DEVICE_EM_GROUP_IDs,
                                          group_str));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_array_symbol_add(entry_hdl, DEVICE_EM_BANK_IDs,
                                                0, bank_array, bank_cnt));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry_hdl, NUM_BANKSs, bank_cnt));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_UPDATE,
                                BCMLT_PRIORITY_NORMAL));
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Disable the usage of variable banks.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
hash_uft_banks_disable(int unit)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    hash_uft_dev_info_t *dev_info = &xgs_ltsw_uft_dev_info[unit];
    hash_uft_group_info_t *group_info = NULL;
    const shr_enum_map_t *group_id_map = NULL;
    int group_id = 0, group_id_map_count = 0;
    int i = 0;
    const char *group_str;
    const char *bank_array[DEVICE_EM_BANK_CNT_MAX];

    SHR_FUNC_ENTER(unit);

    for (i = 0; i < DEVICE_EM_BANK_CNT_MAX; i++) {
        bank_array[i] = INVALIDs;
    }

    group_id_map = uft_var_db[unit]->group_id_map;
    group_id_map_count = uft_var_db[unit]->group_id_map_count;
    for (i = 0; i < dev_info->max_groups; i++) {
        group_info = dev_info->group_info + i;
        if (!group_info->valid || group_info->var_cnt == 0) {
            continue;
        }

        group_id = group_info->group_id;
        group_str = hash_id2name(group_id_map, group_id_map_count, group_id);
        if (group_str == NULL) {
            SHR_ERR_EXIT(SHR_E_INTERNAL);
        }
        SHR_IF_ERR_EXIT
            (bcmlt_entry_allocate(dunit, DEVICE_EM_GROUPs, &entry_hdl));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_symbol_add(entry_hdl, DEVICE_EM_GROUP_IDs,
                                          group_str));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_array_symbol_add(entry_hdl,
                                                DEVICE_EM_BANK_IDs,
                                                0,
                                                bank_array,
                                                DEVICE_EM_BANK_CNT_MAX));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_add(entry_hdl, NUM_BANKSs, 0));
        SHR_IF_ERR_EXIT
            (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_UPDATE,
                                BCMLT_PRIORITY_NORMAL));
        bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize the maximum number of entry moves for hash reordering.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
hash_uft_table_move_depth_init(int unit)
{
    int move_depth;

    SHR_FUNC_ENTER(unit);

    move_depth = bcmi_ltsw_property_get(unit,
                                        BCMI_CPN_MULTI_HASH_RECURSE_DEPTH_L2,
                                        -1);
    if (move_depth >= 0) {
        SHR_IF_ERR_EXIT
            (xgs_ltsw_uft_multi_move_depth_set(unit,
                                                bcmSwitchHashMultiMoveDepthL2,
                                                move_depth));
    }

    move_depth = bcmi_ltsw_property_get(unit,
                                        BCMI_CPN_MULTI_HASH_RECURSE_DEPTH_EXACT_MATCH,
                                        -1);
    if (move_depth >= 0) {
        SHR_IF_ERR_EXIT
            (xgs_ltsw_uft_multi_move_depth_set(unit,
                                                bcmSwitchHashMultiMoveDepthExactMatch,
                                                move_depth));
    }

    move_depth = bcmi_ltsw_property_get(unit,
                                        BCMI_CPN_MULTI_HASH_RECURSE_DEPTH_L3_TUNNEL,
                                        -1);
    if (move_depth >= 0) {
        SHR_IF_ERR_EXIT
            (xgs_ltsw_uft_multi_move_depth_set(unit,
                                                bcmSwitchHashMultiMoveDepthL3Tunnel,
                                                move_depth));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize the robust hash.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
hash_uft_table_robust_init(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (hash_bank_robust_enable_set(unit,
                                     bcmHashTableL2,
                                     true));

    SHR_IF_ERR_VERBOSE_EXIT
        (hash_bank_robust_enable_set(unit,
                                     bcmHashTableMPLS,
                                     true));
    SHR_IF_ERR_VERBOSE_EXIT
        (hash_bank_robust_enable_set(unit,
                                     bcmHashTableL3Tunnel,
                                     true));

    SHR_IF_ERR_VERBOSE_EXIT
        (hash_bank_robust_enable_set(unit,
                                     bcmHashTableExactMatch,
                                     true));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Initialize the maximum number of table entries for logical tables.
 *
 * \param [in] unit Unit number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
hash_uft_table_max_entries_init(int unit)
{
    int rv = SHR_E_NONE;
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    const char *table_id = NULL;
    const char *property = NULL;
    bool is_found = FALSE;
    const bcmint_uft_table_map_t *table_map = NULL;
    uint64_t table_size = 0;
    int i, num_entries = 0, table_map_count = 0;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_EXIT
        (bcmlt_entry_allocate(dunit, TABLE_EM_INFOs, &entry_hdl));

    while ((rv = bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_TRAVERSE,
                                    BCMLT_PRIORITY_NORMAL)) == SHR_E_NONE) {
        SHR_IF_ERR_EXIT
            (bcmlt_entry_field_symbol_get(entry_hdl, TABLE_IDs,
                                          &table_id));
        SHR_IF_ERR_EXIT
            (hash_uft_table_size_get(unit, table_id, &table_size));
        SHR_IF_ERR_EXIT
            (hash_uft_table_max_entries_set(unit, table_id, table_size));
    }

    table_map = uft_var_db[unit]->table_map;
    table_map_count = uft_var_db[unit]->table_map_count;
    for (i = 0; i < table_map_count; i++) {
        if (table_map[i].hash_table == bcmHashTableL2) {
            table_id = table_map[i].table;
            is_found = TRUE;
            break;
        }
    }
    if (is_found == FALSE) {
        SHR_ERR_EXIT(SHR_E_INTERNAL);
    }
    SHR_IF_ERR_EXIT
        (hash_uft_table_size_get(unit, table_id, &table_size));
    num_entries = bcmi_ltsw_property_get(unit, BCMI_CPN_L2_MEM_ENTRIES,
                                         table_size);
    if (num_entries > table_size) {
        LOG_ERROR(BSL_LOG_MODULE,
                  (BSL_META_U(unit,
                              "Error configuration: %s: %d. "
                              "The maximum number of entries exceeds the entry limit = %d.\n"),
                  property, num_entries, (int)table_size));
        SHR_ERR_EXIT(SHR_E_CONFIG);
    }
    if (num_entries) {
        SHR_IF_ERR_EXIT
            (hash_uft_table_max_entries_set(unit, table_id, num_entries));
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}


/******************************************************************************
 * Public functions
 */

int
xgs_ltsw_uft_init(int unit)
{
    hash_uft_dev_info_t *dev_info = &xgs_ltsw_uft_dev_info[unit];

    SHR_FUNC_ENTER(unit);

    if (!bcmi_ltsw_dev_exists(unit)) {
        SHR_ERR_EXIT(SHR_E_UNIT);
    }

    if (dev_info->inited == TRUE) {
        hash_uft_info_cleanup(unit);
    }

    SHR_IF_ERR_EXIT
        (bcmint_uft_var_db_get(unit, &uft_var_db[unit]));

    SHR_IF_ERR_EXIT
        (hash_uft_info_init(unit));

    if (bcmi_warmboot_get(unit)) {
        dev_info->inited = TRUE;
        SHR_EXIT();
    }

    SHR_IF_ERR_EXIT
        (hash_uft_banks_enable(unit));
    SHR_IF_ERR_EXIT
        (hash_uft_table_move_depth_init(unit));
    SHR_IF_ERR_EXIT
        (hash_uft_table_max_entries_init(unit));
    SHR_IF_ERR_EXIT
        (hash_uft_table_robust_init(unit));

    dev_info->inited = TRUE;

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_uft_detach(int unit)
{
    hash_uft_dev_info_t *dev_info = &xgs_ltsw_uft_dev_info[unit];

    SHR_FUNC_ENTER(unit);

    if (!bcmi_ltsw_dev_exists(unit)) {
        SHR_ERR_EXIT(SHR_E_UNIT);
    }

    if (dev_info->inited == FALSE) {
        SHR_EXIT();
    }

    dev_info->inited = FALSE;

    if (bcmi_warmboot_get(unit)) {
        SHR_EXIT();
    }

    SHR_IF_ERR_EXIT
        (hash_uft_banks_disable(unit));

exit:
    hash_uft_info_cleanup(unit);
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_uft_multi_move_depth_set(
    int unit,
    bcm_switch_control_t type,
    int arg)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmlt_transaction_info_t trans_info;
    bcmlt_transaction_hdl_t trans_hdl = BCMLT_INVALID_HDL;
    bcmlt_field_def_t field_def[2];
    const shr_enum_map_t *move_depth_map = NULL;
    uint32_t num_fields;
    int i = 0, move_depth_map_count = 0;
    bool is_found = FALSE;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_table_field_defs_get(unit, TABLE_EM_CONTROLs, 2, field_def,
                                    &num_fields));
    if ((arg < field_def[0].min) || (arg > field_def[0].max)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_transaction_allocate(BCMLT_TRANS_TYPE_BATCH, &trans_hdl));

    move_depth_map = uft_var_db[unit]->move_depth_map;
    move_depth_map_count = uft_var_db[unit]->move_depth_map_count;
    for (i = 0; i < move_depth_map_count; i++) {
        if (move_depth_map[i].val > type) {
            break;
        }
        if (move_depth_map[i].val == type) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, TABLE_EM_CONTROLs, &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(entry_hdl, TABLE_IDs,
                                              move_depth_map[i].name));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, MOVE_DEPTHs, arg));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_transaction_entry_add(trans_hdl, BCMLT_OPCODE_UPDATE,
                                             entry_hdl));
            entry_hdl = BCMLT_INVALID_HDL;
            is_found = TRUE;
        }
    }

    if (is_found == FALSE) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }
    SHR_IF_ERR_CONT
        (bcmlt_transaction_commit(trans_hdl, BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_transaction_info_get(trans_hdl, &trans_info));
    SHR_ERR_EXIT(trans_info.status);

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    if (trans_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_transaction_free(trans_hdl);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_uft_multi_move_depth_get(
    int unit,
    bcm_switch_control_t type,
    int *arg)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    const shr_enum_map_t *move_depth_map = NULL;
    uint64_t field_val = 0;
    int i = 0, move_depth_map_count = 0;
    bool is_found = FALSE;

    SHR_FUNC_ENTER(unit);

    move_depth_map = uft_var_db[unit]->move_depth_map;
    move_depth_map_count = uft_var_db[unit]->move_depth_map_count;
    for (i = 0; i < move_depth_map_count; i++) {
        if (move_depth_map[i].val > type) {
            break;
        }
        if (move_depth_map[i].val == type) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, TABLE_EM_CONTROLs, &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_symbol_add(entry_hdl, TABLE_IDs,
                                              move_depth_map[i].name));
            is_found = TRUE;
            break;
        }
    }

    if (is_found == FALSE) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_LOOKUP,
                            BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, MOVE_DEPTHs, &field_val));
    *arg = (int)field_val;

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_uft_bank_config_set(
    int unit,
    bcm_switch_hash_table_t hash_table,
    uint32_t bank_num,
    int hash_type,
    uint32_t hash_offset)
{
    hash_uft_dev_info_t *dev_info = &xgs_ltsw_uft_dev_info[unit];
    int offset;

    SHR_FUNC_ENTER(unit);

    if (dev_info->inited != TRUE) {
        SHR_ERR_EXIT(SHR_E_INIT);
    }

    if ((hash_type != BCM_HASH_CRC32L) &&
        (hash_type != BCM_HASH_OFFSET)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (hash_offset > 63) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    offset = hash_offset;

    SHR_IF_ERR_VERBOSE_EXIT
        (hash_bank_offset_set(unit, hash_table, bank_num, offset));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_uft_bank_config_get(
    int unit,
    bcm_switch_hash_table_t hash_table,
    uint32_t bank_num,
    int *hash_type,
    uint32_t *hash_offset)
{
    hash_uft_dev_info_t *dev_info = &xgs_ltsw_uft_dev_info[unit];
    uint32_t offset;
    SHR_FUNC_ENTER(unit);

    if (dev_info->inited != TRUE) {
        SHR_ERR_EXIT(SHR_E_INIT);
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (hash_bank_offset_get(unit, hash_table, bank_num, &offset));

     /* All tables in TH3 use CRC-32 with Robust Hash*/
    *hash_type = BCM_HASH_CRC32L;
    *hash_offset = offset;

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_uft_bank_max_get(
    int unit,
    bcm_switch_hash_table_t hash_table,
    uint32_t *bank_count)
{
    int num_banks = 0;

    SHR_FUNC_ENTER(unit);

    if ((hash_table != bcmHashTableL2) &&
        (hash_table != bcmHashTableExactMatch) &&
        (hash_table != bcmHashTableL3Tunnel) &&
        (hash_table != bcmHashTableMPLS)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (hash_uft_group_bank_num_get(unit, hash_table, &num_banks));

    *bank_count = num_banks;

exit:
    SHR_FUNC_EXIT();

}

