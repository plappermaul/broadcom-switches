/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/types.h>
#include <bcm/switch.h>
#include <bcm_int/control.h>
#include <bcm_int/ltsw_dispatch.h>

#include <bcm_int/ltsw/xgs/ecn.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/cosq.h>
#include <bcm_int/ltsw/port.h>
#include <bcm_int/ltsw/ecn.h>
#include <bcm_int/ltsw/ecn_int.h>
#include <bcm_int/ltsw/qos.h>
#include <bcm_int/ltsw/ha.h>
#include <bcm_int/ltsw/profile_mgmt.h>
#include <bcm_int/ltsw/feature.h>

#include <shr/shr_bitop.h>
#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_COSQ

/******************************************************************************
 * Private functions
 */


/* Entry number per set. */
#define XGS_ECN_ING_MPLS_EXP_TO_ECN_ENTRIES_PER_SET       32
#define XGS_ECN_EGR_ECN_TO_MPLS_EXP_ENTRIES_PER_SET       32
#define XGS_ECN_EGR_INT_CN_TO_MPLS_EXP_ENTRIES_PER_SET    32
#define XGS_ECN_ING_TUNNEL_ECN_TERM_ENTRIES_PER_SET       16
#define XGS_ECN_EGR_TUNNEL_IP_PAYLOAD_ENTRIES_PER_SET     4
#define XGS_ECN_EGR_TUNNEL_NON_IP_PAYLOAD_ENTRIES_PER_SET 1
#define XGS_ECN_EGR_LATENCY_ENTRIES_PER_SET               12

/* Internal Congestion Action Values */
#define BCMI_ECN_INT_CN_RESPONSIVE_DROP                   (0x0)
#define BCMI_ECN_INT_CN_NON_RESPONSIVE_DROP               (0x1)
#define BCMI_ECN_INT_CN_NON_CONGESTION_MARK_ECN           (0x2)
#define BCMI_ECN_INT_CN_CONGESTION_MARK_ECN               (0x3)

#define BCMI_ECN_ENCAP_ENTRIES   4


/*
 * \brief ECN map type. Note every new enum must be put following the last valid one.
 */
typedef enum ecn_xgs_map_type_s {

    /* Map MPLS ingress map. */
    EcnMapTypeMplsIngress = 0,

    /* Map MPLS egress map. */
    /* 2 LTs ECN_IP_TO_MPLS_EXP_RESPONSIVE/NON_RESPONSIVE share one PT. */
    EcnMapTypeMplsEgress = 1,

    /* Map MPLS egress map from int_cn. */
    EcnMapTypeMplsEgressIntCn = 2,

    /* Map Tunnel ingress map. */
    EcnMapTypeTunnelIngress = 3,

    /* Map Tunnel ingress map. */
    EcnMapTypeTunnelEgressIPPayload = 4,

    /* Map Tunnel ingress map. */
    EcnMapTypeTunnelEgressNonIPPayload = 5,

    /* Map Latency egress map. */
    EcnMapTypeLatencyEgress = 6,

    /* The count of map type, must be the last. */
    EcnMapTypeCount = 7

} ecn_xgs_map_type_t;


typedef struct xgs_ecn_bookkeeping_s {
    /* ECN map id usage bitmap. */
    SHR_BITDCL *bmp[EcnMapTypeCount];

} xgs_ecn_bookkeeping_t;

static const int ecn_map_max_entries[EcnMapTypeCount] = {
    [EcnMapTypeMplsIngress]     = XGS_ECN_ING_MPLS_EXP_TO_ECN_ENTRIES_PER_SET,
    [EcnMapTypeMplsEgress]      = XGS_ECN_EGR_ECN_TO_MPLS_EXP_ENTRIES_PER_SET,
    [EcnMapTypeMplsEgressIntCn] = XGS_ECN_EGR_INT_CN_TO_MPLS_EXP_ENTRIES_PER_SET,
    [EcnMapTypeTunnelIngress]   = XGS_ECN_ING_TUNNEL_ECN_TERM_ENTRIES_PER_SET,
    [EcnMapTypeTunnelEgressIPPayload]    = XGS_ECN_EGR_TUNNEL_IP_PAYLOAD_ENTRIES_PER_SET,
    [EcnMapTypeTunnelEgressNonIPPayload] = XGS_ECN_EGR_TUNNEL_NON_IP_PAYLOAD_ENTRIES_PER_SET,
    [EcnMapTypeLatencyEgress]            = XGS_ECN_EGR_LATENCY_ENTRIES_PER_SET,
};

static const char* ecn_map_tab[EcnMapTypeCount] = {
    [EcnMapTypeMplsIngress]     = ECN_MPLS_EXP_TO_IP_ECNs,
    [EcnMapTypeMplsEgress]      = ECN_IP_TO_MPLS_EXP_RESPONSIVEs,
    [EcnMapTypeMplsEgressIntCn] = ECN_CNG_TO_MPLS_EXPs,
    [EcnMapTypeTunnelIngress]   = ECN_TNL_DECAP_IP_PAYLOADs,
    [EcnMapTypeTunnelEgressIPPayload]    = ECN_TNL_ENCAP_IP_PAYLOADs,
    [EcnMapTypeTunnelEgressNonIPPayload] = ECN_TNL_ENCAP_NON_IP_PAYLOADs,
    [EcnMapTypeLatencyEgress]            = ECN_LATENCY_PROFILEs,
};

typedef struct ecn_map_config_s {
    const char *id;
    int key1_shift;
    const char *key1;
    int key2_mask;
    const char *key2;
} ecn_map_config_t;

static ecn_map_config_t ecn_map_config[EcnMapTypeCount] = {
    [EcnMapTypeMplsIngress]     = {ECN_MPLS_EXP_TO_IP_ECN_IDs, 3, LAST_DERIVED_ECNs, 7, EXPs},
    [EcnMapTypeMplsEgress]      = {ECN_IP_TO_MPLS_EXP_RESPONSIVE_IDs, 2, EXPs, 3, ECNs},
    [EcnMapTypeMplsEgressIntCn] = {ECN_CNG_TO_MPLS_EXP_IDs, 2, EXPs, 3, INT_ECN_CNGs},
    [EcnMapTypeTunnelIngress]   = {ECN_TNL_DECAP_IP_PAYLOAD_IDs, 2, TNL_ECNs, 3, PAYLOAD_ECNs},
    [EcnMapTypeTunnelEgressIPPayload]    = {ECN_TNL_ENCAP_IP_PAYLOAD_IDs, 0, NULL, 3, PAYLOAD_ECNs},
    [EcnMapTypeTunnelEgressNonIPPayload] = {ECN_TNL_ENCAP_NON_IP_PAYLOAD_IDs, 0, NULL, 0, NULL},
    [EcnMapTypeLatencyEgress]            = {ECN_LATENCY_PROFILE_IDs, 0, NULL, 15, MMU_QUEUE_NUMs},
};

#define cng_num 4
static const int default_cng_action[cng_num] = {
    BCMI_ECN_INT_CN_RESPONSIVE_DROP,
    BCMI_ECN_INT_CN_NON_RESPONSIVE_DROP,
    BCMI_ECN_INT_CN_NON_CONGESTION_MARK_ECN,
    BCMI_ECN_INT_CN_NON_RESPONSIVE_DROP,
};
static xgs_ecn_bookkeeping_t xgs_ecn_bookkeeping[BCM_MAX_NUM_UNITS];

#define XGS_ECN_BK(unit) (&xgs_ecn_bookkeeping[unit])

#define XGS_ECN_MAP_BITMAP(unit, type) \
            (XGS_ECN_BK(unit)->bmp[type])
#define XGS_ECN_MAP_BITMAP_USED_GET(unit, type, map_id) \
            SHR_BITGET(XGS_ECN_MAP_BITMAP(unit, type), map_id)
#define XGS_ECN_MAP_BITMAP_USED_SET(unit, type, map_id) \
            SHR_BITSET(XGS_ECN_MAP_BITMAP(unit, type), map_id)
#define XGS_ECN_MAP_BITMAP_USED_CLR(unit, type, map_id) \
            SHR_BITCLR(XGS_ECN_MAP_BITMAP(unit, type), map_id)

/* All ECN tables that need to be init. */
#define ECN_INIT_TABLE                \
            ECN_PROTOCOLs,            \
            ECN_IP_TO_CNG_POSTs,      \
            ECN_TNL_ENCAP_IP_TO_CNGs, \
            ECN_CNG_TO_WREDs,         \
            ECN_WRED_UPDATEs,         \
            ECN_CNG_TO_IP_ECNs,       \
            ECN_TNL_ENCAP_IP_PAYLOADs

#define ECN_INIT_TABLE_NUM 7

/* 2-bit payload ECN. */
#define XGS_ECN_MAX_VALUE 3
/* 2-bit int CN. */
#define XGS_INT_CN_MAX_VALUE 3
/* 3-bit INT PRI. */
#define XGS_INT_PRI_MAX_VALUE 15


/*
 * \brief HA sub component id. Note that the value of each macro cannot be changed.
 */
/* Map MPLS ingress map. */
#define ECN_SUBCOMPID_MPLS_ING_USED_BMP 0

/* Map MPLS egress map. */
#define QOS_SUBCOMPID_MPLS_EGR_USED_BMP 1

/* Map MPLS egress map from int_cn. */
#define QOS_SUBCOMPID_MPLS_EGR_INT_CN_USED_BMP 2

/* Map Tunnel ingress map. */
#define QOS_SUBCOMPID_TUNNEL_ING_USED_BMP 3

/* Map Tunnel ingress map. */
#define QOS_SUBCOMPID_TUNNEL_EGR_IP_PAYLOAD_USED_BMP 4

/* Map Tunnel ingress map. */
#define QOS_SUBCOMPID_TUNNEL_EGR_NON_IP_PAYLOAD_USED_BMP 5


/*
 * \brief Initialize ECN database.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
ecn_db_init(int unit)
{
    xgs_ecn_bookkeeping_t *ecn_bk = NULL;
    void *ptr[EcnMapTypeCount];
    int i, map_sz;
    int warm = bcmi_warmboot_get(unit);
    uint32_t alloc_size = 0, req_size = 0, size = 0;

    SHR_FUNC_ENTER(unit);

    ecn_bk = XGS_ECN_BK(unit);

    /* Init local variable. */
    for (i = 0; i < EcnMapTypeCount; i++) {
        ptr[i] = NULL;
    }

    /* Init QoS map used bitmap. */
    for (i = 0; i < EcnMapTypeCount; i++) {

        /* Allocate HA memory for used bitmap. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_capacity_get(unit, ecn_map_tab[i], &size));
        map_sz = size / ecn_map_max_entries[i];
        req_size = SHR_BITALLOCSIZE(map_sz);
        alloc_size = req_size;
        ptr[i] = bcmi_ltsw_ha_mem_alloc(unit,
                                        BCMI_HA_COMP_ID_ECN,
                                        ECN_SUBCOMPID_MPLS_ING_USED_BMP + i,
                                        "bcmEcnMapTypeMplsIngress",
                                        &alloc_size);

        SHR_NULL_CHECK(ptr[i], SHR_E_MEMORY);
        SHR_IF_ERR_VERBOSE_EXIT
            ((alloc_size < req_size) ? SHR_E_MEMORY : SHR_E_NONE);
        ecn_bk->bmp[i] = ptr[i];

        if (!warm) {
            sal_memset(ptr[i], 0, alloc_size);
        }
    }

exit:
    if (SHR_FUNC_ERR()) {
        if (!warm) {
            for (i = 0; i < EcnMapTypeCount; i++) {
                if (ptr[i] != NULL) {
                    (void)bcmi_ltsw_ha_mem_free(unit, ptr[i]);
                    ecn_bk->bmp[i] = NULL;
                }
            }
        }
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Init ECN table.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ecn_table_init(int unit)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmlt_transaction_hdl_t trans_hdl = BCMLT_INVALID_HDL;
    int id, i, j, k, cng;
    uint64_t index_min = 0, int_cn_max = 0, tm_max = 0, cng_max = 0;
    uint32_t count, id_count;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_transaction_allocate(BCMLT_TRANS_TYPE_BATCH, &trans_hdl));

    /* Default value for ECN_PROTOCOL. */
    /* Set TCP(0x6) to 1 */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ECN_PROTOCOLs, &entry_hdl));
    id = 6;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, IP_PROTOs, id));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, RESPONSIVEs, 1));
    /* Add entry into transaction. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_transaction_entry_add(trans_hdl, BCMLT_OPCODE_INSERT,
                                     entry_hdl));
    entry_hdl = BCMLT_INVALID_HDL;

    /* Set UDP(0x11) to 0 */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ECN_PROTOCOLs, &entry_hdl));
    id = 0x11;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, IP_PROTOs, id));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, RESPONSIVEs, 0));
    /* Add entry into transaction. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_transaction_entry_add(trans_hdl, BCMLT_OPCODE_INSERT,
                                     entry_hdl));
    entry_hdl = BCMLT_INVALID_HDL;

    /*
     * ECN_IP_TO_CNG_POST / ECN_TNL_ENCAP_IP_TO_CNG table
        Address (ID) : (ECN + responsive)  :     INT_CN
                   0                    0         2'b01
                   0                    1         2'b00
                   0                    2         2'b10
                   0                    3         2'b10
                   0                    4         2'b10
                   0                    5         2'b10
                   0                    6         2'b11
                   0                    7         2'b11
     */

     /*
      * Default value of buffer-ECN entries of ECN_IP_TO_CNG_POST
      * (the first 8 entries).
      */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_capacity_get(unit, ECN_IP_TO_CNG_POSTs, &count));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_width_get(unit, ECN_IP_TO_CNG_POSTs,
                                 ECN_IP_TO_CNG_IDs, &id_count));
    for (i = 0; i < id_count; i++) {
        count /= 2;
    }
    for (i = 0; i < count; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, ECN_IP_TO_CNG_POSTs, &entry_hdl));
        switch (i) {
            case 0:
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(
                        entry_hdl, INT_ECN_CNGs,
                        BCMI_ECN_INT_CN_NON_RESPONSIVE_DROP));
                break;
            case 1:
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(
                        entry_hdl, INT_ECN_CNGs,
                        BCMI_ECN_INT_CN_RESPONSIVE_DROP));
                break;
            case 6:
            case 7:
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(
                        entry_hdl, INT_ECN_CNGs,
                        BCMI_ECN_INT_CN_CONGESTION_MARK_ECN));
                break;
            default:
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(
                        entry_hdl, INT_ECN_CNGs,
                        BCMI_ECN_INT_CN_NON_CONGESTION_MARK_ECN));
                break;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, ECN_IP_TO_CNG_IDs, 0));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, ECNs, (i >> 1)));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, RESPONSIVEs, (i & 1)));
        /* Add entry into transaction. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_transaction_entry_add(trans_hdl, BCMLT_OPCODE_INSERT,
                                         entry_hdl));
        entry_hdl = BCMLT_INVALID_HDL;
    }

    /* Default value for ECN_TNL_ENCAP_IP_TO_CNG. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_capacity_get(unit, ECN_TNL_ENCAP_IP_TO_CNGs, &count));

    for (i = 0; i < count; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, ECN_TNL_ENCAP_IP_TO_CNGs, &entry_hdl));
        switch (i) {
            case 0:
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(
                        entry_hdl, INT_ECN_CNGs,
                        BCMI_ECN_INT_CN_NON_RESPONSIVE_DROP));
                break;
            case 1:
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(
                        entry_hdl, INT_ECN_CNGs,
                        BCMI_ECN_INT_CN_RESPONSIVE_DROP));
                break;
            case 6:
            case 7:
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(
                        entry_hdl, INT_ECN_CNGs,
                        BCMI_ECN_INT_CN_CONGESTION_MARK_ECN));
                break;
            default:
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(
                        entry_hdl, INT_ECN_CNGs,
                        BCMI_ECN_INT_CN_NON_CONGESTION_MARK_ECN));
                break;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, TNL_ECNs, (i >> 1)));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, RESPONSIVEs, (i & 1)));
        /* Add entry into transaction. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_transaction_entry_add(trans_hdl, BCMLT_OPCODE_INSERT,
                                         entry_hdl));
        entry_hdl = BCMLT_INVALID_HDL;
    }

    /* Default value for ECN_CNG_TO_WRED. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_capacity_get(unit, ECN_CNG_TO_WREDs, &count));
    for (i = 0; i < count; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, ECN_CNG_TO_WREDs, &entry_hdl));
        switch (i) {
            case BCMI_ECN_INT_CN_RESPONSIVE_DROP:
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, RESPONSIVEs, 1));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, MARKs, 0));
                break;
            case BCMI_ECN_INT_CN_NON_RESPONSIVE_DROP:
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, RESPONSIVEs, 0));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, MARKs, 0));
                break;
            case BCMI_ECN_INT_CN_CONGESTION_MARK_ECN:
            case BCMI_ECN_INT_CN_NON_CONGESTION_MARK_ECN:
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, RESPONSIVEs, 1));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, MARKs, 1));
                break;
            default:
                break;
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, INT_ECN_CNGs, i));
        /* Add entry into transaction. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_transaction_entry_add(trans_hdl, BCMLT_OPCODE_INSERT,
                                         entry_hdl));
        entry_hdl = BCMLT_INVALID_HDL;
    }

    /* Default value for ECN_WRED_UPDATE. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, ECN_WRED_UPDATEs, INT_ECN_CNGs,
                                 &index_min, &int_cn_max));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, ECN_WRED_UPDATEs, TM_CONGESTIONs,
                                 &index_min, &tm_max));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit, ECN_WRED_UPDATEs, PACKET_CNGs,
                                 &index_min, &cng_max));
    for (k = 0; k <= cng_max; k++) {
        if ((k != bcmColorGreen) &&
            (k != bcmColorYellow) &&
            (k != bcmColorRed)) {
            continue;
        }
        cng = BCMI_LTSW_QOS_COLOR_ENCODING(k);
        for (j = 0; j <= tm_max; j++) {
            for (i = 0; i <= int_cn_max; i++) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(dunit, ECN_WRED_UPDATEs, &entry_hdl));
                if (i != 2) {
                    /* INT_ECN_CNG != 2 */
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_add(entry_hdl, INT_ECN_CNGs, i));
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_add(entry_hdl, TM_CONGESTIONs, j));
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_add(entry_hdl, PACKET_CNGs, cng));
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_add(entry_hdl,
                                               NEW_INT_ECN_CNGs,
                                               default_cng_action[i]));
                } else {
                    /* INT_ECN_CNG == 2 */
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_add(entry_hdl, INT_ECN_CNGs, i));
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_add(entry_hdl, TM_CONGESTIONs, j));
                    SHR_IF_ERR_VERBOSE_EXIT
                        (bcmlt_entry_field_add(entry_hdl, PACKET_CNGs, cng));
                    /* Change the INT_ECN_CNG to 3 if local TM_CONGESTION is congested */
                    if (j == 1) {
                        SHR_IF_ERR_VERBOSE_EXIT
                            (bcmlt_entry_field_add(
                                entry_hdl, NEW_INT_ECN_CNGs,
                                BCMI_ECN_INT_CN_CONGESTION_MARK_ECN));
                        SHR_IF_ERR_VERBOSE_EXIT
                            (bcmlt_entry_field_add(entry_hdl,
                                                   CONGESTION_MARKEDs,1));
                    } else {
                        SHR_IF_ERR_VERBOSE_EXIT
                            (bcmlt_entry_field_add(
                                entry_hdl, NEW_INT_ECN_CNGs,
                                BCMI_ECN_INT_CN_NON_CONGESTION_MARK_ECN));
                    }
                }
                /* Add entry into transaction. */
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_transaction_entry_add(trans_hdl, BCMLT_OPCODE_INSERT,
                                                 entry_hdl));
                entry_hdl = BCMLT_INVALID_HDL;
            }
        }
    }
    /* Default value for ECN_CNG_TO_IP_ECN. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ECN_CNG_TO_IP_ECNs, &entry_hdl));

    /* Change the PAYLOAD_ECN value from 2'b01 to 2'b11 for INT_ECN_CNG is 3 */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, PAYLOAD_ECNs, 1));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, INT_ECN_CNGs, 3));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, CHANGE_PAYLOAD_ECNs, 1));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, NEW_PAYLOAD_ECNs, 3));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, CTR_ECNs, 1));

    /* Add entry into transaction. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_transaction_entry_add(trans_hdl, BCMLT_OPCODE_INSERT,
                                     entry_hdl));
    entry_hdl = BCMLT_INVALID_HDL;

    /* Change the PAYLOAD_ECN value from 2'b10 to 2'b11 for INT_ECN_CNG is 3 */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ECN_CNG_TO_IP_ECNs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, PAYLOAD_ECNs, 3));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, INT_ECN_CNGs, 3));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, CHANGE_PAYLOAD_ECNs, 1));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, NEW_PAYLOAD_ECNs, 3));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, CTR_ECNs, 1));

    /* Add entry into transaction. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_transaction_entry_add(trans_hdl, BCMLT_OPCODE_INSERT,
                                     entry_hdl));
    entry_hdl = BCMLT_INVALID_HDL;

    /* Default value for ECN_TNL_ENCAP_IP_PAYLOAD . */
    for (i = 0; i < BCMI_ECN_ENCAP_ENTRIES; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, ECN_TNL_ENCAP_IP_PAYLOADs,
                                  &entry_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, ECN_TNL_ENCAP_IP_PAYLOAD_IDs, 0));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, PAYLOAD_ECNs, i));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, TNL_ECNs, i));
        /* Add entry into transaction. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_transaction_entry_add(trans_hdl, BCMLT_OPCODE_INSERT,
                                         entry_hdl));
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_transaction_commit(unit, trans_hdl, BCMLT_PRIORITY_NORMAL));

    /*
     * Configure the int_cn of Non-IP packets to Non-Responsive Dropping.
     */
    BCM_IF_ERROR_RETURN(
        bcm_ltsw_switch_control_set(unit,
                               bcmSwitchEcnNonIpIntCongestionNotification,
                               BCMI_ECN_INT_CN_NON_RESPONSIVE_DROP));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    if (trans_hdl != BCMLT_INVALID_HDL) {
        bcmlt_transaction_free(trans_hdl);
    }
    SHR_FUNC_EXIT();
}

/*!
 * \brief Clear ECN table.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
static int
ecn_table_clear_all(int unit)
{
    int i;
    const char *table[] = {ECN_INIT_TABLE};

    SHR_FUNC_ENTER(unit);

    for (i = 0; i < ECN_INIT_TABLE_NUM; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_clear(unit, table[i]));
    }

exit:
    SHR_FUNC_EXIT();

}

static int
ecn_map_id_to_internal_map_type(int unit,
                                int ecn_map_id,
                                ecn_xgs_map_type_t *xgs_ecn_type)
{
    int ecn_map_type;

    SHR_FUNC_ENTER(unit);

    ecn_map_type = (ecn_map_id) & BCMINT_ECN_MAP_TYPE_MASK;
    switch (ecn_map_type) {
        case BCMI_LTSW_ECN_MPLS_ECN_MAP_TYPE_EXP2ECN:
            *xgs_ecn_type = EcnMapTypeMplsIngress;
            break;
        case BCMI_LTSW_ECN_MPLS_ECN_MAP_TYPE_ECN2EXP:
            *xgs_ecn_type = EcnMapTypeMplsEgress;
            break;
        case BCMI_LTSW_ECN_MPLS_ECN_MAP_TYPE_INTCN2EXP:
            *xgs_ecn_type = EcnMapTypeMplsEgressIntCn;
            break;
        case BCMI_LTSW_ECN_TUNNEL_ECN_MAP_TYPE_TERM:
            *xgs_ecn_type = EcnMapTypeTunnelIngress;
            break;
        case BCMI_LTSW_ECN_TUNNEL_ECN_MAP_TYPE_INIT_IP_PAYLOAD:
            *xgs_ecn_type = EcnMapTypeTunnelEgressIPPayload;
            break;
        case BCMI_LTSW_ECN_TUNNEL_ECN_MAP_TYPE_INIT_NON_IP_PAYLOAD:
            *xgs_ecn_type = EcnMapTypeTunnelEgressNonIPPayload;
            break;
        case BCMI_LTSW_ECN_LATENCY_ECN_MAP_TYPE:
            *xgs_ecn_type = EcnMapTypeLatencyEgress;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}


static int
ecn_flags_to_map_type(int unit,
                      int flags,
                      ecn_xgs_map_type_t *xgs_ecn_type,
                      int *ecn_map_type)
{

    SHR_FUNC_ENTER(unit);

    if ((flags & BCM_ECN_MAP_MPLS) && (flags & BCM_ECN_MAP_INGRESS)) {
        *xgs_ecn_type = EcnMapTypeMplsIngress;
        *ecn_map_type = BCMI_LTSW_ECN_MPLS_ECN_MAP_TYPE_EXP2ECN;
    } else if ((flags & BCM_ECN_MAP_MPLS) && (flags & BCM_ECN_MAP_EGRESS)) {
        *xgs_ecn_type = EcnMapTypeMplsEgress;
        *ecn_map_type = BCMI_LTSW_ECN_MPLS_ECN_MAP_TYPE_ECN2EXP;
    } else if ((flags & BCM_ECN_MAP_MPLS_INT_CN_TO_EXP) &&
        (flags & BCM_ECN_MAP_EGRESS)) {
        *xgs_ecn_type = EcnMapTypeMplsEgressIntCn;
        *ecn_map_type = BCMI_LTSW_ECN_MPLS_ECN_MAP_TYPE_INTCN2EXP;
    } else if ((flags & BCM_ECN_MAP_TUNNEL_TERM) &&
        (flags & BCM_ECN_MAP_INGRESS)) {
        *xgs_ecn_type = EcnMapTypeTunnelIngress;
        *ecn_map_type = BCMI_LTSW_ECN_TUNNEL_ECN_MAP_TYPE_TERM;
    } else if ((flags & BCM_ECN_MAP_TUNNEL_INIT_IP_PAYLOAD) &&
        (flags & BCM_ECN_MAP_EGRESS)) {
        *xgs_ecn_type = EcnMapTypeTunnelEgressIPPayload;
        *ecn_map_type = BCMI_LTSW_ECN_TUNNEL_ECN_MAP_TYPE_INIT_IP_PAYLOAD;
    } else if ((flags & BCM_ECN_MAP_TUNNEL_INIT_NON_IP_PAYLOAD) &&
        (flags & BCM_ECN_MAP_EGRESS)) {
        *xgs_ecn_type = EcnMapTypeTunnelEgressNonIPPayload;
        *ecn_map_type = BCMI_LTSW_ECN_TUNNEL_ECN_MAP_TYPE_INIT_NON_IP_PAYLOAD;
    } else if ((flags & BCM_ECN_MAP_LATENCY_ECN) &&
        (flags & BCM_ECN_MAP_EGRESS)) {
        *xgs_ecn_type = EcnMapTypeLatencyEgress;
        *ecn_map_type = BCMI_LTSW_ECN_LATENCY_ECN_MAP_TYPE;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
exit:
    SHR_FUNC_EXIT();
}

static int
ecn_map_type_local_to_external(int unit,
                               ecn_xgs_map_type_t xgs_ecn_type,
                               int *ecn_map_type)
{
    SHR_FUNC_ENTER(unit);

    if (xgs_ecn_type == EcnMapTypeMplsIngress) {
        *ecn_map_type = BCMI_LTSW_ECN_MPLS_ECN_MAP_TYPE_EXP2ECN;
    } else if (xgs_ecn_type == EcnMapTypeMplsEgress) {
        *ecn_map_type = BCMI_LTSW_ECN_MPLS_ECN_MAP_TYPE_ECN2EXP;
    } else if (xgs_ecn_type == EcnMapTypeMplsEgressIntCn) {
        *ecn_map_type = BCMI_LTSW_ECN_MPLS_ECN_MAP_TYPE_INTCN2EXP;
    } else if (xgs_ecn_type == EcnMapTypeTunnelIngress) {
        *ecn_map_type = BCMI_LTSW_ECN_TUNNEL_ECN_MAP_TYPE_TERM;
    } else if (xgs_ecn_type == EcnMapTypeTunnelEgressIPPayload) {
        *ecn_map_type = BCMI_LTSW_ECN_TUNNEL_ECN_MAP_TYPE_INIT_IP_PAYLOAD;
    } else if (xgs_ecn_type == EcnMapTypeTunnelEgressNonIPPayload) {
        *ecn_map_type = BCMI_LTSW_ECN_TUNNEL_ECN_MAP_TYPE_INIT_NON_IP_PAYLOAD;
    } else if (xgs_ecn_type == EcnMapTypeLatencyEgress) {
        *ecn_map_type = BCMI_LTSW_ECN_LATENCY_ECN_MAP_TYPE;
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
exit:
    SHR_FUNC_EXIT();
}

static int
ecn_map_param_check(int unit,
                    bcm_ecn_map_t *ecn_map)
{

    SHR_FUNC_ENTER(unit);

    if ((ecn_map->ecn > 3) || (ecn_map->exp > 7) || (ecn_map->new_ecn > 3) ||
        (ecn_map->int_cn > 3) || (ecn_map->new_exp > 7) ||
        (ecn_map->inner_ecn > 3) || (ecn_map->int_cn < 0) ||
        (ecn_map->new_int_cn < 0)) {
        SHR_ERR_EXIT(BCM_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}


static int
ecn_map_id_check(int unit,
                    int ecn_map_id,
                    int *map_id)
{
    ecn_xgs_map_type_t xgs_ecn_type;
    int map_num;
    uint32_t size;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ecn_map_id_to_internal_map_type(unit, ecn_map_id, &xgs_ecn_type));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_capacity_get(unit, ecn_map_tab[xgs_ecn_type], &size));
    map_num = size / ecn_map_max_entries[xgs_ecn_type];
    *map_id = (ecn_map_id) & BCMINT_ECN_MAP_ID_MASK;

    if (*map_id >= map_num) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
exit:
    SHR_FUNC_EXIT();
}


/******************************************************************************
 * Public functions
 */

int
xgs_ltsw_ecn_deinit(int unit)
{
    return SHR_E_NONE;
}

int
xgs_ltsw_ecn_init(int unit)
{
    int warm = bcmi_warmboot_get(unit);
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ecn_db_init(unit));

    if (!warm) {
        SHR_IF_ERR_VERBOSE_EXIT
            (ecn_table_clear_all(unit));
        SHR_IF_ERR_VERBOSE_EXIT
            (ecn_table_init(unit));
    }

exit:
    SHR_FUNC_EXIT();

}

int
xgs_ltsw_ecn_map_create(
    int unit,
    uint32_t flags,
    int *ecn_map_id)
{
    ecn_xgs_map_type_t xgs_ecn_type;
    int ecn_map_type, dual = 0;
    int map_num, map_id, i, shift, mask;
    uint32_t size;
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int rv = SHR_E_NONE;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(ecn_map_id, SHR_E_PARAM);

    /* Manging the ecn sw data base. */
    if (flags & BCM_ECN_MAP_WITH_ID) {
        SHR_IF_ERR_VERBOSE_EXIT
            (ecn_map_id_to_internal_map_type(unit, *ecn_map_id, &xgs_ecn_type));
        SHR_IF_ERR_VERBOSE_EXIT
            (ecn_map_id_check(unit, *ecn_map_id, &map_id));

        if (XGS_ECN_MAP_BITMAP_USED_GET(unit, xgs_ecn_type, map_id)) {
            SHR_ERR_EXIT(SHR_E_EXISTS);
        }
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (ecn_flags_to_map_type(unit, flags, &xgs_ecn_type, &ecn_map_type));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_capacity_get(unit, ecn_map_tab[xgs_ecn_type], &size));
        map_num = size / ecn_map_max_entries[xgs_ecn_type];

        for (map_id = 0; map_id < map_num; map_id++) {
            if (!XGS_ECN_MAP_BITMAP_USED_GET(unit, xgs_ecn_type, map_id)) {
                break;
            }
        }

        if (map_id == map_num) {
            SHR_ERR_EXIT(SHR_E_FULL);
        }
        *ecn_map_id = map_id | ecn_map_type;
    }
    /* 2 LT share the same PT with the same ecn_map_type. */
    if (xgs_ecn_type == EcnMapTypeMplsEgress) {
        dual = 1;
    }

    /* Init LT table. */
    shift = ecn_map_config[xgs_ecn_type].key1_shift;
    mask = ecn_map_config[xgs_ecn_type].key2_mask;
    for (i = 0; i < ecn_map_max_entries[xgs_ecn_type]; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(
                dunit, ecn_map_tab[xgs_ecn_type], &entry_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl,
                ecn_map_config[xgs_ecn_type].id, map_id));
        if (ecn_map_config[xgs_ecn_type].key1 != NULL) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl,
                    ecn_map_config[xgs_ecn_type].key1, (i >> shift)));
        }
        if (ecn_map_config[xgs_ecn_type].key2 != NULL) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl,
                    ecn_map_config[xgs_ecn_type].key2, (i & mask)));
        }
        rv = bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_UPDATE,
                                BCMLT_PRIORITY_NORMAL);
        if (rv == SHR_E_NOT_FOUND) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_INSERT,
                                    BCMLT_PRIORITY_NORMAL));
        } else {
            SHR_IF_ERR_VERBOSE_EXIT(rv);
        }

        if (entry_hdl != BCMLT_INVALID_HDL) {
            bcmlt_entry_free(entry_hdl);
            entry_hdl = BCMLT_INVALID_HDL;
        }

        if (dual == 1) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(
                    dunit, ECN_IP_TO_MPLS_EXP_NON_RESPONSIVEs, &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl,
                    ECN_IP_TO_MPLS_EXP_NON_RESPONSIVE_IDs, map_id));
            if (ecn_map_config[xgs_ecn_type].key1 != NULL) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl,
                        ecn_map_config[xgs_ecn_type].key1, (i >> shift)));
            }
            if (ecn_map_config[xgs_ecn_type].key2 != NULL) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl,
                        ecn_map_config[xgs_ecn_type].key2, (i & mask)));
            }

            rv = bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_UPDATE,
                                    BCMLT_PRIORITY_NORMAL);
            if (rv == SHR_E_NOT_FOUND) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_INSERT,
                                        BCMLT_PRIORITY_NORMAL));
            } else {
                SHR_IF_ERR_VERBOSE_EXIT(rv);
            }

            if (entry_hdl != BCMLT_INVALID_HDL) {
                bcmlt_entry_free(entry_hdl);
                entry_hdl = BCMLT_INVALID_HDL;
            }
        }
    }

    XGS_ECN_MAP_BITMAP_USED_SET(unit, xgs_ecn_type, map_id);
exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_ecn_map_destroy(
    int unit,
    int ecn_map_id)
{
    ecn_xgs_map_type_t xgs_ecn_type;
    int map_id, shift, mask, i, dual = 0;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    bcmlt_transaction_hdl_t trans_hdl = BCMLT_INVALID_HDL;
    int dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ecn_map_id_to_internal_map_type(unit, ecn_map_id, &xgs_ecn_type));

    SHR_IF_ERR_VERBOSE_EXIT
        (ecn_map_id_check(unit, ecn_map_id, &map_id));

    if (!XGS_ECN_MAP_BITMAP_USED_GET(unit, xgs_ecn_type, map_id)) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    /* 2 LT share the same PT with the same ecn_map_type. */
    if (xgs_ecn_type == EcnMapTypeMplsEgress) {
        dual = 1;
    }

    /* Delete LT table. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_transaction_allocate(BCMLT_TRANS_TYPE_BATCH, &trans_hdl));
    shift = ecn_map_config[xgs_ecn_type].key1_shift;
    mask = ecn_map_config[xgs_ecn_type].key2_mask;
    for (i = 0; i < ecn_map_max_entries[xgs_ecn_type]; i++) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(
                dunit, ecn_map_tab[xgs_ecn_type], &entry_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl,
                ecn_map_config[xgs_ecn_type].id, map_id));
        if (ecn_map_config[xgs_ecn_type].key1 != NULL) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl,
                    ecn_map_config[xgs_ecn_type].key1, (i >> shift)));
        }
        if (ecn_map_config[xgs_ecn_type].key2 != NULL) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl,
                    ecn_map_config[xgs_ecn_type].key2, (i & mask)));
        }
        /* Add entry into transaction. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_transaction_entry_add(trans_hdl,BCMLT_OPCODE_DELETE,
                                         entry_hdl));
        entry_hdl = BCMLT_INVALID_HDL;

        if (dual == 1) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(
                    dunit, ECN_IP_TO_MPLS_EXP_NON_RESPONSIVEs, &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl,
                    ECN_IP_TO_MPLS_EXP_NON_RESPONSIVE_IDs, map_id));
            if (ecn_map_config[xgs_ecn_type].key1 != NULL) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl,
                        ecn_map_config[xgs_ecn_type].key1, (i >> shift)));
            }
            if (ecn_map_config[xgs_ecn_type].key2 != NULL) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl,
                        ecn_map_config[xgs_ecn_type].key2, (i & mask)));
            }

            /* Add entry into transaction. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_transaction_entry_add(trans_hdl,BCMLT_OPCODE_DELETE,
                                             entry_hdl));
            entry_hdl = BCMLT_INVALID_HDL;
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_transaction_commit(unit, trans_hdl, BCMLT_PRIORITY_NORMAL));

    XGS_ECN_MAP_BITMAP_USED_CLR(unit, xgs_ecn_type, map_id);

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    if (trans_hdl != BCMLT_INVALID_HDL) {
        bcmlt_transaction_free(trans_hdl);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_ecn_map_set(
    int unit,
    uint32_t options,
    int ecn_map_id,
    bcm_ecn_map_t *ecn_map)
{
    ecn_xgs_map_type_t xgs_ecn_type;
    int map_id;
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(ecn_map, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (ecn_map_param_check(unit, ecn_map));

    SHR_IF_ERR_VERBOSE_EXIT
        (ecn_map_id_to_internal_map_type(unit, ecn_map_id, &xgs_ecn_type));
    SHR_IF_ERR_VERBOSE_EXIT
        (ecn_map_id_check(unit, ecn_map_id, &map_id));

    if (!XGS_ECN_MAP_BITMAP_USED_GET(unit, xgs_ecn_type, map_id)) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    switch (xgs_ecn_type) {
        case EcnMapTypeMplsIngress:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(
                    dunit, ECN_MPLS_EXP_TO_IP_ECNs, &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl,
                    ECN_MPLS_EXP_TO_IP_ECN_IDs, map_id));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl,
                    LAST_DERIVED_ECNs, ecn_map->ecn));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, EXPs, ecn_map->exp));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, ECNs, ecn_map->new_ecn));
            /* Drop action */
            if (ecn_map->action_flags & BCM_ECN_TRAFFIC_ACTION_INGRESS_DROP) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, DROPs, 1));
            } else {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, DROPs, 0));
            }
            /* ECN counter enable */
            if (ecn_map->action_flags &
                    BCM_ECN_TRAFFIC_ACTION_ECN_COUNTER_ELIGIBLE) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CTR_ECNs, 1));
            } else {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CTR_ECNs, 0));
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_UPDATE,
                                    BCMLT_PRIORITY_NORMAL));
            break;
        case EcnMapTypeMplsEgress:
            if (ecn_map->action_flags & BCM_ECN_TRAFFIC_ACTION_RESPONSIVE) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(
                        dunit, ECN_IP_TO_MPLS_EXP_RESPONSIVEs, &entry_hdl));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl,
                        ECN_IP_TO_MPLS_EXP_RESPONSIVE_IDs, map_id));
            } else {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(
                        dunit, ECN_IP_TO_MPLS_EXP_NON_RESPONSIVEs, &entry_hdl));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl,
                        ECN_IP_TO_MPLS_EXP_NON_RESPONSIVE_IDs, map_id));
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, ECNs, ecn_map->ecn));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, EXPs, ecn_map->exp));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, NEW_INT_ECN_CNGs,
                                       ecn_map->new_int_cn));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, NEW_EXPs, ecn_map->new_exp));
            /* Drop action */
            if (ecn_map->action_flags & BCM_ECN_TRAFFIC_ACTION_EGRESS_DROP) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, DROPs, 1));
            } else {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, DROPs, 0));
            }
            /* ECN Marking action */
            if (ecn_map->action_flags &
                    BCM_ECN_TRAFFIC_ACTION_EGRESS_EXP_MARKING) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CHANGE_EXPs, 1));
            } else {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CHANGE_EXPs, 0));
            }
            /* INT_CN counter enable */
            if (ecn_map->action_flags &
                    BCM_ECN_TRAFFIC_ACTION_EGRESS_INT_CN_MARKING) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CHANGE_INT_ECN_CNGs, 1));
            } else {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CHANGE_INT_ECN_CNGs, 0));
            }
            /* ECN counter enable */
            if (ecn_map->action_flags &
                    BCM_ECN_TRAFFIC_ACTION_ECN_COUNTER_ELIGIBLE) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CTR_ECNs, 1));
            } else {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CTR_ECNs, 0));
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_UPDATE,
                                    BCMLT_PRIORITY_NORMAL));
            break;
        case EcnMapTypeMplsEgressIntCn:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(
                    dunit, ECN_CNG_TO_MPLS_EXPs, &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl,
                    ECN_CNG_TO_MPLS_EXP_IDs, map_id));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, INT_ECN_CNGs,
                                       ecn_map->int_cn));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, EXPs, ecn_map->exp));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, NEW_EXPs, ecn_map->new_exp));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, NEW_INT_ECN_CNGs,
                                       ecn_map->new_int_cn));
            /* Drop action */
            if (ecn_map->action_flags &
                    BCM_ECN_TRAFFIC_ACTION_EGRESS_DROP) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, DROPs, 1));
            } else {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, DROPs, 0));
            }
            /* ECN Marking action */
            if (ecn_map->action_flags &
                    BCM_ECN_TRAFFIC_ACTION_EGRESS_EXP_MARKING) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CHANGE_EXPs, 1));
            } else {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CHANGE_EXPs, 0));
            }
            /* INT_CN counter enable */
            if (ecn_map->action_flags &
                    BCM_ECN_TRAFFIC_ACTION_EGRESS_INT_CN_MARKING) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CHANGE_INT_ECN_CNGs, 1));
            } else {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CHANGE_INT_ECN_CNGs, 0));
            }
            /* ECN counter enable */
            if (ecn_map->action_flags &
                    BCM_ECN_TRAFFIC_ACTION_ECN_COUNTER_ELIGIBLE) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CTR_ECNs, 1));
            } else {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CTR_ECNs, 0));
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_UPDATE,
                                    BCMLT_PRIORITY_NORMAL));
            break;
        case EcnMapTypeTunnelIngress:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(
                    dunit, ECN_TNL_DECAP_IP_PAYLOADs, &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl,
                    ECN_TNL_DECAP_IP_PAYLOAD_IDs, map_id));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, TNL_ECNs, ecn_map->ecn));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, PAYLOAD_ECNs,
                                       ecn_map->inner_ecn));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, NEW_PAYLOAD_ECNs,
                                       ecn_map->new_ecn));
            /* Drop action */
            if (ecn_map->action_flags & BCM_ECN_TRAFFIC_ACTION_INGRESS_DROP) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, DROPs, 1));
            } else {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, DROPs, 0));
            }
            /* ECN Marking action */
            if (ecn_map->action_flags &
                    BCM_ECN_TRAFFIC_ACTION_INGRESS_ECN_MARKING) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CHANGE_PAYLOAD_ECNs, 1));
            } else {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CHANGE_PAYLOAD_ECNs, 0));
            }
            /* ECN counter enable */
            if (ecn_map->action_flags &
                    BCM_ECN_TRAFFIC_ACTION_ECN_COUNTER_ELIGIBLE) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CTR_ECNs, 1));
            } else {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl, CTR_ECNs, 0));
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_UPDATE,
                                    BCMLT_PRIORITY_NORMAL));
            break;
        case EcnMapTypeTunnelEgressIPPayload:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(
                    dunit, ECN_TNL_ENCAP_IP_PAYLOADs, &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl,
                    ECN_TNL_ENCAP_IP_PAYLOAD_IDs, map_id));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, PAYLOAD_ECNs,
                                       ecn_map->inner_ecn));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, TNL_ECNs, ecn_map->new_ecn));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_UPDATE,
                                    BCMLT_PRIORITY_NORMAL));
            break;
        case EcnMapTypeTunnelEgressNonIPPayload:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(
                    dunit, ECN_TNL_ENCAP_NON_IP_PAYLOADs, &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl,
                    ECN_TNL_ENCAP_NON_IP_PAYLOAD_IDs, map_id));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, TNL_ECNs, ecn_map->new_ecn));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_UPDATE,
                                    BCMLT_PRIORITY_NORMAL));
            break;
        case EcnMapTypeLatencyEgress:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(
                    dunit, ECN_LATENCY_PROFILEs, &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl,
                    ECN_LATENCY_PROFILE_IDs, map_id));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, MMU_QUEUE_NUMs,
                                       ecn_map->mmu_queue_id));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, ENABLEs,
                                       ecn_map->latency_ecn_en));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, THDs,
                                       ecn_map->latency_ecn_threshold));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_UPDATE,
                                    BCMLT_PRIORITY_NORMAL));
            break;
        default:
            SHR_ERR_EXIT(SHR_E_EXISTS);
            break;
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_ecn_map_get(
    int unit,
    int ecn_map_id,
    bcm_ecn_map_t *ecn_map)
{
    int map_id;
    ecn_xgs_map_type_t xgs_ecn_type;
    uint64_t data;
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(ecn_map, SHR_E_PARAM);

    SHR_IF_ERR_VERBOSE_EXIT
        (ecn_map_param_check(unit, ecn_map));

    SHR_IF_ERR_VERBOSE_EXIT
        (ecn_map_id_to_internal_map_type(unit, ecn_map_id, &xgs_ecn_type));
    SHR_IF_ERR_VERBOSE_EXIT
        (ecn_map_id_check(unit, ecn_map_id, &map_id));

    if (!XGS_ECN_MAP_BITMAP_USED_GET(unit, xgs_ecn_type, map_id)) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    switch (xgs_ecn_type) {
        case EcnMapTypeMplsIngress:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(
                    dunit, ECN_MPLS_EXP_TO_IP_ECNs, &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl,
                    ECN_MPLS_EXP_TO_IP_ECN_IDs, map_id));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl,
                    LAST_DERIVED_ECNs, ecn_map->ecn));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, EXPs, ecn_map->exp));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_LOOKUP,
                                    BCMLT_PRIORITY_NORMAL));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, ECNs, &data));
            ecn_map->new_ecn = data;

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, DROPs, &data));
            if (data == 1) {
                ecn_map->action_flags |= BCM_ECN_TRAFFIC_ACTION_INGRESS_DROP;
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, CTR_ECNs, &data));
            if (data == 1) {
                ecn_map->action_flags |=
                    BCM_ECN_TRAFFIC_ACTION_ECN_COUNTER_ELIGIBLE;
            }
            break;
        case EcnMapTypeMplsEgress:
            if (ecn_map->action_flags & BCM_ECN_TRAFFIC_ACTION_RESPONSIVE) {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(
                        dunit, ECN_IP_TO_MPLS_EXP_RESPONSIVEs, &entry_hdl));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl,
                        ECN_IP_TO_MPLS_EXP_RESPONSIVE_IDs, map_id));
            } else {
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_allocate(
                        dunit, ECN_IP_TO_MPLS_EXP_NON_RESPONSIVEs, &entry_hdl));
                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_add(entry_hdl,
                        ECN_IP_TO_MPLS_EXP_NON_RESPONSIVE_IDs, map_id));
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, ECNs, ecn_map->ecn));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, EXPs, ecn_map->exp));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_LOOKUP,
                                    BCMLT_PRIORITY_NORMAL));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, NEW_EXPs, &data));
            ecn_map->new_exp = data;

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, NEW_INT_ECN_CNGs, &data));
            ecn_map->new_int_cn = data;

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, CTR_ECNs, &data));
            if (data == 1) {
                ecn_map->action_flags |=
                    BCM_ECN_TRAFFIC_ACTION_ECN_COUNTER_ELIGIBLE;
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, DROPs, &data));
            if (data == 1) {
                ecn_map->action_flags |= BCM_ECN_TRAFFIC_ACTION_EGRESS_DROP;
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, CHANGE_EXPs, &data));
            if (data == 1) {
                ecn_map->action_flags |=
                    BCM_ECN_TRAFFIC_ACTION_EGRESS_EXP_MARKING;
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, CHANGE_INT_ECN_CNGs, &data));
            if (data == 1) {
                ecn_map->action_flags |=
                    BCM_ECN_TRAFFIC_ACTION_EGRESS_INT_CN_MARKING;
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_UPDATE,
                                    BCMLT_PRIORITY_NORMAL));
            break;
        case EcnMapTypeMplsEgressIntCn:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(
                    dunit, ECN_CNG_TO_MPLS_EXPs, &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl,
                    ECN_CNG_TO_MPLS_EXP_IDs, map_id));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, INT_ECN_CNGs,
                                       ecn_map->int_cn));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, EXPs, ecn_map->exp));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_LOOKUP,
                                    BCMLT_PRIORITY_NORMAL));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, NEW_EXPs, &data));
            ecn_map->new_exp = data;

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, NEW_INT_ECN_CNGs, &data));
            ecn_map->new_int_cn = data;

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, DROPs, &data));
            if (data == 1) {
                ecn_map->action_flags |= BCM_ECN_TRAFFIC_ACTION_EGRESS_DROP;
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, CHANGE_EXPs, &data));
            if (data == 1) {
                ecn_map->action_flags |=
                    BCM_ECN_TRAFFIC_ACTION_EGRESS_EXP_MARKING;
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, CTR_ECNs, &data));
            if (data == 1) {
                ecn_map->action_flags |=
                    BCM_ECN_TRAFFIC_ACTION_ECN_COUNTER_ELIGIBLE;
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, CHANGE_INT_ECN_CNGs, &data));
            if (data == 1) {
                ecn_map->action_flags |=
                    BCM_ECN_TRAFFIC_ACTION_EGRESS_INT_CN_MARKING;
            }
            break;
        case EcnMapTypeTunnelIngress:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(
                    dunit, ECN_TNL_DECAP_IP_PAYLOADs, &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl,
                    ECN_TNL_DECAP_IP_PAYLOAD_IDs, map_id));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, TNL_ECNs, ecn_map->ecn));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, PAYLOAD_ECNs,
                                       ecn_map->inner_ecn));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_LOOKUP,
                                    BCMLT_PRIORITY_NORMAL));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, NEW_PAYLOAD_ECNs, &data));
            ecn_map->new_ecn = data;

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, DROPs, &data));
            if (data == 1) {
                ecn_map->action_flags |= BCM_ECN_TRAFFIC_ACTION_INGRESS_DROP;
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, CHANGE_PAYLOAD_ECNs, &data));
            if (data == 1) {
                ecn_map->action_flags |=
                    BCM_ECN_TRAFFIC_ACTION_INGRESS_ECN_MARKING;
            }

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, CTR_ECNs, &data));
            if (data == 1) {
                ecn_map->action_flags |=
                    BCM_ECN_TRAFFIC_ACTION_ECN_COUNTER_ELIGIBLE;
            }

            break;
        case EcnMapTypeTunnelEgressIPPayload:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(
                    dunit, ECN_TNL_ENCAP_IP_PAYLOADs, &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl,
                    ECN_TNL_ENCAP_IP_PAYLOAD_IDs, map_id));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, PAYLOAD_ECNs,
                                       ecn_map->inner_ecn));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_LOOKUP,
                                    BCMLT_PRIORITY_NORMAL));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, TNL_ECNs, &data));
            ecn_map->new_ecn = data;
            break;
        case EcnMapTypeTunnelEgressNonIPPayload:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(
                    dunit, ECN_TNL_ENCAP_NON_IP_PAYLOADs, &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl,
                    ECN_TNL_ENCAP_NON_IP_PAYLOAD_IDs, map_id));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_LOOKUP,
                                    BCMLT_PRIORITY_NORMAL));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, TNL_ECNs, &data));
            ecn_map->new_ecn = data;
            break;
        case EcnMapTypeLatencyEgress:
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(
                    dunit, ECN_LATENCY_PROFILEs, &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl,
                    ECN_LATENCY_PROFILE_IDs, map_id));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl,
                    MMU_QUEUE_NUMs, ecn_map->mmu_queue_id));

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_LOOKUP,
                                    BCMLT_PRIORITY_NORMAL));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, ENABLEs, &data));
            ecn_map->latency_ecn_en = data;

            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, THDs, &data));
            ecn_map->latency_ecn_threshold = data;
            break;
        default:
            SHR_ERR_EXIT(SHR_E_EXISTS);
            break;
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_ecn_responsive_protocol_set(
    int unit,
    uint8 ip_proto,
    int responsive)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    if (!ltsw_feature(unit, LTSW_FT_ECN_WRED)) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ECN_PROTOCOLs, &entry_hdl));

   SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, IP_PROTOs, ip_proto));
   if (responsive) {
       SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, RESPONSIVEs, 1));
   } else {
       SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, RESPONSIVEs, 0));
   }

    /* Set a entry. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));
exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_ecn_responsive_protocol_get(
    int unit,
    uint8 ip_proto,
    int *responsive)
{
     int dunit = bcmi_ltsw_dev_dunit(unit);
     bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
     uint64_t data;

     SHR_FUNC_ENTER(unit);

     if (!ltsw_feature(unit, LTSW_FT_ECN_WRED)) {
         SHR_ERR_EXIT(SHR_E_UNAVAIL);
     }

     SHR_IF_ERR_VERBOSE_EXIT
         (bcmlt_entry_allocate(dunit, ECN_PROTOCOLs, &entry_hdl));

    SHR_IF_ERR_VERBOSE_EXIT
         (bcmlt_entry_field_add(entry_hdl, IP_PROTOs, ip_proto));
    SHR_IF_ERR_VERBOSE_EXIT
         (bcmlt_entry_commit(entry_hdl, BCMLT_OPCODE_LOOKUP,
                             BCMLT_PRIORITY_NORMAL));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, RESPONSIVEs, &data));

    if (data) {
        *responsive = TRUE;
    } else {
        *responsive = FALSE;
    }

 exit:
     if (entry_hdl != BCMLT_INVALID_HDL) {
         bcmlt_entry_free(entry_hdl);
     }

     SHR_FUNC_EXIT();
}

int
xgs_ltsw_ecn_port_map_get(
    int unit,
    bcm_gport_t port,
    bcm_ecn_port_map_t *ecn_map)
{
    int ecn_map_type;
    int data;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(ecn_map, SHR_E_PARAM);

    ecn_map->ecn_map_id = -1;

    if (BCM_GPORT_IS_SET(port)) {
        if (BCM_GPORT_IS_MODPORT(port)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcm_ltsw_port_local_get(unit, port, &port));
        } else {
            SHR_ERR_EXIT(SHR_E_PORT);
        }
    }

    if (ecn_map->flags == BCM_ECN_EGRESS_PORT_ECN_TO_EXP_MAP) {
        ecn_map_type = BCMI_LTSW_ECN_MPLS_ECN_MAP_TYPE_ECN2EXP;
        /* Not supporting PORT_MODBASE uses port as index directly. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_tab_raw_get(
                unit, port, BCMI_PT_ECN_IP_TO_MPLS_EXP_ID, &data));
        ecn_map->ecn_map_id = data | ecn_map_type;
    } else if (ecn_map->flags == BCM_ECN_EGRESS_PORT_INT_CN_TO_EXP_MAP) {
        ecn_map_type = BCMI_LTSW_ECN_MPLS_ECN_MAP_TYPE_INTCN2EXP;
        /* Not supporting PORT_MODBASE uses port as index directly. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_tab_raw_get(
                unit, port, BCMI_PT_ECN_CNG_TO_MPLS_EXP_ID, &data));
        ecn_map->ecn_map_id = data | ecn_map_type;
    } else if (ecn_map->flags == BCM_ECN_EGRESS_PORT_LATENCY_ECN_MAP) {
        ecn_map_type = BCMI_LTSW_ECN_LATENCY_ECN_MAP_TYPE;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_tab_raw_get(
                unit, port, BCMI_PT_ECN_LATENCY_PROFILE_ID, &data));
        ecn_map->ecn_map_id = data | ecn_map_type;
    }

exit:

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_ecn_port_map_set(
    int unit,
    bcm_gport_t port,
    bcm_ecn_port_map_t *ecn_map)
{
    ecn_xgs_map_type_t xgs_ecn_type;
    int map_id, ecn_map_id;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(ecn_map, SHR_E_PARAM);

    if (BCM_GPORT_IS_SET(port)) {
        if (BCM_GPORT_IS_MODPORT(port)) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcm_ltsw_port_local_get(unit, port, &port));
        } else {
            SHR_ERR_EXIT(SHR_E_PORT);
        }
    }

    ecn_map_id = ecn_map->ecn_map_id;
    SHR_IF_ERR_VERBOSE_EXIT
        (ecn_map_id_to_internal_map_type(unit, ecn_map_id, &xgs_ecn_type));
    SHR_IF_ERR_VERBOSE_EXIT
        (ecn_map_id_check(unit, ecn_map_id, &map_id));

    if (ecn_map->flags == BCM_ECN_EGRESS_PORT_ECN_TO_EXP_MAP) {
        if (xgs_ecn_type != EcnMapTypeMplsEgress) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        /* Not supporting PORT_MODBASE uses port as index directly. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_tab_raw_set(
                unit, port, BCMI_PT_ECN_IP_TO_MPLS_EXP_PRI, 1));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_tab_raw_set(
                unit, port, BCMI_PT_ECN_IP_TO_MPLS_EXP_ID, map_id));
    } else if (ecn_map->flags == BCM_ECN_EGRESS_PORT_INT_CN_TO_EXP_MAP) {
        if (xgs_ecn_type != EcnMapTypeMplsEgressIntCn) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        /* Not supporting PORT_MODBASE uses port as index directly. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_tab_raw_set(
                unit, port, BCMI_PT_ECN_CNG_TO_MPLS_EXP_PRI, 1));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_tab_raw_set(
                unit, port, BCMI_PT_ECN_CNG_TO_MPLS_EXP_ID, map_id));
    } else if (ecn_map->flags == BCM_ECN_EGRESS_PORT_LATENCY_ECN_MAP) {
        if (xgs_ecn_type != EcnMapTypeLatencyEgress) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_tab_raw_set(
                unit, port, BCMI_PT_ECN_LATENCY_PROFILE_ID, map_id));
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_ecn_type_map_get(
    int unit,
    uint32_t flags,
    bcm_ecn_type_map_t *map)
{
    uint64_t data;
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(map, SHR_E_PARAM);

    if ((map->int_pri > XGS_INT_PRI_MAX_VALUE)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (flags & BCM_ECN_TYPE_MAP_INTPRI_TO_MARKINGTYPE) {

        if (!(flags &
            (BCM_ECN_TYPE_MAP_INGRESS_POST_FORWARD_MARKING_TYPE_UPDATE |
            BCM_ECN_TYPE_MAP_INGRESS_PRE_FORWARD_MARKING_TYPE_UPDATE))) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }

        if (flags &
            BCM_ECN_TYPE_MAP_INGRESS_POST_FORWARD_MARKING_TYPE_UPDATE) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, ECN_INT_PRI_TO_CNG_POSTs,
                                      &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, INT_PRIs, map->int_pri));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                                      BCMLT_PRIORITY_NORMAL));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, ECN_IP_TO_CNG_IDs, &data));

            map->ing_post_fwd_marking = data;

            if (entry_hdl != BCMLT_INVALID_HDL) {
                bcmlt_entry_free(entry_hdl);
            }
        }

        if (flags &
                   BCM_ECN_TYPE_MAP_INGRESS_PRE_FORWARD_MARKING_TYPE_UPDATE) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, ECN_INT_PRI_TO_CNG_PREs,
                                      &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, INT_PRIs, map->int_pri));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                                      BCMLT_PRIORITY_NORMAL));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_get(entry_hdl, ECN_IP_TO_CNG_IDs, &data));

            map->ing_pre_fwd_marking = data;

            if (entry_hdl != BCMLT_INVALID_HDL) {
                bcmlt_entry_free(entry_hdl);
            }
        }
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_ecn_type_map_set(
    int unit,
    uint32_t flags,
    bcm_ecn_type_map_t *map)
{
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(map, SHR_E_PARAM);

    if ((map->int_pri > XGS_INT_PRI_MAX_VALUE)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (flags & BCM_ECN_TYPE_MAP_INTPRI_TO_MARKINGTYPE) {

        if (!(flags &
            (BCM_ECN_TYPE_MAP_INGRESS_POST_FORWARD_MARKING_TYPE_UPDATE |
            BCM_ECN_TYPE_MAP_INGRESS_PRE_FORWARD_MARKING_TYPE_UPDATE))) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }

        if (flags &
            BCM_ECN_TYPE_MAP_INGRESS_POST_FORWARD_MARKING_TYPE_UPDATE) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, ECN_INT_PRI_TO_CNG_POSTs,
                                      &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, INT_PRIs, map->int_pri));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, ECN_IP_TO_CNG_IDs,
                                       map->ing_post_fwd_marking));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_set_commit(unit, entry_hdl,
                                          BCMLT_PRIORITY_NORMAL));
            if (entry_hdl != BCMLT_INVALID_HDL) {
                bcmlt_entry_free(entry_hdl);
            }
        }

        if (flags &
                   BCM_ECN_TYPE_MAP_INGRESS_PRE_FORWARD_MARKING_TYPE_UPDATE) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, ECN_INT_PRI_TO_CNG_PREs,
                                      &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, INT_PRIs, map->int_pri));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, ECN_IP_TO_CNG_IDs,
                                       map->ing_pre_fwd_marking));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmi_lt_entry_set_commit(unit, entry_hdl,
                                          BCMLT_PRIORITY_NORMAL));
            if (entry_hdl != BCMLT_INVALID_HDL) {
                bcmlt_entry_free(entry_hdl);
            }
        }
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        bcmlt_entry_free(entry_hdl);
    }

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_ecn_map_id_resolve(
    int unit,
    int ecn_map_id,
    int *ecn_map_type,
    uint32_t *prof_id)
{
    ecn_xgs_map_type_t xgs_ecn_type;
    int map_id;

    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (ecn_map_id_to_internal_map_type(unit, ecn_map_id, &xgs_ecn_type));
    SHR_IF_ERR_VERBOSE_EXIT
        (ecn_map_type_local_to_external(unit, xgs_ecn_type, ecn_map_type));
    SHR_IF_ERR_VERBOSE_EXIT
        (ecn_map_id_check(unit, ecn_map_id, &map_id));
    /* Verify map_id existed. */
    if (!XGS_ECN_MAP_BITMAP_USED_GET(unit, xgs_ecn_type, map_id)) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

    *prof_id = (uint32_t)map_id;
exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_ecn_map_id_construct(
    int unit,
    int ecn_map_type,
    uint32_t prof_id,
    int *ecn_map_id)
{
    int map_id;
    ecn_xgs_map_type_t xgs_ecn_type;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(ecn_map_id, SHR_E_PARAM);

    if (ecn_map_type != (BCMI_LTSW_ECN_TUNNEL_ECN_MAP_TYPE_TERM) &&
        ecn_map_type != (BCMI_LTSW_ECN_MPLS_ECN_MAP_TYPE_EXP2ECN) &&
        ecn_map_type != (BCMI_LTSW_ECN_MPLS_ECN_MAP_TYPE_ECN2EXP) &&
        ecn_map_type != (BCMI_LTSW_ECN_MPLS_ECN_MAP_TYPE_INTCN2EXP) &&
        ecn_map_type != (BCMI_LTSW_ECN_TUNNEL_ECN_MAP_TYPE_INIT_IP_PAYLOAD) &&
        ecn_map_type != (BCMI_LTSW_ECN_TUNNEL_ECN_MAP_TYPE_INIT_NON_IP_PAYLOAD)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    *ecn_map_id = prof_id | ecn_map_type;

    /* Verified whether the input prof_id is within valid range. */
    SHR_IF_ERR_VERBOSE_EXIT
        (ecn_map_id_check(unit, *ecn_map_id, &map_id));

    /* Verify map_id existed. */
    SHR_IF_ERR_VERBOSE_EXIT
        (ecn_map_id_to_internal_map_type(unit, *ecn_map_id, &xgs_ecn_type));
    if (!XGS_ECN_MAP_BITMAP_USED_GET(unit, xgs_ecn_type, map_id)) {
        SHR_ERR_EXIT(SHR_E_NOT_FOUND);
    }

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_ecn_traffic_map_set(
    int unit,
    bcm_ecn_traffic_map_info_t *map)
{
    int dunit, latency, responsive;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(map, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    if ((map->ecn > XGS_ECN_MAX_VALUE) || (map->tunnel_ecn > XGS_ECN_MAX_VALUE)
        || (map->int_cn > XGS_INT_CN_MAX_VALUE) || (map->int_cn < 0)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    if ((map->flags & ~ (BCM_ECN_TRAFFIC_MAP_RESPONSIVE |
        BCM_ECN_TRAFFIC_MAP_LATENCY_ECN)) != 0) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    latency = ((map->flags & BCM_ECN_TRAFFIC_MAP_LATENCY_ECN) ? 1 : 0);
    responsive = ((map->flags & BCM_ECN_TRAFFIC_MAP_RESPONSIVE) ? 1 : 0);

    /* base_ptr (1-bit) | inner_ecn(2-bit) | res.(1-bit). */
    if (map->type == bcmEcnTrafficMapTypeIngressPostForward) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, ECN_IP_TO_CNG_POSTs, &entry_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, ECN_IP_TO_CNG_IDs, latency););
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, RESPONSIVEs, responsive););
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, ECNs, map->ecn););
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, INT_ECN_CNGs, map->int_cn););
    } else if (map->type == bcmEcnTrafficMapTypeIngressPreForward ) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, ECN_IP_TO_CNG_PREs, &entry_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, ECN_IP_TO_CNG_IDs, latency););
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, RESPONSIVEs, responsive););
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, ECNs, map->ecn););
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, INT_ECN_CNGs, map->int_cn););
    }else if (map->type == bcmEcnTrafficMapTypeTunnelInitiator) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, ECN_TNL_ENCAP_IP_TO_CNGs, &entry_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, RESPONSIVEs, responsive););
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, TNL_ECNs, map->tunnel_ecn););
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, INT_ECN_CNGs, map->int_cn););
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_ecn_traffic_map_get(
    int unit,
    bcm_ecn_traffic_map_info_t *map)
{
    int dunit, latency, responsive;
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint64_t data;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(map, SHR_E_PARAM);

    dunit = bcmi_ltsw_dev_dunit(unit);

    if ((map->ecn > XGS_ECN_MAX_VALUE) ||
        (map->tunnel_ecn > XGS_ECN_MAX_VALUE)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }
    if ((map->flags & ~ (BCM_ECN_TRAFFIC_MAP_RESPONSIVE |
        BCM_ECN_TRAFFIC_MAP_LATENCY_ECN)) != 0) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    latency = ((map->flags & BCM_ECN_TRAFFIC_MAP_LATENCY_ECN) ? 1 : 0);
    responsive = ((map->flags & BCM_ECN_TRAFFIC_MAP_RESPONSIVE) ? 1 : 0);

    /* base_ptr (1-bit) | inner_ecn(2-bit) | res.(1-bit). */
    if (map->type == bcmEcnTrafficMapTypeIngressPostForward) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, ECN_IP_TO_CNG_POSTs, &entry_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, ECN_IP_TO_CNG_IDs, latency););
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, RESPONSIVEs, responsive););
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, ECNs, map->ecn););
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                                  BCMLT_PRIORITY_NORMAL));
    } else if (map->type == bcmEcnTrafficMapTypeIngressPreForward) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, ECN_IP_TO_CNG_PREs, &entry_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, ECN_IP_TO_CNG_IDs, latency););
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, RESPONSIVEs, responsive););
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, ECNs, map->ecn););
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                                  BCMLT_PRIORITY_NORMAL));
    }else if (map->type == bcmEcnTrafficMapTypeTunnelInitiator) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_allocate(dunit, ECN_TNL_ENCAP_IP_TO_CNGs, &entry_hdl));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, RESPONSIVEs, responsive););
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, TNL_ECNs, map->tunnel_ecn););
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                                  BCMLT_PRIORITY_NORMAL));
    } else {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, INT_ECN_CNGs, &data));

    map->int_cn = data;

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
        entry_hdl = BCMLT_INVALID_HDL;
    }

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_ecn_action_enqueue_set(
    int unit,
    bcm_ecn_traffic_action_config_t *ecn_config)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t data;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(ecn_config, SHR_E_PARAM);

    if ((ecn_config->int_cn < 0)
        || (ecn_config->int_cn > XGS_INT_CN_MAX_VALUE)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ECN_CNG_TO_WREDs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, INT_ECN_CNGs, ecn_config->int_cn));
    data = (ecn_config->action_flags
            & BCM_ECN_TRAFFIC_ACTION_ENQUEUE_WRED_RESPONSIVE) ? 1 : 0;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, RESPONSIVEs, data));
    data = (ecn_config->action_flags
            & BCM_ECN_TRAFFIC_ACTION_ENQUEUE_MARK_ELIGIBLE) ? 1 : 0;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, MARKs, data));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_ecn_action_enqueue_get(
    int unit,
    bcm_ecn_traffic_action_config_t *ecn_config)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t data;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(ecn_config, SHR_E_PARAM);

    if ((ecn_config->int_cn < 0)
        || (ecn_config->int_cn > XGS_INT_CN_MAX_VALUE)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ECN_CNG_TO_WREDs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, INT_ECN_CNGs, ecn_config->int_cn));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, RESPONSIVEs, &data));
    if (data) {
        ecn_config->action_flags |=
            BCM_ECN_TRAFFIC_ACTION_ENQUEUE_WRED_RESPONSIVE;
    } else {
        ecn_config->action_flags &=
            ~ BCM_ECN_TRAFFIC_ACTION_ENQUEUE_WRED_RESPONSIVE;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, MARKs, &data));
    if (data) {
        ecn_config->action_flags |=
            BCM_ECN_TRAFFIC_ACTION_ENQUEUE_MARK_ELIGIBLE;
    } else {
        ecn_config->action_flags &=
            ~ BCM_ECN_TRAFFIC_ACTION_ENQUEUE_MARK_ELIGIBLE;
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_ecn_action_dequeue_set(
    int unit,
    bcm_ecn_traffic_action_config_t *ecn_config)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint64_t data;
    int cng;
    int dunit;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(ecn_config, SHR_E_PARAM);

    if ((ecn_config->color != bcmColorGreen)
        && (ecn_config->color != bcmColorYellow)
        && (ecn_config->color != bcmColorRed)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if ((ecn_config->int_cn < 0)
        || (ecn_config->int_cn > XGS_INT_CN_MAX_VALUE)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    cng = BCMI_LTSW_QOS_COLOR_ENCODING(ecn_config->color);
    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ECN_WRED_UPDATEs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, INT_ECN_CNGs, ecn_config->int_cn));
    /* Update the int_cn value when congestion is not experienced. */
    /* CE = 0. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, TM_CONGESTIONs, 0));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, PACKET_CNGs, cng));

   if ((ecn_config->action_flags &
        BCM_ECN_TRAFFIC_ACTION_DEQUEUE_NON_CONGESTION_INT_CN_UPDATE) &&
        (ecn_config->non_congested_int_cn != ecn_config->int_cn)) {
        if ((ecn_config->non_congested_int_cn < 0) ||
            (ecn_config->non_congested_int_cn > XGS_INT_CN_MAX_VALUE)) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        data = ecn_config->non_congested_int_cn;
    } else {
        data = ecn_config->int_cn;
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, NEW_INT_ECN_CNGs, data));

    data = ecn_config->responsive ? 1 : 0;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, RESPONSIVEs, data));

    data = ecn_config->congestion_marked ? 1 : 0;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, CONGESTION_MARKEDs, data));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

    /* Update the int_cn value when congestion is experienced. */
    /* CE = 1. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, TM_CONGESTIONs, 1));

   if ((ecn_config->action_flags &
        BCM_ECN_TRAFFIC_ACTION_DEQUEUE_CONGESTION_INT_CN_UPDATE) &&
        (ecn_config->congested_int_cn != ecn_config->int_cn)) {
        if ((ecn_config->congested_int_cn < 0) ||
            (ecn_config->congested_int_cn > XGS_INT_CN_MAX_VALUE)) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        data = ecn_config->congested_int_cn;
    } else {
        data = ecn_config->int_cn;
    }
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, NEW_INT_ECN_CNGs, data));

    data = ecn_config->responsive ? 1 : 0;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, RESPONSIVEs, data));

    data = ecn_config->congestion_marked ? 1 : 0;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, CONGESTION_MARKEDs, data));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_ecn_action_dequeue_get(
    int unit,
    bcm_ecn_traffic_action_config_t *ecn_config)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    uint64_t data;
    int cng;
    int dunit;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(ecn_config, SHR_E_PARAM);

    if ((ecn_config->color != bcmColorGreen)
        && (ecn_config->color != bcmColorYellow)
        && (ecn_config->color != bcmColorRed)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if ((ecn_config->int_cn < 0)
        || (ecn_config->int_cn > XGS_INT_CN_MAX_VALUE)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    cng = BCMI_LTSW_QOS_COLOR_ENCODING(ecn_config->color);
    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ECN_WRED_UPDATEs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, INT_ECN_CNGs, ecn_config->int_cn));
    /* Get the updated int_cn value when congestion is not experienced. */
    /* CE = 0. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, TM_CONGESTIONs, 0));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, PACKET_CNGs, cng));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, NEW_INT_ECN_CNGs, &data));
    if (data != ecn_config->int_cn) {
        ecn_config->action_flags |=
            BCM_ECN_TRAFFIC_ACTION_DEQUEUE_NON_CONGESTION_INT_CN_UPDATE;
        ecn_config->non_congested_int_cn = data;
    } else {
        ecn_config->action_flags &=
            ~ BCM_ECN_TRAFFIC_ACTION_DEQUEUE_NON_CONGESTION_INT_CN_UPDATE;
    }

    /* Get the updated int_cn value when congestion is experienced. */
    /* CE = 1. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, TM_CONGESTIONs, 1));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, NEW_INT_ECN_CNGs, &data));
    if (data != ecn_config->int_cn) {
        ecn_config->action_flags |=
            BCM_ECN_TRAFFIC_ACTION_DEQUEUE_CONGESTION_INT_CN_UPDATE;
        ecn_config->congested_int_cn = data;
    } else {
        ecn_config->action_flags &=
            ~ BCM_ECN_TRAFFIC_ACTION_DEQUEUE_CONGESTION_INT_CN_UPDATE;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, RESPONSIVEs, &data));
    ecn_config->responsive = data;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, CONGESTION_MARKEDs, &data));
    ecn_config->congestion_marked = data;

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_ecn_action_egress_set(
    int unit,
    bcm_ecn_traffic_action_config_t *ecn_config)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(ecn_config, SHR_E_PARAM);

    if ((ecn_config->int_cn < 0)
        || (ecn_config->int_cn > XGS_INT_CN_MAX_VALUE)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if ((ecn_config->ecn > XGS_ECN_MAX_VALUE) || (ecn_config->ecn < 0) ||
        (ecn_config->new_ecn > XGS_ECN_MAX_VALUE) ||
        (ecn_config->new_ecn < 0)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ECN_CNG_TO_IP_ECNs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, INT_ECN_CNGs, ecn_config->int_cn));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, PAYLOAD_ECNs, ecn_config->ecn));

    /* ECN Marking action */
    if (ecn_config->action_flags & BCM_ECN_TRAFFIC_ACTION_EGRESS_ECN_MARKING) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, CHANGE_PAYLOAD_ECNs, 1));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, CTR_ECNs, 1));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, NEW_PAYLOAD_ECNs,
                                   ecn_config->new_ecn));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, CHANGE_PAYLOAD_ECNs, 0));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, CTR_ECNs, 0));
    }

    /* ECN counter enable */
    if (ecn_config->action_flags &
            BCM_ECN_TRAFFIC_ACTION_ECN_COUNTER_ELIGIBLE) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, CTR_ECNs, 1));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, CTR_ECNs, 0));
    }

    /* Drop action */
    if (ecn_config->action_flags & BCM_ECN_TRAFFIC_ACTION_EGRESS_DROP) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, DROPs, 1));
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_add(entry_hdl, DROPs, 0));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_ecn_action_egress_get(
    int unit,
    bcm_ecn_traffic_action_config_t *ecn_config)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t data;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(ecn_config, SHR_E_PARAM);

    if ((ecn_config->int_cn < 0)
        || (ecn_config->int_cn > XGS_INT_CN_MAX_VALUE)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if ((ecn_config->ecn > XGS_ECN_MAX_VALUE) || (ecn_config->ecn < 0)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ECN_CNG_TO_IP_ECNs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, INT_ECN_CNGs, ecn_config->int_cn));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, PAYLOAD_ECNs, ecn_config->ecn));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, CHANGE_PAYLOAD_ECNs, &data));
    if (data) {
        ecn_config->action_flags |=
            BCM_ECN_TRAFFIC_ACTION_EGRESS_ECN_MARKING;
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmlt_entry_field_get(entry_hdl, NEW_PAYLOAD_ECNs, &data));
        ecn_config->new_ecn = data;
    } else {
        ecn_config->action_flags &=
            ~ BCM_ECN_TRAFFIC_ACTION_EGRESS_ECN_MARKING;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, DROPs, &data));
    if (data) {
        ecn_config->action_flags |= BCM_ECN_TRAFFIC_ACTION_EGRESS_DROP;
    } else {
        ecn_config->action_flags &= ~ BCM_ECN_TRAFFIC_ACTION_EGRESS_DROP;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, CTR_ECNs, &data));
    if (data) {
        ecn_config->action_flags |= BCM_ECN_TRAFFIC_ACTION_ECN_COUNTER_ELIGIBLE;
    } else {
        ecn_config->action_flags &=
            ~ BCM_ECN_TRAFFIC_ACTION_ECN_COUNTER_ELIGIBLE;
    }

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_ecn_action_latency_dequeue_set(
    int unit,
    bcm_ecn_traffic_action_config_t *ecn_config)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t data;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(ecn_config, SHR_E_PARAM);

    if ((ecn_config->int_cn < 0)
        || (ecn_config->int_cn > XGS_INT_CN_MAX_VALUE)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if ((ecn_config->latency_int_cn < 0)
        || (ecn_config->latency_int_cn > XGS_INT_CN_MAX_VALUE)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ECN_LATENCY_WRED_UPDATEs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, INT_ECN_CNGs, ecn_config->int_cn));
    data = ecn_config->buffer_high_thd_exceeded ? 1 : 0;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, MAX_THD_EXCEEDs, data));
    data = ecn_config->buffer_low_thd_exceeded ? 1 : 0;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, MIN_THD_EXCEEDs, data));
    data = ecn_config->latency_thd_exceeded ? 1 : 0;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, CE_LATENCYs, data));

    /* Latency INT_CN update. */
    if (ecn_config->action_flags &
            BCM_ECN_TRAFFIC_ACTION_DEQUEUE_LATENCY_INT_CN_UPDATE &&
        (ecn_config->latency_int_cn != ecn_config->int_cn)) {
        data = ecn_config->latency_int_cn;
    } else {
        data = ecn_config->int_cn;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(
            entry_hdl, NEW_INT_ECN_CNGs, data));

    data = ecn_config->responsive ? 1 : 0;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, RESPONSIVEs, data));

    data = ecn_config->congestion_marked ? 1 : 0;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, CONGESTION_MARKEDs, data));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set_commit(unit, entry_hdl, BCMLT_PRIORITY_NORMAL));

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_ecn_action_latency_dequeue_get(
    int unit,
    bcm_ecn_traffic_action_config_t *ecn_config)
{
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;
    int dunit;
    uint64_t data;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(ecn_config, SHR_E_PARAM);

    if ((ecn_config->int_cn < 0)
        || (ecn_config->int_cn > XGS_INT_CN_MAX_VALUE)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    dunit = bcmi_ltsw_dev_dunit(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_allocate(dunit, ECN_LATENCY_WRED_UPDATEs, &entry_hdl));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, INT_ECN_CNGs, ecn_config->int_cn));
    data = ecn_config->buffer_high_thd_exceeded ? 1 : 0;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, MAX_THD_EXCEEDs, data));
    data = ecn_config->buffer_low_thd_exceeded ? 1 : 0;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, MIN_THD_EXCEEDs, data));
    data = ecn_config->latency_thd_exceeded ? 1 : 0;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_add(entry_hdl, CE_LATENCYs, data));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                              BCMLT_PRIORITY_NORMAL));

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, NEW_INT_ECN_CNGs, &data));
    if (data != ecn_config->int_cn) {
        ecn_config->action_flags |=
            BCM_ECN_TRAFFIC_ACTION_DEQUEUE_LATENCY_INT_CN_UPDATE;
        ecn_config->latency_int_cn = data;
    } else {
        ecn_config->action_flags &=
            ~ BCM_ECN_TRAFFIC_ACTION_DEQUEUE_LATENCY_INT_CN_UPDATE;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, RESPONSIVEs, &data));
    ecn_config->responsive = data;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmlt_entry_field_get(entry_hdl, CONGESTION_MARKEDs, &data));
    ecn_config->congestion_marked = data;

exit:
    if (entry_hdl != BCMLT_INVALID_HDL) {
        (void)bcmlt_entry_free(entry_hdl);
    }

    SHR_FUNC_EXIT();
}

int
xgs_ltsw_ecn_responsive_default_set(
    int unit,
    int value)
{
    return SHR_E_UNAVAIL;
}

int
xgs_ltsw_ecn_responsive_default_get(
    int unit,
    int *value)
{
    return SHR_E_UNAVAIL;
}

int
xgs_ltsw_ecn_ctrl_set(
    int unit,
    const char *lt_name,
    const char *lt_fld_name,
    int val)
{
    bcmi_lt_entry_t entry;
    bcmi_lt_field_t fields[] = {
        {NULL,    BCMI_LT_FIELD_F_SET, 0, {0}},
    };

    SHR_FUNC_ENTER(unit);

    entry.fields = fields;
    entry.nfields = sizeof(fields) / sizeof(fields[0]);
    entry.attr = 0;
    fields[0].fld_name = lt_fld_name;
    fields[0].u.val = val;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, lt_name, &entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_ecn_ctrl_get(
    int unit,
    const char *lt_name,
    const char *lt_fld_name,
    int *val)
{
    bcmi_lt_entry_t entry;
    bcmi_lt_field_t fields[] = {
        {NULL,    BCMI_LT_FIELD_F_GET, 0, {0}},
    };
    bcmlt_field_def_t fld_def;

    SHR_FUNC_ENTER(unit);

    entry.fields = fields;
    entry.nfields = sizeof(fields) / sizeof(fields[0]);
    entry.attr = 0;
    fields[0].fld_name = lt_fld_name;

    if (SHR_FAILURE(bcmi_lt_entry_get(unit, lt_name, &entry, NULL, NULL))) {
        sal_memset(&fld_def, 0, sizeof(fld_def));
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_def_get(unit, lt_name, lt_fld_name, &fld_def));
        fields[0].u.val = fld_def.def;
    }
    *val = fields[0].u.val;

exit:
    SHR_FUNC_EXIT();
}

int
xgs_ltsw_ecn_type_map_traverse(
    int unit,
    uint32_t flags,
    bcm_ecn_type_map_traverse_cb cb,
    void *user_data)
{
    int i, rv_pre, rv_post, rv;
    uint64_t data;
    uint32_t alloc_size;
    bcm_ecn_type_map_t map;
    int dunit = bcmi_ltsw_dev_dunit(unit);
    bcmlt_entry_handle_t entry_hdl = BCMLT_INVALID_HDL;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(cb, SHR_E_PARAM);
    SHR_NULL_CHECK(user_data, SHR_E_PARAM);

    if (!(flags & BCM_ECN_TYPE_MAP_INTPRI_TO_MARKINGTYPE)) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (!(flags &
        (BCM_ECN_TYPE_MAP_INGRESS_POST_FORWARD_MARKING_TYPE_UPDATE |
        BCM_ECN_TYPE_MAP_INGRESS_PRE_FORWARD_MARKING_TYPE_UPDATE))) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    alloc_size = sizeof(bcm_ecn_type_map_t);
    for (i = 0; i <= XGS_INT_PRI_MAX_VALUE; i++) {

        rv_pre = SHR_E_UNAVAIL;
        rv_post = SHR_E_UNAVAIL;
        sal_memset(&map, 0, alloc_size);

        if (flags &
            BCM_ECN_TYPE_MAP_INGRESS_POST_FORWARD_MARKING_TYPE_UPDATE) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, ECN_INT_PRI_TO_CNG_POSTs,
                                      &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, INT_PRIs, i));
            rv_post = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                                      BCMLT_PRIORITY_NORMAL);
            if (rv_post == SHR_E_NONE) {

                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_get(entry_hdl, ECN_IP_TO_CNG_IDs,
                                           &data));

                map.ing_post_fwd_marking = data;
            }
        }

        if (entry_hdl != BCMLT_INVALID_HDL) {
            bcmlt_entry_free(entry_hdl);
        }

        if (flags &
                   BCM_ECN_TYPE_MAP_INGRESS_PRE_FORWARD_MARKING_TYPE_UPDATE) {
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_allocate(dunit, ECN_INT_PRI_TO_CNG_PREs,
                                      &entry_hdl));
            SHR_IF_ERR_VERBOSE_EXIT
                (bcmlt_entry_field_add(entry_hdl, INT_PRIs, i));
            rv_pre = bcmi_lt_entry_commit(unit, entry_hdl, BCMLT_OPCODE_LOOKUP,
                                      BCMLT_PRIORITY_NORMAL);
            if (rv_pre == SHR_E_NONE) {

                SHR_IF_ERR_VERBOSE_EXIT
                    (bcmlt_entry_field_get(entry_hdl, ECN_IP_TO_CNG_IDs,
                                           &data));

                map.ing_pre_fwd_marking = data;
            }

        }

        map.int_pri = i;

        if (entry_hdl != BCMLT_INVALID_HDL) {
            bcmlt_entry_free(entry_hdl);
        }

        if (rv_pre == SHR_E_NONE || rv_post == SHR_E_NONE) {
            rv = cb(unit, flags, &map, user_data);
            if (SHR_FAILURE(rv) && bcmi_ltsw_dev_cb_err_abort(unit)) {
                SHR_ERR_EXIT(rv);
            }
        }
    }

exit:

    SHR_FUNC_EXIT();
}

