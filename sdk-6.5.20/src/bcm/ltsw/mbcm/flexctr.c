/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/types.h>

#include <bcm_int/ltsw/mbcm/flexctr.h>
#include <bcm_int/ltsw/mbcm/mbcm.h>

#include <shr/shr_debug.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_FLEXCTR

/*!
 * \brief The Flexctr mbcm drivers.
 */
static mbcm_ltsw_flexctr_drv_t mbcm_ltsw_flexctr_drv[BCM_MAX_NUM_UNITS];

/******************************************************************************
 * Private functions
 */

/******************************************************************************
 * Public functions
 */

int
mbcm_ltsw_flexctr_drv_set(
    int unit,
    mbcm_ltsw_flexctr_drv_t *drv)
{
    mbcm_ltsw_flexctr_drv_t *local = &mbcm_ltsw_flexctr_drv[unit];

    SHR_FUNC_ENTER(unit);


    mbcm_ltsw_drv_init((mbcm_ltsw_drv_t *)local,
                       (mbcm_ltsw_drv_t *)drv,
                       sizeof(*local)/MBCM_LTSW_FNPTR_SZ);

    SHR_EXIT();

exit:
    SHR_FUNC_EXIT();
}

int
mbcm_ltsw_flexctr_source_info_get(
    int unit,
    int source,
    bcmint_flexctr_source_info_t **source_info)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_flexctr_drv[unit].flexctr_source_info_get(unit, source, source_info));

exit:
    SHR_FUNC_EXIT();
}

int
mbcm_ltsw_flexctr_object_info_get(
    int unit,
    int object,
    bcmint_flexctr_object_info_t **object_info)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_flexctr_drv[unit].flexctr_object_info_get(unit, object, object_info));

exit:
    SHR_FUNC_EXIT();
}

int
mbcm_ltsw_flexctr_object_overlay_multi_get(
    int unit,
    bcm_flexctr_object_t object,
    int array_size,
    bcm_flexctr_object_t *overlay_object_array,
    int *count)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_flexctr_drv[unit].flexctr_object_overlay_multi_get(unit, object, array_size, overlay_object_array, count));

exit:
    SHR_FUNC_EXIT();
}

int
mbcm_ltsw_flexctr_object_enum_get(
    int unit,
    int object,
    uint32_t object_id,
    const char **symbol)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_flexctr_drv[unit].flexctr_object_enum_get(unit, object, object_id, symbol));

exit:
    SHR_FUNC_EXIT();
}

int
mbcm_ltsw_flexctr_trigger_interval_validate(
    int unit,
    int interval)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_flexctr_drv[unit].flexctr_trigger_interval_validate(unit, interval));

exit:
    SHR_FUNC_EXIT();
}

int
mbcm_ltsw_flexctr_flex_action_range_get(
    int unit,
    int stage,
    uint32_t *min,
    uint32_t *max)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_flexctr_drv[unit].flexctr_flex_action_range_get(unit, stage, min, max));

exit:
    SHR_FUNC_EXIT();
}

int
mbcm_ltsw_flexctr_pkt_attr_info_get(
    int unit,
    int attr_type,
    bcmint_flexctr_pkt_attr_info_t **pkt_attr_info)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_flexctr_drv[unit].flexctr_pkt_attr_info_get(unit, attr_type, pkt_attr_info));

exit:
    SHR_FUNC_EXIT();
}

int
mbcm_ltsw_flexctr_pkt_attr_bus_info_get(
    int unit,
    int stage,
    int bit_pos,
    bcmint_flexctr_pkt_attr_bus_info_t **pkt_attr_bus_info)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_flexctr_drv[unit].flexctr_pkt_attr_bus_info_get(unit, stage, bit_pos, pkt_attr_bus_info));

exit:
    SHR_FUNC_EXIT();
}

int
mbcm_ltsw_flexctr_pkt_type_value_get(
    int unit,
    int pkt_type,
    uint32_t *value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_flexctr_drv[unit].flexctr_pkt_type_value_get(unit, pkt_type, value));

exit:
    SHR_FUNC_EXIT();
}

int
mbcm_ltsw_flexctr_vlan_tag_value_get(
    int unit,
    int vlan_tag,
    uint32_t *value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_flexctr_drv[unit].flexctr_vlan_tag_value_get(unit, vlan_tag, value));

exit:
    SHR_FUNC_EXIT();
}

int
mbcm_ltsw_flexctr_field_opaque_object_value_get(
    int unit,
    uint32_t stat_counter_id,
    uint32_t counter_index,
    uint32_t size,
    uint32_t *obj_val)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_flexctr_drv[unit].flexctr_field_opaque_object_value_get(unit, stat_counter_id, counter_index, size, obj_val));

exit:
    SHR_FUNC_EXIT();
}

int
mbcm_ltsw_flexctr_egr_presel_set(
    int unit,
    int val)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_flexctr_drv[unit].flexctr_egr_presel_set(unit, val));

exit:
    SHR_FUNC_EXIT();
}

int
mbcm_ltsw_flexctr_egr_presel_get(
    int unit,
    int *val)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_flexctr_drv[unit].flexctr_egr_presel_get(unit, val));

exit:
    SHR_FUNC_EXIT();
}

int
mbcm_ltsw_flexctr_action_scale_enum_map_get(
    int unit,
    const bcmint_flexctr_enum_map_t **map,
    uint32_t *count)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_flexctr_drv[unit].flexctr_action_scale_enum_map_get(unit, map, count));

exit:
    SHR_FUNC_EXIT();
}

