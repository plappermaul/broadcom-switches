/**************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by HA parser from YAML formated file.
 * Edits to this file will be lost when it is regenerated.
 * Tool: bcmha/scripts/ha_yml_parser.py
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */
#ifndef FLEXCTR_HA_H
#define FLEXCTR_HA_H

#include <shr/shr_ha.h>

#define FC_MAX_OPOBJ (8)
#define FC_QUANT_RANGE_MAX (8)
#define FC_POOL_NONE (0)
#define FC_POOL_SLIM (1)
#define FC_ACTION_OBJ_COUNT (4)
#define FC_VALUE_A_TRUE (0)
#define FC_VALUE_B_TRUE (1)
#define FC_VALUE_COUNT (2)
#define FC_INDEX_OP (2)
#define FC_OP_COUNT (3)
#define FC_BITWID (32)
#define FLEXCTR_NUM_TBLS_MAX (32)
#define FLEXCTR_NUM_SECTION_MAX (128)
#define FLEXCTR_TBL_WORDS_NUM ((FLEXCTR_NUM_TBLS_MAX + FC_BITWID - 1)/FC_BITWID)
#define FLEXCTR_SECTION_WORDS_NUM ((FLEXCTR_NUM_SECTION_MAX + FC_BITWID - 1)/FC_BITWID)
#define FC_ACTION_OPOBJ_COUNT (FC_MAX_OPOBJ * FC_OP_COUNT)
#define BCMI_FLEXCTR_GROUP_ACTION_SIZE 16

/*!
 * Hint type. This enum should align with bcm_flexctr_hint_type_t.
 * BCMI_FLEXCTR_HINT_POOL = 0,  Assign the same pool ID on one hint value for the
 * given flex counter source. BCMI_FLEXCTR_HINT_FIELD_GROUP_ID = 1, Indicate a
 * field group ID as the hint and assign the pool ID based on the field group
 * priority. BCMI_FLEXCTR_HINT_COUNT = 2,  Always last one.
 */
typedef enum {
   BCMI_FLEXCTR_HINT_POOL = 0,
   BCMI_FLEXCTR_HINT_FIELD_GROUP_ID = 1,
   BCMI_FLEXCTR_HINT_COUNT = 2
} bcmi_flexctr_hint_type_t;

typedef struct {
   /*! TRUE if quantization has been used. */
   bool used;
   /*! TRUE if quantization has been used for 32-bit mode. */
   bool used_for_32bit;
   /*! Reference counter. */
   int ref_count;
   /*! Options. */
   uint32_t options;
   /*! Quant object. */
   int object;
   /*! Quant object for the upper 16 bits. */
   int object_upper;
   /*! Quant min array. */
   uint32_t range_min[FC_QUANT_RANGE_MAX];
   /*! Quant max array. */
   uint32_t range_max[FC_QUANT_RANGE_MAX];
   /*! Quant range_num. */
   uint32_t range_num;
   /*! Quant object id. */
   uint32_t object_id;
   /*! Quant object id for the upper object. */
   uint32_t object_id_upper;
   /*! Reserved for global action in pipe unique mode. */
   bool global_rsvd;
} ltsw_flexctr_quant_t;

#define LTSW_FLEXCTR_QUANT_T_ID 0xc9e9645e1a112f21

typedef struct {
   /*! Bitmap representing tables within the pool. */
   uint32_t used_by_tbls[FLEXCTR_TBL_WORDS_NUM];
   /*! Pool mode. */
   int mode;
   /*! Hint value. */
   int hint;
   /*! Number of action is using this pool. */
   uint32_t used_count;
   /*! Bitmap representing sections within the pool. */
   uint32_t inuse_bitmap[FLEXCTR_SECTION_WORDS_NUM];
   /*! Reserved for global action in pipe unique mode. */
   bool global_rsvd;
} ltsw_flexctr_pool_t;

#define LTSW_FLEXCTR_POOL_T_ID 0xd5ec02b1492fb43b

typedef struct {
   /*! TRUE if action has been used. */
   bool used;
   /*! Reference counter. */
   int ref_count;
   /*! Associated group action id. */
   uint32_t group_stat_counter_id;
   /*! Reference counter for group action. */
   int grp_ref_count;
   /*! Action options. */
   uint32_t options;
   /*! Action object array. */
   int objects[FC_ACTION_OBJ_COUNT];
   /*! Action object id array. */
   uint32_t objects_id[FC_ACTION_OBJ_COUNT];
   /*! Allocated first counter pool. */
   uint32_t start_pool_idx;
   /*! Allocated last counter pool. */
   uint32_t end_pool_idx;
   /*! Allocated first counter section. */
   uint32_t start_section_idx;
   /*! Allocated last counter section. */
   uint32_t end_section_idx;
   /*! Index operation profile id. */
   uint32_t index_profile;
   /*! Value A true operation profile id. */
   uint32_t value_a_profile;
   /*! Value B true operation profile id. */
   uint32_t value_b_profile;
   /*! Stat counter number. */
   uint32_t index_num;
   /*! Action flags. */
   uint32_t flags;
   /*! Action source. */
   int source;
   /*! Action hint. */
   int hint;
   /*! Action drop count mode. */
   int drop_count_mode;
   /*! Action exception drop count enable. */
   int exception_drop_count_enable;
   /*! Action egress mirror count enable. */
   int egress_mirror_count_enable;
   /*! Action mode. */
   int mode;
   /*! Action object array. */
   int object[FC_ACTION_OPOBJ_COUNT];
   /*! Action object id array. */
   uint32_t object_id[FC_ACTION_OPOBJ_COUNT];
   /*! Action quantization array. */
   uint32_t quant_id[FC_ACTION_OPOBJ_COUNT];
   /*! Action mask_size array. */
   uint32_t mask_size[FC_ACTION_OPOBJ_COUNT];
   /*! Action shift array. */
   uint32_t shift[FC_ACTION_OPOBJ_COUNT];
   /*! Action value select. */
   int value_select[FC_VALUE_COUNT];
   /*! Action value type. */
   int value_type[FC_VALUE_COUNT];
   /*! Reserved for global action in pipe unique mode. */
   bool global_rsvd;
   /*! Eviction enabled on the action. */
   bool evict_ena;
   /*! Hint type. */
   bcmi_flexctr_hint_type_t hint_type;
} ltsw_flexctr_action_t;

#define LTSW_FLEXCTR_ACTION_T_ID 0xc0f639952cc6a5da

typedef struct {
   /*! TRUE if action has been used. */
   bool used;
   /*! Reference counter. */
   int ref_count;
   /*! Action options. */
   uint32_t options;
   /*! Parent action id. */
   uint32_t parent_act_id;
   /*! Group action source. */
   int source;
   /*! Group action stat_counter_id array. */
   uint32_t stat_counter_id[BCMI_FLEXCTR_GROUP_ACTION_SIZE];
   /*! Group action number. */
   uint32_t action_num;
   /*! Reserved for global action in pipe unique mode. */
   bool global_rsvd;
} ltsw_flexctr_grp_action_t;

#define LTSW_FLEXCTR_GRP_ACTION_T_ID 0x7589ccc82e5a72f8

#endif /* FLEXCTR_HA_H */
