/** \file algo/swstate/auto_generated/diagnostic/dnx_algo_field_key_alloc_diagnostic.c
 *
 * sw state functions definitions
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */
/*
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#ifdef BSL_LOG_MODULE
#error "BSL_LOG_MODULE redefined"
#endif
#define BSL_LOG_MODULE BSL_LS_SWSTATEDNX_GENERAL

#include <soc/dnxc/swstate/dnxc_sw_state_c_includes.h>
#include <bcm_int/dnx/algo/swstate/auto_generated/diagnostic/dnx_algo_field_key_alloc_diagnostic.h>
#if defined(DNX_SW_STATE_DIAGNOSTIC)
/*
 * Global Variables
 */

extern dnx_field_keys_per_stage_allocation_t * dnx_field_keys_per_stage_allocation_sw_data[SOC_MAX_NUM_DEVICES];
/*
 * FUNCTIONs
 */

/*
 *
 * dump function for the variable dnx_field_keys_per_stage_allocation_sw
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_field_keys_per_stage_allocation_sw_dump(int  unit,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_field_keys_per_stage_allocation_sw_keys_per_stage_dump(unit, filters));
    SHR_IF_ERR_EXIT(dnx_field_keys_per_stage_allocation_sw_keys_availability_dump(unit, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable keys_per_stage
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_field_keys_per_stage_allocation_sw_keys_per_stage_dump(int  unit,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_field_keys_per_stage_allocation_sw_keys_per_stage_key_stage_prog_occupation_dump(unit, -1, -1, filters));
    SHR_IF_ERR_EXIT(dnx_field_keys_per_stage_allocation_sw_keys_per_stage_key_on_stage_supports_bitmap_allocation_dump(unit, -1, -1, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable key_stage_prog_occupation
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_field_keys_per_stage_allocation_sw_keys_per_stage_key_stage_prog_occupation_dump(int  unit,  int  key_stage_prog_occupation_idx_0,  int  key_stage_prog_occupation_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_field_keys_per_stage_allocation_sw_keys_per_stage_key_stage_prog_occupation_key_occupation_dump(unit, key_stage_prog_occupation_idx_0,key_stage_prog_occupation_idx_1, -1, filters));
    SHR_IF_ERR_EXIT(dnx_field_keys_per_stage_allocation_sw_keys_per_stage_key_stage_prog_occupation_key_occupation_nof_dump(unit, key_stage_prog_occupation_idx_0,key_stage_prog_occupation_idx_1, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable key_occupation
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_field_keys_per_stage_allocation_sw_keys_per_stage_key_stage_prog_occupation_key_occupation_dump(int  unit,  int  key_stage_prog_occupation_idx_0,  int  key_stage_prog_occupation_idx_1,  int  key_occupation_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_field_keys_per_stage_allocation_sw_keys_per_stage_key_stage_prog_occupation_key_occupation_key_occupation_state_dump(unit, key_stage_prog_occupation_idx_0, key_stage_prog_occupation_idx_1, key_occupation_idx_0, filters));
    SHR_IF_ERR_EXIT(dnx_field_keys_per_stage_allocation_sw_keys_per_stage_key_stage_prog_occupation_key_occupation_key_field_group_type_dump(unit, key_stage_prog_occupation_idx_0, key_stage_prog_occupation_idx_1, key_occupation_idx_0, filters));
    SHR_IF_ERR_EXIT(dnx_field_keys_per_stage_allocation_sw_keys_per_stage_key_stage_prog_occupation_key_occupation_key_allocation_id_dump(unit, key_stage_prog_occupation_idx_0, key_stage_prog_occupation_idx_1, key_occupation_idx_0, filters));
    SHR_IF_ERR_EXIT(dnx_field_keys_per_stage_allocation_sw_keys_per_stage_key_stage_prog_occupation_key_occupation_bit_range_key_occ_bmp_dump(unit, key_stage_prog_occupation_idx_0, key_stage_prog_occupation_idx_1, key_occupation_idx_0, -1, filters));
    SHR_IF_ERR_EXIT(dnx_field_keys_per_stage_allocation_sw_keys_per_stage_key_stage_prog_occupation_key_occupation_num_bit_ranges_dump(unit, key_stage_prog_occupation_idx_0, key_stage_prog_occupation_idx_1, key_occupation_idx_0, filters));
    SHR_IF_ERR_EXIT(dnx_field_keys_per_stage_allocation_sw_keys_per_stage_key_stage_prog_occupation_key_occupation_is_half_key_range_occupied_dump(unit, key_stage_prog_occupation_idx_0, key_stage_prog_occupation_idx_1, key_occupation_idx_0, filters));
    SHR_IF_ERR_EXIT(dnx_field_keys_per_stage_allocation_sw_keys_per_stage_key_stage_prog_occupation_key_occupation_bit_range_desc_dump(unit, key_stage_prog_occupation_idx_0, key_stage_prog_occupation_idx_1, key_occupation_idx_0, -1, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable key_occupation_state
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_field_keys_per_stage_allocation_sw_keys_per_stage_key_stage_prog_occupation_key_occupation_key_occupation_state_dump(int  unit,  int  key_stage_prog_occupation_idx_0,  int  key_stage_prog_occupation_idx_1,  int  key_occupation_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = key_stage_prog_occupation_idx_0, I0 = key_stage_prog_occupation_idx_0 + 1;
    int i1 = key_stage_prog_occupation_idx_1, I1 = key_stage_prog_occupation_idx_1 + 1, org_i1 = key_stage_prog_occupation_idx_1;
    int i2 = key_occupation_idx_0, I2 = key_occupation_idx_0 + 1, org_i2 = key_occupation_idx_0;
    char *s0 = "", *s1 = "", *s2 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "dnx_field_key_half_occupation_state_e") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "dnx_algo_field_key_alloc keys_per_stage key_stage_prog_occupation key_occupation key_occupation_state") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate dnx_algo_field_key_alloc keys_per_stage key_stage_prog_occupation key_occupation key_occupation_state\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_field_keys_per_stage_allocation_sw/keys_per_stage/key_stage_prog_occupation/key_occupation/key_occupation_state.txt",
            "dnx_field_keys_per_stage_allocation_sw[%d]->","((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[%d][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->","keys_per_stage.key_stage_prog_occupation[][].key_occupation[].key_occupation_state: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID]));

        if (i0 == -1) {
            I0 = DNX_FIELD_STAGE_NOF;
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation
                , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= DNX_FIELD_STAGE_NOF)
        {
            LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[][].key_occupation[].key_occupation_state: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(DNX_FIELD_STAGE_NOF == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            if (i1 == -1) {
                I1 = DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_NOF_CONTEXTS;
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0]
                    , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_NOF_CONTEXTS)
            {
                LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[][].key_occupation[].key_occupation_state: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_NOF_CONTEXTS == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
                However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
                reached the value of the end condition, we exit the function.
                What coverity is catching is the last increment of i0 before the loop ends. */
                /* coverity[overrun-local:FALSE] */
                    DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                        unit,
                        ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation);

                if (i2 == -1) {
                    I2 = dnx_sw_state_get_nof_elements(unit,
                        DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID,
                        ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation);
                    i2 = dnx_sw_state_dump_check_all_the_same(unit,
                        ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation
                        , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation), I2, &s2) ? I2 - 1 : 0;
                }

                if(i2 >= dnx_sw_state_get_nof_elements(unit, DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID, ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation))
                {
                    LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[][].key_occupation[].key_occupation_state: ")));
                    LOG_CLI((BSL_META("Invalid index: %d \n"),i2));
                    SHR_EXIT();
                }

                if(dnx_sw_state_get_nof_elements(unit, DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID, ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation) == 0)
                {
                    SHR_EXIT();
                }

                for(; i2 < I2; i2++) {
                    dnx_sw_state_dump_update_current_idx(unit, i2);
                    DNX_SW_STATE_PRINT_OPAQUE_MONITOR(
                        unit,
                        ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation[i2].key_occupation_state,
                        "dnx_field_keys_per_stage_allocation_sw[%d]->","((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[%d][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->","keys_per_stage.key_stage_prog_occupation[%s%d][%s%d].key_occupation[%s%d].key_occupation_state: ", s0, i0, s1, i1, s2, i2);

                    DNX_SW_STATE_PRINT_OPAQUE_FILE(
                        unit,
                        ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation[i2].key_occupation_state,
                            "[%s%d][%s%d][%s%d]: ", s0, i0, s1, i1, s2, i2);

                }
                i2 = org_i2;
                dnx_sw_state_dump_end_of_stride(unit);
            }
            i1 = org_i1;
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable key_field_group_type
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_field_keys_per_stage_allocation_sw_keys_per_stage_key_stage_prog_occupation_key_occupation_key_field_group_type_dump(int  unit,  int  key_stage_prog_occupation_idx_0,  int  key_stage_prog_occupation_idx_1,  int  key_occupation_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = key_stage_prog_occupation_idx_0, I0 = key_stage_prog_occupation_idx_0 + 1;
    int i1 = key_stage_prog_occupation_idx_1, I1 = key_stage_prog_occupation_idx_1 + 1, org_i1 = key_stage_prog_occupation_idx_1;
    int i2 = key_occupation_idx_0, I2 = key_occupation_idx_0 + 1, org_i2 = key_occupation_idx_0;
    char *s0 = "", *s1 = "", *s2 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "dnx_field_group_type_e") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "dnx_algo_field_key_alloc keys_per_stage key_stage_prog_occupation key_occupation key_field_group_type") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate dnx_algo_field_key_alloc keys_per_stage key_stage_prog_occupation key_occupation key_field_group_type\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_field_keys_per_stage_allocation_sw/keys_per_stage/key_stage_prog_occupation/key_occupation/key_field_group_type.txt",
            "dnx_field_keys_per_stage_allocation_sw[%d]->","((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[%d][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->","keys_per_stage.key_stage_prog_occupation[][].key_occupation[].key_field_group_type: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID]));

        if (i0 == -1) {
            I0 = DNX_FIELD_STAGE_NOF;
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation
                , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= DNX_FIELD_STAGE_NOF)
        {
            LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[][].key_occupation[].key_field_group_type: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(DNX_FIELD_STAGE_NOF == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            if (i1 == -1) {
                I1 = DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_NOF_CONTEXTS;
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0]
                    , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_NOF_CONTEXTS)
            {
                LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[][].key_occupation[].key_field_group_type: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_NOF_CONTEXTS == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
                However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
                reached the value of the end condition, we exit the function.
                What coverity is catching is the last increment of i0 before the loop ends. */
                /* coverity[overrun-local:FALSE] */
                    DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                        unit,
                        ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation);

                if (i2 == -1) {
                    I2 = dnx_sw_state_get_nof_elements(unit,
                        DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID,
                        ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation);
                    i2 = dnx_sw_state_dump_check_all_the_same(unit,
                        ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation
                        , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation), I2, &s2) ? I2 - 1 : 0;
                }

                if(i2 >= dnx_sw_state_get_nof_elements(unit, DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID, ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation))
                {
                    LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[][].key_occupation[].key_field_group_type: ")));
                    LOG_CLI((BSL_META("Invalid index: %d \n"),i2));
                    SHR_EXIT();
                }

                if(dnx_sw_state_get_nof_elements(unit, DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID, ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation) == 0)
                {
                    SHR_EXIT();
                }

                for(; i2 < I2; i2++) {
                    dnx_sw_state_dump_update_current_idx(unit, i2);
                    DNX_SW_STATE_PRINT_OPAQUE_MONITOR(
                        unit,
                        ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation[i2].key_field_group_type,
                        "dnx_field_keys_per_stage_allocation_sw[%d]->","((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[%d][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->","keys_per_stage.key_stage_prog_occupation[%s%d][%s%d].key_occupation[%s%d].key_field_group_type: ", s0, i0, s1, i1, s2, i2);

                    DNX_SW_STATE_PRINT_OPAQUE_FILE(
                        unit,
                        ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation[i2].key_field_group_type,
                            "[%s%d][%s%d][%s%d]: ", s0, i0, s1, i1, s2, i2);

                }
                i2 = org_i2;
                dnx_sw_state_dump_end_of_stride(unit);
            }
            i1 = org_i1;
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable key_allocation_id
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_field_keys_per_stage_allocation_sw_keys_per_stage_key_stage_prog_occupation_key_occupation_key_allocation_id_dump(int  unit,  int  key_stage_prog_occupation_idx_0,  int  key_stage_prog_occupation_idx_1,  int  key_occupation_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = key_stage_prog_occupation_idx_0, I0 = key_stage_prog_occupation_idx_0 + 1;
    int i1 = key_stage_prog_occupation_idx_1, I1 = key_stage_prog_occupation_idx_1 + 1, org_i1 = key_stage_prog_occupation_idx_1;
    int i2 = key_occupation_idx_0, I2 = key_occupation_idx_0 + 1, org_i2 = key_occupation_idx_0;
    char *s0 = "", *s1 = "", *s2 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "uint32") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "dnx_algo_field_key_alloc keys_per_stage key_stage_prog_occupation key_occupation key_allocation_id") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate dnx_algo_field_key_alloc keys_per_stage key_stage_prog_occupation key_occupation key_allocation_id\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_field_keys_per_stage_allocation_sw/keys_per_stage/key_stage_prog_occupation/key_occupation/key_allocation_id.txt",
            "dnx_field_keys_per_stage_allocation_sw[%d]->","((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[%d][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->","keys_per_stage.key_stage_prog_occupation[][].key_occupation[].key_allocation_id: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID]));

        if (i0 == -1) {
            I0 = DNX_FIELD_STAGE_NOF;
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation
                , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= DNX_FIELD_STAGE_NOF)
        {
            LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[][].key_occupation[].key_allocation_id: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(DNX_FIELD_STAGE_NOF == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            if (i1 == -1) {
                I1 = DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_NOF_CONTEXTS;
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0]
                    , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_NOF_CONTEXTS)
            {
                LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[][].key_occupation[].key_allocation_id: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_NOF_CONTEXTS == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
                However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
                reached the value of the end condition, we exit the function.
                What coverity is catching is the last increment of i0 before the loop ends. */
                /* coverity[overrun-local:FALSE] */
                    DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                        unit,
                        ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation);

                if (i2 == -1) {
                    I2 = dnx_sw_state_get_nof_elements(unit,
                        DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID,
                        ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation);
                    i2 = dnx_sw_state_dump_check_all_the_same(unit,
                        ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation
                        , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation), I2, &s2) ? I2 - 1 : 0;
                }

                if(i2 >= dnx_sw_state_get_nof_elements(unit, DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID, ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation))
                {
                    LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[][].key_occupation[].key_allocation_id: ")));
                    LOG_CLI((BSL_META("Invalid index: %d \n"),i2));
                    SHR_EXIT();
                }

                if(dnx_sw_state_get_nof_elements(unit, DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID, ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation) == 0)
                {
                    SHR_EXIT();
                }

                for(; i2 < I2; i2++) {
                    dnx_sw_state_dump_update_current_idx(unit, i2);
                    DNX_SW_STATE_PRINT_MONITOR(
                        unit,
                        "dnx_field_keys_per_stage_allocation_sw[%d]->","((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[%d][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->","keys_per_stage.key_stage_prog_occupation[%s%d][%s%d].key_occupation[%s%d].key_allocation_id: ", s0, i0, s1, i1, s2, i2);

                    DNX_SW_STATE_PRINT_FILE(
                        unit,
                        "[%s%d][%s%d][%s%d]: ", s0, i0, s1, i1, s2, i2);

                    dnx_sw_state_print_uint32(
                        unit,
                        &((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation[i2].key_allocation_id);

                }
                i2 = org_i2;
                dnx_sw_state_dump_end_of_stride(unit);
            }
            i1 = org_i1;
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable bit_range_key_occ_bmp
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_field_keys_per_stage_allocation_sw_keys_per_stage_key_stage_prog_occupation_key_occupation_bit_range_key_occ_bmp_dump(int  unit,  int  key_stage_prog_occupation_idx_0,  int  key_stage_prog_occupation_idx_1,  int  key_occupation_idx_0,  int  bit_range_key_occ_bmp_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = key_stage_prog_occupation_idx_0, I0 = key_stage_prog_occupation_idx_0 + 1;
    int i1 = key_stage_prog_occupation_idx_1, I1 = key_stage_prog_occupation_idx_1 + 1, org_i1 = key_stage_prog_occupation_idx_1;
    int i2 = key_occupation_idx_0, I2 = key_occupation_idx_0 + 1, org_i2 = key_occupation_idx_0;
    int i3 = bit_range_key_occ_bmp_idx_0, I3 = bit_range_key_occ_bmp_idx_0 + 1, org_i3 = bit_range_key_occ_bmp_idx_0;
    char *s0 = "", *s1 = "", *s2 = "", *s3 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "dnx_algo_res_t") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "dnx_algo_field_key_alloc keys_per_stage key_stage_prog_occupation key_occupation bit_range_key_occ_bmp") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate dnx_algo_field_key_alloc keys_per_stage key_stage_prog_occupation key_occupation bit_range_key_occ_bmp\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_field_keys_per_stage_allocation_sw/keys_per_stage/key_stage_prog_occupation/key_occupation/bit_range_key_occ_bmp.txt",
            "dnx_field_keys_per_stage_allocation_sw[%d]->","((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[%d][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->","keys_per_stage.key_stage_prog_occupation[][].key_occupation[].bit_range_key_occ_bmp[]: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID]));

        if (i0 == -1) {
            I0 = DNX_FIELD_STAGE_NOF;
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation
                , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= DNX_FIELD_STAGE_NOF)
        {
            LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[][].key_occupation[].bit_range_key_occ_bmp[]: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(DNX_FIELD_STAGE_NOF == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            if (i1 == -1) {
                I1 = DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_NOF_CONTEXTS;
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0]
                    , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_NOF_CONTEXTS)
            {
                LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[][].key_occupation[].bit_range_key_occ_bmp[]: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_NOF_CONTEXTS == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
                However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
                reached the value of the end condition, we exit the function.
                What coverity is catching is the last increment of i0 before the loop ends. */
                /* coverity[overrun-local:FALSE] */
                    DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                        unit,
                        ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation);

                if (i2 == -1) {
                    I2 = dnx_sw_state_get_nof_elements(unit,
                        DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID,
                        ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation);
                    i2 = dnx_sw_state_dump_check_all_the_same(unit,
                        ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation
                        , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation), I2, &s2) ? I2 - 1 : 0;
                }

                if(i2 >= dnx_sw_state_get_nof_elements(unit, DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID, ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation))
                {
                    LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[][].key_occupation[].bit_range_key_occ_bmp[]: ")));
                    LOG_CLI((BSL_META("Invalid index: %d \n"),i2));
                    SHR_EXIT();
                }

                if(dnx_sw_state_get_nof_elements(unit, DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID, ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation) == 0)
                {
                    SHR_EXIT();
                }

                for(; i2 < I2; i2++) {
                    /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
                    However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
                    reached the value of the end condition, we exit the function.
                    What coverity is catching is the last increment of i0 before the loop ends. */
                    /* coverity[overrun-local:FALSE] */
                        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                            unit,
                            ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation[i2].bit_range_key_occ_bmp);

                    if (i3 == -1) {
                        I3 = dnx_sw_state_get_nof_elements(unit,
                            DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID,
                            ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation[i2].bit_range_key_occ_bmp);
                        i3 = dnx_sw_state_dump_check_all_the_same(unit,
                            ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation[i2].bit_range_key_occ_bmp
                            , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation[i2].bit_range_key_occ_bmp), I3, &s3) ? I3 - 1 : 0;
                    }

                    if(i3 >= dnx_sw_state_get_nof_elements(unit, DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID, ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation[i2].bit_range_key_occ_bmp))
                    {
                        LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[][].key_occupation[].bit_range_key_occ_bmp[]: ")));
                        LOG_CLI((BSL_META("Invalid index: %d \n"),i3));
                        SHR_EXIT();
                    }

                    if(dnx_sw_state_get_nof_elements(unit, DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID, ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation[i2].bit_range_key_occ_bmp) == 0)
                    {
                        SHR_EXIT();
                    }

                    for(; i3 < I3; i3++) {
                        dnx_sw_state_dump_update_current_idx(unit, i3);
                        DNX_SW_STATE_PRINT_MONITOR(
                            unit,
                            "dnx_field_keys_per_stage_allocation_sw[%d]->","((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[%d][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->","keys_per_stage.key_stage_prog_occupation[%s%d][%s%d].key_occupation[%s%d].bit_range_key_occ_bmp[%s%d]: ", s0, i0, s1, i1, s2, i2, s3, i3);

                        DNX_SW_STATE_PRINT_FILE(
                            unit,
                            "[%s%d][%s%d][%s%d][%s%d]: ", s0, i0, s1, i1, s2, i2, s3, i3);

                        DNX_ALGO_RES_MNGR_PRINT(
                            unit,
                            DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID,
                            &((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation[i2].bit_range_key_occ_bmp[i3]);

                    }
                    i3 = org_i3;
                    dnx_sw_state_dump_end_of_stride(unit);
                }
                i2 = org_i2;
            }
            i1 = org_i1;
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable num_bit_ranges
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_field_keys_per_stage_allocation_sw_keys_per_stage_key_stage_prog_occupation_key_occupation_num_bit_ranges_dump(int  unit,  int  key_stage_prog_occupation_idx_0,  int  key_stage_prog_occupation_idx_1,  int  key_occupation_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = key_stage_prog_occupation_idx_0, I0 = key_stage_prog_occupation_idx_0 + 1;
    int i1 = key_stage_prog_occupation_idx_1, I1 = key_stage_prog_occupation_idx_1 + 1, org_i1 = key_stage_prog_occupation_idx_1;
    int i2 = key_occupation_idx_0, I2 = key_occupation_idx_0 + 1, org_i2 = key_occupation_idx_0;
    char *s0 = "", *s1 = "", *s2 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "uint8") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "dnx_algo_field_key_alloc keys_per_stage key_stage_prog_occupation key_occupation num_bit_ranges") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate dnx_algo_field_key_alloc keys_per_stage key_stage_prog_occupation key_occupation num_bit_ranges\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_field_keys_per_stage_allocation_sw/keys_per_stage/key_stage_prog_occupation/key_occupation/num_bit_ranges.txt",
            "dnx_field_keys_per_stage_allocation_sw[%d]->","((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[%d][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->","keys_per_stage.key_stage_prog_occupation[][].key_occupation[].num_bit_ranges: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID]));

        if (i0 == -1) {
            I0 = DNX_FIELD_STAGE_NOF;
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation
                , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= DNX_FIELD_STAGE_NOF)
        {
            LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[][].key_occupation[].num_bit_ranges: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(DNX_FIELD_STAGE_NOF == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            if (i1 == -1) {
                I1 = DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_NOF_CONTEXTS;
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0]
                    , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_NOF_CONTEXTS)
            {
                LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[][].key_occupation[].num_bit_ranges: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_NOF_CONTEXTS == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
                However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
                reached the value of the end condition, we exit the function.
                What coverity is catching is the last increment of i0 before the loop ends. */
                /* coverity[overrun-local:FALSE] */
                    DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                        unit,
                        ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation);

                if (i2 == -1) {
                    I2 = dnx_sw_state_get_nof_elements(unit,
                        DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID,
                        ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation);
                    i2 = dnx_sw_state_dump_check_all_the_same(unit,
                        ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation
                        , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation), I2, &s2) ? I2 - 1 : 0;
                }

                if(i2 >= dnx_sw_state_get_nof_elements(unit, DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID, ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation))
                {
                    LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[][].key_occupation[].num_bit_ranges: ")));
                    LOG_CLI((BSL_META("Invalid index: %d \n"),i2));
                    SHR_EXIT();
                }

                if(dnx_sw_state_get_nof_elements(unit, DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID, ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation) == 0)
                {
                    SHR_EXIT();
                }

                for(; i2 < I2; i2++) {
                    dnx_sw_state_dump_update_current_idx(unit, i2);
                    DNX_SW_STATE_PRINT_MONITOR(
                        unit,
                        "dnx_field_keys_per_stage_allocation_sw[%d]->","((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[%d][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->","keys_per_stage.key_stage_prog_occupation[%s%d][%s%d].key_occupation[%s%d].num_bit_ranges: ", s0, i0, s1, i1, s2, i2);

                    DNX_SW_STATE_PRINT_FILE(
                        unit,
                        "[%s%d][%s%d][%s%d]: ", s0, i0, s1, i1, s2, i2);

                    dnx_sw_state_print_uint8(
                        unit,
                        &((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation[i2].num_bit_ranges);

                }
                i2 = org_i2;
                dnx_sw_state_dump_end_of_stride(unit);
            }
            i1 = org_i1;
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable is_half_key_range_occupied
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_field_keys_per_stage_allocation_sw_keys_per_stage_key_stage_prog_occupation_key_occupation_is_half_key_range_occupied_dump(int  unit,  int  key_stage_prog_occupation_idx_0,  int  key_stage_prog_occupation_idx_1,  int  key_occupation_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = key_stage_prog_occupation_idx_0, I0 = key_stage_prog_occupation_idx_0 + 1;
    int i1 = key_stage_prog_occupation_idx_1, I1 = key_stage_prog_occupation_idx_1 + 1, org_i1 = key_stage_prog_occupation_idx_1;
    int i2 = key_occupation_idx_0, I2 = key_occupation_idx_0 + 1, org_i2 = key_occupation_idx_0;
    char *s0 = "", *s1 = "", *s2 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "uint8") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "dnx_algo_field_key_alloc keys_per_stage key_stage_prog_occupation key_occupation is_half_key_range_occupied") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate dnx_algo_field_key_alloc keys_per_stage key_stage_prog_occupation key_occupation is_half_key_range_occupied\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_field_keys_per_stage_allocation_sw/keys_per_stage/key_stage_prog_occupation/key_occupation/is_half_key_range_occupied.txt",
            "dnx_field_keys_per_stage_allocation_sw[%d]->","((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[%d][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->","keys_per_stage.key_stage_prog_occupation[][].key_occupation[].is_half_key_range_occupied: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID]));

        if (i0 == -1) {
            I0 = DNX_FIELD_STAGE_NOF;
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation
                , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= DNX_FIELD_STAGE_NOF)
        {
            LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[][].key_occupation[].is_half_key_range_occupied: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(DNX_FIELD_STAGE_NOF == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            if (i1 == -1) {
                I1 = DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_NOF_CONTEXTS;
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0]
                    , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_NOF_CONTEXTS)
            {
                LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[][].key_occupation[].is_half_key_range_occupied: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_NOF_CONTEXTS == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
                However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
                reached the value of the end condition, we exit the function.
                What coverity is catching is the last increment of i0 before the loop ends. */
                /* coverity[overrun-local:FALSE] */
                    DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                        unit,
                        ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation);

                if (i2 == -1) {
                    I2 = dnx_sw_state_get_nof_elements(unit,
                        DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID,
                        ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation);
                    i2 = dnx_sw_state_dump_check_all_the_same(unit,
                        ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation
                        , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation), I2, &s2) ? I2 - 1 : 0;
                }

                if(i2 >= dnx_sw_state_get_nof_elements(unit, DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID, ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation))
                {
                    LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[][].key_occupation[].is_half_key_range_occupied: ")));
                    LOG_CLI((BSL_META("Invalid index: %d \n"),i2));
                    SHR_EXIT();
                }

                if(dnx_sw_state_get_nof_elements(unit, DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID, ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation) == 0)
                {
                    SHR_EXIT();
                }

                for(; i2 < I2; i2++) {
                    dnx_sw_state_dump_update_current_idx(unit, i2);
                    DNX_SW_STATE_PRINT_MONITOR(
                        unit,
                        "dnx_field_keys_per_stage_allocation_sw[%d]->","((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[%d][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->","keys_per_stage.key_stage_prog_occupation[%s%d][%s%d].key_occupation[%s%d].is_half_key_range_occupied: ", s0, i0, s1, i1, s2, i2);

                    DNX_SW_STATE_PRINT_FILE(
                        unit,
                        "[%s%d][%s%d][%s%d]: ", s0, i0, s1, i1, s2, i2);

                    dnx_sw_state_print_uint8(
                        unit,
                        &((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation[i2].is_half_key_range_occupied);

                }
                i2 = org_i2;
                dnx_sw_state_dump_end_of_stride(unit);
            }
            i1 = org_i1;
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable bit_range_desc
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_field_keys_per_stage_allocation_sw_keys_per_stage_key_stage_prog_occupation_key_occupation_bit_range_desc_dump(int  unit,  int  key_stage_prog_occupation_idx_0,  int  key_stage_prog_occupation_idx_1,  int  key_occupation_idx_0,  int  bit_range_desc_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_field_keys_per_stage_allocation_sw_keys_per_stage_key_stage_prog_occupation_key_occupation_bit_range_desc_bit_range_size_dump(unit, key_stage_prog_occupation_idx_0, key_stage_prog_occupation_idx_1, key_occupation_idx_0, bit_range_desc_idx_0, filters));
    SHR_IF_ERR_EXIT(dnx_field_keys_per_stage_allocation_sw_keys_per_stage_key_stage_prog_occupation_key_occupation_bit_range_desc_fg_type_dump(unit, key_stage_prog_occupation_idx_0, key_stage_prog_occupation_idx_1, key_occupation_idx_0, bit_range_desc_idx_0, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable bit_range_size
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_field_keys_per_stage_allocation_sw_keys_per_stage_key_stage_prog_occupation_key_occupation_bit_range_desc_bit_range_size_dump(int  unit,  int  key_stage_prog_occupation_idx_0,  int  key_stage_prog_occupation_idx_1,  int  key_occupation_idx_0,  int  bit_range_desc_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = key_stage_prog_occupation_idx_0, I0 = key_stage_prog_occupation_idx_0 + 1;
    int i1 = key_stage_prog_occupation_idx_1, I1 = key_stage_prog_occupation_idx_1 + 1, org_i1 = key_stage_prog_occupation_idx_1;
    int i2 = key_occupation_idx_0, I2 = key_occupation_idx_0 + 1, org_i2 = key_occupation_idx_0;
    int i3 = bit_range_desc_idx_0, I3 = bit_range_desc_idx_0 + 1, org_i3 = bit_range_desc_idx_0;
    char *s0 = "", *s1 = "", *s2 = "", *s3 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "uint8") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "dnx_algo_field_key_alloc keys_per_stage key_stage_prog_occupation key_occupation bit_range_desc bit_range_size") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate dnx_algo_field_key_alloc keys_per_stage key_stage_prog_occupation key_occupation bit_range_desc bit_range_size\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_field_keys_per_stage_allocation_sw/keys_per_stage/key_stage_prog_occupation/key_occupation/bit_range_desc/bit_range_size.txt",
            "dnx_field_keys_per_stage_allocation_sw[%d]->","((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[%d][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->","keys_per_stage.key_stage_prog_occupation[][].key_occupation[].bit_range_desc[].bit_range_size: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID]));

        if (i0 == -1) {
            I0 = DNX_FIELD_STAGE_NOF;
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation
                , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= DNX_FIELD_STAGE_NOF)
        {
            LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[][].key_occupation[].bit_range_desc[].bit_range_size: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(DNX_FIELD_STAGE_NOF == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            if (i1 == -1) {
                I1 = DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_NOF_CONTEXTS;
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0]
                    , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_NOF_CONTEXTS)
            {
                LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[][].key_occupation[].bit_range_desc[].bit_range_size: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_NOF_CONTEXTS == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
                However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
                reached the value of the end condition, we exit the function.
                What coverity is catching is the last increment of i0 before the loop ends. */
                /* coverity[overrun-local:FALSE] */
                    DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                        unit,
                        ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation);

                if (i2 == -1) {
                    I2 = dnx_sw_state_get_nof_elements(unit,
                        DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID,
                        ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation);
                    i2 = dnx_sw_state_dump_check_all_the_same(unit,
                        ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation
                        , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation), I2, &s2) ? I2 - 1 : 0;
                }

                if(i2 >= dnx_sw_state_get_nof_elements(unit, DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID, ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation))
                {
                    LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[][].key_occupation[].bit_range_desc[].bit_range_size: ")));
                    LOG_CLI((BSL_META("Invalid index: %d \n"),i2));
                    SHR_EXIT();
                }

                if(dnx_sw_state_get_nof_elements(unit, DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID, ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation) == 0)
                {
                    SHR_EXIT();
                }

                for(; i2 < I2; i2++) {
                    /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
                    However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
                    reached the value of the end condition, we exit the function.
                    What coverity is catching is the last increment of i0 before the loop ends. */
                    /* coverity[overrun-local:FALSE] */
                        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                            unit,
                            ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation[i2].bit_range_desc);

                    if (i3 == -1) {
                        I3 = dnx_sw_state_get_nof_elements(unit,
                            DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID,
                            ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation[i2].bit_range_desc);
                        i3 = dnx_sw_state_dump_check_all_the_same(unit,
                            ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation[i2].bit_range_desc
                            , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation[i2].bit_range_desc), I3, &s3) ? I3 - 1 : 0;
                    }

                    if(i3 >= dnx_sw_state_get_nof_elements(unit, DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID, ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation[i2].bit_range_desc))
                    {
                        LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[][].key_occupation[].bit_range_desc[].bit_range_size: ")));
                        LOG_CLI((BSL_META("Invalid index: %d \n"),i3));
                        SHR_EXIT();
                    }

                    if(dnx_sw_state_get_nof_elements(unit, DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID, ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation[i2].bit_range_desc) == 0)
                    {
                        SHR_EXIT();
                    }

                    for(; i3 < I3; i3++) {
                        dnx_sw_state_dump_update_current_idx(unit, i3);
                        DNX_SW_STATE_PRINT_MONITOR(
                            unit,
                            "dnx_field_keys_per_stage_allocation_sw[%d]->","((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[%d][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->","keys_per_stage.key_stage_prog_occupation[%s%d][%s%d].key_occupation[%s%d].bit_range_desc[%s%d].bit_range_size: ", s0, i0, s1, i1, s2, i2, s3, i3);

                        DNX_SW_STATE_PRINT_FILE(
                            unit,
                            "[%s%d][%s%d][%s%d][%s%d]: ", s0, i0, s1, i1, s2, i2, s3, i3);

                        dnx_sw_state_print_uint8(
                            unit,
                            &((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation[i2].bit_range_desc[i3].bit_range_size);

                    }
                    i3 = org_i3;
                    dnx_sw_state_dump_end_of_stride(unit);
                }
                i2 = org_i2;
            }
            i1 = org_i1;
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable fg_type
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_field_keys_per_stage_allocation_sw_keys_per_stage_key_stage_prog_occupation_key_occupation_bit_range_desc_fg_type_dump(int  unit,  int  key_stage_prog_occupation_idx_0,  int  key_stage_prog_occupation_idx_1,  int  key_occupation_idx_0,  int  bit_range_desc_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = key_stage_prog_occupation_idx_0, I0 = key_stage_prog_occupation_idx_0 + 1;
    int i1 = key_stage_prog_occupation_idx_1, I1 = key_stage_prog_occupation_idx_1 + 1, org_i1 = key_stage_prog_occupation_idx_1;
    int i2 = key_occupation_idx_0, I2 = key_occupation_idx_0 + 1, org_i2 = key_occupation_idx_0;
    int i3 = bit_range_desc_idx_0, I3 = bit_range_desc_idx_0 + 1, org_i3 = bit_range_desc_idx_0;
    char *s0 = "", *s1 = "", *s2 = "", *s3 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "uint8") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "dnx_algo_field_key_alloc keys_per_stage key_stage_prog_occupation key_occupation bit_range_desc fg_type") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate dnx_algo_field_key_alloc keys_per_stage key_stage_prog_occupation key_occupation bit_range_desc fg_type\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_field_keys_per_stage_allocation_sw/keys_per_stage/key_stage_prog_occupation/key_occupation/bit_range_desc/fg_type.txt",
            "dnx_field_keys_per_stage_allocation_sw[%d]->","((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[%d][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->","keys_per_stage.key_stage_prog_occupation[][].key_occupation[].bit_range_desc[].fg_type: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID]));

        if (i0 == -1) {
            I0 = DNX_FIELD_STAGE_NOF;
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation
                , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= DNX_FIELD_STAGE_NOF)
        {
            LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[][].key_occupation[].bit_range_desc[].fg_type: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(DNX_FIELD_STAGE_NOF == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            if (i1 == -1) {
                I1 = DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_NOF_CONTEXTS;
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0]
                    , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_NOF_CONTEXTS)
            {
                LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[][].key_occupation[].bit_range_desc[].fg_type: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_NOF_CONTEXTS == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
                However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
                reached the value of the end condition, we exit the function.
                What coverity is catching is the last increment of i0 before the loop ends. */
                /* coverity[overrun-local:FALSE] */
                    DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                        unit,
                        ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation);

                if (i2 == -1) {
                    I2 = dnx_sw_state_get_nof_elements(unit,
                        DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID,
                        ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation);
                    i2 = dnx_sw_state_dump_check_all_the_same(unit,
                        ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation
                        , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation), I2, &s2) ? I2 - 1 : 0;
                }

                if(i2 >= dnx_sw_state_get_nof_elements(unit, DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID, ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation))
                {
                    LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[][].key_occupation[].bit_range_desc[].fg_type: ")));
                    LOG_CLI((BSL_META("Invalid index: %d \n"),i2));
                    SHR_EXIT();
                }

                if(dnx_sw_state_get_nof_elements(unit, DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID, ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation) == 0)
                {
                    SHR_EXIT();
                }

                for(; i2 < I2; i2++) {
                    /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
                    However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
                    reached the value of the end condition, we exit the function.
                    What coverity is catching is the last increment of i0 before the loop ends. */
                    /* coverity[overrun-local:FALSE] */
                        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                            unit,
                            ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation[i2].bit_range_desc);

                    if (i3 == -1) {
                        I3 = dnx_sw_state_get_nof_elements(unit,
                            DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID,
                            ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation[i2].bit_range_desc);
                        i3 = dnx_sw_state_dump_check_all_the_same(unit,
                            ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation[i2].bit_range_desc
                            , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation[i2].bit_range_desc), I3, &s3) ? I3 - 1 : 0;
                    }

                    if(i3 >= dnx_sw_state_get_nof_elements(unit, DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID, ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation[i2].bit_range_desc))
                    {
                        LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[][].key_occupation[].bit_range_desc[].fg_type: ")));
                        LOG_CLI((BSL_META("Invalid index: %d \n"),i3));
                        SHR_EXIT();
                    }

                    if(dnx_sw_state_get_nof_elements(unit, DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID, ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation[i2].bit_range_desc) == 0)
                    {
                        SHR_EXIT();
                    }

                    for(; i3 < I3; i3++) {
                        dnx_sw_state_dump_update_current_idx(unit, i3);
                        DNX_SW_STATE_PRINT_MONITOR(
                            unit,
                            "dnx_field_keys_per_stage_allocation_sw[%d]->","((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[%d][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->","keys_per_stage.key_stage_prog_occupation[%s%d][%s%d].key_occupation[%s%d].bit_range_desc[%s%d].fg_type: ", s0, i0, s1, i1, s2, i2, s3, i3);

                        DNX_SW_STATE_PRINT_FILE(
                            unit,
                            "[%s%d][%s%d][%s%d][%s%d]: ", s0, i0, s1, i1, s2, i2, s3, i3);

                        dnx_sw_state_print_uint8(
                            unit,
                            &((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation[i2].bit_range_desc[i3].fg_type);

                    }
                    i3 = org_i3;
                    dnx_sw_state_dump_end_of_stride(unit);
                }
                i2 = org_i2;
            }
            i1 = org_i1;
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable key_occupation_nof
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_field_keys_per_stage_allocation_sw_keys_per_stage_key_stage_prog_occupation_key_occupation_nof_dump(int  unit,  int  key_stage_prog_occupation_idx_0,  int  key_stage_prog_occupation_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = key_stage_prog_occupation_idx_0, I0 = key_stage_prog_occupation_idx_0 + 1;
    int i1 = key_stage_prog_occupation_idx_1, I1 = key_stage_prog_occupation_idx_1 + 1, org_i1 = key_stage_prog_occupation_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "uint8") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "dnx_algo_field_key_alloc keys_per_stage key_stage_prog_occupation key_occupation_nof") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate dnx_algo_field_key_alloc keys_per_stage key_stage_prog_occupation key_occupation_nof\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_field_keys_per_stage_allocation_sw/keys_per_stage/key_stage_prog_occupation/key_occupation_nof.txt",
            "dnx_field_keys_per_stage_allocation_sw[%d]->","((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[%d][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->","keys_per_stage.key_stage_prog_occupation[][].key_occupation_nof: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID]));

        if (i0 == -1) {
            I0 = DNX_FIELD_STAGE_NOF;
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation
                , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= DNX_FIELD_STAGE_NOF)
        {
            LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[][].key_occupation_nof: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(DNX_FIELD_STAGE_NOF == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            if (i1 == -1) {
                I1 = DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_NOF_CONTEXTS;
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0]
                    , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_NOF_CONTEXTS)
            {
                LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[][].key_occupation_nof: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_NOF_CONTEXTS == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_field_keys_per_stage_allocation_sw[%d]->","((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[%d][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->","keys_per_stage.key_stage_prog_occupation[%s%d][%s%d].key_occupation_nof: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_uint8(
                    unit,
                    &((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_stage_prog_occupation[i0][i1].key_occupation_nof);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable key_on_stage_supports_bitmap_allocation
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_field_keys_per_stage_allocation_sw_keys_per_stage_key_on_stage_supports_bitmap_allocation_dump(int  unit,  int  key_on_stage_supports_bitmap_allocation_idx_0,  int  key_on_stage_supports_bitmap_allocation_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = key_on_stage_supports_bitmap_allocation_idx_0, I0 = key_on_stage_supports_bitmap_allocation_idx_0 + 1;
    int i1 = key_on_stage_supports_bitmap_allocation_idx_1, I1 = key_on_stage_supports_bitmap_allocation_idx_1 + 1, org_i1 = key_on_stage_supports_bitmap_allocation_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "uint8") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "dnx_algo_field_key_alloc keys_per_stage key_on_stage_supports_bitmap_allocation") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate dnx_algo_field_key_alloc keys_per_stage key_on_stage_supports_bitmap_allocation\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_field_keys_per_stage_allocation_sw/keys_per_stage/key_on_stage_supports_bitmap_allocation.txt",
            "dnx_field_keys_per_stage_allocation_sw[%d]->","((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[%d][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->","keys_per_stage.key_on_stage_supports_bitmap_allocation[][]: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID]));

        if (i0 == -1) {
            I0 = DNX_FIELD_STAGE_NOF;
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_on_stage_supports_bitmap_allocation
                , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_on_stage_supports_bitmap_allocation), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= DNX_FIELD_STAGE_NOF)
        {
            LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_on_stage_supports_bitmap_allocation[][]: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(DNX_FIELD_STAGE_NOF == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            if (i1 == -1) {
                I1 = DBAL_NOF_ENUM_FIELD_KEY_VALUES;
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_on_stage_supports_bitmap_allocation[i0]
                    , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_on_stage_supports_bitmap_allocation[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= DBAL_NOF_ENUM_FIELD_KEY_VALUES)
            {
                LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_on_stage_supports_bitmap_allocation[][]: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(DBAL_NOF_ENUM_FIELD_KEY_VALUES == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_field_keys_per_stage_allocation_sw[%d]->","((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[%d][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->","keys_per_stage.key_on_stage_supports_bitmap_allocation[%s%d][%s%d]: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_uint8(
                    unit,
                    &((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_per_stage.key_on_stage_supports_bitmap_allocation[i0][i1]);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable keys_availability
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_field_keys_per_stage_allocation_sw_keys_availability_dump(int  unit,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_field_keys_per_stage_allocation_sw_keys_availability_keys_availability_stage_info_dump(unit, -1, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable keys_availability_stage_info
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_field_keys_per_stage_allocation_sw_keys_availability_keys_availability_stage_info_dump(int  unit,  int  keys_availability_stage_info_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_field_keys_per_stage_allocation_sw_keys_availability_keys_availability_stage_info_keys_availability_group_info_dump(unit, keys_availability_stage_info_idx_0, -1, filters));
    SHR_IF_ERR_EXIT(dnx_field_keys_per_stage_allocation_sw_keys_availability_keys_availability_stage_info_nof_available_keys_on_stage_dump(unit, keys_availability_stage_info_idx_0, filters));
    SHR_IF_ERR_EXIT(dnx_field_keys_per_stage_allocation_sw_keys_availability_keys_availability_stage_info_first_available_key_on_stage_dump(unit, keys_availability_stage_info_idx_0, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable keys_availability_group_info
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_field_keys_per_stage_allocation_sw_keys_availability_keys_availability_stage_info_keys_availability_group_info_dump(int  unit,  int  keys_availability_stage_info_idx_0,  int  keys_availability_group_info_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_field_keys_per_stage_allocation_sw_keys_availability_keys_availability_stage_info_keys_availability_group_info_structure_is_valid_dump(unit, keys_availability_stage_info_idx_0, keys_availability_group_info_idx_0, filters));
    SHR_IF_ERR_EXIT(dnx_field_keys_per_stage_allocation_sw_keys_availability_keys_availability_stage_info_keys_availability_group_info_nof_available_keys_dump(unit, keys_availability_stage_info_idx_0, keys_availability_group_info_idx_0, filters));
    SHR_IF_ERR_EXIT(dnx_field_keys_per_stage_allocation_sw_keys_availability_keys_availability_stage_info_keys_availability_group_info_first_available_key_dump(unit, keys_availability_stage_info_idx_0, keys_availability_group_info_idx_0, filters));
    SHR_IF_ERR_EXIT(dnx_field_keys_per_stage_allocation_sw_keys_availability_keys_availability_stage_info_keys_availability_group_info_supports_bitmap_allocation_dump(unit, keys_availability_stage_info_idx_0, keys_availability_group_info_idx_0, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable structure_is_valid
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_field_keys_per_stage_allocation_sw_keys_availability_keys_availability_stage_info_keys_availability_group_info_structure_is_valid_dump(int  unit,  int  keys_availability_stage_info_idx_0,  int  keys_availability_group_info_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = keys_availability_stage_info_idx_0, I0 = keys_availability_stage_info_idx_0 + 1;
    int i1 = keys_availability_group_info_idx_0, I1 = keys_availability_group_info_idx_0 + 1, org_i1 = keys_availability_group_info_idx_0;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "uint8") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "dnx_algo_field_key_alloc keys_availability keys_availability_stage_info keys_availability_group_info structure_is_valid") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate dnx_algo_field_key_alloc keys_availability keys_availability_stage_info keys_availability_group_info structure_is_valid\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_field_keys_per_stage_allocation_sw/keys_availability/keys_availability_stage_info/keys_availability_group_info/structure_is_valid.txt",
            "dnx_field_keys_per_stage_allocation_sw[%d]->","((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[%d][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->","keys_availability.keys_availability_stage_info[].keys_availability_group_info[].structure_is_valid: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID]));

        if (i0 == -1) {
            I0 = DNX_FIELD_STAGE_NOF;
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info
                , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= DNX_FIELD_STAGE_NOF)
        {
            LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info[].keys_availability_group_info[].structure_is_valid: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(DNX_FIELD_STAGE_NOF == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            if (i1 == -1) {
                I1 = DNX_FIELD_GROUP_TYPE_NOF;
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info[i0].keys_availability_group_info
                    , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info[i0].keys_availability_group_info), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= DNX_FIELD_GROUP_TYPE_NOF)
            {
                LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info[].keys_availability_group_info[].structure_is_valid: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(DNX_FIELD_GROUP_TYPE_NOF == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_field_keys_per_stage_allocation_sw[%d]->","((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[%d][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->","keys_availability.keys_availability_stage_info[%s%d].keys_availability_group_info[%s%d].structure_is_valid: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_uint8(
                    unit,
                    &((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info[i0].keys_availability_group_info[i1].structure_is_valid);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable nof_available_keys
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_field_keys_per_stage_allocation_sw_keys_availability_keys_availability_stage_info_keys_availability_group_info_nof_available_keys_dump(int  unit,  int  keys_availability_stage_info_idx_0,  int  keys_availability_group_info_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = keys_availability_stage_info_idx_0, I0 = keys_availability_stage_info_idx_0 + 1;
    int i1 = keys_availability_group_info_idx_0, I1 = keys_availability_group_info_idx_0 + 1, org_i1 = keys_availability_group_info_idx_0;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "uint8") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "dnx_algo_field_key_alloc keys_availability keys_availability_stage_info keys_availability_group_info nof_available_keys") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate dnx_algo_field_key_alloc keys_availability keys_availability_stage_info keys_availability_group_info nof_available_keys\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_field_keys_per_stage_allocation_sw/keys_availability/keys_availability_stage_info/keys_availability_group_info/nof_available_keys.txt",
            "dnx_field_keys_per_stage_allocation_sw[%d]->","((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[%d][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->","keys_availability.keys_availability_stage_info[].keys_availability_group_info[].nof_available_keys: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID]));

        if (i0 == -1) {
            I0 = DNX_FIELD_STAGE_NOF;
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info
                , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= DNX_FIELD_STAGE_NOF)
        {
            LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info[].keys_availability_group_info[].nof_available_keys: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(DNX_FIELD_STAGE_NOF == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            if (i1 == -1) {
                I1 = DNX_FIELD_GROUP_TYPE_NOF;
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info[i0].keys_availability_group_info
                    , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info[i0].keys_availability_group_info), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= DNX_FIELD_GROUP_TYPE_NOF)
            {
                LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info[].keys_availability_group_info[].nof_available_keys: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(DNX_FIELD_GROUP_TYPE_NOF == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_field_keys_per_stage_allocation_sw[%d]->","((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[%d][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->","keys_availability.keys_availability_stage_info[%s%d].keys_availability_group_info[%s%d].nof_available_keys: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_uint8(
                    unit,
                    &((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info[i0].keys_availability_group_info[i1].nof_available_keys);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable first_available_key
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_field_keys_per_stage_allocation_sw_keys_availability_keys_availability_stage_info_keys_availability_group_info_first_available_key_dump(int  unit,  int  keys_availability_stage_info_idx_0,  int  keys_availability_group_info_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = keys_availability_stage_info_idx_0, I0 = keys_availability_stage_info_idx_0 + 1;
    int i1 = keys_availability_group_info_idx_0, I1 = keys_availability_group_info_idx_0 + 1, org_i1 = keys_availability_group_info_idx_0;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "uint8") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "dnx_algo_field_key_alloc keys_availability keys_availability_stage_info keys_availability_group_info first_available_key") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate dnx_algo_field_key_alloc keys_availability keys_availability_stage_info keys_availability_group_info first_available_key\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_field_keys_per_stage_allocation_sw/keys_availability/keys_availability_stage_info/keys_availability_group_info/first_available_key.txt",
            "dnx_field_keys_per_stage_allocation_sw[%d]->","((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[%d][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->","keys_availability.keys_availability_stage_info[].keys_availability_group_info[].first_available_key: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID]));

        if (i0 == -1) {
            I0 = DNX_FIELD_STAGE_NOF;
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info
                , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= DNX_FIELD_STAGE_NOF)
        {
            LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info[].keys_availability_group_info[].first_available_key: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(DNX_FIELD_STAGE_NOF == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            if (i1 == -1) {
                I1 = DNX_FIELD_GROUP_TYPE_NOF;
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info[i0].keys_availability_group_info
                    , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info[i0].keys_availability_group_info), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= DNX_FIELD_GROUP_TYPE_NOF)
            {
                LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info[].keys_availability_group_info[].first_available_key: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(DNX_FIELD_GROUP_TYPE_NOF == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_field_keys_per_stage_allocation_sw[%d]->","((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[%d][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->","keys_availability.keys_availability_stage_info[%s%d].keys_availability_group_info[%s%d].first_available_key: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_uint8(
                    unit,
                    &((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info[i0].keys_availability_group_info[i1].first_available_key);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable supports_bitmap_allocation
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_field_keys_per_stage_allocation_sw_keys_availability_keys_availability_stage_info_keys_availability_group_info_supports_bitmap_allocation_dump(int  unit,  int  keys_availability_stage_info_idx_0,  int  keys_availability_group_info_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = keys_availability_stage_info_idx_0, I0 = keys_availability_stage_info_idx_0 + 1;
    int i1 = keys_availability_group_info_idx_0, I1 = keys_availability_group_info_idx_0 + 1, org_i1 = keys_availability_group_info_idx_0;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "uint8") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "dnx_algo_field_key_alloc keys_availability keys_availability_stage_info keys_availability_group_info supports_bitmap_allocation") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate dnx_algo_field_key_alloc keys_availability keys_availability_stage_info keys_availability_group_info supports_bitmap_allocation\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_field_keys_per_stage_allocation_sw/keys_availability/keys_availability_stage_info/keys_availability_group_info/supports_bitmap_allocation.txt",
            "dnx_field_keys_per_stage_allocation_sw[%d]->","((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[%d][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->","keys_availability.keys_availability_stage_info[].keys_availability_group_info[].supports_bitmap_allocation: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID]));

        if (i0 == -1) {
            I0 = DNX_FIELD_STAGE_NOF;
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info
                , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= DNX_FIELD_STAGE_NOF)
        {
            LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info[].keys_availability_group_info[].supports_bitmap_allocation: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(DNX_FIELD_STAGE_NOF == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            if (i1 == -1) {
                I1 = DNX_FIELD_GROUP_TYPE_NOF;
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info[i0].keys_availability_group_info
                    , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info[i0].keys_availability_group_info), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= DNX_FIELD_GROUP_TYPE_NOF)
            {
                LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info[].keys_availability_group_info[].supports_bitmap_allocation: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(DNX_FIELD_GROUP_TYPE_NOF == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_field_keys_per_stage_allocation_sw[%d]->","((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[%d][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->","keys_availability.keys_availability_stage_info[%s%d].keys_availability_group_info[%s%d].supports_bitmap_allocation: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_uint8(
                    unit,
                    &((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info[i0].keys_availability_group_info[i1].supports_bitmap_allocation);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable nof_available_keys_on_stage
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_field_keys_per_stage_allocation_sw_keys_availability_keys_availability_stage_info_nof_available_keys_on_stage_dump(int  unit,  int  keys_availability_stage_info_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = keys_availability_stage_info_idx_0, I0 = keys_availability_stage_info_idx_0 + 1;
    char *s0 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "uint8") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "dnx_algo_field_key_alloc keys_availability keys_availability_stage_info nof_available_keys_on_stage") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate dnx_algo_field_key_alloc keys_availability keys_availability_stage_info nof_available_keys_on_stage\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_field_keys_per_stage_allocation_sw/keys_availability/keys_availability_stage_info/nof_available_keys_on_stage.txt",
            "dnx_field_keys_per_stage_allocation_sw[%d]->","((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[%d][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->","keys_availability.keys_availability_stage_info[].nof_available_keys_on_stage: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID]));

        if (i0 == -1) {
            I0 = DNX_FIELD_STAGE_NOF;
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info
                , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= DNX_FIELD_STAGE_NOF)
        {
            LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info[].nof_available_keys_on_stage: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(DNX_FIELD_STAGE_NOF == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            dnx_sw_state_dump_update_current_idx(unit, i0);
            DNX_SW_STATE_PRINT_MONITOR(
                unit,
                "dnx_field_keys_per_stage_allocation_sw[%d]->","((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[%d][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->","keys_availability.keys_availability_stage_info[%s%d].nof_available_keys_on_stage: ", s0, i0);

            DNX_SW_STATE_PRINT_FILE(
                unit,
                "[%s%d]: ", s0, i0);

            dnx_sw_state_print_uint8(
                unit,
                &((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info[i0].nof_available_keys_on_stage);

        }
        dnx_sw_state_dump_end_of_stride(unit);
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable first_available_key_on_stage
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_field_keys_per_stage_allocation_sw_keys_availability_keys_availability_stage_info_first_available_key_on_stage_dump(int  unit,  int  keys_availability_stage_info_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = keys_availability_stage_info_idx_0, I0 = keys_availability_stage_info_idx_0 + 1;
    char *s0 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "uint8") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "dnx_algo_field_key_alloc keys_availability keys_availability_stage_info first_available_key_on_stage") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate dnx_algo_field_key_alloc keys_availability keys_availability_stage_info first_available_key_on_stage\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_field_keys_per_stage_allocation_sw/keys_availability/keys_availability_stage_info/first_available_key_on_stage.txt",
            "dnx_field_keys_per_stage_allocation_sw[%d]->","((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[%d][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->","keys_availability.keys_availability_stage_info[].first_available_key_on_stage: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID]));

        if (i0 == -1) {
            I0 = DNX_FIELD_STAGE_NOF;
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info
                , sizeof(*((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= DNX_FIELD_STAGE_NOF)
        {
            LOG_CLI((BSL_META("dnx_field_keys_per_stage_allocation_sw[]->((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info[].first_available_key_on_stage: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(DNX_FIELD_STAGE_NOF == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            dnx_sw_state_dump_update_current_idx(unit, i0);
            DNX_SW_STATE_PRINT_MONITOR(
                unit,
                "dnx_field_keys_per_stage_allocation_sw[%d]->","((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[%d][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->","keys_availability.keys_availability_stage_info[%s%d].first_available_key_on_stage: ", s0, i0);

            DNX_SW_STATE_PRINT_FILE(
                unit,
                "[%s%d]: ", s0, i0);

            dnx_sw_state_print_uint8(
                unit,
                &((dnx_field_keys_per_stage_allocation_t*)sw_state_roots_array[unit][DNX_ALGO_FIELD_KEY_ALLOC_MODULE_ID])->keys_availability.keys_availability_stage_info[i0].first_available_key_on_stage);

        }
        dnx_sw_state_dump_end_of_stride(unit);
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 * Global Variables
 */

dnx_sw_state_diagnostic_info_t dnx_field_keys_per_stage_allocation_sw_info[SOC_MAX_NUM_DEVICES][DNX_FIELD_KEYS_PER_STAGE_ALLOCATION_SW_INFO_NOF_ENTRIES];
const char* dnx_field_keys_per_stage_allocation_sw_layout_str[DNX_FIELD_KEYS_PER_STAGE_ALLOCATION_SW_INFO_NOF_ENTRIES] = {
    "DNX_FIELD_KEYS_PER_STAGE_ALLOCATION_SW~",
    "DNX_FIELD_KEYS_PER_STAGE_ALLOCATION_SW~KEYS_PER_STAGE~",
    "DNX_FIELD_KEYS_PER_STAGE_ALLOCATION_SW~KEYS_PER_STAGE~KEY_STAGE_PROG_OCCUPATION~",
    "DNX_FIELD_KEYS_PER_STAGE_ALLOCATION_SW~KEYS_PER_STAGE~KEY_STAGE_PROG_OCCUPATION~KEY_OCCUPATION~",
    "DNX_FIELD_KEYS_PER_STAGE_ALLOCATION_SW~KEYS_PER_STAGE~KEY_STAGE_PROG_OCCUPATION~KEY_OCCUPATION~KEY_OCCUPATION_STATE~",
    "DNX_FIELD_KEYS_PER_STAGE_ALLOCATION_SW~KEYS_PER_STAGE~KEY_STAGE_PROG_OCCUPATION~KEY_OCCUPATION~KEY_FIELD_GROUP_TYPE~",
    "DNX_FIELD_KEYS_PER_STAGE_ALLOCATION_SW~KEYS_PER_STAGE~KEY_STAGE_PROG_OCCUPATION~KEY_OCCUPATION~KEY_ALLOCATION_ID~",
    "DNX_FIELD_KEYS_PER_STAGE_ALLOCATION_SW~KEYS_PER_STAGE~KEY_STAGE_PROG_OCCUPATION~KEY_OCCUPATION~BIT_RANGE_KEY_OCC_BMP~",
    "DNX_FIELD_KEYS_PER_STAGE_ALLOCATION_SW~KEYS_PER_STAGE~KEY_STAGE_PROG_OCCUPATION~KEY_OCCUPATION~NUM_BIT_RANGES~",
    "DNX_FIELD_KEYS_PER_STAGE_ALLOCATION_SW~KEYS_PER_STAGE~KEY_STAGE_PROG_OCCUPATION~KEY_OCCUPATION~IS_HALF_KEY_RANGE_OCCUPIED~",
    "DNX_FIELD_KEYS_PER_STAGE_ALLOCATION_SW~KEYS_PER_STAGE~KEY_STAGE_PROG_OCCUPATION~KEY_OCCUPATION~BIT_RANGE_DESC~",
    "DNX_FIELD_KEYS_PER_STAGE_ALLOCATION_SW~KEYS_PER_STAGE~KEY_STAGE_PROG_OCCUPATION~KEY_OCCUPATION~BIT_RANGE_DESC~BIT_RANGE_SIZE~",
    "DNX_FIELD_KEYS_PER_STAGE_ALLOCATION_SW~KEYS_PER_STAGE~KEY_STAGE_PROG_OCCUPATION~KEY_OCCUPATION~BIT_RANGE_DESC~FG_TYPE~",
    "DNX_FIELD_KEYS_PER_STAGE_ALLOCATION_SW~KEYS_PER_STAGE~KEY_STAGE_PROG_OCCUPATION~KEY_OCCUPATION_NOF~",
    "DNX_FIELD_KEYS_PER_STAGE_ALLOCATION_SW~KEYS_PER_STAGE~KEY_ON_STAGE_SUPPORTS_BITMAP_ALLOCATION~",
    "DNX_FIELD_KEYS_PER_STAGE_ALLOCATION_SW~KEYS_AVAILABILITY~",
    "DNX_FIELD_KEYS_PER_STAGE_ALLOCATION_SW~KEYS_AVAILABILITY~KEYS_AVAILABILITY_STAGE_INFO~",
    "DNX_FIELD_KEYS_PER_STAGE_ALLOCATION_SW~KEYS_AVAILABILITY~KEYS_AVAILABILITY_STAGE_INFO~KEYS_AVAILABILITY_GROUP_INFO~",
    "DNX_FIELD_KEYS_PER_STAGE_ALLOCATION_SW~KEYS_AVAILABILITY~KEYS_AVAILABILITY_STAGE_INFO~KEYS_AVAILABILITY_GROUP_INFO~STRUCTURE_IS_VALID~",
    "DNX_FIELD_KEYS_PER_STAGE_ALLOCATION_SW~KEYS_AVAILABILITY~KEYS_AVAILABILITY_STAGE_INFO~KEYS_AVAILABILITY_GROUP_INFO~NOF_AVAILABLE_KEYS~",
    "DNX_FIELD_KEYS_PER_STAGE_ALLOCATION_SW~KEYS_AVAILABILITY~KEYS_AVAILABILITY_STAGE_INFO~KEYS_AVAILABILITY_GROUP_INFO~FIRST_AVAILABLE_KEY~",
    "DNX_FIELD_KEYS_PER_STAGE_ALLOCATION_SW~KEYS_AVAILABILITY~KEYS_AVAILABILITY_STAGE_INFO~KEYS_AVAILABILITY_GROUP_INFO~SUPPORTS_BITMAP_ALLOCATION~",
    "DNX_FIELD_KEYS_PER_STAGE_ALLOCATION_SW~KEYS_AVAILABILITY~KEYS_AVAILABILITY_STAGE_INFO~NOF_AVAILABLE_KEYS_ON_STAGE~",
    "DNX_FIELD_KEYS_PER_STAGE_ALLOCATION_SW~KEYS_AVAILABILITY~KEYS_AVAILABILITY_STAGE_INFO~FIRST_AVAILABLE_KEY_ON_STAGE~",
};
#endif /* DNX_SW_STATE_DIAGNOSTIC */
#undef BSL_LOG_MODULE
