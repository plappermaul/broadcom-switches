/** \file algo/swstate/auto_generated/diagnostic/dnx_sch_alloc_mngr_diagnostic.c
 *
 * sw state functions definitions
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */
/*
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#ifdef BSL_LOG_MODULE
#error "BSL_LOG_MODULE redefined"
#endif
#define BSL_LOG_MODULE BSL_LS_SWSTATEDNX_GENERAL

#include <soc/dnxc/swstate/dnxc_sw_state_c_includes.h>
#include <bcm_int/dnx/algo/swstate/auto_generated/diagnostic/dnx_sch_alloc_mngr_diagnostic.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_device.h>
#if defined(DNX_SW_STATE_DIAGNOSTIC)
/*
 * Global Variables
 */

extern dnx_sch_alloc_db_t * sch_alloc_db_data[SOC_MAX_NUM_DEVICES];
/*
 * FUNCTIONs
 */

/*
 *
 * dump function for the variable sch_alloc_db
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
sch_alloc_db_dump(int  unit,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(sch_alloc_db_sch_flow_alloc_mngr_dump(unit, -1, -1, filters));
    SHR_IF_ERR_EXIT(sch_alloc_db_interface_dump(unit, -1, filters));
    SHR_IF_ERR_EXIT(sch_alloc_db_cl_class_alloc_mngr_dump(unit, -1, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable sch_flow_alloc_mngr
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
sch_alloc_db_sch_flow_alloc_mngr_dump(int  unit,  int  sch_flow_alloc_mngr_idx_0,  int  sch_flow_alloc_mngr_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = sch_flow_alloc_mngr_idx_0, I0 = sch_flow_alloc_mngr_idx_0 + 1;
    int i1 = sch_flow_alloc_mngr_idx_1, I1 = sch_flow_alloc_mngr_idx_1 + 1, org_i1 = sch_flow_alloc_mngr_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "dnx_algo_res_t") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "dnx_sch_alloc_mngr sch_flow_alloc_mngr") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate dnx_sch_alloc_mngr sch_flow_alloc_mngr\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "sch_alloc_db/sch_flow_alloc_mngr.txt",
            "sch_alloc_db[%d]->","((dnx_sch_alloc_db_t*)sw_state_roots_array[%d][DNX_SCH_ALLOC_MNGR_MODULE_ID])->","sch_flow_alloc_mngr[][]: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sch_alloc_db_t*)sw_state_roots_array[unit][DNX_SCH_ALLOC_MNGR_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sch_alloc_db_t*)sw_state_roots_array[unit][DNX_SCH_ALLOC_MNGR_MODULE_ID])->sch_flow_alloc_mngr);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                DNX_SCH_ALLOC_MNGR_MODULE_ID,
                ((dnx_sch_alloc_db_t*)sw_state_roots_array[unit][DNX_SCH_ALLOC_MNGR_MODULE_ID])->sch_flow_alloc_mngr);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sch_alloc_db_t*)sw_state_roots_array[unit][DNX_SCH_ALLOC_MNGR_MODULE_ID])->sch_flow_alloc_mngr
                , sizeof(*((dnx_sch_alloc_db_t*)sw_state_roots_array[unit][DNX_SCH_ALLOC_MNGR_MODULE_ID])->sch_flow_alloc_mngr), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, DNX_SCH_ALLOC_MNGR_MODULE_ID, ((dnx_sch_alloc_db_t*)sw_state_roots_array[unit][DNX_SCH_ALLOC_MNGR_MODULE_ID])->sch_flow_alloc_mngr))
        {
            LOG_CLI((BSL_META("sch_alloc_db[]->((dnx_sch_alloc_db_t*)sw_state_roots_array[][DNX_SCH_ALLOC_MNGR_MODULE_ID])->sch_flow_alloc_mngr[][]: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, DNX_SCH_ALLOC_MNGR_MODULE_ID, ((dnx_sch_alloc_db_t*)sw_state_roots_array[unit][DNX_SCH_ALLOC_MNGR_MODULE_ID])->sch_flow_alloc_mngr) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_sch_alloc_db_t*)sw_state_roots_array[unit][DNX_SCH_ALLOC_MNGR_MODULE_ID])->sch_flow_alloc_mngr[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    DNX_SCH_ALLOC_MNGR_MODULE_ID,
                    ((dnx_sch_alloc_db_t*)sw_state_roots_array[unit][DNX_SCH_ALLOC_MNGR_MODULE_ID])->sch_flow_alloc_mngr[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_sch_alloc_db_t*)sw_state_roots_array[unit][DNX_SCH_ALLOC_MNGR_MODULE_ID])->sch_flow_alloc_mngr[i0]
                    , sizeof(*((dnx_sch_alloc_db_t*)sw_state_roots_array[unit][DNX_SCH_ALLOC_MNGR_MODULE_ID])->sch_flow_alloc_mngr[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, DNX_SCH_ALLOC_MNGR_MODULE_ID, ((dnx_sch_alloc_db_t*)sw_state_roots_array[unit][DNX_SCH_ALLOC_MNGR_MODULE_ID])->sch_flow_alloc_mngr[i0]))
            {
                LOG_CLI((BSL_META("sch_alloc_db[]->((dnx_sch_alloc_db_t*)sw_state_roots_array[][DNX_SCH_ALLOC_MNGR_MODULE_ID])->sch_flow_alloc_mngr[][]: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, DNX_SCH_ALLOC_MNGR_MODULE_ID, ((dnx_sch_alloc_db_t*)sw_state_roots_array[unit][DNX_SCH_ALLOC_MNGR_MODULE_ID])->sch_flow_alloc_mngr[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "sch_alloc_db[%d]->","((dnx_sch_alloc_db_t*)sw_state_roots_array[%d][DNX_SCH_ALLOC_MNGR_MODULE_ID])->","sch_flow_alloc_mngr[%s%d][%s%d]: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                DNX_ALGO_RES_MNGR_PRINT(
                    unit,
                    DNX_SCH_ALLOC_MNGR_MODULE_ID,
                    &((dnx_sch_alloc_db_t*)sw_state_roots_array[unit][DNX_SCH_ALLOC_MNGR_MODULE_ID])->sch_flow_alloc_mngr[i0][i1]);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable interface
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
sch_alloc_db_interface_dump(int  unit,  int  interface_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = interface_idx_0, I0 = interface_idx_0 + 1;
    char *s0 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "dnx_algo_res_t") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "dnx_sch_alloc_mngr interface") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate dnx_sch_alloc_mngr interface\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "sch_alloc_db/interface.txt",
            "sch_alloc_db[%d]->","((dnx_sch_alloc_db_t*)sw_state_roots_array[%d][DNX_SCH_ALLOC_MNGR_MODULE_ID])->","interface[]: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sch_alloc_db_t*)sw_state_roots_array[unit][DNX_SCH_ALLOC_MNGR_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sch_alloc_db_t*)sw_state_roots_array[unit][DNX_SCH_ALLOC_MNGR_MODULE_ID])->interface);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                DNX_SCH_ALLOC_MNGR_MODULE_ID,
                ((dnx_sch_alloc_db_t*)sw_state_roots_array[unit][DNX_SCH_ALLOC_MNGR_MODULE_ID])->interface);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sch_alloc_db_t*)sw_state_roots_array[unit][DNX_SCH_ALLOC_MNGR_MODULE_ID])->interface
                , sizeof(*((dnx_sch_alloc_db_t*)sw_state_roots_array[unit][DNX_SCH_ALLOC_MNGR_MODULE_ID])->interface), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, DNX_SCH_ALLOC_MNGR_MODULE_ID, ((dnx_sch_alloc_db_t*)sw_state_roots_array[unit][DNX_SCH_ALLOC_MNGR_MODULE_ID])->interface))
        {
            LOG_CLI((BSL_META("sch_alloc_db[]->((dnx_sch_alloc_db_t*)sw_state_roots_array[][DNX_SCH_ALLOC_MNGR_MODULE_ID])->interface[]: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, DNX_SCH_ALLOC_MNGR_MODULE_ID, ((dnx_sch_alloc_db_t*)sw_state_roots_array[unit][DNX_SCH_ALLOC_MNGR_MODULE_ID])->interface) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            dnx_sw_state_dump_update_current_idx(unit, i0);
            DNX_SW_STATE_PRINT_MONITOR(
                unit,
                "sch_alloc_db[%d]->","((dnx_sch_alloc_db_t*)sw_state_roots_array[%d][DNX_SCH_ALLOC_MNGR_MODULE_ID])->","interface[%s%d]: ", s0, i0);

            DNX_SW_STATE_PRINT_FILE(
                unit,
                "[%s%d]: ", s0, i0);

            DNX_ALGO_RES_MNGR_PRINT(
                unit,
                DNX_SCH_ALLOC_MNGR_MODULE_ID,
                &((dnx_sch_alloc_db_t*)sw_state_roots_array[unit][DNX_SCH_ALLOC_MNGR_MODULE_ID])->interface[i0]);

        }
        dnx_sw_state_dump_end_of_stride(unit);
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable cl_class_alloc_mngr
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
sch_alloc_db_cl_class_alloc_mngr_dump(int  unit,  int  cl_class_alloc_mngr_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = cl_class_alloc_mngr_idx_0, I0 = cl_class_alloc_mngr_idx_0 + 1;
    char *s0 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "dnx_algo_template_t") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "dnx_sch_alloc_mngr cl_class_alloc_mngr") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate dnx_sch_alloc_mngr cl_class_alloc_mngr\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "sch_alloc_db/cl_class_alloc_mngr.txt",
            "sch_alloc_db[%d]->","((dnx_sch_alloc_db_t*)sw_state_roots_array[%d][DNX_SCH_ALLOC_MNGR_MODULE_ID])->","cl_class_alloc_mngr[]: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sch_alloc_db_t*)sw_state_roots_array[unit][DNX_SCH_ALLOC_MNGR_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sch_alloc_db_t*)sw_state_roots_array[unit][DNX_SCH_ALLOC_MNGR_MODULE_ID])->cl_class_alloc_mngr);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                DNX_SCH_ALLOC_MNGR_MODULE_ID,
                ((dnx_sch_alloc_db_t*)sw_state_roots_array[unit][DNX_SCH_ALLOC_MNGR_MODULE_ID])->cl_class_alloc_mngr);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sch_alloc_db_t*)sw_state_roots_array[unit][DNX_SCH_ALLOC_MNGR_MODULE_ID])->cl_class_alloc_mngr
                , sizeof(*((dnx_sch_alloc_db_t*)sw_state_roots_array[unit][DNX_SCH_ALLOC_MNGR_MODULE_ID])->cl_class_alloc_mngr), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, DNX_SCH_ALLOC_MNGR_MODULE_ID, ((dnx_sch_alloc_db_t*)sw_state_roots_array[unit][DNX_SCH_ALLOC_MNGR_MODULE_ID])->cl_class_alloc_mngr))
        {
            LOG_CLI((BSL_META("sch_alloc_db[]->((dnx_sch_alloc_db_t*)sw_state_roots_array[][DNX_SCH_ALLOC_MNGR_MODULE_ID])->cl_class_alloc_mngr[]: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, DNX_SCH_ALLOC_MNGR_MODULE_ID, ((dnx_sch_alloc_db_t*)sw_state_roots_array[unit][DNX_SCH_ALLOC_MNGR_MODULE_ID])->cl_class_alloc_mngr) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            dnx_sw_state_dump_update_current_idx(unit, i0);
            DNX_SW_STATE_PRINT_MONITOR(
                unit,
                "sch_alloc_db[%d]->","((dnx_sch_alloc_db_t*)sw_state_roots_array[%d][DNX_SCH_ALLOC_MNGR_MODULE_ID])->","cl_class_alloc_mngr[%s%d]: ", s0, i0);

            DNX_SW_STATE_PRINT_FILE(
                unit,
                "[%s%d]: ", s0, i0);

            DNX_ALGO_TEMP_MNGR_PRINT(
                unit,
                DNX_SCH_ALLOC_MNGR_MODULE_ID,
                &((dnx_sch_alloc_db_t*)sw_state_roots_array[unit][DNX_SCH_ALLOC_MNGR_MODULE_ID])->cl_class_alloc_mngr[i0],
                dnx_sch_cl_class_print_cb);

        }
        dnx_sw_state_dump_end_of_stride(unit);
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 * Global Variables
 */

dnx_sw_state_diagnostic_info_t sch_alloc_db_info[SOC_MAX_NUM_DEVICES][SCH_ALLOC_DB_INFO_NOF_ENTRIES];
const char* sch_alloc_db_layout_str[SCH_ALLOC_DB_INFO_NOF_ENTRIES] = {
    "SCH_ALLOC_DB~",
    "SCH_ALLOC_DB~SCH_FLOW_ALLOC_MNGR~",
    "SCH_ALLOC_DB~INTERFACE~",
    "SCH_ALLOC_DB~CL_CLASS_ALLOC_MNGR~",
};
#endif /* DNX_SW_STATE_DIAGNOSTIC */
#undef BSL_LOG_MODULE
