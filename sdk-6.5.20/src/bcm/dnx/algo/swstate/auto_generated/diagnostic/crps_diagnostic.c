/** \file algo/swstate/auto_generated/diagnostic/crps_diagnostic.c
 *
 * sw state functions definitions
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */
/*
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#ifdef BSL_LOG_MODULE
#error "BSL_LOG_MODULE redefined"
#endif
#define BSL_LOG_MODULE BSL_LS_SWSTATEDNX_GENERAL

#include <soc/dnxc/swstate/dnxc_sw_state_c_includes.h>
#include <bcm_int/dnx/algo/swstate/auto_generated/diagnostic/crps_diagnostic.h>
#if defined(DNX_SW_STATE_DIAGNOSTIC)
/*
 * Global Variables
 */

extern dnx_crps_db_t * dnx_crps_db_data[SOC_MAX_NUM_DEVICES];
/*
 * FUNCTIONs
 */

/*
 *
 * dump function for the variable dnx_crps_db
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_dump(int  unit,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_crps_db_proc_dump(unit, -1, -1, filters));
    SHR_IF_ERR_EXIT(dnx_crps_db_bg_thread_enable_dump(unit, filters));
    SHR_IF_ERR_EXIT(dnx_crps_db_database_dump(unit, -1, -1, filters));
    SHR_IF_ERR_EXIT(dnx_crps_db_database_res_dump(unit, -1, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable proc
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_proc_dump(int  unit,  int  proc_idx_0,  int  proc_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_crps_db_proc_used_for_meter_dump(unit, proc_idx_0,proc_idx_1, filters));
    SHR_IF_ERR_EXIT(dnx_crps_db_proc_config_started_dump(unit, proc_idx_0,proc_idx_1, filters));
    SHR_IF_ERR_EXIT(dnx_crps_db_proc_config_done_dump(unit, proc_idx_0,proc_idx_1, filters));
    SHR_IF_ERR_EXIT(dnx_crps_db_proc_enablers_dump(unit, proc_idx_0,proc_idx_1, filters));
    SHR_IF_ERR_EXIT(dnx_crps_db_proc_interface_dump(unit, proc_idx_0,proc_idx_1, filters));
    SHR_IF_ERR_EXIT(dnx_crps_db_proc_eviction_dump(unit, proc_idx_0,proc_idx_1, filters));
    SHR_IF_ERR_EXIT(dnx_crps_db_proc_log_obj_id_range_dump(unit, proc_idx_0,proc_idx_1, filters));
    SHR_IF_ERR_EXIT(dnx_crps_db_proc_counter_dump(unit, proc_idx_0,proc_idx_1, -1, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable used_for_meter
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_proc_used_for_meter_dump(int  unit,  int  proc_idx_0,  int  proc_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = proc_idx_0, I0 = proc_idx_0 + 1;
    int i1 = proc_idx_1, I1 = proc_idx_1 + 1, org_i1 = proc_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "crps proc used_for_meter") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate crps proc used_for_meter\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_crps_db/proc/used_for_meter.txt",
            "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[][].used_for_meter: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                CRPS_MODULE_ID,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc
                , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc))
        {
            LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].used_for_meter: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    CRPS_MODULE_ID,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]
                    , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]))
            {
                LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].used_for_meter: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[%s%d][%s%d].used_for_meter: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_int(
                    unit,
                    &((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0][i1].used_for_meter);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable config_started
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_proc_config_started_dump(int  unit,  int  proc_idx_0,  int  proc_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = proc_idx_0, I0 = proc_idx_0 + 1;
    int i1 = proc_idx_1, I1 = proc_idx_1 + 1, org_i1 = proc_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "crps proc config_started") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate crps proc config_started\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_crps_db/proc/config_started.txt",
            "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[][].config_started: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                CRPS_MODULE_ID,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc
                , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc))
        {
            LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].config_started: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    CRPS_MODULE_ID,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]
                    , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]))
            {
                LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].config_started: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[%s%d][%s%d].config_started: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_int(
                    unit,
                    &((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0][i1].config_started);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable config_done
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_proc_config_done_dump(int  unit,  int  proc_idx_0,  int  proc_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = proc_idx_0, I0 = proc_idx_0 + 1;
    int i1 = proc_idx_1, I1 = proc_idx_1 + 1, org_i1 = proc_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "crps proc config_done") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate crps proc config_done\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_crps_db/proc/config_done.txt",
            "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[][].config_done: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                CRPS_MODULE_ID,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc
                , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc))
        {
            LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].config_done: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    CRPS_MODULE_ID,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]
                    , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]))
            {
                LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].config_done: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[%s%d][%s%d].config_done: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_int(
                    unit,
                    &((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0][i1].config_done);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable enablers
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_proc_enablers_dump(int  unit,  int  proc_idx_0,  int  proc_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_crps_db_proc_enablers_counting_enable_dump(unit, proc_idx_0, proc_idx_1, filters));
    SHR_IF_ERR_EXIT(dnx_crps_db_proc_enablers_eviction_enable_dump(unit, proc_idx_0, proc_idx_1, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable counting_enable
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_proc_enablers_counting_enable_dump(int  unit,  int  proc_idx_0,  int  proc_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = proc_idx_0, I0 = proc_idx_0 + 1;
    int i1 = proc_idx_1, I1 = proc_idx_1 + 1, org_i1 = proc_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "crps proc enablers counting_enable") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate crps proc enablers counting_enable\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_crps_db/proc/enablers/counting_enable.txt",
            "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[][].enablers.counting_enable: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                CRPS_MODULE_ID,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc
                , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc))
        {
            LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].enablers.counting_enable: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    CRPS_MODULE_ID,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]
                    , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]))
            {
                LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].enablers.counting_enable: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[%s%d][%s%d].enablers.counting_enable: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_int(
                    unit,
                    &((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0][i1].enablers.counting_enable);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable eviction_enable
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_proc_enablers_eviction_enable_dump(int  unit,  int  proc_idx_0,  int  proc_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = proc_idx_0, I0 = proc_idx_0 + 1;
    int i1 = proc_idx_1, I1 = proc_idx_1 + 1, org_i1 = proc_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "crps proc enablers eviction_enable") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate crps proc enablers eviction_enable\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_crps_db/proc/enablers/eviction_enable.txt",
            "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[][].enablers.eviction_enable: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                CRPS_MODULE_ID,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc
                , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc))
        {
            LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].enablers.eviction_enable: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    CRPS_MODULE_ID,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]
                    , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]))
            {
                LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].enablers.eviction_enable: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[%s%d][%s%d].enablers.eviction_enable: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_int(
                    unit,
                    &((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0][i1].enablers.eviction_enable);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable interface
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_proc_interface_dump(int  unit,  int  proc_idx_0,  int  proc_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_crps_db_proc_interface_next_engine_id_dump(unit, proc_idx_0, proc_idx_1, filters));
    SHR_IF_ERR_EXIT(dnx_crps_db_proc_interface_prev_engine_id_dump(unit, proc_idx_0, proc_idx_1, filters));
    SHR_IF_ERR_EXIT(dnx_crps_db_proc_interface_database_id_dump(unit, proc_idx_0, proc_idx_1, filters));
    SHR_IF_ERR_EXIT(dnx_crps_db_proc_interface_src_type_dump(unit, proc_idx_0, proc_idx_1, filters));
    SHR_IF_ERR_EXIT(dnx_crps_db_proc_interface_command_id_dump(unit, proc_idx_0, proc_idx_1, filters));
    SHR_IF_ERR_EXIT(dnx_crps_db_proc_interface_format_dump(unit, proc_idx_0, proc_idx_1, filters));
    SHR_IF_ERR_EXIT(dnx_crps_db_proc_interface_counter_set_size_dump(unit, proc_idx_0, proc_idx_1, filters));
    SHR_IF_ERR_EXIT(dnx_crps_db_proc_interface_type_hw_valid_dump(unit, proc_idx_0, proc_idx_1, -1, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable next_engine_id
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_proc_interface_next_engine_id_dump(int  unit,  int  proc_idx_0,  int  proc_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = proc_idx_0, I0 = proc_idx_0 + 1;
    int i1 = proc_idx_1, I1 = proc_idx_1 + 1, org_i1 = proc_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "crps proc interface next_engine_id") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate crps proc interface next_engine_id\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_crps_db/proc/interface/next_engine_id.txt",
            "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[][].interface.next_engine_id: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                CRPS_MODULE_ID,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc
                , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc))
        {
            LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].interface.next_engine_id: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    CRPS_MODULE_ID,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]
                    , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]))
            {
                LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].interface.next_engine_id: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[%s%d][%s%d].interface.next_engine_id: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_int(
                    unit,
                    &((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0][i1].interface.next_engine_id);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable prev_engine_id
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_proc_interface_prev_engine_id_dump(int  unit,  int  proc_idx_0,  int  proc_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = proc_idx_0, I0 = proc_idx_0 + 1;
    int i1 = proc_idx_1, I1 = proc_idx_1 + 1, org_i1 = proc_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "crps proc interface prev_engine_id") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate crps proc interface prev_engine_id\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_crps_db/proc/interface/prev_engine_id.txt",
            "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[][].interface.prev_engine_id: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                CRPS_MODULE_ID,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc
                , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc))
        {
            LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].interface.prev_engine_id: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    CRPS_MODULE_ID,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]
                    , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]))
            {
                LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].interface.prev_engine_id: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[%s%d][%s%d].interface.prev_engine_id: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_int(
                    unit,
                    &((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0][i1].interface.prev_engine_id);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable database_id
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_proc_interface_database_id_dump(int  unit,  int  proc_idx_0,  int  proc_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = proc_idx_0, I0 = proc_idx_0 + 1;
    int i1 = proc_idx_1, I1 = proc_idx_1 + 1, org_i1 = proc_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "crps proc interface database_id") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate crps proc interface database_id\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_crps_db/proc/interface/database_id.txt",
            "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[][].interface.database_id: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                CRPS_MODULE_ID,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc
                , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc))
        {
            LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].interface.database_id: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    CRPS_MODULE_ID,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]
                    , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]))
            {
                LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].interface.database_id: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[%s%d][%s%d].interface.database_id: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_int(
                    unit,
                    &((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0][i1].interface.database_id);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable src_type
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_proc_interface_src_type_dump(int  unit,  int  proc_idx_0,  int  proc_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = proc_idx_0, I0 = proc_idx_0 + 1;
    int i1 = proc_idx_1, I1 = proc_idx_1 + 1, org_i1 = proc_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "bcm_stat_counter_interface_type_t") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "crps proc interface src_type") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate crps proc interface src_type\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_crps_db/proc/interface/src_type.txt",
            "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[][].interface.src_type: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                CRPS_MODULE_ID,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc
                , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc))
        {
            LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].interface.src_type: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    CRPS_MODULE_ID,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]
                    , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]))
            {
                LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].interface.src_type: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_OPAQUE_MONITOR(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0][i1].interface.src_type,
                    "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[%s%d][%s%d].interface.src_type: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_OPAQUE_FILE(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0][i1].interface.src_type,
                        "[%s%d][%s%d]: ", s0, i0, s1, i1);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable command_id
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_proc_interface_command_id_dump(int  unit,  int  proc_idx_0,  int  proc_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = proc_idx_0, I0 = proc_idx_0 + 1;
    int i1 = proc_idx_1, I1 = proc_idx_1 + 1, org_i1 = proc_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "crps proc interface command_id") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate crps proc interface command_id\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_crps_db/proc/interface/command_id.txt",
            "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[][].interface.command_id: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                CRPS_MODULE_ID,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc
                , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc))
        {
            LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].interface.command_id: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    CRPS_MODULE_ID,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]
                    , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]))
            {
                LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].interface.command_id: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[%s%d][%s%d].interface.command_id: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_int(
                    unit,
                    &((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0][i1].interface.command_id);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable format
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_proc_interface_format_dump(int  unit,  int  proc_idx_0,  int  proc_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = proc_idx_0, I0 = proc_idx_0 + 1;
    int i1 = proc_idx_1, I1 = proc_idx_1 + 1, org_i1 = proc_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "bcm_stat_counter_format_type_t") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "crps proc interface format") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate crps proc interface format\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_crps_db/proc/interface/format.txt",
            "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[][].interface.format: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                CRPS_MODULE_ID,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc
                , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc))
        {
            LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].interface.format: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    CRPS_MODULE_ID,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]
                    , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]))
            {
                LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].interface.format: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_OPAQUE_MONITOR(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0][i1].interface.format,
                    "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[%s%d][%s%d].interface.format: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_OPAQUE_FILE(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0][i1].interface.format,
                        "[%s%d][%s%d]: ", s0, i0, s1, i1);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable counter_set_size
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_proc_interface_counter_set_size_dump(int  unit,  int  proc_idx_0,  int  proc_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = proc_idx_0, I0 = proc_idx_0 + 1;
    int i1 = proc_idx_1, I1 = proc_idx_1 + 1, org_i1 = proc_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "crps proc interface counter_set_size") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate crps proc interface counter_set_size\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_crps_db/proc/interface/counter_set_size.txt",
            "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[][].interface.counter_set_size: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                CRPS_MODULE_ID,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc
                , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc))
        {
            LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].interface.counter_set_size: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    CRPS_MODULE_ID,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]
                    , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]))
            {
                LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].interface.counter_set_size: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[%s%d][%s%d].interface.counter_set_size: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_int(
                    unit,
                    &((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0][i1].interface.counter_set_size);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable type_hw_valid
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_proc_interface_type_hw_valid_dump(int  unit,  int  proc_idx_0,  int  proc_idx_1,  int  type_hw_valid_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = proc_idx_0, I0 = proc_idx_0 + 1;
    int i1 = proc_idx_1, I1 = proc_idx_1 + 1, org_i1 = proc_idx_1;
    int i2 = type_hw_valid_idx_0, I2 = type_hw_valid_idx_0 + 1, org_i2 = type_hw_valid_idx_0;
    char *s0 = "", *s1 = "", *s2 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "crps proc interface type_hw_valid") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate crps proc interface type_hw_valid\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_crps_db/proc/interface/type_hw_valid.txt",
            "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[][].interface.type_hw_valid[]: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                CRPS_MODULE_ID,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc
                , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc))
        {
            LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].interface.type_hw_valid[]: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    CRPS_MODULE_ID,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]
                    , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]))
            {
                LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].interface.type_hw_valid[]: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                if (i2 == -1) {
                    I2 = BCM_STAT_MAX_NUMBER_OF_OBJECT_TYPES;
                    i2 = dnx_sw_state_dump_check_all_the_same(unit,
                        ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0][i1].interface.type_hw_valid
                        , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0][i1].interface.type_hw_valid), I2, &s2) ? I2 - 1 : 0;
                }

                if(i2 >= BCM_STAT_MAX_NUMBER_OF_OBJECT_TYPES)
                {
                    LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].interface.type_hw_valid[]: ")));
                    LOG_CLI((BSL_META("Invalid index: %d \n"),i2));
                    SHR_EXIT();
                }

                if(BCM_STAT_MAX_NUMBER_OF_OBJECT_TYPES == 0)
                {
                    SHR_EXIT();
                }

                for(; i2 < I2; i2++) {
                    dnx_sw_state_dump_update_current_idx(unit, i2);
                    DNX_SW_STATE_PRINT_MONITOR(
                        unit,
                        "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[%s%d][%s%d].interface.type_hw_valid[%s%d]: ", s0, i0, s1, i1, s2, i2);

                    DNX_SW_STATE_PRINT_FILE(
                        unit,
                        "[%s%d][%s%d][%s%d]: ", s0, i0, s1, i1, s2, i2);

                    dnx_sw_state_print_int(
                        unit,
                        &((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0][i1].interface.type_hw_valid[i2]);

                }
                i2 = org_i2;
                dnx_sw_state_dump_end_of_stride(unit);
            }
            i1 = org_i1;
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable eviction
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_proc_eviction_dump(int  unit,  int  proc_idx_0,  int  proc_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_crps_db_proc_eviction_eviction_type_dump(unit, proc_idx_0, proc_idx_1, filters));
    SHR_IF_ERR_EXIT(dnx_crps_db_proc_eviction_record_format_dump(unit, proc_idx_0, proc_idx_1, filters));
    SHR_IF_ERR_EXIT(dnx_crps_db_proc_eviction_eviction_event_id_dump(unit, proc_idx_0, proc_idx_1, filters));
    SHR_IF_ERR_EXIT(dnx_crps_db_proc_eviction_sequential_timer_value_dump(unit, proc_idx_0, proc_idx_1, filters));
    SHR_IF_ERR_EXIT(dnx_crps_db_proc_eviction_dma_fifo_dump(unit, proc_idx_0, proc_idx_1, filters));
    SHR_IF_ERR_EXIT(dnx_crps_db_proc_eviction_eviction_algorithmic_disable_dump(unit, proc_idx_0, proc_idx_1, filters));
    SHR_IF_ERR_EXIT(dnx_crps_db_proc_eviction_conditional_dump(unit, proc_idx_0, proc_idx_1, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable eviction_type
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_proc_eviction_eviction_type_dump(int  unit,  int  proc_idx_0,  int  proc_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = proc_idx_0, I0 = proc_idx_0 + 1;
    int i1 = proc_idx_1, I1 = proc_idx_1 + 1, org_i1 = proc_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "bcm_eviction_destination_type_t") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "crps proc eviction eviction_type") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate crps proc eviction eviction_type\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_crps_db/proc/eviction/eviction_type.txt",
            "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[][].eviction.eviction_type: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                CRPS_MODULE_ID,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc
                , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc))
        {
            LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].eviction.eviction_type: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    CRPS_MODULE_ID,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]
                    , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]))
            {
                LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].eviction.eviction_type: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_OPAQUE_MONITOR(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0][i1].eviction.eviction_type,
                    "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[%s%d][%s%d].eviction.eviction_type: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_OPAQUE_FILE(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0][i1].eviction.eviction_type,
                        "[%s%d][%s%d]: ", s0, i0, s1, i1);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable record_format
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_proc_eviction_record_format_dump(int  unit,  int  proc_idx_0,  int  proc_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = proc_idx_0, I0 = proc_idx_0 + 1;
    int i1 = proc_idx_1, I1 = proc_idx_1 + 1, org_i1 = proc_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "bcm_eviction_record_format_t") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "crps proc eviction record_format") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate crps proc eviction record_format\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_crps_db/proc/eviction/record_format.txt",
            "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[][].eviction.record_format: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                CRPS_MODULE_ID,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc
                , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc))
        {
            LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].eviction.record_format: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    CRPS_MODULE_ID,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]
                    , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]))
            {
                LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].eviction.record_format: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_OPAQUE_MONITOR(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0][i1].eviction.record_format,
                    "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[%s%d][%s%d].eviction.record_format: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_OPAQUE_FILE(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0][i1].eviction.record_format,
                        "[%s%d][%s%d]: ", s0, i0, s1, i1);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable eviction_event_id
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_proc_eviction_eviction_event_id_dump(int  unit,  int  proc_idx_0,  int  proc_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = proc_idx_0, I0 = proc_idx_0 + 1;
    int i1 = proc_idx_1, I1 = proc_idx_1 + 1, org_i1 = proc_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "crps proc eviction eviction_event_id") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate crps proc eviction eviction_event_id\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_crps_db/proc/eviction/eviction_event_id.txt",
            "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[][].eviction.eviction_event_id: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                CRPS_MODULE_ID,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc
                , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc))
        {
            LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].eviction.eviction_event_id: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    CRPS_MODULE_ID,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]
                    , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]))
            {
                LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].eviction.eviction_event_id: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[%s%d][%s%d].eviction.eviction_event_id: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_int(
                    unit,
                    &((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0][i1].eviction.eviction_event_id);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable sequential_timer_value
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_proc_eviction_sequential_timer_value_dump(int  unit,  int  proc_idx_0,  int  proc_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = proc_idx_0, I0 = proc_idx_0 + 1;
    int i1 = proc_idx_1, I1 = proc_idx_1 + 1, org_i1 = proc_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "uint32") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "crps proc eviction sequential_timer_value") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate crps proc eviction sequential_timer_value\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_crps_db/proc/eviction/sequential_timer_value.txt",
            "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[][].eviction.sequential_timer_value: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                CRPS_MODULE_ID,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc
                , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc))
        {
            LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].eviction.sequential_timer_value: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    CRPS_MODULE_ID,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]
                    , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]))
            {
                LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].eviction.sequential_timer_value: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[%s%d][%s%d].eviction.sequential_timer_value: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_uint32(
                    unit,
                    &((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0][i1].eviction.sequential_timer_value);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable dma_fifo
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_proc_eviction_dma_fifo_dump(int  unit,  int  proc_idx_0,  int  proc_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = proc_idx_0, I0 = proc_idx_0 + 1;
    int i1 = proc_idx_1, I1 = proc_idx_1 + 1, org_i1 = proc_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "crps proc eviction dma_fifo") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate crps proc eviction dma_fifo\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_crps_db/proc/eviction/dma_fifo.txt",
            "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[][].eviction.dma_fifo: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                CRPS_MODULE_ID,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc
                , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc))
        {
            LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].eviction.dma_fifo: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    CRPS_MODULE_ID,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]
                    , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]))
            {
                LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].eviction.dma_fifo: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[%s%d][%s%d].eviction.dma_fifo: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_int(
                    unit,
                    &((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0][i1].eviction.dma_fifo);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable eviction_algorithmic_disable
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_proc_eviction_eviction_algorithmic_disable_dump(int  unit,  int  proc_idx_0,  int  proc_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = proc_idx_0, I0 = proc_idx_0 + 1;
    int i1 = proc_idx_1, I1 = proc_idx_1 + 1, org_i1 = proc_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "crps proc eviction eviction_algorithmic_disable") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate crps proc eviction eviction_algorithmic_disable\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_crps_db/proc/eviction/eviction_algorithmic_disable.txt",
            "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[][].eviction.eviction_algorithmic_disable: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                CRPS_MODULE_ID,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc
                , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc))
        {
            LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].eviction.eviction_algorithmic_disable: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    CRPS_MODULE_ID,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]
                    , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]))
            {
                LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].eviction.eviction_algorithmic_disable: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[%s%d][%s%d].eviction.eviction_algorithmic_disable: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_int(
                    unit,
                    &((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0][i1].eviction.eviction_algorithmic_disable);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable conditional
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_proc_eviction_conditional_dump(int  unit,  int  proc_idx_0,  int  proc_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_crps_db_proc_eviction_conditional_condition_source_select_dump(unit, proc_idx_0, proc_idx_1, filters));
    SHR_IF_ERR_EXIT(dnx_crps_db_proc_eviction_conditional_condition_user_data_dump(unit, proc_idx_0, proc_idx_1, filters));
    SHR_IF_ERR_EXIT(dnx_crps_db_proc_eviction_conditional_qualifier_dump(unit, proc_idx_0, proc_idx_1, filters));
    SHR_IF_ERR_EXIT(dnx_crps_db_proc_eviction_conditional_action_flags_dump(unit, proc_idx_0, proc_idx_1, filters));
    SHR_IF_ERR_EXIT(dnx_crps_db_proc_eviction_conditional_enable_dump(unit, proc_idx_0, proc_idx_1, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable condition_source_select
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_proc_eviction_conditional_condition_source_select_dump(int  unit,  int  proc_idx_0,  int  proc_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = proc_idx_0, I0 = proc_idx_0 + 1;
    int i1 = proc_idx_1, I1 = proc_idx_1 + 1, org_i1 = proc_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "bcm_stat_eviction_conditional_source_t") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "crps proc eviction conditional condition_source_select") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate crps proc eviction conditional condition_source_select\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_crps_db/proc/eviction/conditional/condition_source_select.txt",
            "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[][].eviction.conditional.condition_source_select: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                CRPS_MODULE_ID,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc
                , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc))
        {
            LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].eviction.conditional.condition_source_select: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    CRPS_MODULE_ID,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]
                    , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]))
            {
                LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].eviction.conditional.condition_source_select: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_OPAQUE_MONITOR(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0][i1].eviction.conditional.condition_source_select,
                    "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[%s%d][%s%d].eviction.conditional.condition_source_select: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_OPAQUE_FILE(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0][i1].eviction.conditional.condition_source_select,
                        "[%s%d][%s%d]: ", s0, i0, s1, i1);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable condition_user_data
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_proc_eviction_conditional_condition_user_data_dump(int  unit,  int  proc_idx_0,  int  proc_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = proc_idx_0, I0 = proc_idx_0 + 1;
    int i1 = proc_idx_1, I1 = proc_idx_1 + 1, org_i1 = proc_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "uint64") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "crps proc eviction conditional condition_user_data") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate crps proc eviction conditional condition_user_data\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_crps_db/proc/eviction/conditional/condition_user_data.txt",
            "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[][].eviction.conditional.condition_user_data: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                CRPS_MODULE_ID,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc
                , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc))
        {
            LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].eviction.conditional.condition_user_data: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    CRPS_MODULE_ID,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]
                    , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]))
            {
                LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].eviction.conditional.condition_user_data: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[%s%d][%s%d].eviction.conditional.condition_user_data: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_uint64(
                    unit,
                    &((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0][i1].eviction.conditional.condition_user_data);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable qualifier
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_proc_eviction_conditional_qualifier_dump(int  unit,  int  proc_idx_0,  int  proc_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = proc_idx_0, I0 = proc_idx_0 + 1;
    int i1 = proc_idx_1, I1 = proc_idx_1 + 1, org_i1 = proc_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "bcm_stat_eviction_conditional_qual_t") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "crps proc eviction conditional qualifier") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate crps proc eviction conditional qualifier\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_crps_db/proc/eviction/conditional/qualifier.txt",
            "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[][].eviction.conditional.qualifier: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                CRPS_MODULE_ID,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc
                , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc))
        {
            LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].eviction.conditional.qualifier: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    CRPS_MODULE_ID,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]
                    , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]))
            {
                LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].eviction.conditional.qualifier: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_OPAQUE_MONITOR(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0][i1].eviction.conditional.qualifier,
                    "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[%s%d][%s%d].eviction.conditional.qualifier: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_OPAQUE_FILE(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0][i1].eviction.conditional.qualifier,
                        "[%s%d][%s%d]: ", s0, i0, s1, i1);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable action_flags
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_proc_eviction_conditional_action_flags_dump(int  unit,  int  proc_idx_0,  int  proc_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = proc_idx_0, I0 = proc_idx_0 + 1;
    int i1 = proc_idx_1, I1 = proc_idx_1 + 1, org_i1 = proc_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "uint32") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "crps proc eviction conditional action_flags") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate crps proc eviction conditional action_flags\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_crps_db/proc/eviction/conditional/action_flags.txt",
            "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[][].eviction.conditional.action_flags: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                CRPS_MODULE_ID,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc
                , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc))
        {
            LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].eviction.conditional.action_flags: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    CRPS_MODULE_ID,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]
                    , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]))
            {
                LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].eviction.conditional.action_flags: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[%s%d][%s%d].eviction.conditional.action_flags: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_uint32(
                    unit,
                    &((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0][i1].eviction.conditional.action_flags);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable enable
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_proc_eviction_conditional_enable_dump(int  unit,  int  proc_idx_0,  int  proc_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = proc_idx_0, I0 = proc_idx_0 + 1;
    int i1 = proc_idx_1, I1 = proc_idx_1 + 1, org_i1 = proc_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "crps proc eviction conditional enable") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate crps proc eviction conditional enable\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_crps_db/proc/eviction/conditional/enable.txt",
            "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[][].eviction.conditional.enable: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                CRPS_MODULE_ID,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc
                , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc))
        {
            LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].eviction.conditional.enable: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    CRPS_MODULE_ID,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]
                    , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]))
            {
                LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].eviction.conditional.enable: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[%s%d][%s%d].eviction.conditional.enable: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_int(
                    unit,
                    &((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0][i1].eviction.conditional.enable);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable log_obj_id_range
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_proc_log_obj_id_range_dump(int  unit,  int  proc_idx_0,  int  proc_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_crps_db_proc_log_obj_id_range_logical_object_id_first_dump(unit, proc_idx_0, proc_idx_1, filters));
    SHR_IF_ERR_EXIT(dnx_crps_db_proc_log_obj_id_range_logical_object_id_last_dump(unit, proc_idx_0, proc_idx_1, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable logical_object_id_first
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_proc_log_obj_id_range_logical_object_id_first_dump(int  unit,  int  proc_idx_0,  int  proc_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = proc_idx_0, I0 = proc_idx_0 + 1;
    int i1 = proc_idx_1, I1 = proc_idx_1 + 1, org_i1 = proc_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "uint32") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "crps proc log_obj_id_range logical_object_id_first") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate crps proc log_obj_id_range logical_object_id_first\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_crps_db/proc/log_obj_id_range/logical_object_id_first.txt",
            "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[][].log_obj_id_range.logical_object_id_first: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                CRPS_MODULE_ID,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc
                , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc))
        {
            LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].log_obj_id_range.logical_object_id_first: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    CRPS_MODULE_ID,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]
                    , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]))
            {
                LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].log_obj_id_range.logical_object_id_first: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[%s%d][%s%d].log_obj_id_range.logical_object_id_first: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_uint32(
                    unit,
                    &((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0][i1].log_obj_id_range.logical_object_id_first);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable logical_object_id_last
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_proc_log_obj_id_range_logical_object_id_last_dump(int  unit,  int  proc_idx_0,  int  proc_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = proc_idx_0, I0 = proc_idx_0 + 1;
    int i1 = proc_idx_1, I1 = proc_idx_1 + 1, org_i1 = proc_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "uint32") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "crps proc log_obj_id_range logical_object_id_last") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate crps proc log_obj_id_range logical_object_id_last\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_crps_db/proc/log_obj_id_range/logical_object_id_last.txt",
            "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[][].log_obj_id_range.logical_object_id_last: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                CRPS_MODULE_ID,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc
                , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc))
        {
            LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].log_obj_id_range.logical_object_id_last: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    CRPS_MODULE_ID,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]
                    , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]))
            {
                LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->proc[][].log_obj_id_range.logical_object_id_last: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","proc[%s%d][%s%d].log_obj_id_range.logical_object_id_last: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_uint32(
                    unit,
                    &((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->proc[i0][i1].log_obj_id_range.logical_object_id_last);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable counter
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_proc_counter_dump(int  unit,  int  proc_idx_0,  int  proc_idx_1,  int  counter_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable bg_thread_enable
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_bg_thread_enable_dump(int  unit,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "crps bg_thread_enable") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate crps bg_thread_enable\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_crps_db/bg_thread_enable.txt",
            "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","bg_thread_enable: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID]));

        DNX_SW_STATE_PRINT_MONITOR(
            unit,
            "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","bg_thread_enable: ");

        DNX_SW_STATE_PRINT_FILE(
            unit,
            " ");

        dnx_sw_state_print_int(
            unit,
            &((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->bg_thread_enable);

        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable database
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_database_dump(int  unit,  int  database_idx_0,  int  database_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_crps_db_database_base_engine_dump(unit, database_idx_0,database_idx_1, filters));
    SHR_IF_ERR_EXIT(dnx_crps_db_database_type_dump(unit, database_idx_0,database_idx_1, -1, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable base_engine
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_database_base_engine_dump(int  unit,  int  database_idx_0,  int  database_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = database_idx_0, I0 = database_idx_0 + 1;
    int i1 = database_idx_1, I1 = database_idx_1 + 1, org_i1 = database_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "crps database base_engine") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate crps database base_engine\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_crps_db/database/base_engine.txt",
            "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","database[][].base_engine: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                CRPS_MODULE_ID,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database
                , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database))
        {
            LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->database[][].base_engine: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    CRPS_MODULE_ID,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0]
                    , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0]))
            {
                LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->database[][].base_engine: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","database[%s%d][%s%d].base_engine: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_int(
                    unit,
                    &((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0][i1].base_engine);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable type
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_database_type_dump(int  unit,  int  database_idx_0,  int  database_idx_1,  int  type_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_crps_db_database_type_valid_dump(unit, database_idx_0, database_idx_1, type_idx_0, filters));
    SHR_IF_ERR_EXIT(dnx_crps_db_database_type_offset_dump(unit, database_idx_0, database_idx_1, type_idx_0, filters));
    SHR_IF_ERR_EXIT(dnx_crps_db_database_type_start_dump(unit, database_idx_0, database_idx_1, type_idx_0, filters));
    SHR_IF_ERR_EXIT(dnx_crps_db_database_type_end_dump(unit, database_idx_0, database_idx_1, type_idx_0, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable valid
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_database_type_valid_dump(int  unit,  int  database_idx_0,  int  database_idx_1,  int  type_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = database_idx_0, I0 = database_idx_0 + 1;
    int i1 = database_idx_1, I1 = database_idx_1 + 1, org_i1 = database_idx_1;
    int i2 = type_idx_0, I2 = type_idx_0 + 1, org_i2 = type_idx_0;
    char *s0 = "", *s1 = "", *s2 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "uint32") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "crps database type valid") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate crps database type valid\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_crps_db/database/type/valid.txt",
            "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","database[][].type[].valid: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                CRPS_MODULE_ID,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database
                , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database))
        {
            LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->database[][].type[].valid: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    CRPS_MODULE_ID,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0]
                    , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0]))
            {
                LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->database[][].type[].valid: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                if (i2 == -1) {
                    I2 = BCM_STAT_MAX_NUMBER_OF_OBJECT_TYPES;
                    i2 = dnx_sw_state_dump_check_all_the_same(unit,
                        ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0][i1].type
                        , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0][i1].type), I2, &s2) ? I2 - 1 : 0;
                }

                if(i2 >= BCM_STAT_MAX_NUMBER_OF_OBJECT_TYPES)
                {
                    LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->database[][].type[].valid: ")));
                    LOG_CLI((BSL_META("Invalid index: %d \n"),i2));
                    SHR_EXIT();
                }

                if(BCM_STAT_MAX_NUMBER_OF_OBJECT_TYPES == 0)
                {
                    SHR_EXIT();
                }

                for(; i2 < I2; i2++) {
                    dnx_sw_state_dump_update_current_idx(unit, i2);
                    DNX_SW_STATE_PRINT_MONITOR(
                        unit,
                        "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","database[%s%d][%s%d].type[%s%d].valid: ", s0, i0, s1, i1, s2, i2);

                    DNX_SW_STATE_PRINT_FILE(
                        unit,
                        "[%s%d][%s%d][%s%d]: ", s0, i0, s1, i1, s2, i2);

                    dnx_sw_state_print_uint32(
                        unit,
                        &((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0][i1].type[i2].valid);

                }
                i2 = org_i2;
                dnx_sw_state_dump_end_of_stride(unit);
            }
            i1 = org_i1;
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable offset
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_database_type_offset_dump(int  unit,  int  database_idx_0,  int  database_idx_1,  int  type_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = database_idx_0, I0 = database_idx_0 + 1;
    int i1 = database_idx_1, I1 = database_idx_1 + 1, org_i1 = database_idx_1;
    int i2 = type_idx_0, I2 = type_idx_0 + 1, org_i2 = type_idx_0;
    char *s0 = "", *s1 = "", *s2 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "uint32") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "crps database type offset") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate crps database type offset\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_crps_db/database/type/offset.txt",
            "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","database[][].type[].offset: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                CRPS_MODULE_ID,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database
                , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database))
        {
            LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->database[][].type[].offset: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    CRPS_MODULE_ID,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0]
                    , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0]))
            {
                LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->database[][].type[].offset: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                if (i2 == -1) {
                    I2 = BCM_STAT_MAX_NUMBER_OF_OBJECT_TYPES;
                    i2 = dnx_sw_state_dump_check_all_the_same(unit,
                        ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0][i1].type
                        , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0][i1].type), I2, &s2) ? I2 - 1 : 0;
                }

                if(i2 >= BCM_STAT_MAX_NUMBER_OF_OBJECT_TYPES)
                {
                    LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->database[][].type[].offset: ")));
                    LOG_CLI((BSL_META("Invalid index: %d \n"),i2));
                    SHR_EXIT();
                }

                if(BCM_STAT_MAX_NUMBER_OF_OBJECT_TYPES == 0)
                {
                    SHR_EXIT();
                }

                for(; i2 < I2; i2++) {
                    dnx_sw_state_dump_update_current_idx(unit, i2);
                    DNX_SW_STATE_PRINT_MONITOR(
                        unit,
                        "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","database[%s%d][%s%d].type[%s%d].offset: ", s0, i0, s1, i1, s2, i2);

                    DNX_SW_STATE_PRINT_FILE(
                        unit,
                        "[%s%d][%s%d][%s%d]: ", s0, i0, s1, i1, s2, i2);

                    dnx_sw_state_print_uint32(
                        unit,
                        &((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0][i1].type[i2].offset);

                }
                i2 = org_i2;
                dnx_sw_state_dump_end_of_stride(unit);
            }
            i1 = org_i1;
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable start
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_database_type_start_dump(int  unit,  int  database_idx_0,  int  database_idx_1,  int  type_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = database_idx_0, I0 = database_idx_0 + 1;
    int i1 = database_idx_1, I1 = database_idx_1 + 1, org_i1 = database_idx_1;
    int i2 = type_idx_0, I2 = type_idx_0 + 1, org_i2 = type_idx_0;
    char *s0 = "", *s1 = "", *s2 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "crps database type start") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate crps database type start\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_crps_db/database/type/start.txt",
            "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","database[][].type[].start: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                CRPS_MODULE_ID,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database
                , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database))
        {
            LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->database[][].type[].start: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    CRPS_MODULE_ID,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0]
                    , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0]))
            {
                LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->database[][].type[].start: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                if (i2 == -1) {
                    I2 = BCM_STAT_MAX_NUMBER_OF_OBJECT_TYPES;
                    i2 = dnx_sw_state_dump_check_all_the_same(unit,
                        ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0][i1].type
                        , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0][i1].type), I2, &s2) ? I2 - 1 : 0;
                }

                if(i2 >= BCM_STAT_MAX_NUMBER_OF_OBJECT_TYPES)
                {
                    LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->database[][].type[].start: ")));
                    LOG_CLI((BSL_META("Invalid index: %d \n"),i2));
                    SHR_EXIT();
                }

                if(BCM_STAT_MAX_NUMBER_OF_OBJECT_TYPES == 0)
                {
                    SHR_EXIT();
                }

                for(; i2 < I2; i2++) {
                    dnx_sw_state_dump_update_current_idx(unit, i2);
                    DNX_SW_STATE_PRINT_MONITOR(
                        unit,
                        "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","database[%s%d][%s%d].type[%s%d].start: ", s0, i0, s1, i1, s2, i2);

                    DNX_SW_STATE_PRINT_FILE(
                        unit,
                        "[%s%d][%s%d][%s%d]: ", s0, i0, s1, i1, s2, i2);

                    dnx_sw_state_print_int(
                        unit,
                        &((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0][i1].type[i2].start);

                }
                i2 = org_i2;
                dnx_sw_state_dump_end_of_stride(unit);
            }
            i1 = org_i1;
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable end
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_database_type_end_dump(int  unit,  int  database_idx_0,  int  database_idx_1,  int  type_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = database_idx_0, I0 = database_idx_0 + 1;
    int i1 = database_idx_1, I1 = database_idx_1 + 1, org_i1 = database_idx_1;
    int i2 = type_idx_0, I2 = type_idx_0 + 1, org_i2 = type_idx_0;
    char *s0 = "", *s1 = "", *s2 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "crps database type end") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate crps database type end\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_crps_db/database/type/end.txt",
            "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","database[][].type[].end: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                CRPS_MODULE_ID,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database
                , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database))
        {
            LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->database[][].type[].end: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    CRPS_MODULE_ID,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0]
                    , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0]))
            {
                LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->database[][].type[].end: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                if (i2 == -1) {
                    I2 = BCM_STAT_MAX_NUMBER_OF_OBJECT_TYPES;
                    i2 = dnx_sw_state_dump_check_all_the_same(unit,
                        ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0][i1].type
                        , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0][i1].type), I2, &s2) ? I2 - 1 : 0;
                }

                if(i2 >= BCM_STAT_MAX_NUMBER_OF_OBJECT_TYPES)
                {
                    LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->database[][].type[].end: ")));
                    LOG_CLI((BSL_META("Invalid index: %d \n"),i2));
                    SHR_EXIT();
                }

                if(BCM_STAT_MAX_NUMBER_OF_OBJECT_TYPES == 0)
                {
                    SHR_EXIT();
                }

                for(; i2 < I2; i2++) {
                    dnx_sw_state_dump_update_current_idx(unit, i2);
                    DNX_SW_STATE_PRINT_MONITOR(
                        unit,
                        "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","database[%s%d][%s%d].type[%s%d].end: ", s0, i0, s1, i1, s2, i2);

                    DNX_SW_STATE_PRINT_FILE(
                        unit,
                        "[%s%d][%s%d][%s%d]: ", s0, i0, s1, i1, s2, i2);

                    dnx_sw_state_print_int(
                        unit,
                        &((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database[i0][i1].type[i2].end);

                }
                i2 = org_i2;
                dnx_sw_state_dump_end_of_stride(unit);
            }
            i1 = org_i1;
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable database_res
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_crps_db_database_res_dump(int  unit,  int  database_res_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = database_res_idx_0, I0 = database_res_idx_0 + 1;
    char *s0 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "dnx_algo_res_t") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "crps database_res") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate crps database_res\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_crps_db/database_res.txt",
            "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","database_res[]: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database_res);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                CRPS_MODULE_ID,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database_res);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database_res
                , sizeof(*((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database_res), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database_res))
        {
            LOG_CLI((BSL_META("dnx_crps_db[]->((dnx_crps_db_t*)sw_state_roots_array[][CRPS_MODULE_ID])->database_res[]: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, CRPS_MODULE_ID, ((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database_res) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            dnx_sw_state_dump_update_current_idx(unit, i0);
            DNX_SW_STATE_PRINT_MONITOR(
                unit,
                "dnx_crps_db[%d]->","((dnx_crps_db_t*)sw_state_roots_array[%d][CRPS_MODULE_ID])->","database_res[%s%d]: ", s0, i0);

            DNX_SW_STATE_PRINT_FILE(
                unit,
                "[%s%d]: ", s0, i0);

            DNX_ALGO_RES_MNGR_PRINT(
                unit,
                CRPS_MODULE_ID,
                &((dnx_crps_db_t*)sw_state_roots_array[unit][CRPS_MODULE_ID])->database_res[i0]);

        }
        dnx_sw_state_dump_end_of_stride(unit);
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 * Global Variables
 */

dnx_sw_state_diagnostic_info_t dnx_crps_db_info[SOC_MAX_NUM_DEVICES][DNX_CRPS_DB_INFO_NOF_ENTRIES];
const char* dnx_crps_db_layout_str[DNX_CRPS_DB_INFO_NOF_ENTRIES] = {
    "DNX_CRPS_DB~",
    "DNX_CRPS_DB~PROC~",
    "DNX_CRPS_DB~PROC~USED_FOR_METER~",
    "DNX_CRPS_DB~PROC~CONFIG_STARTED~",
    "DNX_CRPS_DB~PROC~CONFIG_DONE~",
    "DNX_CRPS_DB~PROC~ENABLERS~",
    "DNX_CRPS_DB~PROC~ENABLERS~COUNTING_ENABLE~",
    "DNX_CRPS_DB~PROC~ENABLERS~EVICTION_ENABLE~",
    "DNX_CRPS_DB~PROC~INTERFACE~",
    "DNX_CRPS_DB~PROC~INTERFACE~NEXT_ENGINE_ID~",
    "DNX_CRPS_DB~PROC~INTERFACE~PREV_ENGINE_ID~",
    "DNX_CRPS_DB~PROC~INTERFACE~DATABASE_ID~",
    "DNX_CRPS_DB~PROC~INTERFACE~SRC_TYPE~",
    "DNX_CRPS_DB~PROC~INTERFACE~COMMAND_ID~",
    "DNX_CRPS_DB~PROC~INTERFACE~FORMAT~",
    "DNX_CRPS_DB~PROC~INTERFACE~COUNTER_SET_SIZE~",
    "DNX_CRPS_DB~PROC~INTERFACE~TYPE_HW_VALID~",
    "DNX_CRPS_DB~PROC~EVICTION~",
    "DNX_CRPS_DB~PROC~EVICTION~EVICTION_TYPE~",
    "DNX_CRPS_DB~PROC~EVICTION~RECORD_FORMAT~",
    "DNX_CRPS_DB~PROC~EVICTION~EVICTION_EVENT_ID~",
    "DNX_CRPS_DB~PROC~EVICTION~SEQUENTIAL_TIMER_VALUE~",
    "DNX_CRPS_DB~PROC~EVICTION~DMA_FIFO~",
    "DNX_CRPS_DB~PROC~EVICTION~EVICTION_ALGORITHMIC_DISABLE~",
    "DNX_CRPS_DB~PROC~EVICTION~CONDITIONAL~",
    "DNX_CRPS_DB~PROC~EVICTION~CONDITIONAL~CONDITION_SOURCE_SELECT~",
    "DNX_CRPS_DB~PROC~EVICTION~CONDITIONAL~CONDITION_USER_DATA~",
    "DNX_CRPS_DB~PROC~EVICTION~CONDITIONAL~QUALIFIER~",
    "DNX_CRPS_DB~PROC~EVICTION~CONDITIONAL~ACTION_FLAGS~",
    "DNX_CRPS_DB~PROC~EVICTION~CONDITIONAL~ENABLE~",
    "DNX_CRPS_DB~PROC~LOG_OBJ_ID_RANGE~",
    "DNX_CRPS_DB~PROC~LOG_OBJ_ID_RANGE~LOGICAL_OBJECT_ID_FIRST~",
    "DNX_CRPS_DB~PROC~LOG_OBJ_ID_RANGE~LOGICAL_OBJECT_ID_LAST~",
    "DNX_CRPS_DB~PROC~COUNTER~",
    "DNX_CRPS_DB~BG_THREAD_ENABLE~",
    "DNX_CRPS_DB~DATABASE~",
    "DNX_CRPS_DB~DATABASE~BASE_ENGINE~",
    "DNX_CRPS_DB~DATABASE~TYPE~",
    "DNX_CRPS_DB~DATABASE~TYPE~VALID~",
    "DNX_CRPS_DB~DATABASE~TYPE~OFFSET~",
    "DNX_CRPS_DB~DATABASE~TYPE~START~",
    "DNX_CRPS_DB~DATABASE~TYPE~END~",
    "DNX_CRPS_DB~DATABASE_RES~",
};
#endif /* DNX_SW_STATE_DIAGNOSTIC */
#undef BSL_LOG_MODULE
