/** \file algo/swstate/auto_generated/diagnostic/sec_diagnostic.c
 *
 * sw state functions definitions
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */
/*
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#ifdef BSL_LOG_MODULE
#error "BSL_LOG_MODULE redefined"
#endif
#define BSL_LOG_MODULE BSL_LS_SWSTATEDNX_GENERAL

#include <soc/dnxc/swstate/dnxc_sw_state_c_includes.h>
#include <bcm_int/dnx/algo/swstate/auto_generated/diagnostic/sec_diagnostic.h>
#if defined(DNX_SW_STATE_DIAGNOSTIC)
/*
 * Global Variables
 */

extern dnx_sec_t * dnx_sec_db_data[SOC_MAX_NUM_DEVICES];
/*
 * FUNCTIONs
 */

/*
 *
 * dump function for the variable dnx_sec_db
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_sec_db_dump(int  unit,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_sec_db_ingress_sec_dump(unit, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_egress_sec_dump(unit, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_control_sec_dump(unit, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable ingress_sec
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_sec_db_ingress_sec_dump(int  unit,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_sec_db_ingress_sec_flow_res_mngr_dump(unit, -1, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_ingress_sec_policy_res_mngr_dump(unit, -1, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_ingress_sec_sc_res_mngr_dump(unit, -1, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_ingress_sec_sc_tcam_res_mngr_dump(unit, -1, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_ingress_sec_sa_res_mngr_dump(unit, -1, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_ingress_sec_default_policy_id_dump(unit, -1, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_ingress_sec_sc_index_map_dump(unit, -1, -1, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_ingress_sec_sa_index_info_dump(unit, -1, -1, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable flow_res_mngr
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_sec_db_ingress_sec_flow_res_mngr_dump(int  unit,  int  flow_res_mngr_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = flow_res_mngr_idx_0, I0 = flow_res_mngr_idx_0 + 1;
    char *s0 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "dnx_algo_res_t") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec ingress_sec flow_res_mngr") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec ingress_sec flow_res_mngr\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/ingress_sec/flow_res_mngr.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.flow_res_mngr[]: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.flow_res_mngr);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                SEC_MODULE_ID,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.flow_res_mngr);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.flow_res_mngr
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.flow_res_mngr), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.flow_res_mngr))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->ingress_sec.flow_res_mngr[]: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.flow_res_mngr) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            dnx_sw_state_dump_update_current_idx(unit, i0);
            DNX_SW_STATE_PRINT_MONITOR(
                unit,
                "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.flow_res_mngr[%s%d]: ", s0, i0);

            DNX_SW_STATE_PRINT_FILE(
                unit,
                "[%s%d]: ", s0, i0);

            DNX_ALGO_RES_MNGR_PRINT(
                unit,
                SEC_MODULE_ID,
                &((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.flow_res_mngr[i0]);

        }
        dnx_sw_state_dump_end_of_stride(unit);
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable policy_res_mngr
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_sec_db_ingress_sec_policy_res_mngr_dump(int  unit,  int  policy_res_mngr_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = policy_res_mngr_idx_0, I0 = policy_res_mngr_idx_0 + 1;
    char *s0 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "dnx_algo_res_t") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec ingress_sec policy_res_mngr") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec ingress_sec policy_res_mngr\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/ingress_sec/policy_res_mngr.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.policy_res_mngr[]: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.policy_res_mngr);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                SEC_MODULE_ID,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.policy_res_mngr);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.policy_res_mngr
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.policy_res_mngr), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.policy_res_mngr))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->ingress_sec.policy_res_mngr[]: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.policy_res_mngr) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            dnx_sw_state_dump_update_current_idx(unit, i0);
            DNX_SW_STATE_PRINT_MONITOR(
                unit,
                "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.policy_res_mngr[%s%d]: ", s0, i0);

            DNX_SW_STATE_PRINT_FILE(
                unit,
                "[%s%d]: ", s0, i0);

            DNX_ALGO_RES_MNGR_PRINT(
                unit,
                SEC_MODULE_ID,
                &((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.policy_res_mngr[i0]);

        }
        dnx_sw_state_dump_end_of_stride(unit);
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable sc_res_mngr
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_sec_db_ingress_sec_sc_res_mngr_dump(int  unit,  int  sc_res_mngr_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = sc_res_mngr_idx_0, I0 = sc_res_mngr_idx_0 + 1;
    char *s0 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "dnx_algo_res_t") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec ingress_sec sc_res_mngr") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec ingress_sec sc_res_mngr\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/ingress_sec/sc_res_mngr.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.sc_res_mngr[]: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_res_mngr);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                SEC_MODULE_ID,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_res_mngr);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_res_mngr
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_res_mngr), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_res_mngr))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->ingress_sec.sc_res_mngr[]: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_res_mngr) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            dnx_sw_state_dump_update_current_idx(unit, i0);
            DNX_SW_STATE_PRINT_MONITOR(
                unit,
                "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.sc_res_mngr[%s%d]: ", s0, i0);

            DNX_SW_STATE_PRINT_FILE(
                unit,
                "[%s%d]: ", s0, i0);

            DNX_ALGO_RES_MNGR_PRINT(
                unit,
                SEC_MODULE_ID,
                &((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_res_mngr[i0]);

        }
        dnx_sw_state_dump_end_of_stride(unit);
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable sc_tcam_res_mngr
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_sec_db_ingress_sec_sc_tcam_res_mngr_dump(int  unit,  int  sc_tcam_res_mngr_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = sc_tcam_res_mngr_idx_0, I0 = sc_tcam_res_mngr_idx_0 + 1;
    char *s0 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "dnx_algo_res_t") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec ingress_sec sc_tcam_res_mngr") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec ingress_sec sc_tcam_res_mngr\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/ingress_sec/sc_tcam_res_mngr.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.sc_tcam_res_mngr[]: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_tcam_res_mngr);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                SEC_MODULE_ID,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_tcam_res_mngr);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_tcam_res_mngr
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_tcam_res_mngr), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_tcam_res_mngr))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->ingress_sec.sc_tcam_res_mngr[]: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_tcam_res_mngr) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            dnx_sw_state_dump_update_current_idx(unit, i0);
            DNX_SW_STATE_PRINT_MONITOR(
                unit,
                "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.sc_tcam_res_mngr[%s%d]: ", s0, i0);

            DNX_SW_STATE_PRINT_FILE(
                unit,
                "[%s%d]: ", s0, i0);

            DNX_ALGO_RES_MNGR_PRINT(
                unit,
                SEC_MODULE_ID,
                &((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_tcam_res_mngr[i0]);

        }
        dnx_sw_state_dump_end_of_stride(unit);
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable sa_res_mngr
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_sec_db_ingress_sec_sa_res_mngr_dump(int  unit,  int  sa_res_mngr_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = sa_res_mngr_idx_0, I0 = sa_res_mngr_idx_0 + 1;
    char *s0 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "dnx_algo_res_t") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec ingress_sec sa_res_mngr") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec ingress_sec sa_res_mngr\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/ingress_sec/sa_res_mngr.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.sa_res_mngr[]: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_res_mngr);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                SEC_MODULE_ID,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_res_mngr);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_res_mngr
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_res_mngr), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_res_mngr))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->ingress_sec.sa_res_mngr[]: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_res_mngr) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            dnx_sw_state_dump_update_current_idx(unit, i0);
            DNX_SW_STATE_PRINT_MONITOR(
                unit,
                "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.sa_res_mngr[%s%d]: ", s0, i0);

            DNX_SW_STATE_PRINT_FILE(
                unit,
                "[%s%d]: ", s0, i0);

            DNX_ALGO_RES_MNGR_PRINT(
                unit,
                SEC_MODULE_ID,
                &((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_res_mngr[i0]);

        }
        dnx_sw_state_dump_end_of_stride(unit);
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable default_policy_id
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_sec_db_ingress_sec_default_policy_id_dump(int  unit,  int  default_policy_id_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = default_policy_id_idx_0, I0 = default_policy_id_idx_0 + 1;
    char *s0 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec ingress_sec default_policy_id") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec ingress_sec default_policy_id\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/ingress_sec/default_policy_id.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.default_policy_id[]: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.default_policy_id);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                SEC_MODULE_ID,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.default_policy_id);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.default_policy_id
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.default_policy_id), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.default_policy_id))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->ingress_sec.default_policy_id[]: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.default_policy_id) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            dnx_sw_state_dump_update_current_idx(unit, i0);
            DNX_SW_STATE_PRINT_MONITOR(
                unit,
                "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.default_policy_id[%s%d]: ", s0, i0);

            DNX_SW_STATE_PRINT_FILE(
                unit,
                "[%s%d]: ", s0, i0);

            dnx_sw_state_print_int(
                unit,
                &((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.default_policy_id[i0]);

        }
        dnx_sw_state_dump_end_of_stride(unit);
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable sc_index_map
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_sec_db_ingress_sec_sc_index_map_dump(int  unit,  int  sc_index_map_idx_0,  int  sc_index_map_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_sec_db_ingress_sec_sc_index_map_sc_tcam_index_dump(unit, sc_index_map_idx_0,sc_index_map_idx_1, -1, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_ingress_sec_sc_index_map_is_ipsec_dump(unit, sc_index_map_idx_0,sc_index_map_idx_1, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable sc_tcam_index
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_sec_db_ingress_sec_sc_index_map_sc_tcam_index_dump(int  unit,  int  sc_index_map_idx_0,  int  sc_index_map_idx_1,  int  sc_tcam_index_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = sc_index_map_idx_0, I0 = sc_index_map_idx_0 + 1;
    int i1 = sc_index_map_idx_1, I1 = sc_index_map_idx_1 + 1, org_i1 = sc_index_map_idx_1;
    int i2 = sc_tcam_index_idx_0, I2 = sc_tcam_index_idx_0 + 1, org_i2 = sc_tcam_index_idx_0;
    char *s0 = "", *s1 = "", *s2 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec ingress_sec sc_index_map sc_tcam_index") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec ingress_sec sc_index_map sc_tcam_index\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/ingress_sec/sc_index_map/sc_tcam_index.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.sc_index_map[][].sc_tcam_index[]: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                SEC_MODULE_ID,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->ingress_sec.sc_index_map[][].sc_tcam_index[]: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    SEC_MODULE_ID,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map[i0]
                    , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map[i0]))
            {
                LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->ingress_sec.sc_index_map[][].sc_tcam_index[]: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                if (i2 == -1) {
                    I2 = 2;
                    i2 = dnx_sw_state_dump_check_all_the_same(unit,
                        ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map[i0][i1].sc_tcam_index
                        , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map[i0][i1].sc_tcam_index), I2, &s2) ? I2 - 1 : 0;
                }

                if(i2 >= 2)
                {
                    LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->ingress_sec.sc_index_map[][].sc_tcam_index[]: ")));
                    LOG_CLI((BSL_META("Invalid index: %d \n"),i2));
                    SHR_EXIT();
                }

                if(2 == 0)
                {
                    SHR_EXIT();
                }

                for(; i2 < I2; i2++) {
                    dnx_sw_state_dump_update_current_idx(unit, i2);
                    DNX_SW_STATE_PRINT_MONITOR(
                        unit,
                        "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.sc_index_map[%s%d][%s%d].sc_tcam_index[%s%d]: ", s0, i0, s1, i1, s2, i2);

                    DNX_SW_STATE_PRINT_FILE(
                        unit,
                        "[%s%d][%s%d][%s%d]: ", s0, i0, s1, i1, s2, i2);

                    dnx_sw_state_print_int(
                        unit,
                        &((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map[i0][i1].sc_tcam_index[i2]);

                }
                i2 = org_i2;
                dnx_sw_state_dump_end_of_stride(unit);
            }
            i1 = org_i1;
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable is_ipsec
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_sec_db_ingress_sec_sc_index_map_is_ipsec_dump(int  unit,  int  sc_index_map_idx_0,  int  sc_index_map_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = sc_index_map_idx_0, I0 = sc_index_map_idx_0 + 1;
    int i1 = sc_index_map_idx_1, I1 = sc_index_map_idx_1 + 1, org_i1 = sc_index_map_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec ingress_sec sc_index_map is_ipsec") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec ingress_sec sc_index_map is_ipsec\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/ingress_sec/sc_index_map/is_ipsec.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.sc_index_map[][].is_ipsec: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                SEC_MODULE_ID,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->ingress_sec.sc_index_map[][].is_ipsec: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    SEC_MODULE_ID,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map[i0]
                    , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map[i0]))
            {
                LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->ingress_sec.sc_index_map[][].is_ipsec: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.sc_index_map[%s%d][%s%d].is_ipsec: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_int(
                    unit,
                    &((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sc_index_map[i0][i1].is_ipsec);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable sa_index_info
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_sec_db_ingress_sec_sa_index_info_dump(int  unit,  int  sa_index_info_idx_0,  int  sa_index_info_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_sec_db_ingress_sec_sa_index_info_is_ipsec_dump(unit, sa_index_info_idx_0,sa_index_info_idx_1, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable is_ipsec
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_sec_db_ingress_sec_sa_index_info_is_ipsec_dump(int  unit,  int  sa_index_info_idx_0,  int  sa_index_info_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = sa_index_info_idx_0, I0 = sa_index_info_idx_0 + 1;
    int i1 = sa_index_info_idx_1, I1 = sa_index_info_idx_1 + 1, org_i1 = sa_index_info_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec ingress_sec sa_index_info is_ipsec") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec ingress_sec sa_index_info is_ipsec\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/ingress_sec/sa_index_info/is_ipsec.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.sa_index_info[][].is_ipsec: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_index_info);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                SEC_MODULE_ID,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_index_info);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_index_info
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_index_info), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_index_info))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->ingress_sec.sa_index_info[][].is_ipsec: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_index_info) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_index_info[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    SEC_MODULE_ID,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_index_info[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_index_info[i0]
                    , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_index_info[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_index_info[i0]))
            {
                LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->ingress_sec.sa_index_info[][].is_ipsec: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_index_info[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","ingress_sec.sa_index_info[%s%d][%s%d].is_ipsec: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_int(
                    unit,
                    &((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->ingress_sec.sa_index_info[i0][i1].is_ipsec);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable egress_sec
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_sec_db_egress_sec_dump(int  unit,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_sec_db_egress_sec_sc_res_mngr_dump(unit, -1, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_egress_sec_sa_res_mngr_dump(unit, -1, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_egress_sec_sa_index_info_dump(unit, -1, -1, filters));
    SHR_IF_ERR_EXIT(dnx_sec_db_egress_sec_sc_index_info_dump(unit, -1, -1, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable sc_res_mngr
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_sec_db_egress_sec_sc_res_mngr_dump(int  unit,  int  sc_res_mngr_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = sc_res_mngr_idx_0, I0 = sc_res_mngr_idx_0 + 1;
    char *s0 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "dnx_algo_res_t") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec egress_sec sc_res_mngr") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec egress_sec sc_res_mngr\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/egress_sec/sc_res_mngr.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","egress_sec.sc_res_mngr[]: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_res_mngr);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                SEC_MODULE_ID,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_res_mngr);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_res_mngr
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_res_mngr), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_res_mngr))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->egress_sec.sc_res_mngr[]: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_res_mngr) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            dnx_sw_state_dump_update_current_idx(unit, i0);
            DNX_SW_STATE_PRINT_MONITOR(
                unit,
                "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","egress_sec.sc_res_mngr[%s%d]: ", s0, i0);

            DNX_SW_STATE_PRINT_FILE(
                unit,
                "[%s%d]: ", s0, i0);

            DNX_ALGO_RES_MNGR_PRINT(
                unit,
                SEC_MODULE_ID,
                &((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_res_mngr[i0]);

        }
        dnx_sw_state_dump_end_of_stride(unit);
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable sa_res_mngr
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_sec_db_egress_sec_sa_res_mngr_dump(int  unit,  int  sa_res_mngr_idx_0,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = sa_res_mngr_idx_0, I0 = sa_res_mngr_idx_0 + 1;
    char *s0 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "dnx_algo_res_t") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec egress_sec sa_res_mngr") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec egress_sec sa_res_mngr\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/egress_sec/sa_res_mngr.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","egress_sec.sa_res_mngr[]: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_res_mngr);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                SEC_MODULE_ID,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_res_mngr);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_res_mngr
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_res_mngr), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_res_mngr))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->egress_sec.sa_res_mngr[]: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_res_mngr) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            dnx_sw_state_dump_update_current_idx(unit, i0);
            DNX_SW_STATE_PRINT_MONITOR(
                unit,
                "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","egress_sec.sa_res_mngr[%s%d]: ", s0, i0);

            DNX_SW_STATE_PRINT_FILE(
                unit,
                "[%s%d]: ", s0, i0);

            DNX_ALGO_RES_MNGR_PRINT(
                unit,
                SEC_MODULE_ID,
                &((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_res_mngr[i0]);

        }
        dnx_sw_state_dump_end_of_stride(unit);
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable sa_index_info
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_sec_db_egress_sec_sa_index_info_dump(int  unit,  int  sa_index_info_idx_0,  int  sa_index_info_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_sec_db_egress_sec_sa_index_info_is_ipsec_dump(unit, sa_index_info_idx_0,sa_index_info_idx_1, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable is_ipsec
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_sec_db_egress_sec_sa_index_info_is_ipsec_dump(int  unit,  int  sa_index_info_idx_0,  int  sa_index_info_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = sa_index_info_idx_0, I0 = sa_index_info_idx_0 + 1;
    int i1 = sa_index_info_idx_1, I1 = sa_index_info_idx_1 + 1, org_i1 = sa_index_info_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec egress_sec sa_index_info is_ipsec") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec egress_sec sa_index_info is_ipsec\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/egress_sec/sa_index_info/is_ipsec.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","egress_sec.sa_index_info[][].is_ipsec: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_index_info);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                SEC_MODULE_ID,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_index_info);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_index_info
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_index_info), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_index_info))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->egress_sec.sa_index_info[][].is_ipsec: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_index_info) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_index_info[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    SEC_MODULE_ID,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_index_info[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_index_info[i0]
                    , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_index_info[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_index_info[i0]))
            {
                LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->egress_sec.sa_index_info[][].is_ipsec: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_index_info[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","egress_sec.sa_index_info[%s%d][%s%d].is_ipsec: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_int(
                    unit,
                    &((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sa_index_info[i0][i1].is_ipsec);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable sc_index_info
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_sec_db_egress_sec_sc_index_info_dump(int  unit,  int  sc_index_info_idx_0,  int  sc_index_info_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_sec_db_egress_sec_sc_index_info_is_ipsec_dump(unit, sc_index_info_idx_0,sc_index_info_idx_1, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable is_ipsec
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_sec_db_egress_sec_sc_index_info_is_ipsec_dump(int  unit,  int  sc_index_info_idx_0,  int  sc_index_info_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = sc_index_info_idx_0, I0 = sc_index_info_idx_0 + 1;
    int i1 = sc_index_info_idx_1, I1 = sc_index_info_idx_1 + 1, org_i1 = sc_index_info_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec egress_sec sc_index_info is_ipsec") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec egress_sec sc_index_info is_ipsec\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/egress_sec/sc_index_info/is_ipsec.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","egress_sec.sc_index_info[][].is_ipsec: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_index_info);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                SEC_MODULE_ID,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_index_info);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_index_info
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_index_info), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_index_info))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->egress_sec.sc_index_info[][].is_ipsec: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_index_info) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_index_info[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    SEC_MODULE_ID,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_index_info[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_index_info[i0]
                    , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_index_info[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_index_info[i0]))
            {
                LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->egress_sec.sc_index_info[][].is_ipsec: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_index_info[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","egress_sec.sc_index_info[%s%d][%s%d].is_ipsec: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_int(
                    unit,
                    &((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->egress_sec.sc_index_info[i0][i1].is_ipsec);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable control_sec
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_sec_db_control_sec_dump(int  unit,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_sec_db_control_sec_trunk_info_dump(unit, -1, -1, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable trunk_info
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_sec_db_control_sec_trunk_info_dump(int  unit,  int  trunk_info_idx_0,  int  trunk_info_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    DNXC_SW_STATE_INIT_FUNC_DEFS;
    SHR_IF_ERR_EXIT(dnx_sec_db_control_sec_trunk_info_is_macsec_enabled_dump(unit, trunk_info_idx_0,trunk_info_idx_1, filters));
    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 *
 * dump function for the variable is_macsec_enabled
 * AUTO-GENERATED - DO NOT MODIFY
 */
int
dnx_sec_db_control_sec_trunk_info_is_macsec_enabled_dump(int  unit,  int  trunk_info_idx_0,  int  trunk_info_idx_1,  dnx_sw_state_dump_filters_t  filters)
{
    int i0 = trunk_info_idx_0, I0 = trunk_info_idx_0 + 1;
    int i1 = trunk_info_idx_1, I1 = trunk_info_idx_1 + 1, org_i1 = trunk_info_idx_1;
    char *s0 = "", *s1 = "";
    DNXC_SW_STATE_INIT_FUNC_DEFS;

    if (dnx_sw_state_compare(filters.typefilter, "int") != TRUE)
    {
         SHR_EXIT();
    }

    if (dnx_sw_state_compare(filters.namefilter, "sec control_sec trunk_info is_macsec_enabled") != TRUE)
    {
         SHR_EXIT();
    }

    if (filters.nocontent)
    {
         DNX_SW_STATE_PRINT(unit, "swstate sec control_sec trunk_info is_macsec_enabled\n");
    }
    else
    {
        dnx_sw_state_dump_attach_file(
            unit,
            "dnx_sec_db/control_sec/trunk_info/is_macsec_enabled.txt",
            "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","control_sec.trunk_info[][].is_macsec_enabled: ");

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID]));

        DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
            unit,
            ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.trunk_info);

        if (i0 == -1) {
            I0 = dnx_sw_state_get_nof_elements(unit,
                SEC_MODULE_ID,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.trunk_info);
            i0 = dnx_sw_state_dump_check_all_the_same(unit,
                ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.trunk_info
                , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.trunk_info), I0, &s0) ? I0 - 1 : 0;
        }

        if(i0 >= dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.trunk_info))
        {
            LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->control_sec.trunk_info[][].is_macsec_enabled: ")));
            LOG_CLI((BSL_META("Invalid index: %d \n"),i0));
            SHR_EXIT();
        }

        if(dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.trunk_info) == 0)
        {
            SHR_EXIT();
        }

        for(; i0 < I0; i0++) {
            /*coverity explanation: coverity has detected an out of bound read, due to i0 being incremented;
            However, we have a check if i0 > the end condition of the loop. If the check catches that i0 has
            reached the value of the end condition, we exit the function.
            What coverity is catching is the last increment of i0 before the loop ends. */
            /* coverity[overrun-local:FALSE] */
                DNX_SW_STATE_DUMP_PTR_NULL_CHECK(
                    unit,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.trunk_info[i0]);

            if (i1 == -1) {
                I1 = dnx_sw_state_get_nof_elements(unit,
                    SEC_MODULE_ID,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.trunk_info[i0]);
                i1 = dnx_sw_state_dump_check_all_the_same(unit,
                    ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.trunk_info[i0]
                    , sizeof(*((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.trunk_info[i0]), I1, &s1) ? I1 - 1 : 0;
            }

            if(i1 >= dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.trunk_info[i0]))
            {
                LOG_CLI((BSL_META("dnx_sec_db[]->((dnx_sec_t*)sw_state_roots_array[][SEC_MODULE_ID])->control_sec.trunk_info[][].is_macsec_enabled: ")));
                LOG_CLI((BSL_META("Invalid index: %d \n"),i1));
                SHR_EXIT();
            }

            if(dnx_sw_state_get_nof_elements(unit, SEC_MODULE_ID, ((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.trunk_info[i0]) == 0)
            {
                SHR_EXIT();
            }

            for(; i1 < I1; i1++) {
                dnx_sw_state_dump_update_current_idx(unit, i1);
                DNX_SW_STATE_PRINT_MONITOR(
                    unit,
                    "dnx_sec_db[%d]->","((dnx_sec_t*)sw_state_roots_array[%d][SEC_MODULE_ID])->","control_sec.trunk_info[%s%d][%s%d].is_macsec_enabled: ", s0, i0, s1, i1);

                DNX_SW_STATE_PRINT_FILE(
                    unit,
                    "[%s%d][%s%d]: ", s0, i0, s1, i1);

                dnx_sw_state_print_int(
                    unit,
                    &((dnx_sec_t*)sw_state_roots_array[unit][SEC_MODULE_ID])->control_sec.trunk_info[i0][i1].is_macsec_enabled);

            }
            i1 = org_i1;
            dnx_sw_state_dump_end_of_stride(unit);
        }
        dnx_sw_state_dump_detach_file(
            unit);

    }

    DNXC_SW_STATE_FUNC_RETURN;
}



/*
 * Global Variables
 */

dnx_sw_state_diagnostic_info_t dnx_sec_db_info[SOC_MAX_NUM_DEVICES][DNX_SEC_DB_INFO_NOF_ENTRIES];
const char* dnx_sec_db_layout_str[DNX_SEC_DB_INFO_NOF_ENTRIES] = {
    "DNX_SEC_DB~",
    "DNX_SEC_DB~INGRESS_SEC~",
    "DNX_SEC_DB~INGRESS_SEC~FLOW_RES_MNGR~",
    "DNX_SEC_DB~INGRESS_SEC~POLICY_RES_MNGR~",
    "DNX_SEC_DB~INGRESS_SEC~SC_RES_MNGR~",
    "DNX_SEC_DB~INGRESS_SEC~SC_TCAM_RES_MNGR~",
    "DNX_SEC_DB~INGRESS_SEC~SA_RES_MNGR~",
    "DNX_SEC_DB~INGRESS_SEC~DEFAULT_POLICY_ID~",
    "DNX_SEC_DB~INGRESS_SEC~SC_INDEX_MAP~",
    "DNX_SEC_DB~INGRESS_SEC~SC_INDEX_MAP~SC_TCAM_INDEX~",
    "DNX_SEC_DB~INGRESS_SEC~SC_INDEX_MAP~IS_IPSEC~",
    "DNX_SEC_DB~INGRESS_SEC~SA_INDEX_INFO~",
    "DNX_SEC_DB~INGRESS_SEC~SA_INDEX_INFO~IS_IPSEC~",
    "DNX_SEC_DB~EGRESS_SEC~",
    "DNX_SEC_DB~EGRESS_SEC~SC_RES_MNGR~",
    "DNX_SEC_DB~EGRESS_SEC~SA_RES_MNGR~",
    "DNX_SEC_DB~EGRESS_SEC~SA_INDEX_INFO~",
    "DNX_SEC_DB~EGRESS_SEC~SA_INDEX_INFO~IS_IPSEC~",
    "DNX_SEC_DB~EGRESS_SEC~SC_INDEX_INFO~",
    "DNX_SEC_DB~EGRESS_SEC~SC_INDEX_INFO~IS_IPSEC~",
    "DNX_SEC_DB~CONTROL_SEC~",
    "DNX_SEC_DB~CONTROL_SEC~TRUNK_INFO~",
    "DNX_SEC_DB~CONTROL_SEC~TRUNK_INFO~IS_MACSEC_ENABLED~",
};
#endif /* DNX_SW_STATE_DIAGNOSTIC */
#undef BSL_LOG_MODULE
