
/*
 *         
 * 
 * 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 *         
 *     
 * DO NOT EDIT THIS FILE!
 */

#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX family only!"
#endif /* BCM_DNX_SUPPORT */

#include <bcm/port.h>
#include <bcm_int/dnx/port/imb/imb_common.h>
#include <bcm_int/dnx/port/imb/imb_internal.h>
#include <soc/portmod/portmod.h>
#include <soc/dnx/swstate/auto_generated/access/dnx_port_imb_access.h>
#include <soc/dnx/swstate/auto_generated/types/dnx_port_imb_types.h>
#include <shared/shrextend/shrextend_debug.h>
#include <bcm_int/dnx/port/imb/imb.h>
#include <bcm_int/dnx/port/imb/imb_dispatch.h>

#ifdef BSL_LOG_MODULE
#error "BSL_LOG_MODULE redefined"
#endif
#define BSL_LOG_MODULE BSL_LS_BCMDNX_PORT

const __imb__dispatch__t__ imb_None_driver = { NULL };
extern __imb__dispatch__t__ imb_imb_cdu_driver;
extern __imb__dispatch__t__ imb_imb_clu_driver;
extern __imb__dispatch__t__ imb_imb_ile_driver;
extern __imb__dispatch__t__ imb_imb_ilu_driver;
extern __imb__dispatch__t__ imb_imb_feu_driver;
extern __imb__dispatch__t__ imb_imb_feu_phy_driver;
extern __imb__dispatch__t__ imb_imb_fabric_driver;

const __imb__dispatch__t__ *__imb__dispatch__[imbDispatchTypeCount] = {
    &imb_None_driver,
    &imb_imb_cdu_driver,
    &imb_imb_clu_driver,
    &imb_imb_ile_driver,
    &imb_imb_ilu_driver,
    &imb_imb_feu_driver,
    &imb_imb_feu_phy_driver,
    &imb_imb_fabric_driver,

};

int
imb_dispatch_type_t_validate(
    int unit,
    imb_dispatch_type_t imb_dispatch_type)
{
    SHR_FUNC_INIT_VARS(unit);
    if (imb_dispatch_type >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Parameter is out of range");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_cdu_create_info_t_validate(
    int unit,
    const imb_cdu_create_info_t * imb_cdu_create_info)
{
    SHR_FUNC_INIT_VARS(unit);
    if (imb_cdu_create_info == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "NULL parameter");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_cdu_create_info_t_init(
    int unit,
    imb_cdu_create_info_t * imb_cdu_create_info)
{
    SHR_FUNC_INIT_VARS(unit);

    if (imb_cdu_create_info == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "imb_cdu_create_info NULL parameter");
    }
    sal_memset(imb_cdu_create_info, 0, sizeof(imb_cdu_create_info_t));
    imb_cdu_create_info->user_acc = NULL;

exit:
    SHR_FUNC_EXIT;

}

int
imb_clu_create_info_t_validate(
    int unit,
    const imb_clu_create_info_t * imb_clu_create_info)
{
    SHR_FUNC_INIT_VARS(unit);
    if (imb_clu_create_info == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "NULL parameter");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_clu_create_info_t_init(
    int unit,
    imb_clu_create_info_t * imb_clu_create_info)
{
    SHR_FUNC_INIT_VARS(unit);

    if (imb_clu_create_info == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "imb_clu_create_info NULL parameter");
    }
    sal_memset(imb_clu_create_info, 0, sizeof(imb_clu_create_info_t));
    imb_clu_create_info->user_acc = NULL;

exit:
    SHR_FUNC_EXIT;

}

int
imb_ile_create_info_t_validate(
    int unit,
    const imb_ile_create_info_t * imb_ile_create_info)
{
    SHR_FUNC_INIT_VARS(unit);
    if (imb_ile_create_info == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "NULL parameter");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_ile_create_info_t_init(
    int unit,
    imb_ile_create_info_t * imb_ile_create_info)
{
    SHR_FUNC_INIT_VARS(unit);

    if (imb_ile_create_info == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "imb_ile_create_info NULL parameter");
    }
    sal_memset(imb_ile_create_info, 0, sizeof(imb_ile_create_info_t));
    imb_ile_create_info->stub = 0;

exit:
    SHR_FUNC_EXIT;

}

int
imb_feu_create_info_t_validate(
    int unit,
    const imb_feu_create_info_t * imb_feu_create_info)
{
    SHR_FUNC_INIT_VARS(unit);
    if (imb_feu_create_info == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "NULL parameter");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_feu_create_info_t_init(
    int unit,
    imb_feu_create_info_t * imb_feu_create_info)
{
    SHR_FUNC_INIT_VARS(unit);

    if (imb_feu_create_info == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "imb_feu_create_info NULL parameter");
    }
    sal_memset(imb_feu_create_info, 0, sizeof(imb_feu_create_info_t));
    imb_feu_create_info->stub = 0;

exit:
    SHR_FUNC_EXIT;

}

int
imb_feu_phy_create_info_t_validate(
    int unit,
    const imb_feu_phy_create_info_t * imb_feu_phy_create_info)
{
    SHR_FUNC_INIT_VARS(unit);
    if (imb_feu_phy_create_info == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "NULL parameter");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_feu_phy_create_info_t_init(
    int unit,
    imb_feu_phy_create_info_t * imb_feu_phy_create_info)
{
    SHR_FUNC_INIT_VARS(unit);

    if (imb_feu_phy_create_info == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "imb_feu_phy_create_info NULL parameter");
    }
    sal_memset(imb_feu_phy_create_info, 0, sizeof(imb_feu_phy_create_info_t));
    imb_feu_phy_create_info->stub = 0;

exit:
    SHR_FUNC_EXIT;

}

int
imb_fabric_create_info_t_validate(
    int unit,
    const imb_fabric_create_info_t * imb_fabric_create_info)
{
    SHR_FUNC_INIT_VARS(unit);
    if (imb_fabric_create_info == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "NULL parameter");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_fabric_create_info_t_init(
    int unit,
    imb_fabric_create_info_t * imb_fabric_create_info)
{
    SHR_FUNC_INIT_VARS(unit);

    if (imb_fabric_create_info == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "imb_fabric_create_info NULL parameter");
    }
    sal_memset(imb_fabric_create_info, 0, sizeof(imb_fabric_create_info_t));
    imb_fabric_create_info->stub = 0;

exit:
    SHR_FUNC_EXIT;

}

int
imb_create_info_t_validate(
    int unit,
    const imb_create_info_t * imb_create_info)
{
    SHR_FUNC_INIT_VARS(unit);
    if (imb_create_info == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "NULL parameter");
    }

    if (_SHR_E_NONE != imb_dispatch_type_t_validate(unit, imb_create_info->type))
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "type validation failed");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_create_info_t_init(
    int unit,
    imb_create_info_t * imb_create_info)
{
    SHR_FUNC_INIT_VARS(unit);

    if (imb_create_info == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "imb_create_info NULL parameter");
    }
    sal_memset(imb_create_info, 0, sizeof(imb_create_info_t));
    imb_create_info->type = imbDispatchTypeNone;
    imb_create_info->inst_id = -1;
    sal_memset(&(imb_create_info->imb_specific_info), 0, sizeof(imb_specific_create_info_t));

exit:
    SHR_FUNC_EXIT;

}

int
imb_init(
    int unit,
    const imb_create_info_t * imb_info,
    imb_specific_create_info_t * imb_specific_info)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (_SHR_E_NONE != imb_create_info_t_validate(unit, imb_info))
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "imb_info validation failed");
    }

    if (imb_specific_info == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "imb_specific_info NULL parameter");
    }
    /*
     * Dispatch 
     */
    __type__ = (imb_info)->type;
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_init)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_init(unit, imb_info, imb_specific_info);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_init isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_deinit(
    int unit,
    const imb_create_info_t * imb_info,
    imb_specific_create_info_t * imb_specific_info)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (_SHR_E_NONE != imb_create_info_t_validate(unit, imb_info))
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "imb_info validation failed");
    }

    if (imb_specific_info == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "imb_specific_info NULL parameter");
    }
    /*
     * Dispatch 
     */
    __type__ = (imb_info)->type;
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_deinit)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_deinit(unit, imb_info, imb_specific_info);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_deinit isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_pad_size_set(
    int unit,
    bcm_port_t port,
    int value)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_pad_size_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_pad_size_set(unit, port, value);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_pad_size_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_pad_size_get(
    int unit,
    bcm_port_t port,
    int *value)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (value == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "value NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_pad_size_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_pad_size_get(unit, port, value);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_pad_size_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_attach(
    int unit,
    bcm_port_t port,
    uint32 flags)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_attach)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_attach(unit, port, flags);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_attach isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_detach(
    int unit,
    bcm_port_t port)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_detach)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_detach(unit, port);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_detach isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_enable_set(
    int unit,
    bcm_port_t port,
    uint32 flags,
    int enable)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_enable_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_enable_set(unit, port, flags, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_enable_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_enable_get(
    int unit,
    bcm_port_t port,
    int *enable)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (enable == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "enable NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_enable_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_enable_get(unit, port, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_enable_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_rx_data_enable_set(
    int unit,
    bcm_port_t port,
    int enable)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_rx_data_enable_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_rx_data_enable_set(unit, port, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_rx_data_enable_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_loopback_set(
    int unit,
    bcm_port_t port,
    int loopback)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_loopback_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_loopback_set(unit, port, loopback);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_loopback_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_loopback_get(
    int unit,
    bcm_port_t port,
    int *loopback)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (loopback == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "loopback NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_loopback_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_loopback_get(unit, port, loopback);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_loopback_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_link_state_get(
    int unit,
    bcm_port_t port,
    int clear_status,
    bcm_port_link_state_t * link_state)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (link_state == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "link_state NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_link_state_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_link_state_get(unit, port, clear_status, link_state);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_link_state_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_eee_enable_set(
    int unit,
    bcm_port_t port,
    int enable)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_eee_enable_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_eee_enable_set(unit, port, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_eee_enable_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_eee_enable_get(
    int unit,
    bcm_port_t port,
    int *enable)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (enable == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "enable NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_eee_enable_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_eee_enable_get(unit, port, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_eee_enable_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_link_up_mac_update(
    int unit,
    bcm_port_t port,
    int link)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_link_up_mac_update)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_link_up_mac_update(unit, port, link);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_link_up_mac_update isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_priority_config_set(
    int unit,
    bcm_port_t port,
    const bcm_port_prio_config_t * priority_config)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_priority_config_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_priority_config_set(unit, port, priority_config);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_priority_config_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_priority_config_get(
    int unit,
    bcm_port_t port,
    bcm_port_prio_config_t * priority_config)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (priority_config == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "priority_config NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_priority_config_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_priority_config_get(unit, port, priority_config);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_priority_config_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_phy_measure_get(
    int unit,
    bcm_port_t port,
    int is_rx,
    soc_dnxc_port_phy_measure_t * phy_measure)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (phy_measure == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "phy_measure NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_phy_measure_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_phy_measure_get(unit, port, is_rx, phy_measure);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_phy_measure_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_over_sampling_get(
    int unit,
    bcm_port_t port,
    uint32 *os_int,
    uint32 *os_remainder)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (os_int == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "os_int NULL parameter");
    }
    if (os_remainder == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "os_remainder NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_over_sampling_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_over_sampling_get(unit, port, os_int, os_remainder);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_over_sampling_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_autoneg_set(
    int unit,
    bcm_port_t port,
    uint32 phy_flags,
    const phymod_autoneg_control_t * an)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_autoneg_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_autoneg_set(unit, port, phy_flags, an);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_autoneg_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_autoneg_get(
    int unit,
    bcm_port_t port,
    uint32 phy_flags,
    phymod_autoneg_control_t * an)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (an == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "an NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_autoneg_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_autoneg_get(unit, port, phy_flags, an);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_autoneg_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_link_get(
    int unit,
    bcm_port_t port,
    int flags,
    int *link)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (link == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "link NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_link_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_link_get(unit, port, flags, link);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_link_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_max_packet_size_set(
    int unit,
    bcm_port_t port,
    int value)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_max_packet_size_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_max_packet_size_set(unit, port, value);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_max_packet_size_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_max_packet_size_get(
    int unit,
    bcm_port_t port,
    int *value)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (value == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "value NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_max_packet_size_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_max_packet_size_get(unit, port, value);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_max_packet_size_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_tx_average_ipg_set(
    int unit,
    bcm_port_t port,
    int ipg_value)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_tx_average_ipg_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_tx_average_ipg_set(unit, port, ipg_value);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_tx_average_ipg_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_tx_average_ipg_get(
    int unit,
    bcm_port_t port,
    int *ipg_value)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (ipg_value == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "ipg_value NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_tx_average_ipg_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_tx_average_ipg_get(unit, port, ipg_value);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_tx_average_ipg_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_duplex_set(
    int unit,
    bcm_port_t port,
    int enable)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_duplex_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_duplex_set(unit, port, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_duplex_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_duplex_get(
    int unit,
    bcm_port_t port,
    int *enable)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (enable == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "enable NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_duplex_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_duplex_get(unit, port, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_duplex_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_cntmaxsize_set(
    int unit,
    bcm_port_t port,
    int val)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_cntmaxsize_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_cntmaxsize_set(unit, port, val);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_cntmaxsize_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_cntmaxsize_get(
    int unit,
    bcm_port_t port,
    int *val)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (val == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "val NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_cntmaxsize_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_cntmaxsize_get(unit, port, val);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_cntmaxsize_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_local_fault_status_get(
    int unit,
    bcm_port_t port,
    int *local_fault)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (local_fault == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "local_fault NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_local_fault_status_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_local_fault_status_get(unit, port, local_fault);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_local_fault_status_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_local_fault_status_clear(
    int unit,
    bcm_port_t port)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_local_fault_status_clear)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_local_fault_status_clear(unit, port);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_local_fault_status_clear isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_remote_fault_status_get(
    int unit,
    bcm_port_t port,
    int *remote_fault)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (remote_fault == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "remote_fault NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_remote_fault_status_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_remote_fault_status_get(unit, port, remote_fault);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_remote_fault_status_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_remote_fault_status_clear(
    int unit,
    bcm_port_t port)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_remote_fault_status_clear)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_remote_fault_status_clear(unit, port);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_remote_fault_status_clear isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_local_fault_enable_set(
    int unit,
    bcm_port_t port,
    int enable)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_local_fault_enable_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_local_fault_enable_set(unit, port, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_local_fault_enable_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_local_fault_enable_get(
    int unit,
    bcm_port_t port,
    int *enable)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (enable == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "enable NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_local_fault_enable_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_local_fault_enable_get(unit, port, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_local_fault_enable_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_remote_fault_enable_set(
    int unit,
    bcm_port_t port,
    int enable)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_remote_fault_enable_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_remote_fault_enable_set(unit, port, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_remote_fault_enable_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_remote_fault_enable_get(
    int unit,
    bcm_port_t port,
    int *enable)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (enable == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "enable NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_remote_fault_enable_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_remote_fault_enable_get(unit, port, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_remote_fault_enable_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_tx_mac_sa_set(
    int unit,
    bcm_port_t port,
    sal_mac_addr_t mac_sa)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_tx_mac_sa_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_tx_mac_sa_set(unit, port, mac_sa);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_tx_mac_sa_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_tx_mac_sa_get(
    int unit,
    bcm_port_t port,
    sal_mac_addr_t mac_sa)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_tx_mac_sa_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_tx_mac_sa_get(unit, port, mac_sa);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_tx_mac_sa_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_rx_mac_sa_set(
    int unit,
    bcm_port_t port,
    sal_mac_addr_t mac_sa)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_rx_mac_sa_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_rx_mac_sa_set(unit, port, mac_sa);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_rx_mac_sa_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_rx_mac_sa_get(
    int unit,
    bcm_port_t port,
    sal_mac_addr_t mac_sa)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_rx_mac_sa_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_rx_mac_sa_get(unit, port, mac_sa);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_rx_mac_sa_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_reset_set(
    int unit,
    bcm_port_t port,
    int mode,
    int opcode,
    int direction)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_reset_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_reset_set(unit, port, mode, opcode, direction);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_reset_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_reset_get(
    int unit,
    bcm_port_t port,
    int mode,
    int opcode,
    int *direction)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (direction == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "direction NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_reset_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_reset_get(unit, port, mode, opcode, direction);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_reset_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_pfc_control_set(
    int unit,
    bcm_port_t port,
    const portmod_pfc_control_t * control)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_pfc_control_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_pfc_control_set(unit, port, control);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_pfc_control_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_pfc_control_get(
    int unit,
    bcm_port_t port,
    portmod_pfc_control_t * control)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (control == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "control NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_pfc_control_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_pfc_control_get(unit, port, control);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_pfc_control_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_eee_set(
    int unit,
    bcm_port_t port,
    const portmod_eee_t * eee)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_eee_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_eee_set(unit, port, eee);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_eee_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_eee_get(
    int unit,
    bcm_port_t port,
    portmod_eee_t * eee)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (eee == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "eee NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_eee_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_eee_get(unit, port, eee);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_eee_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_bandwidth_get(
    int unit,
    bcm_port_t port,
    int is_port_include,
    int *bandwidth)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (bandwidth == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "bandwidth NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_bandwidth_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_bandwidth_get(unit, port, is_port_include, bandwidth);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_bandwidth_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_tx_start_thr_set(
    int unit,
    bcm_port_t port,
    int speed)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_tx_start_thr_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_tx_start_thr_set(unit, port, speed);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_tx_start_thr_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_prd_enable_set(
    int unit,
    bcm_port_t port,
    int enable_mode)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_prd_enable_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_prd_enable_set(unit, port, enable_mode);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_prd_enable_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_prd_enable_get(
    int unit,
    bcm_port_t port,
    int *enable_mode)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (enable_mode == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "enable_mode NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_prd_enable_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_prd_enable_get(unit, port, enable_mode);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_prd_enable_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_prd_properties_t_validate(
    int unit,
    imb_prd_properties_t imb_prd_properties)
{
    SHR_FUNC_INIT_VARS(unit);
    if (imb_prd_properties >= imbImbPrdCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Parameter is out of range");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_prd_properties_set(
    int unit,
    bcm_port_t port,
    imb_prd_properties_t property,
    uint32 val)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (_SHR_E_NONE != imb_prd_properties_t_validate(unit, property))
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "property validation failed");
    }

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_prd_properties_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_prd_properties_set(unit, port, property, val);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_prd_properties_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_prd_properties_get(
    int unit,
    bcm_port_t port,
    imb_prd_properties_t property,
    uint32 *val)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (_SHR_E_NONE != imb_prd_properties_t_validate(unit, property))
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "property validation failed");
    }

    if (val == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "val NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_prd_properties_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_prd_properties_get(unit, port, property, val);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_prd_properties_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_prd_port_profile_map_set(
    int unit,
    bcm_port_t port,
    uint32 profile)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_prd_port_profile_map_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_prd_port_profile_map_set(unit, port, profile);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_prd_port_profile_map_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_prd_port_profile_map_get(
    int unit,
    bcm_port_t port,
    uint32 *profile)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (profile == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "profile NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_prd_port_profile_map_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_prd_port_profile_map_get(unit, port, profile);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_prd_port_profile_map_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_prd_map_set(
    int unit,
    bcm_port_t port,
    bcm_cosq_ingress_port_drop_map_t map,
    uint32 key,
    uint32 priority,
    uint32 is_tdm)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_prd_map_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_prd_map_set(unit, port, map, key, priority, is_tdm);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_prd_map_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_prd_map_get(
    int unit,
    bcm_port_t port,
    bcm_cosq_ingress_port_drop_map_t map,
    uint32 key,
    uint32 *priority,
    uint32 *is_tdm)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (priority == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "priority NULL parameter");
    }
    if (is_tdm == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "is_tdm NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_prd_map_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_prd_map_get(unit, port, map, key, priority, is_tdm);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_prd_map_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_prd_threshold_set(
    int unit,
    bcm_port_t port,
    uint32 priority,
    uint32 threshold)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_prd_threshold_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_prd_threshold_set(unit, port, priority, threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_prd_threshold_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_prd_threshold_get(
    int unit,
    bcm_port_t port,
    uint32 priority,
    uint32 *threshold)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (threshold == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "threshold NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_prd_threshold_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_prd_threshold_get(unit, port, priority, threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_prd_threshold_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_prd_threshold_max_get(
    int unit,
    bcm_port_t port,
    uint32 *threshold)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (threshold == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "threshold NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_prd_threshold_max_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_prd_threshold_max_get(unit, port, threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_prd_threshold_max_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_prd_tpid_set(
    int unit,
    bcm_port_t port,
    uint32 tpid_index,
    uint32 tpid_value)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_prd_tpid_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_prd_tpid_set(unit, port, tpid_index, tpid_value);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_prd_tpid_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_prd_tpid_get(
    int unit,
    bcm_port_t port,
    uint32 tpid_index,
    uint32 *tpid_value)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (tpid_value == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "tpid_value NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_prd_tpid_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_prd_tpid_get(unit, port, tpid_index, tpid_value);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_prd_tpid_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_prd_drop_count_get(
    int unit,
    bcm_port_t port,
    bcm_port_nif_scheduler_t sch_priority,
    uint64 *count)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (count == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "count NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_prd_drop_count_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_prd_drop_count_get(unit, port, sch_priority, count);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_prd_drop_count_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_prd_custom_ether_type_set(
    int unit,
    bcm_port_t port,
    uint32 ether_type_code,
    uint32 ether_type_val)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_prd_custom_ether_type_set)
    {
        __rv__ =
            __imb__dispatch__[__type__]->f_imb_prd_custom_ether_type_set(unit, port, ether_type_code, ether_type_val);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_prd_custom_ether_type_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_prd_custom_ether_type_get(
    int unit,
    bcm_port_t port,
    uint32 ether_type_code,
    uint32 *ether_type_val)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (ether_type_val == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "ether_type_val NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_prd_custom_ether_type_get)
    {
        __rv__ =
            __imb__dispatch__[__type__]->f_imb_prd_custom_ether_type_get(unit, port, ether_type_code, ether_type_val);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_prd_custom_ether_type_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_prd_flex_key_entry_set(
    int unit,
    bcm_port_t port,
    uint32 key_index,
    const dnx_cosq_prd_tcam_entry_info_t * entry_info)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_prd_flex_key_entry_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_prd_flex_key_entry_set(unit, port, key_index, entry_info);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_prd_flex_key_entry_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_prd_flex_key_entry_get(
    int unit,
    bcm_port_t port,
    uint32 key_index,
    dnx_cosq_prd_tcam_entry_info_t * entry_info)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (entry_info == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "entry_info NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_prd_flex_key_entry_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_prd_flex_key_entry_get(unit, port, key_index, entry_info);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_prd_flex_key_entry_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_prd_ether_type_size_set(
    int unit,
    bcm_port_t port,
    uint32 ether_type_code,
    uint32 ether_type_size)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_prd_ether_type_size_set)
    {
        __rv__ =
            __imb__dispatch__[__type__]->f_imb_prd_ether_type_size_set(unit, port, ether_type_code, ether_type_size);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_prd_ether_type_size_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_prd_ether_type_size_get(
    int unit,
    bcm_port_t port,
    uint32 ether_type_code,
    uint32 *ether_type_size)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (ether_type_size == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "ether_type_size NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_prd_ether_type_size_get)
    {
        __rv__ =
            __imb__dispatch__[__type__]->f_imb_prd_ether_type_size_get(unit, port, ether_type_code, ether_type_size);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_prd_ether_type_size_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_prd_tcam_entry_key_offset_base_set(
    int unit,
    bcm_port_t port,
    uint32 ether_type_code,
    uint32 offset_base)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_prd_tcam_entry_key_offset_base_set)
    {
        __rv__ =
            __imb__dispatch__[__type__]->f_imb_prd_tcam_entry_key_offset_base_set(unit, port, ether_type_code,
                                                                                  offset_base);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_prd_tcam_entry_key_offset_base_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_prd_tcam_entry_key_offset_base_get(
    int unit,
    bcm_port_t port,
    uint32 ether_type_code,
    uint32 *offset_base)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (offset_base == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "offset_base NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_prd_tcam_entry_key_offset_base_get)
    {
        __rv__ =
            __imb__dispatch__[__type__]->f_imb_prd_tcam_entry_key_offset_base_get(unit, port, ether_type_code,
                                                                                  offset_base);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_prd_tcam_entry_key_offset_base_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_prd_tcam_entry_key_offset_set(
    int unit,
    bcm_port_t port,
    uint32 ether_type_code,
    uint32 offset_index,
    uint32 offset_value)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_prd_tcam_entry_key_offset_set)
    {
        __rv__ =
            __imb__dispatch__[__type__]->f_imb_prd_tcam_entry_key_offset_set(unit, port, ether_type_code, offset_index,
                                                                             offset_value);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_prd_tcam_entry_key_offset_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_prd_tcam_entry_key_offset_get(
    int unit,
    bcm_port_t port,
    uint32 ether_type_code,
    uint32 offset_index,
    uint32 *offset_value)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (offset_value == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "offset_value NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_prd_tcam_entry_key_offset_get)
    {
        __rv__ =
            __imb__dispatch__[__type__]->f_imb_prd_tcam_entry_key_offset_get(unit, port, ether_type_code, offset_index,
                                                                             offset_value);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_prd_tcam_entry_key_offset_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_prd_control_frame_set(
    int unit,
    bcm_port_t port,
    uint32 control_frame_index,
    const bcm_cosq_ingress_drop_control_frame_config_t * control_frame_config)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_prd_control_frame_set)
    {
        __rv__ =
            __imb__dispatch__[__type__]->f_imb_prd_control_frame_set(unit, port, control_frame_index,
                                                                     control_frame_config);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_prd_control_frame_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_prd_control_frame_get(
    int unit,
    bcm_port_t port,
    uint32 control_frame_index,
    bcm_cosq_ingress_drop_control_frame_config_t * control_frame_config)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (control_frame_config == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "control_frame_config NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_prd_control_frame_get)
    {
        __rv__ =
            __imb__dispatch__[__type__]->f_imb_prd_control_frame_get(unit, port, control_frame_index,
                                                                     control_frame_config);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_prd_control_frame_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_prd_mpls_special_label_set(
    int unit,
    bcm_port_t port,
    uint32 label_index,
    const bcm_cosq_ingress_port_drop_mpls_special_label_config_t * label_config)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_prd_mpls_special_label_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_prd_mpls_special_label_set(unit, port, label_index, label_config);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_prd_mpls_special_label_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_prd_mpls_special_label_get(
    int unit,
    bcm_port_t port,
    uint32 label_index,
    bcm_cosq_ingress_port_drop_mpls_special_label_config_t * label_config)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (label_config == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "label_config NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_prd_mpls_special_label_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_prd_mpls_special_label_get(unit, port, label_index, label_config);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_prd_mpls_special_label_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_logical_lane_order_set(
    int unit,
    bcm_port_t port,
    const int *lane_order,
    int lane_order_size)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_logical_lane_order_set)
    {
        __rv__ =
            __imb__dispatch__[__type__]->f_imb_port_logical_lane_order_set(unit, port, lane_order, lane_order_size);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_logical_lane_order_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_logical_lane_order_get(
    int unit,
    bcm_port_t port,
    int lane_order_max_size,
    int *lane_order,
    int *lane_order_actual_size)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (lane_order == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "lane_order NULL parameter");
    }
    if (lane_order_actual_size == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "lane_order_actual_size NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_logical_lane_order_get)
    {
        __rv__ =
            __imb__dispatch__[__type__]->f_imb_port_logical_lane_order_get(unit, port, lane_order_max_size, lane_order,
                                                                           lane_order_actual_size);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_logical_lane_order_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_prbs_polynomial_set(
    int unit,
    bcm_port_t port,
    portmod_prbs_mode_t prbs_mode,
    bcm_port_prbs_t value)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_prbs_polynomial_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_prbs_polynomial_set(unit, port, prbs_mode, value);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_prbs_polynomial_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_prbs_polynomial_get(
    int unit,
    bcm_port_t port,
    portmod_prbs_mode_t prbs_mode,
    bcm_port_prbs_t * value)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (value == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "value NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_prbs_polynomial_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_prbs_polynomial_get(unit, port, prbs_mode, value);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_prbs_polynomial_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_prbs_invert_data_set(
    int unit,
    bcm_port_t port,
    int type,
    portmod_prbs_mode_t prbs_mode,
    int invert)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_prbs_invert_data_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_prbs_invert_data_set(unit, port, type, prbs_mode, invert);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_prbs_invert_data_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_prbs_invert_data_get(
    int unit,
    bcm_port_t port,
    int type,
    portmod_prbs_mode_t prbs_mode,
    int *invert)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (invert == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "invert NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_prbs_invert_data_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_prbs_invert_data_get(unit, port, type, prbs_mode, invert);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_prbs_invert_data_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_prbs_enable_set(
    int unit,
    bcm_port_t port,
    int type,
    portmod_prbs_mode_t prbs_mode,
    int enable)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_prbs_enable_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_prbs_enable_set(unit, port, type, prbs_mode, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_prbs_enable_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_prbs_enable_get(
    int unit,
    bcm_port_t port,
    int type,
    portmod_prbs_mode_t prbs_mode,
    int *enable)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (enable == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "enable NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_prbs_enable_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_prbs_enable_get(unit, port, type, prbs_mode, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_prbs_enable_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_prbs_rx_status_get(
    int unit,
    bcm_port_t port,
    portmod_prbs_mode_t prbs_mode,
    int *status)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (status == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "status NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_prbs_rx_status_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_prbs_rx_status_get(unit, port, prbs_mode, status);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_prbs_rx_status_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_phy_reg_set(
    int unit,
    bcm_port_t port,
    uint32 flags,
    uint32 phy_reg_addr,
    uint32 phy_data)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_phy_reg_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_phy_reg_set(unit, port, flags, phy_reg_addr, phy_data);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_phy_reg_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_phy_reg_get(
    int unit,
    bcm_port_t port,
    uint32 flags,
    uint32 phy_reg_addr,
    uint32 *phy_data)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (phy_data == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "phy_data NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_phy_reg_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_phy_reg_get(unit, port, flags, phy_reg_addr, phy_data);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_phy_reg_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_rx_fifo_status_get(
    int unit,
    bcm_port_t port,
    bcm_port_nif_scheduler_t sch_priority,
    uint32 *max_occupancy,
    uint32 *fifo_level)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (max_occupancy == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "max_occupancy NULL parameter");
    }
    if (fifo_level == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "fifo_level NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_rx_fifo_status_get)
    {
        __rv__ =
            __imb__dispatch__[__type__]->f_imb_port_rx_fifo_status_get(unit, port, sch_priority, max_occupancy,
                                                                       fifo_level);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_rx_fifo_status_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_tx_fifo_status_get(
    int unit,
    bcm_port_t port,
    uint32 *max_occupancy,
    uint32 *fifo_level,
    uint32 *pm_credits)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (max_occupancy == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "max_occupancy NULL parameter");
    }
    if (fifo_level == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "fifo_level NULL parameter");
    }
    if (pm_credits == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "pm_credits NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_tx_fifo_status_get)
    {
        __rv__ =
            __imb__dispatch__[__type__]->f_imb_port_tx_fifo_status_get(unit, port, max_occupancy, fifo_level,
                                                                       pm_credits);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_tx_fifo_status_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_low_latency_llfc_enable_set(
    int unit,
    bcm_port_t port,
    int value)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_low_latency_llfc_enable_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_low_latency_llfc_enable_set(unit, port, value);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_low_latency_llfc_enable_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_low_latency_llfc_enable_get(
    int unit,
    bcm_port_t port,
    int *value)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (value == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "value NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_low_latency_llfc_enable_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_low_latency_llfc_enable_get(unit, port, value);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_low_latency_llfc_enable_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_fec_error_detect_enable_set(
    int unit,
    bcm_port_t port,
    int value)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_fec_error_detect_enable_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_fec_error_detect_enable_set(unit, port, value);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_fec_error_detect_enable_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_fec_error_detect_enable_get(
    int unit,
    bcm_port_t port,
    int *value)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (value == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "value NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_fec_error_detect_enable_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_fec_error_detect_enable_get(unit, port, value);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_fec_error_detect_enable_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_llfc_after_fec_enable_set(
    int unit,
    bcm_port_t port,
    int value)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_llfc_after_fec_enable_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_llfc_after_fec_enable_set(unit, port, value);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_llfc_after_fec_enable_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_llfc_after_fec_enable_get(
    int unit,
    bcm_port_t port,
    int *value)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (value == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "value NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_llfc_after_fec_enable_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_llfc_after_fec_enable_get(unit, port, value);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_llfc_after_fec_enable_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_extract_congestion_indication_from_llfc_enable_set(
    int unit,
    bcm_port_t port,
    int value)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_extract_congestion_indication_from_llfc_enable_set)
    {
        __rv__ =
            __imb__dispatch__[__type__]->f_imb_port_extract_congestion_indication_from_llfc_enable_set(unit, port,
                                                                                                       value);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL,
                     "imb_port_extract_congestion_indication_from_llfc_enable_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_extract_congestion_indication_from_llfc_enable_get(
    int unit,
    bcm_port_t port,
    int *value)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (value == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "value NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_extract_congestion_indication_from_llfc_enable_get)
    {
        __rv__ =
            __imb__dispatch__[__type__]->f_imb_port_extract_congestion_indication_from_llfc_enable_get(unit, port,
                                                                                                       value);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL,
                     "imb_port_extract_congestion_indication_from_llfc_enable_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_control_cells_fec_bypass_enable_set(
    int unit,
    bcm_port_t port,
    int value)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_control_cells_fec_bypass_enable_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_control_cells_fec_bypass_enable_set(unit, port, value);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_control_cells_fec_bypass_enable_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_control_cells_fec_bypass_enable_get(
    int unit,
    bcm_port_t port,
    int *value)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (value == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "value NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_control_cells_fec_bypass_enable_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_control_cells_fec_bypass_enable_get(unit, port, value);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_control_cells_fec_bypass_enable_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_speed_config_set(
    int unit,
    bcm_port_t port,
    const portmod_speed_config_t * speed_config)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_speed_config_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_speed_config_set(unit, port, speed_config);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_speed_config_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_speed_config_get(
    int unit,
    bcm_port_t port,
    portmod_speed_config_t * speed_config)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (speed_config == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "speed_config NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_speed_config_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_speed_config_get(unit, port, speed_config);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_speed_config_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_mib_counter_get(
    int unit,
    bcm_port_t port,
    int counter_type,
    uint64 *counter_val)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (counter_val == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "counter_val NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_mib_counter_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_mib_counter_get(unit, port, counter_type, counter_val);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_mib_counter_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_mib_counter_set(
    int unit,
    bcm_port_t port,
    int counter_type,
    const uint64 *counter_val)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_mib_counter_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_mib_counter_set(unit, port, counter_type, counter_val);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_mib_counter_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_mib_counter_clear(
    int unit,
    bcm_port_t port)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_mib_counter_clear)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_mib_counter_clear(unit, port);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_mib_counter_clear isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_autoneg_ability_advert_set(
    int unit,
    bcm_port_t port,
    int num_ability,
    const bcm_port_speed_ability_t * abilities)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_autoneg_ability_advert_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_autoneg_ability_advert_set(unit, port, num_ability, abilities);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_autoneg_ability_advert_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_autoneg_ability_advert_get(
    int unit,
    bcm_port_t port,
    int max_num_ability,
    bcm_port_speed_ability_t * abilities,
    int *actual_num_ability)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (abilities == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "abilities NULL parameter");
    }
    if (actual_num_ability == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "actual_num_ability NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_autoneg_ability_advert_get)
    {
        __rv__ =
            __imb__dispatch__[__type__]->f_imb_port_autoneg_ability_advert_get(unit, port, max_num_ability, abilities,
                                                                               actual_num_ability);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_autoneg_ability_advert_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_speed_ability_local_get(
    int unit,
    bcm_port_t port,
    int max_num_ability,
    bcm_port_speed_ability_t * abilities,
    int *actual_num_ability)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (abilities == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "abilities NULL parameter");
    }
    if (actual_num_ability == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "actual_num_ability NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_speed_ability_local_get)
    {
        __rv__ =
            __imb__dispatch__[__type__]->f_imb_port_speed_ability_local_get(unit, port, max_num_ability, abilities,
                                                                            actual_num_ability);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_speed_ability_local_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_autoneg_ability_remote_get(
    int unit,
    bcm_port_t port,
    int max_num_ability,
    bcm_port_speed_ability_t * abilities,
    int *actual_num_ability)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (abilities == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "abilities NULL parameter");
    }
    if (actual_num_ability == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "actual_num_ability NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_autoneg_ability_remote_get)
    {
        __rv__ =
            __imb__dispatch__[__type__]->f_imb_port_autoneg_ability_remote_get(unit, port, max_num_ability, abilities,
                                                                               actual_num_ability);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_autoneg_ability_remote_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_scheduler_config_set(
    int unit,
    bcm_port_t port,
    int enable)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_scheduler_config_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_scheduler_config_set(unit, port, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_scheduler_config_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_scheduler_priority_update(
    int unit,
    bcm_port_t port)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_scheduler_priority_update)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_scheduler_priority_update(unit, port);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_scheduler_priority_update isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_resource_default_get(
    int unit,
    bcm_port_t port,
    uint32 flags,
    bcm_port_resource_t * resource)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (resource == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "resource NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_resource_default_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_resource_default_get(unit, port, flags, resource);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_resource_default_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_to_stif_instance_map_set(
    int unit,
    bcm_port_t port,
    int instace_id,
    int instace_core,
    int connect)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_to_stif_instance_map_set)
    {
        __rv__ =
            __imb__dispatch__[__type__]->f_imb_port_to_stif_instance_map_set(unit, port, instace_id, instace_core,
                                                                             connect);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_to_stif_instance_map_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_phys_get(
    int unit,
    int imb_id,
    bcm_pbmp_t * phys)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (phys == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "phys NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imb_id_type_get(unit, imb_id, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_phys_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_phys_get(unit, imb_id, phys);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_phys_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_gen_pfc_from_rmc_enable_set(
    int unit,
    bcm_port_t port,
    uint32 priority,
    uint32 enable)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_gen_pfc_from_rmc_enable_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_gen_pfc_from_rmc_enable_set(unit, port, priority, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_gen_pfc_from_rmc_enable_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_gen_pfc_from_rmc_enable_get(
    int unit,
    bcm_port_t port,
    uint32 priority,
    uint32 *enable)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (enable == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "enable NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_gen_pfc_from_rmc_enable_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_gen_pfc_from_rmc_enable_get(unit, port, priority, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_gen_pfc_from_rmc_enable_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_gen_llfc_from_rmc_enable_set(
    int unit,
    bcm_port_t port,
    uint32 enable)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_gen_llfc_from_rmc_enable_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_gen_llfc_from_rmc_enable_set(unit, port, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_gen_llfc_from_rmc_enable_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_stop_pm_from_cfc_llfc_enable_set(
    int unit,
    bcm_port_t port,
    uint32 enable)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_stop_pm_from_cfc_llfc_enable_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_stop_pm_from_cfc_llfc_enable_set(unit, port, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_stop_pm_from_cfc_llfc_enable_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_stop_pm_from_pfc_enable_set(
    int unit,
    bcm_port_t port,
    int pfc,
    uint32 enable)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_stop_pm_from_pfc_enable_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_stop_pm_from_pfc_enable_set(unit, port, pfc, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_stop_pm_from_pfc_enable_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_stop_pm_from_pfc_enable_get(
    int unit,
    bcm_port_t port,
    int pfc,
    uint32 *enable)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (enable == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "enable NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_stop_pm_from_pfc_enable_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_stop_pm_from_pfc_enable_get(unit, port, pfc, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_stop_pm_from_pfc_enable_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_gen_pfc_from_llfc_thresh_enable_set(
    int unit,
    bcm_port_t port,
    uint32 enable)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_gen_pfc_from_llfc_thresh_enable_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_gen_pfc_from_llfc_thresh_enable_set(unit, port, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_gen_pfc_from_llfc_thresh_enable_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_gen_pfc_from_llfc_thresh_enable_get(
    int unit,
    bcm_port_t port,
    uint32 *enable)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (enable == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "enable NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_gen_pfc_from_llfc_thresh_enable_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_gen_pfc_from_llfc_thresh_enable_get(unit, port, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_gen_pfc_from_llfc_thresh_enable_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_fc_rx_qmlf_threshold_set(
    int unit,
    bcm_port_t port,
    uint32 flags,
    uint32 threshold)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_fc_rx_qmlf_threshold_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_fc_rx_qmlf_threshold_set(unit, port, flags, threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_fc_rx_qmlf_threshold_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_fc_rx_qmlf_threshold_get(
    int unit,
    bcm_port_t port,
    uint32 flags,
    uint32 *threshold)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (threshold == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "threshold NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_fc_rx_qmlf_threshold_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_fc_rx_qmlf_threshold_get(unit, port, flags, threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_fc_rx_qmlf_threshold_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_fc_reset_set(
    int unit,
    const imb_create_info_t * imb_info,
    uint32 in_reset)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (_SHR_E_NONE != imb_create_info_t_validate(unit, imb_info))
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "imb_info validation failed");
    }

    /*
     * Dispatch 
     */
    __type__ = (imb_info)->type;
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_fc_reset_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_fc_reset_set(unit, imb_info, in_reset);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_fc_reset_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_llfc_from_glb_rsc_enable_set(
    int unit,
    const imb_create_info_t * imb_info,
    uint32 enable)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (_SHR_E_NONE != imb_create_info_t_validate(unit, imb_info))
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "imb_info validation failed");
    }

    /*
     * Dispatch 
     */
    __type__ = (imb_info)->type;
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_llfc_from_glb_rsc_enable_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_llfc_from_glb_rsc_enable_set(unit, imb_info, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_llfc_from_glb_rsc_enable_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_pfc_rec_priority_map(
    int unit,
    int imb_id,
    uint32 nif_priority,
    uint32 egq_priority)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imb_id_type_get(unit, imb_id, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_pfc_rec_priority_map)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_pfc_rec_priority_map(unit, imb_id, nif_priority, egq_priority);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_pfc_rec_priority_map isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_pfc_rec_priority_unmap(
    int unit,
    int imb_id)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imb_id_type_get(unit, imb_id, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_pfc_rec_priority_unmap)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_pfc_rec_priority_unmap(unit, imb_id);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_pfc_rec_priority_unmap isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_fec_speed_validate(
    int unit,
    bcm_port_t port,
    bcm_port_phy_fec_t fec_type,
    int speed)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_fec_speed_validate)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_fec_speed_validate(unit, port, fec_type, speed);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_fec_speed_validate isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_inband_ilkn_fc_init(
    int unit,
    const imb_create_info_t * imb_info)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (_SHR_E_NONE != imb_create_info_t_validate(unit, imb_info))
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "imb_info validation failed");
    }

    /*
     * Dispatch 
     */
    __type__ = (imb_info)->type;
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_inband_ilkn_fc_init)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_inband_ilkn_fc_init(unit, imb_info);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_inband_ilkn_fc_init isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_calendar_set(
    int unit,
    bcm_port_t port,
    uint32 flags)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_calendar_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_calendar_set(unit, port, flags);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_calendar_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_fifo_resource_set(
    int unit,
    bcm_port_t port,
    uint32 flags)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_fifo_resource_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_fifo_resource_set(unit, port, flags);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_fifo_resource_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_post_init(
    int unit,
    int imb_id)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imb_id_type_get(unit, imb_id, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_post_init)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_post_init(unit, imb_id);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_post_init isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_instru_counters_reset(
    int unit,
    const imb_create_info_t * imb_info)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (_SHR_E_NONE != imb_create_info_t_validate(unit, imb_info))
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "imb_info validation failed");
    }

    /*
     * Dispatch 
     */
    __type__ = (imb_info)->type;
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_instru_counters_reset)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_instru_counters_reset(unit, imb_info);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_instru_counters_reset isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_pfc_deadlock_counters_reset(
    int unit,
    const imb_create_info_t * imb_info)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (_SHR_E_NONE != imb_create_info_t_validate(unit, imb_info))
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "imb_info validation failed");
    }

    /*
     * Dispatch 
     */
    __type__ = (imb_info)->type;
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_pfc_deadlock_counters_reset)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_pfc_deadlock_counters_reset(unit, imb_info);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_pfc_deadlock_counters_reset isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_pfc_deadlock_counters_reset(
    int unit,
    bcm_port_t port)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_pfc_deadlock_counters_reset)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_pfc_deadlock_counters_reset(unit, port);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_pfc_deadlock_counters_reset isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_pfc_deadlock_debug_info_get(
    int unit,
    int ethu_id,
    int *ethu_port_num,
    int *pfc_num)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (ethu_port_num == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "ethu_port_num NULL parameter");
    }
    if (pfc_num == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "pfc_num NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(ethu_id_type_get(unit, ethu_id, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_pfc_deadlock_debug_info_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_pfc_deadlock_debug_info_get(unit, ethu_id, ethu_port_num, pfc_num);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_pfc_deadlock_debug_info_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_pfc_deadlock_max_duration_set(
    int unit,
    int ethu_id,
    uint32 max_duration)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(ethu_id_type_get(unit, ethu_id, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_pfc_deadlock_max_duration_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_pfc_deadlock_max_duration_set(unit, ethu_id, max_duration);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_pfc_deadlock_max_duration_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_pfc_deadlock_max_duration_get(
    int unit,
    int ethu_id,
    uint32 *max_duration)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (max_duration == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "max_duration NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(ethu_id_type_get(unit, ethu_id, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_pfc_deadlock_max_duration_get)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_pfc_deadlock_max_duration_get(unit, ethu_id, max_duration);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_pfc_deadlock_max_duration_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_phy_control_validate(
    int unit,
    bcm_port_t port,
    bcm_port_phy_control_t type,
    int is_set)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_phy_control_validate)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_phy_control_validate(unit, port, type, is_set);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_phy_control_validate isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_pre_add_validate(
    int unit,
    bcm_port_t port,
    bcm_pbmp_t phys)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_pre_add_validate)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_pre_add_validate(unit, port, phys);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_pre_add_validate isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_autoneg_ability_verify(
    int unit,
    bcm_port_t port,
    int num_ability,
    const bcm_port_speed_ability_t * abilities)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_autoneg_ability_verify)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_autoneg_ability_verify(unit, port, num_ability, abilities);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_autoneg_ability_verify isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_pcs_lane_map_set(
    int unit,
    bcm_port_t port,
    uint32 tx_lane_swap,
    uint32 rx_lane_swap)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_pcs_lane_map_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_pcs_lane_map_set(unit, port, tx_lane_swap, rx_lane_swap);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_pcs_lane_map_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_link_status_change_event(
    int unit,
    bcm_port_t port)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_link_status_change_event)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_link_status_change_event(unit, port);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_link_status_change_event isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_alternative_port_set(
    int unit,
    bcm_port_t port,
    const bcm_pbmp_t * alter_ports)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_alternative_port_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_alternative_port_set(unit, port, alter_ports);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_alternative_port_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_l1_mismatch_rate_rx_config_set(
    int unit,
    bcm_port_t port,
    int tx_speed,
    int enable)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_l1_mismatch_rate_rx_config_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_port_l1_mismatch_rate_rx_config_set(unit, port, tx_speed, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_l1_mismatch_rate_rx_config_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_port_post_ber_proj_get(
    int unit,
    bcm_port_t port,
    int lane,
    const bcm_port_ber_proj_params_t * ber_proj,
    int max_errcnt,
    bcm_port_ber_proj_analyzer_errcnt_t * errcnt_array,
    int *actual_errcnt)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (errcnt_array == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "errcnt_array NULL parameter");
    }
    if (actual_errcnt == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "actual_errcnt NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_port_post_ber_proj_get)
    {
        __rv__ =
            __imb__dispatch__[__type__]->f_imb_port_post_ber_proj_get(unit, port, lane, ber_proj, max_errcnt,
                                                                      errcnt_array, actual_errcnt);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_port_post_ber_proj_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_flexe_core_port_config_set(
    int unit,
    bcm_port_t port,
    int flexe_core_port,
    int speed)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_flexe_core_port_config_set)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_flexe_core_port_config_set(unit, port, flexe_core_port, speed);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_flexe_core_port_config_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
imb_portmod_add_info_config(
    int unit,
    bcm_port_t port,
    portmod_port_add_info_t * add_info)
{

    imb_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (add_info == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "add_info NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(imbm.imb_type.get(unit, port, &__type__));
    if (__type__ >= imbDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __imb__dispatch__[__type__]->f_imb_portmod_add_info_config)
    {
        __rv__ = __imb__dispatch__[__type__]->f_imb_portmod_add_info_config(unit, port, add_info);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "imb_portmod_add_info_config isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

#undef BSL_LOG_MODULE
