
/*
 *         
 * 
 * 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 *         
 *     
 * DO NOT EDIT THIS FILE!
 */

#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX family only!"
#endif /* BCM_DNX_SUPPORT */

#include <bcm_int/dnx/algo/swstate/auto_generated/access/dnx_algo_flexe_core_access.h>
#include <bcm_int/dnx/port/flexe/flexe_core.h>
#include <bcm_int/dnx/port/flexe/flexe_core_dispatch.h>

#ifdef BSL_LOG_MODULE
#error "BSL_LOG_MODULE redefined"
#endif
#define BSL_LOG_MODULE BSL_LS_BCMDNX_PORT

const __flexe_core__dispatch__t__ flexe_core_None_driver = { NULL };
#ifdef INCLUDE_FLEXE
extern __flexe_core__dispatch__t__ flexe_core_flexe_std_driver;
#endif
#ifdef INCLUDE_FLEXE_DBG
extern __flexe_core__dispatch__t__ flexe_core_flexe_dbg_driver;
#endif

const __flexe_core__dispatch__t__ *__flexe_core__dispatch__[flexe_coreDispatchTypeCount] = {
    &flexe_core_None_driver,
#ifdef INCLUDE_FLEXE
    &flexe_core_flexe_std_driver,
#endif
#ifdef INCLUDE_FLEXE_DBG
    &flexe_core_flexe_dbg_driver,
#endif

};

int
flexe_core_dispatch_type_t_validate(
    int unit,
    flexe_core_dispatch_type_t flexe_core_dispatch_type)
{
    SHR_FUNC_INIT_VARS(unit);
    if (flexe_core_dispatch_type >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Parameter is out of range");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_init(
    int unit)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_init)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_init(unit);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_init isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_deinit(
    int unit)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_deinit)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_deinit(unit);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_deinit isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

int
flexe_core_port_speed_mode_t_validate(
    int unit,
    flexe_core_port_speed_mode_t flexe_core_port_speed_mode)
{
    SHR_FUNC_INIT_VARS(unit);
    if (flexe_core_port_speed_mode >= flexe_core_port_speed_mode_Count)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Parameter is out of range");
    }

exit:
    SHR_FUNC_EXIT;

}

int
flexe_core_serdes_rate_mode_t_validate(
    int unit,
    flexe_core_serdes_rate_mode_t flexe_core_serdes_rate_mode)
{
    SHR_FUNC_INIT_VARS(unit);
    if (flexe_core_serdes_rate_mode >= flexe_core_serdes_rate_mode_Count)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Parameter is out of range");
    }

exit:
    SHR_FUNC_EXIT;

}

int
flexe_core_port_info_t_validate(
    int unit,
    const flexe_core_port_info_t * flexe_core_port_info)
{
    SHR_FUNC_INIT_VARS(unit);
    if (flexe_core_port_info == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "NULL parameter");
    }

    if (_SHR_E_NONE != flexe_core_serdes_rate_mode_t_validate(unit, flexe_core_port_info->serdes_rate_mode))
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "serdes_rate_mode validation failed");
    }

exit:
    SHR_FUNC_EXIT;

}

int
flexe_core_port_info_t_init(
    int unit,
    flexe_core_port_info_t * flexe_core_port_info)
{
    SHR_FUNC_INIT_VARS(unit);

    if (flexe_core_port_info == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "flexe_core_port_info NULL parameter");
    }
    sal_memset(flexe_core_port_info, 0, sizeof(flexe_core_port_info_t));
    flexe_core_port_info->is_bypass = 0;
    flexe_core_port_info->speed = 0;
    flexe_core_port_info->serdes_rate_mode = flexe_core_serdes_rate_mode_25G;

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_group_phy_add(
    int unit,
    uint32 flags,
    int group_index,
    soc_pbmp_t flexe_core_port_bmp,
    const int *logical_phy_id,
    const flexe_core_port_info_t * port_info)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (_SHR_E_NONE != flexe_core_port_info_t_validate(unit, port_info))
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "port_info validation failed");
    }

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_group_phy_add)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_group_phy_add(unit, flags, group_index,
                                                                           flexe_core_port_bmp, logical_phy_id,
                                                                           port_info);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_group_phy_add isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_group_phy_remove(
    int unit,
    uint32 flags,
    int group_index,
    soc_pbmp_t flexe_core_port_bmp)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_group_phy_remove)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_group_phy_remove(unit, flags, group_index,
                                                                              flexe_core_port_bmp);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_group_phy_remove isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_client_add(
    int unit,
    int client_channel,
    uint32 flags,
    int cal_id,
    const int *flexe_core_port_array,
    bcm_port_flexe_time_slot_t ts_mask,
    int nof_flexe_core_ports)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_client_add)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_client_add(unit, client_channel, flags, cal_id,
                                                                        flexe_core_port_array, ts_mask,
                                                                        nof_flexe_core_ports);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_client_add isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_client_delete(
    int unit,
    int client_channel,
    uint32 flags,
    int cal_id,
    const int *flexe_core_port_array,
    bcm_port_flexe_time_slot_t ts_mask,
    int nof_flexe_core_ports)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_client_delete)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_client_delete(unit, client_channel, flags, cal_id,
                                                                           flexe_core_port_array, ts_mask,
                                                                           nof_flexe_core_ports);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_client_delete isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_mac_client_add(
    int unit,
    int client_channel,
    int nof_slots)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_mac_client_add)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_mac_client_add(unit, client_channel, nof_slots);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_mac_client_add isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_mac_client_delete(
    int unit,
    int client_channel,
    int nof_slots)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_mac_client_delete)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_mac_client_delete(unit, client_channel, nof_slots);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_mac_client_delete isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_sar_client_add(
    int unit,
    int client_channel,
    uint32 flags,
    int ts_num)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_sar_client_add)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_sar_client_add(unit, client_channel, flags, ts_num);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_sar_client_add isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_sar_client_delete(
    int unit,
    int client_channel,
    uint32 flags,
    int ts_num)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_sar_client_delete)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_sar_client_delete(unit, client_channel, flags, ts_num);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_sar_client_delete isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_rateadpt_slots_add(
    int unit,
    int client_channel,
    int ts_num)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_rateadpt_slots_add)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_rateadpt_slots_add(unit, client_channel, ts_num);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_rateadpt_slots_add isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_rateadpt_slots_delete(
    int unit,
    int client_channel)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_rateadpt_slots_delete)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_rateadpt_slots_delete(unit, client_channel);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_rateadpt_slots_delete isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_sar_channel_map_set(
    int unit,
    uint32 flags,
    int sar_channel,
    int ilkn_channel,
    int enable)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_sar_channel_map_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_sar_channel_map_set(unit, flags, sar_channel, ilkn_channel,
                                                                                 enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_sar_channel_map_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_66b_switch_set(
    int unit,
    int src_channel,
    int dest_channel,
    int index,
    int enable)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_66b_switch_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_66b_switch_set(unit, src_channel, dest_channel, index,
                                                                            enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_66b_switch_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oh_logical_phy_id_set(
    int unit,
    int flexe_core_port,
    int logical_phy_id)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oh_logical_phy_id_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oh_logical_phy_id_set(unit, flexe_core_port,
                                                                                   logical_phy_id);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oh_logical_phy_id_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oh_logical_phy_id_get(
    int unit,
    int flexe_core_port,
    uint32 flags,
    int *logical_phy_id)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (logical_phy_id == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "logical_phy_id NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oh_logical_phy_id_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oh_logical_phy_id_get(unit, flexe_core_port, flags,
                                                                                   logical_phy_id);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oh_logical_phy_id_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oh_group_id_set(
    int unit,
    int flexe_core_port,
    int group_id)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oh_group_id_set)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oh_group_id_set(unit, flexe_core_port, group_id);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oh_group_id_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oh_group_id_get(
    int unit,
    int flexe_core_port,
    uint32 flags,
    int *group_id)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (group_id == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "group_id NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oh_group_id_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oh_group_id_get(unit, flexe_core_port, flags, group_id);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oh_group_id_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oh_client_id_set(
    int unit,
    int cal_id,
    int nof_ports,
    const int *flexe_core_port_array,
    int nof_slots,
    const int *calendar_slots)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oh_client_id_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oh_client_id_set(unit, cal_id, nof_ports,
                                                                              flexe_core_port_array, nof_slots,
                                                                              calendar_slots);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oh_client_id_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oh_client_id_get(
    int unit,
    int cal_id,
    uint32 flags,
    int nof_ports,
    const int *flexe_core_port_array,
    int nof_slots,
    int *calendar_slots)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (calendar_slots == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "calendar_slots NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oh_client_id_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oh_client_id_get(unit, cal_id, flags, nof_ports,
                                                                              flexe_core_port_array, nof_slots,
                                                                              calendar_slots);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oh_client_id_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oh_phymap_set(
    int unit,
    int flexe_core_port,
    int logical_phy_id,
    int enable)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oh_phymap_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oh_phymap_set(unit, flexe_core_port, logical_phy_id,
                                                                           enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oh_phymap_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oh_cr_bit_set(
    int unit,
    int flexe_core_port,
    int cal_id)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oh_cr_bit_set)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oh_cr_bit_set(unit, flexe_core_port, cal_id);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oh_cr_bit_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oh_cr_bit_get(
    int unit,
    int flexe_core_port,
    uint32 flags,
    int *cal_id)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (cal_id == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "cal_id NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oh_cr_bit_get)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oh_cr_bit_get(unit, flexe_core_port, flags, cal_id);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oh_cr_bit_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oh_ca_bit_set(
    int unit,
    int flexe_core_port,
    int cal_id)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oh_ca_bit_set)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oh_ca_bit_set(unit, flexe_core_port, cal_id);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oh_ca_bit_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oh_ca_bit_get(
    int unit,
    int flexe_core_port,
    uint32 flags,
    int *cal_id)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (cal_id == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "cal_id NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oh_ca_bit_get)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oh_ca_bit_get(unit, flexe_core_port, flags, cal_id);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oh_ca_bit_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oh_c_bit_set(
    int unit,
    int flexe_core_port,
    int cal_id)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oh_c_bit_set)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oh_c_bit_set(unit, flexe_core_port, cal_id);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oh_c_bit_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oh_c_bit_get(
    int unit,
    int flexe_core_port,
    uint32 flags,
    int *cal_id)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (cal_id == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "cal_id NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oh_c_bit_get)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oh_c_bit_get(unit, flexe_core_port, flags, cal_id);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oh_c_bit_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oh_sc_bit_set(
    int unit,
    int flexe_core_port,
    int sync_config)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oh_sc_bit_set)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oh_sc_bit_set(unit, flexe_core_port, sync_config);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oh_sc_bit_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oh_sc_bit_get(
    int unit,
    int flexe_core_port,
    uint32 flags,
    int *sync_config)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (sync_config == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "sync_config NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oh_sc_bit_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oh_sc_bit_get(unit, flexe_core_port, flags, sync_config);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oh_sc_bit_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_active_calendar_set(
    int unit,
    int flexe_core_port,
    int cal_id)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_active_calendar_set)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_active_calendar_set(unit, flexe_core_port, cal_id);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_active_calendar_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_active_calendar_get(
    int unit,
    int flexe_core_port,
    uint32 flags,
    int *cal_id)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (cal_id == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "cal_id NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_active_calendar_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_active_calendar_get(unit, flexe_core_port, flags, cal_id);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_active_calendar_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oh_alarm_status_get(
    int unit,
    int flexe_core_port,
    uint16 *alarm_status)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (alarm_status == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "alarm_status NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oh_alarm_status_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oh_alarm_status_get(unit, flexe_core_port, alarm_status);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oh_alarm_status_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oh_cal_mismatch_ts_get(
    int unit,
    int flexe_core_port,
    bcm_port_flexe_time_slot_t * time_slots)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (time_slots == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "time_slots NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oh_cal_mismatch_ts_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oh_cal_mismatch_ts_get(unit, flexe_core_port, time_slots);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oh_cal_mismatch_ts_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_alarm_status_get(
    int unit,
    int flexe_core_port,
    uint16 *alarms_status)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (alarms_status == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "alarms_status NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_alarm_status_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_alarm_status_get(unit, flexe_core_port, alarms_status);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_alarm_status_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_alarm_enable_set(
    int unit,
    int client_channel,
    int alarm_type,
    int enable)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_alarm_enable_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_alarm_enable_set(unit, client_channel, alarm_type,
                                                                                  enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_alarm_enable_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_base_period_set(
    int unit,
    int client_channel,
    uint32 flags,
    uint32 base_period)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_base_period_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_base_period_set(unit, client_channel, flags,
                                                                                 base_period);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_base_period_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_base_period_get(
    int unit,
    int client_channel,
    uint32 flags,
    uint32 *base_period)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (base_period == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "base_period NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_base_period_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_base_period_get(unit, client_channel, flags,
                                                                                 base_period);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_base_period_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_base_insert_enable_set(
    int unit,
    int client_channel,
    uint32 enable)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_base_insert_enable_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_base_insert_enable_set(unit, client_channel, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_base_insert_enable_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_base_insert_enable_get(
    int unit,
    int client_channel,
    uint32 *enable)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (enable == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "enable NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_base_insert_enable_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_base_insert_enable_get(unit, client_channel, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_base_insert_enable_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_bypass_enable_set(
    int unit,
    int client_channel,
    uint32 flags,
    uint32 enable)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_bypass_enable_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_bypass_enable_set(unit, client_channel, flags, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_bypass_enable_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_bypass_enable_get(
    int unit,
    int client_channel,
    uint32 flags,
    uint32 *enable)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (enable == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "enable NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_bypass_enable_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_bypass_enable_get(unit, client_channel, flags, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_bypass_enable_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_sar_oam_bypass_enable_set(
    int unit,
    int client_channel,
    uint32 flags,
    uint32 enable)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_sar_oam_bypass_enable_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_sar_oam_bypass_enable_set(unit, client_channel, flags,
                                                                                       enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_sar_oam_bypass_enable_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_sar_oam_bypass_enable_get(
    int unit,
    int client_channel,
    uint32 flags,
    uint32 *enable)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (enable == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "enable NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_sar_oam_bypass_enable_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_sar_oam_bypass_enable_get(unit, client_channel, flags,
                                                                                       enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_sar_oam_bypass_enable_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_local_fault_insert_set(
    int unit,
    int client_channel,
    uint32 enable)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_local_fault_insert_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_local_fault_insert_set(unit, client_channel, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_local_fault_insert_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_local_fault_insert_get(
    int unit,
    int client_channel,
    uint32 *enable)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (enable == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "enable NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_local_fault_insert_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_local_fault_insert_get(unit, client_channel, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_local_fault_insert_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_remote_fault_insert_set(
    int unit,
    int client_channel,
    uint32 enable)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_remote_fault_insert_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_remote_fault_insert_set(unit, client_channel, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_remote_fault_insert_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_remote_fault_insert_get(
    int unit,
    int client_channel,
    uint32 *enable)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (enable == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "enable NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_remote_fault_insert_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_remote_fault_insert_get(unit, client_channel, enable);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_remote_fault_insert_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sd_alm_block_num_set(
    int unit,
    int client_channel,
    uint32 block_num)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_alm_block_num_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_alm_block_num_set(unit, client_channel, block_num);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sd_alm_block_num_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sd_alm_block_num_get(
    int unit,
    int client_channel,
    uint32 *block_num)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (block_num == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "block_num NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_alm_block_num_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_alm_block_num_get(unit, client_channel, block_num);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sd_alm_block_num_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sd_alm_trigger_thr_set(
    int unit,
    int client_channel,
    uint32 threshold)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_alm_trigger_thr_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_alm_trigger_thr_set(unit, client_channel,
                                                                                        threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sd_alm_trigger_thr_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sd_alm_trigger_thr_get(
    int unit,
    int client_channel,
    uint32 *threshold)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (threshold == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "threshold NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_alm_trigger_thr_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_alm_trigger_thr_get(unit, client_channel,
                                                                                        threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sd_alm_trigger_thr_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sd_alm_clear_thr_set(
    int unit,
    int client_channel,
    uint32 threshold)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_alm_clear_thr_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_alm_clear_thr_set(unit, client_channel, threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sd_alm_clear_thr_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sd_alm_clear_thr_get(
    int unit,
    int client_channel,
    uint32 *threshold)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (threshold == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "threshold NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_alm_clear_thr_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_alm_clear_thr_get(unit, client_channel, threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sd_alm_clear_thr_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sf_bip8_alm_block_num_set(
    int unit,
    int client_channel,
    uint32 block_num)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bip8_alm_block_num_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bip8_alm_block_num_set(unit, client_channel,
                                                                                           block_num);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sf_bip8_alm_block_num_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sf_bip8_alm_block_num_get(
    int unit,
    int client_channel,
    uint32 *block_num)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (block_num == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "block_num NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bip8_alm_block_num_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bip8_alm_block_num_get(unit, client_channel,
                                                                                           block_num);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sf_bip8_alm_block_num_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sf_bip8_alm_trigger_thr_set(
    int unit,
    int client_channel,
    uint32 threshold)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bip8_alm_trigger_thr_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bip8_alm_trigger_thr_set(unit, client_channel,
                                                                                             threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sf_bip8_alm_trigger_thr_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sf_bip8_alm_trigger_thr_get(
    int unit,
    int client_channel,
    uint32 *threshold)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (threshold == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "threshold NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bip8_alm_trigger_thr_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bip8_alm_trigger_thr_get(unit, client_channel,
                                                                                             threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sf_bip8_alm_trigger_thr_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sf_bip8_alm_clear_thr_set(
    int unit,
    int client_channel,
    uint32 threshold)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bip8_alm_clear_thr_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bip8_alm_clear_thr_set(unit, client_channel,
                                                                                           threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sf_bip8_alm_clear_thr_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sf_bip8_alm_clear_thr_get(
    int unit,
    int client_channel,
    uint32 *threshold)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (threshold == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "threshold NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bip8_alm_clear_thr_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bip8_alm_clear_thr_get(unit, client_channel,
                                                                                           threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sf_bip8_alm_clear_thr_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sd_bei_alm_block_num_set(
    int unit,
    int client_channel,
    uint32 block_num)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_bei_alm_block_num_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_bei_alm_block_num_set(unit, client_channel,
                                                                                          block_num);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sd_bei_alm_block_num_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sd_bei_alm_block_num_get(
    int unit,
    int client_channel,
    uint32 *block_num)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (block_num == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "block_num NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_bei_alm_block_num_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_bei_alm_block_num_get(unit, client_channel,
                                                                                          block_num);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sd_bei_alm_block_num_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sd_bei_alm_trigger_thr_set(
    int unit,
    int client_channel,
    uint32 threshold)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_bei_alm_trigger_thr_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_bei_alm_trigger_thr_set(unit, client_channel,
                                                                                            threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sd_bei_alm_trigger_thr_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sd_bei_alm_trigger_thr_get(
    int unit,
    int client_channel,
    uint32 *threshold)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (threshold == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "threshold NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_bei_alm_trigger_thr_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_bei_alm_trigger_thr_get(unit, client_channel,
                                                                                            threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sd_bei_alm_trigger_thr_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sd_bei_alm_clear_thr_set(
    int unit,
    int client_channel,
    uint32 threshold)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_bei_alm_clear_thr_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_bei_alm_clear_thr_set(unit, client_channel,
                                                                                          threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sd_bei_alm_clear_thr_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sd_bei_alm_clear_thr_get(
    int unit,
    int client_channel,
    uint32 *threshold)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (threshold == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "threshold NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_bei_alm_clear_thr_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sd_bei_alm_clear_thr_get(unit, client_channel,
                                                                                          threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sd_bei_alm_clear_thr_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sf_bei_alm_block_num_set(
    int unit,
    int client_channel,
    uint32 block_num)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bei_alm_block_num_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bei_alm_block_num_set(unit, client_channel,
                                                                                          block_num);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sf_bei_alm_block_num_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sf_bei_alm_block_num_get(
    int unit,
    int client_channel,
    uint32 *block_num)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (block_num == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "block_num NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bei_alm_block_num_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bei_alm_block_num_get(unit, client_channel,
                                                                                          block_num);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sf_bei_alm_block_num_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sf_bei_alm_trigger_thr_set(
    int unit,
    int client_channel,
    uint32 threshold)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bei_alm_trigger_thr_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bei_alm_trigger_thr_set(unit, client_channel,
                                                                                            threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sf_bei_alm_trigger_thr_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sf_bei_alm_trigger_thr_get(
    int unit,
    int client_channel,
    uint32 *threshold)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (threshold == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "threshold NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bei_alm_trigger_thr_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bei_alm_trigger_thr_get(unit, client_channel,
                                                                                            threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sf_bei_alm_trigger_thr_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sf_bei_alm_clear_thr_set(
    int unit,
    int client_channel,
    uint32 threshold)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bei_alm_clear_thr_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bei_alm_clear_thr_set(unit, client_channel,
                                                                                          threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sf_bei_alm_clear_thr_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_sf_bei_alm_clear_thr_get(
    int unit,
    int client_channel,
    uint32 *threshold)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (threshold == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "threshold NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bei_alm_clear_thr_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_oam_sf_bei_alm_clear_thr_get(unit, client_channel,
                                                                                          threshold);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_sf_bei_alm_clear_thr_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_bip8_counter_get(
    int unit,
    int client_channel,
    uint64 *val)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (val == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "val NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_bip8_counter_get)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oam_bip8_counter_get(unit, client_channel, val);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_bip8_counter_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_bei_counter_get(
    int unit,
    int client_channel,
    uint64 *val)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (val == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "val NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_bei_counter_get)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oam_bei_counter_get(unit, client_channel, val);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_bei_counter_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_pkt_count_get(
    int unit,
    int client_channel,
    uint64 *val)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (val == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "val NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_pkt_count_get)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oam_pkt_count_get(unit, client_channel, val);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_pkt_count_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_base_pkt_count_get(
    int unit,
    int client_channel,
    uint64 *val)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (val == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "val NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_base_pkt_count_get)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oam_base_pkt_count_get(unit, client_channel, val);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_oam_base_pkt_count_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_phy_default_config_set(
    int unit,
    int flexe_core_port,
    int speed)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_phy_default_config_set)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_phy_default_config_set(unit, flexe_core_port, speed);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_phy_default_config_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_alarm_collection_timer_step_set(
    int unit,
    int step)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_alarm_collection_timer_step_set)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oam_alarm_collection_timer_step_set(unit, step);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL,
                     "flexe_core_oam_alarm_collection_timer_step_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_alarm_collection_timer_step_get(
    int unit,
    int *step)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (step == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "step NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_alarm_collection_timer_step_get)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oam_alarm_collection_timer_step_get(unit, step);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL,
                     "flexe_core_oam_alarm_collection_timer_step_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_alarm_collection_step_count_set(
    int unit,
    int step_count)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_alarm_collection_step_count_set)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oam_alarm_collection_step_count_set(unit, step_count);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL,
                     "flexe_core_oam_alarm_collection_step_count_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_oam_alarm_collection_step_count_get(
    int unit,
    int *step_count)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (step_count == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "step_count NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_oam_alarm_collection_step_count_get)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_oam_alarm_collection_step_count_get(unit, step_count);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL,
                     "flexe_core_oam_alarm_collection_step_count_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_sar_cell_mode_set(
    int unit,
    int cell_mode)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_sar_cell_mode_set)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_sar_cell_mode_set(unit, cell_mode);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_sar_cell_mode_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_sar_cell_mode_get(
    int unit,
    int *cell_mode)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (cell_mode == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "cell_mode NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_sar_cell_mode_get)
    {
        __rv__ = __flexe_core__dispatch__[__type__]->f_flexe_core_sar_cell_mode_get(unit, cell_mode);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_sar_cell_mode_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_channel_map_set(
    int unit,
    uint32 flags,
    int flexe_core_port,
    uint32 local_port)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_channel_map_set)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_channel_map_set(unit, flags, flexe_core_port, local_port);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_channel_map_set isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_client_local_fault_get(
    int unit,
    int client_channel,
    int *local_fault_status)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (local_fault_status == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "local_fault_status NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_client_local_fault_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_client_local_fault_get(unit, client_channel,
                                                                                    local_fault_status);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_client_local_fault_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_client_remote_fault_get(
    int unit,
    int client_channel,
    int *remote_fault_status)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (remote_fault_status == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "remote_fault_status NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_client_remote_fault_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_client_remote_fault_get(unit, client_channel,
                                                                                     remote_fault_status);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_client_remote_fault_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_sar_client_local_fault_get(
    int unit,
    int client_channel,
    int *local_fault_status)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (local_fault_status == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "local_fault_status NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_sar_client_local_fault_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_sar_client_local_fault_get(unit, client_channel,
                                                                                        local_fault_status);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_sar_client_local_fault_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

shr_error_e
flexe_core_sar_client_remote_fault_get(
    int unit,
    int client_channel,
    int *remote_fault_status)
{

    flexe_core_dispatch_type_t __type__;
    int __rv__;
    SHR_FUNC_INIT_VARS(unit);

    if (remote_fault_status == NULL)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "remote_fault_status NULL parameter");
    }
    /*
     * Dispatch 
     */
    SHR_IF_ERR_EXIT(dnx_algo_flexe_core_db.drv_type.get(unit, &__type__));
    if (__type__ >= flexe_coreDispatchTypeCount)
    {
        SHR_ERR_EXIT(_SHR_E_PARAM, "Driver is out of range");
    }

    if (NULL != __flexe_core__dispatch__[__type__]->f_flexe_core_sar_client_remote_fault_get)
    {
        __rv__ =
            __flexe_core__dispatch__[__type__]->f_flexe_core_sar_client_remote_fault_get(unit, client_channel,
                                                                                         remote_fault_status);
        SHR_IF_ERR_EXIT(__rv__);
    }
    else
    {
        SHR_ERR_EXIT(_SHR_E_UNAVAIL, "flexe_core_sar_client_remote_fault_get isn't implemented for driver type");
    }

exit:
    SHR_FUNC_EXIT;

}

#undef BSL_LOG_MODULE
