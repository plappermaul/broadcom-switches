/*
 * 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 *
 * File:        flex_ctr.c
 * Purpose:     Manage flex counter group creation and deletion
 */
#include <shared/bsl.h>
#include <bcm_int/esw/flex_ctr.h>
#include <bcm_int/control.h>
#include <bcm_int/esw/field.h>
#include <bcm_int/esw/subport.h>
#include <bcm_int/esw/firebolt6.h>

#ifdef BCM_HURRICANE4_SUPPORT
#include <soc/flexport/hurricane4/hurricane4_flexport_defines.h>
#endif
/* ******************************************************************  */
/*              COMPOSITION OF STAT COUNTER ID                         */
/* ******************************************************************  */
/*              mode_id =  Max 3 bits (bits 31 - 29)                  */
/*              group_mode_id = Max 5 bits (Total 32)                  */
/*              pool_id = 4 (Max Pool:16)                              */
/*              a/c object_id=4 (Max Object:32)                        */
/*              15 bits for base index                                 */
/*              000    0-0000    0000   -00000     000-0000 0000-0000 */
/*              Mode3b Group5b   Pool4b -A/cObj4b  base-index          */
/* ******************************************************************  */
#define BCM_STAT_FLEX_MODE_START_BIT     29
#define BCM_STAT_FLEX_MODE_END_BIT       31
#define BCM_STAT_FLEX_GROUP_START_BIT    24
#define BCM_STAT_FLEX_GROUP_END_BIT      28
#define BCM_STAT_FLEX_POOL_START_BIT     20
#define BCM_STAT_FLEX_POOL_END_BIT       23
#define BCM_STAT_FLEX_OBJECT_START_BIT   15
#define BCM_STAT_FLEX_OBJECT_END_BIT     19
#define BCM_STAT_FLEX_OBJECT_MSB_START_BIT     14
#define BCM_STAT_FLEX_OBJECT_MSB_END_BIT     14
#define BCM_STAT_FLEX_BASE_IDX_START_BIT  0
#define BCM_STAT_FLEX_BASE_IDX_END_BIT   13

#define FIRST_LKUP                        1
#define SECOND_LKUP                       2

#define BCM_STAT_FLEX_MODE_MASK \
    ((1<<(BCM_STAT_FLEX_MODE_END_BIT - BCM_STAT_FLEX_MODE_START_BIT+1))-1)
#define BCM_STAT_FLEX_GROUP_MASK \
    ((1<<(BCM_STAT_FLEX_GROUP_END_BIT - BCM_STAT_FLEX_GROUP_START_BIT+1))-1)
#define BCM_STAT_FLEX_POOL_MASK \
    ((1<<(BCM_STAT_FLEX_POOL_END_BIT - BCM_STAT_FLEX_POOL_START_BIT+1))-1)
#define BCM_STAT_FLEX_OBJECT_MASK \
    ((1<<(BCM_STAT_FLEX_OBJECT_END_BIT - BCM_STAT_FLEX_OBJECT_START_BIT+1))-1)
#define BCM_STAT_FLEX_OBJECT_MSB_MASK \
    ((1<<(BCM_STAT_FLEX_OBJECT_MSB_END_BIT - \
        BCM_STAT_FLEX_OBJECT_MSB_START_BIT+1))-1)
#define BCM_STAT_FLEX_BASE_IDX_MASK \
    ((1<<(BCM_STAT_FLEX_BASE_IDX_END_BIT-BCM_STAT_FLEX_BASE_IDX_START_BIT+1))-1)

#define BCMI_IF_ERROR_CLEANUP(_rv_) \
    if ((_rv_) != BCM_E_NONE) {     \
        goto cleanup;               \
    }

#ifdef BCM_TOMAHAWK_SUPPORT
#include "bcm_int/esw/tomahawk.h"
bcm_stat_counter_map_t *stat_counter_map[SOC_MAX_NUM_DEVICES] = {0};
static bcm_error_t _bcm_esw_get_ingress_ifp_table_from_pipe(int pipe, soc_mem_t *ingress_table);
void _bcm_fill_stat_counter_map(int unit, int id, uint32 mode, uint32 pool, uint32 base_idx,
                                bcm_stat_object_t object, bcm_stat_group_mode_t group);
static bcm_error_t _bcm_esw_get_ingress_vfp_table_from_pipe(int pipe, soc_mem_t *ingress_table);
#endif
#if defined(BCM_TRIDENT2_SUPPORT)
extern uint8 *_flex_stat_mode_base_map[SOC_MAX_NUM_DEVICES]
                                      [BCM_STAT_FLEX_COUNTER_MAX_DIRECTION]
                                      [BCM_STAT_FLEX_COUNTER_MAX_POOL]
                                      [BCM_STAT_FLEX_COUNTER_MAX_MODE];
#endif /* BCM_TRIDENT2_SUPPORT */

typedef struct _flex_pkt_res_data_s {
    uint32 pkt_res_field;
    uint32 counter_index; 
} _flex_pkt_res_data_t;


static uint32 _flex_pkt_res_values_katana[]={
_UNKNOWN_PKT_KATANA,
_CONTROL_PKT_KATANA,
_BPDU_PKT_KATANA,
_L2BC_PKT_KATANA,    
_L2UC_PKT_KATANA,
_L2DLF_PKT_KATANA,
_UNKNOWN_IPMC_PKT_KATANA,
_KNOWN_IPMC_PKT_KATANA, 
_KNOWN_L2MC_PKT_KATANA,
_UNKNOWN_L2MC_PKT_KATANA,
_KNOWN_L3UC_PKT_KATANA,
_UNKNOWN_L3UC_PKT_KATANA,
_KNOWN_MPLS_PKT_KATANA,
_KNOWN_MPLS_L3_PKT_KATANA,
_KNOWN_MPLS_L2_PKT_KATANA, 
_UNKNOWN_MPLS_PKT_KATANA,
_KNOWN_MIM_PKT_KATANA,
_UNKNOWN_MIM_PKT_KATANA,   
_KNOWN_MPLS_MULTICAST_PKT_KATANA    
};

#define TR3_PKT_RESOLUTIONS _UNKNOWN_PKT_TR3, \
                            _CONTROL_PKT_TR3, \
                            _BPDU_PKT_TR3, \
                            _L2BC_PKT_TR3, \
                            _L2UC_PKT_TR3, \
                            _L2DLF_PKT_TR3, \
                            _UNKNOWN_IPMC_PKT_TR3, \
                            _KNOWN_IPMC_PKT_TR3,  \
                            _KNOWN_L2MC_PKT_TR3, \
                            _UNKNOWN_L2MC_PKT_TR3, \
                            _KNOWN_L3UC_PKT_TR3, \
                            _UNKNOWN_L3UC_PKT_TR3, \
                            _KNOWN_MPLS_PKT_TR3, \
                            _KNOWN_MPLS_L3_PKT_TR3, \
                            _KNOWN_MPLS_L2_PKT_TR3, \
                            _UNKNOWN_MPLS_PKT_TR3, \
                            _KNOWN_MIM_PKT_TR3, \
                            _UNKNOWN_MIM_PKT_TR3, \
                            _KNOWN_MPLS_MULTICAST_PKT_TR3, \
                            _OAM_PKT_TR3, \
                            _BFD_PKT_TR3, \
                            _ICNM_PKT_TR3, \
                            _1588_PKT_TR3, \
                            _KNOWN_TRILL_PKT_TR3, \
                            _UNKNOWN_TRILL_PKT_TR3, \
                            _KNOWN_NIV_PKT_TR3, \
                            _UNKNOWN_NIV_PKT_TR3
    
#define TR3_EGR_PKT_RESOLUTIONS     _L2_UC_PKT_EGR, \
                                    _L2_NON_UC_PKT_EGR

static uint32 _flex_pkt_res_values_tr3[]={TR3_PKT_RESOLUTIONS,
                                          TR3_EGR_PKT_RESOLUTIONS};

/* added in TD2 */
#define TD2_PKT_RESOLUTIONS     _KNOWN_L2GRE_PKT_TD2, \
                                _KNOWN_VXLAN_PKT_TD2, \
                                _KNOWN_FCOE_PKT_TD2, \
                                _UNKNOWN_FCOE_PKT_TD2

static uint32 _flex_pkt_res_values_td2[] = {TR3_PKT_RESOLUTIONS, 
                                            TD2_PKT_RESOLUTIONS,
                                            TR3_EGR_PKT_RESOLUTIONS};


static _flex_pkt_res_data_t ing_Single_res[]={ /* 19 */
                 {_UNKNOWN_PKT,0},
                 {_CONTROL_PKT,0},
                 {_BPDU_PKT,0},
                 {_L2BC_PKT,0},
                 {_L2UC_PKT,0},
                 {_L2DLF_PKT,0},
                 {_UNKNOWN_IPMC_PKT,0},
                 {_KNOWN_IPMC_PKT,0},
                 {_KNOWN_L2MC_PKT,0},
                 {_UNKNOWN_L2MC_PKT,0},
                 {_KNOWN_L3UC_PKT,0},
                 {_UNKNOWN_L3UC_PKT,0},
                 {_KNOWN_MPLS_PKT,0},
                 {_KNOWN_MPLS_L3_PKT,0},
                 {_KNOWN_MPLS_L2_PKT,0},
                 {_UNKNOWN_MPLS_PKT,0},
                 {_KNOWN_MIM_PKT,0},
                 {_UNKNOWN_MIM_PKT,0},
                 {_KNOWN_MPLS_MULTICAST_PKT,0}
#if defined(BCM_TRIUMPH3_SUPPORT)
                 ,
                 {_OAM_PKT,0},
                 {_BFD_PKT,0},
                 {_ICNM_PKT,0},
                 {_1588_PKT,0},
                 {_KNOWN_TRILL_PKT,0},
                 {_UNKNOWN_TRILL_PKT,0},
                 {_KNOWN_NIV_PKT,0},
                 {_UNKNOWN_NIV_PKT,0}
#endif
#if defined(BCM_TRIDENT2_SUPPORT)
                 ,
                 {_KNOWN_L2GRE_PKT,0},
                 {_KNOWN_VXLAN_PKT,0},
                 {_KNOWN_FCOE_PKT,0},
                 {_UNKNOWN_FCOE_PKT,0},
#endif /* BCM_TRIDENT2_SUPPORT */
                 };

static _flex_pkt_res_data_t ing_TrafficType_res[]={ /* 6 */
                 {_L2BC_PKT,2},
                 {_L2UC_PKT,0},
                 {_L2DLF_PKT,0},
                 {_KNOWN_L2MC_PKT,1},
                 {_UNKNOWN_L2MC_PKT,1},
                 {_KNOWN_L3UC_PKT,0},
                 {_UNKNOWN_L3UC_PKT,0}
                 };
static _flex_pkt_res_data_t ing_DlfAll_res[]={ /* 19 */
                 {_UNKNOWN_PKT,1},
                 {_CONTROL_PKT,1},
                 {_BPDU_PKT,1},
                 {_L2BC_PKT,1},
                 {_L2UC_PKT,1},
                 {_L2DLF_PKT,0},
                 {_UNKNOWN_IPMC_PKT,1},
                 {_KNOWN_IPMC_PKT,1},
                 {_KNOWN_L2MC_PKT,1},
                 {_UNKNOWN_L2MC_PKT,1},
                 {_KNOWN_L3UC_PKT,1},
                 {_UNKNOWN_L3UC_PKT,1},
                 {_KNOWN_MPLS_PKT,1},
                 {_KNOWN_MPLS_L3_PKT,1},
                 {_KNOWN_MPLS_L2_PKT,1},
                 {_UNKNOWN_MPLS_PKT,1},
                 {_KNOWN_MIM_PKT,1},
                 {_UNKNOWN_MIM_PKT,1},
                 {_KNOWN_MPLS_MULTICAST_PKT,1}
                 };
static _flex_pkt_res_data_t ing_Typed_res[]={ /* 6 */
                 {_L2BC_PKT,3},
                 {_L2UC_PKT,1},
                 {_KNOWN_L2MC_PKT,2},
                 {_UNKNOWN_L2MC_PKT,2},
                 {_KNOWN_L3UC_PKT,1},
                 {_UNKNOWN_L3UC_PKT,0},
                 {_L2DLF_PKT,0}
                 };
static _flex_pkt_res_data_t ing_TypedAll_res[]={ /* 19 */
                 {_UNKNOWN_PKT,4},
                 {_CONTROL_PKT,4},
                 {_BPDU_PKT,4},
                 {_L2BC_PKT,3},
                 {_L2UC_PKT,1},
                 {_L2DLF_PKT,4},
                 {_UNKNOWN_IPMC_PKT,4},
                 {_KNOWN_IPMC_PKT,4},
                 {_KNOWN_L2MC_PKT,2},
                 {_UNKNOWN_L2MC_PKT,2},
                 {_KNOWN_L3UC_PKT,1},
                 {_UNKNOWN_L3UC_PKT,0},
                 {_KNOWN_MPLS_PKT,4},
                 {_KNOWN_MPLS_L3_PKT,4},
                 {_KNOWN_MPLS_L2_PKT,4},
                 {_UNKNOWN_MPLS_PKT,4},
                 {_KNOWN_MIM_PKT,4},
                 {_UNKNOWN_MIM_PKT,4},
                 {_KNOWN_MPLS_MULTICAST_PKT,4}
                 };
static _flex_pkt_res_data_t ing_SingleWithControl_res[]={ /* 19 */
                 {_UNKNOWN_PKT,0},
                 {_CONTROL_PKT,1},
                 {_BPDU_PKT,1},
                 {_L2BC_PKT,0},
                 {_L2UC_PKT,0},
                 {_L2DLF_PKT,0},
                 {_UNKNOWN_IPMC_PKT,0},
                 {_KNOWN_IPMC_PKT,0},
                 {_KNOWN_L2MC_PKT,0},
                 {_UNKNOWN_L2MC_PKT,0},
                 {_KNOWN_L3UC_PKT,0},
                 {_UNKNOWN_L3UC_PKT,0},
                 {_KNOWN_MPLS_PKT,0},
                 {_KNOWN_MPLS_L3_PKT,0},
                 {_KNOWN_MPLS_L2_PKT,0},
                 {_UNKNOWN_MPLS_PKT,0},
                 {_KNOWN_MIM_PKT,0},
                 {_UNKNOWN_MIM_PKT,0},
                 {_KNOWN_MPLS_MULTICAST_PKT,0}
                 };
static _flex_pkt_res_data_t ing_TrafficTypeWithControl_res[]={ /* 8 */
                 {_CONTROL_PKT,3},
                 {_BPDU_PKT,3},
                 {_L2BC_PKT,2},
                 {_L2UC_PKT,0},
                 {_KNOWN_L2MC_PKT,1},
                 {_UNKNOWN_L2MC_PKT,1},
                 {_KNOWN_L3UC_PKT,0},
                 {_UNKNOWN_L3UC_PKT,0}
                 };
static _flex_pkt_res_data_t ing_DlfAllWithControl_res[]={ /* 19 */
                 {_UNKNOWN_PKT,2},
                 {_CONTROL_PKT,0},
                 {_BPDU_PKT,0},
                 {_L2BC_PKT,2},
                 {_L2UC_PKT,2},
                 {_L2DLF_PKT,1},
                 {_UNKNOWN_IPMC_PKT,2},
                 {_KNOWN_IPMC_PKT,2},
                 {_KNOWN_L2MC_PKT,2},
                 {_UNKNOWN_L2MC_PKT,2},
                 {_KNOWN_L3UC_PKT,2},
                 {_UNKNOWN_L3UC_PKT,2},
                 {_KNOWN_MPLS_PKT,2},
                 {_KNOWN_MPLS_L3_PKT,2},
                 {_KNOWN_MPLS_L2_PKT,2},
                 {_UNKNOWN_MPLS_PKT,2},
                 {_KNOWN_MIM_PKT,2},
                 {_UNKNOWN_MIM_PKT,2},
                 {_KNOWN_MPLS_MULTICAST_PKT,2}
                 };
static _flex_pkt_res_data_t ing_TypedWithControl_res[]={ /* 8 */
                 {_CONTROL_PKT,0},
                 {_BPDU_PKT,0},
                 {_L2BC_PKT,4},
                 {_L2UC_PKT,2},
                 {_KNOWN_L2MC_PKT,3},
                 {_UNKNOWN_L2MC_PKT,3},
                 {_KNOWN_L3UC_PKT,2},
                 {_UNKNOWN_L3UC_PKT,1}
                 };
static _flex_pkt_res_data_t ing_TypedAllWithControl_res[]={ /* 19 */
                 {_UNKNOWN_PKT,5},
                 {_CONTROL_PKT,0},
                 {_BPDU_PKT,0},
                 {_L2BC_PKT,4},
                 {_L2UC_PKT,2},
                 {_L2DLF_PKT,5},
                 {_UNKNOWN_IPMC_PKT,5},
                 {_KNOWN_IPMC_PKT,5},
                 {_KNOWN_L2MC_PKT,3},
                 {_UNKNOWN_L2MC_PKT,3},
                 {_KNOWN_L3UC_PKT,2},
                 {_UNKNOWN_L3UC_PKT,1},
                 {_KNOWN_MPLS_PKT,5},
                 {_KNOWN_MPLS_L3_PKT,5},
                 {_KNOWN_MPLS_L2_PKT,5},
                 {_UNKNOWN_MPLS_PKT,5},
                 {_KNOWN_MIM_PKT,5},
                 {_UNKNOWN_MIM_PKT,5},
                 {_KNOWN_MPLS_MULTICAST_PKT,5}
                 };
static _flex_pkt_res_data_t egr_Single_res[]={ /* 2 */
                 {0,0}, /*Unicast */
                 {1,0}  /*Multicast */
                 };
static _flex_pkt_res_data_t egr_TrafficType_res[]={ /* 2 */
                 {0,0}, /*Unicast */
                 {1,1}  /*Multicast */
                 };

#ifdef BCM_KATANA2_SUPPORT
static class_attr_combine_t class_attr_comb[BCM_MAX_NUM_UNITS];
#endif

#if defined(BCM_TRIDENT3_SUPPORT) || defined(BCM_APACHE_SUPPORT)
static stat_port_group_t stat_port_grp[BCM_MAX_NUM_UNITS];
#endif

bcm_stat_flex_ing_pkt_attr_bits_t
    ing_pkt_attr_uncmprsd_bits_g[BCM_MAX_NUM_UNITS] =  {{0}};
bcm_stat_flex_egr_pkt_attr_bits_t
    egr_pkt_attr_uncmprsd_bits_g[BCM_MAX_NUM_UNITS] =  {{0}};
bcm_stat_flex_ing_pkt_attr_bits_t
    ing_pkt_attr_cmprsd_bits_g[BCM_MAX_NUM_UNITS] =  {{0}};
bcm_stat_flex_egr_pkt_attr_bits_t
    egr_pkt_attr_cmprsd_bits_g[BCM_MAX_NUM_UNITS] =  {{0}};

/*  Information of compression table allocation per device. */
static _bcm_stat_flex_compressed_mode_attr_sel_map_t
             *global_stat_flex_compressed_attr_map[BCM_MAX_NUM_UNITS];
static _bcm_stat_flex_compressed_mode_attr_sel_map_t
             *egr_global_stat_flex_compressed_attr_map[BCM_MAX_NUM_UNITS];

#if defined(BCM_TRIDENT3_SUPPORT)
static bcm_error_t _bcm_esw_get_egr_fp_table_from_pipe(int pipe,
                                soc_mem_t *egress_table);
#endif

/*
 * This flag is used to reset counter values
 * at old base index
 */
compaction_status_t compaction_info[BCM_MAX_NUM_UNITS] = {{0}};

/*
 * Function:
 *      _bcm_esw_stat_flex_init_pkt_res_values
 * Description:
 *      Initialize Packet Resolution related (static) structures as
 *      per pkt_res_field indexes.
 *      
 * Parameters:
 *      unit               - (IN)     unit number
 *      flex_pkt_res_data  - (IN/OUT) Packet Resolution data Pointer
 *      num_entries        - (IN)     Entries in Packet Resolution data array
 *
 * Return Value:
 *      BCM_E_XXX
 *
 * Notes: Please note. Same field is used as index and gets initialized!
 *        TBD:Optimize this procedure using a function pointers array.
 */
static void _bcm_esw_stat_flex_init_pkt_res_values(
            int                  unit,
            _flex_pkt_res_data_t *flex_pkt_res_data,
            uint32               num_entries)
{
   uint32 index=0;
   uint32 *flex_pkt_res_values=NULL;
   uint32 flex_pkt_res_values_count=0;
  
   if (SOC_IS_KATANA(unit)) {
       flex_pkt_res_values = _flex_pkt_res_values_katana;
       flex_pkt_res_values_count = sizeof(_flex_pkt_res_values_katana)/
                                   sizeof(_flex_pkt_res_values_katana[0]);
   }
   if (SOC_IS_TRIUMPH3(unit) || SOC_IS_KATANA2(unit)) {
       flex_pkt_res_values = _flex_pkt_res_values_tr3;
       flex_pkt_res_values_count = sizeof(_flex_pkt_res_values_tr3)/
                                   sizeof(_flex_pkt_res_values_tr3[0]);
   }
   if (SOC_IS_TD2_TT2(unit)) {
       flex_pkt_res_values = _flex_pkt_res_values_td2;
       flex_pkt_res_values_count = sizeof(_flex_pkt_res_values_td2)/
                                   sizeof(_flex_pkt_res_values_td2[0]);
   }
   if ( flex_pkt_res_values_count == 0) {
        LOG_WARN(BSL_LS_BCM_FLEXCTR,
                 (BSL_META_U(unit,
                             "CONFIG ERROR: flex_pkt_res_values_count=0\n")));
        return ;
   }
  
   for(index=0;index<num_entries;index++) {
       /* Check Whether Index is exceeding chip specific count */
       if (flex_pkt_res_data[index].pkt_res_field >= 
           flex_pkt_res_values_count) {
           LOG_DEBUG(BSL_LS_BCM_FLEXCTR,
                     (BSL_META_U(unit,
                                 "Flex Pkt Resolution Value Initialization failed"
                                  "pkt_res_field=%d > flex_pkt_res_values_count=%d=0\n"),
                      flex_pkt_res_data[index].pkt_res_field,
                      flex_pkt_res_values_count));
           /* Set it to invalid value */
           flex_pkt_res_data[index].pkt_res_field = 0xFFFFFFFF;
           continue ;
       }
       flex_pkt_res_data[index].pkt_res_field = 
            flex_pkt_res_values[flex_pkt_res_data[index].pkt_res_field];
   }

   return ;
}
 
/*
 * Function:
 *      _bcm_esw_stat_flex_create_mode
 * Description:
 *      Checks attributes direction and calls ingress/egress mode creation 
 *      function
 * Parameters:
 *      unit  - (IN) unit number
 *      attr  - (IN) Flex attributes
 *      mode  - (OUT) Flex mode
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 */
static bcm_error_t _bcm_esw_stat_flex_create_mode (
                   int                  unit,
                   bcm_stat_flex_attr_t *attr,
                   bcm_stat_flex_mode_t *mode,
                   bcm_stat_flex_attribute_t  *flex_attribute)
{
    if (attr == NULL) {
        return BCM_E_PARAM;
    }
    if (attr->direction == bcmStatFlexDirectionIngress) {
        return _bcm_esw_stat_flex_create_ingress_mode(
                unit,
                &(attr->ing_attr),
                mode,
                flex_attribute);
    }
    if (attr->direction == bcmStatFlexDirectionEgress) {
        return _bcm_esw_stat_flex_create_egress_mode(
                unit,
                &(attr->egr_attr),
                mode,
                flex_attribute);
    }
    return BCM_E_PARAM;
}
/*
 * Function:
 *      _bcm_esw_fillup_ing_uncmp_attr
 * Description:
 *      Fill up ingress uncompressed flex attributes with required parameters
 *      Inialize offset table map also.
 * Parameters:
 *      ing_attr                     - (IN) Flex Ingress attributes
 *      uncmprsd_attr_bits_selector  - (IN) Uncompressed Bits Selector 
 *      total_counters               - (IN) Total Counters
 * Return Value:
 *      None
 * Notes:
 */
static void _bcm_esw_fillup_ing_uncmp_attr(
            bcm_stat_flex_ing_attr_t            *ing_attr,
            uint32                              uncmprsd_attr_bits_selector,
            uint8                               total_counters)
{
    uint32 index=0;

    ing_attr->packet_attr_type=bcmStatFlexPacketAttrTypeUncompressed;

    ing_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector = 
                uncmprsd_attr_bits_selector;
    ing_attr->uncmprsd_attr_selectors.total_counters = total_counters;
    /* Reset all Offset table fields */
    for (index=0;index<256;index++) {
         ing_attr->uncmprsd_attr_selectors.offset_table_map[index].offset=0;
         ing_attr->uncmprsd_attr_selectors.offset_table_map[index].
                  count_enable=0;
    }
}
/*
 * Function:
 *      _bcm_esw_fillup_ing_pkt_res_offset_table
 * Description:
        Fills up Ingress Offset table for Packet Resolution fields
 * Parameters:
 *      ing_attr     - (IN) Flex ingress attributes
 *      num_pairs    - (IN) Number of Packet Resolution Data pairs
 *      pkt_res_data - (IN) Packet Resolution Data Pointer
 * Return Value:
 *      None
 * Notes:
 */
static void _bcm_esw_fillup_ing_pkt_res_offset_table(
            bcm_stat_flex_ing_attr_t *ing_attr,
            uint32                    num_pairs,
            _flex_pkt_res_data_t     *pkt_res_data)
{
    uint32  count=0;
    int     pkt_res_field=0;
    int     counter_index=0;

    /* DROP:1bits(0th) SVP:1bits(1st) PKT_RES:6bits(2nd) bit position */

    for (count=0;count<num_pairs;count++) {
         /* Check for Invalid Value */
         if ((pkt_res_field=pkt_res_data[count].pkt_res_field) == 0xFFFFFFFF) {
             continue;
         }
         counter_index=pkt_res_data[count].counter_index;
         ing_attr->uncmprsd_attr_selectors.offset_table_map[pkt_res_field].
                                           offset= counter_index;
         ing_attr->uncmprsd_attr_selectors.offset_table_map[pkt_res_field].
                                           count_enable=1;
    }
}
/*
 * Function:
 *      _bcm_esw_fillup_egr_uncmp_attr
 * Description:
 *      Fill up egress uncompressed flex attributes with required parameters
 *      Inialize offset table map also.
 * Parameters:
 *      egr_attr                     - (IN) Flex Egress attributes
 *      uncmprsd_attr_bits_selector  - (IN) Uncompressed Bits Selector 
 *      total_counters               - (IN) Total Counters
 * Return Value:
 *      None
 * Notes:
 */
static void _bcm_esw_fillup_egr_uncmp_attr(
            bcm_stat_flex_egr_attr_t            *egr_attr,
            uint32                              uncmprsd_attr_bits_selector,
            uint16                              total_counters)
{
    uint32 index=0;

    egr_attr->packet_attr_type= bcmStatFlexPacketAttrTypeUncompressed;

    egr_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector = 
                uncmprsd_attr_bits_selector;
    egr_attr->uncmprsd_attr_selectors.total_counters = total_counters;
    /* Reset all Offset table fields */
    for (index=0;index<256;index++) {
         egr_attr->uncmprsd_attr_selectors.offset_table_map[index].offset=0;
         egr_attr->uncmprsd_attr_selectors.offset_table_map[index].
                   count_enable=0;
    }
}
/*
 * Function:
 *      _bcm_esw_fillup_egr_pkt_res_offset_table
 * Description:
        Fills up Egress Offset table for Packet Resolution fields
 * Parameters:
 *      egr_attr     - (IN) Flex egress attributes
 *      num_pairs    - (IN) Number of Packet Resolution Data pairs
 *      pkt_res_data - (IN) Packet Resolution Data Pointer
 * Return Value:
 *      None
 * Notes:
 */
static void _bcm_esw_fillup_egr_pkt_res_offset_table(
            bcm_stat_flex_egr_attr_t *egr_attr,
            uint32                    num_pairs,
            _flex_pkt_res_data_t     *pkt_res_data)
{
    uint32  count=0;
    int     pkt_res_field=0;
    int     counter_index=0;

    /* DROP:1bits(0th) SVP:1bits(1st) DVP:1bits(2nd) PKT_RES:1bit(3rd) bit */

    for (count=0;count<num_pairs;count++) {
         if ((pkt_res_field=pkt_res_data[count].pkt_res_field) == 0xFFFFFFFF) {
             continue;
         }
         counter_index=pkt_res_data[count].counter_index;
         egr_attr->uncmprsd_attr_selectors.offset_table_map[pkt_res_field].
                                           offset= counter_index;
         egr_attr->uncmprsd_attr_selectors.offset_table_map[pkt_res_field].
                                           count_enable=1;
    }
}

/*
 * Function:
 *      _bcm_esw_stat_get_counter_id
 * Description:
 *      Get Stat Counter Id based on offset mode,group mode,pool number,object
 *      and base index. 
 *      
 * Parameters:
 *      group             (IN)  Flex Group Mode
 *      object            (IN)  Flex Accounting Object
 *      mode              (IN)  Flex Offset Mode
 *      pool_number       (IN)  Allocated Pool Number for Flex Accounting Object
 *      base_idx          (IN)  Allocated Base Index for Flex Accounting Object
 *      stat_counter_id   (OUT) Stat Counter Id
 *
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 */
void _bcm_esw_stat_get_counter_id(
     int                   unit,
     bcm_stat_group_mode_t group,
     bcm_stat_object_t     object,
     uint32                mode,
     uint32                pool_number,
     uint32                base_idx,
     uint32                *stat_counter_id)
{
     if (!soc_feature(unit, soc_feature_flex_counter_opaque_stat_id)) {
         *stat_counter_id = ((mode & BCM_STAT_FLEX_MODE_MASK)            << 
                                     BCM_STAT_FLEX_MODE_START_BIT)       |
                            ((group & BCM_STAT_FLEX_GROUP_MASK)          << 
                                     BCM_STAT_FLEX_GROUP_START_BIT)      |
                            ((pool_number & BCM_STAT_FLEX_POOL_MASK)     <<
                                     BCM_STAT_FLEX_POOL_START_BIT)       |
                            ((object & BCM_STAT_FLEX_OBJECT_MASK)        << 
                                     BCM_STAT_FLEX_OBJECT_START_BIT)     |
                            (((object >> (BCM_STAT_FLEX_OBJECT_END_BIT 
                                    - BCM_STAT_FLEX_OBJECT_START_BIT+1)) 
                                    & BCM_STAT_FLEX_OBJECT_MSB_MASK)     << 
                                     BCM_STAT_FLEX_OBJECT_MSB_START_BIT) |                                 
                             (base_idx & BCM_STAT_FLEX_BASE_IDX_MASK);
    } else {
#ifdef BCM_TOMAHAWK_SUPPORT
        int i = 0;
        int new_ctr = -1;
        int new_ctr_id = 0;

        *stat_counter_id = 0;
        for(i = 1; i < BCM_MAX_STAT_COUNTER_IDS; ++i) {
            if (stat_counter_map[unit] && stat_counter_map[unit][i].used) {
                if ((stat_counter_map[unit][i].group == group) && 
                (stat_counter_map[unit][i].object == object) &&
                (stat_counter_map[unit][i].mode == mode) && 
                (stat_counter_map[unit][i].pool == pool_number) && 
                (stat_counter_map[unit][i].base_idx == base_idx)) {
                    new_ctr = 0;
                    break;
                }
                continue;
            } else if ((stat_counter_map[unit][i].used == 0)
                        && (new_ctr != 1)) {
                new_ctr = 1;
                new_ctr_id = i;
            }
#if 0
            else if(!(stat_counter_map[unit][i])) {
                stat_counter_map[unit][i] = 
                sal_alloc(sizeof(bcm_stat_counter_map_t),"attr");
                
                if (stat_counter_map[i] == NULL) {
                    LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                        (BSL_META_U(0,
                        "Memory alloc failed! ")));
                        return;
                }
                sal_memset(stat_counter_map[unit][i], 0, sizeof(bcm_stat_counter_map_t));
                
                break;
            }
#endif
        }

        if ((i >= BCM_MAX_STAT_COUNTER_IDS) &&
            (new_ctr == -1)) {
            LOG_ERROR(BSL_LS_BCM_FLEXCTR,
            (BSL_META_U(unit,
            "Failed to get counter id ")));
            return;
        }

        *stat_counter_id = new_ctr ? new_ctr_id: i;

        if (stat_counter_map[unit] != NULL) {
            stat_counter_map[unit][*stat_counter_id].mode = mode;
            stat_counter_map[unit][*stat_counter_id].group = group;
            stat_counter_map[unit][*stat_counter_id].object = object;
            stat_counter_map[unit][*stat_counter_id].pool = pool_number;
            stat_counter_map[unit][*stat_counter_id].base_idx = base_idx;
            stat_counter_map[unit][*stat_counter_id].used = 1;
            stat_counter_map[unit][*stat_counter_id].pipe = 0;
        }
#endif
    }
}

/*
 * Function:
 *      _bcm_esw_stat_counter_id_retrieve
 * Description:
 *      retrieve exist Stat Counter Id based on offset mode,group mode, pool number, object
 *      and base index.
 *
 * Parameters:
 *      group             (IN)  Flex Group Mode
 *      object            (IN)  Flex Accounting Object
 *      mode              (IN)  Flex Offset Mode
 *      pool_number       (IN)  Allocated Pool Number for Flex Accounting Object
 *      base_idx          (IN)  Allocated Base Index for Flex Accounting Object
 *      stat_counter_id   (OUT) Stat Counter Id
 *
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 */
void _bcm_esw_stat_counter_id_retrieve(
     int                   unit,
     bcm_stat_group_mode_t group,
     bcm_stat_object_t     object,
     uint32                mode,
     uint32                pool_number,
     uint32                base_idx,
     uint32                *stat_counter_id)
{
#if defined(BCM_TRIDENT2_SUPPORT)
    bcm_stat_flex_direction_t direction;
#endif /* BCM_TRIDENT2_SUPPORT */

    if (!soc_feature(unit, soc_feature_flex_counter_opaque_stat_id)) {
        *stat_counter_id = ((mode & BCM_STAT_FLEX_MODE_MASK)            <<
                                BCM_STAT_FLEX_MODE_START_BIT)       |
                            ((group & BCM_STAT_FLEX_GROUP_MASK)          <<
                                     BCM_STAT_FLEX_GROUP_START_BIT)      |
                            ((pool_number & BCM_STAT_FLEX_POOL_MASK)     <<
                                     BCM_STAT_FLEX_POOL_START_BIT)       |
                            ((object & BCM_STAT_FLEX_OBJECT_MASK)        <<
                                     BCM_STAT_FLEX_OBJECT_START_BIT)     |
                            (((object >> (BCM_STAT_FLEX_OBJECT_END_BIT
                                    - BCM_STAT_FLEX_OBJECT_START_BIT+1))
                                    & BCM_STAT_FLEX_OBJECT_MSB_MASK)     <<
                                     BCM_STAT_FLEX_OBJECT_MSB_START_BIT) |
                             (base_idx & BCM_STAT_FLEX_BASE_IDX_MASK);
#if defined(BCM_TRIDENT2_SUPPORT)
        if (SOC_IS_TRIDENT2X(unit) &&
            soc_feature(unit, soc_feature_advanced_flex_counter)) {
            (void)_bcm_esw_stat_validate_object(unit, object, &direction);
            if (!_flex_stat_mode_base_map[unit][direction]
                              [pool_number][mode][base_idx]) {
                *stat_counter_id = 0;
            }
        }
#endif
    } else {
#ifdef BCM_TOMAHAWK_SUPPORT
    int i = 0;
    *stat_counter_id = 0;
    for(i = 1; i < BCM_MAX_STAT_COUNTER_IDS; ++i) {
        if (stat_counter_map[unit] && stat_counter_map[unit][i].used) {
            if ((stat_counter_map[unit][i].group == group) &&
                (stat_counter_map[unit][i].object == object) &&
                (stat_counter_map[unit][i].mode == mode) &&
                (stat_counter_map[unit][i].pool == pool_number) &&
                (stat_counter_map[unit][i].base_idx == base_idx)) {
                *stat_counter_id = i;
                break;
            }
            continue;
        }
    }
#endif
    }
}

bcm_field_qualify_t 
_bcm_esw_stat_get_field_stage_from_stat_ctr(int unit, uint32 stat_counter_id) 
{
#ifdef BCM_TOMAHAWK_SUPPORT
    if (!stat_counter_map[unit] || (stat_counter_map[unit][stat_counter_id].used == 0)) {
        LOG_ERROR(BSL_LS_BCM_FLEXCTR,
            (BSL_META_U(unit,
            "Failed to get counter id %d"), (int)stat_counter_id));
        return 0;
    }

    switch(stat_counter_map[unit][stat_counter_id].object) {
        case bcmStatObjectIngFieldStageLookup:
            return bcmFieldQualifyStageLookup;
        case bcmStatObjectIngFieldStageIngress:
            return bcmFieldQualifyStageIngress;
        case bcmStatObjectIngExactMatch:
            return bcmFieldQualifyStageIngressExactMatch;
#if defined(BCM_TRIDENT3_SUPPORT) || defined(BCM_TOMAHAWK3_SUPPORT)
        case bcmStatObjectEgrFieldStageEgress:
            return bcmFieldQualifyStageEgress;
#endif
        default:
            break;
    }
#endif
    return 0;
}

bcm_field_qualify_t 
_bcm_esw_stat_get_field_stage_from_table(soc_mem_t ingress_table) 
{
#if defined(BCM_TOMAHAWK_SUPPORT) || defined(BCM_TRIDENT2PLUS_SUPPORT)
    switch(ingress_table) {
        case VFP_POLICY_TABLEm:
        case VFP_POLICY_TABLE_PIPE0m:
        case VFP_POLICY_TABLE_PIPE1m:
        case VFP_POLICY_TABLE_PIPE2m:
        case VFP_POLICY_TABLE_PIPE3m:
        case VFP_POLICY_TABLE_PIPE4m:
        case VFP_POLICY_TABLE_PIPE5m:
        case VFP_POLICY_TABLE_PIPE6m:
        case VFP_POLICY_TABLE_PIPE7m:
            return bcmFieldQualifyStageLookup;
        case FP_POLICY_TABLEm:
        case IFP_POLICY_TABLEm:
        case IFP_POLICY_TABLE_PIPE0m:
        case IFP_POLICY_TABLE_PIPE1m:
        case IFP_POLICY_TABLE_PIPE2m:
        case IFP_POLICY_TABLE_PIPE3m:
        case IFP_POLICY_TABLE_PIPE4m:
        case IFP_POLICY_TABLE_PIPE5m:
        case IFP_POLICY_TABLE_PIPE6m:
        case IFP_POLICY_TABLE_PIPE7m:
            return bcmFieldQualifyStageIngress;
        case EXACT_MATCH_2m:
        case EXACT_MATCH_2_PIPE0m:
        case EXACT_MATCH_2_PIPE1m:
        case EXACT_MATCH_2_PIPE2m:
        case EXACT_MATCH_2_PIPE3m:
            return bcmFieldQualifyStageIngressExactMatch;
#if defined(BCM_TRIDENT3_SUPPORT) || defined(BCM_TOMAHAWK3_SUPPORT)
        case EFP_POLICY_TABLEm:
        case EFP_POLICY_TABLE_PIPE0m:
        case EFP_POLICY_TABLE_PIPE1m:
            return bcmFieldQualifyStageEgress;
#endif
        default:
            break;
    }
#endif
    return 0;
}

/*  
 * Function:
 *      _bcm_esw_stat_id_validate
 * Description:
 *      Check if the given flex stat id is Valid or not.
 * Parameters:
 *      stat_counter_id  (IN) Stat Counter Id
 *      group            (OUT)  Flex Group Mode
 *      mode             (OUT)  Flex Accounting Object
 *      offset           (OUT)  Flex Offset Mode
 *      pool_number      (OUT)  Allocated Pool Number for Flex Accounting Object
 *      base_idx         (OUT)  Allocated Base Index for Flex Accounting Object
 *
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 */
bcm_error_t  
_bcm_esw_stat_id_validate(int unit, uint32 stat_counter_id) 
{
    int rv = BCM_E_NONE; /* Operational status. */

#ifdef BCM_TOMAHAWK_SUPPORT

    if ((stat_counter_id > BCM_MAX_STAT_COUNTER_IDS) ||
        (stat_counter_id <= 0) || (stat_counter_map[unit][stat_counter_id].used == 0)) {
         rv = BCM_E_NOT_FOUND;
    }

#endif

    return rv;
}
/*
 * Function:
 *      _bcm_esw_stat_get_counter_id_info
 * Description:
 *      Get Stat Counter Id based on offset mode,group mode,pool number,object
 *      and base index. 
 *      
 * Parameters:
 *      stat_counter_id  (IN) Stat Counter Id
 *      group            (OUT)  Flex Group Mode
 *      mode             (OUT)  Flex Accounting Object
 *      offset           (OUT)  Flex Offset Mode
 *      pool_number      (OUT)  Allocated Pool Number for Flex Accounting Object
 *      base_idx         (OUT)  Allocated Base Index for Flex Accounting Object
 *
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 */
void _bcm_esw_stat_get_counter_id_info(
     int                   unit,
     uint32                stat_counter_id,
     bcm_stat_group_mode_t *group,
     bcm_stat_object_t     *object,
     uint32                *mode,
     uint32                *pool_number,
     uint32                *base_idx)
{
     if (!soc_feature(unit, soc_feature_flex_counter_opaque_stat_id)) {
         *mode        = (bcm_stat_flex_mode_t ) ((stat_counter_id >> 
                                                  BCM_STAT_FLEX_MODE_START_BIT) &
                                                 (BCM_STAT_FLEX_MODE_MASK));
         *group       = (bcm_stat_group_mode_t) ((stat_counter_id >> 
                                                  BCM_STAT_FLEX_GROUP_START_BIT) &
                                                 (BCM_STAT_FLEX_GROUP_MASK));
         *pool_number = ((stat_counter_id >> BCM_STAT_FLEX_POOL_START_BIT) &
                                           (BCM_STAT_FLEX_POOL_MASK));
         *object      = (bcm_stat_object_t) (((stat_counter_id >> 
                                              BCM_STAT_FLEX_OBJECT_START_BIT) &
                                             (BCM_STAT_FLEX_OBJECT_MASK))
                                             | (((stat_counter_id >> 
                                              BCM_STAT_FLEX_OBJECT_MSB_START_BIT) &
                                             BCM_STAT_FLEX_OBJECT_MSB_MASK)
                                             <<(BCM_STAT_FLEX_OBJECT_END_BIT - 
                                               BCM_STAT_FLEX_OBJECT_START_BIT+1)));
         *base_idx    = (stat_counter_id & BCM_STAT_FLEX_BASE_IDX_MASK);
     } else {
#ifdef BCM_TOMAHAWK_SUPPORT
         if ((stat_counter_id > BCM_MAX_STAT_COUNTER_IDS) ||
             (stat_counter_id <= 0) || (stat_counter_map[unit][stat_counter_id].used == 0)) {
             LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                      (BSL_META_U(unit,
                                  "Failed to get counter id info %d"), stat_counter_id));
              *mode = 0;
              *group = *pool_number = 0;
              *base_idx = 0;
              return;
         }
         *mode        = (bcm_stat_flex_mode_t ) (stat_counter_map[unit][stat_counter_id].mode); 
         *group       = (bcm_stat_group_mode_t) (stat_counter_map[unit][stat_counter_id].group);
         *pool_number = (stat_counter_map[unit][stat_counter_id].pool); 
         *object      = (bcm_stat_object_t) (stat_counter_map[unit][stat_counter_id].object);
         *base_idx    = (stat_counter_map[unit][stat_counter_id].base_idx);
#endif
    }
}

bcm_error_t _bcm_esw_stat_attr_fill(
            int	                  unit,
            bcm_stat_group_mode_t group_mode,
            bcm_stat_flex_direction_t direction,
            bcm_stat_flex_attr_t     *attr,
            uint32 *num_counters)
{
    bcm_stat_flex_ing_cmprsd_attr_selectors_t *ing_cmprsd_attr_selectors=NULL;
    bcm_stat_flex_ing_pkt_attr_bits_t         *ing_cmprsd_pkt_attr_bits=NULL;

    bcm_stat_flex_egr_cmprsd_attr_selectors_t *egr_cmprsd_attr_selectors=NULL;
    bcm_stat_flex_egr_pkt_attr_bits_t         *egr_cmprsd_pkt_attr_bits=NULL;

    bcm_stat_flex_ing_attr_t *ing_attr=NULL;
    bcm_stat_flex_egr_attr_t *egr_attr=NULL;
    uint32                   total_counters = 0;

    uint32                   l2dlf_pkt=0;
    uint32                   unknown_l3uc_pkt=0;
    uint32                   unknown_l2mc_pkt=0;
    uint32                   known_l3uc_pkt=0;
    uint32                   known_l2mc_pkt=0;
    uint32                   l2uc_pkt=0;
    uint32                   l2bc_pkt=0;
    uint32                   control_pkt=0;
    uint32                   bpdu_pkt=0;
    uint32                   shift_by_bits=0;
    uint32                   shift_by_bits_for_value=0;

    uint32                   map_index=0;
    uint32                   ignore_index=0;
    uint32                   counter_index=0;
    uint32                   outer_index=0;
    uint32                   inner_index=0;

    if (attr == NULL) {
        return BCM_E_FAIL;
    }
    l2dlf_pkt        = _bcm_esw_stat_flex_get_pkt_res_value(unit,_L2DLF_PKT);
    unknown_l3uc_pkt = _bcm_esw_stat_flex_get_pkt_res_value(unit,
                                                            _UNKNOWN_L3UC_PKT);
    unknown_l2mc_pkt =  _bcm_esw_stat_flex_get_pkt_res_value(unit,
                                                             _UNKNOWN_L2MC_PKT);
    known_l3uc_pkt   = _bcm_esw_stat_flex_get_pkt_res_value(unit,
                                                            _KNOWN_L3UC_PKT);
    known_l2mc_pkt   = _bcm_esw_stat_flex_get_pkt_res_value(unit,
                                                            _KNOWN_L2MC_PKT);
    l2uc_pkt         = _bcm_esw_stat_flex_get_pkt_res_value(unit,_L2UC_PKT);
    l2bc_pkt         = _bcm_esw_stat_flex_get_pkt_res_value(unit,_L2BC_PKT);
    control_pkt      = _bcm_esw_stat_flex_get_pkt_res_value(unit,_CONTROL_PKT);
    bpdu_pkt         = _bcm_esw_stat_flex_get_pkt_res_value(unit,_BPDU_PKT);

    /* 1. Allocating attribute Memory .... */
    sal_memset(attr,0,sizeof(bcm_stat_flex_attr_t));

    /* 2. Deciding direction */
    if (direction == bcmStatFlexDirectionIngress) {
        /* INGRESS SIDE */
        attr->direction=bcmStatFlexDirectionIngress;
        ing_attr = &(attr->ing_attr);
        ing_cmprsd_attr_selectors = &(ing_attr->cmprsd_attr_selectors);
        ing_cmprsd_pkt_attr_bits = &(ing_attr->cmprsd_attr_selectors.
                                    pkt_attr_bits);
    } else {
        /* EGRESS SIDE */
        attr->direction=bcmStatFlexDirectionEgress;
        egr_attr = &(attr->egr_attr);
        egr_cmprsd_attr_selectors=&(egr_attr->cmprsd_attr_selectors);
        egr_cmprsd_pkt_attr_bits= &(egr_attr->cmprsd_attr_selectors.
                                    pkt_attr_bits);
    } 

    if (attr->direction == bcmStatFlexDirectionEgress) {
        switch(group_mode) {
            case bcmStatGroupModeDlfAll:
            case bcmStatGroupModeSingleWithControl:
                 LOG_DEBUG(BSL_LS_BCM_FLEXCTR,
                           (BSL_META_U(unit,
                                       "Overiding group_mode->bcmStatGroupModeSingle\n")));
                 group_mode = bcmStatGroupModeSingle;
                 break;
            case bcmStatGroupModeTyped:
            case bcmStatGroupModeTypedAll:
            case bcmStatGroupModeTrafficTypeWithControl:
            case bcmStatGroupModeDlfAllWithControl:
            case bcmStatGroupModeTypedWithControl:
            case bcmStatGroupModeTypedAllWithControl: 
                 LOG_DEBUG(BSL_LS_BCM_FLEXCTR,
                           (BSL_META_U(unit,
                                       "Overiding group_mode to "
                                        "bcmStatGroupModeTrafficType \n")));
                 group_mode = bcmStatGroupModeTrafficType;
                 break;
            case bcmStatGroupModeDlfIntPri: 
            case bcmStatGroupModeDlfIntPriWithControl: 
            case bcmStatGroupModeTypedIntPriWithControl:
                 LOG_DEBUG(BSL_LS_BCM_FLEXCTR,
                           (BSL_META_U(unit,
                                       "Overiding group_mode to "
                                        "bcmStatGroupModeTypedIntPri \n")));
                 group_mode = bcmStatGroupModeTypedIntPri;
                 break;
            default:
                break;
        }
    }
    /* ######################################################### */
    /* Ingress Packet Attributes(KATANA)  */
    /*
    CNG            IFP_CNG INT_PRI VlanFmt OuterDot1P InnerDot1P IngressPort   TOS       PacketRes SVPType DROP  IP
    38-37:2        36-35:2 34-31:4 30-29:2 28-26:3    25-23:3    22-17:6       16-9:8    8-3:6     2-2:1   1-1:1 0-0:1
    PRI_CNG_FN(8)                  PKT_PRI_FN(8)                 PORT_FN_FN(6) TOS_FN(8) PKT_RES_FN(8)           NOT_USED
     */
    /* ######################################################### */

    /* ######################################################### */
    /* Egress Packet Attributes(KATANA)  */
    /*
    CNG            INT_PRI         VlanFmt OuterDot1P InnerDot1P EgressPort    TOS       PacketRes SVPType DVPType DROP  IP
    32-31:2        30-27:4         26-25:2 24-22:3    21-19:3    18-13:6       12-5:8    4-4:1     3-3:1   2-2:1   1-1:1 0-0:1
    PRI_CNG_FN(6)                  PKT_PRI_FN(8)                 PORT_FN_FN(6) TOS_FN(8) PKT_RES_FN(4)                   NOT_USED
     */
    /* ######################################################### */


    /* 3. Filling up attributes */
    switch(group_mode) {
    case bcmStatGroupModeSingle:
         /* *********************************************/
         /* A single counter used for all traffic types */
         /* 1) UNKNOWN_PKT|CONTROL_PKT|BPDU_PKT|L2BC_PKT|L2UC_PKT|L2DLF_PKT| */
         /*    UNKNOWN_IPMC_PKT|KNOWN_IPMC_PKT|KNOWN_L2MC_PKT|               */
         /*    UNKNOWN_L2MC_PKT|UNKNOWN_L2MC_PKT|KNOWN_L3UC_PKT|             */
         /*    UNKNOWN_L3UC_PKT|KNOWN_MPLS_PKT|KNOWN_MPLS_L3_PKT|            */
         /*    KNOWN_MPLS_L2_PKT|UNKNOWN_MPLS_PKT|KNOWN_MIM_PKT|             */
         /*    UNKNOWN_MIM_PKT|KNOWN_MPLS_MULTICAST_PKT                      */

         /* ******************************************* */
         if (attr->direction==bcmStatFlexDirectionIngress) {
             total_counters=1;
             _bcm_esw_fillup_ing_uncmp_attr(
                 ing_attr,
                 BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_PKT_RESOLUTION_ATTR_BITS,
                 1);
             _bcm_esw_fillup_ing_pkt_res_offset_table(
                 ing_attr,sizeof(ing_Single_res)/sizeof(ing_Single_res[0]),
                 &ing_Single_res[0]);
         } else {
             total_counters=1;
             _bcm_esw_fillup_egr_uncmp_attr(
                 egr_attr,
                 BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_PKT_RESOLUTION_ATTR_BITS,
                 1);
             _bcm_esw_fillup_egr_pkt_res_offset_table(
                 egr_attr,sizeof(egr_Single_res)/sizeof(egr_Single_res[0]),
                 &egr_Single_res[0]);
         }
         break;
    case bcmStatGroupModeTrafficType:
         /* **************************************************************** */
         /* A dedicated counter per traffic type Unicast,multicast,broadcast */
         /* 1) L2UC_PKT | KNOWN_L3UC_PKT | UNKNOWN_L3UC_PKT                  */
         /* 2) KNOWN_L2MC_PKT|UNKNOWN_L2MC_PKT|                              */
         /* 3) L2BC_PKT|                                                     */
         /* **************************************************************** */

         if (attr->direction==bcmStatFlexDirectionIngress) {
             total_counters=3;
             _bcm_esw_fillup_ing_uncmp_attr(
                 ing_attr,
                 BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_PKT_RESOLUTION_ATTR_BITS,
                 3);
             _bcm_esw_fillup_ing_pkt_res_offset_table(
                 ing_attr,
                 sizeof(ing_TrafficType_res)/sizeof(ing_TrafficType_res[0]),
                 &ing_TrafficType_res[0]);
         } else {
             total_counters=2;
             _bcm_esw_fillup_egr_uncmp_attr(
                 egr_attr,
                 BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_PKT_RESOLUTION_ATTR_BITS,
                 2);
             _bcm_esw_fillup_egr_pkt_res_offset_table(
                 egr_attr,
                 sizeof(egr_TrafficType_res)/sizeof(egr_TrafficType_res[0]),
                 &egr_TrafficType_res[0]);
         }
         break;
    case bcmStatGroupModeDlfAll:
         /* ************************************************************* */
         /* A pair of counters where the base counter is used for dlf and */ 
         /* the other counter is used for all traffic types               */
         /* 1) L2DLF_PKT                                                  */
         /* 2) UNKNOWN_PKT | CONTROL_PKT|BPDU_PKT|L2BC_PKT|L2UC_PKT|      */
         /*    L2DLF_PKT|UNKNOWN_IPMC_PKT|KNOWN_IPMC_PKT|KNOWN_L2MC_PKT|  */
         /*    UNKNOWN_L2MC_PKT|UNKNOWN_L2MC_PKT|KNOWN_L3UC_PKT|          */
         /*    UNKNOWN_L3UC_PKT|KNOWN_MPLS_PKT|KNOWN_MPLS_L3_PKT|         */
         /*    KNOWN_MPLS_L2_PKT|UNKNOWN_MPLS_PKT|KNOWN_MIM_PKT|          */
         /*    UNKNOWN_MIM_PKT|KNOWN_MPLS_MULTICAST_PKT                   */
         /* ************************************************************* */

         if (attr->direction==bcmStatFlexDirectionIngress) {
             total_counters=2;
             _bcm_esw_fillup_ing_uncmp_attr(
                 ing_attr,
                 BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_PKT_RESOLUTION_ATTR_BITS,
                 2);
             _bcm_esw_fillup_ing_pkt_res_offset_table(
                 ing_attr,sizeof(ing_DlfAll_res)/sizeof(ing_DlfAll_res[0]),
                 &ing_DlfAll_res[0]);
         } else {
             /* Group mode is overrided so  control shouldn't hit this part */
             LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                       (BSL_META_U(unit,
                                   "bcmStatGroupModeDlfAll is not supported"
                                    "in egress side\n")));
             sal_free(attr);
             return BCM_E_INTERNAL;
         }
         break;
    case bcmStatGroupModeDlfIntPri:
         /* ************************************************************** */
         /* N+1 counters where the base counter is used for dlf and next N */
         /* are used per Cos                                               */
         /* 1) L2_DLF                                                      */
         /* 2..17) INT_PRI bits: 4bits                                     */
         /* ************************************************************** */

         if (attr->direction==bcmStatFlexDirectionEgress) {
             /* Must not hit */
             LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                       (BSL_META_U(unit,
                                   "bcmStatGroupModeDlfIntPri IsNotAvailable"
                                    "in EgressSide\n")));
             sal_free(attr);
             return BCM_E_INTERNAL;
         }

        if (SOC_IS_TOMAHAWK3(unit)) {
            LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                      (BSL_META_U(unit,
                                  "bcmStatGroupModeDlfIntPri IsNotAvailable"
                                   "for %s\n"), SOC_UNIT_NAME(unit)));
            sal_free(attr);
            return BCM_E_UNAVAIL;
        }

         /* Although 17 counters but pkt_res(6) + int_pri(4)=10 bits
            so cannot use UNCOMPRESSED MODE */

         /* INT_PRI */ /* .... */ /* PacketRes */ 
         /* 34-31:4 */ /* .... */ /* 8-3:6     */
         /* PRI_CNG_FN=Cng(2x):IFP(2x):IntPri( all 4bits are used). 
            RightMost so no shifting required */
         /* PKT_RES_FN=Pkt(6bits  but 1 is used):SVP(1x):Drop(1x).
            LeftMost so 2 Left shifting required */

         total_counters=17;
         ing_attr->packet_attr_type=bcmStatFlexPacketAttrTypeCompressed;

         ing_cmprsd_pkt_attr_bits->pkt_resolution = 1;
         
         ing_cmprsd_pkt_attr_bits->pkt_resolution_pos = ing_pkt_attr_cmprsd_bits_g[unit].
                                                        pkt_resolution_pos;
         ing_cmprsd_pkt_attr_bits->pkt_resolution_mask = 1;

         ing_cmprsd_pkt_attr_bits->int_pri = ing_pkt_attr_cmprsd_bits_g[unit].int_pri;
         ing_cmprsd_pkt_attr_bits->int_pri_pos = ing_pkt_attr_cmprsd_bits_g[unit].
                                                 int_pri_pos;
         ing_cmprsd_pkt_attr_bits->int_pri_mask = ing_pkt_attr_cmprsd_bits_g[unit].
                                                 int_pri_mask;

         ing_cmprsd_attr_selectors->total_counters = 17;

         /* set pkt_resolution map for  1 counters */
         /* Map[Encoded Packet value << 2=>[SVP-1bit + DROP-1bit]=
                CounterIndex << 2=>[SVP-1bit + DROP-1bit]=4(Start),8,12*/

         /* Reset pkt_resolution map */
         for (map_index=0; 
              map_index < sizeof(bcm_stat_flex_ing_cmprsd_pkt_res_attr_map_t) ;
              map_index++) {
              ing_cmprsd_attr_selectors->pkt_res_attr_map[map_index]=0;
         }
         shift_by_bits= ing_pkt_attr_cmprsd_bits_g[unit].svp_type + ing_pkt_attr_cmprsd_bits_g[unit].drop;
         shift_by_bits_for_value = shift_by_bits;

         for (ignore_index=0; 
              ignore_index < (1<<shift_by_bits); ignore_index++) {
              ing_cmprsd_attr_selectors->
                  pkt_res_attr_map[(l2dlf_pkt<<shift_by_bits) | ignore_index]=
                  (1<<(shift_by_bits_for_value));
         }

         /* Reset pri_cng map */
         for (map_index=0; map_index < 256 ;map_index++) {
              ing_cmprsd_attr_selectors->pri_cnf_attr_map[map_index]=0;
         }
         /* set pri_cng map for  16 counters */
         for (ignore_index=0; ignore_index < (1<<4) ; ignore_index++) {
              for (map_index=0; map_index < 16 ;map_index++) {
                   ing_cmprsd_attr_selectors->
                   pri_cnf_attr_map[(ignore_index<<4) | map_index]=map_index;
              }
         }

         /* Reset all Offset table fields */
         for (counter_index=0;counter_index<256;counter_index++) {
              ing_cmprsd_attr_selectors->
                        offset_table_map[counter_index].offset=0;
              ing_cmprsd_attr_selectors->
                        offset_table_map[counter_index].count_enable=0;
         }

         /* Set DLF counter indexes(ODD 1,3,5) considering INT_PRI bits 
            don't care */
         for (counter_index=0;counter_index<16;counter_index++) {
              ing_cmprsd_attr_selectors->
                        offset_table_map[(counter_index<<1)|1].offset=0;
              ing_cmprsd_attr_selectors->
                        offset_table_map[(counter_index<<1)|1].count_enable=1;
         }

         /* Set Int pri counter indexes(Even 2,4,6) considering DLF=0 */
         for (counter_index=0;counter_index<16;counter_index++) {
              ing_cmprsd_attr_selectors->
                        offset_table_map[(counter_index<<1)].
                        offset=(counter_index+1);
              ing_cmprsd_attr_selectors->
                        offset_table_map[(counter_index<<1)].count_enable=1;
         }
         break;
    case bcmStatGroupModeTyped:
         /* ******************************************************* */
         /* A dedicated counter for unknown unicast, known unicast, */
         /* multicast, broadcast                                    */
         /* 1) UNKNOWN_L3UC_PKT|_L2DLF_PKT                                     */
         /* 2) L2UC_PKT | KNOWN_L3UC_PKT                            */
         /* 3) KNOWN_L2MC_PKT|UNKNOWN_L2MC_PKT                      */
         /* 4) L2BC_PKT                                             */
         /* ******************************************************* */
         if (attr->direction==bcmStatFlexDirectionIngress) {
             total_counters=4;
             _bcm_esw_fillup_ing_uncmp_attr(
                 ing_attr,
                 BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_PKT_RESOLUTION_ATTR_BITS,
                 4);
             _bcm_esw_fillup_ing_pkt_res_offset_table(
                 ing_attr,sizeof(ing_Typed_res)/sizeof(ing_Typed_res[0]),
                 &ing_Typed_res[0]);
         } else {
             /* Group mode is overrided so  control shouldn't hit this part */
             LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                       (BSL_META_U(unit,
                                   "bcmStatGroupModeTyped: is not supported"
                                    " in egress side\n")));
             sal_free(attr);
             return BCM_E_INTERNAL;
         }
         break;
    case bcmStatGroupModeTypedAll:
         /* ******************************************************* */
         /* A dedicated counter for unknown unicast, known unicast, */
         /* multicast, broadcast and one for all traffic(not already*/
         /* counted)                                                */
         /* 1) UNKNOWN_L3UC_PKT                                     */
         /* 2) L2UC_PKT | KNOWN_L3UC_PKT                            */
         /* 3) KNOWN_L2MC_PKT|UNKNOWN_L2MC_PKT                      */
         /* 4) L2BC_PKT                                             */
         /* 5) UNKNOWN_PKT|CONTROL_PKT|BPDU_PKT|L2DLF_PKT|          */
         /*    UNKNOWN_IPMC_PKT|KNOWN_IPMC_PKT|KNOWN_MPLS_PKT |     */
         /*    KNOWN_MPLS_L3_PKT|KNOWN_MPLS_L2_PKT|UNKNOWN_MPLS_PKT */
         /*    KNOWN_MIM_PKT|UNKNOWN_MIM_PKT|                       */
         /*    KNOWN_MPLS_MULTICAST_PKT                             */
         /* ******************************************************* */
         if (attr->direction==bcmStatFlexDirectionIngress) {
             total_counters=5;
             _bcm_esw_fillup_ing_uncmp_attr(
                 ing_attr,
                 BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_PKT_RESOLUTION_ATTR_BITS,
                 5);
             _bcm_esw_fillup_ing_pkt_res_offset_table(
                 ing_attr,sizeof(ing_TypedAll_res)/sizeof(ing_TypedAll_res[0]),
                 &ing_TypedAll_res[0]);
         } else {
             /* Group mode is overrided so  control shouldn't hit this part */
             LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                       (BSL_META_U(unit,
                                   "bcmStatGroupModeTypedAll is NotSupported"
                                    " in EgressSide\n")));
             sal_free(attr);
             return BCM_E_INTERNAL;
         }
         break;
    case bcmStatGroupModeTypedIntPri:
        if (SOC_IS_TOMAHAWK3(unit)) {
            LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                      (BSL_META_U(unit,
                                  "bcmStatGroupModeTypedIntPri IsNotAvailable"
                                   "for %s\n"), SOC_UNIT_NAME(unit)));
            sal_free(attr);
            return BCM_E_UNAVAIL;
        }

         /* *************************************************************** */
         /* A dedicated counter for unknown unicast, known unicast,         */
         /* multicast,broadcast and N internal priority counters for traffic*/
         /* (not already counted)                                           */
         /* 1) UNKNOWN_L3UC_PKT                                             */
         /* 2) L2UC_PKT | KNOWN_L3UC_PKT                                    */ 
         /* 3) KNOWN_L2MC_PKT|UNKNOWN_L2MC_PKT                              */
         /* 4) L2BC_PKT                                                     */
         /* 5..20) INT_PRI bits: 4bits                                      */
         /* *************************************************************** */
         if (attr->direction==bcmStatFlexDirectionIngress) {

             /* Although 20 counters but pkt_res(6) + int_pri(4)=10 bits
                so cannot use UNCOMPRESSED MODE */

             /* INT_PRI */ /* .... */ /* PacketRes */ 
             /* 34-31:4 */ /* .... */ /* 8-3:6     */
             /* PRI_CNG_FN=Cng(2x):IFP(2x):IntPri( all 4bits are used). 
                RightMost so no shifting required */
             /* PKT_RES_FN=Pkt(6bits  but 3 is used):SVP(1x):Drop(1x).
                LeftMost so 2 Left shifting required */

             total_counters=20;

             ing_attr->packet_attr_type=bcmStatFlexPacketAttrTypeCompressed;
             /* Cannot consider 0 value so taking 3 i.s.o. 2 */
             ing_cmprsd_pkt_attr_bits->pkt_resolution = 3;
             ing_cmprsd_pkt_attr_bits->pkt_resolution_pos = ing_pkt_attr_cmprsd_bits_g[unit].
                                                            pkt_resolution_pos;
             ing_cmprsd_pkt_attr_bits->pkt_resolution_mask = (1<<3)-1;

             ing_cmprsd_pkt_attr_bits->int_pri = ing_pkt_attr_cmprsd_bits_g[unit].int_pri;
             ing_cmprsd_pkt_attr_bits->int_pri_pos = ing_pkt_attr_cmprsd_bits_g[unit].
                                                     int_pri_pos;
             ing_cmprsd_pkt_attr_bits->int_pri_mask= ing_pkt_attr_cmprsd_bits_g[unit].
                                                     int_pri_mask;

             ing_cmprsd_attr_selectors->total_counters = 20;
             /* Reset pkt_resolution map */
             for (map_index=0; map_index < 256 ;map_index++) {
                  ing_cmprsd_attr_selectors->pkt_res_attr_map[map_index]=0;
             }
             /* set pkt_resolution map for  1 counters */
             /* Map[Encoded Packet value << 2=>[SVP-1bit + DROP-1bit]=
                CounterIndex << 2=>[SVP-1bit + DROP-1bit]=4(Start),8,12*/
             shift_by_bits= ing_pkt_attr_cmprsd_bits_g[unit].svp_type + 
                            ing_pkt_attr_cmprsd_bits_g[unit].drop;
             shift_by_bits_for_value = shift_by_bits;

             /* set pkt_resolution map for  1 counters.Ignore SVP,DROP bits */
             for (ignore_index=0; 
                  ignore_index < (1<<shift_by_bits) ; ignore_index++) {
                  ing_cmprsd_attr_selectors->pkt_res_attr_map[
                      (unknown_l3uc_pkt<<shift_by_bits)|ignore_index]=
                      (1<<shift_by_bits_for_value);
                  ing_cmprsd_attr_selectors->pkt_res_attr_map[
                      (l2uc_pkt<<shift_by_bits)|ignore_index]=
                      (2<<shift_by_bits_for_value);
                  ing_cmprsd_attr_selectors->pkt_res_attr_map[
                      (known_l3uc_pkt<<shift_by_bits)|ignore_index]=
                      (2<<shift_by_bits_for_value);
                  ing_cmprsd_attr_selectors->pkt_res_attr_map[
                      (known_l2mc_pkt<<shift_by_bits)|ignore_index]=
                      (3<<shift_by_bits_for_value);
                  ing_cmprsd_attr_selectors->pkt_res_attr_map[
                      (unknown_l2mc_pkt<<shift_by_bits)|ignore_index]=
                      (3<<shift_by_bits_for_value);
                  ing_cmprsd_attr_selectors->pkt_res_attr_map[
                      (l2bc_pkt<<shift_by_bits)|ignore_index]=
                      (4<<shift_by_bits_for_value);
             }
             /* Reset pri_cng map */
             for (map_index=0; map_index < 256 ;map_index++) {
                  ing_cmprsd_attr_selectors->pri_cnf_attr_map[map_index]=0;
             }
             /* set pri_cng map for  16 counters */
             for (ignore_index=0; ignore_index < (1<<4) ; ignore_index++) {
                  for (map_index=0; map_index < 16 ;map_index++) {
                       ing_cmprsd_attr_selectors->
                        pri_cnf_attr_map[(ignore_index<<4)|map_index]=map_index;
                  }
             }
             /* Reset all Offset table fields */
             for (counter_index=0;counter_index<256;counter_index++) {
                  ing_cmprsd_attr_selectors->
                           offset_table_map[counter_index].offset=0;
                  ing_cmprsd_attr_selectors->
                           offset_table_map[counter_index].count_enable=0;
             }
             /* ************************************************************* */
             /* Set unicast, known unicast, multicast, broadcast counter      */
             /* indexes considering INT_PRI as 0                              */
             /* ************************************************************* */
             ing_cmprsd_attr_selectors->offset_table_map[1].offset=0;
             ing_cmprsd_attr_selectors->offset_table_map[1].count_enable=1;
             ing_cmprsd_attr_selectors->offset_table_map[2].offset=1;
             ing_cmprsd_attr_selectors->offset_table_map[2].count_enable=1;
             ing_cmprsd_attr_selectors->offset_table_map[3].offset=2;
             ing_cmprsd_attr_selectors->offset_table_map[3].count_enable=1;
             ing_cmprsd_attr_selectors->offset_table_map[4].offset=3;
             ing_cmprsd_attr_selectors->offset_table_map[4].count_enable=1;


             /* Set Int pri counter indexes NotConsidering pkt resolution bits*/
             /* Priority 0 Counter not satisfying any condition */
             ing_cmprsd_attr_selectors->offset_table_map[0].offset=4;
             ing_cmprsd_attr_selectors->offset_table_map[0].count_enable=1;
             ing_cmprsd_attr_selectors->offset_table_map[5].offset=4;
             ing_cmprsd_attr_selectors->offset_table_map[5].count_enable=1;
             ing_cmprsd_attr_selectors->offset_table_map[6].offset=4;
             ing_cmprsd_attr_selectors->offset_table_map[6].count_enable=1;
             ing_cmprsd_attr_selectors->offset_table_map[7].offset=4;
             ing_cmprsd_attr_selectors->offset_table_map[7].count_enable=1;
             /*INT_PRI*/
             for (counter_index=1;counter_index<(1<<4);counter_index++) {
                  /*PktRes*/
                  for(ignore_index=0;ignore_index<(1<<3);ignore_index++) {
                      ing_cmprsd_attr_selectors->
                       offset_table_map[(counter_index<<3)|ignore_index].
                       offset=(counter_index+4);
                      ing_cmprsd_attr_selectors->
                       offset_table_map[(counter_index<<3)|ignore_index].
                       count_enable=1;
                  }
             }
         } else {
             /* ************************************************************* */
             /* A dedicated counter for unknown unicast, known unicast,       */
             /* multicast,broadcast and N internal priority counters for      */ 
             /* traffic (not already counted)                                 */
             /* 1) Unicast                                                    */
             /* 2) Multicast                                                  */
             /* 3..18) INT_PRI bits: 4bits                                    */
             /* ************************************************************* */
            total_counters=18;
            egr_attr->packet_attr_type=bcmStatFlexPacketAttrTypeCompressed;

            egr_cmprsd_pkt_attr_bits->pkt_resolution = egr_pkt_attr_cmprsd_bits_g[unit].
                                                       pkt_resolution;
            egr_cmprsd_pkt_attr_bits->pkt_resolution_pos = egr_pkt_attr_cmprsd_bits_g[unit].
                                                           pkt_resolution_pos;
            egr_cmprsd_pkt_attr_bits->pkt_resolution_mask = egr_pkt_attr_cmprsd_bits_g[unit].
                                                            pkt_resolution_mask;

            egr_cmprsd_pkt_attr_bits->int_pri = egr_pkt_attr_cmprsd_bits_g[unit].int_pri;
            egr_cmprsd_pkt_attr_bits->int_pri_pos = egr_pkt_attr_cmprsd_bits_g[unit].
                                                    int_pri_pos;
            egr_cmprsd_pkt_attr_bits->int_pri_mask=egr_pkt_attr_cmprsd_bits_g[unit].int_pri_mask;

            egr_cmprsd_attr_selectors->total_counters = 18;

            shift_by_bits= egr_pkt_attr_cmprsd_bits_g[unit].svp_type + 
                           egr_pkt_attr_cmprsd_bits_g[unit].dvp_type + 
                           egr_pkt_attr_cmprsd_bits_g[unit].drop;
             shift_by_bits_for_value = shift_by_bits;
            /* Set pkt_resolution map */
            /* Unicast */
            for (map_index=0; map_index < 1<< shift_by_bits ;map_index++) {
                 egr_cmprsd_attr_selectors->pkt_res_attr_map[map_index]=0;
            }       
            /* Multicast */
            for (; map_index < 255 ;map_index++) {
                 egr_cmprsd_attr_selectors->
                       pkt_res_attr_map[map_index]=(1<<shift_by_bits_for_value);
            }       

            /* Reset pri_cng map */
            for (map_index=0; map_index < 64 ;map_index++) {
                 egr_cmprsd_attr_selectors->pri_cnf_attr_map[map_index]=0;
            }        
            /* set pri_cng map for  16 counters */
            for (ignore_index=0; ignore_index < (1<<2) ; ignore_index++) {
                 for (map_index=0; map_index < 16 ;map_index++) {
                      egr_cmprsd_attr_selectors->
                        pri_cnf_attr_map[(ignore_index<<4)|map_index]=map_index;
                 }       
            }
            /* Reset all Offset table fields */
            for(counter_index=0;counter_index<256;counter_index++) {
                egr_cmprsd_attr_selectors->
                          offset_table_map[counter_index].offset=0;
                egr_cmprsd_attr_selectors->
                          offset_table_map[counter_index].count_enable=0;
            }
            /* ************************************************************** */
            /* Set unicast, multicast, counter indexes                        */
            /* considering INT_PRI bits zero                                  */
            /* ************************************************************** */
            egr_cmprsd_attr_selectors->
                      offset_table_map[0].offset=0;
            egr_cmprsd_attr_selectors->
                      offset_table_map[0].count_enable=1;
            egr_cmprsd_attr_selectors->
                      offset_table_map[1].offset=1;
            egr_cmprsd_attr_selectors->
                      offset_table_map[1].count_enable=1;
            /* PRI-0 counters will be addition of unicast & multicast packets!*/
            /* Set Int pri counter indexes ignoring pkt_res bits           */
            /*INT_PRI*/
            for (counter_index=1;counter_index<(1<<4);counter_index++) {
                 /*PktRes*/
                 for (ignore_index=0;ignore_index<(1<<1);ignore_index++) {
                      egr_cmprsd_attr_selectors->
                       offset_table_map[(counter_index<<1)|ignore_index].
                       offset=(counter_index+2);
                      egr_cmprsd_attr_selectors->
                       offset_table_map[(counter_index<<1)|ignore_index].
                       count_enable=1;
                 }
            }
         }
         break;
    case bcmStatGroupModeSingleWithControl:
         /* **************************************************************   */
         /* A single counter used for all traffic types with an additional   */ 
         /* counter for control traffic                                      */
         /* 1) UNKNOWN_PKT|                    |L2BC_PKT|L2UC_PKT|L2DLF_PKT| */
         /*    UNKNOWN_IPMC_PKT|KNOWN_IPMC_PKT|KNOWN_L2MC_PKT|               */
         /*    UNKNOWN_L2MC_PKT|UNKNOWN_L2MC_PKT|KNOWN_L3UC_PKT|             */
         /*    UNKNOWN_L3UC_PKT|KNOWN_MPLS_PKT|KNOWN_MPLS_L3_PKT|            */
         /*    KNOWN_MPLS_L2_PKT|UNKNOWN_MPLS_PKT|KNOWN_MIM_PKT|             */
         /*    UNKNOWN_MIM_PKT|KNOWN_MPLS_MULTICAST_PKT                      */
         /* 2) CONTROL_PKT|BPDU_PKT                                          */
         /* **************************************************************   */
         if (attr->direction==bcmStatFlexDirectionIngress) {
             total_counters=2;
             _bcm_esw_fillup_ing_uncmp_attr(
                 ing_attr,
                 BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_PKT_RESOLUTION_ATTR_BITS,
                 2);
             _bcm_esw_fillup_ing_pkt_res_offset_table(
                 ing_attr,
                 sizeof(ing_SingleWithControl_res)/
                 sizeof(ing_SingleWithControl_res[0]),
                 &ing_SingleWithControl_res[0]);
         } else {
             /* Group mode is overrided so  control shouldn't hit this part */
             LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                       (BSL_META_U(unit,
                                   "bcmStatGroupModeSingleWithControl"
                                    " is not supported in egress side\n")));
             sal_free(attr);
             return BCM_E_INTERNAL;
         }
         break;
    case bcmStatGroupModeTrafficTypeWithControl:
         /* ********************************************************  */
         /* A dedicated counter per traffic type unicast, multicast,  */
         /* broadcast with an additional counter for control traffic  */
         /* 1) L2UC_PKT | KNOWN_L3UC_PKT | UNKNOWN_L3UC_PKT           */
         /* 2) KNOWN_L2MC_PKT|UNKNOWN_L2MC_PKT|                       */
         /* 3) L2BC_PKT|                                              */
         /* 4) CONTROL_PKT|BPDU_PKT                                   */
         /* ********************************************************  */
         if (attr->direction==bcmStatFlexDirectionIngress) {
             total_counters=4;
             _bcm_esw_fillup_ing_uncmp_attr(
                 ing_attr,
                 BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_PKT_RESOLUTION_ATTR_BITS,
                 4);
             _bcm_esw_fillup_ing_pkt_res_offset_table(
                 ing_attr,
                 sizeof(ing_TrafficTypeWithControl_res)/
                 sizeof(ing_TrafficTypeWithControl_res[0]),
                 &ing_TrafficTypeWithControl_res[0]);
         } else {
             /* Group mode is overrided so  control shouldn't hit this part */
             LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                       (BSL_META_U(unit,
                                   "bcmStatGroupModeTrafficTypeWithControl"
                                    "is not supported in egress side\n")));
             sal_free(attr);
             return BCM_E_INTERNAL;
         }
         break;
    case bcmStatGroupModeDlfAllWithControl:
         /* ************************************************************** */
         /* A pair of counters where the base counter is used for control, */
         /* the next one for dlf and the other counter is used for all     */
         /* traffic types                                                  */
         /* 1) CONTROL_PKT|BPDU_PKT                                        */
         /* 2) L2DLF_PKT                                                   */
         /* 3)UNKNOWN_PKT | CONTROL_PKT|BPDU_PKT|L2BC_PKT|L2UC_PKT|        */
         /*   L2DLF_PKT|UNKNOWN_IPMC_PKT|KNOWN_IPMC_PKT|KNOWN_L2MC_PKT|    */
         /*   UNKNOWN_L2MC_PKT|UNKNOWN_L2MC_PKT|KNOWN_L3UC_PKT|            */
         /*   UNKNOWN_L3UC_PKT|KNOWN_MPLS_PKT|KNOWN_MPLS_L3_PKT|           */
         /*   KNOWN_MPLS_L2_PKT|UNKNOWN_MPLS_PKT|KNOWN_MIM_PKT|            */
         /*   UNKNOWN_MIM_PKT|KNOWN_MPLS_MULTICAST_PKT                     */
         /* ************************************************************** */
         if (attr->direction==bcmStatFlexDirectionIngress) {
             total_counters=3;
             _bcm_esw_fillup_ing_uncmp_attr(
                 ing_attr,
                 BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_PKT_RESOLUTION_ATTR_BITS,
                 3);
             _bcm_esw_fillup_ing_pkt_res_offset_table(
                 ing_attr,
                 sizeof(ing_DlfAllWithControl_res)/
                 sizeof(ing_DlfAllWithControl_res[0]),
                 &ing_DlfAllWithControl_res[0]);
         } else {
             /* Group mode is overrided so  control shouldn't hit this part */
             LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                       (BSL_META_U(unit,
                                   "bcmStatGroupModeDlfAllWithControl is not supported "
                                    "in egress side\n")));
             sal_free(attr);
             return BCM_E_INTERNAL;
         }
         break;
    case bcmStatGroupModeDlfIntPriWithControl:
         /* ************************************************************* */
         /* N+2 counters where the base counter is used for control, the  */
         /* next one for dlf and next N are used per Cos                  */
         /* 1) CONTROL_PKT|BPDU_PKT                                       */
         /* 2) L2_DLF                                                     */
         /* 3..18) INT_PRI bits: 4bits                                    */
         /* ************************************************************* */
         if (attr->direction==bcmStatFlexDirectionEgress) {
             LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                       (BSL_META_U(unit,
                                   "GroupModeDlfIntPriWithControl is not available in "
                                    "egress side\n")));
             sal_free(attr);
             return BCM_E_INTERNAL;
         }

        if (SOC_IS_TOMAHAWK3(unit)) {
            LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                      (BSL_META_U(unit,
                                  "bcmStatGroupModeDlfIntPriWithControl IsNotAvailable"
                                   "for %s\n"), SOC_UNIT_NAME(unit)));
            sal_free(attr);
            return BCM_E_UNAVAIL;
        }
         /* Although 18 counters but pkt_res(6) + int_pri(4)=10 bits
            so cannot use UNCOMPRESSED MODE */

         /* INT_PRI */ /* .... */ /* PacketRes */ 
         /* 34-31:4 */ /* .... */ /* 8-3:6     */
         /* PRI_CNG_FN=Cng(2x):IFP(2x):IntPri( all 4bits are used). 
             RightMost so no shifting required */
         /* PKT_RES_FN=Pkt(6bits  but 2 is used):SVP(1x):Drop(1x).
            LeftMost so 2 Left shifting required */

         total_counters=18;
         ing_attr->packet_attr_type=bcmStatFlexPacketAttrTypeCompressed;

         ing_cmprsd_pkt_attr_bits->pkt_resolution = 2;
         ing_cmprsd_pkt_attr_bits->pkt_resolution_pos = ing_pkt_attr_cmprsd_bits_g[unit].
                                                        pkt_resolution_pos;
         ing_cmprsd_pkt_attr_bits->pkt_resolution_mask = (1<<2)-1;

         ing_cmprsd_pkt_attr_bits->int_pri = ing_pkt_attr_cmprsd_bits_g[unit].int_pri;
         ing_cmprsd_pkt_attr_bits->int_pri_pos = ing_pkt_attr_cmprsd_bits_g[unit].
                                                 int_pri_pos;

         ing_cmprsd_pkt_attr_bits->int_pri_mask = ing_pkt_attr_cmprsd_bits_g[unit].
                                                  int_pri_mask;
         ing_cmprsd_attr_selectors->total_counters = 18;

         /* Reset pkt_resolution map */
         for (map_index=0; map_index < 256 ;map_index++) {
              ing_cmprsd_attr_selectors->pkt_res_attr_map[map_index]=0;
         }
         /* set pkt_resolution map for  1 counters */
         /* Map[Encoded Packet value << 2=>[SVP-1bit + DROP-1bit]=
            CounterIndex << 2=>[SVP-1bit + DROP-1bit]=4(Start),8,12*/

         shift_by_bits= ing_pkt_attr_cmprsd_bits_g[unit].svp_type + ing_pkt_attr_cmprsd_bits_g[unit].drop;
         shift_by_bits_for_value = shift_by_bits;

         for (ignore_index=0; 
              ignore_index < (1<<shift_by_bits) ; ignore_index++) {
              ing_cmprsd_attr_selectors->
                   pkt_res_attr_map[
                   (control_pkt<<shift_by_bits) | ignore_index]=
                   (1<<shift_by_bits_for_value);
              ing_cmprsd_attr_selectors->
                   pkt_res_attr_map[(bpdu_pkt<<shift_by_bits) | ignore_index]=
                   (1<<shift_by_bits_for_value);
              ing_cmprsd_attr_selectors->
                   pkt_res_attr_map[
                   (l2dlf_pkt<<shift_by_bits) | ignore_index]=
                   (2<<shift_by_bits_for_value);
         }

         /* Reset pri_cng map */
         for (map_index=0; map_index < 256 ;map_index++) {
              ing_cmprsd_attr_selectors->pri_cnf_attr_map[map_index]=0;
         }
         /* set pri_cng map for  16 counters */
         for (ignore_index=0; ignore_index < (1<<4) ; ignore_index++) {
              for (map_index=0; map_index < 16 ;map_index++) {
                   ing_cmprsd_attr_selectors->
                     pri_cnf_attr_map[(ignore_index<<4) | map_index]=map_index;
              }
         }

         /* Reset all Offset table fields */
         for(counter_index=0;counter_index<256;counter_index++) {
                 ing_cmprsd_attr_selectors->
                           offset_table_map[counter_index].offset=0;
                 ing_cmprsd_attr_selectors->
                           offset_table_map[counter_index].count_enable=0;
         }
         /* ************************************************************ */
         /* Set CONTROL_PKT|BPDU_PKT , L2DLF counter indexes considering */
         /* INT_PRI bits 0                                               */
         /* ************************************************************ */

         ing_cmprsd_attr_selectors->offset_table_map[1].offset=0;
         ing_cmprsd_attr_selectors->offset_table_map[1].count_enable=1;
         ing_cmprsd_attr_selectors->offset_table_map[2].offset=1;
         ing_cmprsd_attr_selectors->offset_table_map[2].count_enable=1;

         /* Set IntPri counter indexes not-considering pkt resolution bits*/
         /* Priority 0 Counter not satisfying any condition  */
         ing_cmprsd_attr_selectors->offset_table_map[0].offset=2;
         ing_cmprsd_attr_selectors->offset_table_map[0].count_enable=1;
         ing_cmprsd_attr_selectors->offset_table_map[3].offset=2;
         ing_cmprsd_attr_selectors->offset_table_map[3].count_enable=1;
         /*INT_PRI*/
         for (counter_index=1;counter_index<(1<<4);counter_index++) {
              /*PktRes*/
              for (ignore_index=0;ignore_index<(1<<2);ignore_index++) {
                   ing_cmprsd_attr_selectors->
                       offset_table_map[(counter_index<<2)|ignore_index].
                       offset=(counter_index+2);
                   ing_cmprsd_attr_selectors->
                       offset_table_map[(counter_index<<2)|ignore_index].
                       count_enable=1;
              }
         }
         break;
    case bcmStatGroupModeTypedWithControl:
         /* **************************************************************** */
         /* A dedicated counter for control, unknown unicast, known unicast, */
         /* multicast, broadcast                                             */
         /* 1) CONTROL_PKT|BPDU_PKT                                          */
         /* 2) UNKNOWN_L3UC_PKT                                              */
         /* 3) L2UC_PKT | KNOWN_L3UC_PKT                                     */
         /* 4) KNOWN_L2MC_PKT|UNKNOWN_L2MC_PKT                               */
         /* 5) L2BC_PKT                                                      */
         /* **************************************************************** */
         if (attr->direction == bcmStatFlexDirectionIngress) {
             total_counters=5;
             _bcm_esw_fillup_ing_uncmp_attr(
                 ing_attr,
                 BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_PKT_RESOLUTION_ATTR_BITS,
                 5);
             _bcm_esw_fillup_ing_pkt_res_offset_table(
                 ing_attr,
                 sizeof(ing_TypedWithControl_res)/
                 sizeof(ing_TypedWithControl_res[0]),
                 &ing_TypedWithControl_res[0]);
         } else {
             /* Group mode is overrided so  control shouldn't hit this part */
             LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                       (BSL_META_U(unit,
                                   "bcmStatGroupModeTypedWithControl" 
                                    "is not supported in egress side\n")));
             sal_free(attr);
             return BCM_E_INTERNAL;
         }
         break;
    case bcmStatGroupModeTypedAllWithControl:
         /* ***************************************************************** */
         /* A dedicated counter for control, unknown unicast, known unicast,  */
         /* multicast, broadcast and one for all traffic (not already counted)*/
         /* 1) CONTROL_PKT|BPDU_PKT                                           */
         /* 2) UNKNOWN_L3UC_PKT                                               */
         /* 3) L2UC_PKT | KNOWN_L3UC_PKT                                      */
         /* 4) KNOWN_L2MC_PKT|UNKNOWN_L2MC_PKT                                */
         /* 5) L2BC_PKT                                                       */
         /* 6) UNKNOWN_PKT|L2DLF_PKT|UNKNOWN_IPMC_PKT|KNOWN_IPMC_PKT          */
         /*    KNOWN_MPLS_PKT | KNOWN_MPLS_L3_PKT|KNOWN_MPLS_L2_PKT|          */
         /*    UNKNOWN_MPLS_PKT|KNOWN_MIM_PKT|UNKNOWN_MIM_PKT|                */
         /*    KNOWN_MPLS_MULTICAST_PKT                                       */
         /* ***************************************************************** */
         if (attr->direction == bcmStatFlexDirectionIngress) {
             total_counters=6;
             _bcm_esw_fillup_ing_uncmp_attr(
                 ing_attr,
                 BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_PKT_RESOLUTION_ATTR_BITS,
                 6);
             _bcm_esw_fillup_ing_pkt_res_offset_table(
                 ing_attr,
                 sizeof(ing_TypedAllWithControl_res)/
                 sizeof(ing_TypedAllWithControl_res[0]),
                 &ing_TypedAllWithControl_res[0]);
         } else {
             /* Group mode is overrided so  control shouldn't hit this part */
             LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                       (BSL_META_U(unit,
                                   "bcmStatGroupModeTypedAllWithControl"
                                    " is not supported in egress side\n")));
             sal_free(attr);
             return BCM_E_INTERNAL;
         }
         break;
    case bcmStatGroupModeTypedIntPriWithControl:
         /* *************************************************************** */
         /* A dedicated counter for control, unknown unicast, known unicast */
         /* , multicast, broadcast and N internal priority counters for     */
         /* traffic (not already counted)                                   */
         /* 1) CONTROL_PKT|BPDU_PKT                                         */
         /* 2) UNKNOWN_L3UC_PKT                                             */
         /* 3) L2UC_PKT | KNOWN_L3UC_PKT                                    */
         /* 4) KNOWN_L2MC_PKT|UNKNOWN_L2MC_PKT                              */
         /* 5) L2BC_PKT                                                     */
         /* 6..21) INT_PRI bits: 4bits                                      */
         /* *************************************************************** */
         if (attr->direction == bcmStatFlexDirectionEgress) {
             LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                       (BSL_META_U(unit,
                                   "GroupModeTypedIntPriWithControl is not available in "
                                    "egress side\n")));
             sal_free(attr);
             return BCM_E_INTERNAL;
         }

        if (SOC_IS_TOMAHAWK3(unit)) {
            LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                      (BSL_META_U(unit,
                                  "GroupModeTypedIntPriWithControl IsNotAvailable"
                                   "for %s\n"), SOC_UNIT_NAME(unit)));
            sal_free(attr);
            return BCM_E_UNAVAIL;
        }

         /* Although 21 counters but pkt_res(6) + int_pri(4)=10 bits
            so cannot use UNCOMPRESSED MODE */

         /* INT_PRI */ /* .... */ /* PacketRes */ 
         /* 34-31:4 */ /* .... */ /* 8-3:6     */
         /* PRI_CNG_FN=Cng(2x):IFP(2x):IntPri( all 4bits are used). 
             RightMost so no shifting required */
         /* PKT_RES_FN=Pkt(6bits  but 2 is used):SVP(1x):Drop(1x).
            LeftMost so 2 Left shifting required */

         total_counters=21;
         ing_attr->packet_attr_type=bcmStatFlexPacketAttrTypeCompressed;

         ing_cmprsd_pkt_attr_bits->pkt_resolution = 3;
         ing_cmprsd_pkt_attr_bits->pkt_resolution_pos = ing_pkt_attr_cmprsd_bits_g[unit].
                                                        pkt_resolution_pos;
         ing_cmprsd_pkt_attr_bits->pkt_resolution_mask = (1<<3)-1;
         ing_cmprsd_pkt_attr_bits->int_pri = ing_pkt_attr_cmprsd_bits_g[unit].int_pri;
         ing_cmprsd_pkt_attr_bits->int_pri_pos = ing_pkt_attr_cmprsd_bits_g[unit].
                                                 int_pri_pos;
         ing_cmprsd_pkt_attr_bits->int_pri_mask = ing_pkt_attr_cmprsd_bits_g[unit].int_pri_mask;
         ing_cmprsd_attr_selectors->total_counters = 21;
            
         /* Reset pkt_resolution map */
         for (map_index=0; map_index < 256 ;map_index++) {
              ing_cmprsd_attr_selectors->pkt_res_attr_map[map_index]=0;
         }       
         /* set pkt_resolution map for  1 counters */
         /* set pkt_resolution map for  1 counters */
         /* Map[Encoded Packet value << 2=>[SVP-1bit + DROP-1bit]=
            CounterIndex << 2=>[SVP-1bit + DROP-1bit]=4(Start),8,12*/

         shift_by_bits= ing_pkt_attr_cmprsd_bits_g[unit].svp_type + ing_pkt_attr_cmprsd_bits_g[unit].drop;
         shift_by_bits_for_value = shift_by_bits;

         for (ignore_index=0; 
              ignore_index < (1<<shift_by_bits) ; ignore_index++) {
              ing_cmprsd_attr_selectors->
                 pkt_res_attr_map[
                 (control_pkt<<shift_by_bits) | ignore_index]=
                 (1<<shift_by_bits_for_value);
              ing_cmprsd_attr_selectors->
                 pkt_res_attr_map[
                 (bpdu_pkt<<shift_by_bits) | ignore_index]=
                 (1<<shift_by_bits_for_value);
              ing_cmprsd_attr_selectors->
                 pkt_res_attr_map[
                 (unknown_l3uc_pkt<<shift_by_bits) | ignore_index]=
                 (2<<shift_by_bits_for_value);
              ing_cmprsd_attr_selectors->
                 pkt_res_attr_map[
                 (l2uc_pkt<<shift_by_bits) | ignore_index]=
                 (3<<shift_by_bits_for_value);
              ing_cmprsd_attr_selectors->
                 pkt_res_attr_map[
                 (known_l3uc_pkt<<shift_by_bits) | ignore_index]=
                 (3<<shift_by_bits_for_value);
              ing_cmprsd_attr_selectors->
                 pkt_res_attr_map[
                 (known_l2mc_pkt<<shift_by_bits) | ignore_index]=
                 (4<<shift_by_bits_for_value);
              ing_cmprsd_attr_selectors->
                 pkt_res_attr_map[
                 (unknown_l2mc_pkt<<shift_by_bits) | ignore_index]=
                 (4<<shift_by_bits_for_value);
              ing_cmprsd_attr_selectors->
                 pkt_res_attr_map[
                 (l2bc_pkt<<shift_by_bits) | ignore_index]=
                 (5<<shift_by_bits_for_value);
         }
         /* Reset pri_cng map */
         for (map_index=0; map_index < 256 ;map_index++) {
              ing_cmprsd_attr_selectors->pri_cnf_attr_map[map_index]=0;
         }       
         /* set pri_cng map for  16 counters */
         for (ignore_index=0; ignore_index < (1<<4) ; ignore_index++) {
              for (map_index=0; map_index < 16 ;map_index++) {
                   ing_cmprsd_attr_selectors->
                      pri_cnf_attr_map[(ignore_index<<4) | map_index]=map_index;
              }       
         }
                 
         /* Reset all Offset table fields */
         for (counter_index=0;counter_index<256;counter_index++) {
              ing_cmprsd_attr_selectors->
                        offset_table_map[counter_index].offset=0;
              ing_cmprsd_attr_selectors->
                        offset_table_map[counter_index].count_enable=0;
         }
         /* **************************************************************** */
         /* Set unicast, known unicast, multicast, broadcast counter indexes */
         /* considering INT_PRI bits 0                                       */
         /* **************************************************************** */
         ing_cmprsd_attr_selectors->offset_table_map[1].offset=0;
         ing_cmprsd_attr_selectors->offset_table_map[1].count_enable=1;
         ing_cmprsd_attr_selectors->offset_table_map[2].offset=1;
         ing_cmprsd_attr_selectors->offset_table_map[2].count_enable=1;
         ing_cmprsd_attr_selectors->offset_table_map[3].offset=2;
         ing_cmprsd_attr_selectors->offset_table_map[3].count_enable=1;
         ing_cmprsd_attr_selectors->offset_table_map[4].offset=3;
         ing_cmprsd_attr_selectors->offset_table_map[4].count_enable=1;
         ing_cmprsd_attr_selectors->offset_table_map[5].offset=4;
         ing_cmprsd_attr_selectors->offset_table_map[5].count_enable=1;

         /* Set IntPri counter indexes not-considering pkt resolution bits*/
         /* Priority 0 Counter not satisfying any condition  */
         ing_cmprsd_attr_selectors->offset_table_map[0].offset=5;
         ing_cmprsd_attr_selectors->offset_table_map[0].count_enable=1;
         ing_cmprsd_attr_selectors->offset_table_map[6].offset=5;
         ing_cmprsd_attr_selectors->offset_table_map[6].count_enable=1;
         ing_cmprsd_attr_selectors->offset_table_map[7].offset=5;
         ing_cmprsd_attr_selectors->offset_table_map[7].count_enable=1;

         /*INT_PRI*/
         for (counter_index=1;counter_index<(1<<4);counter_index++) {
              /*PktRes*/
              for (ignore_index=0;ignore_index<(1<<3);ignore_index++) {
                   ing_cmprsd_attr_selectors->
                       offset_table_map[(counter_index<<3)|ignore_index].
                       offset=(counter_index+5);
                   ing_cmprsd_attr_selectors->
                       offset_table_map[(counter_index<<3)|ignore_index].
                       count_enable=1;
              }
         }
         break;
    case bcmStatGroupModeDot1P:
         /* ******************************************************** */
         /* A set of 8(2^3) counters selected based on Vlan priority */
         /* outer_dot1p; 3 bits 1..8                                 */
         /* ******************************************************** */

         if (attr->direction==bcmStatFlexDirectionIngress) {
             total_counters=8;
             _bcm_esw_fillup_ing_uncmp_attr(
                 ing_attr,
                 BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_OUTER_DOT1P_ATTR_BITS,
                 8);
             /* Set Offset table fields */
             for (counter_index=0;counter_index<8;counter_index++) {
                  ing_attr->uncmprsd_attr_selectors.
                   offset_table_map[counter_index].offset=counter_index;
                  ing_attr->uncmprsd_attr_selectors.
                   offset_table_map[counter_index].count_enable=1;
             }
         } else {
             total_counters=8;
             _bcm_esw_fillup_egr_uncmp_attr(
                 egr_attr,
                 BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_OUTER_DOT1P_ATTR_BITS,
                 8);
             /* Set Offset table fields */
             for (counter_index=0;counter_index<8;counter_index++) {
                  egr_attr->uncmprsd_attr_selectors.
                   offset_table_map[counter_index].offset=counter_index;
                  egr_attr->uncmprsd_attr_selectors.
                   offset_table_map[counter_index].count_enable=1;
             }
         }
         break;
    case bcmStatGroupModeIntPri:
         /* **************************************************** */
         /* A set of 16(2^4) counters based on internal priority */
         /* 1..16 INT_PRI bits: 4bits                            */
         /* **************************************************** */

         if (attr->direction==bcmStatFlexDirectionIngress) {
             total_counters=16;
             _bcm_esw_fillup_ing_uncmp_attr(
                 ing_attr,
                 BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_INT_PRI_ATTR_BITS,
                 16);
             /* Set Offset table fields */
             for (counter_index=0;counter_index<16;counter_index++) {
                  ing_attr->uncmprsd_attr_selectors.
                          offset_table_map[counter_index].offset=counter_index;
                  ing_attr->uncmprsd_attr_selectors.
                          offset_table_map[counter_index].count_enable=1;
             }
         } else {
             total_counters=16;
             _bcm_esw_fillup_egr_uncmp_attr(
                 egr_attr,
                 BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_INT_PRI_ATTR_BITS,
                 16);
             /* Set Offset table fields */
             for (counter_index=0;counter_index<16;counter_index++) {
                  egr_attr->uncmprsd_attr_selectors.
                          offset_table_map[counter_index].offset=counter_index;
                  egr_attr->uncmprsd_attr_selectors.
                          offset_table_map[counter_index].count_enable=1;
             }
         }
         break;
    case bcmStatGroupModeIntPriCng:
         /* ********************************************************** */
         /* set of 64 counters(2^(4+2)) based on Internal priority+CNG */
         /* 1..64 (INT_PRI bits: 4bits + CNG 2 bits                    */
         /* 1..64 (INT_PRI bits: 4bits + CNG 2 bits                    */
         /* ********************************************************** */
         if (attr->direction==bcmStatFlexDirectionIngress) {
             total_counters=64;
             _bcm_esw_fillup_ing_uncmp_attr(
                 ing_attr,
                 BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_CNG_ATTR_BITS|
                 BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_INT_PRI_ATTR_BITS,
                 64);
             /* Set Offset table fields */
             counter_index=0;
             for (outer_index=0;outer_index<4;outer_index++) {/*CNG*/
                  for (inner_index=0;inner_index<16;inner_index++) {/*IntPri*/
                       ing_attr->uncmprsd_attr_selectors.
                          offset_table_map[counter_index].count_enable=1;
                       ing_attr->uncmprsd_attr_selectors.
                       offset_table_map[(outer_index<<4)|inner_index].
                       offset=counter_index++;
                  }
             }
         } else {
             total_counters=64;
             _bcm_esw_fillup_egr_uncmp_attr(
                 egr_attr,
                 BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_CNG_ATTR_BITS|
                 BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_INT_PRI_ATTR_BITS,
                 64);
             /* Set Offset table fields */
             counter_index=0;
             for (outer_index=0;outer_index<4;outer_index++) {/*CNG*/
                  for(inner_index=0;inner_index<16;inner_index++) {/*IntPri*/
                      egr_attr->uncmprsd_attr_selectors.
                         offset_table_map[counter_index].count_enable=1;
                      egr_attr->uncmprsd_attr_selectors.
                         offset_table_map[(outer_index<<4)|inner_index].
                         offset=counter_index++;
                  }
             }
         }
         break;
    case bcmStatGroupModeSvpType:
         /* ****************************************** */
         /* A set of 2 counters(2^1) based on SVP type */
         /* 1..2 (SVP 1 bit)                           */
         /* ****************************************** */

         if (attr->direction==bcmStatFlexDirectionIngress) {
             total_counters=2;
             _bcm_esw_fillup_ing_uncmp_attr(
                 ing_attr,
                 BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_SVP_TYPE_ATTR_BITS,
                 2);
             /* Set Offset table fields */
             /* DropBitShifting=1 is required */
             for (counter_index=0;counter_index<2;counter_index++) {
                  ing_attr->uncmprsd_attr_selectors.
                        offset_table_map[counter_index].offset=counter_index;
                  ing_attr->uncmprsd_attr_selectors.
                        offset_table_map[counter_index].count_enable=1;
             }
         } else {
             total_counters=2;
             _bcm_esw_fillup_egr_uncmp_attr(
                 egr_attr,
                 BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_SVP_TYPE_ATTR_BITS,
                 2);
             /* Set Offset table fields */
             /* DropBitShifting=1 + DvpBitShifting=1 ==> 2 is required */
             for (counter_index=0;counter_index<2;counter_index++) {
                  egr_attr->uncmprsd_attr_selectors.
                        offset_table_map[counter_index<<2].offset=counter_index;
                  egr_attr->uncmprsd_attr_selectors.
                        offset_table_map[counter_index<<2].count_enable=1;
             }
         }
         break;
    case bcmStatGroupModeDscp:
         /* ******************************************** */
         /* A set of 64 counters(2^6) based on DSCP bits */
         /* 1..64 (6 bits from TOS 8 bits)               */
         /* ******************************************** */

         if (attr->direction==bcmStatFlexDirectionIngress) {
             total_counters=64;
             _bcm_esw_fillup_ing_uncmp_attr(
                 ing_attr,
                 BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_TOS_DSCP_ATTR_BITS,
                 64);
             /* Set Offset table fields */
             for (counter_index=0;counter_index<64;counter_index++) {
                  ing_attr->uncmprsd_attr_selectors.
                        offset_table_map[counter_index].offset=counter_index;
                  ing_attr->uncmprsd_attr_selectors.
                        offset_table_map[counter_index].count_enable=1;
             }
         } else {
             total_counters=64;
             _bcm_esw_fillup_egr_uncmp_attr(
                 egr_attr,
                 BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_TOS_DSCP_ATTR_BITS,
                 64);
             /* Set Offset table fields */
             for (counter_index = 0; counter_index < 64; counter_index++) {
                  egr_attr->uncmprsd_attr_selectors.
                        offset_table_map[counter_index].offset=counter_index;
                  egr_attr->uncmprsd_attr_selectors.
                        offset_table_map[counter_index].count_enable=1;
             }
         }
         break;
    case bcmStatGroupModeDvpType:
         /* ******************************************** */
         /* EGRESS SIDE ONLY:                            */
         /* A set of 2 counters(2^1) based on DVP type   */
         /* 1..2 (DVP 1 bits)                            */
         /* ******************************************** */

         if (attr->direction==bcmStatFlexDirectionIngress) {
             LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                       (BSL_META_U(unit,
                                   "bcm_stat_group_mode_t %d is NotSupported"
                                    " in IngressSide\n"), group_mode));
             sal_free(attr);
             return BCM_E_PARAM;
         } else {
             total_counters=2;
             _bcm_esw_fillup_egr_uncmp_attr(
                 egr_attr,
                 BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_DVP_TYPE_ATTR_BITS,
                 2);
             /* Set Offset table fields */
             for (counter_index=0;counter_index<2;counter_index++) {
                  egr_attr->uncmprsd_attr_selectors.
                        offset_table_map[counter_index].offset=counter_index;
                  egr_attr->uncmprsd_attr_selectors.
                        offset_table_map[counter_index].count_enable=1;
             }
         }
         break;
    case bcmStatGroupModeCng:
         if (attr->direction==bcmStatFlexDirectionIngress) {
             total_counters=4;
             _bcm_esw_fillup_ing_uncmp_attr(
                 ing_attr,
                 BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_CNG_ATTR_BITS,
                 4);
             /* Set Offset table fields */
             for (counter_index=0;counter_index<4;counter_index++) {
                  ing_attr->uncmprsd_attr_selectors.
                        offset_table_map[counter_index].offset=counter_index;
                  ing_attr->uncmprsd_attr_selectors.
                        offset_table_map[counter_index].count_enable=1;
             }
         } else {
             total_counters=4;
             _bcm_esw_fillup_egr_uncmp_attr(
                 egr_attr,
                 BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_CNG_ATTR_BITS,
                 4);
             /* Set Offset table fields */
             for (counter_index=0;counter_index<4;counter_index++) {
                  egr_attr->uncmprsd_attr_selectors.
                        offset_table_map[counter_index].offset=counter_index;
                  egr_attr->uncmprsd_attr_selectors.
                        offset_table_map[counter_index].count_enable=1;
             }
         }
         break;
    default:
         return BCM_E_PARAM;
    }
    *num_counters = total_counters;
    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_esw_stat_group_create
 * Description:
 *      Reserve HW counter resources as per given group mode and acounting 
 *      object and make system ready for further stat collection action 
 *      
 * Parameters:
 *    Unit            (IN)  Unit number
 *    object          (IN)  Accounting Object
 *    Group_mode      (IN)  Group Mode
 *    Stat_counter_id (OUT) Stat Counter Id
 *    num_entries     (OUT) Number of Counter entries created 
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 */
bcm_error_t _bcm_esw_stat_group_create (
            int	                  unit,
            bcm_stat_object_t     object,
            bcm_stat_group_mode_t group_mode,
            uint32                *stat_counter_id,
            uint32                *num_entries)
{
    bcm_stat_flex_attr_t     *attr=NULL;
    bcm_stat_flex_mode_t     mode=0;
    bcm_error_t              rv=BCM_E_NONE;
    bcm_stat_flex_ing_attr_t *ing_attr=NULL;
    bcm_stat_flex_egr_attr_t *egr_attr=NULL;
    uint32                   map_index=0;
    uint32                   ignore_index=0;
    uint32                   counter_index=0;
    uint32                   outer_index=0;
    uint32                   inner_index=0;
    uint32                   base_index=0;
    uint32                   pool_number=0;
    uint16                   total_counters=0;
    uint32                   l2dlf_pkt=0;
    uint32                   unknown_l3uc_pkt=0;
    uint32                   unknown_l2mc_pkt=0;
    uint32                   known_l3uc_pkt=0;
    uint32                   known_l2mc_pkt=0;
    uint32                   l2uc_pkt=0;
    uint32                   l2bc_pkt=0;
    uint32                   control_pkt=0;
    uint32                   bpdu_pkt=0;
    uint32                   shift_by_bits=0;
    uint32                   shift_by_bits_for_value=0;

    bcm_stat_flex_ing_cmprsd_attr_selectors_t *ing_cmprsd_attr_selectors=NULL;
    bcm_stat_flex_ing_pkt_attr_bits_t         *ing_cmprsd_pkt_attr_bits=NULL;

    bcm_stat_flex_egr_cmprsd_attr_selectors_t *egr_cmprsd_attr_selectors=NULL;
    bcm_stat_flex_egr_pkt_attr_bits_t         *egr_cmprsd_pkt_attr_bits=NULL;
    bcm_stat_flex_direction_t                 direction;


    if (!soc_feature(unit,soc_feature_advanced_flex_counter)) {
         return BCM_E_UNAVAIL;
    }

    BCM_IF_ERROR_RETURN(_bcm_esw_stat_validate_object(unit,object,&direction));
    BCM_IF_ERROR_RETURN(_bcm_esw_stat_validate_group(unit,group_mode));

    /* Parameters look OK. ... */
  
    l2dlf_pkt        = _bcm_esw_stat_flex_get_pkt_res_value(unit,_L2DLF_PKT);
    unknown_l3uc_pkt = _bcm_esw_stat_flex_get_pkt_res_value(unit,
                                                            _UNKNOWN_L3UC_PKT);
    unknown_l2mc_pkt =  _bcm_esw_stat_flex_get_pkt_res_value(unit,
                                                             _UNKNOWN_L2MC_PKT);
    known_l3uc_pkt   = _bcm_esw_stat_flex_get_pkt_res_value(unit,
                                                            _KNOWN_L3UC_PKT);
    known_l2mc_pkt   = _bcm_esw_stat_flex_get_pkt_res_value(unit,
                                                            _KNOWN_L2MC_PKT);
    l2uc_pkt         = _bcm_esw_stat_flex_get_pkt_res_value(unit,_L2UC_PKT);
    l2bc_pkt         = _bcm_esw_stat_flex_get_pkt_res_value(unit,_L2BC_PKT);
    control_pkt      = _bcm_esw_stat_flex_get_pkt_res_value(unit,_CONTROL_PKT);
    bpdu_pkt         = _bcm_esw_stat_flex_get_pkt_res_value(unit,_BPDU_PKT);

    /* 1. Allocating attribute Memory .... */

    attr = sal_alloc(sizeof(bcm_stat_flex_attr_t),"attr");
    if (attr == NULL) {
        LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                  (BSL_META_U(unit,
                              "Failed to allocate memory for bcm_stat_flex_attr_t ")));
        return BCM_E_MEMORY;
    }
    sal_memset(attr,0,sizeof(bcm_stat_flex_attr_t));

    /* 2. Deciding direction */
    if (direction == bcmStatFlexDirectionIngress) {
        /* INGRESS SIDE */
        attr->direction=bcmStatFlexDirectionIngress;
        ing_attr = &(attr->ing_attr);
        ing_cmprsd_attr_selectors=&(ing_attr->cmprsd_attr_selectors);
        ing_cmprsd_pkt_attr_bits= &(ing_attr->cmprsd_attr_selectors.
                                    pkt_attr_bits);
    } else {
        /* EGRESS SIDE */
        attr->direction=bcmStatFlexDirectionEgress;
        egr_attr = &(attr->egr_attr);
        egr_cmprsd_attr_selectors=&(egr_attr->cmprsd_attr_selectors);
        egr_cmprsd_pkt_attr_bits= &(egr_attr->cmprsd_attr_selectors.
                                    pkt_attr_bits);
    } 

    if (attr->direction == bcmStatFlexDirectionEgress) {
        switch(group_mode) {
        case bcmStatGroupModeDlfAll:
        case bcmStatGroupModeSingleWithControl:
             LOG_DEBUG(BSL_LS_BCM_FLEXCTR,
                       (BSL_META_U(unit,
                                   "Overiding group_mode->bcmStatGroupModeSingle\n")));
             group_mode = bcmStatGroupModeSingle;
             break;
        case bcmStatGroupModeTyped:
        case bcmStatGroupModeTypedAll:
        case bcmStatGroupModeTrafficTypeWithControl:
        case bcmStatGroupModeDlfAllWithControl:
        case bcmStatGroupModeTypedWithControl:
        case bcmStatGroupModeTypedAllWithControl: 
             LOG_DEBUG(BSL_LS_BCM_FLEXCTR,
                       (BSL_META_U(unit,
                                   "Overiding group_mode to "
                                    "bcmStatGroupModeTrafficType \n")));
             group_mode = bcmStatGroupModeTrafficType;
             break;
        case bcmStatGroupModeDlfIntPri: 
        case bcmStatGroupModeDlfIntPriWithControl: 
        case bcmStatGroupModeTypedIntPriWithControl:
             LOG_DEBUG(BSL_LS_BCM_FLEXCTR,
                       (BSL_META_U(unit,
                                   "Overiding group_mode to "
                                    "bcmStatGroupModeTypedIntPri \n")));
             group_mode = bcmStatGroupModeTypedIntPri;
             break;
        default:
            break;
        }
    }
    /* ######################################################### */
    /* Ingress Packet Attributes(KATANA)  */
    /*
    CNG            IFP_CNG INT_PRI VlanFmt OuterDot1P InnerDot1P IngressPort   TOS       PacketRes SVPType DROP  IP
    38-37:2        36-35:2 34-31:4 30-29:2 28-26:3    25-23:3    22-17:6       16-9:8    8-3:6     2-2:1   1-1:1 0-0:1
    PRI_CNG_FN(8)                  PKT_PRI_FN(8)                 PORT_FN_FN(6) TOS_FN(8) PKT_RES_FN(8)           NOT_USED
     */
    /* ######################################################### */

    /* ######################################################### */
    /* Egress Packet Attributes(KATANA)  */
    /*
    CNG            INT_PRI         VlanFmt OuterDot1P InnerDot1P EgressPort    TOS       PacketRes SVPType DVPType DROP  IP
    32-31:2        30-27:4         26-25:2 24-22:3    21-19:3    18-13:6       12-5:8    4-4:1     3-3:1   2-2:1   1-1:1 0-0:1
    PRI_CNG_FN(6)                  PKT_PRI_FN(8)                 PORT_FN_FN(6) TOS_FN(8) PKT_RES_FN(4)                   NOT_USED
     */
    /* ######################################################### */


    /* 3. Filling up attributes */
    switch(group_mode) {
    case bcmStatGroupModeSingle:
         /* *********************************************/
         /* A single counter used for all traffic types */
         /* 1) UNKNOWN_PKT|CONTROL_PKT|BPDU_PKT|L2BC_PKT|L2UC_PKT|L2DLF_PKT| */
         /*    UNKNOWN_IPMC_PKT|KNOWN_IPMC_PKT|KNOWN_L2MC_PKT|               */
         /*    UNKNOWN_L2MC_PKT|UNKNOWN_L2MC_PKT|KNOWN_L3UC_PKT|             */
         /*    UNKNOWN_L3UC_PKT|KNOWN_MPLS_PKT|KNOWN_MPLS_L3_PKT|            */
         /*    KNOWN_MPLS_L2_PKT|UNKNOWN_MPLS_PKT|KNOWN_MIM_PKT|             */
         /*    UNKNOWN_MIM_PKT|KNOWN_MPLS_MULTICAST_PKT                      */

         /* ******************************************* */
         if (attr->direction==bcmStatFlexDirectionIngress) {
             total_counters=1;
             _bcm_esw_fillup_ing_uncmp_attr(
                 ing_attr,
                 BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_PKT_RESOLUTION_ATTR_BITS,
                 1);
             _bcm_esw_fillup_ing_pkt_res_offset_table(
                 ing_attr,sizeof(ing_Single_res)/sizeof(ing_Single_res[0]),
                 &ing_Single_res[0]);
         } else {
             total_counters=1;
             _bcm_esw_fillup_egr_uncmp_attr(
                 egr_attr,
                 BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_PKT_RESOLUTION_ATTR_BITS,
                 1);
             _bcm_esw_fillup_egr_pkt_res_offset_table(
                 egr_attr,sizeof(egr_Single_res)/sizeof(egr_Single_res[0]),
                 &egr_Single_res[0]);
         }
         break;
    case bcmStatGroupModeTrafficType:
         /* **************************************************************** */
         /* A dedicated counter per traffic type Unicast,multicast,broadcast */
         /* 1) L2UC_PKT | KNOWN_L3UC_PKT | UNKNOWN_L3UC_PKT                  */
         /* 2) KNOWN_L2MC_PKT|UNKNOWN_L2MC_PKT|                              */
         /* 3) L2BC_PKT|                                                     */
         /* **************************************************************** */

         if (attr->direction==bcmStatFlexDirectionIngress) {
             total_counters=3;
             _bcm_esw_fillup_ing_uncmp_attr(
                 ing_attr,
                 BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_PKT_RESOLUTION_ATTR_BITS,
                 3);
             _bcm_esw_fillup_ing_pkt_res_offset_table(
                 ing_attr,
                 sizeof(ing_TrafficType_res)/sizeof(ing_TrafficType_res[0]),
                 &ing_TrafficType_res[0]);
         } else {
             total_counters=2;
             _bcm_esw_fillup_egr_uncmp_attr(
                 egr_attr,
                 BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_PKT_RESOLUTION_ATTR_BITS,
                 2);
             _bcm_esw_fillup_egr_pkt_res_offset_table(
                 egr_attr,
                 sizeof(egr_TrafficType_res)/sizeof(egr_TrafficType_res[0]),
                 &egr_TrafficType_res[0]);
         }
         break;
    case bcmStatGroupModeDlfAll:
         /* ************************************************************* */
         /* A pair of counters where the base counter is used for dlf and */ 
         /* the other counter is used for all traffic types               */
         /* 1) L2DLF_PKT                                                  */
         /* 2) UNKNOWN_PKT | CONTROL_PKT|BPDU_PKT|L2BC_PKT|L2UC_PKT|      */
         /*    L2DLF_PKT|UNKNOWN_IPMC_PKT|KNOWN_IPMC_PKT|KNOWN_L2MC_PKT|  */
         /*    UNKNOWN_L2MC_PKT|UNKNOWN_L2MC_PKT|KNOWN_L3UC_PKT|          */
         /*    UNKNOWN_L3UC_PKT|KNOWN_MPLS_PKT|KNOWN_MPLS_L3_PKT|         */
         /*    KNOWN_MPLS_L2_PKT|UNKNOWN_MPLS_PKT|KNOWN_MIM_PKT|          */
         /*    UNKNOWN_MIM_PKT|KNOWN_MPLS_MULTICAST_PKT                   */
         /* ************************************************************* */

         if (attr->direction==bcmStatFlexDirectionIngress) {
             total_counters=2;
             _bcm_esw_fillup_ing_uncmp_attr(
                 ing_attr,
                 BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_PKT_RESOLUTION_ATTR_BITS,
                 2);
             _bcm_esw_fillup_ing_pkt_res_offset_table(
                 ing_attr,sizeof(ing_DlfAll_res)/sizeof(ing_DlfAll_res[0]),
                 &ing_DlfAll_res[0]);
         } else {
             /* Group mode is overrided so  control shouldn't hit this part */
             LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                       (BSL_META_U(unit,
                                   "bcmStatGroupModeDlfAll is not supported"
                                    "in egress side\n")));
             sal_free(attr);
             return BCM_E_INTERNAL;
         }
         break;
    case bcmStatGroupModeDlfIntPri:
         /* ************************************************************** */
         /* N+1 counters where the base counter is used for dlf and next N */
         /* are used per Cos                                               */
         /* 1) L2_DLF                                                      */
         /* 2..17) INT_PRI bits: 4bits                                     */
         /* ************************************************************** */

         if (attr->direction==bcmStatFlexDirectionEgress) {
             /* Must not hit */
             LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                       (BSL_META_U(unit,
                                   "bcmStatGroupModeDlfIntPri IsNotAvailable"
                                    "in EgressSide\n")));
             sal_free(attr);
             return BCM_E_INTERNAL;
         }

        if (SOC_IS_TOMAHAWK3(unit)) {
            LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                      (BSL_META_U(unit,
                                  "bcmStatGroupModeDlfIntPri IsNotAvailable"
                                   "for %s\n"), SOC_UNIT_NAME(unit)));
            sal_free(attr);
            return BCM_E_UNAVAIL;
        }

         /* Although 17 counters but pkt_res(6) + int_pri(4)=10 bits
            so cannot use UNCOMPRESSED MODE */

         /* INT_PRI */ /* .... */ /* PacketRes */ 
         /* 34-31:4 */ /* .... */ /* 8-3:6     */
         /* PRI_CNG_FN=Cng(2x):IFP(2x):IntPri( all 4bits are used). 
            RightMost so no shifting required */
         /* PKT_RES_FN=Pkt(6bits  but 1 is used):SVP(1x):Drop(1x).
            LeftMost so 2 Left shifting required */

         total_counters=17;
         ing_attr->packet_attr_type=bcmStatFlexPacketAttrTypeCompressed;

         ing_cmprsd_pkt_attr_bits->pkt_resolution = 1;
         
         ing_cmprsd_pkt_attr_bits->pkt_resolution_pos = ing_pkt_attr_cmprsd_bits_g[unit].
                                                        pkt_resolution_pos;
         ing_cmprsd_pkt_attr_bits->pkt_resolution_mask = 1;

         ing_cmprsd_pkt_attr_bits->int_pri = ing_pkt_attr_cmprsd_bits_g[unit].int_pri;
         ing_cmprsd_pkt_attr_bits->int_pri_pos = ing_pkt_attr_cmprsd_bits_g[unit].
                                                 int_pri_pos;
         ing_cmprsd_pkt_attr_bits->int_pri_mask = ing_pkt_attr_cmprsd_bits_g[unit].
                                                 int_pri_mask;

         ing_cmprsd_attr_selectors->total_counters = 17;

         /* set pkt_resolution map for  1 counters */
         /* Map[Encoded Packet value << 2=>[SVP-1bit + DROP-1bit]=
                CounterIndex << 2=>[SVP-1bit + DROP-1bit]=4(Start),8,12*/

         /* Reset pkt_resolution map */
         for (map_index=0; 
              map_index < sizeof(bcm_stat_flex_ing_cmprsd_pkt_res_attr_map_t) ;
              map_index++) {
              ing_cmprsd_attr_selectors->pkt_res_attr_map[map_index]=0;
         }
         shift_by_bits= ing_pkt_attr_cmprsd_bits_g[unit].svp_type + ing_pkt_attr_cmprsd_bits_g[unit].drop;
         shift_by_bits_for_value = shift_by_bits;

         for (ignore_index=0; 
              ignore_index < (1<<shift_by_bits); ignore_index++) {
              ing_cmprsd_attr_selectors->
                  pkt_res_attr_map[(l2dlf_pkt<<shift_by_bits) | ignore_index]=
                  (1<<(shift_by_bits_for_value));
         }

         /* Reset pri_cng map */
         for (map_index=0; map_index < 256 ;map_index++) {
              ing_cmprsd_attr_selectors->pri_cnf_attr_map[map_index]=0;
         }
         /* set pri_cng map for  16 counters */
         for (ignore_index=0; ignore_index < (1<<4) ; ignore_index++) {
              for (map_index=0; map_index < 16 ;map_index++) {
                   ing_cmprsd_attr_selectors->
                   pri_cnf_attr_map[(ignore_index<<4) | map_index]=map_index;
              }
         }

         /* Reset all Offset table fields */
         for (counter_index=0;counter_index<256;counter_index++) {
              ing_cmprsd_attr_selectors->
                        offset_table_map[counter_index].offset=0;
              ing_cmprsd_attr_selectors->
                        offset_table_map[counter_index].count_enable=0;
         }

         /* Set DLF counter indexes(ODD 1,3,5) considering INT_PRI bits 
            don't care */
         for (counter_index=0;counter_index<16;counter_index++) {
              ing_cmprsd_attr_selectors->
                        offset_table_map[(counter_index<<1)|1].offset=0;
              ing_cmprsd_attr_selectors->
                        offset_table_map[(counter_index<<1)|1].count_enable=1;
         }

         /* Set Int pri counter indexes(Even 2,4,6) considering DLF=0 */
         for (counter_index=0;counter_index<16;counter_index++) {
              ing_cmprsd_attr_selectors->
                        offset_table_map[(counter_index<<1)].
                        offset=(counter_index+1);
              ing_cmprsd_attr_selectors->
                        offset_table_map[(counter_index<<1)].count_enable=1;
         }
         break;
    case bcmStatGroupModeTyped:
         /* ******************************************************* */
         /* A dedicated counter for unknown unicast, known unicast, */
         /* multicast, broadcast                                    */
         /* 1) UNKNOWN_L3UC_PKT|_L2DLF_PKT                                     */
         /* 2) L2UC_PKT | KNOWN_L3UC_PKT                            */
         /* 3) KNOWN_L2MC_PKT|UNKNOWN_L2MC_PKT                      */
         /* 4) L2BC_PKT                                             */
         /* ******************************************************* */
         if (attr->direction==bcmStatFlexDirectionIngress) {
             total_counters=4;
             _bcm_esw_fillup_ing_uncmp_attr(
                 ing_attr,
                 BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_PKT_RESOLUTION_ATTR_BITS,
                 4);
             _bcm_esw_fillup_ing_pkt_res_offset_table(
                 ing_attr,sizeof(ing_Typed_res)/sizeof(ing_Typed_res[0]),
                 &ing_Typed_res[0]);
         } else {
             /* Group mode is overrided so  control shouldn't hit this part */
             LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                       (BSL_META_U(unit,
                                   "bcmStatGroupModeTyped: is not supported"
                                    " in egress side\n")));
             sal_free(attr);
             return BCM_E_INTERNAL;
         }
         break;
    case bcmStatGroupModeTypedAll:
         /* ******************************************************* */
         /* A dedicated counter for unknown unicast, known unicast, */
         /* multicast, broadcast and one for all traffic(not already*/
         /* counted)                                                */
         /* 1) UNKNOWN_L3UC_PKT                                     */
         /* 2) L2UC_PKT | KNOWN_L3UC_PKT                            */
         /* 3) KNOWN_L2MC_PKT|UNKNOWN_L2MC_PKT                      */
         /* 4) L2BC_PKT                                             */
         /* 5) UNKNOWN_PKT|CONTROL_PKT|BPDU_PKT|L2DLF_PKT|          */
         /*    UNKNOWN_IPMC_PKT|KNOWN_IPMC_PKT|KNOWN_MPLS_PKT |     */
         /*    KNOWN_MPLS_L3_PKT|KNOWN_MPLS_L2_PKT|UNKNOWN_MPLS_PKT */
         /*    KNOWN_MIM_PKT|UNKNOWN_MIM_PKT|                       */
         /*    KNOWN_MPLS_MULTICAST_PKT                             */
         /* ******************************************************* */
         if (attr->direction==bcmStatFlexDirectionIngress) {
             total_counters=5;
             _bcm_esw_fillup_ing_uncmp_attr(
                 ing_attr,
                 BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_PKT_RESOLUTION_ATTR_BITS,
                 5);
             _bcm_esw_fillup_ing_pkt_res_offset_table(
                 ing_attr,sizeof(ing_TypedAll_res)/sizeof(ing_TypedAll_res[0]),
                 &ing_TypedAll_res[0]);
         } else {
             /* Group mode is overrided so  control shouldn't hit this part */
             LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                       (BSL_META_U(unit,
                                   "bcmStatGroupModeTypedAll is NotSupported"
                                    " in EgressSide\n")));
             sal_free(attr);
             return BCM_E_INTERNAL;
         }
         break;
    case bcmStatGroupModeTypedIntPri:
        if (SOC_IS_TOMAHAWK3(unit)) {
            LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                      (BSL_META_U(unit,
                                  "bcmStatGroupModeTypedIntPri IsNotAvailable"
                                   "for %s\n"), SOC_UNIT_NAME(unit)));
            sal_free(attr);
            return BCM_E_UNAVAIL;
        }
         /* *************************************************************** */
         /* A dedicated counter for unknown unicast, known unicast,         */
         /* multicast,broadcast and N internal priority counters for traffic*/
         /* (not already counted)                                           */
         /* 1) UNKNOWN_L3UC_PKT                                             */
         /* 2) L2UC_PKT | KNOWN_L3UC_PKT                                    */ 
         /* 3) KNOWN_L2MC_PKT|UNKNOWN_L2MC_PKT                              */
         /* 4) L2BC_PKT                                                     */
         /* 5..20) INT_PRI bits: 4bits                                      */
         /* *************************************************************** */
         if (attr->direction==bcmStatFlexDirectionIngress) {

             /* Although 20 counters but pkt_res(6) + int_pri(4)=10 bits
                so cannot use UNCOMPRESSED MODE */

             /* INT_PRI */ /* .... */ /* PacketRes */ 
             /* 34-31:4 */ /* .... */ /* 8-3:6     */
             /* PRI_CNG_FN=Cng(2x):IFP(2x):IntPri( all 4bits are used). 
                RightMost so no shifting required */
             /* PKT_RES_FN=Pkt(6bits  but 3 is used):SVP(1x):Drop(1x).
                LeftMost so 2 Left shifting required */

             total_counters=20;

             ing_attr->packet_attr_type=bcmStatFlexPacketAttrTypeCompressed;
             /* Cannot consider 0 value so taking 3 i.s.o. 2 */
             ing_cmprsd_pkt_attr_bits->pkt_resolution = 3;
             ing_cmprsd_pkt_attr_bits->pkt_resolution_pos = ing_pkt_attr_cmprsd_bits_g[unit].
                                                            pkt_resolution_pos;
             ing_cmprsd_pkt_attr_bits->pkt_resolution_mask = (1<<3)-1;

             ing_cmprsd_pkt_attr_bits->int_pri = ing_pkt_attr_cmprsd_bits_g[unit].int_pri;
             ing_cmprsd_pkt_attr_bits->int_pri_pos = ing_pkt_attr_cmprsd_bits_g[unit].
                                                     int_pri_pos;
             ing_cmprsd_pkt_attr_bits->int_pri_mask= ing_pkt_attr_cmprsd_bits_g[unit].
                                                     int_pri_mask;                                                    

             ing_cmprsd_attr_selectors->total_counters = 20;
             /* Reset pkt_resolution map */
             for (map_index=0; map_index < 256 ;map_index++) {
                  ing_cmprsd_attr_selectors->pkt_res_attr_map[map_index]=0;
             }       
             /* set pkt_resolution map for  1 counters */
             /* Map[Encoded Packet value << 2=>[SVP-1bit + DROP-1bit]=
                CounterIndex << 2=>[SVP-1bit + DROP-1bit]=4(Start),8,12*/
             shift_by_bits= ing_pkt_attr_cmprsd_bits_g[unit].svp_type + 
                            ing_pkt_attr_cmprsd_bits_g[unit].drop;
             shift_by_bits_for_value = shift_by_bits;

             /* set pkt_resolution map for  1 counters.Ignore SVP,DROP bits */
             for (ignore_index=0; 
                  ignore_index < (1<<shift_by_bits) ; ignore_index++) {
                  ing_cmprsd_attr_selectors->pkt_res_attr_map[
                      (unknown_l3uc_pkt<<shift_by_bits)|ignore_index]=
                      (1<<shift_by_bits_for_value);
                  ing_cmprsd_attr_selectors->pkt_res_attr_map[
                      (l2uc_pkt<<shift_by_bits)|ignore_index]=
                      (2<<shift_by_bits_for_value);
                  ing_cmprsd_attr_selectors->pkt_res_attr_map[
                      (known_l3uc_pkt<<shift_by_bits)|ignore_index]=
                      (2<<shift_by_bits_for_value);
                  ing_cmprsd_attr_selectors->pkt_res_attr_map[
                      (known_l2mc_pkt<<shift_by_bits)|ignore_index]=
                      (3<<shift_by_bits_for_value);
                  ing_cmprsd_attr_selectors->pkt_res_attr_map[
                      (unknown_l2mc_pkt<<shift_by_bits)|ignore_index]=
                      (3<<shift_by_bits_for_value);
                  ing_cmprsd_attr_selectors->pkt_res_attr_map[
                      (l2bc_pkt<<shift_by_bits)|ignore_index]=
                      (4<<shift_by_bits_for_value);
             }
             /* Reset pri_cng map */
             for (map_index=0; map_index < 256 ;map_index++) {
                  ing_cmprsd_attr_selectors->pri_cnf_attr_map[map_index]=0;
             }       
             /* set pri_cng map for  16 counters */
             for (ignore_index=0; ignore_index < (1<<4) ; ignore_index++) {
                  for (map_index=0; map_index < 16 ;map_index++) {
                       ing_cmprsd_attr_selectors->
                        pri_cnf_attr_map[(ignore_index<<4)|map_index]=map_index;
                  }       
             }
             /* Reset all Offset table fields */
             for (counter_index=0;counter_index<256;counter_index++) {
                  ing_cmprsd_attr_selectors->
                           offset_table_map[counter_index].offset=0;
                  ing_cmprsd_attr_selectors->
                           offset_table_map[counter_index].count_enable=0;
             }
             /* ************************************************************* */
             /* Set unicast, known unicast, multicast, broadcast counter      */
             /* indexes considering INT_PRI as 0                              */
             /* ************************************************************* */
             ing_cmprsd_attr_selectors->offset_table_map[1].offset=0;
             ing_cmprsd_attr_selectors->offset_table_map[1].count_enable=1;
             ing_cmprsd_attr_selectors->offset_table_map[2].offset=1;
             ing_cmprsd_attr_selectors->offset_table_map[2].count_enable=1;
             ing_cmprsd_attr_selectors->offset_table_map[3].offset=2;
             ing_cmprsd_attr_selectors->offset_table_map[3].count_enable=1;
             ing_cmprsd_attr_selectors->offset_table_map[4].offset=3;
             ing_cmprsd_attr_selectors->offset_table_map[4].count_enable=1;


             /* Set Int pri counter indexes NotConsidering pkt resolution bits*/
             /* Priority 0 Counter not satisfying any condition */
             ing_cmprsd_attr_selectors->offset_table_map[0].offset=4;
             ing_cmprsd_attr_selectors->offset_table_map[0].count_enable=1;
             ing_cmprsd_attr_selectors->offset_table_map[5].offset=4;
             ing_cmprsd_attr_selectors->offset_table_map[5].count_enable=1;
             ing_cmprsd_attr_selectors->offset_table_map[6].offset=4;
             ing_cmprsd_attr_selectors->offset_table_map[6].count_enable=1;
             ing_cmprsd_attr_selectors->offset_table_map[7].offset=4;
             ing_cmprsd_attr_selectors->offset_table_map[7].count_enable=1;
             /*INT_PRI*/
             for (counter_index=1;counter_index<(1<<4);counter_index++) {
                  /*PktRes*/
                  for(ignore_index=0;ignore_index<(1<<3);ignore_index++) {
                      ing_cmprsd_attr_selectors->
                       offset_table_map[(counter_index<<3)|ignore_index].
                       offset=(counter_index+4);
                      ing_cmprsd_attr_selectors->
                       offset_table_map[(counter_index<<3)|ignore_index].
                       count_enable=1;
                  }
             }
         } else {
             /* ************************************************************* */
             /* A dedicated counter for unknown unicast, known unicast,       */
             /* multicast,broadcast and N internal priority counters for      */ 
             /* traffic (not already counted)                                 */
             /* 1) Unicast                                                    */
             /* 2) Multicast                                                  */
             /* 3..18) INT_PRI bits: 4bits                                    */
             /* ************************************************************* */
            total_counters=18;
            egr_attr->packet_attr_type=bcmStatFlexPacketAttrTypeCompressed;

            egr_cmprsd_pkt_attr_bits->pkt_resolution = egr_pkt_attr_cmprsd_bits_g[unit].
                                                       pkt_resolution;
            egr_cmprsd_pkt_attr_bits->pkt_resolution_pos = egr_pkt_attr_cmprsd_bits_g[unit].
                                                           pkt_resolution_pos;
            egr_cmprsd_pkt_attr_bits->pkt_resolution_mask = egr_pkt_attr_cmprsd_bits_g[unit].
                                                            pkt_resolution_mask;

            egr_cmprsd_pkt_attr_bits->int_pri = egr_pkt_attr_cmprsd_bits_g[unit].int_pri;
            egr_cmprsd_pkt_attr_bits->int_pri_pos = egr_pkt_attr_cmprsd_bits_g[unit].
                                                    int_pri_pos;
            egr_cmprsd_pkt_attr_bits->int_pri_mask=egr_pkt_attr_cmprsd_bits_g[unit].int_pri_mask;

            egr_cmprsd_attr_selectors->total_counters = 18;

            shift_by_bits= egr_pkt_attr_cmprsd_bits_g[unit].svp_type + 
                           egr_pkt_attr_cmprsd_bits_g[unit].dvp_type + 
                           egr_pkt_attr_cmprsd_bits_g[unit].drop;
             shift_by_bits_for_value = shift_by_bits;
            /* Set pkt_resolution map */
            /* Unicast */
            for (map_index=0; map_index < 1<< shift_by_bits ;map_index++) {
                 egr_cmprsd_attr_selectors->pkt_res_attr_map[map_index]=0;
            }       
            /* Multicast */
            for (; map_index < 255 ;map_index++) {
                 egr_cmprsd_attr_selectors->
                       pkt_res_attr_map[map_index]=(1<<shift_by_bits_for_value);
            }       

            /* Reset pri_cng map */
            for (map_index=0; map_index < 64 ;map_index++) {
                 egr_cmprsd_attr_selectors->pri_cnf_attr_map[map_index]=0;
            }        
            /* set pri_cng map for  16 counters */
            for (ignore_index=0; ignore_index < (1<<2) ; ignore_index++) {
                 for (map_index=0; map_index < 16 ;map_index++) {
                      egr_cmprsd_attr_selectors->
                        pri_cnf_attr_map[(ignore_index<<4)|map_index]=map_index;
                 }       
            }
            /* Reset all Offset table fields */
            for(counter_index=0;counter_index<256;counter_index++) {
                egr_cmprsd_attr_selectors->
                          offset_table_map[counter_index].offset=0;
                egr_cmprsd_attr_selectors->
                          offset_table_map[counter_index].count_enable=0;
            }
            /* ************************************************************** */
            /* Set unicast, multicast, counter indexes                        */
            /* considering INT_PRI bits zero                                  */
            /* ************************************************************** */
            egr_cmprsd_attr_selectors->
                      offset_table_map[0].offset=0;
            egr_cmprsd_attr_selectors->
                      offset_table_map[0].count_enable=1;
            egr_cmprsd_attr_selectors->
                      offset_table_map[1].offset=1;
            egr_cmprsd_attr_selectors->
                      offset_table_map[1].count_enable=1;
            /* PRI-0 counters will be addition of unicast & multicast packets!*/
            /* Set Int pri counter indexes ignoring pkt_res bits           */
            /*INT_PRI*/
            for (counter_index=1;counter_index<(1<<4);counter_index++) {
                 /*PktRes*/
                 for (ignore_index=0;ignore_index<(1<<1);ignore_index++) {
                      egr_cmprsd_attr_selectors->
                       offset_table_map[(counter_index<<1)|ignore_index].
                       offset=(counter_index+2);
                      egr_cmprsd_attr_selectors->
                       offset_table_map[(counter_index<<1)|ignore_index].
                       count_enable=1;
                 }
            }
         }
         break;
    case bcmStatGroupModeSingleWithControl:
         /* **************************************************************   */
         /* A single counter used for all traffic types with an additional   */ 
         /* counter for control traffic                                      */
         /* 1) UNKNOWN_PKT|                    |L2BC_PKT|L2UC_PKT|L2DLF_PKT| */
         /*    UNKNOWN_IPMC_PKT|KNOWN_IPMC_PKT|KNOWN_L2MC_PKT|               */
         /*    UNKNOWN_L2MC_PKT|UNKNOWN_L2MC_PKT|KNOWN_L3UC_PKT|             */
         /*    UNKNOWN_L3UC_PKT|KNOWN_MPLS_PKT|KNOWN_MPLS_L3_PKT|            */
         /*    KNOWN_MPLS_L2_PKT|UNKNOWN_MPLS_PKT|KNOWN_MIM_PKT|             */
         /*    UNKNOWN_MIM_PKT|KNOWN_MPLS_MULTICAST_PKT                      */
         /* 2) CONTROL_PKT|BPDU_PKT                                          */
         /* **************************************************************   */
         if (attr->direction==bcmStatFlexDirectionIngress) {
             total_counters=2;
             _bcm_esw_fillup_ing_uncmp_attr(
                 ing_attr,
                 BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_PKT_RESOLUTION_ATTR_BITS,
                 2);
             _bcm_esw_fillup_ing_pkt_res_offset_table(
                 ing_attr,
                 sizeof(ing_SingleWithControl_res)/
                 sizeof(ing_SingleWithControl_res[0]),
                 &ing_SingleWithControl_res[0]);
         } else {
             /* Group mode is overrided so  control shouldn't hit this part */
             LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                       (BSL_META_U(unit,
                                   "bcmStatGroupModeSingleWithControl"
                                    " is not supported in egress side\n")));
             sal_free(attr);
             return BCM_E_INTERNAL;
         }
         break;
    case bcmStatGroupModeTrafficTypeWithControl:
         /* ********************************************************  */
         /* A dedicated counter per traffic type unicast, multicast,  */
         /* broadcast with an additional counter for control traffic  */
         /* 1) L2UC_PKT | KNOWN_L3UC_PKT | UNKNOWN_L3UC_PKT           */
         /* 2) KNOWN_L2MC_PKT|UNKNOWN_L2MC_PKT|                       */
         /* 3) L2BC_PKT|                                              */
         /* 4) CONTROL_PKT|BPDU_PKT                                   */
         /* ********************************************************  */
         if (attr->direction==bcmStatFlexDirectionIngress) {
             total_counters=4;
             _bcm_esw_fillup_ing_uncmp_attr(
                 ing_attr,
                 BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_PKT_RESOLUTION_ATTR_BITS,
                 4);
             _bcm_esw_fillup_ing_pkt_res_offset_table(
                 ing_attr,
                 sizeof(ing_TrafficTypeWithControl_res)/
                 sizeof(ing_TrafficTypeWithControl_res[0]),
                 &ing_TrafficTypeWithControl_res[0]);
         } else {
             /* Group mode is overrided so  control shouldn't hit this part */
             LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                       (BSL_META_U(unit,
                                   "bcmStatGroupModeTrafficTypeWithControl"
                                    "is not supported in egress side\n")));
             sal_free(attr);
             return BCM_E_INTERNAL;
         }
         break;
    case bcmStatGroupModeDlfAllWithControl:
         /* ************************************************************** */
         /* A pair of counters where the base counter is used for control, */
         /* the next one for dlf and the other counter is used for all     */
         /* traffic types                                                  */
         /* 1) CONTROL_PKT|BPDU_PKT                                        */
         /* 2) L2DLF_PKT                                                   */
         /* 3)UNKNOWN_PKT | CONTROL_PKT|BPDU_PKT|L2BC_PKT|L2UC_PKT|        */
         /*   L2DLF_PKT|UNKNOWN_IPMC_PKT|KNOWN_IPMC_PKT|KNOWN_L2MC_PKT|    */
         /*   UNKNOWN_L2MC_PKT|UNKNOWN_L2MC_PKT|KNOWN_L3UC_PKT|            */
         /*   UNKNOWN_L3UC_PKT|KNOWN_MPLS_PKT|KNOWN_MPLS_L3_PKT|           */
         /*   KNOWN_MPLS_L2_PKT|UNKNOWN_MPLS_PKT|KNOWN_MIM_PKT|            */
         /*   UNKNOWN_MIM_PKT|KNOWN_MPLS_MULTICAST_PKT                     */
         /* ************************************************************** */
         if (attr->direction==bcmStatFlexDirectionIngress) {
             total_counters=3;
             _bcm_esw_fillup_ing_uncmp_attr(
                 ing_attr,
                 BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_PKT_RESOLUTION_ATTR_BITS,
                 3);
             _bcm_esw_fillup_ing_pkt_res_offset_table(
                 ing_attr,
                 sizeof(ing_DlfAllWithControl_res)/
                 sizeof(ing_DlfAllWithControl_res[0]),
                 &ing_DlfAllWithControl_res[0]);
         } else {
             /* Group mode is overrided so  control shouldn't hit this part */
             LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                       (BSL_META_U(unit,
                                   "bcmStatGroupModeDlfAllWithControl is not supported "
                                    "in egress side\n")));
             sal_free(attr);
             return BCM_E_INTERNAL;
         }
         break;
    case bcmStatGroupModeDlfIntPriWithControl:
         /* ************************************************************* */
         /* N+2 counters where the base counter is used for control, the  */
         /* next one for dlf and next N are used per Cos                  */
         /* 1) CONTROL_PKT|BPDU_PKT                                       */
         /* 2) L2_DLF                                                     */
         /* 3..18) INT_PRI bits: 4bits                                    */
         /* ************************************************************* */
         if (attr->direction==bcmStatFlexDirectionEgress) {
             LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                       (BSL_META_U(unit,
                                   "GroupModeDlfIntPriWithControl is not available in "
                                    "egress side\n")));
             sal_free(attr);
             return BCM_E_INTERNAL;
         }

        if (SOC_IS_TOMAHAWK3(unit)) {
            LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                      (BSL_META_U(unit,
                                  "GroupModeDlfIntPriWithControl IsNotAvailable"
                                   "for %s\n"), SOC_UNIT_NAME(unit)));
            sal_free(attr);
            return BCM_E_UNAVAIL;
        }

         /* Although 18 counters but pkt_res(6) + int_pri(4)=10 bits
            so cannot use UNCOMPRESSED MODE */

         /* INT_PRI */ /* .... */ /* PacketRes */ 
         /* 34-31:4 */ /* .... */ /* 8-3:6     */
         /* PRI_CNG_FN=Cng(2x):IFP(2x):IntPri( all 4bits are used). 
             RightMost so no shifting required */
         /* PKT_RES_FN=Pkt(6bits  but 2 is used):SVP(1x):Drop(1x).
            LeftMost so 2 Left shifting required */

         total_counters=18;
         ing_attr->packet_attr_type=bcmStatFlexPacketAttrTypeCompressed;

         ing_cmprsd_pkt_attr_bits->pkt_resolution = 2;
         ing_cmprsd_pkt_attr_bits->pkt_resolution_pos = ing_pkt_attr_cmprsd_bits_g[unit].
                                                        pkt_resolution_pos;
         ing_cmprsd_pkt_attr_bits->pkt_resolution_mask = (1<<2)-1;

         ing_cmprsd_pkt_attr_bits->int_pri = ing_pkt_attr_cmprsd_bits_g[unit].int_pri;
         ing_cmprsd_pkt_attr_bits->int_pri_pos = ing_pkt_attr_cmprsd_bits_g[unit].
                                                 int_pri_pos;

         ing_cmprsd_pkt_attr_bits->int_pri_mask = ing_pkt_attr_cmprsd_bits_g[unit].
                                                  int_pri_mask;
         ing_cmprsd_attr_selectors->total_counters = 18;

         /* Reset pkt_resolution map */
         for (map_index=0; map_index < 256 ;map_index++) {
              ing_cmprsd_attr_selectors->pkt_res_attr_map[map_index]=0;
         }
         /* set pkt_resolution map for  1 counters */
         /* Map[Encoded Packet value << 2=>[SVP-1bit + DROP-1bit]=
            CounterIndex << 2=>[SVP-1bit + DROP-1bit]=4(Start),8,12*/

         shift_by_bits= ing_pkt_attr_cmprsd_bits_g[unit].svp_type + ing_pkt_attr_cmprsd_bits_g[unit].drop;
         shift_by_bits_for_value = shift_by_bits;

         for (ignore_index=0; 
              ignore_index < (1<<shift_by_bits) ; ignore_index++) {
              ing_cmprsd_attr_selectors->
                   pkt_res_attr_map[
                   (control_pkt<<shift_by_bits) | ignore_index]=
                   (1<<shift_by_bits_for_value);
              ing_cmprsd_attr_selectors->
                   pkt_res_attr_map[(bpdu_pkt<<shift_by_bits) | ignore_index]=
                   (1<<shift_by_bits_for_value);
              ing_cmprsd_attr_selectors->
                   pkt_res_attr_map[
                   (l2dlf_pkt<<shift_by_bits) | ignore_index]=
                   (2<<shift_by_bits_for_value);
         }

         /* Reset pri_cng map */
         for (map_index=0; map_index < 256 ;map_index++) {
              ing_cmprsd_attr_selectors->pri_cnf_attr_map[map_index]=0;
         }
         /* set pri_cng map for  16 counters */
         for (ignore_index=0; ignore_index < (1<<4) ; ignore_index++) {
              for (map_index=0; map_index < 16 ;map_index++) {
                   ing_cmprsd_attr_selectors->
                     pri_cnf_attr_map[(ignore_index<<4) | map_index]=map_index;
              }
         }

         /* Reset all Offset table fields */
         for(counter_index=0;counter_index<256;counter_index++) {
                 ing_cmprsd_attr_selectors->
                           offset_table_map[counter_index].offset=0;
                 ing_cmprsd_attr_selectors->
                           offset_table_map[counter_index].count_enable=0;
         }
         /* ************************************************************ */
         /* Set CONTROL_PKT|BPDU_PKT , L2DLF counter indexes considering */
         /* INT_PRI bits 0                                               */
         /* ************************************************************ */

         ing_cmprsd_attr_selectors->offset_table_map[1].offset=0;
         ing_cmprsd_attr_selectors->offset_table_map[1].count_enable=1;
         ing_cmprsd_attr_selectors->offset_table_map[2].offset=1;
         ing_cmprsd_attr_selectors->offset_table_map[2].count_enable=1;

         /* Set IntPri counter indexes not-considering pkt resolution bits*/
         /* Priority 0 Counter not satisfying any condition  */
         ing_cmprsd_attr_selectors->offset_table_map[0].offset=2;
         ing_cmprsd_attr_selectors->offset_table_map[0].count_enable=1;
         ing_cmprsd_attr_selectors->offset_table_map[3].offset=2;
         ing_cmprsd_attr_selectors->offset_table_map[3].count_enable=1;
         /*INT_PRI*/
         for (counter_index=1;counter_index<(1<<4);counter_index++) {
              /*PktRes*/
              for (ignore_index=0;ignore_index<(1<<2);ignore_index++) {
                   ing_cmprsd_attr_selectors->
                       offset_table_map[(counter_index<<2)|ignore_index].
                       offset=(counter_index+2);
                   ing_cmprsd_attr_selectors->
                       offset_table_map[(counter_index<<2)|ignore_index].
                       count_enable=1;
              }
         }
         break;
    case bcmStatGroupModeTypedWithControl:
         /* **************************************************************** */
         /* A dedicated counter for control, unknown unicast, known unicast, */
         /* multicast, broadcast                                             */
         /* 1) CONTROL_PKT|BPDU_PKT                                          */
         /* 2) UNKNOWN_L3UC_PKT                                              */
         /* 3) L2UC_PKT | KNOWN_L3UC_PKT                                     */
         /* 4) KNOWN_L2MC_PKT|UNKNOWN_L2MC_PKT                               */
         /* 5) L2BC_PKT                                                      */
         /* **************************************************************** */
         if (attr->direction == bcmStatFlexDirectionIngress) {
             total_counters=5;
             _bcm_esw_fillup_ing_uncmp_attr(
                 ing_attr,
                 BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_PKT_RESOLUTION_ATTR_BITS,
                 5);
             _bcm_esw_fillup_ing_pkt_res_offset_table(
                 ing_attr,
                 sizeof(ing_TypedWithControl_res)/
                 sizeof(ing_TypedWithControl_res[0]),
                 &ing_TypedWithControl_res[0]);
         } else {
             /* Group mode is overrided so  control shouldn't hit this part */
             LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                       (BSL_META_U(unit,
                                   "bcmStatGroupModeTypedWithControl" 
                                    "is not supported in egress side\n")));
             sal_free(attr);
             return BCM_E_INTERNAL;
         }
         break;
    case bcmStatGroupModeTypedAllWithControl:
         /* ***************************************************************** */
         /* A dedicated counter for control, unknown unicast, known unicast,  */
         /* multicast, broadcast and one for all traffic (not already counted)*/
         /* 1) CONTROL_PKT|BPDU_PKT                                           */
         /* 2) UNKNOWN_L3UC_PKT                                               */
         /* 3) L2UC_PKT | KNOWN_L3UC_PKT                                      */
         /* 4) KNOWN_L2MC_PKT|UNKNOWN_L2MC_PKT                                */
         /* 5) L2BC_PKT                                                       */
         /* 6) UNKNOWN_PKT|L2DLF_PKT|UNKNOWN_IPMC_PKT|KNOWN_IPMC_PKT          */
         /*    KNOWN_MPLS_PKT | KNOWN_MPLS_L3_PKT|KNOWN_MPLS_L2_PKT|          */
         /*    UNKNOWN_MPLS_PKT|KNOWN_MIM_PKT|UNKNOWN_MIM_PKT|                */
         /*    KNOWN_MPLS_MULTICAST_PKT                                       */
         /* ***************************************************************** */
         if (attr->direction == bcmStatFlexDirectionIngress) {
             total_counters=6;
             _bcm_esw_fillup_ing_uncmp_attr(
                 ing_attr,
                 BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_PKT_RESOLUTION_ATTR_BITS,
                 6);
             _bcm_esw_fillup_ing_pkt_res_offset_table(
                 ing_attr,
                 sizeof(ing_TypedAllWithControl_res)/
                 sizeof(ing_TypedAllWithControl_res[0]),
                 &ing_TypedAllWithControl_res[0]);
         } else {
             /* Group mode is overrided so  control shouldn't hit this part */
             LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                       (BSL_META_U(unit,
                                   "bcmStatGroupModeTypedAllWithControl"
                                    " is not supported in egress side\n")));
             sal_free(attr);
             return BCM_E_INTERNAL;
         }
         break;
    case bcmStatGroupModeTypedIntPriWithControl:
         /* *************************************************************** */
         /* A dedicated counter for control, unknown unicast, known unicast */
         /* , multicast, broadcast and N internal priority counters for     */
         /* traffic (not already counted)                                   */
         /* 1) CONTROL_PKT|BPDU_PKT                                         */
         /* 2) UNKNOWN_L3UC_PKT                                             */
         /* 3) L2UC_PKT | KNOWN_L3UC_PKT                                    */
         /* 4) KNOWN_L2MC_PKT|UNKNOWN_L2MC_PKT                              */
         /* 5) L2BC_PKT                                                     */
         /* 6..21) INT_PRI bits: 4bits                                      */
         /* *************************************************************** */
         if (attr->direction == bcmStatFlexDirectionEgress) {
             LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                       (BSL_META_U(unit,
                                   "GroupModeTypedIntPriWithControl is not available in "
                                    "egress side\n")));
             sal_free(attr);
             return BCM_E_INTERNAL;
         }

        if (SOC_IS_TOMAHAWK3(unit)) {
            LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                      (BSL_META_U(unit,
                                  "GroupModeTypedIntPriWithControl IsNotAvailable"
                                   "for %s\n"), SOC_UNIT_NAME(unit)));
            sal_free(attr);
            return BCM_E_UNAVAIL;
        }

         /* Although 21 counters but pkt_res(6) + int_pri(4)=10 bits
            so cannot use UNCOMPRESSED MODE */

         /* INT_PRI */ /* .... */ /* PacketRes */ 
         /* 34-31:4 */ /* .... */ /* 8-3:6     */
         /* PRI_CNG_FN=Cng(2x):IFP(2x):IntPri( all 4bits are used). 
             RightMost so no shifting required */
         /* PKT_RES_FN=Pkt(6bits  but 2 is used):SVP(1x):Drop(1x).
            LeftMost so 2 Left shifting required */

         total_counters=21;
         ing_attr->packet_attr_type=bcmStatFlexPacketAttrTypeCompressed;

         ing_cmprsd_pkt_attr_bits->pkt_resolution = 3;
         ing_cmprsd_pkt_attr_bits->pkt_resolution_pos = ing_pkt_attr_cmprsd_bits_g[unit].
                                                        pkt_resolution_pos;
         ing_cmprsd_pkt_attr_bits->pkt_resolution_mask = (1<<3)-1;
         ing_cmprsd_pkt_attr_bits->int_pri = ing_pkt_attr_cmprsd_bits_g[unit].int_pri;
         ing_cmprsd_pkt_attr_bits->int_pri_pos = ing_pkt_attr_cmprsd_bits_g[unit].
                                                 int_pri_pos;
         ing_cmprsd_pkt_attr_bits->int_pri_mask = ing_pkt_attr_cmprsd_bits_g[unit].int_pri_mask;
         ing_cmprsd_attr_selectors->total_counters = 21;
            
         /* Reset pkt_resolution map */
         for (map_index=0; map_index < 256 ;map_index++) {
              ing_cmprsd_attr_selectors->pkt_res_attr_map[map_index]=0;
         }       
         /* set pkt_resolution map for  1 counters */
         /* set pkt_resolution map for  1 counters */
         /* Map[Encoded Packet value << 2=>[SVP-1bit + DROP-1bit]=
            CounterIndex << 2=>[SVP-1bit + DROP-1bit]=4(Start),8,12*/

         shift_by_bits= ing_pkt_attr_cmprsd_bits_g[unit].svp_type + ing_pkt_attr_cmprsd_bits_g[unit].drop;
         shift_by_bits_for_value = shift_by_bits;

         for (ignore_index=0; 
              ignore_index < (1<<shift_by_bits) ; ignore_index++) {
              ing_cmprsd_attr_selectors->
                 pkt_res_attr_map[
                 (control_pkt<<shift_by_bits) | ignore_index]=
                 (1<<shift_by_bits_for_value);
              ing_cmprsd_attr_selectors->
                 pkt_res_attr_map[
                 (bpdu_pkt<<shift_by_bits) | ignore_index]=
                 (1<<shift_by_bits_for_value);
              ing_cmprsd_attr_selectors->
                 pkt_res_attr_map[
                 (unknown_l3uc_pkt<<shift_by_bits) | ignore_index]=
                 (2<<shift_by_bits_for_value);
              ing_cmprsd_attr_selectors->
                 pkt_res_attr_map[
                 (l2uc_pkt<<shift_by_bits) | ignore_index]=
                 (3<<shift_by_bits_for_value);
              ing_cmprsd_attr_selectors->
                 pkt_res_attr_map[
                 (known_l3uc_pkt<<shift_by_bits) | ignore_index]=
                 (3<<shift_by_bits_for_value);
              ing_cmprsd_attr_selectors->
                 pkt_res_attr_map[
                 (known_l2mc_pkt<<shift_by_bits) | ignore_index]=
                 (4<<shift_by_bits_for_value);
              ing_cmprsd_attr_selectors->
                 pkt_res_attr_map[
                 (unknown_l2mc_pkt<<shift_by_bits) | ignore_index]=
                 (4<<shift_by_bits_for_value);
              ing_cmprsd_attr_selectors->
                 pkt_res_attr_map[
                 (l2bc_pkt<<shift_by_bits) | ignore_index]=
                 (5<<shift_by_bits_for_value);
         }
         /* Reset pri_cng map */
         for (map_index=0; map_index < 256 ;map_index++) {
              ing_cmprsd_attr_selectors->pri_cnf_attr_map[map_index]=0;
         }       
         /* set pri_cng map for  16 counters */
         for (ignore_index=0; ignore_index < (1<<4) ; ignore_index++) {
              for (map_index=0; map_index < 16 ;map_index++) {
                   ing_cmprsd_attr_selectors->
                      pri_cnf_attr_map[(ignore_index<<4) | map_index]=map_index;
              }       
         }
                 
         /* Reset all Offset table fields */
         for (counter_index=0;counter_index<256;counter_index++) {
              ing_cmprsd_attr_selectors->
                        offset_table_map[counter_index].offset=0;
              ing_cmprsd_attr_selectors->
                        offset_table_map[counter_index].count_enable=0;
         }
         /* **************************************************************** */
         /* Set unicast, known unicast, multicast, broadcast counter indexes */
         /* considering INT_PRI bits 0                                       */
         /* **************************************************************** */
         ing_cmprsd_attr_selectors->offset_table_map[1].offset=0;
         ing_cmprsd_attr_selectors->offset_table_map[1].count_enable=1;
         ing_cmprsd_attr_selectors->offset_table_map[2].offset=1;
         ing_cmprsd_attr_selectors->offset_table_map[2].count_enable=1;
         ing_cmprsd_attr_selectors->offset_table_map[3].offset=2;
         ing_cmprsd_attr_selectors->offset_table_map[3].count_enable=1;
         ing_cmprsd_attr_selectors->offset_table_map[4].offset=3;
         ing_cmprsd_attr_selectors->offset_table_map[4].count_enable=1;
         ing_cmprsd_attr_selectors->offset_table_map[5].offset=4;
         ing_cmprsd_attr_selectors->offset_table_map[5].count_enable=1;

         /* Set IntPri counter indexes not-considering pkt resolution bits*/
         /* Priority 0 Counter not satisfying any condition  */
         ing_cmprsd_attr_selectors->offset_table_map[0].offset=5;
         ing_cmprsd_attr_selectors->offset_table_map[0].count_enable=1;
         ing_cmprsd_attr_selectors->offset_table_map[6].offset=5;
         ing_cmprsd_attr_selectors->offset_table_map[6].count_enable=1;
         ing_cmprsd_attr_selectors->offset_table_map[7].offset=5;
         ing_cmprsd_attr_selectors->offset_table_map[7].count_enable=1;

         /*INT_PRI*/
         for (counter_index=1;counter_index<(1<<4);counter_index++) {
              /*PktRes*/
              for (ignore_index=0;ignore_index<(1<<3);ignore_index++) {
                   ing_cmprsd_attr_selectors->
                       offset_table_map[(counter_index<<3)|ignore_index].
                       offset=(counter_index+5);
                   ing_cmprsd_attr_selectors->
                       offset_table_map[(counter_index<<3)|ignore_index].
                       count_enable=1;
              }
         }
         break;
    case bcmStatGroupModeDot1P:
         /* ******************************************************** */
         /* A set of 8(2^3) counters selected based on Vlan priority */
         /* outer_dot1p; 3 bits 1..8                                 */
         /* ******************************************************** */

         if (attr->direction==bcmStatFlexDirectionIngress) {
             total_counters=8;
             _bcm_esw_fillup_ing_uncmp_attr(
                 ing_attr,
                 BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_OUTER_DOT1P_ATTR_BITS,
                 8);
             /* Set Offset table fields */
             for (counter_index=0;counter_index<8;counter_index++) {
                  ing_attr->uncmprsd_attr_selectors.
                   offset_table_map[counter_index].offset=counter_index;
                  ing_attr->uncmprsd_attr_selectors.
                   offset_table_map[counter_index].count_enable=1;
             }
         } else {
             total_counters=8;
             _bcm_esw_fillup_egr_uncmp_attr(
                 egr_attr,
                 BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_OUTER_DOT1P_ATTR_BITS,
                 8);
             /* Set Offset table fields */
             for (counter_index=0;counter_index<8;counter_index++) {
                  egr_attr->uncmprsd_attr_selectors.
                   offset_table_map[counter_index].offset=counter_index;
                  egr_attr->uncmprsd_attr_selectors.
                   offset_table_map[counter_index].count_enable=1;
             }
         }
         break;
    case bcmStatGroupModeIntPri:
         /* **************************************************** */
         /* A set of 16(2^4) counters based on internal priority */
         /* 1..16 INT_PRI bits: 4bits                            */
         /* **************************************************** */

         if (attr->direction==bcmStatFlexDirectionIngress) {
             total_counters=16;
             _bcm_esw_fillup_ing_uncmp_attr(
                 ing_attr,
                 BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_INT_PRI_ATTR_BITS,
                 16);
             /* Set Offset table fields */
             for (counter_index=0;counter_index<16;counter_index++) {
                  ing_attr->uncmprsd_attr_selectors.
                          offset_table_map[counter_index].offset=counter_index;
                  ing_attr->uncmprsd_attr_selectors.
                          offset_table_map[counter_index].count_enable=1;
             }
         } else {
             total_counters=16;
             _bcm_esw_fillup_egr_uncmp_attr(
                 egr_attr,
                 BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_INT_PRI_ATTR_BITS,
                 16);
             /* Set Offset table fields */
             for (counter_index=0;counter_index<16;counter_index++) {
                  egr_attr->uncmprsd_attr_selectors.
                          offset_table_map[counter_index].offset=counter_index;
                  egr_attr->uncmprsd_attr_selectors.
                          offset_table_map[counter_index].count_enable=1;
             }
         }
         break;
    case bcmStatGroupModeIntPriCng:
         /* ********************************************************** */
         /* set of 64 counters(2^(4+2)) based on Internal priority+CNG */
         /* 1..64 (INT_PRI bits: 4bits + CNG 2 bits                    */
         /* 1..64 (INT_PRI bits: 4bits + CNG 2 bits                    */
         /* ********************************************************** */
         if (attr->direction==bcmStatFlexDirectionIngress) {
             total_counters=64;
             _bcm_esw_fillup_ing_uncmp_attr(
                 ing_attr,
                 BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_CNG_ATTR_BITS|
                 BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_INT_PRI_ATTR_BITS,
                 64);
             /* Set Offset table fields */
             counter_index=0;
             for (outer_index=0;outer_index<4;outer_index++) {/*CNG*/
                  for (inner_index=0;inner_index<16;inner_index++) {/*IntPri*/
                       ing_attr->uncmprsd_attr_selectors.
                          offset_table_map[counter_index].count_enable=1;
                       ing_attr->uncmprsd_attr_selectors.
                       offset_table_map[(outer_index<<4)|inner_index].
                       offset=counter_index++;
                  }
             }
         } else {
             total_counters=64;
             _bcm_esw_fillup_egr_uncmp_attr(
                 egr_attr,
                 BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_CNG_ATTR_BITS|
                 BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_INT_PRI_ATTR_BITS,
                 64);
             /* Set Offset table fields */
             counter_index=0;
             for (outer_index=0;outer_index<4;outer_index++) {/*CNG*/
                  for(inner_index=0;inner_index<16;inner_index++) {/*IntPri*/
                      egr_attr->uncmprsd_attr_selectors.
                         offset_table_map[counter_index].count_enable=1;
                      egr_attr->uncmprsd_attr_selectors.
                         offset_table_map[(outer_index<<4)|inner_index].
                         offset=counter_index++;
                  }
             }
         }
         break;
    case bcmStatGroupModeSvpType:
         /* ****************************************** */
         /* A set of 2 counters(2^1) based on SVP type */
         /* 1..2 (SVP 1 bit)                           */
         /* ****************************************** */

         if (attr->direction==bcmStatFlexDirectionIngress) {
             total_counters=2;
             _bcm_esw_fillup_ing_uncmp_attr(
                 ing_attr,
                 BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_SVP_TYPE_ATTR_BITS,
                 2);
             /* Set Offset table fields */
             /* DropBitShifting=1 is required */
             for (counter_index=0;counter_index<2;counter_index++) {
                  ing_attr->uncmprsd_attr_selectors.
                        offset_table_map[counter_index].offset=counter_index;
                  ing_attr->uncmprsd_attr_selectors.
                        offset_table_map[counter_index].count_enable=1;
             }
         } else {
             total_counters=2;
             _bcm_esw_fillup_egr_uncmp_attr(
                 egr_attr,
                 BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_SVP_TYPE_ATTR_BITS,
                 2);
             /* Set Offset table fields */
             /* DropBitShifting=1 + DvpBitShifting=1 ==> 2 is required */
             for (counter_index=0;counter_index<2;counter_index++) {
                  egr_attr->uncmprsd_attr_selectors.
                        offset_table_map[counter_index<<2].offset=counter_index;
                  egr_attr->uncmprsd_attr_selectors.
                        offset_table_map[counter_index<<2].count_enable=1;
             }
         }
         break;
    case bcmStatGroupModeDscp:
         /* ******************************************** */
         /* A set of 64 counters(2^6) based on DSCP bits */
         /* 1..64 (6 bits from TOS 8 bits)               */
         /* ******************************************** */

         if (attr->direction==bcmStatFlexDirectionIngress) {
             total_counters=64;
             _bcm_esw_fillup_ing_uncmp_attr(
                 ing_attr,
                 BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_TOS_DSCP_ATTR_BITS,
                 64);
             /* Set Offset table fields */
             for (counter_index=0;counter_index<64;counter_index++) {
                  ing_attr->uncmprsd_attr_selectors.
                        offset_table_map[counter_index].offset=counter_index;
                  ing_attr->uncmprsd_attr_selectors.
                        offset_table_map[counter_index].count_enable=1;
             }
         } else {
             total_counters=64;
             _bcm_esw_fillup_egr_uncmp_attr(
                 egr_attr,
                 BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_TOS_DSCP_ATTR_BITS,
                 64);
             /* Set Offset table fields */
             for (counter_index = 0; counter_index < 64; counter_index++) {
                  egr_attr->uncmprsd_attr_selectors.
                        offset_table_map[counter_index].offset=counter_index;
                  egr_attr->uncmprsd_attr_selectors.
                        offset_table_map[counter_index].count_enable=1;
             }
         }
         break;
    case bcmStatGroupModeDvpType:
         /* ******************************************** */
         /* EGRESS SIDE ONLY:                            */
         /* A set of 2 counters(2^1) based on DVP type   */
         /* 1..2 (DVP 1 bits)                            */
         /* ******************************************** */

         if (attr->direction==bcmStatFlexDirectionIngress) {
             LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                       (BSL_META_U(unit,
                                   "bcm_stat_group_mode_t %d is NotSupported"
                                    " in IngressSide\n"), group_mode));
             sal_free(attr);
             return BCM_E_PARAM;
         } else {
             total_counters=2;
             _bcm_esw_fillup_egr_uncmp_attr(
                 egr_attr,
                 BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_DVP_TYPE_ATTR_BITS,
                 2);
             /* Set Offset table fields */
             for (counter_index=0;counter_index<2;counter_index++) {
                  egr_attr->uncmprsd_attr_selectors.
                        offset_table_map[counter_index].offset=counter_index;
                  egr_attr->uncmprsd_attr_selectors.
                        offset_table_map[counter_index].count_enable=1;
             }
         }
         break;
    case bcmStatGroupModeCng:
         if (attr->direction==bcmStatFlexDirectionIngress) {
             total_counters=4;
             _bcm_esw_fillup_ing_uncmp_attr(
                 ing_attr,
                 BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_CNG_ATTR_BITS,
                 4);
             /* Set Offset table fields */
             for (counter_index=0;counter_index<4;counter_index++) {
                  ing_attr->uncmprsd_attr_selectors.
                        offset_table_map[counter_index].offset=counter_index;
                  ing_attr->uncmprsd_attr_selectors.
                        offset_table_map[counter_index].count_enable=1;
             }
         } else {
             total_counters=4;
             _bcm_esw_fillup_egr_uncmp_attr(
                 egr_attr,
                 BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_CNG_ATTR_BITS,
                 4);
             /* Set Offset table fields */
             for (counter_index=0;counter_index<4;counter_index++) {
                  egr_attr->uncmprsd_attr_selectors.
                        offset_table_map[counter_index].offset=counter_index;
                  egr_attr->uncmprsd_attr_selectors.
                        offset_table_map[counter_index].count_enable=1;
             }
         }
         break;
#ifdef BCM_APACHE_SUPPORT
    case bcmStatGroupModeMplsCngLabelFirst:
         if (soc_feature(unit,soc_feature_flex_ctr_mpls_3_label_count)) {
             if (attr->direction == bcmStatFlexDirectionIngress) {
                 total_counters = 4;
                 _bcm_esw_fillup_ing_uncmp_attr(
                         ing_attr,
                         BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_CNG_1_ATTR_BITS,
                         4);
                 /* Set Offset table fields */
                 for (counter_index = 0;counter_index<4;counter_index++) {
                     ing_attr->uncmprsd_attr_selectors.
                         offset_table_map[counter_index].offset = counter_index;
                     ing_attr->uncmprsd_attr_selectors.
                         offset_table_map[counter_index].count_enable = 1;
                 }
             } else {
                 total_counters = 4;
                 _bcm_esw_fillup_egr_uncmp_attr(
                         egr_attr,
                         BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_CNG_1_ATTR_BITS,
                         4);
                 /* Set Offset table fields */
                 for (counter_index = 0;counter_index<4;counter_index++) {
                     egr_attr->uncmprsd_attr_selectors.
                         offset_table_map[counter_index].offset = counter_index;
                     egr_attr->uncmprsd_attr_selectors.
                         offset_table_map[counter_index].count_enable = 1;
                 }
             }
         } else {
             sal_free(attr);
             return BCM_E_UNAVAIL;
         }
         break;
    case bcmStatGroupModeMplsIntPriLabelFirst:
         /* **************************************************** */
         /* A set of 16(2^4) counters based on internal pri MPLS label 1*/
         /* 1..16 PHB_1 bits: 4bits                            */
         /* **************************************************** */
         if (soc_feature(unit,soc_feature_flex_ctr_mpls_3_label_count)) {
             if (attr->direction == bcmStatFlexDirectionIngress) {
                 total_counters = 16;
                 _bcm_esw_fillup_ing_uncmp_attr(
                         ing_attr,
                         BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_PHB_1_ATTR_BITS,
                         16);
                 /* Set Offset table fields */
                 for (counter_index = 0;counter_index<16;counter_index++) {
                     ing_attr->uncmprsd_attr_selectors.
                         offset_table_map[counter_index].offset = counter_index;
                     ing_attr->uncmprsd_attr_selectors.
                         offset_table_map[counter_index].count_enable = 1;
                 }
             } else {
                 total_counters = 16;
                 _bcm_esw_fillup_egr_uncmp_attr(
                         egr_attr,
                         BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_PHB_1_ATTR_BITS,
                         16);
                 /* Set Offset table fields */
                 for (counter_index = 0;counter_index<16;counter_index++) {
                     egr_attr->uncmprsd_attr_selectors.
                         offset_table_map[counter_index].offset = counter_index;
                     egr_attr->uncmprsd_attr_selectors.
                         offset_table_map[counter_index].count_enable = 1;
                 }
             }
         } else {
             sal_free(attr);
             return BCM_E_UNAVAIL;
         }
         break;
    case bcmStatGroupModeMplsCngLabelSecond:
         if (soc_feature(unit,soc_feature_flex_ctr_mpls_3_label_count)) {
             if (attr->direction == bcmStatFlexDirectionIngress) {
                 total_counters = 4;
                 _bcm_esw_fillup_ing_uncmp_attr(
                         ing_attr,
                         BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_CNG_2_ATTR_BITS,
                         4);
                 /* Set Offset table fields */
                 for (counter_index = 0;counter_index<4;counter_index++) {
                     ing_attr->uncmprsd_attr_selectors.
                         offset_table_map[counter_index].offset = counter_index;
                     ing_attr->uncmprsd_attr_selectors.
                         offset_table_map[counter_index].count_enable = 1;
                 }
             } else {
                 total_counters = 4;
                 _bcm_esw_fillup_egr_uncmp_attr(
                         egr_attr,
                         BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_CNG_2_ATTR_BITS,
                         4);
                 /* Set Offset table fields */
                 for (counter_index = 0;counter_index<4;counter_index++) {
                     egr_attr->uncmprsd_attr_selectors.
                         offset_table_map[counter_index].offset = counter_index;
                     egr_attr->uncmprsd_attr_selectors.
                         offset_table_map[counter_index].count_enable = 1;
                 }
             }
         } else {
             sal_free(attr);
             return BCM_E_UNAVAIL;
         }
         break;
    case bcmStatGroupModeMplsIntPriLabelSecond:
         /* **************************************************** */
         /* A set of 16(2^4) counters based on internal pri MPLS label 2*/
         /* 1..16 PHB_1 bits: 4bits                            */
         /* **************************************************** */
         if (soc_feature(unit,soc_feature_flex_ctr_mpls_3_label_count)) {
             if (attr->direction == bcmStatFlexDirectionIngress) {
                 total_counters = 16;
                 _bcm_esw_fillup_ing_uncmp_attr(
                         ing_attr,
                         BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_PHB_2_ATTR_BITS,
                         16);
                 /* Set Offset table fields */
                 for (counter_index = 0;counter_index<16;counter_index++) {
                     ing_attr->uncmprsd_attr_selectors.
                         offset_table_map[counter_index].offset = counter_index;
                     ing_attr->uncmprsd_attr_selectors.
                         offset_table_map[counter_index].count_enable = 1;
                 }
             } else {
                 total_counters = 16;
                 _bcm_esw_fillup_egr_uncmp_attr(
                         egr_attr,
                         BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_PHB_2_ATTR_BITS,
                         16);
                 /* Set Offset table fields */
                 for (counter_index = 0;counter_index<16;counter_index++) {
                     egr_attr->uncmprsd_attr_selectors.
                         offset_table_map[counter_index].offset = counter_index;
                     egr_attr->uncmprsd_attr_selectors.
                         offset_table_map[counter_index].count_enable = 1;
                 }
             }
         } else {
             sal_free(attr);
             return BCM_E_UNAVAIL;
         }
         break;
    case bcmStatGroupModeMplsCngLabelThird:
         if (soc_feature(unit,soc_feature_flex_ctr_mpls_3_label_count)) {
             if (attr->direction == bcmStatFlexDirectionIngress) {
                 total_counters = 4;
                 _bcm_esw_fillup_ing_uncmp_attr(
                         ing_attr,
                         BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_CNG_3_ATTR_BITS,
                         4);
                 /* Set Offset table fields */
                 for (counter_index = 0;counter_index<4;counter_index++) {
                     ing_attr->uncmprsd_attr_selectors.
                         offset_table_map[counter_index].offset = counter_index;
                     ing_attr->uncmprsd_attr_selectors.
                         offset_table_map[counter_index].count_enable = 1;
                 }
             } else {
                 total_counters = 4;
                 _bcm_esw_fillup_egr_uncmp_attr(
                         egr_attr,
                         BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_CNG_3_ATTR_BITS,
                         4);
                 /* Set Offset table fields */
                 for (counter_index = 0;counter_index<4;counter_index++) {
                     egr_attr->uncmprsd_attr_selectors.
                         offset_table_map[counter_index].offset = counter_index;
                     egr_attr->uncmprsd_attr_selectors.
                         offset_table_map[counter_index].count_enable = 1;
                 }
             }
         } else {
             sal_free(attr);
             return BCM_E_UNAVAIL;
         }
         break;
    case bcmStatGroupModeMplsIntPriLabelThird:
         /* **************************************************** */
         /* A set of 16(2^4) counters based on internal pri MPLS label 2*/
         /* 1..16 PHB_1 bits: 4bits                            */
         /* **************************************************** */
         if (soc_feature(unit,soc_feature_flex_ctr_mpls_3_label_count)) {
             if (attr->direction == bcmStatFlexDirectionIngress) {
                 total_counters = 16;
                 _bcm_esw_fillup_ing_uncmp_attr(
                         ing_attr,
                         BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_PHB_3_ATTR_BITS,
                         16);
                 /* Set Offset table fields */
                 for (counter_index = 0;counter_index<16;counter_index++) {
                     ing_attr->uncmprsd_attr_selectors.
                         offset_table_map[counter_index].offset = counter_index;
                     ing_attr->uncmprsd_attr_selectors.
                         offset_table_map[counter_index].count_enable = 1;
                 }
             } else {
                 total_counters = 16;
                 _bcm_esw_fillup_egr_uncmp_attr(
                         egr_attr,
                         BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_PHB_3_ATTR_BITS,
                         16);
                 /* Set Offset table fields */
                 for (counter_index = 0;counter_index<16;counter_index++) {
                     egr_attr->uncmprsd_attr_selectors.
                         offset_table_map[counter_index].offset = counter_index;
                     egr_attr->uncmprsd_attr_selectors.
                         offset_table_map[counter_index].count_enable = 1;
                 }
             }
         } else {
             sal_free(attr);
             return BCM_E_UNAVAIL;
         }
         break;
#endif
    default:
         if ((int32)group_mode == bcmIntStatGroupModeLatencyMonitor) {
             /* ********************************************************** */
             /* EGRESS SIDE ONLY:                                          */
             /* A set of 960 counters for 10 sets of  12 Queues/histograms */
             /* and 8 buckets/counters per queue/histogram.                */
             /* ********************************************************** */

             if (attr->direction==bcmStatFlexDirectionIngress) {
                 LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                           (BSL_META_U(unit,
                                       "bcm_stat_group_mode_t %d is NotSupported"
                                        " in IngressSide\n"), group_mode));
                 sal_free(attr);
                 return BCM_E_PARAM;
             } else {
                 total_counters=960;
                 _bcm_esw_fillup_egr_uncmp_attr(
                     egr_attr,
                     0,
                     total_counters);
                 attr->egr_attr.uncmprsd_attr_selectors.uncmprsd_attr_bits_selector = 0;
             }
         } else {
             sal_free(attr);
             return BCM_E_PARAM;
         }
    };
    rv =  _bcm_esw_stat_flex_create_mode(unit,attr,&mode,NULL);
    if ((rv == BCM_E_NONE) || (rv==BCM_E_EXISTS)) {
         soc_mem_t                 mem_tab = PORT_TABm;
         rv = _bcm_esw_stat_flex_set_group_mode(
                             unit,attr->direction, mode,group_mode);
         if(BCM_FAILURE(rv)) {
             sal_free(attr);
             return rv;
         }
         rv = BCM_E_NONE;
         switch(object) {
         /* Ingress Side */
         case bcmStatObjectIngPort:
  #if defined (BCM_TRIDENT3_SUPPORT)
              if (SOC_IS_TRIDENT3X(unit)){
                  mem_tab = LPORT_TABm;
              } else
  #endif
              {
                  mem_tab = PORT_TABm;
              }
              rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                        unit, mem_tab, FIRST_LKUP, object, mode,
                        &base_index, &pool_number);
              break;
         case bcmStatObjectIngVlan:
              rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                        unit, VLAN_TABm, FIRST_LKUP, object,mode,
                        &base_index,&pool_number);
              break;
         case bcmStatObjectIngVlanXlate:
  #if defined (BCM_TRIDENT3_SUPPORT)
              if (SOC_IS_TRIDENT3X(unit)){
                 /* Should consider VLAN_XLATE_2_DOUBLEm in future */
                  mem_tab = VLAN_XLATE_1_DOUBLEm;
              } else
  #endif
              {
                  mem_tab = VLAN_XLATEm;
              }
              rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                        unit, mem_tab, FIRST_LKUP, object, mode,
                        &base_index, &pool_number);
              break;
         case bcmStatObjectIngVlanXlateSecondLookup:
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
              if (soc_feature(unit,soc_feature_ing_vlan_xlate_second_lookup)) {
#if defined (BCM_TRIDENT3_SUPPORT)
                  if (SOC_IS_TRIDENT3X(unit)){
                      mem_tab = VLAN_XLATE_1_DOUBLEm;
                  } else
#endif
                  {
                      mem_tab = VLAN_XLATEm;
                  }
                  rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                          unit, mem_tab, SECOND_LKUP, object,mode,
                          &base_index,&pool_number);
              } else
#endif
              {
                  rv = BCM_E_PARAM;
              }
              break;
         case bcmStatObjectIngVfi:
              rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                        unit, VFIm, FIRST_LKUP, object,mode,
                        &base_index,&pool_number);
              break;
         case bcmStatObjectIngL3Intf:
              rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                        unit, L3_IIFm, FIRST_LKUP, object,mode,
                        &base_index,&pool_number);
              break;
         case bcmStatObjectIngVrf:
#if defined (BCM_TRIDENT3_SUPPORT)
              if (SOC_IS_TRIDENT3X(unit)){
                  mem_tab = VRF_ATTRS_2m;
              } else
#endif
              {
                  mem_tab = VRFm;
              }
              rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                        unit, mem_tab, FIRST_LKUP, object,mode,
                        &base_index,&pool_number);
              break;
         case bcmStatObjectIngPolicy:
              pool_number = 0xff; /* This will cause the default pool to be allocated*/
              rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                        unit, VFP_POLICY_TABLEm, FIRST_LKUP, object,mode,
                        &base_index,&pool_number);
              break;
         case bcmStatObjectIngNiv:
         case bcmStatObjectIngMplsVcLabel:
              rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                        unit, SOURCE_VPm, FIRST_LKUP, object,mode,
                        &base_index,&pool_number);
              break;
         case bcmStatObjectIngMplsSwitchLabel:
              rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                        unit, MPLS_ENTRYm, FIRST_LKUP, object, mode,
                        &base_index, &pool_number);
              break;
         case bcmStatObjectIngMplsSwitchSecondLabel:
#if defined(BCM_APACHE_SUPPORT)
              if (soc_feature(unit,
                      soc_feature_mpls_entry_second_label_lookup)) {
                  rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                          unit, MPLS_ENTRYm, SECOND_LKUP, object,mode,
                          &base_index,&pool_number);
              } else
#endif
              {
                  rv = BCM_E_PARAM;
              }
              break;
         case bcmStatObjectIngMplsFrrLabel:
              rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                        unit, L3_TUNNELm, FIRST_LKUP, object,mode,
                        &base_index,&pool_number);
              break;
         case bcmStatObjectIngL3Host:
              /* To Be Completed..L3_ENTRY_2/4,EXT_IPV4/6_128_UCAST_WIDE */
              rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                        unit, EXT_IPV4_UCAST_WIDEm, FIRST_LKUP, object,mode,
                        &base_index,&pool_number);
              break;
         case bcmStatObjectIngTrill:
              rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                        unit, MPLS_ENTRY_EXTDm, FIRST_LKUP, object,mode,
                        &base_index,&pool_number);
              break;
         case bcmStatObjectIngMimLookupId:
              rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                        unit, MPLS_ENTRY_EXTDm, FIRST_LKUP, object,mode,
                        &base_index,&pool_number);
              break;
         case bcmStatObjectIngL2Gre:
              /* To Be Completed..SOURCE_VPm, VLAN_XLATE_1m L2GRE_DIP view */
  #if defined (BCM_TRIDENT3_SUPPORT)
              if (SOC_IS_TRIDENT3X(unit)){
                  mem_tab = VLAN_XLATE_1_DOUBLEm;
              } else
  #endif
              {
	              mem_tab = VLAN_XLATEm;
              }
              rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                        unit, mem_tab, FIRST_LKUP, object, mode,
                        &base_index, &pool_number);
              break;
         case bcmStatObjectIngEXTPolicy:
              rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                        unit, EXT_FP_POLICYm, FIRST_LKUP, object, mode,
                        &base_index, &pool_number);
              break;
         case bcmStatObjectIngVxlan:
              rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                        unit, SOURCE_VPm, FIRST_LKUP, object,mode,
                        &base_index,&pool_number);
              break;
         case bcmStatObjectIngVsan:
              rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                        unit, ING_VSANm, FIRST_LKUP, object,mode,
                        &base_index,&pool_number);
              break;
         case bcmStatObjectIngFcoe:
  #if defined (BCM_TRIDENT3_SUPPORT)
              if (SOC_IS_TRIDENT3X(unit)){
                  mem_tab = L3_ENTRY_DOUBLEm;
              } else
  #endif
              {
                  mem_tab = L3_ENTRY_IPV4_MULTICASTm;
              }
              rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                        unit, mem_tab, FIRST_LKUP, object, mode,
                        &base_index, &pool_number);
              break;
         case bcmStatObjectIngL3Route:
              rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                        unit, L3_DEFIPm, FIRST_LKUP, object,mode,
                        &base_index,&pool_number);
              break;
         case bcmStatObjectIngIpmc:
  #if defined (BCM_TRIDENT3_SUPPORT)
              if (SOC_IS_TRIDENT3X(unit)){
                  mem_tab = L3_ENTRY_DOUBLEm;
              } else
  #endif
              {
                  mem_tab = L3_ENTRY_IPV4_MULTICASTm;
              }
              rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                        unit, mem_tab, FIRST_LKUP, object, mode,
                        &base_index, &pool_number);
              break; 
         case bcmStatObjectIngVxlanDip:
  #if defined (BCM_TRIDENT3_SUPPORT)
              if (SOC_IS_TRIDENT3X(unit)){
                  mem_tab = VLAN_XLATE_1_DOUBLEm;
              } else
  #endif
              {
                  mem_tab = VLAN_XLATEm;
              }
              rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                        unit, mem_tab, FIRST_LKUP, object, mode,
                        &base_index, &pool_number);
              break;
         case bcmStatObjectIngFieldStageIngress:
              pool_number = 0xff; /* This will cause the default pool to be allocated*/
              rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                        unit, IFP_POLICY_TABLEm, FIRST_LKUP, object,mode,
                        &base_index, &pool_number);
              break;
         case bcmStatObjectIngExactMatch:
              pool_number = 0xff; /* This will cause the default pool to be allocated*/
              rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                        unit, EXACT_MATCH_2m, FIRST_LKUP, object, mode,
                        &base_index, &pool_number);
              break;
         case bcmStatObjectIngGport:
              rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                        unit, SOURCE_VPm, FIRST_LKUP, object, mode,
                        &base_index, &pool_number);
              break;

         /* Egress Side */
         case bcmStatObjectEgrPort:
  #if defined (BCM_TRIDENT3_SUPPORT)
              if (SOC_IS_TRIDENT3X(unit)){
                  mem_tab = EGR_LPORT_PROFILEm;
              } else
  #endif
              {
                  mem_tab = EGR_PORTm;
              }
              rv = _bcm_esw_stat_flex_create_egress_table_counters(
                        unit, mem_tab, FIRST_LKUP, object, mode,
                        &base_index, &pool_number);
              break;
         case bcmStatObjectEgrVlan:
              rv = _bcm_esw_stat_flex_create_egress_table_counters(
                        unit, EGR_VLANm, FIRST_LKUP, object,mode,
                        &base_index,&pool_number);
              break;
         case bcmStatObjectEgrVlanXlate:
  #if defined (BCM_TRIDENT3_SUPPORT)
              if (SOC_IS_TRIDENT3X(unit)){
                  mem_tab = EGR_VLAN_XLATE_1_DOUBLEm;
              } else
  #endif
              {
                  mem_tab = EGR_VLAN_XLATEm;
              }
              rv = _bcm_esw_stat_flex_create_egress_table_counters(
                        unit, mem_tab, FIRST_LKUP, object, mode,
                        &base_index, &pool_number);
              break;
         case bcmStatObjectEgrVlanXlateSecondLookup:
#if defined(BCM_APACHE_SUPPORT) || defined(BCM_TRIDENT3_SUPPORT)
              if (soc_feature(unit, soc_feature_egr_vlan_xlate_second_lookup)) {
#if defined (BCM_TRIDENT3_SUPPORT)
                  if (SOC_IS_TRIDENT3X(unit)){
                      mem_tab = EGR_VLAN_XLATE_1_DOUBLEm;
                  } else
#endif
                  {
                      mem_tab = EGR_VLAN_XLATEm;
                  }
                  rv = _bcm_esw_stat_flex_create_egress_table_counters(
                          unit, mem_tab, SECOND_LKUP, object,mode,
                          &base_index,&pool_number);
              } else
#endif
              {
                  rv = BCM_E_PARAM;
              }
              break;
         case bcmStatObjectEgrVfi:
              rv = _bcm_esw_stat_flex_create_egress_table_counters(
                        unit, EGR_VFIm, FIRST_LKUP, object,mode,
                        &base_index,&pool_number);
              break;
         case bcmStatObjectEgrNiv:
         case bcmStatObjectEgrL3Intf:
              rv = _bcm_esw_stat_flex_create_egress_table_counters(
                        unit, EGR_L3_NEXT_HOPm, FIRST_LKUP, object,mode,
                        &base_index,&pool_number);
              break;
         case bcmStatObjectEgrWlan:
              rv = _bcm_esw_stat_flex_create_egress_table_counters(
                        unit, EGR_L3_NEXT_HOPm, FIRST_LKUP, object,mode,
                        &base_index,&pool_number);
              break;
         case bcmStatObjectEgrMim:
              rv = _bcm_esw_stat_flex_create_egress_table_counters(
                        unit, EGR_L3_NEXT_HOPm, FIRST_LKUP, object,mode,
                        &base_index,&pool_number);
              break;
         case bcmStatObjectEgrMimLookupId:
  #if defined (BCM_TRIDENT3_SUPPORT)
              if (SOC_IS_TRIDENT3X(unit)){
                  mem_tab = EGR_VLAN_XLATE_1_DOUBLEm;
              } else
  #endif
              {
                  mem_tab = EGR_VLAN_XLATEm;
              }
              rv = _bcm_esw_stat_flex_create_egress_table_counters(
                        unit, mem_tab, FIRST_LKUP, object, mode,
                        &base_index, &pool_number);
              break;
         case bcmStatObjectEgrL2Gre:
  #if defined (BCM_TRIDENT3_SUPPORT)
              if (SOC_IS_TRIDENT3X(unit)){
                  mem_tab = EGR_DVP_ATTRIBUTEm;
              } else
  #endif
              {
                  mem_tab = EGR_DVP_ATTRIBUTE_1m;
              }
              rv = _bcm_esw_stat_flex_create_egress_table_counters(
                        unit, mem_tab, FIRST_LKUP, object, mode,
                        &base_index, &pool_number);
              break;
         case bcmStatObjectEgrVxlan:
  #if defined (BCM_TRIDENT3_SUPPORT)
              if (SOC_IS_TRIDENT3X(unit)){
                  mem_tab = EGR_DVP_ATTRIBUTEm;
              } else
  #endif
              {
                  mem_tab = EGR_DVP_ATTRIBUTE_1m;
              }
              rv = _bcm_esw_stat_flex_create_egress_table_counters(
                        unit, mem_tab, FIRST_LKUP, object,mode,
                        &base_index, &pool_number);
              break;
         case bcmStatObjectEgrL3Nat:
              rv = _bcm_esw_stat_flex_create_egress_table_counters(
                        unit, EGR_NAT_PACKET_EDIT_INFOm, FIRST_LKUP, object,mode,
                        &base_index, &pool_number);
              break;
         case bcmStatObjectEgrFieldStageEgress:
              rv = _bcm_esw_stat_flex_create_egress_table_counters(
                        unit, EFP_POLICY_TABLEm, FIRST_LKUP, object,mode,
                        &base_index, &pool_number);
              break;
         case bcmStatObjectEgrMplsTunnelLabel:
              rv = _bcm_esw_stat_flex_create_egress_table_counters(
                        unit, EGR_IP_TUNNEL_MPLSm, FIRST_LKUP, object,mode,
                        &base_index, &pool_number);
              break;
         case bcmStatObjectEgrMplsTunnelSecondLabel:
#if defined(BCM_APACHE_SUPPORT)
              if (soc_feature(unit, soc_feature_multi_tunnel_label_count)) {
                  rv = _bcm_esw_stat_flex_create_egress_table_counters(
                          unit, EGR_IP_TUNNEL_MPLSm, SECOND_LKUP, object,mode,
                          &base_index, &pool_number);
              } else
#endif
              {
                  rv = BCM_E_PARAM;
              }
              break;
         default:
            switch ((int32)object) {
                case bcmIntStatObjectEgrLatencyMonitor0:
                    rv = _bcm_esw_stat_flex_create_egress_table_counters(
                            unit, EGR_HISTO_MON_0_Q_LATENCY_LIMIT_SELm, FIRST_LKUP, object,mode,
                            &base_index,&pool_number);
                    break;
                case bcmIntStatObjectEgrLatencyMonitor1:
                    rv = _bcm_esw_stat_flex_create_egress_table_counters(
                            unit, EGR_HISTO_MON_1_Q_LATENCY_LIMIT_SELm, FIRST_LKUP, object,mode,
                            &base_index,&pool_number);
                    break;
                case bcmIntStatObjectEgrLatencyMonitor2:
                    rv = _bcm_esw_stat_flex_create_egress_table_counters(
                            unit, EGR_HISTO_MON_2_Q_LATENCY_LIMIT_SELm, FIRST_LKUP, object,mode,
                            &base_index,&pool_number);
                    break;
                case bcmIntStatObjectEgrLatencyMonitor3:
                    rv = _bcm_esw_stat_flex_create_egress_table_counters(
                            unit, EGR_HISTO_MON_3_Q_LATENCY_LIMIT_SELm, FIRST_LKUP, object,mode,
                            &base_index,&pool_number);
                    break;
                default:
                    rv = BCM_E_PARAM;
                    break;             
            }

            if (BCM_SUCCESS(rv)) {
                 for (counter_index = 0;counter_index<BCM_STAT_FLEX_MAX_COUNTERS_PER_MODE;counter_index++) {
                     egr_attr->uncmprsd_attr_selectors.
                         offset_table_map[counter_index].offset = 0;
                     egr_attr->uncmprsd_attr_selectors.
                         offset_table_map[counter_index].count_enable = 1;
                 }
                rv = _bcm_esw_stat_flex_update_offset_table(unit, attr->direction=bcmStatFlexDirectionEgress,
                                                       EGR_FLEX_CTR_OFFSET_TABLE_0m+pool_number,
                                                       mode, BCM_STAT_FLEX_MAX_COUNTERS_PER_MODE,
                                                       egr_attr->uncmprsd_attr_selectors.offset_table_map);
            }
            break;
         }
    }
    /* Cleanup activity ... */
    sal_free(attr);
    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                  (BSL_META_U(unit,
                              "creation of counters failed..\n")));
    } else {
        _bcm_esw_stat_get_counter_id(unit, group_mode, object, mode,
                                     pool_number, base_index, stat_counter_id);
        LOG_DEBUG(BSL_LS_BCM_FLEXCTR,
                  (BSL_META_U(unit,
                              "Create: mode:%d group_mode:%d pool:%d object:%d"
                               " base:%d\n stat_counter_id:%d\n"),
                   mode, group_mode, pool_number, object, base_index,
                   *stat_counter_id));
#if defined(BCM_TRIDENT2_SUPPORT)
        if (SOC_IS_TRIDENT2X(unit) &&
            soc_feature(unit, soc_feature_advanced_flex_counter)) {
            _flex_stat_mode_base_map[unit][direction]
                              [pool_number][mode][base_index] = 1;
        }
#endif
        *num_entries = total_counters;
    }
    return rv;
}
/*
 * Function:
 *      _bcm_esw_stat_group_destroy
 * Description:
 *      Release HW counter resources as per given counter id and makes system 
 *      unavailable for any further stat collection action 
 * Parameters:
 *      unit            - (IN) unit number
 *      Stat_counter_id - (IN) Stat Counter Id
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 */
bcm_error_t _bcm_esw_stat_group_destroy(
            int	   unit,
            uint32 stat_counter_id)
{
    bcm_error_t               rv=BCM_E_NONE;
    uint32                    pool_number=0;
    uint32                    base_index=0;
    bcm_stat_flex_mode_t      offset_mode=0;
    bcm_stat_object_t         object=bcmStatObjectIngPort;
    bcm_stat_group_mode_t     group_mode= bcmStatGroupModeSingle;
    bcm_stat_flex_direction_t direction=bcmStatFlexDirectionIngress;
    soc_mem_t                 ingress_table;
    soc_mem_t                 mem_tab;
    uint32 max_mode = BCM_STAT_FLEX_CUSTOM_INGRESS_COUNTER_MAX_MODE;

#ifdef BCM_TOMAHAWK_SUPPORT
    bcm_field_qualify_t       field_stage;
    if (SOC_IS_TOMAHAWKX(unit) || SOC_IS_TRIDENT3X(unit)) {
        if ((stat_counter_id > BCM_MAX_STAT_COUNTER_IDS) ||
            (stat_counter_id <= 0)) {
            return BCM_E_PARAM;
        } else if (stat_counter_map[unit][stat_counter_id].used == 0) {
            return BCM_E_NOT_FOUND;
        }
    }
#endif
#ifdef BCM_TRIDENT3_SUPPORT
    if (SOC_IS_TRIDENT3X(unit)) {
        max_mode = BCM_STAT_FLEX_CUSTOM_EGRESS_COUNTER_MAX_MODE;
    }
#endif

    if (!soc_feature(unit,soc_feature_advanced_flex_counter)) {
         return BCM_E_UNAVAIL;
    }
    _bcm_esw_stat_get_counter_id_info(unit, stat_counter_id,&group_mode,&object, 
                                      &offset_mode,&pool_number,&base_index);
    LOG_DEBUG(BSL_LS_BCM_FLEXCTR,
              (BSL_META_U(unit,
                          "Deleting : mode:%d group_mode:%d pool:%d object:%d"
                          "base:%d\n stat_counter_id:%d\n"),offset_mode,group_mode,
                          pool_number,object,base_index,stat_counter_id));

    BCM_IF_ERROR_RETURN(_bcm_esw_stat_validate_object(unit,object,&direction));
    BCM_IF_ERROR_RETURN(_bcm_esw_stat_validate_group(unit,group_mode));

    if (offset_mode > (BCM_STAT_FLEX_COUNTER_MAX_MODE-1)) {
        if ((SOC_IS_TOMAHAWKX(unit)  || SOC_IS_TRIDENT3X(unit)) &&
            (offset_mode > max_mode)) {
            LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                      (BSL_META_U(unit,
                              "Invalid flex counter mode value %d \n"),
                              offset_mode));
           return BCM_E_PARAM;
        } else if (!(SOC_IS_TOMAHAWKX(unit)  || SOC_IS_TRIDENT3X(unit))){
           return BCM_E_PARAM;
        }
    }
    switch((int32)object) {
         /* Ingress Side */
         case bcmStatObjectIngPort:
 #if defined (BCM_TRIDENT3_SUPPORT)
             if (SOC_IS_TRIDENT3X(unit)){
                 mem_tab = LPORT_TABm;
             } else
 #endif
             {
                 mem_tab = PORT_TABm;
             }
              rv = _bcm_esw_stat_flex_destroy_ingress_table_counters(
                        unit, mem_tab, FIRST_LKUP, object, offset_mode,
                        base_index, pool_number);
              break;
         case bcmStatObjectIngVlan:
              rv = _bcm_esw_stat_flex_destroy_ingress_table_counters(
                        unit, VLAN_TABm, FIRST_LKUP, object,offset_mode,
                        base_index,pool_number);
              break;
         case bcmStatObjectIngVlanXlate:
#if defined (BCM_TRIDENT3_SUPPORT)
             if (SOC_IS_TRIDENT3X(unit)){
                 mem_tab = VLAN_XLATE_1_DOUBLEm;
             } else
 #endif
             {
                 mem_tab = VLAN_XLATEm;
             }
              rv = _bcm_esw_stat_flex_destroy_ingress_table_counters(
                        unit, mem_tab, FIRST_LKUP, object, offset_mode,
                        base_index, pool_number);
              break;
         case bcmStatObjectIngVlanXlateSecondLookup:
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
              if (soc_feature(unit,soc_feature_ing_vlan_xlate_second_lookup)) {
#if defined (BCM_TRIDENT3_SUPPORT)
                  if (SOC_IS_TRIDENT3X(unit)){
                      mem_tab = VLAN_XLATE_1_DOUBLEm;
                  } else
#endif
                  {
                      mem_tab = VLAN_XLATEm;
                  }
                  rv = _bcm_esw_stat_flex_destroy_ingress_table_counters(
                          unit, mem_tab, SECOND_LKUP, object,offset_mode,
                          base_index,pool_number);
              } else
#endif
              {
                  rv = BCM_E_PARAM;
              }
              break;
         case bcmStatObjectIngVfi:
              rv = _bcm_esw_stat_flex_destroy_ingress_table_counters(
                        unit, VFIm, FIRST_LKUP, object,offset_mode,
                        base_index,pool_number);
              break;
         case bcmStatObjectIngL3Intf:
              rv = _bcm_esw_stat_flex_destroy_ingress_table_counters(
                        unit, L3_IIFm, FIRST_LKUP, object,offset_mode,
                        base_index,pool_number);
              break;
         case bcmStatObjectIngVrf:
#if defined (BCM_TRIDENT3_SUPPORT)
              if (SOC_IS_TRIDENT3X(unit)){
                  mem_tab = VRF_ATTRS_2m;
              } else
#endif
              {
                  mem_tab = VRFm;
              }
              rv = _bcm_esw_stat_flex_destroy_ingress_table_counters(
                        unit, mem_tab, FIRST_LKUP, object,offset_mode,
                        base_index,pool_number);
              break;
         case bcmStatObjectIngPolicy:
              ingress_table = VFP_POLICY_TABLEm;
#ifdef BCM_TOMAHAWK_SUPPORT
              if (soc_feature(unit,soc_feature_stat_multi_pipe_support)) {
                  int pipe_num = 0;
                  if (!_bcm_esw_get_fp_mode_global(unit, bcmFieldQualifyStageLookup) &&
                      (offset_mode < BCM_STAT_FLEX_CUSTOM_INGRESS_COUNTER_MAX_MODE) &&
                      (offset_mode >= BCM_CUSTOM_INGRESS_MODE_START)) {
                      _bcm_esw_get_fp_pipe_from_mode(unit, offset_mode,
                                       bcmFieldQualifyStageLookup, &pipe_num);
                      _bcm_esw_get_ingress_vfp_table_from_pipe(pipe_num, &ingress_table);
                      if (BCM_FAILURE(rv)) {
                          LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                                    (BSL_META_U(unit,
                                      "cannot get pipe info %d.\n"), pipe_num));
                      }
                  }
              }
#endif
              rv = _bcm_esw_stat_flex_destroy_ingress_table_counters(
                        unit, ingress_table, FIRST_LKUP, object,offset_mode,
                        base_index,pool_number);
              break;
         case bcmStatObjectIngNiv:
         case bcmStatObjectIngMplsVcLabel:
         case bcmStatObjectIngGport:
              rv = _bcm_esw_stat_flex_destroy_ingress_table_counters(
                        unit, SOURCE_VPm, FIRST_LKUP, object,offset_mode,
                        base_index,pool_number);
              break;
         case bcmStatObjectIngMplsSwitchLabel:
              rv = _bcm_esw_stat_flex_destroy_ingress_table_counters(
                        unit, MPLS_ENTRYm, FIRST_LKUP, object, offset_mode,
                        base_index, pool_number);
              break;
         case bcmStatObjectIngMplsSwitchSecondLabel:
#if defined(BCM_APACHE_SUPPORT)
              if (soc_feature(unit,
                      soc_feature_mpls_entry_second_label_lookup)) {
                  rv = _bcm_esw_stat_flex_destroy_ingress_table_counters(
                          unit, MPLS_ENTRYm, SECOND_LKUP, object,offset_mode,
                          base_index,pool_number);
              } else
#endif
              {
                  rv = BCM_E_PARAM;
              }
              break;
         case bcmStatObjectIngMplsFrrLabel:
              rv = _bcm_esw_stat_flex_destroy_ingress_table_counters(
                        unit, L3_TUNNELm, FIRST_LKUP, object,offset_mode,
                        base_index,pool_number);
              break;
         case bcmStatObjectIngL3Host:
              rv = _bcm_esw_stat_flex_destroy_ingress_table_counters(
                        unit, EXT_IPV4_UCAST_WIDEm, FIRST_LKUP, object,offset_mode,
                        base_index,pool_number);
              break;
         case bcmStatObjectIngTrill:
              rv = _bcm_esw_stat_flex_destroy_ingress_table_counters(
                        unit, MPLS_ENTRY_EXTDm, FIRST_LKUP, object,offset_mode,
                        base_index,pool_number);
              break;
         case bcmStatObjectIngMimLookupId:
              rv = _bcm_esw_stat_flex_destroy_ingress_table_counters(
                        unit, MPLS_ENTRY_EXTDm, FIRST_LKUP, object,offset_mode,
                        base_index,pool_number);
              break;
         case bcmStatObjectIngL2Gre:
              /* To Be Completed..SOURCE_VPm, VLAN_XLATE_1m L2GRE_DIP view */
  #if defined (BCM_TRIDENT3_SUPPORT)
              if (SOC_IS_TRIDENT3X(unit)){
                  mem_tab = VLAN_XLATE_1_DOUBLEm;
              } else
  #endif
              {
                  mem_tab = VLAN_XLATEm;
              }
              rv = _bcm_esw_stat_flex_destroy_ingress_table_counters(
                        unit, mem_tab, FIRST_LKUP, object, offset_mode,
                        base_index, pool_number);
              break;
         case bcmStatObjectIngEXTPolicy:
              rv = _bcm_esw_stat_flex_destroy_ingress_table_counters(
                        unit, EXT_FP_POLICYm, FIRST_LKUP, object, offset_mode,
                        base_index, pool_number);
              break;
         case bcmStatObjectIngVxlan:
              rv = _bcm_esw_stat_flex_destroy_ingress_table_counters(
                        unit, SOURCE_VPm, FIRST_LKUP, object, offset_mode,
                        base_index, pool_number);
              break;
         case bcmStatObjectIngVsan:
              rv = _bcm_esw_stat_flex_destroy_ingress_table_counters(
                        unit, ING_VSANm, FIRST_LKUP, object,offset_mode,
                        base_index, pool_number);
              break;
         case bcmStatObjectIngFcoe:
  #if defined (BCM_TRIDENT3_SUPPORT)
              if (SOC_IS_TRIDENT3X(unit)){
                  mem_tab = L3_ENTRY_DOUBLEm;
              } else
  #endif
              {
                  mem_tab = L3_ENTRY_IPV4_MULTICASTm;
              }
              rv = _bcm_esw_stat_flex_destroy_ingress_table_counters(
                        unit, mem_tab, FIRST_LKUP, object, offset_mode,
                        base_index, pool_number);
              break;
         case bcmStatObjectIngL3Route:
              rv = _bcm_esw_stat_flex_destroy_ingress_table_counters(
                        unit, L3_DEFIPm, FIRST_LKUP, object, offset_mode,
                        base_index, pool_number);
              break;
         case bcmStatObjectIngIpmc:
  #if defined (BCM_TRIDENT3_SUPPORT)
              if (SOC_IS_TRIDENT3X(unit)){
                  mem_tab = L3_ENTRY_DOUBLEm;
              } else
  #endif
              {
                  mem_tab = L3_ENTRY_IPV4_MULTICASTm;
              }
              rv = _bcm_esw_stat_flex_destroy_ingress_table_counters(
                        unit, mem_tab, FIRST_LKUP, object, offset_mode,
                        base_index, pool_number);
              break;
         case bcmStatObjectIngVxlanDip:
  #if defined (BCM_TRIDENT3_SUPPORT)
              if (SOC_IS_TRIDENT3X(unit)){
                  mem_tab = VLAN_XLATE_1_DOUBLEm;
              } else
  #endif
              {
                  mem_tab = VLAN_XLATEm;
              }
              rv = _bcm_esw_stat_flex_destroy_ingress_table_counters(
                        unit, mem_tab, FIRST_LKUP, object, offset_mode,
                        base_index, pool_number);
              break;
         case bcmStatObjectIngExactMatch:
         case bcmStatObjectIngFieldStageIngress:
              if (object == bcmStatObjectIngFieldStageIngress) {
                  ingress_table = IFP_POLICY_TABLEm;
              } else {
                  ingress_table = EXACT_MATCH_2m;
              }
#ifdef BCM_TOMAHAWK_SUPPORT
             if (soc_feature(unit,soc_feature_stat_multi_pipe_support)) {
                 int pipe_num = 0;
                 field_stage = _bcm_esw_stat_get_field_stage_from_table(ingress_table);
                 if (!_bcm_esw_get_fp_mode_global(unit, bcmFieldQualifyStageIngress) && 
                     (offset_mode < BCM_STAT_FLEX_CUSTOM_INGRESS_COUNTER_MAX_MODE) &&
                     (offset_mode >= BCM_CUSTOM_INGRESS_MODE_START)) {
                     _bcm_esw_get_fp_pipe_from_mode(unit, offset_mode, 
                                         field_stage, &pipe_num);
                     if (pipe_num >= 0) {
                        _bcm_esw_get_ingress_ifp_table_from_pipe(pipe_num, &ingress_table);
                        if (BCM_FAILURE(rv)) {
                            LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                                      (BSL_META_U(unit,
                                        "cannot get pipe info %d.\n"), pipe_num));
                        }
                     }
                 }
             }
#endif
             rv = _bcm_esw_stat_flex_destroy_ingress_table_counters(
                       unit, ingress_table, FIRST_LKUP, object, offset_mode,
                       base_index, pool_number);
             break;
         case bcmIntStatObjectIngAgm:
              rv = _bcm_esw_stat_flex_destroy_ingress_table_counters(
                        unit, AGM_MONITOR_TABLEm, FIRST_LKUP, object, offset_mode,
                        base_index, pool_number);
              break;
         case bcmIntStatObjectIngAgmSecondLookup:
              rv = _bcm_esw_stat_flex_destroy_ingress_table_counters(
                        unit, AGM_MONITOR_TABLEm, SECOND_LKUP, object, offset_mode,
                        base_index, pool_number);
              break;

         /* Egress Side */
         case bcmStatObjectEgrPort:
  #if defined (BCM_TRIDENT3_SUPPORT)
              if (SOC_IS_TRIDENT3X(unit)){
                  mem_tab = EGR_LPORT_PROFILEm;
              } else
  #endif
              {
                  mem_tab = EGR_PORTm;
              }
              rv = _bcm_esw_stat_flex_destroy_egress_table_counters(
                        unit, mem_tab, FIRST_LKUP, object, offset_mode,
                        base_index, pool_number);
              break;
         case bcmStatObjectEgrVlan:
              rv = _bcm_esw_stat_flex_destroy_egress_table_counters(
                        unit, EGR_VLANm, FIRST_LKUP, object,offset_mode,
                        base_index,pool_number);
              break;
         case bcmStatObjectEgrVlanXlate:
  #if defined (BCM_TRIDENT3_SUPPORT)
              if (SOC_IS_TRIDENT3X(unit)){
                  mem_tab = EGR_VLAN_XLATE_1_DOUBLEm;
              } else
  #endif
              {
                  mem_tab = EGR_VLAN_XLATEm;
              }
              rv = _bcm_esw_stat_flex_destroy_egress_table_counters(
                        unit, mem_tab, FIRST_LKUP, object, offset_mode,
                        base_index, pool_number);
              break;
         case bcmStatObjectEgrVlanXlateSecondLookup:
#if defined(BCM_APACHE_SUPPORT) || defined (BCM_TRIDENT3_SUPPORT)
              if (soc_feature(unit, soc_feature_egr_vlan_xlate_second_lookup)) {
#if defined (BCM_TRIDENT3_SUPPORT)
                  if (SOC_IS_TRIDENT3X(unit)){
                      mem_tab = EGR_VLAN_XLATE_1_DOUBLEm;
                  } else
#endif
                  {
                      mem_tab = EGR_VLAN_XLATEm;
                  }
                  rv = _bcm_esw_stat_flex_destroy_egress_table_counters(
                          unit, mem_tab, SECOND_LKUP, object,offset_mode,
                          base_index,pool_number);
              } else
#endif
              {
                  rv = BCM_E_PARAM;
              }
              break;
         case bcmStatObjectEgrVfi:
              rv = _bcm_esw_stat_flex_destroy_egress_table_counters(
                        unit, EGR_VFIm, FIRST_LKUP, object,offset_mode,
                        base_index,pool_number);
              break;
         case bcmStatObjectEgrNiv:
         case bcmStatObjectEgrL3Intf:
              rv = _bcm_esw_stat_flex_destroy_egress_table_counters(
                        unit, EGR_L3_NEXT_HOPm, FIRST_LKUP, object,offset_mode,
                        base_index,pool_number);
              break;
         case bcmStatObjectEgrWlan:
              rv = _bcm_esw_stat_flex_destroy_egress_table_counters(
                        unit, EGR_L3_NEXT_HOPm, FIRST_LKUP, object,offset_mode,
                        base_index,pool_number);
              break;
         case bcmStatObjectEgrMim:
              rv = _bcm_esw_stat_flex_destroy_egress_table_counters(
                        unit, EGR_L3_NEXT_HOPm, FIRST_LKUP, object,offset_mode,
                        base_index,pool_number);
              break;
         case bcmStatObjectEgrMimLookupId:
  #if defined (BCM_TRIDENT3_SUPPORT)
              if (SOC_IS_TRIDENT3X(unit)){
                  mem_tab = EGR_VLAN_XLATE_1_DOUBLEm;
              } else
  #endif
              {
                  mem_tab = EGR_VLAN_XLATEm;
              }
              rv = _bcm_esw_stat_flex_destroy_egress_table_counters(
                        unit, mem_tab, FIRST_LKUP, object, offset_mode,
                        base_index, pool_number);
              break;
         case bcmStatObjectEgrL2Gre:
  #if defined (BCM_TRIDENT3_SUPPORT)
              if (SOC_IS_TRIDENT3X(unit)){
                  mem_tab = EGR_DVP_ATTRIBUTEm;
              } else
  #endif
              {
                  mem_tab = EGR_DVP_ATTRIBUTE_1m;
              }
              rv = _bcm_esw_stat_flex_destroy_egress_table_counters(
                        unit, mem_tab, FIRST_LKUP, object, offset_mode,
                        base_index, pool_number);
              break;
         case bcmStatObjectEgrVxlan:
  #if defined (BCM_TRIDENT3_SUPPORT)
              if (SOC_IS_TRIDENT3X(unit)){
                  mem_tab = EGR_DVP_ATTRIBUTEm;
              } else
  #endif
              {
                  mem_tab = EGR_DVP_ATTRIBUTE_1m;
              }
              rv = _bcm_esw_stat_flex_destroy_egress_table_counters(
                        unit, mem_tab, FIRST_LKUP, object, offset_mode,
                        base_index, pool_number);
              break;
         case bcmStatObjectEgrL3Nat:
              rv = _bcm_esw_stat_flex_destroy_egress_table_counters(
                        unit, EGR_NAT_PACKET_EDIT_INFOm, FIRST_LKUP, object, offset_mode,
                        base_index, pool_number);
              break;
         case bcmStatObjectEgrFieldStageEgress:
              mem_tab = EFP_POLICY_TABLEm;
#ifdef BCM_TRIDENT3_SUPPORT
              if (soc_feature(unit,soc_feature_stat_egr_multi_pipe_support)) {
                  int pipe_num = 0;
                  field_stage = _bcm_esw_stat_get_field_stage_from_table(mem_tab);
                  if (!_bcm_esw_get_fp_mode_global(unit, bcmFieldQualifyStageEgress) &&
                      (offset_mode < BCM_STAT_FLEX_CUSTOM_EGRESS_COUNTER_MAX_MODE) &&
                      (offset_mode >= BCM_CUSTOM_EGRESS_MODE_START)) {
                      _bcm_esw_get_fp_pipe_from_mode(unit, offset_mode,
                                          field_stage, &pipe_num);
                      if (pipe_num >= 0) {
                         _bcm_esw_get_egr_fp_table_from_pipe(pipe_num, &mem_tab);
                      }
                  }
              }
#endif
              rv = _bcm_esw_stat_flex_destroy_egress_table_counters(
                        unit, mem_tab, FIRST_LKUP, object, offset_mode,
                        base_index, pool_number);
              break;
         case bcmStatObjectEgrMplsTunnelLabel:
              rv = _bcm_esw_stat_flex_destroy_egress_table_counters(
                        unit, EGR_IP_TUNNEL_MPLSm, FIRST_LKUP, object, offset_mode,
                        base_index, pool_number);
              break;
         case bcmStatObjectEgrMplsTunnelSecondLabel:
#if defined(BCM_APACHE_SUPPORT)
              if (soc_feature(unit, soc_feature_multi_tunnel_label_count)) {
                  rv = _bcm_esw_stat_flex_destroy_egress_table_counters(
                          unit, EGR_IP_TUNNEL_MPLSm, SECOND_LKUP, object, offset_mode,
                          base_index, pool_number);
              } else
#endif
              {
                  rv = BCM_E_PARAM;
              }
         break;
         default:
              switch((int32)object) {
              case bcmIntStatObjectEgrLatencyMonitor0:
                 rv = _bcm_esw_stat_flex_destroy_egress_table_counters(
                        unit, EGR_HISTO_MON_0_Q_LATENCY_LIMIT_SELm, FIRST_LKUP, object, offset_mode,
                        base_index, pool_number);
                 break;
              case bcmIntStatObjectEgrLatencyMonitor1:
                 rv = _bcm_esw_stat_flex_destroy_egress_table_counters(
                        unit, EGR_HISTO_MON_1_Q_LATENCY_LIMIT_SELm, FIRST_LKUP, object, offset_mode,
                        base_index, pool_number);
                 break;
              case bcmIntStatObjectEgrLatencyMonitor2:
                 rv = _bcm_esw_stat_flex_destroy_egress_table_counters(
                        unit, EGR_HISTO_MON_2_Q_LATENCY_LIMIT_SELm, FIRST_LKUP, object, offset_mode,
                        base_index, pool_number);
                 break;
              case bcmIntStatObjectEgrLatencyMonitor3:
                 rv = _bcm_esw_stat_flex_destroy_egress_table_counters(
                        unit, EGR_HISTO_MON_3_Q_LATENCY_LIMIT_SELm, FIRST_LKUP, object, offset_mode,
                        base_index, pool_number);
                 break;
              default:
                 rv = BCM_E_PARAM;
                 break; 
              }  
              break;
    }
    if (BCM_SUCCESS(rv)) {
#if defined(BCM_TRIDENT2_SUPPORT)
        if (SOC_IS_TRIDENT2X(unit) &&
            soc_feature(unit, soc_feature_advanced_flex_counter)) {
            _flex_stat_mode_base_map[unit][direction]
                              [pool_number][offset_mode][base_index] = 0;
        }
#endif
        LOG_DEBUG(BSL_LS_BCM_FLEXCTR,
                  (BSL_META_U(unit,
                              "Destroyed %s table counters.."
                               "Trying to delete group mode itself \n"),
                               bcmStatFlexDirectionIngress == direction ?
                               "ingress" : "egress"));
        /* No decision on return values as actual call is successful */
        if (direction == bcmStatFlexDirectionIngress) {
            if ((offset_mode < BCM_STAT_FLEX_CUSTOM_INGRESS_COUNTER_MAX_MODE) &&
                (offset_mode >= BCM_CUSTOM_INGRESS_MODE_START)) {
                _bcm_esw_stat_group_mode_id_destroy(unit, offset_mode);
            } else if (group_mode < bcmStatGroupModeCount) {

                 /* For Adjustable mode counters, mode id is deleted when an
                  * explicit call is made.
                  * Do not delete mode used by flowtracker.
                  */
                 if (
#if defined (BCM_TOMAHAWK_SUPPORT) && defined (INCLUDE_FLOWTRACKER)
                 (!( soc_feature(unit, soc_feature_uc_flowtracker_learn) &&
                     soc_feature(unit, soc_feature_uc_flowtracker_export)
                     && _bcm_esw_stat_mod_reserved(unit, offset_mode))) &&
#endif
                     ( _bcm_esw_stat_flex_delete_ingress_mode(
                       unit,offset_mode) == BCM_E_NONE)
                 ) {
                     LOG_DEBUG(BSL_LS_BCM_FLEXCTR,
                          (BSL_META_U(unit,
                                      "Destroyed Ingress Mode also \n")));
                     _bcm_esw_stat_flex_reset_group_mode(
                                    unit,bcmStatFlexDirectionIngress,
                                    offset_mode,group_mode);
                 }
            }
#ifdef BCM_TOMAHAWK_SUPPORT
            if (SOC_IS_TOMAHAWKX(unit) ||SOC_IS_TRIDENT3X(unit)) {
                if((stat_counter_map[unit]) != NULL) {
                    stat_counter_map[unit][stat_counter_id].used = 0;
#if 0
                    sal_free(stat_counter_map[unit][stat_counter_id]);
                    stat_counter_map[unit][stat_counter_id] = NULL;
#endif
                }
            }
#endif
       } else {
            if ((offset_mode < BCM_STAT_FLEX_CUSTOM_EGRESS_COUNTER_MAX_MODE) &&
                (offset_mode >= BCM_CUSTOM_EGRESS_MODE_START)) {
                _bcm_esw_stat_group_mode_id_destroy(unit, offset_mode);
            } else if (group_mode < bcmStatGroupModeCount) {
                if (_bcm_esw_stat_flex_delete_egress_mode(
                        unit,offset_mode) == BCM_E_NONE) {
                    LOG_DEBUG(BSL_LS_BCM_FLEXCTR,
                        (BSL_META_U(unit,
                                    "Destroyed Egress Mode also \n")));
                    _bcm_esw_stat_flex_reset_group_mode(
                                    unit,bcmStatFlexDirectionEgress,
                                    offset_mode,group_mode);
                }
            }
#ifdef BCM_TRIDENT3_SUPPORT
            if (SOC_IS_TRIDENT3X(unit)) {
                if((stat_counter_map[unit]) != NULL) {
                    stat_counter_map[unit][stat_counter_id].used = 0;
                }
            }
#endif
        }
    }

    return rv;
}
/*
 * Function:
 *      _bcm_esw_stat_flex_init_pkt_attr_bits
 * Description:
 *      Initialize All Packet attr bits.
 *      
 * Parameters:
 *      unit            - (IN) unit number
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 */
void _bcm_esw_stat_flex_init_pkt_attr_bits(int unit)
{
    int offset_adj = 0;

    if (SOC_IS_TD2_TT2(unit)) {
       int next_pos = 0;

       /* Egress bits initialization */
       egr_pkt_attr_uncmprsd_bits_g[unit].ip_pkt = 1;
       egr_pkt_attr_uncmprsd_bits_g[unit].ip_pkt_pos = next_pos;
       egr_pkt_attr_uncmprsd_bits_g[unit].ip_pkt_mask = 
                           (1<<egr_pkt_attr_uncmprsd_bits_g[unit].ip_pkt) - 1;
       next_pos += egr_pkt_attr_uncmprsd_bits_g[unit].ip_pkt;

       egr_pkt_attr_uncmprsd_bits_g[unit].drop = 1;
       egr_pkt_attr_uncmprsd_bits_g[unit].drop_pos = next_pos;
       egr_pkt_attr_uncmprsd_bits_g[unit].drop_mask = 
                           (1<<egr_pkt_attr_uncmprsd_bits_g[unit].drop) - 1;
       next_pos += egr_pkt_attr_uncmprsd_bits_g[unit].drop;

       egr_pkt_attr_uncmprsd_bits_g[unit].dvp_type =
           (soc_feature(unit, soc_feature_multiple_split_horizon_group)) ? 3 : 1;
       egr_pkt_attr_uncmprsd_bits_g[unit].dvp_type_pos = next_pos;
       egr_pkt_attr_uncmprsd_bits_g[unit].dvp_type_mask = 
                           (1<<egr_pkt_attr_uncmprsd_bits_g[unit].dvp_type) - 1;
       next_pos += egr_pkt_attr_uncmprsd_bits_g[unit].dvp_type;

        egr_pkt_attr_uncmprsd_bits_g[unit].svp_type =
           (soc_feature(unit, soc_feature_multiple_split_horizon_group)) ? 3 : 1;
       egr_pkt_attr_uncmprsd_bits_g[unit].svp_type_pos = next_pos;
       egr_pkt_attr_uncmprsd_bits_g[unit].svp_type_mask = 
                           (1<<egr_pkt_attr_uncmprsd_bits_g[unit].svp_type) - 1;
       next_pos += egr_pkt_attr_uncmprsd_bits_g[unit].svp_type;

       egr_pkt_attr_uncmprsd_bits_g[unit].pkt_resolution = 1;
       egr_pkt_attr_uncmprsd_bits_g[unit].pkt_resolution_pos = next_pos;
       egr_pkt_attr_uncmprsd_bits_g[unit].pkt_resolution_mask = 
                           (1<<egr_pkt_attr_uncmprsd_bits_g[unit].pkt_resolution) - 1;
       next_pos += egr_pkt_attr_uncmprsd_bits_g[unit].pkt_resolution;

       egr_pkt_attr_uncmprsd_bits_g[unit].tos_ecn = 2;
       egr_pkt_attr_uncmprsd_bits_g[unit].tos_ecn_pos = next_pos;
       egr_pkt_attr_uncmprsd_bits_g[unit].tos_ecn_mask = 
                           (1<<egr_pkt_attr_uncmprsd_bits_g[unit].tos_ecn) - 1;
       next_pos += egr_pkt_attr_uncmprsd_bits_g[unit].tos_ecn;

       egr_pkt_attr_uncmprsd_bits_g[unit].tos_dscp = 6;
       egr_pkt_attr_uncmprsd_bits_g[unit].tos_dscp_pos = next_pos;
       egr_pkt_attr_uncmprsd_bits_g[unit].tos_dscp_mask = 
                           (1<<egr_pkt_attr_uncmprsd_bits_g[unit].tos_dscp) - 1;
       next_pos += egr_pkt_attr_uncmprsd_bits_g[unit].tos_dscp;

       if (SOC_IS_TOMAHAWKX(unit) || SOC_IS_TRIDENT3X(unit)) {
           egr_pkt_attr_uncmprsd_bits_g[unit].egr_port = 8; /* For TH, TD3 8 bits */
       } else {
           egr_pkt_attr_uncmprsd_bits_g[unit].egr_port = 7; /* For KT2,TR3 6 bits */
       }
       egr_pkt_attr_uncmprsd_bits_g[unit].egr_port_pos = next_pos;
       egr_pkt_attr_uncmprsd_bits_g[unit].egr_port_mask = 
                           (1<<egr_pkt_attr_uncmprsd_bits_g[unit].egr_port) - 1;
       next_pos += egr_pkt_attr_uncmprsd_bits_g[unit].egr_port;

       egr_pkt_attr_uncmprsd_bits_g[unit].inner_dot1p = 3;
       egr_pkt_attr_uncmprsd_bits_g[unit].inner_dot1p_pos = next_pos;
       egr_pkt_attr_uncmprsd_bits_g[unit].inner_dot1p_mask = 
                           (1<<egr_pkt_attr_uncmprsd_bits_g[unit].inner_dot1p) - 1;
       next_pos += egr_pkt_attr_uncmprsd_bits_g[unit].inner_dot1p;

       egr_pkt_attr_uncmprsd_bits_g[unit].outer_dot1p = 3;
       egr_pkt_attr_uncmprsd_bits_g[unit].outer_dot1p_pos = next_pos;
       egr_pkt_attr_uncmprsd_bits_g[unit].outer_dot1p_mask = 
                           (1<<egr_pkt_attr_uncmprsd_bits_g[unit].outer_dot1p) - 1;
       next_pos += egr_pkt_attr_uncmprsd_bits_g[unit].outer_dot1p;

       egr_pkt_attr_uncmprsd_bits_g[unit].vlan_format = 2;
       egr_pkt_attr_uncmprsd_bits_g[unit].vlan_format_pos = next_pos;
       egr_pkt_attr_uncmprsd_bits_g[unit].vlan_format_mask = 
                           (1<<egr_pkt_attr_uncmprsd_bits_g[unit].vlan_format) - 1;
       next_pos += egr_pkt_attr_uncmprsd_bits_g[unit].vlan_format;

       egr_pkt_attr_uncmprsd_bits_g[unit].int_pri = 4;
       egr_pkt_attr_uncmprsd_bits_g[unit].int_pri_pos = next_pos;
       egr_pkt_attr_uncmprsd_bits_g[unit].int_pri_mask = 
                           (1 << egr_pkt_attr_uncmprsd_bits_g[unit].int_pri) - 1;
       next_pos += egr_pkt_attr_uncmprsd_bits_g[unit].int_pri;

       egr_pkt_attr_uncmprsd_bits_g[unit].cng = 2;
       egr_pkt_attr_uncmprsd_bits_g[unit].cng_pos = next_pos;
       egr_pkt_attr_uncmprsd_bits_g[unit].cng_mask = (1 << egr_pkt_attr_uncmprsd_bits_g[unit].cng) - 1;
#ifdef BCM_APACHE_SUPPORT
       /* Added support for 3 Label Mpls Attr Counting */
       if (soc_feature(unit,soc_feature_flex_ctr_mpls_3_label_count)) {
           next_pos += egr_pkt_attr_uncmprsd_bits_g[unit].cng;

           egr_pkt_attr_uncmprsd_bits_g[unit].phb_1 = 4;
           egr_pkt_attr_uncmprsd_bits_g[unit].phb_1_pos = next_pos;
           egr_pkt_attr_uncmprsd_bits_g[unit].phb_1_mask =
               (1 << egr_pkt_attr_uncmprsd_bits_g[unit].phb_1) - 1;
           next_pos += egr_pkt_attr_uncmprsd_bits_g[unit].phb_1;

           egr_pkt_attr_uncmprsd_bits_g[unit].cng_1 = 2;
           egr_pkt_attr_uncmprsd_bits_g[unit].cng_1_pos = next_pos;
           egr_pkt_attr_uncmprsd_bits_g[unit].cng_1_mask =
               (1 << egr_pkt_attr_uncmprsd_bits_g[unit].cng_1) - 1;
           next_pos += egr_pkt_attr_uncmprsd_bits_g[unit].cng_1;

           egr_pkt_attr_uncmprsd_bits_g[unit].phb_2 = 4;
           egr_pkt_attr_uncmprsd_bits_g[unit].phb_2_pos = next_pos;
           egr_pkt_attr_uncmprsd_bits_g[unit].phb_2_mask =
               (1 << egr_pkt_attr_uncmprsd_bits_g[unit].phb_2) - 1;
           next_pos += egr_pkt_attr_uncmprsd_bits_g[unit].phb_2;

           egr_pkt_attr_uncmprsd_bits_g[unit].cng_2 = 2;
           egr_pkt_attr_uncmprsd_bits_g[unit].cng_2_pos = next_pos;
           egr_pkt_attr_uncmprsd_bits_g[unit].cng_2_mask =
               (1 << egr_pkt_attr_uncmprsd_bits_g[unit].cng_2) - 1;
           next_pos += egr_pkt_attr_uncmprsd_bits_g[unit].cng_2;

           egr_pkt_attr_uncmprsd_bits_g[unit].phb_3 = 4;
           egr_pkt_attr_uncmprsd_bits_g[unit].phb_3_pos = next_pos;
           egr_pkt_attr_uncmprsd_bits_g[unit].phb_3_mask =
               (1 << egr_pkt_attr_uncmprsd_bits_g[unit].phb_3) - 1;
           next_pos += egr_pkt_attr_uncmprsd_bits_g[unit].phb_3;

           egr_pkt_attr_uncmprsd_bits_g[unit].cng_3 = 2;
           egr_pkt_attr_uncmprsd_bits_g[unit].cng_3_pos = next_pos;
           egr_pkt_attr_uncmprsd_bits_g[unit].cng_3_mask =
               (1 << egr_pkt_attr_uncmprsd_bits_g[unit].cng_3) - 1;
       }
#endif
#if defined(BCM_TOMAHAWK_SUPPORT) || defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_flex_stat_egr_queue_congestion_marked)) {
        next_pos += egr_pkt_attr_uncmprsd_bits_g[unit].cng;

        egr_pkt_attr_uncmprsd_bits_g[unit].congestion_marked = 1;
        egr_pkt_attr_uncmprsd_bits_g[unit].congestion_marked_pos = next_pos;
        egr_pkt_attr_uncmprsd_bits_g[unit].congestion_marked_mask =
            (1 << egr_pkt_attr_uncmprsd_bits_g[unit].congestion_marked) - 1;
        next_pos += egr_pkt_attr_uncmprsd_bits_g[unit].congestion_marked;

        egr_pkt_attr_uncmprsd_bits_g[unit].uc_queueing = 1;
        egr_pkt_attr_uncmprsd_bits_g[unit].uc_queueing_pos = next_pos;
        egr_pkt_attr_uncmprsd_bits_g[unit].uc_queueing_mask =
            (1 << egr_pkt_attr_uncmprsd_bits_g[unit].uc_queueing) - 1;
        next_pos += egr_pkt_attr_uncmprsd_bits_g[unit].uc_queueing;

#ifdef BCM_HELIX5_SUPPORT
       if (SOC_IS_HELIX5X(unit)) {
           egr_pkt_attr_uncmprsd_bits_g[unit].mmu_cos = 5;
       } else
#endif
       {
           egr_pkt_attr_uncmprsd_bits_g[unit].mmu_cos = 4;
       }
        egr_pkt_attr_uncmprsd_bits_g[unit].mmu_cos_pos = next_pos;
        egr_pkt_attr_uncmprsd_bits_g[unit].mmu_cos_mask =
            (1 << egr_pkt_attr_uncmprsd_bits_g[unit].mmu_cos) - 1;
        next_pos += egr_pkt_attr_uncmprsd_bits_g[unit].mmu_cos;
    }
#endif
    if (soc_feature(unit, soc_feature_flex_stat_int_cn_support)) {

        egr_pkt_attr_uncmprsd_bits_g[unit].int_cn = 2;
        egr_pkt_attr_uncmprsd_bits_g[unit].int_cn_pos = next_pos;
        egr_pkt_attr_uncmprsd_bits_g[unit].int_cn_mask =
            (1 << egr_pkt_attr_uncmprsd_bits_g[unit].int_cn) - 1;

        /* Increment of next_pos needed if more attributes are added */
    }

       /* Ingress bits initialization */
       next_pos = 0;
       ing_pkt_attr_uncmprsd_bits_g[unit].ip_pkt = 1;
       ing_pkt_attr_uncmprsd_bits_g[unit].ip_pkt_pos = next_pos;
       ing_pkt_attr_uncmprsd_bits_g[unit].ip_pkt_mask = 
                           (1<<ing_pkt_attr_uncmprsd_bits_g[unit].ip_pkt) - 1;
       next_pos += ing_pkt_attr_uncmprsd_bits_g[unit].ip_pkt;

       ing_pkt_attr_uncmprsd_bits_g[unit].drop = 1;
       ing_pkt_attr_uncmprsd_bits_g[unit].drop_pos = next_pos;
       ing_pkt_attr_uncmprsd_bits_g[unit].drop_mask = 
                           (1<<ing_pkt_attr_uncmprsd_bits_g[unit].drop) - 1;
       next_pos += ing_pkt_attr_uncmprsd_bits_g[unit].drop;

       ing_pkt_attr_uncmprsd_bits_g[unit].svp_type =
           (soc_feature(unit, soc_feature_multiple_split_horizon_group)) ? 3 : 1;
       ing_pkt_attr_uncmprsd_bits_g[unit].svp_type_pos = next_pos;
       ing_pkt_attr_uncmprsd_bits_g[unit].svp_type_mask = 
                           (1<<ing_pkt_attr_uncmprsd_bits_g[unit].svp_type) - 1;
       next_pos += ing_pkt_attr_uncmprsd_bits_g[unit].svp_type;

       ing_pkt_attr_uncmprsd_bits_g[unit].pkt_resolution = 6;
       ing_pkt_attr_uncmprsd_bits_g[unit].pkt_resolution_pos = next_pos;
       ing_pkt_attr_uncmprsd_bits_g[unit].pkt_resolution_mask = 
                           (1<<ing_pkt_attr_uncmprsd_bits_g[unit].pkt_resolution) - 1;
       next_pos += ing_pkt_attr_uncmprsd_bits_g[unit].pkt_resolution;

       ing_pkt_attr_uncmprsd_bits_g[unit].tos_ecn = 2;
       ing_pkt_attr_uncmprsd_bits_g[unit].tos_ecn_pos = next_pos;
       ing_pkt_attr_uncmprsd_bits_g[unit].tos_ecn_mask = 
                           (1<<ing_pkt_attr_uncmprsd_bits_g[unit].tos_ecn) - 1;
       next_pos += ing_pkt_attr_uncmprsd_bits_g[unit].tos_ecn;

       ing_pkt_attr_uncmprsd_bits_g[unit].tos_dscp = 6;
       ing_pkt_attr_uncmprsd_bits_g[unit].tos_dscp_pos = next_pos;
       ing_pkt_attr_uncmprsd_bits_g[unit].tos_dscp_mask = 
                           (1<<ing_pkt_attr_uncmprsd_bits_g[unit].tos_dscp) - 1;
       next_pos += ing_pkt_attr_uncmprsd_bits_g[unit].tos_dscp;

       if (SOC_IS_TOMAHAWKX(unit) || SOC_IS_TRIDENT3X(unit)) {
           ing_pkt_attr_uncmprsd_bits_g[unit].ing_port = 8; /* FOR TH, TD3, 8 bits */
       } else {
           ing_pkt_attr_uncmprsd_bits_g[unit].ing_port = 7; /* FOR TD2, 7 bits */
       }
       ing_pkt_attr_uncmprsd_bits_g[unit].ing_port_pos = next_pos;
       ing_pkt_attr_uncmprsd_bits_g[unit].ing_port_mask = 
                           (1<<ing_pkt_attr_uncmprsd_bits_g[unit].ing_port) - 1;
       next_pos += ing_pkt_attr_uncmprsd_bits_g[unit].ing_port;

       ing_pkt_attr_uncmprsd_bits_g[unit].inner_dot1p = 3;
       ing_pkt_attr_uncmprsd_bits_g[unit].inner_dot1p_pos = next_pos;
       ing_pkt_attr_uncmprsd_bits_g[unit].inner_dot1p_mask = 
                           (1<<ing_pkt_attr_uncmprsd_bits_g[unit].inner_dot1p) - 1;
       next_pos += ing_pkt_attr_uncmprsd_bits_g[unit].inner_dot1p;

       ing_pkt_attr_uncmprsd_bits_g[unit].outer_dot1p = 3;
       ing_pkt_attr_uncmprsd_bits_g[unit].outer_dot1p_pos = next_pos;
       ing_pkt_attr_uncmprsd_bits_g[unit].outer_dot1p_mask = 
                           (1<<ing_pkt_attr_uncmprsd_bits_g[unit].outer_dot1p) - 1;
       next_pos += ing_pkt_attr_uncmprsd_bits_g[unit].outer_dot1p;

       ing_pkt_attr_uncmprsd_bits_g[unit].vlan_format = 2;
       ing_pkt_attr_uncmprsd_bits_g[unit].vlan_format_pos = next_pos;
       ing_pkt_attr_uncmprsd_bits_g[unit].vlan_format_mask = 
                           (1<<ing_pkt_attr_uncmprsd_bits_g[unit].vlan_format) - 1;
       next_pos += ing_pkt_attr_uncmprsd_bits_g[unit].vlan_format;

       ing_pkt_attr_uncmprsd_bits_g[unit].int_pri = 4;
       ing_pkt_attr_uncmprsd_bits_g[unit].int_pri_pos = next_pos;
       ing_pkt_attr_uncmprsd_bits_g[unit].int_pri_mask = 
                           (1<<ing_pkt_attr_uncmprsd_bits_g[unit].int_pri) - 1;
       next_pos += ing_pkt_attr_uncmprsd_bits_g[unit].int_pri;

       ing_pkt_attr_uncmprsd_bits_g[unit].ifp_cng = 2;
       ing_pkt_attr_uncmprsd_bits_g[unit].ifp_cng_pos = next_pos;
       ing_pkt_attr_uncmprsd_bits_g[unit].ifp_cng_mask = 
                           (1<<ing_pkt_attr_uncmprsd_bits_g[unit].ifp_cng) - 1;
       next_pos += ing_pkt_attr_uncmprsd_bits_g[unit].ifp_cng;

       ing_pkt_attr_uncmprsd_bits_g[unit].cng = 2;
       ing_pkt_attr_uncmprsd_bits_g[unit].cng_pos = next_pos;
       ing_pkt_attr_uncmprsd_bits_g[unit].cng_mask = 
                           (1<<ing_pkt_attr_uncmprsd_bits_g[unit].cng) - 1;
#ifdef BCM_APACHE_SUPPORT
       /* Added support for 3 Label Mpls Attr Counting */
       if (soc_feature(unit,soc_feature_flex_ctr_mpls_3_label_count)) {
           next_pos += ing_pkt_attr_uncmprsd_bits_g[unit].cng;

           ing_pkt_attr_uncmprsd_bits_g[unit].phb_1 = 4;
           ing_pkt_attr_uncmprsd_bits_g[unit].phb_1_pos = next_pos;
           ing_pkt_attr_uncmprsd_bits_g[unit].phb_1_mask =
               (1 << ing_pkt_attr_uncmprsd_bits_g[unit].phb_1) - 1;
           next_pos += ing_pkt_attr_uncmprsd_bits_g[unit].phb_1;

           ing_pkt_attr_uncmprsd_bits_g[unit].cng_1 = 2;
           ing_pkt_attr_uncmprsd_bits_g[unit].cng_1_pos = next_pos;
           ing_pkt_attr_uncmprsd_bits_g[unit].cng_1_mask =
               (1 << ing_pkt_attr_uncmprsd_bits_g[unit].cng_1) - 1;
           next_pos += ing_pkt_attr_uncmprsd_bits_g[unit].cng_1;

           ing_pkt_attr_uncmprsd_bits_g[unit].phb_2 = 4;
           ing_pkt_attr_uncmprsd_bits_g[unit].phb_2_pos = next_pos;
           ing_pkt_attr_uncmprsd_bits_g[unit].phb_2_mask =
               (1 << ing_pkt_attr_uncmprsd_bits_g[unit].phb_2) - 1;
           next_pos += ing_pkt_attr_uncmprsd_bits_g[unit].phb_2;

           ing_pkt_attr_uncmprsd_bits_g[unit].cng_2 = 2;
           ing_pkt_attr_uncmprsd_bits_g[unit].cng_2_pos = next_pos;
           ing_pkt_attr_uncmprsd_bits_g[unit].cng_2_mask =
               (1 << ing_pkt_attr_uncmprsd_bits_g[unit].cng_2) - 1;
           next_pos += ing_pkt_attr_uncmprsd_bits_g[unit].cng_2;

           ing_pkt_attr_uncmprsd_bits_g[unit].phb_3 = 4;
           ing_pkt_attr_uncmprsd_bits_g[unit].phb_3_pos = next_pos;
           ing_pkt_attr_uncmprsd_bits_g[unit].phb_3_mask =
               (1 << ing_pkt_attr_uncmprsd_bits_g[unit].phb_3) - 1;
           next_pos += ing_pkt_attr_uncmprsd_bits_g[unit].phb_3;

           ing_pkt_attr_uncmprsd_bits_g[unit].cng_3 = 2;
           ing_pkt_attr_uncmprsd_bits_g[unit].cng_3_pos = next_pos;
           ing_pkt_attr_uncmprsd_bits_g[unit].cng_3_mask =
               (1 << ing_pkt_attr_uncmprsd_bits_g[unit].cng_3) - 1;
       }
#endif
       if (soc_feature(unit, soc_feature_flex_stat_ing_tcp_flags_support)) {
           next_pos += ing_pkt_attr_uncmprsd_bits_g[unit].cng;

           ing_pkt_attr_uncmprsd_bits_g[unit].tcp_flags = 8;
           ing_pkt_attr_uncmprsd_bits_g[unit].tcp_flags_pos = next_pos;
           ing_pkt_attr_uncmprsd_bits_g[unit].tcp_flags_mask =
               (1 << ing_pkt_attr_uncmprsd_bits_g[unit].tcp_flags) - 1;
           next_pos += ing_pkt_attr_uncmprsd_bits_g[unit].tcp_flags;
       }
       if (soc_feature(unit, soc_feature_flex_stat_int_cn_support)) {
           ing_pkt_attr_uncmprsd_bits_g[unit].int_cn = 2;
           ing_pkt_attr_uncmprsd_bits_g[unit].int_cn_pos = next_pos;
           ing_pkt_attr_uncmprsd_bits_g[unit].int_cn_mask =
               (1 << ing_pkt_attr_uncmprsd_bits_g[unit].int_cn) - 1;
           next_pos += ing_pkt_attr_uncmprsd_bits_g[unit].int_cn;
       }
       if (soc_feature(unit, soc_feature_channelized_switching)) {
           ing_pkt_attr_uncmprsd_bits_g[unit].fc_type = 2;
           ing_pkt_attr_uncmprsd_bits_g[unit].fc_type_pos = next_pos;
           ing_pkt_attr_uncmprsd_bits_g[unit].fc_type_mask =
               (1 << ing_pkt_attr_uncmprsd_bits_g[unit].fc_type) - 1;
           next_pos = ing_pkt_attr_uncmprsd_bits_g[unit].fc_type;
       }
    } else {
       /* Egress bits initialization */
       if (SOC_IS_KATANA2(unit)) {
           if (SOC_IS_SABER2(unit)) {
               offset_adj = 1;
           }
           egr_pkt_attr_uncmprsd_bits_g[unit].cng = 2;
           egr_pkt_attr_uncmprsd_bits_g[unit].cng_pos = 37;
           egr_pkt_attr_uncmprsd_bits_g[unit].cng_mask = (1 << egr_pkt_attr_uncmprsd_bits_g[unit].cng) - 1;

           egr_pkt_attr_uncmprsd_bits_g[unit].int_pri = 4;
           egr_pkt_attr_uncmprsd_bits_g[unit].int_pri_pos = 33;
           egr_pkt_attr_uncmprsd_bits_g[unit].int_pri_mask = 
                               (1 << egr_pkt_attr_uncmprsd_bits_g[unit].int_pri) - 1;

           egr_pkt_attr_uncmprsd_bits_g[unit].vlan_format = 2;
           egr_pkt_attr_uncmprsd_bits_g[unit].vlan_format_pos = 31;
           egr_pkt_attr_uncmprsd_bits_g[unit].vlan_format_mask = 
                               (1<<egr_pkt_attr_uncmprsd_bits_g[unit].vlan_format) - 1;

           egr_pkt_attr_uncmprsd_bits_g[unit].outer_dot1p = 3;
           egr_pkt_attr_uncmprsd_bits_g[unit].outer_dot1p_pos = 28;
           egr_pkt_attr_uncmprsd_bits_g[unit].outer_dot1p_mask = 
                               (1<<egr_pkt_attr_uncmprsd_bits_g[unit].outer_dot1p) - 1;

           egr_pkt_attr_uncmprsd_bits_g[unit].inner_dot1p = 3;
           egr_pkt_attr_uncmprsd_bits_g[unit].inner_dot1p_pos = 25;
           egr_pkt_attr_uncmprsd_bits_g[unit].inner_dot1p_mask = 
                               (1<<egr_pkt_attr_uncmprsd_bits_g[unit].inner_dot1p) - 1;

                                                   /* For KT2 : 8 bits */
                                                   /* For SB2 : 7 Bits */
           egr_pkt_attr_uncmprsd_bits_g[unit].egr_port = 8 - offset_adj;
           egr_pkt_attr_uncmprsd_bits_g[unit].egr_port_pos = 17;
           egr_pkt_attr_uncmprsd_bits_g[unit].egr_port_mask = 
                               (1<<egr_pkt_attr_uncmprsd_bits_g[unit].egr_port) - 1;

           egr_pkt_attr_uncmprsd_bits_g[unit].tos_dscp = 6;
           egr_pkt_attr_uncmprsd_bits_g[unit].tos_dscp_pos = 11;
           egr_pkt_attr_uncmprsd_bits_g[unit].tos_dscp_mask = 
                               (1<<egr_pkt_attr_uncmprsd_bits_g[unit].tos_dscp) - 1;

           egr_pkt_attr_uncmprsd_bits_g[unit].tos_ecn = 2;
           egr_pkt_attr_uncmprsd_bits_g[unit].tos_ecn_pos = 9;
           egr_pkt_attr_uncmprsd_bits_g[unit].tos_ecn_mask = 
                               (1<<egr_pkt_attr_uncmprsd_bits_g[unit].tos_ecn) - 1;

           egr_pkt_attr_uncmprsd_bits_g[unit].pkt_resolution = 1;
           egr_pkt_attr_uncmprsd_bits_g[unit].pkt_resolution_pos = 8;
           egr_pkt_attr_uncmprsd_bits_g[unit].pkt_resolution_mask = 
                               (1<<egr_pkt_attr_uncmprsd_bits_g[unit].pkt_resolution) - 1;

           egr_pkt_attr_uncmprsd_bits_g[unit].svp_type = 3;
           egr_pkt_attr_uncmprsd_bits_g[unit].svp_type_pos = 5;
           egr_pkt_attr_uncmprsd_bits_g[unit].svp_type_mask = 
                               (1<<egr_pkt_attr_uncmprsd_bits_g[unit].svp_type) - 1;

           egr_pkt_attr_uncmprsd_bits_g[unit].dvp_type = 3;
           egr_pkt_attr_uncmprsd_bits_g[unit].dvp_type_pos = 2;
           egr_pkt_attr_uncmprsd_bits_g[unit].dvp_type_mask = 
                               (1<<egr_pkt_attr_uncmprsd_bits_g[unit].dvp_type) - 1;
       } else {
           egr_pkt_attr_uncmprsd_bits_g[unit].cng = 2;
           egr_pkt_attr_uncmprsd_bits_g[unit].cng_pos = 31;
           egr_pkt_attr_uncmprsd_bits_g[unit].cng_mask = (1 << egr_pkt_attr_uncmprsd_bits_g[unit].cng) - 1;

           egr_pkt_attr_uncmprsd_bits_g[unit].int_pri = 4;
           egr_pkt_attr_uncmprsd_bits_g[unit].int_pri_pos = 27;
           egr_pkt_attr_uncmprsd_bits_g[unit].int_pri_mask = 
                               (1 << egr_pkt_attr_uncmprsd_bits_g[unit].int_pri) - 1;

           egr_pkt_attr_uncmprsd_bits_g[unit].vlan_format = 2;
           egr_pkt_attr_uncmprsd_bits_g[unit].vlan_format_pos = 25;
           egr_pkt_attr_uncmprsd_bits_g[unit].vlan_format_mask = 
                               (1<<egr_pkt_attr_uncmprsd_bits_g[unit].vlan_format) - 1;

           egr_pkt_attr_uncmprsd_bits_g[unit].outer_dot1p = 3;
           egr_pkt_attr_uncmprsd_bits_g[unit].outer_dot1p_pos = 22;
           egr_pkt_attr_uncmprsd_bits_g[unit].outer_dot1p_mask = 
                               (1<<egr_pkt_attr_uncmprsd_bits_g[unit].outer_dot1p) - 1;

           egr_pkt_attr_uncmprsd_bits_g[unit].inner_dot1p = 3;
           egr_pkt_attr_uncmprsd_bits_g[unit].inner_dot1p_pos = 19;
           egr_pkt_attr_uncmprsd_bits_g[unit].inner_dot1p_mask = 
                               (1<<egr_pkt_attr_uncmprsd_bits_g[unit].inner_dot1p) - 1;

           egr_pkt_attr_uncmprsd_bits_g[unit].egr_port = 6; /* For KT2,TR3 6 bits */
           egr_pkt_attr_uncmprsd_bits_g[unit].egr_port_pos = 13;
           egr_pkt_attr_uncmprsd_bits_g[unit].egr_port_mask = 
                               (1<<egr_pkt_attr_uncmprsd_bits_g[unit].egr_port) - 1;

           egr_pkt_attr_uncmprsd_bits_g[unit].tos_dscp = 6;
           egr_pkt_attr_uncmprsd_bits_g[unit].tos_dscp_pos = 7;
           egr_pkt_attr_uncmprsd_bits_g[unit].tos_dscp_mask = 
                               (1<<egr_pkt_attr_uncmprsd_bits_g[unit].tos_dscp) - 1;

           egr_pkt_attr_uncmprsd_bits_g[unit].tos_ecn = 2;
           egr_pkt_attr_uncmprsd_bits_g[unit].tos_ecn_pos = 5;
           egr_pkt_attr_uncmprsd_bits_g[unit].tos_ecn_mask = 
                               (1<<egr_pkt_attr_uncmprsd_bits_g[unit].tos_ecn) - 1;

           egr_pkt_attr_uncmprsd_bits_g[unit].pkt_resolution = 1;
           egr_pkt_attr_uncmprsd_bits_g[unit].pkt_resolution_pos = 4;
           egr_pkt_attr_uncmprsd_bits_g[unit].pkt_resolution_mask = 
                               (1<<egr_pkt_attr_uncmprsd_bits_g[unit].pkt_resolution) - 1;
    
           egr_pkt_attr_uncmprsd_bits_g[unit].svp_type = 1;
           egr_pkt_attr_uncmprsd_bits_g[unit].svp_type_pos = 3;
           egr_pkt_attr_uncmprsd_bits_g[unit].svp_type_mask = 
                               (1<<egr_pkt_attr_uncmprsd_bits_g[unit].svp_type) - 1;

           egr_pkt_attr_uncmprsd_bits_g[unit].dvp_type = 1;
           egr_pkt_attr_uncmprsd_bits_g[unit].dvp_type_pos = 2;
           egr_pkt_attr_uncmprsd_bits_g[unit].dvp_type_mask = 
                               (1<<egr_pkt_attr_uncmprsd_bits_g[unit].dvp_type) - 1;
       }
       egr_pkt_attr_uncmprsd_bits_g[unit].drop = 1;
       egr_pkt_attr_uncmprsd_bits_g[unit].drop_pos = 1;
       egr_pkt_attr_uncmprsd_bits_g[unit].drop_mask = 
                           (1<<egr_pkt_attr_uncmprsd_bits_g[unit].drop) - 1;

       egr_pkt_attr_uncmprsd_bits_g[unit].ip_pkt = 1;
       egr_pkt_attr_uncmprsd_bits_g[unit].ip_pkt_pos = 0;
       egr_pkt_attr_uncmprsd_bits_g[unit].ip_pkt_mask = 
                           (1<<egr_pkt_attr_uncmprsd_bits_g[unit].ip_pkt) - 1;

       /* Ingress bits initialization */
       if (SOC_IS_KATANA2(unit)) {
           if (SOC_IS_SABER2(unit)) {
               offset_adj = 1;
           }
           ing_pkt_attr_uncmprsd_bits_g[unit].cng = 2;
           ing_pkt_attr_uncmprsd_bits_g[unit].cng_pos = 41;
           ing_pkt_attr_uncmprsd_bits_g[unit].cng_mask =
                               (1<<ing_pkt_attr_uncmprsd_bits_g[unit].cng) - 1;

           ing_pkt_attr_uncmprsd_bits_g[unit].ifp_cng = 2;
           ing_pkt_attr_uncmprsd_bits_g[unit].ifp_cng_pos = 39;
           ing_pkt_attr_uncmprsd_bits_g[unit].ifp_cng_mask =
                               (1<<ing_pkt_attr_uncmprsd_bits_g[unit].ifp_cng) - 1;

           ing_pkt_attr_uncmprsd_bits_g[unit].int_pri = 4;
           ing_pkt_attr_uncmprsd_bits_g[unit].int_pri_pos = 35;
           ing_pkt_attr_uncmprsd_bits_g[unit].int_pri_mask =
                               (1<<ing_pkt_attr_uncmprsd_bits_g[unit].int_pri) - 1;

           ing_pkt_attr_uncmprsd_bits_g[unit].vlan_format = 2;
           ing_pkt_attr_uncmprsd_bits_g[unit].vlan_format_pos = 33;
           ing_pkt_attr_uncmprsd_bits_g[unit].vlan_format_mask =
                               (1<<ing_pkt_attr_uncmprsd_bits_g[unit].vlan_format) - 1;

           ing_pkt_attr_uncmprsd_bits_g[unit].outer_dot1p = 3;
           ing_pkt_attr_uncmprsd_bits_g[unit].outer_dot1p_pos = 30;
           ing_pkt_attr_uncmprsd_bits_g[unit].outer_dot1p_mask =
                               (1<<ing_pkt_attr_uncmprsd_bits_g[unit].outer_dot1p) - 1;

           ing_pkt_attr_uncmprsd_bits_g[unit].inner_dot1p = 3;
           ing_pkt_attr_uncmprsd_bits_g[unit].inner_dot1p_pos = 27;
           ing_pkt_attr_uncmprsd_bits_g[unit].inner_dot1p_mask =
                               (1<<ing_pkt_attr_uncmprsd_bits_g[unit].inner_dot1p) - 1;

                                                   /* For KT2,For SB2 : 7 Bits */
           ing_pkt_attr_uncmprsd_bits_g[unit].ing_port = 8 - offset_adj;
           ing_pkt_attr_uncmprsd_bits_g[unit].ing_port_pos = 19;
           ing_pkt_attr_uncmprsd_bits_g[unit].ing_port_mask =
                               (1<<ing_pkt_attr_uncmprsd_bits_g[unit].ing_port) - 1;

           ing_pkt_attr_uncmprsd_bits_g[unit].tos_dscp = 6;
           ing_pkt_attr_uncmprsd_bits_g[unit].tos_dscp_pos = 13;
           ing_pkt_attr_uncmprsd_bits_g[unit].tos_dscp_mask =
                               (1<<ing_pkt_attr_uncmprsd_bits_g[unit].tos_dscp) - 1;

           ing_pkt_attr_uncmprsd_bits_g[unit].tos_ecn = 2;
           ing_pkt_attr_uncmprsd_bits_g[unit].tos_ecn_pos = 11;
           ing_pkt_attr_uncmprsd_bits_g[unit].tos_ecn_mask =
                               (1<<ing_pkt_attr_uncmprsd_bits_g[unit].tos_ecn) - 1;

           ing_pkt_attr_uncmprsd_bits_g[unit].pkt_resolution = 6;
           ing_pkt_attr_uncmprsd_bits_g[unit].pkt_resolution_pos = 5;
           ing_pkt_attr_uncmprsd_bits_g[unit].pkt_resolution_mask =
                               (1<<ing_pkt_attr_uncmprsd_bits_g[unit].pkt_resolution) - 1;

           ing_pkt_attr_uncmprsd_bits_g[unit].svp_type = 3;
           ing_pkt_attr_uncmprsd_bits_g[unit].svp_type_pos = 2;
           ing_pkt_attr_uncmprsd_bits_g[unit].svp_type_mask =
                               (1<<ing_pkt_attr_uncmprsd_bits_g[unit].svp_type) - 1;
       } else {
           ing_pkt_attr_uncmprsd_bits_g[unit].cng = 2;
           ing_pkt_attr_uncmprsd_bits_g[unit].cng_pos = 37;
           ing_pkt_attr_uncmprsd_bits_g[unit].cng_mask =
                               (1<<ing_pkt_attr_uncmprsd_bits_g[unit].cng) - 1;

           ing_pkt_attr_uncmprsd_bits_g[unit].ifp_cng = 2;
           ing_pkt_attr_uncmprsd_bits_g[unit].ifp_cng_pos = 35;
           ing_pkt_attr_uncmprsd_bits_g[unit].ifp_cng_mask =
                               (1<<ing_pkt_attr_uncmprsd_bits_g[unit].ifp_cng) - 1;

           ing_pkt_attr_uncmprsd_bits_g[unit].int_pri = 4;
           ing_pkt_attr_uncmprsd_bits_g[unit].int_pri_pos = 31;
           ing_pkt_attr_uncmprsd_bits_g[unit].int_pri_mask =
                               (1<<ing_pkt_attr_uncmprsd_bits_g[unit].int_pri) - 1;

           ing_pkt_attr_uncmprsd_bits_g[unit].vlan_format = 2;
           ing_pkt_attr_uncmprsd_bits_g[unit].vlan_format_pos = 29;
           ing_pkt_attr_uncmprsd_bits_g[unit].vlan_format_mask =
                               (1<<ing_pkt_attr_uncmprsd_bits_g[unit].vlan_format) - 1;

           ing_pkt_attr_uncmprsd_bits_g[unit].outer_dot1p = 3;
           ing_pkt_attr_uncmprsd_bits_g[unit].outer_dot1p_pos = 26;
           ing_pkt_attr_uncmprsd_bits_g[unit].outer_dot1p_mask =
                               (1<<ing_pkt_attr_uncmprsd_bits_g[unit].outer_dot1p) - 1;

           ing_pkt_attr_uncmprsd_bits_g[unit].inner_dot1p = 3;
           ing_pkt_attr_uncmprsd_bits_g[unit].inner_dot1p_pos = 23;
           ing_pkt_attr_uncmprsd_bits_g[unit].inner_dot1p_mask =
                               (1<<ing_pkt_attr_uncmprsd_bits_g[unit].inner_dot1p) - 1;

           ing_pkt_attr_uncmprsd_bits_g[unit].ing_port = 6; /* For KT2,TR3 6 bits */
           ing_pkt_attr_uncmprsd_bits_g[unit].ing_port_pos = 17;
           ing_pkt_attr_uncmprsd_bits_g[unit].ing_port_mask =
                               (1<<ing_pkt_attr_uncmprsd_bits_g[unit].ing_port) - 1;

           ing_pkt_attr_uncmprsd_bits_g[unit].tos_dscp = 6;
           ing_pkt_attr_uncmprsd_bits_g[unit].tos_dscp_pos = 11;
           ing_pkt_attr_uncmprsd_bits_g[unit].tos_dscp_mask =
                               (1<<ing_pkt_attr_uncmprsd_bits_g[unit].tos_dscp) - 1;
           ing_pkt_attr_uncmprsd_bits_g[unit].tos_ecn = 2;
           ing_pkt_attr_uncmprsd_bits_g[unit].tos_ecn_pos = 9;
           ing_pkt_attr_uncmprsd_bits_g[unit].tos_ecn_mask =
                               (1<<ing_pkt_attr_uncmprsd_bits_g[unit].tos_ecn) - 1;

           ing_pkt_attr_uncmprsd_bits_g[unit].pkt_resolution = 6;
           ing_pkt_attr_uncmprsd_bits_g[unit].pkt_resolution_pos = 3;
           ing_pkt_attr_uncmprsd_bits_g[unit].pkt_resolution_mask =
                               (1<<ing_pkt_attr_uncmprsd_bits_g[unit].pkt_resolution) - 1;

           ing_pkt_attr_uncmprsd_bits_g[unit].svp_type = 1;
           ing_pkt_attr_uncmprsd_bits_g[unit].svp_type_pos = 2;
           ing_pkt_attr_uncmprsd_bits_g[unit].svp_type_mask =
                               (1<<ing_pkt_attr_uncmprsd_bits_g[unit].svp_type) - 1;
       }
       ing_pkt_attr_uncmprsd_bits_g[unit].drop = 1;
       ing_pkt_attr_uncmprsd_bits_g[unit].drop_pos = 1;
       ing_pkt_attr_uncmprsd_bits_g[unit].drop_mask =
                           (1<<ing_pkt_attr_uncmprsd_bits_g[unit].drop) - 1;

       ing_pkt_attr_uncmprsd_bits_g[unit].ip_pkt = 1;
       ing_pkt_attr_uncmprsd_bits_g[unit].ip_pkt_pos = 0;
       ing_pkt_attr_uncmprsd_bits_g[unit].ip_pkt_mask =
                           (1<<ing_pkt_attr_uncmprsd_bits_g[unit].ip_pkt) - 1;
   }
   if (SOC_IS_KATANA2(unit)) {
       if (SOC_IS_SABER2(unit)) {
           offset_adj = 1;
       }
       ing_pkt_attr_cmprsd_bits_g[unit].cng = 2;
       ing_pkt_attr_cmprsd_bits_g[unit].cng_pos = 39 - offset_adj;
       ing_pkt_attr_cmprsd_bits_g[unit].cng_mask =
                           (1<<ing_pkt_attr_cmprsd_bits_g[unit].cng) - 1;

       ing_pkt_attr_cmprsd_bits_g[unit].ifp_cng = 2;
       ing_pkt_attr_cmprsd_bits_g[unit].ifp_cng_pos = 37 - offset_adj;
       ing_pkt_attr_cmprsd_bits_g[unit].ifp_cng_mask =
                           (1<<ing_pkt_attr_cmprsd_bits_g[unit].ifp_cng) - 1;

       ing_pkt_attr_cmprsd_bits_g[unit].int_pri = 4;
       ing_pkt_attr_cmprsd_bits_g[unit].int_pri_pos = 33 - offset_adj;
       ing_pkt_attr_cmprsd_bits_g[unit].int_pri_mask =
                           (1<<ing_pkt_attr_cmprsd_bits_g[unit].int_pri) - 1;

       ing_pkt_attr_cmprsd_bits_g[unit].vlan_format = 2;
       ing_pkt_attr_cmprsd_bits_g[unit].vlan_format_pos = 31 - offset_adj;
       ing_pkt_attr_cmprsd_bits_g[unit].vlan_format_mask =
                           (1<<ing_pkt_attr_cmprsd_bits_g[unit].vlan_format) - 1;

       ing_pkt_attr_cmprsd_bits_g[unit].outer_dot1p = 3;
       ing_pkt_attr_cmprsd_bits_g[unit].outer_dot1p_pos = 28 - offset_adj;
       ing_pkt_attr_cmprsd_bits_g[unit].outer_dot1p_mask =
                           (1<<ing_pkt_attr_cmprsd_bits_g[unit].outer_dot1p) - 1;

       ing_pkt_attr_cmprsd_bits_g[unit].inner_dot1p = 3;
       ing_pkt_attr_cmprsd_bits_g[unit].inner_dot1p_pos = 25;
       ing_pkt_attr_cmprsd_bits_g[unit].inner_dot1p_mask =
                           (1<<ing_pkt_attr_cmprsd_bits_g[unit].inner_dot1p) - 1;

       ing_pkt_attr_cmprsd_bits_g[unit].ing_port = 8 - offset_adj; /* For KT2,TR3 6 bits */
       ing_pkt_attr_cmprsd_bits_g[unit].ing_port_pos = 17;
       ing_pkt_attr_cmprsd_bits_g[unit].ing_port_mask =
                           (1<<ing_pkt_attr_cmprsd_bits_g[unit].ing_port) - 1;

       ing_pkt_attr_cmprsd_bits_g[unit].tos_dscp = 6;
       ing_pkt_attr_cmprsd_bits_g[unit].tos_dscp_pos = 11;
       ing_pkt_attr_cmprsd_bits_g[unit].tos_dscp_mask =
                           (1<<ing_pkt_attr_cmprsd_bits_g[unit].tos_dscp) - 1;

       ing_pkt_attr_cmprsd_bits_g[unit].tos_ecn = 2;
       ing_pkt_attr_cmprsd_bits_g[unit].tos_ecn_pos = 9;
       ing_pkt_attr_cmprsd_bits_g[unit].tos_ecn_mask =
                           (1<<ing_pkt_attr_cmprsd_bits_g[unit].tos_ecn) - 1;

       ing_pkt_attr_cmprsd_bits_g[unit].pkt_resolution = 4;
       ing_pkt_attr_cmprsd_bits_g[unit].pkt_resolution_pos = 5;
       ing_pkt_attr_cmprsd_bits_g[unit].pkt_resolution_mask =
                           (1<<ing_pkt_attr_cmprsd_bits_g[unit].pkt_resolution) - 1;

       ing_pkt_attr_cmprsd_bits_g[unit].svp_type = 3;
       ing_pkt_attr_cmprsd_bits_g[unit].svp_type_pos = 2;
       ing_pkt_attr_cmprsd_bits_g[unit].svp_type_mask =
                           (1<<ing_pkt_attr_cmprsd_bits_g[unit].svp_type) - 1;
       ing_pkt_attr_cmprsd_bits_g[unit].drop = 1;
       ing_pkt_attr_cmprsd_bits_g[unit].drop_pos = 1;
       ing_pkt_attr_cmprsd_bits_g[unit].drop_mask =
                           (1<<ing_pkt_attr_cmprsd_bits_g[unit].drop) - 1;

       ing_pkt_attr_cmprsd_bits_g[unit].ip_pkt = 1;
       ing_pkt_attr_cmprsd_bits_g[unit].ip_pkt_pos = 0;
       ing_pkt_attr_cmprsd_bits_g[unit].ip_pkt_mask =
                           (1<<ing_pkt_attr_cmprsd_bits_g[unit].ip_pkt) - 1;

       egr_pkt_attr_cmprsd_bits_g[unit].cng = 2;
       egr_pkt_attr_cmprsd_bits_g[unit].cng_pos = 33;
       egr_pkt_attr_cmprsd_bits_g[unit].cng_mask = (1 << egr_pkt_attr_cmprsd_bits_g[unit].cng) - 1;

       egr_pkt_attr_cmprsd_bits_g[unit].int_pri = 4;
       egr_pkt_attr_cmprsd_bits_g[unit].int_pri_pos = 29;
       egr_pkt_attr_cmprsd_bits_g[unit].int_pri_mask = 
                           (1 << egr_pkt_attr_cmprsd_bits_g[unit].int_pri) - 1;

       egr_pkt_attr_cmprsd_bits_g[unit].vlan_format = 2;
       egr_pkt_attr_cmprsd_bits_g[unit].vlan_format_pos = 27;
       egr_pkt_attr_cmprsd_bits_g[unit].vlan_format_mask = 
                           (1<<egr_pkt_attr_cmprsd_bits_g[unit].vlan_format) - 1;

       egr_pkt_attr_cmprsd_bits_g[unit].outer_dot1p = 3;
       egr_pkt_attr_cmprsd_bits_g[unit].outer_dot1p_pos = 24;
       egr_pkt_attr_cmprsd_bits_g[unit].outer_dot1p_mask = 
                           (1<<egr_pkt_attr_cmprsd_bits_g[unit].outer_dot1p) - 1;

       egr_pkt_attr_cmprsd_bits_g[unit].inner_dot1p = 3;
       egr_pkt_attr_cmprsd_bits_g[unit].inner_dot1p_pos = 21;
       egr_pkt_attr_cmprsd_bits_g[unit].inner_dot1p_mask = 
                           (1<<egr_pkt_attr_cmprsd_bits_g[unit].inner_dot1p) - 1;

       egr_pkt_attr_cmprsd_bits_g[unit].egr_port = 8 - offset_adj; /* For KT2 : 8 bits */
       egr_pkt_attr_cmprsd_bits_g[unit].egr_port_pos = 13;
       egr_pkt_attr_cmprsd_bits_g[unit].egr_port_mask = 
                           (1<<egr_pkt_attr_cmprsd_bits_g[unit].egr_port) - 1;

       egr_pkt_attr_cmprsd_bits_g[unit].tos_dscp = 6;
       egr_pkt_attr_cmprsd_bits_g[unit].tos_dscp_pos = 7;
       egr_pkt_attr_cmprsd_bits_g[unit].tos_dscp_mask = 
                           (1<<egr_pkt_attr_cmprsd_bits_g[unit].tos_dscp) - 1;

       egr_pkt_attr_cmprsd_bits_g[unit].tos_ecn = 2;
       egr_pkt_attr_cmprsd_bits_g[unit].tos_ecn_pos = 5;
       egr_pkt_attr_cmprsd_bits_g[unit].tos_ecn_mask = 
                           (1<<egr_pkt_attr_cmprsd_bits_g[unit].tos_ecn) - 1;

       egr_pkt_attr_cmprsd_bits_g[unit].pkt_resolution = 1;
       egr_pkt_attr_cmprsd_bits_g[unit].pkt_resolution_pos = 4;
       egr_pkt_attr_cmprsd_bits_g[unit].pkt_resolution_mask = 
                       (1<<egr_pkt_attr_cmprsd_bits_g[unit].pkt_resolution) - 1;

       egr_pkt_attr_cmprsd_bits_g[unit].svp_type = 1;
       egr_pkt_attr_cmprsd_bits_g[unit].svp_type_pos = 3;
       egr_pkt_attr_cmprsd_bits_g[unit].svp_type_mask = 
                           (1<<egr_pkt_attr_cmprsd_bits_g[unit].svp_type) - 1;

       egr_pkt_attr_cmprsd_bits_g[unit].dvp_type = 1;
       egr_pkt_attr_cmprsd_bits_g[unit].dvp_type_pos = 2;
       egr_pkt_attr_cmprsd_bits_g[unit].dvp_type_mask = 
                           (1<<egr_pkt_attr_cmprsd_bits_g[unit].dvp_type) - 1;
       egr_pkt_attr_cmprsd_bits_g[unit].drop = 1;
       egr_pkt_attr_cmprsd_bits_g[unit].drop_pos = 1;
       egr_pkt_attr_cmprsd_bits_g[unit].drop_mask = 
                           (1<<egr_pkt_attr_cmprsd_bits_g[unit].drop) - 1;

       egr_pkt_attr_cmprsd_bits_g[unit].ip_pkt = 1;
       egr_pkt_attr_cmprsd_bits_g[unit].ip_pkt_pos = 0;
       egr_pkt_attr_cmprsd_bits_g[unit].ip_pkt_mask = 
                           (1<<egr_pkt_attr_cmprsd_bits_g[unit].ip_pkt) - 1;
#ifdef BCM_APACHE_SUPPORT
   } else if (SOC_IS_APACHE(unit)) {
       int next_pos = 0;
       /* Egress bits initialization */
       egr_pkt_attr_cmprsd_bits_g[unit].ip_pkt = 1;
       egr_pkt_attr_cmprsd_bits_g[unit].ip_pkt_pos = next_pos;
       egr_pkt_attr_cmprsd_bits_g[unit].ip_pkt_mask =
           (1<<egr_pkt_attr_cmprsd_bits_g[unit].ip_pkt) - 1;
       next_pos += egr_pkt_attr_cmprsd_bits_g[unit].ip_pkt;

       egr_pkt_attr_cmprsd_bits_g[unit].drop = 1;
       egr_pkt_attr_cmprsd_bits_g[unit].drop_pos = next_pos;
       egr_pkt_attr_cmprsd_bits_g[unit].drop_mask =
           (1<<egr_pkt_attr_cmprsd_bits_g[unit].drop) - 1;
       next_pos += egr_pkt_attr_cmprsd_bits_g[unit].drop;

       egr_pkt_attr_cmprsd_bits_g[unit].dvp_type = 1;
       egr_pkt_attr_cmprsd_bits_g[unit].dvp_type_pos = next_pos;
       egr_pkt_attr_cmprsd_bits_g[unit].dvp_type_mask =
           (1<<egr_pkt_attr_cmprsd_bits_g[unit].dvp_type) - 1;
       next_pos += egr_pkt_attr_cmprsd_bits_g[unit].dvp_type;

       egr_pkt_attr_cmprsd_bits_g[unit].svp_type = 1;
       egr_pkt_attr_cmprsd_bits_g[unit].svp_type_pos = next_pos;
       egr_pkt_attr_cmprsd_bits_g[unit].svp_type_mask =
           (1<<egr_pkt_attr_cmprsd_bits_g[unit].svp_type) - 1;
       next_pos += egr_pkt_attr_cmprsd_bits_g[unit].svp_type;

       egr_pkt_attr_cmprsd_bits_g[unit].pkt_resolution = 1;
       egr_pkt_attr_cmprsd_bits_g[unit].pkt_resolution_pos = next_pos;
       egr_pkt_attr_cmprsd_bits_g[unit].pkt_resolution_mask =
           (1<<egr_pkt_attr_cmprsd_bits_g[unit].pkt_resolution) - 1;
       next_pos += egr_pkt_attr_cmprsd_bits_g[unit].pkt_resolution;

       egr_pkt_attr_cmprsd_bits_g[unit].tos_ecn = 2;
       egr_pkt_attr_cmprsd_bits_g[unit].tos_ecn_pos = next_pos;
       egr_pkt_attr_cmprsd_bits_g[unit].tos_ecn_mask =
           (1<<egr_pkt_attr_cmprsd_bits_g[unit].tos_ecn) - 1;
       next_pos += egr_pkt_attr_cmprsd_bits_g[unit].tos_ecn;

       egr_pkt_attr_cmprsd_bits_g[unit].tos_dscp = 6;
       egr_pkt_attr_cmprsd_bits_g[unit].tos_dscp_pos = next_pos;
       egr_pkt_attr_cmprsd_bits_g[unit].tos_dscp_mask =
           (1<<egr_pkt_attr_cmprsd_bits_g[unit].tos_dscp) - 1;
       next_pos += egr_pkt_attr_cmprsd_bits_g[unit].tos_dscp;

       egr_pkt_attr_cmprsd_bits_g[unit].egr_port = 7; /* For KT2,TR3 6 bits */
       egr_pkt_attr_cmprsd_bits_g[unit].egr_port_pos = next_pos;
       egr_pkt_attr_cmprsd_bits_g[unit].egr_port_mask =
           (1<<egr_pkt_attr_cmprsd_bits_g[unit].egr_port) - 1;
       next_pos += egr_pkt_attr_cmprsd_bits_g[unit].egr_port;

       egr_pkt_attr_cmprsd_bits_g[unit].inner_dot1p = 3;
       egr_pkt_attr_cmprsd_bits_g[unit].inner_dot1p_pos = next_pos;
       egr_pkt_attr_cmprsd_bits_g[unit].inner_dot1p_mask =
           (1<<egr_pkt_attr_cmprsd_bits_g[unit].inner_dot1p) - 1;
       next_pos += egr_pkt_attr_cmprsd_bits_g[unit].inner_dot1p;

       egr_pkt_attr_cmprsd_bits_g[unit].outer_dot1p = 3;
       egr_pkt_attr_cmprsd_bits_g[unit].outer_dot1p_pos = next_pos;
       egr_pkt_attr_cmprsd_bits_g[unit].outer_dot1p_mask =
           (1<<egr_pkt_attr_cmprsd_bits_g[unit].outer_dot1p) - 1;
       next_pos += egr_pkt_attr_cmprsd_bits_g[unit].outer_dot1p;

       egr_pkt_attr_cmprsd_bits_g[unit].vlan_format = 2;
       egr_pkt_attr_cmprsd_bits_g[unit].vlan_format_pos = next_pos;
       egr_pkt_attr_cmprsd_bits_g[unit].vlan_format_mask =
           (1<<egr_pkt_attr_cmprsd_bits_g[unit].vlan_format) - 1;
       next_pos += egr_pkt_attr_cmprsd_bits_g[unit].vlan_format;

       egr_pkt_attr_cmprsd_bits_g[unit].int_pri = 4;
       egr_pkt_attr_cmprsd_bits_g[unit].int_pri_pos = next_pos;
       egr_pkt_attr_cmprsd_bits_g[unit].int_pri_mask =
           (1 << egr_pkt_attr_cmprsd_bits_g[unit].int_pri) - 1;
       next_pos += egr_pkt_attr_cmprsd_bits_g[unit].int_pri;

       egr_pkt_attr_cmprsd_bits_g[unit].cng = 2;
       egr_pkt_attr_cmprsd_bits_g[unit].cng_pos = next_pos;
       egr_pkt_attr_cmprsd_bits_g[unit].cng_mask =
           (1 << egr_pkt_attr_cmprsd_bits_g[unit].cng) - 1;

       next_pos += egr_pkt_attr_cmprsd_bits_g[unit].cng;

       egr_pkt_attr_cmprsd_bits_g[unit].phb_1 = 4;
       egr_pkt_attr_cmprsd_bits_g[unit].phb_1_pos = next_pos;
       egr_pkt_attr_cmprsd_bits_g[unit].phb_1_mask =
           (1 << egr_pkt_attr_cmprsd_bits_g[unit].phb_1) - 1;
       next_pos += egr_pkt_attr_cmprsd_bits_g[unit].phb_1;

       egr_pkt_attr_cmprsd_bits_g[unit].cng_1 = 2;
       egr_pkt_attr_cmprsd_bits_g[unit].cng_1_pos = next_pos;
       egr_pkt_attr_cmprsd_bits_g[unit].cng_1_mask =
           (1 << egr_pkt_attr_cmprsd_bits_g[unit].cng_1) - 1;
       next_pos += egr_pkt_attr_cmprsd_bits_g[unit].cng_1;

       egr_pkt_attr_cmprsd_bits_g[unit].phb_2 = 4;
       egr_pkt_attr_cmprsd_bits_g[unit].phb_2_pos = next_pos;
       egr_pkt_attr_cmprsd_bits_g[unit].phb_2_mask =
           (1 << egr_pkt_attr_cmprsd_bits_g[unit].phb_2) - 1;
       next_pos += egr_pkt_attr_cmprsd_bits_g[unit].phb_2;

       egr_pkt_attr_cmprsd_bits_g[unit].cng_2 = 2;
       egr_pkt_attr_cmprsd_bits_g[unit].cng_2_pos = next_pos;
       egr_pkt_attr_cmprsd_bits_g[unit].cng_2_mask =
           (1 << egr_pkt_attr_cmprsd_bits_g[unit].cng_2) - 1;
       next_pos += egr_pkt_attr_cmprsd_bits_g[unit].cng_2;

       egr_pkt_attr_cmprsd_bits_g[unit].phb_3 = 4;
       egr_pkt_attr_cmprsd_bits_g[unit].phb_3_pos = next_pos;
       egr_pkt_attr_cmprsd_bits_g[unit].phb_3_mask =
           (1 << egr_pkt_attr_cmprsd_bits_g[unit].phb_3) - 1;
       next_pos += egr_pkt_attr_cmprsd_bits_g[unit].phb_3;

       egr_pkt_attr_cmprsd_bits_g[unit].cng_3 = 2;
       egr_pkt_attr_cmprsd_bits_g[unit].cng_3_pos = next_pos;
       egr_pkt_attr_cmprsd_bits_g[unit].cng_3_mask =
           (1 << egr_pkt_attr_cmprsd_bits_g[unit].cng_3) - 1;

       /* Ingress bits initialization */
       next_pos = 0;
       ing_pkt_attr_cmprsd_bits_g[unit].ip_pkt = 1;
       ing_pkt_attr_cmprsd_bits_g[unit].ip_pkt_pos = next_pos;
       ing_pkt_attr_cmprsd_bits_g[unit].ip_pkt_mask =
           (1<<ing_pkt_attr_cmprsd_bits_g[unit].ip_pkt) - 1;
       next_pos += ing_pkt_attr_cmprsd_bits_g[unit].ip_pkt;

       ing_pkt_attr_cmprsd_bits_g[unit].drop = 1;
       ing_pkt_attr_cmprsd_bits_g[unit].drop_pos = next_pos;
       ing_pkt_attr_cmprsd_bits_g[unit].drop_mask =
           (1<<ing_pkt_attr_cmprsd_bits_g[unit].drop) - 1;
       next_pos += ing_pkt_attr_cmprsd_bits_g[unit].drop;

       ing_pkt_attr_cmprsd_bits_g[unit].svp_type = 3;
       ing_pkt_attr_cmprsd_bits_g[unit].svp_type_pos = next_pos;
       ing_pkt_attr_cmprsd_bits_g[unit].svp_type_mask =
           (1<<ing_pkt_attr_cmprsd_bits_g[unit].svp_type) - 1;
       next_pos += ing_pkt_attr_cmprsd_bits_g[unit].svp_type;

       ing_pkt_attr_cmprsd_bits_g[unit].pkt_resolution = 4;
       ing_pkt_attr_cmprsd_bits_g[unit].pkt_resolution_pos = next_pos;
       ing_pkt_attr_cmprsd_bits_g[unit].pkt_resolution_mask =
           (1<<ing_pkt_attr_cmprsd_bits_g[unit].pkt_resolution) - 1;
       next_pos += ing_pkt_attr_cmprsd_bits_g[unit].pkt_resolution;

       ing_pkt_attr_cmprsd_bits_g[unit].tos_ecn = 2;
       ing_pkt_attr_cmprsd_bits_g[unit].tos_ecn_pos = next_pos;
       ing_pkt_attr_cmprsd_bits_g[unit].tos_ecn_mask =
           (1<<ing_pkt_attr_cmprsd_bits_g[unit].tos_ecn) - 1;
       next_pos += ing_pkt_attr_cmprsd_bits_g[unit].tos_ecn;

       ing_pkt_attr_cmprsd_bits_g[unit].tos_dscp = 6;
       ing_pkt_attr_cmprsd_bits_g[unit].tos_dscp_pos = next_pos;
       ing_pkt_attr_cmprsd_bits_g[unit].tos_dscp_mask =
           (1<<ing_pkt_attr_cmprsd_bits_g[unit].tos_dscp) - 1;
       next_pos += ing_pkt_attr_cmprsd_bits_g[unit].tos_dscp;

       ing_pkt_attr_cmprsd_bits_g[unit].ing_port = 7; /* FOR TD2, 7 bits */
       ing_pkt_attr_cmprsd_bits_g[unit].ing_port_pos = next_pos;
       ing_pkt_attr_cmprsd_bits_g[unit].ing_port_mask =
           (1<<ing_pkt_attr_cmprsd_bits_g[unit].ing_port) - 1;
       next_pos += ing_pkt_attr_cmprsd_bits_g[unit].ing_port;

       ing_pkt_attr_cmprsd_bits_g[unit].inner_dot1p = 3;
       ing_pkt_attr_cmprsd_bits_g[unit].inner_dot1p_pos = next_pos;
       ing_pkt_attr_cmprsd_bits_g[unit].inner_dot1p_mask =
           (1<<ing_pkt_attr_cmprsd_bits_g[unit].inner_dot1p) - 1;
       next_pos += ing_pkt_attr_cmprsd_bits_g[unit].inner_dot1p;

       ing_pkt_attr_cmprsd_bits_g[unit].outer_dot1p = 3;
       ing_pkt_attr_cmprsd_bits_g[unit].outer_dot1p_pos = next_pos;
       ing_pkt_attr_cmprsd_bits_g[unit].outer_dot1p_mask =
           (1<<ing_pkt_attr_cmprsd_bits_g[unit].outer_dot1p) - 1;
       next_pos += ing_pkt_attr_cmprsd_bits_g[unit].outer_dot1p;

       ing_pkt_attr_cmprsd_bits_g[unit].vlan_format = 2;
       ing_pkt_attr_cmprsd_bits_g[unit].vlan_format_pos = next_pos;
       ing_pkt_attr_cmprsd_bits_g[unit].vlan_format_mask =
           (1<<ing_pkt_attr_cmprsd_bits_g[unit].vlan_format) - 1;
       next_pos += ing_pkt_attr_cmprsd_bits_g[unit].vlan_format;

       ing_pkt_attr_cmprsd_bits_g[unit].int_pri = 4;
       ing_pkt_attr_cmprsd_bits_g[unit].int_pri_pos = next_pos;
       ing_pkt_attr_cmprsd_bits_g[unit].int_pri_mask =
           (1<<ing_pkt_attr_cmprsd_bits_g[unit].int_pri) - 1;
       next_pos += ing_pkt_attr_cmprsd_bits_g[unit].int_pri;

       ing_pkt_attr_cmprsd_bits_g[unit].ifp_cng = 2;
       ing_pkt_attr_cmprsd_bits_g[unit].ifp_cng_pos = next_pos;
       ing_pkt_attr_cmprsd_bits_g[unit].ifp_cng_mask =
           (1<<ing_pkt_attr_cmprsd_bits_g[unit].ifp_cng) - 1;
       next_pos += ing_pkt_attr_cmprsd_bits_g[unit].ifp_cng;

       ing_pkt_attr_cmprsd_bits_g[unit].cng = 2;
       ing_pkt_attr_cmprsd_bits_g[unit].cng_pos = next_pos;
       ing_pkt_attr_cmprsd_bits_g[unit].cng_mask =
           (1<<ing_pkt_attr_cmprsd_bits_g[unit].cng) - 1;

       next_pos += ing_pkt_attr_cmprsd_bits_g[unit].cng;

       ing_pkt_attr_cmprsd_bits_g[unit].phb_1 = 4;
       ing_pkt_attr_cmprsd_bits_g[unit].phb_1_pos = next_pos;
       ing_pkt_attr_cmprsd_bits_g[unit].phb_1_mask =
           (1 << ing_pkt_attr_cmprsd_bits_g[unit].phb_1) - 1;
       next_pos += ing_pkt_attr_cmprsd_bits_g[unit].phb_1;

       ing_pkt_attr_cmprsd_bits_g[unit].cng_1 = 2;
       ing_pkt_attr_cmprsd_bits_g[unit].cng_1_pos = next_pos;
       ing_pkt_attr_cmprsd_bits_g[unit].cng_1_mask =
           (1 << ing_pkt_attr_cmprsd_bits_g[unit].cng_1) - 1;
       next_pos += ing_pkt_attr_cmprsd_bits_g[unit].cng_1;

       ing_pkt_attr_cmprsd_bits_g[unit].phb_2 = 4;
       ing_pkt_attr_cmprsd_bits_g[unit].phb_2_pos = next_pos;
       ing_pkt_attr_cmprsd_bits_g[unit].phb_2_mask =
           (1 << ing_pkt_attr_cmprsd_bits_g[unit].phb_2) - 1;
       next_pos += ing_pkt_attr_cmprsd_bits_g[unit].phb_2;

       ing_pkt_attr_cmprsd_bits_g[unit].cng_2 = 2;
       ing_pkt_attr_cmprsd_bits_g[unit].cng_2_pos = next_pos;
       ing_pkt_attr_cmprsd_bits_g[unit].cng_2_mask =
           (1 << ing_pkt_attr_cmprsd_bits_g[unit].cng_2) - 1;
       next_pos += ing_pkt_attr_cmprsd_bits_g[unit].cng_2;

       ing_pkt_attr_cmprsd_bits_g[unit].phb_3 = 4;
       ing_pkt_attr_cmprsd_bits_g[unit].phb_3_pos = next_pos;
       ing_pkt_attr_cmprsd_bits_g[unit].phb_3_mask =
           (1 << ing_pkt_attr_cmprsd_bits_g[unit].phb_3) - 1;
       next_pos += ing_pkt_attr_cmprsd_bits_g[unit].phb_3;

       ing_pkt_attr_cmprsd_bits_g[unit].cng_3 = 2;
       ing_pkt_attr_cmprsd_bits_g[unit].cng_3_pos = next_pos;
       ing_pkt_attr_cmprsd_bits_g[unit].cng_3_mask =
           (1 << ing_pkt_attr_cmprsd_bits_g[unit].cng_3) - 1;
#endif
   }
#ifdef BCM_TRIDENT3_SUPPORT
   else if(SOC_IS_TRIDENT3X(unit)) {
       int next_pos = 0;

       /* Egress bits initialization */
       egr_pkt_attr_cmprsd_bits_g[unit].ip_pkt = 1;
       egr_pkt_attr_cmprsd_bits_g[unit].ip_pkt_pos = next_pos;
       egr_pkt_attr_cmprsd_bits_g[unit].ip_pkt_mask =
                           (1<<egr_pkt_attr_cmprsd_bits_g[unit].ip_pkt) - 1;
       next_pos += egr_pkt_attr_cmprsd_bits_g[unit].ip_pkt;

       egr_pkt_attr_cmprsd_bits_g[unit].drop = 1;
       egr_pkt_attr_cmprsd_bits_g[unit].drop_pos = next_pos;
       egr_pkt_attr_cmprsd_bits_g[unit].drop_mask =
                (1<<egr_pkt_attr_cmprsd_bits_g[unit].drop) - 1;
       next_pos += egr_pkt_attr_cmprsd_bits_g[unit].drop;

       egr_pkt_attr_cmprsd_bits_g[unit].dvp_type = 1;
       egr_pkt_attr_cmprsd_bits_g[unit].dvp_type_pos = next_pos;
       egr_pkt_attr_cmprsd_bits_g[unit].dvp_type_mask =
                           (1<<egr_pkt_attr_cmprsd_bits_g[unit].dvp_type) - 1;
       next_pos += egr_pkt_attr_cmprsd_bits_g[unit].dvp_type;

       egr_pkt_attr_cmprsd_bits_g[unit].svp_type = 1;
       egr_pkt_attr_cmprsd_bits_g[unit].svp_type_pos = next_pos;
       egr_pkt_attr_cmprsd_bits_g[unit].svp_type_mask =
                           (1<<egr_pkt_attr_cmprsd_bits_g[unit].svp_type) - 1;
       next_pos += egr_pkt_attr_cmprsd_bits_g[unit].svp_type;

       egr_pkt_attr_cmprsd_bits_g[unit].pkt_resolution = 1;
       egr_pkt_attr_cmprsd_bits_g[unit].pkt_resolution_pos = next_pos;
       egr_pkt_attr_cmprsd_bits_g[unit].pkt_resolution_mask =
                           (1<<egr_pkt_attr_cmprsd_bits_g[unit].pkt_resolution) - 1;
       next_pos += egr_pkt_attr_cmprsd_bits_g[unit].pkt_resolution;

       egr_pkt_attr_cmprsd_bits_g[unit].tos_ecn = 2;
       egr_pkt_attr_cmprsd_bits_g[unit].tos_ecn_pos = next_pos;
       egr_pkt_attr_cmprsd_bits_g[unit].tos_ecn_mask =
                           (1<<egr_pkt_attr_cmprsd_bits_g[unit].tos_ecn) - 1;
       next_pos += egr_pkt_attr_cmprsd_bits_g[unit].tos_ecn;

       egr_pkt_attr_cmprsd_bits_g[unit].tos_dscp = 6;
       egr_pkt_attr_cmprsd_bits_g[unit].tos_dscp_pos = next_pos;
       egr_pkt_attr_cmprsd_bits_g[unit].tos_dscp_mask =
                           (1<<egr_pkt_attr_cmprsd_bits_g[unit].tos_dscp) - 1;
       next_pos += egr_pkt_attr_cmprsd_bits_g[unit].tos_dscp;

       egr_pkt_attr_cmprsd_bits_g[unit].egr_port = 8;
#ifdef BCM_FIREBOLT6_SUPPORT
       if (SOC_IS_FIREBOLT6(unit)) {
           /* Increased to 9 bits to accomodate 512 channels */
           egr_pkt_attr_cmprsd_bits_g[unit].egr_port = 9;
       }
#endif
       egr_pkt_attr_cmprsd_bits_g[unit].egr_port_pos = next_pos;
       egr_pkt_attr_cmprsd_bits_g[unit].egr_port_mask =
                           (1<<egr_pkt_attr_cmprsd_bits_g[unit].egr_port) - 1;
       next_pos += egr_pkt_attr_cmprsd_bits_g[unit].egr_port;

       egr_pkt_attr_cmprsd_bits_g[unit].inner_dot1p = 3;
       egr_pkt_attr_cmprsd_bits_g[unit].inner_dot1p_pos = next_pos;
       egr_pkt_attr_cmprsd_bits_g[unit].inner_dot1p_mask =
                           (1<<egr_pkt_attr_cmprsd_bits_g[unit].inner_dot1p) - 1;
       next_pos += egr_pkt_attr_cmprsd_bits_g[unit].inner_dot1p;

       egr_pkt_attr_cmprsd_bits_g[unit].outer_dot1p = 3;
       egr_pkt_attr_cmprsd_bits_g[unit].outer_dot1p_pos = next_pos;
       egr_pkt_attr_cmprsd_bits_g[unit].outer_dot1p_mask =
                           (1<<egr_pkt_attr_cmprsd_bits_g[unit].outer_dot1p) - 1;
       next_pos += egr_pkt_attr_cmprsd_bits_g[unit].outer_dot1p;

       egr_pkt_attr_cmprsd_bits_g[unit].vlan_format = 2;
       egr_pkt_attr_cmprsd_bits_g[unit].vlan_format_pos = next_pos;
       egr_pkt_attr_cmprsd_bits_g[unit].vlan_format_mask =
                           (1<<egr_pkt_attr_cmprsd_bits_g[unit].vlan_format) - 1;
       next_pos += egr_pkt_attr_cmprsd_bits_g[unit].vlan_format;

       egr_pkt_attr_cmprsd_bits_g[unit].int_pri = 4;
       egr_pkt_attr_cmprsd_bits_g[unit].int_pri_pos = next_pos;
       egr_pkt_attr_cmprsd_bits_g[unit].int_pri_mask =
                           (1 << egr_pkt_attr_cmprsd_bits_g[unit].int_pri) - 1;
       next_pos += egr_pkt_attr_cmprsd_bits_g[unit].int_pri;

       egr_pkt_attr_cmprsd_bits_g[unit].cng = 2;
       egr_pkt_attr_cmprsd_bits_g[unit].cng_pos = next_pos;
       egr_pkt_attr_cmprsd_bits_g[unit].cng_mask = (1 << egr_pkt_attr_cmprsd_bits_g[unit].cng) - 1;

       if (soc_feature(unit, soc_feature_flex_stat_egr_queue_congestion_marked)) {
           next_pos += egr_pkt_attr_cmprsd_bits_g[unit].cng;

           egr_pkt_attr_cmprsd_bits_g[unit].congestion_marked = 1;
           egr_pkt_attr_cmprsd_bits_g[unit].congestion_marked_pos = next_pos;
           egr_pkt_attr_cmprsd_bits_g[unit].congestion_marked_mask =
               (1 << egr_pkt_attr_cmprsd_bits_g[unit].congestion_marked) - 1;
           next_pos += egr_pkt_attr_cmprsd_bits_g[unit].congestion_marked;

           egr_pkt_attr_cmprsd_bits_g[unit].uc_queueing = 1;
           egr_pkt_attr_cmprsd_bits_g[unit].uc_queueing_pos = next_pos;
           egr_pkt_attr_cmprsd_bits_g[unit].uc_queueing_mask =
               (1 << egr_pkt_attr_cmprsd_bits_g[unit].uc_queueing) - 1;
           next_pos += egr_pkt_attr_cmprsd_bits_g[unit].uc_queueing;

#ifdef BCM_HELIX5_SUPPORT
           if (SOC_IS_HELIX5X(unit)) {
               egr_pkt_attr_cmprsd_bits_g[unit].mmu_cos = 5;
           } else
#endif
           {
               egr_pkt_attr_cmprsd_bits_g[unit].mmu_cos = 4;
           }

           egr_pkt_attr_cmprsd_bits_g[unit].mmu_cos_pos = next_pos;
           egr_pkt_attr_cmprsd_bits_g[unit].mmu_cos_mask =
               (1 << egr_pkt_attr_cmprsd_bits_g[unit].mmu_cos) - 1;

           /* Increment of next_pos needed if more attributes are added */
       }

       /* Ingress bits initialization */
       next_pos = 0;
       ing_pkt_attr_cmprsd_bits_g[unit].ip_pkt = 1;
       ing_pkt_attr_cmprsd_bits_g[unit].ip_pkt_pos = next_pos;
       ing_pkt_attr_cmprsd_bits_g[unit].ip_pkt_mask =
                           (1<<ing_pkt_attr_cmprsd_bits_g[unit].ip_pkt) - 1;
       next_pos += ing_pkt_attr_cmprsd_bits_g[unit].ip_pkt;

       ing_pkt_attr_cmprsd_bits_g[unit].drop = 1;
       ing_pkt_attr_cmprsd_bits_g[unit].drop_pos = next_pos;
       ing_pkt_attr_cmprsd_bits_g[unit].drop_mask =
                           (1<<ing_pkt_attr_cmprsd_bits_g[unit].drop) - 1;
       next_pos += ing_pkt_attr_cmprsd_bits_g[unit].drop;

       ing_pkt_attr_cmprsd_bits_g[unit].svp_type =
           (soc_feature(unit, soc_feature_multiple_split_horizon_group)) ? 3 : 1;
       ing_pkt_attr_cmprsd_bits_g[unit].svp_type_pos = next_pos;
       ing_pkt_attr_cmprsd_bits_g[unit].svp_type_mask =
                           (1<<ing_pkt_attr_cmprsd_bits_g[unit].svp_type) - 1;
       next_pos += ing_pkt_attr_cmprsd_bits_g[unit].svp_type;

       ing_pkt_attr_cmprsd_bits_g[unit].pkt_resolution = 6;
       ing_pkt_attr_cmprsd_bits_g[unit].pkt_resolution_pos = next_pos;
       ing_pkt_attr_cmprsd_bits_g[unit].pkt_resolution_mask =
                           (1<<ing_pkt_attr_cmprsd_bits_g[unit].pkt_resolution) - 1;
       next_pos += ing_pkt_attr_cmprsd_bits_g[unit].pkt_resolution;

       /* PACKET_RESOLUTION (10:5) + SVP_NETWORK_GROUP(4:2) + DROP (1:1) is
        * 10 bits but compresed to 8 bits PKT_RES_FN (8:1). Position of
        * following attributes asjust by -2.
        */
       next_pos -= 2;
       ing_pkt_attr_cmprsd_bits_g[unit].tos_ecn = 2;
       ing_pkt_attr_cmprsd_bits_g[unit].tos_ecn_pos = next_pos;
       ing_pkt_attr_cmprsd_bits_g[unit].tos_ecn_mask =
                           (1<<ing_pkt_attr_cmprsd_bits_g[unit].tos_ecn) - 1;
       next_pos += ing_pkt_attr_cmprsd_bits_g[unit].tos_ecn;

       ing_pkt_attr_cmprsd_bits_g[unit].tos_dscp = 6;
       ing_pkt_attr_cmprsd_bits_g[unit].tos_dscp_pos = next_pos;
       ing_pkt_attr_cmprsd_bits_g[unit].tos_dscp_mask =
                           (1<<ing_pkt_attr_cmprsd_bits_g[unit].tos_dscp) - 1;
       next_pos += ing_pkt_attr_cmprsd_bits_g[unit].tos_dscp;

       ing_pkt_attr_cmprsd_bits_g[unit].ing_port = 8;

#ifdef BCM_FIREBOLT6_SUPPORT
       if (SOC_IS_FIREBOLT6(unit)) {
           /* Increased to 9 bits to accomodate 512 channels */
           ing_pkt_attr_cmprsd_bits_g[unit].ing_port = 9;
       }
#endif 
       ing_pkt_attr_cmprsd_bits_g[unit].ing_port_pos = next_pos;
       ing_pkt_attr_cmprsd_bits_g[unit].ing_port_mask =
                           (1<<ing_pkt_attr_cmprsd_bits_g[unit].ing_port) - 1;
       next_pos += ing_pkt_attr_cmprsd_bits_g[unit].ing_port;

       ing_pkt_attr_cmprsd_bits_g[unit].inner_dot1p = 3;
       ing_pkt_attr_cmprsd_bits_g[unit].inner_dot1p_pos = next_pos;
       ing_pkt_attr_cmprsd_bits_g[unit].inner_dot1p_mask =
                           (1<<ing_pkt_attr_cmprsd_bits_g[unit].inner_dot1p) - 1;
       next_pos += ing_pkt_attr_cmprsd_bits_g[unit].inner_dot1p;

       ing_pkt_attr_cmprsd_bits_g[unit].outer_dot1p = 3;
       ing_pkt_attr_cmprsd_bits_g[unit].outer_dot1p_pos = next_pos;
       ing_pkt_attr_cmprsd_bits_g[unit].outer_dot1p_mask =
                           (1<<ing_pkt_attr_cmprsd_bits_g[unit].outer_dot1p) - 1;
       next_pos += ing_pkt_attr_cmprsd_bits_g[unit].outer_dot1p;

       ing_pkt_attr_cmprsd_bits_g[unit].vlan_format = 2;
       ing_pkt_attr_cmprsd_bits_g[unit].vlan_format_pos = next_pos;
       ing_pkt_attr_cmprsd_bits_g[unit].vlan_format_mask =
                           (1<<ing_pkt_attr_cmprsd_bits_g[unit].vlan_format) - 1;
       next_pos += ing_pkt_attr_cmprsd_bits_g[unit].vlan_format;

       ing_pkt_attr_cmprsd_bits_g[unit].int_pri = 4;
       ing_pkt_attr_cmprsd_bits_g[unit].int_pri_pos = next_pos;
       ing_pkt_attr_cmprsd_bits_g[unit].int_pri_mask =
                           (1<<ing_pkt_attr_cmprsd_bits_g[unit].int_pri) - 1;
       next_pos += ing_pkt_attr_cmprsd_bits_g[unit].int_pri;

       ing_pkt_attr_cmprsd_bits_g[unit].ifp_cng = 2;
       ing_pkt_attr_cmprsd_bits_g[unit].ifp_cng_pos = next_pos;
       ing_pkt_attr_cmprsd_bits_g[unit].ifp_cng_mask =
                           (1<<ing_pkt_attr_cmprsd_bits_g[unit].ifp_cng) - 1;
       next_pos += ing_pkt_attr_cmprsd_bits_g[unit].ifp_cng;

       ing_pkt_attr_cmprsd_bits_g[unit].cng = 2;
       ing_pkt_attr_cmprsd_bits_g[unit].cng_pos = next_pos;
       ing_pkt_attr_cmprsd_bits_g[unit].cng_mask =
                           (1<<ing_pkt_attr_cmprsd_bits_g[unit].cng) - 1;
   }
#endif
   else {
       egr_pkt_attr_cmprsd_bits_g[unit] = egr_pkt_attr_uncmprsd_bits_g[unit];
       ing_pkt_attr_cmprsd_bits_g[unit] = ing_pkt_attr_uncmprsd_bits_g[unit];
   }
}
/*
 * Function:
 *      _bcm_esw_stat_flex_init_pkt_res_fields
 * Description:
 *      Initialize All Packet Resolution related (static) structures.
 *      Happens only one time.
 *      
 * Parameters:
 *      unit            - (IN) unit number
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 */
void _bcm_esw_stat_flex_init_pkt_res_fields(int unit)
{
  static uint32 init_flag=0;
  if (init_flag==0) {
      _bcm_esw_stat_flex_init_pkt_res_values(
          unit, ing_Single_res,
          sizeof(ing_Single_res)/sizeof(ing_Single_res[0]));
      _bcm_esw_stat_flex_init_pkt_res_values(
          unit,ing_TrafficType_res,
          sizeof(ing_TrafficType_res)/sizeof(ing_TrafficType_res[0]));
      _bcm_esw_stat_flex_init_pkt_res_values(
          unit,ing_DlfAll_res,
          sizeof(ing_DlfAll_res)/sizeof(ing_DlfAll_res[0]));
      _bcm_esw_stat_flex_init_pkt_res_values(
          unit,ing_Typed_res,
          sizeof(ing_Typed_res)/sizeof(ing_Typed_res[0]));
      _bcm_esw_stat_flex_init_pkt_res_values(
          unit,ing_TypedAll_res,
          sizeof(ing_TypedAll_res)/sizeof(ing_TypedAll_res[0]));
      _bcm_esw_stat_flex_init_pkt_res_values(
          unit,ing_SingleWithControl_res,
          sizeof(ing_SingleWithControl_res)/
          sizeof(ing_SingleWithControl_res[0]));
      _bcm_esw_stat_flex_init_pkt_res_values(
          unit,ing_TrafficTypeWithControl_res,
          sizeof(ing_TrafficTypeWithControl_res)/
          sizeof(ing_TrafficTypeWithControl_res[0]));
      _bcm_esw_stat_flex_init_pkt_res_values(
          unit,ing_DlfAllWithControl_res,
          sizeof(ing_DlfAllWithControl_res)/
          sizeof(ing_DlfAllWithControl_res[0]));
      _bcm_esw_stat_flex_init_pkt_res_values(
          unit,ing_TypedWithControl_res,
          sizeof(ing_TypedWithControl_res)/
          sizeof(ing_TypedWithControl_res[0]));
      _bcm_esw_stat_flex_init_pkt_res_values(
          unit,ing_TypedAllWithControl_res,
          sizeof(ing_TypedAllWithControl_res)/
          sizeof(ing_TypedAllWithControl_res[0]));
      _bcm_esw_stat_flex_init_pkt_res_values(
          unit,egr_Single_res,
          sizeof(egr_Single_res)/sizeof(egr_Single_res[0]));
      _bcm_esw_stat_flex_init_pkt_res_values(
          unit,egr_TrafficType_res,
          sizeof(egr_TrafficType_res)/sizeof(egr_TrafficType_res[0]));
      init_flag=1;
  }
}
uint32 _bcm_esw_stat_flex_get_pkt_res_value(int unit,uint32 pkt_res_field)
{
   uint32 *flex_pkt_res_values=NULL;
   uint32 flex_pkt_res_values_count=0;
  
   if (SOC_IS_KATANAX(unit)) {
       flex_pkt_res_values = _flex_pkt_res_values_katana;
       flex_pkt_res_values_count = sizeof(_flex_pkt_res_values_katana)/
                                   sizeof(_flex_pkt_res_values_katana[0]);
   }
   if (SOC_IS_TRIUMPH3(unit) || SOC_IS_KATANA2(unit)) {
       flex_pkt_res_values = _flex_pkt_res_values_tr3;
       flex_pkt_res_values_count = sizeof(_flex_pkt_res_values_tr3)/
                                   sizeof(_flex_pkt_res_values_tr3[0]);
   }
   if (SOC_IS_TD2_TT2(unit)) {
       flex_pkt_res_values = _flex_pkt_res_values_td2;
       flex_pkt_res_values_count = sizeof(_flex_pkt_res_values_td2)/
                                   sizeof(_flex_pkt_res_values_td2[0]);
   }
   if ( flex_pkt_res_values_count == 0) {
        LOG_WARN(BSL_LS_BCM_FLEXCTR,
                 (BSL_META_U(unit,
                             "CONFIG ERROR: flex_pkt_res_values_count=0\n")));
        return 0;
   }
   if (pkt_res_field >= flex_pkt_res_values_count) {
       LOG_WARN(BSL_LS_BCM_FLEXCTR,
                 (BSL_META_U(unit,
                             "Flex Pkt Resolution Value Initialization failed"
                              "pkt_res_field=%d > flex_pkt_res_values_count=%d=0\n"),
                  pkt_res_field, flex_pkt_res_values_count));
           return 0;
   }
   return flex_pkt_res_values[pkt_res_field];
}

/* Create Customized Stat Group mode for given Counter Attributes:UpdateMap  */
static 
int _bcm_stat_flex_update_map(
     bcm_stat_flex_direction_t                 direction,
     bcm_stat_flex_attr_t                      *attr,
     uint8                                     offset ,
     uint8                                     counter)
{
    if (direction == bcmStatFlexDirectionIngress) {
        if (attr->ing_attr.packet_attr_type == 
                bcmStatFlexPacketAttrTypeCompressed) {
            if ((attr->ing_attr.cmprsd_attr_selectors.
                        offset_table_map[offset].offset != counter) &&
                    (attr->ing_attr.cmprsd_attr_selectors.
                     offset_table_map[offset].count_enable == 1)) {
                return BCM_E_CONFIG;
            }
            attr->ing_attr.cmprsd_attr_selectors.
                offset_table_map[offset].offset=counter;
            attr->ing_attr.cmprsd_attr_selectors.
                offset_table_map[offset].count_enable=1;
        } else {
            if ((attr->ing_attr.uncmprsd_attr_selectors.
                        offset_table_map[offset].offset != counter) &&
                    (attr->ing_attr.uncmprsd_attr_selectors.
                     offset_table_map[offset].count_enable == 1)) {
                return BCM_E_CONFIG;
            }
            attr->ing_attr.uncmprsd_attr_selectors.
                offset_table_map[offset].offset=counter;
            attr->ing_attr.uncmprsd_attr_selectors.
                offset_table_map[offset].count_enable=1;
        }
     } else {
        if (attr->egr_attr.packet_attr_type == 
                bcmStatFlexPacketAttrTypeCompressed) {
            if ((attr->egr_attr.cmprsd_attr_selectors.
                        offset_table_map[offset].offset != counter) &&
                    (attr->egr_attr.cmprsd_attr_selectors.
                     offset_table_map[offset].count_enable == 1)) {
                return BCM_E_CONFIG;
            }
            attr->egr_attr.cmprsd_attr_selectors.
                offset_table_map[offset].offset=counter;
            attr->egr_attr.cmprsd_attr_selectors.
                offset_table_map[offset].count_enable=1;

        } else {
            if((attr->egr_attr.uncmprsd_attr_selectors.
                        offset_table_map[offset].offset != counter) &&
                    (attr->egr_attr.uncmprsd_attr_selectors.
                     offset_table_map[offset].count_enable == 1)) {
                return BCM_E_CONFIG;
            }
            attr->egr_attr.uncmprsd_attr_selectors.
                offset_table_map[offset].offset=counter;
            attr->egr_attr.uncmprsd_attr_selectors.
                offset_table_map[offset].count_enable=1;
        }
    }

    return BCM_E_NONE;
}

static 
uint8 _bcm_stat_flex_get_num_bits(uint8 value) 
{
      if (value <= 2) {
          return 1;
      }
      if (value <= 4) {
          return 2;
      }
      if (value <= 8) {
          return 3;
      }
      if (value <= 16) {
          return 4;
      }
      if (value <= 32) {
          return 5;
      }
      if (value <= 64) {
          return 6;
      }
      if (value <= 128) {
          return 7;
      } else {
          return 8;
      }
}

STATIC
int _bcm_esw_stat_flex_compressed_attr_map_update(
        int unit,bcm_stat_flex_direction_t direction,
        bcm_stat_flex_attribute_t *pkt_attr_selectors,
        bcm_stat_flex_ing_pkt_attr_bits_t *ing_cmprsd_pkt_attr_bits,
        bcm_stat_flex_egr_pkt_attr_bits_t *egr_cmprsd_pkt_attr_bits)
{
    int rv = BCM_E_NONE;
    uint32 i = 0;
    _bcm_stat_flex_compressed_mode_attr_sel_map_t *cmprsd_attr_map = NULL;

    /* Ingress */
    if (direction == bcmStatFlexDirectionIngress) {
        cmprsd_attr_map = global_stat_flex_compressed_attr_map[unit];
        if (cmprsd_attr_map == NULL ||
                ing_cmprsd_pkt_attr_bits == NULL) {
            return BCM_E_MEMORY;
        }

        /* save compressed combined flag for pre_ifp_color */
        if (pkt_attr_selectors->pre_ifp_color) {
            cmprsd_attr_map->combine_pre_ifp_color_flags =
                pkt_attr_selectors->combine_pre_ifp_color_flags;
        }

        /* save compressed combined flag for ifp_color */
        if (pkt_attr_selectors->ifp_color) {
            cmprsd_attr_map->combine_ifp_color_flags =
                pkt_attr_selectors->combine_ifp_color_flags;
        }


        /* save compressed combined flag for int_pri */
        if (pkt_attr_selectors->int_pri != 0) {
            cmprsd_attr_map->combine_int_pri_flags =
                pkt_attr_selectors->combine_int_pri_flags;
        }

        /* save compressed combined flag for vlan_format */
        if (pkt_attr_selectors->vlan_format != 0) {
            cmprsd_attr_map->combine_vlan_format_flags =
                pkt_attr_selectors->combine_vlan_format_flags;
        }

        /* save compressed combined flag for outer_dot1p */
        if (pkt_attr_selectors->outer_dot1p != 0) {
            cmprsd_attr_map->combine_outer_dot1p_flags =
                pkt_attr_selectors->combine_outer_dot1p_flags;
        }

        /* save compressed combined flag for inner_dot1p */
        if (pkt_attr_selectors->inner_dot1p != 0) {
            cmprsd_attr_map->combine_inner_dot1p_flags =
                pkt_attr_selectors->combine_inner_dot1p_flags;
        }

        /* save port attributes */
        if (pkt_attr_selectors->port != 0) {
            /* egr_pkt_attr_cmprsd_bits_g[unit].egr_port
             * egr_pkt_attr_cmprsd_bits_g[unit].ing_port */
            for (i = 0; i < BCM_STAT_FLEX_BIT_ARRAY_SIZE; i++) {
                cmprsd_attr_map->combine_value_array[bcmStatFlexAttrPort][i] =
                    pkt_attr_selectors->combine_value_array[bcmStatFlexAttrPort][i];
            }
        }

        /* save tos_dscp attributes */
        if (pkt_attr_selectors->tos_dscp != 0) {
            for (i = 0; i < BCM_STAT_FLEX_BIT_ARRAY_SIZE; i++) {
                cmprsd_attr_map->combine_value_array[bcmStatFlexAttrTosDscp][i] =
                    pkt_attr_selectors->combine_value_array[bcmStatFlexAttrTosDscp][i];
            }
        }

        /* save tos_ecn attributes */
        if (pkt_attr_selectors->tos_ecn != 0) {
            for (i = 0; i < BCM_STAT_FLEX_BIT_ARRAY_SIZE; i++) {
                cmprsd_attr_map->combine_value_array[bcmStatFlexAttrTosEcn][i] =
                    pkt_attr_selectors->combine_value_array[bcmStatFlexAttrTosEcn][i];
            }
        }

        /* save compressed combined flag for pkt_resolution */
        if (pkt_attr_selectors->pkt_resolution != 0) {
            cmprsd_attr_map->combine_pkt_resolution_flags =
                pkt_attr_selectors->combine_pkt_resolution_flags;
        }

        /* save svp_type attributes */
        if (pkt_attr_selectors->svp != 0) {
            for (i = 0; i < BCM_STAT_FLEX_BIT_ARRAY_SIZE; i++) {
                cmprsd_attr_map->combine_value_array[bcmStatFlexAttrSvp][i] =
                    pkt_attr_selectors->combine_value_array[bcmStatFlexAttrSvp][i];
            }
        }

        /* save compressed combined flag for drop */
        if (pkt_attr_selectors->drop != 0) {
            cmprsd_attr_map->combine_drop_flags =
                pkt_attr_selectors->combine_drop_flags;
        }

        /* save compressed combined flag for ip_pkt */
        if (pkt_attr_selectors->ip_pkt != 0) {
            cmprsd_attr_map->combine_ip_pkt_flags =
                pkt_attr_selectors->combine_ip_pkt_flags;
        }
    }

     /* Egress */
    if (direction == bcmStatFlexDirectionEgress) {
        cmprsd_attr_map = egr_global_stat_flex_compressed_attr_map[unit];
        if (cmprsd_attr_map == NULL ||
                egr_cmprsd_pkt_attr_bits == NULL) {
            return BCM_E_MEMORY;
        }
#if defined(BCM_TOMAHAWK_SUPPORT) || defined(BCM_TRIDENT3_SUPPORT)
        if (soc_feature(unit, soc_feature_flex_stat_egr_queue_congestion_marked)) {
            if (pkt_attr_selectors->mmu_cos != 0) {
                cmprsd_attr_map->combine_mmu_cos_flags =
                    pkt_attr_selectors->combine_mmu_cos_flags;
            }

            if (pkt_attr_selectors->uc_queueing != 0) {
                cmprsd_attr_map->combine_uc_queueing_flags =
                    pkt_attr_selectors->combine_uc_queueing_flags;
            }

            if (pkt_attr_selectors->congestion_marked != 0) {
                cmprsd_attr_map->combine_congestion_marked_flags =
                    pkt_attr_selectors->combine_congestion_marked_flags;
            }
        }
#endif
        /* save compressed combined flag for int_pri */
        if (pkt_attr_selectors->int_pri != 0) {
            cmprsd_attr_map->combine_int_pri_flags =
                pkt_attr_selectors->combine_int_pri_flags;
        }

        /* save compressed combined flag for vlan_format */
        if (pkt_attr_selectors->vlan_format != 0) {
            cmprsd_attr_map->combine_vlan_format_flags =
                pkt_attr_selectors->combine_vlan_format_flags;
        }

        /* save compressed combined flag for outer_dot1p */
        if (pkt_attr_selectors->outer_dot1p != 0) {
            cmprsd_attr_map->combine_outer_dot1p_flags =
                pkt_attr_selectors->combine_outer_dot1p_flags;
        }

        /* save compressed combined flag for inner_dot1p */
        if (pkt_attr_selectors->inner_dot1p != 0) {
            cmprsd_attr_map->combine_inner_dot1p_flags =
                pkt_attr_selectors->combine_inner_dot1p_flags;
        }

        /* save port attributes */
        if (pkt_attr_selectors->port != 0) {
            for (i = 0; i < BCM_STAT_FLEX_BIT_ARRAY_SIZE; i++) {
                cmprsd_attr_map->combine_value_array[bcmStatFlexAttrPort][i] =
                    pkt_attr_selectors->combine_value_array[bcmStatFlexAttrPort][i];
            }
        }

        /* save tos_dscp attributes */
        if (pkt_attr_selectors->tos_dscp != 0) {
            for (i = 0; i < BCM_STAT_FLEX_BIT_ARRAY_SIZE; i++) {
                cmprsd_attr_map->combine_value_array[bcmStatFlexAttrTosDscp][i] =
                    pkt_attr_selectors->combine_value_array[bcmStatFlexAttrTosDscp][i];
            }
        }

        /* save tos_ecn attributes */
        if (pkt_attr_selectors->tos_ecn != 0) {
            for (i = 0; i < BCM_STAT_FLEX_BIT_ARRAY_SIZE; i++) {
                cmprsd_attr_map->combine_value_array[bcmStatFlexAttrTosEcn][i] =
                    pkt_attr_selectors->combine_value_array[bcmStatFlexAttrTosEcn][i];
            }
        }

        /* save compressed combined flag for pkt_resolution */
        if (pkt_attr_selectors->pkt_resolution != 0) {
            cmprsd_attr_map->combine_pkt_resolution_flags =
                pkt_attr_selectors->combine_pkt_resolution_flags;
        }

        /* save compressed combined flags 2 for pkt_resolution */
        if (pkt_attr_selectors->pkt_resolution != 0) {
            cmprsd_attr_map->combine_pkt_resolution_high_flags =
                pkt_attr_selectors->combine_pkt_resolution_high_flags;
        }
        
        /* save svp_type attributes */
        if (pkt_attr_selectors->svp != 0) {
            for (i = 0; i < BCM_STAT_FLEX_BIT_ARRAY_SIZE; i++) {
                cmprsd_attr_map->combine_value_array[bcmStatFlexAttrSvp][i] =
                    pkt_attr_selectors->combine_value_array[bcmStatFlexAttrSvp][i];
            }
        }

        /* save dvp attributes */
        if (pkt_attr_selectors->dvp != 0) {
            for (i = 0; i < BCM_STAT_FLEX_BIT_ARRAY_SIZE; i++) {
                cmprsd_attr_map->combine_value_array[bcmStatFlexAttrDvp][i] =
                    pkt_attr_selectors->combine_value_array[bcmStatFlexAttrDvp][i];
            }
        }

        /* save compressed combined flag for drop */
        if (pkt_attr_selectors->drop != 0) {
            cmprsd_attr_map->combine_drop_flags =
                pkt_attr_selectors->combine_drop_flags;
        }

        /* save compressed combined flag for ip_pkt */
        if (pkt_attr_selectors->ip_pkt != 0) {
            cmprsd_attr_map->combine_ip_pkt_flags =
                pkt_attr_selectors->combine_ip_pkt_flags;
        }
    }
    return rv;
}

STATIC
int _bcm_stat_flex_compressed_attr_selectors_verify(
    int unit,
    bcm_stat_flex_direction_t direction,
    bcm_stat_flex_packet_attr_type_t type,
    bcm_stat_flex_attribute_t *pkt_attr_selectors,
    bcm_stat_flex_ing_pkt_attr_bits_t *ing_cmprsd_pkt_attr_bits,
    bcm_stat_flex_egr_pkt_attr_bits_t *egr_cmprsd_pkt_attr_bits)
{
    int rv = BCM_E_NONE;
    uint32 i = 0;
    uint32 combine_flags1 = 0;
    uint32 combine_flags2 = 0;
    uint32 combine_flags3 = 0;
    _bcm_stat_flex_compressed_mode_attr_sel_map_t *cmprsd_attr_map = NULL;

    if (type !=  bcmStatFlexPacketAttrTypeCompressed) {
         return BCM_E_PARAM;
    }

    if (direction == bcmStatFlexDirectionIngress) {
        cmprsd_attr_map = global_stat_flex_compressed_attr_map[unit];
        /* No compression table resource is in use */
        if (cmprsd_attr_map == NULL) {
            return BCM_E_MEMORY;
        }
        /* check pre_ifp_color,ifp_color,int_pri attr flags */
        if ((pkt_attr_selectors->pre_ifp_color != 0) ||
                (pkt_attr_selectors->ifp_color) ||
                (pkt_attr_selectors->int_pri)) {
            /* If ref_count is non-zero, match attribute values. */
            if (cmprsd_attr_map->ref_counts[ing_pkt_attr_pri_cng_map] != 0) {
                SHR_BITOR_RANGE(&pkt_attr_selectors->combine_pre_ifp_color_flags,
                        &cmprsd_attr_map->combine_pre_ifp_color_flags,
                        0, 32, &combine_flags1);
                SHR_BITOR_RANGE(&pkt_attr_selectors->combine_ifp_color_flags,
                        &cmprsd_attr_map->combine_ifp_color_flags,
                        0, 32, &combine_flags2);
                SHR_BITOR_RANGE(&pkt_attr_selectors->combine_int_pri_flags,
                        &cmprsd_attr_map->combine_int_pri_flags,
                        0, 32, &combine_flags3);

                if ((combine_flags1 != cmprsd_attr_map->combine_pre_ifp_color_flags) ||
                        (combine_flags2 != cmprsd_attr_map->combine_ifp_color_flags) ||
                        (combine_flags3 != cmprsd_attr_map->combine_int_pri_flags)) {
                    LOG_VERBOSE(BSL_LS_BCM_FLEXCTR, (BSL_META_U(unit, "ING_PRI_CNG_MAP Compression tables cannot be modified\n")));
                    return BCM_E_PARAM;
                }
                /* Update combined flags */
                pkt_attr_selectors->combine_pre_ifp_color_flags = combine_flags1;
                pkt_attr_selectors->combine_ifp_color_flags = combine_flags2;
                pkt_attr_selectors->combine_int_pri_flags = combine_flags3;
            }
        }


        /* check vlan_format,outer_dot1p,inner_dot1p attr flags */
        if ((pkt_attr_selectors->vlan_format != 0) ||
                (pkt_attr_selectors->outer_dot1p) ||
                (pkt_attr_selectors->inner_dot1p)) {
            /* If ref_count is non-zero, match attribute values. */
            if (cmprsd_attr_map->ref_counts[ing_pkt_attr_pkt_pri_map] != 0) {
                SHR_BITOR_RANGE(&pkt_attr_selectors->combine_vlan_format_flags,
                        &cmprsd_attr_map->combine_vlan_format_flags,
                        0, 32, &combine_flags1);
                SHR_BITOR_RANGE(&pkt_attr_selectors->combine_outer_dot1p_flags,
                        &cmprsd_attr_map->combine_outer_dot1p_flags,
                        0, 32, &combine_flags2);
                SHR_BITOR_RANGE(&pkt_attr_selectors->combine_inner_dot1p_flags,
                        &cmprsd_attr_map->combine_inner_dot1p_flags,
                        0, 32, &combine_flags3);

                if ((combine_flags1 != cmprsd_attr_map->combine_vlan_format_flags) ||
                        (combine_flags2 != cmprsd_attr_map->combine_outer_dot1p_flags) ||
                        (combine_flags3 != cmprsd_attr_map->combine_inner_dot1p_flags)) {
                    LOG_VERBOSE(BSL_LS_BCM_FLEXCTR, (BSL_META_U(unit, "ING_PKT_PRI_MAP Compression tables cannot be modified\n")));
                    return BCM_E_PARAM;
                }
                /* Update combined flags */
                pkt_attr_selectors->combine_vlan_format_flags = combine_flags1;
                pkt_attr_selectors->combine_outer_dot1p_flags = combine_flags2;
                pkt_attr_selectors->combine_inner_dot1p_flags = combine_flags3;
            }
        }

        if (pkt_attr_selectors->port != 0) {
            /* If ref_count is non-zero, match attribute values */
            if (cmprsd_attr_map->ref_counts[ing_pkt_attr_port_map] != 0) {
                for (i = 0; i < BCM_STAT_FLEX_BIT_ARRAY_SIZE; i++) {
                    SHR_BITOR_RANGE(&pkt_attr_selectors->combine_value_array
                            [bcmStatFlexAttrPort][i],
                            &cmprsd_attr_map->combine_value_array
                            [bcmStatFlexAttrPort][i],
                            0, 32, & combine_flags1);
                    if (combine_flags1 != cmprsd_attr_map->combine_value_array
                            [bcmStatFlexAttrPort][i]) {
                    LOG_VERBOSE(BSL_LS_BCM_FLEXCTR, (BSL_META_U(unit, "ING_PORT_MAP Compression tables cannot be modified\n")));
                        return BCM_E_PARAM;
                    }
                    /* Update combined flags */
                    pkt_attr_selectors->combine_value_array[bcmStatFlexAttrPort][i] =
                        combine_flags1;
                }
            }
        }

        if ((pkt_attr_selectors->tos_dscp != 0) ||
                (pkt_attr_selectors->tos_ecn)) {
            /* If ref_count is non-zero, match attribute values. */
            if (cmprsd_attr_map->ref_counts[ing_pkt_attr_tos_map] != 0) {
                for (i = 0; i < BCM_STAT_FLEX_BIT_ARRAY_SIZE; i++) {
                    SHR_BITOR_RANGE(&pkt_attr_selectors->combine_value_array
                            [bcmStatFlexAttrTosDscp][i],
                            &cmprsd_attr_map->combine_value_array
                            [bcmStatFlexAttrTosDscp][i],
                            0, 32, & combine_flags1);
                    SHR_BITOR_RANGE(&pkt_attr_selectors->combine_value_array
                            [bcmStatFlexAttrTosEcn][i],
                            &cmprsd_attr_map->combine_value_array
                            [bcmStatFlexAttrTosEcn][i],
                            0, 32, & combine_flags2);
                    if ((combine_flags1 != cmprsd_attr_map->combine_value_array
                                [bcmStatFlexAttrTosDscp][i]) ||
                            (combine_flags2 != cmprsd_attr_map->combine_value_array
                             [bcmStatFlexAttrTosEcn][i])) {
                    LOG_VERBOSE(BSL_LS_BCM_FLEXCTR, (BSL_META_U(unit, "ING_TOS_MAP Compression tables cannot be modified\n")));
                        return BCM_E_PARAM;
                    }
                    /* Update combined flags */
                    pkt_attr_selectors->combine_value_array
                        [bcmStatFlexAttrTosDscp][i] = combine_flags1;
                    pkt_attr_selectors->combine_value_array
                        [bcmStatFlexAttrTosEcn][i] = combine_flags2;
                }
            }
        }

        if ((pkt_attr_selectors->pkt_resolution != 0) ||
                (pkt_attr_selectors->svp) ||
                (pkt_attr_selectors->drop)) {
            /* If ref_count is non-zero, match */
            if (cmprsd_attr_map->ref_counts[ing_pkt_attr_pkt_res_map] != 0) {
                SHR_BITOR_RANGE(&pkt_attr_selectors->combine_pkt_resolution_flags,
                        &cmprsd_attr_map->combine_pkt_resolution_flags,
                        0, 32, &combine_flags1);
                SHR_BITOR_RANGE(&pkt_attr_selectors->combine_drop_flags,
                        &cmprsd_attr_map->combine_drop_flags,
                        0, 32, &combine_flags2);
                if ((combine_flags1 != cmprsd_attr_map->combine_pkt_resolution_flags) ||
                        (combine_flags2 != cmprsd_attr_map->combine_drop_flags)) {
                    LOG_VERBOSE(BSL_LS_BCM_FLEXCTR, (BSL_META_U(unit, "ING_PKT_RES_MAP Compression tables cannot be modified\n")));
                    return BCM_E_PARAM;
                }
                for (i = 0; i < BCM_STAT_FLEX_BIT_ARRAY_SIZE; i++) {
                    SHR_BITOR_RANGE(&pkt_attr_selectors->combine_value_array
                            [bcmStatFlexAttrSvp][i],
                            &cmprsd_attr_map->combine_value_array
                            [bcmStatFlexAttrSvp][i],
                            0, 32, & combine_flags3);
                    if (combine_flags3 != cmprsd_attr_map->combine_value_array
                            [bcmStatFlexAttrSvp][i]) {
                    LOG_VERBOSE(BSL_LS_BCM_FLEXCTR, (BSL_META_U(unit, "ING_PKT_RES_MAP Compression tables cannot be modified\n")));
                        return BCM_E_PARAM;
                    }
                    /* Update combined flags */
                    pkt_attr_selectors->combine_value_array
                        [bcmStatFlexAttrSvp][i] = combine_flags3;
                }
                /* Update combine_xxx_flags */
                pkt_attr_selectors->combine_pkt_resolution_flags = combine_flags1;
                pkt_attr_selectors->combine_drop_flags = combine_flags2;
            }
        }
    }

    if (direction == bcmStatFlexDirectionEgress) {
        cmprsd_attr_map = egr_global_stat_flex_compressed_attr_map[unit];
        /* No compression table resource is in use */
        if (cmprsd_attr_map == NULL) {
            return BCM_E_MEMORY;
        }

        /* check int_pri attr flags */
        if(pkt_attr_selectors->int_pri) {
            /* If ref_count is non-zero, match attribute values. */
            if (cmprsd_attr_map->ref_counts[egr_pkt_attr_pri_cng_map] != 0) {
                SHR_BITOR_RANGE(&pkt_attr_selectors->combine_int_pri_flags,
                        &cmprsd_attr_map->combine_int_pri_flags,
                        0, 32, &combine_flags1);

                if(combine_flags1 != cmprsd_attr_map->combine_int_pri_flags) {
                    return BCM_E_PARAM;
                }
            }
            /* Update combined flags */
            pkt_attr_selectors->combine_int_pri_flags = combine_flags1;
        }

        /* check vlan_format,outer_dot1p,inner_dot1p attr flags */
        if ((pkt_attr_selectors->vlan_format != 0) ||
                (pkt_attr_selectors->outer_dot1p) ||
                (pkt_attr_selectors->inner_dot1p)) {
            /* If ref_count is non-zero, match attribute values. */
            if (cmprsd_attr_map->ref_counts[egr_pkt_attr_pkt_pri_map] != 0) {
                SHR_BITOR_RANGE(&pkt_attr_selectors->combine_vlan_format_flags,
                        &cmprsd_attr_map->combine_vlan_format_flags,
                        0, 32, &combine_flags1);
                SHR_BITOR_RANGE(&pkt_attr_selectors->combine_outer_dot1p_flags,
                        &cmprsd_attr_map->combine_outer_dot1p_flags,
                        0, 32, &combine_flags2);
                SHR_BITOR_RANGE(&pkt_attr_selectors->combine_inner_dot1p_flags,
                        &cmprsd_attr_map->combine_inner_dot1p_flags,
                        0, 32, &combine_flags3);

                if ((combine_flags1 != cmprsd_attr_map->combine_vlan_format_flags) ||
                        (combine_flags2 != cmprsd_attr_map->combine_outer_dot1p_flags) ||
                        (combine_flags3 != cmprsd_attr_map->combine_inner_dot1p_flags)) {
                    return BCM_E_PARAM;
                }
                /* Update combined flags */
                pkt_attr_selectors->combine_vlan_format_flags = combine_flags1;
                pkt_attr_selectors->combine_outer_dot1p_flags = combine_flags2;
                pkt_attr_selectors->combine_inner_dot1p_flags = combine_flags3;
            }
        }

        if (pkt_attr_selectors->port != 0) {
            /* If ref_count is non-zero, match attribute values */
            if (cmprsd_attr_map->ref_counts[egr_pkt_attr_port_map] != 0) {
                for (i = 0; i < BCM_STAT_FLEX_BIT_ARRAY_SIZE; i++) {
                    SHR_BITOR_RANGE(&pkt_attr_selectors->combine_value_array
                            [bcmStatFlexAttrPort][i],
                            &cmprsd_attr_map->combine_value_array
                            [bcmStatFlexAttrPort][i],
                            0, 32, & combine_flags1);
                    if (combine_flags1 != cmprsd_attr_map->combine_value_array
                            [bcmStatFlexAttrPort][i]) {
                        return BCM_E_PARAM;
                    }
                    /* Update combined flags */
                    pkt_attr_selectors->combine_value_array[bcmStatFlexAttrPort][i] =
                        combine_flags1;
                }
            }
        }

        if ((pkt_attr_selectors->tos_dscp != 0) ||
                (pkt_attr_selectors->tos_ecn)) {
            /* If ref_count is non-zero, match attribute values. */
            if (cmprsd_attr_map->ref_counts[egr_pkt_attr_tos_map] != 0) {
                for (i = 0; i < BCM_STAT_FLEX_BIT_ARRAY_SIZE; i++) {
                    SHR_BITOR_RANGE(&pkt_attr_selectors->combine_value_array
                            [bcmStatFlexAttrTosDscp][i],
                            &cmprsd_attr_map->combine_value_array
                            [bcmStatFlexAttrTosDscp][i],
                            0, 32, & combine_flags1);
                    SHR_BITOR_RANGE(&pkt_attr_selectors->combine_value_array
                            [bcmStatFlexAttrTosEcn][i],
                            &cmprsd_attr_map->combine_value_array
                            [bcmStatFlexAttrTosEcn][i],
                            0, 32, & combine_flags2);
                    if ((combine_flags1 != cmprsd_attr_map->combine_value_array
                                [bcmStatFlexAttrTosDscp][i]) ||
                            (combine_flags2 != cmprsd_attr_map->combine_value_array
                             [bcmStatFlexAttrTosEcn][i])) {
                        return BCM_E_PARAM;
                    }
                    /* Update combined flags */
                    pkt_attr_selectors->combine_value_array
                        [bcmStatFlexAttrTosDscp][i] = combine_flags1;
                    pkt_attr_selectors->combine_value_array
                        [bcmStatFlexAttrTosEcn][i] = combine_flags2;
                }
            }
        }
        /* add dvp_type for egression direction */
        if ((pkt_attr_selectors->pkt_resolution != 0) ||
                (pkt_attr_selectors->svp) ||
                (pkt_attr_selectors->dvp) ||
                (pkt_attr_selectors->drop)) {
            /* If ref_count is non-zero, match */
            if (cmprsd_attr_map->ref_counts[egr_pkt_attr_pkt_res_map] != 0) {
                SHR_BITOR_RANGE(&pkt_attr_selectors->combine_pkt_resolution_flags,
                        &cmprsd_attr_map->combine_pkt_resolution_flags,
                        0, 32, &combine_flags1);
                SHR_BITOR_RANGE(&pkt_attr_selectors->combine_drop_flags,
                        &cmprsd_attr_map->combine_drop_flags,
                        0, 32, &combine_flags2);
                if ((combine_flags1 != cmprsd_attr_map->combine_pkt_resolution_flags) ||
                        (combine_flags2 != cmprsd_attr_map->combine_drop_flags)) {
                    return BCM_E_RESOURCE;
                }
                if (pkt_attr_selectors->svp) {
                    for (i = 0; i < BCM_STAT_FLEX_BIT_ARRAY_SIZE; i++) {
                        SHR_BITOR_RANGE(&pkt_attr_selectors->combine_value_array
                                [bcmStatFlexAttrSvp][i],
                                &cmprsd_attr_map->combine_value_array
                                [bcmStatFlexAttrSvp][i],
                                0, 32, & combine_flags3);
                        if (combine_flags3 != cmprsd_attr_map->combine_value_array
                                [bcmStatFlexAttrSvp][i]) {
                            return BCM_E_PARAM;
                        }
                        /* Update combined flags */
                        pkt_attr_selectors->combine_value_array
                            [bcmStatFlexAttrSvp][i] = combine_flags3;
                    }
                }

                if (pkt_attr_selectors->dvp) {
                    for (i = 0; i < BCM_STAT_FLEX_BIT_ARRAY_SIZE; i++) {
                        SHR_BITOR_RANGE(&pkt_attr_selectors->combine_value_array
                                [bcmStatFlexAttrDvp][i],
                                &cmprsd_attr_map->combine_value_array
                                [bcmStatFlexAttrDvp][i],
                                0, 32, & combine_flags3);
                        if (combine_flags3 != cmprsd_attr_map->combine_value_array
                                [bcmStatFlexAttrDvp][i]) {
                            return BCM_E_PARAM;
                        }
                        /* Update combined flags */
                        pkt_attr_selectors->combine_value_array
                            [bcmStatFlexAttrDvp][i] = combine_flags3;
                    }
                }
                /* Update combine_xxx_flags */
                pkt_attr_selectors->combine_pkt_resolution_flags = combine_flags1;
                pkt_attr_selectors->combine_drop_flags = combine_flags2;
            }
        }
    }
    return rv;
}

/* Create Customized Stat Group mode for given Counter Attributes:CreateMode  */
static 
bcm_error_t _bcm_esw_stat_group_mode_associate_id(
            int unit,
            uint32 flags,
            bcm_stat_flex_attribute_t  *flex_attribute,
            uint32 *mode_id)
{
    bcm_stat_flex_mode_t     mode=0;
    bcm_error_t              rv=BCM_E_NONE;
    bcm_stat_flex_attr_t     *attr=NULL;
    bcm_stat_flex_ing_attr_t *ing_attr=NULL;
    bcm_stat_flex_egr_attr_t *egr_attr=NULL;
    bcm_stat_flex_ing_cmprsd_attr_selectors_t *ing_cmprsd_attr_selectors=NULL;
    bcm_stat_flex_ing_pkt_attr_bits_t         *ing_cmprsd_pkt_attr_bits=NULL;

    bcm_stat_flex_egr_cmprsd_attr_selectors_t *egr_cmprsd_attr_selectors=NULL;
    bcm_stat_flex_egr_pkt_attr_bits_t         *egr_cmprsd_pkt_attr_bits=NULL;
    bcm_stat_flex_direction_t                 direction =
                                              bcmStatFlexDirectionIngress;
    uint8                                     total_bits=0;
    uint16                                    counter=0;
    uint8                                     loop=0;
    uint16                                    *offset_array[8]={NULL};
    uint8                                     shift_by_bits=0;
    uint16                                    temp_count=0;
    uint16                                    max_count=0;
    uint8         *map_array[bcmStatGroupModeAttrMaxValue] = {NULL};
#ifdef BCM_APACHE_SUPPORT
    uint8                                     cng_3_bits = 0;
    uint8                                     phb_3_bits = 0;
    uint8                                     cng_2_bits = 0;
    uint8                                     phb_2_bits = 0;
    uint8                                     cng_1_bits = 0;
    uint8                                     phb_1_bits = 0;
#endif
    uint8                                     cng_bits=0;
    uint8                                     ifp_cng_bits=0;
    uint8                                     int_pri_bits=0;
    uint8                                     vlan_format_bits=0;
    uint8                                     outer_dot1p_bits=0;
    uint8                                     inner_dot1p_bits=0;
    uint8                                     port_bits=0;
    uint8                                     tos_dscp_bits=0;
    uint8                                     tos_ecn_bits=0;
    uint8                                     pkt_resolution_bits=0;
    uint8                                     svp_bits=0;
    uint8                                     dvp_bits=0;
    uint8                                     drop_bits=0;
    uint8                                     ip_pkt_bits=0;
    uint8                                     unknown_pkt=0;
    uint8                                     control_pkt=0;
    uint8                                     oam_pkt=0;
    uint8                                     bfd_pkt=0;
    uint8                                     bpdu_pkt=0;
    uint8                                     icnm_pkt=0;
    uint8                                     _1588_pkt=0;
    uint8                                     known_l2uc_pkt=0;
    uint8                                     unknown_l2uc_pkt=0;
    uint8                                     l2bc_pkt=0;
    uint8                                     known_l2mc_pkt=0;
    uint8                                     unknown_l2mc_pkt=0;
    uint8                                     known_l3uc_pkt=0;
    uint8                                     unknown_l3uc_pkt=0;
    uint8                                     known_ipmc_pkt=0;
    uint8                                     unknown_ipmc_pkt=0;
    uint8                                     known_mpls_l2_pkt=0;
    uint8                                     known_mpls_l3_pkt=0;
    uint8                                     known_mpls_pkt=0;
    uint8                                     unknown_mpls_pkt=0;
    uint8                                     known_mpls_multicast_pkt=0;
    uint8                                     known_mim_pkt=0;
    uint8                                     unknown_mim_pkt=0;
    uint8                                     known_trill_pkt=0;
    uint8                                     unknown_trill_pkt=0;
    uint8                                     known_niv_pkt=0;
    uint8                                     unknown_niv_pkt=0;
    uint16                                     loop_index=0;
    uint16                                     final_index=0;
    uint16                                     index0=0;
    uint16                                     index1=0;
    uint16                                     index2=0;
    uint16                                     index3=0;
    uint16                                     index4=0;
    uint16                                     index5=0;
    uint16                                     index6=0;
    uint16                                     index7=0;
    uint16                                     invalid_index0 = FALSE;
    uint16                                     invalid_index1 = FALSE;
    uint16                                     invalid_index2 = FALSE;
    uint16                                     invalid_index3 = FALSE;
    uint8                                      unused_attr_val_found = FALSE;
    uint32                                     invalid_map_value = 0;
    uint32                                     values = 0, values_max = 0;
    uint8                                      offset=0;
    uint8                                      final_mapped_value;
    uint8                                      mapped_value0;
    uint8                                      mapped_value1;
    uint8                                      mapped_value2;
    uint8                                      mapped_value3;
    uint8                                      max_bits=0;
#ifdef BCM_APACHE_SUPPORT
    uint8                                      pre_ifp_cng_mpls_3_cmprsd_max_bits = 0;
    uint8                                      int_pri_mpls_3_cmprsd_max_bits = 0;
    uint8                                      pre_ifp_cng_mpls_2_cmprsd_max_bits = 0;
    uint8                                      int_pri_mpls_2_cmprsd_max_bits = 0;
    uint8                                      pre_ifp_cng_mpls_1_cmprsd_max_bits = 0;
    uint8                                      int_pri_mpls_1_cmprsd_max_bits = 0;
#endif
    uint8                                      pre_ifp_cng_cmprsd_max_bits=0;
    uint8                                      ifp_cng_cmprsd_max_bits=0;
    uint8                                      int_pri_cmprsd_max_bits=0;

    uint8                                      vlan_format_cmprsd_max_bits=0;
    uint8                                      outer_dot1p_cmprsd_max_bits=0;
    uint8                                      inner_dot1p_cmprsd_max_bits=0;

    uint8                                      port_cmprsd_max_bits=0;

    uint8                                      tos_dscp_cmprsd_max_bits=0;
    uint8                                      tos_ecn_cmprsd_max_bits=0;

    uint8                                      pkt_resolution_cmprsd_max_bits=0;
    uint8                                      svp_cmprsd_max_bits=0;
    uint8                                      dvp_cmprsd_max_bits=0;
    uint8                                      drop_cmprsd_max_bits=0;
    uint8                                      ip_pkt_cmprsd_max_bits=0;
#if defined(BCM_TRIDENT2_SUPPORT)
    uint8                                      known_l2gre_pkt=0;
    uint8                                      known_vxlan_pkt=0;
    uint8                                      known_fcoe_pkt=0;
    uint8                                      unknown_fcoe_pkt=0;
#endif

    uint8                                      l2_uc_pkt = 0;    
    uint8                                      l2_non_uc_pkt = 0;    
    bcm_stat_flex_udf_pkt_attr_selectors_t     *ing_udf_pkt_attr_selectors = NULL;
#if defined(BCM_TOMAHAWK_SUPPORT) || defined(BCM_TRIDENT3_SUPPORT)
    uint8 mmu_cos_bits = 0;
    uint8 uc_queueing_bits = 0;
    uint8 congestion_marked_bits = 0;
    uint8 mmu_cos_cmprsd_max_bits = 0;
    uint8 uc_queueing_cmprsd_max_bits = 0;
    uint8 congestion_marked_cmprsd_max_bits = 0;
#endif
    uint8 tcp_flags_bits = 0, int_cn_bits = 0;
    uint8 fc_type_bits = 0;
#if defined(BCM_KATANA2_SUPPORT)
    uint32 hw_class_id = 0, i = 0;
    uint32 combine_attr_per_mode [bcmStatFlexAttrMax][BCM_STAT_FLEX_BIT_ARRAY_SIZE] = {{0}};
#endif
#if defined(BCM_TRIDENT3_SUPPORT) || defined(BCM_APACHE_SUPPORT)
    uint16                                     inner_loop_index = 0;
    uint16                                     compress_group_count = 0;
#endif
    int port_map_array_size = 0;
    int force_compressed_mode = FALSE;

    if (flags & BCM_STAT_GROUP_MODE_INGRESS) {
        direction = bcmStatFlexDirectionIngress;
    } else {
        direction = bcmStatFlexDirectionEgress;
    } 
    attr = (bcm_stat_flex_attr_t *) sal_alloc(sizeof(bcm_stat_flex_attr_t),
                                              "attr");
    if (attr == NULL) {
        return BCM_E_MEMORY;
    }
    sal_memset(attr,0,sizeof(bcm_stat_flex_attr_t)); 

    if (direction == bcmStatFlexDirectionIngress) {
        /* INGRESS SIDE */
        attr->direction=bcmStatFlexDirectionIngress;
        ing_attr = &(attr->ing_attr);
        ing_cmprsd_attr_selectors=&(ing_attr->cmprsd_attr_selectors);
        ing_cmprsd_pkt_attr_bits= &(ing_attr->cmprsd_attr_selectors.
                                    pkt_attr_bits);
        unknown_pkt      = _bcm_esw_stat_flex_get_pkt_res_value(unit ,
                                                                _UNKNOWN_PKT);
        control_pkt      = _bcm_esw_stat_flex_get_pkt_res_value(unit,
                                                                _CONTROL_PKT);
        oam_pkt          = _bcm_esw_stat_flex_get_pkt_res_value(unit,_OAM_PKT);
        bfd_pkt          = _bcm_esw_stat_flex_get_pkt_res_value(unit,_BFD_PKT);
        bpdu_pkt         = _bcm_esw_stat_flex_get_pkt_res_value(unit,_BPDU_PKT);
        icnm_pkt         = _bcm_esw_stat_flex_get_pkt_res_value(unit,_ICNM_PKT);
        _1588_pkt        = _bcm_esw_stat_flex_get_pkt_res_value(unit,_1588_PKT);
        known_l2uc_pkt   = _bcm_esw_stat_flex_get_pkt_res_value(unit,_L2UC_PKT);
        unknown_l2uc_pkt = _bcm_esw_stat_flex_get_pkt_res_value(unit,
                                                                _L2DLF_PKT);
        l2bc_pkt         = _bcm_esw_stat_flex_get_pkt_res_value(unit,_L2BC_PKT);
        known_l2mc_pkt   = _bcm_esw_stat_flex_get_pkt_res_value(unit,
                           _KNOWN_L2MC_PKT);
        unknown_l2mc_pkt = _bcm_esw_stat_flex_get_pkt_res_value(unit,
                           _UNKNOWN_L2MC_PKT);
        known_l3uc_pkt   = _bcm_esw_stat_flex_get_pkt_res_value(unit,
                           _KNOWN_L3UC_PKT);
        unknown_l3uc_pkt = _bcm_esw_stat_flex_get_pkt_res_value(unit,
                           _UNKNOWN_L3UC_PKT);
        known_ipmc_pkt   = _bcm_esw_stat_flex_get_pkt_res_value(unit,
                           _KNOWN_IPMC_PKT);
        unknown_ipmc_pkt = _bcm_esw_stat_flex_get_pkt_res_value(unit,
                           _UNKNOWN_IPMC_PKT);
        known_mpls_l2_pkt = _bcm_esw_stat_flex_get_pkt_res_value(unit,
                           _KNOWN_MPLS_L2_PKT);
        known_mpls_l3_pkt = _bcm_esw_stat_flex_get_pkt_res_value(unit,
                            _KNOWN_MPLS_L3_PKT);
        known_mpls_pkt    = _bcm_esw_stat_flex_get_pkt_res_value(unit,
                            _KNOWN_MPLS_PKT);
        unknown_mpls_pkt  = _bcm_esw_stat_flex_get_pkt_res_value(unit,
                            _UNKNOWN_MPLS_PKT);
        known_mpls_multicast_pkt = _bcm_esw_stat_flex_get_pkt_res_value(unit,
                                   _KNOWN_MPLS_MULTICAST_PKT);
        known_mim_pkt     = _bcm_esw_stat_flex_get_pkt_res_value(unit,
                            _KNOWN_MIM_PKT);
        unknown_mim_pkt   = _bcm_esw_stat_flex_get_pkt_res_value(unit,
                            _UNKNOWN_MIM_PKT);
        known_trill_pkt     = _bcm_esw_stat_flex_get_pkt_res_value(unit,
                            _KNOWN_TRILL_PKT);
        unknown_trill_pkt   = _bcm_esw_stat_flex_get_pkt_res_value(unit,
                            _UNKNOWN_TRILL_PKT);
        known_niv_pkt     = _bcm_esw_stat_flex_get_pkt_res_value(unit,
                            _KNOWN_NIV_PKT);
        unknown_niv_pkt   = _bcm_esw_stat_flex_get_pkt_res_value(unit,
                            _UNKNOWN_NIV_PKT);
#if defined(BCM_TRIDENT2_SUPPORT)
        if (SOC_IS_TD2_TT2(unit)) {
            known_l2gre_pkt=_bcm_esw_stat_flex_get_pkt_res_value(unit,
                                _KNOWN_L2GRE_PKT);
            known_vxlan_pkt=_bcm_esw_stat_flex_get_pkt_res_value(unit,
                                _KNOWN_VXLAN_PKT);
            known_fcoe_pkt=_bcm_esw_stat_flex_get_pkt_res_value(unit,
                                _KNOWN_FCOE_PKT);
            unknown_fcoe_pkt=_bcm_esw_stat_flex_get_pkt_res_value(unit,
                                _UNKNOWN_FCOE_PKT);
        }
#endif
    } else {
        /* EGRESS SIDE */
        attr->direction=bcmStatFlexDirectionEgress;
        egr_attr = &(attr->egr_attr);
        egr_cmprsd_attr_selectors=&(egr_attr->cmprsd_attr_selectors);
        egr_cmprsd_pkt_attr_bits= &(egr_attr->cmprsd_attr_selectors.
                                    pkt_attr_bits);
        unknown_pkt      = 0;
        control_pkt      = 0;
        oam_pkt          = 0;
        bfd_pkt          = 0;
        bpdu_pkt         = 0;
        icnm_pkt         = 0;
        _1588_pkt        = 0;
        known_l2uc_pkt   = 0;
        unknown_l2uc_pkt = 0;
        l2bc_pkt         = 1;
        known_l2mc_pkt   = 1;
        unknown_l2mc_pkt = 1;
        known_l3uc_pkt   = 0;
        unknown_l3uc_pkt = 0;
        known_ipmc_pkt   = 0;
        unknown_ipmc_pkt = 0;
        known_mpls_l2_pkt = 0;
        known_mpls_l3_pkt = 0;
        known_mpls_pkt    = 0;
        unknown_mpls_pkt  = 0;
        known_mpls_multicast_pkt = 1;
        known_mim_pkt     = 0;
        unknown_mim_pkt   = 0;
        known_trill_pkt     = 0;
        unknown_trill_pkt   = 0;
        known_niv_pkt     = 0;
        unknown_niv_pkt   = 0;

        l2_uc_pkt   = _bcm_esw_stat_flex_get_pkt_res_value(unit,
                            _L2_UC_PKT_EGR);
        l2_non_uc_pkt   = _bcm_esw_stat_flex_get_pkt_res_value(unit,
                            _L2_NON_UC_PKT_EGR);
    }
#ifdef BCM_APACHE_SUPPORT
    if (soc_feature(unit,soc_feature_flex_ctr_mpls_3_label_count)) {
        if (flex_attribute->cng_3 != 0) {
            total_bits += cng_3_bits =
                (direction == bcmStatFlexDirectionIngress) ?
                ing_pkt_attr_uncmprsd_bits_g[unit].cng_3: egr_pkt_attr_uncmprsd_bits_g[unit].cng_3;
        }
        if (flex_attribute->phb_3 != 0) {
            total_bits += phb_3_bits =
                (direction == bcmStatFlexDirectionIngress) ?
                ing_pkt_attr_uncmprsd_bits_g[unit].phb_3: egr_pkt_attr_uncmprsd_bits_g[unit].phb_3;
        }
        if (flex_attribute->cng_2 != 0) {
            total_bits += cng_2_bits =
                (direction == bcmStatFlexDirectionIngress) ?
                ing_pkt_attr_uncmprsd_bits_g[unit].cng_2: egr_pkt_attr_uncmprsd_bits_g[unit].cng_2;
        }
        if (flex_attribute->phb_2 != 0) {
            total_bits += phb_2_bits =
                (direction == bcmStatFlexDirectionIngress) ?
                ing_pkt_attr_uncmprsd_bits_g[unit].phb_2: egr_pkt_attr_uncmprsd_bits_g[unit].phb_2;
        }
        if (flex_attribute->cng_1 != 0) {
            total_bits += cng_1_bits =
                (direction == bcmStatFlexDirectionIngress) ?
                ing_pkt_attr_uncmprsd_bits_g[unit].cng_1: egr_pkt_attr_uncmprsd_bits_g[unit].cng_1;
        }
        if (flex_attribute->phb_1 != 0) {
            total_bits += phb_1_bits =
                (direction == bcmStatFlexDirectionIngress) ?
                ing_pkt_attr_uncmprsd_bits_g[unit].phb_1: egr_pkt_attr_uncmprsd_bits_g[unit].phb_1;
        }
    }
#endif
    if (flex_attribute->pre_ifp_color != 0) {
        total_bits += cng_bits =
                      (direction == bcmStatFlexDirectionIngress) ?
                       ing_pkt_attr_uncmprsd_bits_g[unit].cng: egr_pkt_attr_uncmprsd_bits_g[unit].cng;
    }
    if (flex_attribute->ifp_color != 0) {
        if (direction == bcmStatFlexDirectionEgress) {
            sal_free(attr);
            return BCM_E_PARAM;
        }
        ing_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                  BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_IFP_CNG_ATTR_BITS;
        total_bits += ifp_cng_bits = ing_pkt_attr_uncmprsd_bits_g[unit].ifp_cng;
    }
    if (flex_attribute->int_pri != 0) {
        total_bits += int_pri_bits =
                       (direction == bcmStatFlexDirectionIngress) ?
                       ing_pkt_attr_uncmprsd_bits_g[unit].int_pri:egr_pkt_attr_uncmprsd_bits_g[unit].int_pri;
    }
    if (flex_attribute->vlan_format != 0) {
        total_bits += vlan_format_bits =
                      (direction == bcmStatFlexDirectionIngress) ?
                       ing_pkt_attr_uncmprsd_bits_g[unit].vlan_format:
                       egr_pkt_attr_uncmprsd_bits_g[unit].vlan_format;
    }
    if (flex_attribute->outer_dot1p != 0) {
        total_bits += outer_dot1p_bits =
                      (direction == bcmStatFlexDirectionIngress) ?
                       ing_pkt_attr_uncmprsd_bits_g[unit].outer_dot1p:
                       egr_pkt_attr_uncmprsd_bits_g[unit].outer_dot1p;
    }
    if (flex_attribute->inner_dot1p != 0) {
        total_bits += inner_dot1p_bits =
                      (direction == bcmStatFlexDirectionIngress) ?
                       ing_pkt_attr_uncmprsd_bits_g[unit].inner_dot1p:
                       egr_pkt_attr_uncmprsd_bits_g[unit].inner_dot1p;
    }
    if (flex_attribute->port != 0) {
#ifdef BCM_HURRICANE4_SUPPORT
        if (SOC_IS_HURRICANE4(unit) &&
                (direction == bcmStatFlexDirectionEgress)) {
#if defined(INCLUDE_XFLOW_MACSEC)
            bcm_xflow_macsec_port_info_t port_info;
            if (soc_feature(unit, soc_feature_xflow_macsec)) {
                max_count= (1 << egr_pkt_attr_uncmprsd_bits_g[unit].egr_port) - 1;

                for (counter = 0;
                        counter < flex_attribute->total_counters;
                        counter++) {
                    for (index0 = 0; index0 <= max_count; index0++) {

                        if (BCM_STAT_FLEX_VALUE_GET(
                                    flex_attribute->combine_attr_counter[counter].
                                    value_array[bcmStatFlexAttrPort], index0)) {
                            bcm_xflow_macsec_port_info_t_init(&port_info);
                            bcm_common_xflow_macsec_port_info_get(unit, index0, &port_info);
                            if (port_info.enable) {
                                force_compressed_mode = TRUE;
                                break;
                            }
                        }
                    }
                    if (force_compressed_mode == TRUE) {
                        break;
                    }
                }
            }
#endif /* INCLUDE_XFLOW_MACSEC */
        }
#endif /* BCM_HURRICANE4_SUPPORT */

        total_bits += port_bits =
                      (direction == bcmStatFlexDirectionIngress) ?
                       ing_pkt_attr_uncmprsd_bits_g[unit].ing_port:
                       egr_pkt_attr_uncmprsd_bits_g[unit].egr_port;
    }
    /*
     * Subport can not use uncompressed because of range.
     */
    if (flex_attribute->subport != 0) {
        total_bits += port_bits = 9;
/*
                      (direction == bcmStatFlexDirectionIngress) ?
                       ing_pkt_attr_uncmprsd_bits_g[unit].ing_port+1:
                       egr_pkt_attr_uncmprsd_bits_g[unit].egr_port+1;
*/
    }
    if (flex_attribute->tos_dscp != 0) {
        total_bits += tos_dscp_bits =
                      (direction == bcmStatFlexDirectionIngress) ?
                       ing_pkt_attr_uncmprsd_bits_g[unit].tos_dscp:
                       egr_pkt_attr_uncmprsd_bits_g[unit].tos_dscp;
    }
    if (flex_attribute->tos_ecn != 0) {
        total_bits += tos_ecn_bits =
                      (direction == bcmStatFlexDirectionIngress) ?
                       ing_pkt_attr_uncmprsd_bits_g[unit].tos_ecn:
                       egr_pkt_attr_uncmprsd_bits_g[unit].tos_ecn;
    }
    if (flex_attribute->pkt_resolution != 0) {
        total_bits += pkt_resolution_bits =
                      (direction == bcmStatFlexDirectionIngress) ?
                       ing_pkt_attr_uncmprsd_bits_g[unit].pkt_resolution:
                       egr_pkt_attr_uncmprsd_bits_g[unit].pkt_resolution;
    }
    if (flex_attribute->svp != 0) {
        total_bits += svp_bits =
                      (direction == bcmStatFlexDirectionIngress) ?
                       ing_pkt_attr_uncmprsd_bits_g[unit].svp_type:
                       egr_pkt_attr_uncmprsd_bits_g[unit].svp_type;
    }
    if (flex_attribute->dvp != 0) {
        if (direction == bcmStatFlexDirectionIngress) {
            sal_free(attr);
            return BCM_E_PARAM;
        }
        total_bits += dvp_bits = egr_pkt_attr_uncmprsd_bits_g[unit].dvp_type;
    }
    if (flex_attribute->drop != 0) {
        total_bits += drop_bits =
                      (direction == bcmStatFlexDirectionIngress) ?
                       ing_pkt_attr_uncmprsd_bits_g[unit].drop:
                       egr_pkt_attr_uncmprsd_bits_g[unit].drop;
    }
    if (flex_attribute->ip_pkt != 0) {
        total_bits += ip_pkt_bits =
                      (direction == bcmStatFlexDirectionIngress) ?
                       ing_pkt_attr_uncmprsd_bits_g[unit].ip_pkt:
                       egr_pkt_attr_uncmprsd_bits_g[unit].ip_pkt;
    }
    if (flex_attribute->udf != 0) {
        total_bits += flex_attribute->drop ? 7 : 8;
    }
#if defined(BCM_TOMAHAWK_SUPPORT) || defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_flex_stat_egr_queue_congestion_marked)) {
        if (flex_attribute->mmu_cos != 0) {
            if (direction == bcmStatFlexDirectionIngress) {
                sal_free(attr);
                return BCM_E_PARAM;
            }
            total_bits += mmu_cos_bits =
                egr_pkt_attr_uncmprsd_bits_g[unit].mmu_cos;
        }
        if (flex_attribute->uc_queueing != 0) {
            if (direction == bcmStatFlexDirectionIngress) {
                sal_free(attr);
                return BCM_E_PARAM;
            }
            total_bits += uc_queueing_bits =
                egr_pkt_attr_uncmprsd_bits_g[unit].uc_queueing;
        }
        if (flex_attribute->congestion_marked != 0) {
            if (direction == bcmStatFlexDirectionIngress) {
                sal_free(attr);
                return BCM_E_PARAM;
            }
            total_bits += congestion_marked_bits =
                egr_pkt_attr_uncmprsd_bits_g[unit].congestion_marked;
        }
    }
#endif
    if (soc_feature(unit, soc_feature_flex_stat_ing_tcp_flags_support)) {
        if (flex_attribute->tcp_flags != 0) {
            if (direction == bcmStatFlexDirectionEgress) {
                sal_free(attr);
                return BCM_E_PARAM;
            }
            total_bits += tcp_flags_bits =
                ing_pkt_attr_uncmprsd_bits_g[unit].tcp_flags;
        }
    }
    if (soc_feature(unit, soc_feature_flex_stat_int_cn_support)) {
        if (flex_attribute->int_cn != 0) {
            total_bits += int_cn_bits =
                (direction == bcmStatFlexDirectionIngress) ?
                ing_pkt_attr_uncmprsd_bits_g[unit].int_cn:
                egr_pkt_attr_uncmprsd_bits_g[unit].int_cn;
        }
    }

    if (soc_feature(unit, soc_feature_channelized_switching)) {
        if (flex_attribute->fc_type != 0) {
            if (direction == bcmStatFlexDirectionEgress) {
                sal_free(attr);
                return BCM_E_PARAM;
            }
            total_bits += fc_type_bits =
                ing_pkt_attr_uncmprsd_bits_g[unit].fc_type;
        }
    }

    if ((force_compressed_mode == FALSE) &&
            (total_bits <= BCM_STAT_FLEX_COUNTER_MAX_TOTAL_BITS)) {
        LOG_VERBOSE(BSL_LS_BCM_FLEXCTR,
                    (BSL_META_U(unit,
                                "INFO: UnCompressedMode Will be used \n")));
        if (direction == bcmStatFlexDirectionIngress) {
        if (flags & BCM_STAT_GROUP_MODE_UDF) {
            ing_attr->packet_attr_type=bcmStatFlexPacketAttrTypeUdf;
            ing_udf_pkt_attr_selectors = &(ing_attr->udf_pkt_attr_selectors);

            /* For TD3x, which has a new UDF implementation the order of the
               UDF chunks are reversed as compared to earlier devices */
            if (soc_feature(unit, soc_feature_udf_td3x_support)) {
                ing_udf_pkt_attr_selectors->udf_pkt_attr_bits.udf1 =
                    flex_attribute->udf_bitmap & 0Xffff;
                ing_udf_pkt_attr_selectors->udf_pkt_attr_bits.udf0 =
                    flex_attribute->udf_bitmap >> 16;
            } else {
                ing_udf_pkt_attr_selectors->udf_pkt_attr_bits.udf0 =
                    flex_attribute->udf_bitmap & 0Xffff;
                ing_udf_pkt_attr_selectors->udf_pkt_attr_bits.udf1 =
                    flex_attribute->udf_bitmap >> 16;
            }
            ing_udf_pkt_attr_selectors->drop_enable =
                                        flex_attribute->drop ? 1 : 0;
            ing_udf_pkt_attr_selectors->total_counters =
                                        flex_attribute->total_counters;
        } else {
            ing_attr->packet_attr_type=bcmStatFlexPacketAttrTypeUncompressed;
        }
        if (soc_feature(unit, soc_feature_flex_stat_ing_tcp_flags_support)) {
            if (flex_attribute->tcp_flags != 0) {
                ing_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                    BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_TCP_FLAG_ATTR_BITS;
            }
        }
        if (soc_feature(unit, soc_feature_flex_stat_int_cn_support)) {
            if (flex_attribute->int_cn != 0) {
                ing_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                    BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_INT_CN_ATTR_BITS;
            }
        }
        if (soc_feature(unit, soc_feature_channelized_switching)) {
            if (flex_attribute->fc_type != 0) {
                ing_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                    BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_FC_TYPE_ATTR_BITS;
            }
        }
#ifdef BCM_APACHE_SUPPORT
            if (soc_feature(unit,soc_feature_flex_ctr_mpls_3_label_count)) {
                if (flex_attribute->cng_3 != 0) {
                    ing_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                        BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_CNG_3_ATTR_BITS;
                }
                if (flex_attribute->phb_3 != 0) {
                    ing_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                        BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_PHB_3_ATTR_BITS;
                }
                if (flex_attribute->cng_2 != 0) {
                    ing_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                        BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_CNG_2_ATTR_BITS;
                }
                if (flex_attribute->phb_2 != 0) {
                    ing_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                        BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_PHB_2_ATTR_BITS;
                }
                if (flex_attribute->cng_1 != 0) {
                    ing_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                        BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_CNG_1_ATTR_BITS;
                }
                if (flex_attribute->phb_1 != 0) {
                    ing_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                        BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_PHB_1_ATTR_BITS;
                }
            }
#endif
            if (flex_attribute->pre_ifp_color != 0) {
                ing_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                          BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_CNG_ATTR_BITS;
            }
            if (flex_attribute->ifp_color != 0) {
                ing_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                          BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_IFP_CNG_ATTR_BITS;
            }
            if (flex_attribute->int_pri != 0) {
                ing_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                          BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_INT_PRI_ATTR_BITS;
            }
            if (flex_attribute->vlan_format != 0) {
                ing_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                      BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_VLAN_FORMAT_ATTR_BITS;
            }
            if (flex_attribute->outer_dot1p != 0) {
                ing_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                      BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_OUTER_DOT1P_ATTR_BITS;
            }
            if (flex_attribute->inner_dot1p != 0) {
                ing_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                      BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_INNER_DOT1P_ATTR_BITS;
            }
            if (flex_attribute->port != 0) {
                ing_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                      BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_INGRESS_PORT_ATTR_BITS;
            }
            if (flex_attribute->tos_dscp != 0) {
                ing_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                      BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_TOS_DSCP_ATTR_BITS;
            }
            if (flex_attribute->tos_ecn != 0) {
                ing_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                      BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_TOS_ECN_ATTR_BITS;
            }
            if (flex_attribute->pkt_resolution != 0) {
                ing_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                   BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_PKT_RESOLUTION_ATTR_BITS;
            }
            if (flex_attribute->svp != 0) {
                ing_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                   BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_SVP_TYPE_ATTR_BITS;
            }
            if (flex_attribute->drop != 0) {
                ing_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                   BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_DROP_ATTR_BITS;
            }
            if (flex_attribute->ip_pkt != 0) {
                ing_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                   BCM_STAT_FLEX_ING_UNCOMPRESSED_USE_IP_PKT_ATTR_BITS;
            }
            ing_attr->uncmprsd_attr_selectors.total_counters = 
                      flex_attribute->total_counters;
            /* Reset all Offset table fields */
            for (index0 = 0;
                 index0 < BCM_STAT_FLEX_MAX_COUNTERS_PER_MODE;
                 index0++) {
                 ing_attr->uncmprsd_attr_selectors.offset_table_map[index0].
                           offset = 0;
                 /* IFP Flex stats on TH uses a mode with 0 bits being selected
                  * for packet attributes. In this mode avoid disabling count_enable
                  * for the first 'n' counters that will be allocated.
                  */
                 if ((0 == total_bits) &&
                     (index0 < flex_attribute->total_counters)) {
                     ing_attr->uncmprsd_attr_selectors.offset_table_map[index0].
                         count_enable = 1;
                 } else {
                     ing_attr->uncmprsd_attr_selectors.offset_table_map[index0].
                         count_enable = 0;
                 }
           }
        } else {
            egr_attr->packet_attr_type=bcmStatFlexPacketAttrTypeUncompressed;
            if (soc_feature(unit, soc_feature_flex_stat_int_cn_support)) {
                if (flex_attribute->int_cn != 0) {
                    egr_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                        BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_INT_CN_ATTR_BITS;
                }
            }
#ifdef BCM_APACHE_SUPPORT
            if (soc_feature(unit,soc_feature_flex_ctr_mpls_3_label_count)) {
                if (flex_attribute->cng_3 != 0) {
                    egr_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                        BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_CNG_3_ATTR_BITS;
                }
                if (flex_attribute->phb_3 != 0) {
                    egr_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                        BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_PHB_3_ATTR_BITS;
                }
                if (flex_attribute->cng_2 != 0) {
                    egr_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                        BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_CNG_2_ATTR_BITS;
                }
                if (flex_attribute->phb_2 != 0) {
                    egr_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                        BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_PHB_2_ATTR_BITS;
                }
                if (flex_attribute->cng_1 != 0) {
                    egr_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                        BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_CNG_1_ATTR_BITS;
                }
                if (flex_attribute->phb_1 != 0) {
                    egr_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                        BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_PHB_1_ATTR_BITS;
                }
            }
#endif
            if (flex_attribute->pre_ifp_color != 0) {
                egr_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                          BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_CNG_ATTR_BITS;
            }
            if (flex_attribute->int_pri != 0) {
                egr_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                          BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_INT_PRI_ATTR_BITS;
            }
            if (flex_attribute->vlan_format != 0) {
                egr_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                      BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_VLAN_FORMAT_ATTR_BITS;
            }
            if (flex_attribute->outer_dot1p != 0) {
                egr_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                      BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_OUTER_DOT1P_ATTR_BITS;
            }
            if (flex_attribute->inner_dot1p != 0) {
                egr_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                      BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_INNER_DOT1P_ATTR_BITS;
            }
            if (flex_attribute->port != 0) {
                egr_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                      BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_EGRESS_PORT_ATTR_BITS;
            }
            if (flex_attribute->tos_dscp != 0) {
                egr_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                      BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_TOS_DSCP_ATTR_BITS;
            }
            if (flex_attribute->tos_ecn != 0) {
                egr_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                      BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_TOS_ECN_ATTR_BITS;
            }
            if (flex_attribute->pkt_resolution != 0) {
                egr_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                   BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_PKT_RESOLUTION_ATTR_BITS;
            }
            if (flex_attribute->svp != 0) {
                egr_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                   BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_SVP_TYPE_ATTR_BITS;
            }
            if (flex_attribute->dvp != 0) {
                egr_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                   BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_DVP_TYPE_ATTR_BITS;
            }
            if (flex_attribute->drop != 0) {
                egr_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                   BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_DROP_ATTR_BITS;
            }
            if (flex_attribute->ip_pkt != 0) {
                egr_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                   BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_IP_PKT_ATTR_BITS;
            }
#if defined(BCM_TOMAHAWK_SUPPORT) || defined(BCM_TRIDENT3_SUPPORT)
            if (soc_feature(unit, soc_feature_flex_stat_egr_queue_congestion_marked)) {
                if (flex_attribute->mmu_cos != 0) {
                    egr_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                        BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_MMU_COS_ATTR_BITS;
                }
                if (flex_attribute->uc_queueing != 0) {
                    egr_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                        BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_UC_QUEUEING_ATTR_BITS;
                }
                if (flex_attribute->congestion_marked != 0) {
                    egr_attr->uncmprsd_attr_selectors.uncmprsd_attr_bits_selector |=
                        BCM_STAT_FLEX_EGR_UNCOMPRESSED_USE_CONGESTION_MARKED_ATTR_BITS;
                }
            }
#endif
            egr_attr->uncmprsd_attr_selectors.total_counters = 
                      flex_attribute->total_counters;
            /* Reset all Offset table fields */
            for (index0 = 0;
                 index0 < BCM_STAT_FLEX_MAX_COUNTERS_PER_MODE;
                 index0++) {
                 egr_attr->uncmprsd_attr_selectors.offset_table_map[index0].
                           offset = 0;
                 egr_attr->uncmprsd_attr_selectors.offset_table_map[index0].
                           count_enable = 0;
           }
        }

       for (loop=0;loop<8;loop++) {
            offset_array[loop] = (uint16 *) sal_alloc((256+1) * sizeof(uint16),"offset_array");
            if (offset_array[loop] == NULL) {  
                rv = BCM_E_MEMORY;
                goto cleanup;
            }
       }
       /* Second Level Analysis: Update offset_array */
       for (counter=0;counter < flex_attribute->total_counters ; counter ++ ) {
            for (loop=0;loop<8;loop++) {
                 sal_memset(offset_array[loop],0,(256+1) * sizeof(uint16));
            }
            /* Logical Group0 */
            loop = 0;
#ifdef BCM_APACHE_SUPPORT
            if (soc_feature(unit,soc_feature_flex_ctr_mpls_3_label_count)) {
                if (flex_attribute->cng_3 != 0) {
                    shift_by_bits = phb_3_bits +
                        cng_2_bits +
                        phb_2_bits +
                        cng_1_bits +
                        phb_1_bits +
                        cng_bits +
                        ifp_cng_bits +
                        int_pri_bits +
                        vlan_format_bits +
                        outer_dot1p_bits +
                        inner_dot1p_bits +
                        port_bits +
                        tos_dscp_bits +
                        tos_ecn_bits +
                        pkt_resolution_bits +
                        svp_bits +
                        dvp_bits +
                        drop_bits +
                        ip_pkt_bits ;
                    temp_count = offset_array[loop][0];
                    if (flex_attribute->combine_attr_counter[counter].
                            pre_ifp_color_mpls_label3_flags & BCM_STAT_FLEX_COLOR_GREEN) {
                        /* GreenIndex = 0*/
                        offset_array[loop][temp_count+1] = (0 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pre_ifp_color_mpls_label3_flags & BCM_STAT_FLEX_COLOR_RED) {
                        /* RedIndex = 1 */
                        offset_array[loop][temp_count+1] = (1 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pre_ifp_color_mpls_label3_flags & BCM_STAT_FLEX_COLOR_YELLOW) {
                        /* YellowIndex=3 */
                        offset_array[loop][temp_count+1] = (3 << shift_by_bits);
                        temp_count++;
                    }
                    offset_array[loop][0] = temp_count;
                    loop++;
                }
                if (flex_attribute->phb_3 != 0) {
                    shift_by_bits = cng_2_bits +
                        phb_2_bits +
                        cng_1_bits +
                        phb_1_bits +
                        cng_bits +
                        ifp_cng_bits +
                        int_pri_bits +
                        vlan_format_bits +
                        outer_dot1p_bits +
                        inner_dot1p_bits +
                        port_bits +
                        tos_dscp_bits +
                        tos_ecn_bits +
                        pkt_resolution_bits +
                        svp_bits +
                        dvp_bits +
                        drop_bits +
                        ip_pkt_bits ;
                    temp_count = offset_array[loop][0];
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI0) {
                        offset_array[loop][temp_count+1] = (0 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI1) {
                        offset_array[loop][temp_count+1] = (1 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI2) {
                        offset_array[loop][temp_count+1] = (2 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI3) {
                        offset_array[loop][temp_count+1] = (3 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI4) {
                        offset_array[loop][temp_count+1] = (4 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI5) {
                        offset_array[loop][temp_count+1] = (5 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI6) {
                        offset_array[loop][temp_count+1] = (6 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI7) {
                        offset_array[loop][temp_count+1] = (7 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI8) {
                        offset_array[loop][temp_count+1] = (8 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI9) {
                        offset_array[loop][temp_count+1] = (9 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI10) {
                        offset_array[loop][temp_count+1] = (10 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI11) {
                        offset_array[loop][temp_count+1] = (11 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI12) {
                        offset_array[loop][temp_count+1] = (12 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI13) {
                        offset_array[loop][temp_count+1] = (13 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI14) {
                        offset_array[loop][temp_count+1] = (14 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI15) {
                        offset_array[loop][temp_count+1] = (15 << shift_by_bits);
                        temp_count++;
                    }
                    offset_array[loop][0] = temp_count;
                    loop++;
                }
                if (flex_attribute->cng_2 != 0) {
                    shift_by_bits = phb_2_bits +
                        cng_1_bits +
                        phb_1_bits +
                        cng_bits +
                        ifp_cng_bits +
                        int_pri_bits +
                        vlan_format_bits +
                        outer_dot1p_bits +
                        inner_dot1p_bits +
                        port_bits +
                        tos_dscp_bits +
                        tos_ecn_bits +
                        pkt_resolution_bits +
                        svp_bits +
                        dvp_bits +
                        drop_bits +
                        ip_pkt_bits ;
                    temp_count = offset_array[loop][0];
                    if (flex_attribute->combine_attr_counter[counter].
                            pre_ifp_color_mpls_label2_flags & BCM_STAT_FLEX_COLOR_GREEN) {
                        /* GreenIndex=0*/
                        offset_array[loop][temp_count+1] = (0 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pre_ifp_color_mpls_label2_flags & BCM_STAT_FLEX_COLOR_RED) {
                        /* RedIndex=1 */
                        offset_array[loop][temp_count+1] = (1 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pre_ifp_color_mpls_label2_flags & BCM_STAT_FLEX_COLOR_YELLOW) {
                        /* YellowIndex=3 */
                        offset_array[loop][temp_count+1] = (3 << shift_by_bits);
                        temp_count++;
                    }
                    offset_array[loop][0] = temp_count;
                    loop++;
                }
                if (flex_attribute->phb_2 != 0) {
                    shift_by_bits = cng_1_bits +
                        phb_1_bits +
                        cng_bits +
                        ifp_cng_bits +
                        int_pri_bits +
                        vlan_format_bits +
                        outer_dot1p_bits +
                        inner_dot1p_bits +
                        port_bits +
                        tos_dscp_bits +
                        tos_ecn_bits +
                        pkt_resolution_bits +
                        svp_bits +
                        dvp_bits +
                        drop_bits +
                        ip_pkt_bits ;
                    temp_count = offset_array[loop][0];
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI0) {
                        offset_array[loop][temp_count+1] = (0 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI1) {
                        offset_array[loop][temp_count+1] = (1 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI2) {
                        offset_array[loop][temp_count+1] = (2 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI3) {
                        offset_array[loop][temp_count+1] = (3 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI4) {
                        offset_array[loop][temp_count+1] = (4 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI5) {
                        offset_array[loop][temp_count+1] = (5 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI6) {
                        offset_array[loop][temp_count+1] = (6 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI7) {
                        offset_array[loop][temp_count+1] = (7 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI8) {
                        offset_array[loop][temp_count+1] = (8 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI9) {
                        offset_array[loop][temp_count+1] = (9 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI10) {
                        offset_array[loop][temp_count+1] = (10 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI11) {
                        offset_array[loop][temp_count+1] = (11 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI12) {
                        offset_array[loop][temp_count+1] = (12 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI13) {
                        offset_array[loop][temp_count+1] = (13 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI14) {
                        offset_array[loop][temp_count+1] = (14 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI15) {
                        offset_array[loop][temp_count+1] = (15 << shift_by_bits);
                        temp_count++;
                    }
                    offset_array[loop][0] = temp_count;
                    loop++;
                }
                if (flex_attribute->cng_1 != 0) {
                    shift_by_bits = phb_1_bits +
                        cng_bits +
                        ifp_cng_bits +
                        int_pri_bits +
                        vlan_format_bits +
                        outer_dot1p_bits +
                        inner_dot1p_bits +
                        port_bits +
                        tos_dscp_bits +
                        tos_ecn_bits +
                        pkt_resolution_bits +
                        svp_bits +
                        dvp_bits +
                        drop_bits +
                        ip_pkt_bits ;
                    temp_count = offset_array[loop][0];
                    if (flex_attribute->combine_attr_counter[counter].
                            pre_ifp_color_mpls_label1_flags & BCM_STAT_FLEX_COLOR_GREEN) {
                        /* GreenIndex=0*/
                        offset_array[loop][temp_count+1] = (0 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pre_ifp_color_mpls_label1_flags & BCM_STAT_FLEX_COLOR_RED) {
                        /* RedIndex=1 */
                        offset_array[loop][temp_count+1] = (1 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pre_ifp_color_mpls_label1_flags & BCM_STAT_FLEX_COLOR_YELLOW) {
                        /* YellowIndex=3 */
                        offset_array[loop][temp_count+1] = (3 << shift_by_bits);
                        temp_count++;
                    }
                    offset_array[loop][0] = temp_count;
                    loop++;
                }
                if (flex_attribute->phb_1 != 0) {
                    shift_by_bits = cng_bits +
                        ifp_cng_bits +
                        int_pri_bits +
                        vlan_format_bits +
                        outer_dot1p_bits +
                        inner_dot1p_bits +
                        port_bits +
                        tos_dscp_bits +
                        tos_ecn_bits +
                        pkt_resolution_bits +
                        svp_bits +
                        dvp_bits +
                        drop_bits +
                        ip_pkt_bits ;
                    temp_count = offset_array[loop][0];
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI0) {
                        offset_array[loop][temp_count+1] = (0 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI1) {
                        offset_array[loop][temp_count+1] = (1 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI2) {
                        offset_array[loop][temp_count+1] = (2 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI3) {
                        offset_array[loop][temp_count+1] = (3 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI4) {
                        offset_array[loop][temp_count+1] = (4 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI5) {
                        offset_array[loop][temp_count+1] = (5 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI6) {
                        offset_array[loop][temp_count+1] = (6 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI7) {
                        offset_array[loop][temp_count+1] = (7 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI8) {
                        offset_array[loop][temp_count+1] = (8 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI9) {
                        offset_array[loop][temp_count+1] = (9 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI10) {
                        offset_array[loop][temp_count+1] = (10 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI11) {
                        offset_array[loop][temp_count+1] = (11 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI12) {
                        offset_array[loop][temp_count+1] = (12 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI13) {
                        offset_array[loop][temp_count+1] = (13 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI14) {
                        offset_array[loop][temp_count+1] = (14 << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI15) {
                        offset_array[loop][temp_count+1] = (15 << shift_by_bits);
                        temp_count++;
                    }
                    offset_array[loop][0] = temp_count;
                    loop++;
                }
            }
#endif
           if ((flex_attribute->udf != 0) &&
               (loop <= (BCM_STAT_FLEX_COUNTER_MAX_TOTAL_BITS - 2))) {
               shift_by_bits = drop_bits;
               max_count = flex_attribute->drop ? 127 : 255;
                for (loop_index=0; loop_index <= max_count ; loop_index++) {
                    if (BCM_STAT_FLEX_VALUE_GET(
                            flex_attribute->combine_attr_counter[counter].
                            value_array[bcmStatFlexAttrUdf],loop_index)) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (loop_index
                                                           << shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                }
                loop++;
            }

           if (soc_feature(unit, soc_feature_channelized_switching)) {
               if ((flex_attribute->fc_type != 0)  &&
                       (loop <= (BCM_STAT_FLEX_COUNTER_MAX_TOTAL_BITS - 2))){
                   shift_by_bits = int_cn_bits +
                       tcp_flags_bits +
                       ifp_cng_bits +
                       int_pri_bits +
                       vlan_format_bits +
                       outer_dot1p_bits +
                       inner_dot1p_bits +
                       port_bits +
                       tos_dscp_bits +
                       tos_ecn_bits +
                       pkt_resolution_bits +
                       svp_bits +
                       dvp_bits +
                       drop_bits +
                       ip_pkt_bits ;
                       temp_count = offset_array[loop][0];
                   offset_array[loop][temp_count+1] =
                       flex_attribute->combine_attr_counter[counter].fc_type << shift_by_bits;
                   offset_array[loop][0] = temp_count+1;
                   loop++;
               }
           }

           if (soc_feature(unit, soc_feature_flex_stat_int_cn_support)) {
               if ((flex_attribute->int_cn != 0)  &&
                       (loop <= (BCM_STAT_FLEX_COUNTER_MAX_TOTAL_BITS - 2))){
                   shift_by_bits = tcp_flags_bits +
                       ifp_cng_bits +
                       int_pri_bits +
                       vlan_format_bits +
                       outer_dot1p_bits +
                       inner_dot1p_bits +
                       port_bits +
                       tos_dscp_bits +
                       tos_ecn_bits +
                       pkt_resolution_bits +
                       svp_bits +
                       dvp_bits +
                       drop_bits +
                       ip_pkt_bits ;
                   if (flex_attribute->combine_attr_counter[counter].
                           int_cn & BCM_STAT_FLEX_INT_CN0) {
                       temp_count = offset_array[loop][0];
                       offset_array[loop][temp_count+1]=  (0
                               << shift_by_bits);
                       offset_array[loop][0] = temp_count+1;
                   }
                   if (flex_attribute->combine_attr_counter[counter].
                           int_cn & BCM_STAT_FLEX_INT_CN1) {
                       temp_count = offset_array[loop][0];
                       offset_array[loop][temp_count+1]= (1
                               << shift_by_bits);
                       offset_array[loop][0] = temp_count+1;
                   }
                   if (flex_attribute->combine_attr_counter[counter].
                           int_cn & BCM_STAT_FLEX_INT_CN2) {
                       temp_count = offset_array[loop][0];
                       offset_array[loop][temp_count+1]= (2
                               << shift_by_bits);
                       offset_array[loop][0] = temp_count+1;
                   }
                   if (flex_attribute->combine_attr_counter[counter].
                           int_cn & BCM_STAT_FLEX_INT_CN3) {
                       temp_count = offset_array[loop][0];
                       offset_array[loop][temp_count+1]= (3
                               << shift_by_bits);
                       offset_array[loop][0] = temp_count+1;
                   }
                   loop++;
               }
           }
           if (soc_feature(unit, soc_feature_flex_stat_ing_tcp_flags_support)) {
               if ((flex_attribute->tcp_flags != 0)  &&
                       (loop <= (BCM_STAT_FLEX_COUNTER_MAX_TOTAL_BITS - 2))){
                   shift_by_bits = ifp_cng_bits +
                       int_pri_bits +
                       vlan_format_bits +
                       outer_dot1p_bits +
                       inner_dot1p_bits +
                       port_bits +
                       tos_dscp_bits +
                       tos_ecn_bits +
                       pkt_resolution_bits +
                       svp_bits +
                       dvp_bits +
                       drop_bits +
                       ip_pkt_bits ;
                   if (flex_attribute->combine_attr_counter[counter].
                           tcp_flags & BCM_STAT_FLEX_TCP_FLAG_TYPE_SYN) {
                       temp_count = offset_array[loop][0];
                       offset_array[loop][temp_count+1]= (BCM_STAT_FLEX_TCP_FLAG_TYPE_SYN
                               << shift_by_bits);
                       offset_array[loop][0] = temp_count+1;
                   }
                   if (flex_attribute->combine_attr_counter[counter].
                           tcp_flags & BCM_STAT_FLEX_TCP_FLAG_TYPE_FIN) {
                       temp_count = offset_array[loop][0];
                       offset_array[loop][temp_count+1]= (BCM_STAT_FLEX_TCP_FLAG_TYPE_FIN
                               << shift_by_bits);
                       offset_array[loop][0] = temp_count+1;
                   }
                   if (flex_attribute->combine_attr_counter[counter].
                           tcp_flags & BCM_STAT_FLEX_TCP_FLAG_TYPE_RST) {
                       temp_count = offset_array[loop][0];
                       offset_array[loop][temp_count+1]= (BCM_STAT_FLEX_TCP_FLAG_TYPE_RST
                               << shift_by_bits);
                       offset_array[loop][0] = temp_count+1;
                   }
                   if (flex_attribute->combine_attr_counter[counter].
                           tcp_flags & BCM_STAT_FLEX_TCP_FLAG_TYPE_PSH) {
                       temp_count = offset_array[loop][0];
                       offset_array[loop][temp_count+1]= (BCM_STAT_FLEX_TCP_FLAG_TYPE_PSH
                               << shift_by_bits);
                       offset_array[loop][0] = temp_count+1;
                   }
                   if (flex_attribute->combine_attr_counter[counter].
                           tcp_flags & BCM_STAT_FLEX_TCP_FLAG_TYPE_ACK) {
                       temp_count = offset_array[loop][0];
                       offset_array[loop][temp_count+1]= (BCM_STAT_FLEX_TCP_FLAG_TYPE_ACK
                               << shift_by_bits);
                       offset_array[loop][0] = temp_count+1;
                   }
                   if (flex_attribute->combine_attr_counter[counter].
                           tcp_flags & BCM_STAT_FLEX_TCP_FLAG_TYPE_URG) {
                       temp_count = offset_array[loop][0];
                       offset_array[loop][temp_count+1]= (BCM_STAT_FLEX_TCP_FLAG_TYPE_URG
                               << shift_by_bits);
                       offset_array[loop][0] = temp_count+1;
                   }
                   if (flex_attribute->combine_attr_counter[counter].
                           tcp_flags & BCM_STAT_FLEX_TCP_FLAG_TYPE_ECE) {
                       temp_count = offset_array[loop][0];
                       offset_array[loop][temp_count+1]= (BCM_STAT_FLEX_TCP_FLAG_TYPE_ECE
                               << shift_by_bits);
                       offset_array[loop][0] = temp_count+1;
                   }
                   if (flex_attribute->combine_attr_counter[counter].
                           tcp_flags & BCM_STAT_FLEX_TCP_FLAG_TYPE_CWR) {
                       temp_count = offset_array[loop][0];
                       offset_array[loop][temp_count+1]= (BCM_STAT_FLEX_TCP_FLAG_TYPE_CWR
                               << shift_by_bits);
                       offset_array[loop][0] = temp_count+1;
                   }

                   loop++;
               }
           }

#if defined(BCM_TOMAHAWK_SUPPORT) || defined(BCM_TRIDENT3_SUPPORT)
           if (soc_feature(unit, soc_feature_flex_stat_egr_queue_congestion_marked)) {
               if ((flex_attribute->mmu_cos != 0) &&
                   (loop <= (BCM_STAT_FLEX_COUNTER_MAX_TOTAL_BITS - 2))) {
                   shift_by_bits = uc_queueing_bits +
                                   congestion_marked_bits +
                                   ifp_cng_bits +
                                   int_pri_bits +
                                    vlan_format_bits +
                                    outer_dot1p_bits +
                                    inner_dot1p_bits +
                                    port_bits +
                                    tos_dscp_bits +
                                    tos_ecn_bits +
                                    pkt_resolution_bits +
                                    svp_bits +
                                    dvp_bits +
                                    drop_bits +
                                    ip_pkt_bits ;
                   if (flex_attribute->combine_attr_counter[counter].
                       mmu_cos_flags & BCM_STAT_FLEX_COS0) {
                       temp_count = offset_array[loop][0];
                       offset_array[loop][temp_count+1]= (0 << shift_by_bits);
                       offset_array[loop][0] = temp_count+1;
                   }
                   if (flex_attribute->combine_attr_counter[counter].
                       mmu_cos_flags & BCM_STAT_FLEX_COS1) {
                       temp_count = offset_array[loop][0];
                       offset_array[loop][temp_count+1]= (1 << shift_by_bits);
                       offset_array[loop][0] = temp_count+1;
                   }
                   if (flex_attribute->combine_attr_counter[counter].
                       mmu_cos_flags & BCM_STAT_FLEX_COS2) {
                       temp_count = offset_array[loop][0];
                       offset_array[loop][temp_count+1]= (2 << shift_by_bits);
                       offset_array[loop][0] = temp_count+1;
                   }
                   if (flex_attribute->combine_attr_counter[counter].
                       mmu_cos_flags & BCM_STAT_FLEX_COS3) {
                       temp_count = offset_array[loop][0];
                       offset_array[loop][temp_count+1]= (3 << shift_by_bits);
                       offset_array[loop][0] = temp_count+1;
                   }
                   if (flex_attribute->combine_attr_counter[counter].
                       mmu_cos_flags & BCM_STAT_FLEX_COS4) {
                       temp_count = offset_array[loop][0];
                       offset_array[loop][temp_count+1]= (4 << shift_by_bits);
                       offset_array[loop][0] = temp_count+1;
                   }
                   if (flex_attribute->combine_attr_counter[counter].
                       mmu_cos_flags & BCM_STAT_FLEX_COS5) {
                       temp_count = offset_array[loop][0];
                       offset_array[loop][temp_count+1]= (5 << shift_by_bits);
                       offset_array[loop][0] = temp_count+1;
                   }
                   if (flex_attribute->combine_attr_counter[counter].
                       mmu_cos_flags & BCM_STAT_FLEX_COS6) {
                       temp_count = offset_array[loop][0];
                       offset_array[loop][temp_count+1]= (6 << shift_by_bits);
                       offset_array[loop][0] = temp_count+1;
                   }
                   if (flex_attribute->combine_attr_counter[counter].
                       mmu_cos_flags & BCM_STAT_FLEX_COS7) {
                       temp_count = offset_array[loop][0];
                       offset_array[loop][temp_count+1]= (7 << shift_by_bits);
                       offset_array[loop][0] = temp_count+1;
                   }
                   if (flex_attribute->combine_attr_counter[counter].
                       mmu_cos_flags & BCM_STAT_FLEX_COS8) {
                       temp_count = offset_array[loop][0];
                       offset_array[loop][temp_count+1]= (8 << shift_by_bits);
                       offset_array[loop][0] = temp_count+1;
                   }
                   if (flex_attribute->combine_attr_counter[counter].
                       mmu_cos_flags & BCM_STAT_FLEX_COS9) {
                       temp_count = offset_array[loop][0];
                       offset_array[loop][temp_count+1]= (9 << shift_by_bits);
                       offset_array[loop][0] = temp_count+1;
                   }
                   if (flex_attribute->combine_attr_counter[counter].
                       mmu_cos_flags & BCM_STAT_FLEX_COS10) {
                       temp_count = offset_array[loop][0];
                       offset_array[loop][temp_count+1]= (10 << shift_by_bits);
                       offset_array[loop][0] = temp_count+1;
                   }
                   if (flex_attribute->combine_attr_counter[counter].
                       mmu_cos_flags & BCM_STAT_FLEX_COS11) {
                       temp_count = offset_array[loop][0];
                       offset_array[loop][temp_count+1]= (11 << shift_by_bits);
                       offset_array[loop][0] = temp_count+1;
                   }
                   if (flex_attribute->combine_attr_counter[counter].
                       mmu_cos_flags & BCM_STAT_FLEX_COS12) {
                       temp_count = offset_array[loop][0];
                       offset_array[loop][temp_count+1]= (12 << shift_by_bits);
                       offset_array[loop][0] = temp_count+1;
                   }
                   if (flex_attribute->combine_attr_counter[counter].
                       mmu_cos_flags & BCM_STAT_FLEX_COS13) {
                       temp_count = offset_array[loop][0];
                       offset_array[loop][temp_count+1]= (13 << shift_by_bits);
                       offset_array[loop][0] = temp_count+1;
                   }
                   if (flex_attribute->combine_attr_counter[counter].
                       mmu_cos_flags & BCM_STAT_FLEX_COS14) {
                       temp_count = offset_array[loop][0];
                       offset_array[loop][temp_count+1]= (14 << shift_by_bits);
                       offset_array[loop][0] = temp_count+1;
                   }
                   if (flex_attribute->combine_attr_counter[counter].
                       mmu_cos_flags & BCM_STAT_FLEX_COS15) {
                       temp_count = offset_array[loop][0];
                       offset_array[loop][temp_count+1]= (15 << shift_by_bits);
                       offset_array[loop][0] = temp_count+1;
                   }
                   loop++;
               }
               if ((flex_attribute->uc_queueing != 0) &&
                   (loop <= (BCM_STAT_FLEX_COUNTER_MAX_TOTAL_BITS - 2))) {
                   shift_by_bits = congestion_marked_bits +
                                   ifp_cng_bits +
                                   int_pri_bits +
                                    vlan_format_bits +
                                    outer_dot1p_bits +
                                    inner_dot1p_bits +
                                    port_bits +
                                    tos_dscp_bits +
                                    tos_ecn_bits +
                                    pkt_resolution_bits +
                                    svp_bits +
                                    dvp_bits +
                                    drop_bits +
                                    ip_pkt_bits ;
                   if (flex_attribute->combine_attr_counter[counter].
                       uc_queueing_flags & BCM_STAT_FLEX_UC_QUEUEING_DISABLE) {
                       temp_count = offset_array[loop][0];
                       offset_array[loop][temp_count+1]= (0 << shift_by_bits);
                       offset_array[loop][0] = temp_count+1;
                   }
                   if (flex_attribute->combine_attr_counter[counter].
                       uc_queueing_flags & BCM_STAT_FLEX_UC_QUEUEING_ENABLE) {
                       temp_count = offset_array[loop][0];
                       offset_array[loop][temp_count+1]= (1 << shift_by_bits);
                       offset_array[loop][0] = temp_count+1;
                   }
                   loop++;
               }
               if ((flex_attribute->congestion_marked != 0) &&
                   (loop <= (BCM_STAT_FLEX_COUNTER_MAX_TOTAL_BITS - 2))) {
                   shift_by_bits = ifp_cng_bits +
                                   int_pri_bits +
                                    vlan_format_bits +
                                    outer_dot1p_bits +
                                    inner_dot1p_bits +
                                    port_bits +
                                    tos_dscp_bits +
                                    tos_ecn_bits +
                                    pkt_resolution_bits +
                                    svp_bits +
                                    dvp_bits +
                                    drop_bits +
                                    ip_pkt_bits ;
                   if (flex_attribute->combine_attr_counter[counter].
                       congestion_marked_flags & BCM_STAT_FLEX_CONGESTION_MARKED_DISABLE) {
                       temp_count = offset_array[loop][0];
                       offset_array[loop][temp_count+1]= (0 << shift_by_bits);
                       offset_array[loop][0] = temp_count+1;
                   }
                   if (flex_attribute->combine_attr_counter[counter].
                       congestion_marked_flags & BCM_STAT_FLEX_CONGESTION_MARKED_ENABLE) {
                       temp_count = offset_array[loop][0];
                       offset_array[loop][temp_count+1]= (1 << shift_by_bits);
                       offset_array[loop][0] = temp_count+1;
                   }
                   loop++;
               }
           }
#endif
           if ((flex_attribute->pre_ifp_color != 0) &&
               (loop <= (BCM_STAT_FLEX_COUNTER_MAX_TOTAL_BITS - 2))) {
               shift_by_bits = ifp_cng_bits +
                               int_pri_bits +
                                vlan_format_bits +
                                outer_dot1p_bits +
                                inner_dot1p_bits +
                                port_bits +
                                tos_dscp_bits +
                                tos_ecn_bits +
                                pkt_resolution_bits +
                                svp_bits +
                                dvp_bits +
                                drop_bits +
                                ip_pkt_bits ;
                if (flex_attribute->combine_attr_counter[counter].
                    pre_ifp_color_flags & BCM_STAT_FLEX_COLOR_GREEN) {
                    temp_count = offset_array[loop][0];
                                                       /* GreenIndex=0*/
                    offset_array[loop][temp_count+1] = (0 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    pre_ifp_color_flags & BCM_STAT_FLEX_COLOR_RED) {
                    temp_count = offset_array[loop][0];
                                                      /* RedIndex=1 */
                    offset_array[loop][temp_count+1]= (1 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    pre_ifp_color_flags & BCM_STAT_FLEX_COLOR_YELLOW) {
                    temp_count = offset_array[loop][0];
                                                      /* YellowIndex=3 */
                    offset_array[loop][temp_count+1]= (3 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                loop++;
            }
            if ((flex_attribute->ifp_color != 0) &&
                (loop <= (BCM_STAT_FLEX_COUNTER_MAX_TOTAL_BITS - 2))) {
                shift_by_bits = int_pri_bits +
                                vlan_format_bits +
                                outer_dot1p_bits +
                                inner_dot1p_bits +
                                port_bits +
                                tos_dscp_bits +
                                tos_ecn_bits +
                                pkt_resolution_bits +
                                svp_bits +
                                dvp_bits +
                                drop_bits +
                                ip_pkt_bits ;
                if (flex_attribute->combine_attr_counter[counter].
                    ifp_color_flags & BCM_STAT_FLEX_COLOR_GREEN) {
                    temp_count = offset_array[loop][0];
                                                       /* GreenIndex=0*/
                    offset_array[loop][temp_count+1] = (0 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    ifp_color_flags & BCM_STAT_FLEX_COLOR_RED) {
                    temp_count = offset_array[loop][0];
                                                      /* RedIndex=1 */
                    offset_array[loop][temp_count+1]= (1 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    ifp_color_flags & BCM_STAT_FLEX_COLOR_YELLOW) {
                    temp_count = offset_array[loop][0];
                                                      /* YellowIndex=3 */
                    offset_array[loop][temp_count+1]= (3 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                loop++;
            }
            if ((flex_attribute->int_pri != 0) &&
                (loop <= (BCM_STAT_FLEX_COUNTER_MAX_TOTAL_BITS - 2))) {
                shift_by_bits = vlan_format_bits +
                                outer_dot1p_bits +
                                inner_dot1p_bits +
                                port_bits +
                                tos_dscp_bits +
                                tos_ecn_bits +
                                pkt_resolution_bits +
                                svp_bits +
                                dvp_bits +
                                drop_bits +
                                ip_pkt_bits ;
                if (flex_attribute->combine_attr_counter[counter].
                    int_pri_flags & BCM_STAT_FLEX_PRI0) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (0 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    int_pri_flags & BCM_STAT_FLEX_PRI1) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (1 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    int_pri_flags & BCM_STAT_FLEX_PRI2) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (2 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    int_pri_flags & BCM_STAT_FLEX_PRI3) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (3 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    int_pri_flags & BCM_STAT_FLEX_PRI4) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (4 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    int_pri_flags & BCM_STAT_FLEX_PRI5) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (5 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    int_pri_flags & BCM_STAT_FLEX_PRI6) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (6 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    int_pri_flags & BCM_STAT_FLEX_PRI7) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (7 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    int_pri_flags & BCM_STAT_FLEX_PRI8) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (8 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    int_pri_flags & BCM_STAT_FLEX_PRI9) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (9 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    int_pri_flags & BCM_STAT_FLEX_PRI10) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (10 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    int_pri_flags & BCM_STAT_FLEX_PRI11) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (11 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    int_pri_flags & BCM_STAT_FLEX_PRI12) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (12 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    int_pri_flags & BCM_STAT_FLEX_PRI13) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (13 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    int_pri_flags & BCM_STAT_FLEX_PRI14) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (14 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    int_pri_flags & BCM_STAT_FLEX_PRI15) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (15 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                loop++;
            }
            /* LogicalGroup1 */
            if ((flex_attribute->vlan_format != 0) &&
                (loop <= (BCM_STAT_FLEX_COUNTER_MAX_TOTAL_BITS - 2))) {
                shift_by_bits = outer_dot1p_bits +
                                inner_dot1p_bits +
                                port_bits +
                                tos_dscp_bits +
                                tos_ecn_bits +
                                pkt_resolution_bits +
                                svp_bits +
                                dvp_bits +
                                drop_bits + 
                                ip_pkt_bits ;
                if (flex_attribute->combine_attr_counter[counter].
                    vlan_format_flags & BCM_STAT_FLEX_VLAN_FORMAT_UNTAGGED) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (0 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    vlan_format_flags & BCM_STAT_FLEX_VLAN_FORMAT_INNER) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (1 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    vlan_format_flags & BCM_STAT_FLEX_VLAN_FORMAT_OUTER) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (2 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    vlan_format_flags & BCM_STAT_FLEX_VLAN_FORMAT_BOTH) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (3 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                loop++;
            }
            if ((flex_attribute->outer_dot1p != 0) &&
                (loop <= (BCM_STAT_FLEX_COUNTER_MAX_TOTAL_BITS - 2))) {
                shift_by_bits = inner_dot1p_bits +
                                port_bits +
                                tos_dscp_bits +
                                tos_ecn_bits +
                                pkt_resolution_bits +
                                svp_bits +
                                dvp_bits +
                                drop_bits +
                                ip_pkt_bits ;
                if (flex_attribute->combine_attr_counter[counter].
                    outer_dot1p_flags & BCM_STAT_FLEX_PRI0) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (0 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    outer_dot1p_flags & BCM_STAT_FLEX_PRI1) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (1 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    outer_dot1p_flags & BCM_STAT_FLEX_PRI2) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (2 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    outer_dot1p_flags & BCM_STAT_FLEX_PRI3) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (3 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    outer_dot1p_flags & BCM_STAT_FLEX_PRI4) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (4 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    outer_dot1p_flags & BCM_STAT_FLEX_PRI5) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (5 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    outer_dot1p_flags & BCM_STAT_FLEX_PRI6) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (6 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    outer_dot1p_flags & BCM_STAT_FLEX_PRI7) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (7 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                loop++;
            }
            if ((flex_attribute->inner_dot1p != 0) &&
                (loop <= (BCM_STAT_FLEX_COUNTER_MAX_TOTAL_BITS - 2))) {
                shift_by_bits = port_bits +
                                tos_dscp_bits +
                                tos_ecn_bits +
                                pkt_resolution_bits +
                                svp_bits +
                                dvp_bits +
                                drop_bits +
                                ip_pkt_bits ;
                if (flex_attribute->combine_attr_counter[counter].
                    inner_dot1p_flags & BCM_STAT_FLEX_PRI0) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (0 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    inner_dot1p_flags & BCM_STAT_FLEX_PRI1) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (1 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    inner_dot1p_flags & BCM_STAT_FLEX_PRI2) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (2 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    inner_dot1p_flags & BCM_STAT_FLEX_PRI3) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (3 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    inner_dot1p_flags & BCM_STAT_FLEX_PRI4) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (4 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    inner_dot1p_flags & BCM_STAT_FLEX_PRI5) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (5 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    inner_dot1p_flags & BCM_STAT_FLEX_PRI6) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (6 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    inner_dot1p_flags & BCM_STAT_FLEX_PRI7) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (7 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                loop++;
            }
            /* LogicalGroup2 */
            if ((flex_attribute->port != 0) &&
                (loop <= (BCM_STAT_FLEX_COUNTER_MAX_TOTAL_BITS - 2))) {
                shift_by_bits = tos_dscp_bits +
                                tos_ecn_bits +
                                pkt_resolution_bits +
                                svp_bits +
                                dvp_bits +
                                drop_bits +
                                ip_pkt_bits ;
                if (direction == bcmStatFlexDirectionIngress) {
                    max_count= (1 << ing_pkt_attr_uncmprsd_bits_g[unit].ing_port) - 1;
                } else {
                    max_count= (1 << egr_pkt_attr_uncmprsd_bits_g[unit].egr_port) - 1;
                }
#if defined(BCM_TRIDENT3_SUPPORT) || defined(BCM_APACHE_SUPPORT)
                if (soc_feature(unit,
                            soc_feature_flex_stat_port_group_support)) {
                    for (loop_index=0; loop_index <= max_count ; loop_index++) {
                        if (BCM_STAT_FLEX_VALUE_GET(
                                    flex_attribute->combine_attr_counter[counter].
                                    value_array[bcmStatFlexAttrPort],loop_index)) {
                            for (inner_loop_index = 0;
                                    inner_loop_index <= max_count;
                                    inner_loop_index++) {
                                if (SHR_BITGET(stat_port_grp[unit].
                                            port_grp_bmap[loop_index].pbits, inner_loop_index)) {
                                    temp_count = offset_array[loop][0];
                                    offset_array[loop][temp_count+1]= (inner_loop_index /*value*/
                                            << shift_by_bits);
                                    offset_array[loop][0] = temp_count+1;
                                }
                            }
                        }
                    }
                } else
#endif
                {
                    for (loop_index=0; loop_index <= max_count ; loop_index++) {
                        if (BCM_STAT_FLEX_VALUE_GET(
                                    flex_attribute->combine_attr_counter[counter].
                                    value_array[bcmStatFlexAttrPort],loop_index)) {
                            temp_count = offset_array[loop][0];
                            offset_array[loop][temp_count+1]= (loop_index /*value*/
                                    << shift_by_bits);
                            offset_array[loop][0] = temp_count+1;
                        }
                    }
                }
                loop++;
            }
            /* LogicalGroup3 */
            if ((flex_attribute->tos_dscp != 0) &&
                (loop <= (BCM_STAT_FLEX_COUNTER_MAX_TOTAL_BITS - 2))) {
                shift_by_bits = tos_ecn_bits +
                                pkt_resolution_bits +
                                svp_bits +
                                dvp_bits +
                                drop_bits +
                                ip_pkt_bits ;
                if (direction == bcmStatFlexDirectionIngress) {
                   max_count= (1 << ing_pkt_attr_uncmprsd_bits_g[unit].tos_dscp) - 1;
                } else {
                   max_count= (1 << egr_pkt_attr_uncmprsd_bits_g[unit].tos_dscp) - 1;
                }
                for (loop_index=0; loop_index <= max_count ; loop_index++) {
                    if (BCM_STAT_FLEX_VALUE_GET(
                            flex_attribute->combine_attr_counter[counter].
                            value_array[bcmStatFlexAttrTosDscp],loop_index)) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (loop_index /*value*/
                                                           << (shift_by_bits));
                        offset_array[loop][0] = temp_count+1;
                    }
                }
                loop++;
            }
            if ((flex_attribute->tos_ecn != 0) &&
                (loop <= (BCM_STAT_FLEX_COUNTER_MAX_TOTAL_BITS - 2))) {
                shift_by_bits = pkt_resolution_bits +
                                svp_bits +
                                dvp_bits +
                                drop_bits +
                                ip_pkt_bits ;
                if (direction == bcmStatFlexDirectionIngress) {
                   max_count= (1 << ing_pkt_attr_uncmprsd_bits_g[unit].tos_ecn) - 1;
                } else {
                   max_count= (1 << egr_pkt_attr_uncmprsd_bits_g[unit].tos_ecn) - 1;
                }
                for (loop_index=0; loop_index <= max_count ; loop_index++) {
                    if (BCM_STAT_FLEX_VALUE_GET(
                            flex_attribute->combine_attr_counter[counter].
                            value_array[bcmStatFlexAttrTosEcn],loop_index)) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (loop_index /*value*/
                                                           << (shift_by_bits));
                        offset_array[loop][0] = temp_count+1;
                    }
                }
                loop++;
            }
            /* LogicalGroup4 */
            if ((flex_attribute->pkt_resolution != 0) &&
                (loop <= (BCM_STAT_FLEX_COUNTER_MAX_TOTAL_BITS - 2))) {
                shift_by_bits = svp_bits +
                                dvp_bits +
                                drop_bits +
                                ip_pkt_bits ;
                if (flex_attribute->combine_attr_counter[counter].
                    pkt_resolution_flags & BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_PKT) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (unknown_pkt <<
                                                       shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    pkt_resolution_flags & BCM_STAT_FLEX_PKT_TYPE_CONTROL_PKT) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (control_pkt <<
                                                       shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    pkt_resolution_flags & BCM_STAT_FLEX_PKT_TYPE_OAM_PKT) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (oam_pkt <<
                                                       shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    pkt_resolution_flags & BCM_STAT_FLEX_PKT_TYPE_BFD_PKT) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (bfd_pkt <<
                                                       shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    pkt_resolution_flags & BCM_STAT_FLEX_PKT_TYPE_BPDU_PKT) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (bpdu_pkt <<
                                                       shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    pkt_resolution_flags & BCM_STAT_FLEX_PKT_TYPE_ICNM_PKT) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (icnm_pkt <<
                                                       shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    pkt_resolution_flags & BCM_STAT_FLEX_PKT_TYPE_PKT_IS_1588) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (_1588_pkt <<
                                                       shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    pkt_resolution_flags & BCM_STAT_FLEX_PKT_TYPE_BFD_PKT) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (bfd_pkt <<
                                                       shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    pkt_resolution_flags &
                    BCM_STAT_FLEX_PKT_TYPE_KNOWN_L2UC_PKT) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (known_l2uc_pkt <<
                                                       shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    pkt_resolution_flags &
                    BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_L2UC_PKT) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (unknown_l2uc_pkt <<
                                                       shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    pkt_resolution_flags & BCM_STAT_FLEX_PKT_TYPE_L2BC_PKT) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (l2bc_pkt <<
                                                       shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    pkt_resolution_flags &
                    BCM_STAT_FLEX_PKT_TYPE_KNOWN_L2MC_PKT) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (known_l2mc_pkt <<
                                                       shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    pkt_resolution_flags &
                    BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_L2MC_PKT) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (unknown_l2mc_pkt <<
                                                       shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    pkt_resolution_flags &
                    BCM_STAT_FLEX_PKT_TYPE_KNOWN_L3UC_PKT) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (known_l3uc_pkt <<
                                                       shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    pkt_resolution_flags &
                    BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_L3UC_PKT) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (unknown_l3uc_pkt <<
                                                       shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    pkt_resolution_flags &
                    BCM_STAT_FLEX_PKT_TYPE_KNOWN_IPMC_PKT) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (known_ipmc_pkt <<
                                                       shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    pkt_resolution_flags &
                    BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_IPMC_PKT) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (unknown_ipmc_pkt <<
                                                       shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    pkt_resolution_flags &
                    BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_L2_PKT) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (known_mpls_l2_pkt <<
                                                       shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    pkt_resolution_flags &
                    BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_L3_PKT) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (known_mpls_l3_pkt <<
                                                       shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    pkt_resolution_flags &
                    BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_PKT) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (known_mpls_pkt <<
                                                       shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    pkt_resolution_flags &
                    BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_MPLS_PKT) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (unknown_mpls_pkt <<
                                                       shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    pkt_resolution_flags &
                    BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_MULTICAST_PKT) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (known_mpls_multicast_pkt <<
                                                       shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    pkt_resolution_flags &
                    BCM_STAT_FLEX_PKT_TYPE_KNOWN_MIM_PKT) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (known_mim_pkt <<
                                                       shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    pkt_resolution_flags &
                    BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_MIM_PKT) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (unknown_mim_pkt <<
                                                       shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    pkt_resolution_flags &
                    BCM_STAT_FLEX_PKT_TYPE_KNOWN_TRILL_PKT) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (known_trill_pkt <<
                                                       shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    pkt_resolution_flags &
                    BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_TRILL_PKT) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (unknown_trill_pkt <<
                                                       shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    pkt_resolution_flags &
                    BCM_STAT_FLEX_PKT_TYPE_KNOWN_NIV_PKT) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (known_niv_pkt <<
                                                       shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    pkt_resolution_flags &
                    BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_NIV_PKT) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (unknown_niv_pkt <<
                                                       shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
#if defined(BCM_TRIDENT2_SUPPORT)
                if (SOC_IS_TD2_TT2(unit)) {
                    if (flex_attribute->combine_attr_counter[counter].
                        pkt_resolution_flags &
                        BCM_STAT_FLEX_PKT_TYPE_KNOWN_L2GRE_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (known_l2gre_pkt <<
                                                           shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                        pkt_resolution_flags &
                        BCM_STAT_FLEX_PKT_TYPE_KNOWN_VXLAN_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (known_vxlan_pkt <<
                                                           shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                        pkt_resolution_flags &
                        BCM_STAT_FLEX_PKT_TYPE_KNOWN_FCOE_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (known_fcoe_pkt <<
                                                           shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                        pkt_resolution_flags &
                        BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_FCOE_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (unknown_fcoe_pkt <<
                                                           shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                }
#endif
                    if (flex_attribute->combine_attr_counter[counter].
                        pkt_resolution_high_flags &
                        BCM_STAT_FLEX_PKT_TYPE_2_L2_UC_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (l2_uc_pkt <<
                                                           shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                        pkt_resolution_high_flags &
                        BCM_STAT_FLEX_PKT_TYPE_2_L2_NON_UC_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (l2_non_uc_pkt <<
                                                           shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                
                loop++;
            }
            /* Logical Group 5 */
            if ((flex_attribute->svp != 0) &&
                (loop <= (BCM_STAT_FLEX_COUNTER_MAX_TOTAL_BITS - 2))) {
                shift_by_bits = dvp_bits +
                                drop_bits +
                                ip_pkt_bits ;
                if (direction == bcmStatFlexDirectionIngress) {
                    max_count= (1 << ing_pkt_attr_uncmprsd_bits_g[unit].svp_type)-1;
                } else {
                    max_count= (1 << egr_pkt_attr_uncmprsd_bits_g[unit].svp_type)-1;
                }
                for (loop_index=0; loop_index <= max_count ; loop_index++) {
                    if (BCM_STAT_FLEX_VALUE_GET(
                            flex_attribute->combine_attr_counter[counter].
                            value_array[bcmStatFlexAttrSvp],loop_index)) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (loop_index /*value*/
                                                           << shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                }
                loop++;
            }
            if ((flex_attribute->dvp != 0) &&
                (loop <= (BCM_STAT_FLEX_COUNTER_MAX_TOTAL_BITS - 2))) {
                shift_by_bits = drop_bits +
                                ip_pkt_bits ;
                max_count= (1 << egr_pkt_attr_uncmprsd_bits_g[unit].dvp_type)-1;
                for (loop_index=0; loop_index <= max_count ; loop_index++) {
                    if (BCM_STAT_FLEX_VALUE_GET(
                            flex_attribute->combine_attr_counter[counter].
                            value_array[bcmStatFlexAttrDvp],loop_index)) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (loop_index /*value*/
                                                           << shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                }
                loop++;
            }
            if ((flex_attribute->drop != 0) &&
                (loop <= (BCM_STAT_FLEX_COUNTER_MAX_TOTAL_BITS - 2))) {
                shift_by_bits = ip_pkt_bits ;
                if (flex_attribute->combine_attr_counter[counter].
                    drop_flags & BCM_STAT_FLEX_DROP_DISABLE) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (0 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    drop_flags & BCM_STAT_FLEX_DROP_ENABLE) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (1 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                loop++;
            }
            if ((flex_attribute->ip_pkt != 0) &&
                (loop <= (BCM_STAT_FLEX_COUNTER_MAX_TOTAL_BITS - 2))) {
                shift_by_bits = 0;
                if (flex_attribute->combine_attr_counter[counter].
                    ip_pkt_flags & BCM_STAT_FLEX_IP_PKT_DISABLE) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (0 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    ip_pkt_flags & BCM_STAT_FLEX_IP_PKT_ENABLE) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (1 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                loop++;
            }
            /* Third and Final Level Update: Make Absolute Offset */
            for (index0=0;
                 index0 < offset_array[0][0] ;
                 index0++) {
                 offset = offset_array[0][index0+1];
                 if (offset_array[1][0] != 0) {
                     for (index1=0;
                          index1 < offset_array[1][0] ;
                          index1++) {
                          offset = offset_array[0][index0+1] | offset_array[1][index1+1];
                          if (offset_array[2][0] != 0) {
                              for (index2=0;
                                   index2 < offset_array[2][0] ;
                                   index2++) {
                                   offset = offset_array[0][index0+1] |
                                            offset_array[1][index1+1] |
                                            offset_array[2][index2+1];
                                   if (offset_array[3][0] != 0) {
                                       for (index3=0;
                                            index3 < offset_array[3][0] ;
                                            index3++) {
                                            offset =  offset_array[0][index0+1] |
                                                      offset_array[1][index1+1] |
                                                      offset_array[2][index2+1] |
                                                      offset_array[3][index3+1];
                                            if (offset_array[4][0] != 0) {
                                                for (index4=0;
                                                     index4 < offset_array[4][0] ;
                                                     index4++) {
                                                     offset =  offset_array[0][index0+1] |
                                                               offset_array[1][index1+1] |
                                                               offset_array[2][index2+1] |
                                                               offset_array[3][index3+1] |
                                                               offset_array[4][index4+1];
                                                     if (offset_array[5][0] != 0) {
                                                         for (index5=0;
                                                              index5 < offset_array[5][0] ;
                                                              index5++) {
                                                              offset =  offset_array[0][index0+1] |
                                                                        offset_array[1][index1+1] |
                                                                        offset_array[2][index2+1] |
                                                                        offset_array[3][index3+1] |
                                                                        offset_array[4][index4+1] |
                                                                        offset_array[5][index5+1];
                                                              if (offset_array[6][0] != 0) {
                                                                  for (index6=0;
                                                                       index6 < offset_array[6][0] ;
                                                                       index6++) {
                                                                       offset =  offset_array[0][index0+1] |
                                                                                 offset_array[1][index1+1] |
                                                                                 offset_array[2][index2+1] |
                                                                                 offset_array[3][index3+1] |
                                                                                 offset_array[4][index4+1] |
                                                                                 offset_array[5][index5+1] |
                                                                                 offset_array[6][index6+1];
                                                                       if (offset_array[7][0] != 0) {
                                                                           for (index7=0;
                                                                                index7 < offset_array[7][0] ;
                                                                                index7++) {
                                                                                offset =  offset_array[0][index0+1] |
                                                                                          offset_array[1][index1+1] |
                                                                                          offset_array[2][index2+1] |
                                                                                          offset_array[3][index3+1] |
                                                                                          offset_array[4][index4+1] |
                                                                                          offset_array[5][index5+1] |
                                                                                          offset_array[6][index6+1] |
                                                                                          offset_array[7][index6+1];
                                                                                rv = _bcm_stat_flex_update_map(direction,attr,
                                                                                                          offset,counter);
                                                                                BCMI_IF_ERROR_CLEANUP(rv);
                                                                           }
                                                                       } else {
                                                                           rv = _bcm_stat_flex_update_map(direction,attr,
                                                                                                     offset,counter);
                                                                           BCMI_IF_ERROR_CLEANUP(rv);
                                                                       }
                                                                  }
                                                              } else {
                                                                  rv = _bcm_stat_flex_update_map(direction,attr,offset,counter);
                                                                  BCMI_IF_ERROR_CLEANUP(rv);
                                                              }
                                                         }
                                                     } else {
                                                         rv = _bcm_stat_flex_update_map(direction,attr,offset,counter);
                                                         BCMI_IF_ERROR_CLEANUP(rv);
                                                     }
                                                }
                                            } else {
                                                rv = _bcm_stat_flex_update_map(direction,attr,offset,counter);
                                                BCMI_IF_ERROR_CLEANUP(rv);
                                            }
                                       }
                                   } else {
                                       rv = _bcm_stat_flex_update_map(direction,attr,offset,counter);
                                       BCMI_IF_ERROR_CLEANUP(rv);
                                   }
                              }
                          } else {
                              rv = _bcm_stat_flex_update_map(direction,attr,offset,counter);
                              BCMI_IF_ERROR_CLEANUP(rv);
                          }
                     }
                 } else {
                     rv = _bcm_stat_flex_update_map(direction,attr,offset,counter);
                     BCMI_IF_ERROR_CLEANUP(rv);
                 }
            }
        }
    } else {
        LOG_VERBOSE(BSL_LS_BCM_FLEXCTR,
                    (BSL_META_U(unit,
                                "INFO: TotalBits=%d Trying out CompressedMode\n"),
                 total_bits));
        if (direction == bcmStatFlexDirectionIngress) {
            ing_attr->packet_attr_type = bcmStatFlexPacketAttrTypeCompressed;
            ing_attr->cmprsd_attr_selectors.total_counters =
                      flex_attribute->total_counters;
        } else {
            egr_attr->packet_attr_type = bcmStatFlexPacketAttrTypeCompressed;
            egr_attr->cmprsd_attr_selectors.total_counters =
                      flex_attribute->total_counters;
        }

        if (soc_feature(unit, soc_feature_flex_stat_compression_share)) {
            /* If compression tables sharing is supported, verify attributes */
            rv = _bcm_stat_flex_compressed_attr_selectors_verify(unit,
                    direction, bcmStatFlexPacketAttrTypeCompressed,
                    flex_attribute,ing_cmprsd_pkt_attr_bits,
                    egr_cmprsd_pkt_attr_bits);
            if (BCM_FAILURE(rv)) {
                LOG_VERBOSE(BSL_LS_BCM_FLEXCTR, (BSL_META_U(unit, "Compression"
                                " tables cannot be modified\n")));
                goto cleanup;
            }
            /* BEGIN: PRI_CNG_MAP */
            /* fill map_array for pre_ifp_color */
            if (flex_attribute->pre_ifp_color != 0) {
                if (map_array[bcmStatGroupModeAttrColor] == NULL) {
                    map_array[bcmStatGroupModeAttrColor] =
                        (uint8 *) sal_alloc(256+1,"map_array");
                    if (map_array[bcmStatGroupModeAttrColor] == NULL) {
                        rv = BCM_E_MEMORY;
                        goto cleanup;
                    }
                    sal_memset(map_array[bcmStatGroupModeAttrColor],
                            0xFF,256);
                    map_array[bcmStatGroupModeAttrColor][256]=0;
                }
                if (flex_attribute->combine_pre_ifp_color_flags &
                        BCM_STAT_FLEX_COLOR_GREEN) {
                    if (map_array[bcmStatGroupModeAttrColor][0] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrColor][256];
                        map_array[bcmStatGroupModeAttrColor][0] = temp_count;
                        map_array[bcmStatGroupModeAttrColor][256]=temp_count+1;
                    }
                }
                if (flex_attribute->combine_pre_ifp_color_flags &
                        BCM_STAT_FLEX_COLOR_RED) {
                    if (map_array[bcmStatGroupModeAttrColor][1] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrColor][256];
                        map_array[bcmStatGroupModeAttrColor][1] = temp_count;
                        map_array[bcmStatGroupModeAttrColor][256]=temp_count+1;
                    }
                }
                if (flex_attribute->combine_pre_ifp_color_flags &
                        BCM_STAT_FLEX_COLOR_YELLOW) {
                    if (map_array[bcmStatGroupModeAttrColor][3] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrColor][256];
                        map_array[bcmStatGroupModeAttrColor][3] = temp_count;
                        map_array[bcmStatGroupModeAttrColor][256]=temp_count+1;
                    }
                }
            }
            /* fill map array for ifp_color */
            if (flex_attribute->ifp_color != 0) {
                if (map_array[bcmStatGroupModeAttrFieldIngressColor] == NULL) {
                    map_array[bcmStatGroupModeAttrFieldIngressColor] =
                        (uint8 *) sal_alloc(256+1,"map_array");
                    if (map_array[bcmStatGroupModeAttrFieldIngressColor] == NULL) {
                        rv = BCM_E_MEMORY;
                        goto cleanup;
                    }
                    sal_memset(map_array[bcmStatGroupModeAttrFieldIngressColor],
                            0xFF,256);
                    map_array[bcmStatGroupModeAttrFieldIngressColor][256]=0;
                }
                /* Egress Not Possbile */
                /*
                   shift_by_bits = ing_pkt_attr_cmprsd_bits_g[unit].int_pri;
                   */
                if (flex_attribute->combine_ifp_color_flags &
                        BCM_STAT_FLEX_COLOR_GREEN) {
                    if (map_array[bcmStatGroupModeAttrFieldIngressColor][0]
                            == 0xFF) {
                        temp_count = map_array
                            [bcmStatGroupModeAttrFieldIngressColor]
                            [256];
                        map_array[bcmStatGroupModeAttrFieldIngressColor][0] =
                            temp_count;
                        map_array[bcmStatGroupModeAttrFieldIngressColor][256] =
                            temp_count+1;
                    }
                }
                if (flex_attribute->combine_ifp_color_flags &
                        BCM_STAT_FLEX_COLOR_RED) {
                    if (map_array[bcmStatGroupModeAttrFieldIngressColor][1]
                            == 0xFF) {
                        temp_count = map_array
                            [bcmStatGroupModeAttrFieldIngressColor]
                            [256];
                        map_array[bcmStatGroupModeAttrFieldIngressColor][1] =
                            temp_count;
                        map_array[bcmStatGroupModeAttrFieldIngressColor][256] =
                            temp_count+1;
                    }
                }
                if (flex_attribute->combine_ifp_color_flags &
                        BCM_STAT_FLEX_COLOR_YELLOW) {
                    if (map_array[bcmStatGroupModeAttrFieldIngressColor][3]
                            == 0xFF) {
                        temp_count = map_array
                            [bcmStatGroupModeAttrFieldIngressColor]
                            [256];
                        map_array[bcmStatGroupModeAttrFieldIngressColor][3] =
                            temp_count;
                        map_array[bcmStatGroupModeAttrFieldIngressColor][256] =
                            temp_count+1;
                    }
                }
            }
            /* fill map array for int_pri */
            if (flex_attribute->int_pri != 0) {
                /*
                   shift_by_bits = 0;
                   */
                if (map_array[bcmStatGroupModeAttrIntPri] == NULL) {
                    map_array[bcmStatGroupModeAttrIntPri] = 
                        (uint8 *) sal_alloc(256+1,"map_array");

                    if (map_array[bcmStatGroupModeAttrIntPri] == NULL) {
                        rv = BCM_E_MEMORY;
                        goto cleanup;
                    }

                    sal_memset(map_array[bcmStatGroupModeAttrIntPri],
                            0xFF,256);
                    map_array[bcmStatGroupModeAttrIntPri][256]=0;
                }
                if (flex_attribute->combine_int_pri_flags &
                        BCM_STAT_FLEX_PRI0) {
                    if (map_array[bcmStatGroupModeAttrIntPri][0] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrIntPri][256];
                        map_array[bcmStatGroupModeAttrIntPri][0] = temp_count;
                        map_array[bcmStatGroupModeAttrIntPri][256]=temp_count+1;
                    }
                }
                if (flex_attribute->combine_int_pri_flags &
                        BCM_STAT_FLEX_PRI1) {
                    if (map_array[bcmStatGroupModeAttrIntPri][1] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrIntPri][256];
                        map_array[bcmStatGroupModeAttrIntPri][1] = temp_count;
                        map_array[bcmStatGroupModeAttrIntPri][256]=temp_count+1;
                    }
                }
                if (flex_attribute->combine_int_pri_flags &
                        BCM_STAT_FLEX_PRI2) {
                    if (map_array[bcmStatGroupModeAttrIntPri][2] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrIntPri][256];
                        map_array[bcmStatGroupModeAttrIntPri][2] = temp_count;
                        map_array[bcmStatGroupModeAttrIntPri][256]=temp_count+1;
                    }
                }
                if (flex_attribute->combine_int_pri_flags &
                        BCM_STAT_FLEX_PRI3) {
                    if (map_array[bcmStatGroupModeAttrIntPri][3] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrIntPri][256];
                        map_array[bcmStatGroupModeAttrIntPri][3] = temp_count;
                        map_array[bcmStatGroupModeAttrIntPri][256]=temp_count+1;
                    }
                }
                if (flex_attribute->combine_int_pri_flags &
                        BCM_STAT_FLEX_PRI4) {
                    if (map_array[bcmStatGroupModeAttrIntPri][4] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrIntPri][256];
                        map_array[bcmStatGroupModeAttrIntPri][4] = temp_count;
                        map_array[bcmStatGroupModeAttrIntPri][256]=temp_count+1;
                    }
                }
                if (flex_attribute->combine_int_pri_flags &
                        BCM_STAT_FLEX_PRI5) {
                    if (map_array[bcmStatGroupModeAttrIntPri][5] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrIntPri][256];
                        map_array[bcmStatGroupModeAttrIntPri][5] = temp_count;
                        map_array[bcmStatGroupModeAttrIntPri][256]=temp_count+1;
                    }
                }
                if (flex_attribute->combine_int_pri_flags &
                        BCM_STAT_FLEX_PRI6) {
                    if (map_array[bcmStatGroupModeAttrIntPri][6] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrIntPri][256];
                        map_array[bcmStatGroupModeAttrIntPri][6] = temp_count;
                        map_array[bcmStatGroupModeAttrIntPri][256]=temp_count+1;
                    }
                }
                if (flex_attribute->combine_int_pri_flags &
                        BCM_STAT_FLEX_PRI7) {
                    if (map_array[bcmStatGroupModeAttrIntPri][7] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrIntPri][256];
                        map_array[bcmStatGroupModeAttrIntPri][7] = temp_count;
                        map_array[bcmStatGroupModeAttrIntPri][256]=temp_count+1;
                    }
                }
                if (flex_attribute->combine_int_pri_flags &
                        BCM_STAT_FLEX_PRI8) {
                    if (map_array[bcmStatGroupModeAttrIntPri][8] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrIntPri][256];
                        map_array[bcmStatGroupModeAttrIntPri][8] = temp_count;
                        map_array[bcmStatGroupModeAttrIntPri][256]=temp_count+1;
                    }
                }
                if (flex_attribute->combine_int_pri_flags &
                        BCM_STAT_FLEX_PRI9) {
                    if (map_array[bcmStatGroupModeAttrIntPri][9] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrIntPri][256];
                        map_array[bcmStatGroupModeAttrIntPri][9] = temp_count;
                        map_array[bcmStatGroupModeAttrIntPri][256]=temp_count+1;
                    }
                }
                if (flex_attribute->combine_int_pri_flags &
                        BCM_STAT_FLEX_PRI10) {
                    if (map_array[bcmStatGroupModeAttrIntPri][10] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrIntPri][256];
                        map_array[bcmStatGroupModeAttrIntPri][10] = temp_count;
                        map_array[bcmStatGroupModeAttrIntPri][256]=temp_count+1;
                    }
                }
                if (flex_attribute->combine_int_pri_flags &
                        BCM_STAT_FLEX_PRI11) {
                    if (map_array[bcmStatGroupModeAttrIntPri][11] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrIntPri][256];
                        map_array[bcmStatGroupModeAttrIntPri][11] = temp_count;
                        map_array[bcmStatGroupModeAttrIntPri][256]=temp_count+1;
                    }
                }
                if (flex_attribute->combine_int_pri_flags &
                        BCM_STAT_FLEX_PRI12) {
                    if (map_array[bcmStatGroupModeAttrIntPri][12] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrIntPri][256];
                        map_array[bcmStatGroupModeAttrIntPri][12] = temp_count;
                        map_array[bcmStatGroupModeAttrIntPri][256]=temp_count+1;
                    }
                }
                if (flex_attribute->combine_int_pri_flags &
                        BCM_STAT_FLEX_PRI13) {
                    if (map_array[bcmStatGroupModeAttrIntPri][13] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrIntPri][256];
                        map_array[bcmStatGroupModeAttrIntPri][13] = temp_count;
                        map_array[bcmStatGroupModeAttrIntPri][256]=temp_count+1;
                    }
                }
                if (flex_attribute->combine_int_pri_flags &
                        BCM_STAT_FLEX_PRI14) {
                    if (map_array[bcmStatGroupModeAttrIntPri][14] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrIntPri][256];
                        map_array[bcmStatGroupModeAttrIntPri][14] = temp_count;
                        map_array[bcmStatGroupModeAttrIntPri][256]=temp_count+1;
                    }
                }
                if (flex_attribute->combine_int_pri_flags &
                        BCM_STAT_FLEX_PRI15) {
                    if (map_array[bcmStatGroupModeAttrIntPri][15] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrIntPri][256];
                        map_array[bcmStatGroupModeAttrIntPri][15] = temp_count;
                        map_array[bcmStatGroupModeAttrIntPri][256]=temp_count+1;
                    }
                }
            }
            /* END: PRI_CNG_MAP */

            /* fill map array for vlan_format,outer_dot1p,inner_dot1p
             * BEGIN: PKT_PRI_MAP */
            if (flex_attribute->vlan_format != 0) {
                if (map_array[bcmStatGroupModeAttrVlan] == NULL) {
                    map_array[bcmStatGroupModeAttrVlan] = 
                        (uint8 *) sal_alloc(256+1,"map_array");

                    if (map_array[bcmStatGroupModeAttrVlan] == NULL) {
                        rv = BCM_E_MEMORY;
                        goto cleanup;
                    }

                    sal_memset(map_array[bcmStatGroupModeAttrVlan],
                            0xFF,256);
                    map_array[bcmStatGroupModeAttrVlan][256]=0;
                }
                if (flex_attribute->combine_vlan_format_flags &
                        BCM_STAT_FLEX_VLAN_FORMAT_UNTAGGED) {
                    if (map_array[bcmStatGroupModeAttrVlan][0] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrVlan][256];
                        map_array[bcmStatGroupModeAttrVlan][0] = temp_count;
                        map_array[bcmStatGroupModeAttrVlan][256]=temp_count+1;
                    }
                }
                if (flex_attribute->combine_vlan_format_flags &
                        BCM_STAT_FLEX_VLAN_FORMAT_INNER) {
                    if (map_array[bcmStatGroupModeAttrVlan][1] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrVlan][256];
                        map_array[bcmStatGroupModeAttrVlan][1] = temp_count;
                        map_array[bcmStatGroupModeAttrVlan][256]=temp_count+1;
                    }
                }
                if (flex_attribute->combine_vlan_format_flags &
                        BCM_STAT_FLEX_VLAN_FORMAT_OUTER) {
                    if (map_array[bcmStatGroupModeAttrVlan][2] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrVlan][256];
                        map_array[bcmStatGroupModeAttrVlan][2] = temp_count;
                        map_array[bcmStatGroupModeAttrVlan][256]=temp_count+1;
                    }
                }
                if (flex_attribute->combine_vlan_format_flags &
                        BCM_STAT_FLEX_VLAN_FORMAT_BOTH) {
                    if (map_array[bcmStatGroupModeAttrVlan][3] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrVlan][256];
                        map_array[bcmStatGroupModeAttrVlan][3] = temp_count;
                        map_array[bcmStatGroupModeAttrVlan][256]=temp_count+1;
                    }
                }
            }

            if (flex_attribute->outer_dot1p != 0) {
                if (map_array[bcmStatGroupModeAttrOuterPri] == NULL) {
                    map_array[bcmStatGroupModeAttrOuterPri] = 
                        (uint8 *) sal_alloc(256+1,"map_array");

                    if (map_array[bcmStatGroupModeAttrOuterPri] == NULL) {
                        rv = BCM_E_MEMORY;
                        goto cleanup;
                    }

                    sal_memset(map_array[bcmStatGroupModeAttrOuterPri],
                            0xFF,256);
                    map_array[bcmStatGroupModeAttrOuterPri][256]=0;
                }
                if (flex_attribute->combine_outer_dot1p_flags &
                        BCM_STAT_FLEX_PRI0) {
                    if (map_array[bcmStatGroupModeAttrOuterPri][0] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrOuterPri]
                            [256];
                        map_array[bcmStatGroupModeAttrOuterPri][0] =
                            temp_count;
                        map_array[bcmStatGroupModeAttrOuterPri][256] =
                            temp_count+1;
                    }
                }
                if (flex_attribute->combine_outer_dot1p_flags &
                        BCM_STAT_FLEX_PRI1) {
                    if (map_array[bcmStatGroupModeAttrOuterPri][1] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrOuterPri]
                            [256];
                        map_array[bcmStatGroupModeAttrOuterPri][1] =
                            temp_count;

                        map_array[bcmStatGroupModeAttrOuterPri][256] =
                            temp_count+1;
                    }
                }
                if (flex_attribute->combine_outer_dot1p_flags &
                        BCM_STAT_FLEX_PRI2) {
                    if (map_array[bcmStatGroupModeAttrOuterPri][2] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrOuterPri]
                            [256];
                        map_array[bcmStatGroupModeAttrOuterPri][2] = 
                            temp_count;
                        map_array[bcmStatGroupModeAttrOuterPri][256] =
                            temp_count+1;
                    }
                }
                if (flex_attribute->combine_outer_dot1p_flags &
                        BCM_STAT_FLEX_PRI3) {
                    if (map_array[bcmStatGroupModeAttrOuterPri][3] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrOuterPri]
                            [256];
                        map_array[bcmStatGroupModeAttrOuterPri][3] =
                            temp_count;
                        map_array[bcmStatGroupModeAttrOuterPri][256] =
                            temp_count+1;
                    }
                }
                if (flex_attribute->combine_outer_dot1p_flags &
                        BCM_STAT_FLEX_PRI4) {
                    if (map_array[bcmStatGroupModeAttrOuterPri][4] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrOuterPri]
                            [256];
                        map_array[bcmStatGroupModeAttrOuterPri][4] =
                            temp_count;
                        map_array[bcmStatGroupModeAttrOuterPri][256] =
                            temp_count+1;
                    }
                }
                if (flex_attribute->combine_outer_dot1p_flags &
                        BCM_STAT_FLEX_PRI5) {
                    if (map_array[bcmStatGroupModeAttrOuterPri][5] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrOuterPri]
                            [256];
                        map_array[bcmStatGroupModeAttrOuterPri][5] =
                            temp_count;
                        map_array[bcmStatGroupModeAttrOuterPri][256] =
                            temp_count+1;
                    }
                }
                if (flex_attribute->combine_outer_dot1p_flags &
                        BCM_STAT_FLEX_PRI6) {
                    if (map_array[bcmStatGroupModeAttrOuterPri][6] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrOuterPri]
                            [256];
                        map_array[bcmStatGroupModeAttrOuterPri][6] =
                            temp_count;
                        map_array[bcmStatGroupModeAttrOuterPri][256] =
                            temp_count+1;
                    }
                }
                if (flex_attribute->combine_outer_dot1p_flags &
                        BCM_STAT_FLEX_PRI7) {
                    if (map_array[bcmStatGroupModeAttrOuterPri][7] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrOuterPri]
                            [256];
                        map_array[bcmStatGroupModeAttrOuterPri][7] =
                            temp_count;
                        map_array[bcmStatGroupModeAttrOuterPri][256] =
                            temp_count+1;
                    }
                }
            }
            if (flex_attribute->inner_dot1p != 0) {
                if (map_array[bcmStatGroupModeAttrInnerPri] == NULL) {
                    map_array[bcmStatGroupModeAttrInnerPri] =
                        (uint8 *) sal_alloc(256+1,"map_array");

                    if (map_array[bcmStatGroupModeAttrInnerPri] == NULL) {
                        rv = BCM_E_MEMORY;
                        goto cleanup;
                    }

                    sal_memset(map_array[bcmStatGroupModeAttrInnerPri],
                            0xFF,256);
                    map_array[bcmStatGroupModeAttrInnerPri][256]=0;
                }
                if (flex_attribute->combine_inner_dot1p_flags &
                        BCM_STAT_FLEX_PRI0) {
                    if (map_array[bcmStatGroupModeAttrInnerPri][0] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrInnerPri]
                            [256];
                        map_array[bcmStatGroupModeAttrInnerPri][0] =
                            temp_count;
                        map_array[bcmStatGroupModeAttrInnerPri][256] =
                            temp_count+1;
                    }
                }
                if (flex_attribute->combine_inner_dot1p_flags &
                        BCM_STAT_FLEX_PRI1) {
                    if (map_array[bcmStatGroupModeAttrInnerPri][1] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrInnerPri]
                            [256];
                        map_array[bcmStatGroupModeAttrInnerPri][1] =
                            temp_count;
                        map_array[bcmStatGroupModeAttrInnerPri][256] =
                            temp_count+1;
                    }
                }
                if (flex_attribute->combine_inner_dot1p_flags &
                        BCM_STAT_FLEX_PRI2) {
                    if (map_array[bcmStatGroupModeAttrInnerPri][2] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrInnerPri]
                            [256];
                        map_array[bcmStatGroupModeAttrInnerPri][2] =
                            temp_count;
                        map_array[bcmStatGroupModeAttrInnerPri][256] =
                            temp_count+1;
                    }
                }
                if (flex_attribute->combine_inner_dot1p_flags &
                        BCM_STAT_FLEX_PRI3) {
                    if (map_array[bcmStatGroupModeAttrInnerPri][3] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrInnerPri]
                            [256];
                        map_array[bcmStatGroupModeAttrInnerPri][3] =
                            temp_count;
                        map_array[bcmStatGroupModeAttrInnerPri][256] =
                            temp_count+1;
                    }
                }
                if (flex_attribute->combine_inner_dot1p_flags &
                        BCM_STAT_FLEX_PRI4) {
                    if (map_array[bcmStatGroupModeAttrInnerPri][4] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrInnerPri]
                            [256];
                        map_array[bcmStatGroupModeAttrInnerPri][4] =
                            temp_count;
                        map_array[bcmStatGroupModeAttrInnerPri][256] =
                            temp_count+1;
                    }
                }
                if (flex_attribute->combine_attr_counter[counter].
                        inner_dot1p_flags & BCM_STAT_FLEX_PRI5) {
                    if (map_array[bcmStatGroupModeAttrInnerPri][5] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrInnerPri]
                            [256];
                        map_array[bcmStatGroupModeAttrInnerPri][5] =
                            temp_count;
                        map_array[bcmStatGroupModeAttrInnerPri][256] =
                            temp_count+1;
                    }
                }
                if (flex_attribute->combine_inner_dot1p_flags &
                        BCM_STAT_FLEX_PRI6) {
                    if (map_array[bcmStatGroupModeAttrInnerPri][6] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrInnerPri]
                            [256];
                        map_array[bcmStatGroupModeAttrInnerPri][6] =
                            temp_count;
                        map_array[bcmStatGroupModeAttrInnerPri][256] =
                            temp_count+1;
                    }
                }
                if (flex_attribute->combine_inner_dot1p_flags &
                        BCM_STAT_FLEX_PRI7) {
                    if (map_array[bcmStatGroupModeAttrInnerPri][7] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrInnerPri]
                            [256];
                        map_array[bcmStatGroupModeAttrInnerPri][7] =
                            temp_count;
                        map_array[bcmStatGroupModeAttrInnerPri][256] =
                            temp_count+1;
                    }
                }
            }

            /* BEGIN: PORT_MAP*/ 
            if ((flex_attribute->port != 0) || (flex_attribute->subport != 0)) {
#ifdef BCM_CHANNELIZED_SWITCHING_SUPPORT
                if (soc_feature(unit, soc_feature_channelized_switching)) {
                    port_map_array_size = 512;
                } else
#endif /* BCM_CHANNELIZED_SWITCHING_SUPPORT */
                {
                     port_map_array_size = 256;
                 }

                if (map_array[bcmStatGroupModeAttrPort] == NULL) {
                    map_array[bcmStatGroupModeAttrPort] =
                        (uint8 *) sal_alloc(port_map_array_size+1,"map_array");

                    if (map_array[bcmStatGroupModeAttrPort] == NULL) {
                        rv = BCM_E_MEMORY;
                        goto cleanup;
                    }

                    sal_memset(map_array[bcmStatGroupModeAttrPort],
                            0xFF,port_map_array_size);
                    map_array[bcmStatGroupModeAttrPort][port_map_array_size]=0;
                }
                if (direction == bcmStatFlexDirectionIngress) {
                    max_count= (1 << ing_pkt_attr_cmprsd_bits_g[unit].ing_port) - 1;
                } else {
                    max_count= (1 << egr_pkt_attr_cmprsd_bits_g[unit].egr_port) - 1;
                }
                for (loop_index=0; loop_index <= max_count ; loop_index++) {
                    if (BCM_STAT_FLEX_VALUE_GET(
                                flex_attribute->combine_value_array[bcmStatFlexAttrPort],loop_index)) {
                        if (map_array[bcmStatGroupModeAttrPort][loop_index] 
                                == 0xFF) {
#if defined(BCM_TRIDENT3_SUPPORT) || defined(BCM_APACHE_SUPPORT)
                            if (soc_feature(unit,
                                        soc_feature_flex_stat_port_group_support)) {
                                for (inner_loop_index = 0;
                                        inner_loop_index <= max_count ;
                                        inner_loop_index++) {
                                    if (SHR_BITGET(stat_port_grp[unit].
                                                port_grp_bmap[loop_index].pbits, inner_loop_index)) {
                                        map_array[bcmStatGroupModeAttrPort][inner_loop_index]
                                            = loop_index;
                                    }
                                }
                                map_array[bcmStatGroupModeAttrPort][port_map_array_size] = loop_index + 1;
                            } else
#endif
                            {
                                temp_count = map_array[bcmStatGroupModeAttrPort]
                                    [port_map_array_size];
                                map_array[bcmStatGroupModeAttrPort][loop_index] =
                                    temp_count;
                                map_array[bcmStatGroupModeAttrPort][port_map_array_size] =
                                    temp_count+1;
                            }
                        }
                    }
                }
            }
            /* END: PORT_MAP*/ 
            /* BEGIN: TOS_MAP*/ 
            if (flex_attribute->tos_dscp != 0) {
                if (map_array[bcmStatGroupModeAttrTosDscp] == NULL) {
                    map_array[bcmStatGroupModeAttrTosDscp] = 
                        (uint8 *) sal_alloc(256+1,"map_array");

                    if (map_array[bcmStatGroupModeAttrTosDscp] == NULL) {
                        rv = BCM_E_MEMORY;
                        goto cleanup;
                    }

                    sal_memset(map_array[bcmStatGroupModeAttrTosDscp],
                            0xFF,256);
                    map_array[bcmStatGroupModeAttrTosDscp][256]=0;
                }
                if (direction == bcmStatFlexDirectionIngress) {
                    max_count= (1 << ing_pkt_attr_cmprsd_bits_g[unit].tos_dscp) - 1;
                } else {
                    max_count= (1 << egr_pkt_attr_cmprsd_bits_g[unit].tos_dscp) - 1;
                }
                for (loop_index=0; loop_index <= max_count ; loop_index++) {
                    if (BCM_STAT_FLEX_VALUE_GET(
                                flex_attribute->combine_value_array[bcmStatFlexAttrTosDscp],loop_index)) {
                        if (map_array[bcmStatGroupModeAttrTosDscp][loop_index] 
                                == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrTosDscp]
                                [256];
                            map_array[bcmStatGroupModeAttrTosDscp][loop_index] = 
                                temp_count;
                            map_array[bcmStatGroupModeAttrTosDscp][256] =
                                temp_count+1;
                        }
                    }
                }
            }
            if (flex_attribute->tos_ecn != 0) {
                if (map_array[bcmStatGroupModeAttrTosEcn] == NULL) {
                    map_array[bcmStatGroupModeAttrTosEcn] = 
                        (uint8 *) sal_alloc(256+1,"map_array");

                    if (map_array[bcmStatGroupModeAttrTosEcn] == NULL) {
                        rv = BCM_E_MEMORY;
                        goto cleanup;     
                    }

                    sal_memset(map_array[bcmStatGroupModeAttrTosEcn],
                            0xFF,256);
                    map_array[bcmStatGroupModeAttrTosEcn][256]=0;
                }
                if (direction == bcmStatFlexDirectionIngress) {
                    max_count= (1 << ing_pkt_attr_cmprsd_bits_g[unit].tos_ecn) - 1;
                } else {
                    max_count= (1 << egr_pkt_attr_cmprsd_bits_g[unit].tos_ecn) - 1;
                }
                for (loop_index=0; loop_index <= max_count ; loop_index++) {
                    if (BCM_STAT_FLEX_VALUE_GET(
                                flex_attribute->combine_value_array[bcmStatFlexAttrTosEcn],loop_index)) {
                        if (map_array[bcmStatGroupModeAttrTosEcn][loop_index] 
                                == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrTosEcn]
                                [256];
                            map_array[bcmStatGroupModeAttrTosEcn][loop_index] = 
                                temp_count;
                            map_array[bcmStatGroupModeAttrTosEcn][256] =
                                temp_count+1;
                        }
                    }
                }
            }
            /* END: TOS_MAP*/ 
            /* BEGIN: PKT_RES_MAP*/
            if (flex_attribute->pkt_resolution != 0) {
#ifdef BCM_KATANA2_SUPPORT
                if (soc_feature(unit, soc_feature_flex_stat_attributes_class)) {
                    if (map_array[bcmStatGroupModeAttrClassType] == NULL) {
                        map_array[bcmStatGroupModeAttrClassType] =
                            (uint8 *) sal_alloc(256+1,"map_array");
                        if (map_array[bcmStatGroupModeAttrClassType] == NULL) {
                            rv = BCM_E_MEMORY;
                            goto cleanup;
                        }

                        sal_memset(map_array[bcmStatGroupModeAttrClassType],
                                0xFF,256);
                    }
                    for (i = 0; i < BCM_STAT_FLEX_BIT_ARRAY_SIZE; i++) {
                        if (BCM_STAT_FLEX_VALUE_GET(
                                    flex_attribute->combine_value_array[bcmStatFlexAttrComb], i)) {
                            hw_class_id = i;
                            break;
                        }
                    }

                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_PKT) {
                        if (map_array[bcmStatGroupModeAttrClassType]
                                [unknown_pkt] == 0xFF) {
                            map_array[bcmStatGroupModeAttrClassType]
                                [unknown_pkt] =  hw_class_id;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_CONTROL_PKT) {
                        if (map_array[bcmStatGroupModeAttrClassType]
                                [control_pkt] == 0xFF) {
                            map_array[bcmStatGroupModeAttrClassType]
                                [control_pkt] = hw_class_id;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_OAM_PKT) {
                        if (map_array[bcmStatGroupModeAttrClassType]
                                [oam_pkt] == 0xFF) {
                            map_array[bcmStatGroupModeAttrClassType]
                                [oam_pkt] = hw_class_id;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_BFD_PKT) {
                        if (map_array[bcmStatGroupModeAttrClassType]
                                [bfd_pkt] == 0xFF) {
                            map_array[bcmStatGroupModeAttrClassType]
                                [bfd_pkt] = hw_class_id;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_BPDU_PKT) {
                        if (map_array[bcmStatGroupModeAttrClassType]
                                [bpdu_pkt] == 0xFF) {
                            map_array[bcmStatGroupModeAttrClassType]
                                [bpdu_pkt] = hw_class_id;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_ICNM_PKT) {
                        if (map_array[bcmStatGroupModeAttrClassType]
                                [icnm_pkt] == 0xFF) {
                            map_array[bcmStatGroupModeAttrClassType]
                                [icnm_pkt] = hw_class_id;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_PKT_IS_1588) {
                        if (map_array[bcmStatGroupModeAttrClassType]
                                [_1588_pkt] == 0xFF) {
                            map_array[bcmStatGroupModeAttrClassType]
                                [_1588_pkt] = hw_class_id;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_BFD_PKT) {
                        if (map_array[bcmStatGroupModeAttrClassType]
                                [bfd_pkt] == 0xFF) {
                            map_array[bcmStatGroupModeAttrClassType]
                                [bfd_pkt] = hw_class_id;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_L2UC_PKT) {
                        if (map_array[bcmStatGroupModeAttrClassType]
                                [known_l2uc_pkt] == 0xFF) {
                            map_array[bcmStatGroupModeAttrClassType]
                                [known_l2uc_pkt] = hw_class_id;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_L2UC_PKT) {
                        if (map_array[bcmStatGroupModeAttrClassType]
                                [unknown_l2uc_pkt] == 0xFF) {
                            map_array[bcmStatGroupModeAttrClassType]
                                [unknown_l2uc_pkt] = hw_class_id;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_L2BC_PKT) {
                        if (map_array[bcmStatGroupModeAttrClassType]
                                [l2bc_pkt] == 0xFF) {
                            map_array[bcmStatGroupModeAttrClassType]
                                [l2bc_pkt] = hw_class_id;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_L2MC_PKT) {
                        if (map_array[bcmStatGroupModeAttrClassType]
                                [known_l2mc_pkt] == 0xFF) {
                            map_array[bcmStatGroupModeAttrClassType]
                                [known_l2mc_pkt] = hw_class_id;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_L2MC_PKT) {
                        if (map_array[bcmStatGroupModeAttrClassType]
                                [unknown_l2mc_pkt] == 0xFF) {
                            map_array[bcmStatGroupModeAttrClassType]
                                [unknown_l2mc_pkt] = hw_class_id;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_L3UC_PKT) {
                        if (map_array[bcmStatGroupModeAttrClassType]
                                [known_l3uc_pkt] == 0xFF) {
                            map_array[bcmStatGroupModeAttrClassType]
                                [known_l3uc_pkt] = hw_class_id;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_L3UC_PKT) {
                        if (map_array[bcmStatGroupModeAttrClassType]
                                [unknown_l3uc_pkt] == 0xFF) {
                            map_array[bcmStatGroupModeAttrClassType]
                                [unknown_l3uc_pkt] = hw_class_id;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_IPMC_PKT) {
                        if (map_array[bcmStatGroupModeAttrClassType]
                                [known_ipmc_pkt] == 0xFF) {
                            map_array[bcmStatGroupModeAttrClassType]
                                [known_ipmc_pkt] = hw_class_id;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_IPMC_PKT) {
                        if (map_array[bcmStatGroupModeAttrClassType]
                                [unknown_ipmc_pkt] == 0xFF) {
                            map_array[bcmStatGroupModeAttrClassType]
                                [unknown_ipmc_pkt] = hw_class_id;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_L2_PKT) {
                        if (map_array[bcmStatGroupModeAttrClassType]
                                [known_mpls_l2_pkt] == 0xFF) {
                            map_array[bcmStatGroupModeAttrClassType]
                                [known_mpls_l2_pkt] = hw_class_id;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_L3_PKT) {
                        if (map_array[bcmStatGroupModeAttrClassType]
                                [known_mpls_l3_pkt] == 0xFF) {
                            map_array[bcmStatGroupModeAttrClassType]
                                [known_mpls_l3_pkt] = hw_class_id;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_PKT) {
                        if (map_array[bcmStatGroupModeAttrClassType]
                                [known_mpls_pkt] == 0xFF) {
                            map_array[bcmStatGroupModeAttrClassType]
                                [known_mpls_pkt] = hw_class_id;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_MPLS_PKT) {
                        if (map_array[bcmStatGroupModeAttrClassType]
                                [unknown_mpls_pkt] == 0xFF) {
                            map_array[bcmStatGroupModeAttrClassType]
                                [unknown_mpls_pkt] = hw_class_id;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_MULTICAST_PKT) {
                        if (map_array[bcmStatGroupModeAttrClassType]
                                [known_mpls_multicast_pkt] == 0xFF) {
                            map_array[bcmStatGroupModeAttrClassType]
                                [known_mpls_multicast_pkt] = hw_class_id;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_MIM_PKT) {
                        if (map_array[bcmStatGroupModeAttrClassType]
                                [known_mim_pkt] == 0xFF) {
                            map_array[bcmStatGroupModeAttrClassType]
                                [known_mim_pkt] = hw_class_id;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_MIM_PKT) {
                        if (map_array[bcmStatGroupModeAttrClassType]
                                [unknown_mim_pkt] == 0xFF) {
                            map_array[bcmStatGroupModeAttrClassType]
                                [unknown_mim_pkt] = hw_class_id;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_TRILL_PKT) {
                        if (map_array[bcmStatGroupModeAttrClassType]
                                [known_trill_pkt] == 0xFF) {
                            map_array[bcmStatGroupModeAttrClassType]
                                [known_trill_pkt] = hw_class_id;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_TRILL_PKT) {
                        if (map_array[bcmStatGroupModeAttrClassType]
                                [unknown_trill_pkt] == 0xFF) {
                            map_array[bcmStatGroupModeAttrClassType]
                                [unknown_trill_pkt] = hw_class_id;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_NIV_PKT) {
                        if (map_array[bcmStatGroupModeAttrClassType]
                                [known_niv_pkt] == 0xFF) {

                            map_array[bcmStatGroupModeAttrClassType]
                                [known_niv_pkt] = hw_class_id;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_NIV_PKT) {
                        if (map_array[bcmStatGroupModeAttrClassType]
                                [unknown_niv_pkt] == 0xFF) {
                            map_array[bcmStatGroupModeAttrClassType]
                                [unknown_niv_pkt] = hw_class_id;
                        }
                    }
                    map_array[bcmStatGroupModeAttrClassType][256] = hw_class_id;
                } else
#endif
                {
                    if (map_array[bcmStatGroupModeAttrPktType] == NULL) {
                        map_array[bcmStatGroupModeAttrPktType] =
                            (uint8 *) sal_alloc(256+1,"map_array");
                        if (map_array[bcmStatGroupModeAttrPktType] == NULL) {
                            rv = BCM_E_MEMORY;
                            goto cleanup;
                        }

                        sal_memset(map_array[bcmStatGroupModeAttrPktType],
                                0xFF,256);
                        map_array[bcmStatGroupModeAttrPktType][256]=0;
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_PKT) {
                        if (map_array[bcmStatGroupModeAttrPktType]
                                [unknown_pkt] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrPktType]
                                [256];
                            map_array[bcmStatGroupModeAttrPktType]
                                [unknown_pkt] = temp_count;
                            map_array[bcmStatGroupModeAttrPktType][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_CONTROL_PKT) {
                        if (map_array[bcmStatGroupModeAttrPktType]
                                [control_pkt] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrPktType]
                                [256];
                            map_array[bcmStatGroupModeAttrPktType]
                                [control_pkt] = temp_count;
                            map_array[bcmStatGroupModeAttrPktType][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_OAM_PKT) {
                        if (map_array[bcmStatGroupModeAttrPktType]
                                [oam_pkt] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrPktType]
                                [256];
                            map_array[bcmStatGroupModeAttrPktType]
                                [oam_pkt] = temp_count;
                            map_array[bcmStatGroupModeAttrPktType][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_BFD_PKT) {
                        if (map_array[bcmStatGroupModeAttrPktType]
                                [bfd_pkt] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrPktType]
                                [256];
                            map_array[bcmStatGroupModeAttrPktType]
                                [bfd_pkt] = temp_count;
                            map_array[bcmStatGroupModeAttrPktType][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_BPDU_PKT) {
                        if (map_array[bcmStatGroupModeAttrPktType]
                                [bpdu_pkt] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrPktType]
                                [256];
                            map_array[bcmStatGroupModeAttrPktType]
                                [bpdu_pkt] = temp_count;
                            map_array[bcmStatGroupModeAttrPktType][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_ICNM_PKT) {
                        if (map_array[bcmStatGroupModeAttrPktType]
                                [icnm_pkt] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrPktType]
                                [256];
                            map_array[bcmStatGroupModeAttrPktType]
                                [icnm_pkt] = temp_count;
                            map_array[bcmStatGroupModeAttrPktType][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_PKT_IS_1588) {
                        if (map_array[bcmStatGroupModeAttrPktType]
                                [_1588_pkt] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrPktType]
                                [256];
                            map_array[bcmStatGroupModeAttrPktType]
                                [_1588_pkt] = temp_count;
                            map_array[bcmStatGroupModeAttrPktType][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_BFD_PKT) {
                        if (map_array[bcmStatGroupModeAttrPktType]
                                [bfd_pkt] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrPktType]
                                [256];
                            map_array[bcmStatGroupModeAttrPktType]
                                [bfd_pkt] = temp_count;
                            map_array[bcmStatGroupModeAttrPktType][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_L2UC_PKT) {
                        if (map_array[bcmStatGroupModeAttrPktType]
                                [known_l2uc_pkt] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrPktType]
                                [256];
                            map_array[bcmStatGroupModeAttrPktType]
                                [known_l2uc_pkt] = temp_count;
                            map_array[bcmStatGroupModeAttrPktType][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_L2UC_PKT) {
                        if (map_array[bcmStatGroupModeAttrPktType]
                                [unknown_l2uc_pkt] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrPktType]
                                [256];
                            map_array[bcmStatGroupModeAttrPktType]
                                [unknown_l2uc_pkt] = temp_count;
                            map_array[bcmStatGroupModeAttrPktType][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_L2BC_PKT) {
                        if (map_array[bcmStatGroupModeAttrPktType]
                                [l2bc_pkt] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrPktType]
                                [256];
                            map_array[bcmStatGroupModeAttrPktType]
                                [l2bc_pkt] = temp_count;
                            map_array[bcmStatGroupModeAttrPktType][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_L2MC_PKT) {
                        if (map_array[bcmStatGroupModeAttrPktType]
                                [known_l2mc_pkt] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrPktType]
                                [256];
                            map_array[bcmStatGroupModeAttrPktType]
                                [known_l2mc_pkt] = temp_count;
                            map_array[bcmStatGroupModeAttrPktType][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_L2MC_PKT) {
                        if (map_array[bcmStatGroupModeAttrPktType]
                                [unknown_l2mc_pkt] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrPktType]
                                [256];
                            map_array[bcmStatGroupModeAttrPktType]
                                [unknown_l2mc_pkt] = temp_count;
                            map_array[bcmStatGroupModeAttrPktType][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_L3UC_PKT) {
                        if (map_array[bcmStatGroupModeAttrPktType]
                                [known_l3uc_pkt] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrPktType]
                                [256];
                            map_array[bcmStatGroupModeAttrPktType]
                                [known_l3uc_pkt] = temp_count;
                            map_array[bcmStatGroupModeAttrPktType][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_L3UC_PKT) {
                        if (map_array[bcmStatGroupModeAttrPktType]
                                [unknown_l3uc_pkt] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrPktType]
                                [256];
                            map_array[bcmStatGroupModeAttrPktType]
                                [unknown_l3uc_pkt] = temp_count;
                            map_array[bcmStatGroupModeAttrPktType][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_IPMC_PKT) {
                        if (map_array[bcmStatGroupModeAttrPktType]
                                [known_ipmc_pkt] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrPktType]
                                [256];
                            map_array[bcmStatGroupModeAttrPktType]
                                [known_ipmc_pkt] = temp_count;
                            map_array[bcmStatGroupModeAttrPktType][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_IPMC_PKT) {
                        if (map_array[bcmStatGroupModeAttrPktType]
                                [unknown_ipmc_pkt] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrPktType]
                                [256];
                            map_array[bcmStatGroupModeAttrPktType]
                                [unknown_ipmc_pkt] = temp_count;
                            map_array[bcmStatGroupModeAttrPktType][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_L2_PKT) {
                        if (map_array[bcmStatGroupModeAttrPktType]
                                [known_mpls_l2_pkt] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrPktType]
                                [256];
                            map_array[bcmStatGroupModeAttrPktType]
                                [known_mpls_l2_pkt] = temp_count;
                            map_array[bcmStatGroupModeAttrPktType][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_L3_PKT) {
                        if (map_array[bcmStatGroupModeAttrPktType]
                                [known_mpls_l3_pkt] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrPktType]
                                [256];
                            map_array[bcmStatGroupModeAttrPktType]
                                [known_mpls_l3_pkt] = temp_count;
                            map_array[bcmStatGroupModeAttrPktType][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_PKT) {
                        if (map_array[bcmStatGroupModeAttrPktType]
                                [known_mpls_pkt] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrPktType]
                                [256];
                            map_array[bcmStatGroupModeAttrPktType]
                                [known_mpls_pkt] = temp_count;
                            map_array[bcmStatGroupModeAttrPktType][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_MPLS_PKT) {
                        if (map_array[bcmStatGroupModeAttrPktType]
                                [unknown_mpls_pkt] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrPktType]
                                [256];
                            map_array[bcmStatGroupModeAttrPktType]
                                [unknown_mpls_pkt] = temp_count;
                            map_array[bcmStatGroupModeAttrPktType][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_MULTICAST_PKT) {
                        if (map_array[bcmStatGroupModeAttrPktType]
                                [known_mpls_multicast_pkt] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrPktType]
                                [256];
                            map_array[bcmStatGroupModeAttrPktType]
                                [known_mpls_multicast_pkt] = temp_count;
                            map_array[bcmStatGroupModeAttrPktType][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_MIM_PKT) {
                        if (map_array[bcmStatGroupModeAttrPktType]
                                [known_mim_pkt] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrPktType]
                                [256];
                            map_array[bcmStatGroupModeAttrPktType]
                                [known_mim_pkt] = temp_count;
                            map_array[bcmStatGroupModeAttrPktType][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_MIM_PKT) {
                        if (map_array[bcmStatGroupModeAttrPktType]
                                [unknown_mim_pkt] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrPktType]
                                [256];
                            map_array[bcmStatGroupModeAttrPktType]
                                [unknown_mim_pkt] = temp_count;
                            map_array[bcmStatGroupModeAttrPktType][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_TRILL_PKT) {
                        if (map_array[bcmStatGroupModeAttrPktType]
                                [known_trill_pkt] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrPktType]
                                [256];
                            map_array[bcmStatGroupModeAttrPktType]
                                [known_trill_pkt] = temp_count;
                            map_array[bcmStatGroupModeAttrPktType][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_TRILL_PKT) {
                        if (map_array[bcmStatGroupModeAttrPktType]
                                [unknown_trill_pkt] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrPktType]
                                [256];
                            map_array[bcmStatGroupModeAttrPktType]
                                [unknown_trill_pkt] = temp_count;
                            map_array[bcmStatGroupModeAttrPktType][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_NIV_PKT) {
                        if (map_array[bcmStatGroupModeAttrPktType]
                                [known_niv_pkt] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrPktType]
                                [256];
                            map_array[bcmStatGroupModeAttrPktType]
                                [known_niv_pkt] = temp_count;
                            map_array[bcmStatGroupModeAttrPktType][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_NIV_PKT) {
                        if (map_array[bcmStatGroupModeAttrPktType]
                                [unknown_niv_pkt] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrPktType]
                                [256];
                            map_array[bcmStatGroupModeAttrPktType]
                                [unknown_niv_pkt] = temp_count;
                            map_array[bcmStatGroupModeAttrPktType][256] =
                                temp_count+1;
                        }
                    }
#if defined(BCM_TRIDENT2_SUPPORT)
                    if (SOC_IS_TD2_TT2(unit)) {
                        if (flex_attribute->combine_pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_KNOWN_L2GRE_PKT) {
                            if (map_array[bcmStatGroupModeAttrPktType]
                                    [known_l2gre_pkt] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrPktType]
                                    [256];
                                map_array[bcmStatGroupModeAttrPktType]
                                    [known_l2gre_pkt] = temp_count;
                                map_array[bcmStatGroupModeAttrPktType][256] =
                                    temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_KNOWN_VXLAN_PKT) {
                            if (map_array[bcmStatGroupModeAttrPktType]
                                    [known_fcoe_pkt] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrPktType]
                                    [256];
                                map_array[bcmStatGroupModeAttrPktType]
                                    [known_fcoe_pkt] = temp_count;
                                map_array[bcmStatGroupModeAttrPktType][256] =
                                    temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_KNOWN_FCOE_PKT) {
                            if (map_array[bcmStatGroupModeAttrPktType]
                                    [known_vxlan_pkt] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrPktType]
                                    [256];
                                map_array[bcmStatGroupModeAttrPktType]
                                    [known_vxlan_pkt] = temp_count;
                                map_array[bcmStatGroupModeAttrPktType][256] =
                                    temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_FCOE_PKT) {
                            if (map_array[bcmStatGroupModeAttrPktType]
                                    [unknown_fcoe_pkt] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrPktType]
                                    [256];
                                map_array[bcmStatGroupModeAttrPktType]
                                    [unknown_fcoe_pkt] = temp_count;
                                map_array[bcmStatGroupModeAttrPktType][256] =
                                    temp_count+1;
                            }
                        }
                    }
#endif
                        if (flex_attribute->combine_pkt_resolution_high_flags &
                                BCM_STAT_FLEX_PKT_TYPE_2_L2_UC_PKT) {
                            if (map_array[bcmStatGroupModeAttrPktType]
                                    [l2_uc_pkt] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrPktType]
                                    [256];
                                map_array[bcmStatGroupModeAttrPktType]
                                    [l2_uc_pkt] = temp_count;
                                map_array[bcmStatGroupModeAttrPktType][256] =
                                    temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_pkt_resolution_high_flags &
                                BCM_STAT_FLEX_PKT_TYPE_2_L2_NON_UC_PKT) {
                            if (map_array[bcmStatGroupModeAttrPktType]
                                    [l2_non_uc_pkt] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrPktType]
                                    [256];
                                map_array[bcmStatGroupModeAttrPktType]
                                    [l2_non_uc_pkt] = temp_count;
                                map_array[bcmStatGroupModeAttrPktType][256] =
                                    temp_count+1;
                            }
                        }
                }
            }
            if (flex_attribute->svp != 0) {
                if (map_array[bcmStatGroupModeAttrIngNetworkGroup] == NULL) {
                    map_array[bcmStatGroupModeAttrIngNetworkGroup] =
                        (uint8 *) sal_alloc(256+1,"map_array");

                    if (map_array[bcmStatGroupModeAttrIngNetworkGroup] == NULL) {
                        rv = BCM_E_MEMORY;
                        goto cleanup;
                    }

                    sal_memset(map_array[bcmStatGroupModeAttrIngNetworkGroup],
                            0xFF,256);
                    map_array[bcmStatGroupModeAttrIngNetworkGroup][256]=0;
                }
                if (direction == bcmStatFlexDirectionIngress) {
                    max_count= (1 << ing_pkt_attr_cmprsd_bits_g[unit].svp_type)-1;
                } else {
                    max_count= (1 << egr_pkt_attr_cmprsd_bits_g[unit].svp_type)-1;
                }
                for (loop_index=0; loop_index <= max_count ; loop_index++) {
                    if (BCM_STAT_FLEX_VALUE_GET(
                                flex_attribute->combine_value_array[bcmStatFlexAttrSvp],
                                loop_index)) {
                        if (map_array[bcmStatGroupModeAttrIngNetworkGroup]
                                [loop_index] == 0xFF) {
                            temp_count = map_array
                                [bcmStatGroupModeAttrIngNetworkGroup]
                                [256];
                            map_array[bcmStatGroupModeAttrIngNetworkGroup]
                                [loop_index] = temp_count;
                            map_array[bcmStatGroupModeAttrIngNetworkGroup]
                                [256] = temp_count + 1;
                        }
                    }
                }
            }
            if (flex_attribute->dvp != 0) {
                if (map_array[bcmStatGroupModeAttrEgrNetworkGroup] == NULL) {
                    map_array[bcmStatGroupModeAttrEgrNetworkGroup] =
                        (uint8 *) sal_alloc(256+1,"map_array");

                    if (map_array[bcmStatGroupModeAttrEgrNetworkGroup] == NULL) {
                        rv = BCM_E_MEMORY;
                        goto cleanup;
                    }

                    sal_memset(map_array[bcmStatGroupModeAttrEgrNetworkGroup],
                            0xFF,256);
                    map_array[bcmStatGroupModeAttrEgrNetworkGroup][256]=0;
                }
                max_count= (1 << egr_pkt_attr_cmprsd_bits_g[unit].dvp_type)-1;
                for (loop_index=0; loop_index <= max_count ; loop_index++) {
                    if (BCM_STAT_FLEX_VALUE_GET(
                                flex_attribute->combine_value_array[bcmStatFlexAttrDvp],
                                loop_index)) {
                        if (map_array[bcmStatGroupModeAttrEgrNetworkGroup]
                                [loop_index] == 0xFF) {
                            temp_count = map_array
                                [bcmStatGroupModeAttrEgrNetworkGroup]
                                [256];
                            map_array[bcmStatGroupModeAttrEgrNetworkGroup]
                                [loop_index] = temp_count;
                            map_array[bcmStatGroupModeAttrEgrNetworkGroup]
                                [256] = temp_count + 1;
                        }
                    }
                }
            }
            if (flex_attribute->drop != 0) {
                if (map_array[bcmStatGroupModeAttrDrop] == NULL) {
                    map_array[bcmStatGroupModeAttrDrop] =
                        (uint8 *) sal_alloc(256+1,"map_array");

                    if (map_array[bcmStatGroupModeAttrDrop] == NULL) {
                        rv = BCM_E_MEMORY;
                        goto cleanup;
                    }

                    sal_memset(map_array[bcmStatGroupModeAttrDrop],
                            0xFF,256);
                    map_array[bcmStatGroupModeAttrDrop][256]=0;
                }
                if (flex_attribute->combine_drop_flags & BCM_STAT_FLEX_DROP_DISABLE) {
                    if (map_array[bcmStatGroupModeAttrDrop][0] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrDrop][256];
                        map_array[bcmStatGroupModeAttrDrop][0] = temp_count;
                        map_array[bcmStatGroupModeAttrDrop][256]=temp_count + 1;
                    }
                }
                if (flex_attribute->combine_drop_flags & BCM_STAT_FLEX_DROP_ENABLE) {
                    if (map_array[bcmStatGroupModeAttrDrop][1] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrDrop][256];
                        map_array[bcmStatGroupModeAttrDrop][1] = temp_count;
                        map_array[bcmStatGroupModeAttrDrop][256]=temp_count + 1;
                    }
                }
            }
            /* END: PKT_RES_MAP*/
            if (flex_attribute->ip_pkt!= 0) {
                if (map_array[bcmStatGroupModeAttrPacketTypeIp] == NULL) {
                    map_array[bcmStatGroupModeAttrPacketTypeIp] =
                        (uint8 *) sal_alloc(256+1,"map_array");

                    if (map_array[bcmStatGroupModeAttrPacketTypeIp] == NULL) {
                        rv = BCM_E_MEMORY;
                        goto cleanup;
                    }

                    sal_memset(map_array[bcmStatGroupModeAttrPacketTypeIp],
                            0xFF,256);
                    map_array[bcmStatGroupModeAttrPacketTypeIp][256]=0;
                }
                if (flex_attribute->combine_ip_pkt_flags & BCM_STAT_FLEX_IP_PKT_DISABLE) {
                    if (map_array[bcmStatGroupModeAttrPacketTypeIp][0] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrPacketTypeIp][256];
                        map_array[bcmStatGroupModeAttrPacketTypeIp][0] = temp_count;
                        map_array[bcmStatGroupModeAttrPacketTypeIp][256]=temp_count + 1;
                    }
                }
                if (flex_attribute->combine_ip_pkt_flags & BCM_STAT_FLEX_IP_PKT_ENABLE) {
                    if (map_array[bcmStatGroupModeAttrPacketTypeIp][1] == 0xFF) {
                        temp_count = map_array[bcmStatGroupModeAttrPacketTypeIp][256];
                        map_array[bcmStatGroupModeAttrPacketTypeIp][1] = temp_count;
                        map_array[bcmStatGroupModeAttrPacketTypeIp][256]=temp_count + 1;
                    }
                }
            }
        } else {
            for (counter = 0;counter < flex_attribute->total_counters ; counter ++ ) {
#ifdef BCM_APACHE_SUPPORT
                if (soc_feature(unit,soc_feature_flex_ctr_mpls_3_label_count)) {
                    if (flex_attribute->cng_3 != 0) {
                        if (map_array[bcmStatGroupModeAttrColorMplsLabelThird] == NULL) {
                            map_array[bcmStatGroupModeAttrColorMplsLabelThird] =
                                (uint8 *) sal_alloc(256+1,"map_array");
                            sal_memset(map_array[bcmStatGroupModeAttrColorMplsLabelThird],
                                    0xFF,256);
                            map_array[bcmStatGroupModeAttrColorMplsLabelThird][256]=0;
                        }
                        temp_count = map_array[bcmStatGroupModeAttrColorMplsLabelThird][256];
                        if (flex_attribute->combine_attr_counter[counter].
                                pre_ifp_color_mpls_label3_flags & BCM_STAT_FLEX_COLOR_GREEN) {
                            if (map_array[bcmStatGroupModeAttrColorMplsLabelThird][0] == 0xFF) {
                                map_array[bcmStatGroupModeAttrColorMplsLabelThird][0] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pre_ifp_color_mpls_label3_flags & BCM_STAT_FLEX_COLOR_RED) {
                            if (map_array[bcmStatGroupModeAttrColorMplsLabelThird][1] == 0xFF) {
                                map_array[bcmStatGroupModeAttrColorMplsLabelThird][1] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pre_ifp_color_mpls_label3_flags & BCM_STAT_FLEX_COLOR_YELLOW) {
                            if (map_array[bcmStatGroupModeAttrColorMplsLabelThird][3] == 0xFF) {
                                map_array[bcmStatGroupModeAttrColorMplsLabelThird][3] = temp_count;
                                temp_count++;
                            }
                        }
                        map_array[bcmStatGroupModeAttrColorMplsLabelThird][256] = temp_count;
                    }
                    if (flex_attribute->phb_3 != 0) {
                        /*
                           shift_by_bits = 0;
                           */
                        if (map_array[bcmStatGroupModeAttrIntPriMplsLabelThird] == NULL) {
                            map_array[bcmStatGroupModeAttrIntPriMplsLabelThird] =
                                (uint8 *) sal_alloc(256+1,"map_array");
                            sal_memset(map_array[bcmStatGroupModeAttrIntPriMplsLabelThird],
                                    0xFF,256);
                            map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][256]=0;
                        }
                        temp_count = map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][256];
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI0) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][0] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][0] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI1) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][1] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][1] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI2) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][2] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][2] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI3) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][3] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][3] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI4) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][4] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][4] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI5) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][5] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][5] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI6) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][6] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][6] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI7) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][7] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][7] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI8) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][8] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][8] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI9) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][9] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][9] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI10) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][10] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][10] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI11) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][11] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][11] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI12) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][12] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][12] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI13) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][13] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][13] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI14) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][14] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][14] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI15) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][15] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][15] = temp_count;
                                temp_count++;
                            }
                        }
                        map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][256] = temp_count;
                    }
                    if (flex_attribute->cng_2 != 0) {
                        if (map_array[bcmStatGroupModeAttrColorMplsLabelSecond] == NULL) {
                            map_array[bcmStatGroupModeAttrColorMplsLabelSecond] =
                                (uint8 *) sal_alloc(256+1,"map_array");
                            sal_memset(map_array[bcmStatGroupModeAttrColorMplsLabelSecond],
                                    0xFF,256);
                            map_array[bcmStatGroupModeAttrColorMplsLabelSecond][256]=0;
                        }
                        temp_count = map_array[bcmStatGroupModeAttrColorMplsLabelSecond][256];
                        if (flex_attribute->combine_attr_counter[counter].
                                pre_ifp_color_mpls_label2_flags & BCM_STAT_FLEX_COLOR_GREEN) {
                            if (map_array[bcmStatGroupModeAttrColorMplsLabelSecond][0] == 0xFF) {
                                map_array[bcmStatGroupModeAttrColorMplsLabelSecond][0] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pre_ifp_color_mpls_label2_flags & BCM_STAT_FLEX_COLOR_RED) {
                            if (map_array[bcmStatGroupModeAttrColorMplsLabelSecond][1] == 0xFF) {
                                map_array[bcmStatGroupModeAttrColorMplsLabelSecond][1] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pre_ifp_color_mpls_label2_flags & BCM_STAT_FLEX_COLOR_YELLOW) {
                            if (map_array[bcmStatGroupModeAttrColorMplsLabelSecond][3] == 0xFF) {
                                map_array[bcmStatGroupModeAttrColorMplsLabelSecond][3] = temp_count;
                                temp_count++;
                            }
                        }
                        map_array[bcmStatGroupModeAttrColorMplsLabelSecond][256] = temp_count;
                    }
                    if (flex_attribute->phb_2 != 0) {
                        /*
                           shift_by_bits = 0;
                           */
                        if (map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond] == NULL) {
                            map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond] =
                                (uint8 *) sal_alloc(256+1,"map_array");
                            sal_memset(map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond],
                                    0xFF,256);
                            map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][256]=0;
                        }
                        temp_count = map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][256];
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI0) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][0] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][0] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI1) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][1] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][1] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI2) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][2] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][2] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI3) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][3] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][3] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI4) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][4] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][4] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI5) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][5] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][5] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI6) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][6] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][6] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI7) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][7] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][7] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI8) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][8] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][8] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI9) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][9] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][9] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI10) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][10] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][10] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI11) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][11] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][11] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI12) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][12] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][12] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI13) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][13] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][13] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI14) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][14] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][14] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI15) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][15] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][15] = temp_count;
                                temp_count++;
                            }
                        }
                        map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][256] = temp_count;
                    }
                    if (flex_attribute->cng_1 != 0) {
                        if (map_array[bcmStatGroupModeAttrColorMplsLabelFirst] == NULL) {
                            map_array[bcmStatGroupModeAttrColorMplsLabelFirst] =
                                (uint8 *) sal_alloc(256+1,"map_array");
                            sal_memset(map_array[bcmStatGroupModeAttrColorMplsLabelFirst],
                                    0xFF,256);
                            map_array[bcmStatGroupModeAttrColorMplsLabelFirst][256]=0;
                        }
                        temp_count = map_array[bcmStatGroupModeAttrColorMplsLabelFirst][256];
                        if (flex_attribute->combine_attr_counter[counter].
                                pre_ifp_color_mpls_label1_flags & BCM_STAT_FLEX_COLOR_GREEN) {
                            if (map_array[bcmStatGroupModeAttrColorMplsLabelFirst][0] == 0xFF) {
                                map_array[bcmStatGroupModeAttrColorMplsLabelFirst][0] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pre_ifp_color_mpls_label1_flags & BCM_STAT_FLEX_COLOR_RED) {
                            if (map_array[bcmStatGroupModeAttrColorMplsLabelFirst][1] == 0xFF) {
                                map_array[bcmStatGroupModeAttrColorMplsLabelFirst][1] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pre_ifp_color_mpls_label1_flags & BCM_STAT_FLEX_COLOR_YELLOW) {
                            if (map_array[bcmStatGroupModeAttrColorMplsLabelFirst][3] == 0xFF) {
                                map_array[bcmStatGroupModeAttrColorMplsLabelFirst][3] = temp_count;
                                temp_count++;
                            }
                        }
                        map_array[bcmStatGroupModeAttrColorMplsLabelFirst][256] = temp_count;
                    }
                    if (flex_attribute->phb_1 != 0) {
                        /*
                           shift_by_bits = 0;
                           */
                        if (map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst] == NULL) {
                            map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst] =
                                (uint8 *) sal_alloc(256+1,"map_array");
                            sal_memset(map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst],
                                    0xFF,256);
                            map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][256] = 0;
                        }
                        temp_count = map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][256];
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI0) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][0] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][0] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI1) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][1] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][1] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI2) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][2] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][2] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI3) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][3] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][3] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI4) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][4] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][4] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI5) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][5] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][5] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI6) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][6] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][6] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI7) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][7] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][7] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI8) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][8] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][8] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI9) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][9] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][9] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI10) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][10] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][10] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI11) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][11] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][11] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI12) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][12] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][12] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI13) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][13] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][13] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI14) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][14] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][14] = temp_count;
                                temp_count++;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI15) {
                            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][15] == 0xFF) {
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][15] = temp_count;
                                temp_count++;
                            }
                        }
                        map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][256] = temp_count;
                    }
                }
#endif

#if defined(BCM_TOMAHAWK_SUPPORT) || defined(BCM_TRIDENT3_SUPPORT)
                if (soc_feature(unit, soc_feature_flex_stat_egr_queue_congestion_marked)) {
                    if (flex_attribute->mmu_cos != 0) {
                        if (map_array[bcmStatGroupModeAttrCos] == NULL) {
                            map_array[bcmStatGroupModeAttrCos] =
                                (uint8 *) sal_alloc(256+1,"map_array");

                            if (map_array[bcmStatGroupModeAttrCos] == NULL) {
                                rv = BCM_E_MEMORY;
                                goto cleanup;
                            }

                            sal_memset(map_array[bcmStatGroupModeAttrCos],
                                    0xFF,256);
                            map_array[bcmStatGroupModeAttrCos][256] = 0;
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                mmu_cos_flags & BCM_STAT_FLEX_COS0) {
                            if (map_array[bcmStatGroupModeAttrCos][0] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrCos][256];
                                map_array[bcmStatGroupModeAttrCos][0] = temp_count;
                                map_array[bcmStatGroupModeAttrCos][256] = temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                mmu_cos_flags & BCM_STAT_FLEX_COS1) {
                            if (map_array[bcmStatGroupModeAttrCos][1] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrCos][256];
                                map_array[bcmStatGroupModeAttrCos][1] = temp_count;
                                map_array[bcmStatGroupModeAttrCos][256] = temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                mmu_cos_flags & BCM_STAT_FLEX_COS2) {
                            if (map_array[bcmStatGroupModeAttrCos][2] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrCos][256];
                                map_array[bcmStatGroupModeAttrCos][2] = temp_count;
                                map_array[bcmStatGroupModeAttrCos][256] = temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                mmu_cos_flags & BCM_STAT_FLEX_COS3) {
                            if (map_array[bcmStatGroupModeAttrCos][3] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrCos][256];
                                map_array[bcmStatGroupModeAttrCos][3] = temp_count;
                                map_array[bcmStatGroupModeAttrCos][256] = temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                mmu_cos_flags & BCM_STAT_FLEX_COS4) {
                            if (map_array[bcmStatGroupModeAttrCos][4] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrCos][256];
                                map_array[bcmStatGroupModeAttrCos][4] = temp_count;
                                map_array[bcmStatGroupModeAttrCos][256] = temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                mmu_cos_flags & BCM_STAT_FLEX_COS5) {
                            if (map_array[bcmStatGroupModeAttrCos][5] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrCos][256];
                                map_array[bcmStatGroupModeAttrCos][5] = temp_count;
                                map_array[bcmStatGroupModeAttrCos][256] = temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                mmu_cos_flags & BCM_STAT_FLEX_COS6) {
                            if (map_array[bcmStatGroupModeAttrCos][6] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrCos][256];
                                map_array[bcmStatGroupModeAttrCos][6] = temp_count;
                                map_array[bcmStatGroupModeAttrCos][256] = temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                mmu_cos_flags & BCM_STAT_FLEX_COS7) {
                            if (map_array[bcmStatGroupModeAttrCos][7] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrCos][256];
                                map_array[bcmStatGroupModeAttrCos][7] = temp_count;
                                map_array[bcmStatGroupModeAttrCos][256] = temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                mmu_cos_flags & BCM_STAT_FLEX_COS8) {
                            if (map_array[bcmStatGroupModeAttrCos][8] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrCos][256];
                                map_array[bcmStatGroupModeAttrCos][8] = temp_count;
                                map_array[bcmStatGroupModeAttrCos][256] = temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                mmu_cos_flags & BCM_STAT_FLEX_COS9) {
                            if (map_array[bcmStatGroupModeAttrCos][9] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrCos][256];
                                map_array[bcmStatGroupModeAttrCos][9] = temp_count;
                                map_array[bcmStatGroupModeAttrCos][256] = temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                mmu_cos_flags & BCM_STAT_FLEX_COS10) {
                            if (map_array[bcmStatGroupModeAttrCos][10] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrCos][256];
                                map_array[bcmStatGroupModeAttrCos][10] = temp_count;
                                map_array[bcmStatGroupModeAttrCos][256] = temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                mmu_cos_flags & BCM_STAT_FLEX_COS11) {
                            if (map_array[bcmStatGroupModeAttrCos][11] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrCos][256];
                                map_array[bcmStatGroupModeAttrCos][11] = temp_count;
                                map_array[bcmStatGroupModeAttrCos][256] = temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                mmu_cos_flags & BCM_STAT_FLEX_COS12) {
                            if (map_array[bcmStatGroupModeAttrCos][12] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrCos][256];
                                map_array[bcmStatGroupModeAttrCos][12] = temp_count;
                                map_array[bcmStatGroupModeAttrCos][256] = temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                mmu_cos_flags & BCM_STAT_FLEX_COS13) {
                            if (map_array[bcmStatGroupModeAttrCos][13] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrCos][256];
                                map_array[bcmStatGroupModeAttrCos][13] = temp_count;
                                map_array[bcmStatGroupModeAttrCos][256] = temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                mmu_cos_flags & BCM_STAT_FLEX_COS14) {
                            if (map_array[bcmStatGroupModeAttrCos][14] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrCos][256];
                                map_array[bcmStatGroupModeAttrCos][14] = temp_count;
                                map_array[bcmStatGroupModeAttrCos][256] = temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                mmu_cos_flags & BCM_STAT_FLEX_COS15) {
                            if (map_array[bcmStatGroupModeAttrCos][15] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrCos][256];
                                map_array[bcmStatGroupModeAttrCos][15] = temp_count;
                                map_array[bcmStatGroupModeAttrCos][256] = temp_count+1;
                            }
                        }
                    }

                    if (flex_attribute->uc_queueing != 0) {
                        if (map_array[bcmStatGroupModeAttrQueueType] == NULL) {
                            map_array[bcmStatGroupModeAttrQueueType] =
                                (uint8 *) sal_alloc(256+1,"map_array");

                            if (map_array[bcmStatGroupModeAttrQueueType] == NULL) {
                                rv = BCM_E_MEMORY;
                                goto cleanup;
                            }

                            sal_memset(map_array[bcmStatGroupModeAttrQueueType],
                                    0xFF,256);
                            map_array[bcmStatGroupModeAttrQueueType][256] = 0;
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                uc_queueing_flags & BCM_STAT_FLEX_UC_QUEUEING_DISABLE) {
                            if (map_array[bcmStatGroupModeAttrQueueType][0] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrQueueType][256];
                                map_array[bcmStatGroupModeAttrQueueType][0] = temp_count;
                                map_array[bcmStatGroupModeAttrQueueType][256] = temp_count + 1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                uc_queueing_flags & BCM_STAT_FLEX_UC_QUEUEING_ENABLE) {
                            if (map_array[bcmStatGroupModeAttrQueueType][1] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrQueueType][256];
                                map_array[bcmStatGroupModeAttrQueueType][1] = temp_count;
                                map_array[bcmStatGroupModeAttrQueueType][256] = temp_count + 1;
                            }
                        }
                    }

                    if (flex_attribute->congestion_marked != 0) {
                        if (map_array[bcmStatGroupModeAttrCongestionMarked] == NULL) {
                            map_array[bcmStatGroupModeAttrCongestionMarked] =
                                (uint8 *) sal_alloc(256+1,"map_array");

                            if (map_array[bcmStatGroupModeAttrCongestionMarked] == NULL) {
                                rv = BCM_E_MEMORY;
                                goto cleanup;
                            }

                            sal_memset(map_array[bcmStatGroupModeAttrCongestionMarked],
                                    0xFF,256);
                            map_array[bcmStatGroupModeAttrCongestionMarked][256]=0;
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                congestion_marked_flags & BCM_STAT_FLEX_CONGESTION_MARKED_DISABLE) {
                            if (map_array[bcmStatGroupModeAttrCongestionMarked][0] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrCongestionMarked][256];
                                map_array[bcmStatGroupModeAttrCongestionMarked][0] = temp_count;
                                map_array[bcmStatGroupModeAttrCongestionMarked][256] = temp_count + 1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                congestion_marked_flags & BCM_STAT_FLEX_CONGESTION_MARKED_ENABLE) {
                            if (map_array[bcmStatGroupModeAttrCongestionMarked][1] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrCongestionMarked][256];
                                map_array[bcmStatGroupModeAttrCongestionMarked][1] = temp_count;
                                map_array[bcmStatGroupModeAttrCongestionMarked][256] = temp_count + 1;
                            }
                        }
                    }
                }
#endif
                /* BEGIN: PRI_CNG_MAP */
                if (flex_attribute->pre_ifp_color != 0) {
                    if (map_array[bcmStatGroupModeAttrColor] == NULL) {
                        map_array[bcmStatGroupModeAttrColor] =
                            (uint8 *) sal_alloc(256+1,"map_array");
                        if (map_array[bcmStatGroupModeAttrColor] == NULL) {
                            rv = BCM_E_MEMORY;
                            goto cleanup;
                        }
                        sal_memset(map_array[bcmStatGroupModeAttrColor],
                                0xFF,256);
                        map_array[bcmStatGroupModeAttrColor][256]=0;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pre_ifp_color_flags & BCM_STAT_FLEX_COLOR_GREEN) {
                        if (map_array[bcmStatGroupModeAttrColor][0] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrColor][256];
                            map_array[bcmStatGroupModeAttrColor][0] = temp_count;
                            map_array[bcmStatGroupModeAttrColor][256]=temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pre_ifp_color_flags & BCM_STAT_FLEX_COLOR_RED) {
                        if (map_array[bcmStatGroupModeAttrColor][1] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrColor][256];
                            map_array[bcmStatGroupModeAttrColor][1] = temp_count;
                            map_array[bcmStatGroupModeAttrColor][256]=temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pre_ifp_color_flags & BCM_STAT_FLEX_COLOR_YELLOW) {
                        if (map_array[bcmStatGroupModeAttrColor][3] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrColor][256];
                            map_array[bcmStatGroupModeAttrColor][3] = temp_count;
                            map_array[bcmStatGroupModeAttrColor][256]=temp_count+1;
                        }
                    }
                }
                if (flex_attribute->ifp_color != 0) {
                    if (map_array[bcmStatGroupModeAttrFieldIngressColor] == NULL) {
                        map_array[bcmStatGroupModeAttrFieldIngressColor] =
                            (uint8 *) sal_alloc(256+1,"map_array");
                        if (map_array[bcmStatGroupModeAttrFieldIngressColor] == NULL) {
                            rv = BCM_E_MEMORY;
                            goto cleanup;
                        }
                        sal_memset(map_array[bcmStatGroupModeAttrFieldIngressColor],
                                0xFF,256);
                        map_array[bcmStatGroupModeAttrFieldIngressColor][256]=0;
                    }
                    /* Egress Not Possbile */
                    /*
                       shift_by_bits = ing_pkt_attr_cmprsd_bits_g[unit].int_pri;
                       */
                    if (flex_attribute->combine_attr_counter[counter].
                            ifp_color_flags & BCM_STAT_FLEX_COLOR_GREEN) {
                        if (map_array[bcmStatGroupModeAttrFieldIngressColor][0]
                                == 0xFF) {
                            temp_count = map_array
                                [bcmStatGroupModeAttrFieldIngressColor]
                                [256];
                            map_array[bcmStatGroupModeAttrFieldIngressColor][0] =
                                temp_count;
                            map_array[bcmStatGroupModeAttrFieldIngressColor][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            ifp_color_flags & BCM_STAT_FLEX_COLOR_RED) {
                        if (map_array[bcmStatGroupModeAttrFieldIngressColor][1]
                                == 0xFF) {
                            temp_count = map_array
                                [bcmStatGroupModeAttrFieldIngressColor]
                                [256];
                            map_array[bcmStatGroupModeAttrFieldIngressColor][1] =
                                temp_count;
                            map_array[bcmStatGroupModeAttrFieldIngressColor][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            ifp_color_flags & BCM_STAT_FLEX_COLOR_YELLOW) {
                        if (map_array[bcmStatGroupModeAttrFieldIngressColor][3]
                                == 0xFF) {
                            temp_count = map_array
                                [bcmStatGroupModeAttrFieldIngressColor]
                                [256];
                            map_array[bcmStatGroupModeAttrFieldIngressColor][3] =
                                temp_count;
                            map_array[bcmStatGroupModeAttrFieldIngressColor][256] =
                                temp_count+1;
                        }
                    }
                }
                if (flex_attribute->int_pri != 0) {
                    /*
                       shift_by_bits = 0;
                       */
                    if (map_array[bcmStatGroupModeAttrIntPri] == NULL) {
                        map_array[bcmStatGroupModeAttrIntPri] =
                            (uint8 *) sal_alloc(256+1,"map_array");

                        if (map_array[bcmStatGroupModeAttrIntPri] == NULL) {
                            rv = BCM_E_MEMORY;
                            goto cleanup;
                        }

                        sal_memset(map_array[bcmStatGroupModeAttrIntPri],
                                0xFF,256);
                        map_array[bcmStatGroupModeAttrIntPri][256]=0;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_flags & BCM_STAT_FLEX_PRI0) {
                        if (map_array[bcmStatGroupModeAttrIntPri][0] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrIntPri][256];
                            map_array[bcmStatGroupModeAttrIntPri][0] = temp_count;
                            map_array[bcmStatGroupModeAttrIntPri][256]=temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_flags & BCM_STAT_FLEX_PRI1) {
                        if (map_array[bcmStatGroupModeAttrIntPri][1] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrIntPri][256];
                            map_array[bcmStatGroupModeAttrIntPri][1] = temp_count;
                            map_array[bcmStatGroupModeAttrIntPri][256]=temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_flags & BCM_STAT_FLEX_PRI2) {
                        if (map_array[bcmStatGroupModeAttrIntPri][2] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrIntPri][256];
                            map_array[bcmStatGroupModeAttrIntPri][2] = temp_count;
                            map_array[bcmStatGroupModeAttrIntPri][256]=temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_flags & BCM_STAT_FLEX_PRI3) {
                        if (map_array[bcmStatGroupModeAttrIntPri][3] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrIntPri][256];
                            map_array[bcmStatGroupModeAttrIntPri][3] = temp_count;
                            map_array[bcmStatGroupModeAttrIntPri][256]=temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_flags & BCM_STAT_FLEX_PRI4) {
                        if (map_array[bcmStatGroupModeAttrIntPri][4] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrIntPri][256];
                            map_array[bcmStatGroupModeAttrIntPri][4] = temp_count;
                            map_array[bcmStatGroupModeAttrIntPri][256]=temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_flags & BCM_STAT_FLEX_PRI5) {
                        if (map_array[bcmStatGroupModeAttrIntPri][5] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrIntPri][256];
                            map_array[bcmStatGroupModeAttrIntPri][5] = temp_count;
                            map_array[bcmStatGroupModeAttrIntPri][256]=temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_flags & BCM_STAT_FLEX_PRI6) {
                        if (map_array[bcmStatGroupModeAttrIntPri][6] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrIntPri][256];
                            map_array[bcmStatGroupModeAttrIntPri][6] = temp_count;
                            map_array[bcmStatGroupModeAttrIntPri][256]=temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_flags & BCM_STAT_FLEX_PRI7) {
                        if (map_array[bcmStatGroupModeAttrIntPri][7] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrIntPri][256];
                            map_array[bcmStatGroupModeAttrIntPri][7] = temp_count;
                            map_array[bcmStatGroupModeAttrIntPri][256]=temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_flags & BCM_STAT_FLEX_PRI8) {
                        if (map_array[bcmStatGroupModeAttrIntPri][8] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrIntPri][256];
                            map_array[bcmStatGroupModeAttrIntPri][8] = temp_count;
                            map_array[bcmStatGroupModeAttrIntPri][256]=temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_flags & BCM_STAT_FLEX_PRI9) {
                        if (map_array[bcmStatGroupModeAttrIntPri][9] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrIntPri][256];
                            map_array[bcmStatGroupModeAttrIntPri][9] = temp_count;
                            map_array[bcmStatGroupModeAttrIntPri][256]=temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_flags & BCM_STAT_FLEX_PRI10) {
                        if (map_array[bcmStatGroupModeAttrIntPri][10] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrIntPri][256];
                            map_array[bcmStatGroupModeAttrIntPri][10] = temp_count;
                            map_array[bcmStatGroupModeAttrIntPri][256]=temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_flags & BCM_STAT_FLEX_PRI11) {
                        if (map_array[bcmStatGroupModeAttrIntPri][11] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrIntPri][256];
                            map_array[bcmStatGroupModeAttrIntPri][11] = temp_count;
                            map_array[bcmStatGroupModeAttrIntPri][256]=temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_flags & BCM_STAT_FLEX_PRI12) {
                        if (map_array[bcmStatGroupModeAttrIntPri][12] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrIntPri][256];
                            map_array[bcmStatGroupModeAttrIntPri][12] = temp_count;
                            map_array[bcmStatGroupModeAttrIntPri][256]=temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_flags & BCM_STAT_FLEX_PRI13) {
                        if (map_array[bcmStatGroupModeAttrIntPri][13] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrIntPri][256];
                            map_array[bcmStatGroupModeAttrIntPri][13] = temp_count;
                            map_array[bcmStatGroupModeAttrIntPri][256]=temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_flags & BCM_STAT_FLEX_PRI14) {
                        if (map_array[bcmStatGroupModeAttrIntPri][14] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrIntPri][256];
                            map_array[bcmStatGroupModeAttrIntPri][14] = temp_count;
                            map_array[bcmStatGroupModeAttrIntPri][256]=temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_flags & BCM_STAT_FLEX_PRI15) {
                        if (map_array[bcmStatGroupModeAttrIntPri][15] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrIntPri][256];
                            map_array[bcmStatGroupModeAttrIntPri][15] = temp_count;
                            map_array[bcmStatGroupModeAttrIntPri][256]=temp_count+1;
                        }
                    }
                }
                /* END: PRI_CNG_MAP */
                /* BEGIN: PKT_PRI_MAP*/
                if (flex_attribute->vlan_format != 0) {
                    if (map_array[bcmStatGroupModeAttrVlan] == NULL) {
                        map_array[bcmStatGroupModeAttrVlan] =
                            (uint8 *) sal_alloc(256+1,"map_array");

                        if (map_array[bcmStatGroupModeAttrVlan] == NULL) {
                            rv = BCM_E_MEMORY;
                            goto cleanup;
                        }

                        sal_memset(map_array[bcmStatGroupModeAttrVlan],
                                0xFF,256);
                        map_array[bcmStatGroupModeAttrVlan][256]=0;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            vlan_format_flags & BCM_STAT_FLEX_VLAN_FORMAT_UNTAGGED) {
                        if (map_array[bcmStatGroupModeAttrVlan][0] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrVlan][256];
                            map_array[bcmStatGroupModeAttrVlan][0] = temp_count;
                            map_array[bcmStatGroupModeAttrVlan][256]=temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            vlan_format_flags & BCM_STAT_FLEX_VLAN_FORMAT_INNER) {
                        if (map_array[bcmStatGroupModeAttrVlan][1] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrVlan][256];
                            map_array[bcmStatGroupModeAttrVlan][1] = temp_count;
                            map_array[bcmStatGroupModeAttrVlan][256]=temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            vlan_format_flags & BCM_STAT_FLEX_VLAN_FORMAT_OUTER) {
                        if (map_array[bcmStatGroupModeAttrVlan][2] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrVlan][256];
                            map_array[bcmStatGroupModeAttrVlan][2] = temp_count;
                            map_array[bcmStatGroupModeAttrVlan][256]=temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            vlan_format_flags & BCM_STAT_FLEX_VLAN_FORMAT_BOTH) {
                        if (map_array[bcmStatGroupModeAttrVlan][3] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrVlan][256];
                            map_array[bcmStatGroupModeAttrVlan][3] = temp_count;
                            map_array[bcmStatGroupModeAttrVlan][256]=temp_count+1;
                        }
                    }
                }
                if (flex_attribute->outer_dot1p != 0) {
                    if (map_array[bcmStatGroupModeAttrOuterPri] == NULL) {
                        map_array[bcmStatGroupModeAttrOuterPri] =
                            (uint8 *) sal_alloc(256+1,"map_array");

                        if (map_array[bcmStatGroupModeAttrOuterPri] == NULL) {
                            rv = BCM_E_MEMORY;
                            goto cleanup;
                        }

                        sal_memset(map_array[bcmStatGroupModeAttrOuterPri],
                                0xFF,256);
                        map_array[bcmStatGroupModeAttrOuterPri][256]=0;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            outer_dot1p_flags & BCM_STAT_FLEX_PRI0) {
                        if (map_array[bcmStatGroupModeAttrOuterPri][0] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrOuterPri]
                                [256];
                            map_array[bcmStatGroupModeAttrOuterPri][0] =
                                temp_count;
                            map_array[bcmStatGroupModeAttrOuterPri][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            outer_dot1p_flags & BCM_STAT_FLEX_PRI1) {
                        if (map_array[bcmStatGroupModeAttrOuterPri][1] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrOuterPri]
                                [256];
                            map_array[bcmStatGroupModeAttrOuterPri][1] =
                                temp_count;
                            map_array[bcmStatGroupModeAttrOuterPri][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            outer_dot1p_flags & BCM_STAT_FLEX_PRI2) {
                        if (map_array[bcmStatGroupModeAttrOuterPri][2] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrOuterPri]
                                [256];
                            map_array[bcmStatGroupModeAttrOuterPri][2] =
                                temp_count;
                            map_array[bcmStatGroupModeAttrOuterPri][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            outer_dot1p_flags & BCM_STAT_FLEX_PRI3) {
                        if (map_array[bcmStatGroupModeAttrOuterPri][3] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrOuterPri]
                                [256];
                            map_array[bcmStatGroupModeAttrOuterPri][3] =
                                temp_count;
                            map_array[bcmStatGroupModeAttrOuterPri][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            outer_dot1p_flags & BCM_STAT_FLEX_PRI4) {
                        if (map_array[bcmStatGroupModeAttrOuterPri][4] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrOuterPri]
                                [256];
                            map_array[bcmStatGroupModeAttrOuterPri][4] =
                                temp_count;
                            map_array[bcmStatGroupModeAttrOuterPri][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            outer_dot1p_flags & BCM_STAT_FLEX_PRI5) {
                        if (map_array[bcmStatGroupModeAttrOuterPri][5] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrOuterPri]
                                [256];
                            map_array[bcmStatGroupModeAttrOuterPri][5] =
                                temp_count;
                            map_array[bcmStatGroupModeAttrOuterPri][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            outer_dot1p_flags & BCM_STAT_FLEX_PRI6) {
                        if (map_array[bcmStatGroupModeAttrOuterPri][6] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrOuterPri]
                                [256];
                            map_array[bcmStatGroupModeAttrOuterPri][6] =
                                temp_count;
                            map_array[bcmStatGroupModeAttrOuterPri][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            outer_dot1p_flags & BCM_STAT_FLEX_PRI7) {
                        if (map_array[bcmStatGroupModeAttrOuterPri][7] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrOuterPri]
                                [256];
                            map_array[bcmStatGroupModeAttrOuterPri][7] =
                                temp_count;
                            map_array[bcmStatGroupModeAttrOuterPri][256] =
                                temp_count+1;
                        }
                    }
                }
                if (flex_attribute->inner_dot1p != 0) {
                    if (map_array[bcmStatGroupModeAttrInnerPri] == NULL) {
                        map_array[bcmStatGroupModeAttrInnerPri] =
                            (uint8 *) sal_alloc(256+1,"map_array");

                        if (map_array[bcmStatGroupModeAttrInnerPri] == NULL) {
                            rv = BCM_E_MEMORY;
                            goto cleanup;
                        }

                        sal_memset(map_array[bcmStatGroupModeAttrInnerPri],
                                0xFF,256);
                        map_array[bcmStatGroupModeAttrInnerPri][256]=0;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            inner_dot1p_flags & BCM_STAT_FLEX_PRI0) {
                        if (map_array[bcmStatGroupModeAttrInnerPri][0] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrInnerPri]
                                [256];
                            map_array[bcmStatGroupModeAttrInnerPri][0] =
                                temp_count;
                            map_array[bcmStatGroupModeAttrInnerPri][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            inner_dot1p_flags & BCM_STAT_FLEX_PRI1) {
                        if (map_array[bcmStatGroupModeAttrInnerPri][1] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrInnerPri]
                                [256];
                            map_array[bcmStatGroupModeAttrInnerPri][1] =
                                temp_count;
                            map_array[bcmStatGroupModeAttrInnerPri][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            inner_dot1p_flags & BCM_STAT_FLEX_PRI2) {
                        if (map_array[bcmStatGroupModeAttrInnerPri][2] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrInnerPri]
                                [256];
                            map_array[bcmStatGroupModeAttrInnerPri][2] =
                                temp_count;
                            map_array[bcmStatGroupModeAttrInnerPri][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            inner_dot1p_flags & BCM_STAT_FLEX_PRI3) {
                        if (map_array[bcmStatGroupModeAttrInnerPri][3] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrInnerPri]
                                [256];
                            map_array[bcmStatGroupModeAttrInnerPri][3] =
                                temp_count;
                            map_array[bcmStatGroupModeAttrInnerPri][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            inner_dot1p_flags & BCM_STAT_FLEX_PRI4) {
                        if (map_array[bcmStatGroupModeAttrInnerPri][4] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrInnerPri]
                                [256];
                            map_array[bcmStatGroupModeAttrInnerPri][4] =
                                temp_count;
                            map_array[bcmStatGroupModeAttrInnerPri][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            inner_dot1p_flags & BCM_STAT_FLEX_PRI5) {
                        if (map_array[bcmStatGroupModeAttrInnerPri][5] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrInnerPri]
                                [256];
                            map_array[bcmStatGroupModeAttrInnerPri][5] =
                                temp_count;
                            map_array[bcmStatGroupModeAttrInnerPri][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            inner_dot1p_flags & BCM_STAT_FLEX_PRI6) {
                        if (map_array[bcmStatGroupModeAttrInnerPri][6] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrInnerPri]
                                [256];
                            map_array[bcmStatGroupModeAttrInnerPri][6] =
                                temp_count;
                            map_array[bcmStatGroupModeAttrInnerPri][256] =
                                temp_count+1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            inner_dot1p_flags & BCM_STAT_FLEX_PRI7) {
                        if (map_array[bcmStatGroupModeAttrInnerPri][7] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrInnerPri]
                                [256];
                            map_array[bcmStatGroupModeAttrInnerPri][7] =
                                temp_count;
                            map_array[bcmStatGroupModeAttrInnerPri][256] =
                                temp_count+1;
                        }
                    }
                }
                /* END: PKT_PRI_MAP*/
                /* BEGIN: PORT_MAP*/
                if ((flex_attribute->port != 0) || (flex_attribute->subport != 0)) {
                    if (map_array[bcmStatGroupModeAttrPort] == NULL) {
#ifdef BCM_CHANNELIZED_SWITCHING_SUPPORT
                        if (soc_feature(unit, soc_feature_channelized_switching)) {
                            port_map_array_size = 512;
                        } else
#endif /* BCM_CHANNELIZED_SWITCHING_SUPPORT */
                        {
                            port_map_array_size = 256;
                        }

                        map_array[bcmStatGroupModeAttrPort] =
                            (uint8 *) sal_alloc(port_map_array_size+1,"map_array");

                        if (map_array[bcmStatGroupModeAttrPort] == NULL) {
                            rv = BCM_E_MEMORY;
                            goto cleanup;
                        }

                        sal_memset(map_array[bcmStatGroupModeAttrPort],
                                0xFF,port_map_array_size);
                        map_array[bcmStatGroupModeAttrPort][port_map_array_size]=0;
                    }
                    if (direction == bcmStatFlexDirectionIngress) {
                        max_count= (1 << ing_pkt_attr_cmprsd_bits_g[unit].ing_port) - 1;
                    } else {
                        max_count= (1 << egr_pkt_attr_cmprsd_bits_g[unit].egr_port) - 1;
                    }
                    for (loop_index=0; loop_index <= max_count ; loop_index++) {
                        if (BCM_STAT_FLEX_VALUE_GET(
                                    flex_attribute->combine_attr_counter[counter].
                                    value_array[bcmStatFlexAttrPort],loop_index)) {
                            if (map_array[bcmStatGroupModeAttrPort][loop_index]
                                    == 0xFF) {
#if defined(BCM_TRIDENT3_SUPPORT) || defined(BCM_APACHE_SUPPORT)
                                if (soc_feature(unit,
                                            soc_feature_flex_stat_port_group_support)) {
                                    for (inner_loop_index = 0;
                                            inner_loop_index <= max_count ;
                                            inner_loop_index++) {
                                        if (SHR_BITGET(stat_port_grp[unit].
                                                    port_grp_bmap[loop_index].pbits, inner_loop_index)) {
                                            map_array[bcmStatGroupModeAttrPort][inner_loop_index]
                                                = loop_index;
                                        }
                                    }
                                    map_array[bcmStatGroupModeAttrPort][port_map_array_size] = loop_index + 1;
                                } else
#endif
                                {
                                    temp_count = map_array[bcmStatGroupModeAttrPort]
                                        [port_map_array_size];
                                    map_array[bcmStatGroupModeAttrPort][loop_index] =
                                        temp_count;
                                    map_array[bcmStatGroupModeAttrPort][port_map_array_size] =
                                        temp_count+1;
                                }
                            }
                        }
                    }
                }
                /* END: PORT_MAP*/
                /* BEGIN: TOS_MAP*/
                if (flex_attribute->tos_dscp != 0) {
                    if (map_array[bcmStatGroupModeAttrTosDscp] == NULL) {
                        map_array[bcmStatGroupModeAttrTosDscp] =
                            (uint8 *) sal_alloc(256+1,"map_array");

                        if (map_array[bcmStatGroupModeAttrTosDscp] == NULL) {
                            rv = BCM_E_MEMORY;
                            goto cleanup;
                        }

                        sal_memset(map_array[bcmStatGroupModeAttrTosDscp],
                                0xFF,256);
                        map_array[bcmStatGroupModeAttrTosDscp][256]=0;
                    }
                    if (direction == bcmStatFlexDirectionIngress) {
                        max_count= (1 << ing_pkt_attr_cmprsd_bits_g[unit].tos_dscp) - 1;
                    } else {
                        max_count= (1 << egr_pkt_attr_cmprsd_bits_g[unit].tos_dscp) - 1;
                    }
                    for (loop_index=0; loop_index <= max_count ; loop_index++) {
                        if (BCM_STAT_FLEX_VALUE_GET(
                                    flex_attribute->combine_attr_counter[counter].
                                    value_array[bcmStatFlexAttrTosDscp],loop_index)) {
                            if (map_array[bcmStatGroupModeAttrTosDscp][loop_index]
                                    == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrTosDscp]
                                    [256];
                                map_array[bcmStatGroupModeAttrTosDscp][loop_index] =
                                    temp_count;
                                map_array[bcmStatGroupModeAttrTosDscp][256] =
                                    temp_count+1;
                            }
                        }
                    }
                }
                if (flex_attribute->tos_ecn != 0) {
                    if (map_array[bcmStatGroupModeAttrTosEcn] == NULL) {
                        map_array[bcmStatGroupModeAttrTosEcn] =
                            (uint8 *) sal_alloc(256+1,"map_array");

                        if (map_array[bcmStatGroupModeAttrTosEcn] == NULL) {
                            rv = BCM_E_MEMORY;
                            goto cleanup;
                        }

                        sal_memset(map_array[bcmStatGroupModeAttrTosEcn],
                                0xFF,256);
                        map_array[bcmStatGroupModeAttrTosEcn][256]=0;
                    }
                    if (direction == bcmStatFlexDirectionIngress) {
                        max_count= (1 << ing_pkt_attr_cmprsd_bits_g[unit].tos_ecn) - 1;
                    } else {
                        max_count= (1 << egr_pkt_attr_cmprsd_bits_g[unit].tos_ecn) - 1;
                    }
                    for (loop_index=0; loop_index <= max_count ; loop_index++) {
                        if (BCM_STAT_FLEX_VALUE_GET(
                                    flex_attribute->combine_attr_counter[counter].
                                    value_array[bcmStatFlexAttrTosEcn],loop_index)) {
                            if (map_array[bcmStatGroupModeAttrTosEcn][loop_index]
                                    == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrTosEcn]
                                    [256];
                                map_array[bcmStatGroupModeAttrTosEcn][loop_index] =
                                    temp_count;
                                map_array[bcmStatGroupModeAttrTosEcn][256] =
                                    temp_count+1;
                            }
                        }
                    }
                }
                /* END: TOS_MAP*/
                /* BEGIN: PKT_RES_MAP*/
                if (flex_attribute->pkt_resolution != 0) {
#ifdef BCM_KATANA2_SUPPORT
                    if soc_feature(unit, soc_feature_flex_stat_attributes_class) {
                        if (map_array[bcmStatGroupModeAttrClassType] == NULL) {
                            map_array[bcmStatGroupModeAttrClassType] =
                                (uint8 *) sal_alloc(256+1,"map_array");

                            if (map_array[bcmStatGroupModeAttrClassType] == NULL) {
                                rv = BCM_E_MEMORY;
                                goto cleanup;
                            }

                            sal_memset(map_array[bcmStatGroupModeAttrClassType],
                                    0xFF,256);
                            map_array[bcmStatGroupModeAttrClassType][256]=0;
                        }
                        for (i = 0; i < BCM_STAT_FLEX_BIT_ARRAY_SIZE; i++) {
                            if (BCM_STAT_FLEX_VALUE_GET(
                                        flex_attribute->combine_attr_counter[counter].value_array[bcmStatFlexAttrComb], i)) {
                                if (!combine_attr_per_mode[bcmStatFlexAttrComb][i]) {
                                    combine_attr_per_mode[bcmStatFlexAttrComb][i] =
                                        1;
                                    hw_class_id++;

                                }
                            }
                        }

                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_PKT) {
                            if (map_array[bcmStatGroupModeAttrClassType]
                                    [unknown_pkt] == 0xFF) {
                                map_array[bcmStatGroupModeAttrClassType]
                                    [unknown_pkt] = hw_class_id;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_CONTROL_PKT) {
                            if (map_array[bcmStatGroupModeAttrClassType]
                                    [control_pkt] == 0xFF) {
                                map_array[bcmStatGroupModeAttrClassType]
                                    [control_pkt] = hw_class_id;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_OAM_PKT) {
                            if (map_array[bcmStatGroupModeAttrClassType]
                                    [oam_pkt] == 0xFF) {
                                map_array[bcmStatGroupModeAttrClassType]
                                    [oam_pkt] = hw_class_id;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_BFD_PKT) {
                            if (map_array[bcmStatGroupModeAttrClassType]
                                    [bfd_pkt] == 0xFF) {
                                map_array[bcmStatGroupModeAttrClassType]
                                    [bfd_pkt] = hw_class_id;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_BPDU_PKT) {
                            if (map_array[bcmStatGroupModeAttrClassType]
                                    [bpdu_pkt] == 0xFF) {
                                map_array[bcmStatGroupModeAttrClassType]
                                    [bpdu_pkt] = hw_class_id;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_ICNM_PKT) {
                            if (map_array[bcmStatGroupModeAttrClassType]
                                    [icnm_pkt] == 0xFF) {
                                map_array[bcmStatGroupModeAttrClassType]
                                    [icnm_pkt] = hw_class_id;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_PKT_IS_1588) {
                            if (map_array[bcmStatGroupModeAttrClassType]
                                    [_1588_pkt] == 0xFF) {
                                map_array[bcmStatGroupModeAttrClassType]
                                    [_1588_pkt] = hw_class_id;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_BFD_PKT) {
                            if (map_array[bcmStatGroupModeAttrClassType]
                                    [bfd_pkt] == 0xFF) {
                                map_array[bcmStatGroupModeAttrClassType]
                                    [bfd_pkt] = hw_class_id;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_KNOWN_L2UC_PKT) {
                            if (map_array[bcmStatGroupModeAttrClassType]
                                    [known_l2uc_pkt] == 0xFF) {
                                map_array[bcmStatGroupModeAttrClassType]
                                    [known_l2uc_pkt] = hw_class_id;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_L2UC_PKT) {
                            if (map_array[bcmStatGroupModeAttrClassType]
                                    [unknown_l2uc_pkt] == 0xFF) {
                                map_array[bcmStatGroupModeAttrClassType]
                                    [unknown_l2uc_pkt] = hw_class_id;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_L2BC_PKT) {
                            if (map_array[bcmStatGroupModeAttrClassType]
                                    [l2bc_pkt] == 0xFF) {
                                map_array[bcmStatGroupModeAttrClassType]
                                    [l2bc_pkt] = hw_class_id;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_KNOWN_L2MC_PKT) {
                            if (map_array[bcmStatGroupModeAttrClassType]
                                    [known_l2mc_pkt] == 0xFF) {
                                map_array[bcmStatGroupModeAttrClassType]
                                    [known_l2mc_pkt] = hw_class_id;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_L2MC_PKT) {
                            if (map_array[bcmStatGroupModeAttrClassType]
                                    [unknown_l2mc_pkt] == 0xFF) {
                                map_array[bcmStatGroupModeAttrClassType]
                                    [unknown_l2mc_pkt] = hw_class_id;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_KNOWN_L3UC_PKT) {
                            if (map_array[bcmStatGroupModeAttrClassType]
                                    [known_l3uc_pkt] == 0xFF) {
                                map_array[bcmStatGroupModeAttrClassType]
                                    [known_l3uc_pkt] = hw_class_id;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_L3UC_PKT) {
                            if (map_array[bcmStatGroupModeAttrClassType]
                                    [unknown_l3uc_pkt] == 0xFF) {
                                map_array[bcmStatGroupModeAttrClassType]
                                    [unknown_l3uc_pkt] = hw_class_id;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_KNOWN_IPMC_PKT) {
                            if (map_array[bcmStatGroupModeAttrClassType]
                                    [known_ipmc_pkt] == 0xFF) {
                                map_array[bcmStatGroupModeAttrClassType]
                                    [known_ipmc_pkt] = hw_class_id;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_IPMC_PKT) {
                            if (map_array[bcmStatGroupModeAttrClassType]
                                    [unknown_ipmc_pkt] == 0xFF) {
                                map_array[bcmStatGroupModeAttrClassType]
                                    [unknown_ipmc_pkt] = hw_class_id;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_L2_PKT) {
                            if (map_array[bcmStatGroupModeAttrClassType]
                                    [known_mpls_l2_pkt] == 0xFF) {
                                map_array[bcmStatGroupModeAttrClassType]
                                    [known_mpls_l2_pkt] = hw_class_id;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_L3_PKT) {
                            if (map_array[bcmStatGroupModeAttrClassType]
                                    [known_mpls_l3_pkt] == 0xFF) {
                                map_array[bcmStatGroupModeAttrClassType]
                                    [known_mpls_l3_pkt] = hw_class_id;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_PKT) {
                            if (map_array[bcmStatGroupModeAttrClassType]
                                    [known_mpls_pkt] == 0xFF) {
                                map_array[bcmStatGroupModeAttrClassType]
                                    [known_mpls_pkt] = hw_class_id;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_MPLS_PKT) {
                            if (map_array[bcmStatGroupModeAttrClassType]
                                    [unknown_mpls_pkt] == 0xFF) {
                                map_array[bcmStatGroupModeAttrClassType]
                                    [unknown_mpls_pkt] = hw_class_id;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_MULTICAST_PKT) {
                            if (map_array[bcmStatGroupModeAttrClassType]
                                    [known_mpls_multicast_pkt] == 0xFF) {
                                map_array[bcmStatGroupModeAttrClassType]
                                    [known_mpls_multicast_pkt] = hw_class_id;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_KNOWN_MIM_PKT) {
                            if (map_array[bcmStatGroupModeAttrClassType]
                                    [known_mim_pkt] == 0xFF) {
                                map_array[bcmStatGroupModeAttrClassType]
                                    [known_mim_pkt] = hw_class_id;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_MIM_PKT) {
                            if (map_array[bcmStatGroupModeAttrClassType]
                                    [unknown_mim_pkt] == 0xFF) {
                                map_array[bcmStatGroupModeAttrClassType]
                                    [unknown_mim_pkt] = hw_class_id;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_KNOWN_TRILL_PKT) {
                            if (map_array[bcmStatGroupModeAttrClassType]
                                    [known_trill_pkt] == 0xFF) {
                                map_array[bcmStatGroupModeAttrClassType]
                                    [known_trill_pkt] = hw_class_id;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_TRILL_PKT) {
                            if (map_array[bcmStatGroupModeAttrClassType]
                                    [unknown_trill_pkt] == 0xFF) {
                                map_array[bcmStatGroupModeAttrClassType]
                                    [unknown_trill_pkt] = hw_class_id;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_KNOWN_NIV_PKT) {
                            if (map_array[bcmStatGroupModeAttrClassType]
                                    [known_niv_pkt] == 0xFF) {
                                map_array[bcmStatGroupModeAttrClassType]
                                    [known_niv_pkt] = hw_class_id;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_NIV_PKT) {
                            if (map_array[bcmStatGroupModeAttrClassType]
                                    [unknown_niv_pkt] == 0xFF) {
                                map_array[bcmStatGroupModeAttrClassType]
                                    [unknown_niv_pkt] = hw_class_id;
                            }
                        }
                        map_array[bcmStatGroupModeAttrClassType][256] = hw_class_id;
                    } else
#endif
                    {
                        if (map_array[bcmStatGroupModeAttrPktType] == NULL) {
                            map_array[bcmStatGroupModeAttrPktType] =
                                (uint8 *) sal_alloc(256+1,"map_array");

                            if (map_array[bcmStatGroupModeAttrPktType] == NULL) {
                                rv = BCM_E_MEMORY;
                                goto cleanup;
                            }

                            sal_memset(map_array[bcmStatGroupModeAttrPktType],
                                    0xFF,256);
                            map_array[bcmStatGroupModeAttrPktType][256]=0;
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_PKT) {
                            if (map_array[bcmStatGroupModeAttrPktType]
                                    [unknown_pkt] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrPktType]
                                    [256];
                                map_array[bcmStatGroupModeAttrPktType]
                                    [unknown_pkt] = temp_count;
                                map_array[bcmStatGroupModeAttrPktType][256] =
                                    temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_CONTROL_PKT) {
                            if (map_array[bcmStatGroupModeAttrPktType]
                                    [control_pkt] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrPktType]
                                    [256];
                                map_array[bcmStatGroupModeAttrPktType]
                                    [control_pkt] = temp_count;
                                map_array[bcmStatGroupModeAttrPktType][256] =
                                    temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_OAM_PKT) {
                            if (map_array[bcmStatGroupModeAttrPktType]
                                    [oam_pkt] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrPktType]
                                    [256];
                                map_array[bcmStatGroupModeAttrPktType]
                                    [oam_pkt] = temp_count;
                                map_array[bcmStatGroupModeAttrPktType][256] =
                                    temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_BFD_PKT) {
                            if (map_array[bcmStatGroupModeAttrPktType]
                                    [bfd_pkt] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrPktType]
                                    [256];
                                map_array[bcmStatGroupModeAttrPktType]
                                    [bfd_pkt] = temp_count;
                                map_array[bcmStatGroupModeAttrPktType][256] =
                                    temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_BPDU_PKT) {
                            if (map_array[bcmStatGroupModeAttrPktType]
                                    [bpdu_pkt] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrPktType]
                                    [256];
                                map_array[bcmStatGroupModeAttrPktType]
                                    [bpdu_pkt] = temp_count;
                                map_array[bcmStatGroupModeAttrPktType][256] =
                                    temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_ICNM_PKT) {
                            if (map_array[bcmStatGroupModeAttrPktType]
                                    [icnm_pkt] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrPktType]
                                    [256];
                                map_array[bcmStatGroupModeAttrPktType]
                                    [icnm_pkt] = temp_count;
                                map_array[bcmStatGroupModeAttrPktType][256] =
                                    temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_PKT_IS_1588) {
                            if (map_array[bcmStatGroupModeAttrPktType]
                                    [_1588_pkt] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrPktType]
                                    [256];
                                map_array[bcmStatGroupModeAttrPktType]
                                    [_1588_pkt] = temp_count;
                                map_array[bcmStatGroupModeAttrPktType][256] =
                                    temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_BFD_PKT) {
                            if (map_array[bcmStatGroupModeAttrPktType]
                                    [bfd_pkt] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrPktType]
                                    [256];
                                map_array[bcmStatGroupModeAttrPktType]
                                    [bfd_pkt] = temp_count;
                                map_array[bcmStatGroupModeAttrPktType][256] =
                                    temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_KNOWN_L2UC_PKT) {
                            if (map_array[bcmStatGroupModeAttrPktType]
                                    [known_l2uc_pkt] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrPktType]
                                    [256];
                                map_array[bcmStatGroupModeAttrPktType]
                                    [known_l2uc_pkt] = temp_count;
                                map_array[bcmStatGroupModeAttrPktType][256] =
                                    temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_L2UC_PKT) {
                            if (map_array[bcmStatGroupModeAttrPktType]
                                    [unknown_l2uc_pkt] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrPktType]
                                    [256];
                                map_array[bcmStatGroupModeAttrPktType]
                                    [unknown_l2uc_pkt] = temp_count;
                                map_array[bcmStatGroupModeAttrPktType][256] =
                                    temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_L2BC_PKT) {
                            if (map_array[bcmStatGroupModeAttrPktType]
                                    [l2bc_pkt] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrPktType]
                                    [256];
                                map_array[bcmStatGroupModeAttrPktType]
                                    [l2bc_pkt] = temp_count;
                                map_array[bcmStatGroupModeAttrPktType][256] =
                                    temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_KNOWN_L2MC_PKT) {
                            if (map_array[bcmStatGroupModeAttrPktType]
                                    [known_l2mc_pkt] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrPktType]
                                    [256];
                                map_array[bcmStatGroupModeAttrPktType]
                                    [known_l2mc_pkt] = temp_count;
                                map_array[bcmStatGroupModeAttrPktType][256] =
                                    temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_L2MC_PKT) {
                            if (map_array[bcmStatGroupModeAttrPktType]
                                    [unknown_l2mc_pkt] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrPktType]
                                    [256];
                                map_array[bcmStatGroupModeAttrPktType]
                                    [unknown_l2mc_pkt] = temp_count;
                                map_array[bcmStatGroupModeAttrPktType][256] =
                                    temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_KNOWN_L3UC_PKT) {
                            if (map_array[bcmStatGroupModeAttrPktType]
                                    [known_l3uc_pkt] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrPktType]
                                    [256];
                                map_array[bcmStatGroupModeAttrPktType]
                                    [known_l3uc_pkt] = temp_count;
                                map_array[bcmStatGroupModeAttrPktType][256] =
                                    temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_L3UC_PKT) {
                            if (map_array[bcmStatGroupModeAttrPktType]
                                    [unknown_l3uc_pkt] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrPktType]
                                    [256];
                                map_array[bcmStatGroupModeAttrPktType]
                                    [unknown_l3uc_pkt] = temp_count;
                                map_array[bcmStatGroupModeAttrPktType][256] =
                                    temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_KNOWN_IPMC_PKT) {
                            if (map_array[bcmStatGroupModeAttrPktType]
                                    [known_ipmc_pkt] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrPktType]
                                    [256];
                                map_array[bcmStatGroupModeAttrPktType]
                                    [known_ipmc_pkt] = temp_count;
                                map_array[bcmStatGroupModeAttrPktType][256] =
                                    temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_IPMC_PKT) {
                            if (map_array[bcmStatGroupModeAttrPktType]
                                    [unknown_ipmc_pkt] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrPktType]
                                    [256];
                                map_array[bcmStatGroupModeAttrPktType]
                                    [unknown_ipmc_pkt] = temp_count;
                                map_array[bcmStatGroupModeAttrPktType][256] =
                                    temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_L2_PKT) {
                            if (map_array[bcmStatGroupModeAttrPktType]
                                    [known_mpls_l2_pkt] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrPktType]
                                    [256];
                                map_array[bcmStatGroupModeAttrPktType]
                                    [known_mpls_l2_pkt] = temp_count;
                                map_array[bcmStatGroupModeAttrPktType][256] =
                                    temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_L3_PKT) {
                            if (map_array[bcmStatGroupModeAttrPktType]
                                    [known_mpls_l3_pkt] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrPktType]
                                    [256];
                                map_array[bcmStatGroupModeAttrPktType]
                                    [known_mpls_l3_pkt] = temp_count;
                                map_array[bcmStatGroupModeAttrPktType][256] =
                                    temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_PKT) {
                            if (map_array[bcmStatGroupModeAttrPktType]
                                    [known_mpls_pkt] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrPktType]
                                    [256];
                                map_array[bcmStatGroupModeAttrPktType]
                                    [known_mpls_pkt] = temp_count;
                                map_array[bcmStatGroupModeAttrPktType][256] =
                                    temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_MPLS_PKT) {
                            if (map_array[bcmStatGroupModeAttrPktType]
                                    [unknown_mpls_pkt] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrPktType]
                                    [256];
                                map_array[bcmStatGroupModeAttrPktType]
                                    [unknown_mpls_pkt] = temp_count;
                                map_array[bcmStatGroupModeAttrPktType][256] =
                                    temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_MULTICAST_PKT) {
                            if (map_array[bcmStatGroupModeAttrPktType]
                                    [known_mpls_multicast_pkt] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrPktType]
                                    [256];
                                map_array[bcmStatGroupModeAttrPktType]
                                    [known_mpls_multicast_pkt] = temp_count;
                                map_array[bcmStatGroupModeAttrPktType][256] =
                                    temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_KNOWN_MIM_PKT) {
                            if (map_array[bcmStatGroupModeAttrPktType]
                                    [known_mim_pkt] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrPktType]
                                    [256];
                                map_array[bcmStatGroupModeAttrPktType]
                                    [known_mim_pkt] = temp_count;
                                map_array[bcmStatGroupModeAttrPktType][256] =
                                    temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_MIM_PKT) {
                            if (map_array[bcmStatGroupModeAttrPktType]
                                    [unknown_mim_pkt] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrPktType]
                                    [256];
                                map_array[bcmStatGroupModeAttrPktType]
                                    [unknown_mim_pkt] = temp_count;
                                map_array[bcmStatGroupModeAttrPktType][256] =
                                    temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_KNOWN_TRILL_PKT) {
                            if (map_array[bcmStatGroupModeAttrPktType]
                                    [known_trill_pkt] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrPktType]
                                    [256];
                                map_array[bcmStatGroupModeAttrPktType]
                                    [known_trill_pkt] = temp_count;
                                map_array[bcmStatGroupModeAttrPktType][256] =
                                    temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_TRILL_PKT) {
                            if (map_array[bcmStatGroupModeAttrPktType]
                                    [unknown_trill_pkt] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrPktType]
                                    [256];
                                map_array[bcmStatGroupModeAttrPktType]
                                    [unknown_trill_pkt] = temp_count;
                                map_array[bcmStatGroupModeAttrPktType][256] =
                                    temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_KNOWN_NIV_PKT) {
                            if (map_array[bcmStatGroupModeAttrPktType]
                                    [known_niv_pkt] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrPktType]
                                    [256];
                                map_array[bcmStatGroupModeAttrPktType]
                                    [known_niv_pkt] = temp_count;
                                map_array[bcmStatGroupModeAttrPktType][256] =
                                    temp_count+1;
                            }
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_NIV_PKT) {
                            if (map_array[bcmStatGroupModeAttrPktType]
                                    [unknown_niv_pkt] == 0xFF) {
                                temp_count = map_array[bcmStatGroupModeAttrPktType]
                                    [256];
                                map_array[bcmStatGroupModeAttrPktType]
                                    [unknown_niv_pkt] = temp_count;
                                map_array[bcmStatGroupModeAttrPktType][256] =
                                    temp_count+1;
                            }
                        }
#if defined(BCM_TRIDENT2_SUPPORT)
                        if (SOC_IS_TD2_TT2(unit)) {
                            if (flex_attribute->combine_attr_counter[counter].
                                    pkt_resolution_flags &
                                    BCM_STAT_FLEX_PKT_TYPE_KNOWN_L2GRE_PKT) {
                                if (map_array[bcmStatGroupModeAttrPktType]
                                        [known_l2gre_pkt] == 0xFF) {
                                    temp_count = map_array[bcmStatGroupModeAttrPktType]
                                        [256];
                                    map_array[bcmStatGroupModeAttrPktType]
                                        [known_l2gre_pkt] = temp_count;
                                    map_array[bcmStatGroupModeAttrPktType][256] =
                                        temp_count+1;
                                }
                            }
                            if (flex_attribute->combine_attr_counter[counter].
                                    pkt_resolution_flags &
                                    BCM_STAT_FLEX_PKT_TYPE_KNOWN_VXLAN_PKT) {
                                if (map_array[bcmStatGroupModeAttrPktType]
                                        [known_fcoe_pkt] == 0xFF) {
                                    temp_count = map_array[bcmStatGroupModeAttrPktType]
                                        [256];
                                    map_array[bcmStatGroupModeAttrPktType]
                                        [known_fcoe_pkt] = temp_count;
                                    map_array[bcmStatGroupModeAttrPktType][256] =
                                        temp_count+1;
                                }
                            }
                            if (flex_attribute->combine_attr_counter[counter].
                                    pkt_resolution_flags &
                                    BCM_STAT_FLEX_PKT_TYPE_KNOWN_FCOE_PKT) {
                                if (map_array[bcmStatGroupModeAttrPktType]
                                        [known_vxlan_pkt] == 0xFF) {
                                    temp_count = map_array[bcmStatGroupModeAttrPktType]
                                        [256];
                                    map_array[bcmStatGroupModeAttrPktType]
                                        [known_vxlan_pkt] = temp_count;
                                    map_array[bcmStatGroupModeAttrPktType][256] =
                                        temp_count+1;
                                }
                            }
                            if (flex_attribute->combine_attr_counter[counter].
                                    pkt_resolution_flags &
                                    BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_FCOE_PKT) {
                                if (map_array[bcmStatGroupModeAttrPktType]
                                        [unknown_fcoe_pkt] == 0xFF) {
                                    temp_count = map_array[bcmStatGroupModeAttrPktType]
                                        [256];
                                    map_array[bcmStatGroupModeAttrPktType]
                                        [unknown_fcoe_pkt] = temp_count;
                                    map_array[bcmStatGroupModeAttrPktType][256] =
                                        temp_count+1;
                                }
                            }
                        }
#endif
                            if (flex_attribute->combine_attr_counter[counter].
                                    pkt_resolution_high_flags &
                                    BCM_STAT_FLEX_PKT_TYPE_2_L2_UC_PKT) {
                                if (map_array[bcmStatGroupModeAttrPktType]
                                        [l2_uc_pkt] == 0xFF) {
                                    temp_count = map_array[bcmStatGroupModeAttrPktType]
                                        [256];
                                    map_array[bcmStatGroupModeAttrPktType]
                                        [l2_uc_pkt] = temp_count;
                                    map_array[bcmStatGroupModeAttrPktType][256] =
                                        temp_count+1;
                                }
                            }
                            if (flex_attribute->combine_attr_counter[counter].
                                    pkt_resolution_high_flags &
                                    BCM_STAT_FLEX_PKT_TYPE_2_L2_NON_UC_PKT) {
                                if (map_array[bcmStatGroupModeAttrPktType]
                                        [l2_non_uc_pkt] == 0xFF) {
                                    temp_count = map_array[bcmStatGroupModeAttrPktType]
                                        [256];
                                    map_array[bcmStatGroupModeAttrPktType]
                                        [l2_non_uc_pkt] = temp_count;
                                    map_array[bcmStatGroupModeAttrPktType][256] =
                                        temp_count+1;
                                }
                            }

                        
                    }
                }
                if (flex_attribute->svp != 0) {
                    if (map_array[bcmStatGroupModeAttrIngNetworkGroup] == NULL) {
                        map_array[bcmStatGroupModeAttrIngNetworkGroup] =
                            (uint8 *) sal_alloc(256+1,"map_array");

                        if (map_array[bcmStatGroupModeAttrIngNetworkGroup] == NULL) {
                            rv = BCM_E_MEMORY;
                            goto cleanup;
                        }

                        sal_memset(map_array[bcmStatGroupModeAttrIngNetworkGroup],
                                0xFF,256);
                        map_array[bcmStatGroupModeAttrIngNetworkGroup][256]=0;
                    }
                    if (direction == bcmStatFlexDirectionIngress) {
                        max_count= (1 << ing_pkt_attr_cmprsd_bits_g[unit].svp_type)-1;
                    } else {
                        max_count= (1 << egr_pkt_attr_cmprsd_bits_g[unit].svp_type)-1;
                    }
                    for (loop_index=0; loop_index <= max_count ; loop_index++) {
                        if (BCM_STAT_FLEX_VALUE_GET(
                                    flex_attribute->combine_attr_counter[counter].
                                    value_array[bcmStatFlexAttrSvp],
                                    loop_index)) {
                            if (map_array[bcmStatGroupModeAttrIngNetworkGroup]
                                    [loop_index] == 0xFF) {
                                temp_count = map_array
                                    [bcmStatGroupModeAttrIngNetworkGroup]
                                    [256];
                                map_array[bcmStatGroupModeAttrIngNetworkGroup]
                                    [loop_index] = temp_count;
                                map_array[bcmStatGroupModeAttrIngNetworkGroup]
                                    [256] = temp_count + 1;
                            }
                        }
                    }
                }
                if (flex_attribute->dvp != 0) {
                    if (map_array[bcmStatGroupModeAttrEgrNetworkGroup] == NULL) {
                        map_array[bcmStatGroupModeAttrEgrNetworkGroup] =
                            (uint8 *) sal_alloc(256+1,"map_array");

                        if (map_array[bcmStatGroupModeAttrEgrNetworkGroup] == NULL) {
                            rv = BCM_E_MEMORY;
                            goto cleanup;
                        }

                        sal_memset(map_array[bcmStatGroupModeAttrEgrNetworkGroup],
                                0xFF,256);
                        map_array[bcmStatGroupModeAttrEgrNetworkGroup][256]=0;
                    }
                    max_count= (1 << egr_pkt_attr_cmprsd_bits_g[unit].dvp_type)-1;
                    for (loop_index=0; loop_index <= max_count ; loop_index++) {
                        if (BCM_STAT_FLEX_VALUE_GET(
                                    flex_attribute->combine_attr_counter[counter].
                                    value_array[bcmStatFlexAttrDvp],
                                    loop_index)) {
                            if (map_array[bcmStatGroupModeAttrEgrNetworkGroup]
                                    [loop_index] == 0xFF) {
                                temp_count = map_array
                                    [bcmStatGroupModeAttrEgrNetworkGroup]
                                    [256];
                                map_array[bcmStatGroupModeAttrEgrNetworkGroup]
                                    [loop_index] = temp_count;
                                map_array[bcmStatGroupModeAttrEgrNetworkGroup]
                                    [256] = temp_count + 1;
                            }
                        }
                    }
                }
                if (flex_attribute->drop != 0) {
                    if (map_array[bcmStatGroupModeAttrDrop] == NULL) {
                        map_array[bcmStatGroupModeAttrDrop] =
                            (uint8 *) sal_alloc(256+1,"map_array");

                        if (map_array[bcmStatGroupModeAttrDrop] == NULL) {
                            rv = BCM_E_MEMORY;
                            goto cleanup;
                        }

                        sal_memset(map_array[bcmStatGroupModeAttrDrop],
                                0xFF,256);
                        map_array[bcmStatGroupModeAttrDrop][256]=0;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            drop_flags & BCM_STAT_FLEX_DROP_DISABLE) {
                        if (map_array[bcmStatGroupModeAttrDrop][0] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrDrop][256];
                            map_array[bcmStatGroupModeAttrDrop][0] = temp_count;
                            map_array[bcmStatGroupModeAttrDrop][256]=temp_count + 1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            drop_flags & BCM_STAT_FLEX_DROP_ENABLE) {
                        if (map_array[bcmStatGroupModeAttrDrop][1] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrDrop][256];
                            map_array[bcmStatGroupModeAttrDrop][1] = temp_count;
                            map_array[bcmStatGroupModeAttrDrop][256]=temp_count + 1;
                        }
                    }
                }
                /* END: PKT_RES_MAP*/
                if (flex_attribute->ip_pkt!= 0) {
                    if (map_array[bcmStatGroupModeAttrPacketTypeIp] == NULL) {
                        map_array[bcmStatGroupModeAttrPacketTypeIp] =
                            (uint8 *) sal_alloc(256+1,"map_array");

                        if (map_array[bcmStatGroupModeAttrPacketTypeIp] == NULL) {
                            rv = BCM_E_MEMORY;
                            goto cleanup;
                        }

                        sal_memset(map_array[bcmStatGroupModeAttrPacketTypeIp],
                                0xFF,256);
                        map_array[bcmStatGroupModeAttrPacketTypeIp][256]=0;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            ip_pkt_flags & BCM_STAT_FLEX_IP_PKT_DISABLE) {
                        if (map_array[bcmStatGroupModeAttrPacketTypeIp][0] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrPacketTypeIp][256];
                            map_array[bcmStatGroupModeAttrPacketTypeIp][0] = temp_count;
                            map_array[bcmStatGroupModeAttrPacketTypeIp][256]=temp_count + 1;
                        }
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            ip_pkt_flags & BCM_STAT_FLEX_IP_PKT_ENABLE) {
                        if (map_array[bcmStatGroupModeAttrPacketTypeIp][1] == 0xFF) {
                            temp_count = map_array[bcmStatGroupModeAttrPacketTypeIp][256];
                            map_array[bcmStatGroupModeAttrPacketTypeIp][1] = temp_count;
                            map_array[bcmStatGroupModeAttrPacketTypeIp][256]=temp_count + 1;
                        }
                    }
                }
            }
        }
#ifdef BCM_APACHE_SUPPORT
        if (soc_feature(unit,soc_feature_flex_ctr_mpls_3_label_count)) {
            if (map_array[bcmStatGroupModeAttrColorMplsLabelThird] != NULL) {
                pre_ifp_cng_mpls_3_cmprsd_max_bits = _bcm_stat_flex_get_num_bits(
                        map_array[bcmStatGroupModeAttrColorMplsLabelThird][256]);
                if (pre_ifp_cng_mpls_3_cmprsd_max_bits > cng_3_bits) {
                    pre_ifp_cng_mpls_3_cmprsd_max_bits = cng_3_bits;
                }
            }
            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelThird] != NULL) {
                int_pri_mpls_3_cmprsd_max_bits = _bcm_stat_flex_get_num_bits(
                        map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][256]);
                if (int_pri_mpls_3_cmprsd_max_bits > phb_3_bits) {
                    int_pri_mpls_3_cmprsd_max_bits = phb_3_bits;
                }
            }
            if (map_array[bcmStatGroupModeAttrColorMplsLabelSecond] != NULL) {
                pre_ifp_cng_mpls_2_cmprsd_max_bits = _bcm_stat_flex_get_num_bits(
                        map_array[bcmStatGroupModeAttrColorMplsLabelSecond][256]);
                if (pre_ifp_cng_mpls_2_cmprsd_max_bits > cng_2_bits) {
                    pre_ifp_cng_mpls_2_cmprsd_max_bits = cng_2_bits;
                }
            }
            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond] != NULL) {
                int_pri_mpls_2_cmprsd_max_bits = _bcm_stat_flex_get_num_bits(
                        map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][256]);
                if (int_pri_mpls_2_cmprsd_max_bits > phb_2_bits) {
                    int_pri_mpls_2_cmprsd_max_bits = phb_2_bits;
                }
            }
            if (map_array[bcmStatGroupModeAttrColorMplsLabelFirst] != NULL) {
                pre_ifp_cng_mpls_1_cmprsd_max_bits = _bcm_stat_flex_get_num_bits(
                        map_array[bcmStatGroupModeAttrColorMplsLabelFirst][256]);
                if (pre_ifp_cng_mpls_1_cmprsd_max_bits > cng_1_bits) {
                    pre_ifp_cng_mpls_1_cmprsd_max_bits = cng_1_bits;
                }
            }
            if (map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst] != NULL) {
                int_pri_mpls_1_cmprsd_max_bits = _bcm_stat_flex_get_num_bits(
                        map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][256]);
                if (int_pri_mpls_1_cmprsd_max_bits > phb_1_bits) {
                    int_pri_mpls_1_cmprsd_max_bits = phb_1_bits;
                }
            }
        }
#endif
        /*
         * In flex counter, compressed mode is handled via compression HW tables.
         * Various sets attributes are mapped to particular compression tables
         * and are grouped together.
         *
         * For each Logical Group,
         * 1. Based on number of attribute values per attribute belonging
         *    to that logical group, required bits are calculated to represent
         *    that attribute selector.
         * 2. For non conforming packet ie. the packet that does not have the
         *    selected attribute value, one more counter offset is required.
         *    To get that offset, either we can use any vacant offset value that
         *    is not used by the attribute value and if this condition is not met
         *    then we need to increment one bit in the compressed attribute bit set.
         * 3. Once an extra offset is acquired, we need to validate with the max
         *    number of bits supported.
         */

#if defined(BCM_TOMAHAWK_SUPPORT) || defined(BCM_TRIDENT3_SUPPORT)
        if (soc_feature(unit, soc_feature_flex_stat_egr_queue_congestion_marked)) {
            if (map_array[bcmStatGroupModeAttrCos] != NULL ||
                map_array[bcmStatGroupModeAttrQueueType] != NULL) {
                unused_attr_val_found = FALSE;
                if (map_array[bcmStatGroupModeAttrCos] != NULL) {
                    mmu_cos_cmprsd_max_bits = _bcm_stat_flex_get_num_bits(
                            map_array[bcmStatGroupModeAttrCos][256]);
                    if (mmu_cos_cmprsd_max_bits > mmu_cos_bits) {
                        mmu_cos_cmprsd_max_bits = mmu_cos_bits;
                    }
                    values =  map_array[bcmStatGroupModeAttrCos][256];
                    values_max = 1 << mmu_cos_cmprsd_max_bits;
                    unused_attr_val_found = (values_max > values) ? TRUE : unused_attr_val_found;
                }
                if (map_array[bcmStatGroupModeAttrQueueType] != NULL) {
                    uc_queueing_cmprsd_max_bits = _bcm_stat_flex_get_num_bits(
                            map_array[bcmStatGroupModeAttrQueueType][256]);
                    if (uc_queueing_cmprsd_max_bits > uc_queueing_bits) {
                        uc_queueing_cmprsd_max_bits = uc_queueing_bits;
                    }
                    values =  map_array[bcmStatGroupModeAttrQueueType][256];
                    values_max = 1 << uc_queueing_cmprsd_max_bits;
                    unused_attr_val_found = (values_max >
                            values) ? TRUE : unused_attr_val_found;
                }
                if (!unused_attr_val_found) {
                  if (mmu_cos_cmprsd_max_bits &&
                      (mmu_cos_cmprsd_max_bits < mmu_cos_bits)) {
                      mmu_cos_cmprsd_max_bits++ ;
                  } else if (uc_queueing_cmprsd_max_bits &&
                      (uc_queueing_cmprsd_max_bits < uc_queueing_bits)) {
                      uc_queueing_cmprsd_max_bits++ ;
                  }
                }
            }

            if (map_array[bcmStatGroupModeAttrCongestionMarked] != NULL) {
                congestion_marked_cmprsd_max_bits = _bcm_stat_flex_get_num_bits(
                        map_array[bcmStatGroupModeAttrCongestionMarked][256]);
                if (congestion_marked_cmprsd_max_bits > congestion_marked_bits) {
                    congestion_marked_cmprsd_max_bits = congestion_marked_bits;
                }
            }
        }
#endif

        if (map_array[bcmStatGroupModeAttrColor] != NULL ||
            map_array[bcmStatGroupModeAttrFieldIngressColor] != NULL ||
            map_array[bcmStatGroupModeAttrIntPri] != NULL) {
            unused_attr_val_found = FALSE;
            if (map_array[bcmStatGroupModeAttrColor] != NULL) {
                pre_ifp_cng_cmprsd_max_bits = _bcm_stat_flex_get_num_bits(
                        map_array[bcmStatGroupModeAttrColor][256]);
                if (pre_ifp_cng_cmprsd_max_bits > cng_bits) {
                    pre_ifp_cng_cmprsd_max_bits = cng_bits;
                }
                values =  map_array[bcmStatGroupModeAttrColor][256];
                values_max = 1 << pre_ifp_cng_cmprsd_max_bits;
                unused_attr_val_found = (values_max > values) ? TRUE : unused_attr_val_found;
            }
            if (map_array[bcmStatGroupModeAttrFieldIngressColor] != NULL) {
                ifp_cng_cmprsd_max_bits = _bcm_stat_flex_get_num_bits(
                        map_array[bcmStatGroupModeAttrFieldIngressColor][256]);
                if (ifp_cng_cmprsd_max_bits > ifp_cng_bits) {
                    ifp_cng_cmprsd_max_bits = ifp_cng_bits;
                }
                values =  map_array[bcmStatGroupModeAttrFieldIngressColor][256];
                values_max = 1 << ifp_cng_cmprsd_max_bits;
                unused_attr_val_found = (values_max >
                        values) ? TRUE : unused_attr_val_found;
            }
            if (map_array[bcmStatGroupModeAttrIntPri] != NULL) {
                int_pri_cmprsd_max_bits = _bcm_stat_flex_get_num_bits(
                        map_array[bcmStatGroupModeAttrIntPri][256]);
                if (int_pri_cmprsd_max_bits > int_pri_bits) {
                    int_pri_cmprsd_max_bits = int_pri_bits;
                }
                values =  map_array[bcmStatGroupModeAttrIntPri][256];
                values_max = 1 << int_pri_cmprsd_max_bits;
                unused_attr_val_found = (values_max >
                        values) ? TRUE : unused_attr_val_found;
            }
            if (!unused_attr_val_found) {
              if (pre_ifp_cng_cmprsd_max_bits &&
                  (pre_ifp_cng_cmprsd_max_bits < cng_bits)) {
                  pre_ifp_cng_cmprsd_max_bits++ ;
              } else if (ifp_cng_cmprsd_max_bits &&
                  (ifp_cng_cmprsd_max_bits < ifp_cng_bits)) {
                  ifp_cng_cmprsd_max_bits++ ;
              } else if (int_pri_cmprsd_max_bits &&
                  (int_pri_cmprsd_max_bits < int_pri_bits)) {
                  int_pri_cmprsd_max_bits++ ;
              }
            }
        }

        if (map_array[bcmStatGroupModeAttrVlan] != NULL ||
            map_array[bcmStatGroupModeAttrOuterPri] != NULL ||
            map_array[bcmStatGroupModeAttrInnerPri] != NULL) {
            unused_attr_val_found = FALSE;
            if (map_array[bcmStatGroupModeAttrVlan] != NULL) {
                vlan_format_cmprsd_max_bits = _bcm_stat_flex_get_num_bits(
                        map_array[bcmStatGroupModeAttrVlan][256]);
                if (vlan_format_cmprsd_max_bits > vlan_format_bits) {
                    vlan_format_cmprsd_max_bits = vlan_format_bits;
                }
                values =  map_array[bcmStatGroupModeAttrVlan][256];
                values_max = 1 << vlan_format_cmprsd_max_bits;
                unused_attr_val_found = (values_max >
                        values) ? TRUE : unused_attr_val_found;
            }
            if (map_array[bcmStatGroupModeAttrOuterPri] != NULL) {
                outer_dot1p_cmprsd_max_bits = _bcm_stat_flex_get_num_bits(
                        map_array[bcmStatGroupModeAttrOuterPri][256]);
                if (outer_dot1p_cmprsd_max_bits > outer_dot1p_bits) {
                    outer_dot1p_cmprsd_max_bits = outer_dot1p_bits;
                }
                values =  map_array[bcmStatGroupModeAttrOuterPri][256];
                values_max = 1 << outer_dot1p_cmprsd_max_bits;
                unused_attr_val_found = (values_max >
                        values) ? TRUE : unused_attr_val_found;
            }
            if (map_array[bcmStatGroupModeAttrInnerPri] != NULL) {
                inner_dot1p_cmprsd_max_bits = _bcm_stat_flex_get_num_bits(
                        map_array[bcmStatGroupModeAttrInnerPri][256]);
                if (inner_dot1p_cmprsd_max_bits > inner_dot1p_bits) {
                    inner_dot1p_cmprsd_max_bits = inner_dot1p_bits;
                }
                values =  map_array[bcmStatGroupModeAttrInnerPri][256];
                values_max = 1 << inner_dot1p_cmprsd_max_bits;
                unused_attr_val_found = (values_max >
                        values) ? TRUE : unused_attr_val_found;
            }
            if (!unused_attr_val_found) {
              if (vlan_format_cmprsd_max_bits &&
                  (vlan_format_cmprsd_max_bits < vlan_format_bits)) {
                  vlan_format_cmprsd_max_bits++ ;
              } else if (outer_dot1p_cmprsd_max_bits &&
                  (outer_dot1p_cmprsd_max_bits < outer_dot1p_bits)) {
                  outer_dot1p_cmprsd_max_bits++ ;
              } else if (inner_dot1p_cmprsd_max_bits &&
                  (inner_dot1p_cmprsd_max_bits < inner_dot1p_bits)) {
                  inner_dot1p_cmprsd_max_bits++ ;
              }
            }
        }
        if (map_array[bcmStatGroupModeAttrPort] != NULL) {
            port_cmprsd_max_bits = _bcm_stat_flex_get_num_bits(
                    map_array[bcmStatGroupModeAttrPort][port_map_array_size] + 1);
            if (port_cmprsd_max_bits > port_bits) {
                port_cmprsd_max_bits = port_bits;
            }
        }
        if (map_array[bcmStatGroupModeAttrTosDscp] != NULL ||
            map_array[bcmStatGroupModeAttrTosEcn] != NULL) {
            unused_attr_val_found = FALSE;
            if (map_array[bcmStatGroupModeAttrTosDscp] != NULL) {
                tos_dscp_cmprsd_max_bits = _bcm_stat_flex_get_num_bits(
                        map_array[bcmStatGroupModeAttrTosDscp][256]);
                if (tos_dscp_cmprsd_max_bits > tos_dscp_bits) {
                    tos_dscp_cmprsd_max_bits = tos_dscp_bits;
                }
                values =  map_array[bcmStatGroupModeAttrTosDscp][256];
                values_max = 1 << tos_dscp_cmprsd_max_bits;
                unused_attr_val_found = (values_max >
                        values) ? TRUE : unused_attr_val_found;
            }
            if (map_array[bcmStatGroupModeAttrTosEcn] != NULL) {
                tos_ecn_cmprsd_max_bits = _bcm_stat_flex_get_num_bits(
                        map_array[bcmStatGroupModeAttrTosEcn][256]);
                if (tos_ecn_cmprsd_max_bits > tos_ecn_bits) {
                    tos_ecn_cmprsd_max_bits = tos_ecn_bits;
                }
                values =  map_array[bcmStatGroupModeAttrTosEcn][256];
                values_max = 1 << tos_ecn_cmprsd_max_bits;
                unused_attr_val_found = (values_max >
                        values) ? TRUE : unused_attr_val_found;
            }
            if (!unused_attr_val_found) {
                if (tos_dscp_cmprsd_max_bits &&
                    (tos_dscp_cmprsd_max_bits < tos_dscp_bits)) {
                    tos_dscp_cmprsd_max_bits++ ;
                } else if (tos_ecn_cmprsd_max_bits &&
                    (tos_ecn_cmprsd_max_bits < tos_ecn_bits)) {
                    tos_ecn_cmprsd_max_bits++ ;
                }
            }
        }

        if (map_array[bcmStatGroupModeAttrPktType] != NULL ||
            map_array[bcmStatGroupModeAttrClassType] != NULL ||
            map_array[bcmStatGroupModeAttrIngNetworkGroup] != NULL ||
            map_array[bcmStatGroupModeAttrEgrNetworkGroup] != NULL ||
            map_array[bcmStatGroupModeAttrDrop] != NULL) {
            unused_attr_val_found = FALSE;
#ifdef BCM_KATANA2_SUPPORT
            if soc_feature(unit, soc_feature_flex_stat_attributes_class) {
                if (map_array[bcmStatGroupModeAttrClassType] != NULL) {
                    pkt_resolution_cmprsd_max_bits = _bcm_stat_flex_get_num_bits(
                            map_array[bcmStatGroupModeAttrClassType][256]);
                    if (pkt_resolution_cmprsd_max_bits > pkt_resolution_bits) {
                        pkt_resolution_cmprsd_max_bits = pkt_resolution_bits;
                    }
                    values =  map_array[bcmStatGroupModeAttrClassType][256];
                    values_max = 1 << pkt_resolution_cmprsd_max_bits;
                    unused_attr_val_found = (values_max >
                            values) ? TRUE : unused_attr_val_found;
                }
            } else
#endif
            {
                if (map_array[bcmStatGroupModeAttrPktType] != NULL) {
                    pkt_resolution_cmprsd_max_bits = _bcm_stat_flex_get_num_bits(
                            map_array[bcmStatGroupModeAttrPktType][256]);
                    if (pkt_resolution_cmprsd_max_bits > pkt_resolution_bits) {
                        pkt_resolution_cmprsd_max_bits = pkt_resolution_bits;
                    }
                    values =  map_array[bcmStatGroupModeAttrPktType][256];
                    values_max = 1 << pkt_resolution_cmprsd_max_bits;
                    unused_attr_val_found = (values_max >
                            values) ? TRUE : unused_attr_val_found;
                }
            }
           if (map_array[bcmStatGroupModeAttrIngNetworkGroup] != NULL) {
                svp_cmprsd_max_bits = _bcm_stat_flex_get_num_bits(
                        map_array[bcmStatGroupModeAttrIngNetworkGroup][256]);
                if (svp_cmprsd_max_bits > svp_bits) {
                    svp_cmprsd_max_bits = svp_bits;
                }
                values =  map_array[bcmStatGroupModeAttrIngNetworkGroup][256];
                values_max = 1 << svp_cmprsd_max_bits;
                unused_attr_val_found = (values_max >
                        values) ? TRUE : unused_attr_val_found;
            }
            if (map_array[bcmStatGroupModeAttrEgrNetworkGroup] != NULL) {
                dvp_cmprsd_max_bits = _bcm_stat_flex_get_num_bits(
                        map_array[bcmStatGroupModeAttrEgrNetworkGroup][256]);
                if (dvp_cmprsd_max_bits > dvp_bits) {
                    dvp_cmprsd_max_bits = dvp_bits;
                }
                values =  map_array[bcmStatGroupModeAttrEgrNetworkGroup][256];
                values_max = 1 << dvp_cmprsd_max_bits;
                unused_attr_val_found = (values_max >
                        values) ? TRUE : unused_attr_val_found;
            }
            if (map_array[bcmStatGroupModeAttrDrop] != NULL) {
                drop_cmprsd_max_bits = _bcm_stat_flex_get_num_bits(
                        map_array[bcmStatGroupModeAttrDrop][256]);
                if (drop_cmprsd_max_bits > drop_bits) {
                    drop_cmprsd_max_bits = drop_bits;
                }
                values =  map_array[bcmStatGroupModeAttrDrop][256];
                values_max = 1 << drop_cmprsd_max_bits;
                unused_attr_val_found = (values_max >
                        values) ? TRUE : unused_attr_val_found;
            }
            if (!unused_attr_val_found) {
              if (pkt_resolution_cmprsd_max_bits &&
                  (pkt_resolution_cmprsd_max_bits < pkt_resolution_bits)) {
                  pkt_resolution_cmprsd_max_bits++ ;
              } else if (svp_cmprsd_max_bits &&
                  (svp_cmprsd_max_bits < svp_bits)) {
                  svp_cmprsd_max_bits++ ;
              } else if (dvp_cmprsd_max_bits &&
                  (dvp_cmprsd_max_bits < int_pri_bits)) {
                  dvp_cmprsd_max_bits++ ;
              } else if (drop_cmprsd_max_bits &&
                  (drop_cmprsd_max_bits < drop_bits)) {
                  drop_cmprsd_max_bits++ ;
              }
            }
        }
        if (map_array[bcmStatGroupModeAttrPacketTypeIp] != NULL) {
            ip_pkt_cmprsd_max_bits = _bcm_stat_flex_get_num_bits(
                    map_array[bcmStatGroupModeAttrPacketTypeIp][256]);
            if (ip_pkt_cmprsd_max_bits > ip_pkt_bits) {
                ip_pkt_cmprsd_max_bits = ip_pkt_bits;
            }
        }
        total_bits = 0;
#ifdef BCM_APACHE_SUPPORT
        if (soc_feature(unit,soc_feature_flex_ctr_mpls_3_label_count)) {
            total_bits = pre_ifp_cng_mpls_3_cmprsd_max_bits +
                int_pri_mpls_3_cmprsd_max_bits +
                pre_ifp_cng_mpls_2_cmprsd_max_bits +
                int_pri_mpls_2_cmprsd_max_bits +
                pre_ifp_cng_mpls_1_cmprsd_max_bits;
        }
#endif
#if defined(BCM_TOMAHAWK_SUPPORT) || defined(BCM_TRIDENT3_SUPPORT)
        if (soc_feature(unit, soc_feature_flex_stat_egr_queue_congestion_marked)) {
            total_bits += mmu_cos_cmprsd_max_bits +
                uc_queueing_cmprsd_max_bits + congestion_marked_cmprsd_max_bits;
        }
#endif

        if ((total_bits = total_bits +
             pre_ifp_cng_cmprsd_max_bits + ifp_cng_cmprsd_max_bits +
             int_pri_cmprsd_max_bits + vlan_format_cmprsd_max_bits +
             outer_dot1p_cmprsd_max_bits + inner_dot1p_cmprsd_max_bits +
             port_cmprsd_max_bits +
             tos_dscp_cmprsd_max_bits + tos_ecn_cmprsd_max_bits +
             pkt_resolution_cmprsd_max_bits + svp_cmprsd_max_bits +
             dvp_cmprsd_max_bits + drop_cmprsd_max_bits + ip_pkt_cmprsd_max_bits) > BCM_STAT_FLEX_COUNTER_MAX_TOTAL_BITS)  {
             LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                       (BSL_META_U(unit,
                                   "TotalBits=%d Even Compressed mode cannot be used\n"),
                     total_bits));
             for (loop = 0; loop < bcmStatGroupModeAttrMaxValue; loop++) {
                  if (map_array[loop] != NULL) {
                      sal_free(map_array[loop]);
                  }
             }
             sal_free(attr);
             return BCM_E_PARAM;
        }
        /* Creating MAP..there will be some unnecessary entries but no harm */
        switch(direction) {
        case bcmStatFlexDirectionIngress:
#ifdef BCM_APACHE_SUPPORT
            if (soc_feature(unit,soc_feature_flex_ctr_mpls_3_label_count)) {
                max_bits = 0;
                if ((flex_attribute->cng_3 != 0) &&
                        (map_array[bcmStatGroupModeAttrColorMplsLabelThird] != NULL)) {
                    max_bits =  pre_ifp_cng_mpls_3_cmprsd_max_bits;
                    ing_cmprsd_pkt_attr_bits->cng_3 = max_bits;
                    ing_cmprsd_pkt_attr_bits->cng_3_mask = (1 << max_bits) - 1;
                    ing_cmprsd_pkt_attr_bits->cng_3_pos = ing_pkt_attr_cmprsd_bits_g[unit].
                        cng_3_pos;
                }
                if ((flex_attribute->phb_3 != 0) &&
                        (map_array[bcmStatGroupModeAttrIntPriMplsLabelThird] != NULL)) {
                    max_bits =  int_pri_mpls_3_cmprsd_max_bits;
                    ing_cmprsd_pkt_attr_bits->phb_3 = max_bits;
                    ing_cmprsd_pkt_attr_bits->phb_3_mask = (1 << max_bits) - 1;
                    ing_cmprsd_pkt_attr_bits->phb_3_pos = ing_pkt_attr_cmprsd_bits_g[unit].
                        phb_3_pos;

                }
                if ((flex_attribute->cng_2 != 0) &&
                        (map_array[bcmStatGroupModeAttrColorMplsLabelSecond] != NULL)) {
                    max_bits =  pre_ifp_cng_mpls_2_cmprsd_max_bits;
                    ing_cmprsd_pkt_attr_bits->cng_2 = max_bits;
                    ing_cmprsd_pkt_attr_bits->cng_2_mask = (1 << max_bits) - 1;
                    ing_cmprsd_pkt_attr_bits->cng_2_pos = ing_pkt_attr_cmprsd_bits_g[unit].
                        cng_2_pos;
                }
                if ((flex_attribute->phb_2 != 0) &&
                        (map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond] != NULL)) {
                    max_bits =  int_pri_mpls_2_cmprsd_max_bits;
                    ing_cmprsd_pkt_attr_bits->phb_2 = max_bits;
                    ing_cmprsd_pkt_attr_bits->phb_2_mask = (1 << max_bits) - 1;
                    ing_cmprsd_pkt_attr_bits->phb_2_pos = ing_pkt_attr_cmprsd_bits_g[unit].
                        phb_2_pos;

                }
                if ((flex_attribute->cng_1 != 0) &&
                        (map_array[bcmStatGroupModeAttrColorMplsLabelFirst] != NULL)) {
                    max_bits =  pre_ifp_cng_mpls_1_cmprsd_max_bits;
                    ing_cmprsd_pkt_attr_bits->cng_1 = max_bits;
                    ing_cmprsd_pkt_attr_bits->cng_1_mask = (1 << max_bits) - 1;
                    ing_cmprsd_pkt_attr_bits->cng_1_pos = ing_pkt_attr_cmprsd_bits_g[unit].
                        cng_1_pos;
                }
                if ((flex_attribute->phb_1 != 0) &&
                        (map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst] != NULL)) {
                    max_bits =  int_pri_mpls_1_cmprsd_max_bits;
                    ing_cmprsd_pkt_attr_bits->phb_1 = max_bits;
                    ing_cmprsd_pkt_attr_bits->phb_1_mask = (1 << max_bits) - 1;
                    ing_cmprsd_pkt_attr_bits->phb_1_pos = ing_pkt_attr_cmprsd_bits_g[unit].
                        phb_1_pos;

                }
            }
#endif
            if ((flex_attribute->pre_ifp_color != 0) ||
                (flex_attribute->ifp_color != 0) || 
                (flex_attribute->int_pri != 0)) {
                 mapped_value0 = 0;
                 mapped_value1 = 0;
                 mapped_value2 = 0;
                 max_bits=0;
                 LOG_VERBOSE(BSL_LS_BCM_FLEXCTR,
                             (BSL_META_U(unit,
                                         "Ing: PRI_CNG_MAP Creation \n")));
                 if (map_array[bcmStatGroupModeAttrColor] != NULL) {
                     max_bits =  pre_ifp_cng_cmprsd_max_bits;
                     ing_cmprsd_pkt_attr_bits->cng = max_bits;
                     ing_cmprsd_pkt_attr_bits->cng_mask = (1 << max_bits) - 1;
                     ing_cmprsd_pkt_attr_bits->cng_pos = ing_pkt_attr_cmprsd_bits_g[unit].
                                                         cng_pos;
                 }
                 if (map_array[bcmStatGroupModeAttrFieldIngressColor] != NULL) {
                     max_bits =  ifp_cng_cmprsd_max_bits;
                     ing_cmprsd_pkt_attr_bits->ifp_cng = max_bits;
                     ing_cmprsd_pkt_attr_bits->ifp_cng_mask = (1 << max_bits)-1;
                     ing_cmprsd_pkt_attr_bits->ifp_cng_pos =  
                                               ing_pkt_attr_cmprsd_bits_g[unit].ifp_cng_pos;
                 }
                 if (map_array[bcmStatGroupModeAttrIntPri] != NULL) {
                     max_bits = int_pri_cmprsd_max_bits;
                     ing_cmprsd_pkt_attr_bits->int_pri = max_bits;
                     ing_cmprsd_pkt_attr_bits->int_pri_mask = (1 << max_bits)-1;
                     ing_cmprsd_pkt_attr_bits->int_pri_pos= ing_pkt_attr_cmprsd_bits_g[unit].
                                                            int_pri_pos;
                 }
                 invalid_map_value = (1 << (ing_pkt_attr_cmprsd_bits_g[unit].cng +
                         ing_pkt_attr_cmprsd_bits_g[unit].ifp_cng +
                         ing_pkt_attr_cmprsd_bits_g[unit].int_pri)) - 1;
                 for (index0 =0;
                      index0 < (1 << ing_pkt_attr_cmprsd_bits_g[unit].cng);
                      index0++ ) {
                     invalid_index0 = FALSE;
                     if (map_array[bcmStatGroupModeAttrColor] != NULL) {
                         if (map_array[bcmStatGroupModeAttrColor][index0] ==
                                 0xFF ) {
                             invalid_index0 = TRUE;
                         } else {
                             mapped_value0 = map_array
                                 [bcmStatGroupModeAttrColor][index0];
                         }
                     }
                     for (index1 =0;
                             index1 < (1 << ing_pkt_attr_cmprsd_bits_g[unit].ifp_cng);
                             index1++ ) {
                         invalid_index1 = FALSE;
                         if (map_array[bcmStatGroupModeAttrFieldIngressColor]
                                 != NULL) {
                             if (map_array
                                     [bcmStatGroupModeAttrFieldIngressColor]
                                     [index1] == 0xFF){
                                 invalid_index1 = TRUE;
                             } else {
                                 mapped_value1 = map_array
                                     [bcmStatGroupModeAttrFieldIngressColor]
                                     [index1];
                             }
                         }
                         for (index2 =0;
                                 index2 < (1 << ing_pkt_attr_cmprsd_bits_g[unit].int_pri);
                                 index2++ ) {
                             invalid_index2 = FALSE;
                             if (map_array[bcmStatGroupModeAttrIntPri]
                                     != NULL) {
                                 if (map_array
                                         [bcmStatGroupModeAttrIntPri][index2]
                                         == 0xFF){
                                     invalid_index2 = TRUE;
                                 } else {
                                     mapped_value2 = map_array
                                         [bcmStatGroupModeAttrIntPri]
                                         [index2];
                                 }
                             }
                             final_index =
                                 (index0 <<
                                  (ing_pkt_attr_cmprsd_bits_g[unit].ifp_cng +
                                   ing_pkt_attr_cmprsd_bits_g[unit].int_pri)) +
                                 (index1 <<
                                  (ing_pkt_attr_cmprsd_bits_g[unit].int_pri)) +
                                 (index2) ;
                             if (invalid_index0 || invalid_index1 ||
                                     invalid_index2) {
                                 final_mapped_value = invalid_map_value;
                             } else {
                                 final_mapped_value =
                                     (mapped_value0 << 
                                      (ing_pkt_attr_cmprsd_bits_g[unit].ifp_cng +
                                       ing_pkt_attr_cmprsd_bits_g[unit].int_pri)) +
                                     (mapped_value1 << 
                                      (ing_pkt_attr_cmprsd_bits_g[unit].int_pri)) +
                                     (mapped_value2) ;
                             }
                             ing_cmprsd_attr_selectors->pri_cnf_attr_map
                                 [final_index] = final_mapped_value;
                         }
                     }
                 }
            }
            if ((flex_attribute->vlan_format != 0) ||
                (flex_attribute->outer_dot1p != 0) ||
                (flex_attribute->inner_dot1p != 0)) {
                mapped_value0 = 0;
                mapped_value1 = 0;
                mapped_value2 = 0;
                max_bits=0;
                LOG_VERBOSE(BSL_LS_BCM_FLEXCTR,
                        (BSL_META_U(unit,
                                    "Ing: PKT_PRI_MAP Creation \n")));
                if (map_array[bcmStatGroupModeAttrVlan] != NULL) {
                    max_bits =  vlan_format_cmprsd_max_bits;
                    ing_cmprsd_pkt_attr_bits->vlan_format = max_bits;
                    ing_cmprsd_pkt_attr_bits->vlan_format_mask =
                        (1 << max_bits) - 1;
                    ing_cmprsd_pkt_attr_bits->vlan_format_pos =
                        ing_pkt_attr_cmprsd_bits_g[unit].
                        vlan_format_pos;
                }
                if (map_array[bcmStatGroupModeAttrOuterPri] != NULL) {
                    max_bits =  outer_dot1p_cmprsd_max_bits;
                    ing_cmprsd_pkt_attr_bits->outer_dot1p = max_bits;
                    ing_cmprsd_pkt_attr_bits->outer_dot1p_mask=(1<<max_bits)-1;
                    ing_cmprsd_pkt_attr_bits->outer_dot1p_pos =
                        ing_pkt_attr_cmprsd_bits_g[unit].outer_dot1p_pos;
                }
                if (map_array[bcmStatGroupModeAttrInnerPri] != NULL) {
                    max_bits = inner_dot1p_cmprsd_max_bits;
                    ing_cmprsd_pkt_attr_bits->inner_dot1p = max_bits;
                    ing_cmprsd_pkt_attr_bits->inner_dot1p_mask=(1<<max_bits)-1;
                    ing_cmprsd_pkt_attr_bits->inner_dot1p_pos=
                        ing_pkt_attr_cmprsd_bits_g[unit].inner_dot1p_pos;
                }
                invalid_map_value = (1 <<
                        (ing_pkt_attr_cmprsd_bits_g[unit].vlan_format +
                         ing_pkt_attr_cmprsd_bits_g[unit].outer_dot1p +
                         ing_pkt_attr_cmprsd_bits_g[unit].inner_dot1p)) - 1;
                for (index0 =0;
                     index0 < (1 << ing_pkt_attr_cmprsd_bits_g[unit].vlan_format);
                     index0++ ) {
                    invalid_index0 = FALSE;
                    if (map_array[bcmStatGroupModeAttrVlan] != NULL) {
                        if (map_array[bcmStatGroupModeAttrVlan][index0] ==
                                0xFF ) {
                            invalid_index0 = TRUE;
                        }
                        else {
                            mapped_value0 = map_array
                                [bcmStatGroupModeAttrVlan][index0];
                        }
                    }

                    for (index1 =0;
                         index1 < (1 << ing_pkt_attr_cmprsd_bits_g[unit].outer_dot1p);
                         index1++ ) {
                        invalid_index1 = FALSE;
                        if (map_array[bcmStatGroupModeAttrOuterPri]
                                != NULL) {
                            if (map_array
                                    [bcmStatGroupModeAttrOuterPri]
                                    [index1] == 0xFF){
                                invalid_index1 = TRUE;
                            } else {
                                mapped_value1 = map_array
                                    [bcmStatGroupModeAttrOuterPri]
                                    [index1];
                            }
                        }
                        for (index2 =0;
                             index2 < (1 << ing_pkt_attr_cmprsd_bits_g[unit].inner_dot1p);
                             index2++ ) {
                            invalid_index2 = FALSE;
                            if (map_array[bcmStatGroupModeAttrInnerPri]
                                    != NULL) {
                                if (map_array
                                        [bcmStatGroupModeAttrInnerPri][index2]
                                        == 0xFF){
                                    invalid_index2 = TRUE;
                                } else {
                                    mapped_value2 = map_array
                                        [bcmStatGroupModeAttrInnerPri]
                                        [index2];
                                }
                            }
                            final_index =
                                (index0 <<
                                 (ing_pkt_attr_cmprsd_bits_g[unit].outer_dot1p +
                                  ing_pkt_attr_cmprsd_bits_g[unit].inner_dot1p)) +
                                (index1 <<
                                 (ing_pkt_attr_cmprsd_bits_g[unit].inner_dot1p)) +
                                (index2) ;
                            if (invalid_index0 || invalid_index1 ||
                                    invalid_index2) {
                                final_mapped_value = invalid_map_value;
                            } else {
                                final_mapped_value =
                                    (mapped_value0 <<
                                     (ing_pkt_attr_cmprsd_bits_g[unit].outer_dot1p +
                                      ing_pkt_attr_cmprsd_bits_g[unit].inner_dot1p)) +
                                    (mapped_value1 <<
                                     (ing_pkt_attr_cmprsd_bits_g[unit].inner_dot1p)) +
                                    (mapped_value2) ;
                            }
                            ing_cmprsd_attr_selectors->pkt_pri_attr_map
                                [final_index] = final_mapped_value;
                        }
                    }
                }
            }
            if ((flex_attribute->port != 0) || (flex_attribute->subport != 0)) {
                mapped_value0 = 0;
                max_bits=0;
                LOG_VERBOSE(BSL_LS_BCM_FLEXCTR,
                        (BSL_META_U(unit,
                                    "Ing: PORT_MAP Creation \n")));
                if (map_array[bcmStatGroupModeAttrPort] != NULL) {
                    max_bits =  port_cmprsd_max_bits;
                    ing_cmprsd_pkt_attr_bits->ing_port = max_bits;
                    ing_cmprsd_pkt_attr_bits->ing_port_mask =
                        (1 << max_bits) - 1;
                    ing_cmprsd_pkt_attr_bits->ing_port_pos =
                        ing_pkt_attr_cmprsd_bits_g[unit].ing_port_pos;
                }
                max_count = (1 << ing_pkt_attr_cmprsd_bits_g[unit].ing_port);
                for (index0 =0;
                     index0 < max_count;
                     index0++ ) {
                    invalid_index0 = FALSE;
                    if (map_array[bcmStatGroupModeAttrPort] != NULL) {
                        if (map_array[bcmStatGroupModeAttrPort][index0] ==
                                0xFF ) {
                            invalid_index0 = TRUE;
                        }
                        else {
                            mapped_value0 = map_array
                                [bcmStatGroupModeAttrPort][index0];
                        }
                    }
                    final_index = index0 ;
                    if (invalid_index0) {
                        final_mapped_value = ing_cmprsd_pkt_attr_bits->ing_port_mask;
                    } else {

                        final_mapped_value = mapped_value0 ;
                    }
                    ing_cmprsd_attr_selectors->port_attr_map[final_index] =
                        final_mapped_value;
                }
            }
            if ((flex_attribute->tos_dscp != 0) ||
                (flex_attribute->tos_ecn != 0)) {
                mapped_value0 = 0;
                mapped_value1 = 0;
                max_bits=0;
                LOG_VERBOSE(BSL_LS_BCM_FLEXCTR,
                        (BSL_META_U(unit,
                                    "Ing: TOS_MAP Creation \n")));
                if (map_array[bcmStatGroupModeAttrTosDscp] != NULL) {
                    max_bits =  tos_dscp_cmprsd_max_bits;
                    ing_cmprsd_pkt_attr_bits->tos_dscp = max_bits;
                    ing_cmprsd_pkt_attr_bits->tos_dscp_mask =
                        (1 << max_bits) - 1;
                    ing_cmprsd_pkt_attr_bits->tos_dscp_pos =
                        ing_pkt_attr_cmprsd_bits_g[unit].tos_dscp_pos;
                }
                if (map_array[bcmStatGroupModeAttrTosEcn] != NULL) {
                    max_bits =  tos_ecn_cmprsd_max_bits;
                    ing_cmprsd_pkt_attr_bits->tos_ecn = max_bits;
                    ing_cmprsd_pkt_attr_bits->tos_ecn_mask =
                        (1 << max_bits) - 1;
                    ing_cmprsd_pkt_attr_bits->tos_ecn_pos =
                        ing_pkt_attr_cmprsd_bits_g[unit].tos_ecn_pos;
                }
                invalid_map_value =  (1 <<
                        (ing_pkt_attr_cmprsd_bits_g[unit].tos_dscp +
                        ing_pkt_attr_cmprsd_bits_g[unit].tos_ecn)) - 1;
                for (index0 =0;
                     index0 < (1 << ing_pkt_attr_cmprsd_bits_g[unit].tos_dscp);
                     index0++ ) {
                    invalid_index0 = FALSE;
                    if (map_array[bcmStatGroupModeAttrTosDscp] != NULL) {
                        if (map_array[bcmStatGroupModeAttrTosDscp][index0] ==
                                0xFF ) {
                            invalid_index0 = TRUE;
                        } else {
                            mapped_value0 = map_array
                                [bcmStatGroupModeAttrTosDscp][index0];
                        }
                    }
                    for (index1 =0;
                         index1 < (1 << ing_pkt_attr_cmprsd_bits_g[unit].tos_ecn);
                         index1++ ) {
                        invalid_index1 = FALSE;
                        if (map_array[bcmStatGroupModeAttrTosEcn] != NULL) {
                            if (map_array[bcmStatGroupModeAttrTosEcn]
                                    [index1] == 0xFF ) {
                                invalid_index1 = TRUE;
                            } else {
                                mapped_value1 = map_array
                                    [bcmStatGroupModeAttrTosEcn][index1];
                            }
                        }
                        final_index = (index0 <<
                                ing_pkt_attr_cmprsd_bits_g[unit].tos_ecn) +
                            index1;
                        if (invalid_index0 || invalid_index1) {
                            final_mapped_value = invalid_map_value;
                        } else {
                            final_mapped_value = (mapped_value0 <<
                                    ing_pkt_attr_cmprsd_bits_g[unit].tos_ecn) +
                                mapped_value1;
                        }
                        ing_cmprsd_attr_selectors->tos_attr_map[final_index] =
                            final_mapped_value;
                    }
                }
            }
            if ((flex_attribute->pkt_resolution != 0) ||
                (flex_attribute->svp != 0) || 
                (flex_attribute->drop != 0)) {
                mapped_value0 = 0;
                mapped_value1 = 0;
                mapped_value2 = 0;
                max_bits=0;
                LOG_VERBOSE(BSL_LS_BCM_FLEXCTR,
                        (BSL_META_U(unit,
                                    "Ing: PKT_RES_MAP Creation \n")));
#ifdef BCM_KATANA2_SUPPORT
                if soc_feature(unit, soc_feature_flex_stat_attributes_class) {
                    if (map_array[bcmStatGroupModeAttrClassType] != NULL) {
                        max_bits =  pkt_resolution_cmprsd_max_bits;
                        ing_cmprsd_pkt_attr_bits->pkt_resolution = max_bits;
                        ing_cmprsd_pkt_attr_bits->pkt_resolution_mask =
                            (1 << max_bits) - 1;
                        ing_cmprsd_pkt_attr_bits->pkt_resolution_pos =
                            ing_pkt_attr_cmprsd_bits_g[unit].
                            pkt_resolution_pos;
                    }
                } else
#endif
                {
                    if (map_array[bcmStatGroupModeAttrPktType] != NULL) {
                        max_bits =  pkt_resolution_cmprsd_max_bits;
                        ing_cmprsd_pkt_attr_bits->pkt_resolution = max_bits;
                        ing_cmprsd_pkt_attr_bits->pkt_resolution_mask =
                            (1 << max_bits) - 1;
                        ing_cmprsd_pkt_attr_bits->pkt_resolution_pos =
                            ing_pkt_attr_cmprsd_bits_g[unit].
                            pkt_resolution_pos;
                    }
                }
                if (map_array[bcmStatGroupModeAttrIngNetworkGroup] != NULL) {
                    max_bits =  svp_cmprsd_max_bits;
                    ing_cmprsd_pkt_attr_bits->svp_type = max_bits;
                    ing_cmprsd_pkt_attr_bits->svp_type_mask=(1<<max_bits)-1;
                    ing_cmprsd_pkt_attr_bits->svp_type_pos =
                        ing_pkt_attr_cmprsd_bits_g[unit].svp_type_pos;
                }
                if (map_array[bcmStatGroupModeAttrDrop] != NULL) {
                    max_bits = drop_cmprsd_max_bits;
                    ing_cmprsd_pkt_attr_bits->drop = max_bits;
                    ing_cmprsd_pkt_attr_bits->drop_mask=(1<<max_bits)-1;
                    ing_cmprsd_pkt_attr_bits->drop_pos=
                        ing_pkt_attr_cmprsd_bits_g[unit].drop_pos;
                }
                invalid_map_value = (1 <<
                    (ing_pkt_attr_cmprsd_bits_g[unit].pkt_resolution +
                     ing_pkt_attr_cmprsd_bits_g[unit].svp_type +
                     ing_pkt_attr_cmprsd_bits_g[unit].drop)) - 1;

                /*
                 * map_array of pkt_resolution is filled based on bit position
                 * of corresponding pkt_type in hw. And hence, they are not
                 * sequential like map_array of other attributes. Use number of
                 * bits in uncompressed mode to cover all position bit position.
                 */
                for (index0 =0;
                     index0 < (1 << ing_pkt_attr_uncmprsd_bits_g[unit].pkt_resolution);
                     index0++ ) {
                    invalid_index0 = FALSE;
#ifdef BCM_KATANA2_SUPPORT
                    if (soc_feature(unit, soc_feature_flex_stat_attributes_class)) {
                        if (map_array[bcmStatGroupModeAttrClassType] != NULL) {
                            if (map_array[bcmStatGroupModeAttrClassType][index0] ==
                                    0xFF ) {
                                invalid_index0 = TRUE;
                            } else {
                                mapped_value0 = map_array
                                    [bcmStatGroupModeAttrClassType][index0];
                            }
                        }
                    } else
#endif
                    {
                        if (map_array[bcmStatGroupModeAttrPktType] != NULL) {
                            if (map_array[bcmStatGroupModeAttrPktType][index0] ==
                                    0xFF ) {
                                invalid_index0 = TRUE;
                            } else {
                                mapped_value0 = map_array
                                    [bcmStatGroupModeAttrPktType][index0];
                            }
                        }
                    }
                    for (index1 =0;
                         index1 < (1 << ing_pkt_attr_cmprsd_bits_g[unit].svp_type);
                         index1++ ) {
                        invalid_index1 = FALSE;
                        if (map_array[bcmStatGroupModeAttrIngNetworkGroup]
                                != NULL) {
                            if (map_array
                                    [bcmStatGroupModeAttrIngNetworkGroup]
                                    [index1] == 0xFF){
                                invalid_index1 = TRUE;
                            } else {
                                mapped_value1 = map_array
                                    [bcmStatGroupModeAttrIngNetworkGroup]
                                    [index1];
                            }
                        }
                        for (index2 =0;
                             index2 < (1 << ing_pkt_attr_cmprsd_bits_g[unit].drop);
                             index2++ ) {
                            invalid_index2 = FALSE;
                            if (map_array[bcmStatGroupModeAttrDrop]
                                    != NULL) {
                                if (map_array
                                        [bcmStatGroupModeAttrDrop][index2]
                                        == 0xFF){
                                    invalid_index2 = TRUE;
                                } else {
                                    mapped_value2 = map_array
                                        [bcmStatGroupModeAttrDrop]
                                        [index2];
                                }
                            }
                            final_index =
                                (index0 <<
                                 (ing_pkt_attr_cmprsd_bits_g[unit].svp_type +
                                  ing_pkt_attr_cmprsd_bits_g[unit].drop)) +
                                (index1 <<
                                 (ing_pkt_attr_cmprsd_bits_g[unit].drop)) +
                                (index2) ;
                            if (invalid_index0 || invalid_index1 || invalid_index2) {
                                final_mapped_value = invalid_map_value;
                            } else {
                                final_mapped_value =
                                    (mapped_value0 <<
                                     (ing_pkt_attr_cmprsd_bits_g[unit].svp_type +
                                      ing_pkt_attr_cmprsd_bits_g[unit].drop)) +
                                    (mapped_value1 <<
                                     (ing_pkt_attr_cmprsd_bits_g[unit].drop)) +
                                    (mapped_value2) ;
                            }
                            ing_cmprsd_attr_selectors->pkt_res_attr_map
                                [final_index] = final_mapped_value;
                        }
                    }
                }
            }
            if (flex_attribute->ip_pkt != 0) {
                max_bits=0;
                LOG_VERBOSE(BSL_LS_BCM_FLEXCTR,
                        (BSL_META_U(unit,
                                    "Ing: ip packet Creation \n")));
                if (map_array[bcmStatGroupModeAttrPacketTypeIp] != NULL) {
                    max_bits =  ip_pkt_cmprsd_max_bits;
                    ing_cmprsd_pkt_attr_bits->ip_pkt= max_bits;
                    ing_cmprsd_pkt_attr_bits->ip_pkt_mask =
                        (1 << max_bits) - 1;
                    ing_cmprsd_pkt_attr_bits->ip_pkt_pos =
                        ing_pkt_attr_cmprsd_bits_g[unit].ip_pkt_pos;
                }
            }
            break;
        case bcmStatFlexDirectionEgress:
            mapped_value0 = 0;
            mapped_value1 = 0;
            mapped_value2 = 0;
            max_bits=0;
#ifdef BCM_APACHE_SUPPORT
            if (soc_feature(unit,soc_feature_flex_ctr_mpls_3_label_count)) {
                max_bits = 0;
                if ((flex_attribute->cng_3 != 0) &&
                        (map_array[bcmStatGroupModeAttrColorMplsLabelThird] != NULL)) {
                    max_bits =  pre_ifp_cng_mpls_3_cmprsd_max_bits;
                    egr_cmprsd_pkt_attr_bits->cng_3 = max_bits;
                    egr_cmprsd_pkt_attr_bits->cng_3_mask = (1 << max_bits) - 1;
                    egr_cmprsd_pkt_attr_bits->cng_3_pos = egr_pkt_attr_cmprsd_bits_g[unit].
                        cng_3_pos;
                }
                if ((flex_attribute->phb_3 != 0) &&
                        (map_array[bcmStatGroupModeAttrIntPriMplsLabelThird] != NULL)) {
                    max_bits =  int_pri_mpls_3_cmprsd_max_bits;
                    egr_cmprsd_pkt_attr_bits->phb_3 = max_bits;
                    egr_cmprsd_pkt_attr_bits->phb_3_mask = (1 << max_bits) - 1;
                    egr_cmprsd_pkt_attr_bits->phb_3_pos = egr_pkt_attr_cmprsd_bits_g[unit].
                        phb_3_pos;

                }
                if ((flex_attribute->cng_2 != 0) &&
                        (map_array[bcmStatGroupModeAttrColorMplsLabelSecond] != NULL)) {
                    max_bits =  pre_ifp_cng_mpls_2_cmprsd_max_bits;
                    egr_cmprsd_pkt_attr_bits->cng_2 = max_bits;
                    egr_cmprsd_pkt_attr_bits->cng_2_mask = (1 << max_bits) - 1;
                    egr_cmprsd_pkt_attr_bits->cng_2_pos = egr_pkt_attr_cmprsd_bits_g[unit].
                        cng_2_pos;
                }
                if ((flex_attribute->phb_2 != 0) &&
                        (map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond] != NULL)) {
                    max_bits =  int_pri_mpls_2_cmprsd_max_bits;
                    egr_cmprsd_pkt_attr_bits->phb_2 = max_bits;
                    egr_cmprsd_pkt_attr_bits->phb_2_mask = (1 << max_bits) - 1;
                    egr_cmprsd_pkt_attr_bits->phb_2_pos = egr_pkt_attr_cmprsd_bits_g[unit].
                        phb_2_pos;

                }
                if ((flex_attribute->cng_1 != 0) &&
                        (map_array[bcmStatGroupModeAttrColorMplsLabelFirst] != NULL)) {
                    max_bits =  pre_ifp_cng_mpls_1_cmprsd_max_bits;
                    egr_cmprsd_pkt_attr_bits->cng_1 = max_bits;
                    egr_cmprsd_pkt_attr_bits->cng_1_mask = (1 << max_bits) - 1;
                    egr_cmprsd_pkt_attr_bits->cng_1_pos = egr_pkt_attr_cmprsd_bits_g[unit].
                        cng_1_pos;
                }
                if ((flex_attribute->phb_1 != 0) &&
                        (map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst] != NULL)) {
                    max_bits =  int_pri_mpls_1_cmprsd_max_bits;
                    egr_cmprsd_pkt_attr_bits->phb_1 = max_bits;
                    egr_cmprsd_pkt_attr_bits->phb_1_mask = (1 << max_bits) - 1;
                    egr_cmprsd_pkt_attr_bits->phb_1_pos = egr_pkt_attr_cmprsd_bits_g[unit].
                        phb_1_pos;

                }
            }
#endif
#if defined(BCM_TOMAHAWK_SUPPORT) || defined(BCM_TRIDENT3_SUPPORT)
            if (soc_feature(unit, soc_feature_flex_stat_egr_queue_congestion_marked)) {
                if ((flex_attribute->mmu_cos != 0) ||
                    (flex_attribute->uc_queueing != 0)) {
                    LOG_VERBOSE(BSL_LS_BCM_FLEXCTR,
                                (BSL_META_U(unit,
                                            "Egr: COS_MAP Creation \n")));
                    max_bits = 0;
                    if (map_array[bcmStatGroupModeAttrCos] != NULL) {
                        max_bits =  mmu_cos_cmprsd_max_bits;
                        egr_cmprsd_pkt_attr_bits->mmu_cos = max_bits;
                        egr_cmprsd_pkt_attr_bits->mmu_cos_mask = (1 << max_bits) - 1;
                        egr_cmprsd_pkt_attr_bits->mmu_cos_pos = egr_pkt_attr_cmprsd_bits_g[unit].
                            mmu_cos_pos;
                    }
                    if (map_array[bcmStatGroupModeAttrQueueType] != NULL) {
                        max_bits =  uc_queueing_cmprsd_max_bits;
                        egr_cmprsd_pkt_attr_bits->uc_queueing = max_bits;
                        egr_cmprsd_pkt_attr_bits->uc_queueing_mask = (1 << max_bits) - 1;
                        egr_cmprsd_pkt_attr_bits->uc_queueing_pos = egr_pkt_attr_cmprsd_bits_g[unit].
                            uc_queueing_pos;

                    }

                     invalid_map_value = (1 << (egr_pkt_attr_cmprsd_bits_g[unit].mmu_cos +
                         egr_pkt_attr_cmprsd_bits_g[unit].uc_queueing)) - 1;
                     for (index0 = 0;
                          index0 < (1 << egr_pkt_attr_cmprsd_bits_g[unit].mmu_cos);
                          index0++ ) {
                          invalid_index0 = FALSE;
                         if (map_array[bcmStatGroupModeAttrCos] != NULL) {
                             if (map_array[bcmStatGroupModeAttrCos][index0] ==
                                     0xFF) {
                                 invalid_index0 = TRUE;
                             } else {
                                 mapped_value0 = map_array
                                     [bcmStatGroupModeAttrCos]
                                     [index0];
                             }
                         }
                         for (index1 = 0;
                              index1 < (1 << egr_pkt_attr_cmprsd_bits_g[unit].uc_queueing);
                              index1++ ) {
                             invalid_index1 = FALSE;
                             if (map_array[bcmStatGroupModeAttrQueueType] != NULL) {
                                 if (map_array[bcmStatGroupModeAttrQueueType]
                                         [index1] == 0xFF){
                                 invalid_index1 = TRUE;
                                 } else {
                                     mapped_value1 = map_array
                                         [bcmStatGroupModeAttrQueueType]
                                         [index1];
                                 }
                             }
                             final_index =
                                 (index0 <<
                                  (egr_pkt_attr_cmprsd_bits_g[unit].uc_queueing)) +
                                 (index1) ;
                             if (invalid_index0 || invalid_index1) {
                                 final_mapped_value = invalid_map_value;
                             } else {
                                 final_mapped_value =
                                     (mapped_value0 <<
                                      (egr_pkt_attr_cmprsd_bits_g[unit].uc_queueing)) +
                                     (mapped_value1) ;
                             }
                             egr_cmprsd_attr_selectors->cos_uc_attr_map
                                 [final_index] = final_mapped_value;
                         }
                    }
                }
               if (flex_attribute->congestion_marked != 0) {
                    max_bits = 0;
                    LOG_VERBOSE(BSL_LS_BCM_FLEXCTR,
                                (BSL_META_U(unit,
                                            "Egr: congestion marked Creation \n")));
                    if (map_array[bcmStatGroupModeAttrCongestionMarked] != NULL) {
                        max_bits = congestion_marked_cmprsd_max_bits;
                        egr_cmprsd_pkt_attr_bits->congestion_marked = max_bits;
                        egr_cmprsd_pkt_attr_bits->congestion_marked_mask =
                                                  (1 << max_bits) - 1;
                        egr_cmprsd_pkt_attr_bits->congestion_marked_pos =
                                                  egr_pkt_attr_cmprsd_bits_g[unit].congestion_marked_pos;
                    }
                }
            }
#endif

            if ((flex_attribute->pre_ifp_color != 0) ||
                (flex_attribute->int_pri != 0)) {
                LOG_VERBOSE(BSL_LS_BCM_FLEXCTR,
                        (BSL_META_U(unit,
                                    "Egr: PRI_CNG_MAP Creation \n")));
                if (map_array[bcmStatGroupModeAttrColor] != NULL) {
                    max_bits =  pre_ifp_cng_cmprsd_max_bits;
                    egr_cmprsd_pkt_attr_bits->cng = max_bits;
                    egr_cmprsd_pkt_attr_bits->cng_mask = (1 << max_bits) - 1;
                    egr_cmprsd_pkt_attr_bits->cng_pos = egr_pkt_attr_cmprsd_bits_g[unit].
                        cng_pos;
                }
                if (map_array[bcmStatGroupModeAttrIntPri] != NULL) {
                    max_bits = int_pri_cmprsd_max_bits;
                    egr_cmprsd_pkt_attr_bits->int_pri = max_bits;
                    egr_cmprsd_pkt_attr_bits->int_pri_mask=(1 << max_bits) - 1;
                    egr_cmprsd_pkt_attr_bits->int_pri_pos= egr_pkt_attr_cmprsd_bits_g[unit].
                        int_pri_pos;
                }
                invalid_map_value = (1 << (egr_pkt_attr_cmprsd_bits_g[unit].cng +
                    egr_pkt_attr_cmprsd_bits_g[unit].int_pri)) - 1;
                for (index0 =0;
                     index0 < (1 << egr_pkt_attr_cmprsd_bits_g[unit].cng);
                     index0++ ) {
                     invalid_index0 = FALSE;
                    if (map_array[bcmStatGroupModeAttrColor] != NULL) {
                        if (map_array[bcmStatGroupModeAttrColor][index0] ==
                                0xFF) {
                            invalid_index0 = TRUE;
                        } else {
                            mapped_value0 = map_array
                                [bcmStatGroupModeAttrColor]
                                [index0];
                        }
                    }
                    for (index1 =0;
                         index1 < (1 << egr_pkt_attr_cmprsd_bits_g[unit].int_pri);
                         index1++ ) {
                        invalid_index1 = FALSE;
                        if (map_array[bcmStatGroupModeAttrIntPri] != NULL) {
                            if (map_array[bcmStatGroupModeAttrIntPri]
                                    [index1] == 0xFF){
                            invalid_index1 = TRUE;
                            } else {
                                mapped_value1 = map_array
                                    [bcmStatGroupModeAttrIntPri]
                                    [index1];
                            }
                        }
                        final_index =
                            (index0 <<
                             (egr_pkt_attr_cmprsd_bits_g[unit].int_pri)) +
                            (index1) ;
                        if (invalid_index0 || invalid_index1) {
                            final_mapped_value = invalid_map_value;
                        } else {
                            final_mapped_value =
                                (mapped_value0 <<
                                 (egr_pkt_attr_cmprsd_bits_g[unit].int_pri)) +
                                (mapped_value1) ;
                        }
                        egr_cmprsd_attr_selectors->pri_cnf_attr_map
                            [final_index] = final_mapped_value;
                    }
               }
            }
            if ((flex_attribute->vlan_format != 0) ||
                (flex_attribute->outer_dot1p != 0) ||
                (flex_attribute->inner_dot1p != 0)) {
                mapped_value0 = 0;
                mapped_value1 = 0;
                mapped_value2 = 0;
                max_bits=0;
                LOG_VERBOSE(BSL_LS_BCM_FLEXCTR,
                        (BSL_META_U(unit,
                                    "Egr: PKT_PRI_MAP Creation \n")));
                if (map_array[bcmStatGroupModeAttrVlan] != NULL) {
                    max_bits =  vlan_format_cmprsd_max_bits;
                    egr_cmprsd_pkt_attr_bits->vlan_format = max_bits;
                    egr_cmprsd_pkt_attr_bits->vlan_format_mask =
                        (1 << max_bits) - 1;
                    egr_cmprsd_pkt_attr_bits->vlan_format_pos =
                        egr_pkt_attr_cmprsd_bits_g[unit].
                        vlan_format_pos;
                }
                if (map_array[bcmStatGroupModeAttrOuterPri] != NULL) {
                    max_bits =  outer_dot1p_cmprsd_max_bits;
                    egr_cmprsd_pkt_attr_bits->outer_dot1p = max_bits;
                    egr_cmprsd_pkt_attr_bits->outer_dot1p_mask=(1<<max_bits)-1;
                    egr_cmprsd_pkt_attr_bits->outer_dot1p_pos =
                        egr_pkt_attr_cmprsd_bits_g[unit].outer_dot1p_pos;
                }
                if (map_array[bcmStatGroupModeAttrInnerPri] != NULL) {
                    max_bits = inner_dot1p_cmprsd_max_bits;
                    egr_cmprsd_pkt_attr_bits->inner_dot1p = max_bits;
                    egr_cmprsd_pkt_attr_bits->inner_dot1p_mask=(1<<max_bits)-1;
                    egr_cmprsd_pkt_attr_bits->inner_dot1p_pos=
                        egr_pkt_attr_cmprsd_bits_g[unit].inner_dot1p_pos;
                }
                invalid_map_value = (1 <<
                        (egr_pkt_attr_cmprsd_bits_g[unit].vlan_format +
                         egr_pkt_attr_cmprsd_bits_g[unit].outer_dot1p +
                         egr_pkt_attr_cmprsd_bits_g[unit].inner_dot1p)) - 1;
               for (index0 =0;
                     index0 < (1 << egr_pkt_attr_cmprsd_bits_g[unit].vlan_format);
                     index0++ ) {
                    invalid_index0 = FALSE;
                    if (map_array[bcmStatGroupModeAttrVlan] != NULL) {
                        if (map_array[bcmStatGroupModeAttrVlan][index0] ==
                                0xFF ) {
                            invalid_index0 = TRUE;
                        } else {
                            mapped_value0 = map_array
                                [bcmStatGroupModeAttrVlan][index0];
                        }
                    }
                    for (index1 =0;
                         index1 < (1 << egr_pkt_attr_cmprsd_bits_g[unit].outer_dot1p);
                         index1++ ) {
                        invalid_index1 = FALSE;
                        if (map_array[bcmStatGroupModeAttrOuterPri]
                                != NULL) {
                            if (map_array
                                    [bcmStatGroupModeAttrOuterPri]
                                    [index1] == 0xFF){
                                invalid_index1 = TRUE;
                            } else {
                                mapped_value1 = map_array
                                    [bcmStatGroupModeAttrOuterPri]
                                    [index1];
                            }
                        }
                        for (index2 =0;
                             index2 < (1 << egr_pkt_attr_cmprsd_bits_g[unit].inner_dot1p);
                             index2++ ) {
                            invalid_index2 = FALSE;
                            if (map_array[bcmStatGroupModeAttrInnerPri]
                                    != NULL) {
                                if (map_array
                                        [bcmStatGroupModeAttrInnerPri][index2]
                                        == 0xFF){
                                    invalid_index2 = TRUE;
                                    mapped_value2 = map_array
                                        [bcmStatGroupModeAttrInnerPri]
                                        [256];
                                } else {
                                    mapped_value2 = map_array
                                        [bcmStatGroupModeAttrInnerPri]
                                        [index2];
                                }
                            }
                            final_index =
                                (index0 <<
                                 (egr_pkt_attr_cmprsd_bits_g[unit].outer_dot1p +
                                  egr_pkt_attr_cmprsd_bits_g[unit].inner_dot1p)) +
                                (index1 <<
                                 (egr_pkt_attr_cmprsd_bits_g[unit].inner_dot1p)) +
                                (index2) ;
                            if (invalid_index0 || invalid_index1 ||
                                    invalid_index2) {
                                final_mapped_value = invalid_map_value;
                            } else {
                                final_mapped_value =
                                    (mapped_value0 <<
                                     (egr_pkt_attr_cmprsd_bits_g[unit].outer_dot1p +
                                      egr_pkt_attr_cmprsd_bits_g[unit].inner_dot1p)) +
                                    (mapped_value1 <<
                                     (egr_pkt_attr_cmprsd_bits_g[unit].inner_dot1p)) +
                                    (mapped_value2) ;
                            }
                            egr_cmprsd_attr_selectors->pkt_pri_attr_map
                                [final_index] = final_mapped_value;
                        }
                    }
                }
            }
            if ((flex_attribute->port != 0) ||(flex_attribute->subport != 0)) {
                mapped_value0 = 0;
                max_bits=0;
                LOG_VERBOSE(BSL_LS_BCM_FLEXCTR,
                        (BSL_META_U(unit,
                                    "Egr: PORT_MAP Creation \n")));
                if (map_array[bcmStatGroupModeAttrPort] != NULL) {
                    max_bits =  port_cmprsd_max_bits;
                    egr_cmprsd_pkt_attr_bits->egr_port = max_bits;
                    egr_cmprsd_pkt_attr_bits->egr_port_mask =
                        (1 << max_bits) - 1;
                    egr_cmprsd_pkt_attr_bits->egr_port_pos =
                        egr_pkt_attr_cmprsd_bits_g[unit].egr_port_pos;
                }
                for (index0 =0;
                     index0 < (1 << egr_pkt_attr_cmprsd_bits_g[unit].egr_port);
                     index0++ ) {
                    invalid_index0 = FALSE;
                    if (map_array[bcmStatGroupModeAttrPort] != NULL) {
                        if (map_array[bcmStatGroupModeAttrPort][index0] ==
                                0xFF ) {
                            invalid_index0 = TRUE;
                        } else {
                            mapped_value0 = map_array
                                [bcmStatGroupModeAttrPort][index0];
                        }
                    }
                    final_index = index0 ;
                    if (invalid_index0) {
                        final_mapped_value = egr_cmprsd_pkt_attr_bits->egr_port_mask;
                    } else {
                        final_mapped_value = mapped_value0 ;
                    }
                    egr_cmprsd_attr_selectors->port_attr_map[final_index] =
                        final_mapped_value;
                }
            }
            if ((flex_attribute->tos_dscp != 0) ||
                (flex_attribute->tos_ecn != 0)) {
                mapped_value0 = 0;
                mapped_value1 = 0;
                max_bits=0;
                LOG_VERBOSE(BSL_LS_BCM_FLEXCTR,
                        (BSL_META_U(unit,
                                    "Egr: TOS_MAP Creation \n")));
                if (map_array[bcmStatGroupModeAttrTosDscp] != NULL) {
                    max_bits =  tos_dscp_cmprsd_max_bits;
                    egr_cmprsd_pkt_attr_bits->tos_dscp = max_bits;
                    egr_cmprsd_pkt_attr_bits->tos_dscp_mask =
                        (1 << max_bits) - 1;
                    egr_cmprsd_pkt_attr_bits->tos_dscp_pos =
                        egr_pkt_attr_cmprsd_bits_g[unit].tos_dscp_pos;
                }
                if (map_array[bcmStatGroupModeAttrTosEcn] != NULL) {
                    max_bits =  tos_ecn_cmprsd_max_bits;
                    egr_cmprsd_pkt_attr_bits->tos_ecn = max_bits;
                    egr_cmprsd_pkt_attr_bits->tos_ecn_mask =
                        (1 << max_bits) - 1;
                    egr_cmprsd_pkt_attr_bits->tos_ecn_pos =
                        egr_pkt_attr_cmprsd_bits_g[unit].tos_ecn_pos;
                }
                invalid_map_value = (1 <<
                        (egr_pkt_attr_cmprsd_bits_g[unit].tos_dscp +
                        egr_pkt_attr_cmprsd_bits_g[unit].tos_ecn)) - 1;
                for (index0 =0;
                     index0 < (1 << egr_pkt_attr_cmprsd_bits_g[unit].tos_dscp);
                     index0++ ) {
                    invalid_index0 = FALSE;
                    if (map_array[bcmStatGroupModeAttrTosDscp] != NULL) {
                        if (map_array[bcmStatGroupModeAttrTosDscp][index0] ==
                                0xFF ) {
                            invalid_index0 = TRUE;
                        } else {
                            mapped_value0 = map_array
                                [bcmStatGroupModeAttrTosDscp][index0];
                        }
                        for (index1 =0;
                             index1 < (1 << egr_pkt_attr_cmprsd_bits_g[unit].tos_ecn);
                             index1++ ) {
                            invalid_index1 = FALSE;
                            if (map_array[bcmStatGroupModeAttrTosEcn] != NULL) {
                                if (map_array[bcmStatGroupModeAttrTosEcn]
                                        [index1] == 0xFF ) {
                                    invalid_index1 = TRUE;
                                } else {
                                    mapped_value1 = map_array
                                        [bcmStatGroupModeAttrTosEcn][index1];
                                }
                            }
                            final_index = (index0 <<
                                    egr_pkt_attr_cmprsd_bits_g[unit].tos_ecn) +
                                index1;
                            if (invalid_index0 || invalid_index1) {
                                final_mapped_value = invalid_map_value;
                            } else {
                                final_mapped_value = (mapped_value0 <<
                                        egr_pkt_attr_cmprsd_bits_g[unit].tos_ecn) +
                                    mapped_value1;
                            }
                            egr_cmprsd_attr_selectors->tos_attr_map[final_index] =
                                final_mapped_value;
                        }
                    }
                }
            }
            if ((flex_attribute->pkt_resolution != 0) ||
                (flex_attribute->svp != 0) || 
                (flex_attribute->dvp != 0) || 
                (flex_attribute->drop != 0)) {
                uint8 tmp_svp_type = egr_pkt_attr_cmprsd_bits_g[unit].svp_type;
                uint8 tmp_dvp_type = egr_pkt_attr_cmprsd_bits_g[unit].dvp_type;
                mapped_value0 = 0;
                mapped_value1 = 0;
                mapped_value2 = 0;
                mapped_value3 = 0;
                max_bits=0;
                LOG_VERBOSE(BSL_LS_BCM_FLEXCTR,
                        (BSL_META_U(unit,
                                    "Egr: PKT_RES_MAP Creation \n")));
#ifdef BCM_KATANA2_SUPPORT
                if soc_feature(unit, soc_feature_flex_stat_attributes_class) {
                    if (map_array[bcmStatGroupModeAttrClassType] != NULL) {
                        max_bits =  pkt_resolution_cmprsd_max_bits;
                        egr_cmprsd_pkt_attr_bits->pkt_resolution = max_bits;
                        egr_cmprsd_pkt_attr_bits->pkt_resolution_mask =
                            (1 << max_bits) - 1;
                        egr_cmprsd_pkt_attr_bits->pkt_resolution_pos =
                            egr_pkt_attr_cmprsd_bits_g[unit].
                            pkt_resolution_pos;
                    }
                } else
#endif
                {
                    if (map_array[bcmStatGroupModeAttrPktType] != NULL) {
                        max_bits =  pkt_resolution_cmprsd_max_bits;
                        egr_cmprsd_pkt_attr_bits->pkt_resolution = max_bits;
                        egr_cmprsd_pkt_attr_bits->pkt_resolution_mask =
                            (1 << max_bits) - 1;
                        egr_cmprsd_pkt_attr_bits->pkt_resolution_pos =
                            egr_pkt_attr_cmprsd_bits_g[unit].
                            pkt_resolution_pos;
                    }
                }
                if (map_array[bcmStatGroupModeAttrIngNetworkGroup] != NULL) {
                    max_bits =  svp_cmprsd_max_bits;
                    egr_cmprsd_pkt_attr_bits->svp_type = max_bits;
                    egr_cmprsd_pkt_attr_bits->svp_type_mask=(1<<max_bits)-1;
                    egr_cmprsd_pkt_attr_bits->svp_type_pos =
                        egr_pkt_attr_cmprsd_bits_g[unit].svp_type_pos;
                }
                if (map_array[bcmStatGroupModeAttrEgrNetworkGroup] != NULL) {
                    max_bits =  dvp_cmprsd_max_bits;
                    egr_cmprsd_pkt_attr_bits->dvp_type = max_bits;
                    egr_cmprsd_pkt_attr_bits->dvp_type_mask=(1<<max_bits)-1;
                    egr_cmprsd_pkt_attr_bits->dvp_type_pos =
                        egr_pkt_attr_cmprsd_bits_g[unit].dvp_type_pos;
                }
                if (map_array[bcmStatGroupModeAttrDrop] != NULL) {
                    max_bits = drop_cmprsd_max_bits;
                    egr_cmprsd_pkt_attr_bits->drop = max_bits;
                    egr_cmprsd_pkt_attr_bits->drop_mask=(1<<max_bits)-1;
                    egr_cmprsd_pkt_attr_bits->drop_pos=
                        egr_pkt_attr_cmprsd_bits_g[unit].drop_pos;
                }
                invalid_map_value = (1 <<
                    (egr_pkt_attr_cmprsd_bits_g[unit].pkt_resolution +
                     egr_pkt_attr_cmprsd_bits_g[unit].svp_type +
                     egr_pkt_attr_cmprsd_bits_g[unit].dvp_type +
                     egr_pkt_attr_cmprsd_bits_g[unit].drop)) - 1;

#if defined(BCM_TRIDENT3_SUPPORT)
                if (SOC_IS_TRIDENT3X(unit) &&
                    soc_feature(unit, soc_feature_multiple_split_horizon_group)) {
                    tmp_svp_type = 0x3;
                    tmp_dvp_type = 0x3;
                }
#endif
                for (index0 =0;
                     index0 < (1 << egr_pkt_attr_cmprsd_bits_g[unit].pkt_resolution);
                     index0++ ) {
                    invalid_index0 = FALSE;
                    if (map_array[bcmStatGroupModeAttrPktType] != NULL) {
                        if (map_array[bcmStatGroupModeAttrPktType][index0] ==
                                0xFF ) {
                            invalid_index0 = TRUE;
                        } else {
                            mapped_value0 = map_array
                                [bcmStatGroupModeAttrPktType][index0];
                        }
                    }
                    for (index1 =0;
                         index1 < (1 << tmp_svp_type);
                         index1++ ) {
                        invalid_index1 = FALSE;
                        if (map_array[bcmStatGroupModeAttrIngNetworkGroup]
                                != NULL) {
                            if (map_array
                                    [bcmStatGroupModeAttrIngNetworkGroup]
                                    [index1] == 0xFF){
                                invalid_index1 = TRUE;
                            } else {
                                mapped_value1 = map_array
                                    [bcmStatGroupModeAttrIngNetworkGroup]
                                    [index1];
                            }
                        }
                        for (index2 =0;
                             index2 < (1 << tmp_dvp_type);
                             index2++ ) {
                            invalid_index2 = FALSE;
                            if (map_array
                                    [bcmStatGroupModeAttrEgrNetworkGroup] 
                                    != NULL) {
                                if (map_array
                                        [bcmStatGroupModeAttrEgrNetworkGroup]
                                        [index2] == 0xFF){
                                    invalid_index2 = TRUE;
                                } else {
                                    mapped_value2 = map_array
                                        [bcmStatGroupModeAttrEgrNetworkGroup]
                                        [index2];
                                }
                            }
                            for (index3 =0;
                                 index3 < (1 << egr_pkt_attr_cmprsd_bits_g[unit].drop);
                                 index3++ ) {
                                invalid_index3 = FALSE;
                                if (map_array[bcmStatGroupModeAttrDrop]
                                        != NULL) {
                                    if (map_array
                                            [bcmStatGroupModeAttrDrop][index3]
                                            == 0xFF){
                                        invalid_index3 = TRUE;
                                    } else {
                                        mapped_value3 = map_array
                                            [bcmStatGroupModeAttrDrop]
                                            [index3];
                                    }
                                }
                                final_index =
                                    (index0 <<
                                     (tmp_svp_type +
                                      tmp_dvp_type +
                                      egr_pkt_attr_cmprsd_bits_g[unit].drop)) +
                                    (index1 <<
                                     (tmp_dvp_type +
                                      egr_pkt_attr_cmprsd_bits_g[unit].drop)) +
                                    (index2 <<
                                     egr_pkt_attr_cmprsd_bits_g[unit].drop) +
                                    (index3) ;
                                if (invalid_index0 || invalid_index1 ||
                                        invalid_index2 || invalid_index3) {
                                    final_mapped_value = invalid_map_value;
                                } else {
                                    final_mapped_value =
                                        (mapped_value0 <<
                                         (tmp_svp_type +
                                          tmp_dvp_type +
                                          egr_pkt_attr_cmprsd_bits_g[unit].drop)) +
                                        (mapped_value1 <<
                                         (tmp_dvp_type +
                                          egr_pkt_attr_cmprsd_bits_g[unit].drop)) +
                                        (mapped_value2 <<
                                         egr_pkt_attr_cmprsd_bits_g[unit].drop) +
                                        (mapped_value3) ;
                                }
                                egr_cmprsd_attr_selectors->pkt_res_attr_map
                                    [final_index] = final_mapped_value;
                            }
                        }
                    }
                }
            }
            if (flex_attribute->ip_pkt != 0) {
                 max_bits=0;
                 LOG_VERBOSE(BSL_LS_BCM_FLEXCTR,
                             (BSL_META_U(unit,
                                         "Egr: ip packet Creation \n")));
                 if (map_array[bcmStatGroupModeAttrPacketTypeIp] != NULL) {
                     max_bits =  ip_pkt_cmprsd_max_bits;
                     egr_cmprsd_pkt_attr_bits->ip_pkt= max_bits;
                     egr_cmprsd_pkt_attr_bits->ip_pkt_mask =
                                               (1 << max_bits) - 1;
                     egr_cmprsd_pkt_attr_bits->ip_pkt_pos =
                                               egr_pkt_attr_cmprsd_bits_g[unit].ip_pkt_pos;
                 }
             }
             break;
        default:
             break;
        }
       for (loop=0;loop<8;loop++) {
            offset_array[loop] = (uint16 *) sal_alloc((256+1) * sizeof(uint16),"offset_array");
            if (offset_array[loop] == NULL) {
                rv = BCM_E_MEMORY;
                goto cleanup;
            }
       }
       /* Second Level Analysis: Update offset_array */
       for (counter=0;counter < flex_attribute->total_counters ; counter ++ ) {
            for (loop=0;loop<8;loop++) {
                 sal_memset(offset_array[loop],0,(256+1) * sizeof(uint16));
            }
            /* Logical Group0 */
            loop = 0;
#ifdef BCM_APACHE_SUPPORT
            if (soc_feature(unit,soc_feature_flex_ctr_mpls_3_label_count)) {
                if (flex_attribute->cng_3 != 0) {
                    shift_by_bits = int_pri_mpls_3_cmprsd_max_bits +
                        pre_ifp_cng_mpls_2_cmprsd_max_bits +
                        int_pri_mpls_2_cmprsd_max_bits +
                        pre_ifp_cng_mpls_1_cmprsd_max_bits +
                        int_pri_mpls_1_cmprsd_max_bits +
                        pre_ifp_cng_cmprsd_max_bits +
                        ifp_cng_cmprsd_max_bits +
                        int_pri_cmprsd_max_bits +
                        vlan_format_cmprsd_max_bits +
                        outer_dot1p_cmprsd_max_bits +
                        inner_dot1p_cmprsd_max_bits +
                        port_cmprsd_max_bits +
                        tos_dscp_cmprsd_max_bits +
                        tos_ecn_cmprsd_max_bits +
                        pkt_resolution_cmprsd_max_bits +
                        svp_cmprsd_max_bits +
                        dvp_cmprsd_max_bits +
                        drop_cmprsd_max_bits +
                        ip_pkt_bits ;
                    temp_count = offset_array[loop][0];
                    if (flex_attribute->combine_attr_counter[counter].
                            pre_ifp_color_mpls_label3_flags & BCM_STAT_FLEX_COLOR_GREEN) {
                        /* GreenIndex=0*/
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrColorMplsLabelThird][0] << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pre_ifp_color_mpls_label3_flags & BCM_STAT_FLEX_COLOR_RED) {
                        /* RedIndex=1 */
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrColorMplsLabelThird][1] << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pre_ifp_color_mpls_label3_flags & BCM_STAT_FLEX_COLOR_YELLOW) {
                        /* YellowIndex=3 */
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrColorMplsLabelThird][3] << shift_by_bits);
                        temp_count++;
                    }
                    offset_array[loop][0] = temp_count;
                    loop++;
                }
                if (flex_attribute->phb_3 != 0) {
                    shift_by_bits = pre_ifp_cng_mpls_2_cmprsd_max_bits +
                        int_pri_mpls_2_cmprsd_max_bits +
                        pre_ifp_cng_mpls_1_cmprsd_max_bits +
                        int_pri_mpls_1_cmprsd_max_bits +
                        pre_ifp_cng_cmprsd_max_bits +
                        ifp_cng_cmprsd_max_bits +
                        int_pri_cmprsd_max_bits +
                        vlan_format_cmprsd_max_bits +
                        outer_dot1p_cmprsd_max_bits +
                        inner_dot1p_cmprsd_max_bits +
                        port_cmprsd_max_bits +
                        tos_dscp_cmprsd_max_bits +
                        tos_ecn_cmprsd_max_bits +
                        pkt_resolution_cmprsd_max_bits +
                        svp_cmprsd_max_bits +
                        dvp_cmprsd_max_bits +
                        drop_cmprsd_max_bits +
                        ip_pkt_bits ;
                    temp_count = offset_array[loop][0];
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI0) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][0] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI1) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][1] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI2) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][2] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI3) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][3] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI4) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][4] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI5) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][5] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI6) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][6] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI7) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][7] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI8) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][8] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI9) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][9] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI10) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][10] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI11) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][11] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI12) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][12] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI13) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][13] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI14) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][14] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label3_flags & BCM_STAT_FLEX_PRI15) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelThird][15] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    offset_array[loop][0] = temp_count;
                    loop++;
                }
                if (flex_attribute->cng_2 != 0) {
                    shift_by_bits = int_pri_mpls_2_cmprsd_max_bits +
                        pre_ifp_cng_mpls_1_cmprsd_max_bits +
                        int_pri_mpls_1_cmprsd_max_bits +
                        pre_ifp_cng_cmprsd_max_bits +
                        ifp_cng_cmprsd_max_bits +
                        int_pri_cmprsd_max_bits +
                        vlan_format_cmprsd_max_bits +
                        outer_dot1p_cmprsd_max_bits +
                        inner_dot1p_cmprsd_max_bits +
                        port_cmprsd_max_bits +
                        tos_dscp_cmprsd_max_bits +
                        tos_ecn_cmprsd_max_bits +
                        pkt_resolution_cmprsd_max_bits +
                        svp_cmprsd_max_bits +
                        dvp_cmprsd_max_bits +
                        drop_cmprsd_max_bits +
                        ip_pkt_bits ;
                    temp_count = offset_array[loop][0];
                    if (flex_attribute->combine_attr_counter[counter].
                            pre_ifp_color_mpls_label2_flags & BCM_STAT_FLEX_COLOR_GREEN) {
                        /* GreenIndex=0*/
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrColorMplsLabelSecond][0] << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pre_ifp_color_mpls_label2_flags & BCM_STAT_FLEX_COLOR_RED) {
                        /* RedIndex=1 */
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrColorMplsLabelSecond][1] << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pre_ifp_color_mpls_label2_flags & BCM_STAT_FLEX_COLOR_YELLOW) {
                        /* YellowIndex=3 */
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrColorMplsLabelSecond][3] << shift_by_bits);
                        temp_count++;
                    }
                    offset_array[loop][0] = temp_count;
                    loop++;
                }
                if (flex_attribute->phb_2 != 0) {
                    shift_by_bits = pre_ifp_cng_mpls_1_cmprsd_max_bits +
                        int_pri_mpls_1_cmprsd_max_bits +
                        pre_ifp_cng_cmprsd_max_bits +
                        ifp_cng_cmprsd_max_bits +
                        int_pri_cmprsd_max_bits +
                        vlan_format_cmprsd_max_bits +
                        outer_dot1p_cmprsd_max_bits +
                        inner_dot1p_cmprsd_max_bits +
                        port_cmprsd_max_bits +
                        tos_dscp_cmprsd_max_bits +
                        tos_ecn_cmprsd_max_bits +
                        pkt_resolution_cmprsd_max_bits +
                        svp_cmprsd_max_bits +
                        dvp_cmprsd_max_bits +
                        drop_cmprsd_max_bits +
                        ip_pkt_bits ;
                    temp_count = offset_array[loop][0];
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI0) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][0] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI1) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][1] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI2) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][2] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI3) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][3] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI4) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][4] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI5) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][5] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI6) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][6] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI7) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][7] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI8) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][8] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI9) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][9] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI10) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][10] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI11) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][11] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI12) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][12] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI13) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][13] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI14) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][14] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label2_flags & BCM_STAT_FLEX_PRI15) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelSecond][15] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    offset_array[loop][0] = temp_count;
                    loop++;
                }
                if (flex_attribute->cng_1 != 0) {
                    shift_by_bits = int_pri_mpls_1_cmprsd_max_bits +
                        pre_ifp_cng_cmprsd_max_bits +
                        ifp_cng_cmprsd_max_bits +
                        int_pri_cmprsd_max_bits +
                        vlan_format_cmprsd_max_bits +
                        outer_dot1p_cmprsd_max_bits +
                        inner_dot1p_cmprsd_max_bits +
                        port_cmprsd_max_bits +
                        tos_dscp_cmprsd_max_bits +
                        tos_ecn_cmprsd_max_bits +
                        pkt_resolution_cmprsd_max_bits +
                        svp_cmprsd_max_bits +
                        dvp_cmprsd_max_bits +
                        drop_cmprsd_max_bits +
                        ip_pkt_bits ;
                    temp_count = offset_array[loop][0];
                    if (flex_attribute->combine_attr_counter[counter].
                            pre_ifp_color_mpls_label1_flags & BCM_STAT_FLEX_COLOR_GREEN) {
                        /* GreenIndex=0*/
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrColorMplsLabelFirst][0] << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pre_ifp_color_mpls_label1_flags & BCM_STAT_FLEX_COLOR_RED) {
                        /* RedIndex=1 */
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrColorMplsLabelFirst][1] << shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pre_ifp_color_mpls_label1_flags & BCM_STAT_FLEX_COLOR_YELLOW) {
                        /* YellowIndex=3 */
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrColorMplsLabelFirst][3] << shift_by_bits);
                        temp_count++;
                    }
                    offset_array[loop][0] = temp_count;
                    loop++;
                }
                if (flex_attribute->phb_1 != 0) {
                    shift_by_bits = pre_ifp_cng_cmprsd_max_bits +
                        ifp_cng_cmprsd_max_bits +
                        int_pri_cmprsd_max_bits +
                        vlan_format_cmprsd_max_bits +
                        outer_dot1p_cmprsd_max_bits +
                        inner_dot1p_cmprsd_max_bits +
                        port_cmprsd_max_bits +
                        tos_dscp_cmprsd_max_bits +
                        tos_ecn_cmprsd_max_bits +
                        pkt_resolution_cmprsd_max_bits +
                        svp_cmprsd_max_bits +
                        dvp_cmprsd_max_bits +
                        drop_cmprsd_max_bits +
                        ip_pkt_bits ;
                    temp_count = offset_array[loop][0];
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI0) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][0] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI1) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][1] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI2) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][2] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI3) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][3] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI4) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][4] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI5) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][5] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI6) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][6] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI7) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][7] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI8) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][8] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI9) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][9] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI10) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][10] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI11) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][11] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI12) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][12] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI13) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][13] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI14) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][14] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            int_pri_mpls_label1_flags & BCM_STAT_FLEX_PRI15) {
                        offset_array[loop][temp_count+1] = (
                                map_array[bcmStatGroupModeAttrIntPriMplsLabelFirst][15] <<
                                shift_by_bits);
                        temp_count++;
                    }
                    offset_array[loop][0] = temp_count;
                    loop++;
                }
            }
#endif
#if defined(BCM_TOMAHAWK_SUPPORT) || defined(BCM_TRIDENT3_SUPPORT)
            if (soc_feature(unit, soc_feature_flex_stat_egr_queue_congestion_marked)) {
                if (flex_attribute->mmu_cos != 0) {
                    shift_by_bits = uc_queueing_cmprsd_max_bits +
                                    congestion_marked_cmprsd_max_bits +
                                    ifp_cng_cmprsd_max_bits +
                                    int_pri_cmprsd_max_bits +
                                    vlan_format_cmprsd_max_bits +
                                    outer_dot1p_cmprsd_max_bits +
                                    inner_dot1p_cmprsd_max_bits +
                                    port_cmprsd_max_bits +
                                    tos_dscp_cmprsd_max_bits +
                                    tos_ecn_cmprsd_max_bits +
                                    pkt_resolution_cmprsd_max_bits +
                                    svp_cmprsd_max_bits +
                                    dvp_cmprsd_max_bits +
                                    drop_cmprsd_max_bits +
                                    ip_pkt_bits;
                    if (loop >= 7) {
                        rv = BCM_E_PARAM;
                        goto cleanup;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                        mmu_cos_flags & BCM_STAT_FLEX_COS0) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1] = (
                         map_array[bcmStatGroupModeAttrCos][0] <<
                         shift_by_bits);
                        offset_array[loop][0] = temp_count + 1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                        mmu_cos_flags & BCM_STAT_FLEX_COS1) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1] = (
                         map_array[bcmStatGroupModeAttrCos][1] <<
                         shift_by_bits);
                        offset_array[loop][0] = temp_count + 1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                        mmu_cos_flags & BCM_STAT_FLEX_COS2) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1] = (
                         map_array[bcmStatGroupModeAttrCos][2] <<
                         shift_by_bits);
                        offset_array[loop][0] = temp_count + 1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                        mmu_cos_flags & BCM_STAT_FLEX_COS3) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1] = (
                         map_array[bcmStatGroupModeAttrCos][3] <<
                         shift_by_bits);
                        offset_array[loop][0] = temp_count + 1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                        mmu_cos_flags & BCM_STAT_FLEX_COS4) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1] = (
                         map_array[bcmStatGroupModeAttrCos][4] <<
                         shift_by_bits);
                        offset_array[loop][0] = temp_count + 1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                        mmu_cos_flags & BCM_STAT_FLEX_COS5) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1] = (
                         map_array[bcmStatGroupModeAttrCos][5] <<
                         shift_by_bits);
                        offset_array[loop][0] = temp_count + 1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                        mmu_cos_flags & BCM_STAT_FLEX_COS6) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1] = (
                         map_array[bcmStatGroupModeAttrCos][6] <<
                         shift_by_bits);
                        offset_array[loop][0] = temp_count + 1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                        mmu_cos_flags & BCM_STAT_FLEX_COS7) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1] = (
                         map_array[bcmStatGroupModeAttrCos][7] <<
                         shift_by_bits);
                        offset_array[loop][0] = temp_count + 1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                        mmu_cos_flags & BCM_STAT_FLEX_COS8) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1] = (
                         map_array[bcmStatGroupModeAttrCos][8] <<
                         shift_by_bits);
                        offset_array[loop][0] = temp_count + 1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                        mmu_cos_flags & BCM_STAT_FLEX_COS9) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1] = (
                         map_array[bcmStatGroupModeAttrCos][9] <<
                         shift_by_bits);
                        offset_array[loop][0] = temp_count + 1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                        mmu_cos_flags & BCM_STAT_FLEX_COS10) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1] = (
                         map_array[bcmStatGroupModeAttrCos][10] <<
                         shift_by_bits);
                        offset_array[loop][0] = temp_count + 1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                        mmu_cos_flags & BCM_STAT_FLEX_COS11) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1] = (
                         map_array[bcmStatGroupModeAttrCos][11] <<
                         shift_by_bits);
                        offset_array[loop][0] = temp_count + 1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                        mmu_cos_flags & BCM_STAT_FLEX_COS12) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1] = (
                         map_array[bcmStatGroupModeAttrCos][12] <<
                         shift_by_bits);
                        offset_array[loop][0] = temp_count + 1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                        mmu_cos_flags & BCM_STAT_FLEX_COS13) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1] = (
                         map_array[bcmStatGroupModeAttrCos][13] <<
                         shift_by_bits);
                        offset_array[loop][0] = temp_count + 1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                        mmu_cos_flags & BCM_STAT_FLEX_COS14) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1] = (
                         map_array[bcmStatGroupModeAttrCos][14] <<
                         shift_by_bits);
                        offset_array[loop][0] = temp_count + 1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                        mmu_cos_flags & BCM_STAT_FLEX_COS15) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1] = (
                         map_array[bcmStatGroupModeAttrCos][15] <<
                         shift_by_bits);
                        offset_array[loop][0] = temp_count + 1;
                    }
                    loop++;
                }
                if ((flex_attribute->uc_queueing != 0) &&
                    (loop <= (BCM_STAT_FLEX_COUNTER_MAX_TOTAL_BITS - 2))) {
                    shift_by_bits = congestion_marked_cmprsd_max_bits +
                                    ifp_cng_cmprsd_max_bits +
                                    int_pri_cmprsd_max_bits +
                                    vlan_format_cmprsd_max_bits +
                                    outer_dot1p_cmprsd_max_bits +
                                    inner_dot1p_cmprsd_max_bits +
                                    port_cmprsd_max_bits +
                                    tos_dscp_cmprsd_max_bits +
                                    tos_ecn_cmprsd_max_bits +
                                    pkt_resolution_cmprsd_max_bits +
                                    svp_cmprsd_max_bits +
                                    dvp_cmprsd_max_bits +
                                    drop_cmprsd_max_bits +
                                    ip_pkt_bits;
                    if (flex_attribute->combine_attr_counter[counter].
                        uc_queueing_flags & BCM_STAT_FLEX_UC_QUEUEING_DISABLE) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1] = (
                     map_array[bcmStatGroupModeAttrQueueType][0] << shift_by_bits);
                        offset_array[loop][0] = temp_count + 1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                        uc_queueing_flags & BCM_STAT_FLEX_UC_QUEUEING_ENABLE) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1] = (
                     map_array[bcmStatGroupModeAttrQueueType][1] << shift_by_bits);
                        offset_array[loop][0] = temp_count + 1;
                    }
                    loop++;
                }
                if ((flex_attribute->congestion_marked != 0) &&
                    (loop <= (BCM_STAT_FLEX_COUNTER_MAX_TOTAL_BITS - 2))) {
                    shift_by_bits = ifp_cng_cmprsd_max_bits +
                                    int_pri_cmprsd_max_bits +
                                    vlan_format_cmprsd_max_bits +
                                    outer_dot1p_cmprsd_max_bits +
                                    inner_dot1p_cmprsd_max_bits +
                                    port_cmprsd_max_bits +
                                    tos_dscp_cmprsd_max_bits +
                                    tos_ecn_cmprsd_max_bits +
                                    pkt_resolution_cmprsd_max_bits +
                                    svp_cmprsd_max_bits +
                                    dvp_cmprsd_max_bits +
                                    drop_cmprsd_max_bits +
                                    ip_pkt_bits;
                    if (flex_attribute->combine_attr_counter[counter].
                        congestion_marked_flags & BCM_STAT_FLEX_CONGESTION_MARKED_DISABLE) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1] = (0 << shift_by_bits);
                        offset_array[loop][0] = temp_count + 1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                        congestion_marked_flags & BCM_STAT_FLEX_CONGESTION_MARKED_ENABLE) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1] = (1 << shift_by_bits);
                        offset_array[loop][0] = temp_count + 1;
                    }
                    loop++;
                }
            }
#endif

            if (flex_attribute->pre_ifp_color != 0) {
                shift_by_bits = ifp_cng_cmprsd_max_bits +
                                int_pri_cmprsd_max_bits +
                                vlan_format_cmprsd_max_bits +
                                outer_dot1p_cmprsd_max_bits +
                                inner_dot1p_cmprsd_max_bits + 
                                port_cmprsd_max_bits + 
                                tos_dscp_cmprsd_max_bits + 
                                tos_ecn_cmprsd_max_bits + 
                                pkt_resolution_cmprsd_max_bits + 
                                svp_cmprsd_max_bits + 
                                dvp_cmprsd_max_bits + 
                                drop_cmprsd_max_bits + 
                                ip_pkt_bits ;
                if (flex_attribute->combine_attr_counter[counter].
                    pre_ifp_color_flags & BCM_STAT_FLEX_COLOR_GREEN) {
                    temp_count = offset_array[loop][0];
                                                       /* GreenIndex=0*/
                    offset_array[loop][temp_count+1] = (
                     map_array[bcmStatGroupModeAttrColor][0] << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    pre_ifp_color_flags & BCM_STAT_FLEX_COLOR_RED) {
                    temp_count = offset_array[loop][0];
                                                      /* RedIndex=1 */
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrColor][1] << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    pre_ifp_color_flags & BCM_STAT_FLEX_COLOR_YELLOW) {
                    temp_count = offset_array[loop][0];
                                                      /* YellowIndex=3 */
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrColor][3] << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                loop++;
            }
            if (flex_attribute->ifp_color != 0) {
                shift_by_bits = int_pri_cmprsd_max_bits +
                                vlan_format_cmprsd_max_bits +
                                outer_dot1p_cmprsd_max_bits +
                                inner_dot1p_cmprsd_max_bits +
                                port_cmprsd_max_bits + 
                                tos_dscp_cmprsd_max_bits + 
                                tos_ecn_cmprsd_max_bits + 
                                pkt_resolution_cmprsd_max_bits + 
                                svp_cmprsd_max_bits + 
                                dvp_cmprsd_max_bits + 
                                drop_cmprsd_max_bits + 
                                ip_pkt_bits ;
                if (flex_attribute->combine_attr_counter[counter].
                    ifp_color_flags & BCM_STAT_FLEX_COLOR_GREEN) {
                    temp_count = offset_array[loop][0];
                                                       /* GreenIndex=0*/
                    offset_array[loop][temp_count+1] = (
                     map_array[bcmStatGroupModeAttrFieldIngressColor][0] <<
                     shift_by_bits); 
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    ifp_color_flags & BCM_STAT_FLEX_COLOR_RED) {
                    temp_count = offset_array[loop][0];
                                                      /* RedIndex=1 */
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrFieldIngressColor][1] <<
                     shift_by_bits); 
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    ifp_color_flags & BCM_STAT_FLEX_COLOR_YELLOW) {
                    temp_count = offset_array[loop][0];
                                                      /* YellowIndex=3 */
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrFieldIngressColor][3] <<
                     shift_by_bits); 
                    offset_array[loop][0] = temp_count+1;
                }
                loop++;
            }
            if (flex_attribute->int_pri != 0) {
                shift_by_bits = vlan_format_cmprsd_max_bits +
                                outer_dot1p_cmprsd_max_bits +
                                inner_dot1p_cmprsd_max_bits +
                                port_cmprsd_max_bits +
                                tos_dscp_cmprsd_max_bits + 
                                tos_ecn_cmprsd_max_bits + 
                                pkt_resolution_cmprsd_max_bits + 
                                svp_cmprsd_max_bits + 
                                dvp_cmprsd_max_bits + 
                                drop_cmprsd_max_bits + 
                                ip_pkt_bits ;
                /*
                 * Although logically the value of loop is safeguarded before
                 * hitting this logic but for coverity static analysis adding
                 * a fail-safe condition.
                 */
                if (loop >= 8) {
                    rv = BCM_E_PARAM;
                    goto cleanup;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    int_pri_flags & BCM_STAT_FLEX_PRI0) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrIntPri][0] <<
                     shift_by_bits); 
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    int_pri_flags & BCM_STAT_FLEX_PRI1) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrIntPri][1] <<
                     shift_by_bits); 
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    int_pri_flags & BCM_STAT_FLEX_PRI2) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrIntPri][2] <<
                     shift_by_bits); 
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    int_pri_flags & BCM_STAT_FLEX_PRI3) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrIntPri][3] <<
                     shift_by_bits); 
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    int_pri_flags & BCM_STAT_FLEX_PRI4) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrIntPri][4] <<
                     shift_by_bits); 
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    int_pri_flags & BCM_STAT_FLEX_PRI5) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrIntPri][5] <<
                     shift_by_bits); 
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    int_pri_flags & BCM_STAT_FLEX_PRI6) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrIntPri][6] <<
                     shift_by_bits); 
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    int_pri_flags & BCM_STAT_FLEX_PRI7) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrIntPri][7] <<
                     shift_by_bits); 
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    int_pri_flags & BCM_STAT_FLEX_PRI8) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrIntPri][8] <<
                     shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    int_pri_flags & BCM_STAT_FLEX_PRI9) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrIntPri][9] <<
                     shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    int_pri_flags & BCM_STAT_FLEX_PRI10) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrIntPri][10] <<
                     shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    int_pri_flags & BCM_STAT_FLEX_PRI11) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrIntPri][11] <<
                     shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    int_pri_flags & BCM_STAT_FLEX_PRI12) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrIntPri][12] <<
                     shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    int_pri_flags & BCM_STAT_FLEX_PRI13) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrIntPri][13] <<
                     shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    int_pri_flags & BCM_STAT_FLEX_PRI14) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrIntPri][14] <<
                     shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    int_pri_flags & BCM_STAT_FLEX_PRI15) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrIntPri][15] <<
                     shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                loop++;
            }
            /* LogicalGroup1 */
            if (flex_attribute->vlan_format != 0) {
                shift_by_bits = outer_dot1p_cmprsd_max_bits +
                                inner_dot1p_cmprsd_max_bits +
                                port_cmprsd_max_bits +
                                tos_dscp_cmprsd_max_bits +
                                tos_ecn_cmprsd_max_bits +
                                pkt_resolution_cmprsd_max_bits +
                                svp_cmprsd_max_bits +
                                dvp_cmprsd_max_bits +
                                drop_cmprsd_max_bits +
                                ip_pkt_bits ;
                 if (loop >= 8) {
                    rv = BCM_E_PARAM;
                    goto cleanup;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    vlan_format_flags & BCM_STAT_FLEX_VLAN_FORMAT_UNTAGGED) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrVlan][0] <<
                     shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    vlan_format_flags & BCM_STAT_FLEX_VLAN_FORMAT_INNER) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrVlan][1] <<
                     shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    vlan_format_flags & BCM_STAT_FLEX_VLAN_FORMAT_OUTER) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrVlan][2] <<
                     shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    vlan_format_flags & BCM_STAT_FLEX_VLAN_FORMAT_BOTH) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrVlan][3] <<
                     shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                loop++;
            }
            if (flex_attribute->outer_dot1p != 0) {
                shift_by_bits = inner_dot1p_cmprsd_max_bits +
                                port_cmprsd_max_bits +
                                tos_dscp_cmprsd_max_bits +
                                tos_ecn_cmprsd_max_bits +
                                pkt_resolution_cmprsd_max_bits +
                                svp_cmprsd_max_bits +
                                dvp_cmprsd_max_bits +
                                drop_cmprsd_max_bits +
                                ip_pkt_bits ;
                if (loop >= 8) {
                    rv = BCM_E_PARAM;
                    goto cleanup;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    outer_dot1p_flags & BCM_STAT_FLEX_PRI0) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrOuterPri][0] <<
                     shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    outer_dot1p_flags & BCM_STAT_FLEX_PRI1) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrOuterPri][1] <<
                     shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    outer_dot1p_flags & BCM_STAT_FLEX_PRI2) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrOuterPri][2] <<
                     shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    outer_dot1p_flags & BCM_STAT_FLEX_PRI3) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrOuterPri][3] <<
                     shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    outer_dot1p_flags & BCM_STAT_FLEX_PRI4) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrOuterPri][4] <<
                     shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    outer_dot1p_flags & BCM_STAT_FLEX_PRI5) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrOuterPri][5] <<
                     shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    outer_dot1p_flags & BCM_STAT_FLEX_PRI6) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrOuterPri][6] <<
                     shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    outer_dot1p_flags & BCM_STAT_FLEX_PRI7) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrOuterPri][7] <<
                     shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                loop++;
            }
            if (flex_attribute->inner_dot1p != 0) {
                shift_by_bits = port_cmprsd_max_bits +
                                tos_dscp_cmprsd_max_bits +
                                tos_ecn_cmprsd_max_bits +
                                pkt_resolution_cmprsd_max_bits +
                                svp_cmprsd_max_bits +
                                dvp_cmprsd_max_bits +
                                drop_cmprsd_max_bits +
                                ip_pkt_bits ;
                if (loop >= 8) {
                    rv = BCM_E_PARAM;
                    goto cleanup;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    inner_dot1p_flags & BCM_STAT_FLEX_PRI0) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrInnerPri][0] <<
                     shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    inner_dot1p_flags & BCM_STAT_FLEX_PRI1) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrInnerPri][1] <<
                     shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    inner_dot1p_flags & BCM_STAT_FLEX_PRI2) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrInnerPri][2] <<
                     shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    inner_dot1p_flags & BCM_STAT_FLEX_PRI3) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrInnerPri][3] <<
                     shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    inner_dot1p_flags & BCM_STAT_FLEX_PRI4) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrInnerPri][4] <<
                     shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    inner_dot1p_flags & BCM_STAT_FLEX_PRI5) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrInnerPri][5] <<
                     shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    inner_dot1p_flags & BCM_STAT_FLEX_PRI6) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrInnerPri][6] <<
                     shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    inner_dot1p_flags & BCM_STAT_FLEX_PRI7) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                     map_array[bcmStatGroupModeAttrInnerPri][7] <<
                     shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                loop++;
            }
            /* LogicalGroup2 */
            if ((flex_attribute->port != 0) ||(flex_attribute->subport != 0)) {
                shift_by_bits = tos_dscp_cmprsd_max_bits +
                                tos_ecn_cmprsd_max_bits +
                                pkt_resolution_cmprsd_max_bits +
                                svp_cmprsd_max_bits +
                                dvp_cmprsd_max_bits +
                                drop_cmprsd_max_bits +
                                ip_pkt_bits ;
                if (loop >= 8) {
                    rv = BCM_E_PARAM;
                    goto cleanup;
                }
                if (direction == bcmStatFlexDirectionIngress) {
                    max_count= (1 << ing_pkt_attr_cmprsd_bits_g[unit].ing_port) - 1;
                } else {
                    max_count= (1 << egr_pkt_attr_cmprsd_bits_g[unit].egr_port) - 1;
                }
#if defined(BCM_TRIDENT3_SUPPORT) || defined(BCM_APACHE_SUPPORT)
                if (soc_feature(unit,
                            soc_feature_flex_stat_port_group_support)) {
                    for (loop_index=0; loop_index <= max_count ; loop_index++) {
                        if (BCM_STAT_FLEX_VALUE_GET(
                                    flex_attribute->combine_attr_counter[counter].
                                    value_array[bcmStatFlexAttrPort],loop_index)) {
                            for (inner_loop_index = 0;
                                    inner_loop_index <= max_count;
                                    inner_loop_index++) {
                                if (SHR_BITGET(stat_port_grp[unit].
                                            port_grp_bmap[loop_index].pbits, inner_loop_index)) {
                                    temp_count = offset_array[loop][0];
                                    offset_array[loop][temp_count+1]=
                                        compress_group_count << shift_by_bits;
                                    offset_array[loop][0] = temp_count+1;
                                    compress_group_count++;

                                }
                            }
                        }
                    }
                } else
#endif
                {
                    for (loop_index=0; loop_index <= max_count ; loop_index++) {
                        if (BCM_STAT_FLEX_VALUE_GET(
                                    flex_attribute->combine_attr_counter[counter].
                                    value_array[bcmStatFlexAttrPort],loop_index)) {
                            temp_count = offset_array[loop][0];
                            offset_array[loop][temp_count+1]= (
                                    map_array[bcmStatGroupModeAttrPort][loop_index] <<
                                    shift_by_bits);
                            offset_array[loop][0] = temp_count+1;
                        }
                    }
                }
                loop++;
            }
            /* LogicalGroup3 */
            if ((flex_attribute->tos_dscp != 0) &&
                (loop <= (BCM_STAT_FLEX_COUNTER_MAX_TOTAL_BITS - 2))) {
                shift_by_bits = tos_ecn_cmprsd_max_bits +
                                pkt_resolution_cmprsd_max_bits +
                                svp_cmprsd_max_bits +
                                dvp_cmprsd_max_bits +
                                drop_cmprsd_max_bits +
                                ip_pkt_bits ;
                if (direction == bcmStatFlexDirectionIngress) {
                   max_count= (1 << ing_pkt_attr_cmprsd_bits_g[unit].tos_dscp) - 1;
                } else {
                   max_count= (1 << egr_pkt_attr_cmprsd_bits_g[unit].tos_dscp) - 1;
                }
                for (loop_index=0; loop_index <= max_count ; loop_index++) {
                    if (BCM_STAT_FLEX_VALUE_GET(
                            flex_attribute->combine_attr_counter[counter].
                            value_array[bcmStatFlexAttrTosDscp],loop_index)) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                             map_array[bcmStatGroupModeAttrTosDscp][loop_index] <<
                                                          shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                }
                loop++;
            }
            if ((flex_attribute->tos_ecn != 0) &&
                (loop <= (BCM_STAT_FLEX_COUNTER_MAX_TOTAL_BITS - 2))) {
                shift_by_bits = pkt_resolution_cmprsd_max_bits +
                                svp_cmprsd_max_bits +
                                dvp_cmprsd_max_bits +
                                drop_cmprsd_max_bits +
                                ip_pkt_bits ;
                if (direction == bcmStatFlexDirectionIngress) {
                   max_count= (1 << ing_pkt_attr_cmprsd_bits_g[unit].tos_ecn) - 1;
                } else {
                   max_count= (1 << egr_pkt_attr_cmprsd_bits_g[unit].tos_ecn) - 1;
                }
                for (loop_index=0; loop_index <= max_count ; loop_index++) {
                    if (BCM_STAT_FLEX_VALUE_GET(
                            flex_attribute->combine_attr_counter[counter].
                            value_array[bcmStatFlexAttrTosEcn],loop_index)) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                             map_array[bcmStatGroupModeAttrTosEcn][loop_index] <<
                                                          shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                }
                loop++;
            }
            /* LogicalGroup4 */
            if ((flex_attribute->pkt_resolution != 0) &&
                    (loop <= (BCM_STAT_FLEX_COUNTER_MAX_TOTAL_BITS - 2))) {
#ifdef BCM_KATANA2_SUPPORT
                if soc_feature(unit, soc_feature_flex_stat_attributes_class) {
                    shift_by_bits = svp_cmprsd_max_bits +
                        dvp_cmprsd_max_bits +
                        drop_cmprsd_max_bits +
                        ip_pkt_bits ;
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags & BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrClassType][unknown_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags & BCM_STAT_FLEX_PKT_TYPE_CONTROL_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrClassType][control_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags & BCM_STAT_FLEX_PKT_TYPE_OAM_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrClassType][oam_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags & BCM_STAT_FLEX_PKT_TYPE_BFD_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrClassType][bfd_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags & BCM_STAT_FLEX_PKT_TYPE_BPDU_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrClassType][bpdu_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags & BCM_STAT_FLEX_PKT_TYPE_ICNM_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrClassType][icnm_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags & BCM_STAT_FLEX_PKT_TYPE_PKT_IS_1588) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrClassType][_1588_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags & BCM_STAT_FLEX_PKT_TYPE_BFD_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrClassType][bfd_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_L2UC_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrClassType][known_l2uc_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_L2UC_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrClassType][unknown_l2uc_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags & BCM_STAT_FLEX_PKT_TYPE_L2BC_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrClassType][l2bc_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_L2MC_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrClassType][known_l2mc_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_L2MC_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrClassType][unknown_l2mc_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_L3UC_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrClassType][known_l3uc_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_L3UC_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrClassType][unknown_l3uc_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_IPMC_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrClassType][known_ipmc_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_IPMC_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrClassType][unknown_ipmc_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_L2_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrClassType][known_mpls_l2_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_L3_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrClassType][known_mpls_l3_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrClassType][known_mpls_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_MPLS_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrClassType][unknown_mpls_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_MULTICAST_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrClassType][known_mpls_multicast_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_MIM_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrClassType][known_mim_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_MIM_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrClassType][unknown_mim_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_TRILL_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrClassType][known_trill_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_TRILL_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrClassType][unknown_trill_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_NIV_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrClassType][known_niv_pkt]<<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_NIV_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrClassType][unknown_niv_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    loop++;
                } else
#endif
                {
                    shift_by_bits = svp_cmprsd_max_bits +
                        dvp_cmprsd_max_bits +
                        drop_cmprsd_max_bits +
                        ip_pkt_bits ;
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags & BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrPktType][unknown_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags & BCM_STAT_FLEX_PKT_TYPE_CONTROL_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrPktType][control_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags & BCM_STAT_FLEX_PKT_TYPE_OAM_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrPktType][oam_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags & BCM_STAT_FLEX_PKT_TYPE_BFD_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrPktType][bfd_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags & BCM_STAT_FLEX_PKT_TYPE_BPDU_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrPktType][bpdu_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags & BCM_STAT_FLEX_PKT_TYPE_ICNM_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrPktType][icnm_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags & BCM_STAT_FLEX_PKT_TYPE_PKT_IS_1588) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrPktType][_1588_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags & BCM_STAT_FLEX_PKT_TYPE_BFD_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrPktType][bfd_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_L2UC_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrPktType][known_l2uc_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_L2UC_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrPktType][unknown_l2uc_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags & BCM_STAT_FLEX_PKT_TYPE_L2BC_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrPktType][l2bc_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_L2MC_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrPktType][known_l2mc_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_L2MC_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrPktType][unknown_l2mc_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_L3UC_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrPktType][known_l3uc_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_L3UC_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrPktType][unknown_l3uc_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_IPMC_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrPktType][known_ipmc_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_IPMC_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrPktType][unknown_ipmc_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_L2_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrPktType][known_mpls_l2_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_L3_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrPktType][known_mpls_l3_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrPktType][known_mpls_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_MPLS_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrPktType][unknown_mpls_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_MULTICAST_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrPktType][known_mpls_multicast_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_MIM_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrPktType][known_mim_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_MIM_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrPktType][unknown_mim_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_TRILL_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrPktType][known_trill_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_TRILL_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrPktType][unknown_trill_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_KNOWN_NIV_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrPktType][known_niv_pkt]<<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
                    if (flex_attribute->combine_attr_counter[counter].
                            pkt_resolution_flags &
                            BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_NIV_PKT) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                                map_array[bcmStatGroupModeAttrPktType][unknown_niv_pkt] <<
                                shift_by_bits);
                        offset_array[loop][0] = temp_count+1;
                    }
#if defined(BCM_TRIDENT2_SUPPORT)
                    if (SOC_IS_TD2_TT2(unit)) {
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_KNOWN_L2GRE_PKT) {
                            temp_count = offset_array[loop][0];
                            offset_array[loop][temp_count+1]= (
                                    map_array[bcmStatGroupModeAttrPktType][known_l2gre_pkt] <<
                                    shift_by_bits);
                            offset_array[loop][0] = temp_count+1;
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_KNOWN_VXLAN_PKT) {
                            temp_count = offset_array[loop][0];
                            offset_array[loop][temp_count+1]= (
                                    map_array[bcmStatGroupModeAttrPktType][known_vxlan_pkt] <<
                                    shift_by_bits);
                            offset_array[loop][0] = temp_count+1;
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_KNOWN_FCOE_PKT) {
                            temp_count = offset_array[loop][0];
                            offset_array[loop][temp_count+1]= (
                                    map_array[bcmStatGroupModeAttrPktType][known_fcoe_pkt] <<
                                    shift_by_bits);
                            offset_array[loop][0] = temp_count+1;
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_flags &
                                BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_FCOE_PKT) {
                            temp_count = offset_array[loop][0];
                            offset_array[loop][temp_count+1]= (
                                    map_array[bcmStatGroupModeAttrPktType][unknown_fcoe_pkt] <<
                                    shift_by_bits);
                            offset_array[loop][0] = temp_count+1;
                        }
                    }
#endif
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_high_flags &
                                BCM_STAT_FLEX_PKT_TYPE_2_L2_UC_PKT) {
                            temp_count = offset_array[loop][0];
                            offset_array[loop][temp_count+1]= (
                                    map_array[bcmStatGroupModeAttrPktType][l2_uc_pkt] <<
                                    shift_by_bits);
                            offset_array[loop][0] = temp_count+1;
                        }
                        if (flex_attribute->combine_attr_counter[counter].
                                pkt_resolution_high_flags &
                                BCM_STAT_FLEX_PKT_TYPE_2_L2_NON_UC_PKT) {
                            temp_count = offset_array[loop][0];
                            offset_array[loop][temp_count+1]= (
                                    map_array[bcmStatGroupModeAttrPktType][l2_non_uc_pkt] <<
                                    shift_by_bits);
                            offset_array[loop][0] = temp_count+1;
                        }
                    
                    loop++;
                }
            }
            /* Logical Group 5 */
            if ((flex_attribute->svp != 0) &&
                (loop <= (BCM_STAT_FLEX_COUNTER_MAX_TOTAL_BITS - 2))) {
                shift_by_bits = dvp_cmprsd_max_bits + 
                                drop_cmprsd_max_bits + 
                                ip_pkt_bits ;
                if (direction == bcmStatFlexDirectionIngress) {
                    max_count= (1 << ing_pkt_attr_cmprsd_bits_g[unit].svp_type)-1;
                } else {
                    max_count= (1 << egr_pkt_attr_cmprsd_bits_g[unit].svp_type)-1;
                }
                for (loop_index=0; loop_index <= max_count ; loop_index++) { 
                    if (BCM_STAT_FLEX_VALUE_GET(
                            flex_attribute->combine_attr_counter[counter].
                            value_array[bcmStatFlexAttrSvp],loop_index)) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                 map_array[bcmStatGroupModeAttrIngNetworkGroup][loop_index] << 
                                                          shift_by_bits); 
                        offset_array[loop][0] = temp_count+1;
                    } 
                }
                loop++;
            }
            if ((flex_attribute->dvp != 0) &&
                (loop <= (BCM_STAT_FLEX_COUNTER_MAX_TOTAL_BITS - 2))) {
                shift_by_bits = drop_cmprsd_max_bits + 
                                ip_pkt_bits ;
                max_count= (1 << egr_pkt_attr_cmprsd_bits_g[unit].dvp_type)-1;
                for (loop_index=0; loop_index <= max_count ; loop_index++) { 
                    if (BCM_STAT_FLEX_VALUE_GET(
                            flex_attribute->combine_attr_counter[counter].
                            value_array[bcmStatFlexAttrDvp],loop_index)) {
                        temp_count = offset_array[loop][0];
                        offset_array[loop][temp_count+1]= (
                 map_array[bcmStatGroupModeAttrEgrNetworkGroup][loop_index] << 
                                                          shift_by_bits); 
                        offset_array[loop][0] = temp_count+1;
                    } 
                }
                loop++;
            }
            if ((flex_attribute->drop != 0) &&
                (loop <= (BCM_STAT_FLEX_COUNTER_MAX_TOTAL_BITS - 2))) {
                shift_by_bits = ip_pkt_bits ;
                if (flex_attribute->combine_attr_counter[counter].
                    drop_flags & BCM_STAT_FLEX_DROP_DISABLE) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                 map_array[bcmStatGroupModeAttrDrop][0] << shift_by_bits); 
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    drop_flags & BCM_STAT_FLEX_DROP_ENABLE) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (
                 map_array[bcmStatGroupModeAttrDrop][1] << shift_by_bits); 
                    offset_array[loop][0] = temp_count+1;
                }
                loop++;
            }
            if ((flex_attribute->ip_pkt != 0) &&
                (loop <= (BCM_STAT_FLEX_COUNTER_MAX_TOTAL_BITS - 2))) {
                shift_by_bits = 0;
                if (flex_attribute->combine_attr_counter[counter].
                    ip_pkt_flags & BCM_STAT_FLEX_IP_PKT_DISABLE) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (0 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                if (flex_attribute->combine_attr_counter[counter].
                    ip_pkt_flags & BCM_STAT_FLEX_IP_PKT_ENABLE) {
                    temp_count = offset_array[loop][0];
                    offset_array[loop][temp_count+1]= (1 << shift_by_bits);
                    offset_array[loop][0] = temp_count+1;
                }
                loop++;
            }
            /* Third and Final Level Update: Make Absolute Offset */
            for (index0=0;
                 index0 < offset_array[0][0] ; 
                 index0++) {
                 offset = offset_array[0][index0+1];
                 if (offset_array[1][0] != 0) {
                     for (index1=0;
                          index1 < offset_array[1][0] ; 
                          index1++) {
                          offset = offset_array[0][index0+1] | offset_array[1][index1+1];
                          if (offset_array[2][0] != 0) {
                              for (index2=0;
                                   index2 < offset_array[2][0] ; 
                                   index2++) {
                                   offset = offset_array[0][index0+1] | 
                                            offset_array[1][index1+1] |
                                            offset_array[2][index2+1];
                                   if (offset_array[3][0] != 0) {
                                       for (index3=0;
                                            index3 < offset_array[3][0] ; 
                                            index3++) {
                                            offset =  offset_array[0][index0+1] | 
                                                      offset_array[1][index1+1] |
                                                      offset_array[2][index2+1] |
                                                      offset_array[3][index3+1];
                                            if (offset_array[4][0] != 0) {
                                                for (index4=0;
                                                     index4 < offset_array[4][0] ; 
                                                     index4++) {
                                                     offset =  offset_array[0][index0+1] | 
                                                               offset_array[1][index1+1] |
                                                               offset_array[2][index2+1] |
                                                               offset_array[3][index3+1] |
                                                               offset_array[4][index4+1];
                                                     if (offset_array[5][0] != 0) {
                                                         for (index5=0;
                                                              index5 < offset_array[5][0] ; 
                                                              index5++) {
                                                              offset =  offset_array[0][index0+1] | 
                                                                        offset_array[1][index1+1] |
                                                                        offset_array[2][index2+1] |
                                                                        offset_array[3][index3+1] |
                                                                        offset_array[4][index4+1] |
                                                                        offset_array[5][index5+1];
                                                              if (offset_array[6][0] != 0) {
                                                                  for (index6=0;
                                                                       index6 < offset_array[6][0] ; 
                                                                       index6++) {
                                                                       offset =  offset_array[0][index0+1] | 
                                                                                 offset_array[1][index1+1] |
                                                                                 offset_array[2][index2+1] |
                                                                                 offset_array[3][index3+1] |
                                                                                 offset_array[4][index4+1] |
                                                                                 offset_array[5][index5+1] |
                                                                                 offset_array[6][index6+1];
                                                                       if (offset_array[7][0] != 0) {
                                                                           for (index7=0;
                                                                                index7 < offset_array[7][0] ; 
                                                                                index7++) {
                                                                                offset =  offset_array[0][index0+1] | 
                                                                                          offset_array[1][index1+1] |
                                                                                          offset_array[2][index2+1] |
                                                                                          offset_array[3][index3+1] |
                                                                                          offset_array[4][index4+1] |
                                                                                          offset_array[5][index5+1] |
                                                                                          offset_array[6][index6+1] |
                                                                                          offset_array[7][index6+1];
                                                                                rv = _bcm_stat_flex_update_map(direction,attr,
                                                                                                          offset,counter);
                                                                                BCMI_IF_ERROR_CLEANUP(rv);
                                                                           }
                                                                       } else {
                                                                           rv = _bcm_stat_flex_update_map(direction,attr,
                                                                                                     offset,counter);
                                                                           BCMI_IF_ERROR_CLEANUP(rv);
                                                                       }
                                                                  }
                                                              } else {
                                                                  rv = _bcm_stat_flex_update_map(direction,attr,offset,counter);
                                                                  BCMI_IF_ERROR_CLEANUP(rv);
                                                              }
                                                         }
                                                     } else {
                                                         rv = _bcm_stat_flex_update_map(direction,attr,offset,counter);
                                                         BCMI_IF_ERROR_CLEANUP(rv);
                                                     }
                                                }
                                            } else {
                                                rv = _bcm_stat_flex_update_map(direction,attr,offset,counter);
                                                BCMI_IF_ERROR_CLEANUP(rv);
                                            }
                                       }
                                   } else {
                                       rv = _bcm_stat_flex_update_map(direction,attr,offset,counter);
                                       BCMI_IF_ERROR_CLEANUP(rv);
                                   }
                              }
                          } else {
                              rv = _bcm_stat_flex_update_map(direction,attr,offset,counter);
                              BCMI_IF_ERROR_CLEANUP(rv);
                          }
                     }
                 } else {
                     rv = _bcm_stat_flex_update_map(direction,attr,offset,counter);
                     BCMI_IF_ERROR_CLEANUP(rv);
                 }
            }
       }
 }
 /*
 * COVERITY
 *
 * Intentional stack usage.
 */
 /* coverity[stack_use_callee_max : FALSE] */
 /* coverity[stack_use_overflow : FALSE] */
 rv =  _bcm_esw_stat_flex_create_mode(unit,attr,&mode,flex_attribute);
 if (soc_feature(unit, soc_feature_flex_stat_compression_share)) {
     if (rv == BCM_E_NONE) {
         if(ing_attr != NULL) {
             if (direction == bcmStatFlexDirectionIngress &&
                     ing_attr->packet_attr_type ==  
                     bcmStatFlexPacketAttrTypeCompressed) {
                 rv = _bcm_esw_stat_flex_compressed_attr_map_update(unit,
                         direction,flex_attribute,ing_cmprsd_pkt_attr_bits,
                         NULL);
             }
         }
         if (egr_attr != NULL) {
             if(direction == bcmStatFlexDirectionEgress &&
                     egr_attr->packet_attr_type ==  
                     bcmStatFlexPacketAttrTypeCompressed) {
                 rv = _bcm_esw_stat_flex_compressed_attr_map_update(unit,
                         direction,flex_attribute,NULL,
                         egr_cmprsd_pkt_attr_bits);
             }
         }
     }
 }

 if (NULL != mode_id) {
     *mode_id = mode;
 } else {
    for (loop = 0; loop < 8; loop++) {
        if (offset_array[loop] != NULL) {
            sal_free(offset_array[loop]);
        }
    }
    
    for (loop = 0; loop < bcmStatGroupModeAttrMaxValue; loop++) {
        if (map_array[loop] != NULL) {
            sal_free(map_array[loop]);
        }
    }
    
    sal_free(attr);
    return BCM_E_PARAM;
 }
 
cleanup:
 
 for (loop = 0; loop < 8; loop++) {
     if (offset_array[loop] != NULL) {
         sal_free(offset_array[loop]);
     }
 }
 for (loop = 0; loop < bcmStatGroupModeAttrMaxValue; loop++) {
      if (map_array[loop] != NULL) {
          sal_free(map_array[loop]);
      }
 }
 if (attr != NULL) {
     sal_free(attr);
 }
 return rv;
}

/* Create Customized Stat Group mode for given Counter Attributes:FillUpValues*/
static 
bcm_error_t _bcm_esw_stat_group_mode_fillup_values(
            int unit,
            uint32 flags,
            uint32 total_counters,
            uint32 num_selectors,
            bcm_stat_group_mode_attr_selector_t *attr_selectors,
            bcm_stat_flex_attribute_t  *flex_attribute)
{
    uint32 sel=0;
    uint32 counter_offset=0;              /* Counter Offset */
    bcm_stat_group_mode_attr_t attr=0;    /* (Invalid)Attribute Selector */
    uint32 attr_value=0;                  /* Attribute Values */
    uint32 value=0;
    uint32 max_value=0;
    uint32 array_index=0;
    uint32 udf_bitmap = 0, i, udf_max_num_bits = 0;
#ifdef BCM_KATANA2_SUPPORT
    uint32 iter = 0;
#endif

    for (sel = 0; sel < num_selectors ; sel++) {
         counter_offset = attr_selectors[sel].counter_offset;
         attr = attr_selectors[sel].attr;
         attr_value = attr_selectors[sel].attr_value;
         if (counter_offset >=  total_counters) {
             return BCM_E_PARAM;
         }

         if (flags & BCM_STAT_GROUP_MODE_UDF) {
            switch(attr) {
                case bcmStatGroupModeAttrDrop:
                    flex_attribute->drop = 1;
                    switch(attr_value) {
                        case 0:
                             flex_attribute->combine_attr_counter[counter_offset].
                                 drop_flags |= BCM_STAT_FLEX_DROP_DISABLE;
                             break;
                        case 1:
                             flex_attribute->combine_attr_counter[counter_offset].
                                 drop_flags |= BCM_STAT_FLEX_DROP_ENABLE;
                             break;
                        case BCM_STAT_GROUP_MODE_ATTR_ALL_VALUES:
                             flex_attribute->combine_attr_counter[counter_offset].
                                 drop_flags |= (BCM_STAT_FLEX_DROP_ENABLE |
                                                BCM_STAT_FLEX_DROP_DISABLE);
                             break;
                        default:
                           LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                                     (BSL_META_U(unit,
                                                 "BAD PARAM(DropType)"
                                                 ":sel=%d offset=%d attr=%d value=%d\n"),
                                                 sel, counter_offset , attr, attr_value ));
                           return BCM_E_PARAM;
                      }
                      break;
                case bcmStatGroupModeAttrUdf:
                    flex_attribute->udf = 1;
                    flex_attribute->udf_bitmap = attr_selectors[sel].udf_bitmap;
                    /*udf_bitmap should be same in one stat group mode*/
                    if (udf_bitmap == 0) {
                        udf_bitmap = flex_attribute->udf_bitmap;
                        for (i = 0; i < 32; i++) {
                            udf_max_num_bits += udf_bitmap & 0x1;
                            udf_bitmap = udf_bitmap >> 1;
                        }
                        udf_bitmap = flex_attribute->udf_bitmap;
                    } else if (udf_bitmap != flex_attribute->udf_bitmap) {
                        return BCM_E_PARAM;
                    }
                    /*When AttrDrop is enabled, max number of udf bit is 7.
                     *When AttrDrop is not enabled, max number of udf bit is 8.
                     * We donot know if AttrDrop is enabled at this moment, so let max bit be 8.
                     */
                    if (udf_max_num_bits > 8 ||
                        attr_value > ((1 << udf_max_num_bits) -1)) {
                        return BCM_E_PARAM;
                    }
                    BCM_STAT_FLEX_VALUE_SET(
                        flex_attribute->combine_attr_counter[counter_offset].
                        value_array[bcmStatFlexAttrUdf], attr_value);
                    break;
                default:
                    return BCM_E_PARAM;
            }
            continue;
         }

      switch(attr) {
         case bcmStatGroupModeAttrColor:
              flex_attribute->pre_ifp_color=1;
              switch(attr_value) {
              case bcmColorGreen:
                   flex_attribute->combine_attr_counter[counter_offset].
                        pre_ifp_color_flags |= BCM_STAT_FLEX_COLOR_GREEN;
                   break;
              case bcmColorYellow:
                   flex_attribute->combine_attr_counter[counter_offset].
                        pre_ifp_color_flags |= BCM_STAT_FLEX_COLOR_YELLOW;
                   break;
              case bcmColorRed:
                   flex_attribute->combine_attr_counter[counter_offset].
                        pre_ifp_color_flags |= BCM_STAT_FLEX_COLOR_RED;
                   break;
              case BCM_STAT_GROUP_MODE_ATTR_ALL_VALUES:
                   flex_attribute->combine_attr_counter[counter_offset].
                        pre_ifp_color_flags |= (BCM_STAT_FLEX_COLOR_GREEN |
                                                BCM_STAT_FLEX_COLOR_YELLOW |
                                                BCM_STAT_FLEX_COLOR_RED); 
                   break;
              default: 
                  LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                            (BSL_META_U(unit,
                                        "BAD PARAM(Color):sel=%d offset=%d"
                                        "attr=%d value=%d\n"), sel,
                                        counter_offset, attr, attr_value));
                  return BCM_E_PARAM;
              }
              if (soc_feature(unit, soc_feature_flex_stat_compression_share)) {
                  flex_attribute->combine_pre_ifp_color_flags |=
                      flex_attribute->combine_attr_counter[counter_offset].
                      pre_ifp_color_flags;
              }
       
              break;
         case bcmStatGroupModeAttrFieldIngressColor:
              flex_attribute->ifp_color=1;
              switch(attr_value) {
              case bcmColorGreen:
                   flex_attribute->combine_attr_counter[counter_offset].
                        ifp_color_flags |= BCM_STAT_FLEX_COLOR_GREEN;
                   break;
              case bcmColorYellow:
                   flex_attribute->combine_attr_counter[counter_offset].
                        ifp_color_flags |= BCM_STAT_FLEX_COLOR_YELLOW;
                   break;
              case bcmColorRed:
                   flex_attribute->combine_attr_counter[counter_offset].
                        ifp_color_flags |= BCM_STAT_FLEX_COLOR_RED;
                   break;
              case BCM_STAT_GROUP_MODE_ATTR_ALL_VALUES:
                   flex_attribute->combine_attr_counter[counter_offset].
                        ifp_color_flags |= (BCM_STAT_FLEX_COLOR_GREEN |
                                            BCM_STAT_FLEX_COLOR_YELLOW |
                                            BCM_STAT_FLEX_COLOR_RED); 
                   break;
              default: 
                   LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                             (BSL_META_U(unit,
                                         "BAD PARAM(FieldIngressColor)"
                                         ":sel=%d offset=%d attr=%d value=%d\n"),
                                         sel, counter_offset , attr, attr_value ));
                   return BCM_E_PARAM;
              }

              if (soc_feature(unit, soc_feature_flex_stat_compression_share)) {
                  flex_attribute->combine_ifp_color_flags |=
                      flex_attribute->combine_attr_counter[counter_offset].
                      ifp_color_flags;
              }
              break;
         case bcmStatGroupModeAttrIntPri:
              flex_attribute->int_pri=1;
              switch(attr_value) {
              case 0:   
                     flex_attribute->combine_attr_counter[counter_offset].
                         int_pri_flags |= BCM_STAT_FLEX_PRI0;
                     break;
              case 1:   
                     flex_attribute->combine_attr_counter[counter_offset].
                         int_pri_flags |= BCM_STAT_FLEX_PRI1;
                     break;
              case 2:   
                     flex_attribute->combine_attr_counter[counter_offset].
                         int_pri_flags |= BCM_STAT_FLEX_PRI2;
                     break;
              case 3:   
                     flex_attribute->combine_attr_counter[counter_offset].
                         int_pri_flags |= BCM_STAT_FLEX_PRI3;
                     break;
              case 4:   
                     flex_attribute->combine_attr_counter[counter_offset].
                         int_pri_flags |= BCM_STAT_FLEX_PRI4;
                     break;
              case 5:   
                     flex_attribute->combine_attr_counter[counter_offset].
                         int_pri_flags |= BCM_STAT_FLEX_PRI5;
                     break;
              case 6:   
                     flex_attribute->combine_attr_counter[counter_offset].
                         int_pri_flags |= BCM_STAT_FLEX_PRI6;
                     break;
              case 7:   
                     flex_attribute->combine_attr_counter[counter_offset].
                         int_pri_flags |= BCM_STAT_FLEX_PRI7;
                     break;
              case 8:   
                     flex_attribute->combine_attr_counter[counter_offset].
                         int_pri_flags |= BCM_STAT_FLEX_PRI8;
                     break;
              case 9:   
                     flex_attribute->combine_attr_counter[counter_offset].
                         int_pri_flags |= BCM_STAT_FLEX_PRI9;
                     break;
              case 10:   
                     flex_attribute->combine_attr_counter[counter_offset].
                         int_pri_flags |= BCM_STAT_FLEX_PRI10;
                     break;
              case 11:   
                     flex_attribute->combine_attr_counter[counter_offset].
                         int_pri_flags |= BCM_STAT_FLEX_PRI11;
                     break;
              case 12:   
                     flex_attribute->combine_attr_counter[counter_offset].
                         int_pri_flags |= BCM_STAT_FLEX_PRI12;
                     break;
              case 13:   
                     flex_attribute->combine_attr_counter[counter_offset].
                         int_pri_flags |= BCM_STAT_FLEX_PRI13;
                     break;
              case 14:   
                     flex_attribute->combine_attr_counter[counter_offset].
                         int_pri_flags |= BCM_STAT_FLEX_PRI14;
                     break;
              case 15:   
                     flex_attribute->combine_attr_counter[counter_offset].
                         int_pri_flags |= BCM_STAT_FLEX_PRI15;
                     break;
              case BCM_STAT_GROUP_MODE_ATTR_ALL_VALUES:
                     flex_attribute->combine_attr_counter[counter_offset].
                         int_pri_flags |= (BCM_STAT_FLEX_PRI0 |
                                           BCM_STAT_FLEX_PRI1 |
                                           BCM_STAT_FLEX_PRI2 |
                                           BCM_STAT_FLEX_PRI3 |
                                           BCM_STAT_FLEX_PRI4 |
                                           BCM_STAT_FLEX_PRI5 |
                                           BCM_STAT_FLEX_PRI6 |
                                           BCM_STAT_FLEX_PRI7 |
                                           BCM_STAT_FLEX_PRI8 |
                                           BCM_STAT_FLEX_PRI9 |
                                           BCM_STAT_FLEX_PRI10 |
                                           BCM_STAT_FLEX_PRI11 |
                                           BCM_STAT_FLEX_PRI12 |
                                           BCM_STAT_FLEX_PRI13 |
                                           BCM_STAT_FLEX_PRI14 |
                                           BCM_STAT_FLEX_PRI15);
                     break;
              default:
                   LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                             (BSL_META_U(unit,
                                         "BAD PARAM(IntPri)"
                                         ":sel=%d offset=%d attr=%d value=%d\n"),
                                         sel, counter_offset , attr, attr_value ));
                   return BCM_E_PARAM;
              }

              if (soc_feature(unit, soc_feature_flex_stat_compression_share)) {
                  flex_attribute->combine_int_pri_flags |=
                      flex_attribute->combine_attr_counter[counter_offset].
                      int_pri_flags;
              }
              break;
         case bcmStatGroupModeAttrVlan:
              flex_attribute->vlan_format = 1;
              switch(attr_value) {
              case bcmStatGroupModeAttrVlanUnTagged:
                   flex_attribute->combine_attr_counter[counter_offset].
                        vlan_format_flags |= BCM_STAT_FLEX_VLAN_FORMAT_UNTAGGED;
                   break;
              case bcmStatGroupModeAttrVlanInnerTag:
                   flex_attribute->combine_attr_counter[counter_offset].
                        vlan_format_flags |= BCM_STAT_FLEX_VLAN_FORMAT_INNER;
                   break;
              case bcmStatGroupModeAttrVlanOuterTag:
                   flex_attribute->combine_attr_counter[counter_offset].
                        vlan_format_flags |= BCM_STAT_FLEX_VLAN_FORMAT_OUTER;
                   break;
              case bcmStatGroupModeAttrVlanStackedTag:
                   flex_attribute->combine_attr_counter[counter_offset].
                        vlan_format_flags |= BCM_STAT_FLEX_VLAN_FORMAT_BOTH;
                   break;
              case bcmStatGroupModeAttrVlanAll:
              case BCM_STAT_GROUP_MODE_ATTR_ALL_VALUES:
                   flex_attribute->combine_attr_counter[counter_offset].
                        vlan_format_flags |= (BCM_STAT_FLEX_VLAN_FORMAT_BOTH |
                                              BCM_STAT_FLEX_VLAN_FORMAT_INNER |
                                              BCM_STAT_FLEX_VLAN_FORMAT_OUTER |
                                              BCM_STAT_FLEX_VLAN_FORMAT_UNTAGGED);
                   break;
              default:
                   LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                             (BSL_META_U(unit,
                                         "BAD PARAM(VlanFormat)"
                                         ":sel=%d offset=%d attr=%d value=%d\n"),
                                         sel, counter_offset , attr, attr_value ));
                   return BCM_E_PARAM;
              }

              if (soc_feature(unit, soc_feature_flex_stat_compression_share)) {
                  flex_attribute->combine_vlan_format_flags |=
                      flex_attribute->combine_attr_counter[counter_offset].
                      vlan_format_flags;
              }
              break;
         case bcmStatGroupModeAttrOuterPri:
              flex_attribute->outer_dot1p = 1;
              switch(attr_value) {
              case 0:   
                     flex_attribute->combine_attr_counter[counter_offset].
                         outer_dot1p_flags |= BCM_STAT_FLEX_PRI0;
                     break;
              case 1:   
                     flex_attribute->combine_attr_counter[counter_offset].
                         outer_dot1p_flags |= BCM_STAT_FLEX_PRI1;
                     break;
              case 2:   
                     flex_attribute->combine_attr_counter[counter_offset].
                         outer_dot1p_flags |= BCM_STAT_FLEX_PRI2;
                     break;
              case 3:   
                     flex_attribute->combine_attr_counter[counter_offset].
                         outer_dot1p_flags |= BCM_STAT_FLEX_PRI3;
                     break;
              case 4:   
                     flex_attribute->combine_attr_counter[counter_offset].
                         outer_dot1p_flags |= BCM_STAT_FLEX_PRI4;
                     break;
              case 5:   
                     flex_attribute->combine_attr_counter[counter_offset].
                         outer_dot1p_flags |= BCM_STAT_FLEX_PRI5;
                     break;
              case 6:   
                     flex_attribute->combine_attr_counter[counter_offset].
                         outer_dot1p_flags |= BCM_STAT_FLEX_PRI6;
                     break;
              case 7:   
                     flex_attribute->combine_attr_counter[counter_offset].
                         outer_dot1p_flags |= BCM_STAT_FLEX_PRI7;
                     break;
              case BCM_STAT_GROUP_MODE_ATTR_ALL_VALUES:
                     flex_attribute->combine_attr_counter[counter_offset].
                         outer_dot1p_flags |= (BCM_STAT_FLEX_PRI0 |
                                               BCM_STAT_FLEX_PRI1 |
                                               BCM_STAT_FLEX_PRI2 |
                                               BCM_STAT_FLEX_PRI3 |
                                               BCM_STAT_FLEX_PRI4 |
                                               BCM_STAT_FLEX_PRI5 |
                                               BCM_STAT_FLEX_PRI6 |
                                               BCM_STAT_FLEX_PRI7);
                     break;
              default:
                   LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                             (BSL_META_U(unit,
                                         "BAD PARAM(OuterPri)"
                                         ":sel=%d offset=%d attr=%d value=%d\n"),
                                         sel, counter_offset , attr, attr_value ));
                   return BCM_E_PARAM;
              }

              if (soc_feature(unit, soc_feature_flex_stat_compression_share)) {
                  flex_attribute->combine_outer_dot1p_flags |=
                      flex_attribute->combine_attr_counter[counter_offset].
                      outer_dot1p_flags;
              }
              break;
         case bcmStatGroupModeAttrInnerPri:
              flex_attribute->inner_dot1p = 1;
              switch(attr_value) {
              case 0:   
                     flex_attribute->combine_attr_counter[counter_offset].
                         inner_dot1p_flags |= BCM_STAT_FLEX_PRI0;
                     break;
              case 1:   
                     flex_attribute->combine_attr_counter[counter_offset].
                         inner_dot1p_flags |= BCM_STAT_FLEX_PRI1;
                     break;
              case 2:   
                     flex_attribute->combine_attr_counter[counter_offset].
                         inner_dot1p_flags |= BCM_STAT_FLEX_PRI2;
                     break;
              case 3:   
                     flex_attribute->combine_attr_counter[counter_offset].
                         inner_dot1p_flags |= BCM_STAT_FLEX_PRI3;
                     break;
              case 4:   
                     flex_attribute->combine_attr_counter[counter_offset].
                         inner_dot1p_flags |= BCM_STAT_FLEX_PRI4;
                     break;
              case 5:   
                     flex_attribute->combine_attr_counter[counter_offset].
                         inner_dot1p_flags |= BCM_STAT_FLEX_PRI5;
                     break;
              case 6:   
                     flex_attribute->combine_attr_counter[counter_offset].
                         inner_dot1p_flags |= BCM_STAT_FLEX_PRI6;
                     break;
              case 7:   
                     flex_attribute->combine_attr_counter[counter_offset].
                         inner_dot1p_flags |= BCM_STAT_FLEX_PRI7;
                     break;
              case BCM_STAT_GROUP_MODE_ATTR_ALL_VALUES:
                     flex_attribute->combine_attr_counter[counter_offset].
                         inner_dot1p_flags |= (BCM_STAT_FLEX_PRI0 |
                                               BCM_STAT_FLEX_PRI1 |
                                               BCM_STAT_FLEX_PRI2 |
                                               BCM_STAT_FLEX_PRI3 |
                                               BCM_STAT_FLEX_PRI4 |
                                               BCM_STAT_FLEX_PRI5 |
                                               BCM_STAT_FLEX_PRI6 |
                                               BCM_STAT_FLEX_PRI7);
                     break;
              default:
                   LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                             (BSL_META_U(unit,
                                         "BAD PARAM(InnerPri)"
                                         ":sel=%d offset=%d attr=%d value=%d\n"),
                                         sel, counter_offset , attr, attr_value ));
                   return BCM_E_PARAM;
              }

              if (soc_feature(unit, soc_feature_flex_stat_compression_share)) {
                  flex_attribute->combine_inner_dot1p_flags |=
                      flex_attribute->combine_attr_counter[counter_offset].
                      inner_dot1p_flags;
              }
              break;
         case bcmStatGroupModeAttrPort:
         case bcmStatGroupModePortGroup:
              flex_attribute->port = 1;
              if (flags & BCM_STAT_GROUP_MODE_INGRESS) {
                  max_value = (1 << ing_pkt_attr_uncmprsd_bits_g[unit].ing_port) - 1;
              } else {
                  max_value = (1 << egr_pkt_attr_uncmprsd_bits_g[unit].egr_port) - 1;
              }   
              switch(attr_value) {
              case BCM_STAT_GROUP_MODE_ATTR_ALL_VALUES:
                   for(value=0;value <= max_value ; value++) {
                       BCM_STAT_FLEX_VALUE_SET(
                           flex_attribute->combine_attr_counter[counter_offset].
                           value_array[bcmStatFlexAttrPort], value);
                   }
                   break;
              default:
#if defined(BCM_CHANNELIZED_SWITCHING_SUPPORT)
                  if ((soc_feature(unit, soc_feature_channelized_switching)) &&
                      BCM_GPORT_IS_SET(attr_value) &&
                      _BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, attr_value)) {
                      int subport_num = 0;

                      /* Now get the subport number associated with this sub-port. */
                      BCM_IF_ERROR_RETURN(
                          _bcm_coe_subtag_subport_port_subport_num_get(unit,
                          attr_value, NULL, &subport_num));
                      attr_value = subport_num;
                      flex_attribute->port = 0;
                      flex_attribute->subport = 1;
                      /* Max count for port + subports. 72 + 384 = 456 */
                      max_value = 456;;
                  }
#endif

                   if (attr_value > max_value) {
                       LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                                 (BSL_META_U(unit,
                                             "BAD PARAM(Port)"
                                             ":sel=%d offset=%d attr=%d value=%d\n"),
                                             sel, counter_offset , attr, attr_value ));
                       return BCM_E_PARAM;
                   }
                   BCM_STAT_FLEX_VALUE_SET(
                           flex_attribute->combine_attr_counter[counter_offset].
                           value_array[bcmStatFlexAttrPort], attr_value);
                   break;
              } 
              break;
         case bcmStatGroupModeAttrTosDscp:
              flex_attribute->tos_dscp = 1;
              if (flags & BCM_STAT_GROUP_MODE_INGRESS) {
                  max_value = (1 << ing_pkt_attr_uncmprsd_bits_g[unit].tos_dscp) - 1;
              } else {
                  max_value = (1 << egr_pkt_attr_uncmprsd_bits_g[unit].tos_dscp) - 1;
              }   
              switch(attr_value) {
              case BCM_STAT_GROUP_MODE_ATTR_ALL_VALUES:
                   for(value=0;value <= max_value ; value++) {
                       BCM_STAT_FLEX_VALUE_SET(
                           flex_attribute->combine_attr_counter[counter_offset].
                           value_array[bcmStatFlexAttrTosDscp], value);
                   }
                   break;
              default:
                   if (attr_value > max_value) {
                       LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                                 (BSL_META_U(unit,
                                             "BAD PARAM(Tos)"
                                             ":sel=%d offset=%d attr=%d value=%d\n"),
                                             sel, counter_offset , attr, attr_value ));
                       return BCM_E_PARAM;
                   }    
                   BCM_STAT_FLEX_VALUE_SET(
                       flex_attribute->combine_attr_counter[counter_offset].
                       value_array[bcmStatFlexAttrTosDscp], attr_value);
                   break;
              }
              break;
         case bcmStatGroupModeAttrTosEcn:
              flex_attribute->tos_ecn = 1;
              if (flags & BCM_STAT_GROUP_MODE_INGRESS) {
                  max_value = (1 << ing_pkt_attr_uncmprsd_bits_g[unit].tos_ecn) - 1;
              } else {
                  max_value = (1 << egr_pkt_attr_uncmprsd_bits_g[unit].tos_ecn) - 1;
              }   
              switch(attr_value) {
              case BCM_STAT_GROUP_MODE_ATTR_ALL_VALUES:
                   for(value=0;value <= max_value ; value++) {
                       BCM_STAT_FLEX_VALUE_SET(
                           flex_attribute->combine_attr_counter[counter_offset].
                           value_array[bcmStatFlexAttrTosEcn], value);
                   }
                   break;
              default:
                   if (attr_value > max_value) {
                       LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                                 (BSL_META_U(unit,
                                             "BAD PARAM(Tos)"
                                             ":sel=%d offset=%d attr=%d value=%d\n"),
                                             sel, counter_offset , attr, attr_value ));
                       return BCM_E_PARAM;
                   }    
                   BCM_STAT_FLEX_VALUE_SET(
                       flex_attribute->combine_attr_counter[counter_offset].
                       value_array[bcmStatFlexAttrTosEcn], attr_value);
                   break;
              }
              break;
         case bcmStatGroupModeAttrPktType:
              flex_attribute->pkt_resolution = 1;
              switch(attr_value) {
              case bcmStatGroupModeAttrPktTypeUnknown:
                   flex_attribute->combine_attr_counter[counter_offset].
                         pkt_resolution_flags |= 
                         BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_PKT;
                   break; 
              case bcmStatGroupModeAttrPktTypeControl:
                   flex_attribute->combine_attr_counter[counter_offset].
                         pkt_resolution_flags |= 
                         BCM_STAT_FLEX_PKT_TYPE_CONTROL_PKT                ;
                   break; 
              case bcmStatGroupModeAttrPktTypeOAM:
                   flex_attribute->combine_attr_counter[counter_offset].
                         pkt_resolution_flags |= 
                         BCM_STAT_FLEX_PKT_TYPE_OAM_PKT                    ;
                   break;
              case bcmStatGroupModeAttrPktTypeBFD:
                   flex_attribute->combine_attr_counter[counter_offset].
                         pkt_resolution_flags |= 
                         BCM_STAT_FLEX_PKT_TYPE_BFD_PKT                    ;
                   break;
              case bcmStatGroupModeAttrPktTypeBPDU:
                   flex_attribute->combine_attr_counter[counter_offset].
                         pkt_resolution_flags |= 
                         BCM_STAT_FLEX_PKT_TYPE_BPDU_PKT                   ;
                   break;
              case bcmStatGroupModeAttrPktTypeICNM:
                   flex_attribute->combine_attr_counter[counter_offset].
                         pkt_resolution_flags |= 
                         BCM_STAT_FLEX_PKT_TYPE_ICNM_PKT                   ;
                   break;
              case bcmStatGroupModeAttrPktType1588:
                   flex_attribute->combine_attr_counter[counter_offset].
                         pkt_resolution_flags |= 
                         BCM_STAT_FLEX_PKT_TYPE_PKT_IS_1588                ;
                   break;
              case bcmStatGroupModeAttrPktTypeKnownL2UC:
                   flex_attribute->combine_attr_counter[counter_offset].
                         pkt_resolution_flags |= 
                         BCM_STAT_FLEX_PKT_TYPE_KNOWN_L2UC_PKT             ;
                   break; 
              case bcmStatGroupModeAttrPktTypeUnknownL2UC:
                   flex_attribute->combine_attr_counter[counter_offset].
                         pkt_resolution_flags |= 
                         BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_L2UC_PKT           ;
                   break;
              case bcmStatGroupModeAttrPktTypeL2BC:
                   flex_attribute->combine_attr_counter[counter_offset].
                         pkt_resolution_flags |= 
                         BCM_STAT_FLEX_PKT_TYPE_L2BC_PKT                   ;
                   break;
              case bcmStatGroupModeAttrPktTypeKnownL2MC:
                   flex_attribute->combine_attr_counter[counter_offset].
                         pkt_resolution_flags |= 
                         BCM_STAT_FLEX_PKT_TYPE_KNOWN_L2MC_PKT             ;
                   break;
              case bcmStatGroupModeAttrPktTypeUnknownL2MC:
                   flex_attribute->combine_attr_counter[counter_offset].
                         pkt_resolution_flags |= 
                         BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_L2MC_PKT           ;
                   break;
              case bcmStatGroupModeAttrPktTypeKnownL3UC:
                   flex_attribute->combine_attr_counter[counter_offset].
                         pkt_resolution_flags |= 
                         BCM_STAT_FLEX_PKT_TYPE_KNOWN_L3UC_PKT             ;
                   break;
              case bcmStatGroupModeAttrPktTypeUnknownL3UC:
                   flex_attribute->combine_attr_counter[counter_offset].
                         pkt_resolution_flags |= 
                         BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_L3UC_PKT           ;
                   break;
              case bcmStatGroupModeAttrPktTypeKnownIPMC :
                   flex_attribute->combine_attr_counter[counter_offset].
                         pkt_resolution_flags |= 
                         BCM_STAT_FLEX_PKT_TYPE_KNOWN_IPMC_PKT             ;
                   break; 
              case bcmStatGroupModeAttrPktTypeUnknownIPMC :
                   flex_attribute->combine_attr_counter[counter_offset].
                         pkt_resolution_flags |= 
                         BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_IPMC_PKT           ;
                   break;
              case bcmStatGroupModeAttrPktTypeKnownMplsL2 :
                   flex_attribute->combine_attr_counter[counter_offset].
                         pkt_resolution_flags |= 
                         BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_L2_PKT          ;
                   break;
              case bcmStatGroupModeAttrPktTypeKnownMplsL3 :
                   flex_attribute->combine_attr_counter[counter_offset].
                         pkt_resolution_flags |= 
                         BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_L3_PKT          ;
                   break;
              case bcmStatGroupModeAttrPktTypeKnownMpls :
                   flex_attribute->combine_attr_counter[counter_offset].
                         pkt_resolution_flags |=
                         BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_PKT             ;
                   break;
              case bcmStatGroupModeAttrPktTypeUnknownMpls :
                   flex_attribute->combine_attr_counter[counter_offset].
                         pkt_resolution_flags |=
                         BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_MPLS_PKT           ;
                   break;
              case bcmStatGroupModeAttrPktTypeKnownMplsMulticast:
                   flex_attribute->combine_attr_counter[counter_offset].
                         pkt_resolution_flags |=
                         BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_MULTICAST_PKT   ;
                   break;
              case bcmStatGroupModeAttrPktTypeKnownMim:
                   flex_attribute->combine_attr_counter[counter_offset].
                         pkt_resolution_flags |=
                         BCM_STAT_FLEX_PKT_TYPE_KNOWN_MIM_PKT              ;
                   break;
              case bcmStatGroupModeAttrPktTypeUnknownMim:
                   flex_attribute->combine_attr_counter[counter_offset].
                         pkt_resolution_flags |=
                         BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_MIM_PKT            ;
                   break;
              case bcmStatGroupModeAttrPktTypeKnownTrill:
                   flex_attribute->combine_attr_counter[counter_offset].
                         pkt_resolution_flags |=
                         BCM_STAT_FLEX_PKT_TYPE_KNOWN_TRILL_PKT            ;
                   break;
              case bcmStatGroupModeAttrPktTypeUnknownTrill:
                   flex_attribute->combine_attr_counter[counter_offset].
                         pkt_resolution_flags |=
                         BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_TRILL_PKT          ;
                   break;
              case bcmStatGroupModeAttrPktTypeKnownNiv:
                   flex_attribute->combine_attr_counter[counter_offset].
                         pkt_resolution_flags |=
                         BCM_STAT_FLEX_PKT_TYPE_KNOWN_NIV_PKT              ;
                   break;
              case bcmStatGroupModeAttrPktTypeUnknownNiv:
                   flex_attribute->combine_attr_counter[counter_offset].
                         pkt_resolution_flags |=
                         BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_NIV_PKT              ;
                   break;
              case bcmStatGroupModeAttrPktTypeL2UC:
                   flex_attribute->combine_attr_counter[counter_offset].
                         pkt_resolution_high_flags |=
                         BCM_STAT_FLEX_PKT_TYPE_2_L2_UC_PKT            ;
                   break;
              case bcmStatGroupModeAttrPktTypeL2NonUC:
                   flex_attribute->combine_attr_counter[counter_offset].
                         pkt_resolution_high_flags |=
                         BCM_STAT_FLEX_PKT_TYPE_2_L2_NON_UC_PKT            ;
                   break;
              case bcmStatGroupModeAttrPktTypeAll:
              case BCM_STAT_GROUP_MODE_ATTR_ALL_VALUES:
                   flex_attribute->combine_attr_counter[counter_offset].
                         pkt_resolution_flags |= (
                         BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_PKT                |
                         BCM_STAT_FLEX_PKT_TYPE_CONTROL_PKT                |
                         BCM_STAT_FLEX_PKT_TYPE_OAM_PKT                    |
                         BCM_STAT_FLEX_PKT_TYPE_BFD_PKT                    |
                         BCM_STAT_FLEX_PKT_TYPE_BPDU_PKT                   |
                         BCM_STAT_FLEX_PKT_TYPE_ICNM_PKT                   |
                         BCM_STAT_FLEX_PKT_TYPE_PKT_IS_1588                |
                         BCM_STAT_FLEX_PKT_TYPE_KNOWN_L2UC_PKT             |
                         BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_L2UC_PKT           |
                         BCM_STAT_FLEX_PKT_TYPE_L2BC_PKT                   |
                         BCM_STAT_FLEX_PKT_TYPE_KNOWN_L2MC_PKT             |
                         BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_L2MC_PKT           |
                         BCM_STAT_FLEX_PKT_TYPE_KNOWN_L3UC_PKT             |
                         BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_L3UC_PKT           |
                         BCM_STAT_FLEX_PKT_TYPE_KNOWN_IPMC_PKT             |
                         BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_IPMC_PKT           |
                         BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_L2_PKT          |
                         BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_L3_PKT          |
                         BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_PKT             |
                         BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_MPLS_PKT           |
                         BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_MULTICAST_PKT   |
                         BCM_STAT_FLEX_PKT_TYPE_KNOWN_MIM_PKT              |
                         BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_MIM_PKT            |
                         BCM_STAT_FLEX_PKT_TYPE_KNOWN_TRILL_PKT            |
                         BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_TRILL_PKT          |
                         BCM_STAT_FLEX_PKT_TYPE_KNOWN_NIV_PKT              |
                         BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_NIV_PKT            );
#if defined(BCM_TRIDENT2_SUPPORT)
                        if (SOC_IS_TD2_TT2(unit)) {
                            flex_attribute->combine_attr_counter[counter_offset].
                                 pkt_resolution_flags |= (
                                 BCM_STAT_FLEX_PKT_TYPE_KNOWN_L2GRE_PKT                |
                                 BCM_STAT_FLEX_PKT_TYPE_KNOWN_VXLAN_PKT                |
                                 BCM_STAT_FLEX_PKT_TYPE_KNOWN_FCOE_PKT                    |
                                 BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_FCOE_PKT );
                        }
#endif
                    break;
              default:
                   LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                             (BSL_META_U(unit,
                                         "BAD PARAM(PktType)"
                                         ":sel=%d offset=%d attr=%d value=%d\n"),
                                         sel, counter_offset , attr, attr_value ));
                   return BCM_E_PARAM;
              }

              if(flags & BCM_STAT_GROUP_MODE_INGRESS) {
                  if (flex_attribute->combine_attr_counter[counter_offset].
                         pkt_resolution_high_flags ) {
                      /* L2-UC and L2-NON-UC attr types are not applicable
                         on Ingress. pkt_resolution_high_flags is updated for these */
                      LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                            (BSL_META_U(unit,
                                        "BAD PARAM(PktType) for Ingress attr_value:%d\n"),
                                        attr_value));
                      return BCM_E_PARAM;
                  }
              }

              if (soc_feature(unit, soc_feature_flex_stat_compression_share)) {
                  flex_attribute->combine_pkt_resolution_flags |=
                      flex_attribute->combine_attr_counter[counter_offset].
                      pkt_resolution_flags;
              }
              break;
         case bcmStatGroupModeAttrClassType:
#ifdef BCM_KATANA2_SUPPORT
              if soc_feature(unit, soc_feature_flex_stat_attributes_class) {
                  flex_attribute->pkt_resolution = 1;
                  if (attr_value) {
                      attr_value--;
                  } else {
                      return BCM_E_PARAM;
                  }
                  iter = 0;
                  BCM_STAT_FLEX_VALUE_SET(
                      flex_attribute->combine_attr_counter[counter_offset].
                      value_array[bcmStatFlexAttrComb], attr_value);
                  while (class_attr_comb[unit].class_pkt_attr_comb[attr_value][iter] != 0) {
                      switch(class_attr_comb[unit].class_pkt_attr_comb[attr_value][iter]) {
                          case bcmStatGroupModeAttrPktTypeUnknown:
                              flex_attribute->combine_attr_counter[counter_offset].
                                  pkt_resolution_flags |=
                                  BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_PKT;
                              iter++;
                              break;
                          case bcmStatGroupModeAttrPktTypeControl:
                              flex_attribute->combine_attr_counter[counter_offset].
                                  pkt_resolution_flags |=
                                  BCM_STAT_FLEX_PKT_TYPE_CONTROL_PKT                ;
                              iter++;
                              break;
                          case bcmStatGroupModeAttrPktTypeOAM:
                              flex_attribute->combine_attr_counter[counter_offset].
                                  pkt_resolution_flags |=
                                  BCM_STAT_FLEX_PKT_TYPE_OAM_PKT                    ;
                              iter++;
                              break;
                          case bcmStatGroupModeAttrPktTypeBFD:
                              flex_attribute->combine_attr_counter[counter_offset].
                                  pkt_resolution_flags |=
                                  BCM_STAT_FLEX_PKT_TYPE_BFD_PKT                    ;
                              iter++;
                              break;
                          case bcmStatGroupModeAttrPktTypeBPDU:
                              flex_attribute->combine_attr_counter[counter_offset].
                                  pkt_resolution_flags |=
                                  BCM_STAT_FLEX_PKT_TYPE_BPDU_PKT                   ;
                              iter++;
                              break;
                          case bcmStatGroupModeAttrPktTypeICNM:
                              flex_attribute->combine_attr_counter[counter_offset].
                                  pkt_resolution_flags |=
                                  BCM_STAT_FLEX_PKT_TYPE_ICNM_PKT                   ;
                              iter++;
                              break;
                          case bcmStatGroupModeAttrPktType1588:
                              flex_attribute->combine_attr_counter[counter_offset].
                                  pkt_resolution_flags |=
                                  BCM_STAT_FLEX_PKT_TYPE_PKT_IS_1588                ;
                              iter++;
                              break;
                          case bcmStatGroupModeAttrPktTypeKnownL2UC:
                              flex_attribute->combine_attr_counter[counter_offset].
                                  pkt_resolution_flags |=
                                  BCM_STAT_FLEX_PKT_TYPE_KNOWN_L2UC_PKT             ;
                              iter++;
                              break;
                          case bcmStatGroupModeAttrPktTypeUnknownL2UC:
                              flex_attribute->combine_attr_counter[counter_offset].
                                  pkt_resolution_flags |=
                                  BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_L2UC_PKT           ;
                              iter++;
                              break;
                          case bcmStatGroupModeAttrPktTypeL2BC:
                              flex_attribute->combine_attr_counter[counter_offset].
                                  pkt_resolution_flags |=
                                  BCM_STAT_FLEX_PKT_TYPE_L2BC_PKT                   ;
                              iter++;
                              break;
                          case bcmStatGroupModeAttrPktTypeKnownL2MC:
                              flex_attribute->combine_attr_counter[counter_offset].
                                  pkt_resolution_flags |=
                                  BCM_STAT_FLEX_PKT_TYPE_KNOWN_L2MC_PKT             ;
                              iter++;
                              break;
                          case bcmStatGroupModeAttrPktTypeUnknownL2MC:
                              flex_attribute->combine_attr_counter[counter_offset].
                                  pkt_resolution_flags |=
                                  BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_L2MC_PKT           ;
                              iter++;
                              break;
                          case bcmStatGroupModeAttrPktTypeKnownL3UC:
                              flex_attribute->combine_attr_counter[counter_offset].
                                  pkt_resolution_flags |=
                                  BCM_STAT_FLEX_PKT_TYPE_KNOWN_L3UC_PKT             ;
                              iter++;
                              break;
                          case bcmStatGroupModeAttrPktTypeUnknownL3UC:
                              flex_attribute->combine_attr_counter[counter_offset].
                                  pkt_resolution_flags |=
                                  BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_L3UC_PKT           ;
                              iter++;
                              break;
                          case bcmStatGroupModeAttrPktTypeKnownIPMC :
                              flex_attribute->combine_attr_counter[counter_offset].
                                  pkt_resolution_flags |=
                                  BCM_STAT_FLEX_PKT_TYPE_KNOWN_IPMC_PKT             ;
                              iter++;
                              break;
                          case bcmStatGroupModeAttrPktTypeUnknownIPMC :
                              flex_attribute->combine_attr_counter[counter_offset].
                                  pkt_resolution_flags |=
                                  BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_IPMC_PKT           ;
                              iter++;
                              break;
                          case bcmStatGroupModeAttrPktTypeKnownMplsL2 :
                              flex_attribute->combine_attr_counter[counter_offset].
                                  pkt_resolution_flags |=
                                  BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_L2_PKT          ;
                              iter++;
                              break;
                          case bcmStatGroupModeAttrPktTypeKnownMplsL3 :
                              flex_attribute->combine_attr_counter[counter_offset].
                                  pkt_resolution_flags |=
                                  BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_L3_PKT          ;
                              iter++;
                              break;
                          case bcmStatGroupModeAttrPktTypeKnownMpls :
                              flex_attribute->combine_attr_counter[counter_offset].
                                  pkt_resolution_flags |=
                                  BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_PKT             ;
                              iter++;
                              break;
                          case bcmStatGroupModeAttrPktTypeUnknownMpls :
                              flex_attribute->combine_attr_counter[counter_offset].
                                  pkt_resolution_flags |=
                                  BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_MPLS_PKT           ;
                              iter++;
                              break;
                          case bcmStatGroupModeAttrPktTypeKnownMplsMulticast:
                              flex_attribute->combine_attr_counter[counter_offset].
                                  pkt_resolution_flags |=
                                  BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_MULTICAST_PKT   ;
                              iter++;
                              break;
                          case bcmStatGroupModeAttrPktTypeKnownMim:
                              flex_attribute->combine_attr_counter[counter_offset].
                                  pkt_resolution_flags |=
                                  BCM_STAT_FLEX_PKT_TYPE_KNOWN_MIM_PKT              ;
                              iter++;
                              break;
                          case bcmStatGroupModeAttrPktTypeUnknownMim:
                              flex_attribute->combine_attr_counter[counter_offset].
                                  pkt_resolution_flags |=
                                  BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_MIM_PKT            ;
                              iter++;
                              break;
                          case bcmStatGroupModeAttrPktTypeKnownTrill:
                              flex_attribute->combine_attr_counter[counter_offset].
                                  pkt_resolution_flags |=
                                  BCM_STAT_FLEX_PKT_TYPE_KNOWN_TRILL_PKT            ;
                              iter++;
                              break;
                          case bcmStatGroupModeAttrPktTypeUnknownTrill:
                              flex_attribute->combine_attr_counter[counter_offset].
                                  pkt_resolution_flags |=
                                  BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_TRILL_PKT          ;
                              iter++;
                              break;
                          case bcmStatGroupModeAttrPktTypeKnownNiv:
                              flex_attribute->combine_attr_counter[counter_offset].
                                  pkt_resolution_flags |=
                                  BCM_STAT_FLEX_PKT_TYPE_KNOWN_NIV_PKT              ;
                              iter++;
                              break;
                          case bcmStatGroupModeAttrPktTypeUnknownNiv:
                              flex_attribute->combine_attr_counter[counter_offset].
                                  pkt_resolution_flags |=
                                  BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_NIV_PKT            ;
                              iter++;
                              break;
                          case bcmStatGroupModeAttrPktTypeL2UC:
                              flex_attribute->combine_attr_counter[counter_offset].
                                  pkt_resolution_high_flags |=
                                  BCM_STAT_FLEX_PKT_TYPE_2_L2_UC_PKT;
                              iter++;
                              break;
                          case bcmStatGroupModeAttrPktTypeL2NonUC:
                              flex_attribute->combine_attr_counter[counter_offset].
                                  pkt_resolution_high_flags |=
                                  BCM_STAT_FLEX_PKT_TYPE_2_L2_NON_UC_PKT;
                              iter++;
                              break;
                          case bcmStatGroupModeAttrPktTypeAll:
                          case BCM_STAT_GROUP_MODE_ATTR_ALL_VALUES:
                              flex_attribute->combine_attr_counter[counter_offset].
                                  pkt_resolution_flags |= (
                                          BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_PKT                |
                                          BCM_STAT_FLEX_PKT_TYPE_CONTROL_PKT                |
                                          BCM_STAT_FLEX_PKT_TYPE_OAM_PKT                    |
                                          BCM_STAT_FLEX_PKT_TYPE_BFD_PKT                    |
                                          BCM_STAT_FLEX_PKT_TYPE_BPDU_PKT                   |
                                          BCM_STAT_FLEX_PKT_TYPE_ICNM_PKT                   |
                                          BCM_STAT_FLEX_PKT_TYPE_PKT_IS_1588                |
                                          BCM_STAT_FLEX_PKT_TYPE_KNOWN_L2UC_PKT             |
                                          BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_L2UC_PKT           |
                                          BCM_STAT_FLEX_PKT_TYPE_L2BC_PKT                   |
                                          BCM_STAT_FLEX_PKT_TYPE_KNOWN_L2MC_PKT             |
                                          BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_L2MC_PKT           |
                                          BCM_STAT_FLEX_PKT_TYPE_KNOWN_L3UC_PKT             |
                                          BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_L3UC_PKT           |
                                          BCM_STAT_FLEX_PKT_TYPE_KNOWN_IPMC_PKT             |
                                          BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_IPMC_PKT           |
                                          BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_L2_PKT          |
                                          BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_L3_PKT          |
                                          BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_PKT             |
                                          BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_MPLS_PKT           |
                                          BCM_STAT_FLEX_PKT_TYPE_KNOWN_MPLS_MULTICAST_PKT   |
                                          BCM_STAT_FLEX_PKT_TYPE_KNOWN_MIM_PKT              |
                                          BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_MIM_PKT            |
                                          BCM_STAT_FLEX_PKT_TYPE_KNOWN_TRILL_PKT            |
                                          BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_TRILL_PKT          |
                                          BCM_STAT_FLEX_PKT_TYPE_KNOWN_NIV_PKT              |
                                          BCM_STAT_FLEX_PKT_TYPE_UNKNOWN_NIV_PKT            );
                              break;
                          default:
                              LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                                      (BSL_META_U(unit,
                                                  "BAD PARAM(PktType)"
                                                  ":sel=%d offset=%d attr=%d value=%d\n"),
                                       sel, counter_offset , attr,
                                       class_attr_comb[unit].class_pkt_attr_comb[attr_value][iter] ));
                              return BCM_E_PARAM;
                      }
                  }

                  if (soc_feature(unit, soc_feature_flex_stat_compression_share)) {
                      flex_attribute->combine_pkt_resolution_flags |=
                          flex_attribute->combine_attr_counter[counter_offset].
                          pkt_resolution_flags;
                   BCM_STAT_FLEX_VALUE_SET(
                      flex_attribute->combine_value_array[bcmStatFlexAttrComb], attr_value);
                  }
              }
#endif
              break;
         case bcmStatGroupModeAttrIngNetworkGroup:
              flex_attribute->svp = 1;
              if (flags & BCM_STAT_GROUP_MODE_INGRESS) {
                  max_value = (1 << ing_pkt_attr_uncmprsd_bits_g[unit].svp_type) - 1;
              } else {
                  max_value = (1 << egr_pkt_attr_uncmprsd_bits_g[unit].svp_type) - 1;
              }
              switch(attr_value) {
              case BCM_STAT_GROUP_MODE_ATTR_ALL_VALUES:
                   for(value=0;value <= max_value ; value++) {
                       BCM_STAT_FLEX_VALUE_SET(
                           flex_attribute->combine_attr_counter[counter_offset].
                           value_array[bcmStatFlexAttrSvp], value);
                   }
                   break;
              default:
                   if (attr_value > max_value) {
                       LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                                 (BSL_META_U(unit,
                                             "BAD PARAM(Svp)"
                                             ":sel=%d offset=%d attr=%d value=%d\n"),
                                             sel, counter_offset , attr, attr_value ));
                       return BCM_E_PARAM;
                   }
                   BCM_STAT_FLEX_VALUE_SET(
                       flex_attribute->combine_attr_counter[counter_offset].
                       value_array[bcmStatFlexAttrSvp], attr_value);
                   break;
              }
              break;
         case bcmStatGroupModeAttrEgrNetworkGroup:
              flex_attribute->dvp = 1;
              if (flags & BCM_STAT_GROUP_MODE_INGRESS) {
                  LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                            (BSL_META_U(unit,
                                        "BAD PARAM(DVP) for Ingress Direction\n")));
                  return BCM_E_PARAM;
              } else {
                  max_value = (1 << egr_pkt_attr_uncmprsd_bits_g[unit].dvp_type) - 1;
              }
              switch(attr_value) {
              case BCM_STAT_GROUP_MODE_ATTR_ALL_VALUES:
                   for(value=0;value <= max_value ; value++) {
                       BCM_STAT_FLEX_VALUE_SET(
                           flex_attribute->combine_attr_counter[counter_offset].
                           value_array[bcmStatFlexAttrDvp], value);
                   }
                   break;
              default:
                   if (attr_value > max_value) {
                       LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                                 (BSL_META_U(unit,
                                             "BAD PARAM(Dvp)"
                                             ":sel=%d offset=%d attr=%d value=%d\n"),
                                             sel, counter_offset , attr, attr_value ));
                       return BCM_E_PARAM;
                   }
                   BCM_STAT_FLEX_VALUE_SET(
                       flex_attribute->combine_attr_counter[counter_offset].
                       value_array[bcmStatFlexAttrDvp], attr_value);
                   break;
              }
              break;
         case bcmStatGroupModeAttrDrop:
              flex_attribute->drop = 1;
              switch(attr_value) {
              case 0:
                     flex_attribute->combine_attr_counter[counter_offset].
                         drop_flags |= BCM_STAT_FLEX_DROP_DISABLE;
                     break;
              case 1:
                     flex_attribute->combine_attr_counter[counter_offset].
                         drop_flags |= BCM_STAT_FLEX_DROP_ENABLE;
                     break;
              case BCM_STAT_GROUP_MODE_ATTR_ALL_VALUES:
                     flex_attribute->combine_attr_counter[counter_offset].
                         drop_flags |= (BCM_STAT_FLEX_DROP_ENABLE |
                                        BCM_STAT_FLEX_DROP_DISABLE);
                     break;
              default:
                   LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                             (BSL_META_U(unit,
                                         "BAD PARAM(DropType)"
                                         ":sel=%d offset=%d attr=%d value=%d\n"),
                                         sel, counter_offset , attr, attr_value ));
                   return BCM_E_PARAM;
              }

              if (soc_feature(unit, soc_feature_flex_stat_compression_share)) {
                  flex_attribute->combine_drop_flags |=
                      flex_attribute->combine_attr_counter[counter_offset].
                      drop_flags;
              }
              break;
         case bcmStatGroupModeAttrPacketTypeIp:
              flex_attribute->ip_pkt = 1;
              switch(attr_value) {
              case 0:
                     flex_attribute->combine_attr_counter[counter_offset].
                         ip_pkt_flags |= BCM_STAT_FLEX_IP_PKT_DISABLE;
                     break;
              case 1:
                     flex_attribute->combine_attr_counter[counter_offset].
                         ip_pkt_flags |= BCM_STAT_FLEX_IP_PKT_ENABLE;
                     break;
              case BCM_STAT_GROUP_MODE_ATTR_ALL_VALUES:
                     flex_attribute->combine_attr_counter[counter_offset].
                         ip_pkt_flags |= (BCM_STAT_FLEX_IP_PKT_ENABLE |
                                          BCM_STAT_FLEX_IP_PKT_DISABLE);
                     break;
              default:
                   LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                             (BSL_META_U(unit,
                                         "BAD PARAM(Ip)"
                                         ":sel=%d offset=%d attr=%d value=%d\n"),
                                         sel, counter_offset , attr, attr_value ));
                   return BCM_E_PARAM;
              }

              if (soc_feature(unit, soc_feature_flex_stat_compression_share)) {
                  flex_attribute->combine_ip_pkt_flags |=
                      flex_attribute->combine_attr_counter[counter_offset].
                      ip_pkt_flags;
              }
              break;
#ifdef BCM_APACHE_SUPPORT
         case bcmStatGroupModeAttrColorMplsLabelFirst:
              if (soc_feature(unit,soc_feature_flex_ctr_mpls_3_label_count)) {
                  flex_attribute->cng_1 = 1;
                  switch(attr_value) {
                      case bcmColorGreen:
                          flex_attribute->combine_attr_counter[counter_offset].
                              pre_ifp_color_mpls_label1_flags |= BCM_STAT_FLEX_COLOR_GREEN;
                          break;
                      case bcmColorYellow:
                          flex_attribute->combine_attr_counter[counter_offset].
                              pre_ifp_color_mpls_label1_flags |= BCM_STAT_FLEX_COLOR_YELLOW;
                          break;
                      case bcmColorRed:
                          flex_attribute->combine_attr_counter[counter_offset].
                              pre_ifp_color_mpls_label1_flags |= BCM_STAT_FLEX_COLOR_RED;
                          break;
                      case BCM_STAT_GROUP_MODE_ATTR_ALL_VALUES:
                          flex_attribute->combine_attr_counter[counter_offset].
                              pre_ifp_color_mpls_label1_flags |= (BCM_STAT_FLEX_COLOR_GREEN |
                                      BCM_STAT_FLEX_COLOR_YELLOW |
                                      BCM_STAT_FLEX_COLOR_RED);

                          break;

                      default:
                          LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                                  (BSL_META_U(unit,
                                              "BAD PARAM(ColorMplsLabelFirst)"
                                              ":sel=%d offset=%d attr=%d value=%d\n"),
                                   sel, counter_offset , attr, attr_value ));
                          return BCM_E_PARAM;
                  }
              } else {
                  return BCM_E_UNAVAIL;
              }
              break;
         case bcmStatGroupModeAttrIntPriMplsLabelFirst:
              if (soc_feature(unit,soc_feature_flex_ctr_mpls_3_label_count)) {
                  flex_attribute->phb_1 = 1;
                  switch(attr_value) {
                      case 0:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label1_flags |= BCM_STAT_FLEX_PRI0;
                          break;
                      case 1:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label1_flags |= BCM_STAT_FLEX_PRI1;
                          break;
                      case 2:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label1_flags |= BCM_STAT_FLEX_PRI2;
                          break;
                      case 3:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label1_flags |= BCM_STAT_FLEX_PRI3;
                          break;
                      case 4:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label1_flags |= BCM_STAT_FLEX_PRI4;
                          break;
                      case 5:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label1_flags |= BCM_STAT_FLEX_PRI5;
                          break;
                      case 6:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label1_flags |= BCM_STAT_FLEX_PRI6;
                          break;
                      case 7:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label1_flags |= BCM_STAT_FLEX_PRI7;
                          break;
                      case 8:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label1_flags |= BCM_STAT_FLEX_PRI8;
                          break;
                      case 9:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label1_flags |= BCM_STAT_FLEX_PRI9;
                          break;
                      case 10:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label1_flags |= BCM_STAT_FLEX_PRI10;
                          break;
                      case 11:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label1_flags |= BCM_STAT_FLEX_PRI11;
                          break;
                      case 12:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label1_flags |= BCM_STAT_FLEX_PRI12;
                          break;
                      case 13:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label1_flags |= BCM_STAT_FLEX_PRI13;
                          break;
                      case 14:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label1_flags |= BCM_STAT_FLEX_PRI14;
                          break;
                      case 15:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label1_flags |= BCM_STAT_FLEX_PRI15;
                          break;
                      case BCM_STAT_GROUP_MODE_ATTR_ALL_VALUES:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label1_flags |= (BCM_STAT_FLEX_PRI0 |
                                      BCM_STAT_FLEX_PRI1 |
                                      BCM_STAT_FLEX_PRI2 |
                                      BCM_STAT_FLEX_PRI3 |
                                      BCM_STAT_FLEX_PRI4 |
                                      BCM_STAT_FLEX_PRI5 |
                                      BCM_STAT_FLEX_PRI6 |
                                      BCM_STAT_FLEX_PRI7 |
                                      BCM_STAT_FLEX_PRI8 |
                                      BCM_STAT_FLEX_PRI9 |
                                      BCM_STAT_FLEX_PRI10 |
                                      BCM_STAT_FLEX_PRI11 |
                                      BCM_STAT_FLEX_PRI12 |
                                      BCM_STAT_FLEX_PRI13 |
                                      BCM_STAT_FLEX_PRI14 |
                                      BCM_STAT_FLEX_PRI15);
                          break;
                      default:
                          LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                                  (BSL_META_U(unit,
                                              "BAD PARAM(IntPriMplsLabelFirst)"
                                              ":sel=%d offset=%d attr=%d value=%d\n"),
                                   sel, counter_offset , attr, attr_value ));
                          return BCM_E_PARAM;
                  }
              } else {
                  return BCM_E_UNAVAIL;
              }
              break;
         case bcmStatGroupModeAttrColorMplsLabelSecond:
              if (soc_feature(unit,soc_feature_flex_ctr_mpls_3_label_count)) {
                  flex_attribute->cng_2 = 1;
                  switch(attr_value) {
                      case bcmColorGreen:
                          flex_attribute->combine_attr_counter[counter_offset].
                              pre_ifp_color_mpls_label2_flags |= BCM_STAT_FLEX_COLOR_GREEN;
                          break;
                      case bcmColorYellow:
                          flex_attribute->combine_attr_counter[counter_offset].
                              pre_ifp_color_mpls_label2_flags |= BCM_STAT_FLEX_COLOR_YELLOW;
                          break;
                      case bcmColorRed:
                          flex_attribute->combine_attr_counter[counter_offset].
                              pre_ifp_color_mpls_label2_flags |= BCM_STAT_FLEX_COLOR_RED;
                          break;
                      case BCM_STAT_GROUP_MODE_ATTR_ALL_VALUES:
                          flex_attribute->combine_attr_counter[counter_offset].
                              pre_ifp_color_mpls_label2_flags |= (BCM_STAT_FLEX_COLOR_GREEN |
                                      BCM_STAT_FLEX_COLOR_YELLOW |
                                      BCM_STAT_FLEX_COLOR_RED);
                          break;
                      default:
                          LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                                  (BSL_META_U(unit,
                                              "BAD PARAM(ColorMplsLabelSecond)"
                                              ":sel=%d offset=%d attr=%d value=%d\n"),
                                   sel, counter_offset , attr, attr_value ));
                          return BCM_E_PARAM;
                  }
              } else {
                  return BCM_E_UNAVAIL;
              }
              break;
         case  bcmStatGroupModeAttrIntPriMplsLabelSecond:
              if (soc_feature(unit,soc_feature_flex_ctr_mpls_3_label_count)) {
                  flex_attribute->phb_2 = 1;
                  switch(attr_value) {
                      case 0:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label2_flags |= BCM_STAT_FLEX_PRI0;
                          break;
                      case 1:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label2_flags |= BCM_STAT_FLEX_PRI1;
                          break;
                      case 2:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label2_flags |= BCM_STAT_FLEX_PRI2;
                          break;
                      case 3:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label2_flags |= BCM_STAT_FLEX_PRI3;
                          break;
                      case 4:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label2_flags |= BCM_STAT_FLEX_PRI4;
                          break;
                      case 5:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label2_flags |= BCM_STAT_FLEX_PRI5;
                          break;
                      case 6:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label2_flags |= BCM_STAT_FLEX_PRI6;
                          break;
                      case 7:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label2_flags |= BCM_STAT_FLEX_PRI7;
                          break;
                      case 8:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label2_flags |= BCM_STAT_FLEX_PRI8;
                          break;
                      case 9:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label2_flags |= BCM_STAT_FLEX_PRI9;
                          break;
                      case 10:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label2_flags |= BCM_STAT_FLEX_PRI10;
                          break;
                      case 11:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label2_flags |= BCM_STAT_FLEX_PRI11;
                          break;
                      case 12:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label2_flags |= BCM_STAT_FLEX_PRI12;
                          break;
                      case 13:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label2_flags |= BCM_STAT_FLEX_PRI13;
                          break;
                      case 14:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label2_flags |= BCM_STAT_FLEX_PRI14;
                          break;
                      case 15:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label2_flags |= BCM_STAT_FLEX_PRI15;
                          break;
                      case BCM_STAT_GROUP_MODE_ATTR_ALL_VALUES:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label2_flags |= (BCM_STAT_FLEX_PRI0 |
                                      BCM_STAT_FLEX_PRI1 |
                                      BCM_STAT_FLEX_PRI2 |
                                      BCM_STAT_FLEX_PRI3 |
                                      BCM_STAT_FLEX_PRI4 |
                                      BCM_STAT_FLEX_PRI5 |
                                      BCM_STAT_FLEX_PRI6 |
                                      BCM_STAT_FLEX_PRI7 |
                                      BCM_STAT_FLEX_PRI8 |
                                      BCM_STAT_FLEX_PRI9 |
                                      BCM_STAT_FLEX_PRI10 |
                                      BCM_STAT_FLEX_PRI11 |
                                      BCM_STAT_FLEX_PRI12 |
                                      BCM_STAT_FLEX_PRI13 |
                                      BCM_STAT_FLEX_PRI14 |
                                      BCM_STAT_FLEX_PRI15);
                          break;
                      default:
                          LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                                  (BSL_META_U(unit,
                                              "BAD PARAM(IntPriMplsLabelSecond)"
                                              ":sel=%d offset=%d attr=%d value=%d\n"),
                                   sel, counter_offset , attr, attr_value ));
                          return BCM_E_PARAM;
                  }
              } else {
                  return BCM_E_UNAVAIL;
              }
              break;
         case bcmStatGroupModeAttrColorMplsLabelThird:
              if (soc_feature(unit,soc_feature_flex_ctr_mpls_3_label_count)) {
                  flex_attribute->cng_3 = 1;
                  switch(attr_value) {
                      case bcmColorGreen:
                          flex_attribute->combine_attr_counter[counter_offset].
                              pre_ifp_color_mpls_label3_flags |= BCM_STAT_FLEX_COLOR_GREEN;
                          break;
                      case bcmColorYellow:
                          flex_attribute->combine_attr_counter[counter_offset].
                              pre_ifp_color_mpls_label3_flags |= BCM_STAT_FLEX_COLOR_YELLOW;
                          break;
                      case bcmColorRed:
                          flex_attribute->combine_attr_counter[counter_offset].
                              pre_ifp_color_mpls_label3_flags |= BCM_STAT_FLEX_COLOR_RED;
                          break;
                      case BCM_STAT_GROUP_MODE_ATTR_ALL_VALUES:
                          flex_attribute->combine_attr_counter[counter_offset].
                              pre_ifp_color_mpls_label3_flags |= (BCM_STAT_FLEX_COLOR_GREEN |
                                      BCM_STAT_FLEX_COLOR_YELLOW |
                                      BCM_STAT_FLEX_COLOR_RED);
                          break;
                      default:
                          LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                                  (BSL_META_U(unit,
                                              "BAD PARAM(ColorMplsLabelThird)"
                                              ":sel=%d offset=%d attr=%d value=%d\n"),
                                   sel, counter_offset , attr, attr_value ));
                          return BCM_E_PARAM;
                  }
              } else {
                  return BCM_E_UNAVAIL;
              }
              break;
         case bcmStatGroupModeAttrIntPriMplsLabelThird:
              if (soc_feature(unit,soc_feature_flex_ctr_mpls_3_label_count)) {
                  flex_attribute->phb_3 = 1;
                  switch(attr_value) {
                      case 0:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label3_flags |= BCM_STAT_FLEX_PRI0;
                          break;
                      case 1:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label3_flags |= BCM_STAT_FLEX_PRI1;
                          break;
                      case 2:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label3_flags |= BCM_STAT_FLEX_PRI2;
                          break;
                      case 3:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label3_flags |= BCM_STAT_FLEX_PRI3;
                          break;
                      case 4:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label3_flags |= BCM_STAT_FLEX_PRI4;
                          break;
                      case 5:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label3_flags |= BCM_STAT_FLEX_PRI5;
                          break;
                      case 6:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label3_flags |= BCM_STAT_FLEX_PRI6;
                          break;
                      case 7:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label3_flags |= BCM_STAT_FLEX_PRI7;
                          break;
                      case 8:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label3_flags |= BCM_STAT_FLEX_PRI8;
                          break;
                      case 9:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label3_flags |= BCM_STAT_FLEX_PRI9;
                          break;
                      case 10:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label3_flags |= BCM_STAT_FLEX_PRI10;
                          break;
                      case 11:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label3_flags |= BCM_STAT_FLEX_PRI11;
                          break;
                      case 12:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label3_flags |= BCM_STAT_FLEX_PRI12;
                          break;
                      case 13:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label3_flags |= BCM_STAT_FLEX_PRI13;
                          break;
                      case 14:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label3_flags |= BCM_STAT_FLEX_PRI14;
                          break;
                      case 15:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label3_flags |= BCM_STAT_FLEX_PRI15;
                          break;
                      case BCM_STAT_GROUP_MODE_ATTR_ALL_VALUES:
                          flex_attribute->combine_attr_counter[counter_offset].
                              int_pri_mpls_label3_flags |= (BCM_STAT_FLEX_PRI0 |
                                      BCM_STAT_FLEX_PRI1 |
                                      BCM_STAT_FLEX_PRI2 |
                                      BCM_STAT_FLEX_PRI3 |
                                      BCM_STAT_FLEX_PRI4 |
                                      BCM_STAT_FLEX_PRI5 |
                                      BCM_STAT_FLEX_PRI6 |
                                      BCM_STAT_FLEX_PRI7 |
                                      BCM_STAT_FLEX_PRI8 |
                                      BCM_STAT_FLEX_PRI9 |
                                      BCM_STAT_FLEX_PRI10 |
                                      BCM_STAT_FLEX_PRI11 |
                                      BCM_STAT_FLEX_PRI12 |
                                      BCM_STAT_FLEX_PRI13 |
                                      BCM_STAT_FLEX_PRI14 |
                                      BCM_STAT_FLEX_PRI15);
                          break;
                      default:
                          LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                                  (BSL_META_U(unit,
                                              "BAD PARAM(IntPriMplsLabelThird)"
                                              ":sel=%d offset=%d attr=%d value=%d\n"),
                                   sel, counter_offset , attr, attr_value ));
                          return BCM_E_PARAM;
                  }
              } else {
                  return BCM_E_UNAVAIL;
              }
              break;
#endif
#if defined(BCM_TOMAHAWK_SUPPORT) || defined(BCM_TRIDENT3_SUPPORT)
        case bcmStatGroupModeAttrCos:
            if (soc_feature(unit, soc_feature_flex_stat_egr_queue_congestion_marked)) {
                 flex_attribute->mmu_cos = 1;
                 switch(attr_value) {
                 case 0:
                        flex_attribute->combine_attr_counter[counter_offset].
                            mmu_cos_flags |= BCM_STAT_FLEX_COS0;
                        break;
                 case 1:
                        flex_attribute->combine_attr_counter[counter_offset].
                            mmu_cos_flags |= BCM_STAT_FLEX_COS1;
                        break;
                 case 2:
                        flex_attribute->combine_attr_counter[counter_offset].
                            mmu_cos_flags |= BCM_STAT_FLEX_COS2;
                        break;
                 case 3:
                        flex_attribute->combine_attr_counter[counter_offset].
                            mmu_cos_flags |= BCM_STAT_FLEX_COS3;
                        break;
                 case 4:
                        flex_attribute->combine_attr_counter[counter_offset].
                            mmu_cos_flags |= BCM_STAT_FLEX_COS4;
                        break;
                 case 5:
                        flex_attribute->combine_attr_counter[counter_offset].
                            mmu_cos_flags |= BCM_STAT_FLEX_COS5;
                        break;
                 case 6:
                        flex_attribute->combine_attr_counter[counter_offset].
                            mmu_cos_flags |= BCM_STAT_FLEX_COS6;
                        break;
                 case 7:
                        flex_attribute->combine_attr_counter[counter_offset].
                            mmu_cos_flags |= BCM_STAT_FLEX_COS7;
                        break;
                 case 8:
                        flex_attribute->combine_attr_counter[counter_offset].
                            mmu_cos_flags |= BCM_STAT_FLEX_COS8;
                        break;
                 case 9:
                        flex_attribute->combine_attr_counter[counter_offset].
                            mmu_cos_flags |= BCM_STAT_FLEX_COS9;
                        break;
                 case 10:
                        flex_attribute->combine_attr_counter[counter_offset].
                            mmu_cos_flags |= BCM_STAT_FLEX_COS10;
                        break;
                 case 11:
                        flex_attribute->combine_attr_counter[counter_offset].
                            mmu_cos_flags |= BCM_STAT_FLEX_COS11;
                        break;
                 case 12:
                        flex_attribute->combine_attr_counter[counter_offset].
                            mmu_cos_flags |= BCM_STAT_FLEX_COS12;
                        break;
                 case 13:
                        flex_attribute->combine_attr_counter[counter_offset].
                            mmu_cos_flags |= BCM_STAT_FLEX_COS13;
                        break;
                 case 14:
                        flex_attribute->combine_attr_counter[counter_offset].
                            mmu_cos_flags |= BCM_STAT_FLEX_COS14;
                        break;
                 case 15:
                        flex_attribute->combine_attr_counter[counter_offset].
                            mmu_cos_flags |= BCM_STAT_FLEX_COS15;
                        break;
                 case BCM_STAT_GROUP_MODE_ATTR_ALL_VALUES:
                        flex_attribute->combine_attr_counter[counter_offset].
                            mmu_cos_flags |= (BCM_STAT_FLEX_COS0 |
                                              BCM_STAT_FLEX_COS1 |
                                              BCM_STAT_FLEX_COS2 |
                                              BCM_STAT_FLEX_COS3 |
                                              BCM_STAT_FLEX_COS4 |
                                              BCM_STAT_FLEX_COS5 |
                                              BCM_STAT_FLEX_COS6 |
                                              BCM_STAT_FLEX_COS7 |
                                              BCM_STAT_FLEX_COS8 |
                                              BCM_STAT_FLEX_COS9 |
                                              BCM_STAT_FLEX_COS10 |
                                              BCM_STAT_FLEX_COS11 |
                                              BCM_STAT_FLEX_COS12 |
                                              BCM_STAT_FLEX_COS13 |
                                              BCM_STAT_FLEX_COS14 |
                                              BCM_STAT_FLEX_COS15);
                        break;
                 default:
                      LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                                (BSL_META_U(unit,
                                            "BAD PARAM(mmu_cos)"
                                            ":sel=%d offset=%d attr=%d value=%d\n"),
                                            sel, counter_offset , attr, attr_value ));
                      return BCM_E_PARAM;
                 }
            }else {
                return BCM_E_UNAVAIL;
            }

            break;
       case bcmStatGroupModeAttrQueueType:
            if (soc_feature(unit, soc_feature_flex_stat_egr_queue_congestion_marked)) {
                flex_attribute->uc_queueing = 1;
                switch(attr_value) {
                case 0:
                       flex_attribute->combine_attr_counter[counter_offset].
                           uc_queueing_flags |= BCM_STAT_FLEX_UC_QUEUEING_DISABLE;
                       break;
                case 1:
                       flex_attribute->combine_attr_counter[counter_offset].
                           uc_queueing_flags |= BCM_STAT_FLEX_UC_QUEUEING_ENABLE;
                       break;
                case BCM_STAT_GROUP_MODE_ATTR_ALL_VALUES:
                       flex_attribute->combine_attr_counter[counter_offset].
                           uc_queueing_flags |= (BCM_STAT_FLEX_UC_QUEUEING_DISABLE |
                                          BCM_STAT_FLEX_UC_QUEUEING_ENABLE);
                       break;
                default:
                     LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                               (BSL_META_U(unit,
                                           "BAD PARAM(uc_queueing)"
                                           ":sel=%d offset=%d attr=%d value=%d\n"),
                                           sel, counter_offset , attr, attr_value ));
                     return BCM_E_PARAM;
                }
          } else {
              return BCM_E_UNAVAIL;
          }
            break;
        case bcmStatGroupModeAttrCongestionMarked:
            if (soc_feature(unit, soc_feature_flex_stat_egr_queue_congestion_marked)) {
                 flex_attribute->congestion_marked = 1;
                 switch(attr_value) {
                 case 0:
                        flex_attribute->combine_attr_counter[counter_offset].
                            congestion_marked_flags |= BCM_STAT_FLEX_CONGESTION_MARKED_DISABLE;
                        break;
                 case 1:
                        flex_attribute->combine_attr_counter[counter_offset].
                            congestion_marked_flags |= BCM_STAT_FLEX_CONGESTION_MARKED_ENABLE;
                        break;
                 case BCM_STAT_GROUP_MODE_ATTR_ALL_VALUES:
                        flex_attribute->combine_attr_counter[counter_offset].
                            congestion_marked_flags |= (BCM_STAT_FLEX_CONGESTION_MARKED_DISABLE |
                                           BCM_STAT_FLEX_CONGESTION_MARKED_ENABLE);
                        break;
                default:
                      LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                                (BSL_META_U(unit,
                                            "BAD PARAM(congestion_marked)"
                                            ":sel=%d offset=%d attr=%d value=%d\n"),
                                            sel, counter_offset , attr, attr_value ));
                      return BCM_E_PARAM;
                 }
              } else {
                  return BCM_E_UNAVAIL;
              }

            break;
#endif
        case bcmStatGroupModeAttrTcpFlagsType:
            if (soc_feature(unit, soc_feature_flex_stat_ing_tcp_flags_support)) {
                flex_attribute->tcp_flags = 1;
                switch(attr_value) {
                    case bcmStatGroupModeAttrTcpFlagsTypeSyn:
                        flex_attribute->combine_attr_counter[counter_offset].
                            tcp_flags |= BCM_STAT_FLEX_TCP_FLAG_TYPE_SYN;
                        break;
                    case bcmStatGroupModeAttrTcpFlagsTypeFin:
                        flex_attribute->combine_attr_counter[counter_offset].
                            tcp_flags |= BCM_STAT_FLEX_TCP_FLAG_TYPE_FIN;
                        break;
                    case bcmStatGroupModeAttrTcpFlagsTypeRst:
                        flex_attribute->combine_attr_counter[counter_offset].
                            tcp_flags |= BCM_STAT_FLEX_TCP_FLAG_TYPE_RST;
                        break;
                    case bcmStatGroupModeAttrTcpFlagsTypePsh:
                        flex_attribute->combine_attr_counter[counter_offset].
                            tcp_flags |= BCM_STAT_FLEX_TCP_FLAG_TYPE_PSH;
                        break;
                    case bcmStatGroupModeAttrTcpFlagsTypeAck:
                        flex_attribute->combine_attr_counter[counter_offset].
                            tcp_flags |= BCM_STAT_FLEX_TCP_FLAG_TYPE_ACK;
                        break;
                    case bcmStatGroupModeAttrTcpFlagsTypeUrg:
                        flex_attribute->combine_attr_counter[counter_offset].
                            tcp_flags |= BCM_STAT_FLEX_TCP_FLAG_TYPE_URG;
                        break;
                    case bcmStatGroupModeAttrTcpFlagsTypeEce:
                        flex_attribute->combine_attr_counter[counter_offset].
                            tcp_flags |= BCM_STAT_FLEX_TCP_FLAG_TYPE_ECE;
                        break;
                    case bcmStatGroupModeAttrTcpFlagsTypeCwr:
                        flex_attribute->combine_attr_counter[counter_offset].
                            tcp_flags |= BCM_STAT_FLEX_TCP_FLAG_TYPE_CWR;
                        break;
                    default:
                        LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                                (BSL_META_U(unit,
                                            "BAD PARAM(tcp_flags)"
                                            ":sel=%d offset=%d attr=%d value=%d\n"),
                                 sel, counter_offset , attr, attr_value ));
                        return BCM_E_PARAM;
                }
            } else {
                return BCM_E_UNAVAIL;
            }
            break;
        case bcmStatGroupModeAttrIntCongestion:
            if (soc_feature(unit, soc_feature_flex_stat_int_cn_support)) {
                flex_attribute->int_cn = 1;
                switch(attr_value) {
                    case 0:
                        flex_attribute->combine_attr_counter[counter_offset].
                            int_cn |= BCM_STAT_FLEX_INT_CN0;
                        break;
                    case 1:
                        flex_attribute->combine_attr_counter[counter_offset].
                            int_cn |= BCM_STAT_FLEX_INT_CN1;
                        break;
                    case 2:
                        flex_attribute->combine_attr_counter[counter_offset].
                            int_cn |= BCM_STAT_FLEX_INT_CN2;
                        break;
                    case 3:
                        flex_attribute->combine_attr_counter[counter_offset].
                            int_cn |= BCM_STAT_FLEX_INT_CN3;
                        break;
                    default:
                        LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                                (BSL_META_U(unit,
                                            "BAD PARAM(int_cn)"
                                            ":sel=%d offset=%d attr=%d value=%d\n"),
                                 sel, counter_offset , attr, attr_value ));
                        return BCM_E_PARAM;
                }
            } else {
                return BCM_E_UNAVAIL;
            }
            break;
        case bcmStatGroupModeAttrFlowControlPktType:
            if (soc_feature(unit, soc_feature_channelized_switching)) {
                flex_attribute->fc_type = 1;
                switch(attr_value) {
                    case bcmStatGroupModeAttrFlowControlPktTypeData:
                    case bcmStatGroupModeAttrFlowControlPktTypePause:
                    case bcmStatGroupModeAttrFlowControlPktTypePfc:
                    case bcmStatGroupModeAttrFlowControlPktTypeE2ecc:
                        flex_attribute->combine_attr_counter[counter_offset].
                            fc_type = attr_value;
                        break;
                    default:
                        LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                                (BSL_META_U(unit,
                                            "BAD PARAM(fc_type)"
                                            ":sel=%d offset=%d attr=%d value=%d\n"),
                                 sel, counter_offset , attr, attr_value ));
                        return BCM_E_PARAM;
                }
            } else {
                return BCM_E_UNAVAIL;
            }
            break;

        default:
            return BCM_E_PARAM;
      }
    }
    for (counter_offset = 0; 
         counter_offset < total_counters ; 
         counter_offset++) {
         if (flex_attribute->pre_ifp_color) {
             if (flex_attribute->combine_attr_counter[counter_offset].
                 pre_ifp_color_flags == 0) {
                 LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                           (BSL_META_U(unit,
                                       "PreIfpColor:Combination issue..Check parameters"
                                       "And Assign dummy attributes\n")));
                 return BCM_E_PARAM; 
             } 
         } 
         if (flex_attribute->ifp_color) {
             if (flex_attribute->combine_attr_counter[counter_offset].
                 ifp_color_flags == 0) {
                 LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                           (BSL_META_U(unit,
                                       "IfpColor:Combination issue..Check parameters"

                                       "And Assign dummy attributes\n")));
                 return BCM_E_PARAM; 
             }
         }
         if (flex_attribute->int_pri) {
             if (flex_attribute->combine_attr_counter[counter_offset].
                 int_pri_flags == 0) {
                 LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                           (BSL_META_U(unit,
                                       "IntPri:Combination issue..Check parameters"
                                       "And Assign dummy attributes\n")));
                 return BCM_E_PARAM; 
             }
         }
         if (flex_attribute->vlan_format) {
             if (flex_attribute->combine_attr_counter[counter_offset].
                 vlan_format_flags == 0) {
                 LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                           (BSL_META_U(unit,
                                       "Combination issue..Check parameters"
                                       "And Assign dummy attributes\n")));
                 return BCM_E_PARAM; 
             }
         }
         if (flex_attribute->outer_dot1p) {
             if (flex_attribute->combine_attr_counter[counter_offset].
                 outer_dot1p_flags == 0) {
                 LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                           (BSL_META_U(unit,
                                       "OuterPri: Combination issue..Check parameters"
                                       "And Assign dummy attributes\n")));
                 return BCM_E_PARAM; 
             }
         }
         if (flex_attribute->inner_dot1p) {
             if (flex_attribute->combine_attr_counter[counter_offset].
                 inner_dot1p_flags == 0) {
                 LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                           (BSL_META_U(unit,
                                       "InnerPri: Combination issue..Check parameters"
                                       "And Assign dummy attributes\n")));
                 return BCM_E_PARAM; 
             }
         }
         if ((flex_attribute->port) || (flex_attribute->subport != 0)) {
             for (array_index=0; 
                  array_index < BCM_STAT_FLEX_BIT_ARRAY_SIZE; 
                  array_index++) {
                  if (flex_attribute->combine_attr_counter[counter_offset].
                      value_array[bcmStatFlexAttrPort][array_index]) {
                      break;
                  }
             }
             if (array_index == BCM_STAT_FLEX_BIT_ARRAY_SIZE ) {
                 LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                           (BSL_META_U(unit,
                                       "Port: Combination issue..Check parameters"
                                       "And Assign dummy attributes\n")));
                 return BCM_E_PARAM; 
             }
         }
         if (flex_attribute->tos_dscp) {
             for (array_index=0; 
                  array_index < BCM_STAT_FLEX_BIT_ARRAY_SIZE; 
                  array_index++) {
                  if (flex_attribute->combine_attr_counter[counter_offset].
                      value_array[bcmStatFlexAttrTosDscp][array_index]) {
                      break;
                  }
             }
             if (array_index == BCM_STAT_FLEX_BIT_ARRAY_SIZE ) {
                 LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                           (BSL_META_U(unit,
                                       "Tos: Combination issue..Check parameters"
                                       "And Assign dummy attributes\n")));
                 return BCM_E_PARAM; 
             }
         }
         if (flex_attribute->tos_ecn) {
             for (array_index=0; 
                  array_index < BCM_STAT_FLEX_BIT_ARRAY_SIZE; 
                  array_index++) {
                  if (flex_attribute->combine_attr_counter[counter_offset].
                      value_array[bcmStatFlexAttrTosEcn][array_index]) {
                      break;
                  }
             }
             if (array_index == BCM_STAT_FLEX_BIT_ARRAY_SIZE ) {
                 LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                           (BSL_META_U(unit,
                                       "Tos: Combination issue..Check parameters"
                                       "And Assign dummy attributes\n")));
                 return BCM_E_PARAM; 
             }
         }
         if (flex_attribute->pkt_resolution) {
             if ((flex_attribute->combine_attr_counter[counter_offset].
                  pkt_resolution_flags == 0) && 
                  (flex_attribute->combine_attr_counter[counter_offset].
                  pkt_resolution_high_flags == 0)) {
                 LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                           (BSL_META_U(unit,
                                       "Combination issue..Check parameters"
                                       "And Assign dummy attributes\n")));
                 return BCM_E_PARAM; 
             } 
         }
         if (flex_attribute->svp) {
             for (array_index=0; 
                  array_index < BCM_STAT_FLEX_BIT_ARRAY_SIZE; 
                  array_index++) {
                  if (flex_attribute->combine_attr_counter[counter_offset].
                      value_array[bcmStatFlexAttrSvp][array_index]) {
                      break;
                  }
             }
             if (array_index == BCM_STAT_FLEX_BIT_ARRAY_SIZE ) {
                 LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                           (BSL_META_U(unit,
                                       "SVP: Combination issue..Check parameters"
                                       "And Assign dummy attributes\n")));
                 return BCM_E_PARAM; 
             }
         }
         if (flex_attribute->dvp) {
             for (array_index=0; 
                  array_index < BCM_STAT_FLEX_BIT_ARRAY_SIZE; 
                  array_index++) {
                  if (flex_attribute->combine_attr_counter[counter_offset].
                      value_array[bcmStatFlexAttrDvp][array_index]) {
                      break;
                  }
             }
             if (array_index == BCM_STAT_FLEX_BIT_ARRAY_SIZE ) {
                 LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                           (BSL_META_U(unit,
                                       "DVP: Combination issue..Check parameters"
                                       "And Assign dummy attributes\n")));
                 return BCM_E_PARAM; 
             }
         }
         if (flex_attribute->drop) {
             if (flex_attribute->combine_attr_counter[counter_offset].
                 drop_flags == 0) {
                 LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                           (BSL_META_U(unit,
                                       "Combination issue..Check parameters"
                                       "And Assign dummy attributes\n")));
                 return BCM_E_PARAM; 
             }
         }
         if (flex_attribute->ip_pkt) {
             if (flex_attribute->combine_attr_counter[counter_offset].
                 ip_pkt_flags == 0) {
                 LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                           (BSL_META_U(unit,
                                       "DROP: Combination issue..Check parameters"
                                       "And Assign dummy attributes\n")));
                 return BCM_E_PARAM; 
             }
         }
#ifdef BCM_APACHE_SUPPORT
         if (soc_feature(unit,soc_feature_flex_ctr_mpls_3_label_count)) {
             if (flex_attribute->cng_1) {
                 if (flex_attribute->combine_attr_counter[counter_offset].
                         pre_ifp_color_mpls_label1_flags == 0) {
                     LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                             (BSL_META_U(unit,
                                         "PreIfpColorMpls1:Combination issue..Check parameters"
                                         "And Assign dummy attributes\n")));
                     return BCM_E_PARAM;
                 }
             }
             if (flex_attribute->phb_1) {
                 if (flex_attribute->combine_attr_counter[counter_offset].
                         int_pri_mpls_label1_flags == 0) {
                     LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                             (BSL_META_U(unit,
                                         "IntpriMpls1:Combination issue..Check parameters"
                                         "And Assign dummy attributes\n")));
                     return BCM_E_PARAM;
                 }
             }
             if (flex_attribute->cng_2) {
                 if (flex_attribute->combine_attr_counter[counter_offset].
                         pre_ifp_color_mpls_label2_flags == 0) {
                     LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                             (BSL_META_U(unit,
                                         "PreIfpColorMpls2:Combination issue..Check parameters"
                                         "And Assign dummy attributes\n")));
                     return BCM_E_PARAM;
                 }
             }
             if (flex_attribute->phb_2) {
                 if (flex_attribute->combine_attr_counter[counter_offset].
                         int_pri_mpls_label2_flags == 0) {
                     LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                             (BSL_META_U(unit,
                                         "IntpriMpls2:Combination issue..Check parameters"
                                         "And Assign dummy attributes\n")));
                     return BCM_E_PARAM;
                 }
             }
             if (flex_attribute->cng_3) {
                 if (flex_attribute->combine_attr_counter[counter_offset].
                         pre_ifp_color_mpls_label3_flags == 0) {
                     LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                             (BSL_META_U(unit,
                                         "PreIfpColorMpls3:Combination issue..Check parameters"
                                         "And Assign dummy attributes\n")));
                     return BCM_E_PARAM;
                 }
             }
             if (flex_attribute->phb_3) {
                 if (flex_attribute->combine_attr_counter[counter_offset].
                         int_pri_mpls_label3_flags == 0) {
                     LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                             (BSL_META_U(unit,
                                         "IntpriMpls3:Combination issue..Check parameters"
                                         "And Assign dummy attributes\n")));
                     return BCM_E_PARAM;
                 }
             }
         }
#endif
         if (flex_attribute->udf) {
             for (array_index=0;
                  array_index < BCM_STAT_FLEX_BIT_ARRAY_SIZE;
                  array_index++) {
                  if (flex_attribute->combine_attr_counter[counter_offset].
                      value_array[bcmStatFlexAttrUdf][array_index]) {
                      break;
                  }
             }
             if (array_index == BCM_STAT_FLEX_BIT_ARRAY_SIZE ) {
                 LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                           (BSL_META_U(unit,
                                       "Udf: Combination issue..Check parameters"
                                       "And Assign dummy attributes\n")));
                 return BCM_E_PARAM;
             }
             /*When drop is enabled, udf max bit is 7.*/
             if (flex_attribute->drop && udf_max_num_bits == 8) {
                 return BCM_E_PARAM;
             }
         }

#if defined(BCM_TOMAHAWK_SUPPORT) || defined(BCM_TRIDENT3_SUPPORT)
        if (soc_feature(unit, soc_feature_flex_stat_egr_queue_congestion_marked)) {
            if (flex_attribute->mmu_cos) {
                if (flex_attribute->combine_attr_counter[counter_offset].
                    mmu_cos_flags == 0) {
                    LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                        (BSL_META_U(unit,
                        "mmu_cos: Combination issue..Check parameters"
                        "And Assign dummy attributes\n")));
                        return BCM_E_PARAM;
                    }
                }
                if (flex_attribute->uc_queueing) {
                    if (flex_attribute->combine_attr_counter[counter_offset].
                        uc_queueing_flags == 0) {
                        LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                            (BSL_META_U(unit,
                            "uc_queueing: Combination issue..Check parameters"
                            "And Assign dummy attributes\n")));
                        return BCM_E_PARAM;
                    }
                }
                if (flex_attribute->congestion_marked) {
                    if (flex_attribute->combine_attr_counter[counter_offset].
                        congestion_marked_flags == 0) {
                        LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                            (BSL_META_U(unit,
                            "congestion_marked: Combination issue..Check parameters"
                            "And Assign dummy attributes\n")));
                    return BCM_E_PARAM;
                }
            }
        }
#endif
        if (soc_feature(unit, soc_feature_flex_stat_ing_tcp_flags_support)) {
            if (flex_attribute->tcp_flags) {
                if (flex_attribute->combine_attr_counter[counter_offset].
                        tcp_flags == 0) {
                    LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                            (BSL_META_U(unit,
                                        "tcp_flags: Combination issue..Check parameters"
                                        "And Assign dummy attributes\n")));
                    return BCM_E_PARAM;
                }
            }
        }
        if (soc_feature(unit, soc_feature_flex_stat_int_cn_support)) {
            if (flex_attribute->int_cn) {
                if (flex_attribute->combine_attr_counter[counter_offset].
                        int_cn == 0) {
                    LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                            (BSL_META_U(unit,
                                        "int_cn: Combination issue..Check parameters"
                                        "And Assign dummy attributes\n")));
                    return BCM_E_PARAM;
                }
            }
        }
    }
    flex_attribute->total_counters = total_counters;
    flex_attribute->total_selectors = num_selectors;
    return BCM_E_NONE;
}

#if defined(BCM_CHANNELIZED_SWITCHING_SUPPORT)
static int
_bcm_esw_stat_attr_subport_sanitize(int unit,
                    bcm_stat_group_mode_attr_selector_t *old_attr_selectors,
                    bcm_stat_group_mode_attr_selector_t *attr_selectors,
                    int old_num_selectors,
                    int num_selectors)
{

    int i=0, j=0;

    /* Just to make sure that subports are exclusive. */
    for (i=0; i<num_selectors; i++) {
        if (attr_selectors[i].attr == bcmStatGroupModeAttrPort) {
            if (!(_BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit,
                attr_selectors[i].attr_value))) {
                continue;
            }
        }
        for (j=0; j<old_num_selectors; j++) {
            if (old_attr_selectors[i].attr == bcmStatGroupModeAttrPort) {
                if (!(_BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit,
                    old_attr_selectors[i].attr_value))) {
                    continue;
                }
            }

            if (old_attr_selectors[i].attr_value ==
                attr_selectors[i].attr_value) {
                return BCM_E_PARAM;
            }
        }
    }
    return BCM_E_NONE;
}

int
_bcm_esw_stat_attr_subport_only(int unit,
                    bcm_stat_group_mode_attr_selector_t *attr_selectors,
                    int num_selectors)
{
    int i=0;

    if (!(soc_feature(unit, soc_feature_channelized_switching))) {
        return BCM_E_UNAVAIL;
    }
    if (attr_selectors == NULL) {
        return BCM_E_PARAM;
    }

    /* Just to make sure that subports are exclusive. */
    for (i=0; i<num_selectors; i++) {
        if (attr_selectors[i].attr != bcmStatGroupModeAttrPort) {
            return BCM_E_PARAM;
        } else {
            if (!(_BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit,
                attr_selectors[i].attr_value))) {
                return BCM_E_PARAM;
            }
        }
    }
    return BCM_E_NONE;
}

#endif /* BCM_CHANNELIZED_SWITCHING_SUPPORT */

static int _bcm_esw_stat_group_mode_id_check(int unit,
                                             uint32 flags,
                                             uint32 total_counters,
                                             uint32 num_selectors,
              bcm_stat_group_mode_attr_selector_t *attr_selectors,
                                            int share_hw_mode,
                                             uint32 *mode_id) {

    bcm_error_t rv=BCM_E_NONE;
    bcm_stat_flex_ingress_mode_t *flex_ingress_mode=NULL;
    bcm_stat_flex_egress_mode_t  *flex_egress_mode=NULL;
    uint32      mode=0;

    if (flags & BCM_STAT_GROUP_MODE_INGRESS) {
        flex_ingress_mode = sal_alloc(sizeof(bcm_stat_flex_ingress_mode_t),
                                      "flex_ingress_mod");
        if (flex_ingress_mode == NULL) {
            return BCM_E_MEMORY;
        }
        
        sal_memset(flex_ingress_mode,0,sizeof(bcm_stat_flex_ingress_mode_t));
        
        for (mode = 0; mode < BCM_STAT_FLEX_COUNTER_MAX_MODE; mode++) {
             if (_bcm_esw_stat_flex_get_ingress_mode_info(
                            unit,mode,flex_ingress_mode) == BCM_E_NONE) {
                 if ((flex_ingress_mode->num_selectors == num_selectors) &&
                     (share_hw_mode || (flex_ingress_mode->total_counters == total_counters))) {

                     if (share_hw_mode && (flex_ingress_mode->group_mode < bcmStatGroupModeCount)) {
                         LOG_VERBOSE(BSL_LS_BCM_FLEXCTR,
                                     (BSL_META_U(unit,
                                                 "Cannot reuse Mode %d \n"), mode));
                         continue;
                     }

                     if (sal_memcmp(flex_ingress_mode->attr_selectors,
                         attr_selectors,
                         sizeof(bcm_stat_group_mode_attr_selector_t) * 
                         num_selectors) == 0 ) {
#if defined(BCM_CHANNELIZED_SWITCHING_SUPPORT)
                         /* check if these are exclusive subports */
                         if (!(_bcm_esw_stat_attr_subport_sanitize(unit,
                                    flex_ingress_mode->attr_selectors,
                                    attr_selectors,
                                    flex_ingress_mode->num_selectors,
                                    num_selectors))) {
                                 /* Do nothing. */
                             } else
#endif /* BCM_CHANNELIZED_SWITCHING_SUPPORT */
                             {
                             LOG_VERBOSE(BSL_LS_BCM_FLEXCTR,
                                         (BSL_META_U(unit,
                                                 "Mode exist \n")));
                         sal_free(flex_ingress_mode); 
                         if (flags & BCM_STAT_GROUP_MODE_CAPABILITY_OAM) {
                             *mode_id = mode|BCM_STAT_GROUP_MODE_ID_OAM_SUFFIX;
                         } else {
                             *mode_id = mode;
                         }
                         BCM_IF_ERROR_RETURN(
                            _bcm_esw_stat_flex_update_ingress_flex_info(
                                 unit, mode, flags, num_selectors,
                                 attr_selectors));
                         return BCM_E_EXISTS;
                         }
                     }
                 }
             }
        }
        sal_free(flex_ingress_mode); 
    } else {
        flex_egress_mode = sal_alloc(sizeof(bcm_stat_flex_egress_mode_t),
                                      "flex_egress_mod");
        if (flex_egress_mode == NULL) {
            return BCM_E_MEMORY;
        }

        sal_memset(flex_egress_mode, 0, sizeof(bcm_stat_flex_egress_mode_t));
        
        for (mode = 0; mode < BCM_STAT_FLEX_COUNTER_MAX_MODE; mode++) {
             if (_bcm_esw_stat_flex_get_egress_mode_info(
                            unit,mode,flex_egress_mode) == BCM_E_NONE) {
                 if (flex_egress_mode->num_selectors == num_selectors) {
                     if (sal_memcmp(flex_egress_mode->attr_selectors,
                         attr_selectors,
                         sizeof(bcm_stat_group_mode_attr_selector_t) *
                         num_selectors) == 0 ) {
                         LOG_VERBOSE(BSL_LS_BCM_FLEXCTR,
                                     (BSL_META_U(unit,
                                                 "Mode exist \n")));
                         sal_free(flex_egress_mode); 
                         *mode_id = mode + BCM_STAT_FLEX_COUNTER_MAX_MODE;
                         return BCM_E_EXISTS;
                     }
                 }
             }
        }
        sal_free(flex_egress_mode); 
    }
    return rv;

}

#ifdef BCM_KATANA2_SUPPORT

/*
 * Function:
 *      _bcm_esw_stat_group_mode_attr_class_id_cleanup
 * Description:
 *      Cleanup Customized Stat class identifier related structures
 *
 * Parameters:
 *   unit                (IN) Unit number.
 *
 * Return Value:
 *   BCM_E_XXX
 */

int _bcm_esw_stat_group_mode_attr_class_id_cleanup(
        int unit)
{
    uint32 flex_pkt_res_values_count=0, i = 0;

    if (SOC_IS_KATANAX(unit)) {
        flex_pkt_res_values_count = sizeof(_flex_pkt_res_values_katana)/
            sizeof(_flex_pkt_res_values_katana[0]);
    }
    if (class_attr_comb[unit].class_pkt_attr_comb) {
        for (i = 0; i < flex_pkt_res_values_count; i++) {
            if (class_attr_comb[unit].class_pkt_attr_comb[i] != NULL) {
                sal_free(class_attr_comb[unit].class_pkt_attr_comb[i]);
            }
        }
        sal_free(class_attr_comb[unit].class_pkt_attr_comb);
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_esw_stat_combine_attr_matrix_init
 * Description:
 *      Initialize and allocate Matrix for combining
 *      Counter Attributes.
 *
 * Parameters:
 *   unit                (IN) Unit number.
 *
 * Return Value:
 *   BCM_E_XXX
 */

int _bcm_esw_stat_combine_attr_matrix_init(
        int unit,
        int *size)
{

    uint32 flex_pkt_res_values_count=0, i = 0;

    if (SOC_IS_KATANAX(unit)) {
        flex_pkt_res_values_count = sizeof(_flex_pkt_res_values_katana)/
            sizeof(_flex_pkt_res_values_katana[0]);
    }

    /* Compression matrix creation. */
    class_attr_comb[unit].class_pkt_attr_comb =
        (uint32 **)sal_alloc(flex_pkt_res_values_count*
                sizeof(uint32 *),
                "class_attr_comb");
    if (class_attr_comb[unit].class_pkt_attr_comb == NULL) {
        return BCM_E_INTERNAL;
    }
    for (i = 0; i < flex_pkt_res_values_count; i++) {
        class_attr_comb[unit].class_pkt_attr_comb[i] =
            (uint32 *) sal_alloc(flex_pkt_res_values_count*
                    sizeof(uint32 ),
                    "class_attr_comb");
        if (class_attr_comb[unit].class_pkt_attr_comb[i] == NULL) {
            _bcm_esw_stat_group_mode_attr_class_id_cleanup(unit);
            return BCM_E_INTERNAL;
        }
        sal_memset(class_attr_comb[unit].class_pkt_attr_comb[i], 0,
                flex_pkt_res_values_count*sizeof(uint32 ));
    }

    *size = flex_pkt_res_values_count;
    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_esw_stat_group_mode_attr_class_id_create
 * Description:
 *      Create Customized Stat class identifiers for combining
 *      Counter Attributes.
 *
 * Parameters:
 *   unit                (IN) Unit number.
 *   attr                (IN) Stat Attribute Flex Group Mode
 *   num_of_attr_values  (IN) Number of combined Attributes
 *   attr_values         (IN) Attribute Combined types
 *   attr_class_id       (OUT) Created Class Identifier for the Combined type.
 *
 * Return Value:
 *   BCM_E_XXX
 */

int _bcm_esw_stat_group_mode_attr_class_id_create(
        int unit,
        bcm_stat_group_mode_attr_t attr,
        int num_of_attr_values,
        uint32 *attr_values,
        bcm_stat_group_mode_attr_class_id_t *attr_class_id)
{

    uint32 flex_pkt_res_values_count=0, class_id = 0, attr_val = 0;
    uint32 empty_class_id = 0, i = 0;

    if (attr == bcmStatGroupModeAttrPktType) {
        if (SOC_IS_KATANAX(unit)) {
            flex_pkt_res_values_count = sizeof(_flex_pkt_res_values_katana)/
                sizeof(_flex_pkt_res_values_katana[0]);
        }
        if (flex_pkt_res_values_count < num_of_attr_values) {
            return BCM_E_PARAM;
        }

        /* Validation for new class creation with existing combination. */
        for (class_id = 0; class_id < flex_pkt_res_values_count; class_id++) {
            if ((class_attr_comb[unit].class_pkt_attr_comb[class_id][0] == 0) && (empty_class_id == 0)) {
                empty_class_id = class_id + 1;
                class_id++;
            }
            for (attr_val = 0; attr_val < flex_pkt_res_values_count; attr_val++) {
                if (class_attr_comb[unit].class_pkt_attr_comb[class_id][attr_val] == 0) {
                    break;
                }
                for (i = 0; i < num_of_attr_values; i++) {
                    if (class_attr_comb[unit].class_pkt_attr_comb[class_id][attr_val] == attr_values[i]) {
                        return BCM_E_PARAM;
                    }
                }
            }
        }
        if (empty_class_id >= flex_pkt_res_values_count) {
            return BCM_E_FULL;
        }

        *attr_class_id = empty_class_id;

        /* Populate Compression matrix. */
        for (i = 0; i < num_of_attr_values; i++) {
            class_attr_comb[unit].class_pkt_attr_comb[empty_class_id - 1][i] = attr_values[i];
        }
        return BCM_E_NONE;
    }
    return BCM_E_PARAM;
}


/*
 * Function:
 *      _bcm_esw_stat_group_mode_attr_class_id_destroy
 * Description:
 *      Destroy Customized Stat class identifiers created for combining
 *      Counter Attributes.
 *
 * Parameters:
 *   unit                (IN) Unit number.
 *   class_id            (IN) Created Class Identifier for the Combined type.
 *
 * Return Value:
 *   BCM_E_XXX
 */

int _bcm_esw_stat_group_mode_attr_class_id_destroy(
        int unit,
        bcm_stat_group_mode_attr_class_id_t attr_class_id)
{
    uint32 flex_pkt_res_values_count=0, attr_val = 0;

    if (SOC_IS_KATANAX(unit)) {
        flex_pkt_res_values_count = sizeof(_flex_pkt_res_values_katana)/
            sizeof(_flex_pkt_res_values_katana[0]);
    }
    if (attr_class_id > 0 && (flex_pkt_res_values_count >= attr_class_id)) {
        attr_class_id--;
    } else {
        return BCM_E_PARAM;
    }
    if (class_attr_comb[unit].class_pkt_attr_comb[attr_class_id][0] == 0) {
        return BCM_E_EMPTY;
    }

    /* Destroy the Compression matrix entries related to the class_id. */
    for (attr_val = 0; attr_val < flex_pkt_res_values_count; attr_val++) {
        if (class_attr_comb[unit].class_pkt_attr_comb[attr_class_id][attr_val] == 0) {
            break;
        }
        class_attr_comb[unit].class_pkt_attr_comb[attr_class_id][attr_val] = 0;
    }

    return BCM_E_NONE;
}

/*
 *  Function:
 *    _bcm_esw_stat_flex_compressed_attr_matrix_sync
 *  Purpose:
 *    Sync compressed attr matrix to scache.
 *  Parameters:
 *     unit                  - (IN) unit number
 *     scache_position       - (IN/OUT) Scache position
 *  Returns:
 *      BCM_E_XXX
 */
int
_bcm_esw_stat_flex_compressed_attr_matrix_sync(int unit,
        uint8 **scache_position)
{
    uint32 *scache_ptr = NULL;
    uint32 flex_pkt_res_values_count = 0, i = 0;

    if (SOC_IS_KATANAX(unit)) {
        flex_pkt_res_values_count = sizeof(_flex_pkt_res_values_katana)/
            sizeof(_flex_pkt_res_values_katana[0]);
    }

    scache_ptr = (uint32 *)*scache_position;
    if (soc_feature(unit, soc_feature_flex_stat_attributes_class)) {
        for (i = 0; i < flex_pkt_res_values_count; i++) {
            sal_memcpy(scache_ptr,
                    class_attr_comb[unit].class_pkt_attr_comb[i],
                    flex_pkt_res_values_count*sizeof(uint32));
            scache_ptr += flex_pkt_res_values_count;
        }
    } else {
        sal_memset(scache_ptr, 0,
                flex_pkt_res_values_count*flex_pkt_res_values_count*sizeof(uint32));
        scache_ptr +=
            flex_pkt_res_values_count*flex_pkt_res_values_count;

    }
    *scache_position = (uint8 *)scache_ptr;
    return BCM_E_NONE;
}

/*
 *  Function:
 *    _bcm_esw_stat_flex_compressed_attr_matrix_recover
 *  Purpose:
 *    Recover compressed attr matrix from scache.
 *  Parameters:
 *    unit                  - (IN) unit number
 *    scache_position       - (IN/OUT) Scache position
 *  Returns:
 *    BCM_E_XXX
 */
int _bcm_esw_stat_flex_compressed_attr_matrix_recover(int unit,
        uint8 **scache_position)
{
    uint32 *scache_ptr = NULL;
    uint32 flex_pkt_res_values_count = 0, i = 0;

    if (SOC_IS_KATANAX(unit)) {
        flex_pkt_res_values_count = sizeof(_flex_pkt_res_values_katana)/
            sizeof(_flex_pkt_res_values_katana[0]);
    }

    scache_ptr = (uint32 *)*scache_position;
    /* Combined pkt attributes matrix */
    if (soc_feature(unit, soc_feature_flex_stat_attributes_class)) {
        for (i = 0; i < flex_pkt_res_values_count; i++) {
            sal_memcpy(class_attr_comb[unit].class_pkt_attr_comb[i], scache_ptr,
                    flex_pkt_res_values_count*sizeof(uint32));
            scache_ptr += flex_pkt_res_values_count;
        }
    } else {
        scache_ptr +=
            flex_pkt_res_values_count*flex_pkt_res_values_count;
    }
    *scache_position = (uint8 *)scache_ptr;
    return BCM_E_NONE;
}

#endif

/* Create New Customized Stat Group mode for given Counter Attributes */
/* Doesn't check for existing HW mode */
static 
int _bcm_esw_stat_group_new_mode_id_create(
    int unit,
    uint32 flags,
    uint32 total_counters,
    uint32 num_selectors,
    bcm_stat_group_mode_attr_selector_t *attr_selectors,
    uint32 *mode_id)
{
    bcm_stat_flex_attribute_t  flex_attribute={0};
    bcm_error_t rv=BCM_E_NONE;
    *mode_id = 0; 
    /* Perform Sanity Checks */
    /* Unit will be surely valid */
    if (!((flags & BCM_STAT_GROUP_MODE_INGRESS) || 
          (flags & BCM_STAT_GROUP_MODE_EGRESS))) { 
         return BCM_E_PARAM;
    }

    if (soc_feature(unit, soc_feature_use_flex_ctr_oam_lm)) {
        /* Capability for OAM is defined only on the Ingress.
         */
        if ((flags & BCM_STAT_GROUP_MODE_EGRESS) && 
            (flags & BCM_STAT_GROUP_MODE_CAPABILITY_OAM)) { 
             return BCM_E_PARAM;
        }
    } else {
        /* Capability for OAM shall be created only when use_flex_ctr_oam_lm 
         * feature is defined.
         */
        if (flags & BCM_STAT_GROUP_MODE_CAPABILITY_OAM) { 
             return BCM_E_PARAM;
        }
    }

    if ((total_counters == 0) ||
        (total_counters > BCM_STAT_FLEX_MAX_COUNTER)) {
         return BCM_E_PARAM;
    }
    if (attr_selectors == NULL) {
         return BCM_E_PARAM;
    } 

    if (num_selectors > BCM_STAT_FLEX_MAX_SELECTORS) {
        return BCM_E_PARAM;
    }

    flex_attribute.combine_attr_counter = 
                    sal_alloc(sizeof(bcm_stat_flex_combine_attr_counter_t) * 
                               total_counters, "flex_attribute");
    if (flex_attribute.combine_attr_counter == NULL) {
        return BCM_E_MEMORY;
    }
    sal_memset(flex_attribute.combine_attr_counter,
              0,sizeof(bcm_stat_flex_combine_attr_counter_t) * total_counters); 
    rv = _bcm_esw_stat_group_mode_fillup_values(unit,
         flags, total_counters, num_selectors, attr_selectors, &flex_attribute);
    if (BCM_FAILURE(rv)) { 
        sal_free(flex_attribute.combine_attr_counter);
        return rv;
    }
    rv = _bcm_esw_stat_group_mode_associate_id(unit, 
         flags, &flex_attribute, mode_id);
    if ((rv == BCM_E_NONE) || (rv==BCM_E_EXISTS)) {
         if (flags & BCM_STAT_GROUP_MODE_INGRESS) {
             rv = _bcm_esw_stat_flex_update_ingress_flex_info(
                                 unit, *mode_id, flags, num_selectors,
                                 attr_selectors);
         } else {    
             rv = _bcm_esw_stat_flex_update_egress_flex_info(
                                 unit, *mode_id, flags, num_selectors,
                                 attr_selectors);
         }
         if (BCM_FAILURE(rv)) {
             sal_free(flex_attribute.combine_attr_counter);
             return rv;
         }
         if (flags & BCM_STAT_GROUP_MODE_EGRESS) { 
             *mode_id += BCM_STAT_FLEX_COUNTER_MAX_MODE;
         } 
         if (flags & BCM_STAT_GROUP_MODE_CAPABILITY_OAM) {
             *mode_id |= BCM_STAT_GROUP_MODE_ID_OAM_SUFFIX;
         }
         rv = BCM_E_NONE;
    }
    sal_free(flex_attribute.combine_attr_counter);
    return rv;
}

/* Create Customized Stat Group mode for given Counter Attributes */
int _bcm_esw_stat_group_mode_id_create(
    int unit,
    uint32 flags,
    uint32 total_counters,
    uint32 num_selectors,
    bcm_stat_group_mode_attr_selector_t *attr_selectors,
    uint32 *mode_id)
{
    bcm_stat_flex_attribute_t  flex_attribute={0};
    bcm_error_t rv=BCM_E_NONE;
    *mode_id = 0; 
    /* Perform Sanity Checks */
    /* Unit will be surely valid */
    if (!((flags & BCM_STAT_GROUP_MODE_INGRESS) || 
          (flags & BCM_STAT_GROUP_MODE_EGRESS))) {
         return BCM_E_PARAM;
    }

    if (soc_feature(unit, soc_feature_use_flex_ctr_oam_lm)) {
        /* Capability for OAM is defined only on the Ingress.
         */
        if ((flags & BCM_STAT_GROUP_MODE_EGRESS) && 
            (flags & BCM_STAT_GROUP_MODE_CAPABILITY_OAM)) { 
             return BCM_E_PARAM;
        }
    } else {
        /* Capability for OAM shall be created only when use_flex_ctr_oam_lm 
         * feature is defined.
         */
        if (flags & BCM_STAT_GROUP_MODE_CAPABILITY_OAM) { 
             return BCM_E_PARAM;
        }
    }

    /*UDF in egress mode is not supported so far*/
    if ((flags & BCM_STAT_GROUP_MODE_EGRESS) &&
        (flags & BCM_STAT_GROUP_MODE_UDF)) {
        return BCM_E_PARAM;
    }

    if ((total_counters == 0) ||
        (total_counters > BCM_STAT_FLEX_MAX_COUNTER)) {
         return BCM_E_PARAM;
    }
    if (attr_selectors == NULL) {
         return BCM_E_PARAM;
    } 
    /* Check for existing mode */
    if ((rv = _bcm_esw_stat_group_mode_id_check(unit, flags, total_counters, 
                                      num_selectors, attr_selectors, 0, mode_id)) != BCM_E_NONE) {
         return rv;
    }

    flex_attribute.combine_attr_counter = 
                    sal_alloc(sizeof(bcm_stat_flex_combine_attr_counter_t) * 
                               total_counters, "flex_attribute");
    if (flex_attribute.combine_attr_counter == NULL) {
        return BCM_E_MEMORY;
    }
    sal_memset(flex_attribute.combine_attr_counter,
              0,sizeof(bcm_stat_flex_combine_attr_counter_t) * total_counters); 
    rv = _bcm_esw_stat_group_mode_fillup_values(unit,
         flags, total_counters, num_selectors, attr_selectors, &flex_attribute);
    if (BCM_FAILURE(rv)) {
        sal_free(flex_attribute.combine_attr_counter);
        return rv;
    }
    rv = _bcm_esw_stat_group_mode_associate_id(unit, 
         flags, &flex_attribute, mode_id);
    if ((rv == BCM_E_NONE) || (rv==BCM_E_EXISTS)) {
         if (flags & BCM_STAT_GROUP_MODE_INGRESS) {
             rv = _bcm_esw_stat_flex_update_ingress_flex_info(
                                 unit, *mode_id, flags, num_selectors,
                                 attr_selectors);
         } else {    
             rv = _bcm_esw_stat_flex_update_egress_flex_info(
                                 unit, *mode_id, flags, num_selectors,
                                 attr_selectors);
         }
         if (BCM_FAILURE(rv)) {
             sal_free(flex_attribute.combine_attr_counter);
             return rv;
         }
         if (flags & BCM_STAT_GROUP_MODE_EGRESS) { 
             *mode_id += BCM_STAT_FLEX_COUNTER_MAX_MODE;
         } 
         if (flags & BCM_STAT_GROUP_MODE_CAPABILITY_OAM) {
             *mode_id |= BCM_STAT_GROUP_MODE_ID_OAM_SUFFIX;
         }
         rv = BCM_E_NONE;
    }
    sal_free(flex_attribute.combine_attr_counter);
    return rv;
}

/* Retrieves Customized Stat Group mode Attributes for given mode_id */
int _bcm_esw_stat_group_mode_id_get(
    int unit,
    uint32 mode_id,
    uint32 *flags,
    uint32 *total_counters,
    uint32 num_selectors,
    bcm_stat_group_mode_attr_selector_t *attr_selectors,
    uint32 *actual_num_selectors)
{
    bcm_stat_flex_ingress_mode_t *flex_ingress_mode=NULL;
    bcm_stat_flex_egress_mode_t  *flex_egress_mode=NULL;
    uint32                       selector=0;
    bcm_error_t                  rv=BCM_E_NONE;
    if ((flags == NULL) ||
        (total_counters == NULL) ||
        /* (attr_selectors == NULL) || */ /*Could be used to get num_selectors*/
        (actual_num_selectors == NULL)) {
         return BCM_E_PARAM;
    }

    *flags = 0;
    if ( BCM_STAT_GROUP_MODE_ID_OAM_SUFFIX ==
         (mode_id & BCM_STAT_GROUP_MODE_ID_OAM_MASK)) {
        mode_id = mode_id & ~(BCM_STAT_GROUP_MODE_ID_OAM_MASK);
        *flags = BCM_STAT_GROUP_MODE_CAPABILITY_OAM;
    }

    if (mode_id < BCM_STAT_FLEX_COUNTER_MAX_MODE) {
        flex_ingress_mode = sal_alloc(sizeof(bcm_stat_flex_ingress_mode_t),
                                      "flex_ingress_mod");
        if (flex_ingress_mode == NULL) {
            return BCM_E_MEMORY;
        } 
        
        sal_memset(flex_ingress_mode, 0, sizeof(bcm_stat_flex_ingress_mode_t));

        rv = _bcm_esw_stat_flex_get_ingress_mode_info(unit,
                  mode_id,flex_ingress_mode);
        if (BCM_SUCCESS(rv)) {
            *flags |= flex_ingress_mode->flags;     
            *total_counters = flex_ingress_mode->total_counters;     
            *actual_num_selectors = flex_ingress_mode->num_selectors;     
            if (num_selectors <= *actual_num_selectors) {
                for (selector = 0 ; selector <  num_selectors; selector++) {
                     sal_memcpy(&attr_selectors[selector], 
                                &flex_ingress_mode->attr_selectors[selector], 
                                sizeof(bcm_stat_group_mode_attr_selector_t));
                }
            }
        }
        sal_free(flex_ingress_mode);
    } else {
        flex_egress_mode = sal_alloc(sizeof(bcm_stat_flex_egress_mode_t),
                                      "flex_egress_mod");
        if (flex_egress_mode == NULL) {
            return BCM_E_MEMORY;
        }

        sal_memset(flex_egress_mode, 0, sizeof(bcm_stat_flex_egress_mode_t));
        
        mode_id -= BCM_STAT_FLEX_COUNTER_MAX_MODE;
        rv = _bcm_esw_stat_flex_get_egress_mode_info(unit,
                  mode_id,flex_egress_mode);
        if (BCM_SUCCESS(rv)) {
            *flags = flex_egress_mode->flags;     
            *total_counters = flex_egress_mode->total_counters;     
            *actual_num_selectors = flex_egress_mode->num_selectors;     
            if (num_selectors <= *actual_num_selectors) {
                for (selector = 0 ; selector <  num_selectors; selector++) {
                     sal_memcpy(&attr_selectors[selector], 
                                &flex_egress_mode->attr_selectors[selector], 
                                sizeof(bcm_stat_group_mode_attr_selector_t));
                }
            }
        }
        sal_free(flex_egress_mode);
    }
    return rv;
}

bcm_error_t _bcm_esw_stat_flex_get_hw_mode(int unit, uint32 mode_id, uint32 *hw_mode_id) {

    bcm_error_t rv = BCM_E_NONE;
    bcm_stat_flex_custom_ingress_mode_t cmode;

    *hw_mode_id = 0;
    if (mode_id >= BCM_CUSTOM_INGRESS_MODE_START) {
        if(_bcm_esw_stat_flex_get_custom_ingress_mode_info(unit, mode_id, &cmode)
                                                                == BCM_E_NONE) {
            *hw_mode_id = cmode.offset_mode;
        }
    } else {
        rv = BCM_E_NOT_FOUND;
    }
    return rv;
}



/* Destroys Customized Group mode */
int _bcm_esw_stat_group_mode_id_destroy(
    int unit,
    uint32 mode_id)
{
    uint32 offset_mode=0;
    bcm_error_t rv=BCM_E_NONE;
    bcm_error_t r_rv=BCM_E_NONE;
    bcm_stat_group_mode_t     group_mode= bcmStatGroupModeSingle;
    uint32 flags = 0;
    bcm_stat_flex_custom_ingress_mode_t cmode;
    bcm_stat_flex_ingress_mode_t *flex_ingress_mode = NULL;

#if defined (BCM_TOMAHAWK_SUPPORT) && defined (INCLUDE_FLOWTRACKER)
    if (soc_feature(unit, soc_feature_uc_flowtracker_learn) &&
        soc_feature(unit, soc_feature_uc_flowtracker_export)) {
        if(_bcm_esw_stat_mod_reserved(unit, mode_id)) {
            LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                  (BSL_META_U(unit,
                      "Try to destroy mode used by flowtracker\n")));
            return BCM_E_PARAM;
        }
    }
#endif

    flex_ingress_mode = sal_alloc(sizeof(bcm_stat_flex_ingress_mode_t),
                                      "flex_ingress_mod");
    if (flex_ingress_mode == NULL) {
        return BCM_E_MEMORY;
    }
    memset(flex_ingress_mode, 0, sizeof(bcm_stat_flex_ingress_mode_t));

    offset_mode = mode_id;
    if ( BCM_STAT_GROUP_MODE_ID_OAM_SUFFIX ==
         (mode_id & BCM_STAT_GROUP_MODE_ID_OAM_MASK)) {
         mode_id = mode_id & ~(BCM_STAT_GROUP_MODE_ID_OAM_MASK);
         flags = BCM_STAT_GROUP_MODE_CAPABILITY_OAM;
         offset_mode = mode_id;
    } else if (mode_id >= BCM_CUSTOM_INGRESS_MODE_START
#if defined(BCM_TRIDENT3_SUPPORT) || defined(BCM_TOMAHAWK3_SUPPORT)
                && (mode_id < BCM_CUSTOM_EGRESS_MODE_START)
#endif
    ) {
        if(_bcm_esw_stat_flex_get_custom_ingress_mode_info(unit, mode_id, &cmode)
                                                                == BCM_E_NONE) {
            offset_mode = cmode.offset_mode;
            flags |= BCM_STAT_GROUP_MODE_INGRESS;
            cmode.used = 0;
            cmode.AllocPool = -1;
            if (cmode.attr_selectors) {
                sal_free(cmode.attr_selectors);
                cmode.attr_selectors = NULL;
            }
            _bcm_esw_stat_flex_update_custom_ingress_mode_info(unit, mode_id, &cmode);
        }
    }
#if defined(BCM_TRIDENT3_SUPPORT) || defined(BCM_TOMAHAWK3_SUPPORT)
    else if (mode_id >= BCM_CUSTOM_EGRESS_MODE_START) {
        bcm_stat_flex_custom_egress_mode_t egr_cmode;
        if(_bcm_esw_stat_flex_get_custom_egress_mode_info(unit, mode_id,
            &egr_cmode) == BCM_E_NONE) {
            offset_mode = egr_cmode.offset_mode + BCM_STAT_FLEX_COUNTER_MAX_MODE;
            flags |= BCM_STAT_GROUP_MODE_EGRESS;
            egr_cmode.used = 0;
            egr_cmode.AllocPool = -1;
            if (egr_cmode.attr_selectors) {
                sal_free(egr_cmode.attr_selectors);
                egr_cmode.attr_selectors = NULL;
            }
            _bcm_esw_stat_flex_update_custom_egress_mode_info(unit, mode_id,
                &egr_cmode);
        }
    }
#endif


    if (offset_mode >= BCM_STAT_FLEX_COUNTER_MAX_MODE) {
        flags = BCM_STAT_GROUP_MODE_EGRESS; 
        offset_mode -= BCM_STAT_FLEX_COUNTER_MAX_MODE;
    } else {
        flags |= BCM_STAT_GROUP_MODE_INGRESS; 
    }

    if (flags & BCM_STAT_GROUP_MODE_INGRESS) {
        if (soc_feature(unit, soc_feature_use_flex_ctr_oam_lm)) {
            if ((rv = _bcm_esw_stat_flex_get_ingress_mode_info(
                     unit, offset_mode, flex_ingress_mode)) != BCM_E_NONE) {
                sal_free(flex_ingress_mode);
                return rv;
            }

            if (flags & BCM_STAT_GROUP_MODE_CAPABILITY_OAM) {
                if ((rv=_bcm_esw_stat_flex_delete_ingress_flags(
                        unit,offset_mode,flags)) != BCM_E_NONE) {
                    sal_free(flex_ingress_mode);
                    return rv;
                }
            }
        }
        if ((rv=_bcm_esw_stat_flex_delete_ingress_mode(
                unit,offset_mode)) == BCM_E_NONE) {
                group_mode = bcmStatGroupModeFlex1 + offset_mode;
                LOG_DEBUG(BSL_LS_BCM_FLEXCTR,
                          (BSL_META_U(unit,
                                      "Destroyed Ingress Mode also \n")));
                _bcm_esw_stat_flex_reset_group_mode(
                                    unit,bcmStatFlexDirectionIngress,
                                    offset_mode,group_mode);
        } else if ((flags & BCM_STAT_GROUP_MODE_CAPABILITY_OAM) && 
                   soc_feature(unit, soc_feature_use_flex_ctr_oam_lm)) { 
                if ((r_rv = _bcm_esw_stat_flex_update_ingress_flex_info(unit,
                                         offset_mode, flags,
                                         flex_ingress_mode->num_selectors,
                                         flex_ingress_mode->attr_selectors)) !=
                                         BCM_E_NONE) { 
                    sal_free(flex_ingress_mode);
                    return r_rv;
                }
        }
    } else {
        if ((rv=_bcm_esw_stat_flex_delete_egress_mode(
                unit,offset_mode)) == BCM_E_NONE) {
                group_mode = bcmStatGroupModeFlex1 + offset_mode;
                LOG_DEBUG(BSL_LS_BCM_FLEXCTR,
                          (BSL_META_U(unit,
                                      "Destroyed Egress Mode also \n")));
                _bcm_esw_stat_flex_reset_group_mode(
                                    unit,bcmStatFlexDirectionEgress,
                                    offset_mode,group_mode);
        }
    }
    sal_free(flex_ingress_mode);
    return  rv;
}

#ifdef BCM_TOMAHAWK_SUPPORT
static bcm_error_t _bcm_esw_get_ingress_ifp_table_from_pipe(int pipe, soc_mem_t *ingress_table) {
    bcm_error_t rv=BCM_E_NONE;
    switch(pipe) {
        case 0:
             *ingress_table = IFP_POLICY_TABLE_PIPE0m;
             break;
        case 1:
             *ingress_table = IFP_POLICY_TABLE_PIPE1m;
             break;
        case 2:
             *ingress_table = IFP_POLICY_TABLE_PIPE2m;
             break;
        case 3:
             *ingress_table = IFP_POLICY_TABLE_PIPE3m;
             break;
        case 4:
             *ingress_table = IFP_POLICY_TABLE_PIPE4m;
             break;
        case 5:
             *ingress_table = IFP_POLICY_TABLE_PIPE5m;
             break;
        case 6:
             *ingress_table = IFP_POLICY_TABLE_PIPE6m;
             break;
        case 7:
             *ingress_table = IFP_POLICY_TABLE_PIPE7m;
             break;
        default:
             rv = BCM_E_NOT_FOUND;
             break;
    }
    return rv;
}
static bcm_error_t _bcm_esw_get_ingress_vfp_table_from_pipe(int pipe, soc_mem_t *ingress_table) {
    bcm_error_t rv=BCM_E_NONE;
    switch(pipe) {
        case 0:
             *ingress_table = VFP_POLICY_TABLE_PIPE0m;
             break;
        case 1:
             *ingress_table = VFP_POLICY_TABLE_PIPE1m;
             break;
        case 2:
             *ingress_table = VFP_POLICY_TABLE_PIPE2m;
             break;
        case 3:
             *ingress_table = VFP_POLICY_TABLE_PIPE3m;
             break;
        case 4:
             *ingress_table = VFP_POLICY_TABLE_PIPE4m;
             break;
        case 5:
             *ingress_table = VFP_POLICY_TABLE_PIPE5m;
             break;
        case 6:
             *ingress_table = VFP_POLICY_TABLE_PIPE6m;
             break;
        case 7:
             *ingress_table = VFP_POLICY_TABLE_PIPE7m;
             break;
        default:
             rv = BCM_E_NOT_FOUND;
             break;
    }
    return rv;
}
static bcm_error_t _bcm_esw_get_ingress_em_table_from_pipe(int pipe, soc_mem_t *ingress_table) {
    bcm_error_t rv=BCM_E_NONE;
    switch(pipe) {
        case 0:
             *ingress_table = EXACT_MATCH_2_PIPE0m;
             break;
        case 1:
             *ingress_table = EXACT_MATCH_2_PIPE1m;
             break;
        case 2:
             *ingress_table = EXACT_MATCH_2_PIPE2m;
             break;
        case 3:
             *ingress_table = EXACT_MATCH_2_PIPE3m;
             break;
        default:
             rv = BCM_E_NOT_FOUND;
             break;
    }
    return rv;
}

#if defined(BCM_TRIDENT3_SUPPORT)
static bcm_error_t _bcm_esw_get_egr_fp_table_from_pipe(int pipe,
                                soc_mem_t *egress_table) {
    bcm_error_t rv = BCM_E_NONE;
    switch(pipe) {
        case 0:
             *egress_table = EFP_POLICY_TABLE_PIPE0m;
             break;
        case 1:
             *egress_table = EFP_POLICY_TABLE_PIPE1m;
             break;
        default:
             rv = BCM_E_NOT_FOUND;
             break;
    }
    return rv;
}
#endif

#endif

#if defined(BCM_TRIDENT3_SUPPORT) || defined(BCM_APACHE_SUPPORT)
/*
 * Function:
 *      _bcm_esw_stat_combine_ports_bitmap_cleanup
 * Description:
 *      Cleanup bitmap for combining ports.
 *
 * Parameters:
 *   unit                (IN) Unit number.
 *
 * Return Value:
 *   BCM_E_XXX
 */

int
_bcm_esw_stat_combine_port_bitmap_cleanup(int unit)
{

    if (stat_port_grp[unit].port_grp_bmap != NULL) {
        sal_free(stat_port_grp[unit].port_grp_bmap);
        stat_port_grp[unit].port_grp_bmap = NULL;
    }
    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_esw_stat_combine_ports_bitmap_init
 * Description:
 *      Initialize and allocate bitmap for combining ports.
 *
 * Parameters:
 *   unit                (IN)  Unit number.
 *   size                (OUT) Size of the memory.
 *
 * Return Value:
 *   BCM_E_XXX
 */

int
_bcm_esw_stat_combine_port_bitmap_init(int unit,
                                       int *size)
{

    uint32 max_grp_cnt = 0;

    max_grp_cnt = (1 << ing_pkt_attr_cmprsd_bits_g[unit].ing_port) - 1;

    if (max_grp_cnt && stat_port_grp[unit].port_grp_bmap == NULL) {
        stat_port_grp[unit].port_grp_bmap = (pbmp_t *)sal_alloc(max_grp_cnt*
                sizeof(pbmp_t), "flex_port_grp_bmap");
        if (stat_port_grp[unit].port_grp_bmap) {
            sal_memset(stat_port_grp[unit].port_grp_bmap,
                    0,
                    max_grp_cnt*sizeof(pbmp_t));
        }
    }
    if (stat_port_grp[unit].port_grp_bmap == NULL) {
        return BCM_E_MEMORY;
    }

    *size = (max_grp_cnt + 1)*sizeof(pbmp_t);
    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_esw_stat_port_group_create
 * Description:
 *      Create customized group identifiers for combining ports.
 *
 * Parameters:
 *   unit                (IN) Unit number.
 *   num_ports           (IN) Numbder of ports.
 *   gport               (IN) List of gports
 *   group_id           (OUT) Created group Identifier for the combined ports.
 *
 * Return Value:
 *   BCM_E_XXX
 */
int
_bcm_esw_stat_port_group_create(int unit,
                                uint32 num_gports,
                                bcm_gport_t *gport,
                                uint32 *group_id)
{
    uint32 idx = 0, port_idx = 0, max_grp_cnt = 0;
    bcm_port_t port;

    max_grp_cnt = (1 << ing_pkt_attr_cmprsd_bits_g[unit].ing_port) - 1;
    /* Check whether any of the ports is part of another existing group. */
    for (port_idx = 0; port_idx < num_gports; port_idx++) {
        BCM_IF_ERROR_RETURN(
                bcm_esw_port_local_get(unit, gport[port_idx], &port));
        if (SHR_BITGET(stat_port_grp[unit].port_grp_bmap[0].pbits, port)) {
            return BCM_E_PARAM;
        }
    }
    if (max_grp_cnt) {
        for (idx = 1; idx < max_grp_cnt; idx++) {
            if (!SHR_BITGET(stat_port_grp[unit].port_grp_id_bmap.pbits, idx)) {
                SHR_BITSET(stat_port_grp[unit].port_grp_id_bmap.pbits, idx);
                *group_id = idx;
                for (port_idx = 0; port_idx < num_gports; port_idx++) {
                    BCM_IF_ERROR_RETURN(
                            bcm_esw_port_local_get(unit, gport[port_idx], &port));
                    SHR_BITSET(stat_port_grp[unit].port_grp_bmap[idx].pbits, port);
                    SHR_BITSET(stat_port_grp[unit].port_grp_bmap[0].pbits, port);
                }
            break;
            }
        }
    } else {
        return BCM_E_UNAVAIL;
    }
    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_esw_stat_port_group_destroy
 * Description:
 *      Destroy customized group identifiers for combining ports.
 *
 * Parameters:
 *   unit                (IN) Unit number.
 *   group_id            (IN) Created group Identifier for the combined ports.
 *
 * Return Value:
 *   BCM_E_XXX
 */
int
_bcm_esw_stat_port_group_destroy(int unit,
        uint32 group_id)
{
    uint32 max_grp_cnt = 0;

    max_grp_cnt = (1 << ing_pkt_attr_cmprsd_bits_g[unit].ing_port) - 1;
    if (max_grp_cnt) {
        if (SHR_BITGET(stat_port_grp[unit].port_grp_id_bmap.pbits, group_id)) {
            SHR_BITXOR_RANGE(stat_port_grp[unit].port_grp_bmap[0].pbits,
                    stat_port_grp[unit].port_grp_bmap[group_id].pbits,
                    0, max_grp_cnt,
                    stat_port_grp[unit].port_grp_bmap[0].pbits);
            SHR_BITCLR(stat_port_grp[unit].port_grp_id_bmap.pbits, group_id);
            SHR_BITCLR_RANGE(stat_port_grp[unit].port_grp_bmap[group_id].pbits,
                    0, max_grp_cnt);
        } else {
            return BCM_E_NOT_FOUND;
        }
    } else {
        return BCM_E_UNAVAIL;
    }
    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_esw_stat_combine_port_bitmap_sync
 * Description:
 *      Sync bitmap for group identifiers for combining ports.
 *
 * Parameters:
 *   unit                (IN)     Unit number.
 *   scache_position     (IN/OUT) Scache_position.
 *
 * Return Value:
 *   BCM_E_XXX
 */
int
_bcm_esw_stat_combine_port_bitmap_sync(int unit,
        uint8 **scache_position)
{
    uint32 *scache_ptr = NULL;
    uint32 max_grp_cnt = 0, idx = 0;

    max_grp_cnt = (1 << ing_pkt_attr_cmprsd_bits_g[unit].ing_port) - 1;
    scache_ptr = (uint32 *)*scache_position;
    if (soc_feature(unit,
                soc_feature_flex_stat_port_group_support)) {
        sal_memcpy(scache_ptr,
                stat_port_grp[unit].port_grp_id_bmap.pbits,
                sizeof(pbmp_t));
        scache_ptr += sizeof(pbmp_t)/sizeof(uint32);
        for (idx = 0; idx < max_grp_cnt; idx++) {
            sal_memcpy(scache_ptr,
                    stat_port_grp[unit].port_grp_bmap[idx].pbits,
                    sizeof(pbmp_t));
            scache_ptr += sizeof(pbmp_t)/sizeof(uint32);
        }
    } else {
        sal_memset(scache_ptr, 0,
                (max_grp_cnt + 1)*sizeof(pbmp_t));
        scache_ptr += (max_grp_cnt + 1)*(sizeof(pbmp_t)/sizeof(uint32));
    }
    *scache_position = (uint8 *)scache_ptr;
    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_esw_stat_combine_port_bitmap_recover
 * Description:
 *      Recover bitmap for group identifiers for combining ports.
 *
 * Parameters:
 *   unit                (IN)     Unit number.
 *   scache_position     (IN/OUT) Scache_position.
 *
 * Return Value:
 *   BCM_E_XXX
 */
int
_bcm_esw_stat_combine_port_bitmap_recover(int unit,
        uint8 **scache_position)
{
    uint32 *scache_ptr = NULL;
    uint32 max_grp_cnt = 0, idx = 0;

    max_grp_cnt = (1 << ing_pkt_attr_cmprsd_bits_g[unit].ing_port) - 1;

    scache_ptr = (uint32 *)*scache_position;
    if (soc_feature(unit,
                soc_feature_flex_stat_port_group_support)) {
        sal_memcpy(stat_port_grp[unit].port_grp_id_bmap.pbits,
                scache_ptr,
                sizeof(pbmp_t));
        scache_ptr += sizeof(pbmp_t)/sizeof(uint32);
        for (idx = 0; idx < max_grp_cnt; idx++) {
            sal_memcpy(stat_port_grp[unit].port_grp_bmap[idx].pbits,
                    scache_ptr,
                    sizeof(pbmp_t));
            scache_ptr += sizeof(pbmp_t)/sizeof(uint32);
        }
    } else {
        scache_ptr += (max_grp_cnt + 1)*(sizeof(pbmp_t)/sizeof(uint32));
    }
    *scache_position = (uint8 *)scache_ptr;
    return BCM_E_NONE;
}

#endif

/* Associate an accounting object to customized group mode */
static 
int _bcm_esw_stat_custom_group_associate_object(
    int               unit,
    uint32            mode_id,
    bcm_stat_object_t object,
    uint32            *stat_counter_id,
    uint32            *num_entries,
    uint32            pool_id,
    uint32            base_idx,
    bcm_stat_custom_counter_info_t *counter_info)
{
    bcm_stat_flex_direction_t    direction = bcmStatFlexDirectionIngress;
    uint32                       mode=0;
    uint32                       base_index=0;
    uint32                       pool_number=0;
    bcm_error_t                  rv=BCM_E_NONE;
    bcm_stat_group_mode_t        group_mode= bcmStatGroupModeSingle;
    bcm_stat_flex_ingress_mode_t *flex_ingress_mode=NULL;
    bcm_stat_flex_egress_mode_t  *flex_egress_mode=NULL;
    uint32                       total_counters=0;
    soc_mem_t                    ingress_table;
    bcm_stat_flex_custom_ingress_mode_t cmode;
#ifdef BCM_TOMAHAWK_SUPPORT
    int                          pipe_num = 0;
    uint32                       fg_id;
#endif
    soc_mem_t                    mem_tab;
#if defined(BCM_TRIDENT3_SUPPORT) || defined(BCM_TOMAHAWK3_SUPPORT)
    bcm_stat_flex_custom_egress_mode_t egr_cmode;
#endif
#if defined(BCM_CHANNELIZED_SWITCHING_SUPPORT)
    int subport_only_all_value_group = 0;
#endif
    group_mode = bcmStatGroupModeFlex1 + mode;

    /* 1. Deciding direction */
    BCM_IF_ERROR_RETURN(_bcm_esw_stat_validate_object(unit,object,&direction));

    sal_memset(&cmode, 0, sizeof(bcm_stat_flex_custom_ingress_mode_t));

    if ( BCM_STAT_GROUP_MODE_ID_OAM_SUFFIX ==
         (mode_id & BCM_STAT_GROUP_MODE_ID_OAM_MASK)) {
        mode = mode_id & ~(BCM_STAT_GROUP_MODE_ID_OAM_MASK);
    } else if (mode_id >= BCM_CUSTOM_INGRESS_MODE_START
#if defined(BCM_TRIDENT3_SUPPORT) || defined(BCM_TOMAHAWK3_SUPPORT)
       && (mode_id < BCM_CUSTOM_EGRESS_MODE_START)
#endif
    ) {
        rv = _bcm_esw_stat_flex_get_custom_ingress_mode_info(unit, mode_id, &cmode);
        BCM_IF_ERROR_RETURN(rv);
        mode = cmode.offset_mode;
    }
#if defined(BCM_TRIDENT3_SUPPORT) || defined(BCM_TOMAHAWK3_SUPPORT)
    else if( mode_id >= BCM_CUSTOM_EGRESS_MODE_START ) {
        sal_memset(&egr_cmode, 0, sizeof(bcm_stat_flex_custom_egress_mode_t));
        _bcm_esw_stat_flex_get_custom_egress_mode_info(unit, mode_id, &egr_cmode);
        mode = egr_cmode.offset_mode;
    }
#endif
    else {
        if(direction == bcmStatFlexDirectionIngress) {
            mode = mode_id;
        } else {
            mode = mode_id - BCM_STAT_FLEX_COUNTER_MAX_MODE;
        }
    }

    if (direction == bcmStatFlexDirectionIngress) {
        flex_ingress_mode = sal_alloc(sizeof(bcm_stat_flex_ingress_mode_t),
                                      "flex_ingress_mod");
        if (flex_ingress_mode == NULL) {
            return BCM_E_MEMORY;
        }

        sal_memset(flex_ingress_mode, 0, sizeof(bcm_stat_flex_ingress_mode_t));
        
        rv= _bcm_esw_stat_flex_get_ingress_mode_info(
                 unit,mode,flex_ingress_mode);
        if (BCM_SUCCESS(rv)) {
            total_counters = flex_ingress_mode->total_counters;     
        }
#if defined(BCM_CHANNELIZED_SWITCHING_SUPPORT)
        if (!(_bcm_esw_stat_attr_subport_only(unit, flex_ingress_mode->attr_selectors,
            flex_ingress_mode->num_selectors))) {
            subport_only_all_value_group = 1;
        }
#endif
        sal_free(flex_ingress_mode);
        BCM_IF_ERROR_RETURN(rv);
     } else {
        flex_egress_mode = sal_alloc(sizeof(bcm_stat_flex_egress_mode_t),
                                      "flex_egress_mod");
        if (flex_egress_mode == NULL) {
            return BCM_E_MEMORY;
        }
        
        sal_memset(flex_egress_mode, 0, sizeof(bcm_stat_flex_egress_mode_t));

        rv= _bcm_esw_stat_flex_get_egress_mode_info(
                 unit,mode,flex_egress_mode);
        if (BCM_SUCCESS(rv)) {
            total_counters = flex_egress_mode->total_counters;     
        }
#if defined(BCM_CHANNELIZED_SWITCHING_SUPPORT)
        if (!(_bcm_esw_stat_attr_subport_only(unit, flex_egress_mode->attr_selectors,
            flex_egress_mode->num_selectors))) {
            subport_only_all_value_group = 1;
        }
#endif
        sal_free(flex_egress_mode);
        BCM_IF_ERROR_RETURN(rv);
     }   

    if (soc_feature(unit, soc_feature_flex_stat_compaction_support)) {
        /* User configured pool and base index */
        pool_number = pool_id;
        base_index  = base_idx;
    }
    BCM_IF_ERROR_RETURN(_bcm_esw_stat_flex_set_group_mode(
                        unit,direction, mode,group_mode));
    switch((int32)object) {
    /* Ingress Side */
    case bcmStatObjectIngPort:
#if defined (BCM_TRIDENT3_SUPPORT)
         if (SOC_IS_TRIDENT3X(unit)){
             mem_tab = LPORT_TABm;
         } else
#endif
         {
             mem_tab = PORT_TABm;
         }
         rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                   unit, mem_tab, FIRST_LKUP, object,mode_id,
                   &base_index,&pool_number);
         break;
    case bcmStatObjectIngVlan:
         rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                   unit, VLAN_TABm, FIRST_LKUP, object,mode_id,
                   &base_index,&pool_number);
         break;
    case bcmStatObjectIngVlanXlate:
 #if defined (BCM_TRIDENT3_SUPPORT)
         if (SOC_IS_TRIDENT3X(unit)){
            mem_tab = VLAN_XLATE_1_DOUBLEm;
         } else
 #endif
         {
             mem_tab = VLAN_XLATEm;
         }
         rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                   unit, mem_tab, FIRST_LKUP, object,mode_id,
                   &base_index,&pool_number);
         break;
    case bcmStatObjectIngVlanXlateSecondLookup:
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
         if (soc_feature(unit,soc_feature_ing_vlan_xlate_second_lookup)) {
#if defined (BCM_TRIDENT3_SUPPORT)
             if (SOC_IS_TRIDENT3X(unit)){
                 mem_tab = VLAN_XLATE_1_DOUBLEm;
             } else
#endif
             {
                 mem_tab = VLAN_XLATEm;
             }
             rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                     unit, mem_tab, SECOND_LKUP, object,mode_id,
                     &base_index,&pool_number);
         } else
#endif
         {
             rv = BCM_E_PARAM;
         }
         break;
    case bcmStatObjectIngVfi:
         rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                   unit, VFIm, FIRST_LKUP, object,mode_id,
                   &base_index,&pool_number);
         break;
    case bcmStatObjectIngL3Intf:
         rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                   unit, L3_IIFm, FIRST_LKUP, object,mode_id,
                   &base_index,&pool_number);
         break;
    case bcmStatObjectIngVrf:
#if defined (BCM_TRIDENT3_SUPPORT)
         if (SOC_IS_TRIDENT3X(unit)){
             mem_tab = VRF_ATTRS_2m;
         } else
#endif
         {
             mem_tab = VRFm;
         }
         rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                   unit, mem_tab, FIRST_LKUP, object,mode_id,
                   &base_index,&pool_number);
         break;
    case bcmStatObjectIngPolicy:
         ingress_table = VFP_POLICY_TABLEm;
#ifdef BCM_TOMAHAWK_SUPPORT
         if (soc_feature(unit,soc_feature_stat_multi_pipe_support)) {
             _field_counter_pool_bmp_t pool_bmp;
             if ((mode_id < BCM_STAT_FLEX_CUSTOM_INGRESS_COUNTER_MAX_MODE) &&
                (mode_id >= BCM_CUSTOM_INGRESS_MODE_START)) {
                 fg_id = cmode.hint.value;
                 rv = _bcm_field_group_flex_ctr_info_get(unit, fg_id, &pipe_num, &pool_bmp);
                 if (pipe_num >= 0) {
                    _bcm_esw_get_ingress_vfp_table_from_pipe(pipe_num, &ingress_table);
                    if (BCM_FAILURE(rv)) {
                        LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                                  (BSL_META_U(unit,
                                    "cannot get pipe info %d.\n"), pipe_num));
                    }
                 }

                 for (pool_number = 0; pool_number < BCM_STAT_TH_FLEX_COUNTER_MAX_POOL; pool_number++) {
                   if (!_FP_COUNTER_POOL_BMP_TEST( pool_bmp, pool_number)) {
                       if (pool_number >= BCM_STAT_TH_FLEX_COUNTER_MAX_POOL - 1) {
                           pool_number = 0xff;
                       }
                       else  {
                           continue;
                       }
                   }

                   rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                             unit, ingress_table, FIRST_LKUP, object, mode_id,
                             &base_index, &pool_number);
                   if (rv != BCM_E_RESOURCE) {
                       cmode.AllocPool = pool_number;
                       _bcm_esw_stat_flex_update_custom_ingress_mode_info(unit, mode_id, &cmode);
                       _bcm_field_group_flex_ctr_pool_bmp_update(unit, fg_id, pool_number);
                       break;
                   }
                 }
             }
          } else
#endif
          {
                 if (!soc_feature(unit, soc_feature_flex_stat_compaction_support)) {
                    pool_number = 0xff;
                 }
                 rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                           unit, VFP_POLICY_TABLEm, FIRST_LKUP, object, mode_id,
                           &base_index, &pool_number);
          }
         break;
    case bcmStatObjectIngNiv:
    case bcmStatObjectIngMplsVcLabel:
    case bcmStatObjectIngGport:
         rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                   unit, SOURCE_VPm, FIRST_LKUP, object,mode_id,
                   &base_index,&pool_number);
         break;
    case bcmStatObjectIngMplsSwitchLabel:
         rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                   unit, MPLS_ENTRYm, FIRST_LKUP, object,mode_id,
                   &base_index,&pool_number);
         break;
    case bcmStatObjectIngMplsSwitchSecondLabel:
#if defined(BCM_APACHE_SUPPORT)
         if (soc_feature(unit, soc_feature_mpls_entry_second_label_lookup)) {
             rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                     unit, MPLS_ENTRYm, SECOND_LKUP, object,mode_id,
                     &base_index,&pool_number);
         } else
#endif
         {
             rv = BCM_E_PARAM;
         }
         break;
    case bcmStatObjectIngMplsFrrLabel:
         rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                   unit, L3_TUNNELm, FIRST_LKUP, object,mode_id,
                   &base_index,&pool_number);
         break;
    case bcmStatObjectIngL3Host:
         /* To Be Completed..L3_ENTRY_2/4,EXT_IPV4/6_128_UCAST_WIDE */
         rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                   unit, EXT_IPV4_UCAST_WIDEm, FIRST_LKUP, object,mode_id,
                   &base_index,&pool_number);
         break;
    case bcmStatObjectIngTrill:
         rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                   unit, MPLS_ENTRY_EXTDm, FIRST_LKUP, object,mode_id,
                   &base_index,&pool_number);
         break;
    case bcmStatObjectIngMimLookupId:
         rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                   unit, MPLS_ENTRY_EXTDm, FIRST_LKUP, object,mode_id,
                   &base_index,&pool_number);
         break;
    case bcmStatObjectIngL2Gre:
         /* To Be Completed..SOURCE_VPm, VLAN_XLATE_1m L2GRE_DIP view */
 #if defined (BCM_TRIDENT3_SUPPORT)
         if (SOC_IS_TRIDENT3X(unit)){
             mem_tab = VLAN_XLATE_1_DOUBLEm;
         } else
 #endif
         {
             mem_tab = VLAN_XLATEm;
         }
         rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                   unit, mem_tab, FIRST_LKUP, object,mode_id,
                   &base_index,&pool_number);
         break;
    case bcmStatObjectIngEXTPolicy:
         /* To Be Completed..*/
         rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                   unit, VFP_POLICY_TABLEm, FIRST_LKUP, object,mode_id,
                   &base_index,&pool_number);
         break;
    case bcmStatObjectIngVxlan:
         rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                   unit, SOURCE_VPm, FIRST_LKUP, object,mode_id,
                   &base_index,&pool_number);
         break;
    case bcmStatObjectIngVsan:
         rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                   unit, ING_VSANm, FIRST_LKUP, object,mode_id,
                   &base_index,&pool_number);
         break;
    case bcmStatObjectIngFcoe:
 #if defined (BCM_TRIDENT3_SUPPORT)
         if (SOC_IS_TRIDENT3X(unit)){
             mem_tab = L3_ENTRY_DOUBLEm;
         } else
 #endif
         {
             mem_tab = L3_ENTRY_IPV4_MULTICASTm;
         }
         rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                   unit, mem_tab, FIRST_LKUP, object,mode_id,
                   &base_index,&pool_number);
         break;
    case bcmStatObjectIngL3Route:
         rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                   unit, L3_DEFIPm, FIRST_LKUP, object,mode_id,
                   &base_index,&pool_number);
         break;
    case bcmStatObjectIngIpmc:
 #if defined (BCM_TRIDENT3_SUPPORT)
         if (SOC_IS_TRIDENT3X(unit)){
             mem_tab = L3_ENTRY_DOUBLEm;
         } else
 #endif
         {
             mem_tab = L3_ENTRY_IPV4_MULTICASTm;
         }
         rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                   unit, mem_tab, FIRST_LKUP, object,mode_id,
                   &base_index,&pool_number);
         break; 
    case bcmStatObjectIngVxlanDip:
 #if defined (BCM_TRIDENT3_SUPPORT)
         if (SOC_IS_TRIDENT3X(unit)){
             mem_tab = VLAN_XLATE_1_DOUBLEm;
         } else
 #endif
         {
             mem_tab = VLAN_XLATEm;
         }
         rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                   unit, mem_tab, FIRST_LKUP, object, mode_id,
                   &base_index, &pool_number);
         break;
    case bcmStatObjectIngFieldStageIngress:
          /* IFP can potentially request for counter allocation from
           * a specific pool. Hence, check stat_counter_id to determine
           * the pool number from which to allocate counters.
           */
         
         ingress_table = IFP_POLICY_TABLEm;
#ifdef BCM_TOMAHAWK_SUPPORT
         if (soc_feature(unit,soc_feature_stat_multi_pipe_support)) {
             _field_counter_pool_bmp_t pool_bmp;
             if ((mode_id < BCM_STAT_FLEX_CUSTOM_INGRESS_COUNTER_MAX_MODE) &&
                (mode_id >= BCM_CUSTOM_INGRESS_MODE_START)) {
                 fg_id = cmode.hint.value;
                 rv = _bcm_field_group_flex_ctr_info_get(unit, fg_id, &pipe_num, &pool_bmp);
                 if (pipe_num >= 0) {
                    _bcm_esw_get_ingress_ifp_table_from_pipe(pipe_num, &ingress_table);
                    if (BCM_FAILURE(rv)) {
                        LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                                  (BSL_META_U(unit,
                                    "cannot get pipe info %d.\n"), pipe_num));
                    }
                 }

                 for (pool_number = 0; pool_number <= BCM_STAT_TH_FLEX_COUNTER_MAX_POOL; pool_number++) {
                   if (!_FP_COUNTER_POOL_BMP_TEST( pool_bmp, pool_number)) {
                       if (pool_number <= BCM_STAT_TH_FLEX_COUNTER_MAX_POOL - 1) {
                           continue;
                       }
                   }
                   if (pool_number >= BCM_STAT_TH_FLEX_COUNTER_MAX_POOL) {
                       pool_number = 0xff;
                   }

                   rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                             unit, ingress_table, FIRST_LKUP, object, mode_id,
                             &base_index, &pool_number);
                   if (rv != BCM_E_RESOURCE) {
                       cmode.AllocPool = pool_number;
                       _bcm_esw_stat_flex_update_custom_ingress_mode_info(unit, mode_id, &cmode);
                       _bcm_field_group_flex_ctr_pool_bmp_update(unit, fg_id, pool_number);
                       break;
                   }
                 }

                 if ((cmode.hint.type == bcmStatGroupAllocHintIngressFieldGroup) &&
                     (cmode.attr_selectors[0].attr == bcmStatGroupModeAttrFieldIngressColor)) {
                     /* Color counters in legacy mode, shared hw mode in selector setup.
                      * Counters count for different custom modes can be different.
                      * Should get correct counters count from flex_custom_ingress_modes.
                      */
                     total_counters = cmode.total_counters;
                 }
             }
          } else
#endif
          {
#ifdef BCM_TRIDENT2PLUS_SUPPORT
                 if ((SOC_IS_TRIDENT2PLUS(unit) || SOC_IS_TITAN2PLUS(unit))) {
                     ingress_table = FP_POLICY_TABLEm;
                 }
#endif
                 pool_number = 0xff;
                 rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                           unit, ingress_table, FIRST_LKUP, object, mode_id,
                           &base_index, &pool_number);
          }
          break;
    case bcmStatObjectIngExactMatch:
          /* EM can potentially request for counter allocation from
           * a specific pool. Hence, check stat_counter_id to determine
           * the pool number from which to allocate counters.
           */
         ingress_table = EXACT_MATCH_2m;
         rv = BCM_E_PARAM;
#ifdef BCM_TOMAHAWK_SUPPORT
         if (soc_feature(unit,soc_feature_stat_multi_pipe_support)) {
             _field_counter_pool_bmp_t pool_bmp;
             if ((mode_id < BCM_STAT_FLEX_CUSTOM_INGRESS_COUNTER_MAX_MODE) &&
                (mode_id >= BCM_CUSTOM_INGRESS_MODE_START)) {
                 fg_id = cmode.hint.value;
                 rv = _bcm_field_group_flex_ctr_info_get(unit, fg_id, &pipe_num, &pool_bmp);
                 if (BCM_FAILURE(rv)) {
                     return rv;
                 }
                    
                 if (pipe_num >= 0) {
                    _bcm_esw_get_ingress_em_table_from_pipe(pipe_num, &ingress_table);
                    if (BCM_FAILURE(rv)) {
                        LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                                  (BSL_META_U(unit,
                                    "cannot get pipe info %d.\n"), pipe_num));
                    }
                 }

                 for (pool_number = 0; pool_number < BCM_STAT_TH_FLEX_COUNTER_MAX_POOL; pool_number++) {
                   if (!_FP_COUNTER_POOL_BMP_TEST( pool_bmp, pool_number)) {
                       if (pool_number >= BCM_STAT_TH_FLEX_COUNTER_MAX_POOL - 1) {
                           pool_number = 0xff;
                       }
                       else  {
                           continue;
                       }
                   }

                   rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                             unit, ingress_table, FIRST_LKUP, object, mode_id,
                             &base_index, &pool_number);
                   if (rv != BCM_E_RESOURCE) {
                       cmode.AllocPool = pool_number;
                       _bcm_esw_stat_flex_update_custom_ingress_mode_info(unit, mode_id, &cmode);
                       _bcm_field_group_flex_ctr_pool_bmp_update(unit, fg_id, pool_number);
                       break;
                   }
                 }
             }
          }
#endif
          
          break;
    case bcmIntStatObjectIngAgm:
         rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                   unit, AGM_MONITOR_TABLEm, FIRST_LKUP, object, mode,
                   &base_index, &pool_number);
         break;
    case bcmIntStatObjectIngAgmSecondLookup:
         rv = _bcm_esw_stat_flex_create_ingress_table_counters(
                   unit, AGM_MONITOR_TABLEm, SECOND_LKUP, object, mode,
                   &base_index, &pool_number);
         break;
    /* Egress Side */
    case bcmStatObjectEgrPort:
 #if defined (BCM_TRIDENT3_SUPPORT)
         if (SOC_IS_TRIDENT3X(unit)){
             mem_tab = EGR_LPORT_PROFILEm;
         } else
 #endif
         {
             mem_tab = EGR_PORTm;
         }
         rv = _bcm_esw_stat_flex_create_egress_table_counters(
                   unit, mem_tab, FIRST_LKUP, object,mode,
                   &base_index,&pool_number);
         break;
    case bcmStatObjectEgrVlan:
         rv = _bcm_esw_stat_flex_create_egress_table_counters(
                   unit, EGR_VLANm, FIRST_LKUP, object,mode,
                   &base_index,&pool_number);
         break;
    case bcmStatObjectEgrVlanXlate:
 #if defined (BCM_TRIDENT3_SUPPORT)
         if (SOC_IS_TRIDENT3X(unit)){
             mem_tab = EGR_VLAN_XLATE_1_DOUBLEm;
         } else
 #endif
         {
             mem_tab = EGR_VLAN_XLATEm;
         }
         rv = _bcm_esw_stat_flex_create_egress_table_counters(
                   unit, mem_tab, FIRST_LKUP, object,mode,
                   &base_index,&pool_number);
         break;
    case bcmStatObjectEgrVlanXlateSecondLookup:
#if defined(BCM_APACHE_SUPPORT) || defined(BCM_TRIDENT3_SUPPORT)
         if (soc_feature(unit, soc_feature_egr_vlan_xlate_second_lookup)) {
 #if defined(BCM_TRIDENT3_SUPPORT)
             if (SOC_IS_TRIDENT3X(unit)){
                 mem_tab = EGR_VLAN_XLATE_1_DOUBLEm;
             } else
 #endif
             {
                 mem_tab = EGR_VLAN_XLATEm;
             }
             rv = _bcm_esw_stat_flex_create_egress_table_counters(
                     unit, mem_tab, SECOND_LKUP, object,mode,
                     &base_index,&pool_number);
         } else
#endif
         {
             rv = BCM_E_PARAM;
         }
         break;
    case bcmStatObjectEgrVfi:
         rv = _bcm_esw_stat_flex_create_egress_table_counters(
                   unit, EGR_VFIm, FIRST_LKUP, object,mode,
                   &base_index,&pool_number);
         break;
    case bcmStatObjectEgrNiv:
    case bcmStatObjectEgrL3Intf:
         rv = _bcm_esw_stat_flex_create_egress_table_counters(
                   unit, EGR_L3_NEXT_HOPm, FIRST_LKUP, object,mode,
                   &base_index,&pool_number);
         break;
    case bcmStatObjectEgrWlan:
         rv = _bcm_esw_stat_flex_create_egress_table_counters(
                   unit, EGR_L3_NEXT_HOPm, FIRST_LKUP, object,mode,
                   &base_index,&pool_number);
         break;
    case bcmStatObjectEgrMim:
         rv = _bcm_esw_stat_flex_create_egress_table_counters(
                   unit, EGR_L3_NEXT_HOPm, FIRST_LKUP, object,mode,
                   &base_index,&pool_number);
         break;
    case bcmStatObjectEgrMimLookupId:
 #if defined (BCM_TRIDENT3_SUPPORT)
         if (SOC_IS_TRIDENT3X(unit)){
             mem_tab = EGR_VLAN_XLATE_1_DOUBLEm;
         } else
 #endif
         {
             mem_tab = EGR_VLAN_XLATEm;
         }
         rv = _bcm_esw_stat_flex_create_egress_table_counters(
                   unit, mem_tab, FIRST_LKUP, object,mode,
                   &base_index,&pool_number);
         break;
    case bcmStatObjectEgrL2Gre:
 #if defined (BCM_TRIDENT3_SUPPORT)
         if (SOC_IS_TRIDENT3X(unit)){
             mem_tab = EGR_DVP_ATTRIBUTEm;
         } else
 #endif
         {
             mem_tab = EGR_DVP_ATTRIBUTE_1m;
         }
         rv = _bcm_esw_stat_flex_create_egress_table_counters(
                   unit, mem_tab, FIRST_LKUP, object,mode,
                   &base_index,&pool_number);
         break;
    case bcmStatObjectEgrVxlan:
 #if defined (BCM_TRIDENT3_SUPPORT)
         if (SOC_IS_TRIDENT3X(unit)){
             mem_tab = EGR_DVP_ATTRIBUTEm;
         } else
 #endif
         {
             mem_tab = EGR_DVP_ATTRIBUTE_1m;
         }
         rv = _bcm_esw_stat_flex_create_egress_table_counters(
                   unit, mem_tab, FIRST_LKUP, object,mode,
                   &base_index, &pool_number);
         break;
    case bcmStatObjectEgrL3Nat:
         rv = _bcm_esw_stat_flex_create_egress_table_counters(
                   unit, EGR_NAT_PACKET_EDIT_INFOm, FIRST_LKUP, object,mode,
                   &base_index, &pool_number);
         break;
    case bcmStatObjectEgrFieldStageEgress:
          mem_tab = EFP_POLICY_TABLEm;
          if (-1 != *stat_counter_id
            && (!(SOC_IS_TD2P_TT2P(unit) || SOC_IS_APACHE(unit)))) {
             uint32 l_pool = 0, l_mode, l_baseidx;
             bcm_stat_object_t l_object;
             bcm_stat_group_mode_t l_group;

             _bcm_esw_stat_get_counter_id_info(unit, *stat_counter_id,
                                               &l_group, &l_object,
                                               &l_mode, &l_pool,
                                               &l_baseidx);
             if (l_pool < SOC_INFO(unit).num_flex_egress_pools) {
                 pool_number = l_pool;
             } else {
                 /* Invalid pool number specified */
                 return BCM_E_PARAM;
             }
         } else {
             /* Set pool_number to -1 to indicate that counters
              * can be allocated from any available pool
              */
             pool_number = -1;
         }
#ifdef BCM_TRIDENT3_SUPPORT
         if((soc_feature(unit,soc_feature_stat_egr_multi_pipe_support)) &&
            (!_bcm_esw_get_fp_mode_global(unit, bcmFieldQualifyStageEgress))) {
             _field_counter_pool_bmp_t pool_bmp;
             if ((mode_id < BCM_STAT_FLEX_CUSTOM_EGRESS_COUNTER_MAX_MODE) &&
                     (mode_id >= BCM_CUSTOM_EGRESS_MODE_START)) {
                 fg_id = egr_cmode.hint.value;
                 rv = _bcm_field_group_flex_ctr_info_get(unit, fg_id,
                     &pipe_num, &pool_bmp);
                 if (BCM_FAILURE(rv)) {
                     return rv;
                 }

                 if (pipe_num >= 0) {
                     _bcm_esw_get_egr_fp_table_from_pipe(pipe_num, &mem_tab);
                     if (BCM_FAILURE(rv)) {
                         LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                             (BSL_META_U(unit,
                                 "cannot get pipe info %d.\n"), pipe_num));
                         }
                 }
                 for (pool_number = 0; pool_number < BCM_STAT_TD3_FLEX_COUNTER_MAX_EGR_POOL; pool_number++) {
                   if (!_FP_COUNTER_POOL_BMP_TEST( pool_bmp, pool_number)) {
                       if (pool_number >= BCM_STAT_TD3_FLEX_COUNTER_MAX_EGR_POOL - 1) {
                           pool_number = -1;
                       }
                       else  {
                           continue;
                       }
                   }
                   rv = _bcm_esw_stat_flex_create_egress_table_counters(
                               unit, mem_tab, FIRST_LKUP, object, mode_id,
                               &base_index, &pool_number);
                   if (rv != BCM_E_RESOURCE) {
                       egr_cmode.AllocPool = pool_number;
                       _bcm_esw_stat_flex_update_custom_egress_mode_info(unit,
                               mode_id, &egr_cmode);
                       _bcm_field_group_flex_ctr_pool_bmp_update(unit, fg_id,
                               pool_number);
                       break;
                   }
                 }
             }
         }else
#endif
         {
             rv = _bcm_esw_stat_flex_create_egress_table_counters(
                       unit, mem_tab, FIRST_LKUP, object,mode,
                       &base_index, &pool_number);
         }
        break;
    case bcmStatObjectEgrMplsTunnelLabel:
         rv = _bcm_esw_stat_flex_create_egress_table_counters(
                   unit, EGR_IP_TUNNEL_MPLSm, FIRST_LKUP, object,mode,
                   &base_index, &pool_number);
         break;
    case bcmStatObjectEgrMplsTunnelSecondLabel:
#if defined(BCM_APACHE_SUPPORT)
         if (soc_feature(unit, soc_feature_multi_tunnel_label_count)) {
             rv = _bcm_esw_stat_flex_create_egress_table_counters(
                     unit, EGR_IP_TUNNEL_MPLSm, SECOND_LKUP, object,mode,
                     &base_index, &pool_number);
         } else
#endif
         {
             rv = BCM_E_PARAM;
         }
         break;
    default:
         rv = BCM_E_PARAM;
         break;
    }
    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                  (BSL_META_U(unit,
                              "creation of counters failed..\n")));
    } else {
        /* For Egress, use the HW mode to get the stat counter id */
        if (direction != bcmStatFlexDirectionIngress) {
#if defined(BCM_TRIDENT3_SUPPORT) || defined(BCM_TOMAHAWK3_SUPPORT)
            if (mode_id < BCM_CUSTOM_EGRESS_MODE_START)
#endif
            {
                mode_id = mode;
            }
        }
        _bcm_esw_stat_get_counter_id(unit, group_mode,object, mode_id,
                                     pool_number,base_index,stat_counter_id);

        if (*stat_counter_id == 0) {
           return BCM_E_FAIL;
        }

#ifdef BCM_TOMAHAWK_SUPPORT
        if (pipe_num < 0) {
            /* For global mode field module returns pipe as -1 */
            pipe_num = 0;
        }

        if (((direction == bcmStatFlexDirectionIngress)
#if defined(BCM_TRIDENT3_SUPPORT)
            || (SOC_IS_TRIDENT3X(unit))
#endif
        ) &&
            soc_feature(unit, soc_feature_flex_counter_opaque_stat_id)) {
            stat_counter_map[unit][*stat_counter_id].pipe = pipe_num;
        }
#endif
        LOG_DEBUG(BSL_LS_BCM_FLEXCTR,
                  (BSL_META_U(unit,
                              "Create: mode:%d group_mode:%d pool:%d object:%d"
                               " base:%d\n stat_counter_id:%d\n"),
                   mode,group_mode,pool_number,object,base_index,
                   *stat_counter_id));
#if defined(BCM_TRIDENT2_SUPPORT)
        if (SOC_IS_TRIDENT2X(unit) &&
            soc_feature(unit, soc_feature_advanced_flex_counter)) {
            _flex_stat_mode_base_map[unit][direction]
                              [pool_number][mode][base_index] = 1;
        }
#endif
        *num_entries= total_counters ; 
        if (soc_feature(unit, soc_feature_flex_stat_compaction_support)) {
            if (counter_info != NULL) {
                if (direction != bcmStatFlexDirectionIngress) {
                    counter_info->ctr_tbl_mode_id =
                        mode + BCM_STAT_FLEX_COUNTER_MAX_MODE;
                } else {
                    counter_info->ctr_tbl_mode_id = mode;
                }
                counter_info->ctr_tbl_pool_id       = pool_number;
                counter_info->ctr_tbl_pool_base_idx = base_index;
                counter_info->num_counters          = total_counters;
                counter_info->stat_counter_id       = *stat_counter_id;
                counter_info->object                = object;
            }
        }
    }
#if defined(BCM_CHANNELIZED_SWITCHING_SUPPORT)
    if ((soc_feature(unit, soc_feature_channelized_switching)) &&
        (subport_only_all_value_group == 1)) {

       if (direction == bcmStatFlexDirectionIngress) {
            ing_port_map_info[unit][mode].pool = pool_number;
        }
        if (direction == bcmStatFlexDirectionEgress) {
            egr_port_map_info[unit][mode].pool = pool_number;
        }
    }
#endif

    return rv;
}

/* Associate an accounting object to customized group mode */
int _bcm_esw_stat_custom_group_create(
    int               unit,
    uint32            mode_id,
    bcm_stat_object_t object,
    uint32            *stat_counter_id,
    uint32            *num_entries)
{
    bcm_error_t rv = BCM_E_NONE;
#if defined(BCM_TOMAHAWK_SUPPORT)
    bcm_stat_flex_custom_ingress_mode_t cmode;
    _bcm_ifp_color_map_t    ifp_counter_color; 
    int i, ctr_idx = 0;
    for(i = 0; i< BCM_MAX_IFP_COLOR_COUNTERS; ++i) {
        ifp_counter_color.map[i] = 0;
    }

#endif
    rv = _bcm_esw_stat_custom_group_associate_object(
            unit, mode_id, object, stat_counter_id, num_entries,
            0,0,NULL);

    BCM_IF_ERROR_RETURN(rv);

    if ( BCM_STAT_GROUP_MODE_ID_OAM_SUFFIX ==
         (mode_id & BCM_STAT_GROUP_MODE_ID_OAM_MASK)) {
        return rv;
    }

    if ((object != bcmStatObjectIngFieldStageIngress) &&
        (object != bcmStatObjectIngFieldStageLookup) && 
        (object != bcmStatObjectIngExactMatch)) {
        return rv;
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    cmode.hint.type = 0;
    if (mode_id >= BCM_CUSTOM_INGRESS_MODE_START
#if defined(BCM_TRIDENT3_SUPPORT) || defined(BCM_TOMAHAWK3_SUPPORT)
        && (mode_id < BCM_CUSTOM_EGRESS_MODE_START)
#endif
    ) {
        _bcm_esw_stat_flex_get_custom_ingress_mode_info(unit, mode_id, &cmode);
    }

    if ((cmode.hint.type == bcmStatGroupAllocHintIngressFieldGroup) && cmode.attr_selectors &&
        (cmode.attr_selectors[0].attr != bcmStatGroupModeAttrPort)) {
       if ((cmode.attr_selectors[0].attr == bcmStatGroupModeAttrFieldIngressColor) &&
             (BCM_STAT_GROUP_MODE_ATTR_ALL_VALUES == cmode.attr_selectors[0].attr_value)) {
           ifp_counter_color.map[ctr_idx] = BCM_STAT_FLEX_COLOR_GREEN | BCM_STAT_FLEX_COLOR_YELLOW |
                                            BCM_STAT_FLEX_COLOR_RED;
       } else {
           for(i = 0; i < cmode.num_selectors; ++i) {
                if (cmode.attr_selectors && (cmode.attr_selectors[i].attr == bcmStatGroupModeAttrFieldIngressColor)) {
                   ctr_idx = cmode.attr_selectors[i].counter_offset;
                   ifp_counter_color.map[ctr_idx] |= (1 << cmode.attr_selectors[i].attr_value);

                }
           }
       }
       /*set ifp_color map*/
       rv = _bcm_esw_ifp_color_map_set(unit, *stat_counter_id, &ifp_counter_color);
    } 
#endif
    return rv;
}


bcm_error_t _bcm_esw_stat_group_mode_id_config_create(
    int unit,
    uint32 options,
    bcm_stat_group_mode_id_config_t *stat_config,
    uint32 num_selectors,
    bcm_stat_group_mode_attr_selector_t *attr_sel,
    uint32 *mode_id)
{
    bcm_error_t rv=BCM_E_NONE;
    int ing_mode = 0;
    bcm_stat_flex_ingress_mode_t *flex_ingress_mode = NULL;
    bcm_stat_flex_custom_ingress_mode_t custom_ing_mode;
    int nsel = 0;
    int share_hw_mode = 0;

    nsel = num_selectors;
    if ((stat_config->hint.type == bcmStatGroupAllocHintIngressFieldGroup) || 
        (stat_config->hint.type == bcmStatGroupAllocHintExactMatchFieldGroup)) {
        if (num_selectors && (attr_sel[0].attr == bcmStatGroupModeAttrFieldIngressColor)) {
           /* Color counters in legacy mode, doesnt require any flex-counter style selector setup */
           nsel = 0;
           share_hw_mode = 1;
        }
    } else if (stat_config->hint.type == 
               (bcm_stat_group_mode_hint_type_t)bcmIntStatGroupAllocHintIngressAgmGroup) {
        nsel = 0;
    }

    /* Check if the HW mode already exists */
    rv = _bcm_esw_stat_group_mode_id_check(unit, stat_config->flags, 
                                    stat_config->total_counters,
                                    nsel, attr_sel, share_hw_mode,
                                    mode_id);

    if (rv != BCM_E_EXISTS) {
        rv = _bcm_esw_stat_group_new_mode_id_create(unit, stat_config->flags, 
                                        stat_config->total_counters,
                                        nsel, attr_sel, 
                                        mode_id);
    }

    if (!BCM_SUCCESS(rv) && (rv != BCM_E_EXISTS)) {
        LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                  (BSL_META_U(unit,
                              "creation of mode failed..\n")));
        return rv;
    }

    custom_ing_mode.total_counters = stat_config->total_counters;

    if ((stat_config->hint.type == bcmStatGroupAllocHintIngressFieldGroup) ||
        (stat_config->hint.type == bcmStatGroupAllocHintVlanFieldGroup) ||
        (stat_config->hint.type == bcmStatGroupAllocHintExactMatchFieldGroup)) {

        for (ing_mode = BCM_CUSTOM_INGRESS_MODE_START; 
                      ing_mode < BCM_STAT_FLEX_CUSTOM_INGRESS_COUNTER_MAX_MODE; 
                                                                 ing_mode++) {
           if (_bcm_esw_stat_flex_get_custom_ingress_mode_info(unit, 
                        ing_mode, &custom_ing_mode) == BCM_E_NOT_FOUND) {
                sal_memset(&custom_ing_mode, 0, sizeof(bcm_stat_flex_custom_ingress_mode_t));
                custom_ing_mode.used = 1;  
                custom_ing_mode.hint.type = stat_config->hint.type;
                custom_ing_mode.hint.value = stat_config->hint.value;
                custom_ing_mode.AllocPool = -1;
                custom_ing_mode.offset_mode = *mode_id;
                custom_ing_mode.num_selectors = num_selectors;
                custom_ing_mode.total_counters = stat_config->total_counters;
                _bcm_esw_stat_flex_update_custom_ingress_mode_info(unit, ing_mode, &custom_ing_mode);
                rv = BCM_E_NONE;
                break;
           }
        }
        if (ing_mode == BCM_STAT_FLEX_CUSTOM_INGRESS_COUNTER_MAX_MODE) {
           /* destroy offset mode */
           _bcm_esw_stat_group_mode_id_destroy(unit, *mode_id);
           return BCM_E_MEMORY;
        }

        if ((stat_config->hint.type == bcmStatGroupAllocHintIngressFieldGroup) || 
            (stat_config->hint.type == bcmStatGroupAllocHintExactMatchFieldGroup)) {
            if ((num_selectors) && ((attr_sel[0].attr == bcmStatGroupModeAttrFieldIngressColor) ||
                (attr_sel[0].attr == bcmStatGroupModeAttrPort))) {
               /* Color counters in legacy mode, doesnt require any flex-counter style selector setup */
              _bcm_esw_stat_flex_set_group_mode(
                        unit,bcmStatFlexDirectionIngress, *mode_id,bcmStatGroupModeFlex1);
               custom_ing_mode.attr_selectors = sal_alloc(num_selectors * sizeof(bcm_stat_group_mode_attr_selector_t),"attr");
               if (custom_ing_mode.attr_selectors == NULL) {
                   LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                             (BSL_META_U(unit,
                                         "Failed to allocate memory for custom_ing_mode.attr_selectors ")));
                   return BCM_E_MEMORY;
               }
               sal_memcpy(custom_ing_mode.attr_selectors,
                          attr_sel,
                          num_selectors * sizeof(bcm_stat_group_mode_attr_selector_t));
            }
            custom_ing_mode.num_selectors = num_selectors;
            custom_ing_mode.total_counters = stat_config->total_counters;
            _bcm_esw_stat_flex_update_custom_ingress_mode_info(unit, ing_mode, &custom_ing_mode);

        } 

        flex_ingress_mode = sal_alloc(sizeof(bcm_stat_flex_ingress_mode_t),
                                  "flex_ingress_mod");

        if (flex_ingress_mode == NULL) {
            return BCM_E_MEMORY;
        }

        sal_memset(flex_ingress_mode, 0, sizeof(bcm_stat_flex_ingress_mode_t));
        if (_bcm_esw_stat_flex_get_ingress_mode_info(
                       unit,*mode_id,flex_ingress_mode) == BCM_E_NONE) {
        
          (void)_bcm_esw_stat_flex_update_ingress_flex_info(
                unit, *mode_id, stat_config->flags, nsel,
                attr_sel);
        }

        sal_free(flex_ingress_mode);

        *mode_id = ing_mode;

    }

#if defined(BCM_TRIDENT3_SUPPORT) || defined(BCM_TOMAHAWK3_SUPPORT)
    if (stat_config->hint.type == bcmStatGroupAllocHintEgressFieldGroup) {
        int egr_mode = 0;
        bcm_stat_flex_egress_mode_t *flex_egress_mode = NULL;
        bcm_stat_flex_custom_egress_mode_t custom_egr_mode;
        int off_mode = *mode_id - BCM_STAT_FLEX_COUNTER_MAX_MODE;

        for (egr_mode = BCM_CUSTOM_EGRESS_MODE_START;
                      egr_mode < BCM_STAT_FLEX_CUSTOM_EGRESS_COUNTER_MAX_MODE;
                                                                 egr_mode++) {
           if (_bcm_esw_stat_flex_get_custom_egress_mode_info(unit,
                        egr_mode, &custom_egr_mode) == BCM_E_NOT_FOUND) {
                sal_memset(&custom_egr_mode, 0,
                    sizeof(bcm_stat_flex_custom_egress_mode_t));
                custom_egr_mode.used = 1;
                custom_egr_mode.hint.type = stat_config->hint.type;
                custom_egr_mode.hint.value = stat_config->hint.value;
                custom_egr_mode.AllocPool = -1;
                custom_egr_mode.offset_mode = off_mode;
                custom_egr_mode.num_selectors = num_selectors;
                custom_egr_mode.total_counters = stat_config->total_counters;
                _bcm_esw_stat_flex_update_custom_egress_mode_info(unit,
                    egr_mode, &custom_egr_mode);
                rv = BCM_E_NONE;
                break;
           }
        }
        if (egr_mode == BCM_STAT_FLEX_CUSTOM_EGRESS_COUNTER_MAX_MODE) {
           _bcm_esw_stat_group_mode_id_destroy(unit, *mode_id);
           return BCM_E_MEMORY;
        }

        custom_egr_mode.num_selectors = num_selectors;
        custom_egr_mode.total_counters = stat_config->total_counters;
        _bcm_esw_stat_flex_update_custom_egress_mode_info(unit, egr_mode,
            &custom_egr_mode);

        flex_egress_mode = sal_alloc(sizeof(bcm_stat_flex_egress_mode_t),
                                  "flex_egress_mod");
        if (flex_egress_mode == NULL) {
            return BCM_E_MEMORY;
        }

        sal_memset(flex_egress_mode, 0, sizeof(bcm_stat_flex_egress_mode_t));

        if (_bcm_esw_stat_flex_get_egress_mode_info(
                       unit, off_mode, flex_egress_mode) == BCM_E_NONE) {
          (void)_bcm_esw_stat_flex_update_egress_flex_info(
                unit, off_mode, stat_config->flags, nsel,
                attr_sel);
        }

        sal_free(flex_egress_mode);

        *mode_id = egr_mode;
    }
#endif

    return rv;
}

bcm_error_t 
_bcm_esw_stat_group_mode_id_config_get(
    int unit,
    uint32 mode_id, 
    bcm_stat_group_mode_id_config_t *stat_config,
    uint32 num_selectors,
    bcm_stat_group_mode_attr_selector_t *attr_sel,
    uint32 *actual_num_selectors)
{
    bcm_error_t rv=BCM_E_CONFIG;
    bcm_stat_flex_custom_ingress_mode_t custom_ing_mode;
    int ing_mode = 0;

    if ((mode_id < BCM_STAT_FLEX_CUSTOM_INGRESS_COUNTER_MAX_MODE) &&
       (mode_id >= BCM_CUSTOM_INGRESS_MODE_START)) {
        rv = _bcm_esw_stat_flex_get_custom_ingress_mode_info(unit, mode_id, 
                                                          &custom_ing_mode);
        ing_mode = custom_ing_mode.offset_mode;
        if ((rv  == BCM_E_NONE) && custom_ing_mode.used != 0) {
            rv = _bcm_esw_stat_group_mode_id_get(unit, ing_mode, &stat_config->flags,
                                            &stat_config->total_counters,
                                            num_selectors,
                                            attr_sel, actual_num_selectors);
            stat_config->hint = custom_ing_mode.hint;
        } 
    }

#if defined(BCM_TRIDENT3_SUPPORT)
    if (SOC_IS_TRIDENT3X(unit)){
        bcm_stat_flex_custom_egress_mode_t custom_egr_mode;
        int egr_mode = 0;

        if ((mode_id < BCM_STAT_FLEX_CUSTOM_EGRESS_COUNTER_MAX_MODE) &&
            (mode_id >= BCM_CUSTOM_EGRESS_MODE_START)) {
            rv = _bcm_esw_stat_flex_get_custom_egress_mode_info(unit, mode_id,
                                            &custom_egr_mode);
            egr_mode = custom_egr_mode.offset_mode;
            egr_mode += BCM_STAT_FLEX_COUNTER_MAX_MODE;
            if ((rv  == BCM_E_NONE) && custom_egr_mode.used != 0) {
                rv = _bcm_esw_stat_group_mode_id_get(unit, egr_mode, &stat_config->flags,
                                            &stat_config->total_counters,
                                            num_selectors,
                                            attr_sel, actual_num_selectors);
                stat_config->hint = custom_egr_mode.hint;
            }
        }
    }
#endif

    return rv;
}

int _bcm_esw_stat_flex_compress_mode_id_compare(int unit,
        bcm_stat_flex_direction_t                 direction,
        bcm_stat_flex_mode_t                      *mode,
        bcm_stat_flex_attribute_t                 *flex_attribute)
{
    int total_counters,num_selectors;
    int rv = BCM_E_NONE;
    int attribute_set_is_same = TRUE;
    int index,counter,flags=0;
    bcm_stat_group_mode_attr_selector_t *old_attr_selectors=NULL;
    bcm_stat_flex_combine_attr_counter_t *old_combine_attr_counter = NULL;
    bcm_stat_flex_combine_attr_counter_t *new_combine_attr_counter = NULL;
    bcm_stat_flex_ingress_mode_t      *flex_ingress_mode=NULL;
    bcm_stat_flex_egress_mode_t       *flex_egress_mode=NULL;
    bcm_stat_flex_attribute_t old_flex_attributes = {0};

    if (direction == bcmStatFlexDirectionIngress &&
            flex_attribute != NULL) {
        flex_ingress_mode = sal_alloc(sizeof(bcm_stat_flex_ingress_mode_t),
                "flex_ingress_mode");
        if (flex_ingress_mode == NULL) {
            return BCM_E_MEMORY;
        }
        for (index =0 ; index < BCM_STAT_FLEX_COUNTER_MAX_MODE ; index++) {
            sal_memset(flex_ingress_mode,0,sizeof(bcm_stat_flex_ingress_mode_t));
            if (old_attr_selectors != NULL) {
                sal_free(old_attr_selectors);
                old_attr_selectors = NULL;
            }
            if (_bcm_esw_stat_flex_get_ingress_mode_info(
                        unit,
                        index,
                        flex_ingress_mode) == BCM_E_NONE) {

                total_counters =  flex_ingress_mode->total_counters;
                num_selectors  =  flex_ingress_mode->num_selectors;
                old_attr_selectors = flex_ingress_mode->attr_selectors;

                if (flex_ingress_mode->ing_attr.packet_attr_type !=
                        bcmStatFlexPacketAttrTypeCompressed) {
                    continue;
                }

                if (old_flex_attributes.combine_attr_counter != NULL) {
                    sal_free(old_flex_attributes.combine_attr_counter);
                    old_flex_attributes.combine_attr_counter = NULL;
                }
                old_flex_attributes.combine_attr_counter = 
                    sal_alloc(sizeof(bcm_stat_flex_combine_attr_counter_t) * 
                            total_counters, "combine_attr_counter");
                if (old_flex_attributes.combine_attr_counter == NULL) {
                    sal_free(flex_ingress_mode);
                    sal_free(old_attr_selectors);
                    return BCM_E_MEMORY;
                }
                sal_memset(old_flex_attributes.combine_attr_counter,
                        0,sizeof(bcm_stat_flex_combine_attr_counter_t) * total_counters); 
                rv = _bcm_esw_stat_group_mode_fillup_values(unit,
                        flags, total_counters, num_selectors, old_attr_selectors, &old_flex_attributes);

                /* Check counters set */
                if (flex_attribute->total_counters != 
                        old_flex_attributes.total_counters) {
                    continue;
                }

                old_combine_attr_counter = sal_alloc(
                        sizeof(bcm_stat_flex_combine_attr_counter_t),
                        "old_combine_attr_counter");
                if (old_combine_attr_counter == NULL) {
                    sal_free(flex_ingress_mode);
                    sal_free(old_attr_selectors);
                    sal_free(old_flex_attributes.combine_attr_counter);
                   return BCM_E_MEMORY;
                }
                new_combine_attr_counter =
                    sal_alloc(sizeof(bcm_stat_flex_combine_attr_counter_t), 
                            "new_combine_attr_counter");
                if (new_combine_attr_counter == NULL) {
                    sal_free(flex_ingress_mode);
                    sal_free(old_attr_selectors);
                    sal_free(old_combine_attr_counter);
                    sal_free(old_flex_attributes.combine_attr_counter);
                    return BCM_E_MEMORY;
                }
                for (counter=0; counter < flex_attribute->total_counters ; counter++) {
                    sal_memset(old_combine_attr_counter,
                            0,sizeof(bcm_stat_flex_combine_attr_counter_t)); 
                    sal_memset(new_combine_attr_counter,
                            0,sizeof(bcm_stat_flex_combine_attr_counter_t));
                    sal_memcpy(old_combine_attr_counter,
                            &old_flex_attributes.combine_attr_counter[counter],
                            sizeof(bcm_stat_flex_combine_attr_counter_t));
                    sal_memcpy(new_combine_attr_counter,
                            &flex_attribute->combine_attr_counter[counter],
                            sizeof(bcm_stat_flex_combine_attr_counter_t));
                    /* compare combine attribute set */
                    if (sal_memcmp(old_combine_attr_counter, new_combine_attr_counter,
                                sizeof(bcm_stat_flex_combine_attr_counter_t)) != 0) {
                        attribute_set_is_same  = FALSE;
                        break;
                    }
                }
                /* If attribute set are same */
                if (attribute_set_is_same == TRUE) {
                    rv = BCM_E_EXISTS;
                }
                if (old_combine_attr_counter != NULL) {
                    sal_free(old_combine_attr_counter);
                    old_combine_attr_counter = NULL;
                }
                if (new_combine_attr_counter != NULL) {
                    sal_free(new_combine_attr_counter);
                    new_combine_attr_counter = NULL;
                }
            }
        }
        if(flex_ingress_mode != NULL) {
            sal_free(flex_ingress_mode);
            flex_ingress_mode = NULL;
        }
        if (old_attr_selectors != NULL) {
            sal_free(old_attr_selectors);
            old_attr_selectors = NULL;
        }
        if (old_flex_attributes.combine_attr_counter != NULL) {
            sal_free(old_flex_attributes.combine_attr_counter);
            old_flex_attributes.combine_attr_counter = NULL;
        }
    }
    /* Egress direction */
    if (direction == bcmStatFlexDirectionEgress && 
            flex_attribute != NULL) {
        flex_egress_mode = sal_alloc(sizeof(bcm_stat_flex_egress_mode_t),
                "flex_egress_mode");
        if (flex_egress_mode == NULL) {
            return BCM_E_MEMORY;
        }
        for (index =0 ; index < BCM_STAT_FLEX_COUNTER_MAX_MODE ; index++) {
            sal_memset(flex_egress_mode,0,sizeof(bcm_stat_flex_egress_mode_t));
            if (old_attr_selectors != NULL) {
                sal_free(old_attr_selectors);
                old_attr_selectors = NULL;
            }
            if (_bcm_esw_stat_flex_get_egress_mode_info(
                        unit,
                        index,
                        flex_egress_mode) == BCM_E_NONE) {

                total_counters =  flex_egress_mode->total_counters;
                num_selectors  =  flex_egress_mode->num_selectors;
                old_attr_selectors = flex_egress_mode->attr_selectors;

                if (flex_egress_mode->egr_attr.packet_attr_type !=
                        bcmStatFlexPacketAttrTypeCompressed) {
                    continue;
                }

                if (old_flex_attributes.combine_attr_counter != NULL) {
                    sal_free(old_flex_attributes.combine_attr_counter);
                    old_flex_attributes.combine_attr_counter = NULL;
                }
                old_flex_attributes.combine_attr_counter = 
                    sal_alloc(sizeof(bcm_stat_flex_combine_attr_counter_t) *
                            total_counters, "combine_attr_counter");
                if (old_flex_attributes.combine_attr_counter == NULL) {
                    sal_free(flex_egress_mode);
                    sal_free(old_attr_selectors);
                    return BCM_E_MEMORY;
                }
                sal_memset(old_flex_attributes.combine_attr_counter,
                        0,sizeof(bcm_stat_flex_combine_attr_counter_t) * total_counters);
                rv = _bcm_esw_stat_group_mode_fillup_values(unit,
                        flags, total_counters, num_selectors, old_attr_selectors, &old_flex_attributes);

                /* Check counters set */
                if (flex_attribute->total_counters !=
                        old_flex_attributes.total_counters) {
                    continue;
                }

                old_combine_attr_counter = sal_alloc(
                        sizeof(bcm_stat_flex_combine_attr_counter_t),
                        "old_combine_attr_counter");

                if (old_combine_attr_counter == NULL) {
                    sal_free(flex_egress_mode);
                    sal_free(old_attr_selectors);
                    sal_free(old_flex_attributes.combine_attr_counter);
                    return BCM_E_MEMORY;
                }
                new_combine_attr_counter = 
                    sal_alloc(sizeof(bcm_stat_flex_combine_attr_counter_t),
                            "new_combine_attr_counter");

                if (new_combine_attr_counter == NULL) {
                    sal_free(flex_egress_mode);
                    sal_free(old_attr_selectors);
                    sal_free(old_combine_attr_counter);
                    sal_free(old_flex_attributes.combine_attr_counter);
                    return BCM_E_MEMORY;
                }
                for (counter=0; counter < flex_attribute->total_counters ; counter++) {
                    sal_memset(old_combine_attr_counter,
                            0,sizeof(bcm_stat_flex_combine_attr_counter_t));
                    sal_memset(new_combine_attr_counter,
                            0,sizeof(bcm_stat_flex_combine_attr_counter_t));
                    sal_memcpy(old_combine_attr_counter,
                            &old_flex_attributes.combine_attr_counter[counter],
                            sizeof(bcm_stat_flex_combine_attr_counter_t));
                    sal_memcpy(new_combine_attr_counter,
                            &flex_attribute->combine_attr_counter[counter],
                            sizeof(bcm_stat_flex_combine_attr_counter_t));
                    /* compare combine attribute set */
                    if (sal_memcmp(old_combine_attr_counter, new_combine_attr_counter,
                                sizeof(bcm_stat_flex_combine_attr_counter_t)) != 0) {
                        attribute_set_is_same  = FALSE;
                        break;
                    }
                }
                /* If attribute set are same */
                if (attribute_set_is_same == TRUE) {
                    rv = BCM_E_EXISTS;
                }
                if (old_combine_attr_counter != NULL) {
                    sal_free(old_combine_attr_counter);
                    old_combine_attr_counter = NULL;
                }
                if (new_combine_attr_counter != NULL) {
                    sal_free(new_combine_attr_counter);
                    new_combine_attr_counter = NULL;
                }
            }
        }
        if(flex_egress_mode != NULL) {
            sal_free(flex_egress_mode);
            flex_egress_mode = NULL;
        }
        if (old_attr_selectors != NULL) {
            sal_free(old_attr_selectors);
            old_attr_selectors = NULL;
        }
        if (old_flex_attributes.combine_attr_counter != NULL) {
            sal_free(old_flex_attributes.combine_attr_counter);
            old_flex_attributes.combine_attr_counter = NULL;
        }
    }
    return rv;
}

STATIC
int _bcm_stat_flex_compressed_tbl_dma_write(int unit,
        soc_mem_t tbl_mem, soc_field_t field,
        int alloc_size,uint8 *data_ptr)
{
    uint32 *dma_map_ptr= NULL;
    uint32 map_array_value = 0;
    int index =0;

    dma_map_ptr=soc_cm_salloc(unit,alloc_size, "dma_map_ptr");
    if (dma_map_ptr== NULL) {
        return BCM_E_MEMORY;
    }

    sal_memset(dma_map_ptr, 0,alloc_size);
    if (soc_mem_read_range(
                unit,
                tbl_mem,
                MEM_BLOCK_ANY,
                soc_mem_index_min(unit,tbl_mem),
                soc_mem_index_max(unit,tbl_mem),
                dma_map_ptr) != BCM_E_NONE){
        soc_cm_sfree(unit,dma_map_ptr);
        return BCM_E_INTERNAL;
    }

    for (index=0;
            index< soc_mem_index_count(unit,tbl_mem);
            index++) {
        map_array_value = data_ptr[index];
        soc_mem_field_set(
                unit,
                tbl_mem,
                &dma_map_ptr[index],
                field,
                &map_array_value);
    }

    if (soc_mem_write_range(
                unit,
                tbl_mem,
                MEM_BLOCK_ALL,
                soc_mem_index_min(unit,tbl_mem),
                soc_mem_index_max(unit,tbl_mem),
                dma_map_ptr) != BCM_E_NONE){
        soc_cm_sfree(unit,dma_map_ptr);
        return BCM_E_INTERNAL;
    }

    soc_cm_sfree(unit,dma_map_ptr);
    return BCM_E_NONE;
}

int _bcm_stat_flex_compressed_attr_tbl_write(int unit,
        bcm_stat_flex_direction_t direction, 
        bcm_stat_flex_ing_cmprsd_attr_selectors_t *cmprsd_attr_selectors,
        bcm_stat_flex_egr_cmprsd_attr_selectors_t *egr_cmprsd_attr_selectors)
{
    uint8 *ref_count_p = NULL;
    bcm_stat_flex_ing_pkt_attr_bits_t pkt_attr_bits={0};
    bcm_stat_flex_egr_pkt_attr_bits_t egr_pkt_attr_bits={0};
    _bcm_stat_flex_compressed_mode_attr_sel_map_t *cmprsd_attr_map = NULL;
    uint32  alloc_size=0;

    /* Update reference count per compression table to
     * avoid overwriting */
    /* Ingress direction */
    if (direction == bcmStatFlexDirectionIngress) {
        cmprsd_attr_map = global_stat_flex_compressed_attr_map[unit];
        if (cmprsd_attr_map == NULL || cmprsd_attr_selectors == NULL) {
            return BCM_E_MEMORY;
        }

        /* User configured values */
        pkt_attr_bits = cmprsd_attr_selectors->pkt_attr_bits;
        /* ING_FLEX_CTR_PRI_CNG_MAPm */
        if ((pkt_attr_bits.cng != 0) ||
                (pkt_attr_bits.ifp_cng)  ||
                (pkt_attr_bits.int_pri)) {
            /* Get refrence count of ING_FLEX_CTR_PRI_CNG_MAPm table */
            ref_count_p = &cmprsd_attr_map->ref_counts[ing_pkt_attr_pri_cng_map];
            /* If ref count is zero table is not in use hence allowed to write
             * only once for a set of packet attributes */
            if (*ref_count_p == 0) {
                alloc_size = soc_mem_index_count(unit,ING_FLEX_CTR_PRI_CNG_MAPm) *
                    sizeof(ing_flex_ctr_pri_cng_map_entry_t);
                if(_bcm_stat_flex_compressed_tbl_dma_write(unit,
                       ING_FLEX_CTR_PRI_CNG_MAPm,
                       PRI_CNG_FNf,
                       alloc_size,
                       cmprsd_attr_selectors->pri_cnf_attr_map) !=
                       BCM_E_NONE) {
                    return BCM_E_INTERNAL;
                }
                /* update global structure */
                cmprsd_attr_map->cng = 1;
                cmprsd_attr_map->ifp_cng = 1;
                cmprsd_attr_map->int_pri = 1;
            }
            (*ref_count_p)++;
        }

        /* ING_FLEX_CTR_PKT_PRI_MAPm */ 
        if ((pkt_attr_bits.vlan_format != 0) ||
                (pkt_attr_bits.outer_dot1p) ||
                (pkt_attr_bits.inner_dot1p)) {
            /* Get refrence count of ING_FLEX_CTR_PKT_PRI_MAPm table */
            ref_count_p = &cmprsd_attr_map->ref_counts[ing_pkt_attr_pkt_pri_map];
            /* If ref count is zero table is not in use hence allowed to write
             * only once for a set of packet attributes */
            if (*ref_count_p == 0) {
                /* Sanity Check */
                alloc_size = soc_mem_index_count(unit, ING_FLEX_CTR_PKT_PRI_MAPm) *
                    sizeof(ing_flex_ctr_pkt_pri_map_entry_t);
                if(_bcm_stat_flex_compressed_tbl_dma_write(unit,
                       ING_FLEX_CTR_PKT_PRI_MAPm,
                       PKT_PRI_FNf,
                       alloc_size,
                       cmprsd_attr_selectors->pkt_pri_attr_map) !=
                       BCM_E_NONE) {
                    return BCM_E_INTERNAL;
                }
                /* update global structure */
                cmprsd_attr_map->vlan_format = 1;
                cmprsd_attr_map->outer_dot1p = 1;
                cmprsd_attr_map->inner_dot1p = 1;
            }
            (*ref_count_p)++;
        }

        /* ING_FLEX_CTR_PORT_MAPm */
        if (pkt_attr_bits.ing_port != 0) {
            /* Get refrence count of ING_FLEX_CTR_PORT_MAPm table */
            ref_count_p = &cmprsd_attr_map->ref_counts[ing_pkt_attr_port_map];
            /* If ref count is zero table is not in use hence allowed to write
             * only once for a set of packet attributes */
            if (*ref_count_p == 0) {
                alloc_size = soc_mem_index_count(unit, ING_FLEX_CTR_PORT_MAPm) *
                    sizeof(ing_flex_ctr_port_map_entry_t);
                if(_bcm_stat_flex_compressed_tbl_dma_write(unit,
                       ING_FLEX_CTR_PORT_MAPm,
                       PORT_FNf,
                       alloc_size,
                       cmprsd_attr_selectors->port_attr_map) !=
                       BCM_E_NONE) {
                    return BCM_E_INTERNAL;
                }
                /* update global structure */
                cmprsd_attr_map->port= 1;
            }
            (*ref_count_p)++;
        }

        /* ING_FLEX_CTR_TOS_MAPm */
        if ((pkt_attr_bits.tos_dscp != 0) ||
                (pkt_attr_bits.tos_ecn != 0)) {
            /* Get refrence count of ING_FLEX_CTR_TOS_MAPm table */
            ref_count_p = &cmprsd_attr_map->ref_counts[ing_pkt_attr_tos_map];
            if (*ref_count_p == 0) {
                alloc_size = soc_mem_index_count(unit,ING_FLEX_CTR_TOS_MAPm) *
                    sizeof(ing_flex_ctr_tos_map_entry_t);
                if(_bcm_stat_flex_compressed_tbl_dma_write(unit,
                       ING_FLEX_CTR_TOS_MAPm,
                       TOS_FNf,
                       alloc_size,
                       cmprsd_attr_selectors->tos_attr_map) !=
                       BCM_E_NONE) {
                    return BCM_E_INTERNAL;
                }
                cmprsd_attr_map->tos_dscp = 1;
                cmprsd_attr_map->tos_ecn = 1;
            }
            (*ref_count_p)++;
        }

        /* ING_FLEX_CTR_PKT_RES_MAPm */
        if ((pkt_attr_bits.pkt_resolution != 0) ||
                (pkt_attr_bits.svp_type) ||
                (pkt_attr_bits.drop)) {
            /* Get refrence count of ING_FLEX_CTR_PKT_RES_MAPm table */
            ref_count_p = &cmprsd_attr_map->ref_counts[ing_pkt_attr_pkt_res_map];
            if (*ref_count_p == 0) {
                alloc_size = soc_mem_index_count(unit, ING_FLEX_CTR_PKT_RES_MAPm) *
                    sizeof(ing_flex_ctr_pkt_res_map_entry_t);
                if(_bcm_stat_flex_compressed_tbl_dma_write(unit,
                       ING_FLEX_CTR_PKT_RES_MAPm,
                       PKT_RES_FNf,
                       alloc_size,
                       cmprsd_attr_selectors->pkt_res_attr_map) !=
                       BCM_E_NONE) {
                    return BCM_E_INTERNAL;
                }
                cmprsd_attr_map->pkt_resolution = 1;
                cmprsd_attr_map->svp_type = 1;
                cmprsd_attr_map->drop = 1;
            }
            (*ref_count_p)++;
        }
    }
 
    /* Egress direction */ 
    if (direction == bcmStatFlexDirectionEgress) {
        cmprsd_attr_map = egr_global_stat_flex_compressed_attr_map[unit];
        if (cmprsd_attr_map == NULL ||
                egr_cmprsd_attr_selectors == NULL) {
            return BCM_E_MEMORY;
        }

        egr_pkt_attr_bits = egr_cmprsd_attr_selectors->pkt_attr_bits;
        /* EGR_FLEX_CTR_PRI_CNG_MAPm */
        if ((egr_pkt_attr_bits.cng != 0) ||
                (egr_pkt_attr_bits.int_pri)) {
            ref_count_p = &cmprsd_attr_map->ref_counts[egr_pkt_attr_pri_cng_map];
            if (*ref_count_p == 0) {
                alloc_size = soc_mem_index_count(unit,EGR_FLEX_CTR_PRI_CNG_MAPm) *
                    sizeof(egr_flex_ctr_pri_cng_map_entry_t);
                if(_bcm_stat_flex_compressed_tbl_dma_write(unit,
                       EGR_FLEX_CTR_PRI_CNG_MAPm,
                       PRI_CNG_FNf,
                       alloc_size,
                       egr_cmprsd_attr_selectors->pri_cnf_attr_map) !=
                       BCM_E_NONE) {
                    return BCM_E_INTERNAL;
                }
                cmprsd_attr_map->cng = 1;
                cmprsd_attr_map->int_pri = 1;
            }
            (*ref_count_p)++;
        }
        /* EGR_FLEX_CTR_PKT_PRI_MAPm */
        if ((egr_pkt_attr_bits.vlan_format != 0) ||
                (egr_pkt_attr_bits.outer_dot1p) ||
                (egr_pkt_attr_bits.inner_dot1p)) {
            ref_count_p = &cmprsd_attr_map->ref_counts[egr_pkt_attr_pkt_pri_map];
            if (*ref_count_p == 0) {  
                alloc_size= soc_mem_index_count(unit,EGR_FLEX_CTR_PKT_PRI_MAPm) *
                    sizeof(egr_flex_ctr_pkt_pri_map_entry_t);
                if(_bcm_stat_flex_compressed_tbl_dma_write(unit,
                       EGR_FLEX_CTR_PKT_PRI_MAPm,
                       PKT_PRI_FNf,
                       alloc_size,
                       egr_cmprsd_attr_selectors->pkt_pri_attr_map) !=
                       BCM_E_NONE) {
                    return BCM_E_INTERNAL;
                }
                /* update global structure */
                cmprsd_attr_map->vlan_format = 1;
                cmprsd_attr_map->outer_dot1p = 1;
                cmprsd_attr_map->inner_dot1p = 1;
            }
            (*ref_count_p)++;
        } 

        /* EGR_FLEX_CTR_PORT_MAPm */
        if (egr_pkt_attr_bits.egr_port != 0){
            ref_count_p = &cmprsd_attr_map->ref_counts[egr_pkt_attr_port_map];
            if (*ref_count_p == 0) {    
                alloc_size= soc_mem_index_count(unit,EGR_FLEX_CTR_PORT_MAPm) *
                    sizeof(egr_flex_ctr_port_map_entry_t);
                if(_bcm_stat_flex_compressed_tbl_dma_write(unit,
                       EGR_FLEX_CTR_PORT_MAPm,
                       PORT_FNf,
                       alloc_size,
                       egr_cmprsd_attr_selectors->port_attr_map) !=
                       BCM_E_NONE) {
                    return BCM_E_INTERNAL;
                }
                /* update global structure */
                cmprsd_attr_map->port= 1;
            }
            (*ref_count_p)++;
        }
        /* EGR_FLEX_CTR_TOS_MAPm */
        if ((egr_pkt_attr_bits.tos_dscp != 0) ||
                (egr_pkt_attr_bits.tos_ecn != 0)) {
            ref_count_p = &cmprsd_attr_map->ref_counts[egr_pkt_attr_tos_map];
            if (*ref_count_p == 0) {
                alloc_size = soc_mem_index_count(unit,EGR_FLEX_CTR_TOS_MAPm) *
                    sizeof(egr_flex_ctr_tos_map_entry_t);
                if(_bcm_stat_flex_compressed_tbl_dma_write(unit,
                       EGR_FLEX_CTR_TOS_MAPm,
                       TOS_FNf,
                       alloc_size,
                       egr_cmprsd_attr_selectors->tos_attr_map) !=
                       BCM_E_NONE) {
                    return BCM_E_INTERNAL;
                }
                cmprsd_attr_map->tos_dscp = 1;
                cmprsd_attr_map->tos_ecn = 1;
            }
            (*ref_count_p)++;
        }

        if ((egr_pkt_attr_bits.pkt_resolution != 0) ||
                (egr_pkt_attr_bits.svp_type) ||
                (egr_pkt_attr_bits.dvp_type) ||
                (egr_pkt_attr_bits.drop)){
            ref_count_p = &cmprsd_attr_map->ref_counts[egr_pkt_attr_pkt_res_map];
            if (*ref_count_p == 0) {
                alloc_size = soc_mem_index_count(unit,EGR_FLEX_CTR_PKT_RES_MAPm) *
                    sizeof(egr_flex_ctr_pkt_res_map_entry_t);
                if(_bcm_stat_flex_compressed_tbl_dma_write(unit,
                       EGR_FLEX_CTR_PKT_RES_MAPm,
                       PKT_RES_FNf,
                       alloc_size,
                       egr_cmprsd_attr_selectors->pkt_res_attr_map) !=
                       BCM_E_NONE) {
                    return BCM_E_INTERNAL;
                }
                cmprsd_attr_map->pkt_resolution = 1;
                cmprsd_attr_map->svp_type = 1;
                cmprsd_attr_map->dvp_type = 1;
                cmprsd_attr_map->drop = 1;
            }
            (*ref_count_p)++;
        }
    }
    return BCM_E_NONE;
}

int _bcm_stat_flex_compressed_attr_tbl_clear(int unit,
        bcm_stat_flex_direction_t direction,
        bcm_stat_flex_ing_cmprsd_attr_selectors_t *cmprsd_attr_selectors,
        bcm_stat_flex_egr_cmprsd_attr_selectors_t *egr_cmprsd_attr_selectors)
{

    uint8 *ref_count_p = NULL;
    bcm_stat_flex_ing_pkt_attr_bits_t pkt_attr_bits={0};
    bcm_stat_flex_egr_pkt_attr_bits_t egr_pkt_attr_bits={0};
    _bcm_stat_flex_compressed_mode_attr_sel_map_t *cmprsd_attr_map = NULL;

    if (direction == bcmStatFlexDirectionIngress) {
        cmprsd_attr_map = global_stat_flex_compressed_attr_map[unit];
        if (cmprsd_attr_map == NULL || cmprsd_attr_selectors == NULL) {
            return BCM_E_FAIL;
        }

        pkt_attr_bits = cmprsd_attr_selectors->pkt_attr_bits;
        /* ING_FLEX_CTR_PRI_CNG_MAPm */
        if ((pkt_attr_bits.cng != 0) ||
                (pkt_attr_bits.ifp_cng)  ||
                (pkt_attr_bits.int_pri)) {
            ref_count_p = &cmprsd_attr_map->ref_counts[ing_pkt_attr_pri_cng_map];
            if (*ref_count_p == 1) {
                SOC_IF_ERROR_RETURN(soc_mem_clear(unit,
                            ING_FLEX_CTR_PRI_CNG_MAPm,
                            MEM_BLOCK_ALL,TRUE));
                cmprsd_attr_map->cng = 0;
                cmprsd_attr_map->ifp_cng = 0;
                cmprsd_attr_map->int_pri = 0;
            }
            (*ref_count_p)--;
        }

        /* ING_FLEX_CTR_PKT_PRI_MAPm */ 
        if ((pkt_attr_bits.vlan_format != 0) ||
                (pkt_attr_bits.outer_dot1p) ||
                (pkt_attr_bits.inner_dot1p)) {
            ref_count_p = &cmprsd_attr_map->ref_counts[ing_pkt_attr_pkt_pri_map];
            if (*ref_count_p == 1) {
                SOC_IF_ERROR_RETURN(soc_mem_clear(unit,
                            ING_FLEX_CTR_PKT_PRI_MAPm,
                            MEM_BLOCK_ALL,TRUE));
                /* update global structure */
                cmprsd_attr_map->vlan_format = 0;
                cmprsd_attr_map->outer_dot1p = 0;
                cmprsd_attr_map->inner_dot1p = 0;
            }
            (*ref_count_p)--;
        }

        /* ING_FLEX_CTR_PORT_MAPm */
        if (pkt_attr_bits.ing_port != 0) {
            ref_count_p = &cmprsd_attr_map->ref_counts[ing_pkt_attr_port_map];
            if (*ref_count_p == 1) {
                SOC_IF_ERROR_RETURN(soc_mem_clear(unit,
                            ING_FLEX_CTR_PORT_MAPm,
                            MEM_BLOCK_ALL,TRUE));
                /* update global structure */
                cmprsd_attr_map->port= 0;
            }
            (*ref_count_p)--;
        }

        /* ING_FLEX_CTR_TOS_MAPm */
        if ((pkt_attr_bits.tos_dscp != 0) ||
                (pkt_attr_bits.tos_ecn != 0)) {
            ref_count_p = &cmprsd_attr_map->ref_counts[ing_pkt_attr_tos_map];
            if (*ref_count_p == 1) {   
                SOC_IF_ERROR_RETURN(soc_mem_clear(unit,
                            ING_FLEX_CTR_TOS_MAPm,
                            MEM_BLOCK_ALL,TRUE));
                cmprsd_attr_map->tos_dscp = 1;
                cmprsd_attr_map->tos_ecn = 1;
            }
            (*ref_count_p)--;
        }

        /* ING_FLEX_CTR_PKT_RES_MAPm */
        if ((pkt_attr_bits.pkt_resolution != 0) ||
                (pkt_attr_bits.svp_type) ||
                (pkt_attr_bits.drop)) {
            ref_count_p = &cmprsd_attr_map->ref_counts[ing_pkt_attr_pkt_res_map];
            if (*ref_count_p == 1) {   
                SOC_IF_ERROR_RETURN(soc_mem_clear(unit,
                            ING_FLEX_CTR_PKT_RES_MAPm,
                            MEM_BLOCK_ALL,TRUE));
                cmprsd_attr_map->pkt_resolution = 0;
                cmprsd_attr_map->svp_type = 0;
                cmprsd_attr_map->drop = 0;
            }
            (*ref_count_p)--;
        }
    }
 
    if (direction == bcmStatFlexDirectionEgress) {
        cmprsd_attr_map = egr_global_stat_flex_compressed_attr_map[unit];
        if (cmprsd_attr_map == NULL || egr_cmprsd_attr_selectors == NULL) {
            return BCM_E_MEMORY;
        }

        egr_pkt_attr_bits = egr_cmprsd_attr_selectors->pkt_attr_bits;
        if ((egr_pkt_attr_bits.cng != 0) ||
                (egr_pkt_attr_bits.int_pri)) {
            ref_count_p = &cmprsd_attr_map->ref_counts[ing_pkt_attr_pri_cng_map];
            if (*ref_count_p == 1) {
                SOC_IF_ERROR_RETURN(soc_mem_clear(unit,
                            EGR_FLEX_CTR_PRI_CNG_MAPm,
                            MEM_BLOCK_ALL,TRUE));
                cmprsd_attr_map->cng = 0;
                cmprsd_attr_map->int_pri = 0;
            }
            (*ref_count_p)--;
        }

        if ((egr_pkt_attr_bits.vlan_format != 0) ||
                (egr_pkt_attr_bits.outer_dot1p) ||
                (egr_pkt_attr_bits.inner_dot1p)) {
            ref_count_p = &cmprsd_attr_map->ref_counts[egr_pkt_attr_pkt_pri_map];
            if (*ref_count_p == 1) {
                SOC_IF_ERROR_RETURN(soc_mem_clear(unit,
                            EGR_FLEX_CTR_PKT_PRI_MAPm,
                            MEM_BLOCK_ALL,TRUE));
                /* update global structure */
                cmprsd_attr_map->vlan_format = 0;
                cmprsd_attr_map->outer_dot1p = 0;
                cmprsd_attr_map->inner_dot1p = 0;
            }
            (*ref_count_p)--;
        } 

        if (egr_pkt_attr_bits.egr_port != 0){
            ref_count_p = &cmprsd_attr_map->ref_counts[egr_pkt_attr_port_map];
            if (*ref_count_p == 1) {
                SOC_IF_ERROR_RETURN(soc_mem_clear(unit,
                            EGR_FLEX_CTR_PORT_MAPm,
                            MEM_BLOCK_ALL,TRUE));
                /* update global structure */
                cmprsd_attr_map->port= 0;
            }
            (*ref_count_p)--;
        }

        if ((egr_pkt_attr_bits.tos_dscp != 0) ||
                (egr_pkt_attr_bits.tos_ecn != 0)) {
            ref_count_p = &cmprsd_attr_map->ref_counts[egr_pkt_attr_tos_map];
            if (*ref_count_p == 1) {
                SOC_IF_ERROR_RETURN(soc_mem_clear(unit,
                            EGR_FLEX_CTR_TOS_MAPm,
                            MEM_BLOCK_ALL,TRUE));
                cmprsd_attr_map->tos_dscp = 0;
                cmprsd_attr_map->tos_ecn = 0;
            }
            (*ref_count_p)--;
        }

        if ((egr_pkt_attr_bits.pkt_resolution != 0) ||
                (egr_pkt_attr_bits.svp_type) ||
                (egr_pkt_attr_bits.dvp_type) ||
                (egr_pkt_attr_bits.drop)){
            ref_count_p = &cmprsd_attr_map->ref_counts[egr_pkt_attr_pkt_res_map];
            if (*ref_count_p == 1) {
                SOC_IF_ERROR_RETURN(soc_mem_clear(unit,
                            EGR_FLEX_CTR_PKT_RES_MAPm,
                            MEM_BLOCK_ALL,TRUE));
                cmprsd_attr_map->pkt_resolution = 0;
                cmprsd_attr_map->svp_type = 0;
                cmprsd_attr_map->dvp_type = 0;
                cmprsd_attr_map->drop = 0;
            }
            (*ref_count_p)--;
        }
    }
    return BCM_E_NONE;
}

int _bcm_esw_stat_flex_compressed_shared_attr_map_init(int unit,int alloc)
{
    if (alloc == TRUE) {
        if (global_stat_flex_compressed_attr_map[unit] == NULL) {
            /* For Ingress direction */
            global_stat_flex_compressed_attr_map[unit] = sal_alloc(
                    sizeof (_bcm_stat_flex_compressed_mode_attr_sel_map_t),
                    "compressed attr map");
            if (global_stat_flex_compressed_attr_map[unit] == NULL) {
                return BCM_E_MEMORY;
            }
            sal_memset(global_stat_flex_compressed_attr_map[unit], 0,
                    sizeof (_bcm_stat_flex_compressed_mode_attr_sel_map_t));
        }
        /* For Egress direction */
        if (egr_global_stat_flex_compressed_attr_map[unit] == NULL) {

            egr_global_stat_flex_compressed_attr_map[unit] = sal_alloc(
                    sizeof (_bcm_stat_flex_compressed_mode_attr_sel_map_t),
                    "compressed attr map");
            if (egr_global_stat_flex_compressed_attr_map[unit] == NULL) {
                return BCM_E_MEMORY;
            }
            sal_memset(egr_global_stat_flex_compressed_attr_map[unit], 0,
                    sizeof (_bcm_stat_flex_compressed_mode_attr_sel_map_t));
        }
    } else {
        sal_free(global_stat_flex_compressed_attr_map[unit]);
        global_stat_flex_compressed_attr_map[unit] = NULL;

        sal_free(egr_global_stat_flex_compressed_attr_map[unit]);
        egr_global_stat_flex_compressed_attr_map[unit] = NULL;

    }
    return BCM_E_NONE;
}

#ifdef BCM_WARM_BOOT_SUPPORT
/*
 *  Function:
 *    _bcm_esw_stat_flex_compressed_attr_flags_sync
 *  Purpose:
 *    Sync compressed attr maps to scache.
 *  Parameters:
 *     unit                  - (IN) unit number
 *     scache_position       - (IN/OUT) Scache position
 *  Returns:
 *      BCM_E_XXX
 */
int
_bcm_esw_stat_flex_compressed_attr_flags_sync(int unit, uint8 **scache_position)
{
    int i = 0;
    uint8 *scache_ptr = NULL;
    uint32 array_size = 0;
    _bcm_stat_flex_compressed_mode_attr_sel_map_t *cmprsd_attr_map = NULL;
    _bcm_stat_flex_compressed_mode_attr_sel_map_t *egr_cmprsd_attr_map = NULL;

    scache_ptr = (uint8 *)*scache_position;

    cmprsd_attr_map = global_stat_flex_compressed_attr_map[unit];
    egr_cmprsd_attr_map = egr_global_stat_flex_compressed_attr_map[unit];
    if (cmprsd_attr_map != NULL) { 
        if (cmprsd_attr_map->int_pri != 0) {
            sal_memcpy(scache_ptr,
                    &cmprsd_attr_map->combine_int_pri_flags,
                    sizeof(uint32));
        } else {
            sal_memset(scache_ptr, 0, sizeof(uint32));
        }
        scache_ptr += sizeof(uint32);

        if (cmprsd_attr_map->vlan_format != 0) {
            sal_memcpy(scache_ptr,
                    &cmprsd_attr_map->combine_vlan_format_flags,
                    sizeof(uint32));
        } else {
            sal_memset(scache_ptr, 0, sizeof(uint32));
        }
        scache_ptr += sizeof(uint32);

        if (cmprsd_attr_map->outer_dot1p != 0) {
            sal_memcpy(scache_ptr,
                    &cmprsd_attr_map->combine_outer_dot1p_flags,
                    sizeof(uint32));
        } else {
            sal_memset(scache_ptr, 0, sizeof(uint32));
        }
        scache_ptr += sizeof(uint32);

        if (cmprsd_attr_map->inner_dot1p != 0) {
            sal_memcpy(scache_ptr,
                    &cmprsd_attr_map->combine_inner_dot1p_flags,
                    sizeof(uint32));
        } else {
            sal_memset(scache_ptr, 0, sizeof(uint32));
        }
        scache_ptr += sizeof(uint32);

        if (cmprsd_attr_map->pkt_resolution != 0) {
            sal_memcpy(scache_ptr,
                    &cmprsd_attr_map->combine_pkt_resolution_flags,
                    sizeof(uint32));
        } else {
            sal_memset(scache_ptr, 0, sizeof(uint32));
        }
        scache_ptr += sizeof(uint32);

        if (cmprsd_attr_map->drop != 0) {
            sal_memcpy(scache_ptr,
                    &cmprsd_attr_map->combine_drop_flags,
                    sizeof(uint32));
        } else {
            sal_memset(scache_ptr, 0, sizeof(uint32));
        }
        scache_ptr += sizeof(uint32);

        if (cmprsd_attr_map->ip_pkt != 0) {
            sal_memcpy(scache_ptr,
                    &cmprsd_attr_map->combine_ip_pkt_flags,
                    sizeof(uint32));
        } else {
            sal_memset(scache_ptr, 0, sizeof(uint32));
        }
        scache_ptr += sizeof(uint32);

        /* Syncing Attributes which are array. */
        if (cmprsd_attr_map->port != 0) {
            array_size = BCM_STAT_FLEX_BIT_ARRAY_SIZE;
            sal_memcpy(scache_ptr, &array_size, sizeof(uint32));
            scache_ptr += sizeof(uint32);
            for(i = 0; i < BCM_STAT_FLEX_BIT_ARRAY_SIZE; i++) {
                sal_memcpy(scache_ptr,
                        &cmprsd_attr_map->combine_value_array[bcmStatFlexAttrPort][i],
                        sizeof(uint32));
                scache_ptr += sizeof(uint32);
            }
        } else {
            array_size = BCM_STAT_FLEX_BIT_ARRAY_SIZE;
            sal_memcpy(scache_ptr, &array_size, sizeof(uint32));
            scache_ptr += sizeof(uint32);
            sal_memset(scache_ptr, 0, sizeof(uint32) * BCM_STAT_FLEX_BIT_ARRAY_SIZE);
            scache_ptr += (sizeof(uint32) * BCM_STAT_FLEX_BIT_ARRAY_SIZE);
        }

        if (cmprsd_attr_map->tos_dscp != 0) {
            array_size = BCM_STAT_FLEX_BIT_ARRAY_SIZE;
            sal_memcpy(scache_ptr, &array_size, sizeof(uint32));
            scache_ptr += sizeof(uint32);
            for(i = 0; i < BCM_STAT_FLEX_BIT_ARRAY_SIZE; i++) {
                sal_memcpy(scache_ptr,
                        &cmprsd_attr_map->combine_value_array[bcmStatFlexAttrTosDscp][i],
                        sizeof(uint32));
                scache_ptr += sizeof(uint32);
            }
        } else {
            array_size = BCM_STAT_FLEX_BIT_ARRAY_SIZE;
            sal_memcpy(scache_ptr, &array_size, sizeof(uint32));
            scache_ptr += sizeof(uint32);
            sal_memset(scache_ptr, 0, sizeof(uint32) * BCM_STAT_FLEX_BIT_ARRAY_SIZE);
            scache_ptr += (sizeof(uint32) * BCM_STAT_FLEX_BIT_ARRAY_SIZE);
        }

        if (cmprsd_attr_map->tos_ecn != 0) {
            array_size = BCM_STAT_FLEX_BIT_ARRAY_SIZE;
            sal_memcpy(scache_ptr, &array_size, sizeof(uint32));
            scache_ptr += sizeof(uint32);
            for(i = 0; i < BCM_STAT_FLEX_BIT_ARRAY_SIZE; i++) {
                sal_memcpy(scache_ptr,
                        &cmprsd_attr_map->combine_value_array[bcmStatFlexAttrTosEcn][i],
                        sizeof(uint32));
                scache_ptr += sizeof(uint32);
            }
        } else {
            array_size = BCM_STAT_FLEX_BIT_ARRAY_SIZE;
            sal_memcpy(scache_ptr, &array_size, sizeof(uint32));
            scache_ptr += sizeof(uint32);
            sal_memset(scache_ptr, 0, sizeof(uint32) * BCM_STAT_FLEX_BIT_ARRAY_SIZE);
            scache_ptr += (sizeof(uint32) * BCM_STAT_FLEX_BIT_ARRAY_SIZE);
        }

        if (cmprsd_attr_map->svp_type != 0) {
            array_size = BCM_STAT_FLEX_BIT_ARRAY_SIZE;
            sal_memcpy(scache_ptr, &array_size, sizeof(uint32));
            scache_ptr += sizeof(uint32);
            for(i = 0; i < BCM_STAT_FLEX_BIT_ARRAY_SIZE; i++) {
                sal_memcpy(scache_ptr,
                        &cmprsd_attr_map->combine_value_array[bcmStatFlexAttrSvp][i],
                        sizeof(uint32));
                scache_ptr += sizeof(uint32);
            }
        } else {
            array_size = BCM_STAT_FLEX_BIT_ARRAY_SIZE;
            sal_memcpy(scache_ptr, &array_size, sizeof(uint32));
            scache_ptr += sizeof(uint32);
            sal_memset(scache_ptr, 0, sizeof(uint32) * BCM_STAT_FLEX_BIT_ARRAY_SIZE);
            scache_ptr += (sizeof(uint32) * BCM_STAT_FLEX_BIT_ARRAY_SIZE);
        }

        if (BCM_STAT_WB_DEFAULT_VERSION >= BCM_STAT_WB_VERSION_1_12) {
            if (cmprsd_attr_map->pkt_resolution != 0) {
                sal_memcpy(scache_ptr,
                        &cmprsd_attr_map->combine_pkt_resolution_high_flags,
                        sizeof(uint32));
            } else {
                sal_memset(scache_ptr, 0, sizeof(uint32));
            }
            scache_ptr += sizeof(uint32);
        }
    }

    /* sync for egress direction */
    if (egr_cmprsd_attr_map != NULL) {
        if (egr_cmprsd_attr_map->int_pri != 0) {
            sal_memcpy(scache_ptr,
                    &egr_cmprsd_attr_map->combine_int_pri_flags,
                    sizeof(uint32));
        } else {
            sal_memset(scache_ptr, 0, sizeof(uint32));
        }
        scache_ptr += sizeof(uint32);

        if (egr_cmprsd_attr_map->vlan_format != 0) {
            sal_memcpy(scache_ptr,
                    &egr_cmprsd_attr_map->combine_vlan_format_flags,
                    sizeof(uint32));
        } else {
            sal_memset(scache_ptr, 0, sizeof(uint32));
        }
        scache_ptr += sizeof(uint32);

        if (egr_cmprsd_attr_map->outer_dot1p != 0) {
            sal_memcpy(scache_ptr,
                    &egr_cmprsd_attr_map->combine_outer_dot1p_flags,
                    sizeof(uint32));
        } else {
            sal_memset(scache_ptr, 0, sizeof(uint32));
        }
        scache_ptr += sizeof(uint32);

        if (egr_cmprsd_attr_map->inner_dot1p != 0) {
            sal_memcpy(scache_ptr,
                    &egr_cmprsd_attr_map->combine_inner_dot1p_flags,
                    sizeof(uint32));
        } else {
            sal_memset(scache_ptr, 0, sizeof(uint32));
        }
        scache_ptr += sizeof(uint32);

        if (egr_cmprsd_attr_map->pkt_resolution != 0) {
            sal_memcpy(scache_ptr,
                    &egr_cmprsd_attr_map->combine_pkt_resolution_flags,
                    sizeof(uint32));
        } else {
            sal_memset(scache_ptr, 0, sizeof(uint32));
        }
        scache_ptr += sizeof(uint32);

        if (egr_cmprsd_attr_map->drop != 0) {
            sal_memcpy(scache_ptr,
                    &egr_cmprsd_attr_map->combine_drop_flags,
                    sizeof(uint32));
        } else {
            sal_memset(scache_ptr, 0, sizeof(uint32));
        }
        scache_ptr += sizeof(uint32);

        if (egr_cmprsd_attr_map->ip_pkt != 0) {
            sal_memcpy(scache_ptr,
                    &egr_cmprsd_attr_map->combine_ip_pkt_flags,
                    sizeof(uint32));
        } else {
            sal_memset(scache_ptr, 0, sizeof(uint32));
        }
        scache_ptr += sizeof(uint32);

        /* Syncing Attributes which are array. */
        if (egr_cmprsd_attr_map->port != 0) {
            array_size = BCM_STAT_FLEX_BIT_ARRAY_SIZE;
            sal_memcpy(scache_ptr, &array_size, sizeof(uint32));
            scache_ptr += sizeof(uint32);
            for(i = 0; i < BCM_STAT_FLEX_BIT_ARRAY_SIZE; i++) {
                sal_memcpy(scache_ptr,
                        &egr_cmprsd_attr_map->combine_value_array[bcmStatFlexAttrPort][i],
                        sizeof(uint32));
                scache_ptr += sizeof(uint32);
            }
        } else {
            array_size = BCM_STAT_FLEX_BIT_ARRAY_SIZE;
            sal_memcpy(scache_ptr, &array_size, sizeof(uint32));
            scache_ptr += sizeof(uint32);
            sal_memset(scache_ptr, 0, sizeof(uint32) * BCM_STAT_FLEX_BIT_ARRAY_SIZE);
            scache_ptr += (sizeof(uint32) * BCM_STAT_FLEX_BIT_ARRAY_SIZE);
        }

        if (egr_cmprsd_attr_map->tos_dscp != 0) {
            array_size = BCM_STAT_FLEX_BIT_ARRAY_SIZE;
            sal_memcpy(scache_ptr, &array_size, sizeof(uint32));
            scache_ptr += sizeof(uint32);
            for(i = 0; i < BCM_STAT_FLEX_BIT_ARRAY_SIZE; i++) {
                sal_memcpy(scache_ptr,
                        &egr_cmprsd_attr_map->combine_value_array[bcmStatFlexAttrTosDscp][i],
                        sizeof(uint32));
                scache_ptr += sizeof(uint32);
            }
        } else {
            array_size = BCM_STAT_FLEX_BIT_ARRAY_SIZE;
            sal_memcpy(scache_ptr, &array_size, sizeof(uint32));
            scache_ptr += sizeof(uint32);
            sal_memset(scache_ptr, 0, sizeof(uint32) * BCM_STAT_FLEX_BIT_ARRAY_SIZE);
            scache_ptr += (sizeof(uint32) * BCM_STAT_FLEX_BIT_ARRAY_SIZE);
        }

        if (egr_cmprsd_attr_map->tos_ecn != 0) {
            array_size = BCM_STAT_FLEX_BIT_ARRAY_SIZE;
            sal_memcpy(scache_ptr, &array_size, sizeof(uint32));
            scache_ptr += sizeof(uint32);
            for(i = 0; i < BCM_STAT_FLEX_BIT_ARRAY_SIZE; i++) {
                sal_memcpy(scache_ptr,
                        &egr_cmprsd_attr_map->combine_value_array[bcmStatFlexAttrTosEcn][i],
                        sizeof(uint32));
                scache_ptr += sizeof(uint32);
            }
        } else {
            array_size = BCM_STAT_FLEX_BIT_ARRAY_SIZE;
            sal_memcpy(scache_ptr, &array_size, sizeof(uint32));
            scache_ptr += sizeof(uint32);
            sal_memset(scache_ptr, 0, sizeof(uint32) * BCM_STAT_FLEX_BIT_ARRAY_SIZE);
            scache_ptr += (sizeof(uint32) * BCM_STAT_FLEX_BIT_ARRAY_SIZE);
        }

        if (egr_cmprsd_attr_map->svp_type != 0) {
            array_size = BCM_STAT_FLEX_BIT_ARRAY_SIZE;
            sal_memcpy(scache_ptr, &array_size, sizeof(uint32));
            scache_ptr += sizeof(uint32);
            for(i = 0; i < BCM_STAT_FLEX_BIT_ARRAY_SIZE; i++) {
                sal_memcpy(scache_ptr,
                        &egr_cmprsd_attr_map->combine_value_array[bcmStatFlexAttrSvp][i],
                        sizeof(uint32));
                scache_ptr += sizeof(uint32);
            }
        } else {
            array_size = BCM_STAT_FLEX_BIT_ARRAY_SIZE;
            sal_memcpy(scache_ptr, &array_size, sizeof(uint32));
            scache_ptr += sizeof(uint32);
            sal_memset(scache_ptr, 0, sizeof(uint32) * BCM_STAT_FLEX_BIT_ARRAY_SIZE);
            scache_ptr += (sizeof(uint32) * BCM_STAT_FLEX_BIT_ARRAY_SIZE);
        }

        if (egr_cmprsd_attr_map->dvp_type != 0) {
            array_size = BCM_STAT_FLEX_BIT_ARRAY_SIZE;
            sal_memcpy(scache_ptr, &array_size, sizeof(uint32));
            scache_ptr += sizeof(uint32);
            for(i = 0; i < BCM_STAT_FLEX_BIT_ARRAY_SIZE; i++) {
                sal_memcpy(scache_ptr,
                        &egr_cmprsd_attr_map->combine_value_array[bcmStatFlexAttrDvp][i],
                        sizeof(uint32));
                scache_ptr += sizeof(uint32);
            }
        } else {
            array_size = BCM_STAT_FLEX_BIT_ARRAY_SIZE;
            sal_memcpy(scache_ptr, &array_size, sizeof(uint32));
            scache_ptr += sizeof(uint32);
            sal_memset(scache_ptr, 0, sizeof(uint32) * BCM_STAT_FLEX_BIT_ARRAY_SIZE);
            scache_ptr += (sizeof(uint32) * BCM_STAT_FLEX_BIT_ARRAY_SIZE);
        }

        if (BCM_STAT_WB_DEFAULT_VERSION >= BCM_STAT_WB_VERSION_1_12) {
            if (egr_cmprsd_attr_map->pkt_resolution != 0) {
                sal_memcpy(scache_ptr,
                        &egr_cmprsd_attr_map->combine_pkt_resolution_high_flags,
                        sizeof(uint32));
            } else {
                sal_memset(scache_ptr, 0, sizeof(uint32));
            }
            scache_ptr += sizeof(uint32);
        }
    }


    *scache_position = scache_ptr;
    return BCM_E_NONE;
}


/*
 *  Function:
 *    _bcm_esw_stat_flex_compressed_attr_flags_recover
 *  Purpose:
 *    Recover compressed attr maps from scache.
 *  Parameters:
 *    unit                  - (IN) unit number
 *    recovered_ver         - (IN) recovered wb version
 *    scache_position       - (IN/OUT) Scache position
 *  Returns:
 *    BCM_E_XXX
 */
int _bcm_esw_stat_flex_compressed_attr_flags_recover(int unit,
    uint8 **scache_position)
{
    int i = 0;
    uint8 *scache_ptr = NULL;
    uint32 array_size = 0;
    _bcm_stat_flex_compressed_mode_attr_sel_map_t *cmprsd_attr_maps = NULL;
    _bcm_stat_flex_compressed_mode_attr_sel_map_t *egr_cmprsd_attr_maps = NULL;

    scache_ptr = (uint8 *)*scache_position;
    cmprsd_attr_maps = global_stat_flex_compressed_attr_map[unit];
    egr_cmprsd_attr_maps = egr_global_stat_flex_compressed_attr_map[unit];

    /* Recover in ingress direction. */
    if (cmprsd_attr_maps != NULL) {
        /* combine_int_pri_flags */
        sal_memcpy(&cmprsd_attr_maps->combine_int_pri_flags,
                scache_ptr, sizeof(uint32));
        scache_ptr += sizeof(uint32);

        /* combine_vlan_format_flags */
        sal_memcpy(&cmprsd_attr_maps->combine_vlan_format_flags,
                scache_ptr, sizeof(uint32));
        scache_ptr += sizeof(uint32);

        /* combine_outer_dot1p_flags */
        sal_memcpy(&cmprsd_attr_maps->combine_outer_dot1p_flags,
                scache_ptr, sizeof(uint32));
        scache_ptr += sizeof(uint32);

        /* combine_inner_dot1p_flags */
        sal_memcpy(&cmprsd_attr_maps->combine_inner_dot1p_flags,
                scache_ptr, sizeof(uint32));
        scache_ptr += sizeof(uint32);

        /* combine_pkt_res_flags */
        sal_memcpy(&cmprsd_attr_maps->combine_pkt_resolution_flags,
                scache_ptr, sizeof(uint32));
        scache_ptr += sizeof(uint32);

        /* combine_drop_flags */
        sal_memcpy(&cmprsd_attr_maps->combine_drop_flags,
                scache_ptr, sizeof(uint32));
        scache_ptr += sizeof(uint32);

        /* combine_ip_pkt_flags */
        sal_memcpy(&cmprsd_attr_maps->combine_ip_pkt_flags,
                scache_ptr, sizeof(uint32));
        scache_ptr += sizeof(uint32);

        /* Recovering Attributes which are array. */
        sal_memcpy(&array_size, scache_ptr, sizeof(uint32));
        scache_ptr += sizeof(uint32);
        for(i = 0; i < array_size; i++) {
            sal_memcpy(&cmprsd_attr_maps->combine_value_array[bcmStatFlexAttrPort][i],
                    scache_ptr, sizeof(uint32));
            scache_ptr += sizeof(uint32);
        }
        sal_memcpy(&array_size, scache_ptr, sizeof(uint32));
        scache_ptr += sizeof(uint32);
        for(i = 0; i < array_size; i++) {
            sal_memcpy(&cmprsd_attr_maps->combine_value_array[bcmStatFlexAttrTosDscp][i],
                    scache_ptr, sizeof(uint32));
            scache_ptr += sizeof(uint32);
        }
        sal_memcpy(&array_size, scache_ptr, sizeof(uint32));
        scache_ptr += sizeof(uint32);
        for(i = 0; i < array_size; i++) {
            sal_memcpy(&cmprsd_attr_maps->combine_value_array[bcmStatFlexAttrTosEcn][i],
                    scache_ptr, sizeof(uint32));
            scache_ptr += sizeof(uint32);
        }
        sal_memcpy(&array_size, scache_ptr, sizeof(uint32));
        scache_ptr += sizeof(uint32);
        for(i = 0; i < array_size; i++) {
            sal_memcpy(&cmprsd_attr_maps->combine_value_array[bcmStatFlexAttrSvp][i],
                    scache_ptr, sizeof(uint32));
            scache_ptr += sizeof(uint32);
        }

        if (BCM_STAT_WB_DEFAULT_VERSION >= BCM_STAT_WB_VERSION_1_12) {
            /* combine_pkt_res_high_flags */
            sal_memcpy(&cmprsd_attr_maps->combine_pkt_resolution_high_flags,
                    scache_ptr, sizeof(uint32));
            scache_ptr += sizeof(uint32);
        }
    }

    /* Recover for egress direction */
    if (egr_cmprsd_attr_maps != NULL) {
        /* combine_int_pri_flags */
        sal_memcpy(&egr_cmprsd_attr_maps->combine_int_pri_flags,
                scache_ptr, sizeof(uint32));
        scache_ptr += sizeof(uint32);

        /* combine_vlan_format_flags */
        sal_memcpy(&egr_cmprsd_attr_maps->combine_vlan_format_flags,
                scache_ptr, sizeof(uint32));
        scache_ptr += sizeof(uint32);

        /* combine_outer_dot1p_flags */
        sal_memcpy(&egr_cmprsd_attr_maps->combine_outer_dot1p_flags,
                scache_ptr, sizeof(uint32));
        scache_ptr += sizeof(uint32);

        /* combine_inner_dot1p_flags */
        sal_memcpy(&egr_cmprsd_attr_maps->combine_inner_dot1p_flags,
                scache_ptr, sizeof(uint32));
        scache_ptr += sizeof(uint32);

        /* combine_pkt_res_flags */
        sal_memcpy(&egr_cmprsd_attr_maps->combine_pkt_resolution_flags,
                scache_ptr, sizeof(uint32));
        scache_ptr += sizeof(uint32);

        /* combine_drop_flags */
        sal_memcpy(&egr_cmprsd_attr_maps->combine_drop_flags,
                scache_ptr, sizeof(uint32));
        scache_ptr += sizeof(uint32);

        /* combine_ip_pkt_flags */
        sal_memcpy(&egr_cmprsd_attr_maps->combine_ip_pkt_flags,
                scache_ptr, sizeof(uint32));
        scache_ptr += sizeof(uint32);

        /* Recovering Attributes which are array. */
        sal_memcpy(&array_size, scache_ptr, sizeof(uint32));
        scache_ptr += sizeof(uint32);
        for(i = 0; i < array_size; i++) {
            sal_memcpy(&egr_cmprsd_attr_maps->combine_value_array[bcmStatFlexAttrPort][i],
                    scache_ptr, sizeof(uint32));
            scache_ptr += sizeof(uint32);
        }
        sal_memcpy(&array_size, scache_ptr, sizeof(uint32));
        scache_ptr += sizeof(uint32);
        for(i = 0; i < array_size; i++) {
            sal_memcpy(&egr_cmprsd_attr_maps->combine_value_array[bcmStatFlexAttrTosDscp][i],
                    scache_ptr, sizeof(uint32));
            scache_ptr += sizeof(uint32);
        }
        sal_memcpy(&array_size, scache_ptr, sizeof(uint32));
        scache_ptr += sizeof(uint32);
        for(i = 0; i < array_size; i++) {
            sal_memcpy(&egr_cmprsd_attr_maps->combine_value_array[bcmStatFlexAttrTosEcn][i],
                    scache_ptr, sizeof(uint32));
            scache_ptr += sizeof(uint32);
        }
        sal_memcpy(&array_size, scache_ptr, sizeof(uint32));
        scache_ptr += sizeof(uint32);
        for(i = 0; i < array_size; i++) {
            sal_memcpy(&egr_cmprsd_attr_maps->combine_value_array[bcmStatFlexAttrSvp][i],
                    scache_ptr, sizeof(uint32));
            scache_ptr += sizeof(uint32);
        }

        if (BCM_STAT_WB_DEFAULT_VERSION >= BCM_STAT_WB_VERSION_1_12) {
            /* combine_pkt_res_high_flags */
            sal_memcpy(&egr_cmprsd_attr_maps->combine_pkt_resolution_high_flags,
                    scache_ptr, sizeof(uint32));
            scache_ptr += sizeof(uint32);
        }
    }

    *scache_position = scache_ptr;
    return BCM_E_NONE;
}
#endif /* BCM_WARM_BOOT_SUPPORT */

/*
 * flex counter flexible pool allocation and
 * compaction.
 */
int
_bcm_esw_stat_custom_group_id_create (int  unit,
    uint32                         mode_id,
    bcm_stat_object_t              object,
    uint32                         pool_id,
    uint32                         base_idx,
    bcm_stat_custom_counter_info_t *counter_info)
{
    bcm_error_t rv = BCM_E_NONE;
    uint32 stat_counter_id = 0;
    uint32 num_counters = 0;

    if (!soc_feature(unit, soc_feature_flex_stat_compaction_support)) {
        return BCM_E_UNAVAIL;
    }
    /* Counter base index should be non zero */
    if (base_idx <= 1 || pool_id >= BCM_STAT_FLEX_COUNTER_MAX_POOL) {
        return BCM_E_PARAM;
    }
    /*
     * Check resource allocation for required
     * base_idx in the requested pool
     */
    rv = _bcm_esw_stat_custom_group_associate_object(
            unit, mode_id, object, &stat_counter_id, &num_counters,
            pool_id, base_idx, counter_info);

    BCM_IF_ERROR_RETURN(rv);

    if (BCM_STAT_GROUP_MODE_ID_OAM_SUFFIX ==
         (mode_id & BCM_STAT_GROUP_MODE_ID_OAM_MASK)) {
        return rv;
    }

    if ((object != bcmStatObjectIngFieldStageIngress) &&
        (object != bcmStatObjectIngFieldStageLookup) &&
        (object != bcmStatObjectIngExactMatch)) {
        return rv;
    }

    return rv;
}

int
_bcm_stat_flex_counter_id_move (int unit,
        bcm_stat_custom_base_index_action_t idx_action,
        bcm_stat_custom_counter_info_t   counter_info_old,
        bcm_stat_custom_counter_info_t   *counter_info_new)
{
    uint32 new_base_idx = 0;
    uint32 new_pool_id = 0;
    uint32 new_object = 0;
    uint32 new_mode_id = 0;
    uint32 stat_counter_id = 0, num_counters = 0;
    int rv = BCM_E_NONE;

    if (soc_feature(unit, soc_feature_flex_stat_compaction_support)) {
        switch(idx_action) {
            case bcmStatCustomBaseIdxAlloc:
                /*
                 * Allocates new set of counters based on couter_info_new parameter.
                 * After this API call, customer needs to attach new counter_stat_id
                 * to the individual module HW entries that were referencing the old
                 * counter,using the respective legacy counter attach APIs for each
                 * module before disabling old set of counters based on
                 * counter_info_old parameter to ensure no loss of counter values.
                 */
                if (counter_info_new != NULL) {
                    if(compaction_info[unit].in_progress == FALSE) {
                        new_pool_id  = counter_info_new->ctr_tbl_pool_id;
                        new_base_idx = counter_info_new->ctr_tbl_pool_base_idx;
                        new_mode_id  = counter_info_new->ctr_tbl_mode_id;
                        new_object   = counter_info_new->object;

                        if (_bcm_esw_stat_validate_counter_info(unit,
                                    counter_info_old,
                                    counter_info_new) != BCM_E_NONE) {
                            LOG_DEBUG(BSL_LS_BCM_FLEXCTR,
                                    (BSL_META_U(unit,
                                                "StatBaseIdxAlloc: Config Error \n")));
                            return BCM_E_PARAM;
                        }

                        rv = _bcm_esw_stat_custom_group_associate_object(unit,
                                new_mode_id, new_object, &stat_counter_id,
                                &num_counters, new_pool_id, new_base_idx,
                                counter_info_new);
                        LOG_DEBUG(BSL_LS_BCM_FLEXCTR,
                                (BSL_META_U(unit,
                                            "StatBaseIdxAlloc: Created new stat counter id: %d new base index %d\n"),
                                 stat_counter_id,new_base_idx));
                        if (rv == BCM_E_NONE) {
                            counter_info_new->stat_counter_id = stat_counter_id;
                            compaction_info[unit].base_idx    = counter_info_old.ctr_tbl_pool_base_idx;
                            compaction_info[unit].pool_number = counter_info_old.ctr_tbl_pool_id;
                            compaction_info[unit].in_progress = TRUE;
                        }
                    } else {
                        rv = BCM_E_CONFIG;
                    }
                } else {
                    rv = BCM_E_PARAM;
                }
                break;
            case bcmStatCustomBaseIdxMove:
                /*
                 * Disables existing counter set pointed by
                 * counter_info_old parameter
                 */
                if (counter_info_new == NULL) {
                    return BCM_E_PARAM;
                }
                if (compaction_info[unit].in_progress == FALSE) {
                    LOG_DEBUG(BSL_LS_BCM_FLEXCTR,
                            (BSL_META_U(unit,
                                        "StatBaseIdxMove:Counter Move is not initiated\n")));
                    return BCM_E_CONFIG;
                }
                /*
                 * Do not allow old base-idx,pool-id and
                 * different mode id in new counter info
                 * structure in counter movement.
                 */
                if (((counter_info_new->ctr_tbl_pool_base_idx ==
                    counter_info_old.ctr_tbl_pool_base_idx) &&
                    (counter_info_new->ctr_tbl_pool_id ==
                         counter_info_old.ctr_tbl_pool_id)) ||
                    (counter_info_new->ctr_tbl_mode_id !=
                         counter_info_old.ctr_tbl_mode_id)) {
                    return BCM_E_CONFIG;
                }
                rv = _bcm_stat_flex_counter_base_idx_move(unit,
                        counter_info_old, counter_info_new);
                compaction_info[unit].base_idx    = 0;
                compaction_info[unit].pool_number = 0;
                compaction_info[unit].in_progress = FALSE;
                break;
            default:
                rv = BCM_E_PARAM;
                break;
        }
    }
    return rv;
}

#ifdef BCM_TOMAHAWK_SUPPORT
void _bcm_fill_stat_counter_map(int unit, int id, uint32 mode, uint32 pool, 
                                uint32 base_idx, bcm_stat_object_t object,
                                bcm_stat_group_mode_t group)
{
            if (!stat_counter_map[unit]) {
#if 0
               stat_counter_map[unit][id] = 
               sal_alloc(sizeof(bcm_stat_counter_map_t),"attr");
               
               if (stat_counter_map[unit][id] == NULL) {
                   LOG_ERROR(BSL_LS_BCM_FLEXCTR,
                       (BSL_META_U(0,
                       "Memory alloc failed! ")));
                       return;
               }
               sal_memset(stat_counter_map[id], 0, sizeof(bcm_stat_counter_map_t));
#endif
               return;
            }
            stat_counter_map[unit][id].mode = mode;
            stat_counter_map[unit][id].group = group;
            stat_counter_map[unit][id].object = object;
            stat_counter_map[unit][id].pool = pool;
            stat_counter_map[unit][id].base_idx = base_idx;
            stat_counter_map[unit][id].used = 1;
}

void _bcm_get_stat_counter_map(int unit, int id, bcm_stat_counter_map_t *stat_ctr_map)
{
            if (stat_counter_map[unit][id].used == 0) {
               stat_ctr_map->used = 0;
               return;
            }
            stat_ctr_map->mode = stat_counter_map[unit][id].mode;
            stat_ctr_map->group = stat_counter_map[unit][id].group;
            stat_ctr_map->object = stat_counter_map[unit][id].object;
            stat_ctr_map->pool = stat_counter_map[unit][id].pool;
            stat_ctr_map->base_idx = stat_counter_map[unit][id].base_idx;
            stat_ctr_map->used = stat_counter_map[unit][id].used;
            stat_ctr_map->pipe = stat_counter_map[unit][id].pipe;
}

void stat_ctr_map_init(int unit) 
{

     stat_counter_map[unit] = 
           sal_alloc((BCM_MAX_STAT_COUNTER_IDS + 1) * 
                     sizeof(bcm_stat_counter_map_t),"attr");
     sal_memset(stat_counter_map[unit], 0, (BCM_MAX_STAT_COUNTER_IDS + 1) * 
                                               sizeof(bcm_stat_counter_map_t));
}
void stat_ctr_map_deinit(int unit) 
{
     if (stat_counter_map[unit]) {
         sal_free(stat_counter_map[unit]);
         stat_counter_map[unit] = NULL;
     }
}

#endif

