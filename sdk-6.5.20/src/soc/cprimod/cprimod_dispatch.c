/*
 *         
 * 
 * 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 *         
 *     
 * DO NOT EDIT THIS FILE!
 */

#include <soc/types.h>
#include <soc/error.h>
#include <soc/cprimod/cprimod_internal.h>
#include <soc/cprimod/cprimod.h>
#include <soc/cprimod/cprimod_dispatch.h>


        
#ifdef _ERR_MSG_MODULE_NAME 
#error "_ERR_MSG_MODULE_NAME redefined" 
#endif
#define _ERR_MSG_MODULE_NAME BSL_LS_SOC_PORT
#ifdef CPRIMOD_SUPPORT

#ifdef CPRIMOD_CPRI_FALCON_SUPPORT
extern __cprimod__dispatch__t__ cprimod_cprif_driver;
#endif

__cprimod__dispatch__t__* __cprimod__dispatch__[cprimodDispatchTypeCount] = {
#ifdef CPRIMOD_CPRI_FALCON_SUPPORT
    &cprimod_cprif_driver,
#endif

};

int cprimod_dispatch_type_t_validate(cprimod_dispatch_type_t cprimod_dispatch_type)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_dispatch_type >= cprimodDispatchTypeCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_test_api_dispatch(int unit, int port, int* value)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_test_api_dispatch) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_test_api_dispatch(unit, port, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_test_api_dispatch isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_basic_frame_table_id_t_validate(cprimod_basic_frame_table_id_t cprimod_basic_frame_table_id)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_basic_frame_table_id >= cprimod_basic_frame_table_Count) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_basic_frame_usage_entry_t_validate(const cprimod_basic_frame_usage_entry_t* cprimod_basic_frame_usage_entry)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_basic_frame_usage_entry == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_basic_frame_usage_entry_t_init(cprimod_basic_frame_usage_entry_t* cprimod_basic_frame_usage_entry)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_basic_frame_usage_entry == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_basic_frame_usage_entry NULL parameter"));
    }
    sal_memset(cprimod_basic_frame_usage_entry, 0, sizeof(cprimod_basic_frame_usage_entry_t));
    cprimod_basic_frame_usage_entry->axc_id = 0;
    cprimod_basic_frame_usage_entry->start_bit = 0;
    cprimod_basic_frame_usage_entry->num_bits = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_basic_frame_parser_active_table_set(int unit, int port, cprimod_basic_frame_table_id_t table, int sync_enable)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_basic_frame_table_id_t_validate(table)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("table validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_basic_frame_parser_active_table_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_basic_frame_parser_active_table_set(unit, port, table, sync_enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_basic_frame_parser_active_table_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_basic_frame_parser_active_table_get(int unit, int port, cprimod_basic_frame_table_id_t* table)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(table == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("table NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_basic_frame_parser_active_table_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_basic_frame_parser_active_table_get(unit, port, table);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_basic_frame_parser_active_table_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_basic_frame_parser_table_num_entries_set(int unit, int port, cprimod_basic_frame_table_id_t table, uint32 num_entries)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_basic_frame_table_id_t_validate(table)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("table validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_basic_frame_parser_table_num_entries_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_basic_frame_parser_table_num_entries_set(unit, port, table, num_entries);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_basic_frame_parser_table_num_entries_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_basic_frame_parser_table_num_entries_get(int unit, int port, cprimod_basic_frame_table_id_t table, uint32* num_entries)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_basic_frame_table_id_t_validate(table)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("table validation failed"));
    }

    if(num_entries == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("num_entries NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_basic_frame_parser_table_num_entries_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_basic_frame_parser_table_num_entries_get(unit, port, table, num_entries);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_basic_frame_parser_table_num_entries_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_basic_frame_assembly_active_table_set(int unit, int port, cprimod_basic_frame_table_id_t table, int sync_enable)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_basic_frame_table_id_t_validate(table)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("table validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_basic_frame_assembly_active_table_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_basic_frame_assembly_active_table_set(unit, port, table, sync_enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_basic_frame_assembly_active_table_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_basic_frame_assembly_active_table_get(int unit, int port, cprimod_basic_frame_table_id_t* table)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(table == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("table NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_basic_frame_assembly_active_table_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_basic_frame_assembly_active_table_get(unit, port, table);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_basic_frame_assembly_active_table_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_basic_frame_assembly_table_num_entries_set(int unit, int port, cprimod_basic_frame_table_id_t table, uint32 num_entries)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_basic_frame_table_id_t_validate(table)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("table validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_basic_frame_assembly_table_num_entries_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_basic_frame_assembly_table_num_entries_set(unit, port, table, num_entries);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_basic_frame_assembly_table_num_entries_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_basic_frame_assembly_table_num_entries_get(int unit, int port, cprimod_basic_frame_table_id_t table, uint32* num_entries)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_basic_frame_table_id_t_validate(table)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("table validation failed"));
    }

    if(num_entries == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("num_entries NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_basic_frame_assembly_table_num_entries_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_basic_frame_assembly_table_num_entries_get(unit, port, table, num_entries);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_basic_frame_assembly_table_num_entries_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_basic_frame_parser_switch_active_table(int unit, int port)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_basic_frame_parser_switch_active_table) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_basic_frame_parser_switch_active_table(unit, port);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_basic_frame_parser_switch_active_table isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_basic_frame_assembly_switch_active_table(int unit, int port)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_basic_frame_assembly_switch_active_table) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_basic_frame_assembly_switch_active_table(unit, port);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_basic_frame_assembly_switch_active_table isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rx_axc_basic_frame_add(int unit, int port, uint32 axc_id, uint32 start_bit, uint32 num_bit)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rx_axc_basic_frame_add) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rx_axc_basic_frame_add(unit, port, axc_id, start_bit, num_bit);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rx_axc_basic_frame_add isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rx_axc_basic_frame_delete(int unit, int port, uint32 axc_id)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rx_axc_basic_frame_delete) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rx_axc_basic_frame_delete(unit, port, axc_id);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rx_axc_basic_frame_delete isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rx_axc_basic_frame_clear(int unit, int port)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rx_axc_basic_frame_clear) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rx_axc_basic_frame_clear(unit, port);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rx_axc_basic_frame_clear isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rx_axc_basic_frame_get(int unit, int port, uint32 axc_id, cprimod_basic_frame_table_id_t table, cprimod_basic_frame_usage_entry_t* usage_table, int* num_entries)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_basic_frame_table_id_t_validate(table)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("table validation failed"));
    }

    if(usage_table == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("usage_table NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_basic_frame_usage_entry_t_init(usage_table)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("usage_table initialization failed"));
    }

    if(num_entries == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("num_entries NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rx_axc_basic_frame_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rx_axc_basic_frame_get(unit, port, axc_id, table, usage_table, num_entries);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rx_axc_basic_frame_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_tx_axc_basic_frame_add(int unit, int port, uint32 axc_id, uint32 start_bit, uint32 num_bit)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_tx_axc_basic_frame_add) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_tx_axc_basic_frame_add(unit, port, axc_id, start_bit, num_bit);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_tx_axc_basic_frame_add isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_tx_axc_basic_frame_delete(int unit, int port, uint32 axc_id)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_tx_axc_basic_frame_delete) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_tx_axc_basic_frame_delete(unit, port, axc_id);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_tx_axc_basic_frame_delete isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_tx_axc_basic_frame_clear(int unit, int port)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_tx_axc_basic_frame_clear) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_tx_axc_basic_frame_clear(unit, port);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_tx_axc_basic_frame_clear isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_tx_axc_basic_frame_get(int unit, int port, uint32 axc_id, cprimod_basic_frame_table_id_t table, cprimod_basic_frame_usage_entry_t* usage_table, int* num_entries)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_basic_frame_table_id_t_validate(table)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("table validation failed"));
    }

    if(usage_table == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("usage_table NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_basic_frame_usage_entry_t_init(usage_table)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("usage_table initialization failed"));
    }

    if(num_entries == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("num_entries NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_tx_axc_basic_frame_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_tx_axc_basic_frame_get(unit, port, axc_id, table, usage_table, num_entries);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_tx_axc_basic_frame_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_basic_frame_debug(int unit, int port, uint32 axc_id, cprimod_basic_frame_table_id_t rx_table, cprimod_basic_frame_table_id_t tx_table, uint32 flags)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_basic_frame_table_id_t_validate(rx_table)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("rx_table validation failed"));
    }

    if(SOC_E_NONE != cprimod_basic_frame_table_id_t_validate(tx_table)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("tx_table validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_basic_frame_debug) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_basic_frame_debug(unit, port, axc_id, rx_table, tx_table, flags);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_basic_frame_debug isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_frame_map_method_t_validate(cprimod_cpri_frame_map_method_t cprimod_cpri_frame_map_method)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_cpri_frame_map_method >= cprimod_cpri_frame_map_method_Count) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_cpri_container_config_t_validate(const cprimod_cpri_container_config_t* cprimod_cpri_container_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_cpri_container_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != cprimod_cpri_frame_map_method_t_validate(cprimod_cpri_container_config->map_method)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("map_method validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_cpri_container_config_t_init(cprimod_cpri_container_config_t* cprimod_cpri_container_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_cpri_container_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_cpri_container_config NULL parameter"));
    }
    sal_memset(cprimod_cpri_container_config, 0, sizeof(cprimod_cpri_container_config_t));
    cprimod_cpri_container_config->map_method = 0;
    cprimod_cpri_container_config->Naxc = 0;
    cprimod_cpri_container_config->K = 0;
    cprimod_cpri_container_config->Nst = 0;
    cprimod_cpri_container_config->Na = 0;
    cprimod_cpri_container_config->Nc = 0;
    cprimod_cpri_container_config->Nv = 0;
    cprimod_cpri_container_config->frame_sync_mode = 0;
    cprimod_cpri_container_config->basic_frame_offset = 0;
    cprimod_cpri_container_config->radio_frame_offset = 0;
    cprimod_cpri_container_config->hyper_frame_offset = 0;
    cprimod_cpri_container_config->cblk_cnt = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_rsvd4_container_config_t_validate(const cprimod_rsvd4_container_config_t* cprimod_rsvd4_container_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_rsvd4_container_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_rsvd4_container_config_t_init(cprimod_rsvd4_container_config_t* cprimod_rsvd4_container_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_rsvd4_container_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_rsvd4_container_config NULL parameter"));
    }
    sal_memset(cprimod_rsvd4_container_config, 0, sizeof(cprimod_rsvd4_container_config_t));
    cprimod_rsvd4_container_config->stuffing_cnt = 0;
    cprimod_rsvd4_container_config->msg_ts_mode = 0;
    cprimod_rsvd4_container_config->msg_ts_cnt = 0;
    cprimod_rsvd4_container_config->frame_sync_mode = 0;
    cprimod_rsvd4_container_config->master_frame_offset = 0;
    cprimod_rsvd4_container_config->message_number_offset = 0;
    cprimod_rsvd4_container_config->container_block_cnt = 0;
    cprimod_rsvd4_container_config->use_ts_dbm = 0;
    cprimod_rsvd4_container_config->ts_dbm_prof_num = 0;
    cprimod_rsvd4_container_config->num_active_slots = 0;
    cprimod_rsvd4_container_config->msg_addr = 0;
    cprimod_rsvd4_container_config->msg_type = 0;
    cprimod_rsvd4_container_config->msg_ts_offset = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_cpri_rx_axc_container_config_set(int unit, int port, uint32 axc_id, const cprimod_cpri_container_config_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_cpri_container_config_t_validate(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_rx_axc_container_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_rx_axc_container_config_set(unit, port, axc_id, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_rx_axc_container_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_rx_axc_container_config_get(int unit, int port, uint32 axc_id, cprimod_cpri_container_config_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_cpri_container_config_t_init(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_rx_axc_container_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_rx_axc_container_config_get(unit, port, axc_id, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_rx_axc_container_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_rx_axc_container_config_clear(int unit, int port, uint32 axc_id)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_rx_axc_container_config_clear) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_rx_axc_container_config_clear(unit, port, axc_id);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_rx_axc_container_config_clear isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_tx_axc_container_config_set(int unit, int port, uint32 axc_id, const cprimod_cpri_container_config_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_cpri_container_config_t_validate(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_tx_axc_container_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_tx_axc_container_config_set(unit, port, axc_id, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_tx_axc_container_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_tx_axc_container_config_get(int unit, int port, uint32 axc_id, cprimod_cpri_container_config_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_cpri_container_config_t_init(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_tx_axc_container_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_tx_axc_container_config_get(unit, port, axc_id, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_tx_axc_container_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_tx_axc_container_config_clear(int unit, int port, uint32 axc_id)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_tx_axc_container_config_clear) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_tx_axc_container_config_clear(unit, port, axc_id);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_tx_axc_container_config_clear isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rsvd4_rx_axc_container_config_set(int unit, int port, uint32 flow_id, const cprimod_rsvd4_container_config_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_rsvd4_container_config_t_validate(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_rx_axc_container_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_rx_axc_container_config_set(unit, port, flow_id, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rsvd4_rx_axc_container_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rsvd4_rx_axc_container_config_get(int unit, int port, uint32 flow_id, cprimod_rsvd4_container_config_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_rsvd4_container_config_t_init(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_rx_axc_container_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_rx_axc_container_config_get(unit, port, flow_id, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rsvd4_rx_axc_container_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rsvd4_rx_axc_container_config_clear(int unit, int port, uint32 flow_id)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_rx_axc_container_config_clear) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_rx_axc_container_config_clear(unit, port, flow_id);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rsvd4_rx_axc_container_config_clear isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rsvd4_tx_axc_container_config_set(int unit, int port, uint32 flow_id, const cprimod_rsvd4_container_config_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_rsvd4_container_config_t_validate(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_tx_axc_container_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_tx_axc_container_config_set(unit, port, flow_id, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rsvd4_tx_axc_container_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rsvd4_tx_axc_container_config_get(int unit, int port, uint32 flow_id, cprimod_rsvd4_container_config_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_rsvd4_container_config_t_init(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_tx_axc_container_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_tx_axc_container_config_get(unit, port, flow_id, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rsvd4_tx_axc_container_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rsvd4_tx_axc_container_config_clear(int unit, int port, uint32 flow_id)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_tx_axc_container_config_clear) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_tx_axc_container_config_clear(unit, port, flow_id);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rsvd4_tx_axc_container_config_clear isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_payload_size_info_t_validate(const cprimod_payload_size_info_t* cprimod_payload_size_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_payload_size_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_payload_size_info_t_init(cprimod_payload_size_info_t* cprimod_payload_size_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_payload_size_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_payload_size_info NULL parameter"));
    }
    sal_memset(cprimod_payload_size_info, 0, sizeof(cprimod_payload_size_info_t));
    cprimod_payload_size_info->packet_size = 0;
    cprimod_payload_size_info->last_packet_num = 0;
    cprimod_payload_size_info->last_packet_size = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_rx_roe_payload_size_set(int unit, int port, uint32 axc_id, const cprimod_payload_size_info_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_payload_size_info_t_validate(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rx_roe_payload_size_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rx_roe_payload_size_set(unit, port, axc_id, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rx_roe_payload_size_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rx_roe_payload_size_get(int unit, int port, uint32 axc_id, cprimod_payload_size_info_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_payload_size_info_t_init(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rx_roe_payload_size_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rx_roe_payload_size_get(unit, port, axc_id, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rx_roe_payload_size_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_tx_roe_payload_size_set(int unit, int port, uint32 axc_id, const cprimod_payload_size_info_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_payload_size_info_t_validate(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_tx_roe_payload_size_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_tx_roe_payload_size_set(unit, port, axc_id, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_tx_roe_payload_size_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_tx_roe_payload_size_get(int unit, int port, uint32 axc_id, cprimod_payload_size_info_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_payload_size_info_t_init(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_tx_roe_payload_size_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_tx_roe_payload_size_get(unit, port, axc_id, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_tx_roe_payload_size_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_compression_type_t_validate(cprimod_compression_type_t cprimod_compression_type)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_compression_type >= cprimod_Count) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_truncation_type_t_validate(cprimod_truncation_type_t cprimod_truncation_type)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_truncation_type >= cprimod_truncation_type_Count) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_encap_decap_data_config_t_validate(const cprimod_encap_decap_data_config_t* cprimod_encap_decap_data_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_encap_decap_data_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != cprimod_truncation_type_t_validate(cprimod_encap_decap_data_config->truncation_type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("truncation_type validation failed"));
    }

    if(SOC_E_NONE != cprimod_compression_type_t_validate(cprimod_encap_decap_data_config->compression_type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("compression_type validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_encap_decap_data_config_t_init(cprimod_encap_decap_data_config_t* cprimod_encap_decap_data_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_encap_decap_data_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_encap_decap_data_config NULL parameter"));
    }
    sal_memset(cprimod_encap_decap_data_config, 0, sizeof(cprimod_encap_decap_data_config_t));
    cprimod_encap_decap_data_config->sample_size = 0;
    cprimod_encap_decap_data_config->truncation_enable = 0;
    cprimod_encap_decap_data_config->truncation_type = 0;
    cprimod_encap_decap_data_config->compression_type = cprimod_no_compress;
    cprimod_encap_decap_data_config->mux_enable = 0;
    cprimod_encap_decap_data_config->bit_reversal = 0;
    cprimod_encap_decap_data_config->buffer_size = 0;
    cprimod_encap_decap_data_config->priority = 0;
    cprimod_encap_decap_data_config->cycle_size = 0;
    cprimod_encap_decap_data_config->is_agnostic = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_cpri_encap_data_config_set(int unit, int port, uint32 queue_num, const cprimod_encap_decap_data_config_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_encap_decap_data_config_t_validate(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_encap_data_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_encap_data_config_set(unit, port, queue_num, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_encap_data_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_encap_data_config_get(int unit, int port, uint32 queue_num, cprimod_encap_decap_data_config_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_encap_decap_data_config_t_init(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_encap_data_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_encap_data_config_get(unit, port, queue_num, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_encap_data_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_decap_data_config_set(int unit, int port, uint32 queue_num, const cprimod_encap_decap_data_config_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_encap_decap_data_config_t_validate(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_decap_data_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_decap_data_config_set(unit, port, queue_num, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_decap_data_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_decap_data_config_get(int unit, int port, uint32 queue_num, cprimod_encap_decap_data_config_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_encap_decap_data_config_t_init(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_decap_data_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_decap_data_config_get(unit, port, queue_num, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_decap_data_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rsvd4_encap_data_config_t_validate(const cprimod_rsvd4_encap_data_config_t* cprimod_rsvd4_encap_data_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_rsvd4_encap_data_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_rsvd4_encap_data_config_t_init(cprimod_rsvd4_encap_data_config_t* cprimod_rsvd4_encap_data_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_rsvd4_encap_data_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_rsvd4_encap_data_config NULL parameter"));
    }
    sal_memset(cprimod_rsvd4_encap_data_config, 0, sizeof(cprimod_rsvd4_encap_data_config_t));
    cprimod_rsvd4_encap_data_config->buffer_size = 0;
    cprimod_rsvd4_encap_data_config->priority = 0;
    cprimod_rsvd4_encap_data_config->gsm_pad_size = 0;
    cprimod_rsvd4_encap_data_config->gsm_extra_pad_size = 0;
    cprimod_rsvd4_encap_data_config->gsm_pad_enable = 0;
    cprimod_rsvd4_encap_data_config->gsm_control_location = 0;
    cprimod_rsvd4_encap_data_config->bit_reversal = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_rsvd4_decap_data_config_t_validate(const cprimod_rsvd4_decap_data_config_t* cprimod_rsvd4_decap_data_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_rsvd4_decap_data_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_rsvd4_decap_data_config_t_init(cprimod_rsvd4_decap_data_config_t* cprimod_rsvd4_decap_data_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_rsvd4_decap_data_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_rsvd4_decap_data_config NULL parameter"));
    }
    sal_memset(cprimod_rsvd4_decap_data_config, 0, sizeof(cprimod_rsvd4_decap_data_config_t));
    cprimod_rsvd4_decap_data_config->buffer_size = 0;
    cprimod_rsvd4_decap_data_config->cycle_size = 0;
    cprimod_rsvd4_decap_data_config->gsm_pad_size = 0;
    cprimod_rsvd4_decap_data_config->gsm_extra_pad_size = 0;
    cprimod_rsvd4_decap_data_config->gsm_pad_enable = 0;
    cprimod_rsvd4_decap_data_config->gsm_control_location = 0;
    cprimod_rsvd4_decap_data_config->bit_reversal = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_rsvd4_encap_data_config_set(int unit, int port, uint32 queue_num, const cprimod_rsvd4_encap_data_config_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_rsvd4_encap_data_config_t_validate(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_encap_data_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_encap_data_config_set(unit, port, queue_num, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rsvd4_encap_data_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rsvd4_encap_data_config_get(int unit, int port, uint32 queue_num, cprimod_rsvd4_encap_data_config_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_rsvd4_encap_data_config_t_init(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_encap_data_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_encap_data_config_get(unit, port, queue_num, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rsvd4_encap_data_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rsvd4_decap_data_config_set(int unit, int port, uint32 queue_num, const cprimod_rsvd4_decap_data_config_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_rsvd4_decap_data_config_t_validate(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_decap_data_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_decap_data_config_set(unit, port, queue_num, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rsvd4_decap_data_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rsvd4_decap_data_config_get(int unit, int port, uint32 queue_num, cprimod_rsvd4_decap_data_config_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_rsvd4_decap_data_config_t_init(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_decap_data_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_decap_data_config_get(unit, port, queue_num, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rsvd4_decap_data_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_hdr_encap_type_t_validate(cprimod_hdr_encap_type_t cprimod_hdr_encap_type)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_hdr_encap_type >= cprimod_hdr_encap_type_Count) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_hdr_vlan_type_t_validate(cprimod_hdr_vlan_type_t cprimod_hdr_vlan_type)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_hdr_vlan_type >= cprimodHdrVlanTypeCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_encap_header_config_t_validate(const cprimod_encap_header_config_t* cprimod_encap_header_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_encap_header_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != cprimod_hdr_encap_type_t_validate(cprimod_encap_header_config->header_type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("header_type validation failed"));
    }

    if(SOC_E_NONE != cprimod_hdr_vlan_type_t_validate(cprimod_encap_header_config->vlan_type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("vlan_type validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_encap_header_config_t_init(cprimod_encap_header_config_t* cprimod_encap_header_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_encap_header_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_encap_header_config NULL parameter"));
    }
    sal_memset(cprimod_encap_header_config, 0, sizeof(cprimod_encap_header_config_t));
    cprimod_encap_header_config->header_type = cprimod_hdr_encap_type_roe;
    cprimod_encap_header_config->flow_id = 0xFF;
    cprimod_encap_header_config->roe_subtype = 0;
    cprimod_encap_header_config->ordering_info_index = 0;
    cprimod_encap_header_config->mac_da_index = 0;
    cprimod_encap_header_config->mac_sa_index = 0;
    cprimod_encap_header_config->vlan_type = cprimodHdrVlanTypeUntagged;
    cprimod_encap_header_config->vlan_id_0_index = 0;
    cprimod_encap_header_config->vlan_id_1_index = 0;
    cprimod_encap_header_config->vlan_0_priority = 0;
    cprimod_encap_header_config->vlan_1_priority = 0;
    cprimod_encap_header_config->vlan_eth_type_index = 0;
    cprimod_encap_header_config->use_tagid_for_vlan = 0;
    cprimod_encap_header_config->use_tagid_for_flowid = 0;
    cprimod_encap_header_config->use_opcode = 0;
    cprimod_encap_header_config->roe_opcode = 0;
    cprimod_encap_header_config->version = 0;
    cprimod_encap_header_config->roe_frame_format = CPRIMOD_CPRI_ROE_FRAME_FORMAT_IEEE1914;
    cprimod_encap_header_config->ecpri_pc_id = 0;
    cprimod_encap_header_config->ecpri_msg_type = 0;
    cprimod_encap_header_config->ecpri12_header_byte0 = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_encap_header_config_set(int unit, int port, uint32 queue_num, const cprimod_encap_header_config_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_encap_header_config_t_validate(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_encap_header_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_encap_header_config_set(unit, port, queue_num, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_encap_header_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_encap_header_config_get(int unit, int port, uint32 queue_num, cprimod_encap_header_config_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_encap_header_config_t_init(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_encap_header_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_encap_header_config_get(unit, port, queue_num, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_encap_header_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rx_rsvd4_gsm_tsn_bitmap_set(int unit, int port, uint32 queue_num, uint32 tsn_bitmap)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rx_rsvd4_gsm_tsn_bitmap_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rx_rsvd4_gsm_tsn_bitmap_set(unit, port, queue_num, tsn_bitmap);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rx_rsvd4_gsm_tsn_bitmap_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rx_rsvd4_gsm_tsn_bitmap_get(int unit, int port, uint32 queue_num, uint32* tsn_bitmap)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(tsn_bitmap == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("tsn_bitmap NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rx_rsvd4_gsm_tsn_bitmap_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rx_rsvd4_gsm_tsn_bitmap_get(unit, port, queue_num, tsn_bitmap);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rx_rsvd4_gsm_tsn_bitmap_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_ordering_info_type_t_validate(cprimod_ordering_info_type_t cprimod_ordering_info_type)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_ordering_info_type >= cprimod_ordering_info_type_Count) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_ordering_info_prop_t_validate(cprimod_ordering_info_prop_t cprimod_ordering_info_prop)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_ordering_info_prop >= cprimod_ordering_info_prop_Count) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_encap_ordering_info_entry_t_validate(const cprimod_encap_ordering_info_entry_t* cprimod_encap_ordering_info_entry)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_encap_ordering_info_entry == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != cprimod_ordering_info_type_t_validate(cprimod_encap_ordering_info_entry->type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("type validation failed"));
    }

    if(SOC_E_NONE != cprimod_ordering_info_prop_t_validate(cprimod_encap_ordering_info_entry->pcnt_prop)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pcnt_prop validation failed"));
    }

    if(SOC_E_NONE != cprimod_ordering_info_prop_t_validate(cprimod_encap_ordering_info_entry->qcnt_prop)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("qcnt_prop validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_encap_ordering_info_entry_t_init(cprimod_encap_ordering_info_entry_t* cprimod_encap_ordering_info_entry)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_encap_ordering_info_entry == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_encap_ordering_info_entry NULL parameter"));
    }
    sal_memset(cprimod_encap_ordering_info_entry, 0, sizeof(cprimod_encap_ordering_info_entry_t));
    cprimod_encap_ordering_info_entry->type = cprimod_ordering_info_type_roe_sequence;
    cprimod_encap_ordering_info_entry->pcnt_prop = cprimod_ordering_info_prop_increment_by_constant;
    cprimod_encap_ordering_info_entry->pcnt_size = 1;
    cprimod_encap_ordering_info_entry->pcnt_increment = 0;
    cprimod_encap_ordering_info_entry->pcnt_max = 0;
    cprimod_encap_ordering_info_entry->qcnt_prop = cprimod_ordering_info_prop_increment_by_constant;
    cprimod_encap_ordering_info_entry->qcnt_size = 1;
    cprimod_encap_ordering_info_entry->qcnt_increment = 0;
    cprimod_encap_ordering_info_entry->qcnt_max = 0;
    cprimod_encap_ordering_info_entry->seq_reserve_value = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_decap_ordering_info_entry_t_validate(const cprimod_decap_ordering_info_entry_t* cprimod_decap_ordering_info_entry)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_decap_ordering_info_entry == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != cprimod_ordering_info_type_t_validate(cprimod_decap_ordering_info_entry->type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("type validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_decap_ordering_info_entry_t_init(cprimod_decap_ordering_info_entry_t* cprimod_decap_ordering_info_entry)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_decap_ordering_info_entry == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_decap_ordering_info_entry NULL parameter"));
    }
    sal_memset(cprimod_decap_ordering_info_entry, 0, sizeof(cprimod_decap_ordering_info_entry_t));
    cprimod_decap_ordering_info_entry->type = cprimod_ordering_info_type_roe_sequence;
    cprimod_decap_ordering_info_entry->pcnt_extended = 0;
    cprimod_decap_ordering_info_entry->pcnt_pkt_count = 0;
    cprimod_decap_ordering_info_entry->pcnt_size = 1;
    cprimod_decap_ordering_info_entry->pcnt_increment = 0;
    cprimod_decap_ordering_info_entry->pcnt_max = 0;
    cprimod_decap_ordering_info_entry->pcnt_bias = 0;
    cprimod_decap_ordering_info_entry->pcnt_increment_p2 = 0;
    cprimod_decap_ordering_info_entry->qcnt_size = 1;
    cprimod_decap_ordering_info_entry->qcnt_increment = 0;
    cprimod_decap_ordering_info_entry->qcnt_max = 0;
    cprimod_decap_ordering_info_entry->qcnt_bias = 0;
    cprimod_decap_ordering_info_entry->qcnt_increment_p2 = 0;
    cprimod_decap_ordering_info_entry->modulo_2 = 0;
    cprimod_decap_ordering_info_entry->gsm_tsn_bitmap = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_encap_ordering_info_entry_set(int unit, int port, uint32 index, const cprimod_encap_ordering_info_entry_t* user_entry)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_encap_ordering_info_entry_t_validate(user_entry)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("user_entry validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_encap_ordering_info_entry_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_encap_ordering_info_entry_set(unit, port, index, user_entry);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_encap_ordering_info_entry_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_encap_ordering_info_entry_get(int unit, int port, uint32 index, cprimod_encap_ordering_info_entry_t* user_entry)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(user_entry == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("user_entry NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_encap_ordering_info_entry_t_init(user_entry)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("user_entry initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_encap_ordering_info_entry_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_encap_ordering_info_entry_get(unit, port, index, user_entry);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_encap_ordering_info_entry_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_decap_ordering_info_entry_set(int unit, int port, uint32 index, const cprimod_decap_ordering_info_entry_t* user_entry)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_decap_ordering_info_entry_t_validate(user_entry)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("user_entry validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_decap_ordering_info_entry_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_decap_ordering_info_entry_set(unit, port, index, user_entry);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_decap_ordering_info_entry_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_decap_ordering_info_entry_get(int unit, int port, uint32 index, cprimod_decap_ordering_info_entry_t* user_entry)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(user_entry == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("user_entry NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_decap_ordering_info_entry_t_init(user_entry)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("user_entry initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_decap_ordering_info_entry_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_decap_ordering_info_entry_get(unit, port, index, user_entry);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_decap_ordering_info_entry_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_ordering_info_offset_t_validate(const cprimod_cpri_ordering_info_offset_t* cprimod_cpri_ordering_info_offset)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_cpri_ordering_info_offset == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_cpri_ordering_info_offset_t_init(cprimod_cpri_ordering_info_offset_t* cprimod_cpri_ordering_info_offset)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_cpri_ordering_info_offset == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_cpri_ordering_info_offset NULL parameter"));
    }
    sal_memset(cprimod_cpri_ordering_info_offset, 0, sizeof(cprimod_cpri_ordering_info_offset_t));
    cprimod_cpri_ordering_info_offset->p_size = 1;
    cprimod_cpri_ordering_info_offset->p_offset = 0;
    cprimod_cpri_ordering_info_offset->q_size = 0;
    cprimod_cpri_ordering_info_offset->q_offset = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_encap_ordering_info_sequence_offset_set(int unit, int port, uint32 queue, uint32 control, const cprimod_cpri_ordering_info_offset_t* offset_entry)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_cpri_ordering_info_offset_t_validate(offset_entry)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("offset_entry validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_encap_ordering_info_sequence_offset_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_encap_ordering_info_sequence_offset_set(unit, port, queue, control, offset_entry);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_encap_ordering_info_sequence_offset_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_encap_ordering_info_sequence_offset_get(int unit, int port, uint32 queue, uint32 control, uint32 pcnt_size, uint32 qcnt_size, cprimod_cpri_ordering_info_offset_t* offset_entry)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(offset_entry == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("offset_entry NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_cpri_ordering_info_offset_t_init(offset_entry)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("offset_entry initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_encap_ordering_info_sequence_offset_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_encap_ordering_info_sequence_offset_get(unit, port, queue, control, pcnt_size, qcnt_size, offset_entry);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_encap_ordering_info_sequence_offset_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_decap_ordering_info_sequence_offset_set(int unit, int port, uint32 queue, const cprimod_cpri_ordering_info_offset_t* offset_entry)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_cpri_ordering_info_offset_t_validate(offset_entry)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("offset_entry validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_decap_ordering_info_sequence_offset_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_decap_ordering_info_sequence_offset_set(unit, port, queue, offset_entry);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_decap_ordering_info_sequence_offset_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_decap_ordering_info_sequence_offset_get(int unit, int port, uint32 queue, uint32 pcnt_size, uint32 qcnt_size, cprimod_cpri_ordering_info_offset_t* offset_entry)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(offset_entry == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("offset_entry NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_cpri_ordering_info_offset_t_init(offset_entry)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("offset_entry initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_decap_ordering_info_sequence_offset_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_decap_ordering_info_sequence_offset_get(unit, port, queue, pcnt_size, qcnt_size, offset_entry);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_decap_ordering_info_sequence_offset_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_encap_mac_da_entry_set(int unit, int port, uint32 index, cprimod_mac_addr_t addr)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_encap_mac_da_entry_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_encap_mac_da_entry_set(unit, port, index, addr);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_encap_mac_da_entry_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_encap_mac_da_entry_get(int unit, int port, uint32 index, cprimod_mac_addr_t addr)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_encap_mac_da_entry_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_encap_mac_da_entry_get(unit, port, index, addr);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_encap_mac_da_entry_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_encap_mac_sa_entry_set(int unit, int port, uint32 index, cprimod_mac_addr_t addr)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_encap_mac_sa_entry_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_encap_mac_sa_entry_set(unit, port, index, addr);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_encap_mac_sa_entry_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_encap_mac_sa_entry_get(int unit, int port, uint32 index, cprimod_mac_addr_t addr)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_encap_mac_sa_entry_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_encap_mac_sa_entry_get(unit, port, index, addr);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_encap_mac_sa_entry_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_vlan_table_id_t_validate(cprimod_vlan_table_id_t cprimod_vlan_table_id)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_vlan_table_id >= cprimodVlanTableCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_encap_vlan_id_entry_set(int unit, int port, cprimod_vlan_table_id_t table_id, uint32 index, uint32 vlan_id)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_vlan_table_id_t_validate(table_id)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("table_id validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_encap_vlan_id_entry_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_encap_vlan_id_entry_set(unit, port, table_id, index, vlan_id);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_encap_vlan_id_entry_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_encap_vlan_id_entry_get(int unit, int port, cprimod_vlan_table_id_t table_id, uint32 index, uint32* vlan_id)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_vlan_table_id_t_validate(table_id)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("table_id validation failed"));
    }

    if(vlan_id == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("vlan_id NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_encap_vlan_id_entry_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_encap_vlan_id_entry_get(unit, port, table_id, index, vlan_id);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_encap_vlan_id_entry_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_ethertype_t_validate(cprimod_ethertype_t cprimod_ethertype)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_ethertype >= cprimodEthertypeCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_decap_ethertype_config_set(int unit, int port, cprimod_ethertype_t type_id, uint16 ethertype)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_ethertype_t_validate(type_id)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("type_id validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_decap_ethertype_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_decap_ethertype_config_set(unit, port, type_id, ethertype);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_decap_ethertype_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_decap_ethertype_config_get(int unit, int port, cprimod_ethertype_t type_id, uint16* ethertype)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_ethertype_t_validate(type_id)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("type_id validation failed"));
    }

    if(ethertype == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ethertype NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_decap_ethertype_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_decap_ethertype_config_get(unit, port, type_id, ethertype);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_decap_ethertype_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_encap_ethertype_config_set(int unit, int port, cprimod_ethertype_t type_id, uint16 ethertype)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_ethertype_t_validate(type_id)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("type_id validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_encap_ethertype_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_encap_ethertype_config_set(unit, port, type_id, ethertype);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_encap_ethertype_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_encap_ethertype_config_get(int unit, int port, cprimod_ethertype_t type_id, uint16* ethertype)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_ethertype_t_validate(type_id)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("type_id validation failed"));
    }

    if(ethertype == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ethertype NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_encap_ethertype_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_encap_ethertype_config_get(unit, port, type_id, ethertype);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_encap_ethertype_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_encap_memory_clear(int unit, int port, int queue_num)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_encap_memory_clear) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_encap_memory_clear(unit, port, queue_num);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_encap_memory_clear isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_rx_framer_state_clear(int unit, int port, int queue_num)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_rx_framer_state_clear) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_rx_framer_state_clear(unit, port, queue_num);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_rx_framer_state_clear isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_decap_memory_clear(int unit, int port, int queue_num)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_decap_memory_clear) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_decap_memory_clear(unit, port, queue_num);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_decap_memory_clear isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_tx_framer_state_clear(int unit, int port, int queue_num)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_tx_framer_state_clear) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_tx_framer_state_clear(unit, port, queue_num);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_tx_framer_state_clear isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cls_option_t_validate(cprimod_cls_option_t cprimod_cls_option)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_cls_option >= cprimodClsOptionCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_cls_flow_type_t_validate(cprimod_cls_flow_type_t cprimod_cls_flow_type)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_cls_flow_type >= cprimodClsFlowTypeCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_decap_flow_classification_config_set(int unit, int port, uint8 subtype, uint32 queue_num, cprimod_cls_option_t cls_option, cprimod_cls_flow_type_t flow_type)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_cls_option_t_validate(cls_option)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cls_option validation failed"));
    }

    if(SOC_E_NONE != cprimod_cls_flow_type_t_validate(flow_type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("flow_type validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_decap_flow_classification_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_decap_flow_classification_config_set(unit, port, subtype, queue_num, cls_option, flow_type);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_decap_flow_classification_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_decap_flow_classification_config_get(int unit, int port, uint8 subtype, uint32* queue_num, cprimod_cls_option_t* cls_option, cprimod_cls_flow_type_t* flow_type)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(queue_num == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("queue_num NULL parameter"));
    }
    if(cls_option == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cls_option NULL parameter"));
    }
    if(flow_type == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("flow_type NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_decap_flow_classification_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_decap_flow_classification_config_get(unit, port, subtype, queue_num, cls_option, flow_type);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_decap_flow_classification_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_decap_flow_classification_config_clear(int unit, int port, uint8 subtype)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_decap_flow_classification_config_clear) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_decap_flow_classification_config_clear(unit, port, subtype);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_decap_flow_classification_config_clear isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_decap_flow_to_queue_mapping_set(int unit, int port, uint32 flow_id, uint32 queue_num)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_decap_flow_to_queue_mapping_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_decap_flow_to_queue_mapping_set(unit, port, flow_id, queue_num);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_decap_flow_to_queue_mapping_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_decap_flow_to_queue_mapping_get(int unit, int port, uint32 flow_id, uint32* queue_num)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(queue_num == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("queue_num NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_decap_flow_to_queue_mapping_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_decap_flow_to_queue_mapping_get(unit, port, flow_id, queue_num);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_decap_flow_to_queue_mapping_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_decap_flow_to_queue_mapping_clear(int unit, int port, uint32 flow_id)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_decap_flow_to_queue_mapping_clear) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_decap_flow_to_queue_mapping_clear(unit, port, flow_id);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_decap_flow_to_queue_mapping_clear isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_decap_queue_to_ordering_info_index_mapping_set(int unit, int port, uint32 queue_num, uint32 ordering_info_index)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_decap_queue_to_ordering_info_index_mapping_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_decap_queue_to_ordering_info_index_mapping_set(unit, port, queue_num, ordering_info_index);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_decap_queue_to_ordering_info_index_mapping_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_decap_queue_to_ordering_info_index_mapping_get(int unit, int port, uint32 queue_num, uint32* ordering_info_index)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(ordering_info_index == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ordering_info_index NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_decap_queue_to_ordering_info_index_mapping_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_decap_queue_to_ordering_info_index_mapping_get(unit, port, queue_num, ordering_info_index);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_decap_queue_to_ordering_info_index_mapping_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_tx_framer_tgen_tick_set(int unit, int port, uint32 divider, uint32 basic_frame_tick, uint32 tick_bitmap, uint32 tick_bitmap_size)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_tx_framer_tgen_tick_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_tx_framer_tgen_tick_set(unit, port, divider, basic_frame_tick, tick_bitmap, tick_bitmap_size);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_tx_framer_tgen_tick_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_tx_framer_tgen_tick_get(int unit, int port, uint32* divider, uint32* basic_frame_tick, uint32* tick_bitmap, uint32* tick_bitmap_size)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(divider == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("divider NULL parameter"));
    }
    if(basic_frame_tick == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("basic_frame_tick NULL parameter"));
    }
    if(tick_bitmap == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("tick_bitmap NULL parameter"));
    }
    if(tick_bitmap_size == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("tick_bitmap_size NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_tx_framer_tgen_tick_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_tx_framer_tgen_tick_get(unit, port, divider, basic_frame_tick, tick_bitmap, tick_bitmap_size);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_tx_framer_tgen_tick_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_tx_framer_tgen_enable(int unit, int port, uint8 enable)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_tx_framer_tgen_enable) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_tx_framer_tgen_enable(unit, port, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_tx_framer_tgen_enable isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_tx_framer_tgen_offset_set(int unit, int port, uint64 timestamp_offset)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_tx_framer_tgen_offset_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_tx_framer_tgen_offset_set(unit, port, timestamp_offset);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_tx_framer_tgen_offset_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_tx_framer_tgen_offset_get(int unit, int port, uint64* timestamp_offset)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(timestamp_offset == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("timestamp_offset NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_tx_framer_tgen_offset_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_tx_framer_tgen_offset_get(unit, port, timestamp_offset);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_tx_framer_tgen_offset_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_tx_framer_tgen_next_bfn_config_set(int unit, int port, uint32 tgen_bfn)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_tx_framer_tgen_next_bfn_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_tx_framer_tgen_next_bfn_config_set(unit, port, tgen_bfn);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_tx_framer_tgen_next_bfn_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_tx_framer_tgen_next_bfn_config_get(int unit, int port, uint32* tgen_bfn)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(tgen_bfn == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("tgen_bfn NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_tx_framer_tgen_next_bfn_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_tx_framer_tgen_next_bfn_config_get(unit, port, tgen_bfn);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_tx_framer_tgen_next_bfn_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_tx_framer_tgen_next_hfn_config_set(int unit, int port, uint32 tgen_hfn)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_tx_framer_tgen_next_hfn_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_tx_framer_tgen_next_hfn_config_set(unit, port, tgen_hfn);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_tx_framer_tgen_next_hfn_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_tx_framer_tgen_next_hfn_config_get(int unit, int port, uint32* tgen_hfn)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(tgen_hfn == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("tgen_hfn NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_tx_framer_tgen_next_hfn_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_tx_framer_tgen_next_hfn_config_get(unit, port, tgen_hfn);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_tx_framer_tgen_next_hfn_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_tx_framer_next_bfn_get(int unit, int port, uint32* tgen_bfn)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(tgen_bfn == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("tgen_bfn NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_tx_framer_next_bfn_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_tx_framer_next_bfn_get(unit, port, tgen_bfn);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_tx_framer_next_bfn_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_tx_framer_next_hfn_get(int unit, int port, uint32* tgen_hfn)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(tgen_hfn == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("tgen_hfn NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_tx_framer_next_hfn_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_tx_framer_next_hfn_get(unit, port, tgen_hfn);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_tx_framer_next_hfn_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_tgen_counter_select_t_validate(cprimod_tgen_counter_select_t cprimod_tgen_counter_select)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_tgen_counter_select >= cprimodTgenCounterSelectCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_tx_framer_tgen_select_counter_set(int unit, int port, cprimod_tgen_counter_select_t tgen_counter_select)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_tgen_counter_select_t_validate(tgen_counter_select)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("tgen_counter_select validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_tx_framer_tgen_select_counter_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_tx_framer_tgen_select_counter_set(unit, port, tgen_counter_select);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_tx_framer_tgen_select_counter_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_tx_framer_tgen_select_counter_get(int unit, int port, cprimod_tgen_counter_select_t* tgen_counter_select)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(tgen_counter_select == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("tgen_counter_select NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_tx_framer_tgen_select_counter_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_tx_framer_tgen_select_counter_get(unit, port, tgen_counter_select);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_tx_framer_tgen_select_counter_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_flow_type_t_validate(cprimod_flow_type_t cprimod_flow_type)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_flow_type >= cprimodFlowTypeCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_header_compare_entry_t_validate(const cprimod_header_compare_entry_t* cprimod_header_compare_entry)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_header_compare_entry == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != cprimod_flow_type_t_validate(cprimod_header_compare_entry->flow_type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("flow_type validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_header_compare_entry_t_init(cprimod_header_compare_entry_t* cprimod_header_compare_entry)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_header_compare_entry == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_header_compare_entry NULL parameter"));
    }
    sal_memset(cprimod_header_compare_entry, 0, sizeof(cprimod_header_compare_entry_t));
    cprimod_header_compare_entry->valid = 0;
    cprimod_header_compare_entry->match_data = 0;
    cprimod_header_compare_entry->mask = 0;
    cprimod_header_compare_entry->flow_id = 0;
    cprimod_header_compare_entry->flow_type = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_header_compare_entry_add(int unit, int port, const cprimod_header_compare_entry_t* compare_entry)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_header_compare_entry_t_validate(compare_entry)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("compare_entry validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_header_compare_entry_add) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_header_compare_entry_add(unit, port, compare_entry);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_header_compare_entry_add isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_header_compare_entry_delete(int unit, int port, const cprimod_header_compare_entry_t* compare_entry)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_header_compare_entry_t_validate(compare_entry)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("compare_entry validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_header_compare_entry_delete) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_header_compare_entry_delete(unit, port, compare_entry);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_header_compare_entry_delete isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_header_compare_entry_for_flow_delete(int unit, int port, uint8 flow_id, cprimod_flow_type_t flow_type)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_flow_type_t_validate(flow_type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("flow_type validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_header_compare_entry_for_flow_delete) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_header_compare_entry_for_flow_delete(unit, port, flow_id, flow_type);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_header_compare_entry_for_flow_delete isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_transmission_rule_type_t_validate(cprimod_transmission_rule_type_t cprimod_transmission_rule_type)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_transmission_rule_type >= cprimodTxRuleTypeCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_modulo_rule_mod_t_validate(cprimod_modulo_rule_mod_t cprimod_modulo_rule_mod)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_modulo_rule_mod >= cprimodModuloRuleModCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_modulo_rule_entry_t_validate(const cprimod_modulo_rule_entry_t* cprimod_modulo_rule_entry)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_modulo_rule_entry == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != cprimod_modulo_rule_mod_t_validate(cprimod_modulo_rule_entry->modulo_value)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("modulo_value validation failed"));
    }

    if(SOC_E_NONE != cprimod_flow_type_t_validate(cprimod_modulo_rule_entry->flow_type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("flow_type validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_modulo_rule_entry_t_init(cprimod_modulo_rule_entry_t* cprimod_modulo_rule_entry)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_modulo_rule_entry == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_modulo_rule_entry NULL parameter"));
    }
    sal_memset(cprimod_modulo_rule_entry, 0, sizeof(cprimod_modulo_rule_entry_t));
    cprimod_modulo_rule_entry->active = 0;
    cprimod_modulo_rule_entry->modulo_value = cprimodModuloRuleMod1;
    cprimod_modulo_rule_entry->modulo_index = 0;
    cprimod_modulo_rule_entry->dbm_enable = 0;
    cprimod_modulo_rule_entry->flow_dbm_id = 0;
    cprimod_modulo_rule_entry->flow_type = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_modulo_rule_entry_set(int unit, int port, uint8 modulo_rule_num, cprimod_transmission_rule_type_t modulo_rule_type, const cprimod_modulo_rule_entry_t* modulo_rule)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_transmission_rule_type_t_validate(modulo_rule_type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("modulo_rule_type validation failed"));
    }

    if(SOC_E_NONE != cprimod_modulo_rule_entry_t_validate(modulo_rule)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("modulo_rule validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_modulo_rule_entry_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_modulo_rule_entry_set(unit, port, modulo_rule_num, modulo_rule_type, modulo_rule);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_modulo_rule_entry_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_modulo_rule_entry_get(int unit, int port, uint8 modulo_rule_num, cprimod_transmission_rule_type_t modulo_rule_type, cprimod_modulo_rule_entry_t* modulo_rule)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_transmission_rule_type_t_validate(modulo_rule_type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("modulo_rule_type validation failed"));
    }

    if(modulo_rule == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("modulo_rule NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_modulo_rule_entry_t_init(modulo_rule)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("modulo_rule initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_modulo_rule_entry_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_modulo_rule_entry_get(unit, port, modulo_rule_num, modulo_rule_type, modulo_rule);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_modulo_rule_entry_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_modulo_rule_flow_enable_set(int unit, int port, int enable, cprimod_flow_type_t flow_type, uint32 flow_id)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_flow_type_t_validate(flow_type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("flow_type validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_modulo_rule_flow_enable_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_modulo_rule_flow_enable_set(unit, port, enable, flow_type, flow_id);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_modulo_rule_flow_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_modulo_rule_flow_enable_get(int unit, int port, int* enable, cprimod_flow_type_t flow_type, uint32 flow_id)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_flow_type_t_validate(flow_type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("flow_type validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_modulo_rule_flow_enable_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_modulo_rule_flow_enable_get(unit, port, enable, flow_type, flow_id);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_modulo_rule_flow_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_dbm_rule_pos_index_t_validate(cprimod_dbm_rule_pos_index_t cprimod_dbm_rule_pos_index)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_dbm_rule_pos_index >= cprimodDbmRulePosIndexCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_dbm_rule_pos_grp_size_t_validate(cprimod_dbm_rule_pos_grp_size_t cprimod_dbm_rule_pos_grp_size)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_dbm_rule_pos_grp_size >= cprimodDbmRulePosGrpSizeCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_dbm_rule_entry_t_validate(const cprimod_dbm_rule_entry_t* cprimod_dbm_rule_entry)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_dbm_rule_entry == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != cprimod_dbm_rule_pos_index_t_validate(cprimod_dbm_rule_entry->pos_grp_index)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pos_grp_index validation failed"));
    }

    if(SOC_E_NONE != cprimod_dbm_rule_pos_grp_size_t_validate(cprimod_dbm_rule_entry->pos_grp_size)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pos_grp_size validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_dbm_rule_entry_t_init(cprimod_dbm_rule_entry_t* cprimod_dbm_rule_entry)
{
    int _array_iter;
        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_dbm_rule_entry == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_dbm_rule_entry NULL parameter"));
    }
    sal_memset(cprimod_dbm_rule_entry, 0, sizeof(cprimod_dbm_rule_entry_t));
    cprimod_dbm_rule_entry->bm1_mult = 0;
    for(_array_iter = 0 ; _array_iter < 3 ; _array_iter++){        cprimod_dbm_rule_entry->bm1[_array_iter] = 0;
    }    cprimod_dbm_rule_entry->bm1_size = 0;
    for(_array_iter = 0 ; _array_iter < 2 ; _array_iter++){        cprimod_dbm_rule_entry->bm2[_array_iter] = 0;
    }    cprimod_dbm_rule_entry->bm2_size = 0;
    cprimod_dbm_rule_entry->num_slots = 0;
    cprimod_dbm_rule_entry->pos_grp_index = 0;
    cprimod_dbm_rule_entry->pos_grp_size = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_dual_bitmap_rule_entry_set(int unit, int port, uint8 dbm_rule_num, const cprimod_dbm_rule_entry_t* dbm_rule)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_dbm_rule_entry_t_validate(dbm_rule)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("dbm_rule validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_dual_bitmap_rule_entry_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_dual_bitmap_rule_entry_set(unit, port, dbm_rule_num, dbm_rule);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_dual_bitmap_rule_entry_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_dual_bitmap_rule_entry_get(int unit, int port, uint8 dbm_rule_num, cprimod_dbm_rule_entry_t* dbm_rule)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(dbm_rule == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("dbm_rule NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_dbm_rule_entry_t_init(dbm_rule)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("dbm_rule initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_dual_bitmap_rule_entry_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_dual_bitmap_rule_entry_get(unit, port, dbm_rule_num, dbm_rule);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_dual_bitmap_rule_entry_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_secondary_dbm_rule_entry_t_validate(const cprimod_secondary_dbm_rule_entry_t* cprimod_secondary_dbm_rule_entry)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_secondary_dbm_rule_entry == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_secondary_dbm_rule_entry_t_init(cprimod_secondary_dbm_rule_entry_t* cprimod_secondary_dbm_rule_entry)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_secondary_dbm_rule_entry == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_secondary_dbm_rule_entry NULL parameter"));
    }
    sal_memset(cprimod_secondary_dbm_rule_entry, 0, sizeof(cprimod_secondary_dbm_rule_entry_t));
    cprimod_secondary_dbm_rule_entry->bm1_mult = 0;
    cprimod_secondary_dbm_rule_entry->bm1 = 0;
    cprimod_secondary_dbm_rule_entry->bm1_size = 0;
    cprimod_secondary_dbm_rule_entry->bm2 = 0;
    cprimod_secondary_dbm_rule_entry->bm2_size = 0;
    cprimod_secondary_dbm_rule_entry->num_slots = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_secondary_dual_bitmap_rule_entry_set(int unit, int port, uint8 dbm_rule_num, const cprimod_secondary_dbm_rule_entry_t* dbm_rule)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_secondary_dbm_rule_entry_t_validate(dbm_rule)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("dbm_rule validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_secondary_dual_bitmap_rule_entry_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_secondary_dual_bitmap_rule_entry_set(unit, port, dbm_rule_num, dbm_rule);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_secondary_dual_bitmap_rule_entry_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_secondary_dual_bitmap_rule_entry_get(int unit, int port, uint8 dbm_rule_num, cprimod_secondary_dbm_rule_entry_t* dbm_rule)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(dbm_rule == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("dbm_rule NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_secondary_dbm_rule_entry_t_init(dbm_rule)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("dbm_rule initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_secondary_dual_bitmap_rule_entry_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_secondary_dual_bitmap_rule_entry_get(unit, port, dbm_rule_num, dbm_rule);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_secondary_dual_bitmap_rule_entry_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_dbm_pos_table_entry_t_validate(const cprimod_dbm_pos_table_entry_t* cprimod_dbm_pos_table_entry)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_dbm_pos_table_entry == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != cprimod_flow_type_t_validate(cprimod_dbm_pos_table_entry->flow_type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("flow_type validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_dbm_pos_table_entry_t_init(cprimod_dbm_pos_table_entry_t* cprimod_dbm_pos_table_entry)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_dbm_pos_table_entry == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_dbm_pos_table_entry NULL parameter"));
    }
    sal_memset(cprimod_dbm_pos_table_entry, 0, sizeof(cprimod_dbm_pos_table_entry_t));
    cprimod_dbm_pos_table_entry->valid = 0;
    cprimod_dbm_pos_table_entry->flow_id = 0;
    cprimod_dbm_pos_table_entry->flow_type = 0;
    cprimod_dbm_pos_table_entry->index = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_dbm_position_entry_set(int unit, int port, uint8 index, const cprimod_dbm_pos_table_entry_t* pos_entry)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_dbm_pos_table_entry_t_validate(pos_entry)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pos_entry validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_dbm_position_entry_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_dbm_position_entry_set(unit, port, index, pos_entry);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_dbm_position_entry_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_dbm_position_entry_get(int unit, int port, uint8 index, cprimod_dbm_pos_table_entry_t* pos_entry)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(pos_entry == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pos_entry NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_dbm_pos_table_entry_t_init(pos_entry)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pos_entry initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_dbm_position_entry_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_dbm_position_entry_get(unit, port, index, pos_entry);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_dbm_position_entry_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_dbm_position_flow_enable_set(int unit, int port, int enable, cprimod_flow_type_t flow_type, uint32 flow_id)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_flow_type_t_validate(flow_type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("flow_type validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_dbm_position_flow_enable_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_dbm_position_flow_enable_set(unit, port, enable, flow_type, flow_id);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_dbm_position_flow_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_dbm_position_flow_enable_get(int unit, int port, int* enable, cprimod_flow_type_t flow_type, uint32 flow_id)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_flow_type_t_validate(flow_type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("flow_type validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_dbm_position_flow_enable_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_dbm_position_flow_enable_get(unit, port, enable, flow_type, flow_id);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_dbm_position_flow_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_pcs_mode_t_validate(cprimod_cpri_pcs_mode_t cprimod_cpri_pcs_mode)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_cpri_pcs_mode >= cprimodCpriPcsModeCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_port_speed_t_validate(cprimod_port_speed_t cprimod_port_speed)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_port_speed >= cprimodSpdCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_pll_num_in_use_t_validate(cprimod_pll_num_in_use_t cprimod_pll_num_in_use)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_pll_num_in_use >= cprimodInUseCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_port_interface_type_t_validate(cprimod_port_interface_type_t cprimod_port_interface_type)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_port_interface_type >= cprimodCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_port_encap_type_t_validate(cprimod_port_encap_type_t cprimod_port_encap_type)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_port_encap_type >= cprimodPortEncapCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_port_interface_config_t_validate(const cprimod_port_interface_config_t* cprimod_port_interface_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_port_interface_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != cprimod_port_speed_t_validate(cprimod_port_interface_config->speed)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("speed validation failed"));
    }

    if(SOC_E_NONE != cprimod_port_interface_type_t_validate(cprimod_port_interface_config->interface)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("interface validation failed"));
    }

    if(SOC_E_NONE != cprimod_port_encap_type_t_validate(cprimod_port_interface_config->port_encap_type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("port_encap_type validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_port_interface_config_t_init(cprimod_port_interface_config_t* cprimod_port_interface_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_port_interface_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_port_interface_config NULL parameter"));
    }
    sal_memset(cprimod_port_interface_config, 0, sizeof(cprimod_port_interface_config_t));
    cprimod_port_interface_config->speed = 0;
    cprimod_port_interface_config->interface = 0;
    cprimod_port_interface_config->port_encap_type = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_port_rsvd4_speed_mult_t_validate(cprimod_port_rsvd4_speed_mult_t cprimod_port_rsvd4_speed_mult)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_port_rsvd4_speed_mult >= cprimodRsvd4SpdMultCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_port_rsvd4_config_t_validate(const cprimod_port_rsvd4_config_t* cprimod_port_rsvd4_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_port_rsvd4_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != cprimod_port_rsvd4_speed_mult_t_validate(cprimod_port_rsvd4_config->speed)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("speed validation failed"));
    }

    if(SOC_E_NONE != cprimod_port_interface_type_t_validate(cprimod_port_rsvd4_config->interface)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("interface validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_port_rsvd4_config_t_init(cprimod_port_rsvd4_config_t* cprimod_port_rsvd4_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_port_rsvd4_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_port_rsvd4_config NULL parameter"));
    }
    sal_memset(cprimod_port_rsvd4_config, 0, sizeof(cprimod_port_rsvd4_config_t));
    cprimod_port_rsvd4_config->speed = 0;
    cprimod_port_rsvd4_config->interface = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_port_rx_interface_config_set(int unit, int port, const phymod_phy_access_t* phy, const cprimod_port_interface_config_t* config)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_port_interface_config_t_validate(config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_port_rx_interface_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_port_rx_interface_config_set(unit, port, phy, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_port_rx_interface_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_port_rx_interface_config_get(int unit, int port, cprimod_port_interface_config_t* config)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_port_interface_config_t_init(config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_port_rx_interface_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_port_rx_interface_config_get(unit, port, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_port_rx_interface_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_port_tx_interface_config_set(int unit, int port, const phymod_phy_access_t* phy, const cprimod_port_interface_config_t* config)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_port_interface_config_t_validate(config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_port_tx_interface_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_port_tx_interface_config_set(unit, port, phy, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_port_tx_interface_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_port_tx_interface_config_get(int unit, int port, cprimod_port_interface_config_t* config)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_port_interface_config_t_init(config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_port_tx_interface_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_port_tx_interface_config_get(unit, port, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_port_tx_interface_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_port_rsvd4_rx_config_set(int unit, int port, const cprimod_port_rsvd4_config_t* config)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_port_rsvd4_config_t_validate(config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_rx_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_rx_config_set(unit, port, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_port_rsvd4_rx_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_port_rsvd4_rx_config_get(int unit, int port, cprimod_port_rsvd4_config_t* config)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_port_rsvd4_config_t_init(config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_rx_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_rx_config_get(unit, port, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_port_rsvd4_rx_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_port_rsvd4_tx_config_set(int unit, int port, const cprimod_port_rsvd4_config_t* config)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_port_rsvd4_config_t_validate(config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_tx_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_tx_config_set(unit, port, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_port_rsvd4_tx_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_port_rsvd4_tx_config_get(int unit, int port, cprimod_port_rsvd4_config_t* config)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_port_rsvd4_config_t_init(config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_tx_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_tx_config_get(unit, port, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_port_rsvd4_tx_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rx_config_field_t_validate(cprimod_rx_config_field_t cprimod_rx_config_field)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_rx_config_field >= cprimodRxConfigCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_rsvd4_rx_fsm_state_t_validate(cprimod_rsvd4_rx_fsm_state_t cprimod_rsvd4_rx_fsm_state)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_rsvd4_rx_fsm_state >= cprimodRsvd4RxFsmStateCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_rsvd4_rx_overide_t_validate(cprimod_rsvd4_rx_overide_t cprimod_rsvd4_rx_overide)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_rsvd4_rx_overide >= cprimodRsvd4RxOverideCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_tx_config_field_t_validate(cprimod_tx_config_field_t cprimod_tx_config_field)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_tx_config_field >= cprimodTxConfigCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_rsvd4_tx_fsm_state_t_validate(cprimod_rsvd4_tx_fsm_state_t cprimod_rsvd4_tx_fsm_state)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_rsvd4_tx_fsm_state >= cprimodRsvd4TxFsmStateCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_rsvd4_tx_overide_t_validate(cprimod_rsvd4_tx_overide_t cprimod_rsvd4_tx_overide)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_rsvd4_tx_overide >= cprimodRsvd4TxOverideCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_rx_pcs_status_t_validate(cprimod_rx_pcs_status_t cprimod_rx_pcs_status)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_rx_pcs_status >= cprimodRxPcsStatusCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_port_rx_frame_optional_config_set(int unit, int port, cprimod_rx_config_field_t field, int value)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_rx_config_field_t_validate(field)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("field validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_port_rx_frame_optional_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_port_rx_frame_optional_config_set(unit, port, field, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_port_rx_frame_optional_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_port_rx_frame_optional_config_get(int unit, int port, cprimod_rx_config_field_t field, int* value)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_rx_config_field_t_validate(field)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("field validation failed"));
    }

    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_port_rx_frame_optional_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_port_rx_frame_optional_config_get(unit, port, field, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_port_rx_frame_optional_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_port_tx_frame_optional_config_set(int unit, int port, cprimod_tx_config_field_t field, uint32 value)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_tx_config_field_t_validate(field)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("field validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_port_tx_frame_optional_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_port_tx_frame_optional_config_set(unit, port, field, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_port_tx_frame_optional_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_port_tx_frame_optional_config_get(int unit, int port, cprimod_tx_config_field_t field, uint32* value)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_tx_config_field_t_validate(field)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("field validation failed"));
    }

    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_port_tx_frame_optional_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_port_tx_frame_optional_config_get(unit, port, field, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_port_tx_frame_optional_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_port_rsvd4_rx_frame_optional_config_set(int unit, int port, cprimod_rsvd4_rx_config_field_t field, int value)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_rx_frame_optional_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_rx_frame_optional_config_set(unit, port, field, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_port_rsvd4_rx_frame_optional_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_port_rsvd4_rx_frame_optional_config_get(int unit, int port, cprimod_rsvd4_rx_config_field_t field, int* value)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_rx_frame_optional_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_rx_frame_optional_config_get(unit, port, field, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_port_rsvd4_rx_frame_optional_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_port_rsvd4_rx_speed_set(int unit, int port, const phymod_phy_access_t* phy, cprimod_port_rsvd4_speed_mult_t speed)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_port_rsvd4_speed_mult_t_validate(speed)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("speed validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_rx_speed_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_rx_speed_set(unit, port, phy, speed);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_port_rsvd4_rx_speed_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_port_rsvd4_rx_speed_get(int unit, int port, cprimod_port_rsvd4_speed_mult_t* speed)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(speed == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("speed NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_rx_speed_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_rx_speed_get(unit, port, speed);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_port_rsvd4_rx_speed_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_port_rsvd4_tx_speed_set(int unit, int port, const phymod_phy_access_t* phy, cprimod_port_rsvd4_speed_mult_t speed)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_port_rsvd4_speed_mult_t_validate(speed)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("speed validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_tx_speed_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_tx_speed_set(unit, port, phy, speed);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_port_rsvd4_tx_speed_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_port_rsvd4_tx_speed_get(int unit, int port, cprimod_port_rsvd4_speed_mult_t* speed)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(speed == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("speed NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_tx_speed_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_tx_speed_get(unit, port, speed);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_port_rsvd4_tx_speed_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_port_rsvd4_rx_fsm_state_set(int unit, int port, cprimod_rsvd4_rx_fsm_state_t state)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_rsvd4_rx_fsm_state_t_validate(state)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("state validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_rx_fsm_state_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_rx_fsm_state_set(unit, port, state);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_port_rsvd4_rx_fsm_state_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_port_rsvd4_rx_fsm_state_get(int unit, int port, cprimod_rsvd4_rx_fsm_state_t* state)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(state == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("state NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_rx_fsm_state_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_rx_fsm_state_get(unit, port, state);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_port_rsvd4_rx_fsm_state_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_port_rsvd4_rx_overide_set(int unit, int port, cprimod_rsvd4_rx_overide_t parameter, int enable, int value)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_rsvd4_rx_overide_t_validate(parameter)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("parameter validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_rx_overide_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_rx_overide_set(unit, port, parameter, enable, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_port_rsvd4_rx_overide_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_port_rsvd4_rx_overide_get(int unit, int port, cprimod_rsvd4_rx_overide_t parameter, int* enable, int* value)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_rsvd4_rx_overide_t_validate(parameter)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("parameter validation failed"));
    }

    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_rx_overide_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_rx_overide_get(unit, port, parameter, enable, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_port_rsvd4_rx_overide_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_port_rsvd4_tx_frame_optional_config_set(int unit, int port, cprimod_rsvd4_tx_config_field_t field, int value)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_tx_frame_optional_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_tx_frame_optional_config_set(unit, port, field, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_port_rsvd4_tx_frame_optional_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_port_rsvd4_tx_frame_optional_config_get(int unit, int port, cprimod_rsvd4_tx_config_field_t field, int* value)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_tx_frame_optional_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_tx_frame_optional_config_get(unit, port, field, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_port_rsvd4_tx_frame_optional_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_port_rsvd4_tx_fsm_state_set(int unit, int port, cprimod_rsvd4_tx_fsm_state_t state)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_rsvd4_tx_fsm_state_t_validate(state)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("state validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_tx_fsm_state_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_tx_fsm_state_set(unit, port, state);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_port_rsvd4_tx_fsm_state_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_port_rsvd4_tx_fsm_state_get(int unit, int port, cprimod_rsvd4_tx_fsm_state_t* state)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(state == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("state NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_tx_fsm_state_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_tx_fsm_state_get(unit, port, state);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_port_rsvd4_tx_fsm_state_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_port_rsvd4_tx_overide_set(int unit, int port, cprimod_rsvd4_tx_overide_t parameter, int enable, int value)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_rsvd4_tx_overide_t_validate(parameter)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("parameter validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_tx_overide_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_tx_overide_set(unit, port, parameter, enable, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_port_rsvd4_tx_overide_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_port_rsvd4_tx_overide_get(int unit, int port, cprimod_rsvd4_tx_overide_t parameter, int* enable, int* value)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_rsvd4_tx_overide_t_validate(parameter)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("parameter validation failed"));
    }

    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_tx_overide_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_port_rsvd4_tx_overide_get(unit, port, parameter, enable, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_port_rsvd4_tx_overide_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_port_rx_pcs_status_get(int unit, int port, cprimod_rx_pcs_status_t status, uint32* value)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_rx_pcs_status_t_validate(status)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("status validation failed"));
    }

    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_port_rx_pcs_status_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_port_rx_pcs_status_get(unit, port, status, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_port_rx_pcs_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_polarity_t_validate(const cprimod_polarity_t* cprimod_polarity)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_polarity == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_polarity_t_init(cprimod_polarity_t* cprimod_polarity)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_polarity == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_polarity NULL parameter"));
    }
    sal_memset(cprimod_polarity, 0, sizeof(cprimod_polarity_t));
    cprimod_polarity->rx_polarity = 0x0;
    cprimod_polarity->tx_polarity = 0x0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_lane_map_t_validate(const cprimod_lane_map_t* cprimod_lane_map)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_lane_map == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_lane_map_t_init(cprimod_lane_map_t* cprimod_lane_map)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_lane_map == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_lane_map NULL parameter"));
    }
    sal_memset(cprimod_lane_map, 0, sizeof(cprimod_lane_map_t));
    cprimod_lane_map->num_of_lanes = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_firmware_core_config_t_validate(const cprimod_firmware_core_config_t* cprimod_firmware_core_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_firmware_core_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_firmware_core_config_t_init(cprimod_firmware_core_config_t* cprimod_firmware_core_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_firmware_core_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_firmware_core_config NULL parameter"));
    }
    sal_memset(cprimod_firmware_core_config, 0, sizeof(cprimod_firmware_core_config_t));
    cprimod_firmware_core_config->CoreConfigFromPCS = 0x0;
    cprimod_firmware_core_config->VcoRate = 0;
    cprimod_firmware_core_config->disable_write_pll_iqp = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_firmware_load_force_t_validate(cprimod_firmware_load_force_t cprimod_firmware_load_force)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_firmware_load_force >= cprimodFirmwareLoadCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_firmware_load_method_t_validate(cprimod_firmware_load_method_t cprimod_firmware_load_method)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_firmware_load_method >= cprimodFirmwareLoadMethodCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_tx_input_voltage_t_validate(cprimod_tx_input_voltage_t cprimod_tx_input_voltage)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_tx_input_voltage >= cprimodTxInputVoltageCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_afe_pll_t_validate(const cprimod_afe_pll_t* cprimod_afe_pll)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_afe_pll == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_afe_pll_t_init(cprimod_afe_pll_t* cprimod_afe_pll)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_afe_pll == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_afe_pll NULL parameter"));
    }
    sal_memset(cprimod_afe_pll, 0, sizeof(cprimod_afe_pll_t));
    cprimod_afe_pll->afe_pll_change_default = 0;
    cprimod_afe_pll->ams_pll_iqp = 0xf;
    cprimod_afe_pll->ams_pll_en_hrz = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_pll_parm_t_validate(const cprimod_pll_parm_t* cprimod_pll_parm)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_pll_parm == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != cprimod_afe_pll_t_validate(&cprimod_pll_parm->afe_pll)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("afe_pll validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_pll_parm_t_init(cprimod_pll_parm_t* cprimod_pll_parm)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_pll_parm == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_pll_parm NULL parameter"));
    }
    sal_memset(cprimod_pll_parm, 0, sizeof(cprimod_pll_parm_t));
    cprimod_pll_parm->change_pll = 0xf;
    cprimod_pll_parm->vcoRate = 0xf;
    cprimod_pll_parm->div2 = 0;
    cprimod_pll_parm->div4 = 0;
    if(SOC_E_NONE != cprimod_afe_pll_t_init(&cprimod_pll_parm->afe_pll)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("afe_pll initialization failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_core_init_config_t_validate(const cprimod_core_init_config_t* cprimod_core_init_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_core_init_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != cprimod_lane_map_t_validate(&cprimod_core_init_config->lane_map)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("lane_map validation failed"));
    }

    if(SOC_E_NONE != cprimod_firmware_load_method_t_validate(cprimod_core_init_config->firmware_load_method)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("firmware_load_method validation failed"));
    }

    if(SOC_E_NONE != cprimod_firmware_core_config_t_validate(&cprimod_core_init_config->firmware_core_config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("firmware_core_config validation failed"));
    }

    if(SOC_E_NONE != cprimod_tx_input_voltage_t_validate(cprimod_core_init_config->tx_input_voltage)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("tx_input_voltage validation failed"));
    }

    if(SOC_E_NONE != cprimod_pll_parm_t_validate(&cprimod_core_init_config->pll0)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pll0 validation failed"));
    }

    if(SOC_E_NONE != cprimod_pll_parm_t_validate(&cprimod_core_init_config->pll1)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pll1 validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_core_init_config_t_init(cprimod_core_init_config_t* cprimod_core_init_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_core_init_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_core_init_config NULL parameter"));
    }
    sal_memset(cprimod_core_init_config, 0, sizeof(cprimod_core_init_config_t));
    if(SOC_E_NONE != cprimod_lane_map_t_init(&cprimod_core_init_config->lane_map)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("lane_map initialization failed"));
    }

    cprimod_core_init_config->firmware_load_method = cprimodFirmwareLoadMethodInternal;
    cprimod_core_init_config->firmware_loader = NULL;
    if(SOC_E_NONE != cprimod_firmware_core_config_t_init(&cprimod_core_init_config->firmware_core_config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("firmware_core_config initialization failed"));
    }

    cprimod_core_init_config->flags = 0;
    if(SOC_E_NONE != cprimod_pll_parm_t_init(&cprimod_core_init_config->pll0)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pll0 initialization failed"));
    }

    if(SOC_E_NONE != cprimod_pll_parm_t_init(&cprimod_core_init_config->pll1)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pll1 initialization failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_core_status_t_validate(const cprimod_core_status_t* cprimod_core_status)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_core_status == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_core_status_t_init(cprimod_core_status_t* cprimod_core_status)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_core_status == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_core_status NULL parameter"));
    }
    sal_memset(cprimod_core_status, 0, sizeof(cprimod_core_status_t));

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_core_init(int unit, int port, const phymod_core_access_t* phy, const phymod_core_init_config_t* init_config, phymod_core_status_t* core_status)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(core_status == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("core_status NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_core_init) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_core_init(unit, port, phy, init_config, core_status);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_core_init isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_port_init_config_t_validate(const cprimod_port_init_config_t* cprimod_port_init_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_port_init_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != cprimod_port_interface_type_t_validate(cprimod_port_init_config->interface)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("interface validation failed"));
    }

    if(SOC_E_NONE != cprimod_port_speed_t_validate(cprimod_port_init_config->tx_cpri_speed)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("tx_cpri_speed validation failed"));
    }

    if(SOC_E_NONE != cprimod_port_speed_t_validate(cprimod_port_init_config->rx_cpri_speed)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("rx_cpri_speed validation failed"));
    }

    if(SOC_E_NONE != cprimod_port_rsvd4_speed_mult_t_validate(cprimod_port_init_config->tx_rsvd4_speed)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("tx_rsvd4_speed validation failed"));
    }

    if(SOC_E_NONE != cprimod_port_rsvd4_speed_mult_t_validate(cprimod_port_init_config->rx_rsvd4_speed)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("rx_rsvd4_speed validation failed"));
    }

    if(SOC_E_NONE != cprimod_pll_num_in_use_t_validate(cprimod_port_init_config->pll_in_use)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pll_in_use validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_port_init_config_t_init(cprimod_port_init_config_t* cprimod_port_init_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_port_init_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_port_init_config NULL parameter"));
    }
    sal_memset(cprimod_port_init_config, 0, sizeof(cprimod_port_init_config_t));
    cprimod_port_init_config->tx_params_user_config = 0;
    cprimod_port_init_config->parity_enable = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_port_init(int unit, int port, const phymod_phy_access_t* phy, const cprimod_port_init_config_t* port_config)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_port_init_config_t_validate(port_config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("port_config validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_port_init) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_port_init(unit, port, phy, port_config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_port_init isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rsvd4_rx_master_frame_sync_config_set(int unit, int port, uint32 master_frame_number, uint64 master_frame_start_time)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_rx_master_frame_sync_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_rx_master_frame_sync_config_set(unit, port, master_frame_number, master_frame_start_time);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rsvd4_rx_master_frame_sync_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rsvd4_rx_master_frame_sync_config_get(int unit, int port, uint32* master_frame_number, uint64* master_frame_start_time)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(master_frame_number == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("master_frame_number NULL parameter"));
    }
    if(master_frame_start_time == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("master_frame_start_time NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_rx_master_frame_sync_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_rx_master_frame_sync_config_get(unit, port, master_frame_number, master_frame_start_time);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rsvd4_rx_master_frame_sync_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_rx_control_word_sync_info_get(int unit, int port, uint32* hyper_frame_num, uint32* radio_frame_num)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(hyper_frame_num == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("hyper_frame_num NULL parameter"));
    }
    if(radio_frame_num == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("radio_frame_num NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_rx_control_word_sync_info_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_rx_control_word_sync_info_get(unit, port, hyper_frame_num, radio_frame_num);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_rx_control_word_sync_info_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_rx_control_word_l1_inband_info_get(int unit, int port, cprimod_cpri_cw_l1_inband_info_t* l1_inband_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(l1_inband_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("l1_inband_info NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_rx_control_word_l1_inband_info_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_rx_control_word_l1_inband_info_get(unit, port, l1_inband_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_rx_control_word_l1_inband_info_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_rx_control_word_l1_signal_signal_protection_set(int unit, int port, uint32 signal_map, uint32 enable)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_rx_control_word_l1_signal_signal_protection_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_rx_control_word_l1_signal_signal_protection_set(unit, port, signal_map, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_rx_control_word_l1_signal_signal_protection_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_rx_control_word_l1_signal_signal_protection_get(int unit, int port, uint32 signal_map, uint32* enable)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_rx_control_word_l1_signal_signal_protection_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_rx_control_word_l1_signal_signal_protection_get(unit, port, signal_map, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_rx_control_word_l1_signal_signal_protection_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_hdlc_crc_byte_order_t_validate(cprimod_hdlc_crc_byte_order_t cprimod_hdlc_crc_byte_order)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_hdlc_crc_byte_order >= cprimodHdlcCrcByteOrderCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_hdlc_fcs_err_check_t_validate(cprimod_hdlc_fcs_err_check_t cprimod_hdlc_fcs_err_check)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_hdlc_fcs_err_check >= cprimodHdlcFcsErrCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_slow_hdlc_config_info_t_validate(const cprimod_slow_hdlc_config_info_t* cprimod_slow_hdlc_config_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_slow_hdlc_config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_slow_hdlc_config_info_t_init(cprimod_slow_hdlc_config_info_t* cprimod_slow_hdlc_config_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_slow_hdlc_config_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_slow_hdlc_config_info NULL parameter"));
    }
    sal_memset(cprimod_slow_hdlc_config_info, 0, sizeof(cprimod_slow_hdlc_config_info_t));
    cprimod_slow_hdlc_config_info->tx_crc_mode = 0;
    cprimod_slow_hdlc_config_info->tx_flag_size = 0;
    cprimod_slow_hdlc_config_info->tx_filling_flag_pattern = 0;
    cprimod_slow_hdlc_config_info->crc_init_val = 0;
    cprimod_slow_hdlc_config_info->fcs_size = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_cpri_port_cw_slow_hdlc_config_set(int unit, int port, const cprimod_slow_hdlc_config_info_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_slow_hdlc_config_info_t_validate(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_cw_slow_hdlc_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_cw_slow_hdlc_config_set(unit, port, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_cw_slow_hdlc_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_cw_slow_hdlc_config_get(int unit, int port, cprimod_slow_hdlc_config_info_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_slow_hdlc_config_info_t_init(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_cw_slow_hdlc_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_cw_slow_hdlc_config_get(unit, port, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_cw_slow_hdlc_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_fast_eth_config_info_t_validate(const cprimod_fast_eth_config_info_t* cprimod_fast_eth_config_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_fast_eth_config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_fast_eth_config_info_t_init(cprimod_fast_eth_config_info_t* cprimod_fast_eth_config_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_fast_eth_config_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_fast_eth_config_info NULL parameter"));
    }
    sal_memset(cprimod_fast_eth_config_info, 0, sizeof(cprimod_fast_eth_config_info_t));
    cprimod_fast_eth_config_info->tx_crc_mode = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_cpri_port_cw_fast_eth_config_set(int unit, int port, const cprimod_fast_eth_config_info_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_fast_eth_config_info_t_validate(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_cw_fast_eth_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_cw_fast_eth_config_set(unit, port, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_cw_fast_eth_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_cw_fast_eth_config_get(int unit, int port, cprimod_fast_eth_config_info_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_fast_eth_config_info_t_init(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_cw_fast_eth_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_cw_fast_eth_config_get(unit, port, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_cw_fast_eth_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_rx_vsd_config_info_t_validate(const cprimod_cpri_rx_vsd_config_info_t* cprimod_cpri_rx_vsd_config_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_cpri_rx_vsd_config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_cpri_rx_vsd_config_info_t_init(cprimod_cpri_rx_vsd_config_info_t* cprimod_cpri_rx_vsd_config_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_cpri_rx_vsd_config_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_cpri_rx_vsd_config_info NULL parameter"));
    }
    sal_memset(cprimod_cpri_rx_vsd_config_info, 0, sizeof(cprimod_cpri_rx_vsd_config_info_t));
    cprimod_cpri_rx_vsd_config_info->subchan_size = 0;
    cprimod_cpri_rx_vsd_config_info->subchan_bytes = 0;
    cprimod_cpri_rx_vsd_config_info->flow_bytes = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_cpri_port_rx_vsd_cw_config_set(int unit, int port, const cprimod_cpri_rx_vsd_config_info_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_cpri_rx_vsd_config_info_t_validate(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_vsd_cw_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_vsd_cw_config_set(unit, port, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_rx_vsd_cw_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_rx_vsd_cw_config_get(int unit, int port, cprimod_cpri_rx_vsd_config_info_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_cpri_rx_vsd_config_info_t_init(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_vsd_cw_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_vsd_cw_config_get(unit, port, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_rx_vsd_cw_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_rx_vsd_ctrl_flow_config_xxx_t_validate(const cprimod_cpri_rx_vsd_ctrl_flow_config_xxx_t* cprimod_cpri_rx_vsd_ctrl_flow_config_xxx)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_cpri_rx_vsd_ctrl_flow_config_xxx == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_cpri_rx_vsd_ctrl_flow_config_xxx_t_init(cprimod_cpri_rx_vsd_ctrl_flow_config_xxx_t* cprimod_cpri_rx_vsd_ctrl_flow_config_xxx)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_cpri_rx_vsd_ctrl_flow_config_xxx == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_cpri_rx_vsd_ctrl_flow_config_xxx NULL parameter"));
    }
    sal_memset(cprimod_cpri_rx_vsd_ctrl_flow_config_xxx, 0, sizeof(cprimod_cpri_rx_vsd_ctrl_flow_config_xxx_t));

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_cpri_port_rx_vsd_ctrl_flow_add(int unit, int port, uint32 group_id, const cprimod_cpri_rx_vsd_flow_info_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_vsd_ctrl_flow_add) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_vsd_ctrl_flow_add(unit, port, group_id, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_rx_vsd_ctrl_flow_add isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_rx_vsd_ctrl_flow_delete(int unit, int port, uint32 group_id)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_vsd_ctrl_flow_delete) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_vsd_ctrl_flow_delete(unit, port, group_id);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_rx_vsd_ctrl_flow_delete isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_rx_vsd_ctrl_flow_get(int unit, int port, uint32 group_id, cprimod_cpri_rx_vsd_flow_info_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_vsd_ctrl_flow_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_vsd_ctrl_flow_get(unit, port, group_id, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_rx_vsd_ctrl_flow_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_encap_control_queue_tag_to_flow_id_map_set(int unit, int port, uint32 tag_id, uint32 flow_id)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_encap_control_queue_tag_to_flow_id_map_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_encap_control_queue_tag_to_flow_id_map_set(unit, port, tag_id, flow_id);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_encap_control_queue_tag_to_flow_id_map_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_encap_control_queue_tag_to_flow_id_map_get(int unit, int port, uint32 tag_id, uint32* flow_id)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(flow_id == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("flow_id NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_encap_control_queue_tag_to_flow_id_map_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_encap_control_queue_tag_to_flow_id_map_get(unit, port, tag_id, flow_id);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_encap_control_queue_tag_to_flow_id_map_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_tx_vsd_config_info_t_validate(const cprimod_cpri_tx_vsd_config_info_t* cprimod_cpri_tx_vsd_config_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_cpri_tx_vsd_config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_cpri_tx_vsd_config_info_t_init(cprimod_cpri_tx_vsd_config_info_t* cprimod_cpri_tx_vsd_config_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_cpri_tx_vsd_config_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_cpri_tx_vsd_config_info NULL parameter"));
    }
    sal_memset(cprimod_cpri_tx_vsd_config_info, 0, sizeof(cprimod_cpri_tx_vsd_config_info_t));
    cprimod_cpri_tx_vsd_config_info->subchan_size = 0;
    cprimod_cpri_tx_vsd_config_info->subchan_bytes = 0;
    cprimod_cpri_tx_vsd_config_info->flow_bytes = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_cpri_port_tx_vsd_cw_config_set(int unit, int port, const cprimod_cpri_tx_vsd_config_info_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_cpri_tx_vsd_config_info_t_validate(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_vsd_cw_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_vsd_cw_config_set(unit, port, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_tx_vsd_cw_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_tx_vsd_cw_config_get(int unit, int port, cprimod_cpri_tx_vsd_config_info_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_cpri_tx_vsd_config_info_t_init(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_vsd_cw_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_vsd_cw_config_get(unit, port, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_tx_vsd_cw_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_tx_vsd_flow_config_info_t_validate(const cprimod_cpri_tx_vsd_flow_config_info_t* cprimod_cpri_tx_vsd_flow_config_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_cpri_tx_vsd_flow_config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_cpri_tx_vsd_flow_config_info_t_init(cprimod_cpri_tx_vsd_flow_config_info_t* cprimod_cpri_tx_vsd_flow_config_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_cpri_tx_vsd_flow_config_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_cpri_tx_vsd_flow_config_info NULL parameter"));
    }
    sal_memset(cprimod_cpri_tx_vsd_flow_config_info, 0, sizeof(cprimod_cpri_tx_vsd_flow_config_info_t));

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_cpri_port_tx_vsd_ctrl_flow_add(int unit, int port, uint32 group_id, uint32* group_list, const cprimod_cpri_tx_vsd_flow_info_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(group_list == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("group_list NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_vsd_ctrl_flow_add) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_vsd_ctrl_flow_add(unit, port, group_id, group_list, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_tx_vsd_ctrl_flow_add isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_tx_vsd_ctrl_flow_delete(int unit, int port, uint32 group_id, uint32* group_list)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(group_list == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("group_list NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_vsd_ctrl_flow_delete) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_vsd_ctrl_flow_delete(unit, port, group_id, group_list);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_tx_vsd_ctrl_flow_delete isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_tx_vsd_ctrl_flow_get(int unit, int port, uint32 group_id, uint32* group_list, cprimod_cpri_tx_vsd_flow_info_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(group_list == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("group_list NULL parameter"));
    }
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_vsd_ctrl_flow_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_vsd_ctrl_flow_get(unit, port, group_id, group_list, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_tx_vsd_ctrl_flow_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cw_filter_mode_t_validate(cprimod_cw_filter_mode_t cprimod_cw_filter_mode)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_cw_filter_mode >= cprimodCwFilterCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_cpri_rx_vsd_raw_config_t_validate(const cprimod_cpri_rx_vsd_raw_config_t* cprimod_cpri_rx_vsd_raw_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_cpri_rx_vsd_raw_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_cpri_rx_vsd_raw_config_t_init(cprimod_cpri_rx_vsd_raw_config_t* cprimod_cpri_rx_vsd_raw_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_cpri_rx_vsd_raw_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_cpri_rx_vsd_raw_config NULL parameter"));
    }
    sal_memset(cprimod_cpri_rx_vsd_raw_config, 0, sizeof(cprimod_cpri_rx_vsd_raw_config_t));
    cprimod_cpri_rx_vsd_raw_config->filter_mode = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_cpri_port_rx_vsd_raw_config_set(int unit, int port, uint32 index, const cprimod_cpri_rx_vsd_raw_config_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_cpri_rx_vsd_raw_config_t_validate(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_vsd_raw_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_vsd_raw_config_set(unit, port, index, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_rx_vsd_raw_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_rx_vsd_raw_config_get(int unit, int port, uint32 index, cprimod_cpri_rx_vsd_raw_config_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_cpri_rx_vsd_raw_config_t_init(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_vsd_raw_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_vsd_raw_config_get(unit, port, index, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_rx_vsd_raw_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_vsd_raw_map_mode_t_validate(cprimod_vsd_raw_map_mode_t cprimod_vsd_raw_map_mode)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_vsd_raw_map_mode >= cprimodVsdRawMapModeCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_cpri_tx_vsd_raw_config_t_validate(const cprimod_cpri_tx_vsd_raw_config_t* cprimod_cpri_tx_vsd_raw_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_cpri_tx_vsd_raw_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_cpri_tx_vsd_raw_config_t_init(cprimod_cpri_tx_vsd_raw_config_t* cprimod_cpri_tx_vsd_raw_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_cpri_tx_vsd_raw_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_cpri_tx_vsd_raw_config NULL parameter"));
    }
    sal_memset(cprimod_cpri_tx_vsd_raw_config, 0, sizeof(cprimod_cpri_tx_vsd_raw_config_t));
    cprimod_cpri_tx_vsd_raw_config->map_mode = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_cpri_port_tx_vsd_raw_config_set(int unit, int port, uint32 index, const cprimod_cpri_tx_vsd_raw_config_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_cpri_tx_vsd_raw_config_t_validate(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_vsd_raw_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_vsd_raw_config_set(unit, port, index, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_tx_vsd_raw_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_tx_vsd_raw_config_get(int unit, int port, uint32 index, cprimod_cpri_tx_vsd_raw_config_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_cpri_tx_vsd_raw_config_t_init(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_vsd_raw_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_vsd_raw_config_get(unit, port, index, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_tx_vsd_raw_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_tx_vsd_raw_filter_set(int unit, int port, uint32 bfn0_value, uint32 bfn0_mask, uint32 bfn1_value, uint32 bfn1_mask)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_vsd_raw_filter_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_vsd_raw_filter_set(unit, port, bfn0_value, bfn0_mask, bfn1_value, bfn1_mask);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_tx_vsd_raw_filter_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_tx_vsd_raw_filter_get(int unit, int port, uint32* bfn0_value, uint32* bfn0_mask, uint32* bfn1_value, uint32* bfn1_mask)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(bfn0_value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("bfn0_value NULL parameter"));
    }
    if(bfn0_mask == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("bfn0_mask NULL parameter"));
    }
    if(bfn1_value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("bfn1_value NULL parameter"));
    }
    if(bfn1_mask == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("bfn1_mask NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_vsd_raw_filter_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_vsd_raw_filter_get(unit, port, bfn0_value, bfn0_mask, bfn1_value, bfn1_mask);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_tx_vsd_raw_filter_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_rx_brcm_rsvd5_control_config_set(int unit, int port, uint32 schan_start, uint32 schan_size, uint32 queue_num, int parity_disable)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_brcm_rsvd5_control_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_brcm_rsvd5_control_config_set(unit, port, schan_start, schan_size, queue_num, parity_disable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_rx_brcm_rsvd5_control_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_rx_brcm_rsvd5_control_config_get(int unit, int port, uint32* schan_start, uint32* schan_size, uint32* queue_num, int* parity_disable)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(schan_start == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("schan_start NULL parameter"));
    }
    if(schan_size == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("schan_size NULL parameter"));
    }
    if(queue_num == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("queue_num NULL parameter"));
    }
    if(parity_disable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("parity_disable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_brcm_rsvd5_control_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_brcm_rsvd5_control_config_get(unit, port, schan_start, schan_size, queue_num, parity_disable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_rx_brcm_rsvd5_control_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_tx_brcm_rsvd5_control_config_set(int unit, int port, uint32 schan_start, uint32 schan_size, uint32 queue_num, int crc_enable)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_brcm_rsvd5_control_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_brcm_rsvd5_control_config_set(unit, port, schan_start, schan_size, queue_num, crc_enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_tx_brcm_rsvd5_control_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_tx_brcm_rsvd5_control_config_get(int unit, int port, uint32* schan_start, uint32* schan_size, uint32* queue_num, int* crc_enable)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(schan_start == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("schan_start NULL parameter"));
    }
    if(schan_size == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("schan_size NULL parameter"));
    }
    if(queue_num == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("queue_num NULL parameter"));
    }
    if(crc_enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("crc_enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_brcm_rsvd5_control_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_brcm_rsvd5_control_config_get(unit, port, schan_start, schan_size, queue_num, crc_enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_tx_brcm_rsvd5_control_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_gcw_mask_t_validate(cprimod_gcw_mask_t cprimod_gcw_mask)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_gcw_mask >= cprimodGcwMaskCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_cpri_rx_gcw_config_t_validate(const cprimod_cpri_rx_gcw_config_t* cprimod_cpri_rx_gcw_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_cpri_rx_gcw_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_cpri_rx_gcw_config_t_init(cprimod_cpri_rx_gcw_config_t* cprimod_cpri_rx_gcw_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_cpri_rx_gcw_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_cpri_rx_gcw_config NULL parameter"));
    }
    sal_memset(cprimod_cpri_rx_gcw_config, 0, sizeof(cprimod_cpri_rx_gcw_config_t));
    cprimod_cpri_rx_gcw_config->mask = 0;
    cprimod_cpri_rx_gcw_config->filter_mode = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_cpri_tx_gcw_config_t_validate(const cprimod_cpri_tx_gcw_config_t* cprimod_cpri_tx_gcw_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_cpri_tx_gcw_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_cpri_tx_gcw_config_t_init(cprimod_cpri_tx_gcw_config_t* cprimod_cpri_tx_gcw_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_cpri_tx_gcw_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_cpri_tx_gcw_config NULL parameter"));
    }
    sal_memset(cprimod_cpri_tx_gcw_config, 0, sizeof(cprimod_cpri_tx_gcw_config_t));
    cprimod_cpri_tx_gcw_config->mask = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_cpri_port_rx_gcw_config_set(int unit, int port, uint32 index, const cprimod_cpri_rx_gcw_config_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_cpri_rx_gcw_config_t_validate(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_gcw_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_gcw_config_set(unit, port, index, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_rx_gcw_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_rx_gcw_config_get(int unit, int port, uint32 index, cprimod_cpri_rx_gcw_config_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_cpri_rx_gcw_config_t_init(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_gcw_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_gcw_config_get(unit, port, index, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_rx_gcw_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_tx_gcw_config_set(int unit, int port, uint32 index, const cprimod_cpri_tx_gcw_config_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_cpri_tx_gcw_config_t_validate(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_gcw_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_gcw_config_set(unit, port, index, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_tx_gcw_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_tx_gcw_config_get(int unit, int port, uint32 index, cprimod_cpri_tx_gcw_config_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_cpri_tx_gcw_config_t_init(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_gcw_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_gcw_config_get(unit, port, index, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_tx_gcw_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_tx_gcw_filter_set(int unit, int port, uint32 bfn0_value, uint32 bfn0_mask, uint32 bfn1_value, uint32 bfn1_mask)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_gcw_filter_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_gcw_filter_set(unit, port, bfn0_value, bfn0_mask, bfn1_value, bfn1_mask);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_tx_gcw_filter_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_tx_gcw_filter_get(int unit, int port, uint32* bfn0_value, uint32* bfn0_mask, uint32* bfn1_value, uint32* bfn1_mask)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(bfn0_value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("bfn0_value NULL parameter"));
    }
    if(bfn0_mask == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("bfn0_mask NULL parameter"));
    }
    if(bfn1_value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("bfn1_value NULL parameter"));
    }
    if(bfn1_mask == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("bfn1_mask NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_gcw_filter_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_gcw_filter_get(unit, port, bfn0_value, bfn0_mask, bfn1_value, bfn1_mask);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_tx_gcw_filter_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_tx_control_word_t_validate(const cprimod_cpri_tx_control_word_t* cprimod_cpri_tx_control_word)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_cpri_tx_control_word == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_cpri_tx_control_word_t_init(cprimod_cpri_tx_control_word_t* cprimod_cpri_tx_control_word)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_cpri_tx_control_word == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_cpri_tx_control_word NULL parameter"));
    }
    sal_memset(cprimod_cpri_tx_control_word, 0, sizeof(cprimod_cpri_tx_control_word_t));

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_cpri_tx_control_word_l1_inband_info_set(int unit, int port, const cprimod_cpri_cw_l1_inband_info_t* control_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_tx_control_word_l1_inband_info_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_tx_control_word_l1_inband_info_set(unit, port, control_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_tx_control_word_l1_inband_info_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_tx_control_word_l1_inband_info_get(int unit, int port, cprimod_cpri_cw_l1_inband_info_t* control_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(control_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control_info NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_tx_control_word_l1_inband_info_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_tx_control_word_l1_inband_info_get(unit, port, control_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_tx_control_word_l1_inband_info_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rsvd4_rx_control_message_config_set(int unit, int port, uint32 queue_num, uint32 default_tag, uint32 no_match_tag)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_rx_control_message_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_rx_control_message_config_set(unit, port, queue_num, default_tag, no_match_tag);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rsvd4_rx_control_message_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_control_flow_config_t_validate(const cprimod_control_flow_config_t* cprimod_control_flow_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_control_flow_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_control_flow_config_t_init(cprimod_control_flow_config_t* cprimod_control_flow_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_control_flow_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_control_flow_config NULL parameter"));
    }
    sal_memset(cprimod_control_flow_config, 0, sizeof(cprimod_control_flow_config_t));
    cprimod_control_flow_config->proc_type = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_rsvd4_rx_control_flow_config_set(int unit, int port, uint32 flow_id, const cprimod_control_flow_config_t* config)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_control_flow_config_t_validate(config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_rx_control_flow_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_rx_control_flow_config_set(unit, port, flow_id, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rsvd4_rx_control_flow_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rsvd4_rx_control_flow_config_get(int unit, int port, uint32 flow_id, cprimod_control_flow_config_t* config)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_control_flow_config_t_init(config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_rx_control_flow_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_rx_control_flow_config_get(unit, port, flow_id, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rsvd4_rx_control_flow_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_sync_profile_entry_t_validate(const cprimod_sync_profile_entry_t* cprimod_sync_profile_entry)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_sync_profile_entry == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_sync_profile_entry_t_init(cprimod_sync_profile_entry_t* cprimod_sync_profile_entry)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_sync_profile_entry == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_sync_profile_entry NULL parameter"));
    }
    sal_memset(cprimod_sync_profile_entry, 0, sizeof(cprimod_sync_profile_entry_t));
    cprimod_sync_profile_entry->count_cycle = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_rsvd4_rx_sync_profile_entry_set(int unit, int port, uint32 profile_id, const cprimod_sync_profile_entry_t* entry)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_sync_profile_entry_t_validate(entry)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("entry validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_rx_sync_profile_entry_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_rx_sync_profile_entry_set(unit, port, profile_id, entry);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rsvd4_rx_sync_profile_entry_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rsvd4_rx_sync_profile_entry_get(int unit, int port, uint32 profile_id, cprimod_sync_profile_entry_t* entry)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(entry == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("entry NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_sync_profile_entry_t_init(entry)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("entry initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_rx_sync_profile_entry_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_rx_sync_profile_entry_get(unit, port, profile_id, entry);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rsvd4_rx_sync_profile_entry_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rx_tag_config_set(int unit, int port, uint32 default_tag, uint32 no_match_tag)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rx_tag_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rx_tag_config_set(unit, port, default_tag, no_match_tag);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rx_tag_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rx_tag_gen_entry_add(int unit, int port, const cprimod_tag_gen_entry_t* entry)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rx_tag_gen_entry_add) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rx_tag_gen_entry_add(unit, port, entry);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rx_tag_gen_entry_add isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rx_tag_gen_entry_delete(int unit, int port, const cprimod_tag_gen_entry_t* entry)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rx_tag_gen_entry_delete) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rx_tag_gen_entry_delete(unit, port, entry);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rx_tag_gen_entry_delete isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rx_control_flow_tag_option_set(int unit, int port, uint32 flow_id, cprimod_cpri_tag_option_t tag_option)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rx_control_flow_tag_option_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rx_control_flow_tag_option_set(unit, port, flow_id, tag_option);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rx_control_flow_tag_option_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rsvd4_tx_control_flow_group_member_add(int unit, int port, uint32 group_id, uint32 priority, uint32 queue_num, cprimod_control_msg_proc_type_t proc_type)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_tx_control_flow_group_member_add) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_tx_control_flow_group_member_add(unit, port, group_id, priority, queue_num, proc_type);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rsvd4_tx_control_flow_group_member_add isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rsvd4_tx_control_flow_group_member_delete(int unit, int port, uint32 group_id, uint32 priority)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_tx_control_flow_group_member_delete) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_tx_control_flow_group_member_delete(unit, port, group_id, priority);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rsvd4_tx_control_flow_group_member_delete isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rsvd4_tx_eth_message_config_set(int unit, int port, uint32 msg_node, uint32 msg_subnode, uint32 msg_type, uint32 msg_padding)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_tx_eth_message_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_tx_eth_message_config_set(unit, port, msg_node, msg_subnode, msg_type, msg_padding);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rsvd4_tx_eth_message_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rsvd4_tx_single_raw_message_config_set(int unit, int port, uint32 msg_id, uint32 msg_type)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_tx_single_raw_message_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_tx_single_raw_message_config_set(unit, port, msg_id, msg_type);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rsvd4_tx_single_raw_message_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rsvd4_tx_single_tunnel_message_config_set(int unit, int port, cprimod_cpri_crc_option_t crc_option)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_tx_single_tunnel_message_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_tx_single_tunnel_message_config_set(unit, port, crc_option);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rsvd4_tx_single_tunnel_message_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rsvd4_tx_config_info_t_validate(const cprimod_rsvd4_tx_config_info_t* cprimod_rsvd4_tx_config_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_rsvd4_tx_config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_rsvd4_tx_config_info_t_init(cprimod_rsvd4_tx_config_info_t* cprimod_rsvd4_tx_config_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_rsvd4_tx_config_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_rsvd4_tx_config_info NULL parameter"));
    }
    sal_memset(cprimod_rsvd4_tx_config_info, 0, sizeof(cprimod_rsvd4_tx_config_info_t));
    cprimod_rsvd4_tx_config_info->proc_type = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_rsvd4_tx_control_flow_config_set(int unit, int port, uint32 flow_id, const cprimod_rsvd4_tx_config_info_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_rsvd4_tx_config_info_t_validate(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_tx_control_flow_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_tx_control_flow_config_set(unit, port, flow_id, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rsvd4_tx_control_flow_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rsvd4_tx_control_flow_config_get(int unit, int port, uint32 flow_id, cprimod_rsvd4_tx_config_info_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_rsvd4_tx_config_info_t_init(config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_tx_control_flow_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_tx_control_flow_config_get(unit, port, flow_id, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rsvd4_tx_control_flow_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rsvd4_tx_control_flow_header_index_set(int unit, int port, uint32 roe_flow_id, uint32 index)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_tx_control_flow_header_index_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_tx_control_flow_header_index_set(unit, port, roe_flow_id, index);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rsvd4_tx_control_flow_header_index_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rsvd4_tx_control_flow_header_index_get(int unit, int port, uint32 roe_flow_id, uint32* index)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(index == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("index NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_tx_control_flow_header_index_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_tx_control_flow_header_index_get(unit, port, roe_flow_id, index);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rsvd4_tx_control_flow_header_index_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rsvd4_tx_control_header_entry_set(int unit, int port, uint32 index, uint32 header_node, uint32 header_subnode, uint32 payload_node)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_tx_control_header_entry_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_tx_control_header_entry_set(unit, port, index, header_node, header_subnode, payload_node);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rsvd4_tx_control_header_entry_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rsvd4_tx_control_header_entry_get(int unit, int port, uint32 index, uint32* header_node, uint32* header_subnode, uint32* payload_node)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(header_node == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("header_node NULL parameter"));
    }
    if(header_subnode == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("header_subnode NULL parameter"));
    }
    if(payload_node == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("payload_node NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_tx_control_header_entry_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_tx_control_header_entry_get(unit, port, index, header_node, header_subnode, payload_node);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rsvd4_tx_control_header_entry_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rsvd4_fast_eth_config_set(int unit, int port, const cprimod_cpri_fast_eth_config_t* config_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_fast_eth_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_fast_eth_config_set(unit, port, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rsvd4_fast_eth_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_or_enet_port_set(int unit, int port, int val)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_or_enet_port_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_or_enet_port_set(unit, port, val);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_or_enet_port_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_or_enet_port_get(int unit, int port, int* val)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(val == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("val NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_or_enet_port_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_or_enet_port_get(unit, port, val);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_or_enet_port_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_rx_enable_set(int unit, int port, int val)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_enable_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_enable_set(unit, port, val);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_rx_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_rx_enable_get(int unit, int port, int* val)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(val == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("val NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_enable_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_enable_get(unit, port, val);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_rx_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_tx_enable_set(int unit, int port, int val)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_enable_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_enable_set(unit, port, val);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_tx_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_tx_enable_get(int unit, int port, int* val)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(val == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("val NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_enable_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_enable_get(unit, port, val);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_tx_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_interrupt_link_status_get(int unit, int port, const int* is_link_intr_status)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_interrupt_link_status_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_interrupt_link_status_get(unit, port, is_link_intr_status);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_interrupt_link_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_interrupt_callback_entry_t_validate(const cprimod_interrupt_callback_entry_t* cprimod_interrupt_callback_entry)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_interrupt_callback_entry == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_interrupt_callback_entry_t_init(cprimod_interrupt_callback_entry_t* cprimod_interrupt_callback_entry)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_interrupt_callback_entry == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_interrupt_callback_entry NULL parameter"));
    }
    sal_memset(cprimod_interrupt_callback_entry, 0, sizeof(cprimod_interrupt_callback_entry_t));
    cprimod_interrupt_callback_entry->cb_func = NULL;
    cprimod_interrupt_callback_entry->cb_data = NULL;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_cpri_port_interrupt_enable_set(int unit, int port, cprimod_cpri_port_intr_type_t cpri_intr_type, int data, int enable)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_interrupt_enable_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_interrupt_enable_set(unit, port, cpri_intr_type, data, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_interrupt_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_interrupt_enable_get(int unit, int port, cprimod_cpri_port_intr_type_t cpri_intr_type, int data, int* enable)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_interrupt_enable_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_interrupt_enable_get(unit, port, cpri_intr_type, data, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_interrupt_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_interrupt_process(int unit, int port)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_interrupt_process) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_interrupt_process(unit, port);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_interrupt_process isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_1588_capture_mode_t_validate(cprimod_1588_capture_mode_t cprimod_1588_capture_mode)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_1588_capture_mode >= cprimod_1588_MATCH_Count) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_1588_capture_config_t_validate(const cprimod_1588_capture_config_t* cprimod_1588_capture_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_1588_capture_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != cprimod_1588_capture_mode_t_validate(cprimod_1588_capture_config->mode)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_1588_capture_config_t_init(cprimod_1588_capture_config_t* cprimod_1588_capture_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_1588_capture_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_1588_capture_config NULL parameter"));
    }
    sal_memset(cprimod_1588_capture_config, 0, sizeof(cprimod_1588_capture_config_t));
    cprimod_1588_capture_config->mode = 0;
    cprimod_1588_capture_config->capture_bfn_num = 0;
    cprimod_1588_capture_config->capture_hfn_num = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_1588_time_t_validate(const cprimod_1588_time_t* cprimod_1588_time)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_1588_time == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_1588_time_t_init(cprimod_1588_time_t* cprimod_1588_time)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_1588_time == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_1588_time NULL parameter"));
    }
    sal_memset(cprimod_1588_time, 0, sizeof(cprimod_1588_time_t));
    COMPILER_64_ZERO(cprimod_1588_time->nano_sec);
    cprimod_1588_time->sub_nano_sec = 0;
    cprimod_1588_time->sign_bit = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_fast_clk_bit_time_period_set(int unit, int port, uint32 bit_time_period)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_fast_clk_bit_time_period_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_fast_clk_bit_time_period_set(unit, port, bit_time_period);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_fast_clk_bit_time_period_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_fast_clk_bit_time_period_get(int unit, int port, uint32* bit_time_period)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(bit_time_period == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("bit_time_period NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_fast_clk_bit_time_period_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_fast_clk_bit_time_period_get(unit, port, bit_time_period);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_fast_clk_bit_time_period_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_1588_bit_time_period_set(int unit, int port, cprimod_direction_t direction, cprimod_port_speed_t speed)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_port_speed_t_validate(speed)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("speed validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_1588_bit_time_period_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_1588_bit_time_period_set(unit, port, direction, speed);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_1588_bit_time_period_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_1588_bit_time_period_get(int unit, int port, cprimod_direction_t direction, uint32* bit_time_period)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(bit_time_period == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("bit_time_period NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_1588_bit_time_period_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_1588_bit_time_period_get(unit, port, direction, bit_time_period);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_1588_bit_time_period_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_1588_timestamp_capture_config_set(int unit, int port, cprimod_direction_t direction, const cprimod_1588_capture_config_t* config)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_1588_capture_config_t_validate(config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_1588_timestamp_capture_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_1588_timestamp_capture_config_set(unit, port, direction, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_1588_timestamp_capture_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_1588_timestamp_capture_config_get(int unit, int port, cprimod_direction_t direction, cprimod_1588_capture_config_t* config)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_1588_capture_config_t_init(config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_1588_timestamp_capture_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_1588_timestamp_capture_config_get(unit, port, direction, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_1588_timestamp_capture_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_1588_captured_timestamp_get(int unit, int port, cprimod_direction_t direction, uint8 fifo0_sw1, uint8 mx_cnt, uint8* count, uint64* captured_time)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(count == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("count NULL parameter"));
    }
    if(captured_time == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("captured_time NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_1588_captured_timestamp_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_1588_captured_timestamp_get(unit, port, direction, fifo0_sw1, mx_cnt, count, captured_time);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_1588_captured_timestamp_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_1588_timestamp_adjust_set(int unit, int port, cprimod_direction_t direction, const cprimod_1588_time_t* adjust_time)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_1588_time_t_validate(adjust_time)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("adjust_time validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_1588_timestamp_adjust_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_1588_timestamp_adjust_set(unit, port, direction, adjust_time);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_1588_timestamp_adjust_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_1588_timestamp_adjust_get(int unit, int port, cprimod_direction_t direction, cprimod_1588_time_t* adjust_time)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(adjust_time == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("adjust_time NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_1588_time_t_init(adjust_time)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("adjust_time initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_1588_timestamp_adjust_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_1588_timestamp_adjust_get(unit, port, direction, adjust_time);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_1588_timestamp_adjust_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_1588_timestamp_fifo_config_set(int unit, int port, cprimod_direction_t direction, uint16 modulo)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_1588_timestamp_fifo_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_1588_timestamp_fifo_config_set(unit, port, direction, modulo);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_1588_timestamp_fifo_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_1588_timestamp_fifo_config_get(int unit, int port, cprimod_direction_t direction, uint16* modulo)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(modulo == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("modulo NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_1588_timestamp_fifo_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_1588_timestamp_fifo_config_get(unit, port, direction, modulo);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_1588_timestamp_fifo_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_1588_timestamp_cmic_config_set(int unit, int port, cprimod_direction_t direction, uint16 modulo)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_1588_timestamp_cmic_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_1588_timestamp_cmic_config_set(unit, port, direction, modulo);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_1588_timestamp_cmic_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_1588_timestamp_cmic_config_get(int unit, int port, cprimod_direction_t direction, uint16* modulo)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(modulo == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("modulo NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_1588_timestamp_cmic_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_1588_timestamp_cmic_config_get(unit, port, direction, modulo);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_1588_timestamp_cmic_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_basic_frame_info_get(int unit, int port, cprimod_direction_t dir, uint32* frame_len_in_bits, uint32* control_word_len_in_bits)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(frame_len_in_bits == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("frame_len_in_bits NULL parameter"));
    }
    if(control_word_len_in_bits == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control_word_len_in_bits NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_basic_frame_info_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_basic_frame_info_get(unit, port, dir, frame_len_in_bits, control_word_len_in_bits);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_basic_frame_info_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_agnostic_mode_basic_frame_config_set(int unit, int port, cprimod_direction_t dir, int enable)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_agnostic_mode_basic_frame_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_agnostic_mode_basic_frame_config_set(unit, port, dir, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_agnostic_mode_basic_frame_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_interface_bus_width_get(int unit, int port, int* is_10bit_mode)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(is_10bit_mode == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("is_10bit_mode NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_interface_bus_width_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_interface_bus_width_get(unit, port, is_10bit_mode);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_interface_bus_width_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_tunnel_mode_basic_frame_config_set(int unit, int port, cprimod_direction_t dir, int enable, int restore_rsvd4)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_tunnel_mode_basic_frame_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_tunnel_mode_basic_frame_config_set(unit, port, dir, enable, restore_rsvd4);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_tunnel_mode_basic_frame_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rsvd4_agnostic_mode_basic_frame_config_set(int unit, int port, cprimod_direction_t dir, int enable)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_agnostic_mode_basic_frame_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_agnostic_mode_basic_frame_config_set(unit, port, dir, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rsvd4_agnostic_mode_basic_frame_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_encap_presentation_time_enable_set(int unit, int port, int enable)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_encap_presentation_time_enable_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_encap_presentation_time_enable_set(unit, port, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_encap_presentation_time_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_encap_presentation_time_enable_get(int unit, int port, int* enable)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_encap_presentation_time_enable_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_encap_presentation_time_enable_get(unit, port, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_encap_presentation_time_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_encap_presentation_time_config_t_validate(const cprimod_encap_presentation_time_config_t* cprimod_encap_presentation_time_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_encap_presentation_time_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_encap_presentation_time_config_t_init(cprimod_encap_presentation_time_config_t* cprimod_encap_presentation_time_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_encap_presentation_time_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_encap_presentation_time_config NULL parameter"));
    }
    sal_memset(cprimod_encap_presentation_time_config, 0, sizeof(cprimod_encap_presentation_time_config_t));
    cprimod_encap_presentation_time_config->mod_count = 0;
    cprimod_encap_presentation_time_config->frame_sync_mode = 0;
    cprimod_encap_presentation_time_config->radio_frame_offset = 0;
    cprimod_encap_presentation_time_config->hyper_frame_offset = 0;
    cprimod_encap_presentation_time_config->approx_inc_disable = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_encap_presentation_time_config_set(int unit, int port, const cprimod_encap_presentation_time_config_t* config)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_encap_presentation_time_config_t_validate(config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_encap_presentation_time_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_encap_presentation_time_config_set(unit, port, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_encap_presentation_time_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_encap_presentation_time_config_get(int unit, int port, cprimod_encap_presentation_time_config_t* config)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_encap_presentation_time_config_t_init(config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_encap_presentation_time_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_encap_presentation_time_config_get(unit, port, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_encap_presentation_time_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_encap_presentation_time_adjust_set(int unit, int port, uint32 time)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_encap_presentation_time_adjust_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_encap_presentation_time_adjust_set(unit, port, time);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_encap_presentation_time_adjust_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_encap_presentation_time_adjust_get(int unit, int port, uint32* time)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(time == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("time NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_encap_presentation_time_adjust_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_encap_presentation_time_adjust_get(unit, port, time);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_encap_presentation_time_adjust_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_encap_presentation_time_approximate_increment_set(int unit, int port, uint32 time)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_encap_presentation_time_approximate_increment_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_encap_presentation_time_approximate_increment_set(unit, port, time);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_encap_presentation_time_approximate_increment_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_encap_presentation_time_approximate_increment_get(int unit, int port, uint32* time)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(time == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("time NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_encap_presentation_time_approximate_increment_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_encap_presentation_time_approximate_increment_get(unit, port, time);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_encap_presentation_time_approximate_increment_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_decap_agnostic_mode_enable_set(int unit, int port, int enable, cprimod_cpri_roe_ordering_info_option_t mode)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_decap_agnostic_mode_enable_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_decap_agnostic_mode_enable_set(unit, port, enable, mode);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_decap_agnostic_mode_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_decap_agnostic_mode_enable_get(int unit, int port, int* enable, cprimod_cpri_roe_ordering_info_option_t* mode)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    if(mode == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_decap_agnostic_mode_enable_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_decap_agnostic_mode_enable_get(unit, port, enable, mode);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_decap_agnostic_mode_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_decap_agnostic_mode_config_t_validate(const cprimod_decap_agnostic_mode_config_t* cprimod_decap_agnostic_mode_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_decap_agnostic_mode_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_decap_agnostic_mode_config_t_init(cprimod_decap_agnostic_mode_config_t* cprimod_decap_agnostic_mode_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_decap_agnostic_mode_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_decap_agnostic_mode_config NULL parameter"));
    }
    sal_memset(cprimod_decap_agnostic_mode_config, 0, sizeof(cprimod_decap_agnostic_mode_config_t));
    cprimod_decap_agnostic_mode_config->mod_count = 0;
    cprimod_decap_agnostic_mode_config->packet_size = 0;
    cprimod_decap_agnostic_mode_config->queue_num = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_decap_agnostic_mode_config_set(int unit, int port, const cprimod_decap_agnostic_mode_config_t* config)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_decap_agnostic_mode_config_t_validate(config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_decap_agnostic_mode_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_decap_agnostic_mode_config_set(unit, port, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_decap_agnostic_mode_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_decap_agnostic_mode_config_get(int unit, int port, cprimod_decap_agnostic_mode_config_t* config)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_decap_agnostic_mode_config_t_init(config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_decap_agnostic_mode_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_decap_agnostic_mode_config_get(unit, port, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_decap_agnostic_mode_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_decap_presentation_time_config_set(int unit, int port, uint32 mod_offset, uint32 mod_count)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_decap_presentation_time_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_decap_presentation_time_config_set(unit, port, mod_offset, mod_count);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_decap_presentation_time_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_decap_presentation_time_config_get(int unit, int port, uint32* mod_offset, uint32* mod_count)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(mod_offset == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mod_offset NULL parameter"));
    }
    if(mod_count == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mod_count NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_decap_presentation_time_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_decap_presentation_time_config_get(unit, port, mod_offset, mod_count);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_decap_presentation_time_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_compression_lookup_table_set(int unit, int port, int table_depth, const uint32* table)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_compression_lookup_table_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_compression_lookup_table_set(unit, port, table_depth, table);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_compression_lookup_table_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_compression_lookup_table_get(int unit, int port, int max_depth, int* table_depth, uint32* table)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(table_depth == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("table_depth NULL parameter"));
    }
    if(table == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("table NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_compression_lookup_table_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_compression_lookup_table_get(unit, port, max_depth, table_depth, table);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_compression_lookup_table_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_decompression_lookup_table_set(int unit, int port, int table_depth, const uint32* table)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_decompression_lookup_table_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_decompression_lookup_table_set(unit, port, table_depth, table);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_decompression_lookup_table_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_decompression_lookup_table_get(int unit, int port, int max_depth, int* table_depth, uint32* table)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(table_depth == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("table_depth NULL parameter"));
    }
    if(table == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("table NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_decompression_lookup_table_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_decompression_lookup_table_get(unit, port, max_depth, table_depth, table);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_decompression_lookup_table_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_decap_queue_flow_control_set(int unit, int port, uint32 queue_num, int enable, uint32_t xon_threshold, uint32_t xoff_threshold)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_decap_queue_flow_control_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_decap_queue_flow_control_set(unit, port, queue_num, enable, xon_threshold, xoff_threshold);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_decap_queue_flow_control_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_decap_queue_flow_control_get(int unit, int port, uint32 queue_num, int* enable, uint32_t* xon_threshold, uint32_t* xoff_threshold)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    if(xon_threshold == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("xon_threshold NULL parameter"));
    }
    if(xoff_threshold == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("xoff_threshold NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_decap_queue_flow_control_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_decap_queue_flow_control_get(unit, port, queue_num, enable, xon_threshold, xoff_threshold);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_decap_queue_flow_control_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_fec_timestamp_config_t_validate(const cprimod_fec_timestamp_config_t* cprimod_fec_timestamp_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_fec_timestamp_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_fec_timestamp_config_t_init(cprimod_fec_timestamp_config_t* cprimod_fec_timestamp_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_fec_timestamp_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_fec_timestamp_config NULL parameter"));
    }
    sal_memset(cprimod_fec_timestamp_config, 0, sizeof(cprimod_fec_timestamp_config_t));
    cprimod_fec_timestamp_config->enable = 0;
    cprimod_fec_timestamp_config->fec_fifo_ts_source_select = 1;
    cprimod_fec_timestamp_config->fec_cmic_ts_source_select = 0;
    cprimod_fec_timestamp_config->control_bit_offset_0 = 0;
    cprimod_fec_timestamp_config->control_bit_offset_1 = 0x45;
    cprimod_fec_timestamp_config->control_bit_offset_2 = 0x85;
    cprimod_fec_timestamp_config->control_bit_offset_3 = 0xc5;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_cpri_port_fec_enable_set(int unit, int port, cprimod_direction_t dir, int enable)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_fec_enable_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_fec_enable_set(unit, port, dir, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_fec_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_fec_enable_get(int unit, int port, cprimod_direction_t dir, int* enable)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_fec_enable_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_fec_enable_get(unit, port, dir, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_fec_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_fec_timestamp_config_set(int unit, int port, cprimod_direction_t dir, const cprimod_fec_timestamp_config_t* config)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_fec_timestamp_config_t_validate(config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_fec_timestamp_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_fec_timestamp_config_set(unit, port, dir, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_fec_timestamp_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_fec_timestamp_config_get(int unit, int port, cprimod_direction_t dir, const cprimod_fec_timestamp_config_t* config)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_fec_timestamp_config_t_validate(config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_fec_timestamp_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_fec_timestamp_config_get(unit, port, dir, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_fec_timestamp_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_fec_aux_config_set(int unit, int port, cprimod_fec_aux_config_para_t parameter_id, uint32 value)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_fec_aux_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_fec_aux_config_set(unit, port, parameter_id, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_fec_aux_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_fec_aux_config_get(int unit, int port, cprimod_fec_aux_config_para_t parameter_id, const uint32* value)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_fec_aux_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_fec_aux_config_get(unit, port, parameter_id, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_fec_aux_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


#ifdef CPRIMOD_SUPPORT
int cprimod_cpri_port_fec_stat_get(int unit, int port, cprimod_cpri_fec_stat_type_t stat_type, uint32* value)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_fec_stat_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_fec_stat_get(unit, port, stat_type, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_fec_stat_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int cprimod_cpri_ecc_intr_info_t_validate(const cprimod_cpri_ecc_intr_info_t* cprimod_cpri_ecc_intr_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_cpri_ecc_intr_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int cprimod_cpri_ecc_intr_info_t_init(cprimod_cpri_ecc_intr_info_t* cprimod_cpri_ecc_intr_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_cpri_ecc_intr_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_cpri_ecc_intr_info NULL parameter"));
    }
    sal_memset(cprimod_cpri_ecc_intr_info, 0, sizeof(cprimod_cpri_ecc_intr_info_t));
    cprimod_cpri_ecc_intr_info->port = 0;
    cprimod_cpri_ecc_intr_info->err_mem_info = INVALIDm;
    cprimod_cpri_ecc_intr_info->ecc_reg_info = 0;
    cprimod_cpri_ecc_intr_info->ecc_num_bits_err = 0;
    cprimod_cpri_ecc_intr_info->err_addr = 0;
    cprimod_cpri_ecc_intr_info->mem_str = NULL;

        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int cprimod_cpri_port_ecc_interrupt_enable_set(int unit, int port, int enable)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_ecc_interrupt_enable_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_ecc_interrupt_enable_set(unit, port, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_ecc_interrupt_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int cprimod_cpri_port_ecc_interrupt_status_get(int unit, int port, const cprimod_cpri_ecc_intr_info_t* ecc_err_info)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_cpri_ecc_intr_info_t_validate(ecc_err_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ecc_err_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_ecc_interrupt_status_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_ecc_interrupt_status_get(unit, port, ecc_err_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_ecc_interrupt_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT_ECC_INJECT
int cprimod_cpri_port_ecc_interrupt_test(int unit, int port)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_ecc_interrupt_test) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_ecc_interrupt_test(unit, port);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_ecc_interrupt_test isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT_ECC_INJECT */


int cprimod_cpri_pll_status_get(int unit, int port, const phymod_phy_access_t* phy, int* pll_sel, int* pll_lock)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(pll_sel == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pll_sel NULL parameter"));
    }
    if(pll_lock == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pll_lock NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_pll_status_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_pll_status_get(unit, port, phy, pll_sel, pll_lock);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_pll_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_reset_set(int unit, int port, int rst)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_reset_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_reset_set(unit, port, rst);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_reset_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_reset_get(int unit, int port, int* rst)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(rst == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("rst NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_reset_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_reset_get(unit, port, rst);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_reset_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_init(int unit, int port)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_init) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_init(unit, port);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_init isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_rx_gcw_word_get(int unit, int port, int group_index, uint16* gcw_word)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(gcw_word == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("gcw_word NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_gcw_word_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_gcw_word_get(unit, port, group_index, gcw_word);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_rx_gcw_word_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_tx_gcw_word_set(int unit, int port, int group_index, uint16 gcw_word)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_gcw_word_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_gcw_word_set(unit, port, group_index, gcw_word);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_tx_gcw_word_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_mac_drain_start(int unit, int port)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_mac_drain_start) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_mac_drain_start(unit, port);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_mac_drain_start isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_mac_drain_stop(int unit, int port)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_mac_drain_stop) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_mac_drain_stop(unit, port);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_mac_drain_stop isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_mac_credit_reset_set(int unit, int port, int rst)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_mac_credit_reset_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_mac_credit_reset_set(unit, port, rst);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_mac_credit_reset_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_mac_credit_reset_get(int unit, int port, int* rst)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(rst == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("rst NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_mac_credit_reset_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_mac_credit_reset_get(unit, port, rst);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_mac_credit_reset_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_link_up_event(int unit, int port)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_link_up_event) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_link_up_event(unit, port);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_link_up_event isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_link_down_event(int unit, int port)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_link_down_event) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_link_down_event(unit, port);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_link_down_event isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_agnostic_mode_type_t_validate(cprimod_agnostic_mode_type_t cprimod_agnostic_mode_type)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_agnostic_mode_type >= cprimod_agnostic_mode_Count) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_cpri_port_rx_tunnel_mode_set(int unit, int port, int enable, uint32 payload_size, int restore_rsvd4, cprimod_port_speed_t restore_speed)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_port_speed_t_validate(restore_speed)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("restore_speed validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_tunnel_mode_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_tunnel_mode_set(unit, port, enable, payload_size, restore_rsvd4, restore_speed);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_rx_tunnel_mode_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_rx_tunnel_mode_get(int unit, int port, int* enable, uint32* payload_size)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    if(payload_size == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("payload_size NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_tunnel_mode_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_tunnel_mode_get(unit, port, enable, payload_size);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_rx_tunnel_mode_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_tx_agnostic_mode_set(int unit, int port, int enable, cprimod_agnostic_mode_type_t mode, uint32 payload_size, int restore_rsvd4, cprimod_port_speed_t restore_speed)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_agnostic_mode_type_t_validate(mode)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode validation failed"));
    }

    if(SOC_E_NONE != cprimod_port_speed_t_validate(restore_speed)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("restore_speed validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_agnostic_mode_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_agnostic_mode_set(unit, port, enable, mode, payload_size, restore_rsvd4, restore_speed);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_tx_agnostic_mode_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_tx_agnostic_mode_get(int unit, int port, int* enable, cprimod_agnostic_mode_type_t* mode, uint32* payload_size)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    if(mode == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode NULL parameter"));
    }
    if(payload_size == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("payload_size NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_agnostic_mode_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_agnostic_mode_get(unit, port, enable, mode, payload_size);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_tx_agnostic_mode_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_rx_agnostic_mode_get(int unit, int port, int* enable, cprimod_agnostic_mode_type_t* mode)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    if(mode == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_agnostic_mode_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_agnostic_mode_get(unit, port, enable, mode);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_rx_agnostic_mode_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_pmd_port_status_t_validate(cprimod_pmd_port_status_t cprimod_pmd_port_status)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_pmd_port_status >= cprimodPmdPortStatusCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int cprimod_port_pmd_status_get(int unit, int port, cprimod_pmd_port_status_t status, uint32* value)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_pmd_port_status_t_validate(status)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("status validation failed"));
    }

    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_port_pmd_status_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_port_pmd_status_get(unit, port, status, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_port_pmd_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_link_get(int unit, int port, int* link)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(link == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("link NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_link_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_link_get(unit, port, link);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_link_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


#ifdef CPRIMOD_SUPPORT
int cprimod_cpri_encap_header_field_mapping_t_validate(const cprimod_cpri_encap_header_field_mapping_t* cprimod_cpri_encap_header_field_mapping)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_cpri_encap_header_field_mapping == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int cprimod_cpri_encap_header_field_mapping_t_init(cprimod_cpri_encap_header_field_mapping_t* cprimod_cpri_encap_header_field_mapping)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_cpri_encap_header_field_mapping == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_cpri_encap_header_field_mapping NULL parameter"));
    }
    sal_memset(cprimod_cpri_encap_header_field_mapping, 0, sizeof(cprimod_cpri_encap_header_field_mapping_t));
    cprimod_cpri_encap_header_field_mapping->hdr_byte0_sel = CPRIMOD_CPRI_ROE_HEADER_FIELD_SUBTYPE;
    cprimod_cpri_encap_header_field_mapping->hdr_byte1_sel = CPRIMOD_CPRI_ROE_HEADER_FIELD_FLOW_ID;
    cprimod_cpri_encap_header_field_mapping->hdr_byte2_sel = CPRIMOD_CPRI_ROE_HEADER_FIELD_LENGTH_15_8;
    cprimod_cpri_encap_header_field_mapping->hdr_byte3_sel = CPRIMOD_CPRI_ROE_HEADER_FIELD_LENGTH_7_0;
    cprimod_cpri_encap_header_field_mapping->hdr_byte4_sel = CPRIMOD_CPRI_ROE_HEADER_FIELD_ORDER_INFO_31_24;
    cprimod_cpri_encap_header_field_mapping->hdr_byte5_sel = CPRIMOD_CPRI_ROE_HEADER_FIELD_ORDER_INFO_23_16;
    cprimod_cpri_encap_header_field_mapping->hdr_byte6_sel = CPRIMOD_CPRI_ROE_HEADER_FIELD_ORDER_INFO_15_8;
    cprimod_cpri_encap_header_field_mapping->hdr_byte7_sel = CPRIMOD_CPRI_ROE_HEADER_FIELD_ORDER_INFO_7_0;
    cprimod_cpri_encap_header_field_mapping->hdr_byte8_sel = CPRIMOD_CPRI_ROE_HEADER_FIELD_UNMAPPED;
    cprimod_cpri_encap_header_field_mapping->hdr_byte9_sel = CPRIMOD_CPRI_ROE_HEADER_FIELD_UNMAPPED;
    cprimod_cpri_encap_header_field_mapping->hdr_byte10_sel = CPRIMOD_CPRI_ROE_HEADER_FIELD_UNMAPPED;
    cprimod_cpri_encap_header_field_mapping->hdr_byte11_sel = CPRIMOD_CPRI_ROE_HEADER_FIELD_UNMAPPED;

        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int cprimod_cpri_decap_header_field_mapping_t_validate(const cprimod_cpri_decap_header_field_mapping_t* cprimod_cpri_decap_header_field_mapping)
{        
    SOC_INIT_FUNC_DEFS;
    if(cprimod_cpri_decap_header_field_mapping == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int cprimod_cpri_decap_header_field_mapping_t_init(cprimod_cpri_decap_header_field_mapping_t* cprimod_cpri_decap_header_field_mapping)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(cprimod_cpri_decap_header_field_mapping == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cprimod_cpri_decap_header_field_mapping NULL parameter"));
    }
    sal_memset(cprimod_cpri_decap_header_field_mapping, 0, sizeof(cprimod_cpri_decap_header_field_mapping_t));
    cprimod_cpri_decap_header_field_mapping->subtype_sel = CPRIMOD_CPRI_ECPRI_HEADER_FIELD_BYTE_0;
    cprimod_cpri_decap_header_field_mapping->flowid_sel = CPRIMOD_CPRI_ECPRI_HEADER_FIELD_BYTE_1;
    cprimod_cpri_decap_header_field_mapping->length_15_8_sel = CPRIMOD_CPRI_ECPRI_HEADER_FIELD_BYTE_2;
    cprimod_cpri_decap_header_field_mapping->length_7_0_sel = CPRIMOD_CPRI_ECPRI_HEADER_FIELD_BYTE_3;
    cprimod_cpri_decap_header_field_mapping->orderinginfo_31_24_sel = CPRIMOD_CPRI_ECPRI_HEADER_FIELD_BYTE_4;
    cprimod_cpri_decap_header_field_mapping->orderinginfo_23_16_sel = CPRIMOD_CPRI_ECPRI_HEADER_FIELD_BYTE_5;
    cprimod_cpri_decap_header_field_mapping->orderinginfo_15_8_sel = CPRIMOD_CPRI_ECPRI_HEADER_FIELD_BYTE_6;
    cprimod_cpri_decap_header_field_mapping->orderinginfo_7_0_sel = CPRIMOD_CPRI_ECPRI_HEADER_FIELD_BYTE_7;

        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int cprimod_cpri_encap_header_field_mapping_set(int unit, int port, const cprimod_cpri_encap_header_field_mapping_t* mapping)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_cpri_encap_header_field_mapping_t_validate(mapping)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mapping validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_encap_header_field_mapping_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_encap_header_field_mapping_set(unit, port, mapping);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_encap_header_field_mapping_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int cprimod_cpri_encap_header_field_mapping_get(int unit, int port, cprimod_cpri_encap_header_field_mapping_t* mapping)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(mapping == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mapping NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_cpri_encap_header_field_mapping_t_init(mapping)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mapping initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_encap_header_field_mapping_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_encap_header_field_mapping_get(unit, port, mapping);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_encap_header_field_mapping_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int cprimod_cpri_decap_header_field_mapping_set(int unit, int port, const cprimod_cpri_decap_header_field_mapping_t* mapping)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_cpri_decap_header_field_mapping_t_validate(mapping)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mapping validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_decap_header_field_mapping_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_decap_header_field_mapping_set(unit, port, mapping);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_decap_header_field_mapping_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int cprimod_cpri_decap_header_field_mapping_get(int unit, int port, cprimod_cpri_decap_header_field_mapping_t* mapping)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(mapping == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mapping NULL parameter"));
    }
    if(SOC_E_NONE != cprimod_cpri_decap_header_field_mapping_t_init(mapping)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mapping initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_decap_header_field_mapping_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_decap_header_field_mapping_get(unit, port, mapping);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_decap_header_field_mapping_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int cprimod_cpri_header_field_adjustment_config_set(int unit, int port, cprimod_direction_t dir, int ext_hdr_enable, int len_field_adj)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_header_field_adjustment_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_header_field_adjustment_config_set(unit, port, dir, ext_hdr_enable, len_field_adj);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_header_field_adjustment_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int cprimod_cpri_header_field_adjustment_config_get(int unit, int port, cprimod_direction_t dir, int* ext_hdr_enable, int* len_field_adj)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(ext_hdr_enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ext_hdr_enable NULL parameter"));
    }
    if(len_field_adj == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("len_field_adj NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_header_field_adjustment_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_header_field_adjustment_config_get(unit, port, dir, ext_hdr_enable, len_field_adj);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_header_field_adjustment_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int cprimod_cpri_decap_header_field_mask_set(int unit, int port, cprimod_cpri_roe_header_field_t field_id, uint32 mask)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_decap_header_field_mask_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_decap_header_field_mask_set(unit, port, field_id, mask);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_decap_header_field_mask_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int cprimod_cpri_decap_header_field_mask_get(int unit, int port, cprimod_cpri_roe_header_field_t field_id, uint32* mask)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(mask == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mask NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_decap_header_field_mask_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_decap_header_field_mask_get(unit, port, field_id, mask);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_decap_header_field_mask_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int cprimod_cpri_port_compression_saturation_config_set(int unit, int port, uint32 threshold_value)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_compression_saturation_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_compression_saturation_config_set(unit, port, threshold_value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_compression_saturation_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int cprimod_cpri_port_compression_saturation_config_get(int unit, int port, uint32* threshold_value)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(threshold_value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("threshold_value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_compression_saturation_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_compression_saturation_config_get(unit, port, threshold_value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_compression_saturation_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int cprimod_cpri_port_decompression_saturation_config_set(int unit, int port, uint32 sat_value)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_decompression_saturation_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_decompression_saturation_config_set(unit, port, sat_value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_decompression_saturation_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int cprimod_cpri_port_decompression_saturation_config_get(int unit, int port, uint32* sat_value)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(sat_value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("sat_value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_decompression_saturation_config_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_decompression_saturation_config_get(unit, port, sat_value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_decompression_saturation_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int cprimod_rsvd4_tx_padding_size_set(int unit, int port, uint32 padding_size)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_tx_padding_size_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_tx_padding_size_set(unit, port, padding_size);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rsvd4_tx_padding_size_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int cprimod_rsvd4_tx_padding_size_get(int unit, int port, uint32* padding_size)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(padding_size == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("padding_size NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_tx_padding_size_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_tx_padding_size_get(unit, port, padding_size);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rsvd4_tx_padding_size_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int cprimod_cpri_rx_datapath_reset(int unit, int port)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_rx_datapath_reset) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_rx_datapath_reset(unit, port);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_rx_datapath_reset isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int cprimod_cpri_tx_datapath_reset(int unit, int port)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_tx_datapath_reset) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_tx_datapath_reset(unit, port);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_tx_datapath_reset isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int cprimod_cpri_port_rx_pipeline_clear(int unit, int port)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_pipeline_clear) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_rx_pipeline_clear(unit, port);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_rx_pipeline_clear isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int cprimod_cpri_port_tx_pipeline_clear(int unit, int port)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_pipeline_clear) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_tx_pipeline_clear(unit, port);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_tx_pipeline_clear isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int cprimod_cpri_port_speed_set(int unit, int port, const phymod_phy_access_t* phy, const cprimod_port_init_config_t* port_config)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_port_init_config_t_validate(port_config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("port_config validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_speed_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_speed_set(unit, port, phy, port_config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_speed_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


int cprimod_cpri_tx_framer_tgen_tick_config_set(int unit, int port, cprimod_port_speed_t speed)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_port_speed_t_validate(speed)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("speed validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_tx_framer_tgen_tick_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_tx_framer_tgen_tick_config_set(unit, port, speed);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_tx_framer_tgen_tick_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_rsvd4_tx_framer_tgen_tick_config_set(int unit, int port, cprimod_port_rsvd4_speed_mult_t speed)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != cprimod_port_rsvd4_speed_mult_t_validate(speed)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("speed validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_tx_framer_tgen_tick_config_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_rsvd4_tx_framer_tgen_tick_config_set(unit, port, speed);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_rsvd4_tx_framer_tgen_tick_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_debug_set(int unit, int port, cprimod_cpri_debug_attr_t type, int index, int buffer_size, const uint32* data)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_debug_set) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_debug_set(unit, port, type, index, buffer_size, data);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_debug_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_debug_get(int unit, int port, cprimod_cpri_debug_attr_t type, int index, int buffer_size, uint32* data)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(data == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("data NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_debug_get) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_debug_get(unit, port, type, index, buffer_size, data);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_debug_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int cprimod_cpri_port_debug_clear(int unit, int port, cprimod_cpri_debug_attr_t type, int index)
{

    cprimod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(cprimod_port_cpm_type_get(unit, port, &__type__));
    if(__type__ >= cprimodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_debug_clear) {
        __rv__ = __cprimod__dispatch__[__type__]->f_cprimod_cpri_port_debug_clear(unit, port, type, index);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("cprimod_cpri_port_debug_clear isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}



#undef _ERR_MSG_MODULE_NAME
#endif /* CPRIMOD_SUPPORT */
