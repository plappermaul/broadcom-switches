/*
 * 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 *
 * File:        greyhound2.c
 * Purpose:
 * Requires:
 */


#include <sal/core/boot.h>

#include <soc/firebolt.h>
#include <soc/bradley.h>
#include <soc/greyhound.h>
#include <soc/hurricane3.h>
#include <soc/greyhound2.h>
#include <soc/greyhound2_tdm.h>
#include <soc/drv.h>
#include <soc/mem.h>
#include <soc/hash.h>
#include <soc/lpm.h>
#include <soc/error.h>
#include <soc/debug.h>
#include <soc/er_tcam.h>
#include <soc/memtune.h>
#include <soc/devids.h>
#include <soc/defs.h>
#include <soc/bondoptions.h>
#include <soc/esw/port.h>
#include <soc/scache.h>
#include <soc/mspi.h>
#include <soc/iproc.h>
#include <soc/cmicm.h>

#include <shared/util.h>
#include <shared/l3.h>
#include <shared/bsl.h>

#ifdef BCM_GREYHOUND2_SUPPORT

#define SOC_MAX_PHY_PORTS            90
#define SOC_MAX_LOGICAL_PORTS        66
#define SOC_MAX_MMU_PORTS            66

static int gh2_port_speed[SOC_MAX_PHY_PORTS];

/* Port config related : p2l, max_speed and TDM */
#define GH2_TDM_SLOT_MAX            512
/* Initial TDM table */
uint32 tdm_table_default[GH2_TDM_SLOT_MAX] = {0};

/* OPTION_1 */
int p2l_mapping_template_op1[] = {
     0, -1,
    /* TSC4L 0~5 */
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSCF 0*/
     -1, -1, -1, -1
};
int port_speed_max_template_op1[] = {
     0, -1,
    /* TSC4L 0~5 */
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSCF 0*/
     -1, -1, -1, -1
};

/* OPTION_2 */
int p2l_mapping_template_op2[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     6, 7, 8, 9,
     10, 11, 12, 13,
     14, 15, 16, 17,
     18, 19, 20, 21,
     22, 23, 24, 25,
    /* TSC4Q 0~1 */
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSCF 0*/
     -1, -1, -1, -1
};
int port_speed_max_template_op2[] = {
     0, -1,
    /* TSC4L 0~5 */
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
    /* TSC4Q 0~1 */
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSCF 0*/
     -1, -1, -1, -1
};

/* OPTION_2A */
int p2l_mapping_template_op2a[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     6, 7, 8, 9,
     10, 11, 12, 13,
     14, 15, 16, 17,
     18, 19, 20, 21,
     22, 23, 24, 25,
    /* TSC4Q 0~1 */
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSCF 0*/
     -1, -1, -1, -1
};
int port_speed_max_template_op2a[] = {
     0, -1,
    /* TSC4L 0~5 */
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
    /* TSC4Q 0~1 */
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSCF 0*/
     -1, -1, -1, -1
};

/* OPTION_3A */
int p2l_mapping_template_op3a[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     6, 7, 8, 9, 10, 11, 12, 13,
     14, 15, 16, 17, 18, 19, 20, 21,
     22, 23, 24, 25, 26, 27, 28, 29,
     30, 31, 32, 33, 34, 35, 36, 37,
    /* TSC 0~6*/
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSCF 0*/
     -1, -1, -1, -1
};
int port_speed_max_template_op3a[] = {
     0, -1,
    /* TSC4L 0~5 */
     10, 10, 10, 10,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
    /* TSC 0~6*/
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSCF 0*/
     -1, -1, -1, -1
};

/* OPTION_4A */
int p2l_mapping_template_op4a[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     6, 7, 8, 9,
     10, 11, 12, 13,
     14, 15, 16, 17,
     18, 19, 20, 21,
     22, 23, 24, 25,
    /* TSC4Q 0~1 */
     26, 27, 28, 29, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     30, 31, 32, 33, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSCF 0*/
     -1, -1, -1, -1
};
int port_speed_max_template_op4a[] = {
     0, -1,
    /* TSC4L 0~5 */
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
    /* TSC4Q 0~1 */
     25, 25, 25, 25, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     25, 25, 25, 25, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSCF 0*/
     -1, -1, -1, -1
};

/* OPTION_5 */
int p2l_mapping_template_op5[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     6, 7, 8, 9,
     10, 11, 12, 13,
     14, 15, 16, 17,
     18, 19, 20, 21,
     22, 23, 24, 25,
    /* TSC4Q 0~1 */
     26, 27, 28, 29, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     30, 31, 32, 33, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSCF 0*/
     -1, -1, -1, -1
};
int port_speed_max_template_op5[] = {
     0, -1,
    /* TSC4L 0~5 */
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
    /* TSC4Q 0~1 */
     25, 25, 25, 25, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     25, 25, 25, 25, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSCF 0*/
     -1, -1, -1, -1
};

/* OPTION_6 */
int p2l_mapping_template_op6[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     6, 7, 8, 9,
     10, 11, 12, 13,
     14, 15, 16, 17,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     18, 19, 20, 21, 22, 23, 24, 25,
     26, 27, 28, 29, 30, 31, 32, 33,
     34, 35, 36, 37, 38, 39, 40, 41,
     42, 43, 44, 45, 46, 47, 48, 49,
    /* TSC 0~6*/
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSCF 0*/
     -1, -1, -1, -1
};
int port_speed_max_template_op6[] = {
     0, -1,
    /* TSC4L 0~5 */
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
    /* TSC 0~6*/
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSCF 0*/
     -1, -1, -1, -1
};

/* OPTION_7 */
int p2l_mapping_template_op7[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSCF 0*/
     -1, -1, -1, -1
};
int port_speed_max_template_op7[] = {
     0, -1,
    /* TSC4L 0~5 */
     10, 10, 10, 10,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSCF 0*/
     -1, -1, -1, -1
};

/* OPTION_7B */
int p2l_mapping_template_op7b[] = {
     0, -1,
    /* TSC4L 0~5 */
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSCF 0*/
     -1, -1, -1, -1
};
int port_speed_max_template_op7b[] = {
     0, -1,
    /* TSC4L 0~5 */
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSCF 0*/
     -1, -1, -1, -1
};

/* OPTION_8B */
int p2l_mapping_template_op8b[] = {
     0, -1,
    /* TSC4L 0~5 */
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     2, 3, 4, 5,
    /* TSC4Q 0~1 */
     6, 7, 8, 9, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     10, 11, 12, 13, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSCF 0*/
     -1, -1, -1, -1
};
int port_speed_max_template_op8b[] = {
     0, -1,
    /* TSC4L 0~5 */
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     25, 25, 25, 25,
    /* TSC4Q 0~1 */
     25, 25, 25, 25, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     25, 25, 25, 25, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSCF 0*/
     -1, -1, -1, -1
};

/* OPTION_9B */
int p2l_mapping_template_op9b[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     6, 7, 8, 9,
     10, 11, 12, 13,
     14, 15, 16, 17,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     18, 19, 20, 21, 22, 23, 24, 25,
     26, 27, 28, 29, 30, 31, 32, 33,
     34, 35, 36, 37, 38, 39, 40, 41,
     42, 43, 44, 45, 46, 47, 48, 49,
    /* TSC 0~6*/
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSCF 0*/
     -1, -1, -1, -1
};
int port_speed_max_template_op9b[] = {
     0, -1,
    /* TSC4L 0~5 */
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
    /* TSC 0~6*/
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSCF 0*/
     -1, -1, -1, -1
};

/* OPTION_10B */
int p2l_mapping_template_op10b[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     6, 7, 8, 9,
     10, 11, 12, 13,
     14, 15, 16, 17,
     18, 19, 20, 21,
     22, 23, 24, 25,
    /* TSC4Q 0~1 */
     26, 27, 28, 29, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     30, 31, 32, 33, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSCF 0*/
     -1, -1, -1, -1
};
int port_speed_max_template_op10b[] = {
     0, -1,
    /* TSC4L 0~5 */
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
    /* TSC4Q 0~1 */
     10, 10, 10, 10, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     10, 10, 10, 10, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSCF 0*/
     -1, -1, -1, -1
};

/* OPTION_11B */
int p2l_mapping_template_op11b[] = {
     0, -1,
    /* TSC4L 0~5 */
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     2, 3, 4, 5, 6, 7, 8, 9,
     10, 11, 12, 13, 14, 15, 16, 17,
     18, 19, 20, 21, 22, 23, 24, 25,
     26, 27, 28, 29, 30, 31, 32, 33,
    /* TSC 0~6*/
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSCF 0*/
     -1, -1, -1, -1
};
int port_speed_max_template_op11b[] = {
     0, -1,
    /* TSC4L 0~5 */
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
    /* TSC 0~6*/
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSCF 0*/
     -1, -1, -1, -1
};

/* OPTION_12B */
int p2l_mapping_template_op12b[] = {
     0, -1,
    /* TSC4L 0~5 */
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSCF 0*/
     -1, -1, -1, -1
};
int port_speed_max_template_op12b[] = {
     0, -1,
    /* TSC4L 0~5 */
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSCF 0*/
     -1, -1, -1, -1
};

/* OPTION_12 */
int p2l_mapping_template_op12[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSCF 0*/
     -1, -1, -1, -1
};
int port_speed_max_template_op12[] = {
     0, -1,
    /* TSC4L 0~5 */
     10, 10, 10, 10,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSCF 0*/
     -1, -1, -1, -1
};

/* OPTION_13 */
int p2l_mapping_template_op13[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     6, 7, 8, 9,
     10, 11, 12, 13,
     14, 15, 16, 17,
     18, 19, 20, 21,
     22, 23, 24, 25,
    /* TSC4Q 0~1 */
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSCF 0*/
     -1, -1, -1, -1
};
int port_speed_max_template_op13[] = {
     0, -1,
    /* TSC4L 0~5 */
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
    /* TSC4Q 0~1 */
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSCF 0*/
     -1, -1, -1, -1
};

/* OPTION_14 */
int p2l_mapping_template_op14[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     6, 7, 8, 9,
     10, 11, 12, 13,
     14, 15, 16, 17,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSCF 0*/
     -1, -1, -1, -1
};
int port_speed_max_template_op14[] = {
     0, -1,
    /* TSC4L 0~5 */
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSCF 0*/
     -1, -1, -1, -1
};

/* Below options defined in PRD 4.7*/
/* OPTION_2_0, 24P 2.5G + 32P 10G */
static int p2l_mapping_op2_0[] = {
    0, -1,
    /* TSC4L 0~5 */
    2, 3, 4, 5,
    6, 7, 8, 9,
    10, 11, 12, 13,
    14, 15, 16, 17,
    18, 19, 20, 21,
    22, 23, 24, 25,
    /* TSC4Q 0~1 */
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
    26, 27, 28, 29,
    30, 31, 32, 33,
    34, 35, 36, 37,
    38, 39, 40, 41,
    42, 43, 44, 45,
    46, 47, 48, 49,
    50, 51, 52, 53,
    /* TSCF 0*/
    54, 55, 56, 57
};
static int port_speed_max_op2_0[] = {
     0, -1,
    /* TSC4L 0~5 */
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
    /* TSC4Q 0~1 */
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
    110, 110, 110, 110,
    110, 110, 110, 110,
    110, 110, 110, 110,
    110, 110, 110, 110,
    110, 110, 110, 110,
    110, 110, 110, 110,
    110, 110, 110, 110,
    /* TSCF 0*/
    110, 110, 110, 110,
};
uint32 tdm_table_op2_0[305] = {
    58, 62, 66, 70, 74, 2, 78, 82, 86, 59,
    63, 3, 67, 71, 75, 79, 83, 4, 87, 60,
    64, 68, 72, 5, 76, 80, 84, 88, 61, 6,
    65, 69, 73, 77, 81, 7, 85, 89, 58, 62,
    66, 70, 74, 8, 78, 82, 86, 59, 63, 9,
    67, 71, 75, 79, 83, 10, 87, 60, 64, 68,
    72, 11, 76, 80, 84, 88, 61, 12, 65, 69,
    73, 77, 81, 13, 85, 89, 58, 62, 66, 70,
    74, 14, 78, 82, 86, 59, 63, 15, 67, 71,
    75, 79, 83, 16, 87, 60, 64, 68, 72, 17,
    76, 80, 84, 88, 61, 18, 65, 69, 73, 77,
    81, 19, 85, 89, 58, 62, 66, 70, 74, 20,
    78, 82, 86, 59, 63, 21, 67, 71, 75, 79,
    83, 22, 87, 60, 64, 68, 72, 23, 76, 80,
    84, 88, 61, 24, 65, 69, 73, 77, 81, 25,
    85, 89, 58, 62, 66, 70, 74, 2, 78, 82,
    86, 59, 63, 3, 67, 71, 75, 79, 83, 4,
    87, 60, 64, 68, 72, 5, 76, 80, 84, 88,
    61, 6, 65, 69, 73, 77, 81, 7, 85, 89,
    58, 62, 66, 70, 74, 8, 78, 82, 86, 59,
    63, 9, 67, 71, 75, 79, 83, 10, 87, 60,
    64, 68, 72, 11, 76, 80, 84, 88, 61, 12,
    65, 69, 73, 77, 81, 13, 85, 89, 58, 62,
    66, 70, 74, 14, 78, 82, 86, 59, 63, 15,
    67, 71, 75, 79, 83, 16, 87, 60, 64, 68,
    72, 17, 76, 80, 84, 88, 61, 18, 65, 69,
    73, 77, 81, 19, 85, 89, 58, 62, 66, 70,
    74, 20, 78, 82, 86, 59, 63, 21, 67, 71,
    75, 79, 83, 22, 87, 60, 64, 68, 72, 23,
    76, 80, 84, 88, 61, 24, 65, 69, 73, 77,
    81, 25, 85, 89, 0
};

/* OPTION_2_2, 24*2.5G + 16*10G + 4*40G */
static int p2l_mapping_op2_2[] = {
     0, -1,
    /* TSC4L 0~5 */
    2, 3, 4, 5,
    6, 7, 8, 9,
    10, 11, 12, 13,
    14, 15, 16, 17,
    18, 19, 20, 21,
    22, 23, 24, 25,
    /* TSC4Q 0~1 */
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
    26, 27, 28, 29,
    30, 31, 32, 33,
    34, 35, 36, 37,
    38, 39, 40, 41,
    42, -1, -1, -1,
    43, -1, -1, -1,
    44, -1, -1, -1,
    /* TSCF 0*/
    45, -1, -1, -1
};

static int port_speed_max_op2_2[] = {
     0, -1,
    /* TSC4L 0~5 */
    25, 25, 25, 25,
    25, 25, 25, 25,
    25, 25, 25, 25,
    25, 25, 25, 25,
    25, 25, 25, 25,
    25, 25, 25, 25,
    /* TSC4Q 0~1 */
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
    110, 110, 110, 110,
    110, 110, 110, 110,
    110, 110, 110, 110,
    110, 110, 110, 110,
    420, -1, -1, -1,
    420, -1, -1, -1,
    420, -1, -1, -1,
    /* TSCF 0*/
    420, -1, -1, -1
};

uint32 tdm_table_op2_2[305] = {
    58, 62, 66, 70, 74, 2, 78, 82, 86, 59,
    63, 3, 67, 71, 74, 78, 82, 4, 86, 60,
    64, 68, 72, 5, 74, 78, 82, 86, 61, 6,
    65, 69, 73, 74, 78, 7, 82, 86, 58, 62,
    66, 70, 74, 8, 78, 82, 86, 59, 63, 9,
    67, 71, 74, 78, 82, 10, 86, 60, 64, 68,
    72, 11, 74, 78, 82, 86, 61, 12, 65, 69,
    73, 74, 78, 13, 82, 86, 58, 62, 66, 70,
    74, 14, 78, 82, 86, 59, 63, 15, 67, 71,
    74, 78, 82, 16, 86, 60, 64, 68, 72, 17,
    74, 78, 82, 86, 61, 18, 65, 69, 73, 74,
    78, 19, 82, 86, 58, 62, 66, 70, 74, 20,
    78, 82, 86, 59, 63, 21, 67, 71, 74, 78,
    82, 22, 86, 60, 64, 68, 72, 23, 74, 78,
    82, 86, 61, 24, 65, 69, 73, 74, 78, 25,
    82, 86, 58, 62, 66, 70, 74, 2, 78, 82,
    86, 59, 63, 3, 67, 71, 74, 78, 82, 4,
    86, 60, 64, 68, 72, 5, 74, 78, 82, 86,
    61, 6, 65, 69, 73, 74, 78, 7, 82, 86,
    58, 62, 66, 70, 74, 8, 78, 82, 86, 59,
    63, 9, 67, 71, 74, 78, 82, 10, 86, 60,
    64, 68, 72, 11, 74, 78, 82, 86, 61, 12,
    65, 69, 73, 74, 78, 13, 82, 86, 58, 62,
    66, 70, 74, 14, 78, 82, 86, 59, 63, 15,
    67, 71, 74, 78, 82, 16, 86, 60, 64, 68,
    72, 17, 74, 78, 82, 86, 61, 18, 65, 69,
    73, 74, 78, 19, 82, 86, 58, 62, 66, 70,
    74, 20, 78, 82, 86, 59, 63, 21, 67, 71,
    74, 78, 82, 22, 86, 60, 64, 68, 72, 23,
    74, 78, 82, 86, 61, 24, 65, 69, 73, 74,
    78, 25, 82, 86, 0
};

/* OPTION_2_3, 24x2.5G + 24x10G + 2x40G */
static int p2l_mapping_op2_3[] = {
     0, -1,
    /* TSC4L 0~5 */
    2, 3, 4, 5,
    6, 7, 8, 9,
    10, 11, 12, 13,
    14, 15, 16, 17,
    18, 19, 20, 21,
    22, 23, 24, 25,
    /* TSC4Q 0~1 */
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
    26, 27, 28, 29,
    30, 31, 32, 33,
    34, 35, 36, 37,
    38, 39, 40, 41,
    42, 43, 44, 45,
    46, 47, 48, 49,
    50, -1, -1, -1,
    /* TSCF 0*/
    51, -1, -1, -1
};

static int port_speed_max_op2_3[] = {
     0, -1,
    /* TSC4L 0~5 */
    25, 25, 25, 25,
    25, 25, 25, 25,
    25, 25, 25, 25,
    25, 25, 25, 25,
    25, 25, 25, 25,
    25, 25, 25, 25,
    /* TSC4Q 0~1 */
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
    110, 110, 110, 110,
    110, 110, 110, 110,
    110, 110, 110, 110,
    110, 110, 110, 110,
    110, 110, 110, 110,
    110, 110, 110, 110,
    420, -1, -1, -1,
    /* TSCF 0*/
    420, -1, -1, -1
};

uint32 tdm_table_op2_3[305] = {
    82, 86, 58, 60, 62, 64, 66, 68, 70, 82,
    86, 72, 74, 76, 78, 80,  2, 10, 18, 82,
    86, 59, 61, 63, 65, 67, 69, 71, 82, 86,
    73, 75, 77, 79, 81,  3, 11, 19, 82, 86,
    58, 60, 62, 64, 66, 68, 70, 82, 86, 72,
    74, 76, 78, 80,  4, 12, 20, 82, 86, 59,
    61, 63, 65, 67, 69, 71, 82, 86, 73, 75,
    77, 79, 81,  5, 13, 21, 82, 86, 58, 60,
    62, 64, 66, 68, 70, 82, 86, 72, 74, 76,
    78, 80,  6, 14, 22, 82, 86, 59, 61, 63,
    65, 67, 69, 71, 82, 86, 73, 75, 77, 79,
    81,  7, 15, 23, 82, 86, 58, 60, 62, 64,
    66, 68, 70, 82, 86, 72, 74, 76, 78, 80,
     8, 16, 24, 82, 86, 59, 61, 63, 65, 67,
    69, 71, 82, 86, 73, 75, 77, 79, 81,  9,
    17, 25, 82, 86, 58, 60, 62, 64, 66, 68,
    70, 72, 82, 86, 74, 76, 78, 80,  2, 10,
    18, 82, 86, 59, 61, 63, 65, 67, 69, 71,
    73, 82, 86, 75, 77, 79, 81,  3, 11, 19,
    82, 86, 58, 60, 62, 64, 66, 68, 70, 72,
    82, 86, 74, 76, 78, 80,  4, 12, 20, 82,
    86, 59, 61, 63, 65, 67, 69, 71, 73, 82,
    86, 75, 77, 79, 81,  5, 13, 21, 82, 86,
    58, 60, 62, 64, 66, 68, 70, 72, 82, 86,
    74, 76, 78, 80,  6, 14, 22, 82, 86, 59,
    61, 63, 65, 67, 69, 71, 73, 82, 86, 75,
    77, 79, 81,  7, 15, 23, 82, 86, 58, 60,
    62, 64, 66, 68, 70, 72, 82, 86, 74, 76,
    78, 80,  8, 16, 24, 82, 86, 59, 61, 63,
    65, 67, 69, 71, 73, 82, 86, 75, 77, 79,
    81,  9, 17, 25, 0
};

/* OPTION_5_2, 52*2.5G + 8*10G + 2*50G */
static int p2l_mapping_op5_2[] = {
     0, -1,
    /* TSC4L 0~5 */
    2, 3, 4, 5,
    6, 7, 8, 9,
    10, 11, 12, 13,
    14, 15, 16, 17,
    18, 19, 20, 21,
    22, 23, 24, 25,
    /* TSC4Q 0~1 */
    26, 27, 28, 29, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    30, 31, 32, 33, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
    34, 35, 36, 37,
    38, 39, 40, 41,
    42, 43, 44, 45,
    46, 47, 48, 49,
    50, 51, 52, 53,
    54, 55, 56, 57,
    58, 59, 60, 61,
    /* TSCF 0*/
    62, -1, 63, -1
};

static int port_speed_max_op5_2[] = {
     0, -1,
    /* TSC4L 0~5 */
    25, 25, 25, 25,
    25, 25, 25, 25,
    25, 25, 25, 25,
    25, 25, 25, 25,
    25, 25, 25, 25,
    25, 25, 25, 25,
    /* TSC4Q 0~1 */
    25, 25, 25, 25, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    25, 25, 25, 25, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
    25, 25, 25, 25,
    25, 25, 25, 25,
    25, 25, 25, 25,
    25, 25, 25, 25,
    110, 110, 110, 110,
    25, 25, 25, 25,
    110, 110, 110, 110,
    /* TSCF 0*/
    530, -1, 530, -1
};

uint32 tdm_table_op5_2[126] = {
    72, 127, 86, 74, 76, 88, 84, 3, 86, 14,
    25, 88, 82, 42, 86, 61, 79, 88, 75, 77,
    28, 86, 85, 4, 88, 15, 18, 86, 83, 58,
    88, 66, 70, 86, 74, 76, 88, 84, 5, 63,
    86, 16, 19, 88, 82, 43, 86, 81, 68, 88,
    75, 77, 86, 85, 6, 88, 17, 20, 86, 83,
    29, 64, 88, 73, 0, 86, 74, 76, 88, 84,
    7, 86, 10, 21, 88, 82, 44, 86, 60, 78,
    88, 75, 77, 85, 86, 26, 8, 88, 11, 22,
    86, 83, 59, 88, 67, 71, 86, 74, 76, 88,
    84, 9, 62, 86, 12, 23, 88, 82, 45, 86,
    80, 69, 88, 75, 77, 86, 85, 2, 88, 13,
    27, 86, 24, 83, 65, 88
};

/* OPTION_9B_0, 48*1G + 40G RioT + 8*10G + 4*25G */
static int p2l_mapping_op9b_0[] = {
     0, -1,
    /* TSC4L 0~5 */
    2, 3, 4, 5,
    6, 7, 8, 9,
    10, 11, 12, 13,
    14, 15, 16, 17,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    /* TSC4Q 0~1 */
    18, 19, 20, 21, 22, 23, 24, 25,
    26, 27, 28, 29, 30, 31, 32, 33,
    34, 35, 36, 37, 38, 39, 40, 41,
    42, 43, 44, 45, 46, 47, 48, 49,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    50, -1, -1, -1,
    51, 52, 53, 54,
    55, -1, -1, -1,
    56, 57, 58, 59,
    /* TSCF 0*/
    60, 61, 62, 63
};

static int port_speed_max_op9b_0[] = {
     0, -1,
    /* TSC4L 0~5 */
    10, 10, 10, 10,
    10, 10, 10, 10,
    10, 10, 10, 10,
    10, 10, 10, 10,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    /* TSC4Q 0~1 */
    10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    420, -1, -1, -1,
    110, 110, 110, 110,
    420, -1, -1, -1,
    110, 110, 110, 110,
    /* TSCF 0*/
    250, 250, 250, 250
};

uint32 tdm_table_op9b_0[309] = {
    77, 87, 29, 78, 11, 88, 70, 83, 89, 74,
    86, 78, 76, 70, 87, 84, 34, 88, 2, 78,
    89, 70, 82, 86, 52, 75, 78, 87, 77, 70,
    88, 85, 89, 57, 78, 86, 70, 45, 83, 87,
    30, 88, 78, 74, 70, 89, 76, 84, 86, 78,
    12, 87, 70, 82, 88, 35, 3, 78, 89, 75,
    70, 86, 77, 87, 85, 78, 88, 70, 53, 89,
    83, 76, 74, 78, 86, 70, 87, 84, 46, 88,
    78, 54, 89, 70, 82, 86, 31, 75, 78, 87,
    70, 88, 77, 85, 89, 4, 78, 86, 70, 83,
    87, 13, 74, 88, 78, 76, 70, 89, 84, 36,
    86, 78, 47, 87, 70, 82, 88, 77, 89, 78,
    75, 70, 86, 85, 32, 87, 14, 78, 88, 70,
    83, 89, 37, 56, 78, 86, 74, 70, 87, 76,
    84, 88, 78, 5, 89, 70, 82, 86, 75, 87,
    78, 77, 70, 88, 85, 48, 89, 38, 78, 86,
    70, 83, 87, 74, 88, 78, 76, 15, 70, 89,
    84, 86, 6, 78, 87, 70, 33, 82, 88, 77,
    89, 78, 75, 70, 86, 85, 55, 87, 78, 49,
    88, 70, 83, 89, 74, 86, 78, 76, 87, 70,
    26, 84, 88, 0, 78, 89, 70, 7, 82, 86,
    77, 87, 78, 75, 70, 88, 85, 16, 89, 78,
    39, 86, 70, 83, 87, 74, 88, 78, 76, 89,
    70, 84, 42, 86, 27, 78, 87, 70, 82, 88,
    17, 77, 75, 78, 89, 70, 86, 85, 40, 87,
    78, 8, 88, 70, 83, 89, 50, 74, 78, 86,
    70, 87, 76, 84, 88, 43, 78, 89, 70, 82,
    86, 75, 87, 78, 28, 77, 70, 88, 85, 41,
    89, 78, 10, 86, 70, 83, 87, 84, 88, 78,
    74, 70, 89, 76, 9, 86, 51, 78, 87, 70,
    82, 88, 44, 85, 78, 89, 75, 70, 86
};

/* OPTION_10B_0, 32*1G + 40G RioT + 8*10G + 4*25G */
static int p2l_mapping_op10b_0[] = {
     0, -1,
    /* TSC4L 0~5 */
    2, 3, 4, 5,
    6, 7, 8, 9,
    10, 11, 12, 13,
    14, 15, 16, 17,
    18, 19, 20, 21,
    22, 23, 24, 25,
    /* TSC4Q 0~1 */
    26, 27, 28, 29, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    30, 31, 32, 33, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    34, 35, 36, 37,
    38, 39, 40, 41,
    42, 43, 44, 45,
    46, 47, 48, 49,
    /* TSCF 0*/
    50, 51, 52, 53
};

static int port_speed_max_op10b_0[] = {
     0, -1,
    /* TSC4L 0~5 */
    10, 10, 10, 10,
    10, 10, 10, 10,
    10, 10, 10, 10,
    10, 10, 10, 10,
    10, 10, 10, 10,
    10, 10, 10, 10,
    /* TSC4Q 0~1 */
    10, 10, 10, 10, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    10, 10, 10, 10, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    110, 110, 110, 110,
    110, 110, 110, 110,
    110, 110, 110, 110,
    110, 110, 110, 110,
    /* TSCF 0*/
    250, 250, 250, 250
};

uint32 tdm_table_op10b_0[293] = {
    82, 77, 88, 85, 79, 89, 81, 18, 86, 70,
    83, 87, 75, 73, 88, 76, 84, 89, 78, 80,
    86, 17, 6, 87, 71, 82, 88, 74, 72, 89,
    77, 86, 44, 79, 87, 81, 85, 88, 83, 70,
    89, 75, 73, 86, 19, 76, 87, 78, 84, 88,
    80, 7, 89, 71, 82, 86, 74, 72, 87, 77,
    85, 88, 79, 81, 89, 10, 26, 86, 70, 83,
    87, 75, 88, 73, 76, 89, 84, 78, 86, 80,
    20, 87, 11, 71, 88, 74, 72, 89, 82, 77,
    86, 79, 85, 87, 81, 8, 88, 70, 83, 89,
    75, 73, 86, 76, 45, 87, 78, 84, 88, 80,
    27, 89, 71, 86, 74, 82, 87, 72, 77, 88,
    12, 79, 89, 81, 85, 86, 70, 83, 87, 75,
    73, 88, 9, 76, 89, 78, 84, 86, 80, 21,
    87, 71, 82, 88, 74, 72, 89, 77, 42, 86,
    79, 81, 87, 85, 83, 88, 70, 89, 75, 13,
    86, 73, 76, 87, 84, 78, 88, 80, 2, 89,
    71, 82, 86, 74, 72, 87, 22, 77, 88, 79,
    85, 89, 81, 43, 86, 70, 83, 87, 75, 73,
    88, 76, 23, 89, 78, 84, 86, 80, 87, 3,
    71, 88, 74, 82, 89, 72, 77, 86, 14, 79,
    87, 81, 85, 88, 70, 83, 89, 75, 73, 86,
    28, 76, 87, 78, 84, 88, 80, 24, 89, 71,
    82, 86, 74, 72, 87, 77, 4, 88, 79, 89,
    81, 85, 86, 25, 70, 87, 75, 73, 88, 83,
    76, 89, 15, 78, 86, 80, 84, 87, 71, 82,
    88, 74, 72, 89, 77, 0, 86, 79, 85, 87,
    81, 29, 88, 70, 83, 89, 75, 73, 86, 76,
    87, 5, 78, 88, 80, 84, 89, 16, 71, 86,
    74, 72, 87
};

/* OPTION_13_0, 24P 1G + 4P 10G + XAUI*/
static int p2l_mapping_op13_0[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     6, 7, 8, 9,
     10, 11, 12, 13,
     14, 15, 16, 17,
     18, 19, 20, 21,
     22, 23, 24, 25,
    /* TSC4Q 0~1 */
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    26, 27, 28, 29,
    30, -1, -1, -1,
    -1, -1, -1, -1,
    /* TSCF 0*/
    -1, -1, -1, -1
};
static int port_speed_max_op13_0[] = {
     0, -1,
    /* TSC4L 0~5 */
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
    /* TSC4Q 0~1 */
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    110, 110, 110, 110,
    100, -1, -1, -1,
    -1, -1, -1, -1,
    /* TSCF 0*/
    -1, -1, -1, -1
};
uint32 tdm_table_op13_0[72] = {
    75, 77, 78, 10, 74, 76, 2, 22, 75, 77,
    78, 127, 74, 76, 11, 3, 75, 77, 78, 23,
    74, 76, 12, 24, 75, 77, 78, 4, 74, 76,
    13, 5, 75, 77, 78, 25, 74, 76, 127, 14,
    75, 77, 78, 6, 74, 76, 18, 15, 75, 77,
    78, 7, 74, 76, 0, 19, 75, 77, 78, 16,
    74, 76, 8, 20, 75, 77, 78, 9, 74, 76,
    17, 21
};

/* Below options defined in PRD 4.6*/
/* OPTION_1_0, 24P 10G + 4P 10G/25G */
static int p2l_mapping_op1_0[] = {
     0, -1,
    /* TSC4L 0~5 */
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    /* TSC4Q 0~1 */
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    /* TSC 0~6*/
     2,   3,   4,   5,
     6,   7,   8,   9,
    10,  11,  12,  13,
    14,  15,  16,  17,
    18,  19,  20,  21,
    22,  -1,  -1,  -1,
    23,  24,  25,  26,
    /* TSCF 0*/
    27,  28,  29,  30
};

static int port_speed_max_op1_0[] = {
     0, -1,
    /* TSC4L 0~5 */
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    /* TSC4Q 0~1 */
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    /* TSC 0~6*/
    110, 110, 110, 110,
    110, 110, 110, 110,
    110, 110, 110, 110,
    110, 110, 110, 110,
    110, 110, 110, 110,
    100,  -1,  -1,  -1,
    110, 110, 110, 110,
    /* TSCF 0*/
    250, 250, 250, 250
};

uint32 tdm_table_op1_0[216] = {
    62, 88, 70, 60, 73, 89, 74, 76,
    85, 86, 83, 78, 87, 64, 58, 66,
    88, 69, 63, 89, 71, 61, 72, 86,
    75, 77, 84, 87, 82, 127, 88, 65,
    59, 67, 89, 68, 62, 86, 70, 60,
    73, 87, 74, 76, 85, 88, 83, 78,
    89, 64, 58, 66, 86, 69, 63, 87,
    71, 61, 72, 88, 75, 77, 84, 89,
    82, 0, 86, 65, 59, 67, 87, 68,
    62, 88, 70, 60, 73, 89, 74, 76,
    85, 86, 83, 78, 87, 64, 58, 66,
    88, 69, 63, 89, 71, 61, 72, 86,
    75, 77, 84, 87, 82, 127, 88, 65,
    59, 67, 89, 68, 62, 86, 70, 60,
    73, 87, 74, 76, 85, 88, 83, 78,
    89, 64, 58, 66, 86, 69, 63, 87,
    71, 61, 72, 88, 75, 77, 84, 89,
    82, 127, 86, 65, 59, 67, 87, 68,
    62, 88, 70, 60, 73, 89, 74, 76,
    85, 86, 83, 78, 87, 64, 58, 66,
    88, 69, 63, 89, 71, 61, 72, 86,
    75, 77, 84, 87, 82, 127, 88, 65,
    59, 67, 89, 68, 62, 86, 70, 60,
    73, 87, 74, 76, 85, 88, 83, 78,
    89, 64, 58, 66, 86, 69, 63, 87,
    71, 61, 72, 88, 75, 77, 84, 89,
    82, 127, 86, 65, 59, 67, 87, 68
};

/* OPTION_1_1, 24P 10G + 2P HG[50] */
static int p2l_mapping_op1_1[] = {
     0, -1,
    /* TSC4L 0~5 */
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    /* TSC4Q 0~1 */
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    /* TSC 0~6*/
     2,   3,   4,   5,
     6,   7,   8,   9,
    10,  11,  12,  13,
    14,  15,  16,  17,
    18,  19,  20,  21,
    22,  -1,  -1,  -1,
    23,  24,  25,  26,
    /* TSCF 0*/
    27,  -1,  28,  -1
};
static int port_speed_max_op1_1[] = {
     0, -1,
    /* TSC4L 0~5 */
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    /* TSC4Q 0~1 */
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    /* TSC 0~6*/
    110, 110, 110, 110,
    110, 110, 110, 110,
    110, 110, 110, 110,
    110, 110, 110, 110,
    110, 110, 110, 110,
    100,  -1,  -1,  -1,
    110, 110, 110, 110,
    /* TSCF 0*/
    530,  -1,  530,  -1
};
uint32 tdm_table_op1_1[252] = {
    59, 88, 66, 71, 72, 86, 74, 68,
    88, 60, 77, 84, 86, 78, 64, 88,
    63, 83, 58, 86, 67, 70, 73, 88,
    75, 69, 86, 61, 76, 85, 88, 127,
    65, 86, 62, 82, 59, 88, 66, 71,
    72, 86, 74, 68, 88, 60, 77, 84,
    86, 78, 64, 88, 63, 83, 58, 86,
    67, 70, 73, 88, 75, 69, 86, 61,
    76, 85, 88, 127, 65, 86, 62, 82,
    59, 88, 66, 71, 72, 86, 74, 68,
    88, 60, 77, 84, 86, 78, 64, 88,
    63, 83, 58, 86, 67, 70, 73, 88,
    75, 69, 86, 61, 76, 85, 88, 127,
    65, 86, 62, 82, 59, 88, 66, 71,
    72, 86, 74, 68, 88, 60, 77, 84,
    86, 78, 64, 88, 63, 83, 58, 86,
    67, 70, 73, 88, 75, 69, 86, 61,
    76, 85, 88, 127, 65, 86, 62, 82,
    59, 88, 66, 71, 72, 86, 74, 68,
    88, 60, 77, 84, 86, 78, 64, 88,
    63, 83, 58, 86, 67, 70, 73, 88,
    75, 69, 86, 61, 76, 85, 88, 127,
    65, 86, 62, 82, 59, 88, 66, 71,
    72, 86, 74, 68, 88, 60, 77, 84,
    86, 78, 64, 88, 63, 83, 58, 86,
    67, 70, 73, 88, 75, 69, 86, 61,
    76, 85, 88, 0, 65, 86, 62, 82,
    59, 88, 66, 71, 72, 86, 74, 68,
    88, 60, 77, 84, 86, 78, 64, 88,
    63, 83, 58, 86, 67, 70, 73, 88,
    75, 69, 86, 61, 76, 85, 88, 127,
    65, 86, 62, 82
};

/* OPTION_1_2, 6P 40G + 4P 10G/25G */
static int p2l_mapping_op1_2[] = {
     0, -1,
    /* TSC4L 0~5 */
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    /* TSC4Q 0~1 */
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    /* TSC 0~6*/
     2,  -1,  -1,  -1,
     3,  -1,  -1,  -1,
     4,  -1,  -1,  -1,
     5,  -1,  -1,  -1,
     6,  -1,  -1,  -1,
     7,  -1,  -1,  -1,
     8,  -1,  -1,  -1,
    /* TSCF 0*/
     9,  10,  11,  12
};

static int port_speed_max_op1_2[] = {
     0, -1,
    /* TSC4L 0~5 */
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    /* TSC4Q 0~1 */
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    /* TSC 0~6*/
    420,  -1,  -1,  -1,
    420,  -1,  -1,  -1,
    420,  -1,  -1,  -1,
    420,  -1,  -1,  -1,
    420,  -1,  -1,  -1,
    100,  -1,  -1,  -1,
    420,  -1,  -1,  -1,
    /* TSCF 0*/
    250, 250, 250, 250
};
uint32 tdm_table_op1_2[105] = {
    86, 58, 62, 66, 88, 70, 74, 87,
    82, 58, 62, 89, 66, 70, 74, 86,
    82, 58, 78, 88, 62, 66, 87, 70,
    74, 82, 89, 58, 62, 66, 86, 70,
    74, 82, 88, 58, 62, 87, 66, 70,
    74, 89, 82, 58, 62, 86, 78, 66,
    70, 88, 74, 82, 87, 58, 62, 66,
    89, 70, 74, 82, 86, 58, 78, 62,
    88, 66, 70, 87, 74, 82, 58, 89,
    62, 66, 70, 86, 74, 82, 58, 88,
    62, 66, 87, 70, 74, 82, 89, 58,
    78, 62, 86, 66, 70, 74, 88, 82,
    58, 87, 62, 66, 70, 89, 74, 0,
    82
};

/* OPTION_1_3, 6P 40G + 2P HG[50] */
static int p2l_mapping_op1_3[] = {
     0, -1,
    /* TSC4L 0~5 */
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    /* TSC4Q 0~1 */
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    /* TSC 0~6*/
     2,  -1,  -1,  -1,
     3,  -1,  -1,  -1,
     4,  -1,  -1,  -1,
     5,  -1,  -1,  -1,
     6,  -1,  -1,  -1,
     7,  -1,  -1,  -1,
     8,  -1,  -1,  -1,
    /* TSCF 0*/
     9,  -1,  10,  -1
};
static int port_speed_max_op1_3[] = {
     0, -1,
    /* TSC4L 0~5 */
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    /* TSC4Q 0~1 */
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    /* TSC 0~6*/
    420,  -1,  -1,  -1,
    420,  -1,  -1,  -1,
    420,  -1,  -1,  -1,
    420,  -1,  -1,  -1,
    420,  -1,  -1,  -1,
    100,  -1,  -1,  -1,
    420,  -1,  -1,  -1,
    /* TSCF 0*/
    530,  -1, 530,  -1
};
uint32 tdm_table_op1_3[105] = {
    86, 58, 62, 66, 88, 70, 74, 86,
    82, 58, 62, 88, 66, 70, 74, 86,
    82, 58, 78, 88, 62, 66, 86, 70,
    74, 82, 88, 58, 62, 66, 86, 70,
    74, 82, 88, 58, 62, 86, 66, 70,
    74, 88, 82, 58, 62, 86, 78, 66,
    70, 88, 74, 82, 86, 58, 62, 66,
    88, 70, 74, 82, 86, 58, 78, 62,
    88, 66, 70, 86, 74, 82, 58, 88,
    62, 66, 70, 86, 74, 82, 58, 88,
    62, 66, 86, 70, 74, 82, 88, 58,
    78, 62, 86, 66, 70, 74, 88, 82,
    58, 86, 62, 66, 70, 88, 74, 0,
    82
};

/* OPTION_2_1, 12P 2.5G + 8P 40G */
static int p2l_mapping_op2_1[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     6, 7, 8, 9,
     10, 11, 12, 13,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
    14, -1, -1, -1,
    15, -1, -1, -1,
    16, -1, -1, -1,
    17, -1, -1, -1,
    18, -1, -1, -1,
    19, -1, -1, -1,
    20, -1, -1, -1,
    /* TSCF 0*/
    21, -1, -1, -1
};
static int port_speed_max_op2_1[] = {
       0,  -1,
     /* TSC4L 0~5 */
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
     /* TSC 0~6*/
    420, -1, -1, -1,
    420, -1, -1, -1,
    420, -1, -1, -1,
    420, -1, -1, -1,
    420, -1, -1, -1,
    420, -1, -1, -1,
    420, -1, -1, -1,
    /* TSCF 0*/
    420, -1, -1, -1
};
uint32 tdm_table_op2_1[144] = {
    6, 82, 70, 62, 78, 74, 66, 58,
    86, 10, 82, 70, 62, 78, 74, 66,
    58, 86, 7, 82, 70, 62, 78, 74,
    66, 58, 86, 127, 82, 70, 62, 78,
    74, 66, 58, 86, 8, 82, 70, 62,
    78, 74, 66, 58, 86, 11, 82, 70,
    62, 78, 74, 66, 58, 86, 9, 82,
    70, 62, 78, 74, 66, 58, 86, 127,
    82, 70, 62, 78, 74, 66, 58, 86,
    2, 82, 70, 62, 78, 74, 66, 58,
    86, 12, 82, 70, 62, 78, 74, 66,
    58, 86, 3, 82, 70, 62, 78, 74,
    66, 58, 86, 127, 82, 70, 62, 78,
    74, 66, 58, 86, 4, 82, 70, 62,
    78, 74, 66, 58, 86, 13, 82, 70,
    62, 78, 74, 66, 58, 86, 5, 82,
    70, 62, 78, 74, 66, 58, 86, 0,
    82, 70, 62, 78, 74, 66, 58, 86
};

/* OPTION_3_0, 52P 2.5G + 4P 25G + 8P 10G */
static int p2l_mapping_op3_0[] = {
     0, -1,
    /* TSC4L 0~5 */
     2,  3,  4,  5,
     6,  7,  8,  9,
     10,  11,  12,  13,
     14,  15,  16,  17,
     18,  19,  20,  21,
     22,  23,  24,  25,
    /* TSC4Q 0~1 */
     26,  27,  28,  29,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     30,  31,  32,  33,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    /* TSC 0~6*/
     34,  35,  36,  37,
     38,  39,  40,  41,
     42,  43,  44,  45,
     46,  47,  48,  49,
     50,  51,  52,  53,
     54,  55,  56,  57,
     58,  59,  60,  61,
    /* TSCF 0*/
     62,  63,  64,  65
};
static int port_speed_max_op3_0[] = {
     0, -1,
    /* TSC4L 0~5 */
     25,  25,  25,  25,
     25,  25,  25,  25,
     25,  25,  25,  25,
     25,  25,  25,  25,
     25,  25,  25,  25,
     25,  25,  25,  25,
    /* TSC4Q 0~1 */
     25,  25,  25,  25,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     25,  25,  25,  25,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    /* TSC 0~6*/
     25,  25,  25,  25,
     25,  25,  25,  25,
     25,  25,  25,  25,
     25,  25,  25,  25,
     110,  110,  110,  110,
     25,  25,  25,  25,
     110,  110,  110,  110,
    /* TSCF 0*/
     250,  250,  250,  250
};
uint32 tdm_table_op3_0[252] = {
    76, 88, 82, 71, 89, 84, 78, 86,
    127, 75, 27, 87, 17, 21, 88, 8,
    77, 89, 83, 85, 86, 61, 63, 87,
    45, 74, 88, 10, 22, 89, 9, 65,
    76, 86, 82, 84, 87, 72, 81, 88,
    75, 66, 89, 11, 23, 86, 2, 77,
    87, 83, 28, 88, 85, 59, 69, 89,
    74, 42, 86, 12, 24, 87, 3, 76,
    88, 82, 84, 89, 70, 79, 86, 0,
    75, 25, 87, 13, 29, 88, 4, 77,
    89, 83, 85, 86, 60, 62, 87, 43,
    74, 88, 14, 18, 89, 5, 64, 76,
    86, 82, 84, 87, 73, 80, 88, 75,
    67, 89, 15, 19, 86, 6, 77, 87,
    83, 26, 88, 85, 58, 68, 89, 74,
    44, 86, 16, 20, 87, 7, 76, 88,
    82, 84, 89, 71, 78, 86, 127, 75,
    17, 87, 21, 27, 88, 8, 77, 89,
    83, 85, 86, 61, 63, 87, 45, 74,
    88, 10, 22, 89, 9, 65, 76, 86,
    82, 84, 87, 72, 81, 88, 75, 66,
    89, 11, 23, 86, 2, 77, 87, 83,
    28, 85, 88, 59, 69, 89, 74, 42,
    86, 12, 24, 87, 3, 76, 88, 82,
    84, 89, 70, 79, 86, 127, 75, 29,
    87, 13, 25, 88, 4, 77, 89, 83,
    85, 86, 60, 62, 87, 43, 74, 88,
    14, 18, 89, 5, 64, 76, 86, 82,
    84, 87, 73, 80, 88, 75, 67, 89,
    15, 19, 86, 6, 77, 87, 83, 26,
    85, 88, 58, 68, 89, 74, 44, 86,
    16, 20, 87, 7
};

/* OPTION_3_1, 52P 2.5G + 4P 25G + 2P 40G */
static int p2l_mapping_op3_1[] = {
     0, -1,
    /* TSC4L 0~5 */
     2,  3,  4,  5,
     6,  7,  8,  9,
     10,  11,  12,  13,
     14,  15,  16,  17,
     18,  19,  20,  21,
     22,  23,  24,  25,
    /* TSC4Q 0~1 */
     26,  27,  28,  29,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     30,  31,  32,  33,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    /* TSC 0~6*/
     34,  35,  36,  37,
     38,  39,  40,  41,
     42,  43,  44,  45,
     46,  47,  48,  49,
     50,  -1,  -1,  -1,
     51,  52,  53,  54,
     55,  -1,  -1,  -1,
    /* TSCF 0*/
     56,  57,  58,  59
};
static int port_speed_max_op3_1[] = {
     0, -1,
    /* TSC4L 0~5 */
     25,  25,  25,  25,
     25,  25,  25,  25,
     25,  25,  25,  25,
     25,  25,  25,  25,
     25,  25,  25,  25,
     25,  25,  25,  25,
    /* TSC4Q 0~1 */
     25,  25,  25,  25,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     25,  25,  25,  25,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    /* TSC 0~6*/
     25,  25,  25,  25,
     25,  25,  25,  25,
     25,  25,  25,  25,
     25,  25,  25,  25,
     420,  -1,  -1,  -1,
     25,  25,  25,  25,
     420,  -1,  -1,  -1,
    /* TSCF 0*/
     250,  250,  250,  250
};
uint32 tdm_table_op3_1[128] = {
    127, 127, 88, 74, 13, 89, 82, 22,
    86, 29, 45, 74, 87, 6, 82, 88,
    58, 73, 89, 74, 14, 86, 82, 23,
    87, 64, 67, 74, 88, 7, 82, 89,
    79, 81, 86, 74, 15, 87, 82, 24,
    88, 26, 42, 74, 89, 8, 82, 86,
    61, 62, 87, 74, 16, 88, 82, 25,
    89, 69, 70, 74, 86, 9, 82, 87,
    0, 127, 88, 74, 17, 89, 82, 18,
    86, 27, 43, 74, 87, 2, 82, 88,
    59, 72, 89, 74, 10, 86, 82, 19,
    87, 65, 66, 74, 88, 3, 82, 89,
    78, 80, 86, 74, 11, 87, 82, 20,
    88, 28, 44, 74, 89, 4, 82, 86,
    60, 63, 87, 74, 12, 88, 82, 21,
    89, 68, 71, 74, 86, 5, 82, 87
};

/* OPTION_3_2, 52P 2.5G + 2P 50G + 8P 10G */
static int p2l_mapping_op3_2[] = {
     0, -1,
    /* TSC4L 0~5 */
     2,  3,  4,  5,
     6,  7,  8,  9,
     10,  11,  12,  13,
     14,  15,  16,  17,
     18,  19,  20,  21,
     22,  23,  24,  25,
    /* TSC4Q 0~1 */
     26,  27,  28,  29,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     30,  31,  32,  33,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    /* TSC 0~6*/
     34,  35,  36,  37,
     38,  39,  40,  41,
     42,  43,  44,  45,
     46,  47,  48,  49,
     50,  51,  52,  53,
     54,  55,  56,  57,
     58,  59,  60,  61,
    /* TSCF 0*/
     62,  -1,  63,  -1
};
static int port_speed_max_op3_2[] = {
     0, -1,
    /* TSC4L 0~5 */
     25,  25,  25,  25,
     25,  25,  25,  25,
     25,  25,  25,  25,
     25,  25,  25,  25,
     25,  25,  25,  25,
     25,  25,  25,  25,
    /* TSC4Q 0~1 */
     25,  25,  25,  25,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     25,  25,  25,  25,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    /* TSC 0~6*/
     25,  25,  25,  25,
     25,  25,  25,  25,
     25,  25,  25,  25,
     25,  25,  25,  25,
     110,  110,  110,  110,
     25,  25,  25,  25,
     110,  110,  110,  110,
    /* TSCF 0*/
     530,  -1,  530,  -1
};
uint32 tdm_table_op3_2[250] = {
    59, 88, 19, 3, 74, 86, 15, 81,
    88, 85, 82, 86, 70, 76, 88, 67,
    20, 86, 4, 27, 88, 75, 16, 86,
    84, 83, 88, 62, 45, 77, 86, 65,
    21, 88, 5, 74, 86, 17, 60, 88,
    85, 82, 86, 72, 69, 88, 76, 78,
    86, 22, 6, 88, 75, 10, 28, 86,
    84, 83, 88, 42, 77, 86, 58, 23,
    88, 7, 0, 86, 74, 11, 88, 85,
    80, 86, 82, 71, 88, 76, 29, 24,
    86, 8, 75, 88, 12, 64, 86, 84,
    83, 88, 43, 77, 86, 63, 25, 88,
    9, 74, 86, 66, 13, 88, 61, 85,
    82, 86, 68, 76, 88, 73, 18, 86,
    2, 75, 88, 26, 14, 86, 84, 83,
    88, 44, 77, 86, 79, 59, 88, 19,
    3, 74, 86, 15, 81, 88, 85, 82,
    86, 70, 76, 88, 67, 20, 86, 4,
    27, 88, 75, 16, 86, 84, 83, 88,
    62, 45, 77, 86, 65, 21, 88, 5,
    74, 86, 17, 60, 88, 85, 82, 86,
    72, 69, 88, 76, 78, 86, 22, 6,
    88, 75, 10, 28, 86, 84, 83, 88,
    42, 77, 86, 58, 23, 88, 7, 127,
    86, 74, 11, 88, 85, 82, 86, 80,
    71, 88, 76, 29, 24, 86, 8, 75,
    88, 12, 64, 86, 84, 83, 88, 43,
    77, 86, 63, 25, 88, 9, 74, 86,
    61, 13, 88, 66, 85, 82, 86, 68,
    76, 88, 73, 18, 86, 2, 75, 88,
    26, 14, 86, 84, 83, 88, 79, 44,
    86, 77
};

/* OPTION_3_3, 52P 2.5G + 2P 50G + 2P 40G */
static int p2l_mapping_op3_3[] = {
     0, -1,
    /* TSC4L 0~5 */
     2,  3,  4,  5,
     6,  7,  8,  9,
     10,  11,  12,  13,
     14,  15,  16,  17,
     18,  19,  20,  21,
     22,  23,  24,  25,
    /* TSC4Q 0~1 */
     26,  27,  28,  29,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     30,  31,  32,  33,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    /* TSC 0~6*/
     34,  35,  36,  37,
     38,  39,  40,  41,
     42,  43,  44,  45,
     46,  47,  48,  49,
     50,  -1,  -1,  -1,
     51,  52,  53,  54,
     55,  -1,  -1,  -1,
    /* TSCF 0*/
     56,  -1,  57,  -1
};
static int port_speed_max_op3_3[] = {
     0, -1,
    /* TSC4L 0~5 */
     25,  25,  25,  25,
     25,  25,  25,  25,
     25,  25,  25,  25,
     25,  25,  25,  25,
     25,  25,  25,  25,
     25,  25,  25,  25,
    /* TSC4Q 0~1 */
     25,  25,  25,  25,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
     25,  25,  25,  25,  -1,  -1,  -1,  -1,
     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    /* TSC 0~6*/
     25,  25,  25,  25,
     25,  25,  25,  25,
     25,  25,  25,  25,
     25,  25,  25,  25,
     420,  -1,  -1,  -1,
     25,  25,  25,  25,
     420,  -1,  -1,  -1,
    /* TSCF 0*/
     530,  -1,  530,  -1
};
uint32 tdm_table_op3_3[128] = {
    42, 21, 86, 74, 62, 82, 88, 26,
    15, 86, 66, 74, 88, 82, 4, 86,
    68, 22, 88, 74, 70, 82, 86, 64,
    16, 88, 61, 74, 86, 82, 5, 88,
    43, 23, 86, 74, 73, 82, 88, 27,
    17, 86, 59, 74, 88, 82, 6, 86,
    79, 24, 88, 74, 81, 82, 86, 0,
    10, 88, 127, 74, 86, 82, 7, 88,
    44, 25, 86, 74, 63, 82, 88, 28,
    11, 86, 67, 74, 88, 82, 8, 86,
    69, 18, 88, 74, 71, 82, 86, 65,
    12, 88, 60, 74, 86, 82, 9, 88,
    45, 19, 86, 74, 72, 82, 88, 29,
    13, 86, 58, 74, 88, 82, 2, 86,
    78, 20, 88, 74, 80, 82, 86, 127,
    14, 88, 127, 74, 86, 82, 3, 88
};

/* OPTION_4_0, 48P 2.5G + 4P 25G + 8P 10G */
static int p2l_mapping_op4_0[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     6, 7, 8, 9,
     10, 11, 12, 13,
     14, 15, 16, 17,
     18, 19, 20, 21,
     22, 23, 24, 25,
    /* TSC4Q 0~1 */
     26, 27, 28, 29, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     30, 31, 32, 33, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     34, 35, 36, 37,
     38, 39, 40, 41,
     42, 43, 44, 45,
     46, 47, 48, 49,
     50, 51, 52, 53,
     54, -1, -1, -1,
     55, 56, 57, 58,
    /* TSCF 0*/
     59, 60, 61, 62
};
static int port_speed_max_op4_0[] = {
       0,  -1,
     /* TSC4L 0~5 */
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
    /* TSC4Q 0~1 */
     25, 25, 25, 25, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     25, 25, 25, 25, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     110, 110, 110, 110,
     100, -1, -1, -1,
     110, 110, 110, 110,
    /* TSCF 0*/
     250, 250, 250, 250
};
uint32 tdm_table_op4_0[126] = {
    15, 85, 88, 74, 83, 89, 26, 77, 86, 43,
    5, 87, 78, 18, 64, 88, 16, 84, 89, 75,
    82, 86, 62, 76, 87, 0, 6, 88, 61, 19,
    89, 17, 85, 86, 83, 74, 44, 87, 27, 77,
    88, 58, 7, 89, 78, 20, 86, 10, 84, 87,
    75, 82, 88, 66, 71, 89, 76, 68, 8, 86,
    21, 72, 87, 11, 85, 88, 74, 83, 89, 28,
    77, 86, 45, 9, 87, 127, 22, 78, 88, 12,
    84, 89, 75, 82, 86, 63, 76, 87, 65, 2,
    88, 60, 23, 89, 13, 85, 86, 83, 74, 42,
    87, 29, 77, 88, 59, 3, 89, 78, 24, 86,
    14, 84, 87, 75, 82, 88, 67, 70, 89, 76,
    69, 4, 86, 25, 73, 87
};

/* OPTION_4_1, 48P 2.5G + 4P 25G + 2P 40G  */
static int p2l_mapping_op4_1[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     6, 7, 8, 9,
     10, 11, 12, 13,
     14, 15, 16, 17,
     18, 19, 20, 21,
     22, 23, 24, 25,
    /* TSC4Q 0~1 */
     26, 27, 28, 29, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     30, 31, 32, 33, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     34, 35, 36, 37,
     38, 39, 40, 41,
     42, 43, 44, 45,
     46, 47, 48, 49,
     50, -1, -1, -1,
     51, -1, -1, -1,
     52, -1, -1, -1,
    /* TSCF 0*/
     53, 54, 55, 56
};
static int port_speed_max_op4_1[] = {
       0,  -1,
     /* TSC4L 0~5 */
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
    /* TSC4Q 0~1 */
     25, 25, 25, 25, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     25, 25, 25, 25, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     420, -1, -1, -1,
     100, -1, -1, -1,
     420, -1, -1, -1,
    /* TSCF 0*/
     250, 250, 250, 250
};
uint32 tdm_table_op4_1[128] = {
    88, 74, 5, 89, 78, 60, 82, 86, 23, 74,
    87, 17, 45, 88, 82, 63, 89, 74, 6, 86,
    66, 127, 82, 87, 24, 74, 88, 10, 127, 89,
    82, 28, 86, 74, 7, 87, 78, 72, 82, 88,
    25, 74, 89, 11, 42, 86, 82, 69, 87, 74,
    8, 88, 64, 70, 82, 89, 18, 74, 86, 12,
    58, 87, 82, 29, 88, 74, 9, 89, 78, 61,
    82, 86, 19, 74, 87, 13, 43, 88, 82, 62,
    89, 74, 2, 86, 67, 0, 82, 87, 20, 74,
    88, 14, 127, 89, 82, 26, 86, 74, 3, 87,
    78, 73, 82, 88, 21, 74, 89, 15, 44, 86,
    82, 68, 87, 74, 4, 88, 65, 71, 82, 89,
    22, 74, 86, 16, 59, 87, 82, 27
};

/* OPTION_4_2, 48P 2.5G + 2P 50G + 8P 10G */
static int p2l_mapping_op4_2[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     6, 7, 8, 9,
     10, 11, 12, 13,
     14, 15, 16, 17,
     18, 19, 20, 21,
     22, 23, 24, 25,
    /* TSC4Q 0~1 */
     26, 27, 28, 29, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     30, 31, 32, 33, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     34, 35, 36, 37,
     38, 39, 40, 41,
     42, 43, 44, 45,
     46, 47, 48, 49,
     50, 51, 52, 53,
     54, -1, -1, -1,
     55, 56, 57, 58,
    /* TSCF 0*/
     59, -1, 60, -1
};
static int port_speed_max_op4_2[] = {
       0,  -1,
     /* TSC4L 0~5 */
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
    /* TSC4Q 0~1 */
     25, 25, 25, 25, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     25, 25, 25, 25, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     110, 110, 110, 110,
     100, -1, -1, -1,
     110, 110, 110, 110,
    /* TSCF 0*/
     530, -1, 530, -1
};
uint32 tdm_table_op4_2[251] = {
    58, 23, 86, 16, 66, 88, 8, 75, 86, 82,
    29, 88, 85, 60, 86, 76, 69, 88, 17, 24,
    86, 127, 9, 74, 88, 83, 45, 86, 84, 78,
    88, 77, 71, 86, 10, 25, 88, 73, 2, 86,
    75, 82, 88, 85, 26, 63, 86, 76, 64, 88,
    11, 18, 86, 3, 74, 88, 83, 42, 86, 84,
    78, 88, 77, 59, 86, 12, 19, 88, 67, 4,
    75, 86, 82, 27, 88, 85, 61, 86, 76, 68,
    88, 13, 20, 86, 43, 5, 88, 74, 83, 86,
    84, 78, 72, 88, 77, 70, 86, 14, 21, 88,
    6, 75, 86, 82, 127, 88, 85, 28, 86, 76,
    62, 88, 15, 22, 65, 86, 7, 74, 88, 83,
    44, 86, 84, 78, 88, 77, 58, 86, 16, 23,
    88, 66, 8, 86, 75, 82, 85, 88, 29, 60,
    86, 76, 69, 88, 17, 24, 86, 9, 74, 88,
    83, 45, 86, 84, 78, 88, 77, 71, 86, 73,
    10, 25, 88, 2, 75, 86, 82, 85, 88, 26,
    63, 86, 76, 64, 88, 11, 18, 86, 59, 3,
    88, 74, 83, 84, 86, 42, 78, 88, 77, 0,
    86, 12, 19, 88, 4, 75, 86, 82, 27, 88,
    85, 61, 86, 76, 67, 20, 88, 13, 68, 86,
    5, 74, 88, 83, 43, 86, 84, 78, 88, 77,
    70, 86, 14, 21, 88, 75, 6, 86, 72, 82,
    85, 88, 28, 62, 86, 76, 65, 88, 15, 22,
    86, 7, 74, 88, 83, 44, 86, 84, 78, 88,
    77
};

/* OPTION_4_3, 48P 2.5G + 2P 50G + 2P 40G */
static int p2l_mapping_op4_3[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     6, 7, 8, 9,
     10, 11, 12, 13,
     14, 15, 16, 17,
     18, 19, 20, 21,
     22, 23, 24, 25,
    /* TSC4Q 0~1 */
     26, 27, 28, 29, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     30, 31, 32, 33, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     34, 35, 36, 37,
     38, 39, 40, 41,
     42, 43, 44, 45,
     46, 47, 48, 49,
     50, -1, -1, -1,
     51, -1, -1, -1,
     52, -1, -1, -1,
    /* TSCF 0*/
     53, -2, 54, -2
};
static int port_speed_max_op4_3[] = {
       0,  -1,
     /* TSC4L 0~5 */
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
    /* TSC4Q 0~1 */
     25, 25, 25, 25, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     25, 25, 25, 25, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     25, 25, 25, 25,
     420, -1, -1, -1,
     100, -1, -1, -1,
     420, -1, -1, -1,
    /* TSCF 0*/
     530, -1, 530, -1
};
uint32 tdm_table_op4_3[128] = {
    88, 82, 0, 86, 74, 5, 78, 88, 11, 82,
    86, 20, 74, 88, 27, 58, 86, 82, 60, 88,
    74, 6, 44, 86, 12, 82, 88, 21, 74, 86,
    67, 73, 88, 82, 127, 86, 74, 7, 78, 88,
    13, 82, 86, 22, 74, 88, 28, 70, 86, 82,
    63, 88, 74, 8, 45, 86, 14, 82, 88, 23,
    74, 86, 64, 69, 88, 82, 127, 86, 74, 9,
    78, 88, 15, 82, 86, 24, 74, 88, 29, 59,
    86, 82, 61, 88, 74, 2, 42, 86, 16, 82,
    88, 25, 74, 86, 66, 72, 88, 82, 127, 86,
    74, 3, 78, 88, 17, 82, 86, 18, 74, 88,
    26, 71, 86, 82, 62, 88, 74, 4, 43, 86,
    10, 82, 88, 19, 74, 86, 65, 68
};

/* OPTION_5_0, 24P 2.5G + 4P 25G + 8P 10G */
static int p2l_mapping_op5_0[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     -1, -1, -1, -1,
     6, 7, 8, 9,
     -1, -1, -1, -1,
     10, 11, 12, 13,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     14, 15, 16, 17, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     18, 19, 20, 21,
     -1, -1, -1, -1,
     22, 23, 24, 25,
     -1, -1, -1, -1,
     26, 27, 28, 29,
     30, -1, -1, -1,
     31, 32, 33, 34,
    /* TSCF 0*/
     35, 36, 37, 38
};
static int port_speed_max_op5_0[] = {
       0,  -1,
     /* TSC4L 0~5 */
     25, 25, 25, 25,
     -1, -1, -1, -1,
     25, 25, 25, 25,
     -1, -1, -1, -1,
     25, 25, 25, 25,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     25, 25, 25, 25, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     25, 25, 25, 25,
     -1, -1, -1, -1,
     25, 25, 25, 25,
     -1, -1, -1, -1,
     110, 110, 110, 110,
     100, -1, -1, -1,
     110, 110, 110, 110,
    /* TSCF 0*/
     250, 250, 250, 250
};
uint32 tdm_table_op5_0[102] = {
    88, 84, 89, 75, 29, 86, 83, 87, 78, 60,
    88, 76, 89, 85, 21, 86, 74, 2, 87, 82,
    88, 10, 0, 89, 77, 86, 84, 26, 87, 75,
    88, 83, 58, 89, 78, 86, 66, 76, 87, 85,
    88, 74, 3, 89, 82, 18, 86, 11, 87, 77,
    68, 88, 84, 89, 75, 27, 86, 83, 87, 78,
    61, 88, 76, 89, 85, 127, 86, 74, 4, 87,
    82, 88, 12, 19, 89, 77, 86, 84, 28, 87,
    75, 88, 83, 59, 89, 78, 86, 67, 76, 87,
    85, 88, 74, 69, 89, 82, 5, 86, 13, 87,
    77, 20
};

/* OPTION_5_1, 24P 2.5G + 4P 25G + 2P 40G */
static int p2l_mapping_op5_1[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     -1, -1, -1, -1,
     6, 7, 8, 9,
     -1, -1, -1, -1,
     10, 11, 12, 13,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     14, 15, 16, 17, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     18, 19, 20, 21,
     -1, -1, -1, -1,
     22, 23, 24, 25,
     -1, -1, -1, -1,
     26, -1, -1, -1,
     27, -1, -1, -1,
     28, -1, -1, -1,
    /* TSCF 0*/
     29, 30, 31, 32
};
static int port_speed_max_op5_1[] = {
       0,  -1,
     /* TSC4L 0~5 */
     25, 25, 25, 25,
     -1, -1, -1, -1,
     25, 25, 25, 25,
     -1, -1, -1, -1,
     25, 25, 25, 25,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     25, 25, 25, 25, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     25, 25, 25, 25,
     -1, -1, -1, -1,
     25, 25, 25, 25,
     -1, -1, -1, -1,
     420, -1, -1, -1,
     100, -1, -1, -1,
     420, -1, -1, -1,
    /* TSCF 0*/
     250, 250, 250, 250
};
uint32 tdm_table_op5_1[204] = {
    4, 87, 59, 74, 88, 82, 89, 78, 74, 86,
    21, 87, 82, 10, 88, 74, 89, 61, 82, 86,
    29, 87, 74, 68, 88, 82, 89, 5, 74, 86,
    78, 82, 87, 67, 88, 74, 82, 89, 18, 86,
    11, 74, 87, 82, 88, 58, 26, 89, 74, 86,
    82, 2, 87, 78, 74, 88, 82, 89, 60, 0,
    86, 74, 87, 82, 12, 88, 19, 89, 74, 82,
    86, 27, 87, 74, 69, 88, 82, 89, 3, 74,
    86, 78, 82, 87, 127, 88, 74, 59, 89, 82,
    86, 13, 74, 87, 20, 88, 82, 28, 89, 74,
    86, 82, 4, 87, 78, 74, 88, 82, 89, 61,
    74, 86, 66, 87, 82, 10, 88, 74, 89, 21,
    82, 86, 29, 87, 74, 68, 88, 82, 89, 5,
    74, 86, 78, 82, 87, 67, 88, 74, 58, 89,
    82, 86, 11, 74, 87, 18, 88, 82, 26, 89,
    74, 86, 82, 2, 87, 78, 74, 88, 82, 89,
    60, 19, 86, 74, 87, 82, 12, 88, 74, 89,
    127, 82, 86, 27, 87, 74, 69, 88, 82, 89,
    3, 74, 86, 78, 82, 87, 20, 88, 74, 13,
    89, 82, 86, 127, 74, 87, 66, 88, 82, 28,
    89, 74, 86, 82
};

/* OPTION_5_3, 24P 2.5G + 2P 50G + 2P 40G */
static int p2l_mapping_op5_3[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     -1, -1, -1, -1,
     6, 7, 8, 9,
     -1, -1, -1, -1,
     10, 11, 12, 13,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     14, 15, 16, 17, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     18, 19, 20, 21,
     -1, -1, -1, -1,
     22, 23, 24, 25,
     -1, -1, -1, -1,
     26, -1, -1, -1,
     27, -1, -1, -1,
     28, -1, -1, -1,
    /* TSCF 0*/
     29, -1, 30, -1
};
static int port_speed_max_op5_3[] = {
       0,  -1,
     /* TSC4L 0~5 */
     25, 25, 25, 25,
     -1, -1, -1, -1,
     25, 25, 25, 25,
     -1, -1, -1, -1,
     25, 25, 25, 25,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     25, 25, 25, 25, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
     25, 25, 25, 25,
     -1, -1, -1, -1,
     25, 25, 25, 25,
     -1, -1, -1, -1,
     420, -1, -1, -1,
     100, -1, -1, -1,
     420, -1, -1, -1,
    /* TSCF 0*/
     530, -1, 530, -1
};
uint32 tdm_table_op5_3[102] = {
    11, 74, 88, 82, 86, 18, 2, 88, 74, 86,
    82, 26, 88, 66, 74, 86, 82, 88, 68, 74,
    86, 78, 88, 82, 58, 86, 74, 88, 12, 82,
    86, 19, 88, 74, 3, 86, 82, 27, 88, 74,
    86, 60, 82, 88, 0, 86, 74, 78, 88, 82,
    86, 28, 74, 88, 13, 86, 82, 4, 88, 74,
    86, 82, 20, 88, 67, 74, 86, 82, 88, 69,
    74, 86, 78, 88, 82, 59, 86, 74, 88, 10,
    82, 86, 5, 88, 74, 21, 86, 82, 29, 88,
    74, 86, 61, 82, 88, 127, 86, 74, 78, 88,
    82, 86
};

/* OPTION_6_0, 36P 1G + 12P 10G + 4P 25G + 8P 10G */
static int p2l_mapping_op6_0[] = {
     0, -1,
    /* TSC4L 0~5 */
     2,  3,  4,  5,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     6,  7,  8,  9, 10, 11, 12, 13,
    14, 15, 16, 17, 18, 19, 20, 21,
    22, 23, 24, 25, 26, 27, 28, 29,
    30, 31, 32, 33, 34, 35, 36, 37,
    /* TSC 0~6*/
    38, 39, 40, 41,
    -1, -1, -1, -1,
    42, 43, 44, 45,
    46, 47, 48, 49,
    50, 51, 52, 53,
    54, -1, -1, -1,
    55, 56, 57, 58,
    /* TSCF 0*/
    59, 60, 61, 62
};
static int port_speed_max_op6_0[] = {
       0,  -1,
     /* TSC4L 0~5 */
    10, 10, 10, 10,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    /* TSC4Q 0~1 */
    10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10,
    /* TSC 0~6*/
    100, 100, 100, 100,
    -1, -1, -1, -1,
    100, 100, 100, 100,
    100, 100, 100, 100,
    110, 110, 110, 110,
    100, -1, -1, -1,
    110, 110, 110, 110,
    /* TSCF 0*/
    250, 250, 250, 250
};
uint32 tdm_table_op6_0[315] = {
    86, 58, 2, 66, 88, 70, 74, 87, 82, 59,
    3, 89, 67, 71, 75, 86, 83, 60, 78, 88,
    4, 68, 87, 72, 76, 84, 89, 61, 5, 69,
    86, 73, 77, 85, 88, 58, 26, 87, 66, 70,
    74, 89, 82, 59, 27, 86, 78, 67, 71, 88,
    75, 83, 87, 60, 28, 68, 89, 72, 76, 84,
    86, 61, 78, 29, 88, 69, 73, 87, 77, 85,
    58, 89, 30, 66, 70, 86, 74, 82, 59, 88,
    31, 67, 87, 71, 75, 83, 89, 60, 78, 32,
    86, 68, 72, 76, 88, 84, 61, 87, 33, 69,
    73, 89, 77, 34, 85, 86, 58, 35, 66, 88,
    70, 74, 87, 82, 59, 36, 89, 67, 71, 75,
    86, 83, 60, 78, 88, 37, 68, 87, 72, 76,
    84, 89, 61, 38, 69, 86, 73, 77, 85, 88,
    58, 39, 87, 66, 70, 74, 89, 82, 59, 40,
    86, 78, 67, 71, 88, 75, 83, 87, 60, 41,
    68, 89, 72, 76, 84, 86, 61, 78, 42, 88,
    69, 73, 87, 77, 85, 58, 89, 43, 66, 70,
    86, 74, 82, 59, 88, 44, 67, 87, 71, 75,
    83, 89, 60, 78, 45, 86, 68, 72, 76, 88,
    84, 61, 87, 46, 69, 73, 89, 77, 47, 85,
    86, 58, 127, 66, 88, 70, 74, 87, 82, 59,
    48, 89, 67, 71, 75, 86, 83, 60, 78, 88,
    49, 68, 87, 72, 76, 84, 89, 61, 50, 69,
    86, 73, 77, 85, 88, 58, 51, 87, 66, 70,
    74, 89, 82, 59, 52, 86, 78, 67, 71, 88,
    75, 83, 87, 60, 53, 68, 89, 72, 76, 84,
    86, 61, 78, 54, 88, 69, 73, 87, 77, 85,
    58, 89, 127, 66, 70, 86, 74, 82, 59, 88,
    55, 67, 87, 71, 75, 83, 89, 60, 78, 56,
    86, 68, 72, 76, 88, 84, 61, 87, 57, 69,
    73, 89, 77, 0, 85
};

/* OPTION_6_1, 36P 1G + 12P 10G + 4P 25G + 2P 40G */
static int p2l_mapping_op6_1[] = {
     0, -1,
    /* TSC4L 0~5 */
      2, 3,  4,  5,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
      6,  7,  8,  9, 10, 11, 12, 13,
     14, 15, 16, 17, 18, 19, 20, 21,
     22, 23, 24, 25, 26, 27, 28, 29,
     30, 31, 32, 33, 34, 35, 36, 37,
    /* TSC 0~6*/
    38, 39, 40, 41,
    -1, -1, -1, -1,
    42, 43, 44, 45,
    46, 47, 48, 49,
    50, -1, -1, -1,
    51, -1, -1, -1,
    52, -1, -1, -1,
    /* TSCF 0*/
    53, 54, 55, 56
};
static int port_speed_max_op6_1[] = {
     0,  -1,
    /* TSC4L 0~5 */
    10, 10, 10, 10,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    /* TSC4Q 0~1 */
    10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10,
     /* TSC 0~6*/
    100, 100, 100, 100,
    -1, -1, -1, -1,
    100, 100, 100, 100,
    100, 100, 100, 100,
    420, -1, -1, -1,
    100, -1, -1, -1,
    420, -1, -1, -1,
    /* TSCF 0*/
    250, 250, 250, 250
};
uint32 tdm_table_op6_1[315] = {
    86, 58, 2, 66, 88, 70, 74, 87, 82, 59,
    3, 89, 67, 71, 74, 86, 82, 60, 78, 88,
    4, 68, 87, 72, 74, 82, 89, 61, 5, 69,
    86, 73, 74, 82, 88, 58, 26, 87, 66, 70,
    74, 89, 82, 59, 27, 86, 78, 67, 71, 88,
    74, 82, 87, 60, 28, 68, 89, 72, 74, 82,
    86, 61, 78, 29, 88, 69, 73, 87, 74, 82,
    58, 89, 30, 66, 70, 86, 74, 82, 59, 88,
    31, 67, 87, 71, 74, 82, 89, 60, 78, 32,
    86, 68, 72, 74, 88, 82, 61, 87, 33, 69,
    73, 89, 74, 34, 82, 86, 58, 35, 66, 88,
    70, 74, 87, 82, 59, 36, 89, 67, 71, 74,
    86, 82, 60, 78, 88, 37, 68, 87, 72, 74,
    82, 89, 61, 38, 69, 86, 73, 74, 82, 88,
    58, 39, 87, 66, 70, 74, 89, 82, 59, 40,
    86, 78, 67, 71, 88, 74, 82, 87, 60, 41,
    68, 89, 72, 74, 82, 86, 61, 78, 42, 88,
    69, 73, 87, 74, 82, 58, 89, 43, 66, 70,
    86, 74, 82, 59, 88, 44, 67, 87, 71, 74,
    82, 89, 60, 78, 45, 86, 68, 72, 74, 88,
    82, 61, 87, 46, 69, 73, 89, 74, 47, 82,
    86, 58, 127, 66, 88, 70, 74, 87, 82, 59,
    48, 89, 67, 71, 74, 86, 82, 60, 78, 88,
    49, 68, 87, 72, 74, 82, 89, 61, 50, 69,
    86, 73, 74, 82, 88, 58, 51, 87, 66, 70,
    74, 89, 82, 59, 52, 86, 78, 67, 71, 88,
    74, 82, 87, 60, 53, 68, 89, 72, 74, 82,
    86, 61, 78, 54, 88, 69, 73, 87, 74, 82,
    58, 89, 127, 66, 70, 86, 74, 82, 59, 88,
    55, 67, 87, 71, 74, 82, 89, 60, 78, 56,
    86, 68, 72, 74, 88, 82, 61, 87, 57, 69,
    73, 89, 74, 0, 82
};

/* OPTION_6_2, 36P 1G + 12P 10G + 2P 50G + 8P 10G */
static int p2l_mapping_op6_2[] = {
     0, -1,
    /* TSC4L 0~5 */
     2,  3,  4,  5,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     6,  7,  8,  9, 10, 11, 12, 13,
    14, 15, 16, 17, 18, 19, 20, 21,
    22, 23, 24, 25, 26, 27, 28, 29,
    30, 31, 32, 33, 34, 35, 36, 37,
    /* TSC 0~6*/
    38, 39, 40, 41,
    -1, -1, -1, -1,
    42, 43, 44, 45,
    46, 47, 48, 49,
    50, 51, 52, 53,
    54, -1, -1, -1,
    55, 56, 57, 58,
    /* TSCF 0*/
    59, -1, 60, -1
};
static int port_speed_max_op6_2[] = {
       0,  -1,
     /* TSC4L 0~5 */
    10, 10, 10, 10,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    /* TSC4Q 0~1 */
    10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10,
    /* TSC 0~6*/
    100, 100, 100, 100,
    -1, -1, -1, -1,
    100, 100, 100, 100,
    100, 100, 100, 100,
    110, 110, 110, 110,
    100, -1, -1, -1,
    110, 110, 110, 110,
    /* TSCF 0*/
    530, -1, 530, -1
};
uint32 tdm_table_op6_2[315] = {
    86, 58, 2, 66, 88, 70, 74, 86,
    82, 59, 3, 88, 67, 71, 75, 86,
    83, 60, 78, 88, 4, 68, 86, 72,
    76, 84, 88, 61, 5, 69, 86, 73,
    77, 85, 88, 58, 26, 86, 66, 70,
    74, 88, 82, 59, 27, 86, 78, 67,
    71, 88, 75, 83, 86, 60, 28, 68,
    88, 72, 76, 84, 86, 61, 78, 29,
    88, 69, 73, 86, 77, 85, 58, 88,
    30, 66, 70, 86, 74, 82, 59, 88,
    31, 67, 86, 71, 75, 83, 88, 60,
    78, 32, 86, 68, 72, 76, 88, 84,
    61, 86, 33, 69, 73, 88, 77, 34,
    85, 86, 58, 35, 66, 88, 70, 74,
    86, 82, 59, 36, 88, 67, 71, 75,
    86, 83, 60, 78, 88, 37, 68, 86,
    72, 76, 84, 88, 61, 38, 69, 86,
    73, 77, 85, 88, 58, 39, 86, 66,
    70, 74, 88, 82, 59, 40, 86, 78,
    67, 71, 88, 75, 83, 86, 60, 41,
    68, 88, 72, 76, 84, 86, 61, 78,
    42, 88, 69, 73, 86, 77, 85, 58,
    88, 43, 66, 70, 86, 74, 82, 59,
    88, 44, 67, 86, 71, 75, 83, 88,
    60, 78, 45, 86, 68, 72, 76, 88,
    84, 61, 86, 46, 69, 73, 88, 77,
    47, 85, 86, 58, 127, 66, 88, 70,
    74, 86, 82, 59, 48, 88, 67, 71,
    75, 86, 83, 60, 78, 88, 49, 68,
    86, 72, 76, 84, 88, 61, 50, 69,
    86, 73, 77, 85, 88, 58, 51, 86,
    66, 70, 74, 88, 82, 59, 52, 86,
    78, 67, 71, 88, 75, 83, 86, 60,
    53, 68, 88, 72, 76, 84, 86, 61,
    78, 54, 88, 69, 73, 86, 77, 85,
    58, 88, 127, 66, 70, 86, 74, 82,
    59, 88, 55, 67, 86, 71, 75, 83,
    88, 60, 78, 56, 86, 68, 72, 76,
    88, 84, 61, 86, 57, 69, 73, 88,
    77, 0, 85
};

/* OPTION_6_3, 36P 1G + 12P 10G + 2P 50G + 2P 40G */
static int p2l_mapping_op6_3[] = {
     0, -1,
    /* TSC4L 0~5 */
     2,  3,  4,  5,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     6,  7,  8,  9, 10, 11, 12, 13,
    14, 15, 16, 17, 18, 19, 20, 21,
    22, 23, 24, 25, 26, 27, 28, 29,
    30, 31, 32, 33, 34, 35, 36, 37,
    /* TSC 0~6*/
    38, 39, 40, 41,
    -1, -1, -1, -1,
    42, 43, 44, 45,
    46, 47, 48, 49,
    50, -1, -1, -1,
    51, -1, -1, -1,
    52, -1, -1, -1,
    /* TSCF 0*/
    53, -1, 54, -1
};
static int port_speed_max_op6_3[] = {
       0,  -1,
     /* TSC4L 0~5 */
    10, 10, 10, 10,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    /* TSC4Q 0~1 */
    10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10,
     /* TSC 0~6*/
    100, 100, 100, 100,
    -1, -1, -1, -1,
    100, 100, 100, 100,
    100, 100, 100, 100,
    420, -1, -1, -1,
    100, -1, -1, -1,
    420, -1, -1, -1,
    /* TSCF 0*/
    530, -1, 530, -1
};
uint32 tdm_table_op6_3[315] = {
    86, 58, 2, 66, 88, 70, 74, 86,
    82, 59, 3, 88, 67, 71, 74, 86,
    82, 60, 78, 88, 4, 68, 86, 72,
    74, 82, 88, 61, 5, 69, 86, 73,
    74, 82, 88, 58, 26, 86, 66, 70,
    74, 88, 82, 59, 27, 86, 78, 67,
    71, 88, 74, 82, 86, 60, 28, 68,
    88, 72, 74, 82, 86, 61, 78, 29,
    88, 69, 73, 86, 74, 82, 58, 88,
    30, 66, 70, 86, 74, 82, 59, 88,
    31, 67, 86, 71, 74, 82, 88, 60,
    78, 32, 86, 68, 72, 74, 88, 82,
    61, 86, 33, 69, 73, 88, 74, 34,
    82, 86, 58, 35, 66, 88, 70, 74,
    86, 82, 59, 36, 88, 67, 71, 74,
    86, 82, 60, 78, 88, 37, 68, 86,
    72, 74, 82, 88, 61, 38, 69, 86,
    73, 74, 82, 88, 58, 39, 86, 66,
    70, 74, 88, 82, 59, 40, 86, 78,
    67, 71, 88, 74, 82, 86, 60, 41,
    68, 88, 72, 74, 82, 86, 61, 78,
    42, 88, 69, 73, 86, 74, 82, 58,
    88, 43, 66, 70, 86, 74, 82, 59,
    88, 44, 67, 86, 71, 74, 82, 88,
    60, 78, 45, 86, 68, 72, 74, 88,
    82, 61, 86, 46, 69, 73, 88, 74,
    47, 82, 86, 58, 127, 66, 88, 70,
    74, 86, 82, 59, 48, 88, 67, 71,
    74, 86, 82, 60, 78, 88, 49, 68,
    86, 72, 74, 82, 88, 61, 50, 69,
    86, 73, 74, 82, 88, 58, 51, 86,
    66, 70, 74, 88, 82, 59, 52, 86,
    78, 67, 71, 88, 74, 82, 86, 60,
    53, 68, 88, 72, 74, 82, 86, 61,
    78, 54, 88, 69, 73, 86, 74, 82,
    58, 88, 127, 66, 70, 86, 74, 82,
    59, 88, 55, 67, 86, 71, 74, 82,
    88, 60, 78, 56, 86, 68, 72, 74,
    88, 82, 61, 86, 57, 69, 73, 88,
    74, 0, 82
};

/* OPTION_7_0, 12P 1G + 12P 10G + 4P 25G + 8P 10G */
static int p2l_mapping_op7_0[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     6, 7, 8, 9, 10, 11, 12, 13,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
    14, 15, 16, 17,
    -1, -1, -1, -1,
    18, 19, 20, 21,
    22, 23, 24, 25,
    26, 27, 28, 29,
    30, -1, -1, -1,
    31, 32, 33, 34,
    /* TSCF 0*/
    35, 36, 37, 38
};
static int port_speed_max_op7_0[] = {
       0,  -1,
     /* TSC4L 0~5 */
     10, 10, 10, 10,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     10, 10, 10, 10, 10, 10, 10, 10,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
    100, 100, 100, 100,
    -1, -1, -1, -1,
    100, 100, 100, 100,
    100, 100, 100, 100,
    110, 110, 110, 110,
    100, -1, -1, -1,
    110, 110, 110, 110,
    /* TSCF 0*/
    250, 250, 250, 250
};
uint32 tdm_table_op7_0[204] = {
    68, 73, 86, 85, 67, 87, 32, 78, 82, 88,
    59, 61, 89, 75, 77, 86, 70, 69, 72, 87,
    84, 66, 88, 127, 33, 83, 89, 58, 60, 86,
    74, 76, 87, 71, 68, 73, 88, 85, 67, 89,
    3, 78, 82, 86, 59, 61, 87, 75, 77, 88,
    70, 69, 72, 89, 84, 66, 86, 26, 127, 83,
    87, 58, 60, 88, 74, 76, 89, 71, 68, 73,
    86, 85, 67, 87, 127, 78, 82, 88, 59, 61,
    89, 75, 77, 86, 70, 69, 72, 87, 84, 66,
    88, 27, 4, 83, 89, 58, 60, 86, 74, 76,
    87, 71, 68, 73, 88, 85, 67, 89, 28, 78,
    82, 86, 59, 61, 87, 75, 77, 88, 70, 69,
    72, 89, 84, 66, 86, 127, 127, 83, 87, 58,
    60, 88, 74, 76, 89, 71, 68, 73, 86, 85,
    67, 87, 29, 78, 82, 88, 59, 61, 89, 75,
    77, 86, 70, 69, 72, 87, 84, 66, 88, 30,
    5, 83, 89, 58, 60, 86, 74, 76, 87, 71,
    68, 73, 88, 85, 67, 89, 0, 78, 82, 86,
    59, 61, 87, 75, 77, 88, 70, 69, 72, 89,
    84, 66, 86, 31, 2, 83, 87, 58, 60, 88,
    74, 76, 89, 71
};

/* OPTION_7_1, 12P 1G + 12P 10G + 4P 25G + 2P 40G */
static int p2l_mapping_op7_1[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     6, 7, 8, 9, 10, 11, 12, 13,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
    14, 15, 16, 17,
    -1, -1, -1, -1,
    18, 19, 20, 21,
    22, 23, 24, 25,
    26, -1, -1, -1,
    27, -1, -1, -1,
    28, -1, -1, -1,
    /* TSCF 0*/
    29, 30, 31, 32
};
static int port_speed_max_op7_1[] = {
       0,  -1,
     /* TSC4L 0~5 */
     10, 10, 10, 10,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     10, 10, 10, 10, 10, 10, 10, 10,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
    100, 100, 100, 100,
    -1, -1, -1, -1,
    100, 100, 100, 100,
    100, 100, 100, 100,
    420, -1, -1, -1,
    100, -1, -1, -1,
    420, -1, -1, -1,
    /* TSCF 0*/
    250, 250, 250, 250
};
uint32 tdm_table_op7_1[204] = {
    66, 86, 68, 127, 82, 87, 74, 70, 88, 61,
    27, 89, 82, 73, 74, 86, 58, 67, 87, 69,
    78, 82, 88, 74, 71, 89, 60, 5, 86, 82,
    72, 74, 87, 59, 66, 88, 68, 127, 82, 89,
    74, 70, 86, 61, 28, 87, 82, 73, 74, 88,
    58, 67, 89, 69, 78, 82, 86, 74, 71, 87,
    60, 29, 88, 82, 72, 74, 89, 59, 66, 86,
    68, 2, 82, 87, 74, 70, 88, 61, 127, 89,
    82, 73, 74, 86, 58, 67, 87, 69, 78, 82,
    88, 74, 71, 89, 60, 30, 86, 82, 72, 74,
    87, 59, 66, 88, 68, 127, 82, 89, 74, 70,
    86, 61, 31, 87, 82, 73, 74, 88, 58, 67,
    89, 69, 78, 82, 86, 74, 71, 87, 60, 3,
    88, 82, 72, 74, 89, 59, 66, 86, 68, 0,
    82, 87, 74, 70, 88, 61, 32, 89, 82, 73,
    74, 86, 58, 67, 87, 69, 78, 82, 88, 74,
    71, 89, 60, 33, 86, 82, 72, 74, 87, 59,
    66, 88, 68, 4, 82, 89, 74, 70, 86, 61,
    127, 87, 82, 73, 74, 88, 58, 67, 89, 69,
    78, 82, 86, 74, 71, 87, 60, 26, 88, 82,
    72, 74, 89, 59
};

/* OPTION_7_2, 12P 1G + 12P 10G + 2P 50G + 8P 10G */
static int p2l_mapping_op7_2[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     6, 7, 8, 9, 10, 11, 12, 13,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
    14, 15, 16, 17,
    -1, -1, -1, -1,
    18, 19, 20, 21,
    22, 23, 24, 25,
    26, 27, 28, 29,
    30, -1, -1, -1,
    31, 32, 33, 34,
    /* TSCF 0*/
    35, -1, 36, -1
};
static int port_speed_max_op7_2[] = {
       0,  -1,
     /* TSC4L 0~5 */
     10, 10, 10, 10,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     10, 10, 10, 10, 10, 10, 10, 10,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
    100, 100, 100, 100,
    -1, -1, -1, -1,
    100, 100, 100, 100,
    100, 100, 100, 100,
    110, 110, 110, 110,
    100, -1, -1, -1,
    110, 100, 110, 110,
    /* TSCF 0*/
    530, -1, 530, -1
};
uint32 tdm_table_op7_2[204] = {
    77, 85, 86, 58, 33, 2, 88, 71, 74, 86,
    82, 60, 88, 66, 68, 73, 86, 76, 84, 88,
    59, 26, 78, 86, 70, 75, 88, 83, 61, 86,
    67, 69, 72, 88, 77, 85, 86, 58, 127, 27,
    88, 71, 74, 86, 82, 60, 88, 66, 68, 73,
    86, 76, 84, 88, 59, 3, 78, 86, 70, 75,
    88, 83, 61, 86, 67, 69, 72, 88, 77, 85,
    86, 58, 28, 127, 88, 71, 74, 86, 82, 60,
    88, 66, 68, 73, 86, 76, 84, 88, 59, 0,
    78, 86, 70, 75, 88, 83, 61, 86, 67, 69,
    72, 88, 77, 85, 86, 58, 29, 4, 88, 71,
    74, 86, 82, 60, 88, 66, 68, 73, 86, 76,
    84, 88, 59, 30, 78, 86, 70, 75, 88, 83,
    61, 86, 67, 69, 72, 88, 77, 85, 86, 58,
    127, 31, 88, 71, 74, 86, 82, 60, 88, 66,
    68, 73, 86, 76, 84, 88, 59, 5, 78, 86,
    70, 75, 88, 83, 61, 86, 67, 69, 72, 88,
    77, 85, 86, 58, 32, 127, 88, 71, 74, 86,
    82, 60, 88, 66, 68, 73, 86, 76, 84, 88,
    59, 127, 78, 86, 70, 75, 88, 83, 61, 86,
    67, 69, 72, 88
};

/* OPTION_7_3, 12P 1G + 12P 10G + 2P 50G + 2P 40G */
static int p2l_mapping_op7_3[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     6, 7, 8, 9, 10, 11, 12, 13,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
    14, 15, 16, 17,
    -1, -1, -1, -1,
    18, 19, 20, 21,
    22, 23, 24, 25,
    26, -1, -1, -1,
    27, -1, -1, -1,
    28, -1, -1, -1,
    /* TSCF 0*/
    29, -1, 30, -1
};
static int port_speed_max_op7_3[] = {
       0,  -1,
     /* TSC4L 0~5 */
     10, 10, 10, 10,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     10, 10, 10, 10, 10, 10, 10, 10,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
    100, 100, 100, 100,
    -1, -1, -1, -1,
    100, 100, 100, 100,
    100, 100, 100, 100,
    420, -1, -1, -1,
    100, -1, -1, -1,
    420, -1, -1, -1,
    /* TSCF 0*/
    530, -1, 530, -1
};
uint32 tdm_table_op7_3[204] = {
    71, 88, 60, 74, 86, 26, 82, 0, 88, 72,
    68, 86, 74, 67, 82, 88, 58, 70, 86, 61,
    74, 88, 127, 82, 78, 86, 73, 69, 88, 74,
    66, 82, 86, 59, 71, 88, 60, 74, 86, 27,
    82, 2, 88, 72, 68, 86, 74, 67, 82, 88,
    58, 70, 86, 61, 74, 88, 28, 82, 78, 86,
    73, 69, 88, 74, 66, 82, 86, 59, 71, 88,
    60, 74, 86, 127, 82, 29, 88, 72, 68, 86,
    74, 67, 82, 88, 58, 70, 86, 61, 74, 88,
    127, 82, 78, 86, 73, 69, 88, 74, 66, 82,
    86, 59, 71, 88, 60, 74, 86, 30, 82, 3,
    88, 72, 68, 86, 74, 67, 82, 88, 58, 70,
    86, 61, 74, 88, 127, 82, 78, 86, 73, 69,
    88, 74, 66, 82, 86, 59, 71, 88, 60, 74,
    86, 31, 82, 4, 88, 72, 68, 86, 74, 67,
    82, 88, 58, 70, 86, 61, 74, 88, 32, 82,
    78, 86, 73, 69, 88, 74, 66, 82, 86, 59,
    71, 88, 60, 74, 86, 127, 82, 33, 88, 72,
    68, 86, 74, 67, 82, 88, 58, 70, 86, 61,
    74, 88, 5, 82, 78, 86, 73, 69, 88, 74,
    66, 82, 86, 59
};

/* OPTION_8_0, 56P 1G + 4P 25G  + 4P 10G  */
static int p2l_mapping_op8_0[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     6, 7, 8, 9,
     10, 11, 12, 13,
     14, 15, 16, 17,
     18, 19, 20, 21,
     22, 23, 24, 25,
    /* TSC4Q 0~1 */
     26, 27, 28, 29, 30, 31, 32, 33,
     34, 35, 36, 37, 38, 39, 40, 41,
     42, 43, 44, 45, 46, 47, 48, 49,
     50, 51, 52, 53, 54, 55, 56, 57,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    58, 59, 60, 61,
    /* TSCF 0*/
    62, 63, 64, 65
};
static int port_speed_max_op8_0[] = {
       0,  -1,
     /* TSC4L 0~5 */
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
    /* TSC4Q 0~1 */
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    110, 110, 110, 110,
    /* TSCF 0*/
    250, 250, 250, 250
};
uint32 tdm_table_op8_0[200] = {
    88, 15, 89, 85, 86, 39, 87, 83, 88, 20,
    89, 29, 86, 84, 87, 55, 88, 82, 89, 2,
    86, 127, 87, 85, 88, 16, 89, 83, 86, 42,
    87, 21, 88, 84, 89, 30, 86, 82, 87, 40,
    88, 3, 89, 85, 86, 56, 87, 83, 88, 17,
    89, 43, 86, 84, 87, 127, 88, 82, 89, 22,
    86, 31, 87, 85, 88, 41, 89, 83, 86, 4,
    87, 57, 88, 84, 89, 10, 86, 82, 87, 44,
    88, 23, 89, 85, 86, 32, 87, 83, 88, 34,
    89, 5, 86, 84, 87, 50, 88, 82, 89, 11,
    86, 127, 87, 85, 88, 33, 89, 83, 86, 24,
    87, 35, 88, 84, 89, 45, 86, 82, 87, 6,
    88, 51, 89, 85, 86, 12, 87, 83, 88, 46,
    89, 25, 86, 84, 87, 26, 88, 82, 89, 36,
    86, 52, 87, 85, 88, 7, 89, 83, 86, 47,
    87, 13, 88, 84, 89, 37, 86, 82, 87, 18,
    88, 27, 89, 85, 86, 53, 87, 83, 88, 8,
    89, 0, 86, 84, 87, 14, 88, 82, 89, 48,
    86, 38, 87, 85, 88, 19, 89, 83, 86, 28,
    87, 9, 88, 84, 89, 54, 86, 82, 87, 49
};

/* OPTION_8_1, 56P 1G + 4P 25G  + 1P 40G */
static int p2l_mapping_op8_1[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     6, 7, 8, 9,
     10, 11, 12, 13,
     14, 15, 16, 17,
     18, 19, 20, 21,
     22, 23, 24, 25,
    /* TSC4Q 0~1 */
     26, 27, 28, 29, 30, 31, 32, 33,
     34, 35, 36, 37, 38, 39, 40, 41,
     42, 43, 44, 45, 46, 47, 48, 49,
     50, 51, 52, 53, 54, 55, 56, 57,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    58, -1, -1, -1,
    /* TSCF 0*/
    59, 60, 61, 62
};
static int port_speed_max_op8_1[] = {
       0,  -1,
     /* TSC4L 0~5 */
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
    /* TSC4Q 0~1 */
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    420, -1, -1, -1,
    /* TSCF 0*/
    250, 250, 250, 250
};
uint32 tdm_table_op8_1[176] = {
    88, 82, 89, 127, 86, 42, 87, 82, 88, 17,
    31, 89, 82, 86, 34, 87, 9, 88, 82, 89,
    56, 23, 86, 82, 87, 127, 88, 43, 89, 82,
    86, 10, 32, 87, 82, 88, 35, 89, 2, 86,
    82, 87, 57, 24, 88, 82, 89, 127, 86, 44,
    87, 82, 88, 11, 33, 89, 82, 86, 36, 87,
    3, 88, 82, 89, 50, 25, 86, 82, 87, 127,
    88, 45, 89, 82, 86, 12, 26, 87, 82, 88,
    37, 89, 4, 86, 82, 87, 51, 18, 88, 82,
    89, 127, 86, 46, 87, 82, 88, 13, 27, 89,
    82, 86, 38, 87, 5, 88, 82, 89, 52, 19,
    86, 82, 87, 127, 88, 47, 89, 82, 86, 14,
    28, 87, 82, 88, 39, 89, 6, 86, 82, 87,
    53, 20, 88, 82, 89, 0, 86, 48, 87, 82,
    88, 15, 29, 89, 82, 86, 40, 87, 7, 88,
    82, 89, 54, 21, 86, 82, 87, 127, 88, 49,
    89, 82, 86, 16, 30, 87, 82, 88, 41, 89,
    8, 86, 82, 87, 55, 22
};

/* OPTION_8_2, 56P 1G + 2P 50G  + 4P 10G */
static int p2l_mapping_op8_2[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     6, 7, 8, 9,
     10, 11, 12, 13,
     14, 15, 16, 17,
     18, 19, 20, 21,
     22, 23, 24, 25,
    /* TSC4Q 0~1 */
     26, 27, 28, 29, 30, 31, 32, 33,
     34, 35, 36, 37, 38, 39, 40, 41,
     42, 43, 44, 45, 46, 47, 48, 49,
     50, 51, 52, 53, 54, 55, 56, 57,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    58, 59, 60, 61,
    /* TSCF 0*/
    62, -1, 63, -1
};
static int port_speed_max_op8_2[] = {
       0,  -1,
     /* TSC4L 0~5 */
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
    /* TSC4Q 0~1 */
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    110, 110, 110, 110,
    /* TSCF 0*/
    530, -1, 530, -1
};
uint32 tdm_table_op8_2[196] = {
    83, 88, 40, 86, 84, 88, 42, 86, 16, 88,
    82, 86, 57, 88, 85, 86, 22, 88, 29, 86,
    83, 88, 41, 86, 84, 88, 9, 86, 43, 88,
    82, 86, 50, 88, 85, 86, 17, 88, 34, 86,
    83, 88, 23, 86, 84, 88, 30, 86, 82, 88,
    2, 86, 44, 88, 85, 86, 35, 88, 83, 86,
    10, 88, 24, 86, 84, 88, 31, 86, 82, 88,
    51, 86, 85, 88, 0, 86, 3, 88, 83, 86,
    45, 88, 84, 86, 52, 88, 11, 86, 82, 88,
    25, 86, 85, 88, 32, 86, 36, 88, 83, 86,
    4, 88, 84, 86, 46, 88, 37, 86, 82, 88,
    12, 86, 85, 88, 18, 86, 33, 88, 83, 86,
    53, 88, 84, 86, 5, 88, 54, 86, 82, 88,
    38, 86, 85, 88, 13, 86, 19, 88, 83, 86,
    26, 88, 84, 86, 47, 88, 82, 86, 6, 88,
    48, 86, 85, 88, 127, 86, 20, 88, 83, 86,
    84, 88, 14, 86, 39, 88, 82, 86, 27, 88,
    7, 86, 85, 88, 55, 86, 83, 88, 49, 86,
    84, 88, 56, 86, 15, 88, 82, 86, 21, 88,
    85, 86, 28, 88, 8, 86
};

/* OPTION_8_3, 56P 1G + 2P 50G  + 1P 40G */
static int p2l_mapping_op8_3[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     6, 7, 8, 9,
     10, 11, 12, 13,
     14, 15, 16, 17,
     18, 19, 20, 21,
     22, 23, 24, 25,
    /* TSC4Q 0~1 */
     26, 27, 28, 29, 30, 31, 32, 33,
     34, 35, 36, 37, 38, 39, 40, 41,
     42, 43, 44, 45, 46, 47, 48, 49,
     50, 51, 52, 53, 54, 55, 56, 57,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    58, -1, -1, -1,
    /* TSCF 0*/
    59, -1, 60, -1
};
static int port_speed_max_op8_3[] = {
       0,  -1,
     /* TSC4L 0~5 */
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
    /* TSC4Q 0~1 */
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    420, -1, -1, -1,
    /* TSCF 0*/
    530, -1, 530, -1
};
uint32 tdm_table_op8_3[184] = {
    86, 82, 88, 7, 86, 13, 88, 82, 86, 21,
    88, 46, 82, 86, 127, 88, 82, 86, 28, 88,
    38, 86, 82, 8, 88, 47, 86, 82, 88, 22,
    86, 14, 88, 82, 51, 86, 0, 88, 82, 86,
    39, 88, 29, 86, 82, 9, 88, 48, 86, 82,
    88, 23, 86, 52, 88, 82, 86, 15, 127, 88,
    82, 86, 53, 88, 30, 86, 82, 88, 40, 2,
    86, 82, 88, 127, 86, 16, 88, 82, 86, 24,
    49, 88, 82, 86, 54, 88, 41, 86, 82, 88,
    31, 3, 86, 82, 88, 127, 86, 42, 88, 82,
    86, 17, 88, 25, 82, 86, 55, 88, 82, 86,
    32, 88, 34, 86, 82, 4, 88, 127, 86, 82,
    88, 18, 86, 10, 88, 82, 43, 86, 127, 88,
    82, 86, 56, 88, 33, 86, 82, 35, 88, 5,
    86, 82, 88, 44, 86, 11, 88, 82, 86, 19,
    127, 88, 82, 86, 57, 88, 26, 86, 82, 88,
    36, 6, 86, 82, 88, 127, 86, 20, 88, 82,
    86, 12, 45, 88, 82, 86, 50, 88, 37, 86,
    82, 88, 27, 127
};

/* OPTION_9_0, 48P 1G + 4P 25G  + 8P 10G */
static int p2l_mapping_op9_0[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     6, 7, 8, 9,
     10, 11, 12, 13,
     14, 15, 16, 17,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     18, 19, 20, 21, 22, 23, 24, 25,
     26, 27, 28, 29, 30, 31, 32, 33,
     34, 35, 36, 37, 38, 39, 40, 41,
     42, 43, 44, 45, 46, 47, 48, 49,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    50, 51, 52, 53,
    54, -1, -1, -1,
    55, 56, 57, 58,
    /* TSCF 0*/
    59, 60, 61, 62
};
static int port_speed_max_op9_0[] = {
       0,  -1,
     /* TSC4L 0~5 */
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    110, 110, 110, 110,
    100, -1, -1, -1,
    110, 110, 110, 110,
    /* TSCF 0*/
    250, 250, 250, 250
};
uint32 tdm_table_op9_0[240] = {
    84, 54, 88, 127, 89, 31, 77, 86, 83, 87,
    74, 88, 85, 78, 89, 3, 86, 47, 76, 87,
    82, 88, 75, 89, 84, 39, 86, 12, 87, 56,
    77, 88, 83, 89, 74, 86, 85, 78, 87, 32,
    88, 4, 76, 89, 82, 86, 75, 87, 84, 48,
    88, 40, 89, 57, 77, 86, 83, 87, 74, 88,
    85, 78, 89, 13, 86, 33, 76, 87, 82, 88,
    75, 89, 84, 5, 86, 49, 87, 41, 77, 88,
    83, 89, 74, 86, 85, 78, 87, 14, 88, 50,
    76, 89, 82, 86, 75, 87, 84, 42, 88, 26,
    89, 6, 77, 86, 83, 87, 74, 88, 85, 78,
    89, 34, 86, 51, 76, 87, 82, 88, 75, 89,
    84, 15, 86, 27, 87, 7, 77, 88, 83, 89,
    74, 86, 85, 78, 87, 43, 88, 35, 76, 89,
    82, 86, 75, 87, 84, 0, 88, 16, 89, 52,
    77, 86, 83, 87, 74, 88, 85, 78, 89, 28,
    86, 8, 76, 87, 82, 88, 75, 89, 84, 44,
    86, 36, 87, 53, 77, 88, 83, 89, 74, 86,
    85, 78, 87, 17, 88, 9, 76, 89, 82, 86,
    75, 87, 84, 29, 88, 45, 89, 55, 77, 86,
    83, 87, 74, 88, 85, 78, 89, 10, 86, 37,
    76, 87, 82, 88, 75, 89, 84, 46, 86, 30,
    87, 2, 77, 88, 83, 89, 74, 86, 85, 78,
    87, 38, 88, 11, 76, 89, 82, 86, 75, 87
};

/* OPTION_9_1, 48P 1G + 4P 25G  + 2P 40G */
static int p2l_mapping_op9_1[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     6, 7, 8, 9,
     10, 11, 12, 13,
     14, 15, 16, 17,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     18, 19, 20, 21, 22, 23, 24, 25,
     26, 27, 28, 29, 30, 31, 32, 33,
     34, 35, 36, 37, 38, 39, 40, 41,
     42, 43, 44, 45, 46, 47, 48, 49,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    50, -1, -1, -1,
    51, -1, -1, -1,
    52, -1, -1, -1,
    /* TSCF 0*/
    53, 54, 55, 56
};
static int port_speed_max_op9_1[] = {
       0,  -1,
     /* TSC4L 0~5 */
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    420, -1, -1, -1,
    100, -1, -1, -1,
    420, -1, -1, -1,
    /* TSCF 0*/
    250, 250, 250, 250
};
uint32 tdm_table_op9_1[240] = {
    48, 74, 86, 82, 87, 56, 88, 74, 82, 89,
    57, 86, 78, 74, 87, 82, 88, 14, 89, 74,
    82, 86, 37, 87, 29, 74, 88, 82, 89, 4,
    86, 74, 49, 87, 82, 88, 78, 74, 89, 82,
    86, 38, 87, 74, 82, 88, 42, 89, 15, 74,
    86, 82, 87, 30, 88, 74, 50, 89, 82, 86,
    78, 74, 87, 82, 88, 5, 89, 74, 82, 86,
    39, 87, 43, 74, 88, 82, 89, 16, 86, 74,
    82, 87, 51, 88, 78, 74, 89, 82, 86, 6,
    87, 74, 31, 88, 82, 89, 52, 74, 86, 82,
    87, 40, 88, 74, 82, 89, 32, 86, 78, 74,
    87, 82, 88, 17, 89, 74, 82, 86, 7, 87,
    44, 74, 88, 82, 89, 45, 86, 74, 41, 87,
    82, 88, 78, 74, 89, 82, 86, 10, 87, 74,
    82, 88, 53, 89, 33, 74, 86, 82, 87, 8,
    88, 74, 82, 89, 46, 86, 78, 74, 87, 82,
    88, 34, 89, 74, 82, 86, 11, 87, 0, 74,
    88, 82, 89, 26, 86, 74, 54, 87, 82, 88,
    78, 74, 89, 82, 86, 9, 87, 74, 55, 88,
    82, 89, 35, 74, 86, 82, 87, 12, 88, 74,
    82, 89, 47, 86, 78, 74, 87, 82, 88, 2,
    89, 74, 82, 86, 27, 87, 127, 74, 88, 82,
    89, 36, 86, 74, 13, 87, 82, 88, 78, 74,
    89, 82, 86, 28, 87, 74, 82, 88, 3, 89
};

/* OPTION_9_2, 48P 1G + 2P 50G  + 8P 10G */
static int p2l_mapping_op9_2[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     6, 7, 8, 9,
     10, 11, 12, 13,
     14, 15, 16, 17,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     18, 19, 20, 21, 22, 23, 24, 25,
     26, 27, 28, 29, 30, 31, 32, 33,
     34, 35, 36, 37, 38, 39, 40, 41,
     42, 43, 44, 45, 46, 47, 48, 49,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    50, 51, 52, 53,
    54, -1, -1, -1,
    55, 56, 57, 58,
    /* TSCF 0*/
    59, -1, 60, -1
};
static int port_speed_max_op9_2[] = {
       0,  -1,
     /* TSC4L 0~5 */
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    110, 110, 110, 110,
    100, -1, -1, -1,
    110, 110, 110, 110,
    /* TSCF 0*/
    530, -1, 530, -1
};
uint32 tdm_table_op9_2[240] = {
    15, 88, 77, 86, 75, 88, 83, 78, 86, 54,
    88, 85, 34, 86, 76, 88, 74, 86, 82, 43,
    88, 27, 86, 84, 8, 88, 77, 86, 75, 88,
    83, 78, 86, 16, 88, 85, 55, 86, 76, 88,
    74, 86, 82, 35, 88, 44, 86, 84, 9, 88,
    77, 86, 75, 88, 83, 78, 86, 28, 88, 85,
    56, 86, 76, 88, 74, 86, 82, 17, 88, 45,
    86, 84, 36, 88, 77, 86, 75, 88, 83, 78,
    86, 57, 88, 85, 2, 86, 76, 88, 74, 86,
    82, 10, 88, 29, 86, 84, 37, 88, 77, 86,
    75, 88, 83, 78, 86, 46, 88, 85, 3, 86,
    76, 88, 74, 86, 82, 50, 88, 30, 86, 84,
    11, 88, 77, 86, 75, 88, 83, 78, 86, 47,
    88, 85, 38, 86, 76, 88, 74, 86, 82, 51,
    88, 12, 86, 84, 4, 88, 77, 86, 75, 88,
    83, 78, 86, 31, 88, 85, 0, 86, 76, 88,
    74, 86, 82, 39, 88, 48, 86, 84, 5, 88,
    77, 86, 75, 88, 83, 78, 86, 32, 88, 85,
    13, 86, 76, 88, 74, 86, 82, 52, 88, 49,
    86, 84, 40, 88, 77, 86, 75, 88, 83, 78,
    86, 33, 88, 85, 6, 86, 76, 88, 74, 86,
    82, 14, 88, 53, 86, 84, 41, 88, 77, 86,
    75, 88, 83, 78, 86, 42, 88, 85, 127, 86,
    76, 88, 74, 86, 82, 7, 88, 26, 86, 84
};

/* OPTION_9_3, 48P 1G + 2P 50G  + 2P 40G */
static int p2l_mapping_op9_3[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     6, 7, 8, 9,
     10, 11, 12, 13,
     14, 15, 16, 17,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     18, 19, 20, 21, 22, 23, 24, 25,
     26, 27, 28, 29, 30, 31, 32, 33,
     34, 35, 36, 37, 38, 39, 40, 41,
     42, 43, 44, 45, 46, 47, 48, 49,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    50, -1, -1, -1,
    51, -1, -1, -1,
    52, -1, -1, -1,
    /* TSCF 0*/
    53, -1, 54, -1
};
static int port_speed_max_op9_3[] = {
       0,  -1,
     /* TSC4L 0~5 */
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    420, -1, -1, -1,
    100, -1, -1, -1,
    420, -1, -1, -1,
    /* TSCF 0*/
    530, -1, 530, -1
};
uint32 tdm_table_op9_3[240] = {
    42, 54, 88, 82, 86, 74, 9, 88, 82, 86,
    55, 88, 74, 78, 86, 82, 88, 74, 14, 86,
    82, 88, 74, 86, 27, 39, 88, 82, 86, 74,
    43, 88, 82, 86, 74, 88, 78, 2, 86, 82,
    88, 74, 56, 86, 82, 88, 74, 86, 15, 44,
    88, 82, 86, 74, 28, 88, 82, 86, 74, 88,
    78, 40, 86, 82, 88, 74, 3, 86, 82, 88,
    0, 86, 74, 57, 88, 82, 86, 74, 16, 88,
    82, 86, 78, 88, 74, 82, 86, 29, 88, 74,
    41, 86, 82, 88, 45, 86, 74, 4, 88, 82,
    86, 74, 17, 88, 82, 86, 74, 88, 78, 82,
    86, 34, 88, 74, 30, 86, 82, 88, 46, 86,
    74, 50, 88, 82, 86, 74, 5, 88, 82, 86,
    35, 88, 74, 82, 86, 78, 88, 74, 10, 86,
    82, 88, 31, 86, 74, 82, 88, 127, 86, 74,
    47, 88, 82, 86, 78, 88, 74, 6, 86, 82,
    88, 74, 51, 86, 82, 88, 74, 86, 11, 36,
    88, 82, 86, 74, 32, 88, 82, 86, 74, 88,
    78, 48, 86, 82, 88, 74, 52, 86, 82, 88,
    74, 86, 7, 33, 88, 82, 86, 74, 12, 88,
    82, 86, 78, 88, 74, 37, 86, 82, 88, 74,
    49, 86, 82, 88, 53, 86, 74, 8, 88, 82,
    86, 74, 38, 88, 82, 86, 13, 88, 74, 78,
    86, 82, 88, 74, 26, 86, 82, 88, 74, 86
};

/* OPTION_10_0, 16P 1G (SGMII) + 16P 1G (QSGMII) + 4P 25G + 8P 10G */
static int p2l_mapping_op10_0[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     6, 7, 8, 9,
     10, 11, 12, 13,
     14, 15, 16, 17,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
    18, 19, 20, 21, 22, 23, 24, 25,
    26, 27, 28, 29, 30, 31, 32, 33,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    34, 35, 36, 37,
    38, -1, -1, -1,
    39, 40, 41, 42,
    /* TSCF 0*/
    43, 44, 45, 46
};
static int port_speed_max_op10_0[] = {
       0,  -1,
     /* TSC4L 0~5 */
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
    10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    110, 110, 110, 110,
    100, -1, -1, -1,
    110, 110, 110, 110,
    /* TSCF 0*/
    250, 250, 250, 250
};
uint32 tdm_table_op10_0[224] = {
    89, 85, 26, 86, 77, 87, 39, 88, 75, 89,
    40, 83, 86, 84, 87, 76, 88, 78, 89, 74,
    9, 86, 82, 87, 85, 88, 77, 89, 10, 86,
    27, 75, 87, 83, 88, 84, 89, 76, 86, 78,
    2, 87, 74, 88, 82, 89, 85, 86, 41, 77,
    87, 11, 88, 75, 89, 83, 86, 84, 28, 87,
    76, 88, 78, 89, 74, 86, 34, 82, 87, 85,
    88, 77, 89, 3, 86, 75, 29, 87, 83, 88,
    84, 89, 76, 86, 78, 87, 12, 74, 88, 82,
    89, 85, 86, 77, 87, 35, 4, 88, 75, 89,
    83, 86, 84, 87, 13, 76, 88, 78, 89, 74,
    86, 82, 87, 85, 30, 88, 77, 89, 36, 86,
    75, 87, 5, 83, 88, 84, 89, 76, 86, 78,
    87, 74, 37, 88, 82, 89, 85, 86, 77, 87,
    14, 88, 31, 75, 89, 83, 86, 84, 87, 76,
    88, 78, 6, 89, 74, 86, 82, 87, 85, 88,
    0, 77, 89, 127, 86, 75, 87, 83, 88, 84,
    15, 89, 76, 86, 78, 87, 74, 88, 32, 82,
    89, 85, 86, 77, 87, 7, 88, 75, 38, 89,
    83, 86, 84, 87, 76, 88, 78, 89, 16, 74,
    86, 82, 87, 85, 88, 77, 89, 33, 8, 86,
    75, 87, 83, 88, 84, 89, 17, 76, 86, 78,
    87, 74, 88, 82
};

/* OPTION_10_1, 16P 1G (SGMII) + 16P 1G (QSGMII) + 4P 25G + 2P 40G */
static int p2l_mapping_op10_1[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     6, 7, 8, 9,
     10, 11, 12, 13,
     14, 15, 16, 17,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
    18, 19, 20, 21, 22, 23, 24, 25,
    26, 27, 28, 29, 30, 31, 32, 33,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    34, -1, -1, -1,
    35, -1, -1, -1,
    36, -1, -1, -1,
    /* TSCF 0*/
    37, 38, 39, 40
};
static int port_speed_max_op10_1[] = {
       0,  -1,
     /* TSC4L 0~5 */
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
    10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    420, -1, -1, -1,
    100, -1, -1, -1,
    420, -1, -1, -1,
    /* TSCF 0*/
    250, 250, 250, 250
};
uint32 tdm_table_op10_1[224] = {
    74, 4, 88, 82, 89, 74, 86, 82, 87, 78,
    74, 88, 82, 89, 34, 86, 74, 87, 82, 28,
    88, 74, 89, 35, 86, 82, 87, 17, 74, 88,
    82, 89, 74, 86, 78, 87, 82, 5, 88, 74,
    89, 82, 86, 74, 87, 0, 82, 88, 29, 89,
    74, 86, 82, 87, 78, 88, 74, 82, 89, 127,
    86, 74, 87, 82, 88, 6, 10, 89, 74, 86,
    82, 87, 74, 88, 82, 30, 89, 74, 86, 78,
    87, 82, 88, 36, 74, 89, 82, 86, 74, 87,
    82, 88, 38, 7, 89, 74, 86, 82, 87, 11,
    88, 74, 82, 89, 78, 86, 74, 87, 82, 88,
    31, 89, 74, 12, 86, 82, 87, 74, 88, 82,
    89, 8, 74, 86, 82, 87, 78, 88, 74, 89,
    82, 32, 86, 74, 87, 37, 88, 82, 89, 13,
    74, 86, 82, 87, 74, 88, 78, 89, 82, 9,
    86, 74, 87, 82, 88, 74, 89, 39, 82, 86,
    33, 87, 74, 88, 82, 89, 40, 86, 74, 82,
    87, 78, 88, 74, 89, 82, 86, 2, 74, 87,
    82, 88, 14, 89, 74, 86, 82, 26, 87, 74,
    88, 78, 89, 82, 86, 41, 74, 87, 82, 88,
    15, 89, 74, 86, 82, 3, 87, 74, 88, 82,
    89, 74, 86, 78, 82, 87, 27, 88, 74, 89,
    82, 86, 16, 87
};

/* OPTION_10_2, 16P 1G (SGMII) + 16P 1G (QSGMII) + 2P 50G + 8P 10G */
static int p2l_mapping_op10_2[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     6, 7, 8, 9,
     10, 11, 12, 13,
     14, 15, 16, 17,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
    18, 19, 20, 21, 22, 23, 24, 25,
    26, 27, 28, 29, 30, 31, 32, 33,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    34, 35, 36, 37,
    38, -1, -1, -1,
    39, 40, 41, 42,
    /* TSCF 0*/
    43, -1, 44, -1
};
static int port_speed_max_op10_2[] = {
       0,  -1,
     /* TSC4L 0~5 */
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
    10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    110, 110, 110, 110,
    100, -1, -1, -1,
    110, 110, 110, 110,
    /* TSCF 0*/
    530, -1, 530, -1
};
uint32 tdm_table_op10_2[224] = {
    84, 88, 74, 86, 40, 88, 82, 30, 86, 76,
    88, 85, 86, 75, 88, 78, 41, 86, 83, 88,
    77, 86, 84, 88, 7, 74, 86, 13, 88, 82,
    86, 76, 88, 85, 31, 86, 75, 88, 78, 86,
    83, 88, 77, 86, 34, 84, 88, 74, 86, 14,
    88, 82, 86, 76, 8, 88, 85, 86, 75, 88,
    78, 86, 83, 32, 88, 77, 86, 84, 88, 74,
    86, 127, 15, 88, 82, 86, 76, 88, 85, 86,
    35, 75, 88, 78, 86, 83, 88, 77, 86, 84,
    9, 88, 74, 86, 33, 88, 82, 86, 76, 88,
    36, 85, 86, 75, 88, 78, 86, 83, 88, 77,
    2, 86, 84, 88, 74, 86, 16, 88, 82, 26,
    86, 76, 88, 85, 86, 75, 88, 78, 17, 86,
    83, 88, 77, 86, 84, 88, 3, 74, 86, 37,
    88, 82, 86, 76, 88, 85, 38, 86, 75, 88,
    78, 86, 83, 88, 77, 86, 27, 84, 88, 74,
    86, 10, 88, 82, 86, 76, 4, 88, 85, 86,
    75, 88, 78, 86, 83, 28, 88, 77, 86, 84,
    88, 74, 86, 0, 11, 88, 82, 86, 76, 88,
    85, 86, 29, 75, 88, 78, 86, 83, 88, 77,
    86, 84, 5, 88, 74, 86, 39, 88, 82, 86,
    76, 88, 12, 85, 86, 75, 88, 78, 86, 83,
    88, 77, 6, 86
};

/* OPTION_10_3, 16P 1G (SGMII) + 16P 1G (QSGMII) + 2P 50G + 2P 40G */
static int p2l_mapping_op10_3[] = {
     0, -1,
    /* TSC4L 0~5 */
     2, 3, 4, 5,
     6, 7, 8, 9,
     10, 11, 12, 13,
     14, 15, 16, 17,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
    18, 19, 20, 21, 22, 23, 24, 25,
    26, 27, 28, 29, 30, 31, 32, 33,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    34, -1, -1, -1,
    35, -1, -1, -1,
    36, -1, -1, -1,
    /* TSCF 0*/
    37, -1, 38, -1
};
static int port_speed_max_op10_3[] = {
       0,  -1,
     /* TSC4L 0~5 */
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     10, 10, 10, 10,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
    10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    420, -1, -1, -1,
    100, -1, -1, -1,
    420, -1, -1, -1,
    /* TSCF 0*/
    530, -1, 530, -1
};
uint32 tdm_table_op10_3[224] = {
    0, 86, 74, 88, 82, 86, 74, 38, 88, 82,
    86, 78, 88, 74, 86, 82, 5, 88, 74, 86,
    82, 88, 74, 86, 31, 82, 88, 15, 86, 74,
    88, 82, 86, 78, 74, 88, 6, 86, 82, 88,
    74, 86, 82, 32, 88, 16, 86, 74, 88, 82,
    86, 74, 88, 82, 78, 86, 74, 88, 37, 86,
    82, 88, 74, 127, 86, 82, 88, 74, 86, 7,
    88, 82, 17, 86, 74, 88, 82, 86, 74, 88,
    78, 82, 86, 33, 88, 74, 86, 82, 88, 8,
    74, 86, 82, 88, 39, 86, 74, 88, 82, 26,
    86, 78, 88, 74, 86, 82, 88, 74, 86, 82,
    10, 88, 74, 86, 40, 88, 82, 86, 74, 9,
    88, 82, 86, 74, 88, 82, 86, 78, 27, 88,
    74, 86, 82, 88, 74, 86, 11, 82, 88, 41,
    86, 74, 88, 82, 86, 78, 74, 88, 2, 86,
    82, 88, 74, 86, 82, 28, 88, 74, 86, 34,
    88, 82, 86, 74, 88, 82, 12, 86, 78, 88,
    74, 86, 82, 88, 74, 3, 86, 82, 88, 74,
    86, 35, 88, 82, 29, 86, 74, 88, 82, 86,
    78, 88, 74, 82, 86, 13, 88, 74, 86, 82,
    88, 36, 74, 86, 82, 88, 4, 86, 74, 88,
    82, 30, 86, 78, 88, 74, 86, 82, 88, 74,
    86, 82, 14, 88
};

/* OPTION_11_0, 32P 1G (QSGMII)+ 4P 25G + 8P 10G */
static int p2l_mapping_op11_0[] = {
     0, -1,
    /* TSC4L 0~5 */
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     2, 3, 4, 5, 6, 7, 8, 9,
     10, 11, 12, 13, 14, 15, 16, 17,
     18, 19, 20, 21, 22, 23, 24, 25,
     26, 27, 28, 29, 30, 31, 32, 33,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    34, 35, 36, 37,
    38, -1, -1, -1,
    39, 40, 41, 42,
    /* TSCF 0*/
    43, 44, 45, 46
};
static int port_speed_max_op11_0[] = {
       0,  -1,
     /* TSC4L 0~5 */
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    110, 110, 110, 110,
    100, -1, -1, -1,
    110, 110, 110, 110,
    /* TSCF 0*/
    250, 250, 250, 250
};
uint32 tdm_table_op11_0[224] = {
    87, 74, 88, 76, 89, 34, 42, 86, 85, 87,
    83, 88, 75, 89, 77, 51, 86, 78, 87, 84,
    88, 82, 89, 74, 52, 86, 76, 87, 33, 88,
    85, 89, 83, 35, 86, 75, 87, 77, 88, 78,
    89, 84, 86, 43, 82, 87, 74, 88, 76, 89,
    0, 86, 85, 26, 87, 83, 88, 75, 89, 77,
    86, 36, 78, 87, 84, 88, 82, 89, 74, 86,
    76, 44, 87, 53, 88, 85, 89, 83, 86, 75,
    27, 87, 77, 88, 78, 89, 84, 86, 82, 37,
    87, 74, 88, 76, 89, 45, 86, 85, 87, 54,
    83, 88, 75, 89, 77, 86, 78, 87, 84, 28,
    88, 82, 89, 74, 86, 76, 87, 38, 46, 88,
    85, 89, 83, 86, 75, 87, 77, 55, 88, 78,
    89, 84, 86, 82, 87, 74, 47, 88, 76, 89,
    29, 86, 85, 87, 83, 39, 88, 75, 89, 77,
    86, 78, 87, 84, 88, 56, 82, 89, 74, 86,
    76, 87, 48, 88, 85, 30, 89, 83, 86, 75,
    87, 77, 88, 40, 78, 89, 84, 86, 82, 87,
    74, 88, 76, 57, 89, 49, 86, 85, 87, 83,
    88, 75, 41, 89, 77, 86, 78, 87, 84, 88,
    82, 31, 89, 74, 86, 76, 87, 127, 88, 85,
    89, 50, 83, 86, 75, 87, 77, 88, 78, 89,
    84, 32, 86, 82
};

/* OPTION_11_1, 32P 1G (QSGMII)+ 4P 25G + 2P 40G */
static int p2l_mapping_op11_1[] = {
     0, -1,
    /* TSC4L 0~5 */
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     2, 3, 4, 5, 6, 7, 8, 9,
     10, 11, 12, 13, 14, 15, 16, 17,
     18, 19, 20, 21, 22, 23, 24, 25,
     26, 27, 28, 29, 30, 31, 32, 33,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    34, -1, -1, -1,
    35, -1, -1, -1,
    36, -1, -1, -1,
    /* TSCF 0*/
    37, 38, 39, 40
};
static int port_speed_max_op11_1[] = {
       0,  -1,
     /* TSC4L 0~5 */
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    420, -1, -1, -1,
    100, -1, -1, -1,
    420, -1, -1, -1,
    /* TSCF 0*/
    250, 250, 250, 250
};
uint32 tdm_table_op11_1[224] = {
    74, 89, 82, 86, 78, 87, 74, 88, 82, 89,
    34, 74, 86, 82, 87, 74, 88, 57, 89, 82,
    46, 86, 74, 87, 82, 88, 78, 89, 74, 28,
    86, 82, 87, 74, 88, 82, 89, 0, 35, 86,
    74, 87, 82, 88, 74, 89, 47, 82, 86, 78,
    87, 74, 88, 82, 89, 29, 74, 86, 82, 87,
    74, 88, 82, 89, 50, 86, 36, 74, 87, 82,
    88, 78, 89, 74, 86, 82, 48, 87, 74, 88,
    82, 89, 51, 86, 74, 82, 87, 30, 88, 74,
    89, 82, 86, 78, 37, 87, 74, 88, 82, 89,
    74, 86, 49, 82, 87, 74, 88, 82, 89, 52,
    86, 38, 74, 87, 82, 88, 74, 89, 78, 86,
    82, 87, 31, 74, 88, 82, 89, 127, 86, 74,
    87, 82, 42, 88, 74, 89, 82, 86, 78, 87,
    74, 53, 88, 82, 89, 74, 86, 82, 87, 32,
    74, 88, 39, 89, 82, 86, 74, 87, 78, 82,
    88, 74, 89, 82, 86, 43, 87, 54, 74, 88,
    82, 89, 33, 86, 74, 87, 82, 88, 40, 74,
    89, 82, 86, 78, 87, 74, 88, 82, 44, 89,
    74, 86, 82, 87, 55, 88, 74, 82, 89, 26,
    86, 74, 87, 82, 88, 78, 74, 89, 82, 86,
    41, 87, 74, 88, 56, 82, 89, 45, 86, 74,
    87, 82, 88, 27
};

/* OPTION_11_2, 32P 1G (QSGMII)+ 2P 50G + 8P 10G */
static int p2l_mapping_op11_2[] = {
     0, -1,
    /* TSC4L 0~5 */
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     2, 3, 4, 5, 6, 7, 8, 9,
     10, 11, 12, 13, 14, 15, 16, 17,
     18, 19, 20, 21, 22, 23, 24, 25,
     26, 27, 28, 29, 30, 31, 32, 33,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    34, 35, 36, 37,
    38, -1, -1, -1,
    39, 40, 41, 42,
    /* TSCF 0*/
    43, -1, 44, -1
};
static int port_speed_max_op11_2[] = {
       0,  -1,
     /* TSC4L 0~5 */
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    110, 110, 110, 110,
    100, -1, -1, -1,
    110, 110, 110, 110,
    /* TSCF 0*/
    530, -1, 530, -1
};
uint32 tdm_table_op11_2[224] = {
    88, 74, 86, 0, 76, 88, 45, 86, 83, 88,
    84, 86, 127, 75, 88, 77, 86, 78, 88, 82,
    86, 85, 29, 88, 74, 86, 76, 88, 38, 86,
    83, 88, 84, 46, 86, 75, 88, 77, 86, 78,
    88, 50, 82, 86, 85, 88, 74, 86, 76, 88,
    30, 47, 86, 83, 88, 84, 86, 75, 88, 39,
    77, 86, 78, 88, 82, 86, 85, 88, 57, 74,
    86, 76, 88, 48, 86, 83, 88, 84, 31, 86,
    75, 88, 77, 86, 78, 88, 82, 86, 85, 40,
    88, 74, 86, 76, 88, 51, 86, 32, 83, 88,
    84, 86, 75, 88, 77, 86, 78, 52, 88, 82,
    86, 85, 88, 74, 86, 41, 76, 88, 49, 86,
    83, 88, 84, 86, 53, 75, 88, 77, 86, 78,
    88, 82, 86, 85, 33, 88, 74, 86, 76, 88,
    34, 86, 83, 88, 84, 42, 86, 75, 88, 77,
    86, 78, 88, 54, 82, 86, 85, 88, 74, 86,
    76, 88, 26, 43, 86, 83, 88, 84, 86, 75,
    88, 35, 77, 86, 78, 88, 82, 86, 85, 88,
    55, 74, 86, 76, 88, 36, 86, 83, 88, 84,
    27, 86, 75, 88, 77, 86, 78, 88, 82, 86,
    85, 44, 88, 74, 86, 76, 88, 56, 86, 37,
    83, 88, 84, 86, 75, 88, 77, 86, 78, 28,
    88, 82, 86, 85
};

/* OPTION_11_3, 32P 1G (QSGMII)+ 2P 50G + 2P 40G */
static int p2l_mapping_op11_3[] = {
     0, -1,
    /* TSC4L 0~5 */
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     2, 3, 4, 5, 6, 7, 8, 9,
     10, 11, 12, 13, 14, 15, 16, 17,
     18, 19, 20, 21, 22, 23, 24, 25,
     26, 27, 28, 29, 30, 31, 32, 33,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    34, -1, -1, -1,
    35, -1, -1, -1,
    36, -1, -1, -1,
    /* TSCF 0*/
    37, -1, 38, -1
};
static int port_speed_max_op11_3[] = {
       0,  -1,
     /* TSC4L 0~5 */
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
     -1, -1, -1, -1,
    /* TSC4Q 0~1 */
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
     10, 10, 10, 10, 10, 10, 10, 10,
    /* TSC 0~6*/
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    -1, -1, -1, -1,
    420, -1, -1, -1,
    100, -1, -1, -1,
    420, -1, -1, -1,
    /* TSCF 0*/
    530, -1, 530, -1
};
uint32 tdm_table_op11_3[224] = {
    88, 32, 74, 86, 78, 88, 82, 86, 74, 88,
    82, 86, 37, 74, 88, 127, 86, 82, 88, 74,
    86, 42, 82, 88, 74, 86, 78, 88, 82, 86,
    74, 33, 88, 82, 86, 74, 88, 38, 86, 82,
    43, 88, 74, 86, 82, 88, 78, 86, 74, 82,
    88, 39, 86, 74, 88, 82, 86, 26, 74, 88,
    55, 86, 82, 88, 74, 86, 82, 88, 56, 74,
    86, 78, 88, 82, 86, 74, 88, 44, 82, 86,
    27, 88, 74, 86, 82, 88, 74, 40, 86, 82,
    88, 74, 86, 78, 88, 82, 0, 86, 74, 88,
    82, 86, 45, 88, 74, 82, 86, 57, 88, 74,
    86, 82, 88, 28, 74, 86, 78, 88, 82, 86,
    74, 88, 82, 86, 41, 50, 88, 74, 86, 82,
    88, 74, 86, 29, 82, 88, 78, 86, 74, 88,
    82, 86, 74, 34, 88, 82, 86, 46, 88, 74,
    86, 82, 51, 88, 74, 86, 82, 88, 74, 86,
    78, 82, 88, 47, 86, 74, 88, 82, 86, 30,
    74, 88, 82, 86, 35, 88, 74, 86, 82, 88,
    52, 78, 86, 74, 88, 82, 86, 74, 88, 48,
    82, 86, 74, 88, 82, 86, 53, 88, 74, 31,
    86, 82, 88, 78, 86, 74, 88, 82, 36, 86,
    74, 88, 82, 86, 74, 88, 49, 82, 86, 54,
    88, 74, 86, 82
};

/* OPTION_12_0, 8P 1G (QGMII) + 4P 10G */
static int p2l_mapping_op12_0[] = {
     0, -1,
    /* TSC4L 0~5 */
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    /* TSC4Q 0~1 */
    2,  3,  4,  5,  6,  7,  8,  9,
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    10,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    /* TSC 0~6*/
    11,  12,  13,  14,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    /* TSCF 0*/
    -1,  -1,  -1,  -1
};
static int port_speed_max_op12_0[] = {
     0, -1,
    /* TSC4L 0~5 */
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    /* TSC4Q 0~1 */
    10,  10,  10,  10,  10,  10,  10,  10,
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    25,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    /* TSC 0~6*/
    100,  100,  100,  100,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,
    /* TSCF 0*/
    -1,  -1,  -1,  -1
};
uint32 tdm_table_op12_0[32] = {
    27, 58, 127, 61, 28, 127, 59, 127, 29, 60,
    127, 58, 30, 127, 61, 0, 31, 59, 42, 60,
    32, 127, 58, 127, 33, 61, 127, 59, 26, 127,
    60, 127
};


/* System Clock Freq (MHz) */
#define _GH2_SYSTEM_FREQ_583          (583) /* 583.4 MHz */
#define _GH2_SYSTEM_FREQ_500          (500) /* 500 MHz */
#define _GH2_SYSTEM_FREQ_450          (450) /* 450 MHz */
#define _GH2_SYSTEM_FREQ_437          (437) /* 437.5 MHz */
#define _GH2_SYSTEM_FREQ_392          (392) /* 392.9 MHz */
#define _GH2_SYSTEM_FREQ_389          (389) /* 389 MHz */
#define _GH2_SYSTEM_FREQ_375          (375) /* 375 MHz */
#define _GH2_SYSTEM_FREQ_125          (125) /* 125 MHz */
#define _GH2_53570_SYSTEM_FREQ        _GH2_SYSTEM_FREQ_583

#define _GH2_MAX_TSC_COUNT              (8)
#define _GH2_MAX_QTC_COUNT              (2)
#define _GH2_PORT_COUNT_PER_TSC         (4)
#define _GH2_PORT_COUNT_PER_QTC         (16)
#define _GH2_TSC_TSCF0_IDX              (7)

#define _GH2_QTC_SERDES_OVERRDE_NONE    (0)
#define _GH2_QTC_SERDES_OVERRDE_QSGMII  (1)
#define _GH2_QTC_SERDES_OVERRDE_SGMII   (2)

#define _GH2_QTC_SERDES_DEFAULT_MODE_NONE    (0)
#define _GH2_QTC_SERDES_DEFAULT_MODE_QSGMII  (1)
#define _GH2_QTC_SERDES_DEFAULT_MODE_SGMII   (2)

#define _GH2_ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))

/* 8 TSC (TSC0~6, TSCF0) */
static const int tsc_phy_port[] = {58, 62, 66, 70, 74, 78, 82, 86};
/* 2 QTC */
static const int qtc_phy_port[] = {26, 42};

#define GH2_PORT_CFG_RENEW_PHY_PORT_MIN 26 /* first physical port of QTC#0 */
#define GH2_PORT_CFG_RENEW_PHY_PORT_MAX 89 /* last physical port of TSCF */

/* Option string */
#define OPTION_1 "op1"
#define OPTION_2 "op2"
#define OPTION_2A "op2a"
#define OPTION_3A "op3a"
#define OPTION_4A "op4a"
#define OPTION_5 "op5"
#define OPTION_6 "op6"
#define OPTION_7 "op7"
#define OPTION_7B "op7b"
#define OPTION_8B "op8b"
#define OPTION_9B "op9b"
#define OPTION_10B "op10b"
#define OPTION_11B "op11b"
#define OPTION_12B "op12b"
#define OPTION_12 "op12"
#define OPTION_13 "op13"
#define OPTION_14 "op14"

/* Below options defined in PRD 4.7*/
#define OPTION_2_0 "op2_0"
#define OPTION_2_2 "op2_2"
#define OPTION_2_3 "op2_3"
#define OPTION_5_2 "op5_2"
#define OPTION_9B_0 "op9b_0"
#define OPTION_10B_0 "op10b_0"
/* Below options defined in PRD 4.6*/
#define OPTION_1_0 "op1_0"
#define OPTION_1_1 "op1_1"
#define OPTION_1_2 "op1_2"
#define OPTION_1_3 "op1_3"
#define OPTION_2_1 "op2_1"
#define OPTION_3_0 "op3_0"
#define OPTION_3_1 "op3_1"
#define OPTION_3_2 "op3_2"
#define OPTION_3_3 "op3_3"
#define OPTION_4_0 "op4_0"
#define OPTION_4_1 "op4_1"
#define OPTION_4_2 "op4_2"
#define OPTION_4_3 "op4_3"
#define OPTION_5_0 "op5_0"
#define OPTION_5_1 "op5_1"
#define OPTION_5_3 "op5_3"
#define OPTION_6_0 "op6_0"
#define OPTION_6_1 "op6_1"
#define OPTION_6_2 "op6_2"
#define OPTION_6_3 "op6_3"
#define OPTION_7_0 "op7_0"
#define OPTION_7_1 "op7_1"
#define OPTION_7_2 "op7_2"
#define OPTION_7_3 "op7_3"
#define OPTION_8_0 "op8_0"
#define OPTION_8_1 "op8_1"
#define OPTION_8_2 "op8_2"
#define OPTION_8_3 "op8_3"
#define OPTION_9_0 "op9_0"
#define OPTION_9_1 "op9_1"
#define OPTION_9_2 "op9_2"
#define OPTION_9_3 "op9_3"
#define OPTION_10_0 "op10_0"
#define OPTION_10_1 "op10_1"
#define OPTION_10_2 "op10_2"
#define OPTION_10_3 "op10_3"
#define OPTION_11_0 "op11_0"
#define OPTION_11_1 "op11_1"
#define OPTION_11_2 "op11_2"
#define OPTION_11_3 "op11_3"
#define OPTION_12_0 "op12_0"
#define OPTION_13_0 "op13_0"

static int matched_option_idx = -1;

typedef struct _gh2_tsc_info_s {
    int     port_count;
    uint8   valid;
    int     phy_port_base;
} _gh2_tsc_info_t;

typedef struct _gh2_option_info_s {
    char        *config_op; /* option string */
    int         freq;
    int   *p2l_mapping;
    int   *speed_max;
    uint32      *tdm_table;
    int         tdm_table_size;
    uint32      disabled_qtc_bmp; /* 2 bits: [qtc1~qtc0] */
    uint32      disabled_tsc_bmp; /* 8 bits: [tscf, tsce6~tsce0] */
    int         default_port_ratio[_GH2_MAX_TSC_COUNT];
    int         num_qsgmii_supported[_GH2_MAX_QTC_COUNT];
    int         num_sgmii_supported[_GH2_MAX_QTC_COUNT];
    int         qtc_default_mode[_GH2_MAX_QTC_COUNT];
} _gh2_option_info_t;

_gh2_option_info_t *_gh2_option_port_config;

static _gh2_tsc_info_t _gh2_tsc[_GH2_MAX_TSC_COUNT];
static int _gh2_qtc_serdes_override[_GH2_MAX_QTC_COUNT];

STATIC _gh2_option_info_t _gh2_b0_option_port_config[] = {
/* OPTION_1 */
{OPTION_1, _GH2_SYSTEM_FREQ_583,
    p2l_mapping_template_op1, port_speed_max_template_op1,
    tdm_table_default, GH2_TDM_SLOT_MAX,
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD},
    {0, 0}, {0, 0},
    {_GH2_QTC_SERDES_DEFAULT_MODE_NONE, _GH2_QTC_SERDES_DEFAULT_MODE_NONE}},
/* OPTION_2 */
{OPTION_2, _GH2_SYSTEM_FREQ_583,
    p2l_mapping_template_op2, port_speed_max_template_op2,
    tdm_table_default, GH2_TDM_SLOT_MAX,
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD},
    {0, 0}, {0, 0},
    {_GH2_QTC_SERDES_DEFAULT_MODE_NONE, _GH2_QTC_SERDES_DEFAULT_MODE_NONE}},
/* OPTION_2A */
{OPTION_2A, _GH2_SYSTEM_FREQ_583,
    p2l_mapping_template_op2a, port_speed_max_template_op2a,
    tdm_table_default, GH2_TDM_SLOT_MAX,
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD},
    {0, 0}, {0, 0},
    {_GH2_QTC_SERDES_DEFAULT_MODE_NONE, _GH2_QTC_SERDES_DEFAULT_MODE_NONE}},
/* OPTION_3A */
{OPTION_3A, _GH2_SYSTEM_FREQ_583,
    p2l_mapping_template_op3a, port_speed_max_template_op3a,
    tdm_table_default, GH2_TDM_SLOT_MAX,
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD},
    {4, 4}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_QSGMII, _GH2_QTC_SERDES_DEFAULT_MODE_QSGMII}},
/* OPTION_4A */
{OPTION_4A, _GH2_SYSTEM_FREQ_583,
    p2l_mapping_template_op4a, port_speed_max_template_op4a,
    tdm_table_default, GH2_TDM_SLOT_MAX,
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD},
    {0, 0}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_SGMII, _GH2_QTC_SERDES_DEFAULT_MODE_SGMII}},
/* OPTION_5 */
{OPTION_5, _GH2_SYSTEM_FREQ_500,
    p2l_mapping_template_op5, port_speed_max_template_op5,
    tdm_table_default, GH2_TDM_SLOT_MAX,
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD},
    {0, 0}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_SGMII, _GH2_QTC_SERDES_DEFAULT_MODE_SGMII}},
/* OPTION_6 */
{OPTION_6, _GH2_SYSTEM_FREQ_392,
    p2l_mapping_template_op6, port_speed_max_template_op6,
    tdm_table_default, GH2_TDM_SLOT_MAX,
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD},
    {4, 4}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_QSGMII, _GH2_QTC_SERDES_DEFAULT_MODE_QSGMII}},
/* OPTION_7 */
{OPTION_7, _GH2_SYSTEM_FREQ_500,
    p2l_mapping_template_op7, port_speed_max_template_op7,
    tdm_table_default, GH2_TDM_SLOT_MAX,
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD},
    {0, 0}, {0, 0},
    {_GH2_QTC_SERDES_DEFAULT_MODE_NONE, _GH2_QTC_SERDES_DEFAULT_MODE_NONE}},
/* OPTION_7B */
{OPTION_7B, _GH2_SYSTEM_FREQ_500,
    p2l_mapping_template_op7b, port_speed_max_template_op7b,
    tdm_table_default, GH2_TDM_SLOT_MAX,
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD},
    {0, 0}, {0, 0},
    {_GH2_QTC_SERDES_DEFAULT_MODE_NONE, _GH2_QTC_SERDES_DEFAULT_MODE_NONE}},
/* OPTION_8B */
{OPTION_8B, _GH2_SYSTEM_FREQ_500,
    p2l_mapping_template_op8b, port_speed_max_template_op8b,
    tdm_table_default, GH2_TDM_SLOT_MAX,
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD},
    {0, 0}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_SGMII, _GH2_QTC_SERDES_DEFAULT_MODE_SGMII}},
/* OPTION_9B */
{OPTION_9B, _GH2_SYSTEM_FREQ_450,
    p2l_mapping_template_op9b, port_speed_max_template_op9b,
    tdm_table_default, GH2_TDM_SLOT_MAX,
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD},
    {4, 4}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_QSGMII, _GH2_QTC_SERDES_DEFAULT_MODE_QSGMII}},
/* OPTION_10B */
{OPTION_10B, _GH2_SYSTEM_FREQ_450,
    p2l_mapping_template_op10b, port_speed_max_template_op10b,
    tdm_table_default, GH2_TDM_SLOT_MAX,
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD},
    {0, 0}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_SGMII, _GH2_QTC_SERDES_DEFAULT_MODE_SGMII}},
/* OPTION_11B */
{OPTION_11B, _GH2_SYSTEM_FREQ_450,
    p2l_mapping_template_op11b, port_speed_max_template_op11b,
    tdm_table_default, GH2_TDM_SLOT_MAX,
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD},
    {4, 4}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_QSGMII, _GH2_QTC_SERDES_DEFAULT_MODE_QSGMII}},
/* OPTION_12B */
{OPTION_12B, _GH2_SYSTEM_FREQ_392,
    p2l_mapping_template_op12b, port_speed_max_template_op12b,
    tdm_table_default, GH2_TDM_SLOT_MAX,
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD},
    {0, 0}, {0, 0},
    {_GH2_QTC_SERDES_DEFAULT_MODE_NONE, _GH2_QTC_SERDES_DEFAULT_MODE_NONE}},
/* OPTION_12 */
{OPTION_12, _GH2_SYSTEM_FREQ_392,
    p2l_mapping_template_op12, port_speed_max_template_op12,
    tdm_table_default, GH2_TDM_SLOT_MAX,
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD},
    {0, 0}, {0, 0},
    {_GH2_QTC_SERDES_DEFAULT_MODE_NONE, _GH2_QTC_SERDES_DEFAULT_MODE_NONE}},
/* OPTION_13 */
{OPTION_13, _GH2_SYSTEM_FREQ_125,
    p2l_mapping_template_op13, port_speed_max_template_op13,
    tdm_table_default, GH2_TDM_SLOT_MAX,
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD},
    {0, 0}, {0, 0},
    {_GH2_QTC_SERDES_DEFAULT_MODE_NONE, _GH2_QTC_SERDES_DEFAULT_MODE_NONE}},
/* OPTION_14 */
{OPTION_14, _GH2_SYSTEM_FREQ_392,
    p2l_mapping_template_op14, port_speed_max_template_op14,
    tdm_table_default, GH2_TDM_SLOT_MAX,
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD},
    {0, 0}, {0, 0},
    {_GH2_QTC_SERDES_DEFAULT_MODE_NONE, _GH2_QTC_SERDES_DEFAULT_MODE_NONE}},
{NULL, 0,
    0, 0,
    0, 0,
    0, 0,
    {-1, -1, -1, -1, -1, -1, -1, -1},
    {0, 0}, {0, 0},
    {0, 0}},
};

STATIC _gh2_option_info_t _gh2_a0_option_port_config[] = {
/* Below options defined in PRD 4.7*/
/* OPTION_2_0, 24P*2.5G + 32P*10G */
{OPTION_2_0, _GH2_SYSTEM_FREQ_583,
    p2l_mapping_op2_0, port_speed_max_op2_0,
    tdm_table_op2_0, _GH2_ARRAY_SIZE(tdm_table_op2_0),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD},
    {0, 0}, {0, 0},
    {_GH2_QTC_SERDES_DEFAULT_MODE_NONE, _GH2_QTC_SERDES_DEFAULT_MODE_NONE}},
/* OPTION_2_2, 24*2.5G + 16*10G + 4*40G */
{OPTION_2_2, _GH2_SYSTEM_FREQ_583,
    p2l_mapping_op2_2, port_speed_max_op2_2,
    tdm_table_op2_2, _GH2_ARRAY_SIZE(tdm_table_op2_2),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_SINGLE,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_SINGLE},
    {0, 0}, {0, 0},
    {_GH2_QTC_SERDES_DEFAULT_MODE_NONE, _GH2_QTC_SERDES_DEFAULT_MODE_NONE}},
/* OPTION_2_3, 24*2.5G + 24*10G + 2*40G */
{OPTION_2_3, _GH2_SYSTEM_FREQ_583,
    p2l_mapping_op2_3, port_speed_max_op2_3,
    tdm_table_op2_3, _GH2_ARRAY_SIZE(tdm_table_op2_3),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_SINGLE},
    {0, 0}, {0, 0},
    {_GH2_QTC_SERDES_DEFAULT_MODE_NONE, _GH2_QTC_SERDES_DEFAULT_MODE_NONE}},
/* OPTION_5_2, 52*2.5G + 8*10G + 2*50G */
{OPTION_5_2, _GH2_SYSTEM_FREQ_500,
    p2l_mapping_op5_2, port_speed_max_op5_2,
    tdm_table_op5_2, _GH2_ARRAY_SIZE(tdm_table_op5_2),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_DUAL_2_2},
    {4, 4}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_SGMII, _GH2_QTC_SERDES_DEFAULT_MODE_SGMII}},
/* OPTION_9B_0, 48*1G + 40G RioT + 8*10G + 4*25G */
{OPTION_9B_0, _GH2_SYSTEM_FREQ_450,
    p2l_mapping_op9b_0, port_speed_max_op9b_0,
    tdm_table_op9b_0, _GH2_ARRAY_SIZE(tdm_table_op9b_0),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_SINGLE,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_SINGLE,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD},
    {4, 4}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_QSGMII, _GH2_QTC_SERDES_DEFAULT_MODE_QSGMII}},
/* OPTION_10B_0, 32*1G + 40G RioT + 8*10G + 4*25G */
{OPTION_10B_0, _GH2_SYSTEM_FREQ_450,
    p2l_mapping_op10b_0, port_speed_max_op10b_0,
    tdm_table_op10b_0, _GH2_ARRAY_SIZE(tdm_table_op10b_0),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD},
    {4, 4}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_SGMII, _GH2_QTC_SERDES_DEFAULT_MODE_SGMII}},
/* OPTION_13_0, 24P 1G + 4P 10G + XAUI*/
{OPTION_13_0, _GH2_SYSTEM_FREQ_125,
    p2l_mapping_op13_0, port_speed_max_op13_0,
    tdm_table_op13_0, _GH2_ARRAY_SIZE(tdm_table_op13_0),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_SINGLE_XAUI,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD},
    {0, 0}, {0, 0},
    {_GH2_QTC_SERDES_DEFAULT_MODE_NONE, _GH2_QTC_SERDES_DEFAULT_MODE_NONE}},

/* Below options defined in PRD 4.6*/
/* OPTION_1_0, 24P 10G + 4P 10G/25G */
{OPTION_1_0, _GH2_SYSTEM_FREQ_583,
    p2l_mapping_op1_0, port_speed_max_op1_0,
    tdm_table_op1_0, _GH2_ARRAY_SIZE(tdm_table_op1_0),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD},
    {0, 0}, {0, 0},
    {_GH2_QTC_SERDES_DEFAULT_MODE_NONE, _GH2_QTC_SERDES_DEFAULT_MODE_NONE}},
/* OPTION_1_1, 24P 10G + 2P HG[50] */
{OPTION_1_1, _GH2_SYSTEM_FREQ_583,
    p2l_mapping_op1_1, port_speed_max_op1_1,
    tdm_table_op1_1, _GH2_ARRAY_SIZE(tdm_table_op1_1),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_DUAL_2_2},
    {0, 0}, {0, 0},
    {_GH2_QTC_SERDES_DEFAULT_MODE_NONE, _GH2_QTC_SERDES_DEFAULT_MODE_NONE}},
/* OPTION_1_2, 6P 40G + 4P 10G/25G */
{OPTION_1_2, _GH2_SYSTEM_FREQ_583,
    p2l_mapping_op1_2, port_speed_max_op1_2,
    tdm_table_op1_2, _GH2_ARRAY_SIZE(tdm_table_op1_2),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_SINGLE,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_SINGLE,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_QUAD},
    {0, 0}, {0, 0},
    {_GH2_QTC_SERDES_DEFAULT_MODE_NONE, _GH2_QTC_SERDES_DEFAULT_MODE_NONE}},
/* OPTION_1_3, 6P 40G + 2P HG[50] */
{OPTION_1_3, _GH2_SYSTEM_FREQ_583,
    p2l_mapping_op1_3, port_speed_max_op1_3,
    tdm_table_op1_3, _GH2_ARRAY_SIZE(tdm_table_op1_3),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_SINGLE,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_SINGLE,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_DUAL_2_2},
    {0, 0}, {0, 0},
    {_GH2_QTC_SERDES_DEFAULT_MODE_NONE, _GH2_QTC_SERDES_DEFAULT_MODE_NONE}},
/* OPTION_2_1, 12P 2.5G + 8P 40G */
{OPTION_2_1, _GH2_SYSTEM_FREQ_583,
    p2l_mapping_op2_1, port_speed_max_op2_1,
    tdm_table_op2_1, _GH2_ARRAY_SIZE(tdm_table_op2_1),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_SINGLE,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_SINGLE,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_SINGLE,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_SINGLE},
    {0, 0}, {0, 0},
    {_GH2_QTC_SERDES_DEFAULT_MODE_NONE, _GH2_QTC_SERDES_DEFAULT_MODE_NONE}},
/* OPTION_3_0, 52P 2.5G + 4P 25G + 8P 10G */
{OPTION_3_0, _GH2_SYSTEM_FREQ_583,
    p2l_mapping_op3_0, port_speed_max_op3_0,
    tdm_table_op3_0, _GH2_ARRAY_SIZE(tdm_table_op3_0),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD},
    {4, 4}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_SGMII, _GH2_QTC_SERDES_DEFAULT_MODE_SGMII}},
/* OPTION_3_1, 52P 2.5G + 4P 25G + 2P 40G */
{OPTION_3_1, _GH2_SYSTEM_FREQ_583,
    p2l_mapping_op3_1, port_speed_max_op3_1,
    tdm_table_op3_1, _GH2_ARRAY_SIZE(tdm_table_op3_1),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_QUAD},
    {4, 4}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_SGMII, _GH2_QTC_SERDES_DEFAULT_MODE_SGMII}},
/* OPTION_3_2, 52P 2.5G + 2P 50G + 8P 10G */
{OPTION_3_2, _GH2_SYSTEM_FREQ_583,
    p2l_mapping_op3_2, port_speed_max_op3_2,
    tdm_table_op3_2, _GH2_ARRAY_SIZE(tdm_table_op3_2),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_DUAL_2_2},
    {4, 4}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_SGMII, _GH2_QTC_SERDES_DEFAULT_MODE_SGMII}},
/* OPTION_3_3, 52P 2.5G + 2P 50G + 2P 40G */
{OPTION_3_3, _GH2_SYSTEM_FREQ_583,
    p2l_mapping_op3_3, port_speed_max_op3_3,
    tdm_table_op3_3, _GH2_ARRAY_SIZE(tdm_table_op3_3),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_DUAL_2_2},
    {4, 4}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_SGMII, _GH2_QTC_SERDES_DEFAULT_MODE_SGMII}},
/* OPTION_4_0, 48P 2.5G + 4P 25G + 8P 10G */
{OPTION_4_0, _GH2_SYSTEM_FREQ_583,
    p2l_mapping_op4_0, port_speed_max_op4_0,
    tdm_table_op4_0, _GH2_ARRAY_SIZE(tdm_table_op4_0),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD},
    {4, 4}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_SGMII, _GH2_QTC_SERDES_DEFAULT_MODE_SGMII}},
/* OPTION_4_1, 48P 2.5G + 4P 25G + 2P 40G  */
{OPTION_4_1, _GH2_SYSTEM_FREQ_583,
    p2l_mapping_op4_1, port_speed_max_op4_1,
    tdm_table_op4_1, _GH2_ARRAY_SIZE(tdm_table_op4_1),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_QUAD},
    {4, 4}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_SGMII, _GH2_QTC_SERDES_DEFAULT_MODE_SGMII}},
/* OPTION_4_2, 48P 2.5G + 2P 50G + 8P 10G */
{OPTION_4_2, _GH2_SYSTEM_FREQ_583,
    p2l_mapping_op4_2, port_speed_max_op4_2,
    tdm_table_op4_2, _GH2_ARRAY_SIZE(tdm_table_op4_2),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_DUAL_2_2},
    {4, 4}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_SGMII, _GH2_QTC_SERDES_DEFAULT_MODE_SGMII}},
/* OPTION_4_3, 48P 2.5G + 2P 50G + 2P 40G */
{OPTION_4_3, _GH2_SYSTEM_FREQ_583,
    p2l_mapping_op4_3, port_speed_max_op4_3,
    tdm_table_op4_3, _GH2_ARRAY_SIZE(tdm_table_op4_3),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_DUAL_2_2},
    {4, 4}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_SGMII, _GH2_QTC_SERDES_DEFAULT_MODE_SGMII}},
/* OPTION_5_0, 24P 2.5G + 4P 25G + 8P 10G */
{OPTION_5_0, _GH2_SYSTEM_FREQ_437,
    p2l_mapping_op5_0, port_speed_max_op5_0,
    tdm_table_op5_0, _GH2_ARRAY_SIZE(tdm_table_op5_0),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD},
    {4, 0}, {4, 0},
    {_GH2_QTC_SERDES_DEFAULT_MODE_SGMII, _GH2_QTC_SERDES_DEFAULT_MODE_NONE}},
/* OPTION_5_1, 24P 2.5G + 4P 25G + 2P 40G */
{OPTION_5_1, _GH2_SYSTEM_FREQ_437,
    p2l_mapping_op5_1, port_speed_max_op5_1,
    tdm_table_op5_1, _GH2_ARRAY_SIZE(tdm_table_op5_1),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_QUAD},
    {4, 0}, {4, 0},
    {_GH2_QTC_SERDES_DEFAULT_MODE_SGMII, _GH2_QTC_SERDES_DEFAULT_MODE_NONE}},
/* OPTION_5_3, 24P 2.5G + 2P 50G + 2P 40G */
{OPTION_5_3, _GH2_SYSTEM_FREQ_437,
    p2l_mapping_op5_3, port_speed_max_op5_3,
    tdm_table_op5_3, _GH2_ARRAY_SIZE(tdm_table_op5_3),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_DUAL_2_2},
    {4, 0}, {4, 0},
    {_GH2_QTC_SERDES_DEFAULT_MODE_SGMII, _GH2_QTC_SERDES_DEFAULT_MODE_NONE}},
/* OPTION_6_0, 36P 1G + 12P 10G + 4P 25G + 8P 10G */
{OPTION_6_0, _GH2_SYSTEM_FREQ_583,
    p2l_mapping_op6_0, port_speed_max_op6_0,
    tdm_table_op6_0, _GH2_ARRAY_SIZE(tdm_table_op6_0),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD},
    {4, 4}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_QSGMII, _GH2_QTC_SERDES_DEFAULT_MODE_QSGMII}},
/* OPTION_6_1, 36P 1G + 12P 10G + 4P 25G + 2P 40G */
{OPTION_6_1, _GH2_SYSTEM_FREQ_583,
    p2l_mapping_op6_1, port_speed_max_op6_1,
    tdm_table_op6_1, _GH2_ARRAY_SIZE(tdm_table_op6_1),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_QUAD},
    {4, 4}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_QSGMII, _GH2_QTC_SERDES_DEFAULT_MODE_QSGMII}},
/* OPTION_6_2, 36P 1G + 12P 10G + 2P 50G + 8P 10G */
{OPTION_6_2, _GH2_SYSTEM_FREQ_583,
    p2l_mapping_op6_2, port_speed_max_op6_2,
    tdm_table_op6_2, _GH2_ARRAY_SIZE(tdm_table_op6_2),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_DUAL_2_2},
    {4, 4}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_QSGMII, _GH2_QTC_SERDES_DEFAULT_MODE_QSGMII}},
/* OPTION_6_3, 36P 1G + 12P 10G + 2P 50G + 2P 40G */
{OPTION_6_3, _GH2_SYSTEM_FREQ_583,
    p2l_mapping_op6_3, port_speed_max_op6_3,
    tdm_table_op6_3, _GH2_ARRAY_SIZE(tdm_table_op6_3),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_DUAL_2_2},
    {4, 4}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_QSGMII, _GH2_QTC_SERDES_DEFAULT_MODE_QSGMII}},
/* OPTION_7_0, 12P 1G + 12P 10G + 4P 25G + 8P 10G */
{OPTION_7_0, _GH2_SYSTEM_FREQ_583,
    p2l_mapping_op7_0, port_speed_max_op7_0,
    tdm_table_op7_0, _GH2_ARRAY_SIZE(tdm_table_op7_0),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD},
    {4, 0}, {0, 0},
    {_GH2_QTC_SERDES_DEFAULT_MODE_QSGMII, _GH2_QTC_SERDES_DEFAULT_MODE_NONE}},
/* OPTION_7_1, 12P 1G + 12P 10G + 4P 25G + 2P 40G */
{OPTION_7_1, _GH2_SYSTEM_FREQ_583,
    p2l_mapping_op7_1, port_speed_max_op7_1,
    tdm_table_op7_1, _GH2_ARRAY_SIZE(tdm_table_op7_1),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_QUAD},
    {4, 0}, {0, 0},
    {_GH2_QTC_SERDES_DEFAULT_MODE_QSGMII, _GH2_QTC_SERDES_DEFAULT_MODE_NONE}},
/* OPTION_7_2, 12P 1G + 12P 10G + 2P 50G + 8P 10G */
{OPTION_7_2, _GH2_SYSTEM_FREQ_583,
    p2l_mapping_op7_2, port_speed_max_op7_2,
    tdm_table_op7_2, _GH2_ARRAY_SIZE(tdm_table_op7_2),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_DUAL_2_2},
    {4, 0}, {0, 0},
    {_GH2_QTC_SERDES_DEFAULT_MODE_QSGMII, _GH2_QTC_SERDES_DEFAULT_MODE_NONE}},
/* OPTION_7_3, 12P 1G + 12P 10G + 2P 50G + 2P 40G */
{OPTION_7_3, _GH2_SYSTEM_FREQ_583,
    p2l_mapping_op7_3, port_speed_max_op7_3,
    tdm_table_op7_3, _GH2_ARRAY_SIZE(tdm_table_op7_3),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_DUAL_2_2},
    {4, 0}, {0, 0},
    {_GH2_QTC_SERDES_DEFAULT_MODE_QSGMII, _GH2_QTC_SERDES_DEFAULT_MODE_NONE}},
/* OPTION_8_0, 56P 1G + 4P 25G  + 4P 10G  */
{OPTION_8_0, _GH2_SYSTEM_FREQ_437,
    p2l_mapping_op8_0, port_speed_max_op8_0,
    tdm_table_op8_0, _GH2_ARRAY_SIZE(tdm_table_op8_0),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD},
    {4, 4}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_QSGMII, _GH2_QTC_SERDES_DEFAULT_MODE_QSGMII}},
/* OPTION_8_1, 56P 1G + 4P 25G  + 1P 40G */
{OPTION_8_1, _GH2_SYSTEM_FREQ_437,
    p2l_mapping_op8_1, port_speed_max_op8_1,
    tdm_table_op8_1, _GH2_ARRAY_SIZE(tdm_table_op8_1),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_QUAD},
    {4, 4}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_QSGMII, _GH2_QTC_SERDES_DEFAULT_MODE_QSGMII}},
/* OPTION_8_2, 56P 1G + 2P 50G  + 4P 10G */
{OPTION_8_2, _GH2_SYSTEM_FREQ_437,
    p2l_mapping_op8_2, port_speed_max_op8_2,
    tdm_table_op8_2, _GH2_ARRAY_SIZE(tdm_table_op8_2),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_DUAL_2_2},
    {4, 4}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_QSGMII, _GH2_QTC_SERDES_DEFAULT_MODE_QSGMII}},
/* OPTION_8_3, 56P 1G + 2P 50G  + 1P 40G */
{OPTION_8_3, _GH2_SYSTEM_FREQ_437,
    p2l_mapping_op8_3, port_speed_max_op8_3,
    tdm_table_op8_3, _GH2_ARRAY_SIZE(tdm_table_op8_3),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_DUAL_2_2},
    {4, 4}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_QSGMII, _GH2_QTC_SERDES_DEFAULT_MODE_QSGMII}},
/* OPTION_9_0, 48P 1G + 4P 25G  + 8P 10G */
{OPTION_9_0, _GH2_SYSTEM_FREQ_437,
    p2l_mapping_op9_0, port_speed_max_op9_0,
    tdm_table_op9_0, _GH2_ARRAY_SIZE(tdm_table_op9_0),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD},
    {4, 4}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_QSGMII, _GH2_QTC_SERDES_DEFAULT_MODE_QSGMII}},
/* OPTION_9_1, 48P 1G + 4P 25G  + 2P 40G */
{OPTION_9_1, _GH2_SYSTEM_FREQ_437,
    p2l_mapping_op9_1, port_speed_max_op9_1,
    tdm_table_op9_1, _GH2_ARRAY_SIZE(tdm_table_op9_1),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_QUAD},
    {4, 4}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_QSGMII, _GH2_QTC_SERDES_DEFAULT_MODE_QSGMII}},
/* OPTION_9_2, 48P 1G + 2P 50G  + 8P 10G */
{OPTION_9_2, _GH2_SYSTEM_FREQ_437,
    p2l_mapping_op9_2, port_speed_max_op9_2,
    tdm_table_op9_2, _GH2_ARRAY_SIZE(tdm_table_op9_2),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_DUAL_2_2},
    {4, 4}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_QSGMII, _GH2_QTC_SERDES_DEFAULT_MODE_QSGMII}},
/* OPTION_9_3, 48P 1G + 2P 50G  + 2P 40G */
{OPTION_9_3, _GH2_SYSTEM_FREQ_437,
    p2l_mapping_op9_3, port_speed_max_op9_3,
    tdm_table_op9_3, _GH2_ARRAY_SIZE(tdm_table_op9_3),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_DUAL_2_2},
    {4, 4}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_QSGMII, _GH2_QTC_SERDES_DEFAULT_MODE_QSGMII}},
/* OPTION_10_0, 16P 1G (SGMII) + 16P 1G (QSGMII) + 4P 25G + 8P 10G */
{OPTION_10_0, _GH2_SYSTEM_FREQ_437,
    p2l_mapping_op10_0, port_speed_max_op10_0,
    tdm_table_op10_0, _GH2_ARRAY_SIZE(tdm_table_op10_0),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD},
    {4, 0}, {0, 0},
    {_GH2_QTC_SERDES_DEFAULT_MODE_QSGMII, _GH2_QTC_SERDES_DEFAULT_MODE_NONE}},
/* OPTION_10_1, 16P 1G (SGMII) + 16P 1G (QSGMII) + 4P 25G + 2P 40G */
{OPTION_10_1, _GH2_SYSTEM_FREQ_437,
    p2l_mapping_op10_1, port_speed_max_op10_1,
    tdm_table_op10_1, _GH2_ARRAY_SIZE(tdm_table_op10_1),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_QUAD},
    {4, 0}, {0, 0},
    {_GH2_QTC_SERDES_DEFAULT_MODE_QSGMII, _GH2_QTC_SERDES_DEFAULT_MODE_NONE}},
/* OPTION_10_2, 16P 1G (SGMII) + 16P 1G (QSGMII) + 2P 50G + 8P 10G */
{OPTION_10_2, _GH2_SYSTEM_FREQ_437,
    p2l_mapping_op10_2, port_speed_max_op10_2,
    tdm_table_op10_2, _GH2_ARRAY_SIZE(tdm_table_op10_2),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_DUAL_2_2},
    {4, 0}, {0, 0},
    {_GH2_QTC_SERDES_DEFAULT_MODE_QSGMII, _GH2_QTC_SERDES_DEFAULT_MODE_NONE}},
/* OPTION_10_3, 16P 1G (SGMII) + 16P 1G (QSGMII) + 2P 50G + 2P 40G */
{OPTION_10_3, _GH2_SYSTEM_FREQ_437,
    p2l_mapping_op10_3, port_speed_max_op10_3,
    tdm_table_op10_3, _GH2_ARRAY_SIZE(tdm_table_op10_3),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_DUAL_2_2},
    {4, 0}, {0, 0},
    {_GH2_QTC_SERDES_DEFAULT_MODE_QSGMII, _GH2_QTC_SERDES_DEFAULT_MODE_NONE}},
/* OPTION_11_0, 32P 1G (QSGMII)+ 4P 25G + 8P 10G */
{OPTION_11_0, _GH2_SYSTEM_FREQ_437,
    p2l_mapping_op11_0, port_speed_max_op11_0,
    tdm_table_op11_0, _GH2_ARRAY_SIZE(tdm_table_op11_0),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD},
    {4, 4}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_QSGMII, _GH2_QTC_SERDES_DEFAULT_MODE_QSGMII}},
/* OPTION_11_1, 32P 1G (QSGMII)+ 4P 25G + 2P 40G */
{OPTION_11_1, _GH2_SYSTEM_FREQ_437,
    p2l_mapping_op11_1, port_speed_max_op11_1,
    tdm_table_op11_1, _GH2_ARRAY_SIZE(tdm_table_op11_1),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_QUAD},
    {4, 4}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_QSGMII, _GH2_QTC_SERDES_DEFAULT_MODE_QSGMII}},
/* OPTION_11_2, 32P 1G (QSGMII)+ 2P 50G + 8P 10G */
{OPTION_11_2, _GH2_SYSTEM_FREQ_437,
    p2l_mapping_op11_2, port_speed_max_op11_2,
    tdm_table_op11_2, _GH2_ARRAY_SIZE(tdm_table_op11_2),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_DUAL_2_2},
    {4, 4}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_QSGMII, _GH2_QTC_SERDES_DEFAULT_MODE_QSGMII}},
/* OPTION_11_3, 32P 1G (QSGMII)+ 2P 50G + 2P 40G */
{OPTION_11_3, _GH2_SYSTEM_FREQ_437,
    p2l_mapping_op11_3, port_speed_max_op11_3,
    tdm_table_op11_3, _GH2_ARRAY_SIZE(tdm_table_op11_3),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_SINGLE, SOC_GH2_PORT_RATIO_DUAL_2_2},
    {4, 4}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_QSGMII, _GH2_QTC_SERDES_DEFAULT_MODE_QSGMII}},
/* OPTION_12_0, 8P 1G (QGMII) + 4P 10G */
{OPTION_12_0, _GH2_SYSTEM_FREQ_125,
    p2l_mapping_op12_0, port_speed_max_op12_0,
    tdm_table_op12_0, _GH2_ARRAY_SIZE(tdm_table_op12_0),
    0x0, 0x0,
    {SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD,
     SOC_GH2_PORT_RATIO_QUAD, SOC_GH2_PORT_RATIO_QUAD},
    {4, 4}, {4, 4},
    {_GH2_QTC_SERDES_DEFAULT_MODE_QSGMII, _GH2_QTC_SERDES_DEFAULT_MODE_SGMII}},
{NULL, 0,
    0, 0,
    0, 0,
    0, 0,
    {-1, -1, -1, -1, -1, -1, -1, -1},
    {0, 0}, {0, 0},
    {0, 0}},
};

typedef struct _gh2_sku_option_list_s {
    uint16      dev_id;
    char        *option_string; /* option */
    int         default_option; /* 1 : the default option of the SKU */
} _gh2_sku_option_list_t;

_gh2_sku_option_list_t *_gh2_sku_option_support_list;

STATIC _gh2_sku_option_list_t _gh2_b0_sku_option_support_list[] = {
    {BCM56170_DEVICE_ID,  OPTION_1, 1},
    {BCM56170_DEVICE_ID,  OPTION_2, 0},
    {BCM56170_DEVICE_ID,  OPTION_2A, 0},
    {BCM56170_DEVICE_ID,  OPTION_3A, 0},
    {BCM56170_DEVICE_ID,  OPTION_4A, 0},
    {BCM56170_DEVICE_ID,  OPTION_5, 0},
    {BCM56170_DEVICE_ID,  OPTION_6, 0},
    {BCM56170_DEVICE_ID,  OPTION_7, 0},
    {BCM56170_DEVICE_ID,  OPTION_7B, 0},
    {BCM56170_DEVICE_ID,  OPTION_8B, 0},
    {BCM56170_DEVICE_ID,  OPTION_9B, 0},
    {BCM56170_DEVICE_ID,  OPTION_10B, 0},
    {BCM56170_DEVICE_ID,  OPTION_11B, 0},
    {BCM56170_DEVICE_ID,  OPTION_12B, 0},
    {BCM56170_DEVICE_ID,  OPTION_12, 0},
    {BCM56170_DEVICE_ID,  OPTION_13, 0},
    {BCM56170_DEVICE_ID,  OPTION_14, 0},
    {BCM56172_DEVICE_ID,  OPTION_7B, 1},
    {BCM56172_DEVICE_ID,  OPTION_8B, 0},
    {BCM56172_DEVICE_ID,  OPTION_9B, 0},
    {BCM56174_DEVICE_ID,  OPTION_10B, 1},
    {BCM56174_DEVICE_ID,  OPTION_11B, 0},
    {BCM56174_DEVICE_ID,  OPTION_12B, 0},
    {BCM56174_DEVICE_ID,  OPTION_14, 0},
    {BCM53570_DEVICE_ID,  OPTION_1, 1},
    {BCM53570_DEVICE_ID,  OPTION_2, 0},
    {BCM53570_DEVICE_ID,  OPTION_5, 0},
    {BCM53570_DEVICE_ID,  OPTION_6, 0},
    {BCM53570_DEVICE_ID,  OPTION_7, 0},
    {BCM53570_DEVICE_ID,  OPTION_12, 0},
    {BCM53570_DEVICE_ID,  OPTION_13, 0},
    {BCM53575_DEVICE_ID,  OPTION_13, 1},
    {0, "not existed", 0},
};

STATIC _gh2_sku_option_list_t _gh2_a0_sku_option_support_list[] = {
    /* Below options defined in PRD 4.7*/
    /* BCM56170 */
    {BCM56170_DEVICE_ID,  OPTION_2_0, 0},
    {BCM56170_DEVICE_ID,  OPTION_2_2, 1},
    {BCM56170_DEVICE_ID,  OPTION_2_3, 0},
    {BCM56170_DEVICE_ID,  OPTION_5_2, 0},
    {BCM56170_DEVICE_ID,  OPTION_9B_0, 0},
    {BCM56170_DEVICE_ID,  OPTION_10B_0, 0},
    {BCM56170_DEVICE_ID,  OPTION_13_0, 0},
    /* BCM56172 */
    {BCM56172_DEVICE_ID,  OPTION_9B_0, 1},
    /* BCM56174 */
    {BCM56174_DEVICE_ID,  OPTION_10B_0, 1},
    /* BCM53570 */
    {BCM53570_DEVICE_ID,  OPTION_2_0, 0},
    {BCM53570_DEVICE_ID,  OPTION_2_2, 1},
    {BCM53570_DEVICE_ID,  OPTION_2_3, 0},
    {BCM53570_DEVICE_ID,  OPTION_5_2, 0},
    {BCM53570_DEVICE_ID,  OPTION_13_0, 0},

    /* Below options defined in PRD 4.6*/
    /* BCM56170 */
    {BCM56170_DEVICE_ID,  OPTION_1_0, 0},
    {BCM56170_DEVICE_ID,  OPTION_1_1, 0},
    {BCM56170_DEVICE_ID,  OPTION_1_2, 0},
    {BCM56170_DEVICE_ID,  OPTION_1_3, 0},
    {BCM56170_DEVICE_ID,  OPTION_2_1, 0},
    {BCM56170_DEVICE_ID,  OPTION_3_0, 0},
    {BCM56170_DEVICE_ID,  OPTION_3_1, 0},
    {BCM56170_DEVICE_ID,  OPTION_3_2, 0},
    {BCM56170_DEVICE_ID,  OPTION_3_3, 0},
    {BCM56170_DEVICE_ID,  OPTION_4_0, 0},
    {BCM56170_DEVICE_ID,  OPTION_4_1, 0},
    {BCM56170_DEVICE_ID,  OPTION_4_2, 0},
    {BCM56170_DEVICE_ID,  OPTION_4_3, 0},
    {BCM56170_DEVICE_ID,  OPTION_6_0, 0},
    {BCM56170_DEVICE_ID,  OPTION_6_1, 0},
    {BCM56170_DEVICE_ID,  OPTION_6_2, 0},
    {BCM56170_DEVICE_ID,  OPTION_6_3, 0},
    {BCM56170_DEVICE_ID,  OPTION_8_0, 0},
    {BCM56170_DEVICE_ID,  OPTION_8_1, 0},
    {BCM56170_DEVICE_ID,  OPTION_8_2, 0},
    {BCM56170_DEVICE_ID,  OPTION_8_3, 0},
    /* BCM56172 */
    {BCM56172_DEVICE_ID,  OPTION_5_0, 0},
    {BCM56172_DEVICE_ID,  OPTION_5_1, 0},
    {BCM56172_DEVICE_ID,  OPTION_5_3, 0},
    {BCM56172_DEVICE_ID,  OPTION_7_0, 0},
    {BCM56172_DEVICE_ID,  OPTION_7_1, 0},
    {BCM56172_DEVICE_ID,  OPTION_7_2, 0},
    {BCM56172_DEVICE_ID,  OPTION_7_3, 0},
    {BCM56172_DEVICE_ID,  OPTION_9_0, 0},
    {BCM56172_DEVICE_ID,  OPTION_9_1, 0},
    {BCM56172_DEVICE_ID,  OPTION_9_2, 0},
    {BCM56172_DEVICE_ID,  OPTION_9_3, 0},
    /* BCM56174 */
    {BCM56174_DEVICE_ID,  OPTION_10_0, 0},
    {BCM56174_DEVICE_ID,  OPTION_10_1, 0},
    {BCM56174_DEVICE_ID,  OPTION_10_2, 0},
    {BCM56174_DEVICE_ID,  OPTION_10_3, 0},
    {BCM56174_DEVICE_ID,  OPTION_11_0, 0},
    {BCM56174_DEVICE_ID,  OPTION_11_1, 0},
    {BCM56174_DEVICE_ID,  OPTION_11_2, 0},
    {BCM56174_DEVICE_ID,  OPTION_11_3, 0},
    /* BCM53570 */
    {BCM53570_DEVICE_ID,  OPTION_1_0, 0},
    {BCM53570_DEVICE_ID,  OPTION_1_1, 0},
    {BCM53570_DEVICE_ID,  OPTION_1_2, 0},
    {BCM53570_DEVICE_ID,  OPTION_1_3, 0},
    {BCM53570_DEVICE_ID,  OPTION_2_1, 0},
    {BCM53570_DEVICE_ID,  OPTION_3_0, 0},
    {BCM53570_DEVICE_ID,  OPTION_3_1, 0},
    {BCM53570_DEVICE_ID,  OPTION_3_2, 0},
    {BCM53570_DEVICE_ID,  OPTION_3_3, 0},
    {BCM53570_DEVICE_ID,  OPTION_4_0, 0},
    {BCM53570_DEVICE_ID,  OPTION_4_1, 0},
    {BCM53570_DEVICE_ID,  OPTION_4_2, 0},
    {BCM53570_DEVICE_ID,  OPTION_4_3, 0},
    {BCM53570_DEVICE_ID,  OPTION_6_0, 0},
    {BCM53570_DEVICE_ID,  OPTION_6_1, 0},
    {BCM53570_DEVICE_ID,  OPTION_6_2, 0},
    {BCM53570_DEVICE_ID,  OPTION_6_3, 0},
    {BCM53570_DEVICE_ID,  OPTION_8_0, 0},
    {BCM53570_DEVICE_ID,  OPTION_8_1, 0},
    {BCM53570_DEVICE_ID,  OPTION_8_2, 0},
    {BCM53570_DEVICE_ID,  OPTION_8_3, 0},
    /* BCM53575 */
    {BCM53575_DEVICE_ID,  OPTION_12_0, 1},
    {BCM53575_DEVICE_ID,  OPTION_13_0, 0},
    {0, "not existed", 0},
};

#define FLEX_2P5    0 /* flex 2.5 */
#define FLEX_10     1 /* flex 10 */
#define FLEX_40     2 /* flex 40 */
#define FLEX_50     3 /* flex 50 */
#define FLEX_XAUI   4 /* flex xaui */
#define FLEX_20G_RIOT   5 /* flex 20G RioT */
#define FLEX_OFF    (-1) /* core is off */

typedef struct _gh2_option_tsc_flex_mode_s {
    char        *config_op; /* option string */
    int         mode[_GH2_MAX_TSC_COUNT];
} _gh2_option_tsc_flex_mode_t;

/* Supported flex port speed of each TSC */
STATIC _gh2_option_tsc_flex_mode_t _gh2_option_tsc_flex_modes[] = {
    /* OPTION_1 */
    {OPTION_1, {FLEX_40, FLEX_40, FLEX_40, FLEX_40,
                FLEX_40, FLEX_40, FLEX_40, FLEX_50}},
    /* OPTION_2 */
    {OPTION_2, {FLEX_40, FLEX_40, FLEX_40, FLEX_40,
                FLEX_40, FLEX_40, FLEX_40, FLEX_40}},
    /* OPTION_2A */
    {OPTION_2A, {FLEX_40, FLEX_40, FLEX_40, FLEX_40,
                FLEX_40, FLEX_40, FLEX_40, FLEX_40}},
    /* OPTION_3A */
    {OPTION_3A, {FLEX_10, FLEX_OFF, FLEX_10, FLEX_10,
                FLEX_40, FLEX_20G_RIOT, FLEX_40, FLEX_50}},
    /* OPTION_4A */
    {OPTION_4A, {FLEX_2P5, FLEX_2P5, FLEX_2P5, FLEX_2P5,
                FLEX_40, FLEX_20G_RIOT, FLEX_40, FLEX_50}},
    /* OPTION_5 */
    {OPTION_5, {FLEX_2P5, FLEX_2P5, FLEX_2P5, FLEX_2P5,
                FLEX_40, FLEX_2P5, FLEX_40, FLEX_50}},
    /* OPTION_6 */
    {OPTION_6, {FLEX_OFF, FLEX_OFF, FLEX_OFF, FLEX_OFF,
                FLEX_40, FLEX_XAUI, FLEX_40, FLEX_50}},
    /* OPTION_7 */
    {OPTION_7, {FLEX_40, FLEX_40, FLEX_40, FLEX_40,
                FLEX_40, FLEX_40, FLEX_40, FLEX_40}},
    /* OPTION_7B */
    {OPTION_7B, {FLEX_40, FLEX_40, FLEX_40, FLEX_20G_RIOT,
                FLEX_40, FLEX_20G_RIOT, FLEX_40, FLEX_40}},
    /* OPTION_8B */
    {OPTION_8B, {FLEX_2P5, FLEX_2P5, FLEX_2P5, FLEX_20G_RIOT,
                FLEX_40, FLEX_20G_RIOT, FLEX_40, FLEX_50}},
    /* OPTION_9B */
    {OPTION_9B, {FLEX_OFF, FLEX_OFF, FLEX_OFF, FLEX_20G_RIOT,
                FLEX_40, FLEX_20G_RIOT, FLEX_40, FLEX_50}},
    /* OPTION_10B */
    {OPTION_10B, {FLEX_OFF, FLEX_OFF, FLEX_OFF, FLEX_20G_RIOT,
                FLEX_40, FLEX_20G_RIOT, FLEX_40, FLEX_50}},
    /* OPTION_11B */
    {OPTION_11B, {FLEX_OFF, FLEX_OFF, FLEX_OFF, FLEX_20G_RIOT,
                FLEX_40, FLEX_20G_RIOT, FLEX_40, FLEX_50}},
    /* OPTION_12B */
    {OPTION_12B, {FLEX_OFF, FLEX_OFF, FLEX_40, FLEX_20G_RIOT,
                FLEX_40, FLEX_20G_RIOT, FLEX_40, FLEX_40}},
    /* OPTION_12 */
    {OPTION_12, {FLEX_OFF, FLEX_OFF, FLEX_40, FLEX_40,
                FLEX_40, FLEX_40, FLEX_40, FLEX_40}},
    /* OPTION_13 */
    {OPTION_13, {FLEX_OFF, FLEX_OFF, FLEX_OFF, FLEX_OFF,
                FLEX_40, FLEX_XAUI, FLEX_OFF, FLEX_OFF}},
    /* OPTION_14 */
    {OPTION_14, {FLEX_OFF, FLEX_OFF, FLEX_40, FLEX_OFF,
                FLEX_40, FLEX_OFF, FLEX_40, FLEX_50}},
    /* invalid entry */
    {NULL, {-1, -1, -1, -1, -1, -1, -1, -1}},
};

/* MMU related */
#define GH2_A0_MMU_CBP_FULL_SIZE 0x5fff
#define GH2_A0_MMU_CBP_HALF_SIZE 0x47ff
#define GH2_A0_MMU_CBP_QUARTER_SIZE 0x2fff

#define GH2_B0_MMU_CBP_FULL_SIZE 0x7fff
#define GH2_B0_MMU_CBP_HALF_SIZE 0x5fff
#define GH2_B0_MMU_CBP_QUARTER_SIZE 0x3fff

#define CMIC_PARITY_MMU_TO_CMIC_MEMFAIL_INTR_BIT    0x0001
#define CMIC_PARITY_EP_TO_CMIC_PERR_INTR_BIT        0x0002
#define CMIC_PARITY_IP0_TO_CMIC_PERR_INTR_BIT       0x0004
#define CMIC_PARITY_IP1_TO_CMIC_PERR_INTR_BIT       0x0008
#define CMIC_PARITY_IP2_TO_CMIC_PERR_INTR_BIT       0x0010

#define _SOC_GH2_MMU_IPMC_GROUP_MAX     65
static soc_mem_t ipmc_mems[_SOC_GH2_MMU_IPMC_GROUP_MAX] = {
        INVALIDm,  INVALIDm,
        MMU_IPMC_GROUP_TBL2m,  MMU_IPMC_GROUP_TBL3m,
        MMU_IPMC_GROUP_TBL4m,  MMU_IPMC_GROUP_TBL5m,
        MMU_IPMC_GROUP_TBL6m,  MMU_IPMC_GROUP_TBL7m,
        MMU_IPMC_GROUP_TBL8m,  MMU_IPMC_GROUP_TBL9m,
        MMU_IPMC_GROUP_TBL10m,  MMU_IPMC_GROUP_TBL11m,
        MMU_IPMC_GROUP_TBL12m,  MMU_IPMC_GROUP_TBL13m,
        MMU_IPMC_GROUP_TBL14m,  MMU_IPMC_GROUP_TBL15m,
        MMU_IPMC_GROUP_TBL16m,  MMU_IPMC_GROUP_TBL17m,
        MMU_IPMC_GROUP_TBL18m,  MMU_IPMC_GROUP_TBL19m,
        MMU_IPMC_GROUP_TBL20m,  MMU_IPMC_GROUP_TBL21m,
        MMU_IPMC_GROUP_TBL22m,  MMU_IPMC_GROUP_TBL23m,
        MMU_IPMC_GROUP_TBL24m,  MMU_IPMC_GROUP_TBL25m,
        MMU_IPMC_GROUP_TBL26m,  MMU_IPMC_GROUP_TBL27m,
        MMU_IPMC_GROUP_TBL28m,  MMU_IPMC_GROUP_TBL29m,
        MMU_IPMC_GROUP_TBL30m,  MMU_IPMC_GROUP_TBL31m,
        MMU_IPMC_GROUP_TBL32m,  MMU_IPMC_GROUP_TBL33m,
        MMU_IPMC_GROUP_TBL34m,  MMU_IPMC_GROUP_TBL35m,
        MMU_IPMC_GROUP_TBL36m,  MMU_IPMC_GROUP_TBL37m,
        MMU_IPMC_GROUP_TBL38m,  MMU_IPMC_GROUP_TBL39m,
        MMU_IPMC_GROUP_TBL40m,  MMU_IPMC_GROUP_TBL41m,
        MMU_IPMC_GROUP_TBL42m,  MMU_IPMC_GROUP_TBL43m,
        MMU_IPMC_GROUP_TBL44m,  MMU_IPMC_GROUP_TBL45m,
        MMU_IPMC_GROUP_TBL46m,  MMU_IPMC_GROUP_TBL47m,
        MMU_IPMC_GROUP_TBL48m,  MMU_IPMC_GROUP_TBL49m,
        MMU_IPMC_GROUP_TBL50m,  MMU_IPMC_GROUP_TBL51m,
        MMU_IPMC_GROUP_TBL52m,  MMU_IPMC_GROUP_TBL53m,
        MMU_IPMC_GROUP_TBL54m,  MMU_IPMC_GROUP_TBL55m,
        MMU_IPMC_GROUP_TBL56m,  MMU_IPMC_GROUP_TBL57m,
        MMU_IPMC_GROUP_TBL58m,  MMU_IPMC_GROUP_TBL59m,
        MMU_IPMC_GROUP_TBL60m,  MMU_IPMC_GROUP_TBL61m,
        MMU_IPMC_GROUP_TBL62m,  MMU_IPMC_GROUP_TBL63m,
        MMU_IPMC_GROUP_TBL64m
};

static int
soc_greyhound2_pipe_mem_clear(int unit)
{
    uint32              rval;
    int                 pipe_init_usec, index;
    soc_timeout_t       to;
    static const struct {
        soc_mem_t mem;
        uint32 skip_flags; /* always skip on QUICKTURN or XGSSIM */
    } cam_list[] = {
        { CPU_COS_MAPm,                     BOOT_F_PLISIM },
        { EFP_TCAMm,                        BOOT_F_PLISIM },
        { FP_GLOBAL_MASK_TCAMm,             BOOT_F_PLISIM },
        { FP_TCAMm,                         BOOT_F_PLISIM },
        { L2_USER_ENTRYm,                   BOOT_F_PLISIM },
        { L2_USER_ENTRY_ONLYm,              BOOT_F_PLISIM },
        { L3_DEFIPm,                        BOOT_F_PLISIM },
        { L3_DEFIP_ONLYm,                   BOOT_F_PLISIM },
        { VFP_TCAMm,                        BOOT_F_PLISIM },
        { VLAN_SUBNETm,                     0 },/* VLAN API needs all 0 mask */
        { VLAN_SUBNET_ONLYm,                0 }
    };

    /*
     * Reset the IPIPE and EPIPE block
     */
    rval = 0;
    SOC_IF_ERROR_RETURN(WRITE_ING_HW_RESET_CONTROL_1r(unit, rval));
    soc_reg_field_set(unit, ING_HW_RESET_CONTROL_2r, &rval, RESET_ALLf, 1);
    soc_reg_field_set(unit, ING_HW_RESET_CONTROL_2r, &rval, VALIDf, 1);
    /* Set count to # entries in largest IPIPE table, L2_ENTRYm */
    soc_reg_field_set(unit, ING_HW_RESET_CONTROL_2r, &rval, COUNTf, 0x8000);
    SOC_IF_ERROR_RETURN(WRITE_ING_HW_RESET_CONTROL_2r(unit, rval));

    rval = 0;
    SOC_IF_ERROR_RETURN(WRITE_EGR_HW_RESET_CONTROL_0r(unit, rval));
    soc_reg_field_set(unit, EGR_HW_RESET_CONTROL_1r, &rval, RESET_ALLf, 1);
    soc_reg_field_set(unit, EGR_HW_RESET_CONTROL_1r, &rval, VALIDf, 1);
    /*
     * Set count to # entries in largest EPIPE table,
     * SR_FLOW_EGR_COUNTER_CONTROLm
     */
    soc_reg_field_set(unit, EGR_HW_RESET_CONTROL_1r, &rval, COUNTf, 0x2000);
    SOC_IF_ERROR_RETURN(WRITE_EGR_HW_RESET_CONTROL_1r(unit, rval));

    /* For simulation, set timeout to 10 sec.  Otherwise, timeout = 50 ms */
    if (SAL_BOOT_SIMULATION) {
        pipe_init_usec = 10000000;
    } else {
        pipe_init_usec = 50000;
    }
    soc_timeout_init(&to, pipe_init_usec, 0);

    /* Wait for IPIPE memory initialization done. */
    do {
        SOC_IF_ERROR_RETURN(READ_ING_HW_RESET_CONTROL_2r(unit, &rval));
        if (soc_reg_field_get(unit, ING_HW_RESET_CONTROL_2r, rval, DONEf)) {
            break;
        }
        if (soc_timeout_check(&to)) {
            LOG_WARN(BSL_LS_SOC_COMMON,
                     (BSL_META_U(unit,
                                 "unit %d : ING_HW_RESET timeout\n"), unit));
            break;
        }
    } while (TRUE);

    /* Wait for EPIPE memory initialization done. */
    do {
        SOC_IF_ERROR_RETURN(READ_EGR_HW_RESET_CONTROL_1r(unit, &rval));
        if (soc_reg_field_get(unit, EGR_HW_RESET_CONTROL_1r, rval, DONEf)) {
            break;
        }
        if (soc_timeout_check(&to)) {
            LOG_WARN(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit, "unit %d : EGR_HW_RESET timeout\n"), unit));
            break;
        }
    } while (TRUE);

    rval = 0;
    SOC_IF_ERROR_RETURN(WRITE_ING_HW_RESET_CONTROL_2r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_EGR_HW_RESET_CONTROL_1r(unit, rval));

    /* Processing tables that are not handled by hardware reset */
    if (!SAL_BOOT_SIMULATION || SAL_BOOT_BCMSIM) {
        /* TCAM tables are not handled by hardware reset control */
        for (index = 0; index < sizeof(cam_list) / sizeof(cam_list[0]);
             index++) {
            if (sal_boot_flags_get() & cam_list[index].skip_flags) {
                continue;
            }
            if (((cam_list[index].mem == EFP_TCAMm) ||
                (cam_list[index].mem == VFP_TCAMm)) &&
                (!soc_feature(unit, soc_feature_field_multi_stage))) {
                continue;
            }

            SOC_IF_ERROR_RETURN
                (soc_mem_clear(unit, cam_list[index].mem, COPYNO_ALL, TRUE));
        }

        /* MMU_IPMC_VLAN_TBL */
        SOC_IF_ERROR_RETURN
            (soc_mem_clear(unit, MMU_IPMC_VLAN_TBLm, COPYNO_ALL, TRUE));

        /* MMU_IPMC_GROUP_TBLn : n is 2 ~ 64 in GH2 */
        for (index = 0; index < _SOC_GH2_MMU_IPMC_GROUP_MAX; index++) {
            if (ipmc_mems[index] != INVALIDm) {
                SOC_IF_ERROR_RETURN(soc_mem_clear(unit,
                                    ipmc_mems[index], COPYNO_ALL, TRUE));
            }
        }

    }

    return SOC_E_NONE;
}

/*
 * Function:
 *      soc_greyhound2_gmac_init()
 * Purpose:
 *      To init GMAC (should be moved to mac)
 */
STATIC int
soc_greyhound2_gmac_init(int unit)
{
    uint32 rval;
    uint32 prev_reg_addr;
    int port;

    rval = 0;
    soc_reg_field_set(unit, GPORT_CONFIGr, &rval, CLR_CNTf, 1);
    soc_reg_field_set(unit, GPORT_CONFIGr, &rval, GPORT_ENf, 1);
    prev_reg_addr = 0xffffffff;
    PBMP_E_ITER(unit, port) {
        uint32  reg_addr;
        if (IS_XL_PORT(unit, port) || IS_CL_PORT(unit, port)) {
            continue;
        }
        reg_addr = soc_reg_addr(unit, GPORT_CONFIGr, port, 0);
        if (reg_addr != prev_reg_addr) {
            SOC_IF_ERROR_RETURN(WRITE_GPORT_CONFIGr(unit, port, rval));
            prev_reg_addr = reg_addr;
        }
    }
    prev_reg_addr = 0xffffffff;
    soc_reg_field_set(unit, GPORT_CONFIGr, &rval, CLR_CNTf, 0);
    PBMP_E_ITER(unit, port) {
        uint32  reg_addr;
        if (IS_XL_PORT(unit, port) || IS_CL_PORT(unit, port)) {
            continue;
        }
        reg_addr = soc_reg_addr(unit, GPORT_CONFIGr, port, 0);
        if (reg_addr != prev_reg_addr) {
            SOC_IF_ERROR_RETURN(WRITE_GPORT_CONFIGr(unit, port, rval));
            prev_reg_addr = reg_addr;
        }
    }

    return SOC_E_NONE;
}

/*
 * Func : soc_greyhound2_pgw_encap_field_modify
 *  - To write to PGW interface on GX/XL/CL port on indicated field
 */
int
soc_greyhound2_pgw_encap_field_modify(int unit,
                                soc_port_t lport,
                                soc_field_t field,
                                uint32 val)
{
    int     pport = SOC_INFO(unit).port_l2p_mapping[lport];

    if (SOC_PORT_BLOCK_TYPE(unit, pport) == SOC_BLK_XLPORT) {
        SOC_IF_ERROR_RETURN(soc_reg_field32_modify(unit,
                    PGW_XL_CONFIGr, lport, field, val));
    } else if (SOC_PORT_BLOCK_TYPE(unit, pport) == SOC_BLK_CLPORT) {
        SOC_IF_ERROR_RETURN(soc_reg_field32_modify(unit,
                    PGW_CL_CONFIGr, lport, field, val));
    } else {
        SOC_IF_ERROR_RETURN(soc_reg_field32_modify(unit,
                    PGW_GE_CONFIGr, lport, field, val));
    }

    return SOC_E_NONE;
}
/*
 * Function:
 *      soc_greyhound2_higig_mode_init()
 * Purpose:
 *      To init the default Higig mode for HG port
 */
STATIC int
soc_greyhound2_higig_mode_init(int unit)
{
    uint32 rval;
    int port;

    PBMP_PORT_ITER(unit, port) {
        if (!IS_HG_PORT(unit, port)) {
            continue;
        }
        if (!IS_XL_PORT(unit, port) && !IS_CL_PORT(unit, port)) {
            continue;
        }

        /* Section below is used to config XLPORT and PGW related HiGig encap
         * setting for normal init process.
         */
        if (IS_XL_PORT(unit, port)) {
            SOC_IF_ERROR_RETURN(READ_XLPORT_CONFIGr(unit, port, &rval));
            soc_reg_field_set(unit, XLPORT_CONFIGr, &rval, HIGIG_MODEf, 1);
            SOC_IF_ERROR_RETURN(WRITE_XLPORT_CONFIGr(unit, port, rval));
        }
        if (IS_CL_PORT(unit, port)) {
            SOC_IF_ERROR_RETURN(READ_CLPORT_CONFIGr(unit, port, &rval));
            soc_reg_field_set(unit, CLPORT_CONFIGr, &rval, HIGIG_MODEf, 1);
            SOC_IF_ERROR_RETURN(WRITE_CLPORT_CONFIGr(unit, port, rval));
        }

        /* only HG ports allows PGW encap setting below */
        SOC_IF_ERROR_RETURN(soc_greyhound2_pgw_encap_field_modify(unit,
                port, HIGIG_MODEf, 1));
    }

    return SOC_E_NONE;
}

/*
 * Function:
 *      soc_greyhound2_mib_reset()
 * Purpose:
 *      Reset MIB counter
 */
STATIC int
soc_greyhound2_mib_reset(int unit)
{
    uint32 rval, fval;
    int blk, bindex;
    soc_info_t *si = &SOC_INFO(unit);
    int blk_port, phy_port;

    /*
     * Reset XLPORT and CLPORT MIB counter
     * (registers implemented in memory).
     * The clear function is implemented with read-modify-write,
     * parity needs to be disabled
     */
    SOC_BLOCK_ITER(unit, blk, SOC_BLK_XLPORT) {
        blk_port = SOC_BLOCK_PORT(unit, blk);
        if (blk_port < 0) {
            continue;
        }
        phy_port = si->port_l2p_mapping[blk_port];
        fval = 0;
        for (bindex = 0; bindex < 4; bindex++) {
            if (si->port_p2l_mapping[phy_port + bindex] != -1) {
                fval |= 1 << bindex;
            }
        }
        rval = 0;
        soc_reg_field_set(unit, XLPORT_MIB_RESETr, &rval, CLR_CNTf, fval);
        SOC_IF_ERROR_RETURN(WRITE_XLPORT_MIB_RESETr(unit, blk_port, rval));
        SOC_IF_ERROR_RETURN(WRITE_XLPORT_MIB_RESETr(unit, blk_port, 0));
    }
    SOC_BLOCK_ITER(unit, blk, SOC_BLK_CLPORT) {
        blk_port = SOC_BLOCK_PORT(unit, blk);
        if (blk_port < 0) {
            continue;
        }
        phy_port = si->port_l2p_mapping[blk_port];
        fval = 0;
        for (bindex = 0; bindex < 4; bindex++) {
            if (si->port_p2l_mapping[phy_port + bindex] != -1) {
                fval |= 1 << bindex;
            }
        }
        rval = 0;
        soc_reg_field_set(unit, CLPORT_MIB_RESETr, &rval, CLR_CNTf, fval);
        SOC_IF_ERROR_RETURN(WRITE_CLPORT_MIB_RESETr(unit, blk_port, rval));
        SOC_IF_ERROR_RETURN(WRITE_CLPORT_MIB_RESETr(unit, blk_port, 0));
    }

    return SOC_E_NONE;
}

/*
 * GH2 interrupt handler functions
 */
STATIC soc_gh2_oam_ser_handler_t
gh2_oam_ser_handler[SOC_MAX_NUM_DEVICES] = {NULL};
STATIC soc_gh2_oam_handler_t gh2_oam_handler[SOC_MAX_NUM_DEVICES] = {NULL};
STATIC soc_gh2_tsn_event_handler_t gh2_intr_sr_h[SOC_MAX_NUM_DEVICES] = {NULL};
STATIC soc_gh2_cosq_event_handler_t
gh2_intr_tas_h[SOC_MAX_NUM_DEVICES] = {NULL};
STATIC soc_gh2_taf_event_handler_t
gh2_intr_taf_h[SOC_MAX_NUM_DEVICES] = {NULL};

STATIC soc_ser_functions_t gh2_ser_functions[SOC_MAX_NUM_DEVICES];
static uint8 gh2_event_handler_init = 0;

/* Interrupt types on GH2 */
#define GH2_INTR_PARITY         (1)
#define GH2_INTR_L2_OVERFLOW    (2)
#define GH2_INTR_OAM            (3)
#define GH2_INTR_TAS            (4)
#define GH2_INTR_SR             (5)
#define GH2_INTR_TAF            (6)

/* CMIC IRQ type */
#define GH2_CMIC_IRQ3           (3)
#define GH2_CMIC_IRQ4           (4)

/*
 * Helper macro to get interrupt types' device CMIC IRQx mask
 */
#define GH2_IRQ_MASK(bit)       (1<<(bit)) /* Bit 0-31  */
/*
 * GH2_INTR_PARITY: CMIC_CMCx_IRQ_STAT3r
 * bit0-6(mmu,ep,ip), 8-20(ge,xl,cl port)
 */
#define GH2_IRQ3_INTR_MASK_PARITY           (0x1FFF7F)
/* GH2_INTR_L2_OVERFLOW: IP1_TO_CMIC_PERR_INTR (CMIC_CMCx_IRQ_STAT3r : bit 3) */
#define GH2_IRQ3_INTR_MASK_L2_OVERFLOW      (0x8)
/* GH2_INTR_OAM: IP2_TO_CMIC_PERR_INTR  (CMIC_CMCx_IRQ_STAT3r : bit 4) */
#define GH2_IRQ3_INTR_MASK_OAM              (0x10)
/* GH2_INTR_TAS: MMU_TO_CMIC_MEMFAIL_INTR (CMIC_CMCx_IRQ_STAT3r : bit 0) */
#define GH2_IRQ3_INTR_MASK_TAS              (0x1)
/*
 * GH2_INTR_SR:
 * EP_TO_CMIC_PERR_INTR (CMIC_CMCx_IRQ_STAT3r : bit 1)
 * IP2_TO_CMIC_PERR_INTR  (CMIC_CMCx_IRQ_STAT3r : bit 4)
 * IP2_SR_TH_TO_CMIC_INTR  (CMIC_CMCx_IRQ_STAT4r : bit 3)
 * TAF_GSG_TO_CMIC_INTR  (CMIC_CMCx_IRQ_STAT4r : bit 4)
 */
#define GH2_IRQ3_INTR_MASK_SR               (0x12)
#define GH2_IRQ4_INTR_MASK_SR               (0x8)
#define GH2_IRQ4_INTR_MASK_TAF              (0x10)


/* Fields for OAM SER and event */
soc_field_t _soc_gh2_oam_interrupt_fields[] = {
    SOME_RMEP_CCM_DEFECT_INTRf,
    SOME_RDI_DEFECT_INTRf,
    ANY_RMEP_TLV_PORT_DOWN_INTRf,
    ANY_RMEP_TLV_PORT_UP_INTRf,
    ANY_RMEP_TLV_INTERFACE_DOWN_INTRf,
    ANY_RMEP_TLV_INTERFACE_UP_INTRf,
    XCON_CCM_DEFECT_INTRf,
    ERROR_CCM_DEFECT_INTRf,
    INVALIDf
};

/* Fields mask for TAS evnets bit 22,21,20,19,17,16 in MEMFAILINTSTATUSr */
#define GH2_TAS_INTR_STATUS_MASK     (0x7B0000)

/* Fields mask for TAF evnets bit 22,21,20,19,17,16 in TAF_MEMFAILINTSTATUSr */
#define GH2_TAF_INTR_STATUS_MASK     (0x7B0000)

/* Fields mask for SR events bit 43,44 in IP2_INTR_STATUSr */
#define GH2_IP2_SR_LAN_INTR_STATUS_HI_MASK     (0x1800)

/* Fields mask for L2 overflow bit 8,9 in IP1_INTR_STATUSr */
#define GH2_IP1_L2_INTR_STATUS_MASK     (0x300)

/* Helper function to config the interrupt mask */
STATIC int
soc_gh2_cmic_interrupt_mask(int unit, int intr_type, int enable)
{
    uint32 mask3, mask4;
    int rv = SOC_E_NONE;

    mask3 = 0;
    mask4 = 0;
    switch (intr_type) {
        case GH2_INTR_PARITY:
            mask3 = GH2_IRQ3_INTR_MASK_PARITY;
            break;
        case GH2_INTR_L2_OVERFLOW:
            mask3 = GH2_IRQ3_INTR_MASK_L2_OVERFLOW;
            break;
        case GH2_INTR_OAM:
            mask3 = GH2_IRQ3_INTR_MASK_OAM;
            break;
        case GH2_INTR_TAS:
            mask3 = GH2_IRQ3_INTR_MASK_TAS;
            break;
        case GH2_INTR_SR:
            mask3 = GH2_IRQ3_INTR_MASK_SR;
            mask4 = GH2_IRQ4_INTR_MASK_SR;
            break;
        case GH2_INTR_TAF:
            mask4 = GH2_IRQ4_INTR_MASK_TAF;
            break;
        default :
            return SOC_E_PARAM;
    }

    if (enable) {
        if (mask3) {
            SOC_IF_ERROR_RETURN(soc_cmicm_intr3_enable(unit, mask3));
        }
        if (mask4) {
            SOC_IF_ERROR_RETURN(soc_cmicm_intr4_enable(unit, mask4));
        }
    } else {
        /*
         * Each bit in IRQ3 might be shared with multiple types
         * Remove bits from disable mask if it is required for
         * the valid/working types.
         */
        if (SOC_CONTROL(unit)->l2_overflow_enable) {
            /* remove l2 mask */
            mask3 &= ~GH2_IRQ3_INTR_MASK_L2_OVERFLOW;
        }
        if (gh2_intr_sr_h[unit]) {
            /* remove sr mask */
            mask3 &= ~GH2_IRQ3_INTR_MASK_SR;
        }
        if (gh2_intr_tas_h[unit]) {
            /* remove tas mask */
            mask3 &= ~GH2_IRQ3_INTR_MASK_TAS;
        }
        if (gh2_oam_handler[unit]) {
            /* remove oam mask */
            mask3 &= ~GH2_IRQ3_INTR_MASK_OAM;
        }
        if (gh2_ser_functions[unit]._soc_ser_parity_error_cmicm_intr_f) {
            /* remove ser mask */
            mask3 &= ~GH2_IRQ3_INTR_MASK_PARITY;
        }
        if (gh2_intr_taf_h[unit]) {
            /* remove taf mask */
            mask4 &= ~GH2_IRQ4_INTR_MASK_TAF;
        }

        if (mask3) {
            SOC_IF_ERROR_RETURN(soc_cmicm_intr3_disable(unit, mask3));
        }
        if (mask4) {
            SOC_IF_ERROR_RETURN(soc_cmicm_intr4_disable(unit, mask4));
        }
    }
    return rv;
}

/* SER */
void
soc_gh2_ser_cmic_interrupt_enable(int unit, int enable)
{
    (void)soc_gh2_cmic_interrupt_mask(unit, GH2_INTR_PARITY, enable);
}

/* OAM SER */
void
soc_gh2_oam_ser_handler_register(int unit, soc_gh2_oam_ser_handler_t handler)
{
    gh2_oam_ser_handler[unit] = handler;
}

int
soc_gh2_oam_ser_process(int unit, soc_mem_t mem, int index)
{
    if (gh2_oam_ser_handler[unit]) {
        return gh2_oam_ser_handler[unit](unit, mem, index);
    } else {
        return SOC_E_UNAVAIL;
    }
}

/* OAM event */
void
soc_gh2_oam_handler_register(int unit, soc_gh2_oam_handler_t handler)
{
    uint64 rval;
    int rv, id = 0;
    uint32 enable = 0;

    gh2_oam_handler[unit] = handler;

    if (handler != NULL) {
        enable = 1;
    }
    rv = READ_IP2_INTR_ENABLEr(unit, &rval);
    if (rv) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d: Error reading %s reg !!\n"),
                   unit, SOC_REG_NAME(unit, IP2_INTR_ENABLEr)));
    }
    while (_soc_gh2_oam_interrupt_fields[id] != INVALIDf) {
        soc_reg64_field32_set(unit, IP2_INTR_ENABLEr, &rval,
                              _soc_gh2_oam_interrupt_fields[id], enable);
        id++;
    }
    rv = WRITE_IP2_INTR_ENABLEr(unit, rval);
    if (rv) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d: Error writing %s reg !!\n"),
                   unit, SOC_REG_NAME(unit, IP1_INTR_ENABLEr)));
    }

    (void)soc_gh2_cmic_interrupt_mask(unit, GH2_INTR_OAM, enable);
}

STATIC int
_soc_gh2_process_oam_interrupt(int unit)
{
    uint64 rval;
    int id = 0;
    soc_gh2_oam_handler_t oam_handler_snapshot = gh2_oam_handler[unit];

    SOC_IF_ERROR_RETURN(READ_IP2_INTR_STATUSr(unit, &rval));

    while (_soc_gh2_oam_interrupt_fields[id] != INVALIDf) {
        if (soc_reg64_field32_get(unit, IP2_INTR_STATUSr, rval,
                                  _soc_gh2_oam_interrupt_fields[id])) {
            if (oam_handler_snapshot != NULL) {
                (void)(oam_handler_snapshot(unit,
                                            _soc_gh2_oam_interrupt_fields[id]));
            }
        }
        id++;
    }

    return SOC_E_NONE;
}

/* TAS interrupt/evnet */
int
soc_gh2_cosq_event_handler_register(
    int unit,
    soc_gh2_cosq_event_handler_t handler)
{
    int rv = SOC_E_NONE;

    gh2_intr_tas_h[unit] = handler;

    if (handler != NULL) {
        rv = soc_gh2_cmic_interrupt_mask(unit, GH2_INTR_TAS, 1);
    } else {
        rv = soc_gh2_cmic_interrupt_mask(unit, GH2_INTR_TAS, 0);
    }
    if (SOC_FAILURE(rv)) {
        gh2_intr_tas_h[unit] = NULL;
    }
    return rv;
}

STATIC void
soc_gh2_process_tas_intr(int unit)
{
    uint32 rval;

    rval = 0;
    /* check if this belong to interested TAS interrupt */
    if (SOC_FAILURE(READ_MEMFAILINTSTATUSr(unit, &rval))) {
        return;
    }

    if (rval & GH2_TAS_INTR_STATUS_MASK) {
        if (gh2_intr_tas_h[unit] != NULL) {
            gh2_intr_tas_h[unit](unit);
        }
    }
    return;
}

/* TAF interrupt/evnet */
int
soc_gh2_taf_event_handler_register(
    int unit,
    soc_gh2_taf_event_handler_t handler)
{
    int rv = SOC_E_NONE;

    gh2_intr_taf_h[unit] = handler;

    if (handler != NULL) {
        rv = soc_gh2_cmic_interrupt_mask(unit, GH2_INTR_TAF, 1);
    } else {
        rv = soc_gh2_cmic_interrupt_mask(unit, GH2_INTR_TAF, 0);
    }
    if (SOC_FAILURE(rv)) {
        gh2_intr_taf_h[unit] = NULL;
    }
    return rv;
}

STATIC void
soc_gh2_process_taf_intr(int unit)
{
    uint32 rval;

    rval = 0;
    /* check if this belong to interested TAS interrupt */
    if (SOC_FAILURE(READ_TAF_MEMFAILINTSTATUSr(unit, &rval))) {
        return;
    }

    if (rval & GH2_TAF_INTR_STATUS_MASK) {
        if (gh2_intr_taf_h[unit] != NULL) {
            gh2_intr_taf_h[unit](unit
                );
        }
    }
    return;
}


/* TSN/SR interrupt/event */
int
soc_gh2_tsn_event_handler_register(
    int unit,
    soc_gh2_tsn_event_handler_t handler)
{
    int rv;

    gh2_intr_sr_h[unit] = handler;

    if (handler != NULL) {
        rv = soc_gh2_cmic_interrupt_mask(unit, GH2_INTR_SR, 1);
    } else {
        rv = soc_gh2_cmic_interrupt_mask(unit, GH2_INTR_SR, 0);
    }
    if (SOC_FAILURE(rv)) {
        gh2_intr_sr_h[unit] = NULL;
    }
    return rv;
}

STATIC int
soc_gh2_process_sr_intr(int unit, int type)
{
    uint64  rval64;
    uint32  rval32;
    uint8   lan_err = 0, ip_cnt_err = 0, ep_cnt_err = 0;
    uint16 dev_id;
    uint8  rev_id;

    soc_cm_get_id(unit, &dev_id, &rev_id);

    if (type == GH2_CMIC_IRQ3) {
        SOC_IF_ERROR_RETURN(READ_IP2_INTR_STATUSr(unit, &rval64));
        if (COMPILER_64_HI(rval64) & GH2_IP2_SR_LAN_INTR_STATUS_HI_MASK) {
            lan_err = 1;
        }
        SOC_IF_ERROR_RETURN(READ_EGR_MISC_INTR_STATUSr(unit, &rval32));
        if (rval32) {
            ep_cnt_err = 1;
        }
    }
    if (type == GH2_CMIC_IRQ4) {
        if (rev_id == BCM56170_B0_REV_ID) {
            SOC_IF_ERROR_RETURN(READ_IP2_SR_TH_INTR_STATUSr(unit, &rval64));
            if (COMPILER_64_HI(rval64) || COMPILER_64_LO(rval64)) {
                ip_cnt_err = 1;
            }
        } else {
            SOC_IF_ERROR_RETURN(
                READ_IP2_SR_TH_INTR_STATUSr_REG32(unit, &rval32));
            if (rval32) {
                ip_cnt_err = 1;
            }
        }
    }

    if (lan_err || ep_cnt_err || ip_cnt_err) {
        if (gh2_intr_sr_h[unit] != NULL) {
            gh2_intr_sr_h[unit](unit, lan_err, ip_cnt_err, ep_cnt_err);
        }
    }
    return SOC_E_NONE;
}

STATIC void
soc_gh2_process_l2_intr(int unit)
{
    uint32 rval;

    if (SOC_FAILURE(READ_IP1_INTR_STATUSr(unit, &rval))) {
        return;
    }

    if (rval & GH2_IP1_L2_INTR_STATUS_MASK) {
        (void)_soc_hr3_process_l2_overflow(unit);
    }
    return;
}

/* Registered interrupt handler */
STATIC void
soc_gh2_intr_handler(void *unit_vp, void *d1, void *d2, void *d3, void *d4)
{
    int unit = PTR_TO_INT(unit_vp);
    int type = PTR_TO_INT(d3);
    int val = PTR_TO_INT(d4);
    uint32 mask = GH2_IRQ_MASK(val);

    if (type == GH2_CMIC_IRQ4) {
        if (mask & GH2_IRQ4_INTR_MASK_SR) {
            soc_gh2_process_sr_intr(unit, type);
        }
        if (mask & GH2_IRQ4_INTR_MASK_TAF) {
            soc_gh2_process_taf_intr(unit);
        }
        (void)soc_cmicm_intr4_enable(unit, PTR_TO_INT(d2));
    } else if (type == GH2_CMIC_IRQ3) {
        if (mask & GH2_IRQ3_INTR_MASK_TAS) {
            soc_gh2_process_tas_intr(unit);
        }
        if (mask & GH2_IRQ3_INTR_MASK_SR) {
            soc_gh2_process_sr_intr(unit, type);
        }
        if (mask & GH2_IRQ3_INTR_MASK_L2_OVERFLOW) {
            soc_gh2_process_l2_intr(unit);
        }
        if (mask & GH2_IRQ3_INTR_MASK_OAM) {
            (void)_soc_gh2_process_oam_interrupt(unit);
        }
        /* process parity */
        if (mask & GH2_IRQ3_INTR_MASK_PARITY) {
            (void)soc_gh2_ser_process_all(unit, mask);
            sal_usleep(SAL_BOOT_QUICKTURN ? 1000000 : 10000);
        }

        (void)soc_cmicm_intr3_enable(unit, PTR_TO_INT(d2));
    }
    return;
}

/* Interrupt initialization function */
STATIC void
soc_gh2_interrupt_init(int unit)
{
    int u;

    /* Initialize event handlers */
    if (!gh2_event_handler_init) {
        for (u = 0; u < SOC_MAX_NUM_DEVICES; u++) {
            gh2_oam_ser_handler[u] = NULL;
            gh2_oam_handler[u] = NULL;
            gh2_intr_sr_h[u] = NULL;
            gh2_intr_tas_h[u] = NULL;
            gh2_intr_taf_h[u] = NULL;
        }
        gh2_event_handler_init = 1;
    }

    /* register the SER callback function sets */
    memset(&gh2_ser_functions[unit], 0, sizeof(soc_ser_functions_t));
    gh2_ser_functions[unit]._soc_ser_fail_f = &soc_gh2_ser_fail;
    gh2_ser_functions[unit]._soc_ser_parity_error_cmicm_intr_f =
        &soc_gh2_intr_handler;
    soc_ser_function_register(unit, &gh2_ser_functions[unit]);
}

/* End of Interrupt handler functions */

#ifdef BCM_WARM_BOOT_SUPPORT
STATIC int
soc_gh2_port_init_speed_scache_allocate(int unit)
{
    int     rv;
    uint8   *scache_ptr;
    soc_scache_handle_t scache_handle;
    uint32  alloc_get = 0;
    uint32  alloc_size = 0;

    alloc_size = sizeof(int) * SOC_MAX_PHY_PORTS;
    SOC_SCACHE_HANDLE_SET(scache_handle, unit, SOC_SCACHE_FLEXIO_HANDLE, 0);
    rv = soc_scache_alloc(unit, scache_handle, alloc_size);
    if (rv == SOC_E_CONFIG) {
        /* Probably Level1 */
        return SOC_E_NONE;
    }
    /* NotRequired but just to confirm Get the pointer for the Level 2 cache */
    SOC_IF_ERROR_RETURN(
        soc_scache_ptr_get(unit, scache_handle, &scache_ptr, &alloc_get));

    if (alloc_get != alloc_size) {
        /* Expected size doesn't match retrieved size */
        return SOC_E_INTERNAL;
    }
    if (NULL == scache_ptr) {
        return SOC_E_MEMORY;
    }

    return SOC_E_NONE;
}

int
soc_gh2_port_init_speed_scache_sync(int unit)
{
    int                 rv, phy_port;
    uint8               *scache_ptr;
    soc_scache_handle_t scache_handle;
    uint32              alloc_get = 0, alloc_size = 0, scache_offset = 0;

    SOC_SCACHE_HANDLE_SET(scache_handle, unit, SOC_SCACHE_FLEXIO_HANDLE, 0);
    /* NotRequired but just to confirm Get the pointer for the Level 2 cache */
    rv = soc_scache_ptr_get(unit, scache_handle,
                            &scache_ptr, &alloc_get);
    if (rv == SOC_E_NOT_FOUND) {
        /* Probably Level1 */
        return SOC_E_NONE;
    }
    alloc_size = sizeof(int) * SOC_MAX_PHY_PORTS;
    if (alloc_get != alloc_size) {
        /* Expected size doesn't match retrieved size */
        return SOC_E_INTERNAL;
    }
    if (NULL == scache_ptr) {
        return SOC_E_MEMORY;
    }

    for (phy_port = 0; phy_port < SOC_MAX_PHY_PORTS; phy_port++) {
        sal_memcpy(&scache_ptr[scache_offset],
                   &gh2_port_speed[phy_port],
                   sizeof(int));
        scache_offset += sizeof(int);
    }
    return SOC_E_NONE;
}

STATIC int
soc_gh2_port_init_speed_scache_recovery(int unit)
{
    int                 rv, phy_port;
    uint8               *scache_ptr;
    soc_scache_handle_t scache_handle;
    uint32              alloc_get = 0, alloc_size = 0, scache_offset = 0;

    SOC_SCACHE_HANDLE_SET(scache_handle, unit, SOC_SCACHE_FLEXIO_HANDLE, 0);
    /* NotRequired but just to confirm Get the pointer for the Level 2 cache */
    rv = soc_scache_ptr_get(unit, scache_handle,
                            &scache_ptr, &alloc_get);
    if (rv == SOC_E_NOT_FOUND) {
        /* Probably Level1 */
        return SOC_E_NONE;
    }
    alloc_size = sizeof(int) * SOC_MAX_PHY_PORTS;
    if (alloc_get != alloc_size) {
        /* Expected size doesn't match retrieved size */
        return SOC_E_INTERNAL;
    }
    if (NULL == scache_ptr) {
        return SOC_E_MEMORY;
    }
    for (phy_port = 0; phy_port < SOC_MAX_PHY_PORTS; phy_port++) {
        sal_memcpy(&gh2_port_speed[phy_port],
                   &scache_ptr[scache_offset],
                   sizeof(int));
        scache_offset += sizeof(int);
    }
    return SOC_E_NONE;
}
#endif /* BCM_WARM_BOOT_SUPPORT */

#define gh2_get_pval(_map_, _idx_, _max_num_) \
    ((_idx_ < _max_num_) ? _map_[_idx_]: 0)

#define GH2_PGW_COUNT_GE8P       (3)
#define GH2_PORTS_PER_PGW_GE8P   (8)
#define GH2_FIRST_PORT_PGW_GE8P0 (2)
#define GH2_PGW_COUNT_GE         (2)
#define GH2_PORTS_PER_PGW_GE     (16)
#define GH2_FIRST_PORT_PGW_GE0   (26)
#define GH2_PGW_COUNT_XL         (7)
#define GH2_PORTS_PER_PGW_XL     (4)
#define GH2_FIRST_PORT_PGW_XL0   (2)
#define GH2_PGW_COUNT_CL         (1)
#define GH2_PORTS_PER_PGW_CL     (4)
#define GH2_FIRST_PORT_PGW_CL0   (30)

STATIC int
soc_greyhound2_ledup_init(int unit)
{
    int i, j, pval0, pval1, pval2, pval3, port_idx;
    uint32 led_remap0[64] = {0}, led_remap1[64] = {0};
    uint32 port_cnt = 0, port0_cnt = 0, port1_cnt = 0;
    uint32 rval = 0, rval1 = 0;
    uint32 disable_4x10 = 0, disable_4x25 = 0;
    int phy_p;

    struct led_remap_t {
       uint32 reg_addr;
       uint32 port0;
       uint32 port1;
       uint32 port2;
       uint32 port3;
    };
    struct led_remap_t ledup0_remap_r[] = {
        {CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r,
         REMAP_PORT_0f, REMAP_PORT_1f, REMAP_PORT_2f, REMAP_PORT_3f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_4_7r,
         REMAP_PORT_4f, REMAP_PORT_5f, REMAP_PORT_6f, REMAP_PORT_7f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_8_11r,
         REMAP_PORT_8f, REMAP_PORT_9f, REMAP_PORT_10f, REMAP_PORT_11f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_12_15r,
         REMAP_PORT_12f, REMAP_PORT_13f, REMAP_PORT_14f, REMAP_PORT_15f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_16_19r,
         REMAP_PORT_16f, REMAP_PORT_17f, REMAP_PORT_18f, REMAP_PORT_19f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_20_23r,
         REMAP_PORT_20f, REMAP_PORT_21f, REMAP_PORT_22f, REMAP_PORT_23f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_24_27r,
         REMAP_PORT_24f, REMAP_PORT_25f, REMAP_PORT_26f, REMAP_PORT_27f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_28_31r,
         REMAP_PORT_28f, REMAP_PORT_29f, REMAP_PORT_30f, REMAP_PORT_31f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_32_35r,
         REMAP_PORT_32f, REMAP_PORT_33f, REMAP_PORT_34f, REMAP_PORT_35f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_36_39r,
         REMAP_PORT_36f, REMAP_PORT_37f, REMAP_PORT_38f, REMAP_PORT_39f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_40_43r,
         REMAP_PORT_40f, REMAP_PORT_41f, REMAP_PORT_42f, REMAP_PORT_43f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_44_47r,
         REMAP_PORT_44f, REMAP_PORT_45f, REMAP_PORT_46f, REMAP_PORT_47f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_48_51r,
         REMAP_PORT_48f, REMAP_PORT_49f, REMAP_PORT_50f, REMAP_PORT_51f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_52_55r,
         REMAP_PORT_52f, REMAP_PORT_53f, REMAP_PORT_54f, REMAP_PORT_55f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_56_59r,
         REMAP_PORT_56f, REMAP_PORT_57f, REMAP_PORT_58f, REMAP_PORT_59f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r,
         REMAP_PORT_60f, REMAP_PORT_61f, REMAP_PORT_62f, REMAP_PORT_63f}
    };

    /* Greyhound2 has 2 LED chan for storing port number that is greater than 63 */
    struct led_remap_t ledup1_remap_r[] = {
        {CMIC_LEDUP1_PORT_ORDER_REMAP_0_3r,
         REMAP_PORT_0f, REMAP_PORT_1f, REMAP_PORT_2f, REMAP_PORT_3f},
        {CMIC_LEDUP1_PORT_ORDER_REMAP_4_7r,
         REMAP_PORT_4f, REMAP_PORT_5f, REMAP_PORT_6f, REMAP_PORT_7f},
        {CMIC_LEDUP1_PORT_ORDER_REMAP_8_11r,
         REMAP_PORT_8f, REMAP_PORT_9f, REMAP_PORT_10f, REMAP_PORT_11f},
        {CMIC_LEDUP1_PORT_ORDER_REMAP_12_15r,
         REMAP_PORT_12f, REMAP_PORT_13f, REMAP_PORT_14f, REMAP_PORT_15f},
        {CMIC_LEDUP1_PORT_ORDER_REMAP_16_19r,
         REMAP_PORT_16f, REMAP_PORT_17f, REMAP_PORT_18f, REMAP_PORT_19f},
        {CMIC_LEDUP1_PORT_ORDER_REMAP_20_23r,
         REMAP_PORT_20f, REMAP_PORT_21f, REMAP_PORT_22f, REMAP_PORT_23f},
        {CMIC_LEDUP1_PORT_ORDER_REMAP_24_27r,
         REMAP_PORT_24f, REMAP_PORT_25f, REMAP_PORT_26f, REMAP_PORT_27f},
        {CMIC_LEDUP1_PORT_ORDER_REMAP_28_31r,
         REMAP_PORT_28f, REMAP_PORT_29f, REMAP_PORT_30f, REMAP_PORT_31f},
        {CMIC_LEDUP1_PORT_ORDER_REMAP_32_35r,
         REMAP_PORT_32f, REMAP_PORT_33f, REMAP_PORT_34f, REMAP_PORT_35f},
        {CMIC_LEDUP1_PORT_ORDER_REMAP_36_39r,
         REMAP_PORT_36f, REMAP_PORT_37f, REMAP_PORT_38f, REMAP_PORT_39f},
        {CMIC_LEDUP1_PORT_ORDER_REMAP_40_43r,
         REMAP_PORT_40f, REMAP_PORT_41f, REMAP_PORT_42f, REMAP_PORT_43f},
        {CMIC_LEDUP1_PORT_ORDER_REMAP_44_47r,
         REMAP_PORT_44f, REMAP_PORT_45f, REMAP_PORT_46f, REMAP_PORT_47f},
        {CMIC_LEDUP1_PORT_ORDER_REMAP_48_51r,
         REMAP_PORT_48f, REMAP_PORT_49f, REMAP_PORT_50f, REMAP_PORT_51f},
        {CMIC_LEDUP1_PORT_ORDER_REMAP_52_55r,
         REMAP_PORT_52f, REMAP_PORT_53f, REMAP_PORT_54f, REMAP_PORT_55f},
        {CMIC_LEDUP1_PORT_ORDER_REMAP_56_59r,
         REMAP_PORT_56f, REMAP_PORT_57f, REMAP_PORT_58f, REMAP_PORT_59f},
        {CMIC_LEDUP1_PORT_ORDER_REMAP_60_63r,
         REMAP_PORT_60f, REMAP_PORT_61f, REMAP_PORT_62f, REMAP_PORT_63f}
    };
    /* The LED scanning out order is
     *  LED Chan1 (physical port view):
     *  PGW_CL0(89->86) -> PGW_XL6(85->82) ->...-> PGW_XL0(61->58)
     *  Remap to schan 1 (remap, -56 view)
     *  PGW_CL0(33->30) -> PGW_XL6(29->26) ->...-> PGW_XL0(5->2)
     *  LED Chan0:
     *  PGW_GE1(42->57) -> PGW_GE0(26->41)-> PGW_GE8P2(18->25)->
     *  PGW_GE8P1(10->17)-> PGW_GE8P0(2->9)
     *  If PM4x25 is ON, PGW_CL will output 4 bytes LED status to the LED chain.
     *  If PM4x25 is OFF, PGW_CL will output 1 byte to the LED chain.
     *  If PM4x10 is ON, PGW_XL will output 4 bytes LED status to the LED chain.
     *  If PM4x10 is OFF, PGW_XL will output 1 byte to the LED chain.
     *  PGW_GE will always output 16 bytes LED status to the LED chain.
     *  PGW_GE8P will always output 8 bytes LED status to the LED chain.
     */

    SOC_IF_ERROR_RETURN(READ_PGW_CTRL_0r(unit, &rval));
    disable_4x10 = soc_reg_field_get(unit, PGW_CTRL_0r,
                                     rval, SW_PM4X10_DISABLEf);
    disable_4x25 = soc_reg_field_get(unit, PGW_CTRL_0r,
                                     rval, SW_PM4X25_DISABLEf);
    /* LED Chan1 */
    /* PGW_CL0 */
    for (i = GH2_PGW_COUNT_CL - 1; i >= 0; i--) {
        if (disable_4x25 & (1 << i)) {
            /* For PGW_CL, shift out 1 byte if PM4x25 is disabled */
            led_remap1[port1_cnt++] = 0;
            port_cnt++;
        } else {
            /* For PGW_CL, port 3 is shifted out first and port 0 is the last */
            for (j = GH2_PORTS_PER_PGW_CL - 1; j >= 0; j--) {
                led_remap1[port1_cnt++] =
                    GH2_FIRST_PORT_PGW_CL0 + GH2_PORTS_PER_PGW_CL * i + j;
                port_cnt++;
            }
        }
    }

    /* PGW_XL6 -> PGW_XL0 */
    for (i = GH2_PGW_COUNT_XL - 1; i >= 0; i--) {
        if (disable_4x10 & (1 << i)) {
            /* For PGW_XL, shift out 1 byte if PM4x10 is disabled */
            led_remap1[port1_cnt++] = 0;
            port_cnt++;
        } else {
            /* For PGW_XL, port 3 is shifted out first and port 0 is the last */
            for (j = GH2_PORTS_PER_PGW_XL - 1; j >= 0; j--) {
                led_remap1[port1_cnt++] =
                    GH2_FIRST_PORT_PGW_XL0 + GH2_PORTS_PER_PGW_XL * i + j;
                port_cnt++;
            }
        }
    }

    /* LED Chan0 */
    /* PGW_GE1 -> PGW_GE0 */
    for (i = GH2_PGW_COUNT_GE - 1; i >= 0; i--) {
        /* For PGW_GE, port 0 is shifted out first and port 15 is the last */
        for (j = 0; j < GH2_PORTS_PER_PGW_GE; j++) {
            phy_p = GH2_FIRST_PORT_PGW_GE0 + GH2_PORTS_PER_PGW_GE * i + j;
            if (SOC_INFO(unit).port_p2l_mapping[phy_p] != -1) {
                led_remap0[port0_cnt++] =
                    GH2_FIRST_PORT_PGW_GE0 + GH2_PORTS_PER_PGW_GE * i + j;
            } else {
                led_remap0[port0_cnt++] = 0;
            }
            port_cnt++;
        }
    }

    /* PGW_GE8P2 -> PGW_GE8P0 */
    for (i = GH2_PGW_COUNT_GE8P - 1; i >= 0; i--) {
        /* For PGW_GE8P, port 0 is shifted out first and port 7 is the last */
        for (j = 0; j < GH2_PORTS_PER_PGW_GE8P; j++) {
            led_remap0[port0_cnt++] =
                GH2_FIRST_PORT_PGW_GE8P0 + GH2_PORTS_PER_PGW_GE8P * i + j;
            port_cnt++;
        }
    }

    /* Setup CMIC_LEDUP0/1_PORT_ORDER_REMAP registers */
    for (i = 0; i < sizeof(ledup0_remap_r) / sizeof(ledup0_remap_r[0]); i++) {
        port_idx = i * 4;
        pval0 = gh2_get_pval(led_remap0, port_idx, port_cnt);
        pval1 = gh2_get_pval(led_remap0, port_idx + 1, port_cnt);
        pval2 = gh2_get_pval(led_remap0, port_idx + 2, port_cnt);
        pval3 = gh2_get_pval(led_remap0, port_idx + 3, port_cnt);

        rval = 0;
        soc_reg_field_set(unit, ledup0_remap_r[i].reg_addr, &rval,
                          ledup0_remap_r[i].port0, pval0);
        soc_reg_field_set(unit, ledup0_remap_r[i].reg_addr, &rval,
                          ledup0_remap_r[i].port1, pval1);
        soc_reg_field_set(unit, ledup0_remap_r[i].reg_addr, &rval,
                          ledup0_remap_r[i].port2, pval2);
        soc_reg_field_set(unit, ledup0_remap_r[i].reg_addr, &rval,
                          ledup0_remap_r[i].port3, pval3);

        /* coverity[result_independent_of_operands] */
        SOC_IF_ERROR_RETURN
            (soc_pci_write(unit,
                soc_reg_addr(unit, ledup0_remap_r[i].reg_addr, REG_PORT_ANY, 0),
                rval));
    }

    for (i = 0; i < sizeof(ledup1_remap_r) / sizeof(ledup1_remap_r[0]); i++) {
        port_idx = i * 4;
        pval0 = gh2_get_pval(led_remap1, port_idx, port_cnt);
        pval1 = gh2_get_pval(led_remap1, port_idx + 1, port_cnt);
        pval2 = gh2_get_pval(led_remap1, port_idx + 2, port_cnt);
        pval3 = gh2_get_pval(led_remap1, port_idx + 3, port_cnt);

        rval = 0;
        soc_reg_field_set(unit, ledup1_remap_r[i].reg_addr, &rval1,
                          ledup1_remap_r[i].port0, pval0);
        soc_reg_field_set(unit, ledup1_remap_r[i].reg_addr, &rval1,
                          ledup1_remap_r[i].port1, pval1);
        soc_reg_field_set(unit, ledup1_remap_r[i].reg_addr, &rval1,
                          ledup1_remap_r[i].port2, pval2);
        soc_reg_field_set(unit, ledup1_remap_r[i].reg_addr, &rval1,
                          ledup1_remap_r[i].port3, pval3);

        /* coverity[result_independent_of_operands] */
        SOC_IF_ERROR_RETURN
            (soc_pci_write(unit,
                           soc_reg_addr(unit, ledup1_remap_r[i].reg_addr,
                                        REG_PORT_ANY, 0), rval1));
    }

    /* Initialize the LEDuP0/LEDuP1 data ram */
    rval = 0;
    for (i = 0; i < 256; i++) {
        /* coverity[result_independent_of_operands] */
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_DATA_RAMr(unit, i, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_DATA_RAMr(unit, i, rval1));
    }

    return SOC_E_NONE;
}

#define GH2R_PGW_COUNT_GE         (2)
#define GH2R_PORTS_PER_PGW_GE     (16)
#define GH2R_FIRST_PORT_PGW_GE0   (26)
#define GH2R_FIRST_PORT_PGW_GE1   (42)
#define GH2R_PGW_COUNT_XL         (2)
#define GH2R_PORTS_PER_PGW_XL     (4)
#define GH2R_FIRST_PORT_PGW_XL4   (18)
#define GH2R_FIRST_PORT_PGW_XL5   (22)
#define GH2R_FIRST_PORT_PGW_XL6   (26)
#define GH2R_PGW_COUNT_CL         (1)
#define GH2R_PORTS_PER_PGW_CL     (4)
#define GH2R_FIRST_PORT_PGW_CL0   (30)

STATIC int
soc_greyhound2_ledupr_init(int unit)
{
    int i, j, pval0, pval1, pval2, pval3, port_idx;
    uint32 led_remap0[64] = {0}, led_remap1[64] = {0};
    uint32 port_cnt0 = 0,port_cnt1 = 0, rval = 0, rval1 = 0;
    int phy_p;

    struct led_remap_t {
       uint32 reg_addr;
       uint32 port0;
       uint32 port1;
       uint32 port2;
       uint32 port3;
    };
    struct led_remap_t ledup0_remap_r[] = {
        {CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r,
         REMAP_PORT_0f, REMAP_PORT_1f, REMAP_PORT_2f, REMAP_PORT_3f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_4_7r,
         REMAP_PORT_4f, REMAP_PORT_5f, REMAP_PORT_6f, REMAP_PORT_7f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_8_11r,
         REMAP_PORT_8f, REMAP_PORT_9f, REMAP_PORT_10f, REMAP_PORT_11f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_12_15r,
         REMAP_PORT_12f, REMAP_PORT_13f, REMAP_PORT_14f, REMAP_PORT_15f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_16_19r,
         REMAP_PORT_16f, REMAP_PORT_17f, REMAP_PORT_18f, REMAP_PORT_19f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_20_23r,
         REMAP_PORT_20f, REMAP_PORT_21f, REMAP_PORT_22f, REMAP_PORT_23f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_24_27r,
         REMAP_PORT_24f, REMAP_PORT_25f, REMAP_PORT_26f, REMAP_PORT_27f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_28_31r,
         REMAP_PORT_28f, REMAP_PORT_29f, REMAP_PORT_30f, REMAP_PORT_31f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_32_35r,
         REMAP_PORT_32f, REMAP_PORT_33f, REMAP_PORT_34f, REMAP_PORT_35f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_36_39r,
         REMAP_PORT_36f, REMAP_PORT_37f, REMAP_PORT_38f, REMAP_PORT_39f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_40_43r,
         REMAP_PORT_40f, REMAP_PORT_41f, REMAP_PORT_42f, REMAP_PORT_43f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_44_47r,
         REMAP_PORT_44f, REMAP_PORT_45f, REMAP_PORT_46f, REMAP_PORT_47f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_48_51r,
         REMAP_PORT_48f, REMAP_PORT_49f, REMAP_PORT_50f, REMAP_PORT_51f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_52_55r,
         REMAP_PORT_52f, REMAP_PORT_53f, REMAP_PORT_54f, REMAP_PORT_55f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_56_59r,
         REMAP_PORT_56f, REMAP_PORT_57f, REMAP_PORT_58f, REMAP_PORT_59f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r,
         REMAP_PORT_60f, REMAP_PORT_61f, REMAP_PORT_62f, REMAP_PORT_63f}
    };

    /* Greyhound2 has 2 LED chan for storing port number that is greater than 63 */
    struct led_remap_t ledup1_remap_r[] = {
        {CMIC_LEDUP1_PORT_ORDER_REMAP_0_3r,
         REMAP_PORT_0f, REMAP_PORT_1f, REMAP_PORT_2f, REMAP_PORT_3f},
        {CMIC_LEDUP1_PORT_ORDER_REMAP_4_7r,
         REMAP_PORT_4f, REMAP_PORT_5f, REMAP_PORT_6f, REMAP_PORT_7f},
        {CMIC_LEDUP1_PORT_ORDER_REMAP_8_11r,
         REMAP_PORT_8f, REMAP_PORT_9f, REMAP_PORT_10f, REMAP_PORT_11f},
        {CMIC_LEDUP1_PORT_ORDER_REMAP_12_15r,
         REMAP_PORT_12f, REMAP_PORT_13f, REMAP_PORT_14f, REMAP_PORT_15f},
        {CMIC_LEDUP1_PORT_ORDER_REMAP_16_19r,
         REMAP_PORT_16f, REMAP_PORT_17f, REMAP_PORT_18f, REMAP_PORT_19f},
        {CMIC_LEDUP1_PORT_ORDER_REMAP_20_23r,
         REMAP_PORT_20f, REMAP_PORT_21f, REMAP_PORT_22f, REMAP_PORT_23f},
        {CMIC_LEDUP1_PORT_ORDER_REMAP_24_27r,
         REMAP_PORT_24f, REMAP_PORT_25f, REMAP_PORT_26f, REMAP_PORT_27f},
        {CMIC_LEDUP1_PORT_ORDER_REMAP_28_31r,
         REMAP_PORT_28f, REMAP_PORT_29f, REMAP_PORT_30f, REMAP_PORT_31f},
        {CMIC_LEDUP1_PORT_ORDER_REMAP_32_35r,
         REMAP_PORT_32f, REMAP_PORT_33f, REMAP_PORT_34f, REMAP_PORT_35f},
        {CMIC_LEDUP1_PORT_ORDER_REMAP_36_39r,
         REMAP_PORT_36f, REMAP_PORT_37f, REMAP_PORT_38f, REMAP_PORT_39f},
        {CMIC_LEDUP1_PORT_ORDER_REMAP_40_43r,
         REMAP_PORT_40f, REMAP_PORT_41f, REMAP_PORT_42f, REMAP_PORT_43f},
        {CMIC_LEDUP1_PORT_ORDER_REMAP_44_47r,
         REMAP_PORT_44f, REMAP_PORT_45f, REMAP_PORT_46f, REMAP_PORT_47f},
        {CMIC_LEDUP1_PORT_ORDER_REMAP_48_51r,
         REMAP_PORT_48f, REMAP_PORT_49f, REMAP_PORT_50f, REMAP_PORT_51f},
        {CMIC_LEDUP1_PORT_ORDER_REMAP_52_55r,
         REMAP_PORT_52f, REMAP_PORT_53f, REMAP_PORT_54f, REMAP_PORT_55f},
        {CMIC_LEDUP1_PORT_ORDER_REMAP_56_59r,
         REMAP_PORT_56f, REMAP_PORT_57f, REMAP_PORT_58f, REMAP_PORT_59f},
        {CMIC_LEDUP1_PORT_ORDER_REMAP_60_63r,
         REMAP_PORT_60f, REMAP_PORT_61f, REMAP_PORT_62f, REMAP_PORT_63f}
    };
    /* The LED scanning out order is
     *  LED Chan1 (physical port view):
     *  PGW_CL0(89->86) -> PGW_XL6(85->82) -> PGW_XL5(81->78) -> PGW_XL4(77->74)
     *  Remap to schan 1 (remap, -56 view)
     *  PGW_CL0(33->30) -> PGW_XL6(29->26) -> PGW_XL5(25->22) -> PGW_XL4(21->18)
     *  LED Chan0:
     *  PGW_GE1(42->57) -> PGW_GE0(26->41)
     *  PGW_CL will output 4 bytes LED status to the LED chain.
     *  PGW_XL will output 4 bytes LED status to the LED chain.
     *  PGW_GE will always output 16 bytes LED status to the LED chain.
     *  PGW_GE8P will always output 8 bytes LED status to the LED chain.
     */


    /* LED Chan1 */
    /* PGW_CL0 */
    for (j = GH2R_PORTS_PER_PGW_CL - 1; j >= 0; j--) {
        led_remap1[port_cnt1++] = GH2R_FIRST_PORT_PGW_CL0 + j;
    }
    /* PGW_XL6 */
    for (j = GH2R_PORTS_PER_PGW_XL - 1; j >= 0; j--) {
        led_remap1[port_cnt1++] =
            GH2R_FIRST_PORT_PGW_XL6 + j;
    }
    /* PGW_XL5, LED output not used */
    for (j = GH2R_PORTS_PER_PGW_XL - 1; j >= 0; j--) {
        led_remap1[port_cnt1++] =
            GH2R_FIRST_PORT_PGW_XL5 + j;
    }
    /* PGW_XL4 */
    for (j = GH2R_PORTS_PER_PGW_XL - 1; j >= 0; j--) {
        led_remap1[port_cnt1++] =
            GH2R_FIRST_PORT_PGW_XL4 + j;
    }

    /* LED Chan0 */
    /* PGW_GE1 from 42-57 */
    for (j = 0; j < GH2R_PORTS_PER_PGW_GE; j++) {
        phy_p = GH2R_FIRST_PORT_PGW_GE1 + j;
        if (SOC_INFO(unit).port_p2l_mapping[phy_p] != -1) {
            led_remap0[port_cnt0++] = GH2R_FIRST_PORT_PGW_GE1 + j;
        } else {
            led_remap0[port_cnt0++] = 0;
        }
    }
    /* PGW_GE0 from 26-41, evn though front panel only using 26-33 */
    for (j = 0; j < GH2R_PORTS_PER_PGW_GE; j++) {
        phy_p = GH2R_FIRST_PORT_PGW_GE0 + j;
        if (SOC_INFO(unit).port_p2l_mapping[phy_p] != -1) {
            led_remap0[port_cnt0++] = GH2R_FIRST_PORT_PGW_GE0 + j;
        } else {
            led_remap0[port_cnt0++] = 0;
        }
    }

    /* Setup CMIC_LEDUP0/1_PORT_ORDER_REMAP registers */
    for (i = 0; i < sizeof(ledup0_remap_r) / sizeof(ledup0_remap_r[0]); i++) {
        port_idx = i * 4;
        pval0 = led_remap0[port_idx];
        pval1 = led_remap0[port_idx + 1];
        pval2 = led_remap0[port_idx + 2];
        pval3 = led_remap0[port_idx + 3];

        rval = 0;
        soc_reg_field_set(unit, ledup0_remap_r[i].reg_addr, &rval,
                          ledup0_remap_r[i].port0, pval0);
        soc_reg_field_set(unit, ledup0_remap_r[i].reg_addr, &rval,
                          ledup0_remap_r[i].port1, pval1);
        soc_reg_field_set(unit, ledup0_remap_r[i].reg_addr, &rval,
                          ledup0_remap_r[i].port2, pval2);
        soc_reg_field_set(unit, ledup0_remap_r[i].reg_addr, &rval,
                          ledup0_remap_r[i].port3, pval3);

        /* coverity[result_independent_of_operands] */
        SOC_IF_ERROR_RETURN
            (soc_pci_write(unit,
                soc_reg_addr(unit, ledup0_remap_r[i].reg_addr, REG_PORT_ANY, 0),
                rval));
    }

    for (i = 0; i < sizeof(ledup1_remap_r) / sizeof(ledup1_remap_r[0]); i++) {
        port_idx = i * 4;
        pval0 = led_remap1[port_idx];
        pval1 = led_remap1[port_idx + 1];
        pval2 = led_remap1[port_idx + 2];
        pval3 = led_remap1[port_idx + 3];


        rval = 0;
        soc_reg_field_set(unit, ledup1_remap_r[i].reg_addr, &rval1,
                          ledup1_remap_r[i].port0, pval0);
        soc_reg_field_set(unit, ledup1_remap_r[i].reg_addr, &rval1,
                          ledup1_remap_r[i].port1, pval1);
        soc_reg_field_set(unit, ledup1_remap_r[i].reg_addr, &rval1,
                          ledup1_remap_r[i].port2, pval2);
        soc_reg_field_set(unit, ledup1_remap_r[i].reg_addr, &rval1,
                          ledup1_remap_r[i].port3, pval3);

        /* coverity[result_independent_of_operands] */
        SOC_IF_ERROR_RETURN
            (soc_pci_write(unit,
                           soc_reg_addr(unit, ledup1_remap_r[i].reg_addr,
                                        REG_PORT_ANY, 0), rval1));
    }

    /* Initialize the LEDuP0/LEDuP1 data ram */
    rval = 0;
    rval1 = 0;
    for (i = 0; i < 256; i++) {
        /* coverity[result_independent_of_operands] */
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_DATA_RAMr(unit, i, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_DATA_RAMr(unit, i, rval1));
    }

    return SOC_E_NONE;
}

int
soc_greyhound2_init_port_mapping(int unit)
{
    soc_info_t *si;
    soc_mem_t mem;
    uint32 rval;
    ing_physical_to_logical_port_number_mapping_table_entry_t entry;
    int logical_port, phy_port, mmu_port;
    int num_port, num_phy_port;
    uint32 fval[3];
    egr_tdm_port_map_entry_t egr_tdm_port_map_entry;
    int idx;
    int shift;
    int port, speed;

    si = &SOC_INFO(unit);

    /* Ingress physical to logical port mapping */
    mem = ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLEm;
    num_phy_port = soc_mem_index_count(unit, mem);
    sal_memset(&entry, 0, sizeof(entry));
    for (phy_port = 0; phy_port < num_phy_port; phy_port++) {
        logical_port = si->port_p2l_mapping[phy_port];
        soc_mem_field32_set(unit, mem, &entry, LOGICAL_PORT_NUMBERf,
                            logical_port == -1 ? 0x7f : logical_port);
        SOC_IF_ERROR_RETURN
            (soc_mem_write(unit, mem, MEM_BLOCK_ALL, phy_port, &entry));
    }
    num_port = soc_mem_index_count(unit, PORT_TABm);

    /* Egress logical to physical port mapping */
    for (logical_port = 0; logical_port < num_port; logical_port++) {
        phy_port = si->port_l2p_mapping[logical_port];
        rval = 0;
        soc_reg_field_set(unit, EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPINGr,
                          &rval, PHYSICAL_PORT_NUMBERf,
                          phy_port == -1 ? 0x7f : phy_port);
        SOC_IF_ERROR_RETURN
            (WRITE_EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPINGr(unit,
                                                                logical_port,
                                                                rval));
    }

    /* EGR_TDM_PORT_MAPm */
    sal_memset(&egr_tdm_port_map_entry, 0, sizeof(egr_tdm_port_map_entry));
    sal_memset(fval, 0, sizeof(fval));
    mem = EGR_TDM_PORT_MAPm;
    for (logical_port = 0; logical_port < num_port; logical_port++) {
        phy_port = si->port_l2p_mapping[logical_port];
        /*
            * Physical port of loopback port(1) is assigned -1.
            * The port should be programmed on physical port 1.
            */
        if (logical_port == 1) {
            phy_port = 1;
        }
        if (phy_port == -1) {
            /* skip not mapped physical port */
            continue;
        }
        idx = phy_port / 32;
        shift = phy_port - idx * 32;
        fval[idx] |= (1 << shift);
    }
    soc_mem_field_set(unit, EGR_TDM_PORT_MAPm,
        (void *)&egr_tdm_port_map_entry, BITMAPf, fval);
    SOC_IF_ERROR_RETURN
        (soc_mem_write(unit, mem, MEM_BLOCK_ALL, 0, &egr_tdm_port_map_entry));

    /* MMU to physical port mapping and MMU to logical port mapping */
    for (mmu_port = 0; mmu_port < SOC_MAX_MMU_PORTS; mmu_port++) {
        /* MMU to Physical  port */
        phy_port = si->port_m2p_mapping[mmu_port];
        /* Physical to Logical port */
        logical_port = si->port_p2l_mapping[phy_port];

        if (phy_port == 1) {
            /* skip loopback port */
            continue;
        }
        if (phy_port == -1) {
            /* skip not mapped mmu port */
            continue;
        }
        rval = 0;
        soc_reg_field_set(unit, MMU_PORT_TO_PHY_PORT_MAPPINGr, &rval,
                          PHY_PORTf, phy_port);
        SOC_IF_ERROR_RETURN
            (WRITE_MMU_PORT_TO_PHY_PORT_MAPPINGr(unit, logical_port, rval));

        if (logical_port == -1) {
            logical_port = 1;
        }
        rval = 0;
        soc_reg_field_set(unit, MMU_PORT_TO_LOGIC_PORT_MAPPINGr, &rval,
                          LOGIC_PORTf, logical_port);
        SOC_IF_ERROR_RETURN
            (WRITE_MMU_PORT_TO_LOGIC_PORT_MAPPINGr(unit, logical_port, rval));
    }
#ifdef BCM_WARM_BOOT_SUPPORT
    if (SOC_WARM_BOOT(unit)) {
        SOC_IF_ERROR_RETURN(
            soc_gh2_port_init_speed_scache_recovery(unit));
    } else {
        SOC_IF_ERROR_RETURN(
            soc_gh2_port_init_speed_scache_allocate(unit));
    }
#endif /* BCM_WARM_BOOT_SUPPORT */

    /* Initialize the si->port_init_speed */
    PBMP_ALL_ITER(unit, port) {
        /*
         * Let the port_init_speed as the max supported speed of xe
         * while the port_speed_max would be the max supported speed of hg
         */
        switch (si->port_speed_max[port]) {
            case 11000:
                speed = 10000;
                break;
            case 21000:
                speed = 20000;
                break;
            case 27000:
                speed = 25000;
                break;
            case 42000:
                speed = 40000;
                break;
            case 53000:
                speed = 50000;
                break;
            default:
                speed = si->port_speed_max[port];
                break;
        }
        si->port_init_speed[port] = speed;
        if (!SOC_WARM_BOOT(unit)) {
            gh2_port_speed[si->port_l2p_mapping[port]] = speed;
        }
    }
    return SOC_E_NONE;
}

/* Provide the max speed mapping from xe to hg */
int
soc_greyhound2_port_hg_speed_get(int unit, soc_port_t port, int *speed)
{
    soc_info_t *si;

    si = &SOC_INFO(unit);

    switch (si->port_init_speed[port]) {
        case 10000:
            *speed = 11000;
            break;
        case 20000:
            *speed = 21000;
            break;
        case 25000:
            *speed = 27000;
            break;
        case 40000:
            *speed = 42000;
            break;
        case 50000:
            *speed = 53000;
            break;
        default:
            *speed = si->port_init_speed[port];
            break;
    }

    if (*speed > si->port_speed_max[port]) {
        *speed = si->port_speed_max[port];
    }
    return SOC_E_NONE;
}

/*
 * Check if the configured port speed matched.
 *
 * return value
 *    1 : check passed
 *    0 : check failed
 */
static int
flex_lane_speed_check(int speed, int flex_mode, int lane_count)
{
    /* Check invalid lane count */
    if ((lane_count < 1) || (lane_count > 4)) {
        return 0;
    }
    if (lane_count == 3) {
        return 0;
    }

    if (flex_mode == FLEX_2P5) {
        if (lane_count == 1) {
            /* 1G, 2.5G */
            if ((speed == 10) || (speed == 25)) {
                return 1;
            }
        }
    } else if (flex_mode == FLEX_10) {
        if (lane_count == 1) {
            /* 1G, 10G, 11G */
            if ((speed == 10) || (speed == 100) || (speed == 110)) {
                return 1;
            }
        }
    } else if (flex_mode == FLEX_40) {
        if (lane_count == 1) {
            /* 1G, 2.5G, 5G, 10G, 11G */
            if ((speed == 10) || (speed == 25) || (speed == 50) || \
                (speed == 100) || (speed == 110)) {
                return 1;
            }
        }
        if (lane_count == 2) {
            /* 20G, 21G */
            if ((speed == 200) || (speed == 210)) {
                return 1;
            }
        }
        if (lane_count == 4) {
            /* 40G, 42G, 21G */
            if ((speed == 400) || (speed == 420) || (speed == 210)) {
                return 1;
            }
        }
    } else if (flex_mode == FLEX_50) {
        if (lane_count == 1) {
            /* 1G, 10G, 11G, 25G */
            if ((speed == 10) || (speed == 100) || (speed == 110) || \
                (speed == 250)) {
                return 1;
            }
        }
        if (lane_count == 2) {
            /* 20G, 21G, 50G, 53G */
            if ((speed == 200) || (speed == 210) || (speed == 500) || \
                (speed == 530)) {
                return 1;
            }
        }
        if (lane_count == 4) {
            /* 40G, 42G */
            if ((speed == 400) || (speed == 420)) {
                return 1;
            }
        }
    } else if (flex_mode == FLEX_XAUI) {
        if (lane_count == 1) {
            /* 1G, 2.5G */
            if ((speed == 10) || (speed == 25)) {
                return 1;
            }
        }
        if (lane_count == 2) {
            return 0;
        }
        if (lane_count == 4) {
            /* 10G */
            if (speed == 100) {
                return 1;
            }
        }
    } else if (flex_mode == FLEX_20G_RIOT) {
        if (lane_count == 1) {
            /* 10G */
            if (speed == 100) {
                return 1;
            }
        }
        if (lane_count == 4) {
            /* 40G */
            if (speed == 400) {
                return 1;
            }
        }
    } else {
        return 0;
    }
    return 0;
}

static int
soc_gh2_flex2p5_checker(int unit,
                        int cfg_match_id,
                        int tsc_idx,
                        int *port_ratio)
{
    _gh2_option_info_t *matched_port_config = NULL;
    int *p2l_mapping, *speed_max;
    int rv = SOC_E_NONE;
    int ratio;

    matched_port_config = &_gh2_option_port_config[cfg_match_id];

    p2l_mapping = matched_port_config->p2l_mapping;
    speed_max = matched_port_config->speed_max;

    ratio = -1;
    if ((p2l_mapping[tsc_phy_port[tsc_idx]] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+1] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+2] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+3] != -1)) {

        if (flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx]], FLEX_2P5, 1) &&
            flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx] + 1], FLEX_2P5, 1) &&
            flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx] + 2], FLEX_2P5, 1) &&
            flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx] + 3], FLEX_2P5, 1)) {
            ratio = SOC_GH2_PORT_RATIO_QUAD;
        }
    }

    if ((p2l_mapping[tsc_phy_port[tsc_idx]] == -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+1] == -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+2] == -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+3] == -1)) {
        /* No lanes enabled on the core, assign default value */
        ratio = SOC_GH2_PORT_RATIO_QUAD;
    }

    if ((ratio >= SOC_GH2_PORT_RATIO_SINGLE) &&
        (ratio < SOC_GH2_PORT_RATIO_COUNT)) {
        *port_ratio = ratio;
        rv = SOC_E_NONE;
    } else {
        rv = SOC_E_FAIL;
    }
    return rv;
}

static int
soc_gh2_flex10_checker(int unit,
                       int cfg_match_id,
                       int tsc_idx,
                       int *port_ratio)
{
    _gh2_option_info_t *matched_port_config = NULL;
    int *p2l_mapping, *speed_max;
    int rv = SOC_E_NONE;
    int ratio;

    matched_port_config = &_gh2_option_port_config[cfg_match_id];

    p2l_mapping = matched_port_config->p2l_mapping;
    speed_max = matched_port_config->speed_max;

    ratio = -1;
    if ((p2l_mapping[tsc_phy_port[tsc_idx]] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+1] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+2] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+3] != -1)) {
        if (flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx]], FLEX_10, 1) &&
            flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx] + 1], FLEX_10, 1) &&
            flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx] + 2], FLEX_10, 1) &&
            flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx] + 3], FLEX_10, 1)) {
            ratio = SOC_GH2_PORT_RATIO_QUAD;
        }
    }

    if ((p2l_mapping[tsc_phy_port[tsc_idx]] == -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+1] == -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+2] == -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+3] == -1)) {
        /* No lanes enabled on the core, assign default value */
        ratio = SOC_GH2_PORT_RATIO_QUAD;
    }

    if ((ratio >= SOC_GH2_PORT_RATIO_SINGLE) &&
        (ratio < SOC_GH2_PORT_RATIO_COUNT)) {
        *port_ratio = ratio;
        rv = SOC_E_NONE;
    } else {
        rv = SOC_E_FAIL;
    }
    return rv;
}

static int
soc_gh2_flex40_checker(int unit,
                       int cfg_match_id,
                       int tsc_idx,
                       int *port_ratio)
{
    _gh2_option_info_t *matched_port_config = NULL;
    int *p2l_mapping, *speed_max;
    int rv = SOC_E_NONE;
    int ratio;

    matched_port_config = &_gh2_option_port_config[cfg_match_id];

    p2l_mapping = matched_port_config->p2l_mapping;
    speed_max = matched_port_config->speed_max;

    ratio = -1;
    if ((p2l_mapping[tsc_phy_port[tsc_idx]] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+1] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+2] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+3] != -1)) {
        if (flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx]], FLEX_40, 1) &&
            flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx] + 1], FLEX_40, 1) &&
            flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx] + 2], FLEX_40, 1) &&
            flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx] + 3], FLEX_40, 1)) {
            ratio = SOC_GH2_PORT_RATIO_QUAD;
        }
    }

    if ((p2l_mapping[tsc_phy_port[tsc_idx]] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+1] == -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+2] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+3] != -1)) {
        if (flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx]], FLEX_40, 2) &&
            flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx] + 2], FLEX_40, 1) &&
            flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx] + 3], FLEX_40, 1)) {
            ratio = SOC_GH2_PORT_RATIO_TRI_023;
        }
    }

    if ((p2l_mapping[tsc_phy_port[tsc_idx]] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+1] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+2] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+3] == -1)) {
        if (flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx]], FLEX_40, 1) &&
            flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx] + 1], FLEX_40, 1) &&
            flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx] + 2], FLEX_40, 2)) {
            ratio = SOC_GH2_PORT_RATIO_TRI_012;
        }
    }

    if ((p2l_mapping[tsc_phy_port[tsc_idx]] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+1] == -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+2] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+3] == -1)) {
        if (flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx]], FLEX_40, 2) &&
            flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx] + 2], FLEX_40, 2)) {
            ratio = SOC_GH2_PORT_RATIO_DUAL_2_2;
        }
    }

    if ((p2l_mapping[tsc_phy_port[tsc_idx]] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+1] == -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+2] == -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+3] == -1)) {
        if (_GH2_TSC_TSCF0_IDX == tsc_idx) {
            if ((speed_max[tsc_phy_port[tsc_idx]] == 100) || \
                (speed_max[tsc_phy_port[tsc_idx]] == 210)) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Quad lane mode with speed %dGbps "
                                      "is not supported on TSCF(TSC #7).\n"),
                                      speed_max[tsc_phy_port[tsc_idx]] / 10));
                return SOC_E_CONFIG;
            }
        }

        if (flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx]], FLEX_40, 4)) {
            ratio = SOC_GH2_PORT_RATIO_SINGLE;
        }
        /* Check if it is XAUI port */
        if (flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx]], FLEX_XAUI, 4)) {
            ratio = SOC_GH2_PORT_RATIO_SINGLE_XAUI;
        }
    }

    if ((p2l_mapping[tsc_phy_port[tsc_idx]] == -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+1] == -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+2] == -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+3] == -1)) {
        /* No lanes enabled on the core, assign default value */
        ratio = SOC_GH2_PORT_RATIO_QUAD;
    }

    if ((ratio >= SOC_GH2_PORT_RATIO_SINGLE) &&
        (ratio < SOC_GH2_PORT_RATIO_COUNT)) {
        *port_ratio = ratio;
        rv = SOC_E_NONE;
    } else {
        rv = SOC_E_FAIL;
    }
    return rv;
}

static int
soc_gh2_flex50_checker(int unit,
                       int cfg_match_id,
                       int tsc_idx,
                       int *port_ratio)
{
    _gh2_option_info_t *matched_port_config = NULL;
    int *p2l_mapping, *speed_max;
    int rv = SOC_E_NONE;
    int ratio;

    matched_port_config = &_gh2_option_port_config[cfg_match_id];

    p2l_mapping = matched_port_config->p2l_mapping;
    speed_max = matched_port_config->speed_max;

    ratio = -1;
    if ((p2l_mapping[tsc_phy_port[tsc_idx]] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+1] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+2] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+3] != -1)) {
        if (flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx]], FLEX_50, 1) &&
            flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx] + 1], FLEX_50, 1) &&
            flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx] + 2], FLEX_50, 1) &&
            flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx] + 3], FLEX_50, 1)) {
            ratio = SOC_GH2_PORT_RATIO_QUAD;
        }
    }

    if ((p2l_mapping[tsc_phy_port[tsc_idx]] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+1] == -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+2] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+3] != -1)) {
        if (flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx]], FLEX_50, 2) &&
            flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx] + 2], FLEX_50, 1) &&
            flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx] + 3], FLEX_50, 1)) {
            ratio = SOC_GH2_PORT_RATIO_TRI_023;
        }
    }

    if ((p2l_mapping[tsc_phy_port[tsc_idx]] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+1] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+2] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+3] == -1)) {
        if (flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx]], FLEX_50, 1) &&
            flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx] + 1], FLEX_50, 1) &&
            flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx] + 2], FLEX_50, 2)) {
            ratio = SOC_GH2_PORT_RATIO_TRI_012;
        }
    }

    if ((p2l_mapping[tsc_phy_port[tsc_idx]] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+1] == -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+2] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+3] == -1)) {
        if (flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx]], FLEX_50, 2) &&
            flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx] + 2], FLEX_50, 2)) {
            ratio = SOC_GH2_PORT_RATIO_DUAL_2_2;
        }
    }

    if ((p2l_mapping[tsc_phy_port[tsc_idx]] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+1] == -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+2] == -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+3] == -1)) {
        if (flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx]], FLEX_50, 4)) {
            ratio = SOC_GH2_PORT_RATIO_SINGLE;
        }
    }

    if ((p2l_mapping[tsc_phy_port[tsc_idx]] == -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+1] == -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+2] == -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+3] == -1)) {
        /* No lanes enabled on the core, assign default value */
        ratio = SOC_GH2_PORT_RATIO_QUAD;
    }

    if ((ratio >= SOC_GH2_PORT_RATIO_SINGLE) &&
        (ratio < SOC_GH2_PORT_RATIO_COUNT)) {
        *port_ratio = ratio;
        rv = SOC_E_NONE;
    } else {
        rv = SOC_E_FAIL;
    }
    return rv;
}

static int
soc_gh2_flex_xaui_checker(int unit,
                          int cfg_match_id,
                          int tsc_idx,
                          int *port_ratio)
{
    _gh2_option_info_t *matched_port_config = NULL;
    int *p2l_mapping, *speed_max;
    int rv = SOC_E_NONE;
    int ratio;

    matched_port_config = &_gh2_option_port_config[cfg_match_id];

    p2l_mapping = matched_port_config->p2l_mapping;
    speed_max = matched_port_config->speed_max;

    ratio = -1;
    if ((p2l_mapping[tsc_phy_port[tsc_idx]] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+1] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+2] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+3] != -1)) {
        if (flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx]], FLEX_XAUI, 1) &&
            flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx] + 1], FLEX_XAUI, 1) &&
            flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx] + 2], FLEX_XAUI, 1) &&
            flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx] + 3], FLEX_XAUI, 1)) {
            ratio = SOC_GH2_PORT_RATIO_QUAD;
        }
    }

    if ((p2l_mapping[tsc_phy_port[tsc_idx]] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+1] == -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+2] == -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+3] == -1)) {
        if (flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx]], FLEX_XAUI, 4)) {
            ratio = SOC_GH2_PORT_RATIO_SINGLE_XAUI;
        }
    }

    if ((p2l_mapping[tsc_phy_port[tsc_idx]] == -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+1] == -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+2] == -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+3] == -1)) {
        /* No lanes enabled on the core, assign default value */
        ratio = SOC_GH2_PORT_RATIO_QUAD;
    }

    if ((ratio >= SOC_GH2_PORT_RATIO_SINGLE) &&
        (ratio < SOC_GH2_PORT_RATIO_COUNT)) {
        *port_ratio = ratio;
        rv = SOC_E_NONE;
    } else {
        rv = SOC_E_FAIL;
    }
    return rv;
}

static int
soc_gh2_flex20_riot_checker(int unit,
                            int cfg_match_id,
                            int tsc_idx,
                            int *port_ratio)
{
    _gh2_option_info_t *matched_port_config = NULL;
    int *p2l_mapping, *speed_max;
    int rv = SOC_E_NONE;
    int ratio;

    matched_port_config = &_gh2_option_port_config[cfg_match_id];

    p2l_mapping = matched_port_config->p2l_mapping;
    speed_max = matched_port_config->speed_max;

    ratio = -1;
    if ((p2l_mapping[tsc_phy_port[tsc_idx]] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+1] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+2] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+3] != -1)) {
        if (flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx]], FLEX_20G_RIOT, 1) &&
            flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx] + 1], FLEX_20G_RIOT, 1) &&
            flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx] + 2], FLEX_20G_RIOT, 1) &&
            flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx] + 3], FLEX_20G_RIOT, 1)) {
            ratio = SOC_GH2_PORT_RATIO_QUAD;
        }
    }

    if ((p2l_mapping[tsc_phy_port[tsc_idx]] != -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+1] == -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+2] == -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+3] == -1)) {
        if (flex_lane_speed_check
                (speed_max[tsc_phy_port[tsc_idx]], FLEX_20G_RIOT, 4)) {
            ratio = SOC_GH2_PORT_RATIO_SINGLE;
        }
    }

    if ((p2l_mapping[tsc_phy_port[tsc_idx]] == -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+1] == -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+2] == -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+3] == -1)) {
        /* No lanes enabled on the core, assign default value */
        ratio = SOC_GH2_PORT_RATIO_QUAD;
    }

    if ((ratio >= SOC_GH2_PORT_RATIO_SINGLE) &&
        (ratio < SOC_GH2_PORT_RATIO_COUNT)) {
        *port_ratio = ratio;
        rv = SOC_E_NONE;
    } else {
        rv = SOC_E_FAIL;
    }
    return rv;
}

static int
soc_gh2_flex_off_checker(int unit,
                            int cfg_match_id,
                            int tsc_idx,
                            int *port_ratio)
{
    _gh2_option_info_t *matched_port_config = NULL;
    int *p2l_mapping;
    int rv = SOC_E_NONE;
    int ratio;

    matched_port_config = &_gh2_option_port_config[cfg_match_id];

    p2l_mapping = matched_port_config->p2l_mapping;

    ratio = -1;
    if ((p2l_mapping[tsc_phy_port[tsc_idx]] == -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+1] == -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+2] == -1) &&
        (p2l_mapping[tsc_phy_port[tsc_idx]+3] == -1)) {
        /* No lanes enabled on the core, assign default value */
        ratio = SOC_GH2_PORT_RATIO_QUAD;
    }

    if ((ratio >= SOC_GH2_PORT_RATIO_SINGLE) &&
        (ratio < SOC_GH2_PORT_RATIO_COUNT)) {
        *port_ratio = ratio;
        rv = SOC_E_NONE;
    } else {
        rv = SOC_E_FAIL;
    }
    return rv;
}


/*
 * Check portmap configured data matches the flex mode.
 */
static int
soc_gh2_port_cfg_checker(int unit, int cfg_match_id, int flex_mode_id)
{
    /*
     * Validate each core
     * Check if p2l and speed matched flex port mode of the TSC core.
     *    If matched, return the PORT_RATIO_TYPE
     *    If not matched, put warning message and return error.
     */
    _gh2_option_info_t *matched_port_config = NULL;
    _gh2_option_tsc_flex_mode_t *tsc_flex_modes = NULL;
    int rv = SOC_E_NONE;
    int i;
    int port_ratio = SOC_GH2_PORT_RATIO_QUAD;

    matched_port_config = &_gh2_option_port_config[cfg_match_id];
    tsc_flex_modes = &_gh2_option_tsc_flex_modes[flex_mode_id];

    for (i = 0; i < _GH2_MAX_TSC_COUNT; i++) {
        switch (tsc_flex_modes->mode[i]) {
            case FLEX_2P5:
                rv = soc_gh2_flex2p5_checker(unit, cfg_match_id,
                                             i, &port_ratio);
                break;
            case FLEX_10:
                rv = soc_gh2_flex10_checker(unit, cfg_match_id,
                                            i, &port_ratio);
                break;
            case FLEX_40:
                rv = soc_gh2_flex40_checker(unit, cfg_match_id,
                                            i, &port_ratio);
                break;
            case FLEX_50:
                rv = soc_gh2_flex50_checker(unit, cfg_match_id,
                                            i, &port_ratio);
                break;
            case FLEX_XAUI:
                rv = soc_gh2_flex_xaui_checker(unit, cfg_match_id,
                                               i, &port_ratio);
                break;
            case FLEX_20G_RIOT:
                rv = soc_gh2_flex20_riot_checker(unit, cfg_match_id,
                                                 i, &port_ratio);
                break;
            case FLEX_OFF:
                rv = soc_gh2_flex_off_checker(unit, cfg_match_id,
                                              i, &port_ratio);
                break;
            default:
                LOG_WARN(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit, "PORTMAP config is invalid "
                                    "on TSC #%d.\n"), i));
                return SOC_E_FAIL;
        }
        if (rv != SOC_E_NONE) {
            LOG_WARN(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit, "Incorrect PORTMAP config "
                                "on TSC #%d.\n"), i));
            return rv;
        }
        matched_port_config->default_port_ratio[i] = port_ratio;
    }

    return rv;
}

/* Update port cfg, p2l and speed, based on spn_PORTMAP */
static int
soc_gh2_port_mapping_update(int unit,
                                 int cfg_match_id,
                                 int flex_mode_id,
                                 int *updated)
{
    int lport;
    int pport;
    int port_bw;
    _gh2_option_info_t *matched_port_config = NULL;
    int rv = SOC_E_NONE;
    int renew;
    char *config_str;
    char *sub_str;
    char *sub_str_end;
    int portmap_qtc_port_cnt[2] = {0, 0};
    int i;

    matched_port_config = &_gh2_option_port_config[cfg_match_id];

    renew = 0;
    /* Scan spn_PORTMAP and update to p2l_mapping and speed max tables */
    for (lport = 2; lport < SOC_MAX_LOGICAL_PORTS; lport++) {
        config_str = soc_property_port_get_str(unit, lport, spn_PORTMAP);
        if (config_str == NULL) {
            continue;
        }

        /*
         * portmap.<port>=<physical port number>:<bandwidth in Gb>
         */
        sub_str = config_str;

        /* Parsing physical port number */
        pport = sal_ctoi(sub_str, &sub_str_end);
        if (sub_str == sub_str_end) {
            LOG_WARN(BSL_LS_SOC_COMMON,
                     (BSL_META_U(unit, "Port %d: Missing physical port "
                                 "information \"%s\"\n"),
                                 lport, config_str));
            rv = SOC_E_FAIL;
            continue;
        }
        if (pport < GH2_PORT_CFG_RENEW_PHY_PORT_MIN || \
            pport > GH2_PORT_CFG_RENEW_PHY_PORT_MAX) {
            LOG_WARN(BSL_LS_SOC_COMMON,
                     (BSL_META_U(unit, "Port %d: Invalid physical port "
                                 "number %d\n"),
                                 lport, pport));
            rv = SOC_E_FAIL;
            continue;
        }

        /* Skip ':' */
        sub_str = sub_str_end;
        if (*sub_str != '\0') {
            if (*sub_str != ':') {
                LOG_WARN(BSL_LS_SOC_COMMON,
                         (BSL_META_U(unit, "Port %d: Bad config "
                                     "string \"%s\"\n"),
                                     lport, config_str));
                rv = SOC_E_FAIL;
                continue;
            }
            sub_str++;
        }

        /* Parsing bandwidth */
        port_bw = sal_ctoi(sub_str, &sub_str_end);
        if (sub_str == sub_str_end) {
            LOG_WARN(BSL_LS_SOC_COMMON,
                     (BSL_META_U(unit, "Port %d: Missing bandwidth "
                                 "information \"%s\"\n"),
                                 lport, config_str));
            rv = SOC_E_FAIL;
            continue;
        }

        matched_port_config->p2l_mapping[pport] = lport;
        matched_port_config->speed_max[pport] = port_bw * 10;
        /* Special case for 2.5G config */
        if (!sal_strcmp(sub_str, "2.5")) {
            matched_port_config->speed_max[pport] = 25;
        }

        /* Count the number of qtc ports from config property. */
        if ((pport >= qtc_phy_port[0]) && (pport <= (qtc_phy_port[0] + 15))) {
            portmap_qtc_port_cnt[0]++;
        }
        if ((pport >= qtc_phy_port[1]) && (pport <= (qtc_phy_port[1] + 15))) {
            portmap_qtc_port_cnt[1]++;
        }

        if (!renew) {
            renew = 1;
        }
    }

    for (i = 0; i < 2; i++) {
        if (portmap_qtc_port_cnt[i] != 0) {
            if (portmap_qtc_port_cnt[i] == 4) {
                /* SGMII mode. */
                matched_port_config->qtc_default_mode[i] = \
                    _GH2_QTC_SERDES_DEFAULT_MODE_SGMII;
            } else if (portmap_qtc_port_cnt[i] == 16) {
                /* QSGMII mode. */
                matched_port_config->qtc_default_mode[i] = \
                    _GH2_QTC_SERDES_DEFAULT_MODE_QSGMII;
            } else {
                /* Error configuration. */
                rv = SOC_E_CONFIG;
                break;
            }
        }
    }

    *updated = renew;

    return rv;
}

STATIC
void soc_gh2_port_user_config_update(int unit, int cfg_match_id)
{
    int origin_p2l_mapping[SOC_MAX_PHY_PORTS];
    int origin_speed_max[SOC_MAX_PHY_PORTS];
    int rv = SOC_E_NONE;
    _gh2_option_info_t *matched_port_config = NULL;
    int i;
    int flex_mode_id = -1;
    int updated;
    char *port_ratio_str;
    int port_ratio;

    matched_port_config = &_gh2_option_port_config[cfg_match_id];

    /* Get the default TSC flex modes */
    for (i = 0; _gh2_option_tsc_flex_modes[i].config_op; i++) {
        if (!sal_strcmp(matched_port_config->config_op,
                        _gh2_option_tsc_flex_modes[i].config_op)) {
            flex_mode_id = i;
            break;
        }
    }
    if (flex_mode_id == -1) {
        /* No matched entry found */
        return;
    }

    /* Save copy of port cfg templates */
    sal_memcpy(origin_p2l_mapping,
               matched_port_config->p2l_mapping,
               SOC_MAX_PHY_PORTS * sizeof(int));
    sal_memcpy(origin_speed_max,
               matched_port_config->speed_max,
               SOC_MAX_PHY_PORTS * sizeof(int));

    /*
     * Update flex port configuration (p2l mapping and speed)
     * based on spn_PORTMAP user config
     */
    updated = 0;
    if (SOC_SUCCESS(rv)) {
        rv = soc_gh2_port_mapping_update(unit, cfg_match_id, flex_mode_id,
                                         &updated);
    }

    /* If success, check p2l mapping and speed based on supported flex mode */
    if (SOC_SUCCESS(rv) && updated) {
        rv = soc_gh2_port_cfg_checker(unit, cfg_match_id, flex_mode_id);
    }

    /* Any failure, restore the port cfg templates */
    if ((rv != SOC_E_NONE) || (!updated)){
        sal_memcpy(matched_port_config->p2l_mapping,
                   origin_p2l_mapping,
                   SOC_MAX_PHY_PORTS * sizeof(int));
        sal_memcpy(matched_port_config->speed_max,
                   origin_speed_max,
                   SOC_MAX_PHY_PORTS * sizeof(int));
        if (rv != SOC_E_NONE) {
            LOG_WARN(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit, "Option %s port config scan failed.\n"),
                                matched_port_config->config_op));
        }
        if (!updated) {
            LOG_WARN(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit, "Option %s port config not updated.\n"),
                                matched_port_config->config_op));
        }
    }

    /* Dump the final p2l mapping table */
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,"Physical to Logical port mapping : "
                            "[P] L")));
    for (i = 0; i < SOC_MAX_PHY_PORTS; i++) {
        if (!(i % 10)) {
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,"\n")));
        }
        if (matched_port_config->p2l_mapping[i] == -1) {
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,"[%2d]   "), i));
        } else {
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,"[%2d]%2d "),
                                    i, matched_port_config->p2l_mapping[i]));
        }
    }
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,"\n")));
    /* Dump the final port max speed table */
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,"Physical port max speed : "
                            "[P] Speed(Gb)")));
    for (i = 0; i < SOC_MAX_PHY_PORTS; i++) {
        if (!(i % 10)) {
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,"\n")));
        }
        if (matched_port_config->speed_max[i] == -1) {
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,"[%2d]   "), i));
        } else if (matched_port_config->speed_max[i] == -1) {
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,"[%2d]2.5"), i));
        } else {
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,"[%2d]%2d "),
                                    i, matched_port_config->speed_max[i] / 10));
        }
    }
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,"\n")));
    /* Dump port ratio mode of each TSC */
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,"TSC (0~6: TSCE, 7: TSCF) "
                            "port ratio mode :\n")));
    for (i = 0; i < (_GH2_MAX_TSC_COUNT); i++) {
        port_ratio = matched_port_config->default_port_ratio[i];
        if (port_ratio == SOC_GH2_PORT_RATIO_SINGLE) {
            port_ratio_str = "SINGLE";
        } else if (port_ratio == SOC_GH2_PORT_RATIO_SINGLE_XAUI) {
            port_ratio_str = "XAUI";
        } else if (port_ratio == SOC_GH2_PORT_RATIO_DUAL_2_2) {
            port_ratio_str = "DUAL";
        } else if (port_ratio == SOC_GH2_PORT_RATIO_TRI_012) {
            port_ratio_str = "TRI 012";
        } else if (port_ratio == SOC_GH2_PORT_RATIO_TRI_023) {
            port_ratio_str = "TRI 023";
        } else if (port_ratio == SOC_GH2_PORT_RATIO_QUAD) {
            port_ratio_str = "QUAD";
        } else {
            port_ratio_str = "INVALID";
        }

        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,"TSCE #%d port mode : %s\n"),
                                i, port_ratio_str));
    }
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,"\n")));
}


/*
 *  GH2 port mapping
 * cpu port number is fixed: physical 0, logical 0, mmu 0
 */
int
soc_greyhound2_port_config_init(int unit, uint16 dev_id)
{

    soc_info_t *si;
    int rv = SOC_E_NONE;
    int phy_port;
    int *p2l_mapping = 0, *speed_max = 0;
    char *option;
    int match = -1, i, j;
    int valid_sku_option;
    char *default_option_string = NULL;
    int p2l_mapping_override[SOC_MAX_PHY_PORTS];
    int port_speed_max_override[SOC_MAX_PHY_PORTS];
    int port_num_lanes[SOC_MAX_PHY_PORTS];
    _gh2_option_info_t *matched_port_config = NULL;
    int freq = _GH2_53570_SYSTEM_FREQ;
    uint16  device_id;
    uint8   revision_id;

    option = soc_property_get_str(unit, spn_INIT_PORT_CONFIG_OPTION);
    if (option == NULL) {
        /* Backward compatible */
        option = soc_property_get_str(unit, "bcm53570_init_port_config");
    }

    if (option == NULL) {
        option = OPTION_1;
    }


    soc_cm_get_id(unit, &device_id, &revision_id);
    if (revision_id == BCM56170_A0_REV_ID) {
        _gh2_option_port_config = _gh2_a0_option_port_config;
        _gh2_sku_option_support_list = _gh2_a0_sku_option_support_list;
    } else {
        _gh2_option_port_config = _gh2_b0_option_port_config;
        _gh2_sku_option_support_list = _gh2_b0_sku_option_support_list;
    }

    valid_sku_option = 0;
    for (i = 0; _gh2_sku_option_support_list[i].dev_id; i++) {
        if (dev_id == _gh2_sku_option_support_list[i].dev_id) {
            /* save the default option in case nothing matched later */
            if ((default_option_string == NULL) &&
                _gh2_sku_option_support_list[i].default_option) {
                default_option_string =
                    _gh2_sku_option_support_list[i].option_string;
            }
            /* compare if the optoin is suppported in the SKU */
            if (!sal_strcmp(_gh2_sku_option_support_list[i].option_string,
                   option)) {
                valid_sku_option = 1;
                break;
            }
        }
    }
    if (!valid_sku_option && default_option_string) {
        LOG_WARN(BSL_LS_SOC_COMMON,
            (BSL_META_U(unit,
                        "Warning: option %s "
                        "is not supported in %s \n"), option,
                        soc_dev_name(unit)));
        LOG_WARN(BSL_LS_SOC_COMMON,
            (BSL_META_U(unit,
                        "Use default option %s "
                        "instead\n"), default_option_string));
        /* assign the default option if nothing matched */
        option = default_option_string;
    }

    for (i = 0; _gh2_option_port_config[i].config_op; i++) {
        if (!sal_strcmp(_gh2_option_port_config[i].config_op, option)) {
            match = i;
            break;
        }
    }

    /* Flex port configuration update */
    /* Only available for B0 */
    if (revision_id != BCM56170_A0_REV_ID) {
        soc_gh2_port_user_config_update(unit, (match == -1) ? 0 : match);
    }

    for (i = 0; i < _GH2_MAX_TSC_COUNT; i++) {
        _gh2_tsc[i].port_count = 0;
        _gh2_tsc[i].valid = 0;
        _gh2_tsc[i].phy_port_base = tsc_phy_port[i];
        if (match == -1) {
            _gh2_tsc[i].port_count =
                _gh2_option_port_config[0].default_port_ratio[i];
        } else {
            _gh2_tsc[i].port_count =
                _gh2_option_port_config[match].default_port_ratio[i];
        }
    }

    for (phy_port = 0; phy_port < SOC_MAX_PHY_PORTS; phy_port++) {
        p2l_mapping_override[phy_port] = 0;
        port_speed_max_override[phy_port] = 0;
        port_num_lanes[phy_port] = 1;
        gh2_port_speed[phy_port] = 0;
    }

    if (match == -1) {
        /* take opton 1_0 as default config */
        p2l_mapping = p2l_mapping_op1_0;
        speed_max = port_speed_max_op1_0;
        freq = _GH2_53570_SYSTEM_FREQ;
        LOG_WARN(BSL_LS_SOC_COMMON,
            (BSL_META_U(unit,"%s: no device_id matched\n"), FUNCTION_NAME()));
    } else {
        matched_option_idx = match;
        matched_port_config = &_gh2_option_port_config[match];

        LOG_VERBOSE(BSL_LS_SOC_COMMON,
            (BSL_META_U(unit,"%s: option matched %s\n"),
            FUNCTION_NAME(), matched_port_config->config_op));

        p2l_mapping = matched_port_config->p2l_mapping;
        speed_max = matched_port_config->speed_max;
        freq = matched_port_config->freq;

        /* Check QTC SGMII/QSGMII selection */
        for (i = 0; i < _GH2_MAX_QTC_COUNT; i++) {
            _gh2_qtc_serdes_override[i] = _GH2_QTC_SERDES_OVERRDE_NONE;

            if (matched_port_config->qtc_default_mode[i] ==
                _GH2_QTC_SERDES_DEFAULT_MODE_SGMII) {
                _gh2_qtc_serdes_override[i] = _GH2_QTC_SERDES_OVERRDE_SGMII;
                LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,"%s: QTC%1d is SGMII\n"),
                    FUNCTION_NAME(), i));
            } else if (matched_port_config->qtc_default_mode[i] ==
                       _GH2_QTC_SERDES_DEFAULT_MODE_QSGMII) {
                _gh2_qtc_serdes_override[i] = _GH2_QTC_SERDES_OVERRDE_QSGMII;
                LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,"%s: QTC%1d is QSGMII\n"),
                    FUNCTION_NAME(), i));
            } else {
                _gh2_qtc_serdes_override[i] = _GH2_QTC_SERDES_OVERRDE_NONE;
            }
        }

        /* QSGMII or SGMII selection */
        for (i = 0; i < _GH2_MAX_QTC_COUNT; i++) {
            if (!((1 << i) & matched_port_config->disabled_qtc_bmp)) {
                /* Override to the SGMII port mapping and max speed */
                if (_gh2_qtc_serdes_override[i] ==
                    _GH2_QTC_SERDES_OVERRDE_SGMII) {
                    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,"%s: QTC%1d SGMII overrided.\n"),
                        FUNCTION_NAME(), i));
                    if (matched_port_config->num_sgmii_supported[i] == 0) {
                        LOG_ERROR(BSL_LS_SOC_COMMON,
                            (BSL_META_U(unit,
                                  "Warning: QTC#%d SGMII mode "
                                  "is not supported in %s option %s.\n"), i,
                                  soc_dev_name(unit),
                                  matched_port_config->config_op));
                        return SOC_E_CONFIG;
                    }
                    /* Disable original qsgmii ports */
                    for (j = 0;
                         j < matched_port_config->num_qsgmii_supported[i];
                         j++) {
                        p2l_mapping_override[qtc_phy_port[i] + j * 4] = -1;
                        p2l_mapping_override[qtc_phy_port[i] + j * 4 + 1] = -1;
                        p2l_mapping_override[qtc_phy_port[i] + j * 4 + 2] = -1;
                        p2l_mapping_override[qtc_phy_port[i] + j * 4 + 3] = -1;
                    }
                    for (j = 0;
                         j < matched_port_config->num_sgmii_supported[i];
                         j++) {
                        /*
                         * Override sgmii port to max speed
                         *  option 10b: 1G
                         *  option 4a, 5, 8b: 2.5G
                         *  other options: keep the configured speed
                         */
                        p2l_mapping_override[qtc_phy_port[i] + j] = 1;
                        port_num_lanes[qtc_phy_port[i]+j] = 4;
                        if (!sal_strcmp
                            (matched_port_config->config_op, OPTION_10B_0) || \
                            !sal_strcmp
                            (matched_port_config->config_op, OPTION_10B)) {
                            port_speed_max_override[qtc_phy_port[i] + j] = 10;
                        } else if (!sal_strcmp(matched_port_config->config_op,
                                               OPTION_4A) || \
                                   !sal_strcmp(matched_port_config->config_op,
                                               OPTION_5) || \
                                   !sal_strcmp(matched_port_config->config_op,
                                               OPTION_8B)) {
                            port_speed_max_override[qtc_phy_port[i] + j] = 25;
                        } else {
                            port_speed_max_override[qtc_phy_port[i] + j] = \
                                speed_max[qtc_phy_port[i] + j];
                        }
                    }
                } else if (_gh2_qtc_serdes_override[i] ==
                        _GH2_QTC_SERDES_OVERRDE_QSGMII) {
                    if (matched_port_config->num_qsgmii_supported[i] == 0) {
                        LOG_ERROR(BSL_LS_SOC_COMMON,
                            (BSL_META_U(unit,
                                  "Warning: QTC#%d QSGMII mode "
                                  "is not supported in %s option %s.\n"), i,
                                  soc_dev_name(unit),
                                  matched_port_config->config_op));
                        /*
                         * Defaul configuration is QSGMII except QSGMII
                         * is not supported
                         */
                        /* No need to override the mapping and max port speed */
                        return SOC_E_CONFIG;
                    }
                }
            }
        }

    }

    si = &SOC_INFO(unit);

    for (phy_port = 0; phy_port < SOC_MAX_PHY_PORTS; phy_port++) {
        if (p2l_mapping_override[phy_port] == -1) {
            si->port_p2l_mapping[phy_port] = p2l_mapping_override[phy_port];
            /* Same as Egr P2L */
            si->port_p2m_mapping[phy_port] = p2l_mapping_override[phy_port];
            /* For COSQ programming */
            si->max_port_p2m_mapping[phy_port] = p2l_mapping_override[phy_port];
        } else {
            /* speed_max reflects the valid port */
            /*
             * For the same TDM, the phy_port should be existed in
             * p2l_mapping table
             */
            if ((speed_max[phy_port] == -1) && (phy_port != 0)) {
                si->port_p2l_mapping[phy_port] = -1;
                si->port_p2m_mapping[phy_port] = -1;
                si->max_port_p2m_mapping[phy_port] = -1;
                si->port_num_lanes[p2l_mapping[phy_port]] = -1;
            } else {
                si->port_p2l_mapping[phy_port] = p2l_mapping[phy_port];
                si->port_p2m_mapping[phy_port] = p2l_mapping[phy_port];
                si->max_port_p2m_mapping[phy_port] = p2l_mapping[phy_port];
                si->port_num_lanes[p2l_mapping[phy_port]] = 1;
            }
        }
        if (port_speed_max_override[phy_port] != 0) {
            if (port_speed_max_override[phy_port] != -1) {
                si->port_speed_max[si->port_p2l_mapping[phy_port]] =
                    port_speed_max_override[phy_port] * 100;
                si->port_num_lanes[p2l_mapping[phy_port]] =
                    port_num_lanes[phy_port];
            }
        } else {
            if (speed_max[phy_port] != -1) {
                si->port_speed_max[si->port_p2l_mapping[phy_port]] =
                    speed_max[phy_port] * 100;
            }
        }
    }

    for (phy_port = 0; phy_port < SOC_MAX_PHY_PORTS; phy_port++) {
        if (si->port_p2l_mapping[phy_port] != -1) {
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,"%s: Port %d, lane number %d.\n"),
                FUNCTION_NAME(), si->port_p2l_mapping[phy_port],
                si->port_num_lanes[si->port_p2l_mapping[phy_port]]));
        }
    }

    /* physical to mmu port mapping */
    {
        int phy_port_cpu;
        int phy_port_loopback;
        int mmu_port_cpu;
        int mmu_port_loopback;
        int num_mmu_port = SOC_MAX_MMU_PORTS;
        int mmu_port_max;
        int mmu_port;

        phy_port_cpu = 0;
        mmu_port_cpu = 0;
        phy_port_loopback = 1;
        mmu_port_loopback = 1;
        si->port_p2m_mapping[phy_port_cpu] = mmu_port_cpu;
        si->port_p2m_mapping[phy_port_loopback] = mmu_port_loopback;

        mmu_port_max = num_mmu_port - 1;
        for (phy_port = (SOC_MAX_PHY_PORTS - 1);
             phy_port > phy_port_loopback; phy_port--) {
            if (si->port_p2l_mapping[phy_port] != -1) {
                si->port_p2m_mapping[phy_port] = mmu_port_max;
                mmu_port_max--;
            }
        }

        /*
         * reset port_m2p_mapping, actual value is setup in
         * soc_info_config() later
         */
        for (mmu_port = 0; mmu_port < num_mmu_port; mmu_port++) {
            si->port_m2p_mapping[mmu_port] = -1;
        }
    }

    /* system core clock */
    si->frequency = freq;

    return rv;
}

int
_soc_greyhound2_autotdm_init(int unit)
{
    soc_info_t *si = &SOC_INFO(unit);
    soc_port_schedule_state_t *port_schedule_state;
    soc_port_map_type_t *in_portmap;
    int port;
    int rv = SOC_E_NONE;

    port_schedule_state = sal_alloc(sizeof(soc_port_schedule_state_t),
                                    "Greyhound2 soc_port_schedule_state_t");
    if (port_schedule_state == NULL) {
        return SOC_E_MEMORY;
    }
    sal_memset(port_schedule_state, 0, sizeof(soc_port_schedule_state_t));

    /* Core clock frequency */
    port_schedule_state->frequency = si->frequency;

    /* Construct in_port_map */
    in_portmap = &port_schedule_state->in_port_map;

    PBMP_PORT_ITER(unit, port) {
        in_portmap->log_port_speed[port] = si->port_speed_max[port];
        in_portmap->port_num_lanes[port] = si->port_num_lanes[port];
    }

    /* DV requires CPU port speed 1G */
    port = 0;
    in_portmap->log_port_speed[port] = SPEED_1G;

    sal_memcpy(in_portmap->port_p2l_mapping, si->port_p2l_mapping,
               sizeof(int) * SOC_MAX_PHY_PORTS);
    sal_memcpy(in_portmap->port_l2p_mapping, si->port_l2p_mapping,
               sizeof(int) * SOC_MAX_LOGICAL_PORTS);
    sal_memcpy(in_portmap->port_p2m_mapping, si->port_p2m_mapping,
               sizeof(int) * SOC_MAX_PHY_PORTS);
    sal_memcpy(in_portmap->port_m2p_mapping, si->port_m2p_mapping,
               sizeof(int) * SOC_MAX_MMU_PORTS);
    sal_memcpy(&in_portmap->physical_pbm, &si->physical_pbm, sizeof(pbmp_t));
    sal_memcpy(&in_portmap->hg2_pbm, &si->hg.bitmap, sizeof(pbmp_t));

    rv = soc_gh2_tdm_init(unit, port_schedule_state);
    if (rv != SOC_E_NONE) {
        LOG_CLI((BSL_META_U(unit,
                            "TDM calendar generation failed.\n")));
        sal_free(port_schedule_state);
        return rv;
    }

    sal_free(port_schedule_state);

    return rv;
}

int
_soc_greyhound2_tdm_init(int unit, uint16 dev_id)
{
    uint32              *arr = NULL;
    int                 tdm_size;
    uint32              rval;
    iarb_tdm_table_entry_t iarb_tdm;
    mmu_arb_tdm_table_entry_t mmu_arb_tdm;
    int i, port, phy_port;
    _gh2_option_info_t *matched_opt_info;
    soc_info_t *si;
    int flex_mode_id = -1;

    if (matched_option_idx == -1) {
        LOG_WARN(BSL_LS_SOC_COMMON,
           (BSL_META_U(unit, "Warning: soc_greyhound2_port_config_init should "
                        "be invoked first! Choose bcm53570 port config.\n")));
        matched_option_idx = 0;
    }
    matched_opt_info = &_gh2_option_port_config[matched_option_idx];

    /* Check if AutoTDM available on the option */
    for (i = 0; _gh2_option_tsc_flex_modes[i].config_op; i++) {
        if (!sal_strcmp(matched_opt_info->config_op,
                        _gh2_option_tsc_flex_modes[i].config_op)) {
            flex_mode_id = i;
            break;
        }
    }
    if (flex_mode_id != -1) {
        /* Apply AutoTDM */
        return _soc_greyhound2_autotdm_init(unit);
    }

    si = &SOC_INFO(unit);



    SOC_IF_ERROR_RETURN(READ_IARB_TDM_CONTROLr(unit, &rval));
    soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, DISABLEf, 1);
    soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, TDM_WRAP_PTRf, 83);
    SOC_IF_ERROR_RETURN(WRITE_IARB_TDM_CONTROLr(unit, rval));

    arr = matched_opt_info->tdm_table;
    tdm_size = matched_opt_info->tdm_table_size;

    if (arr == NULL) {
        return SOC_E_CONFIG;
    }

    for (i = 0; i < tdm_size; i++) {
        phy_port = arr[i];
        port = (phy_port != 127) ? si->port_p2m_mapping[phy_port] : 127;
        sal_memset(&iarb_tdm, 0, sizeof(iarb_tdm_table_entry_t));
        sal_memset(&mmu_arb_tdm, 0, sizeof(mmu_arb_tdm_table_entry_t));

        soc_IARB_TDM_TABLEm_field32_set(unit, &iarb_tdm, PORT_NUMf,
                                        phy_port);
        soc_MMU_ARB_TDM_TABLEm_field32_set(unit, &mmu_arb_tdm, PORT_NUMf,
                                           port);

        if (i == tdm_size - 1) {
            soc_MMU_ARB_TDM_TABLEm_field32_set(unit, &mmu_arb_tdm, WRAP_ENf, 1);
        }
        SOC_IF_ERROR_RETURN(WRITE_IARB_TDM_TABLEm(unit, SOC_BLOCK_ALL, i,
                                                  &iarb_tdm));
        SOC_IF_ERROR_RETURN(WRITE_MMU_ARB_TDM_TABLEm(unit, SOC_BLOCK_ALL, i,
                                                     &mmu_arb_tdm));
    }
    rval = 0;
    soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, DISABLEf, 0);
    soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, TDM_WRAP_PTRf,
                      tdm_size -1);
    SOC_IF_ERROR_RETURN(WRITE_IARB_TDM_CONTROLr(unit, rval));

    return SOC_E_NONE;
}

STATIC int ceiling_func(uint32 numerators, uint32 denominator)
{
    uint32  result;
    if (denominator == 0) {
        return 0xFFFFFFFF;
    }
    result = numerators / denominator;
    if (numerators % denominator != 0) {
        result++;
    }
    return result;
}


STATIC int _soc_greyhound2_mmu_init_helper_lossy(int unit)
{
    uint32 rval;
    int port, phy_port;
    int index;
    soc_info_t *si = &SOC_INFO(unit);
    soc_pbmp_t pbmp_cpu;
    soc_pbmp_t pbmp_uplink;
    soc_pbmp_t pbmp_downlink_1g;
    soc_pbmp_t pbmp_downlink_2dot5g;

    static int standard_jumbo_frame;
    static int cell_size;
    static int ethernet_mtu_cell;
    static int standard_jumbo_frame_cell;
    static int total_physical_memory;
    static int total_cell_memory_for_admission;
    static int number_of_used_memory_banks;
    static int reserved_for_cfap;
    static int skidmarker;
    static int prefetch;
    static int total_cell_memory;
    static int cfapfullsetpoint;
    static int total_advertised_cell_memory;
    static int number_of_uplink_ports;
    static int number_of_downlink_ports;
    static int queue_port_limit_ratio;
    static int egress_queue_min_reserve_uplink_ports_lossy;
    static int egress_queue_min_reserve_downlink_ports_lossy;
    static int egress_queue_min_reserve_uplink_ports_lossless;
    static int egress_queue_min_reserve_downlink_ports_lossless;
    static int egress_queue_min_reserve_cpu_ports;
    static int egress_xq_min_reserve_lossy_ports;
    static int egress_xq_min_reserve_lossless_uplink_ports;
    static int egress_xq_min_reserve_lossless_downlink_ports;
    static int num_active_pri_group_lossless;
    static int num_lossy_queues;
    static int mmu_xoff_pkt_threshold_uplink_ports;
    static int mmu_xoff_pkt_threshold_downlink_ports;
    static int mmu_xoff_cell_threshold_1g_port_downlink_ports;
    static int mmu_xoff_cell_threshold_2dot5g_port_downlink_ports;
    static int mmu_xoff_cell_threshold_all_uplink_ports;
    static int num_cpu_queues;
    static int num_cpu_ports;
    static int numxqs_per_uplink_ports;
    static int numxqs_per_downlink_ports_and_cpu_port;
    static int headroom_for_1g_port;
    static int headroom_for_2dot5g_port;
    static int xoff_cell_thresholds_per_port_1g_port_downlink_ports;
    static int xoff_cell_thresholds_per_port_2dot5g_downlink_ports;
    static int xoff_cell_threshold_all_uplink_ports;
    static int xoff_packet_thresholds_per_port_uplink_port;
    static int xoff_packet_thresholds_per_port_downlink_port;
    static int discard_limit_per_port_pg_uplink_1g_port;
    static int discard_limit_per_port_pg_uplink_2dot5g_port;
    static int discard_limit_per_port_pg_downlink_port;
    static int total_reserved_cells_for_uplink_ports;
    static int total_reserved_cells_for_downlink_ports;
    static int total_reserved_cells_for_cpu_port;
    static int total_reserved;
    static int shared_space_cells;
    static int reserved_xqs_per_uplink_port;
    static int shared_xqs_per_uplink_port;
    static int reserved_xqs_per_downlink_port;
    static int shared_xqs_per_downlink_port;
    static int cfapfullthreshold_cfapfullsetpoint_up;
    static int gbllimitsetlimit_gblcellsetlimit_up;
    static int totaldyncellsetlimit_totaldyncellsetlimit_up;
    static int holcosminxqcnt_qlayer8_holcosminxqcnt_up;
    static int holcospktsetlimit0_pktsetlimit_up;
    static int holcospktsetlimit7_pktsetlimit_up;
    static int holcospktsetlimit_qlayer0_pktsetlimit_up;
    static int holcospktsetlimit_qlayer7_pktsetlimit_up;
    static int holcospktsetlimit_qlayer8_pktsetlimit_up;
    static int dynxqcntport_dynxqcntport_up;
    static int lwmcoscellsetlimit0_cellsetlimit_up;
    static int lwmcoscellsetlimit7_cellsetlimit_up;
    static int lwmcoscellsetlimit_qlayer0_cellsetlimit_up;
    static int lwmcoscellsetlimit_qlayer7_cellsetlimit_up;
    static int lwmcoscellsetlimit_qlayer8_cellsetlimit_up;
    static int holcoscellmaxlimit0_cellmaxlimit_up;
    static int holcoscellmaxlimit7_cellmaxlimit_up;
    static int holcoscellmaxlimit_qlayer0_cellmaxlimit_up;
    static int holcoscellmaxlimit_qlayer7_cellmaxlimit_up;
    static int holcoscellmaxlimit_qlayer8_cellmaxlimit_up;
    static int dyncelllimit_dyncellsetlimit_up;
    static int holcospktsetlimit_qgroup0_pktsetlimit_up;
    static int holcoscellmaxlimit_qgroup0_cellmaxlimit_up;
    static int holcosminxqcnt_qlayer8_holcosminxqcnt_down_1;
    static int holcospktsetlimit0_pktsetlimit_down_1;
    static int holcospktsetlimit7_pktsetlimit_down_1;
    static int holcospktsetlimit_qlayer0_pktsetlimit_down_1;
    static int holcospktsetlimit_qlayer7_pktsetlimit_down_1;
    static int holcospktsetlimit_qlayer8_pktsetlimit_down_1;
    static int dynxqcntport_dynxqcntport_down_1;
    static int lwmcoscellsetlimit0_cellsetlimit_down_1;
    static int lwmcoscellsetlimit7_cellsetlimit_down_1;
    static int lwmcoscellsetlimit_qlayer0_cellsetlimit_down_1;
    static int lwmcoscellsetlimit_qlayer7_cellsetlimit_down_1;
    static int lwmcoscellsetlimit_qlayer8_cellsetlimit_down_1;
    static int holcoscellmaxlimit0_cellmaxlimit_down_1;
    static int holcoscellmaxlimit7_cellmaxlimit_down_1;
    static int holcoscellmaxlimit_qlayer0_cellmaxlimit_down_1;
    static int holcoscellmaxlimit_qlayer7_cellmaxlimit_down_1;
    static int holcoscellmaxlimit_qlayer8_cellmaxlimit_down_1;
    static int dyncelllimit_dyncellsetlimit_down_1;
    static int holcospktsetlimit_qgroup0_pktsetlimit_down_1;
    static int holcoscellmaxlimit_qgroup0_cellmaxlimit_down_1;
    static int holcospktsetlimit0_pktsetlimit_down_2dot5;
    static int holcospktsetlimit7_pktsetlimit_down_2dot5;
    static int holcospktsetlimit_qlayer0_pktsetlimit_down_2dot5;
    static int holcospktsetlimit_qlayer7_pktsetlimit_down_2dot5;
    static int holcospktsetlimit_qlayer8_pktsetlimit_down_2dot5;
    static int dynxqcntport_dynxqcntport_down_2dot5;
    static int lwmcoscellsetlimit0_cellsetlimit_down_2dot5;
    static int lwmcoscellsetlimit7_cellsetlimit_down_2dot5;
    static int lwmcoscellsetlimit_qlayer0_cellsetlimit_down_2dot5;
    static int lwmcoscellsetlimit_qlayer7_cellsetlimit_down_2dot5;
    static int lwmcoscellsetlimit_qlayer8_cellsetlimit_down_2dot5;
    static int holcoscellmaxlimit0_cellmaxlimit_down_2dot5;
    static int holcoscellmaxlimit7_cellmaxlimit_down_2dot5;
    static int holcoscellmaxlimit_qlayer0_cellmaxlimit_down_2dot5;
    static int holcoscellmaxlimit_qlayer7_cellmaxlimit_down_2dot5;
    static int holcoscellmaxlimit_qlayer8_cellmaxlimit_down_2dot5;
    static int dyncelllimit_dyncellsetlimit_down_2dot5;
    static int holcospktsetlimit_qgroup0_pktsetlimit_down_2dot5;
    static int holcoscellmaxlimit_qgroup0_cellmaxlimit_down_2dot5;
    static int holcosminxqcnt0_holcosminxqcnt_cpu;
    static int holcosminxqcnt7_holcosminxqcnt_cpu;
    static int holcospktsetlimit0_pktsetlimit_cpu;
    static int holcospktsetlimit7_pktsetlimit_cpu;
    static int dynxqcntport_dynxqcntport_cpu;
    static int lwmcoscellsetlimit0_cellsetlimit_cpu;
    static int lwmcoscellsetlimit7_cellsetlimit_cpu;
    static int holcoscellmaxlimit0_cellmaxlimit_cpu;
    static int holcoscellmaxlimit7_cellmaxlimit_cpu;
    static int dyncelllimit_dyncellsetlimit_cpu;
    uint16 dev_id;
    uint8  rev_id;

    soc_cm_get_id(unit, &dev_id, &rev_id);

    /* setup port bitmap according the port max speed for lossy
     *   TSC/TSCF    : uplink port
     *   QGMII/SGMII : donnlink port
     */
    num_cpu_ports = 0;
    number_of_uplink_ports = 0;
    number_of_downlink_ports = 0;
    SOC_PBMP_CLEAR(pbmp_cpu);
    SOC_PBMP_CLEAR(pbmp_uplink);
    SOC_PBMP_CLEAR(pbmp_downlink_1g);
    SOC_PBMP_CLEAR(pbmp_downlink_2dot5g);
    for (phy_port = 0; phy_port < SOC_MAX_PHY_PORTS; phy_port++) {
        port = si->port_p2l_mapping[phy_port];
        if (port < 0) {
            continue; /* this user port has not been mapping in this sku */
        } else if (!SOC_PBMP_MEMBER(PBMP_ALL(unit), port)) {
            continue; /* this user port has been masked out by pbmp_valid */
        }
        if (IS_XL_PORT(unit, port) || IS_CL_PORT(unit, port)) {
            number_of_uplink_ports++;
            SOC_PBMP_PORT_ADD(pbmp_uplink, port);
        } else if (IS_GE_PORT(unit, port)) {
            number_of_downlink_ports++;
            if (SOC_INFO(unit).port_speed_max[port] > 1000) {
                SOC_PBMP_PORT_ADD(pbmp_downlink_2dot5g, port);
            } else {
                SOC_PBMP_PORT_ADD(pbmp_downlink_1g, port);
            }
        } else if (IS_CPU_PORT(unit, port)) {
            num_cpu_ports++;
            SOC_PBMP_PORT_ADD(pbmp_cpu, port);
        }
    }

    standard_jumbo_frame = 9216;
    cell_size = 144;
    ethernet_mtu_cell = ceiling_func(15 * 1024 / 10, cell_size);
    standard_jumbo_frame_cell = ceiling_func(standard_jumbo_frame, cell_size);
    if (rev_id == BCM56170_B0_REV_ID) {
        total_physical_memory = 32 * 1024;
    } else {
        total_physical_memory = 24 * 1024;
    }
    total_cell_memory_for_admission = total_physical_memory * 7 / 8;
    number_of_used_memory_banks = 8;
    reserved_for_cfap = (65) * 2 + number_of_used_memory_banks * 4;
    skidmarker = 7;
    prefetch = 64 + 4;
    total_cell_memory = total_cell_memory_for_admission;
    cfapfullsetpoint = total_physical_memory - reserved_for_cfap;
    total_advertised_cell_memory = total_cell_memory;
    queue_port_limit_ratio = 8;
    egress_queue_min_reserve_uplink_ports_lossy = ethernet_mtu_cell;
    egress_queue_min_reserve_downlink_ports_lossy = ethernet_mtu_cell;
    egress_queue_min_reserve_uplink_ports_lossless = 0;
    egress_queue_min_reserve_downlink_ports_lossless = 0;
    egress_queue_min_reserve_cpu_ports = ethernet_mtu_cell;
    egress_xq_min_reserve_lossy_ports
          = ethernet_mtu_cell;
    egress_xq_min_reserve_lossless_uplink_ports = 0;
    egress_xq_min_reserve_lossless_downlink_ports = 0;
    num_active_pri_group_lossless = 0;
    num_lossy_queues = 8;
    mmu_xoff_pkt_threshold_uplink_ports = total_advertised_cell_memory;
    mmu_xoff_pkt_threshold_downlink_ports = total_advertised_cell_memory;
    mmu_xoff_cell_threshold_1g_port_downlink_ports
          = total_advertised_cell_memory;
    mmu_xoff_cell_threshold_2dot5g_port_downlink_ports
          = total_advertised_cell_memory;
    mmu_xoff_cell_threshold_all_uplink_ports = total_advertised_cell_memory;
    num_cpu_queues = 8;
    num_cpu_ports = 1;
    numxqs_per_uplink_ports = 6 * 1024;
    numxqs_per_downlink_ports_and_cpu_port = 2 * 1024;
    headroom_for_1g_port = 0;
    headroom_for_2dot5g_port = 0;
    xoff_cell_thresholds_per_port_1g_port_downlink_ports
          = mmu_xoff_cell_threshold_1g_port_downlink_ports;
    xoff_cell_thresholds_per_port_2dot5g_downlink_ports
          = mmu_xoff_cell_threshold_2dot5g_port_downlink_ports;
    xoff_cell_threshold_all_uplink_ports
          = mmu_xoff_cell_threshold_all_uplink_ports;
    xoff_packet_thresholds_per_port_uplink_port
          = mmu_xoff_pkt_threshold_uplink_ports;
    xoff_packet_thresholds_per_port_downlink_port
          = mmu_xoff_pkt_threshold_downlink_ports;
    discard_limit_per_port_pg_uplink_1g_port
        = xoff_cell_thresholds_per_port_1g_port_downlink_ports
          + headroom_for_1g_port;
    discard_limit_per_port_pg_uplink_2dot5g_port
        = xoff_cell_thresholds_per_port_2dot5g_downlink_ports
          + headroom_for_2dot5g_port;
    discard_limit_per_port_pg_downlink_port = total_advertised_cell_memory;
    total_reserved_cells_for_uplink_ports
        = egress_queue_min_reserve_uplink_ports_lossy
          * number_of_uplink_ports * num_lossy_queues
          + number_of_uplink_ports
          * egress_queue_min_reserve_uplink_ports_lossless
          * num_active_pri_group_lossless;
    total_reserved_cells_for_downlink_ports
        = number_of_downlink_ports
          * egress_queue_min_reserve_downlink_ports_lossy
          * (num_lossy_queues) + number_of_downlink_ports
          * egress_queue_min_reserve_downlink_ports_lossless
          * num_active_pri_group_lossless;
    total_reserved_cells_for_cpu_port
        = num_cpu_ports * egress_queue_min_reserve_cpu_ports
          * num_cpu_queues;
    total_reserved
        = total_reserved_cells_for_uplink_ports
          + total_reserved_cells_for_downlink_ports
          + total_reserved_cells_for_cpu_port;
    shared_space_cells = total_advertised_cell_memory - total_reserved;
    reserved_xqs_per_uplink_port
        = egress_xq_min_reserve_lossy_ports
          * num_lossy_queues + egress_xq_min_reserve_lossless_uplink_ports
          * num_active_pri_group_lossless;
    shared_xqs_per_uplink_port
          = numxqs_per_uplink_ports - reserved_xqs_per_uplink_port;
    reserved_xqs_per_downlink_port
        = egress_xq_min_reserve_lossy_ports
          * num_lossy_queues + egress_xq_min_reserve_lossless_downlink_ports
          * num_active_pri_group_lossless;
    shared_xqs_per_downlink_port
        = numxqs_per_downlink_ports_and_cpu_port
          - reserved_xqs_per_downlink_port;
    cfapfullthreshold_cfapfullsetpoint_up = cfapfullsetpoint;
    gbllimitsetlimit_gblcellsetlimit_up = total_cell_memory_for_admission;
    totaldyncellsetlimit_totaldyncellsetlimit_up = shared_space_cells;
    holcosminxqcnt_qlayer8_holcosminxqcnt_up = 0;
    holcospktsetlimit0_pktsetlimit_up
        = shared_xqs_per_uplink_port
          + egress_xq_min_reserve_lossy_ports;
    holcospktsetlimit7_pktsetlimit_up
        = shared_xqs_per_uplink_port
          + egress_xq_min_reserve_lossy_ports;
    holcospktsetlimit_qlayer0_pktsetlimit_up
        = shared_xqs_per_uplink_port
          + egress_xq_min_reserve_lossy_ports;
    holcospktsetlimit_qlayer7_pktsetlimit_up
        = shared_xqs_per_uplink_port
          + egress_xq_min_reserve_lossy_ports;
    holcospktsetlimit_qlayer8_pktsetlimit_up
        = shared_xqs_per_uplink_port
          + holcosminxqcnt_qlayer8_holcosminxqcnt_up;
    dynxqcntport_dynxqcntport_up
          = shared_xqs_per_uplink_port - skidmarker - prefetch;
    lwmcoscellsetlimit0_cellsetlimit_up
          = egress_queue_min_reserve_uplink_ports_lossy;
    lwmcoscellsetlimit7_cellsetlimit_up
          = egress_queue_min_reserve_uplink_ports_lossy;
    lwmcoscellsetlimit_qlayer0_cellsetlimit_up
          = egress_queue_min_reserve_uplink_ports_lossy;
    lwmcoscellsetlimit_qlayer7_cellsetlimit_up
          = egress_queue_min_reserve_uplink_ports_lossy;
    lwmcoscellsetlimit_qlayer8_cellsetlimit_up = 0;
    holcoscellmaxlimit0_cellmaxlimit_up
        = ceiling_func(shared_space_cells, queue_port_limit_ratio)
          + lwmcoscellsetlimit0_cellsetlimit_up;
    holcoscellmaxlimit7_cellmaxlimit_up
        = ceiling_func(shared_space_cells, queue_port_limit_ratio)
          + lwmcoscellsetlimit7_cellsetlimit_up;
    holcoscellmaxlimit_qlayer0_cellmaxlimit_up
        = ceiling_func(shared_space_cells, queue_port_limit_ratio)
          + lwmcoscellsetlimit_qlayer0_cellsetlimit_up;
    holcoscellmaxlimit_qlayer7_cellmaxlimit_up
        = ceiling_func(shared_space_cells, queue_port_limit_ratio)
          + lwmcoscellsetlimit_qlayer7_cellsetlimit_up;
    holcoscellmaxlimit_qlayer8_cellmaxlimit_up
        = ceiling_func(shared_space_cells, queue_port_limit_ratio)
          + lwmcoscellsetlimit_qlayer8_cellsetlimit_up;
    dyncelllimit_dyncellsetlimit_up = shared_space_cells;
    holcospktsetlimit_qgroup0_pktsetlimit_up = numxqs_per_uplink_ports - 1;
    holcoscellmaxlimit_qgroup0_cellmaxlimit_up
        = ceiling_func(total_advertised_cell_memory, queue_port_limit_ratio);
    holcosminxqcnt_qlayer8_holcosminxqcnt_down_1 = 0;
    holcospktsetlimit0_pktsetlimit_down_1
        = shared_xqs_per_downlink_port
          + egress_xq_min_reserve_lossy_ports;
    holcospktsetlimit7_pktsetlimit_down_1
        = shared_xqs_per_downlink_port
          + egress_xq_min_reserve_lossy_ports;
    holcospktsetlimit_qlayer0_pktsetlimit_down_1
        = shared_xqs_per_downlink_port
          + egress_xq_min_reserve_lossy_ports;
    holcospktsetlimit_qlayer7_pktsetlimit_down_1
        = shared_xqs_per_downlink_port
          + egress_xq_min_reserve_lossy_ports;
    holcospktsetlimit_qlayer8_pktsetlimit_down_1
        = shared_xqs_per_downlink_port
          + holcosminxqcnt_qlayer8_holcosminxqcnt_down_1;
    dynxqcntport_dynxqcntport_down_1
          = shared_xqs_per_downlink_port - skidmarker - prefetch;
    lwmcoscellsetlimit0_cellsetlimit_down_1 =
              egress_queue_min_reserve_downlink_ports_lossy;
    lwmcoscellsetlimit7_cellsetlimit_down_1 =
              egress_queue_min_reserve_downlink_ports_lossy;
    lwmcoscellsetlimit_qlayer0_cellsetlimit_down_1 =
              egress_queue_min_reserve_downlink_ports_lossy;
    lwmcoscellsetlimit_qlayer7_cellsetlimit_down_1 =
              egress_queue_min_reserve_downlink_ports_lossy;
    lwmcoscellsetlimit_qlayer8_cellsetlimit_down_1 = 0;
    holcoscellmaxlimit0_cellmaxlimit_down_1
        = ceiling_func(shared_space_cells, queue_port_limit_ratio)
          + lwmcoscellsetlimit0_cellsetlimit_down_1;
    holcoscellmaxlimit7_cellmaxlimit_down_1
        = ceiling_func(shared_space_cells, queue_port_limit_ratio)
          + lwmcoscellsetlimit7_cellsetlimit_down_1;
    holcoscellmaxlimit_qlayer0_cellmaxlimit_down_1
        = ceiling_func(shared_space_cells, queue_port_limit_ratio)
          + lwmcoscellsetlimit_qlayer0_cellsetlimit_down_1;
    holcoscellmaxlimit_qlayer7_cellmaxlimit_down_1
        = ceiling_func(shared_space_cells, queue_port_limit_ratio)
          + lwmcoscellsetlimit_qlayer7_cellsetlimit_down_1;
    holcoscellmaxlimit_qlayer8_cellmaxlimit_down_1
        = ceiling_func(shared_space_cells, queue_port_limit_ratio)
          + lwmcoscellsetlimit_qlayer8_cellsetlimit_down_1;
    dyncelllimit_dyncellsetlimit_down_1 = shared_space_cells;
    holcospktsetlimit_qgroup0_pktsetlimit_down_1
          = numxqs_per_downlink_ports_and_cpu_port - 1;
    holcoscellmaxlimit_qgroup0_cellmaxlimit_down_1
        = ceiling_func(total_advertised_cell_memory, queue_port_limit_ratio);
    holcospktsetlimit0_pktsetlimit_down_2dot5
        = shared_xqs_per_downlink_port
          + egress_xq_min_reserve_lossy_ports;
    holcospktsetlimit7_pktsetlimit_down_2dot5
        = shared_xqs_per_downlink_port
          + egress_xq_min_reserve_lossy_ports;
    holcospktsetlimit_qlayer0_pktsetlimit_down_2dot5
        = shared_xqs_per_downlink_port
          + egress_xq_min_reserve_lossy_ports;
    holcospktsetlimit_qlayer7_pktsetlimit_down_2dot5
        = shared_xqs_per_downlink_port
          + egress_xq_min_reserve_lossy_ports;
    holcospktsetlimit_qlayer8_pktsetlimit_down_2dot5
        = shared_xqs_per_downlink_port
          + holcosminxqcnt_qlayer8_holcosminxqcnt_down_1;
    dynxqcntport_dynxqcntport_down_2dot5
          = shared_xqs_per_downlink_port - skidmarker - prefetch;
    lwmcoscellsetlimit0_cellsetlimit_down_2dot5 =
              egress_queue_min_reserve_downlink_ports_lossy;
    lwmcoscellsetlimit7_cellsetlimit_down_2dot5 =
              egress_queue_min_reserve_downlink_ports_lossy;
    lwmcoscellsetlimit_qlayer0_cellsetlimit_down_2dot5 =
              egress_queue_min_reserve_downlink_ports_lossy;
    lwmcoscellsetlimit_qlayer7_cellsetlimit_down_2dot5 =
              egress_queue_min_reserve_downlink_ports_lossy;
    lwmcoscellsetlimit_qlayer8_cellsetlimit_down_2dot5 = 0;
    holcoscellmaxlimit0_cellmaxlimit_down_2dot5
        = ceiling_func(shared_space_cells, queue_port_limit_ratio)
          + lwmcoscellsetlimit0_cellsetlimit_down_2dot5;
    holcoscellmaxlimit7_cellmaxlimit_down_2dot5
        = ceiling_func(shared_space_cells, queue_port_limit_ratio)
          + lwmcoscellsetlimit7_cellsetlimit_down_2dot5;
    holcoscellmaxlimit_qlayer0_cellmaxlimit_down_2dot5
        = ceiling_func(shared_space_cells, queue_port_limit_ratio)
          + lwmcoscellsetlimit_qlayer0_cellsetlimit_down_2dot5;
    holcoscellmaxlimit_qlayer7_cellmaxlimit_down_2dot5
        = ceiling_func(shared_space_cells, queue_port_limit_ratio)
          + lwmcoscellsetlimit_qlayer7_cellsetlimit_down_2dot5;
    holcoscellmaxlimit_qlayer8_cellmaxlimit_down_2dot5
        = ceiling_func(shared_space_cells, queue_port_limit_ratio)
          + lwmcoscellsetlimit_qlayer8_cellsetlimit_down_2dot5;
    dyncelllimit_dyncellsetlimit_down_2dot5 = shared_space_cells;
    holcospktsetlimit_qgroup0_pktsetlimit_down_2dot5
          = numxqs_per_downlink_ports_and_cpu_port - 1;
    holcoscellmaxlimit_qgroup0_cellmaxlimit_down_2dot5
        = ceiling_func(total_advertised_cell_memory, queue_port_limit_ratio);
    holcosminxqcnt0_holcosminxqcnt_cpu = egress_queue_min_reserve_cpu_ports;
    holcosminxqcnt7_holcosminxqcnt_cpu = egress_queue_min_reserve_cpu_ports;
    holcospktsetlimit0_pktsetlimit_cpu =
              shared_xqs_per_downlink_port + holcosminxqcnt0_holcosminxqcnt_cpu;
    holcospktsetlimit7_pktsetlimit_cpu =
              shared_xqs_per_downlink_port + holcosminxqcnt7_holcosminxqcnt_cpu;
    dynxqcntport_dynxqcntport_cpu =
              shared_xqs_per_downlink_port - skidmarker - prefetch;
    lwmcoscellsetlimit0_cellsetlimit_cpu = egress_queue_min_reserve_cpu_ports;
    lwmcoscellsetlimit7_cellsetlimit_cpu = egress_queue_min_reserve_cpu_ports;
    holcoscellmaxlimit0_cellmaxlimit_cpu =
              ceiling_func(shared_space_cells, queue_port_limit_ratio) +
              lwmcoscellsetlimit0_cellsetlimit_cpu;
    holcoscellmaxlimit7_cellmaxlimit_cpu =
              ceiling_func(shared_space_cells, queue_port_limit_ratio) +
              lwmcoscellsetlimit7_cellsetlimit_cpu;
    dyncelllimit_dyncellsetlimit_cpu = shared_space_cells;

    if ((shared_space_cells * cell_size)/1024 <= 800) {
        LOG_CLI((BSL_META_U(unit,
                 "Shared Pool Is Small,\
                 should be larger than 800 (value=%d)\n"),
                 (shared_space_cells * cell_size)/1024));
        return SOC_E_PARAM;
    }

    /* system-based */
    soc_reg_field32_modify(unit, CFAPFULLTHRESHOLDr,
                           REG_PORT_ANY,
                           CFAPFULLSETPOINTf,
                           cfapfullsetpoint);
    soc_reg_field32_modify(unit, CFAPFULLTHRESHOLDr,
                           REG_PORT_ANY,
                           CFAPFULLRESETPOINTf,
                           cfapfullthreshold_cfapfullsetpoint_up -
                           (standard_jumbo_frame_cell * 2));
    soc_reg_field32_modify(unit, GBLLIMITSETLIMITr,
                           REG_PORT_ANY,
                           GBLCELLSETLIMITf,
                           total_cell_memory_for_admission);
    soc_reg_field32_modify(unit, GBLLIMITRESETLIMITr,
                           REG_PORT_ANY,
                           GBLCELLRESETLIMITf,
                           gbllimitsetlimit_gblcellsetlimit_up);
    soc_reg_field32_modify(unit, TOTALDYNCELLSETLIMITr,
                           REG_PORT_ANY,
                           TOTALDYNCELLSETLIMITf,
                           shared_space_cells);
    soc_reg_field32_modify(unit, TOTALDYNCELLRESETLIMITr,
                           REG_PORT_ANY,
                           TOTALDYNCELLRESETLIMITf,
                           totaldyncellsetlimit_totaldyncellsetlimit_up -
                           (standard_jumbo_frame_cell * 2));
    soc_reg_field32_modify(unit, TWO_LAYER_SCH_MODEr,
                           REG_PORT_ANY,
                           SCH_MODEf,
                           0);
    soc_reg_field32_modify(unit, MISCCONFIGr,
                           REG_PORT_ANY,
                           MULTIPLE_ACCOUNTING_FIX_ENf,
                           1);
    soc_reg_field32_modify(unit, MISCCONFIGr,
                           REG_PORT_ANY,
                           CNG_DROP_ENf,
                           0);
    soc_reg_field32_modify(unit, MISCCONFIGr,
                           REG_PORT_ANY,
                           DYN_XQ_ENf,
                           1);
    soc_reg_field32_modify(unit, MISCCONFIGr,
                           REG_PORT_ANY,
                           HOL_CELL_SOP_DROP_ENf,
                           1);
    soc_reg_field32_modify(unit, MISCCONFIGr,
                           REG_PORT_ANY,
                           DYNAMIC_MEMORY_ENf,
                           1);
    soc_reg_field32_modify(unit, MISCCONFIGr,
                           REG_PORT_ANY,
                           SKIDMARKERf,
                           3);
    soc_reg_field32_modify(unit, MMUPORTTXENABLE_0r,
                           REG_PORT_ANY,
                           MMUPORTTXENABLEf,
                           0xFFFFFFFF);
    soc_reg_field32_modify(unit, MMUPORTTXENABLE_1r,
                           REG_PORT_ANY,
                           MMUPORTTXENABLEf,
                           0xFFFFFFFF);
    soc_reg_field32_modify(unit, MMUPORTTXENABLE_2r,
                           REG_PORT_ANY,
                           MMUPORTTXENABLEf,
                           3);

    /* port-based : uplink */
    SOC_PBMP_ITER(pbmp_uplink, port) {
        /* PG_CTRL0r, index 0 */
        soc_reg32_get(unit, PG_CTRL0r,
                      port, 0, &rval);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PPFC_PG_ENf,
                          0);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI0_GRPf,
                          0);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI1_GRPf,
                          1);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI2_GRPf,
                          2);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI3_GRPf,
                          3);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI4_GRPf,
                          4);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI5_GRPf,
                          5);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI6_GRPf,
                          6);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI7_GRPf,
                          7);
        soc_reg32_set(unit, PG_CTRL0r,
                      port, 0, rval);

        /* PG_CTRL1r, index 0 */
        soc_reg32_get(unit, PG_CTRL1r,
                      port, 0, &rval);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI8_GRPf,
                          7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI9_GRPf,
                          7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI10_GRPf,
                          7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI11_GRPf,
                          7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI12_GRPf,
                          7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI13_GRPf,
                          7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI14_GRPf,
                          7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI15_GRPf,
                          7);
        soc_reg32_set(unit, PG_CTRL1r,
                      port, 0, rval);

        /* PG2TCr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, PG2TCr,
                          port, index, &rval);
            soc_reg_field_set(unit, PG2TCr, &rval,
                              PG_BMPf,
                              0);
            soc_reg32_set(unit, PG2TCr,
                          port, index, rval);
        }

        /* IBPPKTSETLIMITr, index 0 */
        soc_reg32_get(unit, IBPPKTSETLIMITr,
                      port, 0, &rval);
        soc_reg_field_set(unit, IBPPKTSETLIMITr, &rval,
                          PKTSETLIMITf,
                          xoff_packet_thresholds_per_port_uplink_port);
        soc_reg_field_set(unit, IBPPKTSETLIMITr, &rval,
                          RESETLIMITSELf,
                          3);
        soc_reg32_set(unit, IBPPKTSETLIMITr,
                      port, 0, rval);

        /* MMU_FC_RX_ENr, index 0 */
        soc_reg32_get(unit, MMU_FC_RX_ENr,
                      port, 0, &rval);
        soc_reg_field_set(unit, MMU_FC_RX_ENr, &rval,
                          MMU_FC_RX_ENABLEf,
                          0);
        soc_reg32_set(unit, MMU_FC_RX_ENr,
                      port, 0, rval);

        /* MMU_FC_TX_ENr, index 0 */
        soc_reg32_get(unit, MMU_FC_TX_ENr,
                      port, 0, &rval);
        soc_reg_field_set(unit, MMU_FC_TX_ENr, &rval,
                          MMU_FC_TX_ENABLEf,
                          0);
        soc_reg32_set(unit, MMU_FC_TX_ENr,
                      port, 0, rval);

        /* PGCELLLIMITr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, PGCELLLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, PGCELLLIMITr, &rval,
                              CELLSETLIMITf,
                              xoff_cell_threshold_all_uplink_ports);
            soc_reg32_set(unit, PGCELLLIMITr,
                          port, index, rval);
        }

        /* PGCELLLIMITr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, PGCELLLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, PGCELLLIMITr, &rval,
                              CELLRESETLIMITf,
                              xoff_cell_threshold_all_uplink_ports);
            soc_reg32_set(unit, PGCELLLIMITr,
                          port, index, rval);
        }

        /* PGDISCARDSETLIMITr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, PGDISCARDSETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, PGDISCARDSETLIMITr, &rval,
                              DISCARDSETLIMITf,
                              discard_limit_per_port_pg_downlink_port);
            soc_reg32_set(unit, PGDISCARDSETLIMITr,
                          port, index, rval);
        }

        /* HOLCOSMINXQCNTr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSMINXQCNTr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSMINXQCNTr, &rval,
                              HOLCOSMINXQCNTf,
                              egress_xq_min_reserve_lossy_ports);
            soc_reg32_set(unit, HOLCOSMINXQCNTr,
                          port, index, rval);
        }

        /* HOLCOSMINXQCNT_QLAYERr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSMINXQCNT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSMINXQCNT_QLAYERr, &rval,
                              HOLCOSMINXQCNTf,
                              egress_xq_min_reserve_lossy_ports);
            soc_reg32_set(unit, HOLCOSMINXQCNT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSMINXQCNT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, HOLCOSMINXQCNT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSMINXQCNT_QLAYERr, &rval,
                              HOLCOSMINXQCNTf,
                              0);
            soc_reg32_set(unit, HOLCOSMINXQCNT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSPKTSETLIMITr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSPKTSETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTSETLIMITr, &rval,
                              PKTSETLIMITf,
                              shared_xqs_per_uplink_port +
                              egress_xq_min_reserve_lossy_ports);
            soc_reg32_set(unit, HOLCOSPKTSETLIMITr,
                          port, index, rval);
        }

        /* HOLCOSPKTSETLIMIT_QLAYERr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTSETLIMIT_QLAYERr, &rval,
                              PKTSETLIMITf,
                              shared_xqs_per_uplink_port +
                              egress_xq_min_reserve_lossy_ports);
            soc_reg32_set(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSPKTSETLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTSETLIMIT_QLAYERr, &rval,
                              PKTSETLIMITf,
                              shared_xqs_per_uplink_port +
                              holcosminxqcnt_qlayer8_holcosminxqcnt_up);
            soc_reg32_set(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSPKTRESETLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSPKTRESETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTRESETLIMITr, &rval,
                              PKTRESETLIMITf,
                              holcospktsetlimit0_pktsetlimit_up - 1);
            soc_reg32_set(unit, HOLCOSPKTRESETLIMITr,
                          port, index, rval);
        }

        /* HOLCOSPKTRESETLIMITr, index 7 */
        soc_reg32_get(unit, HOLCOSPKTRESETLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSPKTRESETLIMITr, &rval,
                          PKTRESETLIMITf,
                          holcospktsetlimit7_pktsetlimit_up - 1);
        soc_reg32_set(unit, HOLCOSPKTRESETLIMITr,
                      port, 7, rval);

        /* HOLCOSPKTRESETLIMIT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr, &rval,
                              PKTRESETLIMITf,
                              holcospktsetlimit_qlayer0_pktsetlimit_up - 1);
            soc_reg32_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSPKTRESETLIMIT_QLAYERr, index 7 */
        soc_reg32_get(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr, &rval,
                          PKTRESETLIMITf,
                          holcospktsetlimit_qlayer7_pktsetlimit_up - 1);
        soc_reg32_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                      port, 7, rval);

        /* HOLCOSPKTRESETLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr, &rval,
                              PKTRESETLIMITf,
                              holcospktsetlimit_qlayer8_pktsetlimit_up - 1);
            soc_reg32_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT0r, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT0r,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT0r, &rval,
                              CNGPKTSETLIMIT0f,
                              numxqs_per_uplink_ports - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT0r,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT1r, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT1r,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT1r, &rval,
                              CNGPKTSETLIMIT1f,
                              numxqs_per_uplink_ports - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT1r,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT0_QLAYERr, index 0 ~ 63 */
        for (index = 0; index <= 63; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT0_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT0_QLAYERr, &rval,
                              CNGPKTSETLIMIT0f,
                              numxqs_per_uplink_ports - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT0_QLAYERr,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT1_QLAYERr, index 0 ~ 63 */
        for (index = 0; index <= 63; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT1_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT1_QLAYERr, &rval,
                              CNGPKTSETLIMIT1f,
                              numxqs_per_uplink_ports - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT1_QLAYERr,
                          port, index, rval);
        }

        /* CNGPORTPKTLIMIT0r, index 0 */
        soc_reg32_get(unit, CNGPORTPKTLIMIT0r,
                      port, 0, &rval);
        soc_reg_field_set(unit, CNGPORTPKTLIMIT0r, &rval,
                          CNGPORTPKTLIMIT0f,
                          numxqs_per_uplink_ports - 1);
        soc_reg32_set(unit, CNGPORTPKTLIMIT0r,
                      port, 0, rval);

        /* CNGPORTPKTLIMIT1r, index 0 */
        soc_reg32_get(unit, CNGPORTPKTLIMIT1r,
                      port, 0, &rval);
        soc_reg_field_set(unit, CNGPORTPKTLIMIT1r, &rval,
                          CNGPORTPKTLIMIT1f,
                          numxqs_per_uplink_ports - 1);
        soc_reg32_set(unit, CNGPORTPKTLIMIT1r,
                      port, 0, rval);

        /* DYNXQCNTPORTr, index 0 */
        soc_reg32_get(unit, DYNXQCNTPORTr,
                      port, 0, &rval);
        soc_reg_field_set(unit, DYNXQCNTPORTr, &rval,
                          DYNXQCNTPORTf,
                          shared_xqs_per_uplink_port - skidmarker - prefetch);
        soc_reg32_set(unit, DYNXQCNTPORTr,
                      port, 0, rval);

        /* DYNRESETLIMPORTr, index 0 */
        soc_reg32_get(unit, DYNRESETLIMPORTr,
                      port, 0, &rval);
        soc_reg_field_set(unit, DYNRESETLIMPORTr, &rval,
                          DYNRESETLIMPORTf,
                          dynxqcntport_dynxqcntport_up - 2);
        soc_reg32_set(unit, DYNRESETLIMPORTr,
                      port, 0, rval);

        /* LWMCOSCELLSETLIMITr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMITr, &rval,
                              CELLSETLIMITf,
                              egress_queue_min_reserve_uplink_ports_lossy);
            soc_reg32_set(unit, LWMCOSCELLSETLIMITr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                              CELLSETLIMITf,
                              egress_queue_min_reserve_uplink_ports_lossy);
            soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                              CELLSETLIMITf,
                              0);
            soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMITr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMITr, &rval,
                              CELLRESETLIMITf,
                              egress_queue_min_reserve_uplink_ports_lossy);
            soc_reg32_set(unit, LWMCOSCELLSETLIMITr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                              CELLRESETLIMITf,
                              egress_queue_min_reserve_uplink_ports_lossy);
            soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                              CELLRESETLIMITf,
                              0);
            soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                              CELLMAXLIMITf,
                              ceiling_func(shared_space_cells,
                                           queue_port_limit_ratio) +
                              lwmcoscellsetlimit0_cellsetlimit_up);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMITr, index 7 */
        soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                          CELLMAXLIMITf,
                          ceiling_func(shared_space_cells,
                                       queue_port_limit_ratio) +
                          lwmcoscellsetlimit7_cellsetlimit_up);
        soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                      port, 7, rval);

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                              CELLMAXLIMITf,
                              ceiling_func(shared_space_cells,
                                           queue_port_limit_ratio) +
                              lwmcoscellsetlimit_qlayer0_cellsetlimit_up);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 7 */
        soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                          CELLMAXLIMITf,
                          ceiling_func(shared_space_cells,
                                       queue_port_limit_ratio) +
                          lwmcoscellsetlimit_qlayer7_cellsetlimit_up);
        soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                      port, 7, rval);

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                              CELLMAXLIMITf,
                              ceiling_func(shared_space_cells,
                                           queue_port_limit_ratio) +
                              lwmcoscellsetlimit_qlayer8_cellsetlimit_up);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                              CELLMAXRESUMELIMITf,
                              holcoscellmaxlimit0_cellmaxlimit_up -
                              ethernet_mtu_cell);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMITr, index 7 */
        soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                          CELLMAXRESUMELIMITf,
                          holcoscellmaxlimit7_cellmaxlimit_up -
                          ethernet_mtu_cell);
        soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                      port, 7, rval);

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                              CELLMAXRESUMELIMITf,
                              holcoscellmaxlimit_qlayer0_cellmaxlimit_up -
                              ethernet_mtu_cell);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 7 */
        soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                          CELLMAXRESUMELIMITf,
                          holcoscellmaxlimit_qlayer7_cellmaxlimit_up -
                          ethernet_mtu_cell);
        soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                      port, 7, rval);

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                              CELLMAXRESUMELIMITf,
                              holcoscellmaxlimit_qlayer8_cellmaxlimit_up -
                              ethernet_mtu_cell);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* DYNCELLLIMITr, index 0 */
        soc_reg32_get(unit, DYNCELLLIMITr,
                      port, 0, &rval);
        soc_reg_field_set(unit, DYNCELLLIMITr, &rval,
                          DYNCELLSETLIMITf,
                          shared_space_cells);
        soc_reg_field_set(unit, DYNCELLLIMITr, &rval,
                          DYNCELLRESETLIMITf,
                          dyncelllimit_dyncellsetlimit_up -
                          (2 * ethernet_mtu_cell));
        soc_reg32_set(unit, DYNCELLLIMITr,
                      port, 0, rval);

        /* COLOR_DROP_ENr, index 0 */
        soc_reg32_get(unit, COLOR_DROP_ENr,
                      port, 0, &rval);
        soc_reg_field_set(unit, COLOR_DROP_ENr, &rval,
                          COLOR_DROP_ENf,
                          0);
        soc_reg32_set(unit, COLOR_DROP_ENr,
                      port, 0, rval);

        /* COLOR_DROP_EN_QLAYERr, index 0 */
        soc_reg32_get(unit, COLOR_DROP_EN_QLAYERr,
                      port, 0, &rval);
        soc_reg_field_set(unit, COLOR_DROP_EN_QLAYERr, &rval,
                          COLOR_DROP_ENf,
                          0);
        soc_reg32_set(unit, COLOR_DROP_EN_QLAYERr,
                      port, 0, rval);

        /* HOLCOSPKTSETLIMIT_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSPKTSETLIMIT_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTSETLIMIT_QGROUPr, &rval,
                              PKTSETLIMITf,
                              numxqs_per_uplink_ports - 1);
            soc_reg32_set(unit, HOLCOSPKTSETLIMIT_QGROUPr,
                          port, index, rval);
        }

        /* HOLCOSPKTRESETLIMIT_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSPKTRESETLIMIT_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTRESETLIMIT_QGROUPr, &rval,
                              PKTRESETLIMITf,
                              holcospktsetlimit_qgroup0_pktsetlimit_up - 1);
            soc_reg32_set(unit, HOLCOSPKTRESETLIMIT_QGROUPr,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT0_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT0_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT0_QGROUPr, &rval,
                              CNGPKTSETLIMIT0f,
                              numxqs_per_uplink_ports - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT0_QGROUPr,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT1_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT1_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT1_QGROUPr, &rval,
                              CNGPKTSETLIMIT1f,
                              numxqs_per_uplink_ports - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT1_QGROUPr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMIT_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QGROUPr, &rval,
                              CELLMAXLIMITf,
                              ceiling_func(total_advertised_cell_memory,
                                           queue_port_limit_ratio));
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QGROUPr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMIT_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QGROUPr, &rval,
                              CELLMAXRESUMELIMITf,
                              holcoscellmaxlimit_qgroup0_cellmaxlimit_up -
                              ethernet_mtu_cell);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QGROUPr,
                          port, index, rval);
        }

        /* COLOR_DROP_EN_QGROUPr, index 0 */
        soc_reg32_get(unit, COLOR_DROP_EN_QGROUPr,
                      port, 0, &rval);
        soc_reg_field_set(unit, COLOR_DROP_EN_QGROUPr, &rval,
                          COLOR_DROP_ENf,
                          0);
        soc_reg32_set(unit, COLOR_DROP_EN_QGROUPr,
                      port, 0, rval);

        /* SHARED_POOL_CTRLr, index 0 */
        soc_reg32_get(unit, SHARED_POOL_CTRLr,
                      port, 0, &rval);
        soc_reg_field_set(unit, SHARED_POOL_CTRLr, &rval,
                          DYNAMIC_COS_DROP_ENf,
                          255);
        soc_reg_field_set(unit, SHARED_POOL_CTRLr, &rval,
                          SHARED_POOL_DISCARD_ENf,
                          255);
        soc_reg_field_set(unit, SHARED_POOL_CTRLr, &rval,
                          SHARED_POOL_XOFF_ENf,
                          0);
        soc_reg32_set(unit, SHARED_POOL_CTRLr,
                      port, 0, rval);

        /* SHARED_POOL_CTRL_EXT1r, index 0 */
        soc_reg32_get(unit, SHARED_POOL_CTRL_EXT1r,
                      port, 0, &rval);
        soc_reg_field_set(unit, SHARED_POOL_CTRL_EXT1r, &rval,
                          DYNAMIC_COS_DROP_ENf,
                          0xFFFFFF);
        soc_reg32_set(unit, SHARED_POOL_CTRL_EXT1r,
                      port, 0, rval);

        /* SHARED_POOL_CTRL_EXT2r, index 0 */
        soc_reg32_get(unit, SHARED_POOL_CTRL_EXT2r,
                      port, 0, &rval);
        soc_reg_field_set(unit, SHARED_POOL_CTRL_EXT2r, &rval,
                          DYNAMIC_COS_DROP_ENf,
                          0xFFFFFFFF);
        soc_reg32_set(unit, SHARED_POOL_CTRL_EXT2r,
                      port, 0, rval);
    }

    /* port-based : downlink 1G */
    SOC_PBMP_ITER(pbmp_downlink_1g, port) {
        /* PG_CTRL0r, index 0 */
        soc_reg32_get(unit, PG_CTRL0r,
                      port, 0, &rval);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PPFC_PG_ENf,
                          0);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI0_GRPf,
                          0);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI1_GRPf,
                          1);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI2_GRPf,
                          2);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI3_GRPf,
                          3);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI4_GRPf,
                          4);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI5_GRPf,
                          5);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI6_GRPf,
                          6);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI7_GRPf,
                          7);
        soc_reg32_set(unit, PG_CTRL0r,
                      port, 0, rval);

        /* PG_CTRL1r, index 0 */
        soc_reg32_get(unit, PG_CTRL1r,
                      port, 0, &rval);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI8_GRPf,
                          7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI9_GRPf,
                          7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI10_GRPf,
                          7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI11_GRPf,
                          7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI12_GRPf,
                          7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI13_GRPf,
                          7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI14_GRPf,
                          7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI15_GRPf,
                          7);
        soc_reg32_set(unit, PG_CTRL1r,
                      port, 0, rval);

        /* PG2TCr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, PG2TCr,
                          port, index, &rval);
            soc_reg_field_set(unit, PG2TCr, &rval,
                              PG_BMPf,
                              0);
            soc_reg32_set(unit, PG2TCr,
                          port, index, rval);
        }

        /* IBPPKTSETLIMITr, index 0 */
        soc_reg32_get(unit, IBPPKTSETLIMITr,
                      port, 0, &rval);
        soc_reg_field_set(unit, IBPPKTSETLIMITr, &rval,
                          PKTSETLIMITf,
                          xoff_packet_thresholds_per_port_downlink_port);
        soc_reg_field_set(unit, IBPPKTSETLIMITr, &rval,
                          RESETLIMITSELf,
                          3);
        soc_reg32_set(unit, IBPPKTSETLIMITr,
                      port, 0, rval);

        /* MMU_FC_RX_ENr, index 0 */
        soc_reg32_get(unit, MMU_FC_RX_ENr,
                      port, 0, &rval);
        soc_reg_field_set(unit, MMU_FC_RX_ENr, &rval,
                          MMU_FC_RX_ENABLEf,
                          0);
        soc_reg32_set(unit, MMU_FC_RX_ENr,
                      port, 0, rval);

        /* MMU_FC_TX_ENr, index 0 */
        soc_reg32_get(unit, MMU_FC_TX_ENr,
                      port, 0, &rval);
        soc_reg_field_set(unit, MMU_FC_TX_ENr, &rval,
                          MMU_FC_TX_ENABLEf,
                          0);
        soc_reg32_set(unit, MMU_FC_TX_ENr,
                      port, 0, rval);

        /* PGCELLLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, PGCELLLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, PGCELLLIMITr, &rval,
                              CELLSETLIMITf,
                              xoff_cell_threshold_all_uplink_ports);
            soc_reg32_set(unit, PGCELLLIMITr,
                          port, index, rval);
        }

        /* PGCELLLIMITr, index 7 */
        soc_reg32_get(unit, PGCELLLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, PGCELLLIMITr, &rval,
                          CELLSETLIMITf,
                          xoff_cell_thresholds_per_port_1g_port_downlink_ports);
        soc_reg32_set(unit, PGCELLLIMITr,
                      port, 7, rval);

        /* PGCELLLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, PGCELLLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, PGCELLLIMITr, &rval,
                              CELLRESETLIMITf,
                              xoff_cell_threshold_all_uplink_ports);
            soc_reg32_set(unit, PGCELLLIMITr,
                          port, index, rval);
        }

        /* PGCELLLIMITr, index 7 */
        soc_reg32_get(unit, PGCELLLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, PGCELLLIMITr, &rval,
                          CELLRESETLIMITf,
                          xoff_cell_thresholds_per_port_1g_port_downlink_ports);
        soc_reg32_set(unit, PGCELLLIMITr,
                      port, 7, rval);

        /* PGDISCARDSETLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, PGDISCARDSETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, PGDISCARDSETLIMITr, &rval,
                              DISCARDSETLIMITf,
                              discard_limit_per_port_pg_downlink_port);
            soc_reg32_set(unit, PGDISCARDSETLIMITr,
                          port, index, rval);
        }

        /* PGDISCARDSETLIMITr, index 7 */
        soc_reg32_get(unit, PGDISCARDSETLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, PGDISCARDSETLIMITr, &rval,
                          DISCARDSETLIMITf,
                          discard_limit_per_port_pg_uplink_1g_port);
        soc_reg32_set(unit, PGDISCARDSETLIMITr,
                      port, 7, rval);

        /* HOLCOSMINXQCNTr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSMINXQCNTr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSMINXQCNTr, &rval,
                              HOLCOSMINXQCNTf,
                              egress_xq_min_reserve_lossy_ports);
            soc_reg32_set(unit, HOLCOSMINXQCNTr,
                          port, index, rval);
        }

        /* HOLCOSMINXQCNT_QLAYERr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSMINXQCNT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSMINXQCNT_QLAYERr, &rval,
                              HOLCOSMINXQCNTf,
                              egress_xq_min_reserve_lossy_ports);
            soc_reg32_set(unit, HOLCOSMINXQCNT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSMINXQCNT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, HOLCOSMINXQCNT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSMINXQCNT_QLAYERr, &rval,
                              HOLCOSMINXQCNTf,
                              0);
            soc_reg32_set(unit, HOLCOSMINXQCNT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSPKTSETLIMITr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSPKTSETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTSETLIMITr, &rval,
                              PKTSETLIMITf,
                              shared_xqs_per_downlink_port +
                              egress_xq_min_reserve_lossy_ports);
            soc_reg32_set(unit, HOLCOSPKTSETLIMITr,
                          port, index, rval);
        }

        /* HOLCOSPKTSETLIMIT_QLAYERr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTSETLIMIT_QLAYERr, &rval,
                              PKTSETLIMITf,
                              shared_xqs_per_downlink_port +
                              egress_xq_min_reserve_lossy_ports);
            soc_reg32_set(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSPKTSETLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTSETLIMIT_QLAYERr, &rval,
                              PKTSETLIMITf,
                              shared_xqs_per_downlink_port +
                              holcosminxqcnt_qlayer8_holcosminxqcnt_down_1);
            soc_reg32_set(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSPKTRESETLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSPKTRESETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTRESETLIMITr, &rval,
                              PKTRESETLIMITf,
                              holcospktsetlimit0_pktsetlimit_down_1 - 1);
            soc_reg32_set(unit, HOLCOSPKTRESETLIMITr,
                          port, index, rval);
        }

        /* HOLCOSPKTRESETLIMITr, index 7 */
        soc_reg32_get(unit, HOLCOSPKTRESETLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSPKTRESETLIMITr, &rval,
                          PKTRESETLIMITf,
                          holcospktsetlimit7_pktsetlimit_down_1 - 1);
        soc_reg32_set(unit, HOLCOSPKTRESETLIMITr,
                      port, 7, rval);

        /* HOLCOSPKTRESETLIMIT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr, &rval,
                              PKTRESETLIMITf,
                              holcospktsetlimit_qlayer0_pktsetlimit_down_1 - 1);
            soc_reg32_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSPKTRESETLIMIT_QLAYERr, index 7 */
        soc_reg32_get(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr, &rval,
                          PKTRESETLIMITf,
                          holcospktsetlimit_qlayer7_pktsetlimit_down_1 - 1);
        soc_reg32_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                      port, 7, rval);

        /* HOLCOSPKTRESETLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr, &rval,
                              PKTRESETLIMITf,
                              holcospktsetlimit_qlayer8_pktsetlimit_down_1 - 1);
            soc_reg32_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT0r, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT0r,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT0r, &rval,
                              CNGPKTSETLIMIT0f,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT0r,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT1r, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT1r,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT1r, &rval,
                              CNGPKTSETLIMIT1f,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT1r,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT0_QLAYERr, index 0 ~ 63 */
        for (index = 0; index <= 63; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT0_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT0_QLAYERr, &rval,
                              CNGPKTSETLIMIT0f,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT0_QLAYERr,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT1_QLAYERr, index 0 ~ 63 */
        for (index = 0; index <= 63; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT1_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT1_QLAYERr, &rval,
                              CNGPKTSETLIMIT1f,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT1_QLAYERr,
                          port, index, rval);
        }

        /* CNGPORTPKTLIMIT0r, index 0 */
        soc_reg32_get(unit, CNGPORTPKTLIMIT0r,
                      port, 0, &rval);
        soc_reg_field_set(unit, CNGPORTPKTLIMIT0r, &rval,
                          CNGPORTPKTLIMIT0f,
                          numxqs_per_downlink_ports_and_cpu_port - 1);
        soc_reg32_set(unit, CNGPORTPKTLIMIT0r,
                      port, 0, rval);

        /* CNGPORTPKTLIMIT1r, index 0 */
        soc_reg32_get(unit, CNGPORTPKTLIMIT1r,
                      port, 0, &rval);
        soc_reg_field_set(unit, CNGPORTPKTLIMIT1r, &rval,
                          CNGPORTPKTLIMIT1f,
                          numxqs_per_downlink_ports_and_cpu_port - 1);
        soc_reg32_set(unit, CNGPORTPKTLIMIT1r,
                      port, 0, rval);

        /* DYNXQCNTPORTr, index 0 */
        soc_reg32_get(unit, DYNXQCNTPORTr,
                      port, 0, &rval);
        soc_reg_field_set(unit, DYNXQCNTPORTr, &rval,
                          DYNXQCNTPORTf,
                          shared_xqs_per_downlink_port - skidmarker - prefetch);
        soc_reg32_set(unit, DYNXQCNTPORTr,
                      port, 0, rval);

        /* DYNRESETLIMPORTr, index 0 */
        soc_reg32_get(unit, DYNRESETLIMPORTr,
                      port, 0, &rval);
        soc_reg_field_set(unit, DYNRESETLIMPORTr, &rval,
                          DYNRESETLIMPORTf,
                          dynxqcntport_dynxqcntport_down_1 - 2);
        soc_reg32_set(unit, DYNRESETLIMPORTr,
                      port, 0, rval);

        /* LWMCOSCELLSETLIMITr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMITr, &rval,
                              CELLSETLIMITf,
                              egress_queue_min_reserve_downlink_ports_lossy);
            soc_reg32_set(unit, LWMCOSCELLSETLIMITr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                              CELLSETLIMITf,
                              egress_queue_min_reserve_downlink_ports_lossy);
            soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                              CELLSETLIMITf,
                              0);
            soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMITr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMITr, &rval,
                              CELLRESETLIMITf,
                              egress_queue_min_reserve_downlink_ports_lossy);
            soc_reg32_set(unit, LWMCOSCELLSETLIMITr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                              CELLRESETLIMITf,
                              egress_queue_min_reserve_downlink_ports_lossy);
            soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                              CELLRESETLIMITf,
                              0);
            soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                              CELLMAXLIMITf,
                              ceiling_func(shared_space_cells,
                                           queue_port_limit_ratio) +
                              lwmcoscellsetlimit0_cellsetlimit_down_1);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMITr, index 7 */
        soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                          CELLMAXLIMITf,
                          ceiling_func(shared_space_cells,
                                       queue_port_limit_ratio) +
                          lwmcoscellsetlimit7_cellsetlimit_down_1);
        soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                      port, 7, rval);

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                              CELLMAXLIMITf,
                              ceiling_func(shared_space_cells,
                                           queue_port_limit_ratio) +
                              lwmcoscellsetlimit_qlayer0_cellsetlimit_down_1);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 7 */
        soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                          CELLMAXLIMITf,
                          ceiling_func(shared_space_cells,
                                       queue_port_limit_ratio) +
                          lwmcoscellsetlimit_qlayer7_cellsetlimit_down_1);
        soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                      port, 7, rval);

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                              CELLMAXLIMITf,
                              ceiling_func(shared_space_cells,
                                           queue_port_limit_ratio) +
                              lwmcoscellsetlimit_qlayer8_cellsetlimit_down_1);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                              CELLMAXRESUMELIMITf,
                              holcoscellmaxlimit0_cellmaxlimit_down_1 -
                              ethernet_mtu_cell);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMITr, index 7 */
        soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                          CELLMAXRESUMELIMITf,
                          holcoscellmaxlimit7_cellmaxlimit_down_1 -
                          ethernet_mtu_cell);
        soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                      port, 7, rval);

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                              CELLMAXRESUMELIMITf,
                              holcoscellmaxlimit_qlayer0_cellmaxlimit_down_1 -
                              ethernet_mtu_cell);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 7 */
        soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                          CELLMAXRESUMELIMITf,
                          holcoscellmaxlimit_qlayer7_cellmaxlimit_down_1 -
                          ethernet_mtu_cell);
        soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                      port, 7, rval);

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                              CELLMAXRESUMELIMITf,
                              holcoscellmaxlimit_qlayer8_cellmaxlimit_down_1 -
                              ethernet_mtu_cell);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* DYNCELLLIMITr, index 0 */
        soc_reg32_get(unit, DYNCELLLIMITr,
                      port, 0, &rval);
        soc_reg_field_set(unit, DYNCELLLIMITr, &rval,
                          DYNCELLSETLIMITf,
                          shared_space_cells);
        soc_reg_field_set(unit, DYNCELLLIMITr, &rval,
                          DYNCELLRESETLIMITf,
                          dyncelllimit_dyncellsetlimit_down_1 -
                          (ethernet_mtu_cell * 2));
        soc_reg32_set(unit, DYNCELLLIMITr,
                      port, 0, rval);

        /* COLOR_DROP_ENr, index 0 */
        soc_reg32_get(unit, COLOR_DROP_ENr,
                      port, 0, &rval);
        soc_reg_field_set(unit, COLOR_DROP_ENr, &rval,
                          COLOR_DROP_ENf,
                          0);
        soc_reg32_set(unit, COLOR_DROP_ENr,
                      port, 0, rval);

        /* COLOR_DROP_EN_QLAYERr, index 0 */
        soc_reg32_get(unit, COLOR_DROP_EN_QLAYERr,
                      port, 0, &rval);
        soc_reg_field_set(unit, COLOR_DROP_EN_QLAYERr, &rval,
                          COLOR_DROP_ENf,
                          0);
        soc_reg32_set(unit, COLOR_DROP_EN_QLAYERr,
                      port, 0, rval);

        /* HOLCOSPKTSETLIMIT_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSPKTSETLIMIT_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTSETLIMIT_QGROUPr, &rval,
                              PKTSETLIMITf,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, HOLCOSPKTSETLIMIT_QGROUPr,
                          port, index, rval);
        }

        /* HOLCOSPKTRESETLIMIT_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSPKTRESETLIMIT_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTRESETLIMIT_QGROUPr, &rval,
                              PKTRESETLIMITf,
                              holcospktsetlimit_qgroup0_pktsetlimit_down_1 - 1);
            soc_reg32_set(unit, HOLCOSPKTRESETLIMIT_QGROUPr,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT0_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT0_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT0_QGROUPr, &rval,
                              CNGPKTSETLIMIT0f,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT0_QGROUPr,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT1_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT1_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT1_QGROUPr, &rval,
                              CNGPKTSETLIMIT1f,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT1_QGROUPr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMIT_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QGROUPr, &rval,
                              CELLMAXLIMITf,
                              ceiling_func(total_advertised_cell_memory,
                                           queue_port_limit_ratio));
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QGROUPr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMIT_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QGROUPr, &rval,
                              CELLMAXRESUMELIMITf,
                              holcoscellmaxlimit_qgroup0_cellmaxlimit_down_1 -
                              ethernet_mtu_cell);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QGROUPr,
                          port, index, rval);
        }

        /* COLOR_DROP_EN_QGROUPr, index 0 */
        soc_reg32_get(unit, COLOR_DROP_EN_QGROUPr,
                      port, 0, &rval);
        soc_reg_field_set(unit, COLOR_DROP_EN_QGROUPr, &rval,
                          COLOR_DROP_ENf,
                          0);
        soc_reg32_set(unit, COLOR_DROP_EN_QGROUPr,
                      port, 0, rval);

        /* SHARED_POOL_CTRLr, index 0 */
        soc_reg32_get(unit, SHARED_POOL_CTRLr,
                      port, 0, &rval);
        soc_reg_field_set(unit, SHARED_POOL_CTRLr, &rval,
                          DYNAMIC_COS_DROP_ENf,
                          255);
        soc_reg_field_set(unit, SHARED_POOL_CTRLr, &rval,
                          SHARED_POOL_DISCARD_ENf,
                          255);
        soc_reg_field_set(unit, SHARED_POOL_CTRLr, &rval,
                          SHARED_POOL_XOFF_ENf,
                          0);
        soc_reg32_set(unit, SHARED_POOL_CTRLr,
                      port, 0, rval);

        /* SHARED_POOL_CTRL_EXT1r, index 0 */
        soc_reg32_get(unit, SHARED_POOL_CTRL_EXT1r,
                      port, 0, &rval);
        soc_reg_field_set(unit, SHARED_POOL_CTRL_EXT1r, &rval,
                          DYNAMIC_COS_DROP_ENf,
                          0xFFFFFF);
        soc_reg32_set(unit, SHARED_POOL_CTRL_EXT1r,
                      port, 0, rval);

        /* SHARED_POOL_CTRL_EXT2r, index 0 */
        soc_reg32_get(unit, SHARED_POOL_CTRL_EXT2r,
                      port, 0, &rval);
        soc_reg_field_set(unit, SHARED_POOL_CTRL_EXT2r, &rval,
                          DYNAMIC_COS_DROP_ENf,
                          0xFFFFFFFF);
        soc_reg32_set(unit, SHARED_POOL_CTRL_EXT2r,
                      port, 0, rval);
    }

    /* port-based : downlink 2.5G */
    SOC_PBMP_ITER(pbmp_downlink_2dot5g, port) {
        /* PG_CTRL0r, index 0 */
        soc_reg32_get(unit, PG_CTRL0r,
                      port, 0, &rval);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PPFC_PG_ENf,
                          0);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI0_GRPf,
                          0);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI1_GRPf,
                          1);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI2_GRPf,
                          2);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI3_GRPf,
                          3);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI4_GRPf,
                          4);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI5_GRPf,
                          5);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI6_GRPf,
                          6);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI7_GRPf,
                          7);
        soc_reg32_set(unit, PG_CTRL0r,
                      port, 0, rval);

        /* PG_CTRL1r, index 0 */
        soc_reg32_get(unit, PG_CTRL1r,
                      port, 0, &rval);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI8_GRPf,
                          7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI9_GRPf,
                          7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI10_GRPf,
                          7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI11_GRPf,
                          7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI12_GRPf,
                          7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI13_GRPf,
                          7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI14_GRPf,
                          7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI15_GRPf,
                          7);
        soc_reg32_set(unit, PG_CTRL1r,
                      port, 0, rval);

        /* PG2TCr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, PG2TCr,
                          port, index, &rval);
            soc_reg_field_set(unit, PG2TCr, &rval,
                              PG_BMPf,
                              0);
            soc_reg32_set(unit, PG2TCr,
                          port, index, rval);
        }

        /* IBPPKTSETLIMITr, index 0 */
        soc_reg32_get(unit, IBPPKTSETLIMITr,
                      port, 0, &rval);
        soc_reg_field_set(unit, IBPPKTSETLIMITr, &rval,
                          PKTSETLIMITf,
                          xoff_packet_thresholds_per_port_downlink_port);
        soc_reg_field_set(unit, IBPPKTSETLIMITr, &rval,
                          RESETLIMITSELf,
                          3);
        soc_reg32_set(unit, IBPPKTSETLIMITr,
                      port, 0, rval);

        /* MMU_FC_RX_ENr, index 0 */
        soc_reg32_get(unit, MMU_FC_RX_ENr,
                      port, 0, &rval);
        soc_reg_field_set(unit, MMU_FC_RX_ENr, &rval,
                          MMU_FC_RX_ENABLEf,
                          0);
        soc_reg32_set(unit, MMU_FC_RX_ENr,
                      port, 0, rval);

        /* MMU_FC_TX_ENr, index 0 */
        soc_reg32_get(unit, MMU_FC_TX_ENr,
                      port, 0, &rval);
        soc_reg_field_set(unit, MMU_FC_TX_ENr, &rval,
                          MMU_FC_TX_ENABLEf,
                          0);
        soc_reg32_set(unit, MMU_FC_TX_ENr,
                      port, 0, rval);

        /* PGCELLLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, PGCELLLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, PGCELLLIMITr, &rval,
                              CELLSETLIMITf,
                              xoff_cell_threshold_all_uplink_ports);
            soc_reg32_set(unit, PGCELLLIMITr,
                          port, index, rval);
        }

        /* PGCELLLIMITr, index 7 */
        soc_reg32_get(unit, PGCELLLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, PGCELLLIMITr, &rval,
                          CELLSETLIMITf,
                          xoff_cell_thresholds_per_port_2dot5g_downlink_ports);
        soc_reg32_set(unit, PGCELLLIMITr,
                      port, 7, rval);

        /* PGCELLLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, PGCELLLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, PGCELLLIMITr, &rval,
                              CELLRESETLIMITf,
                              xoff_cell_threshold_all_uplink_ports);
            soc_reg32_set(unit, PGCELLLIMITr,
                          port, index, rval);
        }

        /* PGCELLLIMITr, index 7 */
        soc_reg32_get(unit, PGCELLLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, PGCELLLIMITr, &rval,
                          CELLRESETLIMITf,
                          xoff_cell_thresholds_per_port_2dot5g_downlink_ports);
        soc_reg32_set(unit, PGCELLLIMITr,
                      port, 7, rval);

        /* PGDISCARDSETLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, PGDISCARDSETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, PGDISCARDSETLIMITr, &rval,
                              DISCARDSETLIMITf,
                              discard_limit_per_port_pg_downlink_port);
            soc_reg32_set(unit, PGDISCARDSETLIMITr,
                          port, index, rval);
        }

        /* PGDISCARDSETLIMITr, index 7 */
        soc_reg32_get(unit, PGDISCARDSETLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, PGDISCARDSETLIMITr, &rval,
                          DISCARDSETLIMITf,
                          discard_limit_per_port_pg_uplink_2dot5g_port);
        soc_reg32_set(unit, PGDISCARDSETLIMITr,
                      port, 7, rval);

        /* HOLCOSMINXQCNTr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSMINXQCNTr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSMINXQCNTr, &rval,
                              HOLCOSMINXQCNTf,
                              egress_xq_min_reserve_lossy_ports);
            soc_reg32_set(unit, HOLCOSMINXQCNTr,
                          port, index, rval);
        }

        /* HOLCOSMINXQCNT_QLAYERr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSMINXQCNT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSMINXQCNT_QLAYERr, &rval,
                              HOLCOSMINXQCNTf,
                              egress_xq_min_reserve_lossy_ports);
            soc_reg32_set(unit, HOLCOSMINXQCNT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSMINXQCNT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, HOLCOSMINXQCNT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSMINXQCNT_QLAYERr, &rval,
                              HOLCOSMINXQCNTf,
                              0);
            soc_reg32_set(unit, HOLCOSMINXQCNT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSPKTSETLIMITr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSPKTSETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTSETLIMITr, &rval,
                              PKTSETLIMITf,
                              shared_xqs_per_downlink_port +
                              egress_xq_min_reserve_lossy_ports);
            soc_reg32_set(unit, HOLCOSPKTSETLIMITr,
                          port, index, rval);
        }

        /* HOLCOSPKTSETLIMIT_QLAYERr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTSETLIMIT_QLAYERr, &rval,
                              PKTSETLIMITf,
                              shared_xqs_per_downlink_port +
                              egress_xq_min_reserve_lossy_ports);
            soc_reg32_set(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSPKTSETLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTSETLIMIT_QLAYERr, &rval,
                              PKTSETLIMITf,
                              shared_xqs_per_downlink_port +
                              holcosminxqcnt_qlayer8_holcosminxqcnt_down_1);
            soc_reg32_set(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSPKTRESETLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSPKTRESETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTRESETLIMITr, &rval,
                              PKTRESETLIMITf,
                              holcospktsetlimit0_pktsetlimit_down_2dot5 - 1);
            soc_reg32_set(unit, HOLCOSPKTRESETLIMITr,
                          port, index, rval);
        }

        /* HOLCOSPKTRESETLIMITr, index 7 */
        soc_reg32_get(unit, HOLCOSPKTRESETLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSPKTRESETLIMITr, &rval,
                          PKTRESETLIMITf,
                          holcospktsetlimit7_pktsetlimit_down_2dot5 - 1);
        soc_reg32_set(unit, HOLCOSPKTRESETLIMITr,
                      port, 7, rval);

        /* HOLCOSPKTRESETLIMIT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr, &rval,
                              PKTRESETLIMITf,
                              holcospktsetlimit_qlayer0_pktsetlimit_down_2dot5
                              - 1);
            soc_reg32_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSPKTRESETLIMIT_QLAYERr, index 7 */
        soc_reg32_get(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr, &rval,
                          PKTRESETLIMITf,
                          holcospktsetlimit_qlayer7_pktsetlimit_down_2dot5 - 1);
        soc_reg32_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                      port, 7, rval);

        /* HOLCOSPKTRESETLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr, &rval,
                              PKTRESETLIMITf,
                              holcospktsetlimit_qlayer8_pktsetlimit_down_2dot5
                              - 1);
            soc_reg32_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT0r, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT0r,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT0r, &rval,
                              CNGPKTSETLIMIT0f,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT0r,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT1r, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT1r,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT1r, &rval,
                              CNGPKTSETLIMIT1f,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT1r,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT0_QLAYERr, index 0 ~ 63 */
        for (index = 0; index <= 63; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT0_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT0_QLAYERr, &rval,
                              CNGPKTSETLIMIT0f,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT0_QLAYERr,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT1_QLAYERr, index 0 ~ 63 */
        for (index = 0; index <= 63; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT1_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT1_QLAYERr, &rval,
                              CNGPKTSETLIMIT1f,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT1_QLAYERr,
                          port, index, rval);
        }

        /* CNGPORTPKTLIMIT0r, index 0 */
        soc_reg32_get(unit, CNGPORTPKTLIMIT0r,
                      port, 0, &rval);
        soc_reg_field_set(unit, CNGPORTPKTLIMIT0r, &rval,
                          CNGPORTPKTLIMIT0f,
                          numxqs_per_downlink_ports_and_cpu_port - 1);
        soc_reg32_set(unit, CNGPORTPKTLIMIT0r,
                      port, 0, rval);

        /* CNGPORTPKTLIMIT1r, index 0 */
        soc_reg32_get(unit, CNGPORTPKTLIMIT1r,
                      port, 0, &rval);
        soc_reg_field_set(unit, CNGPORTPKTLIMIT1r, &rval,
                          CNGPORTPKTLIMIT1f,
                          numxqs_per_downlink_ports_and_cpu_port - 1);
        soc_reg32_set(unit, CNGPORTPKTLIMIT1r,
                      port, 0, rval);

        /* DYNXQCNTPORTr, index 0 */
        soc_reg32_get(unit, DYNXQCNTPORTr,
                      port, 0, &rval);
        soc_reg_field_set(unit, DYNXQCNTPORTr, &rval,
                          DYNXQCNTPORTf,
                          shared_xqs_per_downlink_port - skidmarker - prefetch);
        soc_reg32_set(unit, DYNXQCNTPORTr,
                      port, 0, rval);

        /* DYNRESETLIMPORTr, index 0 */
        soc_reg32_get(unit, DYNRESETLIMPORTr,
                      port, 0, &rval);
        soc_reg_field_set(unit, DYNRESETLIMPORTr, &rval,
                          DYNRESETLIMPORTf,
                          dynxqcntport_dynxqcntport_down_2dot5 - 2);
        soc_reg32_set(unit, DYNRESETLIMPORTr,
                      port, 0, rval);

        /* LWMCOSCELLSETLIMITr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMITr, &rval,
                              CELLSETLIMITf,
                              egress_queue_min_reserve_downlink_ports_lossy);
            soc_reg32_set(unit, LWMCOSCELLSETLIMITr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                              CELLSETLIMITf,
                              egress_queue_min_reserve_downlink_ports_lossy);
            soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                              CELLSETLIMITf,
                              0);
            soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMITr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMITr, &rval,
                              CELLRESETLIMITf,
                              egress_queue_min_reserve_downlink_ports_lossy);
            soc_reg32_set(unit, LWMCOSCELLSETLIMITr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                              CELLRESETLIMITf,
                              egress_queue_min_reserve_downlink_ports_lossy);
            soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                              CELLRESETLIMITf,
                              0);
            soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                              CELLMAXLIMITf,
                              ceiling_func(shared_space_cells,
                                           queue_port_limit_ratio) +
                              lwmcoscellsetlimit0_cellsetlimit_down_2dot5);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMITr, index 7 */
        soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                          CELLMAXLIMITf,
                          ceiling_func(shared_space_cells,
                                       queue_port_limit_ratio) +
                          lwmcoscellsetlimit7_cellsetlimit_down_2dot5);
        soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                      port, 7, rval);

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                              CELLMAXLIMITf,
                              ceiling_func(shared_space_cells,
                                           queue_port_limit_ratio) +
                              lwmcoscellsetlimit_qlayer0_cellsetlimit_down_2dot5);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 7 */
        soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                          CELLMAXLIMITf,
                          ceiling_func(shared_space_cells,
                                       queue_port_limit_ratio) +
                          lwmcoscellsetlimit_qlayer7_cellsetlimit_down_2dot5);
        soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                      port, 7, rval);

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                              CELLMAXLIMITf,
                              ceiling_func(shared_space_cells,
                                           queue_port_limit_ratio) +
                              lwmcoscellsetlimit_qlayer8_cellsetlimit_down_2dot5);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                              CELLMAXRESUMELIMITf,
                              holcoscellmaxlimit0_cellmaxlimit_down_2dot5 -
                              ethernet_mtu_cell);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMITr, index 7 */
        soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                          CELLMAXRESUMELIMITf,
                          holcoscellmaxlimit7_cellmaxlimit_down_2dot5 -
                          ethernet_mtu_cell);
        soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                      port, 7, rval);

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                              CELLMAXRESUMELIMITf,
                              holcoscellmaxlimit_qlayer0_cellmaxlimit_down_2dot5 -
                              ethernet_mtu_cell);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 7 */
        soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                          CELLMAXRESUMELIMITf,
                          holcoscellmaxlimit_qlayer7_cellmaxlimit_down_2dot5 -
                          ethernet_mtu_cell);
        soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                      port, 7, rval);

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                              CELLMAXRESUMELIMITf,
                              holcoscellmaxlimit_qlayer8_cellmaxlimit_down_2dot5 -
                              ethernet_mtu_cell);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* DYNCELLLIMITr, index 0 */
        soc_reg32_get(unit, DYNCELLLIMITr,
                      port, 0, &rval);
        soc_reg_field_set(unit, DYNCELLLIMITr, &rval,
                          DYNCELLSETLIMITf,
                          shared_space_cells);
        soc_reg_field_set(unit, DYNCELLLIMITr, &rval,
                          DYNCELLRESETLIMITf,
                          dyncelllimit_dyncellsetlimit_down_2dot5 -
                          (ethernet_mtu_cell * 2));
        soc_reg32_set(unit, DYNCELLLIMITr,
                      port, 0, rval);

        /* COLOR_DROP_ENr, index 0 */
        soc_reg32_get(unit, COLOR_DROP_ENr,
                      port, 0, &rval);
        soc_reg_field_set(unit, COLOR_DROP_ENr, &rval,
                          COLOR_DROP_ENf,
                          0);
        soc_reg32_set(unit, COLOR_DROP_ENr,
                      port, 0, rval);

        /* COLOR_DROP_EN_QLAYERr, index 0 */
        soc_reg32_get(unit, COLOR_DROP_EN_QLAYERr,
                      port, 0, &rval);
        soc_reg_field_set(unit, COLOR_DROP_EN_QLAYERr, &rval,
                          COLOR_DROP_ENf,
                          0);
        soc_reg32_set(unit, COLOR_DROP_EN_QLAYERr,
                      port, 0, rval);

        /* HOLCOSPKTSETLIMIT_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSPKTSETLIMIT_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTSETLIMIT_QGROUPr, &rval,
                              PKTSETLIMITf,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, HOLCOSPKTSETLIMIT_QGROUPr,
                          port, index, rval);
        }

        /* HOLCOSPKTRESETLIMIT_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSPKTRESETLIMIT_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTRESETLIMIT_QGROUPr, &rval,
                              PKTRESETLIMITf,
                              holcospktsetlimit_qgroup0_pktsetlimit_down_2dot5
                              - 1);
            soc_reg32_set(unit, HOLCOSPKTRESETLIMIT_QGROUPr,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT0_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT0_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT0_QGROUPr, &rval,
                              CNGPKTSETLIMIT0f,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT0_QGROUPr,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT1_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT1_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT1_QGROUPr, &rval,
                              CNGPKTSETLIMIT1f,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT1_QGROUPr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMIT_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QGROUPr, &rval,
                              CELLMAXLIMITf,
                              ceiling_func(total_advertised_cell_memory,
                                           queue_port_limit_ratio));
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QGROUPr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMIT_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QGROUPr, &rval,
                              CELLMAXRESUMELIMITf,
                              holcoscellmaxlimit_qgroup0_cellmaxlimit_down_2dot5 -
                              ethernet_mtu_cell);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QGROUPr,
                          port, index, rval);
        }

        /* COLOR_DROP_EN_QGROUPr, index 0 */
        soc_reg32_get(unit, COLOR_DROP_EN_QGROUPr,
                      port, 0, &rval);
        soc_reg_field_set(unit, COLOR_DROP_EN_QGROUPr, &rval,
                          COLOR_DROP_ENf,
                          0);
        soc_reg32_set(unit, COLOR_DROP_EN_QGROUPr,
                      port, 0, rval);

        /* SHARED_POOL_CTRLr, index 0 */
        soc_reg32_get(unit, SHARED_POOL_CTRLr,
                      port, 0, &rval);
        soc_reg_field_set(unit, SHARED_POOL_CTRLr, &rval,
                          DYNAMIC_COS_DROP_ENf,
                          255);
        soc_reg_field_set(unit, SHARED_POOL_CTRLr, &rval,
                          SHARED_POOL_DISCARD_ENf,
                          255);
        soc_reg_field_set(unit, SHARED_POOL_CTRLr, &rval,
                          SHARED_POOL_XOFF_ENf,
                          0);
        soc_reg32_set(unit, SHARED_POOL_CTRLr,
                      port, 0, rval);

        /* SHARED_POOL_CTRL_EXT1r, index 0 */
        soc_reg32_get(unit, SHARED_POOL_CTRL_EXT1r,
                      port, 0, &rval);
        soc_reg_field_set(unit, SHARED_POOL_CTRL_EXT1r, &rval,
                          DYNAMIC_COS_DROP_ENf,
                          0xFFFFFF);
        soc_reg32_set(unit, SHARED_POOL_CTRL_EXT1r,
                      port, 0, rval);

        /* SHARED_POOL_CTRL_EXT2r, index 0 */
        soc_reg32_get(unit, SHARED_POOL_CTRL_EXT2r,
                      port, 0, &rval);
        soc_reg_field_set(unit, SHARED_POOL_CTRL_EXT2r, &rval,
                          DYNAMIC_COS_DROP_ENf,
                          0xFFFFFFFF);
        soc_reg32_set(unit, SHARED_POOL_CTRL_EXT2r,
                      port, 0, rval);
    }


    /* port-based : cpu port*/
    SOC_PBMP_ITER(pbmp_cpu, port) {
       /* PG_CTRL0r, index 0 */
       soc_reg32_get(unit, PG_CTRL0r,
                     port, 0, &rval);
       soc_reg_field_set(unit, PG_CTRL0r, &rval,
                         PPFC_PG_ENf,
                         0);
       soc_reg_field_set(unit, PG_CTRL0r, &rval,
                         PRI0_GRPf,
                         0);
       soc_reg_field_set(unit, PG_CTRL0r, &rval,
                         PRI1_GRPf,
                         1);
       soc_reg_field_set(unit, PG_CTRL0r, &rval,
                         PRI2_GRPf,
                         2);
       soc_reg_field_set(unit, PG_CTRL0r, &rval,
                         PRI3_GRPf,
                         3);
       soc_reg_field_set(unit, PG_CTRL0r, &rval,
                         PRI4_GRPf,
                         4);
       soc_reg_field_set(unit, PG_CTRL0r, &rval,
                         PRI5_GRPf,
                         5);
       soc_reg_field_set(unit, PG_CTRL0r, &rval,
                         PRI6_GRPf,
                         6);
       soc_reg_field_set(unit, PG_CTRL0r, &rval,
                         PRI7_GRPf,
                         7);
       soc_reg32_set(unit, PG_CTRL0r,
                     port, 0, rval);

       /* PG_CTRL1r, index 0 */
       soc_reg32_get(unit, PG_CTRL1r,
                     port, 0, &rval);
       soc_reg_field_set(unit, PG_CTRL1r, &rval,
                         PRI8_GRPf,
                         7);
       soc_reg_field_set(unit, PG_CTRL1r, &rval,
                         PRI9_GRPf,
                         7);
       soc_reg_field_set(unit, PG_CTRL1r, &rval,
                         PRI10_GRPf,
                         7);
       soc_reg_field_set(unit, PG_CTRL1r, &rval,
                         PRI11_GRPf,
                         7);
       soc_reg_field_set(unit, PG_CTRL1r, &rval,
                         PRI12_GRPf,
                         7);
       soc_reg_field_set(unit, PG_CTRL1r, &rval,
                         PRI13_GRPf,
                         7);
       soc_reg_field_set(unit, PG_CTRL1r, &rval,
                         PRI14_GRPf,
                         7);
       soc_reg_field_set(unit, PG_CTRL1r, &rval,
                         PRI15_GRPf,
                         7);
       soc_reg32_set(unit, PG_CTRL1r,
                     port, 0, rval);

       /* PG2TCr, index 0 ~ 7 */
       for (index = 0; index <= 7; index++) {
           soc_reg32_get(unit, PG2TCr,
                         port, index, &rval);
           soc_reg_field_set(unit, PG2TCr, &rval,
                             PG_BMPf,
                             0);
           soc_reg32_set(unit, PG2TCr,
                         port, index, rval);
       }

       /* IBPPKTSETLIMITr, index 0 */
       soc_reg32_get(unit, IBPPKTSETLIMITr,
                     port, 0, &rval);
       soc_reg_field_set(unit, IBPPKTSETLIMITr, &rval,
                         PKTSETLIMITf,
                         xoff_packet_thresholds_per_port_uplink_port);
       soc_reg_field_set(unit, IBPPKTSETLIMITr, &rval,
                         RESETLIMITSELf,
                         3);
       soc_reg32_set(unit, IBPPKTSETLIMITr,
                     port, 0, rval);

       /* MMU_FC_RX_ENr, index 0 */
       soc_reg32_get(unit, MMU_FC_RX_ENr,
                     port, 0, &rval);
       soc_reg_field_set(unit, MMU_FC_RX_ENr, &rval,
                         MMU_FC_RX_ENABLEf,
                         0);
       soc_reg32_set(unit, MMU_FC_RX_ENr,
                     port, 0, rval);

       /* MMU_FC_TX_ENr, index 0 */
       soc_reg32_get(unit, MMU_FC_TX_ENr,
                     port, 0, &rval);
       soc_reg_field_set(unit, MMU_FC_TX_ENr, &rval,
                         MMU_FC_TX_ENABLEf,
                         0);
       soc_reg32_set(unit, MMU_FC_TX_ENr,
                     port, 0, rval);

       /* PGCELLLIMITr, index 0 ~ 7 */
       for (index = 0; index <= 7; index++) {
           soc_reg32_get(unit, PGCELLLIMITr,
                         port, index, &rval);
           soc_reg_field_set(unit, PGCELLLIMITr, &rval,
                             CELLSETLIMITf,
                             xoff_cell_threshold_all_uplink_ports);
           soc_reg32_set(unit, PGCELLLIMITr,
                         port, index, rval);
       }

       /* PGCELLLIMITr, index 0 ~ 7 */
       for (index = 0; index <= 7; index++) {
           soc_reg32_get(unit, PGCELLLIMITr,
                         port, index, &rval);
           soc_reg_field_set(unit, PGCELLLIMITr, &rval,
                             CELLRESETLIMITf,
                             xoff_cell_threshold_all_uplink_ports);
           soc_reg32_set(unit, PGCELLLIMITr,
                         port, index, rval);
       }

       /* PGDISCARDSETLIMITr, index 0 ~ 7 */
       for (index = 0; index <= 7; index++) {
           soc_reg32_get(unit, PGDISCARDSETLIMITr,
                         port, index, &rval);
           soc_reg_field_set(unit, PGDISCARDSETLIMITr, &rval,
                             DISCARDSETLIMITf,
                             discard_limit_per_port_pg_downlink_port);
           soc_reg32_set(unit, PGDISCARDSETLIMITr,
                         port, index, rval);
       }

       /* HOLCOSMINXQCNTr, index 0 ~ 7 */
       for (index = 0; index <= 7; index++) {
           soc_reg32_get(unit, HOLCOSMINXQCNTr,
                         port, index, &rval);
           soc_reg_field_set(unit, HOLCOSMINXQCNTr, &rval,
                             HOLCOSMINXQCNTf,
                             egress_queue_min_reserve_cpu_ports);
           soc_reg32_set(unit, HOLCOSMINXQCNTr,
                         port, index, rval);
       }

       /* HOLCOSPKTSETLIMITr, index 0 ~ 6 */
       for (index = 0; index <= 6; index++) {
           soc_reg32_get(unit, HOLCOSPKTSETLIMITr,
                         port, index, &rval);
           soc_reg_field_set(unit, HOLCOSPKTSETLIMITr, &rval,
                             PKTSETLIMITf,
                             shared_xqs_per_downlink_port +
                             holcosminxqcnt0_holcosminxqcnt_cpu);
           soc_reg32_set(unit, HOLCOSPKTSETLIMITr,
                         port, index, rval);
       }

       /* HOLCOSPKTSETLIMITr, index 7 */
       soc_reg32_get(unit, HOLCOSPKTSETLIMITr,
                     port, 7, &rval);
       soc_reg_field_set(unit, HOLCOSPKTSETLIMITr, &rval,
                         PKTSETLIMITf,
                         shared_xqs_per_downlink_port +
                         holcosminxqcnt7_holcosminxqcnt_cpu);
       soc_reg32_set(unit, HOLCOSPKTSETLIMITr,
                     port, 7, rval);

       /* HOLCOSPKTRESETLIMITr, index 0 ~ 6 */
       for (index = 0; index <= 6; index++) {
           soc_reg32_get(unit, HOLCOSPKTRESETLIMITr,
                         port, index, &rval);
           soc_reg_field_set(unit, HOLCOSPKTRESETLIMITr, &rval,
                             PKTRESETLIMITf,
                             holcospktsetlimit0_pktsetlimit_cpu - 1);
           soc_reg32_set(unit, HOLCOSPKTRESETLIMITr,
                         port, index, rval);
       }

       /* HOLCOSPKTRESETLIMITr, index 7 */
       soc_reg32_get(unit, HOLCOSPKTRESETLIMITr,
                     port, 7, &rval);
       soc_reg_field_set(unit, HOLCOSPKTRESETLIMITr, &rval,
                         PKTRESETLIMITf,
                         holcospktsetlimit7_pktsetlimit_cpu - 1);
       soc_reg32_set(unit, HOLCOSPKTRESETLIMITr,
                     port, 7, rval);

       /* CNGCOSPKTLIMIT0r, index 0 ~ 7 */
       for (index = 0; index <= 7; index++) {
           soc_reg32_get(unit, CNGCOSPKTLIMIT0r,
                         port, index, &rval);
           soc_reg_field_set(unit, CNGCOSPKTLIMIT0r, &rval,
                             CNGPKTSETLIMIT0f,
                             numxqs_per_downlink_ports_and_cpu_port - 1);
           soc_reg32_set(unit, CNGCOSPKTLIMIT0r,
                         port, index, rval);
       }

       /* CNGCOSPKTLIMIT1r, index 0 ~ 7 */
       for (index = 0; index <= 7; index++) {
           soc_reg32_get(unit, CNGCOSPKTLIMIT1r,
                         port, index, &rval);
           soc_reg_field_set(unit, CNGCOSPKTLIMIT1r, &rval,
                             CNGPKTSETLIMIT1f,
                             numxqs_per_downlink_ports_and_cpu_port - 1);
           soc_reg32_set(unit, CNGCOSPKTLIMIT1r,
                         port, index, rval);
       }

       /* CNGCOSPKTLIMIT0_QLAYERr, index 0 ~ 63 */
       for (index = 0; index <= 63; index++) {
           soc_reg32_get(unit, CNGCOSPKTLIMIT0_QLAYERr,
                         port, index, &rval);
           soc_reg_field_set(unit, CNGCOSPKTLIMIT0_QLAYERr, &rval,
                             CNGPKTSETLIMIT0f,
                             numxqs_per_downlink_ports_and_cpu_port - 1);
           soc_reg32_set(unit, CNGCOSPKTLIMIT0_QLAYERr,
                         port, index, rval);
       }

       /* CNGCOSPKTLIMIT1_QLAYERr, index 0 ~ 63 */
       for (index = 0; index <= 63; index++) {
           soc_reg32_get(unit, CNGCOSPKTLIMIT1_QLAYERr,
                         port, index, &rval);
           soc_reg_field_set(unit, CNGCOSPKTLIMIT1_QLAYERr, &rval,
                             CNGPKTSETLIMIT1f,
                             numxqs_per_downlink_ports_and_cpu_port - 1);
           soc_reg32_set(unit, CNGCOSPKTLIMIT1_QLAYERr,
                         port, index, rval);
       }

       /* CNGPORTPKTLIMIT0r, index 0 */
       soc_reg32_get(unit, CNGPORTPKTLIMIT0r,
                     port, 0, &rval);
       soc_reg_field_set(unit, CNGPORTPKTLIMIT0r, &rval,
                         CNGPORTPKTLIMIT0f,
                         numxqs_per_downlink_ports_and_cpu_port - 1);
       soc_reg32_set(unit, CNGPORTPKTLIMIT0r,
                     port, 0, rval);

       /* CNGPORTPKTLIMIT1r, index 0 */
       soc_reg32_get(unit, CNGPORTPKTLIMIT1r,
                     port, 0, &rval);
       soc_reg_field_set(unit, CNGPORTPKTLIMIT1r, &rval,
                         CNGPORTPKTLIMIT1f,
                         numxqs_per_downlink_ports_and_cpu_port - 1);
       soc_reg32_set(unit, CNGPORTPKTLIMIT1r,
                     port, 0, rval);

       /* DYNXQCNTPORTr, index 0 */
       soc_reg32_get(unit, DYNXQCNTPORTr,
                     port, 0, &rval);
       soc_reg_field_set(unit, DYNXQCNTPORTr, &rval,
                         DYNXQCNTPORTf,
                         shared_xqs_per_downlink_port - skidmarker - prefetch);
       soc_reg32_set(unit, DYNXQCNTPORTr,
                     port, 0, rval);

       /* DYNRESETLIMPORTr, index 0 */
       soc_reg32_get(unit, DYNRESETLIMPORTr,
                     port, 0, &rval);
       soc_reg_field_set(unit, DYNRESETLIMPORTr, &rval,
                         DYNRESETLIMPORTf,
                         dynxqcntport_dynxqcntport_cpu - 2);
       soc_reg32_set(unit, DYNRESETLIMPORTr,
                     port, 0, rval);

       /* LWMCOSCELLSETLIMITr, index 0 ~ 7 */
       for (index = 0; index <= 7; index++) {
           soc_reg32_get(unit, LWMCOSCELLSETLIMITr,
                         port, index, &rval);
           soc_reg_field_set(unit, LWMCOSCELLSETLIMITr, &rval,
                             CELLSETLIMITf,
                             egress_queue_min_reserve_cpu_ports);
           soc_reg32_set(unit, LWMCOSCELLSETLIMITr,
                         port, index, rval);
       }

       /* LWMCOSCELLSETLIMITr, index 0 ~ 7 */
       for (index = 0; index <= 7; index++) {
           soc_reg32_get(unit, LWMCOSCELLSETLIMITr,
                         port, index, &rval);
           soc_reg_field_set(unit, LWMCOSCELLSETLIMITr, &rval,
                             CELLRESETLIMITf,
                             egress_queue_min_reserve_cpu_ports);
           soc_reg32_set(unit, LWMCOSCELLSETLIMITr,
                         port, index, rval);
       }

       /* HOLCOSCELLMAXLIMITr, index 0 ~ 6 */
       for (index = 0; index <= 6; index++) {
           soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                         port, index, &rval);
           soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                             CELLMAXLIMITf,
                             ceiling_func(shared_space_cells,
                                          queue_port_limit_ratio) +
                             lwmcoscellsetlimit0_cellsetlimit_cpu);
           soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                         port, index, rval);
       }

       /* HOLCOSCELLMAXLIMITr, index 7 */
       soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                     port, 7, &rval);
       soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                         CELLMAXLIMITf,
                         ceiling_func(shared_space_cells,
                                      queue_port_limit_ratio) +
                         lwmcoscellsetlimit7_cellsetlimit_cpu);
       soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                     port, 7, rval);

       /* HOLCOSCELLMAXLIMITr, index 0 ~ 6 */
       for (index = 0; index <= 6; index++) {
           soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                         port, index, &rval);
           soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                             CELLMAXRESUMELIMITf,
                             holcoscellmaxlimit0_cellmaxlimit_cpu -
                             ethernet_mtu_cell);
           soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                         port, index, rval);
       }

       /* HOLCOSCELLMAXLIMITr, index 7 */
       soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                     port, 7, &rval);
       soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                         CELLMAXRESUMELIMITf,
                         holcoscellmaxlimit7_cellmaxlimit_cpu -
                         ethernet_mtu_cell);
       soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                     port, 7, rval);

       /* DYNCELLLIMITr, index 0 */
       soc_reg32_get(unit, DYNCELLLIMITr,
                     port, 0, &rval);
       soc_reg_field_set(unit, DYNCELLLIMITr, &rval,
                         DYNCELLSETLIMITf,
                         shared_space_cells);
       soc_reg_field_set(unit, DYNCELLLIMITr, &rval,
                         DYNCELLRESETLIMITf,
                         dyncelllimit_dyncellsetlimit_cpu -
                         ethernet_mtu_cell * 2);
       soc_reg32_set(unit, DYNCELLLIMITr,
                     port, 0, rval);

       /* COLOR_DROP_ENr, index 0 */
       soc_reg32_get(unit, COLOR_DROP_ENr,
                     port, 0, &rval);
       soc_reg_field_set(unit, COLOR_DROP_ENr, &rval,
                         COLOR_DROP_ENf,
                         0);
       soc_reg32_set(unit, COLOR_DROP_ENr,
                     port, 0, rval);

       /* COLOR_DROP_EN_QLAYERr, index 0 */
       soc_reg32_get(unit, COLOR_DROP_EN_QLAYERr,
                     port, 0, &rval);
       soc_reg_field_set(unit, COLOR_DROP_EN_QLAYERr, &rval,
                         COLOR_DROP_ENf,
                         0);
       soc_reg32_set(unit, COLOR_DROP_EN_QLAYERr,
                     port, 0, rval);

       /* COLOR_DROP_EN_QGROUPr, index 0 */
       soc_reg32_get(unit, COLOR_DROP_EN_QGROUPr,
                     port, 0, &rval);
       soc_reg_field_set(unit, COLOR_DROP_EN_QGROUPr, &rval,
                         COLOR_DROP_ENf,
                         0);
       soc_reg32_set(unit, COLOR_DROP_EN_QGROUPr,
                     port, 0, rval);

       /* SHARED_POOL_CTRLr, index 0 */
       soc_reg32_get(unit, SHARED_POOL_CTRLr,
                     port, 0, &rval);
       soc_reg_field_set(unit, SHARED_POOL_CTRLr, &rval,
                         DYNAMIC_COS_DROP_ENf,
                         255);
       soc_reg_field_set(unit, SHARED_POOL_CTRLr, &rval,
                         SHARED_POOL_DISCARD_ENf,
                         255);
       soc_reg_field_set(unit, SHARED_POOL_CTRLr, &rval,
                         SHARED_POOL_XOFF_ENf,
                         0);
       soc_reg32_set(unit, SHARED_POOL_CTRLr,
                     port, 0, rval);

       /* SHARED_POOL_CTRL_EXT1r, index 0 */
       soc_reg32_get(unit, SHARED_POOL_CTRL_EXT1r,
                     port, 0, &rval);
       soc_reg_field_set(unit, SHARED_POOL_CTRL_EXT1r, &rval,
                         DYNAMIC_COS_DROP_ENf,
                         0xFFFFFF);
       soc_reg32_set(unit, SHARED_POOL_CTRL_EXT1r,
                     port, 0, rval);

       /* SHARED_POOL_CTRL_EXT2r, index 0 */
       soc_reg32_get(unit, SHARED_POOL_CTRL_EXT2r,
                     port, 0, &rval);
       soc_reg_field_set(unit, SHARED_POOL_CTRL_EXT2r, &rval,
                         DYNAMIC_COS_DROP_ENf,
                         0xFFFFFFFF);
       soc_reg32_set(unit, SHARED_POOL_CTRL_EXT2r,
                     port, 0, rval);
    }
    return SOC_E_NONE;
}


STATIC int _soc_greyhound2_mmu_init_helper_lossless(int unit)
{
    uint32 rval;
    int port, phy_port;
    int index;
    soc_info_t *si = &SOC_INFO(unit);
    soc_pbmp_t pbmp_cpu;
    soc_pbmp_t pbmp_uplink;
    soc_pbmp_t pbmp_downlink_1g;
    soc_pbmp_t pbmp_downlink_2dot5g;
    soc_pbmp_t pbmp_downlink_10g;

    static int standard_jumbo_frame;
    static int cell_size;
    static int ethernet_mtu_cell;
    static int standard_jumbo_frame_cell;
    static int total_physical_memory;
    static int total_cell_memory_for_admission;
    static int number_of_used_memory_banks;
    static int reserved_for_cfap;
    static int skidmarker;
    static int prefetch;
    static int total_cell_memory;
    static int cfapfullsetpoint;
    static int total_advertised_cell_memory;
    static int number_of_uplink_ports;
    static int number_of_downlink_ports;
    static int flow_control_type_pause_0_pfc_1;
    static int queue_port_limit_ratio;
    static int headroom_for_1g_port;
    static int headroom_for_2dot5g_port;
    static int headroom_for_10g_port;
    static int headroom_for_20g_port;
    static int headroom_for_25g_port;
    static int headroom_for_40g_port;
    static int num_1g_ports_downlink_ports;
    static int num_2dot5g_ports_downlink_ports;
    static int num_10g_ports_downlink_ports;
    static int num_20g_ports_downlink_ports;
    static int num_25g_ports_downlink_ports;
    static int num_40g_ports_downlink_ports;
    static int mmu_xoff_pkt_threshold_uplink_ports;
    static int mmu_xoff_pkt_threshold_downlink_ports;
    static int mmu_xoff_cell_threshold_1g_port_downlink_ports;
    static int mmu_xoff_cell_threshold_2dot5g_port_downlink_ports;
    static int mmu_xoff_cell_threshold_10g_port_downlink_ports;
    static int mmu_xoff_cell_threshold_20g_port_downlink_ports;
    static int mmu_xoff_cell_threshold_25g_port_downlink_ports;
    static int mmu_xoff_cell_threshold_40g_port_downlink_ports;
    static int mmu_xoff_cell_threshold_all_uplink_ports;
    static int egress_xq_min_reserve_lossless_uplink_ports;
    static int egress_xq_min_reserve_lossless_downlink_ports;
    static int egress_xq_min_reserve_lossy_up_downlink_ports;
    static int egress_queue_min_reserve_uplink_ports_lossy;
    static int egress_queue_min_reserve_downlink_ports_lossy;
    static int egress_queue_min_reserve_uplink_ports_lossless;
    static int egress_queue_min_reserve_downlink_ports_lossless;
    static int egress_queue_min_reserve_cpu_ports;
    static int egress_xq_min_reserve_lossy_ports;
    static int num_active_pri_group_lossless;
    static int num_lossy_queues;
    static int num_cpu_queues;
    static int num_cpu_ports;
    static int numxqs_per_uplink_ports;
    static int numxqs_per_downlink_ports_and_cpu_port;
    static int xoff_cell_thresholds_per_port_1g_port_downlink_ports;
    static int xoff_cell_thresholds_per_port_2dot5g_downlink_ports;
    static int xoff_cell_thresholds_per_port_10g_port_downlink_ports;
    static int xoff_cell_threshold_all_uplink_ports;
    static int xoff_packet_thresholds_per_port_uplink_port;
    static int xoff_packet_thresholds_per_port_downlink_port;
    static int discard_limit_per_port_pg_uplink_1g_port;
    static int discard_limit_per_port_pg_uplink_2dot5g_port;
    static int discard_limit_per_port_pg_uplink_10g_port;
    static int discard_limit_per_port_pg_downlink_port;
    static int total_reserved_cells_for_uplink_ports;
    static int total_reserved_cells_for_downlink_ports;
    static int total_reserved_cells_for_cpu_port;
    static int total_reserved;
    static int shared_space_cells;
    static int reserved_xqs_per_uplink_port;
    static int shared_xqs_per_uplink_port;
    static int reserved_xqs_per_downlink_port;
    static int shared_xqs_per_downlink_port;
    static int cfapfullthreshold_cfapfullsetpoint_up;
    static int gbllimitsetlimit_gblcellsetlimit_up;
    static int totaldyncellsetlimit_totaldyncellsetlimit_up;
    static int holcosminxqcnt_qlayer8_holcosminxqcnt_up;
    static int holcospktsetlimit0_pktsetlimit_up;
    static int holcospktsetlimit7_pktsetlimit_up;
    static int holcospktsetlimit_qlayer0_pktsetlimit_up;
    static int holcospktsetlimit_qlayer7_pktsetlimit_up;
    static int holcospktsetlimit_qlayer8_pktsetlimit_up;
    static int dynxqcntport_dynxqcntport_up;
    static int lwmcoscellsetlimit0_cellsetlimit_up;
    static int lwmcoscellsetlimit7_cellsetlimit_up;
    static int lwmcoscellsetlimit_qlayer0_cellsetlimit_up;
    static int lwmcoscellsetlimit_qlayer7_cellsetlimit_up;
    static int lwmcoscellsetlimit_qlayer8_cellsetlimit_up;
    static int holcoscellmaxlimit0_cellmaxlimit_up;
    static int holcoscellmaxlimit7_cellmaxlimit_up;
    static int holcoscellmaxlimit_qlayer0_cellmaxlimit_up;
    static int holcoscellmaxlimit_qlayer7_cellmaxlimit_up;
    static int holcoscellmaxlimit_qlayer8_cellmaxlimit_up;
    static int dyncelllimit_dyncellsetlimit_up;
    static int holcospktsetlimit_qgroup0_pktsetlimit_up;
    static int holcoscellmaxlimit_qgroup0_cellmaxlimit_up;
    static int holcosminxqcnt_qlayer8_holcosminxqcnt_down_1;
    static int holcospktsetlimit0_pktsetlimit_down_1;
    static int holcospktsetlimit7_pktsetlimit_down_1;
    static int holcospktsetlimit_qlayer0_pktsetlimit_down_1;
    static int holcospktsetlimit_qlayer7_pktsetlimit_down_1;
    static int holcospktsetlimit_qlayer8_pktsetlimit_down_1;
    static int dynxqcntport_dynxqcntport_down_1;
    static int lwmcoscellsetlimit0_cellsetlimit_down_1;
    static int lwmcoscellsetlimit7_cellsetlimit_down_1;
    static int lwmcoscellsetlimit_qlayer0_cellsetlimit_down_1;
    static int lwmcoscellsetlimit_qlayer7_cellsetlimit_down_1;
    static int lwmcoscellsetlimit_qlayer8_cellsetlimit_down_1;
    static int holcoscellmaxlimit0_cellmaxlimit_down_1;
    static int holcoscellmaxlimit7_cellmaxlimit_down_1;
    static int holcoscellmaxlimit_qlayer0_cellmaxlimit_down_1;
    static int holcoscellmaxlimit_qlayer7_cellmaxlimit_down_1;
    static int holcoscellmaxlimit_qlayer8_cellmaxlimit_down_1;
    static int dyncelllimit_dyncellsetlimit_down_1;
    static int holcospktsetlimit_qgroup0_pktsetlimit_down_1;
    static int holcoscellmaxlimit_qgroup0_cellmaxlimit_down_1;
    static int holcosminxqcnt_qlayer8_holcosminxqcnt_down_2dot5;
    static int holcospktsetlimit0_pktsetlimit_down_2dot5;
    static int holcospktsetlimit7_pktsetlimit_down_2dot5;
    static int holcospktsetlimit_qlayer0_pktsetlimit_down_2dot5;
    static int holcospktsetlimit_qlayer7_pktsetlimit_down_2dot5;
    static int holcospktsetlimit_qlayer8_pktsetlimit_down_2dot5;
    static int dynxqcntport_dynxqcntport_down_2dot5;
    static int lwmcoscellsetlimit0_cellsetlimit_down_2dot5;
    static int lwmcoscellsetlimit7_cellsetlimit_down_2dot5;
    static int lwmcoscellsetlimit_qlayer0_cellsetlimit_down_2dot5;
    static int lwmcoscellsetlimit_qlayer7_cellsetlimit_down_2dot5;
    static int lwmcoscellsetlimit_qlayer8_cellsetlimit_down_2dot5;
    static int holcoscellmaxlimit0_cellmaxlimit_down_2dot5;
    static int holcoscellmaxlimit7_cellmaxlimit_down_2dot5;
    static int holcoscellmaxlimit_qlayer0_cellmaxlimit_down_2dot5;
    static int holcoscellmaxlimit_qlayer7_cellmaxlimit_down_2dot5;
    static int holcoscellmaxlimit_qlayer8_cellmaxlimit_down_2dot5;
    static int dyncelllimit_dyncellsetlimit_down_2dot5;
    static int holcospktsetlimit_qgroup0_pktsetlimit_down_2dot5;
    static int holcoscellmaxlimit_qgroup0_cellmaxlimit_down_2dot5;
    static int holcosminxqcnt_qlayer8_holcosminxqcnt_down_10;
    static int holcospktsetlimit0_pktsetlimit_down_10;
    static int holcospktsetlimit7_pktsetlimit_down_10;
    static int holcospktsetlimit_qlayer0_pktsetlimit_down_10;
    static int holcospktsetlimit_qlayer7_pktsetlimit_down_10;
    static int holcospktsetlimit_qlayer8_pktsetlimit_down_10;
    static int dynxqcntport_dynxqcntport_down_10;
    static int lwmcoscellsetlimit0_cellsetlimit_down_10;
    static int lwmcoscellsetlimit7_cellsetlimit_down_10;
    static int lwmcoscellsetlimit_qlayer0_cellsetlimit_down_10;
    static int lwmcoscellsetlimit_qlayer7_cellsetlimit_down_10;
    static int lwmcoscellsetlimit_qlayer8_cellsetlimit_down_10;
    static int holcoscellmaxlimit0_cellmaxlimit_down_10;
    static int holcoscellmaxlimit7_cellmaxlimit_down_10;
    static int holcoscellmaxlimit_qlayer0_cellmaxlimit_down_10;
    static int holcoscellmaxlimit_qlayer7_cellmaxlimit_down_10;
    static int holcoscellmaxlimit_qlayer8_cellmaxlimit_down_10;
    static int dyncelllimit_dyncellsetlimit_down_10;
    static int holcospktsetlimit_qgroup0_pktsetlimit_down_10;
    static int holcoscellmaxlimit_qgroup0_cellmaxlimit_down_10;
    static int holcospktsetlimit0_pktsetlimit_cpu;
    static int holcospktsetlimit7_pktsetlimit_cpu;
    static int dynxqcntport_dynxqcntport_cpu;
    static int lwmcoscellsetlimit0_cellsetlimit_cpu;
    static int lwmcoscellsetlimit7_cellsetlimit_cpu;
    static int holcoscellmaxlimit0_cellmaxlimit_cpu;
    static int holcoscellmaxlimit7_cellmaxlimit_cpu;
    static int dyncelllimit_dyncellsetlimit_cpu;
    uint16 dev_id;
    uint8  rev_id;
    int    propval;

    soc_cm_get_id(unit, &dev_id, &rev_id);

    /* setup port bitmap according the port max speed for lossless
     *   TSC4/TSC6/TSCF    : uplink port
     *   TSC0~3/TSC5/QGMII/SGMII : donnlink port
     *     Note.
     *       1. the number of uplink port should not exceed 4
     *       2. cannot support donnlink port with speed > 10G
     */
    num_cpu_ports = 0;
    number_of_uplink_ports = 0;
    number_of_downlink_ports = 0;
    num_1g_ports_downlink_ports = 0;
    num_2dot5g_ports_downlink_ports = 0;
    num_10g_ports_downlink_ports = 0;
    num_20g_ports_downlink_ports = 0;
    num_25g_ports_downlink_ports = 0;
    num_40g_ports_downlink_ports = 0;
    SOC_PBMP_CLEAR(pbmp_cpu);
    SOC_PBMP_CLEAR(pbmp_uplink);
    SOC_PBMP_CLEAR(pbmp_downlink_1g);
    SOC_PBMP_CLEAR(pbmp_downlink_2dot5g);
    SOC_PBMP_CLEAR(pbmp_downlink_10g);
    for (phy_port = 0; phy_port < SOC_MAX_PHY_PORTS; phy_port++) {
        port = si->port_p2l_mapping[phy_port];
        if (port < 0) {
            continue; /* this user port has not been mapping in this sku */
        } else if (!SOC_PBMP_MEMBER(PBMP_ALL(unit), port)) {
            continue; /* this user port has been masked out by pbmp_valid */
        }
        if (IS_CL_PORT(unit, port) ||
            (74 <= phy_port && phy_port <= 77) ||
            (82 <= phy_port && phy_port <= 85)) {
            number_of_uplink_ports++;
            SOC_PBMP_PORT_ADD(pbmp_uplink, port);
        } else if (IS_GE_PORT(unit, port) ||
                   (58 <= phy_port && phy_port <= 73) ||
                   (78 <= phy_port && phy_port <= 81)) {
            number_of_downlink_ports++;
            if (SOC_INFO(unit).port_speed_max[port] > 10000) {
                LOG_CLI((BSL_META_U(unit,
                         "for downlink port %d,\
                         the max speed cannot exceed 10G (value=%d)\n"),
                         port, SOC_INFO(unit).port_speed_max[port]));
                return SOC_E_PARAM;
            } else if (SOC_INFO(unit).port_speed_max[port] > 2500) {
                num_10g_ports_downlink_ports++;
                SOC_PBMP_PORT_ADD(pbmp_downlink_10g, port);
            } else if (SOC_INFO(unit).port_speed_max[port] > 1000) {
                num_2dot5g_ports_downlink_ports++;
                SOC_PBMP_PORT_ADD(pbmp_downlink_2dot5g, port);
            } else {
                num_1g_ports_downlink_ports++;
                SOC_PBMP_PORT_ADD(pbmp_downlink_1g, port);
            }
        } else if (IS_CPU_PORT(unit, port)) {
            num_cpu_ports++;
            SOC_PBMP_PORT_ADD(pbmp_cpu, port);
        }
    }
    if (number_of_uplink_ports > 4) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                  "Warning: MMU lossless mode allows maximum 4 "
                  "logical ports mapped to physical port range[74~77, 82~89]. "
                  "Currently %d logical ports are mapped.\n"),
                  number_of_uplink_ports));
        return SOC_E_PARAM;
    }

    standard_jumbo_frame = 9216;
    cell_size = 144;
    ethernet_mtu_cell = ceiling_func(15 * 1024 / 10, cell_size);
    standard_jumbo_frame_cell =
          ceiling_func(standard_jumbo_frame, cell_size);
    if (rev_id == BCM56170_B0_REV_ID) {
        total_physical_memory = 32 * 1024;
    } else {
        total_physical_memory = 24 * 1024;
    }
    total_cell_memory_for_admission = total_physical_memory * 7 / 8;;
    number_of_used_memory_banks = 8;
    reserved_for_cfap = 65 * 2 + number_of_used_memory_banks * 4;
    skidmarker = 7;
    prefetch = 64 + 4;
    total_cell_memory = total_cell_memory_for_admission;
    cfapfullsetpoint = total_physical_memory - reserved_for_cfap;
    total_advertised_cell_memory = total_cell_memory;
    flow_control_type_pause_0_pfc_1 = 1;

    propval = soc_property_get(unit, spn_MMU_LOSSLESS_FC_TYPE, 0);
    if (propval == 1) {
        /* PAUSE mode is specified. */
        flow_control_type_pause_0_pfc_1 = 0;
    } else if ((propval == 2) || (propval == 0)) {
        /* PFC mode is specified or use default mode (PFC). */
        flow_control_type_pause_0_pfc_1 = 1;
    } else {
        LOG_WARN(BSL_LS_SOC_COMMON,
                 (BSL_META_U(unit,
                 "Invalid MMU lossless flow control type specified. "
                 "Use default mode (PFC).\n")));
        flow_control_type_pause_0_pfc_1 = 1;
    }

    queue_port_limit_ratio = 8;
    headroom_for_1g_port = 30;
    headroom_for_2dot5g_port = 34;
    headroom_for_10g_port = 74;
    headroom_for_20g_port = 92;
    headroom_for_25g_port = 100;
    headroom_for_40g_port = 186;
    mmu_xoff_pkt_threshold_uplink_ports = total_advertised_cell_memory;
    mmu_xoff_pkt_threshold_downlink_ports = total_advertised_cell_memory;
    mmu_xoff_cell_threshold_1g_port_downlink_ports = headroom_for_1g_port;
    mmu_xoff_cell_threshold_2dot5g_port_downlink_ports =
          headroom_for_2dot5g_port;
    mmu_xoff_cell_threshold_10g_port_downlink_ports = headroom_for_10g_port;
    mmu_xoff_cell_threshold_20g_port_downlink_ports = headroom_for_20g_port;
    mmu_xoff_cell_threshold_25g_port_downlink_ports = headroom_for_25g_port;
    mmu_xoff_cell_threshold_40g_port_downlink_ports = headroom_for_40g_port;
    mmu_xoff_cell_threshold_all_uplink_ports = total_advertised_cell_memory;
    egress_xq_min_reserve_lossless_uplink_ports =
          (headroom_for_1g_port +
          mmu_xoff_cell_threshold_1g_port_downlink_ports) *
          num_1g_ports_downlink_ports + (headroom_for_2dot5g_port +
          mmu_xoff_cell_threshold_2dot5g_port_downlink_ports) *
          num_2dot5g_ports_downlink_ports + (headroom_for_10g_port +
          mmu_xoff_cell_threshold_10g_port_downlink_ports) *
          num_10g_ports_downlink_ports + (headroom_for_20g_port +
          mmu_xoff_cell_threshold_20g_port_downlink_ports) *
          num_20g_ports_downlink_ports + (headroom_for_25g_port +
          mmu_xoff_cell_threshold_25g_port_downlink_ports) *
          num_25g_ports_downlink_ports + (headroom_for_40g_port +
          mmu_xoff_cell_threshold_40g_port_downlink_ports) *
          num_40g_ports_downlink_ports;
    egress_xq_min_reserve_lossless_downlink_ports = 0;
    egress_xq_min_reserve_lossy_up_downlink_ports = ethernet_mtu_cell;
    egress_queue_min_reserve_uplink_ports_lossy = ethernet_mtu_cell;
    egress_queue_min_reserve_downlink_ports_lossy = ethernet_mtu_cell;
    egress_queue_min_reserve_uplink_ports_lossless =
          egress_xq_min_reserve_lossless_uplink_ports;
    egress_queue_min_reserve_downlink_ports_lossless = 0;
    egress_queue_min_reserve_cpu_ports = ethernet_mtu_cell;
    egress_xq_min_reserve_lossy_ports =
          ethernet_mtu_cell;
    num_active_pri_group_lossless = 1;
    num_lossy_queues = 7;
    num_cpu_queues = 8;
    num_cpu_ports = 1;
    numxqs_per_uplink_ports = 6 * 1024;
    numxqs_per_downlink_ports_and_cpu_port = 2 * 1024;
    xoff_cell_thresholds_per_port_1g_port_downlink_ports =
          mmu_xoff_cell_threshold_1g_port_downlink_ports;
    xoff_cell_thresholds_per_port_2dot5g_downlink_ports =
          mmu_xoff_cell_threshold_2dot5g_port_downlink_ports;
    xoff_cell_thresholds_per_port_10g_port_downlink_ports =
          mmu_xoff_cell_threshold_10g_port_downlink_ports;
    xoff_cell_threshold_all_uplink_ports =
          mmu_xoff_cell_threshold_all_uplink_ports;
    xoff_packet_thresholds_per_port_uplink_port =
          mmu_xoff_pkt_threshold_uplink_ports;
    xoff_packet_thresholds_per_port_downlink_port =
          mmu_xoff_pkt_threshold_downlink_ports;
    discard_limit_per_port_pg_uplink_1g_port =
          xoff_cell_thresholds_per_port_1g_port_downlink_ports +
          headroom_for_1g_port;
    discard_limit_per_port_pg_uplink_2dot5g_port =
          xoff_cell_thresholds_per_port_2dot5g_downlink_ports +
          headroom_for_2dot5g_port;
    discard_limit_per_port_pg_uplink_10g_port =
          xoff_cell_thresholds_per_port_10g_port_downlink_ports +
          headroom_for_10g_port;
    discard_limit_per_port_pg_downlink_port = total_advertised_cell_memory;
    total_reserved_cells_for_uplink_ports =
          egress_queue_min_reserve_uplink_ports_lossy *
          number_of_uplink_ports * num_lossy_queues + number_of_uplink_ports *
          egress_queue_min_reserve_uplink_ports_lossless *
          num_active_pri_group_lossless;
    total_reserved_cells_for_downlink_ports =
          number_of_downlink_ports *
          egress_queue_min_reserve_downlink_ports_lossy * (num_lossy_queues) +
          number_of_downlink_ports *
          egress_queue_min_reserve_downlink_ports_lossless;
    total_reserved_cells_for_cpu_port =
          num_cpu_ports * egress_queue_min_reserve_cpu_ports * num_cpu_queues;
    total_reserved =
          total_reserved_cells_for_uplink_ports +
          total_reserved_cells_for_downlink_ports +
          total_reserved_cells_for_cpu_port;
    shared_space_cells = total_advertised_cell_memory - total_reserved;
    reserved_xqs_per_uplink_port =
          egress_xq_min_reserve_lossy_ports *
          num_lossy_queues + egress_xq_min_reserve_lossless_uplink_ports;
    shared_xqs_per_uplink_port =
          numxqs_per_uplink_ports - reserved_xqs_per_uplink_port;
    reserved_xqs_per_downlink_port =
          egress_xq_min_reserve_lossy_ports *
          num_lossy_queues + egress_xq_min_reserve_lossless_downlink_ports;
    shared_xqs_per_downlink_port =
          numxqs_per_downlink_ports_and_cpu_port -
          reserved_xqs_per_downlink_port;
    cfapfullthreshold_cfapfullsetpoint_up = cfapfullsetpoint;
    gbllimitsetlimit_gblcellsetlimit_up = total_cell_memory_for_admission;
    totaldyncellsetlimit_totaldyncellsetlimit_up = shared_space_cells;
    holcosminxqcnt_qlayer8_holcosminxqcnt_up = 0;
    holcospktsetlimit0_pktsetlimit_up =
          shared_xqs_per_uplink_port +
          egress_xq_min_reserve_lossy_ports;
    holcospktsetlimit7_pktsetlimit_up =
          shared_xqs_per_uplink_port +
          egress_xq_min_reserve_lossless_uplink_ports;
    holcospktsetlimit_qlayer0_pktsetlimit_up =
          shared_xqs_per_uplink_port +
          egress_xq_min_reserve_lossy_ports;
    holcospktsetlimit_qlayer7_pktsetlimit_up =
          shared_xqs_per_uplink_port +
          egress_xq_min_reserve_lossless_uplink_ports;
    holcospktsetlimit_qlayer8_pktsetlimit_up =
          shared_xqs_per_uplink_port +
          holcosminxqcnt_qlayer8_holcosminxqcnt_up;
    dynxqcntport_dynxqcntport_up =
          shared_xqs_per_uplink_port - skidmarker - prefetch;
    lwmcoscellsetlimit0_cellsetlimit_up =
          egress_queue_min_reserve_uplink_ports_lossy;
    lwmcoscellsetlimit7_cellsetlimit_up =
          egress_queue_min_reserve_uplink_ports_lossless;
    lwmcoscellsetlimit_qlayer0_cellsetlimit_up =
          egress_queue_min_reserve_uplink_ports_lossy;
    lwmcoscellsetlimit_qlayer7_cellsetlimit_up =
          egress_queue_min_reserve_uplink_ports_lossless;
    lwmcoscellsetlimit_qlayer8_cellsetlimit_up = 0;
    holcoscellmaxlimit0_cellmaxlimit_up =
          ceiling_func(shared_space_cells, queue_port_limit_ratio) +
          lwmcoscellsetlimit0_cellsetlimit_up;
    holcoscellmaxlimit7_cellmaxlimit_up =
          ceiling_func(shared_space_cells, queue_port_limit_ratio) +
          lwmcoscellsetlimit7_cellsetlimit_up;
    holcoscellmaxlimit_qlayer0_cellmaxlimit_up =
          ceiling_func(shared_space_cells, queue_port_limit_ratio) +
          lwmcoscellsetlimit_qlayer0_cellsetlimit_up;
    holcoscellmaxlimit_qlayer7_cellmaxlimit_up =
          ceiling_func(shared_space_cells, queue_port_limit_ratio) +
          lwmcoscellsetlimit_qlayer7_cellsetlimit_up;
    holcoscellmaxlimit_qlayer8_cellmaxlimit_up =
          ceiling_func(shared_space_cells, queue_port_limit_ratio) +
          lwmcoscellsetlimit_qlayer8_cellsetlimit_up;
    dyncelllimit_dyncellsetlimit_up = shared_space_cells;
    holcospktsetlimit_qgroup0_pktsetlimit_up = numxqs_per_uplink_ports - 1;
    holcoscellmaxlimit_qgroup0_cellmaxlimit_up =
          ceiling_func(total_advertised_cell_memory, queue_port_limit_ratio);
    holcosminxqcnt_qlayer8_holcosminxqcnt_down_1 = 0;
    holcospktsetlimit0_pktsetlimit_down_1 =
          shared_xqs_per_downlink_port +
          egress_xq_min_reserve_lossy_ports;
    holcospktsetlimit7_pktsetlimit_down_1 =
          shared_xqs_per_downlink_port +
          egress_xq_min_reserve_lossless_downlink_ports;
    holcospktsetlimit_qlayer0_pktsetlimit_down_1 =
          shared_xqs_per_downlink_port +
          egress_xq_min_reserve_lossy_ports;
    holcospktsetlimit_qlayer7_pktsetlimit_down_1 =
          shared_xqs_per_downlink_port +
          egress_xq_min_reserve_lossless_downlink_ports;
    holcospktsetlimit_qlayer8_pktsetlimit_down_1 =
          shared_xqs_per_downlink_port +
          holcosminxqcnt_qlayer8_holcosminxqcnt_down_1;
    dynxqcntport_dynxqcntport_down_1 =
          shared_xqs_per_downlink_port - skidmarker - prefetch;
    lwmcoscellsetlimit0_cellsetlimit_down_1 =
              egress_queue_min_reserve_downlink_ports_lossy;
    lwmcoscellsetlimit7_cellsetlimit_down_1 =
              egress_queue_min_reserve_downlink_ports_lossless;
    lwmcoscellsetlimit_qlayer0_cellsetlimit_down_1 =
              egress_queue_min_reserve_downlink_ports_lossy;
    lwmcoscellsetlimit_qlayer7_cellsetlimit_down_1 =
              egress_queue_min_reserve_downlink_ports_lossless;
    lwmcoscellsetlimit_qlayer8_cellsetlimit_down_1 = 0;
    holcoscellmaxlimit0_cellmaxlimit_down_1 =
          ceiling_func(shared_space_cells, queue_port_limit_ratio) +
          lwmcoscellsetlimit0_cellsetlimit_down_1;
    holcoscellmaxlimit7_cellmaxlimit_down_1 =
          ceiling_func(shared_space_cells, queue_port_limit_ratio) +
          lwmcoscellsetlimit7_cellsetlimit_down_1;
    holcoscellmaxlimit_qlayer0_cellmaxlimit_down_1 =
          ceiling_func(shared_space_cells, queue_port_limit_ratio) +
          lwmcoscellsetlimit_qlayer0_cellsetlimit_down_1;
    holcoscellmaxlimit_qlayer7_cellmaxlimit_down_1 =
          ceiling_func(shared_space_cells, queue_port_limit_ratio) +
          lwmcoscellsetlimit_qlayer7_cellsetlimit_down_1;
    holcoscellmaxlimit_qlayer8_cellmaxlimit_down_1 =
          ceiling_func(shared_space_cells, queue_port_limit_ratio) +
          lwmcoscellsetlimit_qlayer8_cellsetlimit_down_1;
    dyncelllimit_dyncellsetlimit_down_1 = shared_space_cells;
    holcospktsetlimit_qgroup0_pktsetlimit_down_1 =
          numxqs_per_downlink_ports_and_cpu_port - 1;
    holcoscellmaxlimit_qgroup0_cellmaxlimit_down_1 =
          ceiling_func(total_advertised_cell_memory, queue_port_limit_ratio);
    holcosminxqcnt_qlayer8_holcosminxqcnt_down_2dot5 = 0;
    holcospktsetlimit0_pktsetlimit_down_2dot5 =
          shared_xqs_per_downlink_port +
          egress_xq_min_reserve_lossy_ports;
    holcospktsetlimit7_pktsetlimit_down_2dot5 =
          shared_xqs_per_downlink_port +
          egress_xq_min_reserve_lossless_downlink_ports;
    holcospktsetlimit_qlayer0_pktsetlimit_down_2dot5 =
          shared_xqs_per_downlink_port +
          egress_xq_min_reserve_lossy_ports;
    holcospktsetlimit_qlayer7_pktsetlimit_down_2dot5 =
          shared_xqs_per_downlink_port +
          egress_xq_min_reserve_lossless_downlink_ports;
    holcospktsetlimit_qlayer8_pktsetlimit_down_2dot5 =
          shared_xqs_per_downlink_port +
          holcosminxqcnt_qlayer8_holcosminxqcnt_down_2dot5;
    dynxqcntport_dynxqcntport_down_2dot5 =
          shared_xqs_per_downlink_port - skidmarker - prefetch;
    lwmcoscellsetlimit0_cellsetlimit_down_2dot5 =
              egress_queue_min_reserve_downlink_ports_lossy;
    lwmcoscellsetlimit7_cellsetlimit_down_2dot5 =
              egress_queue_min_reserve_downlink_ports_lossless;
    lwmcoscellsetlimit_qlayer0_cellsetlimit_down_2dot5 =
              egress_queue_min_reserve_downlink_ports_lossy;
    lwmcoscellsetlimit_qlayer7_cellsetlimit_down_2dot5 =
              egress_queue_min_reserve_downlink_ports_lossless;
    lwmcoscellsetlimit_qlayer8_cellsetlimit_down_2dot5 = 0;
    holcoscellmaxlimit0_cellmaxlimit_down_2dot5 =
          ceiling_func(shared_space_cells, queue_port_limit_ratio) +
          lwmcoscellsetlimit0_cellsetlimit_down_2dot5;
    holcoscellmaxlimit7_cellmaxlimit_down_2dot5 =
          ceiling_func(shared_space_cells, queue_port_limit_ratio) +
          lwmcoscellsetlimit7_cellsetlimit_down_2dot5;
    holcoscellmaxlimit_qlayer0_cellmaxlimit_down_2dot5 =
          ceiling_func(shared_space_cells, queue_port_limit_ratio) +
          lwmcoscellsetlimit_qlayer0_cellsetlimit_down_2dot5;
    holcoscellmaxlimit_qlayer7_cellmaxlimit_down_2dot5 =
          ceiling_func(shared_space_cells, queue_port_limit_ratio) +
          lwmcoscellsetlimit_qlayer7_cellsetlimit_down_2dot5;
    holcoscellmaxlimit_qlayer8_cellmaxlimit_down_2dot5 =
          ceiling_func(shared_space_cells, queue_port_limit_ratio) +
          lwmcoscellsetlimit_qlayer8_cellsetlimit_down_2dot5;
    dyncelllimit_dyncellsetlimit_down_2dot5 = shared_space_cells;
    holcospktsetlimit_qgroup0_pktsetlimit_down_2dot5 =
          numxqs_per_downlink_ports_and_cpu_port - 1;
    holcoscellmaxlimit_qgroup0_cellmaxlimit_down_2dot5 =
          ceiling_func(total_advertised_cell_memory, queue_port_limit_ratio);
    holcosminxqcnt_qlayer8_holcosminxqcnt_down_10 = 0;
    holcospktsetlimit0_pktsetlimit_down_10 =
          shared_xqs_per_downlink_port +
          egress_xq_min_reserve_lossy_ports;
    holcospktsetlimit7_pktsetlimit_down_10 =
          shared_xqs_per_downlink_port +
          egress_xq_min_reserve_lossless_downlink_ports;
    holcospktsetlimit_qlayer0_pktsetlimit_down_10 =
          shared_xqs_per_downlink_port +
          egress_xq_min_reserve_lossy_ports;
    holcospktsetlimit_qlayer7_pktsetlimit_down_10 =
          shared_xqs_per_downlink_port +
          egress_xq_min_reserve_lossless_downlink_ports;
    holcospktsetlimit_qlayer8_pktsetlimit_down_10 =
          shared_xqs_per_downlink_port +
          holcosminxqcnt_qlayer8_holcosminxqcnt_down_10;
    dynxqcntport_dynxqcntport_down_10 =
          shared_xqs_per_downlink_port - skidmarker - prefetch;
    lwmcoscellsetlimit0_cellsetlimit_down_10 =
              egress_queue_min_reserve_downlink_ports_lossy;
    lwmcoscellsetlimit7_cellsetlimit_down_10 =
              egress_queue_min_reserve_downlink_ports_lossless;
    lwmcoscellsetlimit_qlayer0_cellsetlimit_down_10 =
              egress_queue_min_reserve_downlink_ports_lossy;
    lwmcoscellsetlimit_qlayer7_cellsetlimit_down_10 =
              egress_queue_min_reserve_downlink_ports_lossless;
    lwmcoscellsetlimit_qlayer8_cellsetlimit_down_10 = 0;
    holcoscellmaxlimit0_cellmaxlimit_down_10 =
          ceiling_func(shared_space_cells, queue_port_limit_ratio) +
          lwmcoscellsetlimit0_cellsetlimit_down_10;
    holcoscellmaxlimit7_cellmaxlimit_down_10 =
          ceiling_func(shared_space_cells, queue_port_limit_ratio) +
          lwmcoscellsetlimit7_cellsetlimit_down_10;
    holcoscellmaxlimit_qlayer0_cellmaxlimit_down_10 =
          ceiling_func(shared_space_cells, queue_port_limit_ratio) +
          lwmcoscellsetlimit_qlayer0_cellsetlimit_down_10;
    holcoscellmaxlimit_qlayer7_cellmaxlimit_down_10 =
          ceiling_func(shared_space_cells, queue_port_limit_ratio) +
          lwmcoscellsetlimit_qlayer7_cellsetlimit_down_10;
    holcoscellmaxlimit_qlayer8_cellmaxlimit_down_10 =
          ceiling_func(shared_space_cells, queue_port_limit_ratio) +
          lwmcoscellsetlimit_qlayer8_cellsetlimit_down_10;
    dyncelllimit_dyncellsetlimit_down_10 = shared_space_cells;
    holcospktsetlimit_qgroup0_pktsetlimit_down_10 =
          numxqs_per_downlink_ports_and_cpu_port - 1;
    holcoscellmaxlimit_qgroup0_cellmaxlimit_down_10 =
          ceiling_func(total_advertised_cell_memory, queue_port_limit_ratio);
    holcospktsetlimit0_pktsetlimit_cpu =
          shared_xqs_per_downlink_port +
          egress_xq_min_reserve_lossy_ports;
    holcospktsetlimit7_pktsetlimit_cpu =
          shared_xqs_per_downlink_port +
          egress_xq_min_reserve_lossless_downlink_ports;
    dynxqcntport_dynxqcntport_cpu =
          shared_xqs_per_downlink_port - skidmarker - prefetch;
    lwmcoscellsetlimit0_cellsetlimit_cpu = egress_queue_min_reserve_cpu_ports;
    lwmcoscellsetlimit7_cellsetlimit_cpu = egress_queue_min_reserve_cpu_ports;
    holcoscellmaxlimit0_cellmaxlimit_cpu =
          ceiling_func(shared_space_cells, queue_port_limit_ratio) +
          lwmcoscellsetlimit0_cellsetlimit_cpu;
    holcoscellmaxlimit7_cellmaxlimit_cpu =
          ceiling_func(shared_space_cells, queue_port_limit_ratio) +
          lwmcoscellsetlimit7_cellsetlimit_cpu;
    dyncelllimit_dyncellsetlimit_cpu = shared_space_cells;

    if ((shared_space_cells * cell_size)/1024 <= 800) {
        LOG_CLI((BSL_META_U(unit,
                 "Shared Pool Is Small,\
                 should be larger than 800 (value=%d)\n"),
                 (shared_space_cells * cell_size)/1024));
        return SOC_E_PARAM;
    }

    /* system-based */
    soc_reg_field32_modify(unit, CFAPFULLTHRESHOLDr,
                           REG_PORT_ANY,
                           CFAPFULLSETPOINTf,
                           cfapfullsetpoint);
    soc_reg_field32_modify(unit, CFAPFULLTHRESHOLDr,
                           REG_PORT_ANY,
                           CFAPFULLRESETPOINTf,
                           cfapfullthreshold_cfapfullsetpoint_up -
                           (standard_jumbo_frame_cell * 2));
    soc_reg_field32_modify(unit, GBLLIMITSETLIMITr,
                           REG_PORT_ANY,
                           GBLCELLSETLIMITf,
                           total_cell_memory_for_admission);
    soc_reg_field32_modify(unit, GBLLIMITRESETLIMITr,
                           REG_PORT_ANY,
                           GBLCELLRESETLIMITf,
                           gbllimitsetlimit_gblcellsetlimit_up);
    soc_reg_field32_modify(unit, TOTALDYNCELLSETLIMITr,
                           REG_PORT_ANY,
                           TOTALDYNCELLSETLIMITf,
                           shared_space_cells);
    soc_reg_field32_modify(unit, TOTALDYNCELLRESETLIMITr,
                           REG_PORT_ANY,
                           TOTALDYNCELLRESETLIMITf,
                           totaldyncellsetlimit_totaldyncellsetlimit_up -
                           (standard_jumbo_frame_cell * 2));
    soc_reg_field32_modify(unit, TWO_LAYER_SCH_MODEr,
                           REG_PORT_ANY,
                           SCH_MODEf,
                           0);
    soc_reg_field32_modify(unit, MISCCONFIGr,
                           REG_PORT_ANY,
                           MULTIPLE_ACCOUNTING_FIX_ENf,
                           1);
    soc_reg_field32_modify(unit, MISCCONFIGr,
                           REG_PORT_ANY,
                           CNG_DROP_ENf,
                           0);
    soc_reg_field32_modify(unit, MISCCONFIGr,
                           REG_PORT_ANY,
                           DYN_XQ_ENf,
                           1);
    soc_reg_field32_modify(unit, MISCCONFIGr,
                           REG_PORT_ANY,
                           HOL_CELL_SOP_DROP_ENf,
                           1);
    soc_reg_field32_modify(unit, MISCCONFIGr,
                           REG_PORT_ANY,
                           DYNAMIC_MEMORY_ENf,
                           1);
    soc_reg_field32_modify(unit, MISCCONFIGr,
                           REG_PORT_ANY,
                           SKIDMARKERf,
                           3);
    soc_reg_field32_modify(unit, MMUPORTTXENABLE_0r,
                           REG_PORT_ANY,
                           MMUPORTTXENABLEf,
                           0xFFFFFFFF);
    soc_reg_field32_modify(unit, MMUPORTTXENABLE_1r,
                           REG_PORT_ANY,
                           MMUPORTTXENABLEf,
                           0xFFFFFFFF);
    soc_reg_field32_modify(unit, MMUPORTTXENABLE_2r,
                           REG_PORT_ANY,
                           MMUPORTTXENABLEf,
                           3);

    /* port-based : uplink */
    SOC_PBMP_ITER(pbmp_uplink, port) {
        /* PG_CTRL0r, index 0 */
        soc_reg32_get(unit, PG_CTRL0r,
                      port, 0, &rval);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PPFC_PG_ENf,
                          0);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI0_GRPf,
                          /* coverity[dead_error_line : FALSE] */
                          flow_control_type_pause_0_pfc_1?0:7);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI1_GRPf,
                          /* coverity[dead_error_line : FALSE] */
                          flow_control_type_pause_0_pfc_1?1:7);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI2_GRPf,
                          /* coverity[dead_error_line : FALSE] */
                          flow_control_type_pause_0_pfc_1?2:7);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI3_GRPf,
                          /* coverity[dead_error_line : FALSE] */
                          flow_control_type_pause_0_pfc_1?3:7);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI4_GRPf,
                          /* coverity[dead_error_line : FALSE] */
                          flow_control_type_pause_0_pfc_1?4:7);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI5_GRPf,
                          /* coverity[dead_error_line : FALSE] */
                          flow_control_type_pause_0_pfc_1?5:7);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI6_GRPf,
                          /* coverity[dead_error_line : FALSE] */
                          flow_control_type_pause_0_pfc_1?6:7);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI7_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg32_set(unit, PG_CTRL0r,
                      port, 0, rval);

        /* PG_CTRL1r, index 0 */
        soc_reg32_get(unit, PG_CTRL1r,
                      port, 0, &rval);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI8_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI9_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI10_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI11_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI12_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI13_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI14_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI15_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg32_set(unit, PG_CTRL1r,
                      port, 0, rval);

        /* PG2TCr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, PG2TCr,
                          port, index, &rval);
            soc_reg_field_set(unit, PG2TCr, &rval,
                              PG_BMPf,
                              0);
            soc_reg32_set(unit, PG2TCr,
                          port, index, rval);
        }

        /* IBPPKTSETLIMITr, index 0 */
        soc_reg32_get(unit, IBPPKTSETLIMITr,
                      port, 0, &rval);
        soc_reg_field_set(unit, IBPPKTSETLIMITr, &rval,
                          PKTSETLIMITf,
                          xoff_packet_thresholds_per_port_uplink_port);
        soc_reg_field_set(unit, IBPPKTSETLIMITr, &rval,
                          RESETLIMITSELf,
                          3);
        soc_reg32_set(unit, IBPPKTSETLIMITr,
                      port, 0, rval);

        /* MMU_FC_RX_ENr, index 0 */
        soc_reg32_get(unit, MMU_FC_RX_ENr,
                      port, 0, &rval);
        soc_reg_field_set(unit, MMU_FC_RX_ENr, &rval,
                          MMU_FC_RX_ENABLEf,
                          0);
        soc_reg32_set(unit, MMU_FC_RX_ENr,
                      port, 0, rval);

        /* MMU_FC_TX_ENr, index 0 */
        soc_reg32_get(unit, MMU_FC_TX_ENr,
                      port, 0, &rval);
        soc_reg_field_set(unit, MMU_FC_TX_ENr, &rval,
                          MMU_FC_TX_ENABLEf,
                          0);
        soc_reg32_set(unit, MMU_FC_TX_ENr,
                      port, 0, rval);

        /* PGCELLLIMITr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, PGCELLLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, PGCELLLIMITr, &rval,
                              CELLSETLIMITf,
                              xoff_cell_threshold_all_uplink_ports);
            soc_reg32_set(unit, PGCELLLIMITr,
                          port, index, rval);
        }

        /* PGCELLLIMITr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, PGCELLLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, PGCELLLIMITr, &rval,
                              CELLRESETLIMITf,
                              xoff_cell_threshold_all_uplink_ports);
            soc_reg32_set(unit, PGCELLLIMITr,
                          port, index, rval);
        }

        /* PGDISCARDSETLIMITr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, PGDISCARDSETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, PGDISCARDSETLIMITr, &rval,
                              DISCARDSETLIMITf,
                              discard_limit_per_port_pg_downlink_port);
            soc_reg32_set(unit, PGDISCARDSETLIMITr,
                          port, index, rval);
        }

        /* HOLCOSMINXQCNTr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSMINXQCNTr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSMINXQCNTr, &rval,
                              HOLCOSMINXQCNTf,
                              egress_xq_min_reserve_lossy_ports);
            soc_reg32_set(unit, HOLCOSMINXQCNTr,
                          port, index, rval);
        }

        /* HOLCOSMINXQCNTr, index 7 */
        soc_reg32_get(unit, HOLCOSMINXQCNTr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSMINXQCNTr, &rval,
                          HOLCOSMINXQCNTf,
                          egress_xq_min_reserve_lossless_uplink_ports);
        soc_reg32_set(unit, HOLCOSMINXQCNTr,
                      port, 7, rval);

        /* HOLCOSMINXQCNT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSMINXQCNT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSMINXQCNT_QLAYERr, &rval,
                              HOLCOSMINXQCNTf,
                              egress_xq_min_reserve_lossy_ports);
            soc_reg32_set(unit, HOLCOSMINXQCNT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSMINXQCNT_QLAYERr, index 7 */
        soc_reg32_get(unit, HOLCOSMINXQCNT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSMINXQCNT_QLAYERr, &rval,
                          HOLCOSMINXQCNTf,
                          egress_xq_min_reserve_lossless_uplink_ports);
        soc_reg32_set(unit, HOLCOSMINXQCNT_QLAYERr,
                      port, 7, rval);

        /* HOLCOSMINXQCNT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, HOLCOSMINXQCNT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSMINXQCNT_QLAYERr, &rval,
                              HOLCOSMINXQCNTf,
                              0);
            soc_reg32_set(unit, HOLCOSMINXQCNT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSPKTSETLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSPKTSETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTSETLIMITr, &rval,
                              PKTSETLIMITf,
                              shared_xqs_per_uplink_port +
                              egress_xq_min_reserve_lossy_ports);
            soc_reg32_set(unit, HOLCOSPKTSETLIMITr,
                          port, index, rval);
        }

        /* HOLCOSPKTSETLIMITr, index 7 */
        soc_reg32_get(unit, HOLCOSPKTSETLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSPKTSETLIMITr, &rval,
                          PKTSETLIMITf,
                          shared_xqs_per_uplink_port +
                          egress_xq_min_reserve_lossless_uplink_ports);
        soc_reg32_set(unit, HOLCOSPKTSETLIMITr,
                      port, 7, rval);

        /* HOLCOSPKTSETLIMIT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTSETLIMIT_QLAYERr, &rval,
                              PKTSETLIMITf,
                              shared_xqs_per_uplink_port +
                              egress_xq_min_reserve_lossy_ports);
            soc_reg32_set(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSPKTSETLIMIT_QLAYERr, index 7 */
        soc_reg32_get(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSPKTSETLIMIT_QLAYERr, &rval,
                          PKTSETLIMITf,
                          shared_xqs_per_uplink_port +
                          egress_xq_min_reserve_lossless_uplink_ports);
        soc_reg32_set(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                      port, 7, rval);

        /* HOLCOSPKTSETLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTSETLIMIT_QLAYERr, &rval,
                              PKTSETLIMITf,
                              shared_xqs_per_uplink_port +
                              holcosminxqcnt_qlayer8_holcosminxqcnt_up);
            soc_reg32_set(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSPKTRESETLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSPKTRESETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTRESETLIMITr, &rval,
                              PKTRESETLIMITf,
                              holcospktsetlimit0_pktsetlimit_up - 1);
            soc_reg32_set(unit, HOLCOSPKTRESETLIMITr,
                          port, index, rval);
        }

        /* HOLCOSPKTRESETLIMITr, index 7 */
        soc_reg32_get(unit, HOLCOSPKTRESETLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSPKTRESETLIMITr, &rval,
                          PKTRESETLIMITf,
                          holcospktsetlimit7_pktsetlimit_up - 1);
        soc_reg32_set(unit, HOLCOSPKTRESETLIMITr,
                      port, 7, rval);

        /* HOLCOSPKTRESETLIMIT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr, &rval,
                              PKTRESETLIMITf,
                              holcospktsetlimit_qlayer0_pktsetlimit_up - 1);
            soc_reg32_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSPKTRESETLIMIT_QLAYERr, index 7 */
        soc_reg32_get(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr, &rval,
                          PKTRESETLIMITf,
                          holcospktsetlimit_qlayer7_pktsetlimit_up - 1);
        soc_reg32_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                      port, 7, rval);

        /* HOLCOSPKTRESETLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr, &rval,
                              PKTRESETLIMITf,
                              holcospktsetlimit_qlayer8_pktsetlimit_up - 1);
            soc_reg32_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT0r, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT0r,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT0r, &rval,
                              CNGPKTSETLIMIT0f,
                              numxqs_per_uplink_ports - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT0r,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT1r, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT1r,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT1r, &rval,
                              CNGPKTSETLIMIT1f,
                              numxqs_per_uplink_ports - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT1r,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT0_QLAYERr, index 0 ~ 63 */
        for (index = 0; index <= 63; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT0_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT0_QLAYERr, &rval,
                              CNGPKTSETLIMIT0f,
                              numxqs_per_uplink_ports - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT0_QLAYERr,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT1_QLAYERr, index 0 ~ 63 */
        for (index = 0; index <= 63; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT1_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT1_QLAYERr, &rval,
                              CNGPKTSETLIMIT1f,
                              numxqs_per_uplink_ports - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT1_QLAYERr,
                          port, index, rval);
        }

        /* CNGPORTPKTLIMIT0r, index 0 */
        soc_reg32_get(unit, CNGPORTPKTLIMIT0r,
                      port, 0, &rval);
        soc_reg_field_set(unit, CNGPORTPKTLIMIT0r, &rval,
                          CNGPORTPKTLIMIT0f,
                          numxqs_per_uplink_ports - 1);
        soc_reg32_set(unit, CNGPORTPKTLIMIT0r,
                      port, 0, rval);

        /* CNGPORTPKTLIMIT1r, index 0 */
        soc_reg32_get(unit, CNGPORTPKTLIMIT1r,
                      port, 0, &rval);
        soc_reg_field_set(unit, CNGPORTPKTLIMIT1r, &rval,
                          CNGPORTPKTLIMIT1f,
                          numxqs_per_uplink_ports - 1);
        soc_reg32_set(unit, CNGPORTPKTLIMIT1r,
                      port, 0, rval);

        /* DYNXQCNTPORTr, index 0 */
        soc_reg32_get(unit, DYNXQCNTPORTr,
                      port, 0, &rval);
        soc_reg_field_set(unit, DYNXQCNTPORTr, &rval,
                          DYNXQCNTPORTf,
                          shared_xqs_per_uplink_port - skidmarker - prefetch);
        soc_reg32_set(unit, DYNXQCNTPORTr,
                      port, 0, rval);

        /* DYNRESETLIMPORTr, index 0 */
        soc_reg32_get(unit, DYNRESETLIMPORTr,
                      port, 0, &rval);
        soc_reg_field_set(unit, DYNRESETLIMPORTr, &rval,
                          DYNRESETLIMPORTf,
                          dynxqcntport_dynxqcntport_up - 2);
        soc_reg32_set(unit, DYNRESETLIMPORTr,
                      port, 0, rval);

        /* LWMCOSCELLSETLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMITr, &rval,
                              CELLSETLIMITf,
                              egress_queue_min_reserve_uplink_ports_lossy);
            soc_reg32_set(unit, LWMCOSCELLSETLIMITr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMITr, index 7 */
        soc_reg32_get(unit, LWMCOSCELLSETLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, LWMCOSCELLSETLIMITr, &rval,
                          CELLSETLIMITf,
                          egress_queue_min_reserve_uplink_ports_lossless);
        soc_reg32_set(unit, LWMCOSCELLSETLIMITr,
                      port, 7, rval);

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                              CELLSETLIMITf,
                              egress_queue_min_reserve_uplink_ports_lossy);
            soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 7 */
        soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                          CELLSETLIMITf,
                          egress_queue_min_reserve_uplink_ports_lossless);
        soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                      port, 7, rval);

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                              CELLSETLIMITf,
                              0);
            soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMITr, &rval,
                              CELLRESETLIMITf,
                              egress_queue_min_reserve_uplink_ports_lossy);
            soc_reg32_set(unit, LWMCOSCELLSETLIMITr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMITr, index 7 */
        soc_reg32_get(unit, LWMCOSCELLSETLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, LWMCOSCELLSETLIMITr, &rval,
                          CELLRESETLIMITf,
                          egress_queue_min_reserve_uplink_ports_lossless);
        soc_reg32_set(unit, LWMCOSCELLSETLIMITr,
                      port, 7, rval);

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                              CELLRESETLIMITf,
                              egress_queue_min_reserve_uplink_ports_lossy);
            soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 7 */
        soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                          CELLRESETLIMITf,
                          egress_queue_min_reserve_uplink_ports_lossless);
        soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                      port, 7, rval);

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                              CELLRESETLIMITf,
                              0);
            soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                              CELLMAXLIMITf,
                              ceiling_func(shared_space_cells,
                                           queue_port_limit_ratio) +
                              lwmcoscellsetlimit0_cellsetlimit_up);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMITr, index 7 */
        soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                          CELLMAXLIMITf,
                          ceiling_func(shared_space_cells,
                                       queue_port_limit_ratio) +
                          lwmcoscellsetlimit7_cellsetlimit_up);
        soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                      port, 7, rval);

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                              CELLMAXLIMITf,
                              ceiling_func(shared_space_cells,
                                           queue_port_limit_ratio) +
                              lwmcoscellsetlimit_qlayer0_cellsetlimit_up);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 7 */
        soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                          CELLMAXLIMITf,
                          ceiling_func(shared_space_cells,
                                       queue_port_limit_ratio) +
                          lwmcoscellsetlimit_qlayer7_cellsetlimit_up);
        soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                      port, 7, rval);

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                              CELLMAXLIMITf,
                              ceiling_func(shared_space_cells,
                                           queue_port_limit_ratio) +
                              lwmcoscellsetlimit_qlayer8_cellsetlimit_up);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                              CELLMAXRESUMELIMITf,
                              holcoscellmaxlimit0_cellmaxlimit_up -
                              ethernet_mtu_cell);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMITr, index 7 */
        soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                          CELLMAXRESUMELIMITf,
                          holcoscellmaxlimit7_cellmaxlimit_up -
                          ethernet_mtu_cell);
        soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                      port, 7, rval);

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                              CELLMAXRESUMELIMITf,
                              holcoscellmaxlimit_qlayer0_cellmaxlimit_up -
                              ethernet_mtu_cell);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 7 */
        soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                          CELLMAXRESUMELIMITf,
                          holcoscellmaxlimit_qlayer7_cellmaxlimit_up -
                          ethernet_mtu_cell);
        soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                      port, 7, rval);

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                              CELLMAXRESUMELIMITf,
                              holcoscellmaxlimit_qlayer8_cellmaxlimit_up -
                              ethernet_mtu_cell);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* DYNCELLLIMITr, index 0 */
        soc_reg32_get(unit, DYNCELLLIMITr,
                      port, 0, &rval);
        soc_reg_field_set(unit, DYNCELLLIMITr, &rval,
                          DYNCELLSETLIMITf,
                          shared_space_cells);
        soc_reg_field_set(unit, DYNCELLLIMITr, &rval,
                          DYNCELLRESETLIMITf,
                          dyncelllimit_dyncellsetlimit_up -
                          (2 * ethernet_mtu_cell));
        soc_reg32_set(unit, DYNCELLLIMITr,
                      port, 0, rval);

        /* COLOR_DROP_ENr, index 0 */
        soc_reg32_get(unit, COLOR_DROP_ENr,
                      port, 0, &rval);
        soc_reg_field_set(unit, COLOR_DROP_ENr, &rval,
                          COLOR_DROP_ENf,
                          0);
        soc_reg32_set(unit, COLOR_DROP_ENr,
                      port, 0, rval);

        /* COLOR_DROP_EN_QLAYERr, index 0 */
        soc_reg32_get(unit, COLOR_DROP_EN_QLAYERr,
                      port, 0, &rval);
        soc_reg_field_set(unit, COLOR_DROP_EN_QLAYERr, &rval,
                          COLOR_DROP_ENf,
                          0);
        soc_reg32_set(unit, COLOR_DROP_EN_QLAYERr,
                      port, 0, rval);

        /* HOLCOSPKTSETLIMIT_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSPKTSETLIMIT_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTSETLIMIT_QGROUPr, &rval,
                              PKTSETLIMITf,
                              numxqs_per_uplink_ports - 1);
            soc_reg32_set(unit, HOLCOSPKTSETLIMIT_QGROUPr,
                          port, index, rval);
        }

        /* HOLCOSPKTRESETLIMIT_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSPKTRESETLIMIT_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTRESETLIMIT_QGROUPr, &rval,
                              PKTRESETLIMITf,
                              holcospktsetlimit_qgroup0_pktsetlimit_up - 1);
            soc_reg32_set(unit, HOLCOSPKTRESETLIMIT_QGROUPr,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT0_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT0_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT0_QGROUPr, &rval,
                              CNGPKTSETLIMIT0f,
                              numxqs_per_uplink_ports - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT0_QGROUPr,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT1_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT1_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT1_QGROUPr, &rval,
                              CNGPKTSETLIMIT1f,
                              numxqs_per_uplink_ports - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT1_QGROUPr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMIT_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QGROUPr, &rval,
                              CELLMAXLIMITf,
                              ceiling_func(total_advertised_cell_memory,
                                           queue_port_limit_ratio));
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QGROUPr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMIT_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QGROUPr, &rval,
                              CELLMAXRESUMELIMITf,
                              holcoscellmaxlimit_qgroup0_cellmaxlimit_up -
                              ethernet_mtu_cell);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QGROUPr,
                          port, index, rval);
        }

        /* COLOR_DROP_EN_QGROUPr, index 0 */
        soc_reg32_get(unit, COLOR_DROP_EN_QGROUPr,
                      port, 0, &rval);
        soc_reg_field_set(unit, COLOR_DROP_EN_QGROUPr, &rval,
                          COLOR_DROP_ENf,
                          0);
        soc_reg32_set(unit, COLOR_DROP_EN_QGROUPr,
                      port, 0, rval);

        /* SHARED_POOL_CTRLr, index 0 */
        soc_reg32_get(unit, SHARED_POOL_CTRLr,
                      port, 0, &rval);
        soc_reg_field_set(unit, SHARED_POOL_CTRLr, &rval,
                          DYNAMIC_COS_DROP_ENf,
                          255);
        soc_reg_field_set(unit, SHARED_POOL_CTRLr, &rval,
                          SHARED_POOL_DISCARD_ENf,
                          127);
        soc_reg_field_set(unit, SHARED_POOL_CTRLr, &rval,
                          SHARED_POOL_XOFF_ENf,
                          0);
        soc_reg32_set(unit, SHARED_POOL_CTRLr,
                      port, 0, rval);

        /* SHARED_POOL_CTRL_EXT1r, index 0 */
        soc_reg32_get(unit, SHARED_POOL_CTRL_EXT1r,
                      port, 0, &rval);
        soc_reg_field_set(unit, SHARED_POOL_CTRL_EXT1r, &rval,
                          DYNAMIC_COS_DROP_ENf,
                          0xFFFFFF);
        soc_reg32_set(unit, SHARED_POOL_CTRL_EXT1r,
                      port, 0, rval);

        /* SHARED_POOL_CTRL_EXT2r, index 0 */
        soc_reg32_get(unit, SHARED_POOL_CTRL_EXT2r,
                      port, 0, &rval);
        soc_reg_field_set(unit, SHARED_POOL_CTRL_EXT2r, &rval,
                          DYNAMIC_COS_DROP_ENf,
                          0xFFFFFFFF);
        soc_reg32_set(unit, SHARED_POOL_CTRL_EXT2r,
                      port, 0, rval);
    }

    /* port-based : downlink 1G */
    SOC_PBMP_ITER(pbmp_downlink_1g, port) {
        /* PG_CTRL0r, index 0 */
        soc_reg32_get(unit, PG_CTRL0r,
                      port, 0, &rval);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PPFC_PG_ENf,
                          128);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI0_GRPf,
                          /* coverity[dead_error_line : FALSE] */
                          flow_control_type_pause_0_pfc_1?0:7);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI1_GRPf,
                          /* coverity[dead_error_line : FALSE] */
                          flow_control_type_pause_0_pfc_1?1:7);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI2_GRPf,
                          /* coverity[dead_error_line : FALSE] */
                          flow_control_type_pause_0_pfc_1?2:7);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI3_GRPf,
                          /* coverity[dead_error_line : FALSE] */
                          flow_control_type_pause_0_pfc_1?3:7);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI4_GRPf,
                          /* coverity[dead_error_line : FALSE] */
                          flow_control_type_pause_0_pfc_1?4:7);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI5_GRPf,
                          /* coverity[dead_error_line : FALSE] */
                          flow_control_type_pause_0_pfc_1?5:7);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI6_GRPf,
                          /* coverity[dead_error_line : FALSE] */
                          flow_control_type_pause_0_pfc_1?6:7);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI7_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg32_set(unit, PG_CTRL0r,
                      port, 0, rval);

        /* PG_CTRL1r, index 0 */
        soc_reg32_get(unit, PG_CTRL1r,
                      port, 0, &rval);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI8_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI9_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI10_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI11_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI12_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI13_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI14_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI15_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg32_set(unit, PG_CTRL1r,
                      port, 0, rval);

        /* PG2TCr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, PG2TCr,
                          port, index, &rval);
            soc_reg_field_set(unit, PG2TCr, &rval,
                              PG_BMPf,
                              0);
            soc_reg32_set(unit, PG2TCr,
                          port, index, rval);
        }

        /* PG2TCr, index 7 */
        soc_reg32_get(unit, PG2TCr,
                      port, 7, &rval);
        soc_reg_field_set(unit, PG2TCr, &rval,
                          PG_BMPf,
                          /* coverity[dead_error_line : FALSE] */
                          flow_control_type_pause_0_pfc_1?128:255);
        soc_reg32_set(unit, PG2TCr,
                      port, 7, rval);

        /* IBPPKTSETLIMITr, index 0 */
        soc_reg32_get(unit, IBPPKTSETLIMITr,
                      port, 0, &rval);
        soc_reg_field_set(unit, IBPPKTSETLIMITr, &rval,
                          PKTSETLIMITf,
                          xoff_packet_thresholds_per_port_downlink_port);
        soc_reg_field_set(unit, IBPPKTSETLIMITr, &rval,
                          RESETLIMITSELf,
                          3);
        soc_reg32_set(unit, IBPPKTSETLIMITr,
                      port, 0, rval);

        /* MMU_FC_RX_ENr, index 0 */
        soc_reg32_get(unit, MMU_FC_RX_ENr,
                      port, 0, &rval);
        soc_reg_field_set(unit, MMU_FC_RX_ENr, &rval,
                          MMU_FC_RX_ENABLEf,
                          128);
        soc_reg32_set(unit, MMU_FC_RX_ENr,
                      port, 0, rval);

        /* MMU_FC_TX_ENr, index 0 */
        soc_reg32_get(unit, MMU_FC_TX_ENr,
                      port, 0, &rval);
        soc_reg_field_set(unit, MMU_FC_TX_ENr, &rval,
                          MMU_FC_TX_ENABLEf,
                          128);
        soc_reg32_set(unit, MMU_FC_TX_ENr,
                      port, 0, rval);

        /* PGCELLLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, PGCELLLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, PGCELLLIMITr, &rval,
                              CELLSETLIMITf,
                              xoff_cell_threshold_all_uplink_ports);
            soc_reg32_set(unit, PGCELLLIMITr,
                          port, index, rval);
        }

        /* PGCELLLIMITr, index 7 */
        soc_reg32_get(unit, PGCELLLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, PGCELLLIMITr, &rval,
                          CELLSETLIMITf,
                          xoff_cell_thresholds_per_port_1g_port_downlink_ports);
        soc_reg32_set(unit, PGCELLLIMITr,
                      port, 7, rval);

        /* PGCELLLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, PGCELLLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, PGCELLLIMITr, &rval,
                              CELLRESETLIMITf,
                              xoff_cell_threshold_all_uplink_ports);
            soc_reg32_set(unit, PGCELLLIMITr,
                          port, index, rval);
        }

        /* PGCELLLIMITr, index 7 */
        soc_reg32_get(unit, PGCELLLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, PGCELLLIMITr, &rval,
                          CELLRESETLIMITf,
                          xoff_cell_thresholds_per_port_1g_port_downlink_ports);
        soc_reg32_set(unit, PGCELLLIMITr,
                      port, 7, rval);

        /* PGDISCARDSETLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, PGDISCARDSETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, PGDISCARDSETLIMITr, &rval,
                              DISCARDSETLIMITf,
                              discard_limit_per_port_pg_downlink_port);
            soc_reg32_set(unit, PGDISCARDSETLIMITr,
                          port, index, rval);
        }

        /* PGDISCARDSETLIMITr, index 7 */
        soc_reg32_get(unit, PGDISCARDSETLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, PGDISCARDSETLIMITr, &rval,
                          DISCARDSETLIMITf,
                          discard_limit_per_port_pg_uplink_1g_port);
        soc_reg32_set(unit, PGDISCARDSETLIMITr,
                      port, 7, rval);

        /* HOLCOSMINXQCNTr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSMINXQCNTr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSMINXQCNTr, &rval,
                              HOLCOSMINXQCNTf,
                              egress_xq_min_reserve_lossy_ports);
            soc_reg32_set(unit, HOLCOSMINXQCNTr,
                          port, index, rval);
        }

        /* HOLCOSMINXQCNTr, index 7 */
        soc_reg32_get(unit, HOLCOSMINXQCNTr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSMINXQCNTr, &rval,
                          HOLCOSMINXQCNTf,
                          egress_xq_min_reserve_lossless_downlink_ports);
        soc_reg32_set(unit, HOLCOSMINXQCNTr,
                      port, 7, rval);

        /* HOLCOSMINXQCNT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSMINXQCNT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSMINXQCNT_QLAYERr, &rval,
                              HOLCOSMINXQCNTf,
                              egress_xq_min_reserve_lossy_ports);
            soc_reg32_set(unit, HOLCOSMINXQCNT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSMINXQCNT_QLAYERr, index 7 */
        soc_reg32_get(unit, HOLCOSMINXQCNT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSMINXQCNT_QLAYERr, &rval,
                          HOLCOSMINXQCNTf,
                          egress_xq_min_reserve_lossless_downlink_ports);
        soc_reg32_set(unit, HOLCOSMINXQCNT_QLAYERr,
                      port, 7, rval);

        /* HOLCOSMINXQCNT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, HOLCOSMINXQCNT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSMINXQCNT_QLAYERr, &rval,
                              HOLCOSMINXQCNTf,
                              0);
            soc_reg32_set(unit, HOLCOSMINXQCNT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSPKTSETLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSPKTSETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTSETLIMITr, &rval,
                              PKTSETLIMITf,
                              shared_xqs_per_downlink_port +
                              egress_xq_min_reserve_lossy_ports);
            soc_reg32_set(unit, HOLCOSPKTSETLIMITr,
                          port, index, rval);
        }

        /* HOLCOSPKTSETLIMITr, index 7 */
        soc_reg32_get(unit, HOLCOSPKTSETLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSPKTSETLIMITr, &rval,
                          PKTSETLIMITf,
                          shared_xqs_per_downlink_port +
                          egress_xq_min_reserve_lossless_downlink_ports);
        soc_reg32_set(unit, HOLCOSPKTSETLIMITr,
                      port, 7, rval);

        /* HOLCOSPKTSETLIMIT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTSETLIMIT_QLAYERr, &rval,
                              PKTSETLIMITf,
                              shared_xqs_per_downlink_port +
                              egress_xq_min_reserve_lossy_ports);
            soc_reg32_set(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSPKTSETLIMIT_QLAYERr, index 7 */
        soc_reg32_get(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSPKTSETLIMIT_QLAYERr, &rval,
                          PKTSETLIMITf,
                          shared_xqs_per_downlink_port +
                          egress_xq_min_reserve_lossless_downlink_ports);
        soc_reg32_set(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                      port, 7, rval);

        /* HOLCOSPKTSETLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTSETLIMIT_QLAYERr, &rval,
                              PKTSETLIMITf,
                              shared_xqs_per_downlink_port +
                              holcosminxqcnt_qlayer8_holcosminxqcnt_down_1);
            soc_reg32_set(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSPKTRESETLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSPKTRESETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTRESETLIMITr, &rval,
                              PKTRESETLIMITf,
                              holcospktsetlimit0_pktsetlimit_down_1 - 1);
            soc_reg32_set(unit, HOLCOSPKTRESETLIMITr,
                          port, index, rval);
        }

        /* HOLCOSPKTRESETLIMITr, index 7 */
        soc_reg32_get(unit, HOLCOSPKTRESETLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSPKTRESETLIMITr, &rval,
                          PKTRESETLIMITf,
                          holcospktsetlimit7_pktsetlimit_down_1 - 1);
        soc_reg32_set(unit, HOLCOSPKTRESETLIMITr,
                      port, 7, rval);

        /* HOLCOSPKTRESETLIMIT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr, &rval,
                              PKTRESETLIMITf,
                              holcospktsetlimit_qlayer0_pktsetlimit_down_1 - 1);
            soc_reg32_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSPKTRESETLIMIT_QLAYERr, index 7 */
        soc_reg32_get(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr, &rval,
                          PKTRESETLIMITf,
                          holcospktsetlimit_qlayer7_pktsetlimit_down_1 - 1);
        soc_reg32_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                      port, 7, rval);

        /* HOLCOSPKTRESETLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr, &rval,
                              PKTRESETLIMITf,
                              holcospktsetlimit_qlayer8_pktsetlimit_down_1 - 1);
            soc_reg32_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT0r, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT0r,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT0r, &rval,
                              CNGPKTSETLIMIT0f,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT0r,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT1r, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT1r,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT1r, &rval,
                              CNGPKTSETLIMIT1f,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT1r,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT0_QLAYERr, index 0 ~ 63 */
        for (index = 0; index <= 63; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT0_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT0_QLAYERr, &rval,
                              CNGPKTSETLIMIT0f,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT0_QLAYERr,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT1_QLAYERr, index 0 ~ 63 */
        for (index = 0; index <= 63; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT1_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT1_QLAYERr, &rval,
                              CNGPKTSETLIMIT1f,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT1_QLAYERr,
                          port, index, rval);
        }

        /* CNGPORTPKTLIMIT0r, index 0 */
        soc_reg32_get(unit, CNGPORTPKTLIMIT0r,
                      port, 0, &rval);
        soc_reg_field_set(unit, CNGPORTPKTLIMIT0r, &rval,
                          CNGPORTPKTLIMIT0f,
                          numxqs_per_downlink_ports_and_cpu_port - 1);
        soc_reg32_set(unit, CNGPORTPKTLIMIT0r,
                      port, 0, rval);

        /* CNGPORTPKTLIMIT1r, index 0 */
        soc_reg32_get(unit, CNGPORTPKTLIMIT1r,
                      port, 0, &rval);
        soc_reg_field_set(unit, CNGPORTPKTLIMIT1r, &rval,
                          CNGPORTPKTLIMIT1f,
                          numxqs_per_downlink_ports_and_cpu_port - 1);
        soc_reg32_set(unit, CNGPORTPKTLIMIT1r,
                      port, 0, rval);

        /* DYNXQCNTPORTr, index 0 */
        soc_reg32_get(unit, DYNXQCNTPORTr,
                      port, 0, &rval);
        soc_reg_field_set(unit, DYNXQCNTPORTr, &rval,
                          DYNXQCNTPORTf,
                          shared_xqs_per_downlink_port - skidmarker - prefetch);
        soc_reg32_set(unit, DYNXQCNTPORTr,
                      port, 0, rval);

        /* DYNRESETLIMPORTr, index 0 */
        soc_reg32_get(unit, DYNRESETLIMPORTr,
                      port, 0, &rval);
        soc_reg_field_set(unit, DYNRESETLIMPORTr, &rval,
                          DYNRESETLIMPORTf,
                          dynxqcntport_dynxqcntport_down_1 - 2);
        soc_reg32_set(unit, DYNRESETLIMPORTr,
                      port, 0, rval);

        /* LWMCOSCELLSETLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMITr, &rval,
                              CELLSETLIMITf,
                              egress_queue_min_reserve_downlink_ports_lossy);
            soc_reg32_set(unit, LWMCOSCELLSETLIMITr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMITr, index 7 */
        soc_reg32_get(unit, LWMCOSCELLSETLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, LWMCOSCELLSETLIMITr, &rval,
                          CELLSETLIMITf,
                          egress_queue_min_reserve_downlink_ports_lossless);
        soc_reg32_set(unit, LWMCOSCELLSETLIMITr,
                      port, 7, rval);

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                              CELLSETLIMITf,
                              egress_queue_min_reserve_downlink_ports_lossy);
            soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 7 */
        soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                          CELLSETLIMITf,
                          egress_queue_min_reserve_downlink_ports_lossless);
        soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                      port, 7, rval);

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                              CELLSETLIMITf,
                              0);
            soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMITr, &rval,
                              CELLRESETLIMITf,
                              egress_queue_min_reserve_downlink_ports_lossy);
            soc_reg32_set(unit, LWMCOSCELLSETLIMITr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMITr, index 7 */
        soc_reg32_get(unit, LWMCOSCELLSETLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, LWMCOSCELLSETLIMITr, &rval,
                          CELLRESETLIMITf,
                          egress_queue_min_reserve_downlink_ports_lossless);
        soc_reg32_set(unit, LWMCOSCELLSETLIMITr,
                      port, 7, rval);

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                              CELLRESETLIMITf,
                              egress_queue_min_reserve_downlink_ports_lossy);
            soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 7 */
        soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                          CELLRESETLIMITf,
                          egress_queue_min_reserve_downlink_ports_lossless);
        soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                      port, 7, rval);

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                              CELLRESETLIMITf,
                              0);
            soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                              CELLMAXLIMITf,
                              ceiling_func(shared_space_cells,
                                           queue_port_limit_ratio) +
                              lwmcoscellsetlimit0_cellsetlimit_down_1);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMITr, index 7 */
        soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                          CELLMAXLIMITf,
                          ceiling_func(shared_space_cells,
                                       queue_port_limit_ratio) +
                          lwmcoscellsetlimit7_cellsetlimit_down_1);
        soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                      port, 7, rval);

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                              CELLMAXLIMITf,
                              ceiling_func(shared_space_cells,
                                           queue_port_limit_ratio) +
                              lwmcoscellsetlimit_qlayer0_cellsetlimit_down_1);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 7 */
        soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                          CELLMAXLIMITf,
                          ceiling_func(shared_space_cells,
                                       queue_port_limit_ratio) +
                          lwmcoscellsetlimit_qlayer7_cellsetlimit_down_1);
        soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                      port, 7, rval);

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                              CELLMAXLIMITf,
                              ceiling_func(shared_space_cells,
                                           queue_port_limit_ratio) +
                              lwmcoscellsetlimit_qlayer8_cellsetlimit_down_1);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                              CELLMAXRESUMELIMITf,
                              holcoscellmaxlimit0_cellmaxlimit_down_1 -
                              ethernet_mtu_cell);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMITr, index 7 */
        soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                          CELLMAXRESUMELIMITf,
                          holcoscellmaxlimit7_cellmaxlimit_down_1 -
                          ethernet_mtu_cell);
        soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                      port, 7, rval);

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                              CELLMAXRESUMELIMITf,
                              holcoscellmaxlimit_qlayer0_cellmaxlimit_down_1 -
                              ethernet_mtu_cell);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 7 */
        soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                          CELLMAXRESUMELIMITf,
                          holcoscellmaxlimit_qlayer7_cellmaxlimit_down_1 -
                          ethernet_mtu_cell);
        soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                      port, 7, rval);

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                              CELLMAXRESUMELIMITf,
                              holcoscellmaxlimit_qlayer8_cellmaxlimit_down_1 -
                              ethernet_mtu_cell);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* DYNCELLLIMITr, index 0 */
        soc_reg32_get(unit, DYNCELLLIMITr,
                      port, 0, &rval);
        soc_reg_field_set(unit, DYNCELLLIMITr, &rval,
                          DYNCELLSETLIMITf,
                          shared_space_cells);
        soc_reg_field_set(unit, DYNCELLLIMITr, &rval,
                          DYNCELLRESETLIMITf,
                          dyncelllimit_dyncellsetlimit_down_1 -
                          (ethernet_mtu_cell * 2));
        soc_reg32_set(unit, DYNCELLLIMITr,
                      port, 0, rval);

        /* COLOR_DROP_ENr, index 0 */
        soc_reg32_get(unit, COLOR_DROP_ENr,
                      port, 0, &rval);
        soc_reg_field_set(unit, COLOR_DROP_ENr, &rval,
                          COLOR_DROP_ENf,
                          0);
        soc_reg32_set(unit, COLOR_DROP_ENr,
                      port, 0, rval);

        /* COLOR_DROP_EN_QLAYERr, index 0 */
        soc_reg32_get(unit, COLOR_DROP_EN_QLAYERr,
                      port, 0, &rval);
        soc_reg_field_set(unit, COLOR_DROP_EN_QLAYERr, &rval,
                          COLOR_DROP_ENf,
                          0);
        soc_reg32_set(unit, COLOR_DROP_EN_QLAYERr,
                      port, 0, rval);

        /* HOLCOSPKTSETLIMIT_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSPKTSETLIMIT_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTSETLIMIT_QGROUPr, &rval,
                              PKTSETLIMITf,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, HOLCOSPKTSETLIMIT_QGROUPr,
                          port, index, rval);
        }

        /* HOLCOSPKTRESETLIMIT_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSPKTRESETLIMIT_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTRESETLIMIT_QGROUPr, &rval,
                              PKTRESETLIMITf,
                              holcospktsetlimit_qgroup0_pktsetlimit_down_1 - 1);
            soc_reg32_set(unit, HOLCOSPKTRESETLIMIT_QGROUPr,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT0_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT0_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT0_QGROUPr, &rval,
                              CNGPKTSETLIMIT0f,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT0_QGROUPr,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT1_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT1_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT1_QGROUPr, &rval,
                              CNGPKTSETLIMIT1f,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT1_QGROUPr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMIT_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QGROUPr, &rval,
                              CELLMAXLIMITf,
                              ceiling_func(total_advertised_cell_memory,
                                           queue_port_limit_ratio));
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QGROUPr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMIT_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QGROUPr, &rval,
                              CELLMAXRESUMELIMITf,
                              holcoscellmaxlimit_qgroup0_cellmaxlimit_down_1 -
                              ethernet_mtu_cell);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QGROUPr,
                          port, index, rval);
        }

        /* COLOR_DROP_EN_QGROUPr, index 0 */
        soc_reg32_get(unit, COLOR_DROP_EN_QGROUPr,
                      port, 0, &rval);
        soc_reg_field_set(unit, COLOR_DROP_EN_QGROUPr, &rval,
                          COLOR_DROP_ENf,
                          0);
        soc_reg32_set(unit, COLOR_DROP_EN_QGROUPr,
                      port, 0, rval);

        /* SHARED_POOL_CTRLr, index 0 */
        soc_reg32_get(unit, SHARED_POOL_CTRLr,
                      port, 0, &rval);
        soc_reg_field_set(unit, SHARED_POOL_CTRLr, &rval,
                          DYNAMIC_COS_DROP_ENf,
                          255);
        soc_reg_field_set(unit, SHARED_POOL_CTRLr, &rval,
                          SHARED_POOL_DISCARD_ENf,
                          127);
        soc_reg_field_set(unit, SHARED_POOL_CTRLr, &rval,
                          SHARED_POOL_XOFF_ENf,
                          0);
        soc_reg32_set(unit, SHARED_POOL_CTRLr,
                      port, 0, rval);

        /* SHARED_POOL_CTRL_EXT1r, index 0 */
        soc_reg32_get(unit, SHARED_POOL_CTRL_EXT1r,
                      port, 0, &rval);
        soc_reg_field_set(unit, SHARED_POOL_CTRL_EXT1r, &rval,
                          DYNAMIC_COS_DROP_ENf,
                          0xFFFFFF);
        soc_reg32_set(unit, SHARED_POOL_CTRL_EXT1r,
                      port, 0, rval);

        /* SHARED_POOL_CTRL_EXT2r, index 0 */
        soc_reg32_get(unit, SHARED_POOL_CTRL_EXT2r,
                      port, 0, &rval);
        soc_reg_field_set(unit, SHARED_POOL_CTRL_EXT2r, &rval,
                          DYNAMIC_COS_DROP_ENf,
                          0xFFFFFFFF);
        soc_reg32_set(unit, SHARED_POOL_CTRL_EXT2r,
                      port, 0, rval);
    }

    /* port-based : downlink 2.5G */
    SOC_PBMP_ITER(pbmp_downlink_2dot5g, port) {
        /* PG_CTRL0r, index 0 */
        soc_reg32_get(unit, PG_CTRL0r,
                      port, 0, &rval);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PPFC_PG_ENf,
                          128);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI0_GRPf,
                          /* coverity[dead_error_line : FALSE] */
                          flow_control_type_pause_0_pfc_1?0:7);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI1_GRPf,
                          /* coverity[dead_error_line : FALSE] */
                          flow_control_type_pause_0_pfc_1?1:7);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI2_GRPf,
                          /* coverity[dead_error_line : FALSE] */
                          flow_control_type_pause_0_pfc_1?2:7);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI3_GRPf,
                          /* coverity[dead_error_line : FALSE] */
                          flow_control_type_pause_0_pfc_1?3:7);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI4_GRPf,
                          /* coverity[dead_error_line : FALSE] */
                          flow_control_type_pause_0_pfc_1?4:7);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI5_GRPf,
                          /* coverity[dead_error_line : FALSE] */
                          flow_control_type_pause_0_pfc_1?5:7);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI6_GRPf,
                          /* coverity[dead_error_line : FALSE] */
                          flow_control_type_pause_0_pfc_1?6:7);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI7_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg32_set(unit, PG_CTRL0r,
                      port, 0, rval);

        /* PG_CTRL1r, index 0 */
        soc_reg32_get(unit, PG_CTRL1r,
                      port, 0, &rval);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI8_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI9_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI10_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI11_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI12_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI13_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI14_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI15_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg32_set(unit, PG_CTRL1r,
                      port, 0, rval);

        /* PG2TCr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, PG2TCr,
                          port, index, &rval);
            soc_reg_field_set(unit, PG2TCr, &rval,
                              PG_BMPf,
                              0);
            soc_reg32_set(unit, PG2TCr,
                          port, index, rval);
        }

        /* PG2TCr, index 7 */
        soc_reg32_get(unit, PG2TCr,
                      port, 7, &rval);
        soc_reg_field_set(unit, PG2TCr, &rval,
                          PG_BMPf,
                          /* coverity[dead_error_line : FALSE] */
                          flow_control_type_pause_0_pfc_1?128:255);
        soc_reg32_set(unit, PG2TCr,
                      port, 7, rval);

        /* IBPPKTSETLIMITr, index 0 */
        soc_reg32_get(unit, IBPPKTSETLIMITr,
                      port, 0, &rval);
        soc_reg_field_set(unit, IBPPKTSETLIMITr, &rval,
                          PKTSETLIMITf,
                          xoff_packet_thresholds_per_port_downlink_port);
        soc_reg_field_set(unit, IBPPKTSETLIMITr, &rval,
                          RESETLIMITSELf,
                          3);
        soc_reg32_set(unit, IBPPKTSETLIMITr,
                      port, 0, rval);

        /* MMU_FC_RX_ENr, index 0 */
        soc_reg32_get(unit, MMU_FC_RX_ENr,
                      port, 0, &rval);
        soc_reg_field_set(unit, MMU_FC_RX_ENr, &rval,
                          MMU_FC_RX_ENABLEf,
                          128);
        soc_reg32_set(unit, MMU_FC_RX_ENr,
                      port, 0, rval);

        /* MMU_FC_TX_ENr, index 0 */
        soc_reg32_get(unit, MMU_FC_TX_ENr,
                      port, 0, &rval);
        soc_reg_field_set(unit, MMU_FC_TX_ENr, &rval,
                          MMU_FC_TX_ENABLEf,
                          128);
        soc_reg32_set(unit, MMU_FC_TX_ENr,
                      port, 0, rval);

        /* PGCELLLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, PGCELLLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, PGCELLLIMITr, &rval,
                              CELLSETLIMITf,
                              xoff_cell_threshold_all_uplink_ports);
            soc_reg32_set(unit, PGCELLLIMITr,
                          port, index, rval);
        }

        /* PGCELLLIMITr, index 7 */
        soc_reg32_get(unit, PGCELLLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, PGCELLLIMITr, &rval,
                          CELLSETLIMITf,
                          xoff_cell_thresholds_per_port_2dot5g_downlink_ports);
        soc_reg32_set(unit, PGCELLLIMITr,
                      port, 7, rval);

        /* PGCELLLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, PGCELLLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, PGCELLLIMITr, &rval,
                              CELLRESETLIMITf,
                              xoff_cell_threshold_all_uplink_ports);
            soc_reg32_set(unit, PGCELLLIMITr,
                          port, index, rval);
        }

        /* PGCELLLIMITr, index 7 */
        soc_reg32_get(unit, PGCELLLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, PGCELLLIMITr, &rval,
                          CELLRESETLIMITf,
                          xoff_cell_thresholds_per_port_2dot5g_downlink_ports);
        soc_reg32_set(unit, PGCELLLIMITr,
                      port, 7, rval);

        /* PGDISCARDSETLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, PGDISCARDSETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, PGDISCARDSETLIMITr, &rval,
                              DISCARDSETLIMITf,
                              discard_limit_per_port_pg_downlink_port);
            soc_reg32_set(unit, PGDISCARDSETLIMITr,
                          port, index, rval);
        }

        /* PGDISCARDSETLIMITr, index 7 */
        soc_reg32_get(unit, PGDISCARDSETLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, PGDISCARDSETLIMITr, &rval,
                          DISCARDSETLIMITf,
                          discard_limit_per_port_pg_uplink_2dot5g_port);
        soc_reg32_set(unit, PGDISCARDSETLIMITr,
                      port, 7, rval);

        /* HOLCOSMINXQCNTr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSMINXQCNTr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSMINXQCNTr, &rval,
                              HOLCOSMINXQCNTf,
                              egress_xq_min_reserve_lossy_ports);
            soc_reg32_set(unit, HOLCOSMINXQCNTr,
                          port, index, rval);
        }

        /* HOLCOSMINXQCNTr, index 7 */
        soc_reg32_get(unit, HOLCOSMINXQCNTr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSMINXQCNTr, &rval,
                          HOLCOSMINXQCNTf,
                          egress_xq_min_reserve_lossless_downlink_ports);
        soc_reg32_set(unit, HOLCOSMINXQCNTr,
                      port, 7, rval);

        /* HOLCOSMINXQCNT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSMINXQCNT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSMINXQCNT_QLAYERr, &rval,
                              HOLCOSMINXQCNTf,
                              egress_xq_min_reserve_lossy_ports);
            soc_reg32_set(unit, HOLCOSMINXQCNT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSMINXQCNT_QLAYERr, index 7 */
        soc_reg32_get(unit, HOLCOSMINXQCNT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSMINXQCNT_QLAYERr, &rval,
                          HOLCOSMINXQCNTf,
                          egress_xq_min_reserve_lossless_downlink_ports);
        soc_reg32_set(unit, HOLCOSMINXQCNT_QLAYERr,
                      port, 7, rval);

        /* HOLCOSMINXQCNT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, HOLCOSMINXQCNT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSMINXQCNT_QLAYERr, &rval,
                              HOLCOSMINXQCNTf,
                              0);
            soc_reg32_set(unit, HOLCOSMINXQCNT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSPKTSETLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSPKTSETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTSETLIMITr, &rval,
                              PKTSETLIMITf,
                              shared_xqs_per_downlink_port +
                              egress_xq_min_reserve_lossy_ports);
            soc_reg32_set(unit, HOLCOSPKTSETLIMITr,
                          port, index, rval);
        }

        /* HOLCOSPKTSETLIMITr, index 7 */
        soc_reg32_get(unit, HOLCOSPKTSETLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSPKTSETLIMITr, &rval,
                          PKTSETLIMITf,
                          shared_xqs_per_downlink_port +
                          egress_xq_min_reserve_lossless_downlink_ports);
        soc_reg32_set(unit, HOLCOSPKTSETLIMITr,
                      port, 7, rval);

        /* HOLCOSPKTSETLIMIT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTSETLIMIT_QLAYERr, &rval,
                              PKTSETLIMITf,
                              shared_xqs_per_downlink_port +
                              egress_xq_min_reserve_lossy_ports);
            soc_reg32_set(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSPKTSETLIMIT_QLAYERr, index 7 */
        soc_reg32_get(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSPKTSETLIMIT_QLAYERr, &rval,
                          PKTSETLIMITf,
                          shared_xqs_per_downlink_port +
                          egress_xq_min_reserve_lossless_downlink_ports);
        soc_reg32_set(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                      port, 7, rval);

        /* HOLCOSPKTSETLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTSETLIMIT_QLAYERr, &rval,
                              PKTSETLIMITf,
                              shared_xqs_per_downlink_port +
                              holcosminxqcnt_qlayer8_holcosminxqcnt_down_2dot5);
            soc_reg32_set(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSPKTRESETLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSPKTRESETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTRESETLIMITr, &rval,
                              PKTRESETLIMITf,
                              holcospktsetlimit0_pktsetlimit_down_2dot5 - 1);
            soc_reg32_set(unit, HOLCOSPKTRESETLIMITr,
                          port, index, rval);
        }

        /* HOLCOSPKTRESETLIMITr, index 7 */
        soc_reg32_get(unit, HOLCOSPKTRESETLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSPKTRESETLIMITr, &rval,
                          PKTRESETLIMITf,
                          holcospktsetlimit7_pktsetlimit_down_2dot5 - 1);
        soc_reg32_set(unit, HOLCOSPKTRESETLIMITr,
                      port, 7, rval);

        /* HOLCOSPKTRESETLIMIT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr, &rval,
                              PKTRESETLIMITf,
                              holcospktsetlimit_qlayer0_pktsetlimit_down_2dot5 -
                              1);
            soc_reg32_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSPKTRESETLIMIT_QLAYERr, index 7 */
        soc_reg32_get(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr, &rval,
                          PKTRESETLIMITf,
                          holcospktsetlimit_qlayer7_pktsetlimit_down_2dot5 - 1);
        soc_reg32_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                      port, 7, rval);

        /* HOLCOSPKTRESETLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr, &rval,
                              PKTRESETLIMITf,
                              holcospktsetlimit_qlayer8_pktsetlimit_down_2dot5 -
                              1);
            soc_reg32_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT0r, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT0r,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT0r, &rval,
                              CNGPKTSETLIMIT0f,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT0r,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT1r, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT1r,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT1r, &rval,
                              CNGPKTSETLIMIT1f,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT1r,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT0_QLAYERr, index 0 ~ 63 */
        for (index = 0; index <= 63; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT0_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT0_QLAYERr, &rval,
                              CNGPKTSETLIMIT0f,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT0_QLAYERr,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT1_QLAYERr, index 0 ~ 63 */
        for (index = 0; index <= 63; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT1_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT1_QLAYERr, &rval,
                              CNGPKTSETLIMIT1f,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT1_QLAYERr,
                          port, index, rval);
        }

        /* CNGPORTPKTLIMIT0r, index 0 */
        soc_reg32_get(unit, CNGPORTPKTLIMIT0r,
                      port, 0, &rval);
        soc_reg_field_set(unit, CNGPORTPKTLIMIT0r, &rval,
                          CNGPORTPKTLIMIT0f,
                          numxqs_per_downlink_ports_and_cpu_port - 1);
        soc_reg32_set(unit, CNGPORTPKTLIMIT0r,
                      port, 0, rval);

        /* CNGPORTPKTLIMIT1r, index 0 */
        soc_reg32_get(unit, CNGPORTPKTLIMIT1r,
                      port, 0, &rval);
        soc_reg_field_set(unit, CNGPORTPKTLIMIT1r, &rval,
                          CNGPORTPKTLIMIT1f,
                          numxqs_per_downlink_ports_and_cpu_port - 1);
        soc_reg32_set(unit, CNGPORTPKTLIMIT1r,
                      port, 0, rval);

        /* DYNXQCNTPORTr, index 0 */
        soc_reg32_get(unit, DYNXQCNTPORTr,
                      port, 0, &rval);
        soc_reg_field_set(unit, DYNXQCNTPORTr, &rval,
                          DYNXQCNTPORTf,
                          shared_xqs_per_downlink_port - skidmarker - prefetch);
        soc_reg32_set(unit, DYNXQCNTPORTr,
                      port, 0, rval);

        /* DYNRESETLIMPORTr, index 0 */
        soc_reg32_get(unit, DYNRESETLIMPORTr,
                      port, 0, &rval);
        soc_reg_field_set(unit, DYNRESETLIMPORTr, &rval,
                          DYNRESETLIMPORTf,
                          dynxqcntport_dynxqcntport_down_2dot5 - 2);
        soc_reg32_set(unit, DYNRESETLIMPORTr,
                      port, 0, rval);

        /* LWMCOSCELLSETLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMITr, &rval,
                              CELLSETLIMITf,
                              egress_queue_min_reserve_downlink_ports_lossy);
            soc_reg32_set(unit, LWMCOSCELLSETLIMITr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMITr, index 7 */
        soc_reg32_get(unit, LWMCOSCELLSETLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, LWMCOSCELLSETLIMITr, &rval,
                          CELLSETLIMITf,
                          egress_queue_min_reserve_downlink_ports_lossless);
        soc_reg32_set(unit, LWMCOSCELLSETLIMITr,
                      port, 7, rval);

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                              CELLSETLIMITf,
                              egress_queue_min_reserve_downlink_ports_lossy);
            soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 7 */
        soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                          CELLSETLIMITf,
                          egress_queue_min_reserve_downlink_ports_lossless);
        soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                      port, 7, rval);

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                              CELLSETLIMITf,
                              0);
            soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMITr, &rval,
                              CELLRESETLIMITf,
                              egress_queue_min_reserve_downlink_ports_lossy);
            soc_reg32_set(unit, LWMCOSCELLSETLIMITr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMITr, index 7 */
        soc_reg32_get(unit, LWMCOSCELLSETLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, LWMCOSCELLSETLIMITr, &rval,
                          CELLRESETLIMITf,
                          egress_queue_min_reserve_downlink_ports_lossless);
        soc_reg32_set(unit, LWMCOSCELLSETLIMITr,
                      port, 7, rval);

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                              CELLRESETLIMITf,
                              egress_queue_min_reserve_downlink_ports_lossy);
            soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 7 */
        soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                          CELLRESETLIMITf,
                          egress_queue_min_reserve_downlink_ports_lossless);
        soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                      port, 7, rval);

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                              CELLRESETLIMITf,
                              0);
            soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                              CELLMAXLIMITf,
                              ceiling_func(shared_space_cells,
                                           queue_port_limit_ratio) +
                              lwmcoscellsetlimit0_cellsetlimit_down_2dot5);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMITr, index 7 */
        soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                          CELLMAXLIMITf,
                          ceiling_func(shared_space_cells,
                                       queue_port_limit_ratio) +
                          lwmcoscellsetlimit7_cellsetlimit_down_2dot5);
        soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                      port, 7, rval);

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                              CELLMAXLIMITf,
                              ceiling_func(shared_space_cells,
                                           queue_port_limit_ratio) +
                              lwmcoscellsetlimit_qlayer0_cellsetlimit_down_2dot5);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 7 */
        soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                          CELLMAXLIMITf,
                          ceiling_func(shared_space_cells,
                                       queue_port_limit_ratio) +
                          lwmcoscellsetlimit_qlayer7_cellsetlimit_down_2dot5);
        soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                      port, 7, rval);

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                              CELLMAXLIMITf,
                              ceiling_func(shared_space_cells,
                                           queue_port_limit_ratio) +
                              lwmcoscellsetlimit_qlayer8_cellsetlimit_down_2dot5);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                              CELLMAXRESUMELIMITf,
                              holcoscellmaxlimit0_cellmaxlimit_down_2dot5 -
                              ethernet_mtu_cell);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMITr, index 7 */
        soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                          CELLMAXRESUMELIMITf,
                          holcoscellmaxlimit7_cellmaxlimit_down_2dot5 -
                          ethernet_mtu_cell);
        soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                      port, 7, rval);

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                              CELLMAXRESUMELIMITf,
                              holcoscellmaxlimit_qlayer0_cellmaxlimit_down_2dot5 -
                              ethernet_mtu_cell);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 7 */
        soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                          CELLMAXRESUMELIMITf,
                          holcoscellmaxlimit_qlayer7_cellmaxlimit_down_2dot5 -
                          ethernet_mtu_cell);
        soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                      port, 7, rval);

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                              CELLMAXRESUMELIMITf,
                              holcoscellmaxlimit_qlayer8_cellmaxlimit_down_2dot5 -
                              ethernet_mtu_cell);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* DYNCELLLIMITr, index 0 */
        soc_reg32_get(unit, DYNCELLLIMITr,
                      port, 0, &rval);
        soc_reg_field_set(unit, DYNCELLLIMITr, &rval,
                          DYNCELLSETLIMITf,
                          shared_space_cells);
        soc_reg_field_set(unit, DYNCELLLIMITr, &rval,
                          DYNCELLRESETLIMITf,
                          dyncelllimit_dyncellsetlimit_down_2dot5 -
                          (ethernet_mtu_cell * 2));
        soc_reg32_set(unit, DYNCELLLIMITr,
                      port, 0, rval);

        /* COLOR_DROP_ENr, index 0 */
        soc_reg32_get(unit, COLOR_DROP_ENr,
                      port, 0, &rval);
        soc_reg_field_set(unit, COLOR_DROP_ENr, &rval,
                          COLOR_DROP_ENf,
                          0);
        soc_reg32_set(unit, COLOR_DROP_ENr,
                      port, 0, rval);

        /* COLOR_DROP_EN_QLAYERr, index 0 */
        soc_reg32_get(unit, COLOR_DROP_EN_QLAYERr,
                      port, 0, &rval);
        soc_reg_field_set(unit, COLOR_DROP_EN_QLAYERr, &rval,
                          COLOR_DROP_ENf,
                          0);
        soc_reg32_set(unit, COLOR_DROP_EN_QLAYERr,
                      port, 0, rval);

        /* HOLCOSPKTSETLIMIT_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSPKTSETLIMIT_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTSETLIMIT_QGROUPr, &rval,
                              PKTSETLIMITf,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, HOLCOSPKTSETLIMIT_QGROUPr,
                          port, index, rval);
        }

        /* HOLCOSPKTRESETLIMIT_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSPKTRESETLIMIT_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTRESETLIMIT_QGROUPr, &rval,
                              PKTRESETLIMITf,
                              holcospktsetlimit_qgroup0_pktsetlimit_down_2dot5 -
                              1);
            soc_reg32_set(unit, HOLCOSPKTRESETLIMIT_QGROUPr,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT0_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT0_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT0_QGROUPr, &rval,
                              CNGPKTSETLIMIT0f,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT0_QGROUPr,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT1_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT1_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT1_QGROUPr, &rval,
                              CNGPKTSETLIMIT1f,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT1_QGROUPr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMIT_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QGROUPr, &rval,
                              CELLMAXLIMITf,
                              ceiling_func(total_advertised_cell_memory,
                                           queue_port_limit_ratio));
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QGROUPr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMIT_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QGROUPr, &rval,
                              CELLMAXRESUMELIMITf,
                              holcoscellmaxlimit_qgroup0_cellmaxlimit_down_2dot5 -
                              ethernet_mtu_cell);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QGROUPr,
                          port, index, rval);
        }

        /* COLOR_DROP_EN_QGROUPr, index 0 */
        soc_reg32_get(unit, COLOR_DROP_EN_QGROUPr,
                      port, 0, &rval);
        soc_reg_field_set(unit, COLOR_DROP_EN_QGROUPr, &rval,
                          COLOR_DROP_ENf,
                          0);
        soc_reg32_set(unit, COLOR_DROP_EN_QGROUPr,
                      port, 0, rval);

        /* SHARED_POOL_CTRLr, index 0 */
        soc_reg32_get(unit, SHARED_POOL_CTRLr,
                      port, 0, &rval);
        soc_reg_field_set(unit, SHARED_POOL_CTRLr, &rval,
                          DYNAMIC_COS_DROP_ENf,
                          255);
        soc_reg_field_set(unit, SHARED_POOL_CTRLr, &rval,
                          SHARED_POOL_DISCARD_ENf,
                          127);
        soc_reg_field_set(unit, SHARED_POOL_CTRLr, &rval,
                          SHARED_POOL_XOFF_ENf,
                          0);
        soc_reg32_set(unit, SHARED_POOL_CTRLr,
                      port, 0, rval);

        /* SHARED_POOL_CTRL_EXT1r, index 0 */
        soc_reg32_get(unit, SHARED_POOL_CTRL_EXT1r,
                      port, 0, &rval);
        soc_reg_field_set(unit, SHARED_POOL_CTRL_EXT1r, &rval,
                          DYNAMIC_COS_DROP_ENf,
                          0xFFFFFF);
        soc_reg32_set(unit, SHARED_POOL_CTRL_EXT1r,
                      port, 0, rval);

        /* SHARED_POOL_CTRL_EXT2r, index 0 */
        soc_reg32_get(unit, SHARED_POOL_CTRL_EXT2r,
                      port, 0, &rval);
        soc_reg_field_set(unit, SHARED_POOL_CTRL_EXT2r, &rval,
                          DYNAMIC_COS_DROP_ENf,
                          0xFFFFFFFF);
        soc_reg32_set(unit, SHARED_POOL_CTRL_EXT2r,
                      port, 0, rval);

    }

    /* port-based : downlink 10G */
    SOC_PBMP_ITER(pbmp_downlink_10g, port) {
        /* PG_CTRL0r, index 0 */
        soc_reg32_get(unit, PG_CTRL0r,
                      port, 0, &rval);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PPFC_PG_ENf,
                          128);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI0_GRPf,
                          /* coverity[dead_error_line : FALSE] */
                          flow_control_type_pause_0_pfc_1?0:7);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI1_GRPf,
                          /* coverity[dead_error_line : FALSE] */
                          flow_control_type_pause_0_pfc_1?1:7);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI2_GRPf,
                          /* coverity[dead_error_line : FALSE] */
                          flow_control_type_pause_0_pfc_1?2:7);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI3_GRPf,
                          /* coverity[dead_error_line : FALSE] */
                          flow_control_type_pause_0_pfc_1?3:7);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI4_GRPf,
                          /* coverity[dead_error_line : FALSE] */
                          flow_control_type_pause_0_pfc_1?4:7);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI5_GRPf,
                          /* coverity[dead_error_line : FALSE] */
                          flow_control_type_pause_0_pfc_1?5:7);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI6_GRPf,
                          /* coverity[dead_error_line : FALSE] */
                          flow_control_type_pause_0_pfc_1?6:7);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI7_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg32_set(unit, PG_CTRL0r,
                      port, 0, rval);

        /* PG_CTRL1r, index 0 */
        soc_reg32_get(unit, PG_CTRL1r,
                      port, 0, &rval);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI8_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI9_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI10_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI11_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI12_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI13_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI14_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI15_GRPf,
                          /* coverity[identical_branches : FALSE] */
                          flow_control_type_pause_0_pfc_1?7:7);
        soc_reg32_set(unit, PG_CTRL1r,
                      port, 0, rval);

        /* PG2TCr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, PG2TCr,
                          port, index, &rval);
            soc_reg_field_set(unit, PG2TCr, &rval,
                              PG_BMPf,
                              0);
            soc_reg32_set(unit, PG2TCr,
                          port, index, rval);
        }

        /* PG2TCr, index 7 */
        soc_reg32_get(unit, PG2TCr,
                      port, 7, &rval);
        soc_reg_field_set(unit, PG2TCr, &rval,
                          PG_BMPf,
                          /* coverity[dead_error_line : FALSE] */
                          flow_control_type_pause_0_pfc_1?128:255);
        soc_reg32_set(unit, PG2TCr,
                      port, 7, rval);

        /* IBPPKTSETLIMITr, index 0 */
        soc_reg32_get(unit, IBPPKTSETLIMITr,
                      port, 0, &rval);
        soc_reg_field_set(unit, IBPPKTSETLIMITr, &rval,
                          PKTSETLIMITf,
                          xoff_packet_thresholds_per_port_downlink_port);
        soc_reg_field_set(unit, IBPPKTSETLIMITr, &rval,
                          RESETLIMITSELf,
                          3);
        soc_reg32_set(unit, IBPPKTSETLIMITr,
                      port, 0, rval);

        /* MMU_FC_RX_ENr, index 0 */
        soc_reg32_get(unit, MMU_FC_RX_ENr,
                      port, 0, &rval);
        soc_reg_field_set(unit, MMU_FC_RX_ENr, &rval,
                          MMU_FC_RX_ENABLEf,
                          128);
        soc_reg32_set(unit, MMU_FC_RX_ENr,
                      port, 0, rval);

        /* MMU_FC_TX_ENr, index 0 */
        soc_reg32_get(unit, MMU_FC_TX_ENr,
                      port, 0, &rval);
        soc_reg_field_set(unit, MMU_FC_TX_ENr, &rval,
                          MMU_FC_TX_ENABLEf,
                          128);
        soc_reg32_set(unit, MMU_FC_TX_ENr,
                      port, 0, rval);

        /* PGCELLLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, PGCELLLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, PGCELLLIMITr, &rval,
                              CELLSETLIMITf,
                              xoff_cell_threshold_all_uplink_ports);
            soc_reg32_set(unit, PGCELLLIMITr,
                          port, index, rval);
        }

        /* PGCELLLIMITr, index 7 */
        soc_reg32_get(unit, PGCELLLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, PGCELLLIMITr, &rval,
                          CELLSETLIMITf,
                          xoff_cell_thresholds_per_port_10g_port_downlink_ports);
        soc_reg32_set(unit, PGCELLLIMITr,
                      port, 7, rval);

        /* PGCELLLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, PGCELLLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, PGCELLLIMITr, &rval,
                              CELLRESETLIMITf,
                              xoff_cell_threshold_all_uplink_ports);
            soc_reg32_set(unit, PGCELLLIMITr,
                          port, index, rval);
        }

        /* PGCELLLIMITr, index 7 */
        soc_reg32_get(unit, PGCELLLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, PGCELLLIMITr, &rval,
                          CELLRESETLIMITf,
                          xoff_cell_thresholds_per_port_10g_port_downlink_ports);
        soc_reg32_set(unit, PGCELLLIMITr,
                      port, 7, rval);

        /* PGDISCARDSETLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, PGDISCARDSETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, PGDISCARDSETLIMITr, &rval,
                              DISCARDSETLIMITf,
                              discard_limit_per_port_pg_downlink_port);
            soc_reg32_set(unit, PGDISCARDSETLIMITr,
                          port, index, rval);
        }

        /* PGDISCARDSETLIMITr, index 7 */
        soc_reg32_get(unit, PGDISCARDSETLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, PGDISCARDSETLIMITr, &rval,
                          DISCARDSETLIMITf,
                          discard_limit_per_port_pg_uplink_10g_port);
        soc_reg32_set(unit, PGDISCARDSETLIMITr,
                      port, 7, rval);

        /* HOLCOSMINXQCNTr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSMINXQCNTr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSMINXQCNTr, &rval,
                              HOLCOSMINXQCNTf,
                              egress_xq_min_reserve_lossy_ports);
            soc_reg32_set(unit, HOLCOSMINXQCNTr,
                          port, index, rval);
        }

        /* HOLCOSMINXQCNTr, index 7 */
        soc_reg32_get(unit, HOLCOSMINXQCNTr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSMINXQCNTr, &rval,
                          HOLCOSMINXQCNTf,
                          egress_xq_min_reserve_lossless_downlink_ports);
        soc_reg32_set(unit, HOLCOSMINXQCNTr,
                      port, 7, rval);

        /* HOLCOSMINXQCNT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSMINXQCNT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSMINXQCNT_QLAYERr, &rval,
                              HOLCOSMINXQCNTf,
                              egress_xq_min_reserve_lossy_ports);
            soc_reg32_set(unit, HOLCOSMINXQCNT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSMINXQCNT_QLAYERr, index 7 */
        soc_reg32_get(unit, HOLCOSMINXQCNT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSMINXQCNT_QLAYERr, &rval,
                          HOLCOSMINXQCNTf,
                          egress_xq_min_reserve_lossless_downlink_ports);
        soc_reg32_set(unit, HOLCOSMINXQCNT_QLAYERr,
                      port, 7, rval);

        /* HOLCOSMINXQCNT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, HOLCOSMINXQCNT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSMINXQCNT_QLAYERr, &rval,
                              HOLCOSMINXQCNTf,
                              0);
            soc_reg32_set(unit, HOLCOSMINXQCNT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSPKTSETLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSPKTSETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTSETLIMITr, &rval,
                              PKTSETLIMITf,
                              shared_xqs_per_downlink_port +
                              egress_xq_min_reserve_lossy_ports);
            soc_reg32_set(unit, HOLCOSPKTSETLIMITr,
                          port, index, rval);
        }

        /* HOLCOSPKTSETLIMITr, index 7 */
        soc_reg32_get(unit, HOLCOSPKTSETLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSPKTSETLIMITr, &rval,
                          PKTSETLIMITf,
                          shared_xqs_per_downlink_port +
                          egress_xq_min_reserve_lossless_downlink_ports);
        soc_reg32_set(unit, HOLCOSPKTSETLIMITr,
                      port, 7, rval);

        /* HOLCOSPKTSETLIMIT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTSETLIMIT_QLAYERr, &rval,
                              PKTSETLIMITf,
                              shared_xqs_per_downlink_port +
                              egress_xq_min_reserve_lossy_ports);
            soc_reg32_set(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSPKTSETLIMIT_QLAYERr, index 7 */
        soc_reg32_get(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSPKTSETLIMIT_QLAYERr, &rval,
                          PKTSETLIMITf,
                          shared_xqs_per_downlink_port +
                          egress_xq_min_reserve_lossless_downlink_ports);
        soc_reg32_set(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                      port, 7, rval);

        /* HOLCOSPKTSETLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTSETLIMIT_QLAYERr, &rval,
                              PKTSETLIMITf,
                              shared_xqs_per_downlink_port +
                              holcosminxqcnt_qlayer8_holcosminxqcnt_down_10);
            soc_reg32_set(unit, HOLCOSPKTSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSPKTRESETLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSPKTRESETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTRESETLIMITr, &rval,
                              PKTRESETLIMITf,
                              holcospktsetlimit0_pktsetlimit_down_10 - 1);
            soc_reg32_set(unit, HOLCOSPKTRESETLIMITr,
                          port, index, rval);
        }

        /* HOLCOSPKTRESETLIMITr, index 7 */
        soc_reg32_get(unit, HOLCOSPKTRESETLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSPKTRESETLIMITr, &rval,
                          PKTRESETLIMITf,
                          holcospktsetlimit7_pktsetlimit_down_10 - 1);
        soc_reg32_set(unit, HOLCOSPKTRESETLIMITr,
                      port, 7, rval);

        /* HOLCOSPKTRESETLIMIT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr, &rval,
                              PKTRESETLIMITf,
                              holcospktsetlimit_qlayer0_pktsetlimit_down_10 - 1);
            soc_reg32_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSPKTRESETLIMIT_QLAYERr, index 7 */
        soc_reg32_get(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr, &rval,
                          PKTRESETLIMITf,
                          holcospktsetlimit_qlayer7_pktsetlimit_down_10 - 1);
        soc_reg32_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                      port, 7, rval);

        /* HOLCOSPKTRESETLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr, &rval,
                              PKTRESETLIMITf,
                              holcospktsetlimit_qlayer8_pktsetlimit_down_10 - 1);
            soc_reg32_set(unit, HOLCOSPKTRESETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT0r, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT0r,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT0r, &rval,
                              CNGPKTSETLIMIT0f,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT0r,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT1r, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT1r,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT1r, &rval,
                              CNGPKTSETLIMIT1f,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT1r,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT0_QLAYERr, index 0 ~ 63 */
        for (index = 0; index <= 63; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT0_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT0_QLAYERr, &rval,
                              CNGPKTSETLIMIT0f,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT0_QLAYERr,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT1_QLAYERr, index 0 ~ 63 */
        for (index = 0; index <= 63; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT1_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT1_QLAYERr, &rval,
                              CNGPKTSETLIMIT1f,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT1_QLAYERr,
                          port, index, rval);
        }

        /* CNGPORTPKTLIMIT0r, index 0 */
        soc_reg32_get(unit, CNGPORTPKTLIMIT0r,
                      port, 0, &rval);
        soc_reg_field_set(unit, CNGPORTPKTLIMIT0r, &rval,
                          CNGPORTPKTLIMIT0f,
                          numxqs_per_downlink_ports_and_cpu_port - 1);
        soc_reg32_set(unit, CNGPORTPKTLIMIT0r,
                      port, 0, rval);

        /* CNGPORTPKTLIMIT1r, index 0 */
        soc_reg32_get(unit, CNGPORTPKTLIMIT1r,
                      port, 0, &rval);
        soc_reg_field_set(unit, CNGPORTPKTLIMIT1r, &rval,
                          CNGPORTPKTLIMIT1f,
                          numxqs_per_downlink_ports_and_cpu_port - 1);
        soc_reg32_set(unit, CNGPORTPKTLIMIT1r,
                      port, 0, rval);

        /* DYNXQCNTPORTr, index 0 */
        soc_reg32_get(unit, DYNXQCNTPORTr,
                      port, 0, &rval);
        soc_reg_field_set(unit, DYNXQCNTPORTr, &rval,
                          DYNXQCNTPORTf,
                          shared_xqs_per_downlink_port - skidmarker - prefetch);
        soc_reg32_set(unit, DYNXQCNTPORTr,
                      port, 0, rval);

        /* DYNRESETLIMPORTr, index 0 */
        soc_reg32_get(unit, DYNRESETLIMPORTr,
                      port, 0, &rval);
        soc_reg_field_set(unit, DYNRESETLIMPORTr, &rval,
                          DYNRESETLIMPORTf,
                          dynxqcntport_dynxqcntport_down_10 - 2);
        soc_reg32_set(unit, DYNRESETLIMPORTr,
                      port, 0, rval);

        /* LWMCOSCELLSETLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMITr, &rval,
                              CELLSETLIMITf,
                              egress_queue_min_reserve_downlink_ports_lossy);
            soc_reg32_set(unit, LWMCOSCELLSETLIMITr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMITr, index 7 */
        soc_reg32_get(unit, LWMCOSCELLSETLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, LWMCOSCELLSETLIMITr, &rval,
                          CELLSETLIMITf,
                          egress_queue_min_reserve_downlink_ports_lossless);
        soc_reg32_set(unit, LWMCOSCELLSETLIMITr,
                      port, 7, rval);

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                              CELLSETLIMITf,
                              egress_queue_min_reserve_downlink_ports_lossy);
            soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 7 */
        soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                          CELLSETLIMITf,
                          egress_queue_min_reserve_downlink_ports_lossless);
        soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                      port, 7, rval);

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                              CELLSETLIMITf,
                              0);
            soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMITr, &rval,
                              CELLRESETLIMITf,
                              egress_queue_min_reserve_downlink_ports_lossy);
            soc_reg32_set(unit, LWMCOSCELLSETLIMITr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMITr, index 7 */
        soc_reg32_get(unit, LWMCOSCELLSETLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, LWMCOSCELLSETLIMITr, &rval,
                          CELLRESETLIMITf,
                          egress_queue_min_reserve_downlink_ports_lossless);
        soc_reg32_set(unit, LWMCOSCELLSETLIMITr,
                      port, 7, rval);

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                              CELLRESETLIMITf,
                              egress_queue_min_reserve_downlink_ports_lossy);
            soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 7 */
        soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                          CELLRESETLIMITf,
                          egress_queue_min_reserve_downlink_ports_lossless);
        soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                      port, 7, rval);

        /* LWMCOSCELLSETLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMIT_QLAYERr, &rval,
                              CELLRESETLIMITf,
                              0);
            soc_reg32_set(unit, LWMCOSCELLSETLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                              CELLMAXLIMITf,
                              ceiling_func(shared_space_cells,
                              queue_port_limit_ratio) +
                              lwmcoscellsetlimit0_cellsetlimit_down_10);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMITr, index 7 */
        soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                          CELLMAXLIMITf,
                          ceiling_func(shared_space_cells,
                          queue_port_limit_ratio) +
                          lwmcoscellsetlimit7_cellsetlimit_down_10);
        soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                      port, 7, rval);

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                              CELLMAXLIMITf,
                              ceiling_func(shared_space_cells,
                                           queue_port_limit_ratio) +
                              lwmcoscellsetlimit_qlayer0_cellsetlimit_down_10);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 7 */
        soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                          CELLMAXLIMITf,
                          ceiling_func(shared_space_cells,
                                       queue_port_limit_ratio) +
                          lwmcoscellsetlimit_qlayer7_cellsetlimit_down_10);
        soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                      port, 7, rval);

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                              CELLMAXLIMITf,
                              ceiling_func(shared_space_cells,
                                           queue_port_limit_ratio) +
                              lwmcoscellsetlimit_qlayer8_cellsetlimit_down_10);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                              CELLMAXRESUMELIMITf,
                              holcoscellmaxlimit0_cellmaxlimit_down_10 -
                              ethernet_mtu_cell);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMITr, index 7 */
        soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                          CELLMAXRESUMELIMITf,
                          holcoscellmaxlimit7_cellmaxlimit_down_10 -
                          ethernet_mtu_cell);
        soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                      port, 7, rval);

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                              CELLMAXRESUMELIMITf,
                              holcoscellmaxlimit_qlayer0_cellmaxlimit_down_10 -
                              ethernet_mtu_cell);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 7 */
        soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                          CELLMAXRESUMELIMITf,
                          holcoscellmaxlimit_qlayer7_cellmaxlimit_down_10 -
                          ethernet_mtu_cell);
        soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                      port, 7, rval);

        /* HOLCOSCELLMAXLIMIT_QLAYERr, index 8 ~ 63 */
        for (index = 8; index <= 63; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr, &rval,
                              CELLMAXRESUMELIMITf,
                              holcoscellmaxlimit_qlayer8_cellmaxlimit_down_10 -
                              ethernet_mtu_cell);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QLAYERr,
                          port, index, rval);
        }

        /* DYNCELLLIMITr, index 0 */
        soc_reg32_get(unit, DYNCELLLIMITr,
                      port, 0, &rval);
        soc_reg_field_set(unit, DYNCELLLIMITr, &rval,
                          DYNCELLSETLIMITf,
                          shared_space_cells);
        soc_reg_field_set(unit, DYNCELLLIMITr, &rval,
                          DYNCELLRESETLIMITf,
                          dyncelllimit_dyncellsetlimit_down_10 -
                          (ethernet_mtu_cell * 2));
        soc_reg32_set(unit, DYNCELLLIMITr,
                      port, 0, rval);

        /* COLOR_DROP_ENr, index 0 */
        soc_reg32_get(unit, COLOR_DROP_ENr,
                      port, 0, &rval);
        soc_reg_field_set(unit, COLOR_DROP_ENr, &rval,
                          COLOR_DROP_ENf,
                          0);
        soc_reg32_set(unit, COLOR_DROP_ENr,
                      port, 0, rval);

        /* COLOR_DROP_EN_QLAYERr, index 0 */
        soc_reg32_get(unit, COLOR_DROP_EN_QLAYERr,
                      port, 0, &rval);
        soc_reg_field_set(unit, COLOR_DROP_EN_QLAYERr, &rval,
                          COLOR_DROP_ENf,
                          0);
        soc_reg32_set(unit, COLOR_DROP_EN_QLAYERr,
                      port, 0, rval);

        /* HOLCOSPKTSETLIMIT_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSPKTSETLIMIT_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTSETLIMIT_QGROUPr, &rval,
                              PKTSETLIMITf,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, HOLCOSPKTSETLIMIT_QGROUPr,
                          port, index, rval);
        }

        /* HOLCOSPKTRESETLIMIT_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSPKTRESETLIMIT_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTRESETLIMIT_QGROUPr, &rval,
                              PKTRESETLIMITf,
                              holcospktsetlimit_qgroup0_pktsetlimit_down_10 - 1);
            soc_reg32_set(unit, HOLCOSPKTRESETLIMIT_QGROUPr,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT0_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT0_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT0_QGROUPr, &rval,
                              CNGPKTSETLIMIT0f,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT0_QGROUPr,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT1_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT1_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT1_QGROUPr, &rval,
                              CNGPKTSETLIMIT1f,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT1_QGROUPr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMIT_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QGROUPr, &rval,
                              CELLMAXLIMITf,
                              ceiling_func(total_advertised_cell_memory,
                                           queue_port_limit_ratio));
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QGROUPr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMIT_QGROUPr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMIT_QGROUPr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMIT_QGROUPr, &rval,
                              CELLMAXRESUMELIMITf,
                              holcoscellmaxlimit_qgroup0_cellmaxlimit_down_10 -
                              ethernet_mtu_cell);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMIT_QGROUPr,
                          port, index, rval);
        }

        /* COLOR_DROP_EN_QGROUPr, index 0 */
        soc_reg32_get(unit, COLOR_DROP_EN_QGROUPr,
                      port, 0, &rval);
        soc_reg_field_set(unit, COLOR_DROP_EN_QGROUPr, &rval,
                          COLOR_DROP_ENf,
                          0);
        soc_reg32_set(unit, COLOR_DROP_EN_QGROUPr,
                      port, 0, rval);

        /* SHARED_POOL_CTRLr, index 0 */
        soc_reg32_get(unit, SHARED_POOL_CTRLr,
                      port, 0, &rval);
        soc_reg_field_set(unit, SHARED_POOL_CTRLr, &rval,
                          DYNAMIC_COS_DROP_ENf,
                          255);
        soc_reg_field_set(unit, SHARED_POOL_CTRLr, &rval,
                          SHARED_POOL_DISCARD_ENf,
                          127);
        soc_reg_field_set(unit, SHARED_POOL_CTRLr, &rval,
                          SHARED_POOL_XOFF_ENf,
                          0);
        soc_reg32_set(unit, SHARED_POOL_CTRLr,
                      port, 0, rval);

        /* SHARED_POOL_CTRL_EXT1r, index 0 */
        soc_reg32_get(unit, SHARED_POOL_CTRL_EXT1r,
                      port, 0, &rval);
        soc_reg_field_set(unit, SHARED_POOL_CTRL_EXT1r, &rval,
                          DYNAMIC_COS_DROP_ENf,
                          0xFFFFFF);
        soc_reg32_set(unit, SHARED_POOL_CTRL_EXT1r,
                      port, 0, rval);

        /* SHARED_POOL_CTRL_EXT2r, index 0 */
        soc_reg32_get(unit, SHARED_POOL_CTRL_EXT2r,
                      port, 0, &rval);
        soc_reg_field_set(unit, SHARED_POOL_CTRL_EXT2r, &rval,
                          DYNAMIC_COS_DROP_ENf,
                          0xFFFFFFFF);
        soc_reg32_set(unit, SHARED_POOL_CTRL_EXT2r,
                      port, 0, rval);
    }

    /* port-based : cpu port*/
    SOC_PBMP_ITER(pbmp_cpu, port) {
        /* PG_CTRL0r, index 0 */
        soc_reg32_get(unit, PG_CTRL0r,
                      port, 0, &rval);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PPFC_PG_ENf,
                          0);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI0_GRPf,
                          0);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI1_GRPf,
                          1);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI2_GRPf,
                          2);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI3_GRPf,
                          3);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI4_GRPf,
                          4);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI5_GRPf,
                          5);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI6_GRPf,
                          6);
        soc_reg_field_set(unit, PG_CTRL0r, &rval,
                          PRI7_GRPf,
                          7);
        soc_reg32_set(unit, PG_CTRL0r,
                      port, 0, rval);

        /* PG_CTRL1r, index 0 */
        soc_reg32_get(unit, PG_CTRL1r,
                      port, 0, &rval);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI8_GRPf,
                          7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI9_GRPf,
                          7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI10_GRPf,
                          7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI11_GRPf,
                          7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI12_GRPf,
                          7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI13_GRPf,
                          7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI14_GRPf,
                          7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval,
                          PRI15_GRPf,
                          7);
        soc_reg32_set(unit, PG_CTRL1r,
                      port, 0, rval);

        /* PG2TCr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, PG2TCr,
                          port, index, &rval);
            soc_reg_field_set(unit, PG2TCr, &rval,
                              PG_BMPf,
                              0);
            soc_reg32_set(unit, PG2TCr,
                          port, index, rval);
        }

        /* IBPPKTSETLIMITr, index 0 */
        soc_reg32_get(unit, IBPPKTSETLIMITr,
                      port, 0, &rval);
        soc_reg_field_set(unit, IBPPKTSETLIMITr, &rval,
                          PKTSETLIMITf,
                          xoff_packet_thresholds_per_port_uplink_port);
        soc_reg_field_set(unit, IBPPKTSETLIMITr, &rval,
                          RESETLIMITSELf,
                          3);
        soc_reg32_set(unit, IBPPKTSETLIMITr,
                      port, 0, rval);

        /* MMU_FC_RX_ENr, index 0 */
        soc_reg32_get(unit, MMU_FC_RX_ENr,
                      port, 0, &rval);
        soc_reg_field_set(unit, MMU_FC_RX_ENr, &rval,
                          MMU_FC_RX_ENABLEf,
                          0);
        soc_reg32_set(unit, MMU_FC_RX_ENr,
                      port, 0, rval);

        /* MMU_FC_TX_ENr, index 0 */
        soc_reg32_get(unit, MMU_FC_TX_ENr,
                      port, 0, &rval);
        soc_reg_field_set(unit, MMU_FC_TX_ENr, &rval,
                          MMU_FC_TX_ENABLEf,
                          0);
        soc_reg32_set(unit, MMU_FC_TX_ENr,
                      port, 0, rval);

        /* PGCELLLIMITr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, PGCELLLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, PGCELLLIMITr, &rval,
                              CELLSETLIMITf,
                              xoff_cell_threshold_all_uplink_ports);
            soc_reg32_set(unit, PGCELLLIMITr,
                          port, index, rval);
        }

        /* PGCELLLIMITr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, PGCELLLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, PGCELLLIMITr, &rval,
                              CELLRESETLIMITf,
                              xoff_cell_threshold_all_uplink_ports);
            soc_reg32_set(unit, PGCELLLIMITr,
                          port, index, rval);
        }

        /* PGDISCARDSETLIMITr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, PGDISCARDSETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, PGDISCARDSETLIMITr, &rval,
                              DISCARDSETLIMITf,
                              discard_limit_per_port_pg_downlink_port);
            soc_reg32_set(unit, PGDISCARDSETLIMITr,
                          port, index, rval);
        }

        /* HOLCOSMINXQCNTr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSMINXQCNTr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSMINXQCNTr, &rval,
                              HOLCOSMINXQCNTf,
                              egress_queue_min_reserve_cpu_ports);
            soc_reg32_set(unit, HOLCOSMINXQCNTr,
                          port, index, rval);
        }

        /* HOLCOSPKTSETLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSPKTSETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTSETLIMITr, &rval,
                              PKTSETLIMITf,
                              shared_xqs_per_downlink_port +
                              egress_xq_min_reserve_lossy_up_downlink_ports);
            soc_reg32_set(unit, HOLCOSPKTSETLIMITr,
                          port, index, rval);
        }

        /* HOLCOSPKTSETLIMITr, index 7 */
        soc_reg32_get(unit, HOLCOSPKTSETLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSPKTSETLIMITr, &rval,
                          PKTSETLIMITf,
                          shared_xqs_per_downlink_port +
                          egress_xq_min_reserve_lossless_downlink_ports);
        soc_reg32_set(unit, HOLCOSPKTSETLIMITr,
                      port, 7, rval);

        /* HOLCOSPKTRESETLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSPKTRESETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTRESETLIMITr, &rval,
                              PKTRESETLIMITf,
                              holcospktsetlimit0_pktsetlimit_cpu - 1);
            soc_reg32_set(unit, HOLCOSPKTRESETLIMITr,
                          port, index, rval);
        }

        /* HOLCOSPKTRESETLIMITr, index 7 */
        soc_reg32_get(unit, HOLCOSPKTRESETLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSPKTRESETLIMITr, &rval,
                          PKTRESETLIMITf,
                          holcospktsetlimit7_pktsetlimit_cpu - 1);
        soc_reg32_set(unit, HOLCOSPKTRESETLIMITr,
                      port, 7, rval);

        /* CNGCOSPKTLIMIT0r, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT0r,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT0r, &rval,
                              CNGPKTSETLIMIT0f,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT0r,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT1r, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT1r,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT1r, &rval,
                              CNGPKTSETLIMIT1f,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT1r,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT0_QLAYERr, index 0 ~ 63 */
        for (index = 0; index <= 63; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT0_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT0_QLAYERr, &rval,
                              CNGPKTSETLIMIT0f,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT0_QLAYERr,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT1_QLAYERr, index 0 ~ 63 */
        for (index = 0; index <= 63; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT1_QLAYERr,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT1_QLAYERr, &rval,
                              CNGPKTSETLIMIT1f,
                              numxqs_per_downlink_ports_and_cpu_port - 1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT1_QLAYERr,
                          port, index, rval);
        }

        /* CNGPORTPKTLIMIT0r, index 0 */
        soc_reg32_get(unit, CNGPORTPKTLIMIT0r,
                      port, 0, &rval);
        soc_reg_field_set(unit, CNGPORTPKTLIMIT0r, &rval,
                          CNGPORTPKTLIMIT0f,
                          numxqs_per_downlink_ports_and_cpu_port - 1);
        soc_reg32_set(unit, CNGPORTPKTLIMIT0r,
                      port, 0, rval);

        /* CNGPORTPKTLIMIT1r, index 0 */
        soc_reg32_get(unit, CNGPORTPKTLIMIT1r,
                      port, 0, &rval);
        soc_reg_field_set(unit, CNGPORTPKTLIMIT1r, &rval,
                          CNGPORTPKTLIMIT1f,
                          numxqs_per_downlink_ports_and_cpu_port - 1);
        soc_reg32_set(unit, CNGPORTPKTLIMIT1r,
                      port, 0, rval);

        /* DYNXQCNTPORTr, index 0 */
        soc_reg32_get(unit, DYNXQCNTPORTr,
                      port, 0, &rval);
        soc_reg_field_set(unit, DYNXQCNTPORTr, &rval,
                          DYNXQCNTPORTf,
                          shared_xqs_per_downlink_port - skidmarker - prefetch);
        soc_reg32_set(unit, DYNXQCNTPORTr,
                      port, 0, rval);

        /* DYNRESETLIMPORTr, index 0 */
        soc_reg32_get(unit, DYNRESETLIMPORTr,
                      port, 0, &rval);
        soc_reg_field_set(unit, DYNRESETLIMPORTr, &rval,
                          DYNRESETLIMPORTf,
                          dynxqcntport_dynxqcntport_cpu - 2);
        soc_reg32_set(unit, DYNRESETLIMPORTr,
                      port, 0, rval);

        /* LWMCOSCELLSETLIMITr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMITr, &rval,
                              CELLSETLIMITf,
                              egress_queue_min_reserve_cpu_ports);
            soc_reg32_set(unit, LWMCOSCELLSETLIMITr,
                          port, index, rval);
        }

        /* LWMCOSCELLSETLIMITr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMITr, &rval,
                              CELLRESETLIMITf,
                              egress_queue_min_reserve_cpu_ports);
            soc_reg32_set(unit, LWMCOSCELLSETLIMITr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                              CELLMAXLIMITf,
                              ceiling_func(shared_space_cells,
                                           queue_port_limit_ratio) +
                              lwmcoscellsetlimit0_cellsetlimit_cpu);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMITr, index 7 */
        soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                          CELLMAXLIMITf,
                          ceiling_func(shared_space_cells,
                                       queue_port_limit_ratio) +
                          lwmcoscellsetlimit7_cellsetlimit_cpu);
        soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                      port, 7, rval);

        /* HOLCOSCELLMAXLIMITr, index 0 ~ 6 */
        for (index = 0; index <= 6; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                              CELLMAXRESUMELIMITf,
                              holcoscellmaxlimit0_cellmaxlimit_cpu -
                              ethernet_mtu_cell);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMITr, index 7 */
        soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                      port, 7, &rval);
        soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                          CELLMAXRESUMELIMITf,
                          holcoscellmaxlimit7_cellmaxlimit_cpu -
                          ethernet_mtu_cell);
        soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                      port, 7, rval);

        /* DYNCELLLIMITr, index 0 */
        soc_reg32_get(unit, DYNCELLLIMITr,
                      port, 0, &rval);
        soc_reg_field_set(unit, DYNCELLLIMITr, &rval,
                          DYNCELLSETLIMITf,
                          shared_space_cells);
        soc_reg_field_set(unit, DYNCELLLIMITr, &rval,
                          DYNCELLRESETLIMITf,
                          dyncelllimit_dyncellsetlimit_cpu -
                          ethernet_mtu_cell * 2);
        soc_reg32_set(unit, DYNCELLLIMITr,
                      port, 0, rval);

        /* COLOR_DROP_ENr, index 0 */
        soc_reg32_get(unit, COLOR_DROP_ENr,
                      port, 0, &rval);
        soc_reg_field_set(unit, COLOR_DROP_ENr, &rval,
                          COLOR_DROP_ENf,
                          0);
        soc_reg32_set(unit, COLOR_DROP_ENr,
                      port, 0, rval);

        /* COLOR_DROP_EN_QLAYERr, index 0 */
        soc_reg32_get(unit, COLOR_DROP_EN_QLAYERr,
                      port, 0, &rval);
        soc_reg_field_set(unit, COLOR_DROP_EN_QLAYERr, &rval,
                          COLOR_DROP_ENf,
                          0);
        soc_reg32_set(unit, COLOR_DROP_EN_QLAYERr,
                      port, 0, rval);

        /* COLOR_DROP_EN_QGROUPr, index 0 */
        soc_reg32_get(unit, COLOR_DROP_EN_QGROUPr,
                      port, 0, &rval);
        soc_reg_field_set(unit, COLOR_DROP_EN_QGROUPr, &rval,
                          COLOR_DROP_ENf,
                          0);
        soc_reg32_set(unit, COLOR_DROP_EN_QGROUPr,
                      port, 0, rval);

        /* SHARED_POOL_CTRLr, index 0 */
        soc_reg32_get(unit, SHARED_POOL_CTRLr,
                      port, 0, &rval);
        soc_reg_field_set(unit, SHARED_POOL_CTRLr, &rval,
                          DYNAMIC_COS_DROP_ENf,
                          255);
        soc_reg_field_set(unit, SHARED_POOL_CTRLr, &rval,
                          SHARED_POOL_DISCARD_ENf,
                          127);
        soc_reg_field_set(unit, SHARED_POOL_CTRLr, &rval,
                          SHARED_POOL_XOFF_ENf,
                          0);
        soc_reg32_set(unit, SHARED_POOL_CTRLr,
                      port, 0, rval);

        /* SHARED_POOL_CTRL_EXT1r, index 0 */
        soc_reg32_get(unit, SHARED_POOL_CTRL_EXT1r,
                      port, 0, &rval);
        soc_reg_field_set(unit, SHARED_POOL_CTRL_EXT1r, &rval,
                          DYNAMIC_COS_DROP_ENf,
                          0xFFFFFF);
        soc_reg32_set(unit, SHARED_POOL_CTRL_EXT1r,
                      port, 0, rval);

        /* SHARED_POOL_CTRL_EXT2r, index 0 */
        soc_reg32_get(unit, SHARED_POOL_CTRL_EXT2r,
                      port, 0, &rval);
        soc_reg_field_set(unit, SHARED_POOL_CTRL_EXT2r, &rval,
                          DYNAMIC_COS_DROP_ENf,
                          0xFFFFFFFF);
        soc_reg32_set(unit, SHARED_POOL_CTRL_EXT2r,
                      port, 0, rval);
    }

    return SOC_E_NONE;
}


#define  GH2_NUM_COS  8


STATIC int
_soc_greyhound2_mmu_init(int unit)
{

    {
        uint16 dev_id;
        uint8 rev_id;
        uint32 val, oval, cfap_max_idx;

        soc_cm_get_id(unit, &dev_id, &rev_id);
        if ((dev_id & 0xF000) == 0x8000) {
            dev_id &= 0xFF0F;
        }
        SOC_IF_ERROR_RETURN(_soc_greyhound2_tdm_init(unit, dev_id));

        if (rev_id == BCM56170_B0_REV_ID) {
            cfap_max_idx = GH2_B0_MMU_CBP_FULL_SIZE;
        } else {
            cfap_max_idx = GH2_A0_MMU_CBP_FULL_SIZE;
        }
        SOC_IF_ERROR_RETURN(READ_CFAPCONFIGr(unit, &val));
        oval = val;
        soc_reg_field_set(unit, CFAPCONFIGr, &val, CFAPPOOLSIZEf, cfap_max_idx);
        if (oval != val) {
            SOC_IF_ERROR_RETURN(WRITE_CFAPCONFIGr(unit, val));
        }
    }

    /* Enable IP to CMICM credit transfer */
    {
        uint32 val;
        val = 0;
        soc_reg_field_set(unit, IP_TO_CMICM_CREDIT_TRANSFERr,
                          &val, TRANSFER_ENABLEf, 1);
        soc_reg_field_set(unit, IP_TO_CMICM_CREDIT_TRANSFERr,
                          &val, NUM_OF_CREDITSf, 32);
        SOC_IF_ERROR_RETURN(WRITE_IP_TO_CMICM_CREDIT_TRANSFERr(unit, val));

        if (soc_property_get(unit, spn_MMU_LOSSLESS, 0)) {
            SOC_IF_ERROR_RETURN(_soc_greyhound2_mmu_init_helper_lossless(unit));
        } else {
            SOC_IF_ERROR_RETURN(_soc_greyhound2_mmu_init_helper_lossy(unit));
        }
        /* Enable E2EFC in mmu block */
        SOC_IF_ERROR_RETURN(READ_E2EFC_IBP_ENr(unit, &val));
        soc_reg_field_set(unit, E2EFC_IBP_ENr,
                          &val, SEND_RX_E2E_BKP_ENf, 1);
        soc_reg_field_set(unit, E2EFC_IBP_ENr,
                          &val, ENf, 1);
        SOC_IF_ERROR_RETURN(WRITE_E2EFC_IBP_ENr(unit, val));
    }

    /*
     * Configure per-XQ packet aging for the various COSQs.
     *
     * The shortest age allowed by H/W is 250 microseconds.
     * The longest age allowed is 7.162 seconds (7162 msec).
     * The maximum ratio between the longest age and the shortest
     * (nonzero) age is 7:2.
     */
    {
        int cos;
        int age[GH2_NUM_COS], max_age, min_age;
        int age_enable, disabled_age;
        int qgroup;

        age_enable = disabled_age = max_age = 0;
        min_age = 7162;
        for (cos = 0; cos < NUM_COS(unit); cos++) {
            if ((age[cos] =
                 soc_property_suffix_num_get(unit, cos, spn_MMU_XQ_AGING,
                                             "cos",  0)) > 0) {
                age_enable = 1;
                if (age[cos] > 7162) {
                    age[cos] = 7162;
                }
                if (age[cos] < min_age) {
                    min_age = age[cos];
                }
            } else {
                disabled_age = 1;
                age[cos] = 0;
            }
            if (age[cos] > max_age) {
                max_age = age[cos];
            }
        }
        if (!age_enable) {
            /* Disable packet aging on all COSQs */
            SOC_IF_ERROR_RETURN(WRITE_PKTAGINGTIMERr(unit, 0));
            for (qgroup = 0; qgroup < 8; qgroup++) {
                SOC_IF_ERROR_RETURN(WRITE_PKTAGINGLIMIT_r(unit, qgroup, 0));
            }
        } else {
            uint32 regval = 0;
            uint32 timerval;

            /* Enforce the 7:2 ratio between min and max values */
            if ((((max_age * 2) + 6) / 7) > min_age) {
                /* Keep requested max age; make min_age comply */
                min_age = ((max_age * 2) + 6) / 7;
            }

            /*
             * Give up granularity for range, if we need to
             * "disable" (max out) aging for any COSQ(s).
             */
            if (disabled_age) {
                /* Max range */
                max_age = min_age * 7 / 2;
            }

            /*
             * Compute shortest duration of one PKTAGINGTIMERr cycle.
             * This duration is 1/7th of the longest packet age.
             * This duration is in units of 125 usec (msec * 8).
             */
            timerval = ((8 * max_age) + 6) / 7;
            SOC_IF_ERROR_RETURN(WRITE_PKTAGINGTIMERr(unit, timerval));

            /* rPKTAGINGTIMER value 0 means aging disabled */
            if (timerval != 0) {
                for (cos = 0; cos < NUM_COS(unit); cos++) {
                    if (!age[cos]) {
                        /*
                         * Requested to be disabled, but cannot disable
                         * individual COSQs once packet aging is enabled.
                         * Therefore, mark this COSQ's aging duration as maxed
                         * out.
                         */
                        age[cos] = -1;
                    } else if (age[cos] < min_age) {
                        age[cos] = min_age;
                    }

                    /* Normalize each "age" into # of PKTAGINGTIMERr cycles. */
                    if (age[cos] > 0) {
                        age[cos] = ((8 * age[cos]) + timerval - 1) / timerval;
                    }
                    else {
                        age[cos] = 7;
                    }
                    /* Format each "age" for its appropriate field */
                    regval |= ((7 - age[cos]) << (cos * 3));
                }
            } else {
                regval = 0;
            }
            for (qgroup = 0; qgroup < 8; qgroup++) {
                SOC_IF_ERROR_RETURN
                    (WRITE_PKTAGINGLIMIT_r(unit, qgroup, regval));
            }
        }
    }

    /*
     * MMU Port enable
     */
    {
        soc_port_t  port;
        pbmp_t mmu_pbmp;
        int phy_port;
        int mmu_port;
        soc_info_t *si = &SOC_INFO(unit);
        uint32 val;

        SOC_PBMP_CLEAR(mmu_pbmp);
        PBMP_ALL_ITER(unit, port) {
            phy_port = si->port_l2p_mapping[port];
            mmu_port = si->port_p2m_mapping[phy_port];
            SOC_PBMP_PORT_ADD(mmu_pbmp, mmu_port);
        }
        val = 0;
        soc_reg_field_set(unit, MMUPORTENABLE_0r, &val, MMUPORTENABLEf,
                          SOC_PBMP_WORD_GET(mmu_pbmp, 0));
        SOC_IF_ERROR_RETURN(WRITE_MMUPORTENABLE_0r(unit, val));
        val = 0;
        soc_reg_field_set(unit, MMUPORTENABLE_1r, &val, MMUPORTENABLEf,
                          SOC_PBMP_WORD_GET(mmu_pbmp, 1));
        SOC_IF_ERROR_RETURN(WRITE_MMUPORTENABLE_1r(unit, val));
        val = 0;
        soc_reg_field_set(unit, MMUPORTENABLE_2r, &val, MMUPORTENABLEf,
                          SOC_PBMP_WORD_GET(mmu_pbmp, 2));
        SOC_IF_ERROR_RETURN(WRITE_MMUPORTENABLE_2r(unit, val));
    }

    return SOC_E_NONE;
}

/* soc_greyhound2_tsc_reset()
 *  - to reset TSCE, TSCF and QTC on Greyhound2
 */
int
soc_greyhound2_tsc_reset(int unit)
{
    int blk, port;
    uint32 rval;

    /* Reset SGMII4Px2 */
    SOC_BLOCK_ITER(unit, blk, SOC_BLK_PMQ) {
        port = blk | SOC_REG_ADDR_BLOCK_ID_MASK;
        SOC_IF_ERROR_RETURN(soc_sgmii4px2_reset(unit, port, 0));
        SOC_IF_ERROR_RETURN(soc_sgmii4px2_reset(unit, port, 1));
    }

    /* Reset QTC */
    SOC_BLOCK_ITER(unit, blk, SOC_BLK_PMQ) {
        port = blk | SOC_REG_ADDR_BLOCK_ID_MASK;
        SOC_IF_ERROR_RETURN(soc_tsc_xgxs_reset(unit, port, 0));
    }

    /* Reset TSCE */
    SOC_BLOCK_ITER(unit, blk, SOC_BLK_XLPORT) {
        port = SOC_BLOCK_PORT(unit, blk);
        SOC_IF_ERROR_RETURN(soc_tsc_xgxs_reset(unit, port, 0));
    }

    /* Reset TSCF */
    SOC_BLOCK_ITER(unit, blk, SOC_BLK_CLPORT) {
        port = SOC_BLOCK_PORT(unit, blk);
        SOC_IF_ERROR_RETURN(soc_tsc_xgxs_reset(unit, port, 0));
    }

    SOC_BLOCK_ITER(unit, blk, SOC_BLK_XLPORT) {
        port = SOC_BLOCK_PORT(unit, blk);
        if (port == -1 || port == REG_PORT_ANY) {
            continue;
        }
        SOC_IF_ERROR_RETURN(READ_XLPORT_MAC_CONTROLr(unit, port, &rval));
        soc_reg_field_set(unit, XLPORT_MAC_CONTROLr, &rval, XMAC0_RESETf, 1);
        SOC_IF_ERROR_RETURN(WRITE_XLPORT_MAC_CONTROLr(unit, port, rval));
        sal_udelay(10);
        soc_reg_field_set(unit, XLPORT_MAC_CONTROLr, &rval, XMAC0_RESETf, 0);
        SOC_IF_ERROR_RETURN(WRITE_XLPORT_MAC_CONTROLr(unit, port, rval));
    }

    SOC_BLOCK_ITER(unit, blk, SOC_BLK_CLPORT) {
        port = SOC_BLOCK_PORT(unit, blk);
        if (port == -1 || port == REG_PORT_ANY) {
            continue;
        }
        SOC_IF_ERROR_RETURN(READ_CLPORT_MAC_CONTROLr(unit, port, &rval));
        soc_reg_field_set(unit, CLPORT_MAC_CONTROLr, &rval, XMAC0_RESETf, 1);
        SOC_IF_ERROR_RETURN(WRITE_CLPORT_MAC_CONTROLr(unit, port, rval));
        sal_udelay(10);
        soc_reg_field_set(unit, CLPORT_MAC_CONTROLr, &rval, XMAC0_RESETf, 0);
        SOC_IF_ERROR_RETURN(WRITE_CLPORT_MAC_CONTROLr(unit, port, rval));
    }

    return SOC_E_NONE;
}

extern int
(*_phy_tsce_firmware_set_helper[SOC_MAX_NUM_DEVICES])(int, int, uint8 *, int);
extern int
(*_phy_tscf_firmware_set_helper[SOC_MAX_NUM_DEVICES])(int, int, uint8 *, int);
extern int
(*_phy_qtce_firmware_set_helper[SOC_MAX_NUM_DEVICES])(int, int, uint8 *, int);


STATIC int
_soc_greyhound2_tscx_firmware_set(int unit, int port, uint8 *array, int datalen)
{
    soc_mem_t mem = IS_CL_PORT(unit, port) ? CLPORT_WC_UCMEM_DATAm :
                    (IS_XL_PORT(unit, port) ? XLPORT_WC_UCMEM_DATAm :
                                              GPORT_WC_UCMEM_DATAm);
    soc_reg_t reg = IS_CL_PORT(unit, port) ? CLPORT_WC_UCMEM_CTRLr :
                    (IS_XL_PORT(unit, port) ? XLPORT_WC_UCMEM_CTRLr :
                                              GPORT_WC_UCMEM_CTRLr);

    return soc_warpcore_firmware_set(unit, port, array, datalen, 0, mem, reg);
}

#define INVALID_PPORT_ID    -1
/*
 * Func : _soc_greyhound2_mdio_addr_to_port
 *  - To report pport_id from given phy_addr(for INT-PHY)
 *
 * INFO :
 *  - This is HW dependent design in TOP Spec.
 *      1. Int-MDIO-Bus0 : SGMII4Px2_0 ~ SGMII4Px2_2 (each for 8 ports)
 *      2. Int-MDIO-Bus1 : TSCE0 ~ TSCE6 (each for 4 ports)
 *      3. Int-MDIO-Bus2 : QTC0 ~ QTC1 (each for 16 ports)
 *      4. Int-MDIO-Bus3 : TSCF (each for 4 ports)
 *  - Param of "phy_addr" here has been constructed by phymod driver.
 */
STATIC int
_soc_greyhound2_mdio_addr_to_port(uint32 phy_addr_int)
{
    int bus, offset = 0;
    int mdio_addr;

    /* Must be internal MDIO address */
    if ((phy_addr_int & 0x80) == 0) {
        return INVALID_PPORT_ID;
    }

    bus = PHY_ID_BUS_NUM(phy_addr_int);
    mdio_addr = phy_addr_int & 0x1f;

    if (bus == 0) {
        /* for SGMII4Px2 */
        if (mdio_addr <= 0x18) {
            offset = 1;
        } else {
            return INVALID_PPORT_ID;
        }
    } else if (bus == 1) {
        /* for TSCE */
        if (mdio_addr <= 0x1c) {
            offset = 57;
        } else {
            return INVALID_PPORT_ID;
        }
    } else if (bus == 2) {
        if (mdio_addr <= 4) {
            /* for QTC0 */
            offset = 25;
        } else if (mdio_addr <= 8) {
            /* for QTC1 */
            offset = 37;
        } else {
            return INVALID_PPORT_ID;
        }
    } else if (bus == 3) {
        /* for TSCF */
        if (mdio_addr <= 0x4) {
            offset = 85;
        } else {
            return INVALID_PPORT_ID;
        }
    } else {
        return INVALID_PPORT_ID;
    }

    return mdio_addr + offset;
}

/*
 * PHY_REG address decode for TSCx phy access :
 *  - TSC_ADDR[31:0]={DEVICE(ADVAD)[31:27],??[26:24],TSC_ID(PHYAD)[23:19],
 *      PORT_MODE(LANE)[18:16], IEEE_BIT[15], BLOCK[14:4], REG[3:0]}
 */
#define TSC_REG_ADDR_TSCID_SET(_phy_reg, _phyad)    \
                            ((_phy_reg) |= ((_phyad) & 0x1f) << 19)

/*
 *  GH2's PMQ block definition.
 *      1. PMQ0-PMQ2 : SGMII4Px2_0-SGMII4Px2_2 for pport2-pport25
 *          >> Expected no SBUS-MDIO for SGMII4Px2
 *      2. PMQ3-PMQ4 for QTC0-QCT1 for pport26-pport57
 */
#define GH2_PMQ3_MIN_PPORT  26
#define GH2_PMQ3_MAX_PPORT  41
#define GH2_PMQ4_MIN_PPORT  42
#define GH2_PMQ4_MAX_PPORT  57

/*
 * Func :  soc_greyhound2_sbus_tsc_block()
 *  - to report the valid blk of this port for wc_ucmem_data
 *      (i.e. GPORT/XLPORT/CLPORT_WC_UCMEM_DATAm)access process.
 *
 *  - Parameters :
 *      phy_port(IN) : physical port.
 *      blk(OUT) : the valid block
 *
 * INFO :
 *  - PMQ block in GH2 are
 *      1. PMQ0-PMQ2 : SGMII4Px2_0-SGMII4Px2_2 for pport2-pport25
 *          >> Expected no SBUS-MDIO for SGMII4Px2
 *      2. PMQ3-PMQ4 for QTC0-QCT1 for pport26-pport57
 */
int
soc_greyhound2_sbus_tsc_block(int unit, int phy_port, int *blk)
{
    soc_info_t *si = &SOC_INFO(unit);

    *blk = -1;
    if (SOC_PORT_BLOCK_TYPE(unit, phy_port) == SOC_BLK_GPORT) {
        if ((phy_port >= GH2_PMQ3_MIN_PPORT) &&
                (phy_port <= GH2_PMQ3_MAX_PPORT)) {
            *blk = si->pmq_block[3];
        } else if ((phy_port >= GH2_PMQ4_MIN_PPORT) &&
                (phy_port <= GH2_PMQ4_MAX_PPORT)) {
            *blk = si->pmq_block[4];
        } else {
            /*
             * Port in GPORT block can be QTC port or SGMII port.
             *  - Only QTC ports support SBus-MDIO
             *  - SGMII4P ports return SOC_E_PORT due to no SBus-MDIO.
             */
            LOG_INFO(BSL_LS_SOC_MII, (BSL_META_U(unit,
                     "unit(%d),pport(%d) is unable for TSC SBus-MDIO!\n"),
                     unit, phy_port));
            return SOC_E_PORT;
        }
    } else {
        if ((SOC_PORT_BLOCK_TYPE(unit, phy_port) == SOC_BLK_XLPORT) ||
            (SOC_PORT_BLOCK_TYPE(unit, phy_port) == SOC_BLK_CLPORT)) {
            /* for CL/XL port block */
            *blk = SOC_PORT_BLOCK(unit, phy_port);
        } else {
            /* Unexpected port for SBus-MDIO */
            LOG_WARN(BSL_LS_SOC_MII, (BSL_META_U(unit,
                     "unit(%d),pport(%d) is unable for TSC SBus-MDIO!\n"),
                     unit, phy_port));
            return SOC_E_PORT;
        }
    }

    return SOC_E_NONE;
}

/*
 * Func : _soc_greyhound2_tscx_reg_read
 *  - GH2 function to serve SBus MDIO read on TSCx
 */
STATIC int
_soc_greyhound2_tscx_reg_read(int unit, uint32 phy_addr,
                            uint32 phy_reg, uint32 *phy_data)
{
    int rv, blk, port;
    int phy_port = _soc_greyhound2_mdio_addr_to_port(phy_addr);

    if (phy_port == INVALID_PPORT_ID) {
        LOG_WARN(BSL_LS_SOC_MII, (BSL_META_U(unit,
                "unit%d: phy_addr=%d is unable for Sbus-MDIO read!\n"),
                unit, phy_addr));
        return SOC_E_PARAM;
    }

    port = SOC_INFO(unit).port_p2l_mapping[phy_port];

    SOC_IF_ERROR_RETURN
        (soc_greyhound2_sbus_tsc_block(unit, phy_port, &blk));

    LOG_INFO(BSL_LS_SOC_MII, (BSL_META_U(unit,
             "_soc_greyhound2_tscx_reg_read[%d]: %d/%d/%d/%d\n"),
             unit, phy_addr, phy_port, port, blk));
    TSC_REG_ADDR_TSCID_SET(phy_reg, phy_addr);
    rv = soc_sbus_tsc_reg_read(unit, port, blk, phy_addr,
                               phy_reg, phy_data);

    return rv;
}

/*
 * Func : _soc_greyhound2_tscx_reg_read
 *  - GH2 function to serve SBus MDIO read on TSCx
 */
STATIC int
_soc_greyhound2_tscx_reg_write(int unit, uint32 phy_addr,
                             uint32 phy_reg, uint32 phy_data)
{
    int rv, blk, port;
    int phy_port = _soc_greyhound2_mdio_addr_to_port(phy_addr);

    if (phy_port == INVALID_PPORT_ID) {
        LOG_WARN(BSL_LS_SOC_MII, (BSL_META_U(unit,
                "unit%d: phy_addr=%d is unable for Sbus-MDIO write!\n"),
                unit, phy_addr));
        return SOC_E_PARAM;
    }

    port = SOC_INFO(unit).port_p2l_mapping[phy_port];

    SOC_IF_ERROR_RETURN
        (soc_greyhound2_sbus_tsc_block(unit, phy_port, &blk));

    LOG_INFO(BSL_LS_SOC_MII, (BSL_META_U(unit,
             "_soc_greyhound2_tscx_reg_write[%d]: %d/%d/%d/%d\n"),
             unit, phy_addr, phy_port, port, blk));
    TSC_REG_ADDR_TSCID_SET(phy_reg, phy_addr);
    rv = soc_sbus_tsc_reg_write(unit, port, blk, phy_addr,
                                phy_reg, phy_data);

    return rv;
}

/*
 * Func : soc_greyhound2_pgw_encap_field_get
 *  - To write to PGW interface on GX/XL/CL port on indicated field
 */
int
soc_greyhound2_pgw_encap_field_get(int unit,
                                soc_port_t lport,
                                soc_field_t field,
                                uint32 *val)
{
    uint32  reg_val = 0;
    int     pport = SOC_INFO(unit).port_l2p_mapping[lport];

    *val = 0;
    if (SOC_PORT_BLOCK_TYPE(unit, pport) == SOC_BLK_XLPORT) {
        SOC_IF_ERROR_RETURN(READ_PGW_XL_CONFIGr(unit, lport, &reg_val));
        *val = soc_reg_field_get(unit, PGW_XL_CONFIGr, reg_val, field);
    } else if (SOC_PORT_BLOCK_TYPE(unit, pport) == SOC_BLK_CLPORT) {
        SOC_IF_ERROR_RETURN(READ_PGW_CL_CONFIGr(unit, lport, &reg_val));
        *val = soc_reg_field_get(unit, PGW_CL_CONFIGr, reg_val, field);
    } else {
        SOC_IF_ERROR_RETURN(READ_PGW_GE_CONFIGr(unit, lport, &reg_val));
        *val = soc_reg_field_get(unit, PGW_GE_CONFIGr, reg_val, field);

    }

    return SOC_E_NONE;
}

#define _GH2_PORTS_PER_CLBLK             4

#define GH2_FLOW_TYPE_SR  1
#define GH2_FLOW_TYPE_TSN 2

STATIC int
_soc_greyhound2_misc_init(int unit)
{
#define NUM_SUBPORT 4 /* number of subport of a XL or CL port */
    static const soc_field_t port_field[] = {
        PORT0f, PORT1f, PORT2f, PORT3f
    };
    uint32              rval, l2_ovf_enable, l2_tbl_size, fval;
    uint64              reg64;
    int                 port;
    uint32 entry[SOC_MAX_MEM_WORDS];
    soc_field_t         fields[3];
    uint32              values[3];
    int blk, bindex, mode;
    int phy_port_base;
    soc_info_t *si = &SOC_INFO(unit);
    int delay;
    int freq, target_freq, divisor, dividend;
    int index, count, sub_sel, offset;
    static int rtag7_field_width[] = { 16, 16, 4, 16, 8, 8, 16, 16 };
    int port_count = 0;
    int i = 0;
    int flow_type;
    int parity_enable;
    char *board_name;

    if (!SOC_IS_RELOADING(unit) && !SOC_WARM_BOOT(unit)) {
        /* Clear IPIPE/EIPIE Memories */
        SOC_IF_ERROR_RETURN(soc_greyhound2_pipe_mem_clear(unit));

        /* CHECKME : GH2 needs the same programming as HR3 */
        /* _soc_hurricane3_gport_tdm_mode_init(unit) */

        /* Clear MIB counter */
        SOC_IF_ERROR_RETURN(soc_greyhound2_mib_reset(unit));
    }

    SOC_IF_ERROR_RETURN(soc_greyhound2_init_port_mapping(unit));

    soc_gh2_interrupt_init(unit);
    /* Do SER init and enable/disable parity according to config */
    parity_enable = soc_property_get(unit, spn_PARITY_ENABLE, TRUE);

    if (parity_enable) {
        SOC_IF_ERROR_RETURN(soc_gh2_tcam_ser_init(unit));
        /* Enabling the packet drop when parity error occurred */
        SOC_IF_ERROR_RETURN(READ_IPIPE_PERR_CONTROLr(unit, &rval));
        fval = 1;
        soc_reg_field_set(unit, IPIPE_PERR_CONTROLr, &rval, DROPf, fval);
        SOC_IF_ERROR_RETURN(WRITE_IPIPE_PERR_CONTROLr(unit, rval));
        SOC_IF_ERROR_RETURN(soc_gh2_ser_enable_all(unit, TRUE));
#if defined(SER_TR_TEST_SUPPORT)
        soc_gh2_ser_test_register(unit);
#endif
    } else {
        SOC_IF_ERROR_RETURN(soc_gh2_ser_enable_all(unit, FALSE));
    }

    /* Enable L2 overflow bucket */
    l2_tbl_size = soc_property_get(unit, spn_L2_TABLE_SIZE, 0);
    if (l2_tbl_size == (soc_mem_index_count(unit, L2Xm) +
                        soc_mem_index_count(unit, L2_ENTRY_OVERFLOWm))) {
        /*
         * if l2 table size equals to l2 table size + l2 overflow table size,
         * it indicates the l2 overflow table is enabled.
         */
        l2_ovf_enable = 1;
    } else {
        l2_ovf_enable = 0;
    }
    SOC_IF_ERROR_RETURN(READ_L2_LEARN_CONTROLr(unit, &rval));
    soc_reg_field_set(unit, L2_LEARN_CONTROLr, &rval,
                      OVERFLOW_BUCKET_ENABLEf, l2_ovf_enable);
    SOC_IF_ERROR_RETURN(WRITE_L2_LEARN_CONTROLr(unit, rval));
    SOC_CONTROL_LOCK(unit);
    SOC_CONTROL(unit)->l2_overflow_bucket_enable = l2_ovf_enable;
    SOC_CONTROL_UNLOCK(unit);

    /* Enable L2 overflow interrupt */
    if (soc_property_get(unit, spn_L2_OVERFLOW_EVENT, FALSE)) {

        SOC_CONTROL_LOCK(unit);
        SOC_CONTROL(unit)->l2_overflow_enable = TRUE;
        SOC_CONTROL_UNLOCK(unit);
        SOC_IF_ERROR_RETURN(soc_hr3_l2_overflow_start(unit));
        /* Enable the l2 overflow interrupt */
        soc_gh2_cmic_interrupt_mask(unit, GH2_INTR_L2_OVERFLOW, 1);
    } else {
        SOC_CONTROL_LOCK(unit);
        SOC_CONTROL(unit)->l2_overflow_enable = FALSE;
        SOC_CONTROL_UNLOCK(unit);
        SOC_IF_ERROR_RETURN(soc_hr3_l2_overflow_stop(unit));
        /* Disable the l2 overflow interrupt */
        soc_gh2_cmic_interrupt_mask(unit, GH2_INTR_L2_OVERFLOW, 0);
    }


    /* GMAC init  */
    SOC_IF_ERROR_RETURN(soc_greyhound2_gmac_init(unit));

    /* HG init */
    SOC_IF_ERROR_RETURN(soc_greyhound2_higig_mode_init(unit));

    /* XLPORT and CLPORT blocks init */
    SOC_BLOCK_ITER(unit, blk, SOC_BLK_XLPORT) {
        port = SOC_BLOCK_PORT(unit, blk);
        if (port == -1 || port == REG_PORT_ANY) {
            continue;
        }
        phy_port_base = si->port_l2p_mapping[port];

        /* Assert XLPORT soft reset */
        port_count = -1;
        rval = 0;
        for (bindex = 0; bindex < NUM_SUBPORT; bindex++) {
            if (si->port_p2l_mapping[phy_port_base + bindex] != -1) {
                soc_reg_field_set(unit, XLPORT_SOFT_RESETr, &rval,
                                  port_field[bindex], 1);
            }
        }
        SOC_IF_ERROR_RETURN(WRITE_XLPORT_SOFT_RESETr(unit, port, rval));

        for (i = 0; i < _GH2_MAX_TSC_COUNT ; i++) {
            if (_gh2_tsc[i].phy_port_base == phy_port_base) {
                port_count = _gh2_tsc[i].port_count;
                break;
            }
        }
        if (port_count == SOC_GH2_PORT_RATIO_QUAD) {
            mode = SOC_GH2_PORT_MODE_QUAD;
            si->port_num_lanes[port] = 1;
            si->port_num_lanes[port + 1] = 1;
            si->port_num_lanes[port + 2] = 1;
            si->port_num_lanes[port + 3] = 1;
        } else if ((port_count == SOC_GH2_PORT_RATIO_SINGLE) ||
            (port_count == SOC_GH2_PORT_RATIO_SINGLE_XAUI)) {
            mode = SOC_GH2_PORT_MODE_SINGLE;
            si->port_num_lanes[port] = 4;
        } else if (port_count == SOC_GH2_PORT_RATIO_DUAL_2_2) {
            mode = SOC_GH2_PORT_MODE_DUAL;
            si->port_num_lanes[port] = 2;
            si->port_num_lanes[port + 1] = 2;
        } else if (port_count == SOC_GH2_PORT_RATIO_TRI_012) {
            mode = SOC_GH2_PORT_MODE_TRI_012;
            si->port_num_lanes[port] = 1;
            si->port_num_lanes[port + 1] = 1;
            si->port_num_lanes[port + 2] = 2;
        } else if (port_count == SOC_GH2_PORT_RATIO_TRI_023) {
            mode = SOC_GH2_PORT_MODE_TRI_023;
            si->port_num_lanes[port] = 2;
            si->port_num_lanes[port + 1] = 1;
            si->port_num_lanes[port + 2] = 1;
        } else {
            mode = SOC_GH2_PORT_MODE_QUAD;
            si->port_num_lanes[port] = 1;
            si->port_num_lanes[port + 1] = 1;
            si->port_num_lanes[port + 2] = 1;
            si->port_num_lanes[port + 3] = 1;
        }

        rval = 0;
        soc_reg_field_set(unit, XLPORT_MODE_REGr, &rval,
                          XPORT0_CORE_PORT_MODEf, mode);
        soc_reg_field_set(unit, XLPORT_MODE_REGr, &rval,
                          XPORT0_PHY_PORT_MODEf, mode);
        SOC_IF_ERROR_RETURN(WRITE_XLPORT_MODE_REGr(unit, port, rval));

        /* De-assert XLPORT soft reset */
        SOC_IF_ERROR_RETURN(WRITE_XLPORT_SOFT_RESETr(unit, port, 0));

        /* Enable XLPORT */
        rval = 0;
        for (bindex = 0; bindex < NUM_SUBPORT; bindex++) {
            if (si->port_p2l_mapping[phy_port_base + bindex] != -1) {
                soc_reg_field_set(unit, XLPORT_ENABLE_REGr, &rval,
                                  port_field[bindex], 1);
            }
        }
        SOC_IF_ERROR_RETURN(WRITE_XLPORT_ENABLE_REGr(unit, port, rval));
    }

    SOC_BLOCK_ITER(unit, blk, SOC_BLK_CLPORT) {
        port = SOC_BLOCK_PORT(unit, blk);
        if (port == -1 || port == REG_PORT_ANY) {
            continue;
        }
        phy_port_base = si->port_l2p_mapping[port];

        /* Assert XLPORT soft reset */
        port_count = -1;
        rval = 0;
        for (bindex = 0; bindex < NUM_SUBPORT; bindex++) {
            if (si->port_p2l_mapping[phy_port_base + bindex] != -1) {
                soc_reg_field_set(unit, CLPORT_SOFT_RESETr, &rval,
                                  port_field[bindex], 1);
            }
        }
        SOC_IF_ERROR_RETURN(WRITE_CLPORT_SOFT_RESETr(unit, port, rval));

        for (i = 0; i < _GH2_MAX_TSC_COUNT ; i++) {
            if (_gh2_tsc[i].phy_port_base == phy_port_base) {
                port_count = _gh2_tsc[i].port_count;
                break;
            }
        }
        if (port_count == SOC_GH2_PORT_RATIO_QUAD) {
            mode = SOC_GH2_PORT_MODE_QUAD;
            si->port_num_lanes[port] = 1;
            si->port_num_lanes[port + 1] = 1;
            si->port_num_lanes[port + 2] = 1;
            si->port_num_lanes[port + 3] = 1;
        } else if ((port_count == SOC_GH2_PORT_RATIO_SINGLE) ||
            (port_count == SOC_GH2_PORT_RATIO_SINGLE_XAUI)) {
            mode = SOC_GH2_PORT_MODE_SINGLE;
            si->port_num_lanes[port] = 4;
        } else if (port_count == SOC_GH2_PORT_RATIO_DUAL_2_2) {
            mode = SOC_GH2_PORT_MODE_DUAL;
            si->port_num_lanes[port] = 2;
            si->port_num_lanes[port + 1] = 2;
        } else if (port_count == SOC_GH2_PORT_RATIO_TRI_012) {
            mode = SOC_GH2_PORT_MODE_TRI_012;
            si->port_num_lanes[port] = 1;
            si->port_num_lanes[port + 1] = 1;
            si->port_num_lanes[port + 2] = 2;
        } else if (port_count == SOC_GH2_PORT_RATIO_TRI_023) {
            mode = SOC_GH2_PORT_MODE_TRI_023;
            si->port_num_lanes[port] = 2;
            si->port_num_lanes[port + 1] = 1;
            si->port_num_lanes[port + 2] = 1;
        } else {
            mode = SOC_GH2_PORT_MODE_QUAD;
            si->port_num_lanes[port] = 1;
            si->port_num_lanes[port + 1] = 1;
            si->port_num_lanes[port + 2] = 1;
            si->port_num_lanes[port + 3] = 1;
        }

        rval = 0;
        soc_reg_field_set(unit, CLPORT_MODE_REGr, &rval,
                          XPORT0_CORE_PORT_MODEf, mode);
        soc_reg_field_set(unit, CLPORT_MODE_REGr, &rval,
                          XPORT0_PHY_PORT_MODEf, mode);
        SOC_IF_ERROR_RETURN(WRITE_CLPORT_MODE_REGr(unit, port, rval));

        /* De-assert XLPORT soft reset */
        SOC_IF_ERROR_RETURN(WRITE_CLPORT_SOFT_RESETr(unit, port, 0));

        /* Enable XLPORT */
        rval = 0;
        for (bindex = 0; bindex < NUM_SUBPORT; bindex++) {
            if (si->port_p2l_mapping[phy_port_base + bindex] != -1) {
                soc_reg_field_set(unit, CLPORT_ENABLE_REGr, &rval,
                                  port_field[bindex], 1);
            }
        }
        SOC_IF_ERROR_RETURN(WRITE_CLPORT_ENABLE_REGr(unit, port, rval));
    }

    SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
    soc_reg_field_set(unit, MISCCONFIGr, &rval, METERING_CLK_ENf, 1);
    SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));

    /* Enable dual hash on L2 and L3 tables */
    fields[0] = ENABLEf;
    values[0] = 1;
    fields[1] = HASH_SELECTf;
    values[1] = FB_HASH_CRC32_LOWER;
    fields[2] = INSERT_LEAST_FULL_HALFf;
    values[2] = 1;
    SOC_IF_ERROR_RETURN
        (soc_reg_fields32_modify(unit, L2_AUX_HASH_CONTROLr, REG_PORT_ANY, 3,
                                 fields, values));
    SOC_IF_ERROR_RETURN
        (soc_reg_fields32_modify(unit, L3_AUX_HASH_CONTROLr, REG_PORT_ANY, 3,
                                 fields, values));

    /*
     * Egress Enable
     */
    sal_memset(entry, 0, sizeof(egr_enable_entry_t));
    soc_mem_field32_set(unit, EGR_ENABLEm, entry, PRT_ENABLEf, 1);
    PBMP_ALL_ITER(unit, port) {
        SOC_IF_ERROR_RETURN
            (WRITE_EGR_ENABLEm(unit, MEM_BLOCK_ALL,
                               SOC_INFO(unit).port_l2p_mapping[port], entry));
    }

    COMPILER_64_ZERO(reg64);
    soc_reg64_field32_set(unit, EPC_LINK_BMAP_LO_64r, &reg64, PORT_BITMAP_LOf,
                         SOC_PBMP_WORD_GET(PBMP_CMIC(unit), 0));
    SOC_IF_ERROR_RETURN(WRITE_EPC_LINK_BMAP_LO_64r(unit, reg64));
    SOC_IF_ERROR_RETURN(READ_ING_CONFIG_64r(unit, &reg64));
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
                          L3SRC_HIT_ENABLEf, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
                          L2DST_HIT_ENABLEf, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
                          APPLY_EGR_MASK_ON_L2f, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
                          APPLY_EGR_MASK_ON_L3f, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
                          ARP_RARP_TO_FPf, 0x3); /* enable both ARP & RARP */
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
                          ARP_VALIDATION_ENf, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
                          IGNORE_HG_HDR_LAG_FAILOVERf, 1);
    SOC_IF_ERROR_RETURN(WRITE_ING_CONFIG_64r(unit, reg64));

    SOC_IF_ERROR_RETURN(READ_EGR_CONFIG_1r(unit, &rval));
    soc_reg_field_set(unit, EGR_CONFIG_1r, &rval, RING_MODEf, 1);
    SOC_IF_ERROR_RETURN(WRITE_EGR_CONFIG_1r(unit, rval));

    /* The HW defaults for EGR_VLAN_CONTROL_1.VT_MISS_UNTAG == 1, which
     * causes the outer tag to be removed from packets that don't have
     * a hit in the egress vlan tranlation table. Set to 0 to disable this.
     */
    rval = 0;
    soc_reg_field_set(unit, EGR_VLAN_CONTROL_1r, &rval, VT_MISS_UNTAGf, 0);

    /* Enable pri/cfi remarking on egress ports. */
    soc_reg_field_set(unit, EGR_VLAN_CONTROL_1r, &rval, REMARK_OUTER_DOT1Pf,
                      1);
    PBMP_ALL_ITER(unit, port) {
        SOC_IF_ERROR_RETURN(WRITE_EGR_VLAN_CONTROL_1r(unit, port, rval));
    }

    /* Multicast range initialization */
    SOC_IF_ERROR_RETURN
        (soc_hbx_higig2_mcast_sizes_set(unit,
             soc_property_get(unit, spn_HIGIG2_MULTICAST_VLAN_RANGE,
                              SOC_HBX_MULTICAST_RANGE_DEFAULT),
             soc_property_get(unit, spn_HIGIG2_MULTICAST_L2_RANGE,
                              SOC_HBX_MULTICAST_RANGE_DEFAULT),
             soc_property_get(unit, spn_HIGIG2_MULTICAST_L3_RANGE,
                              SOC_HBX_MULTICAST_RANGE_DEFAULT)));

    /* Enable vrf based l3 lookup by default. */
    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, VRF_MASKr, REG_PORT_ANY, MASKf, 0));

    /* Setup SW2_FP_DST_ACTION_CONTROL */
    fields[0] = HGTRUNK_RES_ENf;
    fields[1] = LAG_RES_ENf;
    values[0] = values[1] = 1;
    SOC_IF_ERROR_RETURN
        (soc_reg_fields32_modify(unit, SW2_FP_DST_ACTION_CONTROLr,
                                 REG_PORT_ANY, 2, fields, values));

    /* Populate and enable RTAG7 Macro flow offset table */
    if (soc_mem_is_valid(unit, RTAG7_FLOW_BASED_HASHm)) {
        count = soc_mem_index_max(unit, RTAG7_FLOW_BASED_HASHm);
        sal_memset(entry, 0, sizeof(rtag7_flow_based_hash_entry_t));
        for (index = 0; index < count; ) {
            for (sub_sel = 0; sub_sel < 8 && index < count; sub_sel++) {
                for (offset = 0;
                     offset < rtag7_field_width[sub_sel] && index < count;
                     offset++) {
                    soc_mem_field32_set(unit, RTAG7_FLOW_BASED_HASHm, &entry,
                                        SUB_SEL_ECMPf, sub_sel);
                    soc_mem_field32_set(unit, RTAG7_FLOW_BASED_HASHm, &entry,
                                        OFFSET_ECMPf, offset);
                    SOC_IF_ERROR_RETURN
                        (soc_mem_write(unit, RTAG7_FLOW_BASED_HASHm,
                                       MEM_BLOCK_ALL, index, &entry));
                    index++;
                }
            }
        }
        rval = 0;
        soc_reg_field_set(unit, RTAG7_HASH_SELr, &rval, USE_FLOW_SEL_ECMPf, 1);
        SOC_IF_ERROR_RETURN(WRITE_RTAG7_HASH_SELr(unit, rval));
    }

    freq = si->frequency;

    /*
     * Set external MDIO freq to around 10MHz
     * target_freq = core_clock_freq * DIVIDEND / DIVISOR / 2
     */
    target_freq = 10;
    divisor = (freq + (target_freq * 2 - 1)) / (target_freq * 2);
    divisor = soc_property_get(unit, spn_RATE_EXT_MDIO_DIVISOR, divisor);
    dividend = soc_property_get(unit, spn_RATE_EXT_MDIO_DIVIDEND, 1);

    rval = 0;
    soc_reg_field_set(unit, CMIC_RATE_ADJUSTr, &rval, DIVISORf, divisor);
    soc_reg_field_set(unit, CMIC_RATE_ADJUSTr, &rval, DIVIDENDf, dividend);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_RATE_ADJUSTr(unit, rval));

    /*
     * Set internal MDIO freq to around 10MHz
     * Valid range is from 2.5MHz to 12.5MHz
     * target_freq = core_clock_freq * DIVIDEND / DIVISOR / 2
     * or
     * DIVISOR = core_clock_freq * DIVIDENT / (target_freq * 2)
     */
    target_freq = 10;
    divisor = (freq + (target_freq * 2 - 1)) / (target_freq * 2);
    divisor = soc_property_get(unit, spn_RATE_INT_MDIO_DIVISOR, divisor);
    dividend = soc_property_get(unit, spn_RATE_INT_MDIO_DIVIDEND, 1);
    rval = 0;
    soc_reg_field_set (unit, CMIC_RATE_ADJUST_INT_MDIOr, &rval, DIVISORf,
                       divisor);
    soc_reg_field_set (unit, CMIC_RATE_ADJUST_INT_MDIOr, &rval, DIVIDENDf,
                       dividend);
    /* coverity[result_independent_of_operands] */
    SOC_IF_ERROR_RETURN(WRITE_CMIC_RATE_ADJUST_INT_MDIOr(unit, rval));

    delay = soc_property_get(unit, spn_MDIO_OUTPUT_DELAY, -1);
    if (delay >= 1  && delay <= 15) {
        SOC_IF_ERROR_RETURN(READ_CMIC_MIIM_CONFIGr(unit, &rval));
        soc_reg_field_set(unit, CMIC_MIIM_CONFIGr, &rval, MDIO_OUT_DELAYf,
                          delay);
        SOC_IF_ERROR_RETURN(WRITE_CMIC_MIIM_CONFIGr(unit, rval));
    }

    /* Directed Mirroring ON by default */
    PBMP_ALL_ITER(unit, port) {
        SOC_IF_ERROR_RETURN(READ_EGR_PORT_64r(unit, port, &reg64));
        soc_reg64_field32_set(unit, EGR_PORT_64r,
                              &reg64, EM_SRCMOD_CHANGEf, 1);
        SOC_IF_ERROR_RETURN(WRITE_EGR_PORT_64r(unit, port, reg64));
        SOC_IF_ERROR_RETURN(READ_IEGR_PORT_64r(unit, port, &reg64));
        soc_reg64_field32_set(unit, IEGR_PORT_64r,
                              &reg64, EM_SRCMOD_CHANGEf, 1);
        SOC_IF_ERROR_RETURN(WRITE_IEGR_PORT_64r(unit, port, reg64));
    }

    /* Attach serdes firmware set function */
    _phy_tsce_firmware_set_helper[unit] = _soc_greyhound2_tscx_firmware_set;
    _phy_tscf_firmware_set_helper[unit] = _soc_greyhound2_tscx_firmware_set;
    _phy_qtce_firmware_set_helper[unit] = _soc_greyhound2_tscx_firmware_set;

#ifdef INCLUDE_AVS
    soc_hr3_avs_init(unit);
#endif /* INCLUDE_AVS  */


    /* Major for L3_IIFm.TRUST_DSCP_PTRf init */
    SOC_IF_ERROR_RETURN(_soc_hr3_l3iif_hw_mem_init(unit, TRUE));

    /* Select flow type to not eligible for cut-through */
    flow_type = soc_property_get(unit, spn_FLOW_TYPE_FOR_CUT_THROUGH_CONTROL,
                                 GH2_FLOW_TYPE_SR);
    SOC_IF_ERROR_RETURN(READ_CUT_THROUGH_PRIORITYr(unit, &rval));
    if (flow_type == GH2_FLOW_TYPE_TSN) {
        soc_reg_field_set(unit, CUT_THROUGH_PRIORITYr, &rval, CT_PRIORITYf, 1);
    } else {
        /* Default select SR flow type */
        soc_reg_field_set(unit, CUT_THROUGH_PRIORITYr, &rval, CT_PRIORITYf, 0);
    }
    SOC_IF_ERROR_RETURN(WRITE_CUT_THROUGH_PRIORITYr(unit, rval));

    /* Write default value of EGR_EDB_XMIT_CTRLm for preemption */
    SOC_IF_ERROR_RETURN(
        soc_mem_clear(unit, EGR_EDB_XMIT_CTRLm, COPYNO_ALL, TRUE));

    /* Write default value of GE[0~7]_MIN_FRAG_SIZEr for preemption on A0 */
    {
        uint16  dev_id;
        uint8   rev_id;

        soc_cm_get_id(unit, &dev_id, &rev_id);
        if (BCM56170_A0_REV_ID == rev_id || BCM56172_A0_REV_ID == rev_id
            || BCM56174_A0_REV_ID == rev_id || BCM53570_A0_REV_ID == rev_id
            || BCM53575_A0_REV_ID == rev_id
        ) {
            int     reg_index;
            soc_reg_t reg[8] = {GE0_MIN_FRAG_SIZEr,
                                GE1_MIN_FRAG_SIZEr,
                                GE2_MIN_FRAG_SIZEr,
                                GE3_MIN_FRAG_SIZEr,
                                GE4_MIN_FRAG_SIZEr,
                                GE5_MIN_FRAG_SIZEr,
                                GE6_MIN_FRAG_SIZEr,
                                GE7_MIN_FRAG_SIZEr};

            for (reg_index = 0; reg_index < 8; reg_index++) {
                rval = 0;
                soc_reg_field_set(unit, reg[reg_index], &rval,
                                  FINAL_FRAGf, 0x8);
                soc_reg_field_set(unit, reg[reg_index], &rval,
                                  NON_FINAL_FRAGf, 0x8);
                SOC_IF_ERROR_RETURN(
                    soc_reg_write_all_blocks(unit, reg[reg_index], rval));
            }
        }
    }

    /* LEDuP init */
    /* Add board properity which can be used in rc.soc */
    board_name = soc_property_get_str(unit, spn_BOARD_NAME);

    if (board_name) {
        if (soc_mem_config_set == NULL) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                 (BSL_META_U(unit, "unit %d : soc_mem_config_set() is NULL\n"),
                  unit));
            return SOC_E_MEMORY;
        } else {
            if (sal_strcmp(board_name, "BCM956174R") == 0) {
                soc_mem_config_set("bcm956174r", "1");
                SOC_IF_ERROR_RETURN(soc_greyhound2_ledupr_init(unit));
            } else {
                if (sal_strcmp(board_name, "BCM956170R") == 0) {
                    soc_mem_config_set("bcm956170r", "1");
                }
                SOC_IF_ERROR_RETURN(soc_greyhound2_ledup_init(unit));
            }
        }
    } else {
        SOC_IF_ERROR_RETURN(soc_greyhound2_ledup_init(unit));
    }

    /*
     * Clear CMIC_CMCx_CHy_RXBUF_THRESHOLD_CONFIG.ENABLE to not reset MMU
     * COS weighting count.
     */
    for (i = 0; i < 4; i++) {
        rval = soc_pci_read(
                   unit,
                   CMIC_CMCx_CHy_RXBUF_THRESHOLD_CONFIG(SOC_PCI_CMC(unit), i));
        rval &= ~0x100; /* Bit 8 ENABLEf = 0 */
        soc_pci_write(
            unit, CMIC_CMCx_CHy_RXBUF_THRESHOLD_CONFIG(SOC_PCI_CMC(unit), i),
            rval);
    }

    return SOC_E_NONE;
}

/* soc_greyhound2_mem_config:
 * Over-ride the default table sizes (from regsfile) for any SKUs here
 */
int
soc_greyhound2_mem_config(int unit, int dev_id)
{
    int rv = SOC_E_NONE;
    soc_persist_t *sop = SOC_PERSIST(unit);
    uint16 dev = 0;
    uint8 rev = 0;

    SOC_CONTROL(unit)->l3_defip_max_tcams = 2;
    SOC_CONTROL(unit)->l3_defip_tcam_size = 512; /* or 64 per OTP */

    if (SAL_BOOT_QUICKTURN) {
        soc_cm_get_id(unit, &dev, &rev);

        /* QuickTurn with limited table entries */
        sop->memState[L2_USER_ENTRYm].index_max = 11;
        sop->memState[L2_USER_ENTRY_ONLYm].index_max = 11;
        sop->memState[VFP_TCAMm].index_max = 63;
        sop->memState[EFP_TCAMm].index_max = 63;
        sop->memState[FP_TCAMm].index_max = 63;
        sop->memState[VLAN_SUBNETm].index_max = 11;
        sop->memState[VLAN_SUBNET_ONLYm].index_max = 11;
        sop->memState[FP_GLOBAL_MASK_TCAMm].index_max = 63;
        sop->memState[CPU_COS_MAPm].index_max = 11;
        sop->memState[CPU_COS_MAP_ONLYm].index_max = 11;
        sop->memState[L3_DEFIPm].index_max = 63;
        sop->memState[L3_DEFIP_ONLYm].index_max = 63;

        if (rev == BCM56170_B0_REV_ID) {
            sop->memState[MY_STATION_TCAMm].index_max = 1;
            sop->memState[MY_STATION_TCAM_ENTRY_ONLYm].index_max = 1;
            sop->memState[MY_STATION_TCAM_DATA_ONLYm].index_max = 1;
        } else {
            sop->memState[MY_STATION_TCAMm].index_max = 63;
        }
    }
    return rv;
}

/*
 * Function:
 *  _soc_greyhound2_gpio_set
 * Purpose:
 *  Write value to the specified GPIO pin
 */
STATIC int
_soc_greyhound2_gpio_set(int unit, int pin, int output, int val)
{
    uint32 rval = 0;
    uint32 fval = 0;
    uint8 mask = 0xFF;

    mask &= ~(1 << pin);

    /* coverity[result_independent_of_operands] */
    SOC_IF_ERROR_RETURN(READ_CMIC_GP_OUT_ENr(unit, &rval));
    fval = soc_reg_field_get(unit, CMIC_GP_OUT_ENr, rval, OUT_ENABLEf);
    if (output) {
        fval |= 1 << pin;
    } else {
        fval &= ~(1 << pin);
    }
    soc_reg_field_set(unit, CMIC_GP_OUT_ENr, &rval, OUT_ENABLEf, fval);
    /* coverity[result_independent_of_operands] */
    SOC_IF_ERROR_RETURN(WRITE_CMIC_GP_OUT_ENr(unit, rval));

    if (output) {
        /* coverity[result_independent_of_operands] */
        SOC_IF_ERROR_RETURN(READ_CMIC_GP_DATA_OUTr(unit, &rval));
        fval = soc_reg_field_get(unit, CMIC_GP_DATA_OUTr, rval, DATA_OUTf);
        if (val) {
            fval |= (val << pin);
        } else {
            fval &= ~(1 << pin);
        }

        soc_reg_field_set(unit, CMIC_GP_DATA_OUTr, &rval, DATA_OUTf, fval);
        /* coverity[result_independent_of_operands] */
        SOC_IF_ERROR_RETURN(WRITE_CMIC_GP_DATA_OUTr(unit, rval));
    }

    return SOC_E_NONE;
}

/*
 * Function:
 *  soc_greyhound2_serdes_disabled
 * Purpose:
 *  Get the disabled serdes core from strap status register
 */
STATIC int
soc_greyhound2_serdes_disabled(int unit,
                               uint32 *disabled_tsc,
                               uint32 *disabled_qtc)
{
    uint32 strap_sts_1 = 0;
    int power_off = 0;
    int i = 0;
    soc_field_t qtc_fields[] = {
        STRAP_TSCQ0_PWR_OFFf,
        STRAP_TSCQ1_PWR_OFFf,
        INVALIDf
    };
    soc_field_t tsc_fields[] = {
        STRAP_TSCE0_PWR_OFFf,
        STRAP_TSCE1_PWR_OFFf,
        STRAP_TSCE2_PWR_OFFf,
        STRAP_TSCE3_PWR_OFFf,
        STRAP_TSCE4_PWR_OFFf,
        STRAP_TSCE5_PWR_OFFf,
        STRAP_TSCE6_PWR_OFFf,
        STRAP_TSCF0_PWR_OFFf,
        INVALIDf
    };

    /* parameter validation */
    if ((disabled_tsc == NULL) || (disabled_qtc == NULL)) {
        return SOC_E_PARAM;
    }

    /*
     * For simulation, starp status register is empty.
     * Return all QTC and TSC not disabled.
     */
    if  (SAL_BOOT_SIMULATION) {
        *disabled_tsc = 0;
        *disabled_qtc = 0;
        return SOC_E_NONE;
    } else {
        if (soc_feature(unit, soc_feature_untethered_otp)) {
            /* read OTP information */
            /* qtc */
            for (i = 0; i < 2; i++) {
                if (SHR_BITGET(SOC_BOND_INFO(unit)->tsc_disabled, i)) {
                    *disabled_qtc |= (1 << i);
                }
            }
            /* tsc */
            for (i = 0; i < 8; i++) {
                if (SHR_BITGET(SOC_BOND_INFO(unit)->tsc_disabled, 2 + i)) {
                    *disabled_tsc |= (1 << i);
                }
            }
        } else {
            *disabled_tsc = 0;
            *disabled_qtc = 0;
        }
    }

    SOC_IF_ERROR_RETURN(READ_TOP_STRAP_STATUS_1r(unit, &strap_sts_1));

    /* Get the disabled QTC cores */
    i = 0;
    while (qtc_fields[i] != INVALIDf) {
        power_off = soc_reg_field_get(unit, TOP_STRAP_STATUS_1r,
                                      strap_sts_1, qtc_fields[i]);
        if (power_off) {
            *disabled_qtc |= (1 << i);
        }
        i++;
    };

    /* Get the disabled TSC cores */
    i = 0;
    while (tsc_fields[i] != INVALIDf) {
        power_off = soc_reg_field_get(unit, TOP_STRAP_STATUS_1r,
                                      strap_sts_1, tsc_fields[i]);
        if (power_off) {
            *disabled_tsc |= (1 << i);
        }
        i++;
    };

    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,"%s: disabled QTC(0x%x), "
                            "disabled TSC(0x%x)\n"),
                 FUNCTION_NAME(), *disabled_qtc, *disabled_tsc));

    return SOC_E_NONE;
}

/*
 * Function:
 *      _soc_greyhound2_core_disable
 * Purpose:
 *      Re-config the port info for the core disabled
 */
STATIC int
_soc_greyhound2_core_disable(int unit, int core_type, uint32 disable_core_bmp)
{
    int i, j, idx, core_count;
    int phy_port, port, blk, num_port;
    soc_info_t *si;
    const int *core_phy_port;
    int mmu_port;

    si = &SOC_INFO(unit);

    switch (core_type) {
        case SOC_GH2_PORT_CORE_TYPE_TSC:
            num_port = _GH2_PORT_COUNT_PER_TSC; /* 4 */
            core_phy_port = &tsc_phy_port[0];
            core_count = _GH2_MAX_TSC_COUNT; /* 8 */
            break;
        case SOC_GH2_PORT_CORE_TYPE_QTC:
            num_port = _GH2_PORT_COUNT_PER_QTC; /* 16 */
            core_phy_port = &qtc_phy_port[0];
            core_count = _GH2_MAX_QTC_COUNT; /* 2 */
            break;
        default:
            return (SOC_E_PARAM);
    }
    for (i = 0; i < core_count; i++) {
        if ((1 << i) & disable_core_bmp){
            for (j = 0; j < num_port; j++) {
                phy_port = core_phy_port[i] + j;
                port = si->port_p2l_mapping[phy_port];
                mmu_port = si->port_p2m_mapping[phy_port];

                si->port_p2l_mapping[phy_port] = -1;
                /*
                 * port_p2m_mapping value 127 for non-enabled port program in
                 * MMU_ARB_TDM_TABLE.PORT_NUMf
                 */
                si->port_p2m_mapping[phy_port] = 127;
                si->max_port_p2m_mapping[phy_port] = -1;

                /* skip native unmapped mmu ports */
                if (mmu_port != -1) {
                    si->port_m2p_mapping[mmu_port] = -1;
                }

                /* skip native unmapped logical ports */
                if (port != -1) {
                    for (idx = 0; idx < SOC_DRIVER(unit)->port_num_blktype; idx++) {
                        blk = SOC_PORT_IDX_BLOCK(unit, phy_port, idx);
                        if (blk < 0) { /* end of block list of each port */
                            break;
                        }
                        if(si->block_port[blk] == port){
                            si->block_port[blk] = -1;
                        }
                        si->block_valid[blk] = 0;
                        SOC_PBMP_PORT_REMOVE(si->block_bitmap[blk], port);
                    }

                    si->port_l2p_mapping[port] = -1;
                    SOC_PBMP_PORT_REMOVE(si->ether.bitmap, port);
                    SOC_PBMP_PORT_REMOVE(si->ge.bitmap, port);
                    SOC_PBMP_PORT_REMOVE(si->xe.bitmap, port);
                    SOC_PBMP_PORT_REMOVE(si->hg.bitmap, port);
                    SOC_PBMP_PORT_REMOVE(si->st.bitmap, port);
                    SOC_PBMP_PORT_REMOVE(si->xl.bitmap, port);
                    SOC_PBMP_PORT_REMOVE(si->cl.bitmap, port);
                    SOC_PBMP_PORT_REMOVE(si->all.bitmap, port);
                    SOC_PBMP_PORT_REMOVE(si->port.bitmap, port);
                    sal_snprintf(si->port_name[port],
                                 sizeof(si->port_name[port]),
                                 "?%d", port);
                    si->port_offset[port] = port;
                }
            }
        }
    }

#define RECONFIG_PORT_INFO(ptype,str) \
    si->ptype.num = 0; \
    si->ptype.min = si->ptype.max = -1; \
    PBMP_ITER(si->ptype.bitmap, port) { \
        if (sal_strcmp(str,"")) {\
            sal_snprintf(si->port_name[port], sizeof(si->port_name[port]),\
            "%s%d", str, si->ptype.num);\
        }\
        si->ptype.port[si->ptype.num++] = port; \
        if (si->ptype.min < 0) { \
            si->ptype.min = port; \
        } \
        if (port > si->ptype.max) { \
            si->ptype.max = port; \
        } \
    }

    /* coverity[pointless_string_compare] */
    RECONFIG_PORT_INFO(ether,"");
    /* coverity[pointless_string_compare] */
    RECONFIG_PORT_INFO(st,"");
    RECONFIG_PORT_INFO(hg,"hg");
    RECONFIG_PORT_INFO(xe,"xe");
    RECONFIG_PORT_INFO(ge,"ge");
#undef RECONFIG_PORT_INFO

    return SOC_E_NONE;
}

#define TOP_STRAP_STATUS_LCPLL1_REFCLK_SEL(val)    \
    (((val) >> 9) & 0x1)

#define TOP_STRAP_STATUS_XTAL_FREQ_SEL_B0(val)    \
    (((val) >> 25) & 0x1)

#define TOP_STRAP_STATUS_XTAL_FREQ_SEL_A0(val)    \
    (((val) >> 26) & 0x1)
/*
 * Function:
 *      soc_greyhound2_chip_reset
 * Purpose:
 *      Special reset sequencing for BCM53570
 */
int
soc_greyhound2_chip_reset(int unit)
{
    uint32 rval, to_usec;
    _gh2_option_info_t *matched_opt_info;
    uint32 disabled_bmp;
    uint32 disabled_tsc = 0;
    uint32 disabled_qtc = 0;
    int i;
    soc_info_t *si;
    uint16 dev_id;
    uint8  rev_id;
    uint32 core_pll_ndiv;
    uint32 core_pll_ch0;
    uint32 core_pll_ch1;
    uint32 core_pll_ch2;
    uint32 core_pll_ch3;
    unsigned ext_clk_lcpll0, ext_clk_lcpll1, ext_phy_clk_fref_lcpll0;
    uint32 lcpll1_i_refclk_sel, lcpll_xtal_freq_sel;
    uint32 strap_sts=0;
    char cfg_str[20];

    unsigned ts_ref_freq;
    unsigned ts_idx;
    static const soc_pll_param_t ts_pll[] = {  /* values for 500MHz TSPLL output */
      /*     Fref,  Ndiv_int, Ndiv_frac,  Pdiv, Mdiv, Ka, Ki, Kp, VCO_DIV2 */
        {25000000,       100,          0,     1,    5,  0,  2,  3,        1},
        {50000000,        50,          0,     1,    5,  0,  2,  3,        1},
        {       0,       100,          0,     1,    5,  0,  2,  3,        1},  /* 25MHz, from internal reference */
        {       0,        50,          0,     1,    5,  0,  2,  3,        1}   /* 50MHz, from internal reference */
        /* 0 => 25MHz or 50Mhz from internal reference based on strap_xtal_freq_sel */
    };
    unsigned bs_ref_freq;
    unsigned bs_idx;
    uint32 bs0_ndiv_high, bs0_ndiv_low;
    uint32 bs1_ndiv_high, bs1_ndiv_low;

    /* For performance reasons, use different settings for BSPLL0 and BSPLL1 */
    static const soc_pll_param_t bs0_pll[] = {  /* values for 20MHz BSPLL output */
      /*     Fref,  Ndiv_int,  Ndiv_frac,  Pdiv, Mdiv, Ka, Ki, Kp, VCO_FB_DIV2 */
        {25000000,        60,          0,     1,  150,  4,  1,  8,        1},
        {50000000,        60,          0,     1,  150,  4,  1,  8,        1},
        {       0,        60 ,         0,     1,  150,  4,  1,  8,        1},  /* 25MHz, from internal reference */
        {       0,        60,          0,     1,  150,  4,  1,  8,        1}   /* 50MHz, from internal reference */
        /* 0 => 25MHz or 50Mhz from internal reference based on strap_xtal_freq_sel */
    };
    static const soc_pll_param_t bs1_pll[] = {  /* values for 20MHz BSPLL output */
      /*     Fref,  Ndiv_int,  Ndiv_frac,  Pdiv, Mdiv, Ka, Ki, Kp, VCO_FB_DIV2 */
        {25000000,         60,         0,     1,  150,  4,  1,  8,        1},
        {50000000,         60,         0,     1,  150,  4,  1,  8,        1},
        {       0,         60,         0,     1,  150,  4,  1,  8,        1},  /* 25MHz, from internal reference */
        {       0,         60,         0,     1,  150,  4,  1,  8,        1}   /* 50MHz, from internal reference */
        /* 0 => 25MHz or 50Mhz from internal reference based on strap_xtal_freq_sel */
    };

    /* Parameters for BSPLL particular to GH2.  Same indexing as above */
    static const unsigned bs_cp1[] = {3, 3, 3, 3};
    static const unsigned bs_cp[] = {1, 1, 1, 1};
    static const unsigned bs_cz[] = {3, 3, 3, 3};
    static const unsigned bs_rp[] = {1, 1, 1, 1};
    static const unsigned bs_rz[] = {1, 1, 1, 1};
    static const unsigned bs_icp[] = {42, 42, 42, 42};

    /* MSPI init */
    if (soc_mspi_init(unit) != SOC_E_NONE) {
        LOG_WARN(BSL_LS_SOC_COMMON,
                 (BSL_META_U(unit,
                             "unit %d : MSPI Init Failed\n"), unit));
    }

    soc_cm_get_id(unit, &dev_id, &rev_id);

    to_usec = SAL_BOOT_QUICKTURN ? (250 * MILLISECOND_USEC) :
                                   (10 * MILLISECOND_USEC);

    WRITE_CMIC_SBUS_RING_MAP_0_7r(unit, 0x11110100); /* block 7  - 0 */
    if (rev_id == BCM56170_B0_REV_ID) {
        WRITE_CMIC_SBUS_RING_MAP_8_15r(unit, 0x00430070); /* block 15 - 8 */
    } else {
        WRITE_CMIC_SBUS_RING_MAP_8_15r(unit, 0x00430000); /* block 15 - 8 */
    }
    WRITE_CMIC_SBUS_RING_MAP_16_23r(unit, 0x00005064); /* block 23 - 16 */
    WRITE_CMIC_SBUS_RING_MAP_24_31r(unit, 0x02220111); /* block 31 - 24 */
    WRITE_CMIC_SBUS_RING_MAP_32_39r(unit, 0x02220222); /* block 39 - 32 */
    WRITE_CMIC_SBUS_RING_MAP_40_47r(unit, 0x22222222); /* block 40 - 47 */
    WRITE_CMIC_SBUS_TIMEOUTr(unit, 0x7d0);

    sal_usleep(to_usec);


    /* core clock PLL setting */
    si = &SOC_INFO(unit);
    switch (si->frequency) {
        case _GH2_SYSTEM_FREQ_125:
            core_pll_ndiv = 140;
            core_pll_ch0 = 28;
            core_pll_ch1 = 28;
            core_pll_ch2 = 14;
            core_pll_ch3 = 7;
            break;
        case _GH2_SYSTEM_FREQ_375:
            core_pll_ndiv = 120;
            core_pll_ch0 = 8;
            core_pll_ch1 = 24;
            core_pll_ch2 = 12;
            core_pll_ch3 = 6;
            break;
        case _GH2_SYSTEM_FREQ_389:
            core_pll_ndiv = 140;
            core_pll_ch0 = 9;
            core_pll_ch1 = 28;
            core_pll_ch2 = 14;
            core_pll_ch3 = 7;
            break;
        case _GH2_SYSTEM_FREQ_392:
            core_pll_ndiv = 110;
            core_pll_ch0 = 7;
            core_pll_ch1 = 22;
            core_pll_ch2 = 11;
            core_pll_ch3 = 6;
            break;
        case _GH2_SYSTEM_FREQ_437:
            core_pll_ndiv = 140;
            core_pll_ch0 = 8;
            core_pll_ch1 = 28;
            core_pll_ch2 = 14;
            core_pll_ch3 = 7;
            break;
        case _GH2_SYSTEM_FREQ_450:
            core_pll_ndiv = 90;
            core_pll_ch0 = 5;
            core_pll_ch1 = 18;
            core_pll_ch2 = 9;
            core_pll_ch3 = 5;
            break;
        case _GH2_SYSTEM_FREQ_500:
            core_pll_ndiv = 140;
            core_pll_ch0 = 7;
            core_pll_ch1 = 28;
            core_pll_ch2 = 14;
            core_pll_ch3 = 7;
            break;
        case _GH2_SYSTEM_FREQ_583:
        default:
            core_pll_ndiv = 140;
            core_pll_ch0 = 6;
            core_pll_ch1 = 28;
            core_pll_ch2 = 14;
            core_pll_ch3 = 7;
            break;
    }
    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, TOP_CORE_PLL_CTRL3r,
                                 REG_PORT_ANY, MSTR_NDIV_INTf, core_pll_ndiv));
    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, TOP_CORE_PLL_CTRL4r,
                                 REG_PORT_ANY, MSTR_CH0_MDIVf, core_pll_ch0));
    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, TOP_CORE_PLL_CTRL4r,
                                 REG_PORT_ANY, MSTR_CH1_MDIVf, core_pll_ch1));
    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, TOP_CORE_PLL_CTRL5r,
                                 REG_PORT_ANY, MSTR_CH2_MDIVf, core_pll_ch2));
    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, TOP_CORE_PLL_CTRL6r,
                                 REG_PORT_ANY, MSTR_CH3_MDIVf, core_pll_ch3));
    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, TOP_MISC_CONTROL_1r, REG_PORT_ANY,
                                CMIC_TO_CORE_PLL_LOADf, 1));

    /* 250Mhz TS PLL implies 4ns resolution */
    /* TSPLL configuration: 500MHz TS_CLK from 20/25/32/50MHz refclk */
    /* CMICd divides by 2 on input, so this is a 250MHz clock to TS logic */

    ts_ref_freq = soc_property_get(unit, spn_PTP_TS_PLL_FREF, 0);  /* 0->internal reference */

    for (ts_idx = 0; ts_idx < sizeof(ts_pll)/sizeof(ts_pll[0]); ++ts_idx) {
        if (ts_pll[ts_idx].ref_freq == ts_ref_freq) {
            break;
        }
    }

    strap_sts=0;
    SOC_IF_ERROR_RETURN(READ_TOP_STRAP_STATUSr(unit, &strap_sts));
    if (ts_ref_freq == 0) {
        if (rev_id == BCM53570_B0_REV_ID) { 
            ts_idx = (TOP_STRAP_STATUS_XTAL_FREQ_SEL_B0(strap_sts) == 0) ? 2 : 3;
        } else {
            ts_idx = (TOP_STRAP_STATUS_XTAL_FREQ_SEL_A0(strap_sts) == 0) ? 2 : 3;
        }
    }

    if (ts_idx == sizeof(ts_pll)/sizeof(ts_pll[0])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "Invalid value for PTP_TS_PLL_REF (%u).  No default PLL params.\n"), ts_ref_freq));
        /* Could check for existence of SOC properties for VCO_DIV2, KA, KI, KP, NDIV_INT, NDIV_FRAC, MDIV, PDIV, and if
           all exist, use them.  For now, just fail.
        */
    } else {
        SOC_IF_ERROR_RETURN(READ_TOP_TS_PLL_CTRL_0r(unit,&rval));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_0r, &rval, VCO_DIV2f,
                          soc_property_get(unit, spn_PTP_TS_VCO_DIV2, ts_pll[ts_idx].vco_div2));
        WRITE_TOP_TS_PLL_CTRL_0r(unit, rval);

        SOC_IF_ERROR_RETURN(READ_TOP_TS_PLL_CTRL_4r(unit,&rval));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_4r, &rval, KAf,
                          soc_property_get(unit, spn_PTP_TS_KA, ts_pll[ts_idx].ka));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_4r, &rval, KIf,
                          soc_property_get(unit, spn_PTP_TS_KI, ts_pll[ts_idx].ki));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_4r, &rval, KPf,
                          soc_property_get(unit, spn_PTP_TS_KP, ts_pll[ts_idx].kp));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_4r, &rval, FREF_SELf,
                          ts_ref_freq ? 1 : 0);
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_4r, &rval, REFCLK_SELf,
                          ts_ref_freq ? 1 : 0);
        WRITE_TOP_TS_PLL_CTRL_4r(unit, rval);

        SOC_IF_ERROR_RETURN(READ_TOP_TS_PLL_CTRL_3r(unit,&rval));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_3r, &rval, NDIV_INTf,
                          soc_property_get(unit, spn_PTP_TS_PLL_N, ts_pll[ts_idx].ndiv_int));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_3r, &rval, NDIV_FRACf,
                          ts_pll[ts_idx].ndiv_frac);
        WRITE_TOP_TS_PLL_CTRL_3r(unit, rval);

        SOC_IF_ERROR_RETURN(READ_TOP_TS_PLL_CTRL_2r(unit,&rval));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_2r, &rval, PDIVf,
                          soc_property_get(unit, spn_PTP_TS_PLL_PDIV, ts_pll[ts_idx].pdiv));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_2r, &rval, CH0_MDIVf,
                          soc_property_get(unit, spn_PTP_TS_PLL_MNDIV, ts_pll[ts_idx].mdiv));
        WRITE_TOP_TS_PLL_CTRL_2r(unit, rval);

        /* Enable software overwrite of TimeSync PLL settings. */
        SOC_IF_ERROR_RETURN(READ_TOP_MISC_CONTROL_1r(unit, &rval));
        soc_reg_field_set(unit, TOP_MISC_CONTROL_1r, &rval, CMIC_TO_TS_PLL_LOADf, 1);
        WRITE_TOP_MISC_CONTROL_1r(unit, rval);
    }

    /* 500Mhz TSPLL -> 250MHz ref at timestamper, implies 4ns resolution */
    /* clock period in nanoseconds */
    SOC_TIMESYNC_PLL_CLOCK_NS(unit) = (1/250 * 1000);

    if (!soc_feature(unit, soc_feature_time_v3_no_bs)) {
        /* as a signal to upper-level code that the BroadSync is newly initialized
         * disable BroadSync0/1 bitclock output.  Checked in time.c / 1588 firmware    */
        /* coverity[result_independent_of_operands] */
        SOC_IF_ERROR_RETURN(READ_CMIC_BS0_CONFIGr(unit, &rval));
        soc_reg_field_set(unit, CMIC_BS0_CONFIGr, &rval, BS_CLK_OUTPUT_ENABLEf, 0);
        WRITE_CMIC_BS0_CONFIGr(unit, rval);

        /* coverity[result_independent_of_operands] */
        SOC_IF_ERROR_RETURN(READ_CMIC_BS1_CONFIGr(unit, &rval));
        soc_reg_field_set(unit, CMIC_BS1_CONFIGr, &rval, BS_CLK_OUTPUT_ENABLEf, 0);
        WRITE_CMIC_BS1_CONFIGr(unit, rval);

        /* BSPLL0 has not been configured, so reset/configure both BSPLL0 and BSPLL1 */
        SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REG_2r(unit, &rval));
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_BS_PLL0_RST_Lf, 0);
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_BS_PLL1_RST_Lf, 0);
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_BS_PLL0_POST_RST_Lf, 0);
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_BS_PLL1_POST_RST_Lf, 0);
        WRITE_TOP_SOFT_RESET_REG_2r(unit, rval);

        /* Different BSPLL configurations, but with same Fref */

        bs_ref_freq = soc_property_get(unit, spn_PTP_BS_FREF, 0);  /* 0->internal reference */

        for (bs_idx = 0; bs_idx < sizeof(bs0_pll)/sizeof(bs0_pll[0]); ++bs_idx) {
            if (bs0_pll[bs_idx].ref_freq == bs_ref_freq) {
                break;
            }
        }

        if (bs_ref_freq == 0) {
            if (rev_id == BCM53570_B0_REV_ID) {
                ts_idx = (TOP_STRAP_STATUS_XTAL_FREQ_SEL_B0(strap_sts) == 0) ? 2 : 3;
            } else {
                ts_idx = (TOP_STRAP_STATUS_XTAL_FREQ_SEL_A0(strap_sts) == 0) ? 2 : 3;
            }
        }

        if (bs_idx == sizeof(bs0_pll)/sizeof(bs0_pll[0])) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Invalid value for PTP_BS_REF (%u).  No default PLL params.\n"), bs_ref_freq));
            /* Could check for existence of SOC properties for VCO_DIV2, KA, KI, KP, NDIV_INT,
               NDIV_FRAC, MDIV, PDIV, and if all exist, use them.  For now, just fail.
            */
        } else {
            /* BSPLL0 */
            /* Program MSC_CTRL=0x24 for External ref as confirmed by Henry */
            SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL0_CTRL_6r(unit,&rval));
            soc_reg_field_set(unit, TOP_BS_PLL0_CTRL_6r, &rval, MSC_CTRLf,
                           bs_ref_freq ? 0x24 : 0x20);
            WRITE_TOP_BS_PLL0_CTRL_6r(unit, rval);

            SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL0_CTRL_1r(unit,&rval));
            soc_reg_field_set(unit, TOP_BS_PLL0_CTRL_1r, &rval, PDIVf,
                              soc_property_get(unit, spn_PTP_BS_PDIV, bs0_pll[bs_idx].pdiv));
            WRITE_TOP_BS_PLL0_CTRL_1r(unit, rval);

            bs0_ndiv_high = ((soc_property_get(unit, spn_PTP_BS_NDIV_INT, bs0_pll[bs_idx].ndiv_int) << 6) |
                            ((soc_property_get(unit, spn_PTP_BS_NDIV_FRAC, bs0_pll[bs_idx].ndiv_frac) >> 26) & 0x3f));
            bs0_ndiv_low = ((soc_property_get(unit, spn_PTP_BS_NDIV_FRAC, bs0_pll[bs_idx].ndiv_frac) << 6) & 0xffffc000);

            SOC_IF_ERROR_RETURN(READ_TOP_BROAD_SYNC0_LCPLL_FBDIV_CTRL_0r(unit,&rval));
            soc_reg_field_set(unit, TOP_BROAD_SYNC0_LCPLL_FBDIV_CTRL_0r, &rval, BROAD_SYNC0_LCPLL_FBDIV_0f, bs0_ndiv_low);
            WRITE_TOP_BROAD_SYNC0_LCPLL_FBDIV_CTRL_0r(unit, rval);

            SOC_IF_ERROR_RETURN(READ_TOP_BROAD_SYNC0_LCPLL_FBDIV_CTRL_1r(unit,&rval));
            soc_reg_field_set(unit, TOP_BROAD_SYNC0_LCPLL_FBDIV_CTRL_1r, &rval, BROAD_SYNC0_LCPLL_FBDIV_1f, bs0_ndiv_high);
            WRITE_TOP_BROAD_SYNC0_LCPLL_FBDIV_CTRL_1r(unit, rval);

            SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL0_CTRL_0r(unit,&rval));
            soc_reg_field_set(unit, TOP_BS_PLL0_CTRL_0r, &rval, CH0_MDIVf,
                              soc_property_get(unit, spn_PTP_BS_MNDIV, bs0_pll[bs_idx].mdiv));
            WRITE_TOP_BS_PLL0_CTRL_0r(unit, rval);


            SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL0_CTRL_5r(unit,&rval));
            soc_reg_field_set(unit, TOP_BS_PLL0_CTRL_5r, &rval, CP1f, bs_cp1[bs_idx]);
            soc_reg_field_set(unit, TOP_BS_PLL0_CTRL_5r, &rval, CPf,  bs_cp[bs_idx]);
            soc_reg_field_set(unit, TOP_BS_PLL0_CTRL_5r, &rval, CZf,  bs_cz[bs_idx]);
            soc_reg_field_set(unit, TOP_BS_PLL0_CTRL_5r, &rval, RPf,  bs_rp[bs_idx]);
            soc_reg_field_set(unit, TOP_BS_PLL0_CTRL_5r, &rval, RZf,  bs_rz[bs_idx]);
            soc_reg_field_set(unit, TOP_BS_PLL0_CTRL_5r, &rval, ICPf, bs_icp[bs_idx]);
            WRITE_TOP_BS_PLL0_CTRL_5r(unit, rval);


            /* BSPLL1 */
            /* Program MSC_CTRL=0x24 for external ref */
            SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL1_CTRL_6r(unit,&rval));
            soc_reg_field_set(unit, TOP_BS_PLL1_CTRL_6r, &rval, MSC_CTRLf,
                           bs_ref_freq ? 0x24 : 0x20);
            WRITE_TOP_BS_PLL1_CTRL_6r(unit, rval);

            SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL1_CTRL_1r(unit,&rval));
            soc_reg_field_set(unit, TOP_BS_PLL1_CTRL_1r, &rval, PDIVf,
                              soc_property_get(unit, spn_PTP_BS_PDIV, bs1_pll[bs_idx].pdiv));
            WRITE_TOP_BS_PLL1_CTRL_1r(unit, rval);

            bs1_ndiv_high = ((soc_property_get(unit, spn_PTP_BS_NDIV_INT, bs1_pll[bs_idx].ndiv_int) << 6) |
                            ((soc_property_get(unit, spn_PTP_BS_NDIV_FRAC, bs1_pll[bs_idx].ndiv_frac) >> 26) & 0x3f));
            bs1_ndiv_low = ((soc_property_get(unit, spn_PTP_BS_NDIV_FRAC, bs1_pll[bs_idx].ndiv_frac) << 6) & 0xffffc000);

            SOC_IF_ERROR_RETURN(READ_TOP_BROAD_SYNC1_LCPLL_FBDIV_CTRL_0r(unit,&rval));
            soc_reg_field_set(unit, TOP_BROAD_SYNC1_LCPLL_FBDIV_CTRL_0r, &rval, BROAD_SYNC1_LCPLL_FBDIV_0f, bs1_ndiv_low);
            WRITE_TOP_BROAD_SYNC1_LCPLL_FBDIV_CTRL_0r(unit, rval);

            SOC_IF_ERROR_RETURN(READ_TOP_BROAD_SYNC1_LCPLL_FBDIV_CTRL_1r(unit,&rval));
            soc_reg_field_set(unit, TOP_BROAD_SYNC1_LCPLL_FBDIV_CTRL_1r, &rval, BROAD_SYNC1_LCPLL_FBDIV_1f, bs1_ndiv_high);
            WRITE_TOP_BROAD_SYNC1_LCPLL_FBDIV_CTRL_1r(unit, rval);

            SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL1_CTRL_0r(unit,&rval));
            soc_reg_field_set(unit, TOP_BS_PLL1_CTRL_0r, &rval, CH0_MDIVf,
                              soc_property_get(unit, spn_PTP_BS_MNDIV, bs1_pll[bs_idx].mdiv));
            WRITE_TOP_BS_PLL1_CTRL_0r(unit, rval);


            SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL1_CTRL_5r(unit,&rval));
            soc_reg_field_set(unit, TOP_BS_PLL1_CTRL_5r, &rval, CP1f, bs_cp1[bs_idx]);
            soc_reg_field_set(unit, TOP_BS_PLL1_CTRL_5r, &rval, CPf,  bs_cp[bs_idx]);
            soc_reg_field_set(unit, TOP_BS_PLL1_CTRL_5r, &rval, CZf,  bs_cz[bs_idx]);
            soc_reg_field_set(unit, TOP_BS_PLL1_CTRL_5r, &rval, RPf,  bs_rp[bs_idx]);
            soc_reg_field_set(unit, TOP_BS_PLL1_CTRL_5r, &rval, RZf,  bs_rz[bs_idx]);
            soc_reg_field_set(unit, TOP_BS_PLL1_CTRL_5r, &rval, ICPf, bs_icp[bs_idx]);
            WRITE_TOP_BS_PLL1_CTRL_5r(unit, rval);

            /*
             * Set frequency doubler based on reference clock.
             * Greyhound2 supports 25MHz/50MHz reference clocks.
             * LCPLL frequency doubler Boolean in PLL control
             * register 7 scales 25MHz so effective reference
             * frequency equals 50MHz.
             */
            strap_sts=0;
            SOC_IF_ERROR_RETURN(READ_TOP_STRAP_STATUSr(unit, &strap_sts));
            if (rev_id == BCM53570_B0_REV_ID) {
                lcpll_xtal_freq_sel = TOP_STRAP_STATUS_XTAL_FREQ_SEL_B0(strap_sts);
            } else {
                lcpll_xtal_freq_sel = TOP_STRAP_STATUS_XTAL_FREQ_SEL_A0(strap_sts);
            }

            if (50000000 == bs_ref_freq || lcpll_xtal_freq_sel ) { /* STRAP_XTAL_FREQ_SEL */
                SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL0_CTRL_7r(unit, &rval));
                soc_reg_field_set(unit, TOP_BS_PLL0_CTRL_7r, &rval, FREQ_DOUBLER_ONf, 0);
                WRITE_TOP_BS_PLL0_CTRL_7r(unit, rval);

                SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL1_CTRL_7r(unit, &rval));
                soc_reg_field_set(unit, TOP_BS_PLL1_CTRL_7r, &rval, FREQ_DOUBLER_ONf, 0);
                WRITE_TOP_BS_PLL1_CTRL_7r(unit, rval);
            } else {
                SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL0_CTRL_7r(unit, &rval));
                soc_reg_field_set(unit, TOP_BS_PLL0_CTRL_7r, &rval, FREQ_DOUBLER_ONf, 1);
                WRITE_TOP_BS_PLL0_CTRL_7r(unit, rval);

                SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL1_CTRL_7r(unit, &rval));
                soc_reg_field_set(unit, TOP_BS_PLL1_CTRL_7r, &rval, FREQ_DOUBLER_ONf, 1);
                WRITE_TOP_BS_PLL1_CTRL_7r(unit, rval);
            }

            /* Enable software overwrite of BroadSync 0/1 PLL settings. */
            SOC_IF_ERROR_RETURN(READ_TOP_MISC_CONTROL_1r(unit, &rval));
            soc_reg_field_set(unit, TOP_MISC_CONTROL_1r, &rval, CMIC_TO_BS_PLL0_SW_OVWRf, 1);
            soc_reg_field_set(unit, TOP_MISC_CONTROL_1r, &rval, CMIC_TO_BS_PLL1_SW_OVWRf, 1);
            WRITE_TOP_MISC_CONTROL_1r(unit, rval);

            SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL0_CTRL_1r(unit,&rval));
            soc_reg_field_set(unit, TOP_BS_PLL0_CTRL_1r, &rval, LOAD_EN_CHf, 0);
            WRITE_TOP_BS_PLL0_CTRL_1r(unit, rval);
            soc_reg_field_set(unit, TOP_BS_PLL0_CTRL_1r, &rval, LOAD_EN_CHf, 1);
            WRITE_TOP_BS_PLL0_CTRL_1r(unit, rval);

            SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL1_CTRL_1r(unit,&rval));
            soc_reg_field_set(unit, TOP_BS_PLL1_CTRL_1r, &rval, LOAD_EN_CHf, 0);
            WRITE_TOP_BS_PLL1_CTRL_1r(unit, rval);
            soc_reg_field_set(unit, TOP_BS_PLL1_CTRL_1r, &rval, LOAD_EN_CHf, 1);
            WRITE_TOP_BS_PLL1_CTRL_1r(unit, rval);
        }

        SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REG_2r(unit, &rval));
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_BS_PLL0_RST_Lf, 1);
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_BS_PLL1_RST_Lf, 1);
        WRITE_TOP_SOFT_RESET_REG_2r(unit, rval);

        SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REG_2r(unit, &rval));
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_BS_PLL0_POST_RST_Lf, 1);
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_BS_PLL1_POST_RST_Lf, 1);
        WRITE_TOP_SOFT_RESET_REG_2r(unit, rval);

        /* Increas drive stregth */
        SOC_IF_ERROR_RETURN(READ_ICFG_IPROC_IOPAD_CTRL_21r(unit, &rval));
        soc_reg_field_set(unit, ICFG_IPROC_IOPAD_CTRL_21r, &rval,IPROC_BS0_CLK_DRIVEf,0x7);
        soc_reg_field_set(unit, ICFG_IPROC_IOPAD_CTRL_21r, &rval,IPROC_BS0_HB_DRIVEf,0x7);
        soc_reg_field_set(unit, ICFG_IPROC_IOPAD_CTRL_21r, &rval,IPROC_BS0_TC_DRIVEf,0x7);
        soc_reg_field_set(unit, ICFG_IPROC_IOPAD_CTRL_21r, &rval,IPROC_BS0_CLK_HYSf, 0x1);
        WRITE_ICFG_IPROC_IOPAD_CTRL_21r(unit, rval);
        SOC_IF_ERROR_RETURN(READ_ICFG_IPROC_IOPAD_CTRL_20r(unit, &rval));
        soc_reg_field_set(unit, ICFG_IPROC_IOPAD_CTRL_20r, &rval,IPROC_BS1_CLK_DRIVEf,0x7);
        soc_reg_field_set(unit, ICFG_IPROC_IOPAD_CTRL_20r, &rval,IPROC_BS1_HB_DRIVEf,0x7);
        soc_reg_field_set(unit, ICFG_IPROC_IOPAD_CTRL_20r, &rval,IPROC_BS1_TC_DRIVEf,0x7);
        soc_reg_field_set(unit, ICFG_IPROC_IOPAD_CTRL_20r, &rval,IPROC_BS1_CLK_HYSf, 0x1);
        WRITE_ICFG_IPROC_IOPAD_CTRL_20r(unit, rval);
    }

    /*
     * Select LCPLL0 as external PHY reference clock and output 125MHz
     */
    /* Pull GPIO3 low to reset the ext. PHY */
    SOC_IF_ERROR_RETURN(_soc_greyhound2_gpio_set(unit, 3, TRUE, 0));

    /* 0->internal reference; lc_pll_ext_clock */
    ext_clk_lcpll0 = soc_property_get(unit, spn_LC_PLL_EXT_CLOCK, 0);

    /* 0->internal reference; lc_pll_ext_clock.1 */
    sal_sprintf(cfg_str, "%s.%d", spn_LC_PLL_EXT_CLOCK, 1);
    ext_clk_lcpll1 = soc_property_get(unit, cfg_str, 0);
    /* 125Mhz/125000000 */
    ext_phy_clk_fref_lcpll0 = soc_property_get(unit,
                                               spn_EXT_PHY_FREQ_REF_LCPLL0, 0);
    
    strap_sts=0;
    SOC_IF_ERROR_RETURN(READ_TOP_STRAP_STATUSr(unit, &strap_sts));
    
    lcpll1_i_refclk_sel = (TOP_STRAP_STATUS_LCPLL1_REFCLK_SEL(strap_sts) == 1);

    if (rev_id == BCM53570_B0_REV_ID) {
        lcpll_xtal_freq_sel = TOP_STRAP_STATUS_XTAL_FREQ_SEL_B0(strap_sts);
    } else {
        lcpll_xtal_freq_sel = TOP_STRAP_STATUS_XTAL_FREQ_SEL_A0(strap_sts);
    }

    /* Calibrate RATE_MANAGER_MODE */
    SOC_IF_ERROR_RETURN(READ_TOP_XG_PLL0_CTRL_3r(unit, &rval));
    soc_reg_field_set(unit, TOP_XG_PLL0_CTRL_3r, &rval, RATE_MANAGER_MODEf, 0);
    WRITE_TOP_XG_PLL0_CTRL_3r(unit, rval);

    SOC_IF_ERROR_RETURN(READ_TOP_XG_PLL1_CTRL_3r(unit, &rval));
    soc_reg_field_set(unit, TOP_XG_PLL1_CTRL_3r, &rval, RATE_MANAGER_MODEf, 0);
    WRITE_TOP_XG_PLL1_CTRL_3r(unit, rval);

        /* # Put PLL in reset state */
    SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REGr(unit, &rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_LCPLL_SOFT_RESETf, 0x1);
    WRITE_TOP_SOFT_RESET_REGr(unit, rval);

    SOC_IF_ERROR_RETURN(READ_TOP_XG_PLL0_CTRL_3r(unit, &rval));
    soc_reg_field_set(unit, TOP_XG_PLL0_CTRL_3r, &rval, RATE_MANAGER_MODEf, 1);
    WRITE_TOP_XG_PLL0_CTRL_3r(unit, rval);

    SOC_IF_ERROR_RETURN(READ_TOP_XG_PLL1_CTRL_3r(unit, &rval));
    soc_reg_field_set(unit, TOP_XG_PLL1_CTRL_3r, &rval, RATE_MANAGER_MODEf, 1);
    WRITE_TOP_XG_PLL1_CTRL_3r(unit, rval);

    /*
     * Setup LCPLL0
     */
    if (ext_phy_clk_fref_lcpll0 == 125000000) {
        /* Reference clock of 125Mhz is provided by LCPLL0 test p/n */
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, TOP_XG_PLL0_CTRL_6r, REG_PORT_ANY, MSC_CTRLf, 0x71A2));
    } else if (ext_clk_lcpll0) { /*external clk source */
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, TOP_XG_PLL0_CTRL_6r, REG_PORT_ANY, MSC_CTRLf, 0x71A4));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, TOP_XG_PLL0_CTRL_7r, REG_PORT_ANY, FREQ_DOUBLER_ONf, (ext_clk_lcpll0 == 25000000) ? 0x1 : 0x0));
    } else { /*internal clk source */
     /* lcpll_xtal_freq_sel==1 internal 50Mhz */
        SOC_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, TOP_XG_PLL0_CTRL_6r, REG_PORT_ANY, MSC_CTRLf, 0x71A2));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, TOP_XG_PLL0_CTRL_7r, REG_PORT_ANY, FREQ_DOUBLER_ONf, (lcpll_xtal_freq_sel) ? 0x0 : 0x1));
    }
    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, TOP_MISC_CONTROL_1r, REG_PORT_ANY, CMIC_TO_XG_PLL0_SW_OVWRf, 0x1));

/*
Scenario                                         |Clock source       |Refclk Freq |strap_xtal_freq_sel |strap_lcpll1_refclk_sel |soc_property_settings
------------------------------------------------------------------------------------------------------------------------------------------------------
TSCE/TSCF lane spd< 10G                          |i_refclk (XTAL)    |25          |0                   |1                       |
TSCE/TSCF lane spd< 10G                          |i_refclk (XTAL)    |50          |1                   |1                       |
TSCE/TSCF lane spd >= 10G, bypass LCPLL1         |pad_lcpll1_frefp/n |156.25      |X                   |0                       |
1588 application, LCPLL1 non-bypass, 50MHz input |pad_lcpll1_frefp/n |50          |X                   |0                       |ext_clk_lcpll1 = 50000000
*/
    /* # Setup LCPLL1 */
    if (!lcpll1_i_refclk_sel) { /* pad_lcpll1_frefp/n Refclk Freq 156.25Mhz or 50Mhz strap_lcpll1_refclk_sel=0 */
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_6r, REG_PORT_ANY, MSC_CTRLf, (ext_clk_lcpll1 == 50000000) ? 0xD1A4 : 0x0BA4)); /* 0x0BA4 -> 156.25Mhz external clk Bypass enabled */
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_7r, REG_PORT_ANY, FREQ_DOUBLER_ONf, (ext_clk_lcpll1 == 50000000) ? 0x1 : 0x0));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_0r, REG_PORT_ANY, CH0_MDIVf, (ext_clk_lcpll1 == 50000000) ? 0x15 : 0x14));

        /* # Update FBDIV via bypass holdover logic */
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, TOP_XG1_LCPLL_FBDIV_CTRL_1r, REG_PORT_ANY, XG1_LCPLL_FBDIV_1f, (ext_clk_lcpll1 == 50000000) ? 0x0834 : 0x0500));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, TOP_MISC_CONTROL_3r, REG_PORT_ANY, XG1_LCPLL_HO_BYP_ENABLEf, 0x1));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, TOP_MISC_CONTROL_1r, REG_PORT_ANY, CMIC_TO_XG_PLL1_SW_OVWRf, 0x1));
    } else { /* i_refclk(XTAL) Refclk Freq 25Mhz or 50Mhz strap_lcpll1_refclk_sel=1 TSCE/TSCF lane speed < 10G strap_xtal_freq_sel = 0(25Mhz):1(50Mhz)*/
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_6r, REG_PORT_ANY, MSC_CTRLf, 0x01A2)); /* 0x01A2 for both 50Mhz and 25 Mhz */
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_7r, REG_PORT_ANY, FREQ_DOUBLER_ONf, 0x1));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_0r, REG_PORT_ANY, CH0_MDIVf, 0x15));

            /* # Update FBDIV via bypass holdover logic */
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, TOP_XG1_LCPLL_FBDIV_CTRL_1r, REG_PORT_ANY, XG1_LCPLL_FBDIV_1f, (lcpll_xtal_freq_sel) ? 0x0834 : 0x1068));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, TOP_MISC_CONTROL_3r, REG_PORT_ANY, XG1_LCPLL_HO_BYP_ENABLEf, 0x1));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, TOP_MISC_CONTROL_1r, REG_PORT_ANY, CMIC_TO_XG_PLL1_SW_OVWRf, 0x1));
    }
    /* # Release PLL reset */
    SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REGr(unit, &rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_LCPLL_SOFT_RESETf, 0x0);
    WRITE_TOP_SOFT_RESET_REGr(unit, rval);

    /*
     * Delay required for ensure the output becomes stable before leave
     * reset state.
     */
    sal_udelay(100);

    /* Pull  GPIO high to leave the reset state */
    SOC_IF_ERROR_RETURN(_soc_greyhound2_gpio_set(unit, 3, TRUE, 1));

    /* # Update FBDIV via bypass holdover logic again post soft reset */
    if (!lcpll1_i_refclk_sel) { /* pad_lcpll1_frefp/n Refclk Freq 156.25Mhz or 50Mhz strap_lcpll1_refclk_sel=0 */
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, TOP_XG1_LCPLL_FBDIV_CTRL_1r, REG_PORT_ANY, XG1_LCPLL_FBDIV_1f, (ext_clk_lcpll1 == 50000000) ? 0x0834 : 0x0500));
    } else { /* i_refclk(XTAL) Refclk Freq 25Mhz or 50Mhz strap_lcpll1_refclk_sel=1 TSCE/TSCF lane speed < 10G */
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, TOP_XG1_LCPLL_FBDIV_CTRL_1r, REG_PORT_ANY, XG1_LCPLL_FBDIV_1f, (lcpll_xtal_freq_sel) ? 0x0834 : 0x1068));
    }
    
    /* # Release bypass holdover logic */
    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, TOP_MISC_CONTROL_3r, REG_PORT_ANY, XG1_LCPLL_HO_BYP_ENABLEf, 0x0));

    /*
     * TSCx or QTCx to be disabled in some sku.
     */
    /* To be reviewed on chip */
    if (matched_option_idx == -1) {
        LOG_WARN(BSL_LS_SOC_COMMON,
           (BSL_META_U(unit, "Warning: soc_greyhound2_port_config_init should "
                        "be invoked first! Choose bcm56070 port config.\n")));
        matched_option_idx = 0;
    }

    matched_opt_info = &_gh2_option_port_config[matched_option_idx];
    disabled_tsc = 0;
    disabled_qtc = 0;
    SOC_IF_ERROR_RETURN(
        soc_greyhound2_serdes_disabled(unit,
                                       &disabled_tsc, &disabled_qtc));
    disabled_bmp = matched_opt_info->disabled_tsc_bmp;
    for (i = 0; i < _GH2_MAX_TSC_COUNT; i++) {
        if ((1 << i) & disabled_bmp) {
            disabled_tsc |= (1 << i);
        }
    }

    disabled_bmp = matched_opt_info->disabled_qtc_bmp;
    for (i = 0; i < _GH2_MAX_QTC_COUNT; i++) {
        if ((1 << i) & disabled_bmp) {
            disabled_qtc |= (1 << i);
        }
    }

    if (disabled_tsc) {
        SOC_IF_ERROR_RETURN(
            _soc_greyhound2_core_disable(unit, SOC_GH2_PORT_CORE_TYPE_TSC,
                                         disabled_tsc));
    }
    if (disabled_qtc) {
        SOC_IF_ERROR_RETURN(
            _soc_greyhound2_core_disable(unit, SOC_GH2_PORT_CORE_TYPE_QTC,
                                         disabled_qtc));
    }

    /* Re-order port sequence */
    soc_esw_dport_init(unit);

    SOC_IF_ERROR_RETURN(READ_PGW_CTRL_0r(unit, &rval));
    soc_reg_field_set(unit, PGW_CTRL_0r, &rval, SW_PM4X10_DISABLEf,
                      disabled_tsc & 0x7f);
    soc_reg_field_set(unit, PGW_CTRL_0r, &rval, SW_QTC_DISABLEf,
                      disabled_qtc);
    soc_reg_field_set(unit, PGW_CTRL_0r, &rval, SW_PM4X25_DISABLEf,
                      (disabled_tsc >> 7) & 0x1);
    SOC_IF_ERROR_RETURN(WRITE_PGW_CTRL_0r(unit, rval));
    sal_usleep(to_usec);

    /*
     * Bring port blocks out of reset
     */
    SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REGr(unit, &rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_GE8P_RST_Lf, 0x7);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_GEP0_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_GEP1_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_XLP0_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_XLP1_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_XLP2_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_XLP3_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_XLP4_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_XLP5_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_XLP6_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_CLP0_RST_Lf, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REGr(unit, rval));
    sal_usleep(to_usec);

    /* Bring IP, EP, and MMU blocks out of reset */
    SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REGr(unit, &rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_EP_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_IP_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_MMU_RST_Lf, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REGr(unit, rval));
    sal_usleep(to_usec);

    /* Bring network sync out of reset */
    SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REGr(unit, &rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_TS_RST_Lf, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REGr(unit, rval));
    sal_usleep(to_usec);

    /* Add TS_PLL WAR to achieve 1ns resolution
    
    m TOP_TS_PLL_CTRL_3 NDIV_INT=120 NDIV_FRAC=0x0
    m TOP_TS_PLL_CTRL_2 PDIV=2 CH0_MDIV=4 CH0_MDEL=0
    m TOP_SOFT_RESET_REG_2 TOP_TS_PLL_RST_L=1

    sleep 1

    g TOP_TS_PLL_STATUS
    m TOP_SOFT_RESET_REG_2 TOP_TS_PLL_POST_RST_L=1

    sleep 1

    #m TOP_SOFT_RESET_REG_2 TOP_TS_PLL_POST_RST_L=0
    #sleep 1
    m TOP_TS_PLL_CTRL_2 CH0_MDIV=6
    #m TOP_SOFT_RESET_REG_2 TOP_TS_PLL_POST_RST_L=1

    */

    /* set VCO to 3.0 GHz */
    SOC_IF_ERROR_RETURN(READ_TOP_TS_PLL_CTRL_3r(unit, &rval));
    soc_reg_field_set(unit, TOP_TS_PLL_CTRL_3r, &rval, NDIV_INTf, 120);
    soc_reg_field_set(unit, TOP_TS_PLL_CTRL_3r, &rval, NDIV_FRACf,  0);
    WRITE_TOP_TS_PLL_CTRL_3r(unit, rval);
    
    /* set to 750MHz */
    SOC_IF_ERROR_RETURN(READ_TOP_TS_PLL_CTRL_2r(unit, &rval));
    soc_reg_field_set(unit, TOP_TS_PLL_CTRL_2r, &rval, CH0_MDIVf, 4);
    soc_reg_field_set(unit, TOP_TS_PLL_CTRL_2r, &rval, PDIVf, (lcpll_xtal_freq_sel||(ts_ref_freq == 50000000))? 0x2:0x1);
    WRITE_TOP_TS_PLL_CTRL_2r(unit, rval);

    SOC_IF_ERROR_RETURN(READ_TOP_MISC_CONTROL_1r(unit, &rval));
    soc_reg_field_set(unit, TOP_MISC_CONTROL_1r, &rval, CMIC_TO_TS_PLL_LOADf, 1);
    WRITE_TOP_MISC_CONTROL_1r(unit, rval);

    SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REG_2r(unit, &rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_TS_PLL_RST_Lf, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));

    /* wait ts_pll lock */
    sal_usleep(to_usec);

    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_TS_PLL_POST_RST_Lf, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));

    /* Let ts_rst_l reset release to ts_clk gen */
    sal_usleep(to_usec);

    /* stop clock */
    /* SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));
     * soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_TS_PLL_POST_RST_Lf, 0);
     * SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));
     */

    /* Adjust back to 500MHz*/

    SOC_IF_ERROR_RETURN(READ_TOP_TS_PLL_CTRL_2r(unit, &rval));
    soc_reg_field_set(unit, TOP_TS_PLL_CTRL_2r, &rval, CH0_MDIVf, 6);
    WRITE_TOP_TS_PLL_CTRL_2r(unit, rval);

    /* Release post reset */
    /* SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REG_2r(unit, &rval));
     * soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_TS_PLL_POST_RST_Lf, 1);
     * SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));
     */

    /* Reset peak temperature monitor and start recording. */
    SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REG_2r(unit, &rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                      TOP_TEMP_MON_PEAK_RST_Lf, 0);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                      TOP_TEMP_MON_PEAK_RST_Lf, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));

    return SOC_E_NONE;
}


STATIC int
_soc_greyhound2_age_timer_get(int unit, int *age_seconds, int *enabled)
{
    uint32 value;

    SOC_IF_ERROR_RETURN(READ_L2_AGE_TIMERr(unit, &value));
    *enabled = soc_reg_field_get(unit, L2_AGE_TIMERr, value, AGE_ENAf);
    *age_seconds = soc_reg_field_get(unit, L2_AGE_TIMERr, value, AGE_VALf);

    return SOC_E_NONE;
}

STATIC int
_soc_greyhound2_age_timer_max_get(int unit, int *max_seconds)
{
    *max_seconds =
        soc_reg_field_get(unit, L2_AGE_TIMERr, 0xffffffff, AGE_VALf);

    return SOC_E_NONE;
}

STATIC int
_soc_greyhound2_age_timer_set(int unit, int age_seconds, int enable)
{
    uint32 value;

    value = 0;
    soc_reg_field_set(unit, L2_AGE_TIMERr, &value, AGE_ENAf, enable);
    soc_reg_field_set(unit, L2_AGE_TIMERr, &value, AGE_VALf, age_seconds);
    SOC_IF_ERROR_RETURN(WRITE_L2_AGE_TIMERr(unit, value));

    return SOC_E_NONE;
}

static const soc_reg_t pvtmon_result_reg[] = {
    TOP_PVTMON_RESULT_0r,
    TOP_TMON0_RESULTr,
    TOP_TMON1_RESULTr,
    TOP_TMON2_RESULTr
};

int
soc_gh2_temperature_monitor_get(int unit,
          int temperature_max,
          soc_switch_temperature_monitor_t *temperature_array,
          int *temperature_count)
{
    soc_reg_t reg;
    int index;
    uint32 rval;
    int fval, cur, peak;
    int num_entries_out;

    *temperature_count = 0;
    if (COUNTOF(pvtmon_result_reg) > temperature_max) {
        num_entries_out = temperature_max;
    } else {
        num_entries_out = COUNTOF(pvtmon_result_reg);
    }

    /* Read from TOP_PVTMON_RESULT_0r */
    index = 0;
    reg = pvtmon_result_reg[index];
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));

    fval = soc_reg_field_get(unit, reg, rval, PVT_DATAf);
    cur = (41335000 - (49055 * fval)) / 10000;
    fval = soc_reg_field_get(unit, reg, rval, PEAK_TEMP_DATAf);
    peak = (41335000 - (49055 * fval)) / 10000;
    (temperature_array + index)->curr = cur;
    (temperature_array + index)->peak = peak;

    /* Read from TOP_TMON0/1/2_RESULT */
    for (index = 1; index < num_entries_out; index++) {
        reg = pvtmon_result_reg[index];
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));

        cur = -1;
        peak = -1;
        if (soc_reg_field_get(unit, reg, rval, TMON_DATA_VALIDf)) {
            fval = soc_reg_field_get(unit, reg, rval, TMON_DATAf);
            cur = (41335000 - (49055 * fval)) / 10000;
            peak = cur;
        }
        (temperature_array + index)->curr = cur;
        (temperature_array + index)->peak = peak;
    }
    SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REG_2r(unit, &rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                      TOP_TEMP_MON_PEAK_RST_Lf, 0);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                      TOP_TEMP_MON_PEAK_RST_Lf, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));

    *temperature_count = num_entries_out;
    return SOC_E_NONE;
}

typedef struct _gh2_pgw_reg_info_s {
    soc_reg_t   pgw_reg;
    uint32      valid_bm;
    uint32      invalid_bm;
    uint32      invalid_blk_num_bm;
}_gh2_pgw_reg_info_t;

STATIC _gh2_pgw_reg_info_t _gh2_pgw_reg_info[] = {
    {PGW_GX_CONFIGr, 0x3c, 0, 0x1f},
    {PGW_GX_TXFIFO_CTRLr, 0x3c, 0, 0x1f},
    {PGW_GX_SPARE0_REGr, 0x3c, 0, 0x1f},
    {PGW_GX_RXFIFO_SOFT_RESETr, 0, 0, 0x1f},
    {PGW_GX_ECC_CONTROLr, 0, 0, 0x1f},
    {PGW_GX_RXFIFO0_ECC_SBE_STATUSr, 0, 0, 0x1f},
    {PGW_GX_RXFIFO0_ECC_DBE_STATUSr, 0, 0, 0x1f},
    {PGW_GX_RXFIFO1_ECC_SBE_STATUSr, 0, 0, 0x1f},
    {PGW_GX_RXFIFO1_ECC_DBE_STATUSr, 0, 0, 0x1f},
    {PGW_GX_TXFIFO0_ECC_SBE_STATUSr, 0, 0, 0x1f},
    {PGW_GX_TXFIFO0_ECC_DBE_STATUSr, 0, 0, 0x1f},
    {PGW_GX_TXFIFO1_ECC_SBE_STATUSr, 0, 0, 0x1f},
    {PGW_GX_TXFIFO1_ECC_DBE_STATUSr, 0, 0, 0x1f},
    {PGW_GX_TXFIFO2_ECC_SBE_STATUSr, 0, 0, 0x1f},
    {PGW_GX_TXFIFO2_ECC_DBE_STATUSr, 0, 0, 0x1f},
    {PGW_GX_TXFIFO3_ECC_SBE_STATUSr, 0, 0, 0x1f},
    {PGW_GX_TXFIFO3_ECC_DBE_STATUSr, 0, 0, 0x1f},
    {PGW_GX_TXFIFO_OVERFLOWr, 0, 0, 0x1f},
    {PGW_GX_RXFIFO0_OVERFLOW_ERRORr, 0, 0, 0x1f},
    {PGW_GX_RXFIFO1_OVERFLOW_ERRORr, 0, 0, 0x1f},
    {PGW_GX_TM0_CONTROLr, 0, 0, 0x1f},
    {PGW_GX_TM1_CONTROLr, 0, 0, 0x1f},
    {PGW_GX_TM2_CONTROLr, 0, 0, 0x1f},
    {PGW_GX_TM3_CONTROLr, 0, 0, 0x1f},
    {PGW_GX_TM4_CONTROLr, 0, 0, 0x1f},
    {PGW_GX_TM5_CONTROLr, 0, 0, 0x1f},
    {PGW_GX_TM6_CONTROLr, 0, 0, 0x1f},
    {PGW_GX_TM7_CONTROLr, 0, 0, 0x1f},
    {PGW_GX_TM8_CONTROLr, 0, 0, 0x1f},
    {PGW_GX_BYPASS_LED_CHAIN_CONFIGr, 0, 0, 0x1f},
    {PGW_GX_INTR_STATUSr, 0, 0, 0x1f},
    {PGW_GX_INTR_ENABLEr, 0, 0, 0x1f},
    {PGW_XL_CONFIGr, 0, 0x3c, 0x20},
    {PGW_XL_TXFIFO_CTRLr, 0, 0x3c, 0x20},
    {PGW_XL_SPARE0_REGr, 0, 0x3c, 0x20},
    {PGW_XL_RXFIFO_SOFT_RESETr, 0, 0, 0x20},
    {PGW_XL_ECC_CONTROLr, 0, 0, 0x20},
    {PGW_XL_RXFIFO_ECC_SBE_STATUSr, 0, 0, 0x20},
    {PGW_XL_RXFIFO_ECC_DBE_STATUSr, 0, 0, 0x20},
    {PGW_XL_TXFIFO0_ECC_SBE_STATUSr, 0, 0, 0x20},
    {PGW_XL_TXFIFO0_ECC_DBE_STATUSr, 0, 0, 0x20},
    {PGW_XL_TXFIFO1_ECC_SBE_STATUSr, 0, 0, 0x20},
    {PGW_XL_TXFIFO1_ECC_DBE_STATUSr, 0, 0, 0x20},
    {PGW_XL_TXFIFO2_ECC_SBE_STATUSr, 0, 0, 0x20},
    {PGW_XL_TXFIFO2_ECC_DBE_STATUSr, 0, 0, 0x20},
    {PGW_XL_TXFIFO3_ECC_SBE_STATUSr, 0, 0, 0x20},
    {PGW_XL_TXFIFO3_ECC_DBE_STATUSr, 0, 0, 0x20},
    {PGW_XL_TXFIFO_OVERFLOWr, 0, 0, 0x20},
    {PGW_XL_RXFIFO_OVERFLOW_ERRORr, 0, 0, 0x20},
    {PGW_XL_TM0_CONTROLr, 0, 0, 0x20},
    {PGW_XL_TM1_CONTROLr, 0, 0, 0x20},
    {PGW_XL_TM2_CONTROLr, 0, 0, 0x20},
    {PGW_XL_TM3_CONTROLr, 0, 0, 0x20},
    {PGW_XL_TM4_CONTROLr, 0, 0, 0x20},
    {PGW_XL_TM5_CONTROLr, 0, 0, 0x20},
    {PGW_XL_TM6_CONTROLr, 0, 0, 0x20},
    {PGW_XL_TM7_CONTROLr, 0, 0, 0x20},
    {PGW_XL_TM8_CONTROLr, 0, 0, 0x20},
    {PGW_XL_BYPASS_LED_CHAIN_CONFIGr, 0, 0, 0x20},
    {PGW_XL_INTR_STATUSr, 0, 0, 0x20},
    {PGW_XL_INTR_ENABLEr, 0, 0, 0x20},
    {INVALIDr, 0, 0},
};

/*
 * Function:
 *  soc_greyhound2_pgw_reg_blk_index_get
 * Purpose:
 *  Deal with the blk, blknum for PGW_GX and PGW_XL registers
 * Parameters:
 *  reg (IN): register.
 *  port (IN): logical port if PGW_GX's port register.
 *  bm (IN/OUT): bm should be added for the reg.
 *  block (IN/OUT): blk used to access the reg.
 *  index (OUT): port index of the reg.
 *  invalid_blk_check (IN): perform the blk check.
 *                          skip the block if the return value = 1.
 * Return:
 *   SOC_E_NOT_FOUND : w/o bm,blk,invalid_blk_check case, register not matched.
 *   1 : register matched and the block/index has been override.
 *   1 : register matched and the valid bm has been override.
 *   1 : skip the block when the invalid_blk_check=1
 *   SOC_E_PARAM : invalid paramter
 */
int
soc_greyhound2_pgw_reg_blk_index_get(int unit,
    soc_reg_t reg, soc_port_t port,
    pbmp_t *bm, int *block, int *index, int invalid_blk_check) {

    int i, p, phy_port, blk_num, pgw_blk;
    soc_reg_info_t *reginfo;
    _gh2_pgw_reg_info_t *pgw_reg = NULL;
    pbmp_t pgw_pbm, pgw_invalid_pbm;

    pgw_blk = -1;
    SOC_PBMP_CLEAR(pgw_pbm);

    for (i = 0; _gh2_pgw_reg_info[i].pgw_reg != INVALIDr; i ++) {
        if (reg == _gh2_pgw_reg_info[i].pgw_reg) {
            pgw_reg = &_gh2_pgw_reg_info[i];
            break;
        }
    }

    if (!pgw_reg) {
        return SOC_E_NOT_FOUND;
    }

    reginfo = &SOC_REG_INFO(unit, reg);
    phy_port = 0;
    if (reginfo->regtype == soc_portreg) {
        SOC_PBMP_WORD_SET(pgw_pbm, 0, pgw_reg->valid_bm);
        SOC_PBMP_WORD_SET(pgw_invalid_pbm, 0, pgw_reg->invalid_bm);
        phy_port = SOC_INFO(unit).port_l2p_mapping[port];
    }

    if (bm != NULL) {
        SOC_PBMP_ITER(pgw_pbm, p) {
            SOC_PBMP_PORT_ADD(*bm, p);
        }
        return 1;
    }
    if (block) {
        if (reginfo->regtype == soc_portreg) {
            if (SOC_PORT_BLOCK_TYPE(unit,phy_port) == SOC_BLK_GXPORT) {
                if (SOC_PBMP_MEMBER(pgw_pbm, port)) {
                    /* get the blk from phy_port=2 bindex=1 i.e. XLPORT5 */
                    pgw_blk = SOC_PORT_IDX_BLOCK(unit, 2, 1);
                    if (index) {
                        *index = phy_port - 2;
                    }
                    if (!invalid_blk_check) {
                        *block = pgw_blk;
                        return 1;
                    }
                }
                if (SOC_PBMP_MEMBER(pgw_invalid_pbm, port)) {
                    *block = 0;
                    return 1;
                }
            }
        }
    }
    if (invalid_blk_check) {
        if (!block) {
            return SOC_E_PARAM;
        }
        /* check if the *block is valid for the reg */

        if (pgw_blk == -1) {
            pgw_blk = *block;
        }
        blk_num = SOC_BLOCK_NUMBER(unit, pgw_blk) & 0xff;
        if (pgw_reg->invalid_blk_num_bm & (1 << blk_num)) {
            return 1;
        }
    }
    return SOC_E_NONE;
}

/*
* Function:
*      soc_gh2_chip_sku_get
* Purpose:
*      Get the chip sku
* Parameters :
*      sku - (OUT)Greyhound2 chip sku(SOC_GH2_SKU_XXX)
*/
int
soc_gh2_chip_sku_get(int unit, int *sku)
{
    uint16  dev_id;
    uint8    rev_id;

    soc_cm_get_id(unit, &dev_id, &rev_id);

    if ((dev_id & 0xfff0) == 0xb170) {
        /* Hurricane3-MG (56170, 56172, 56174) */
        *sku = SOC_GH2_SKU_HURRICANE3MG;
    } else if ((dev_id & 0xfff0) == 0x8570) {
        /* Quartz (53570, 53575) */
        *sku = SOC_GH2_SKU_QUARTZ;
    } else {
        *sku = -1;
        return SOC_E_BADID;
    }

    return SOC_E_NONE;
}

int
_soc_greyhound2_features(int unit, soc_feature_t feature)
{
    int sku = 0;
    int flow_type = 0;
    uint16 dev_id = 0;
    uint8  rev_id = 0;

    SOC_IF_ERROR_RETURN(soc_gh2_chip_sku_get(unit, &sku));

    flow_type = soc_property_get(unit, spn_FLOW_TYPE_FOR_CUT_THROUGH_CONTROL,
                                 GH2_FLOW_TYPE_SR);

    soc_cm_get_id(unit, &dev_id, &rev_id);

    switch (feature) {
        case soc_feature_arl_hashed:
        case soc_feature_arl_insert_ovr:
        case soc_feature_cfap_pool:
        case soc_feature_cos_rx_dma:
        case soc_feature_dcb_type37:
        case soc_feature_ingress_metering:
        case soc_feature_egress_metering:
        case soc_feature_l3_lookup_cmd:
        case soc_feature_led_proc:
        case soc_feature_led_data_offset_a0:
        case soc_feature_schmsg_alias:
        case soc_feature_stack_my_modid:
        case soc_feature_stat_dma:
        case soc_feature_cpuport_stat_dma:
        case soc_feature_table_dma:
        case soc_feature_tslam_dma:
        case soc_feature_stg:
        case soc_feature_stg_xgs:
        case soc_feature_remap_ut_prio:
        case soc_feature_xgxs_v7:
        case soc_feature_phy_cl45:
        case soc_feature_aging_extended:
        case soc_feature_modmap:
        case soc_feature_l2_hashed:
        case soc_feature_l2_lookup_cmd:
        case soc_feature_l2_lookup_retry:
        case soc_feature_l2_user_table:
        case soc_feature_schan_hw_timeout:
        case soc_feature_mdio_enhanced:
        case soc_feature_dodeca_serdes:
        case soc_feature_rxdma_cleanup:
        case soc_feature_fe_maxframe:
        case soc_feature_l2x_parity:
        case soc_feature_l3x_parity:
        case soc_feature_l2_modfifo:
        case soc_feature_vlan_mc_flood_ctrl:
        case soc_feature_vlan_translation:
        case soc_feature_parity_err_tocpu:
        case soc_feature_nip_l3_err_tocpu:
        case soc_feature_l3mtu_fail_tocpu:
        case soc_feature_meter_adjust:
        case soc_feature_xgxs_power:
        case soc_feature_src_modid_blk:
        case soc_feature_src_modid_blk_ucast_override:
        case soc_feature_src_modid_blk_opcode_override:
        case soc_feature_egress_blk_ucast_override:
        case soc_feature_stat_jumbo_adj:
        case soc_feature_stat_xgs3:
        case soc_feature_port_trunk_index:
        case soc_feature_port_flow_hash:
        case soc_feature_cpuport_switched:
        case soc_feature_cpuport_mirror:
        case soc_feature_higig2:
        case soc_feature_color:
        case soc_feature_color_inner_cfi:
        case soc_feature_color_prio_map:
        case soc_feature_untagged_vt_miss:
        case soc_feature_module_loopback:
        case soc_feature_dscp_map_per_port:
        case soc_feature_egr_dscp_map_per_port:
        case soc_feature_dscp_map_mode_all:
        case soc_feature_higig_lookup:
        case soc_feature_egr_mirror_path:
        case soc_feature_trunk_extended:
        case soc_feature_hg_trunking:
        case soc_feature_hg_trunk_override:
        case soc_feature_egr_vlan_check:
        case soc_feature_cpu_proto_prio:
        case soc_feature_hg_trunk_failover:
        case soc_feature_trunk_egress:
        case soc_feature_force_forward:
        case soc_feature_port_egr_block_ctl:
        case soc_feature_bucket_support:
        case soc_feature_remote_learn_trust:
        case soc_feature_src_mac_group:
        case soc_feature_storm_control:
        case soc_feature_hw_stats_calc:
        case soc_feature_mac_learn_limit:
        case soc_feature_linear_drr_weight:
        case soc_feature_igmp_mld_support:
        case soc_feature_basic_dos_ctrl:
        case soc_feature_enhanced_dos_ctrl:
        case soc_feature_proto_pkt_ctrl:
        case soc_feature_vlan_ctrl:
        case soc_feature_big_icmpv6_ping_check:
        case soc_feature_trunk_group_overlay:
        case soc_feature_xport_convertible:
        case soc_feature_dual_hash:
        case soc_feature_dscp:
        case soc_feature_rcpu_1:
        case soc_feature_unimac:
        case soc_feature_ifg_wb_include_unimac:
        case soc_feature_xlmac:
        case soc_feature_clmac:
        case soc_feature_generic_table_ops:
        case soc_feature_vlan_translation_range:
        case soc_feature_static_pfm:
        case soc_feature_sgmii_autoneg:
        case soc_feature_rcpu_priority:
        case soc_feature_rcpu_tc_mapping:
        case soc_feature_mem_push_pop:
        case soc_feature_dcb_reason_hi:
        case soc_feature_multi_sbus_cmds:
        case soc_feature_new_sbus_format:
        case soc_feature_new_sbus_old_resp:
        case soc_feature_sbus_format_v4:
        case soc_feature_fifo_dma:
        case soc_feature_fifo_dma_active:
        case soc_feature_l2_pending:
        case soc_feature_internal_loopback:
        case soc_feature_vlan_action:
        case soc_feature_mac_based_vlan:
        case soc_feature_ip_subnet_based_vlan:
        case soc_feature_packet_rate_limit:
        case soc_feature_system_mac_learn_limit:
        case soc_feature_field:
        case soc_feature_field_mirror_ovr:
        case soc_feature_field_udf_higig:
        case soc_feature_field_udf_ethertype:
        case soc_feature_field_udf_offset_hg_114B:
        case soc_feature_field_udf_offset_hg2_110B:
        case soc_feature_field_comb_read:
        case soc_feature_field_wide:
        case soc_feature_field_slice_enable:
        case soc_feature_field_cos:
        case soc_feature_field_color_indep:
        case soc_feature_field_qual_drop:
        case soc_feature_field_qual_IpType:
        case soc_feature_field_qual_Ip6High:
        case soc_feature_field_qual_vlanformat_reverse:
        case soc_feature_field_ingress_global_meter_pools:
        case soc_feature_field_ingress_ipbm:
        case soc_feature_field_egress_flexible_v6_key:
        case soc_feature_field_egress_global_counters:
        case soc_feature_field_ing_egr_separate_packet_byte_counters:
        case soc_feature_field_egress_metering:
        case soc_feature_field_intraslice_double_wide:
        case soc_feature_field_virtual_slice_group:
        case soc_feature_field_virtual_queue:
        case soc_feature_field_action_timestamp:
        case soc_feature_field_action_l2_change:
        case soc_feature_field_action_redirect_nexthop:
        case soc_feature_field_action_pfc_class:
        case soc_feature_field_action_redirect_ipmc:
        case soc_feature_field_slice_dest_entity_select:
        case soc_feature_field_packet_based_metering:
        case soc_feature_lport_tab_profile:
        case soc_feature_field_oam_actions:
        case soc_feature_oam:
        case soc_feature_ignore_cmic_xgxs_pll_status:
        case soc_feature_use_double_freq_for_ddr_pll:
        case soc_feature_counter_parity:
        case soc_feature_extended_pci_error:
        case soc_feature_qos_profile:
        case soc_feature_rx_timestamp:
        case soc_feature_rx_timestamp_upper:
        case soc_feature_logical_port_num:
        case soc_feature_timestamp_counter:
        case soc_feature_modport_map_profile:
        case soc_feature_modport_map_dest_is_hg_port_bitmap:
        case soc_feature_eee:
        case soc_feature_xy_tcam:
        case soc_feature_xy_tcam_direct:
        case soc_feature_xy_tcam_28nm:
        case soc_feature_vlan_egr_it_inner_replace:
        case soc_feature_cmicm:
        case soc_feature_iproc:
        case soc_feature_iproc_7:
        case soc_feature_unified_port:
        case soc_feature_sbusdma:
        case soc_feature_mirror_encap_profile:
        case soc_feature_higig_misc_speed_support:
        case soc_feature_vpd_profile:
        case soc_feature_color_prio_map_profile:
        case soc_feature_mem_parity_eccmask:
        case soc_feature_l2_no_vfi:
        case soc_feature_gmii_clkout:
        case soc_feature_fifo_dma_hu2:
        case soc_feature_proxy_port_property:
        case soc_feature_system_reserved_vlan:
        case soc_feature_ser_parity:
        case soc_feature_mem_cache:
        case soc_feature_mem_wb_cache_reload:
        case soc_feature_ser_engine:
        case soc_feature_ser_system_scrub:
        case soc_feature_regs_as_mem:
        case soc_feature_cmicd_v2:
        case soc_feature_cmicm_extended_interrupts:
        case soc_feature_int_common_init:
        case soc_feature_inner_tpid_enable:
        case soc_feature_no_tunnel:
        case soc_feature_eee_bb_mode:
        case soc_feature_hg_no_speed_change:
        case soc_feature_src_modid_base_index:
        case soc_feature_avs:
        case soc_feature_l2_overflow:
        case soc_feature_l2_overflow_bucket:
        case soc_feature_l2_learn_stats:
        case soc_feature_miml:
        case soc_feature_custom_header:
        case soc_feature_ing_capwap_parser:
        case soc_feature_port_extension:
        case soc_feature_niv:
        case soc_feature_gh2_rtag7:
        case soc_feature_no_vlan_vrf:
        case soc_feature_tscf:
        case soc_feature_sync_port_lport_tab:
            /* GH2 Service Metering Block is a simple version of Apache */
        case soc_feature_global_meter:
        case soc_feature_global_meter_v2:
        case soc_feature_global_meter_source_l2:
        case soc_feature_separate_ing_lport_rtag7_profile:
        case soc_feature_rtag7_port_profile:
        case soc_feature_no_vrf_stats:
        case soc_feature_flowcnt:
        case soc_feature_high_portcount_register:
        case soc_feature_asf:
        case soc_feature_hg2_light_in_portmacro:
        case soc_feature_tas:
        case soc_feature_use_local_1588:
        case soc_feature_common_egr_ip_tunnel_ser:
        case soc_feature_memory_2bit_ecc_ser:
        case soc_feature_switch_match:
        case soc_feature_pktpri_as_dot1p:
        case soc_feature_cpureg_dump:
        case soc_feature_hr2_dual_hash:
        case soc_feature_discard_ability:
        case soc_feature_wred_drop_counter_per_port:
        case soc_feature_ecn_wred:
        case soc_feature_port_encap_speed_max_config:
        case soc_feature_extended_cmic_error:
        case soc_feature_xlmac_speed_display_above_10g:
        case soc_feature_xlmac_timestamp_disable:
        case soc_feature_serdes_firmware_pos_by_host_endian:
        case soc_feature_dport_update_hl:
        case soc_feature_phy_interface_wb:
        case soc_feature_port_enable_encap_restore:
        case soc_feature_timesync_time_capture:
        case soc_feature_no_mirror_truncate:
            return TRUE;
        case soc_feature_tsn:
        case soc_feature_tsn_sr:
        case soc_feature_tsn_sr_hsr:
        case soc_feature_tsn_sr_prp:
        case soc_feature_tsn_sr_802_1cb:
        case soc_feature_tsn_mtu_stu:
        case soc_feature_uc_mhost:
        case soc_feature_ptp:
            return TRUE;
        case soc_feature_tsn_sr_auto_learn:
            if (NUM_PORT(unit) < 3) {
                /*
                 * At least 3 ports are required to setup SR Auto Learn table.
                 */
                return FALSE;
            } else {
                return TRUE;
            }
        case soc_feature_uc:
            if (soc_property_get(unit, spn_UC_VALID_BMP, 1) != 0) {
                return TRUE;
            } else {
                return FALSE;
            }
        case soc_feature_tsn_taf:
            if (rev_id == BCM56170_B0_REV_ID) {
                return TRUE;
            } else {
                return FALSE;
            }
        case soc_feature_tsn_sr_flow_no_asf_select:
            if (flow_type == GH2_FLOW_TYPE_SR) {
                return TRUE;
            } else {
                return FALSE;
            }
            break;
        case soc_feature_tsn_flow_no_asf_select:
            if (flow_type == GH2_FLOW_TYPE_TSN) {
                return TRUE;
            } else {
                return FALSE;
            }
            break;
        case soc_feature_time_v3_no_bs:
            return FALSE;
        case soc_feature_e2ecc:
        case soc_feature_priority_flow_control:
        case soc_feature_gh_style_pfc_config:
        case soc_feature_time_support:
        case soc_feature_time_v3:
        case soc_feature_timesync_support:
        case soc_feature_timesync_v3:
        case soc_feature_timesync_timestampingmode:
            return TRUE;
        case soc_feature_gh2_my_station:
            return TRUE;
        case soc_feature_preempt_mib_support:
        case soc_feature_clmib_support:
        case soc_feature_ecmp_hash_bit_count_select:
            return TRUE;
        case soc_feature_field_multi_stage:
            return TRUE;
        case soc_feature_field_slices12:
        case soc_feature_field_meter_pools12:
            
            return TRUE;
        case soc_feature_field_slices8:
        case soc_feature_field_meter_pools8:
            
            return FALSE;
        case soc_feature_field_slice_size128:
            
            return FALSE;
        case soc_feature_preemption:
        case soc_feature_preemption_cnt:
            return TRUE;
        case soc_feature_l3_no_ecmp:
        case soc_feature_miml_no_l3:
#if 1
            if (!SAL_BOOT_SIMULATION) {
                return FALSE;
            } else {
#endif
                if (sku == SOC_GH2_SKU_QUARTZ) {
                    return TRUE;
                } else {
                    return FALSE;
                }
            }
            break;
        case soc_feature_e2efc:
            return TRUE;
        /* L3 related features */
        case soc_feature_l3:
        case soc_feature_l3_ip6:
        case soc_feature_l3_entry_key_type:
        case soc_feature_lpm_tcam:
        case soc_feature_ip_mcast:
        case soc_feature_ip_mcast_repl:
        case soc_feature_ipmc_unicast:
        case soc_feature_ipmc_use_configured_dest_mac:
        case soc_feature_urpf:
        case soc_feature_l3mc_use_egress_next_hop:
        case soc_feature_l3_sgv:
        case soc_feature_l3_dynamic_ecmp_group:
        case soc_feature_l3_ingress_interface:
        case soc_feature_l3_iif_zero_invalid:
        case soc_feature_l3_iif_under_4k:
        case soc_feature_vxlan_lite:
        case soc_feature_tunnel_any_in_6:
        case soc_feature_rroce:
#if 1
            if (!SAL_BOOT_SIMULATION) {
                return TRUE;
            } else {
#endif
                if (sku == SOC_GH2_SKU_QUARTZ) {
                    return FALSE;
                } else {
                    return TRUE;
                }
            }
            break;
        case soc_feature_untethered_otp:
#if 1
            return (!SAL_BOOT_SIMULATION);
#endif
        case soc_feature_vxlan_lite_riot:
            /* Only GH2-B0 suport VXLAN-Lite RIOT */
            if (rev_id == BCM56170_B0_REV_ID) {
                return TRUE;
            } else {
                return FALSE;
            }
            break;
        case soc_feature_trunk_group_size:
            if (rev_id == BCM56170_B0_REV_ID) {
                /* tTRUNK_GROUP.TG_SIZE is supported in B0 */
                return TRUE;
            } else {
                return FALSE;
            }
            break;
        default:
            return FALSE;
    }
}

/*
 * Function:
 *      soc_gh2_tdm_size_get
 * Purpose:
 *      Get the TDM array size.
 * Parameters:
 *      unit - unit number.
 *      tdm_size (OUT) - TDM array size
 * Returns:
 *      SOC_E_XXX
 */
int soc_gh2_tdm_size_get(int unit, int *tdm_size)
{
    _gh2_option_info_t *matched_opt_info;

    /* The function should be called only if the TDM is programmed */
    if (matched_option_idx == -1) {
        LOG_WARN(BSL_LS_SOC_COMMON,
                 (BSL_META_U(unit, "Warning: soc_greyhound2_port_config_init "
                             "should be invoked first! \n")));
        return SOC_E_INIT;
    }

    /* Return the TDM size */
    matched_opt_info = &_gh2_option_port_config[matched_option_idx];
    *tdm_size = matched_opt_info->tdm_table_size;

    return SOC_E_NONE;
}

/*
 * Function:
 *      soc_gh2_tdm_size_set
 * Purpose:
 *      Set the TDM array size.
 * Parameters:
 *      unit - unit number.
 *      tdm_size (OUT) - TDM array size
 * Returns:
 *      SOC_E_XXX
 */
int soc_gh2_tdm_size_set(int unit, int tdm_size)
{
    _gh2_option_info_t *matched_opt_info;
    int flex_mode_id = -1;
    int i;

    matched_opt_info = &_gh2_option_port_config[matched_option_idx];

    /* Check if AutoTDM available on the option */
    for (i = 0; _gh2_option_tsc_flex_modes[i].config_op; i++) {
        if (!sal_strcmp(matched_opt_info->config_op,
                        _gh2_option_tsc_flex_modes[i].config_op)) {
            flex_mode_id = i;
            break;
        }
    }
    if (flex_mode_id != -1) {
        /* AutoTDM option */
        matched_opt_info->tdm_table_size = tdm_size;
    } else {
        LOG_WARN(BSL_LS_SOC_COMMON,
                 (BSL_META_U(unit, "Warning: TDM size cannot be changed "
                             "on this option.\n")));
        return SOC_E_FAIL;
    }
    return SOC_E_NONE;
}

/*
 * Function:
 *      soc_gh2_64q_port_check
 * Purpose:
 *      Check if the port(logical) is capable of configured up to 64 COSQ.
 * Parameters:
 *      unit - StrataSwitch unit number.
 *      port - logical port.
 *      is_64q (OUT) - with 64 COSQ or not
 * Returns:
 *      BCM_E_XXX
 */
int soc_gh2_64q_port_check(int unit, soc_port_t port, int *is_64q_port)
{
    int phy_port;
    int mmu_port;

    /* Array access protection. */
    if ((port < 0) || (port >= SOC_MAX_NUM_PORTS)){
        return SOC_E_PORT;
    }

    *is_64q_port = 0;
    phy_port = SOC_INFO(unit).port_l2p_mapping[port];
    if (phy_port < 0) {
        /* Invalid port. */
        return SOC_E_PORT;
    }

    mmu_port = SOC_INFO(unit).port_p2m_mapping[phy_port];
    if ((mmu_port >= SOC_GH2_64Q_MMU_PORT_IDX_MIN) &&
        (mmu_port <= SOC_GH2_64Q_MMU_PORT_IDX_MAX)) {
        *is_64q_port = 1;
    } else {
        *is_64q_port = 0;
    }
    return SOC_E_NONE;
}

/*
 * For calculate GH2 MMU_MAX/MIN_BUCKET_QLAYER table index.
 *    - mmu port 0~57 : 8 entries
 *    - mmu port 58~65 : 64 entries
 *  (IN) p : logical port
 *  (IN) q : cosq
 *  (OUT) idx : the entry index of MMU_MAX/MIN_BUCKET_QLAYER table
 */
int
soc_gh2_mmu_bucket_qlayer_index(int unit, int p, int q, int *idx)
{
    int is_64q;
    int phy_port;
    int mmu_port;

    is_64q = 0;
    phy_port = SOC_INFO(unit).port_l2p_mapping[p];
    mmu_port = SOC_INFO(unit).port_p2m_mapping[phy_port];

    SOC_IF_ERROR_RETURN(soc_gh2_64q_port_check(unit, p, &is_64q));


    if (!is_64q) {
        *idx = (mmu_port * SOC_GH2_LEGACY_QUEUE_NUM) + q;
    }  else {
        *idx = (SOC_GH2_64Q_MMU_PORT_IDX_MIN * SOC_GH2_LEGACY_QUEUE_NUM) + \
               ((mmu_port-SOC_GH2_64Q_MMU_PORT_IDX_MIN) * \
                 SOC_GH2_QLAYER_COSQ_PER_PORT_NUM) + \
               q;
    }
    return SOC_E_NONE;
}

/*
 * For calculate GH2 MMU_MAX/MIN_BUCKET_QGROUP table index.
 *    - mmu port 0~57 : not available
 *    - mmu port 58~65 : 8 entries
 *  (IN) p : logical port
 *  (IN) g : queue group id
 *  (OUT) idx : the entry index of MMU_MAX/MIN_BUCKET_QGROUP table
 */
int
soc_gh2_mmu_bucket_qgroup_index(int unit, int p, int g, int *idx)
{
    int is_64q = 0;
    int phy_port;
    int mmu_port;

    SOC_IF_ERROR_RETURN(soc_gh2_64q_port_check(unit, p, &is_64q));
    if (!is_64q) {
        /* MMU port 0~57 do not have QGROUP tables */
        return SOC_E_PARAM;
    }

    phy_port = SOC_INFO(unit).port_l2p_mapping[p];
    mmu_port = SOC_INFO(unit).port_p2m_mapping[phy_port];
    *idx = ((mmu_port - SOC_GH2_64Q_MMU_PORT_IDX_MIN) * \
             SOC_GH2_QGROUP_PER_PORT_NUM) + g;

    return SOC_E_NONE;
}

/*
 * Greyhound2 chip driver functions.
 */
soc_functions_t soc_greyhound2_drv_funs = {
    _soc_greyhound2_misc_init,
    _soc_greyhound2_mmu_init,
    _soc_greyhound2_age_timer_get,
    _soc_greyhound2_age_timer_max_get,
    _soc_greyhound2_age_timer_set,
    _soc_greyhound2_tscx_firmware_set,
    _soc_greyhound2_tscx_reg_read,
    _soc_greyhound2_tscx_reg_write,
    soc_greyhound2_bond_info_init
};

soc_error_t
soc_greyhound2_granular_speed_get(int unit, soc_port_t port, int *speed)
{
    soc_info_t  *si = &SOC_INFO(unit);

    /* CLMAC and XLMAC only */
    if (!IS_CL_PORT(unit, port) && !IS_XL_PORT(unit, port)) {
        return SOC_E_PARAM;
    }

    *speed = gh2_port_speed[si->port_l2p_mapping[port]];

    return SOC_E_NONE;
}

int
soc_greyhound2_port_speed_update(int unit, soc_port_t port, int speed)
{
    soc_info_t  *si = &SOC_INFO(unit);

    gh2_port_speed[si->port_l2p_mapping[port]] = speed;

    return SOC_E_NONE;
}

int
soc_greyhound2_auto_tdm_realloc(int unit)
{
    _gh2_option_info_t *matched_port_config;
    int option_match = 0;
    int qtc0_match = 0;
    int qtc1_match = 0;

    if (matched_option_idx == -1) {
        LOG_WARN(BSL_LS_SOC_COMMON,
           (BSL_META_U(unit, "Warning: soc_greyhound2_port_config_init should "
                        "be invoked first! Choose default port config.\n")));
        matched_option_idx = 0;
    }
    matched_port_config = &_gh2_option_port_config[matched_option_idx];

    /*
     * The following combination requires TDM reallocation.
     *
     * Option 6 and 9B.
     * QTC in SGMII mode and at 2.5Gps.
 */
    if (!sal_strcmp(matched_port_config->config_op, OPTION_6) ||
        !sal_strcmp(matched_port_config->config_op, OPTION_9B)) {
        option_match = 1;
    }

    if ((matched_port_config->qtc_default_mode[0] == \
        _GH2_QTC_SERDES_DEFAULT_MODE_SGMII)) {
        if ((matched_port_config->speed_max[qtc_phy_port[0]] == 25) ||
            (matched_port_config->speed_max[qtc_phy_port[0] + 1] == 25) ||
            (matched_port_config->speed_max[qtc_phy_port[0] + 2] == 25) ||
            (matched_port_config->speed_max[qtc_phy_port[0] + 3] == 25)) {
            qtc0_match = 1;
        }
    }

    if ((matched_port_config->qtc_default_mode[1] == \
        _GH2_QTC_SERDES_DEFAULT_MODE_SGMII)) {
        if ((matched_port_config->speed_max[qtc_phy_port[1]] == 25) ||
            (matched_port_config->speed_max[qtc_phy_port[1] + 1] == 25) ||
            (matched_port_config->speed_max[qtc_phy_port[1] + 2] == 25) ||
            (matched_port_config->speed_max[qtc_phy_port[1] + 3] == 25)) {
            qtc1_match = 1;
        }
    }

    if (option_match && (qtc0_match || qtc1_match)) {
        return 1;
    }

    return 0;
}
#endif /* BCM_GREYHOUND2_SUPPORT */
