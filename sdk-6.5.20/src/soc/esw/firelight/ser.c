 /*
 * 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 * File:      ser.c
 * Purpose:   SER enable/detect and test functionality.
 * Requires:
 */
#include <shared/bsl.h>
#include <soc/drv.h>
#include <soc/error.h>
#include <soc/debug.h>
#include <soc/mem.h>
#include <soc/firelight.h>
#include <soc/intr_cmicx.h>
#include <include/sal/core/dpc.h>
#if defined(INCLUDE_XFLOW_MACSEC)
#include <bcm/xflow_macsec.h>
#include <esw/xflow_macsec_esw_defs.h>
#endif

/* Internal Use Only : Individually Test Purpose */
#define _FL_SER_TEST_MMU        (1)
#define _FL_SER_TEST_TCAM       (1)
#define _FL_SER_TEST_EP         (1)
#define _FL_SER_TEST_IP0        (1)
#define _FL_SER_TEST_IP1        (1)
#define _FL_SER_TEST_IP2        (1)
#define _FL_SER_TEST_IP2_SR     (1)
#define _FL_SER_TEST_IP2_SR_SN  (1)
#define _FL_SER_TEST_CLPORT     (1)
#define _FL_SER_TEST_XLPORT     (1)
#define _FL_SER_TEST_GPORT      (1)
#define _FL_SER_TEST_MACSEC     (1)

/* Redefine */
#define FL_REG1_MACSEC_INTR_MASK           (0x20)


#define READ_CMICx_INTC_INTR(unit, reg, rvp) \
        soc_iproc_getreg(unit, soc_reg_addr(unit, reg, REG_PORT_ANY, 0), rvp)

/*
 * Chip specific SER information.
 */
/* FL chip revisions */
#define _SOC_SER_SKIP_FL_A0     (0x1 << 2)
#define _SOC_SER_SKIP_FL_B0     (0x1 << 3)

#if _FL_SER_TEST_CLPORT
static _soc_fl_ser_info_t _soc_fl_clport_ser_info[] = {
    { _SOC_PARITY_TYPE_ECC, NULL,
        MIB_RX_MEM_ERRf, MIB_RX_MEM_ERRf,
        INVALIDm, NULL,
        CLPORT_ECC_CONTROLr, MIB_RSC_MEM_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        CLPORT_MIB_RSC0_ECC_STATUSr, NULL, ECC_ERRf,
        CLPORT_INTR_STATUSr, MIB_RX_MEM_ERRf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        MIB_TX_MEM_ERRf, MIB_TX_MEM_ERRf,
        INVALIDm, NULL,
        CLPORT_ECC_CONTROLr, MIB_TSC_MEM_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        CLPORT_MIB_TSC0_ECC_STATUSr, NULL, ECC_ERRf,
        CLPORT_INTR_STATUSr, MIB_TX_MEM_ERRf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_NONE }, /* table terminator */
};
#endif /* _FL_SER_TEST_CLPORT */

/* from FORMAT CMIC_PARITY_INTR_STATUS */
#define _FL_PAR_MMU       (0)
#define _FL_PAR_EP        (1)
#define _FL_PAR_IP0       (2)
#define _FL_PAR_IP1       (3)
#define _FL_PAR_IP2       (4)
#define _FL_PAR_IP2_SR    (5)
#define _FL_PAR_IP2_SR_SN (6)
#define _FL_PAR_GE0       (11)
#define _FL_PAR_GE1       (12)
#define _FL_PAR_GE2       (13)
#define _FL_PAR_XL0       (13)
#define _FL_PAR_XL1       (14)
#define _FL_PAR_XL2       (15)
#define _FL_PAR_CL0       (20)
#define _FL_PAR_CL1       (21)
#define _FL_PAR_CL2       (22)
#define _FL_PAR_CL3       (23)

#define _FL_PAR_MACSEC    (5)

#define _FL_X_TO_CMIC_INTR(bit) (1 << (bit)) /* Bit 0-31 */

#if _FL_SER_TEST_IP0
static _soc_fl_ser_reg_t vlan_xlate_regs[] = {
    { VLAN_XLATE_PARITY_STATUS_0r, "", INVALIDm},
    { VLAN_XLATE_PARITY_STATUS_1r, "", INVALIDm},
    { INVALIDr }
};
#endif /* _FL_SER_TEST_IP0 */

#if _FL_SER_TEST_IP1
static _soc_fl_ser_reg_t _soc_fl_l3_entry_regs[] = {
    { L3_ENTRY_PARITY_STATUS_0r, "", INVALIDm},
    { L3_ENTRY_PARITY_STATUS_1r, "", INVALIDm},
    { INVALIDr }
};

static _soc_fl_ser_reg_t _soc_fl_l2_entry_regs[] = {
    { L2_ENTRY_PARITY_STATUS_0r, "", INVALIDm},
    { L2_ENTRY_PARITY_STATUS_1r, "", INVALIDm},
    { INVALIDr }
};
#endif /* _FL_SER_TEST_IP1 */

#if _FL_SER_TEST_EP
static _soc_fl_ser_reg_t egr_vlan_xlate_regs[] = {
    { EGR_VLAN_XLATE_PARITY_STATUS_0r, "", INVALIDm},
    { EGR_VLAN_XLATE_PARITY_STATUS_1r, "", INVALIDm},
    { INVALIDr }
};
#endif /* _FL_SER_TEST_EP */

static _soc_fl_ser_info_t _soc_fl_ip0_ser_info[] = {
#if _FL_SER_TEST_IP0
    { _SOC_PARITY_TYPE_PARITY, NULL,
        PORT_TABLE_1BIT_ERR_INTRf, PORT_TABLE_1BIT_ERR_INTRf,
        PORT_TABm, "PORT_TAB PARITY",
        PORT_TABLE_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        PORT_TABLE_PARITY_STATUS_INTRr, NULL, PARITY_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        PORT_TABLE_ECC_INTRf, PORT_TABLE_ECC_INTRf,
        INVALIDm, "PORT_TAB ECC",
        PORT_TABLE_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        PORT_TABLE_ECC_STATUS_INTRr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SYSTEM_CONFIG_PAR_ERRf, SYSTEM_CONFIG_PAR_ERRf,
        SYSTEM_CONFIG_TABLEm, "SYSTEM_CONFIG_TABLE PARITY",
        SYSTEM_CONFIG_TABLE_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SYSTEM_CONFIG_TABLE_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SYSTEM_CONFIG_MODBASE_PAR_ERRf, SYSTEM_CONFIG_MODBASE_PAR_ERRf,
        SYSTEM_CONFIG_TABLE_MODBASEm, "SYSTEM_CONFIG_TABLE_MODBASE PARITY",
        SYSTEM_CONFIG_TABLE_MODBASE_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SYSTEM_CONFIG_TABLE_MODBASE_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SR_PORT_TABLE_1BIT_ERR_INTRf, SR_PORT_TABLE_1BIT_ERR_INTRf,
        SR_PORT_TABLEm, "SR_PORT_TABLE PARITY",
        SR_PORT_TABLE_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_PORT_TABLE_PARITY_STATUS_INTRr, NULL, PARITY_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        SR_PORT_TABLE_ECC_INTRf, SR_PORT_TABLE_ECC_INTRf,
        INVALIDm, "SR_PORT_TABLE ECC",
        SR_PORT_TABLE_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_PORT_TABLE_ECC_STATUS_INTRr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SR_LPORT_PROFILE_TABLE_1BIT_ERR_INTRf, SR_LPORT_PROFILE_TABLE_1BIT_ERR_INTRf,
        SR_LPORT_TABm, NULL,
        SR_LPORT_PROFILE_TABLE_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_LPORT_PROFILE_TABLE_PARITY_STATUSr, NULL, PARITY_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        SR_LPORT_PROFILE_TABLE_ECC_INTRf, SR_LPORT_PROFILE_TABLE_ECC_INTRf,
        INVALIDm, NULL,
        SR_LPORT_PROFILE_TABLE_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_LPORT_PROFILE_TABLE_ECC_STATUS_INTRr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SOURCE_TRUNK_MAP_PARITY_ERRf, SOURCE_TRUNK_MAP_PARITY_ERRf,
        SOURCE_TRUNK_MAP_TABLEm, NULL,
        SOURCE_TRUNK_MAP_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SOURCE_TRUNK_MAP_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SOURCE_TRUNK_MAP_MODBASE_PARITY_ERRf, SOURCE_TRUNK_MAP_MODBASE_PARITY_ERRf,
        SOURCE_TRUNK_MAP_MODBASEm, NULL,
        SOURCE_TRUNK_MAP_MODBASE_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SOURCE_TRUNK_MAP_MODBASE_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        ING_MOD_MAP_PAR_ERRf, ING_MOD_MAP_PAR_ERRf,
        ING_MOD_MAP_TABLEm, "ING_MOD_MAP",
        ING_MOD_MAP_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        ING_MOD_MAP_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        LPORT_TABLE_ECC_INTRf, LPORT_TABLE_ECC_INTRf,
        INVALIDm, "LPORT_TABLE/LPORT_PROFILE_TABLE ECC",
        LPORT_TABLE_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        LPORT_TABLE_ECC_STATUS_INTRr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        LPORT_TABLE_1BIT_ERR_INTRf, LPORT_TABLE_1BIT_ERR_INTRf,
        LPORT_TABm, "LPORT_TABLE/LPORT_PROFILE_TABLE PARITY",
        LPORT_TABLE_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        LPORT_TABLE_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        UDF_OFFSET_PAR_ERRf, UDF_OFFSET_PAR_ERRf,
        FP_UDF_OFFSETm, NULL,
        UDF_OFFSET_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        UDF_OFFSET_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        ING_ETAG_PCP_MAPPING_PAR_ERRf, ING_ETAG_PCP_MAPPING_PAR_ERRf,
        ING_ETAG_PCP_MAPPINGm, NULL,
        ING_ETAG_PCP_MAPPING_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        ING_ETAG_PCP_MAPPING_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        MY_STATION_TCAM_DATA_PAR_INTRf, MY_STATION_TCAM_DATA_PAR_INTRf,
        MY_STATION_TCAMm, NULL,
        MY_STATION_TCAM_DATA_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        MY_STATION_TCAM_DATA_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        MY_STATION_TCAM_DATA_PAR_INTRf, MY_STATION_TCAM_DATA_PAR_INTRf,
        MY_STATION_TCAM_DATA_ONLYm, NULL,
        MY_STATION_TCAM_DATA_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        MY_STATION_TCAM_DATA_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY_DUAL, NULL,
        VXLT_PAR_ERRf, VXLT_PAR_ERRf,
        VLAN_XLATEm, NULL,
        VLAN_XLATE_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, vlan_xlate_regs, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        VLAN_PROTOCOL_DATA_PARITY_ERRf, VLAN_PROTOCOL_DATA_PARITY_ERRf,
        VLAN_PROTOCOL_DATAm, NULL,
        VLAN_PROTOCOL_DATA_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        VLAN_PROTOCOL_DATA_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        VLAN_SUBNET_DATA_PARITY_ERRf, VLAN_SUBNET_DATA_PARITY_ERRf,
        VLAN_SUBNETm, NULL,
        VLAN_SUBNET_DATA_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        VLAN_SUBNET_DATA_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        VLAN_SUBNET_DATA_PARITY_ERRf, VLAN_SUBNET_DATA_PARITY_ERRf,
        VLAN_SUBNET_DATA_ONLYm, NULL,
        VLAN_SUBNET_DATA_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        VLAN_SUBNET_DATA_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        VFP_POLICY_PAR_ERRf, VFP_POLICY_PAR_ERRf,
        VFP_POLICY_TABLEm, NULL,
        VFP_POLICY_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        VFP_POLICY_PARITY_STATUS_INTRr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        LMEP_PAR_ERRf, LMEP_PAR_ERRf,
        LMEPm, NULL,
        LMEP_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        LMEP_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        LMEP_DA_PAR_ERRf, LMEP_DA_PAR_ERRf,
        LMEP_DAm, NULL,
        LMEP_DA_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        LMEP_DA_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        VLAN_PARITY_ERRf, VLAN_PARITY_ERRf,
        VLAN_TABm, NULL,
        VLAN_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        VLAN_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        L3_IIF_PAR_ERRf, L3_IIF_PAR_ERRf,
        L3_IIFm, NULL,
        L3_IIF_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        L3_IIF_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        VLAN_STG_PARITY_ERRf, VLAN_STG_PARITY_ERRf,
        STG_TABm, NULL,
        VLAN_STG_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        VLAN_STG_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        IARB_PKT_ECC_INTRf, IARB_PKT_ECC_INTRf,
        INVALIDm, "IARB_PKT ECC",
        IARB_PKT_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        IARB_PKT_ECC_STATUS_INTRr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        IARB_PKT_1BIT_ERR_INTRf, IARB_PKT_1BIT_ERR_INTRf,
        INVALIDm, "IARB_PKT PARITY",
        IARB_PKT_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        IARB_PKT_PARITY_STATUS_INTRr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        VFI_PAR_INTRf, VFI_PAR_INTRf,
        VFIm, "VFI PARITY",
        VFI_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        VFI_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
#endif /* _FL_SER_TEST_IP0 */
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

static _soc_fl_ser_info_t _soc_fl_ip1_ser_info[] = {
#if _FL_SER_TEST_IP1
    { _SOC_PARITY_TYPE_PARITY_DUAL, NULL,
        L3_ENTRY_PAR_ERRf, L3_ENTRY_PAR_ERRf,
        L3_ENTRY_ONLYm, NULL,
        L3_ENTRY_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, _soc_fl_l3_entry_regs, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        L2_USER_ENTRY_DATA_ONLY_PAR_ERRf, L2_USER_ENTRY_DATA_ONLY_PAR_ERRf,
        L2_USER_ENTRYm, NULL,
        L2_USER_ENTRY_DATA_ONLY_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        L2_USER_ENTRY_DATA_ONLY_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        L2_USER_ENTRY_DATA_ONLY_PAR_ERRf, L2_USER_ENTRY_DATA_ONLY_PAR_ERRf,
        L2_USER_ENTRY_DATA_ONLYm, NULL,
        L2_USER_ENTRY_DATA_ONLY_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        L2_USER_ENTRY_DATA_ONLY_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY_DUAL, NULL,
        L2_ENTRY_PAR_ERRf, L2_ENTRY_PAR_ERRf,
        L2Xm, "L2_ENTRY/L2_ENTRY_ONLY",
        L2_ENTRY_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, _soc_fl_l2_entry_regs, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY_DUAL, NULL,
        L2_ENTRY_PAR_ERRf, L2_ENTRY_PAR_ERRf,
        SR_L2_ENTRYm, "SR_L2_ENTRY",
        L2_ENTRY_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, _soc_fl_l2_entry_regs, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        RTAG7_FLOW_BASED_HASH_PARITY_INTRf, RTAG7_FLOW_BASED_HASH_PARITY_INTRf,
        RTAG7_FLOW_BASED_HASHm, NULL,
        RTAG7_FLOW_BASED_HASH_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        RTAG7_FLOW_BASED_HASH_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        RTAG7_PORT_BASED_HASH_PARITY_INTRf, RTAG7_PORT_BASED_HASH_PARITY_INTRf,
        RTAG7_PORT_BASED_HASHm, NULL,
        RTAG7_PORT_BASED_HASH_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        RTAG7_PORT_BASED_HASH_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    /* SR_RX_FLOW_ID_POOLm is 2 bit ECC (ECC_ERRf = 1) */
    { _SOC_PARITY_TYPE_ECC_DUAL, NULL,
        RX_FLOW_ID_ECC_STATUS_INTRf, RX_FLOW_ID_ECC_STATUS_INTRf,
        SR_RX_FLOW_ID_POOLm, "SR_RX_FLOW_ID_POOLm 2 bit ECC",
        SR_RX_FLOW_ID_POOL_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_RX_FLOW_ID_POOL_ECC_STATUS_INTRr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        RX_FLOW_ID_PARITY_STATUS_INTRf, RX_FLOW_ID_PARITY_STATUS_INTRf,
        INVALIDm, "SR_RX_FLOW_ID_POOL PARITY",
        SR_RX_FLOW_ID_POOL_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_RX_FLOW_ID_POOL_PARITY_STATUS_INTRr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    /* SR_TX_FLOW_ID_POOLm is 2 bit ECC (ECC_ERRf = 1) */
    { _SOC_PARITY_TYPE_ECC_DUAL, NULL,
        TX_FLOW_ID_ECC_STATUS_INTRf, TX_FLOW_ID_ECC_STATUS_INTRf,
        SR_TX_FLOW_ID_POOLm, "SR_TX_FLOW_ID_POOL 2 bit ECC",
        SR_TX_FLOW_ID_POOL_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_TX_FLOW_ID_POOL_ECC_STATUS_INTRr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        TX_FLOW_ID_PARITY_STATUS_INTRf, TX_FLOW_ID_PARITY_STATUS_INTRf,
        INVALIDm, "SR_TX_FLOW_ID_POOL PARITY",
        SR_TX_FLOW_ID_POOL_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_TX_FLOW_ID_POOL_PARITY_STATUS_INTRr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        L3_DEFIP_DATA_PAR_ERRf, L3_DEFIP_DATA_PAR_ERRf,
        L3_DEFIPm, NULL,
        L3_DEFIP_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        L3_DEFIP_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        L3_DEFIP_DATA_PAR_ERRf, L3_DEFIP_DATA_PAR_ERRf,
        L3_DEFIP_DATA_ONLYm, NULL,
        L3_DEFIP_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        L3_DEFIP_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
#endif /* _FL_SER_TEST_IP1 */
    { _SOC_PARITY_TYPE_NONE }, /* table terminator */
};

static _soc_fl_ser_info_t _soc_fl_ip2_ser_info[] = {
#if _FL_SER_TEST_IP2
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_MASK_PAR_ERRf, EGR_MASK_PAR_ERRf,
        EGR_MASKm, NULL,
        EGR_MASK_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_MASK_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_MASK_MODBASE_PAR_ERRf, EGR_MASK_MODBASE_PAR_ERRf,
        EGR_MASK_MODBASEm, NULL,
        EGR_MASK_MODBASE_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_MASK_MODBASE_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        RMEP_PAR_ERRf, RMEP_PAR_ERRf,
        RMEPm, NULL,
        RMEP_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        RMEP_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        TRUNK_GROUP_PAR_ERRf, TRUNK_GROUP_PAR_ERRf,
        TRUNK_GROUPm, NULL,
        TRUNK_GROUP_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        TRUNK_GROUP_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        L3_ECMP_PAR_ERRf, L3_ECMP_PAR_ERRf,
        L3_ECMPm, NULL,
        L3_ECMP_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        L3_ECMP_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        L3_ECMP_GROUP_PAR_ERRf, L3_ECMP_GROUP_PAR_ERRf,
        L3_ECMP_COUNTm, NULL,
        L3_ECMP_GROUP_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        L3_ECMP_GROUP_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        VLAN_PROFILE_2_PAR_ERRf, VLAN_PROFILE_2_PAR_ERRf,
        VLAN_PROFILE_2m, NULL,
        VLAN_PROFILE_2_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        VLAN_PROFILE_2_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        IFP_STORM_CONTROL_PAR_ERRf, IFP_STORM_CONTROL_PAR_ERRf,
        FP_STORM_CONTROL_METERSm, NULL,
        IFP_STORM_CONTROL_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        IFP_STORM_CONTROL_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        NONUCAST_TRUNK_BLOCK_MASK_PAR_ERRf, NONUCAST_TRUNK_BLOCK_MASK_PAR_ERRf,
        NONUCAST_TRUNK_BLOCK_MASKm, NULL,
        NONUCAST_TRUNK_BLOCK_MASK_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        NONUCAST_TRUNK_BLOCK_MASK_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SRC_MODID_BLOCK_PAR_ERRf, SRC_MODID_BLOCK_PAR_ERRf,
        SRC_MODID_BLOCKm, NULL,
        SRC_MODID_BLOCK_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SRC_MODID_BLOCK_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        IFP_METER_PAR_ERRf, IFP_METER_PAR_ERRf,
        FP_METER_TABLEm, NULL,
        IFP_METER_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        IFP_METER_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        INITIAL_L3_ECMP_GROUP_PAR_ERRf, INITIAL_L3_ECMP_GROUP_PAR_ERRf,
        INITIAL_L3_ECMP_GROUPm, NULL,
        INITIAL_L3_ECMP_GROUP_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        INITIAL_L3_ECMP_GROUP_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        INITIAL_L3_ECMP_PAR_ERRf, INITIAL_L3_ECMP_PAR_ERRf,
        INITIAL_L3_ECMPm, NULL,
        INITIAL_L3_ECMP_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        INITIAL_L3_ECMP_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        MODPORT_MAP_SW_PAR_ERRf, MODPORT_MAP_SW_PAR_ERRf,
        MODPORT_MAP_SWm, NULL,
        MODPORT_MAP_SW_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        MODPORT_MAP_SW_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        MODPORT_MAP_IM_PAR_ERRf, MODPORT_MAP_IM_PAR_ERRf,
        MODPORT_MAP_IMm, NULL,
        MODPORT_MAP_IM_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        MODPORT_MAP_IM_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        MODPORT_MAP_EM_PAR_ERRf, MODPORT_MAP_EM_PAR_ERRf,
        MODPORT_MAP_EMm, NULL,
        MODPORT_MAP_EM_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        MODPORT_MAP_EM_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        ALTERNATE_EMIRROR_BITMAP_PAR_ERRf, ALTERNATE_EMIRROR_BITMAP_PAR_ERRf,
        ALTERNATE_EMIRROR_BITMAPm, NULL,
        ALTERNATE_EMIRROR_BITMAP_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        ALTERNATE_EMIRROR_BITMAP_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        MAC_BLOCK_TABLE_PAR_ERRf, MAC_BLOCK_TABLE_PAR_ERRf,
        MAC_BLOCKm, "MAC_BLOCK_TABLE",
        MAC_BLOCK_TABLE_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        MAC_BLOCK_TABLE_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        TRUNK_EGR_MASK_PAR_ERRf, TRUNK_EGR_MASK_PAR_ERRf,
        TRUNK_EGR_MASKm, NULL,
        TRUNK_EGR_MASK_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        TRUNK_EGR_MASK_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        L3_MTU_VALUES_PAR_ERRf, L3_MTU_VALUES_PAR_ERRf,
        L3_MTU_VALUESm, NULL,
        L3_MTU_VALUES_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        L3_MTU_VALUES_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        OAM_LM_COUNTERS_PAR_ERRf, OAM_LM_COUNTERS_PAR_ERRf,
        OAM_LM_COUNTERSm, NULL,
        OAM_LM_COUNTERS_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        OAM_LM_COUNTERS_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        ING_VLAN_COUNTER_PAR_ERRf, ING_VLAN_COUNTER_PAR_ERRf,
        ING_VLAN_COUNTER_TABLEm, NULL,
        ING_VLAN_COUNTER_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        ING_VLAN_COUNTER_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        MAID_REDUCTION_PAR_ERRf, MAID_REDUCTION_PAR_ERRf,
        MAID_REDUCTIONm, NULL,
        MAID_REDUCTION_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        MAID_REDUCTION_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        TRUNK_BITMAP_TABLE_PAR_ERRf, TRUNK_BITMAP_TABLE_PAR_ERRf,
        TRUNK_BITMAPm, NULL,
        TRUNK_BITMAP_TABLE_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        TRUNK_BITMAP_TABLE_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        MA_STATE_PAR_ERRf, MA_STATE_PAR_ERRf,
        MA_STATEm, NULL,
        MA_STATE_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        MA_STATE_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        ING_NHOP_PAR_ERRf, ING_NHOP_PAR_ERRf,
        ING_L3_NEXT_HOPm, NULL,
        ING_L3_NEXT_HOP_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        ING_L3_NEXT_HOP_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        INITIAL_NHOP_PAR_ERRf, INITIAL_NHOP_PAR_ERRf,
        INITIAL_ING_L3_NEXT_HOPm, NULL,
        INITIAL_NHOP_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        INITIAL_NHOP_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        IFP_POLICY_PAR_ERRf, IFP_POLICY_PAR_ERRf,
        FP_POLICY_TABLEm, NULL,
        IFP_POLICY_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        IFP_POLICY_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        IFP_COUNTER_PAR_ERRf, IFP_COUNTER_PAR_ERRf,
        FP_COUNTER_TABLEm, NULL,
        IFP_COUNTER_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        IFP_COUNTER_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        MA_INDEX_PAR_ERRf, MA_INDEX_PAR_ERRf,
        MA_INDEXm, NULL,
        MA_INDEX_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        MA_INDEX_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        L3_IPMC_1_PAR_ERRf, L3_IPMC_1_PAR_ERRf,
        L3_IPMC_1m, NULL,
        L3_IPMC_1_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        L3_IPMC_1_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        L3_IPMC_PAR_ERRf, L3_IPMC_PAR_ERRf,
        L3_IPMCm, NULL,
        L3_IPMC_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        L3_IPMC_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        L2MC_PAR_ERRf, L2MC_PAR_ERRf,
        L2MCm, NULL,
        L2MC_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        L2MC_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
#endif /* _FL_SER_TEST_IP2 */
    { _SOC_PARITY_TYPE_NONE }, /* table terminator */
};

static _soc_fl_ser_info_t _soc_fl_ip2_sr_ser_info[] = {
#if _FL_SER_TEST_IP2_SR
    /* SR_MAC_PROXY_PROFILEm is 2 bit ECC (ECC_ERRf = 1) */
    { _SOC_PARITY_TYPE_ECC_DUAL, NULL,
        SR_MAC_PROXY_PROFILE_ECC_ERRf, SR_MAC_PROXY_PROFILE_ECC_ERRf,
        SR_MAC_PROXY_PROFILEm, "SR_MAC_PROXY_PROFILE 2 bit ECC",
        SR_MAC_PROXY_PROFILE_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_MAC_PROXY_PROFILE_ECC_STATUS_INTRr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SR_MAC_PROXY_PROFILE_1BIT_ERRf, SR_MAC_PROXY_PROFILE_1BIT_ERRf,
        INVALIDm, NULL,
        SR_MAC_PROXY_PROFILE_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_MAC_PROXY_PROFILE_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    /* SR_FLOW_ING_COUNTER_CONTROLm is 2 bit ECC (ECC_ERRf = 1) */
    { _SOC_PARITY_TYPE_ECC_DUAL, NULL,
        SR_FLOW_ING_COUNTER_CONTROL_ECC_ERRf, SR_FLOW_ING_COUNTER_CONTROL_ECC_ERRf,
        SR_FLOW_ING_COUNTER_CONTROLm, "SR_FLOW_ING_COUNTER_CONTROL 2 bit ECC",
        SR_FLOW_ING_COUNTER_CONTROL_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_FLOW_ING_COUNTER_CONTROL_ECC_STATUSr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SR_FLOW_ING_COUNTER_CONTROL_1BIT_ERRf, SR_FLOW_ING_COUNTER_CONTROL_1BIT_ERRf,
        INVALIDm, NULL,
        SR_FLOW_ING_COUNTER_CONTROL_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_FLOW_ING_COUNTER_CONTROL_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SR_FLOW_COUNT_POOL0_PAR_ERRf, SR_FLOW_COUNT_POOL0_PAR_ERRf,
        SR_FLOW_COUNT_POOL0m, NULL,
        SR_FLOW_COUNT_POOL0_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_FLOW_COUNT_POOL0_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SR_FLOW_COUNT_POOL1_PAR_ERRf, SR_FLOW_COUNT_POOL1_PAR_ERRf,
        SR_FLOW_COUNT_POOL1m, NULL,
        SR_FLOW_COUNT_POOL1_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_FLOW_COUNT_POOL1_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SR_FLOW_COUNT_POOL2_PAR_ERRf, SR_FLOW_COUNT_POOL2_PAR_ERRf,
        SR_FLOW_COUNT_POOL2m, NULL,
        SR_FLOW_COUNT_POOL2_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_FLOW_COUNT_POOL2_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SR_FLOW_COUNT_POOL3_PAR_ERRf, SR_FLOW_COUNT_POOL3_PAR_ERRf,
        SR_FLOW_COUNT_POOL3m, NULL,
        SR_FLOW_COUNT_POOL3_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_FLOW_COUNT_POOL3_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SR_FLOW_COUNT_POOL4_PAR_ERRf, SR_FLOW_COUNT_POOL4_PAR_ERRf,
        SR_FLOW_COUNT_POOL4m, NULL,
        SR_FLOW_COUNT_POOL4_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_FLOW_COUNT_POOL4_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SR_FLOW_COUNT_POOL5_PAR_ERRf, SR_FLOW_COUNT_POOL5_PAR_ERRf,
        SR_FLOW_COUNT_POOL5m, NULL,
        SR_FLOW_COUNT_POOL5_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_FLOW_COUNT_POOL5_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SR_FLOW_COUNT_POOL6_PAR_ERRf, SR_FLOW_COUNT_POOL6_PAR_ERRf,
        SR_FLOW_COUNT_POOL6m, NULL,
        SR_FLOW_COUNT_POOL6_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_FLOW_COUNT_POOL6_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SR_FLOW_COUNT_POOL7_PAR_ERRf, SR_FLOW_COUNT_POOL7_PAR_ERRf,
        SR_FLOW_COUNT_POOL7m, NULL,
        SR_FLOW_COUNT_POOL7_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_FLOW_COUNT_POOL7_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SR_PORT_COUNT_RX_PAR_ERRf, SR_PORT_COUNT_RX_PAR_ERRf,
        SR_PORT_COUNT_RXm, NULL,
        SR_PORT_COUNT_RX_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_PORT_COUNT_RX_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SR_PORT_COUNT_RX_TAGGED_PAR_ERRf, SR_PORT_COUNT_RX_TAGGED_PAR_ERRf,
        SR_PORT_COUNT_RX_TAGGEDm, "SR_PORT_COUNT_RX_TAGGED",
        SR_PORT_COUNT_RX_TAGGED_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_PORT_COUNT_RX_TAGGED_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SR_PORT_COUNT_RX_WRONG_LAN_PAR_ERRf, SR_PORT_COUNT_RX_WRONG_LAN_PAR_ERRf,
        SR_PORT_COUNT_RX_WRONG_LANm, "SR_PORT_COUNT_RX_WRONG_LAN",
        SR_PORT_COUNT_RX_WRONG_LAN_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_PORT_COUNT_RX_WRONG_LAN_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SR_PORT_COUNT_RX_ERROR_PAR_ERRf, SR_PORT_COUNT_RX_ERROR_PAR_ERRf,
        SR_PORT_COUNT_RX_ERRORm, "SR_PORT_COUNT_RX_ERROR",
        SR_PORT_COUNT_RX_ERROR_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_PORT_COUNT_RX_ERROR_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SR_PORT_COUNT_RX_TAG_ERROR_PAR_ERRf, SR_PORT_COUNT_RX_TAG_ERROR_PAR_ERRf,
        SR_PORT_COUNT_RX_TAG_ERRORm, NULL,
        SR_PORT_COUNT_RX_TAG_ERROR_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_PORT_COUNT_RX_TAG_ERROR_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SR_PORT_COUNT_RX_DUPLICATES_PAR_ERRf, SR_PORT_COUNT_RX_DUPLICATES_PAR_ERRf,
        SR_PORT_COUNT_RX_DUPLICATESm, NULL,
        SR_PORT_COUNT_RX_DUPLICATES_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_PORT_COUNT_RX_DUPLICATES_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SR_PORT_COUNT_RX_OUTOFORDER_PAR_ERRf, SR_PORT_COUNT_RX_OUTOFORDER_PAR_ERRf,
        SR_PORT_COUNT_RX_OUTOFORDERm, NULL,
        SR_PORT_COUNT_RX_OUTOFORDER_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_PORT_COUNT_RX_OUTOFORDER_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SR_PORT_COUNT_OWN_RX_PAR_ERRf, SR_PORT_COUNT_OWN_RX_PAR_ERRf,
        SR_PORT_COUNT_OWN_RXm, NULL,
        SR_PORT_COUNT_OWN_RX_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_PORT_COUNT_OWN_RX_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SR_PORT_COUNT_UNEXPECTED_FRAME_PAR_ERRf, SR_PORT_COUNT_UNEXPECTED_FRAME_PAR_ERRf,
        SR_PORT_COUNT_UNEXPECTED_FRAMEm, NULL,
        SR_PORT_COUNT_UNEXPECTED_FRAME_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_PORT_COUNT_UNEXPECTED_FRAME_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SR_PORT_MTU_ERROR_PAR_ERRf, SR_PORT_MTU_ERROR_PAR_ERRf,
        SR_PORT_MTU_ERRORm, NULL,
        SR_PORT_MTU_ERROR_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_PORT_MTU_ERROR_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SR_PORT_STU_ERROR_PAR_ERRf, SR_PORT_STU_ERROR_PAR_ERRf,
        SR_PORT_STU_ERRORm, NULL,
        SR_PORT_STU_ERROR_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_PORT_STU_ERROR_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SR_PORT_PROXY_MAC_ERROR_PAR_ERRf, SR_PORT_PROXY_MAC_ERROR_PAR_ERRf,
        SR_PORT_PROXY_MAC_ERRORm, NULL,
        SR_PORT_PROXY_MAC_ERROR_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_PORT_PROXY_MAC_ERROR_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SR_PORT_SN_WINDOW_RESET_PAR_ERRf, SR_PORT_SN_WINDOW_RESET_PAR_ERRf,
        SR_PORT_SN_WINDOW_RESETm, NULL,
        SR_PORT_SN_WINDOW_RESET_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_PORT_SN_WINDOW_RESET_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SR_PORT_COUNT_RX_PASSED_PAR_ERRf, SR_PORT_COUNT_RX_PASSED_PAR_ERRf,
        SR_PORT_COUNT_RX_PASSEDm, NULL,
        SR_PORT_COUNT_RX_PASSED_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_PORT_COUNT_RX_PASSED_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    /* TAF_GATE_ID_LOOKUPm is 2 bit ECC (ECC_ERRf = 1) */
    { _SOC_PARITY_TYPE_ECC_DUAL, NULL,
        TAF_GATE_ID_LOOKUP_ECC_2B_ERRORf, TAF_GATE_ID_LOOKUP_ECC_2B_ERRORf,
        TAF_GATE_ID_LOOKUPm, "TAF_GATE_ID_LOOKUP 2 bit ECC",
        TAF_GATE_ID_LOOKUP_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        TAF_GATE_ID_LOOKUP_ECC_STATUS_INTRr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
#endif /* _FL_SER_TEST_IP2_SR */
    { _SOC_PARITY_TYPE_NONE }, /* table terminator */
};

static _soc_fl_ser_info_t _soc_fl_ip2_sr_sn_ser_info[] = {
#if _FL_SER_TEST_IP2_SR_SN
    /* ING_MTU_CHECK_1m is 2 bit ECC (ECC_ERRf = 1) */
    { _SOC_PARITY_TYPE_ECC_DUAL, NULL,
        IFP_MTU_CHECK_1_ECC_ERRORf, IFP_MTU_CHECK_1_ECC_ERRORf,
        ING_MTU_CHECK_1m, NULL,
        IFP_MTU_CHECK_1_TABLE_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        IFP_MTU_CHECK_1_TABLE_ECC_STATUS_INTRr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        IFP_MTU_CHECK_1_PARITY_ERRORf, IFP_MTU_CHECK_1_PARITY_ERRORf,
        INVALIDm, NULL,
        IFP_MTU_CHECK_1_TABLE_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        IFP_MTU_CHECK_1_TABLE_PARITY_STATUS_INTRr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    /* ING_MTU_CHECK_2m is 2 bit ECC (ECC_ERRf = 1) */
    { _SOC_PARITY_TYPE_ECC_DUAL, NULL,
        IFP_MTU_CHECK_2_ECC_ERRORf, IFP_MTU_CHECK_2_ECC_ERRORf,
        ING_MTU_CHECK_2m, NULL,
        IFP_MTU_CHECK_2_TABLE_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        IFP_MTU_CHECK_2_TABLE_ECC_STATUS_INTRr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        IFP_MTU_CHECK_2_PARITY_ERRORf, IFP_MTU_CHECK_2_PARITY_ERRORf,
        INVALIDm, NULL,
        IFP_MTU_CHECK_2_TABLE_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        IFP_MTU_CHECK_2_TABLE_PARITY_STATUS_INTRr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC_DUAL, NULL,
        IFP_SR_TX_ECC_ERRORf, IFP_SR_TX_ECC_ERRORf,
        SR_TXm, NULL,
        IFP_SR_TX_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        IFP_SR_TX_TABLE_ECC_STATUS_INTRr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        IFP_SR_TX_PARITY_ERRORf, IFP_SR_TX_PARITY_ERRORf,
        INVALIDm, NULL,
        IFP_SR_TX_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        IFP_SR_TX_TABLE_PARITY_STATUS_INTRr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        IFP_SN_HISTORY_0_ECC_ERRORf, IFP_SN_HISTORY_0_ECC_ERRORf,
        INVALIDm, NULL,
        IFP_SR_RX_HISTORY_TABLE_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        IFP_SN_HISTORY_0_TABLE_ECC_STATUS_INTRr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        IFP_SN_HISTORY_1_ECC_ERRORf, IFP_SN_HISTORY_1_ECC_ERRORf,
        INVALIDm, NULL,
        IFP_SR_RX_HISTORY_TABLE_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        IFP_SN_HISTORY_1_TABLE_ECC_STATUS_INTRr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        IFP_SN_HISTORY_2_ECC_ERRORf, IFP_SN_HISTORY_2_ECC_ERRORf,
        INVALIDm, NULL,
        IFP_SR_RX_HISTORY_TABLE_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        IFP_SN_HISTORY_2_TABLE_ECC_STATUS_INTRr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        IFP_SN_HISTORY_3_ECC_ERRORf, IFP_SN_HISTORY_3_ECC_ERRORf,
        INVALIDm, NULL,
        IFP_SR_RX_HISTORY_TABLE_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        IFP_SN_HISTORY_3_TABLE_ECC_STATUS_INTRr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        IFP_SN_HISTORY_4_ECC_ERRORf, IFP_SN_HISTORY_4_ECC_ERRORf,
        INVALIDm, NULL,
        IFP_SR_RX_HISTORY_TABLE_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        IFP_SN_HISTORY_4_TABLE_ECC_STATUS_INTRr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        IFP_SN_HISTORY_5_ECC_ERRORf, IFP_SN_HISTORY_5_ECC_ERRORf,
        INVALIDm, NULL,
        IFP_SR_RX_HISTORY_TABLE_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        IFP_SN_HISTORY_5_TABLE_ECC_STATUS_INTRr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        IFP_SN_HISTORY_6_ECC_ERRORf, IFP_SN_HISTORY_6_ECC_ERRORf,
        INVALIDm, NULL,
        IFP_SR_RX_HISTORY_TABLE_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        IFP_SN_HISTORY_6_TABLE_ECC_STATUS_INTRr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        IFP_SN_HISTORY_7_ECC_ERRORf, IFP_SN_HISTORY_7_ECC_ERRORf,
        INVALIDm, NULL,
        IFP_SR_RX_HISTORY_TABLE_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        IFP_SN_HISTORY_7_TABLE_ECC_STATUS_INTRr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        IFP_SN_HISTORY_8_ECC_ERRORf, IFP_SN_HISTORY_8_ECC_ERRORf,
        INVALIDm, NULL,
        IFP_SR_RX_HISTORY_TABLE_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        IFP_SN_HISTORY_8_TABLE_ECC_STATUS_INTRr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        IFP_SN_HISTORY_9_ECC_ERRORf, IFP_SN_HISTORY_9_ECC_ERRORf,
        INVALIDm, NULL,
        IFP_SR_RX_HISTORY_TABLE_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        IFP_SN_HISTORY_9_TABLE_ECC_STATUS_INTRr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        IFP_SN_HISTORY_10_ECC_ERRORf, IFP_SN_HISTORY_10_ECC_ERRORf,
        INVALIDm, NULL,
        IFP_SR_RX_HISTORY_TABLE_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        IFP_SN_HISTORY_10_TABLE_ECC_STATUS_INTRr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        IFP_SN_HISTORY_11_ECC_ERRORf, IFP_SN_HISTORY_11_ECC_ERRORf,
        INVALIDm, NULL,
        IFP_SR_RX_HISTORY_TABLE_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        IFP_SN_HISTORY_11_TABLE_ECC_STATUS_INTRr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        IFP_SN_HISTORY_12_ECC_ERRORf, IFP_SN_HISTORY_12_ECC_ERRORf,
        INVALIDm, NULL,
        IFP_SR_RX_HISTORY_TABLE_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        IFP_SN_HISTORY_12_TABLE_ECC_STATUS_INTRr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        IFP_SN_HISTORY_13_ECC_ERRORf, IFP_SN_HISTORY_13_ECC_ERRORf,
        INVALIDm, NULL,
        IFP_SR_RX_HISTORY_TABLE_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        IFP_SN_HISTORY_13_TABLE_ECC_STATUS_INTRr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        IFP_SN_HISTORY_14_ECC_ERRORf, IFP_SN_HISTORY_14_ECC_ERRORf,
        INVALIDm, NULL,
        IFP_SR_RX_HISTORY_TABLE_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        IFP_SN_HISTORY_14_TABLE_ECC_STATUS_INTRr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        IFP_SN_HISTORY_15_ECC_ERRORf, IFP_SN_HISTORY_15_ECC_ERRORf,
        INVALIDm, NULL,
        IFP_SR_RX_HISTORY_TABLE_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        IFP_SN_HISTORY_15_TABLE_ECC_STATUS_INTRr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        IFP_SVM_METER_PARITY_ERRORf, IFP_SVM_METER_PARITY_ERRORf,
        SVM_METER_TABLEm, NULL,
        IFP_SVM_METER_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        IFP_SVM_METER_PARITY_STATUSr, NULL, PARITY_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        IFP_SVM_POLICY_PARITY_ERRORf, IFP_SVM_POLICY_PARITY_ERRORf,
        SVM_POLICY_TABLEm, NULL,
        IFP_SVM_POLICY_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        IFP_SVM_POLICY_PARITY_STATUSr, NULL, PARITY_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
#endif /* _FL_SER_TEST_IP2_SR_SN */
    { _SOC_PARITY_TYPE_NONE }, /* table terminator */
};

static _soc_fl_ser_info_t _soc_fl_ep_ser_info[] = {
#if _FL_SER_TEST_EP
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_EFP_POLICY_TABLE_PAR_ERRf, EGR_EFP_POLICY_TABLE_PAR_ERRf,
        EFP_POLICY_TABLEm, NULL,
        EFP_POLICY_TABLE_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EFP_POLICY_TABLE_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_EFP_METER_TABLE_PAR_ERRf, EGR_EFP_METER_TABLE_PAR_ERRf,
        EFP_METER_TABLEm, NULL,
        EFP_METER_TABLE_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EFP_METER_TABLE_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_MOD_MAP_PAR_ERRf, EGR_MOD_MAP_PAR_ERRf,
        EGR_MOD_MAP_TABLEm, NULL,
        EGR_EHCPM_PARITY_CONTROLr, EGR_MOD_MAPf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_MOD_MAP_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EFP_COUNTER_TABLE_PAR_ERRf, EFP_COUNTER_TABLE_PAR_ERRf,
        EFP_COUNTER_TABLEm, NULL,
        EGR_EDATABUF_PARITY_CONTROL_64r, EFP_COUNTER_TABLEf, NULL,
        INVALIDr, INVALIDf, NULL,
        EFP_COUNTER_TABLE_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_PERQ_XMT_COUNTERS_PAR_ERRf, EGR_PERQ_XMT_COUNTERS_PAR_ERRf,
        EGR_PERQ_XMT_COUNTERSm, NULL,
        EGR_EDATABUF_PARITY_CONTROL_64r, EGR_PERQ_XMT_COUNTERSf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_PERQ_XMT_COUNTERS_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_PER_Q_ECN_MARKED_PAR_ERRf, EGR_PER_Q_ECN_MARKED_PAR_ERRf,
        EGR_PER_Q_ECN_MARKEDm, NULL,
        EGR_EDATABUF_PARITY_CONTROL_64r, EGR_PER_Q_ECN_MARKEDf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_PER_Q_ECN_MARKED_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_VLAN_COUNTER_TABLE_PAR_ERRf, EGR_VLAN_COUNTER_TABLE_PAR_ERRf,
        EGR_VLAN_COUNTER_TABLEm, NULL,
        EGR_EDATABUF_PARITY_CONTROL_64r, EGR_VLAN_COUNTER_TABLEf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_VLAN_COUNTER_TABLE_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_ECN_COUNTER_PAR_ERRf, EGR_ECN_COUNTER_PAR_ERRf,
        EGR_ECN_COUNTERm, NULL,
        EGR_EDATABUF_PARITY_CONTROL_64r, EGR_ECN_COUNTERf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_ECN_COUNTER_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    /* SR_FLOW_EGR_COUNTER_CONTROLm is 2 bit ECC (PARITY_ERRf = 1) */
    { _SOC_PARITY_TYPE_ECC_DUAL, NULL,
        SR_FLOW_EGR_COUNTER_CONTROL_PAR_ERRf, SR_FLOW_EGR_COUNTER_CONTROL_PAR_ERRf,
        SR_FLOW_EGR_COUNTER_CONTROLm, NULL,
        EGR_EDATABUF_PARITY_CONTROL_64r, SR_FLOW_EGR_COUNTER_CONTROLf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_FLOW_EGR_COUNTER_CONTROL_PARITY_STATUSr, NULL, PARITY_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SR_PORT_COUNT_TX_TAGGED_PAR_ERRf, SR_PORT_COUNT_TX_TAGGED_PAR_ERRf,
        SR_PORT_COUNT_TX_TAGGEDm, NULL,
        EGR_EDATABUF_PARITY_CONTROL_64r, SR_PORT_COUNT_TX_TAGGEDf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_PORT_COUNT_TX_TAGGED_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SR_PORT_COUNT_TX_PAR_ERRf, SR_PORT_COUNT_TX_PAR_ERRf,
        SR_PORT_COUNT_TXm, NULL,
        EGR_EDATABUF_PARITY_CONTROL_64r, SR_PORT_COUNT_TXf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_PORT_COUNT_TX_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SR_PORT_TX_MTU_ERROR_PAR_ERRf, SR_PORT_TX_MTU_ERROR_PAR_ERRf,
        SR_PORT_TX_MTU_ERRORm, NULL,
        EGR_EDATABUF_PARITY_CONTROL_64r, SR_PORT_TX_MTU_ERRORf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_PORT_TX_MTU_ERROR_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SR_PORT_TX_STU_ERROR_PAR_ERRf, SR_PORT_TX_STU_ERROR_PAR_ERRf,
        SR_PORT_TX_STU_ERRORm, NULL,
        EGR_EDATABUF_PARITY_CONTROL_64r, SR_PORT_TX_STU_ERRORf, NULL,
        INVALIDr, INVALIDf, NULL,
        SR_PORT_TX_STU_ERROR_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_SR_FLOW_COUNT_POOL0_PAR_ERRf, EGR_SR_FLOW_COUNT_POOL0_PAR_ERRf,
        EGR_SR_FLOW_COUNT_POOL0m, NULL,
        EGR_EDATABUF_PARITY_CONTROL_64r, EGR_SR_FLOW_COUNT_POOL0f, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_SR_FLOW_COUNT_POOL0_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_SR_FLOW_COUNT_POOL1_PAR_ERRf, EGR_SR_FLOW_COUNT_POOL1_PAR_ERRf,
        EGR_SR_FLOW_COUNT_POOL1m, NULL,
        EGR_EDATABUF_PARITY_CONTROL_64r, EGR_SR_FLOW_COUNT_POOL1f, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_SR_FLOW_COUNT_POOL1_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_MFRAME_COUNTER_PAR_ERRf, EGR_MFRAME_COUNTER_PAR_ERRf,
        INVALIDm, NULL,
        EGR_EDATABUF_PARITY_CONTROL_64r, EGR_MFRAME_COUNTERf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_MFRAME_COUNTER_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_COUNTER, NULL,
        EGR_STATS_COUNTER_TABLE_PAR_ERRf, EGR_STATS_COUNTER_TABLE_PAR_ERRf,
        INVALIDm, "TDBGC0-TDBGC11",
        EGR_EDATABUF_PARITY_CONTROL_64r, EGR_STATS_COUNTER_TABLEf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_STATS_COUNTER_TABLE_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_RESI0_PAR_ERRf, EGR_RESI0_PAR_ERRf,
        INVALIDm, NULL,
        EGR_EDATABUF_PARITY_CONTROL_64r, EGR_RESI0f, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_RESI0_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_RESI14_PAR_ERRf, EGR_RESI14_PAR_ERRf,
        INVALIDm, NULL,
        EGR_EDATABUF_PARITY_CONTROL_64r, EGR_RESI14f, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_RESI14_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_CM_PAR_ERRf, EGR_CM_PAR_ERRf,
        INVALIDm, NULL,
        EGR_EDATABUF_PARITY_CONTROL_64r, EGR_CMf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_CM_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_GE0_PAR_ERRf, EGR_GE0_PAR_ERRf,
        INVALIDm, "EP_EDB_GE0_MEM",
        EGR_EDATABUF_PARITY_CONTROL_64r, EGR_GE0f, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_GE0_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_GE1_PAR_ERRf, EGR_GE1_PAR_ERRf,
        INVALIDm, "EP_EDB_GE1_MEM",
        EGR_EDATABUF_PARITY_CONTROL_64r, EGR_GE1f, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_GE1_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_GE2_PAR_ERRf, EGR_GE2_PAR_ERRf,
        INVALIDm, "EP_EDB_GE2_MEM",
        EGR_EDATABUF_PARITY_CONTROL_64r, EGR_GE2f, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_GE2_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_GE3_PAR_ERRf, EGR_GE3_PAR_ERRf,
        INVALIDm, "EP_EDB_GE3_MEM",
        EGR_EDATABUF_PARITY_CONTROL_64r, EGR_GE3f, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_GE3_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_GE4_PAR_ERRf, EGR_GE4_PAR_ERRf,
        INVALIDm, "EP_EDB_GE4_MEM",
        EGR_EDATABUF_PARITY_CONTROL_64r, EGR_GE4f, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_GE4_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_GE5_PAR_ERRf, EGR_GE5_PAR_ERRf,
        INVALIDm, "EP_EDB_GE5_MEM",
        EGR_EDATABUF_PARITY_CONTROL_64r, EGR_GE5f, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_GE5_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_XL0_PAR_ERRf, EGR_XL0_PAR_ERRf,
        INVALIDm, "EP_EDB_XL0_MEM",
        EGR_EDATABUF_PARITY_CONTROL_64r, EGR_XL0f, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_XL0_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_XL1_PAR_ERRf, EGR_XL1_PAR_ERRf,
        INVALIDm, "EP_EDB_XL1_MEM",
        EGR_EDATABUF_PARITY_CONTROL_64r, EGR_XL1f, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_XL1_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_XL2_PAR_ERRf, EGR_XL2_PAR_ERRf,
        INVALIDm, "EP_EDB_XL2_MEM",
        EGR_EDATABUF_PARITY_CONTROL_64r, EGR_XL2f, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_XL2_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_XL3_PAR_ERRf, EGR_XL3_PAR_ERRf,
        INVALIDm, "EP_EDB_XL3_MEM",
        EGR_EDATABUF_PARITY_CONTROL_64r, EGR_XL3f, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_XL3_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_XL4_PAR_ERRf, EGR_XL4_PAR_ERRf,
        INVALIDm, "EP_EDB_XL4_MEM",
        EGR_EDATABUF_PARITY_CONTROL_64r, EGR_XL4f, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_XL4_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_XL5_PAR_ERRf, EGR_XL5_PAR_ERRf,
        INVALIDm, "EP_EDB_XL5_MEM",
        EGR_EDATABUF_PARITY_CONTROL_64r, EGR_XL5f, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_XL5_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_CL0_PAR_ERRf, EGR_CL0_PAR_ERRf,
        INVALIDm, "EP_EDB_CL0_MEM",
        EGR_EDATABUF_PARITY_CONTROL_64r, EGR_CL0f, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_CL0_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_CL1_PAR_ERRf, EGR_CL1_PAR_ERRf,
        INVALIDm, "EP_EDB_CL1_MEM",
        EGR_EDATABUF_PARITY_CONTROL_64r, EGR_CL1f, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_CL1_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_CL2_PAR_ERRf, EGR_CL2_PAR_ERRf,
        INVALIDm, "EP_EDB_CL2_MEM",
        EGR_EDATABUF_PARITY_CONTROL_64r, EGR_CL2f, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_CL2_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_CL3_PAR_ERRf, EGR_CL3_PAR_ERRf,
        INVALIDm, "EP_EDB_CL3_MEM",
        EGR_EDATABUF_PARITY_CONTROL_64r, EGR_CL3f, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_CL3_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_NHOP_PAR_ERRf, EGR_NHOP_PAR_ERRf,
        EGR_L3_NEXT_HOPm, NULL,
        EGR_L3_NEXT_HOP_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_L3_NEXT_HOP_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_L3_INTF_PAR_ERRf, EGR_L3_INTF_PAR_ERRf,
        EGR_L3_INTFm, NULL,
        EGR_L3_INTF_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_L3_INTF_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_VLAN_PAR_ERRf, EGR_VLAN_PAR_ERRf,
        EGR_VLANm, NULL,
        EGR_VLAN_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_VLAN_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_VLAN_STG_PAR_ERRf, EGR_VLAN_STG_PAR_ERRf,
        EGR_VLAN_STGm, NULL,
        EGR_VLAN_STG_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_VLAN_STG_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY_DUAL, NULL,
        EGR_VXLT_PAR_ERRf, EGR_VXLT_PAR_ERRf,
        EGR_VLAN_XLATEm, NULL,
        EGR_VLAN_XLATE_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, egr_vlan_xlate_regs, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_ETAG_PCP_DE_MAPPING_PAR_ERRf, EGR_ETAG_PCP_DE_MAPPING_PAR_ERRf,
        EGR_ETAG_PCP_MAPPINGm, NULL,
        EGR_ETAG_PCP_DE_MAPPING_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_ETAG_PCP_DE_MAPPING_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_GPP_ATTRIBUTES_PAR_ERRf, EGR_GPP_ATTRIBUTES_PAR_ERRf,
        EGR_GPP_ATTRIBUTESm, NULL,
        EGR_GPP_ATTRIBUTES_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_GPP_ATTRIBUTES_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_GPP_ATTRIBUTES_MODBASE_PAR_ERRf, EGR_GPP_ATTRIBUTES_MODBASE_PAR_ERRf,
        EGR_GPP_ATTRIBUTES_MODBASEm, NULL,
        EGR_GPP_ATTRIBUTES_MODBASE_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_GPP_ATTRIBUTES_MODBASE_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_HEADER_ENCAP_DATA_PAR_ERRf, EGR_HEADER_ENCAP_DATA_PAR_ERRf,
        EGR_HEADER_ENCAP_DATAm, NULL,
        EGR_HEADER_ENCAP_DATA_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_HEADER_ENCAP_DATA_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_VXLAN_HEADER_PAR_ERRf, EGR_VXLAN_HEADER_PAR_ERRf,
        EGR_VXLAN_HEADERm, NULL,
        EGR_VXLAN_HEADER_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_VXLAN_HEADER_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_IP_TUNNEL_PAR_ERRf, EGR_IP_TUNNEL_PAR_ERRf,
        EGR_IP_TUNNELm, NULL,
        EGR_IP_TUNNEL_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_IP_TUNNEL_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    /* EGR_MTU_CHECKm is 2 bit ECC (PARITY_ERRf = 1) */
    { _SOC_PARITY_TYPE_ECC_DUAL, NULL,
        EGR_MTU_CHECK_PAR_ERRf, EGR_MTU_CHECK_PAR_ERRf,
        EGR_MTU_CHECKm, NULL,
        EGR_MTU_CHECK_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_MTU_CHECK_PARITY_STATUSr, NULL, PARITY_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    /* EGR_STU_CHECKm is 2 bit ECC (PARITY_ERRf = 1) */
    { _SOC_PARITY_TYPE_ECC_DUAL, NULL,
        EGR_STU_CHECK_PAR_ERRf, EGR_STU_CHECK_PAR_ERRf,
        EGR_STU_CHECKm, NULL,
        EGR_STU_CHECK_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_STU_CHECK_PARITY_STATUSr, NULL, PARITY_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        EGR_INITBUF_DBE_PAR_ERRf, EGR_INITBUF_DBE_PAR_ERRf,
        INVALIDm, "EGR_INITBUF Double-Bit error",
        EGR_INITBUF_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_INITBUF_ECC_STATUS_DBEr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
#endif /* _FL_SER_TEST_EP */
    { _SOC_PARITY_TYPE_NONE }, /* table terminator */
};

#if _FL_SER_TEST_MMU
static _soc_fl_ser_reg_t cbppkthdr_regs[] = {
    { CBPPKTHDR_ERRPTR0r, "CBPPKTHD[0:126]",INVALIDm},
    { CBPPKTHDR_ERRPTR1r, "CBPPKTHD[127:253]",INVALIDm},
    { CBPPKTHDR_ERRPTR2r, "CBPPKTHD[254:286]",INVALIDm},
    { CBPPKTHDR_ERRPTR3r, "CBPPKTHD[287:322]",INVALIDm},
    { INVALIDr }
};

static _soc_fl_ser_reg_t fl_soc_wred_regs[] = {
    { WRED_AVG_QSIZE_QG_PARITY_ERR_PTRr, "WRED AVG QSIZE QGROUP", MMU_WRED_AVG_QSIZE_QGROUPm},
    { WRED_CONFIG_QG_PARITY_ERR_PTRr, "WRED CONFIG QGROUP", MMU_WRED_CONFIG_QGROUPm},
    { WRED_MARK_THD_PARITY_ERR_PTRr, "WRED MARK THD", MMU_WRED_MARK_THDm},
    { WRED_DROP_PROFILE_GREEN_PARITY_ERR_PTRr, "WRED DROP PROFILE GREEN", MMU_WRED_DROP_PROFILE_GREENm},
    { WRED_DROP_PROFILE_YELLOW_PARITY_ERR_PTRr, "WRED_DROP_PROFILE YELLOW", MMU_WRED_DROP_PROFILE_YELLOWm},
    { WRED_DROP_PROFILE_RED_PARITY_ERR_PTRr, "WRED DROP PROFILE RED", MMU_WRED_DROP_PROFILE_REDm},
    { WRED_MARK_PROFILE_GREEN_PARITY_ERR_PTRr, "WRED MARK PROFILE GREEN", MMU_WRED_MARK_PROFILE_GREENm},
    { WRED_MARK_PROFILE_YELLOW_PARITY_ERR_PTRr, "WRED MARK PROFILE YELLOW", MMU_WRED_MARK_PROFILE_YELLOWm},
    { WRED_MARK_PROFILE_RED_PARITY_ERR_PTRr, "WRED MARK PROFILE RED", MMU_WRED_MARK_PROFILE_REDm},
    { WRED_AVG_QSIZE_PARITY_ERR_PTRr, "WRED AVG QSIZE", MMU_WRED_AVG_QSIZEm},
    { WRED_CONFIG_PARITY_ERR_PTRr, "WRED CONFIG", MMU_WRED_CONFIGm},
    { INVALIDr }
};

static _soc_fl_ser_reg_t ipmcgroup2to31_regs[] = {
    { IPMC_GROUP_ERR_PTRr, "", INVALIDm },
    { IPMC_GROUP_ERR_PTRr, "", INVALIDm },
    { IPMC_GROUP_ERR_PTRr, "", INVALIDm },
    { IPMC_GROUP_ERR_PTRr, "", INVALIDm },
    { IPMC_GROUP_ERR_PTRr, "", INVALIDm },
    { IPMC_GROUP_ERR_PTRr, "", INVALIDm },
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP6", MMU_IPMC_GROUP_TBL6m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP7", MMU_IPMC_GROUP_TBL7m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP8", MMU_IPMC_GROUP_TBL8m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP9", MMU_IPMC_GROUP_TBL9m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP10", MMU_IPMC_GROUP_TBL10m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP11", MMU_IPMC_GROUP_TBL11m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP12", MMU_IPMC_GROUP_TBL12m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP13", MMU_IPMC_GROUP_TBL13m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP14", MMU_IPMC_GROUP_TBL14m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP15", MMU_IPMC_GROUP_TBL15m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP16", MMU_IPMC_GROUP_TBL16m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP17", MMU_IPMC_GROUP_TBL17m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP18", MMU_IPMC_GROUP_TBL18m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP19", MMU_IPMC_GROUP_TBL19m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP20", MMU_IPMC_GROUP_TBL20m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP21", MMU_IPMC_GROUP_TBL21m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP22", MMU_IPMC_GROUP_TBL22m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP23", MMU_IPMC_GROUP_TBL23m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP24", MMU_IPMC_GROUP_TBL24m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP25", MMU_IPMC_GROUP_TBL25m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP26", MMU_IPMC_GROUP_TBL26m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP27", MMU_IPMC_GROUP_TBL27m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP28", MMU_IPMC_GROUP_TBL28m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP29", MMU_IPMC_GROUP_TBL29m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP30", MMU_IPMC_GROUP_TBL30m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP31", MMU_IPMC_GROUP_TBL31m},
    { INVALIDr }
};

static _soc_fl_ser_reg_t ipmcgroup32to63_regs[] = {
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP32", MMU_IPMC_GROUP_TBL32m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP33", MMU_IPMC_GROUP_TBL33m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP34", MMU_IPMC_GROUP_TBL34m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP35", MMU_IPMC_GROUP_TBL35m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP36", MMU_IPMC_GROUP_TBL36m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP37", MMU_IPMC_GROUP_TBL37m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP38", MMU_IPMC_GROUP_TBL38m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP39", MMU_IPMC_GROUP_TBL39m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP40", MMU_IPMC_GROUP_TBL40m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP41", MMU_IPMC_GROUP_TBL41m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP42", MMU_IPMC_GROUP_TBL42m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP43", MMU_IPMC_GROUP_TBL43m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP44", MMU_IPMC_GROUP_TBL44m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP45", MMU_IPMC_GROUP_TBL45m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP46", MMU_IPMC_GROUP_TBL46m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP47", MMU_IPMC_GROUP_TBL47m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP48", MMU_IPMC_GROUP_TBL48m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP49", MMU_IPMC_GROUP_TBL49m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP50", MMU_IPMC_GROUP_TBL50m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP51", MMU_IPMC_GROUP_TBL51m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP52", MMU_IPMC_GROUP_TBL52m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP53", MMU_IPMC_GROUP_TBL53m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP54", MMU_IPMC_GROUP_TBL54m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP55", MMU_IPMC_GROUP_TBL55m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP56", MMU_IPMC_GROUP_TBL56m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP57", MMU_IPMC_GROUP_TBL57m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP58", MMU_IPMC_GROUP_TBL58m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP59", MMU_IPMC_GROUP_TBL59m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP60", MMU_IPMC_GROUP_TBL60m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP61", MMU_IPMC_GROUP_TBL61m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP62", MMU_IPMC_GROUP_TBL62m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP63", MMU_IPMC_GROUP_TBL63m},
    { INVALIDr }
};

static _soc_fl_ser_reg_t ipmcgroup64to65_regs[] = {
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP64", MMU_IPMC_GROUP_TBL64m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP65", MMU_IPMC_GROUP_TBL65m},
    { INVALIDr }
};

static _soc_fl_ser_reg_t ipmcgroup_vld_regs[] = {
    { IPMC_GROUP_ERR_VLD_0r, "", INVALIDm },
    { IPMC_GROUP_ERR_VLD_1r, "", INVALIDm },
    { IPMC_GROUP_ERR_VLD_2r, "", INVALIDm },
    { INVALIDr }
};


static _soc_fl_ser_info_t _soc_fl_mmu_ser_info[] = {
    { _SOC_PARITY_TYPE_MMU_ECC, NULL,
        CELLECCERRORINTMASKf, CELLECCERRORf,
        INVALIDm, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        CBPCELLERRPTRr, NULL, INVALIDf,
        INVALIDr ,CELLECCERROR_CLRf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC, NULL,
        CBPCELLHDRPARITYERRORINTMASKf, CBPCELLHDRPARITYERRORf,
        INVALIDm, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        CBPCELLHDRPARITYERRPTRr, NULL, INVALIDf,
        INVALIDr, CBPCELLHDRPARITYERROR_CLRf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC, NULL,
        CFAPPARITYERRORINTMASKf, CFAPPARITYERRORf,
        INVALIDm, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        CFAPPARITYERRORPTRr, NULL, INVALIDf,
        INVALIDr, CFAPPARITYERROR_CLRf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC, NULL,
        CCPPARITYERRORINTMASKf, CCPPARITYERRORf,
        INVALIDm, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        CCPPARITYERRORPTRr, NULL, INVALIDf,
        INVALIDr, CCPPARITYERROR_CLRf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_CBPH, NULL,
        CBPPKTHDRPARITYERRORINTMASKf, CBPPKTHDRPARITYERRORf,
        INVALIDm, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, cbppkthdr_regs, INVALIDf,
        INVALIDr, CBPPKTHDRPARITYERROR_CLRf,
        CBPPKTHDR_ERR_VLDr, NULL, INVALIDr, CBPPKTHDR_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_XQ, NULL,
        XQPARITYERRORINTMASKf, XQPARITYERRORf,
        INVALIDm, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        XQPARITYERRORPTRr, NULL, INVALIDf,
        INVALIDr, XQPARITYERROR_CLRf,
        XQ_ERR_VLDr, NULL, XQ_MULTI_ERRr, XQ_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_XQ, NULL,
        XQFLLPARITYERRORINTMASKf, XQFLLPARITYERRORf,
        INVALIDm, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        XQFLLPARITYERRORPTRr, NULL, INVALIDf,
        INVALIDr, XQFLLPARITYERROR_CLRf,
        XQFLL_ERR_VLDr, NULL, XQFLL_MULTI_ERRr, XQFLL_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_PAR_E2EFC, NULL,
        E2EFCPARITYERRORINTMASKf, E2EFCPARITYERRORf,
        INVALIDm, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        E2EFC_PARITYERRORPTRr, NULL, INVALIDf,
        INVALIDr, E2EFCPARITYERROR_CLRf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_PAR_WRED, NULL,
        WREDPARITYERRORINTMASKf, WREDPARITYERRORf,
        MMU_WRED_MARK_THDm, "MMU_WRED_MARK_THDm",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, fl_soc_wred_regs, INVALIDf,
        INVALIDr, WREDPARITYERROR_CLRf,
        WRED_PARITY_ERR_STATUSr, NULL, INVALIDr, WRED_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_PAR_WRED, NULL,
        WREDPARITYERRORINTMASKf, WREDPARITYERRORf,
        MMU_WRED_DROP_PROFILE_GREENm, "MMU_WRED_DROP_PROFILE_GREENm",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, fl_soc_wred_regs, INVALIDf,
        INVALIDr, WREDPARITYERROR_CLRf,
        WRED_PARITY_ERR_STATUSr, NULL, INVALIDr, WRED_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_PAR_WRED, NULL,
        WREDPARITYERRORINTMASKf, WREDPARITYERRORf,
        MMU_WRED_DROP_PROFILE_YELLOWm, "MMU_WRED_DROP_PROFILE_YELLOWm",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, fl_soc_wred_regs, INVALIDf,
        INVALIDr, WREDPARITYERROR_CLRf,
        WRED_PARITY_ERR_STATUSr, NULL, INVALIDr, WRED_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_PAR_WRED, NULL,
        WREDPARITYERRORINTMASKf, WREDPARITYERRORf,
        MMU_WRED_DROP_PROFILE_REDm, "MMU_WRED_DROP_PROFILE_REDm",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, fl_soc_wred_regs, INVALIDf,
        INVALIDr, WREDPARITYERROR_CLRf,
        WRED_PARITY_ERR_STATUSr, NULL, INVALIDr, WRED_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_PAR_WRED, NULL,
        WREDPARITYERRORINTMASKf, WREDPARITYERRORf,
        MMU_WRED_MARK_PROFILE_GREENm, "MMU_WRED_MARK_PROFILE_GREENm",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, fl_soc_wred_regs, INVALIDf,
        INVALIDr, WREDPARITYERROR_CLRf,
        WRED_PARITY_ERR_STATUSr, NULL, INVALIDr, WRED_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_PAR_WRED, NULL,
        WREDPARITYERRORINTMASKf, WREDPARITYERRORf,
        MMU_WRED_MARK_PROFILE_YELLOWm, "MMU_WRED_MARK_PROFILE_YELLOWm",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, fl_soc_wred_regs, INVALIDf,
        INVALIDr, WREDPARITYERROR_CLRf,
        WRED_PARITY_ERR_STATUSr, NULL, INVALIDr, WRED_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_PAR_WRED, NULL,
        WREDPARITYERRORINTMASKf, WREDPARITYERRORf,
        MMU_WRED_MARK_PROFILE_REDm, "MMU_WRED_MARK_PROFILE_REDm",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, fl_soc_wred_regs, INVALIDf,
        INVALIDr, WREDPARITYERROR_CLRf,
        WRED_PARITY_ERR_STATUSr, NULL, INVALIDr, WRED_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_PAR_WRED, NULL,
        WREDPARITYERRORINTMASKf, WREDPARITYERRORf,
        MMU_WRED_AVG_QSIZEm, "MMU_WRED_AVG_QSIZEm",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, fl_soc_wred_regs, INVALIDf,
        INVALIDr, WREDPARITYERROR_CLRf,
        WRED_PARITY_ERR_STATUSr, NULL, INVALIDr, WRED_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_PAR_WRED, NULL,
        WREDPARITYERRORINTMASKf, WREDPARITYERRORf,
        MMU_WRED_CONFIGm, "MMU_WRED_CONFIGm",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, fl_soc_wred_regs, INVALIDf,
        INVALIDr, WREDPARITYERROR_CLRf,
        WRED_PARITY_ERR_STATUSr, NULL, INVALIDr, WRED_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_PAR_WRED, NULL,
        WREDPARITYERRORINTMASKf, WREDPARITYERRORf,
        MMU_WRED_AVG_QSIZE_QGROUPm, "MMU_WRED_AVG_QSIZE_QGROUPm",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, fl_soc_wred_regs, INVALIDf,
        INVALIDr, WREDPARITYERROR_CLRf,
        WRED_PARITY_ERR_STATUSr, NULL, INVALIDr, WRED_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_PAR_WRED, NULL,
        WREDPARITYERRORINTMASKf, WREDPARITYERRORf,
        MMU_WRED_CONFIG_QGROUPm, "MMU_WRED_CONFIG_QGROUPm",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, fl_soc_wred_regs, INVALIDf,
        INVALIDr, WREDPARITYERROR_CLRf,
        WRED_PARITY_ERR_STATUSr, NULL, INVALIDr, WRED_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL6m, "MMU_IPMC_GROUP_TBL2~31m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup2to31_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_0r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_0r, IPMC_GROUP_ERR_CLR_0r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL7m, "MMU_IPMC_GROUP_TBL2~31m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup2to31_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_0r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_0r, IPMC_GROUP_ERR_CLR_0r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL8m, "MMU_IPMC_GROUP_TBL2~31m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup2to31_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_0r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_0r, IPMC_GROUP_ERR_CLR_0r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL9m, "MMU_IPMC_GROUP_TBL2~31m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup2to31_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_0r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_0r, IPMC_GROUP_ERR_CLR_0r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL10m, "MMU_IPMC_GROUP_TBL2~31m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup2to31_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_0r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_0r, IPMC_GROUP_ERR_CLR_0r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL11m, "MMU_IPMC_GROUP_TBL2~31m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup2to31_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_0r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_0r, IPMC_GROUP_ERR_CLR_0r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL12m, "MMU_IPMC_GROUP_TBL2~31m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup2to31_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_0r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_0r, IPMC_GROUP_ERR_CLR_0r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL13m, "MMU_IPMC_GROUP_TBL2~31m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup2to31_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_0r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_0r, IPMC_GROUP_ERR_CLR_0r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL14m, "MMU_IPMC_GROUP_TBL2~31m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup2to31_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_0r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_0r, IPMC_GROUP_ERR_CLR_0r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL15m, "MMU_IPMC_GROUP_TBL2~31m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup2to31_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_0r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_0r, IPMC_GROUP_ERR_CLR_0r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL16m, "MMU_IPMC_GROUP_TBL2~31m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup2to31_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_0r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_0r, IPMC_GROUP_ERR_CLR_0r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL17m, "MMU_IPMC_GROUP_TBL2~31m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup2to31_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_0r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_0r, IPMC_GROUP_ERR_CLR_0r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL18m, "MMU_IPMC_GROUP_TBL2~31m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup2to31_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_0r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_0r, IPMC_GROUP_ERR_CLR_0r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL19m, "MMU_IPMC_GROUP_TBL2~31m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup2to31_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_0r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_0r, IPMC_GROUP_ERR_CLR_0r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL20m, "MMU_IPMC_GROUP_TBL2~31m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup2to31_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_0r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_0r, IPMC_GROUP_ERR_CLR_0r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL21m, "MMU_IPMC_GROUP_TBL2~31m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup2to31_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_0r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_0r, IPMC_GROUP_ERR_CLR_0r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL22m, "MMU_IPMC_GROUP_TBL2~31m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup2to31_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_0r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_0r, IPMC_GROUP_ERR_CLR_0r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL23m, "MMU_IPMC_GROUP_TBL2~31m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup2to31_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_0r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_0r, IPMC_GROUP_ERR_CLR_0r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL24m, "MMU_IPMC_GROUP_TBL2~31m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup2to31_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_0r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_0r, IPMC_GROUP_ERR_CLR_0r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL25m, "MMU_IPMC_GROUP_TBL2~31m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup2to31_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_0r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_0r, IPMC_GROUP_ERR_CLR_0r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL26m, "MMU_IPMC_GROUP_TBL2~31m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup2to31_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_0r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_0r, IPMC_GROUP_ERR_CLR_0r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL27m, "MMU_IPMC_GROUP_TBL2~31m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup2to31_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_0r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_0r, IPMC_GROUP_ERR_CLR_0r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL28m, "MMU_IPMC_GROUP_TBL2~31m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup2to31_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_0r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_0r, IPMC_GROUP_ERR_CLR_0r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL29m, "MMU_IPMC_GROUP_TBL2~31m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup2to31_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_0r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_0r, IPMC_GROUP_ERR_CLR_0r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL30m, "MMU_IPMC_GROUP_TBL2~31m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup2to31_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_0r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_0r, IPMC_GROUP_ERR_CLR_0r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL31m, "MMU_IPMC_GROUP_TBL2~31m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup2to31_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_0r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_0r, IPMC_GROUP_ERR_CLR_0r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL32m, "MMU_IPMC_GROUP_TBL32~63m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup32to63_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_1r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_1r, IPMC_GROUP_ERR_CLR_1r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL33m, "MMU_IPMC_GROUP_TBL32~63m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup32to63_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_1r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_1r, IPMC_GROUP_ERR_CLR_1r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL34m, "MMU_IPMC_GROUP_TBL32~63m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup32to63_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_1r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_1r, IPMC_GROUP_ERR_CLR_1r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL35m, "MMU_IPMC_GROUP_TBL32~63m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup32to63_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_1r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_1r, IPMC_GROUP_ERR_CLR_1r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL36m, "MMU_IPMC_GROUP_TBL32~63m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup32to63_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_1r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_1r, IPMC_GROUP_ERR_CLR_1r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL37m, "MMU_IPMC_GROUP_TBL32~63m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup32to63_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_1r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_1r, IPMC_GROUP_ERR_CLR_1r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL38m, "MMU_IPMC_GROUP_TBL32~63m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup32to63_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_1r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_1r, IPMC_GROUP_ERR_CLR_1r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL39m, "MMU_IPMC_GROUP_TBL32~63m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup32to63_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_1r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_1r, IPMC_GROUP_ERR_CLR_1r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL40m, "MMU_IPMC_GROUP_TBL32~63m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup32to63_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_1r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_1r, IPMC_GROUP_ERR_CLR_1r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL41m, "MMU_IPMC_GROUP_TBL32~63m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup32to63_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_1r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_1r, IPMC_GROUP_ERR_CLR_1r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL42m, "MMU_IPMC_GROUP_TBL32~63m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup32to63_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_1r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_1r, IPMC_GROUP_ERR_CLR_1r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL43m, "MMU_IPMC_GROUP_TBL32~63m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup32to63_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_1r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_1r, IPMC_GROUP_ERR_CLR_1r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL44m, "MMU_IPMC_GROUP_TBL32~63m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup32to63_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_1r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_1r, IPMC_GROUP_ERR_CLR_1r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL45m, "MMU_IPMC_GROUP_TBL32~63m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup32to63_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_1r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_1r, IPMC_GROUP_ERR_CLR_1r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL46m, "MMU_IPMC_GROUP_TBL32~63m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup32to63_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_1r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_1r, IPMC_GROUP_ERR_CLR_1r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL47m, "MMU_IPMC_GROUP_TBL32~63m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup32to63_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_1r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_1r, IPMC_GROUP_ERR_CLR_1r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL48m, "MMU_IPMC_GROUP_TBL32~63m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup32to63_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_1r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_1r, IPMC_GROUP_ERR_CLR_1r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL49m, "MMU_IPMC_GROUP_TBL32~63m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup32to63_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_1r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_1r, IPMC_GROUP_ERR_CLR_1r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL50m, "MMU_IPMC_GROUP_TBL32~63m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup32to63_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_1r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_1r, IPMC_GROUP_ERR_CLR_1r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL51m, "MMU_IPMC_GROUP_TBL32~63m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup32to63_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_1r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_1r, IPMC_GROUP_ERR_CLR_1r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL52m, "MMU_IPMC_GROUP_TBL32~63m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup32to63_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_1r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_1r, IPMC_GROUP_ERR_CLR_1r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL53m, "MMU_IPMC_GROUP_TBL32~63m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup32to63_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_1r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_1r, IPMC_GROUP_ERR_CLR_1r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL54m, "MMU_IPMC_GROUP_TBL32~63m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup32to63_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_1r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_1r, IPMC_GROUP_ERR_CLR_1r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL55m, "MMU_IPMC_GROUP_TBL32~63m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup32to63_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_1r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_1r, IPMC_GROUP_ERR_CLR_1r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL56m, "MMU_IPMC_GROUP_TBL32~63m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup32to63_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_1r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_1r, IPMC_GROUP_ERR_CLR_1r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL57m, "MMU_IPMC_GROUP_TBL32~63m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup32to63_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_1r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_1r, IPMC_GROUP_ERR_CLR_1r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL58m, "MMU_IPMC_GROUP_TBL32~63m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup32to63_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_1r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_1r, IPMC_GROUP_ERR_CLR_1r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL59m, "MMU_IPMC_GROUP_TBL32~63m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup32to63_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_1r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_1r, IPMC_GROUP_ERR_CLR_1r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL60m, "MMU_IPMC_GROUP_TBL32~63m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup32to63_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_1r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_1r, IPMC_GROUP_ERR_CLR_1r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL61m, "MMU_IPMC_GROUP_TBL32~63m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup32to63_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_1r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_1r, IPMC_GROUP_ERR_CLR_1r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL62m, "MMU_IPMC_GROUP_TBL32~63m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup32to63_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_1r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_1r, IPMC_GROUP_ERR_CLR_1r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL63m, "MMU_IPMC_GROUP_TBL32~63m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup32to63_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_1r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_1r, IPMC_GROUP_ERR_CLR_1r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL64m, "MMU_IPMC_GROUP_TBL64~65m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup64to65_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_2r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_2r, IPMC_GROUP_ERR_CLR_2r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL65m, "MMU_IPMC_GROUP_TBL64~65m",
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup64to65_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLD_2r, ipmcgroup_vld_regs,
        IPMC_GROUP_MULTI_ERR_2r, IPMC_GROUP_ERR_CLR_2r,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCVLAN, NULL,
        IPMCVLANXPORTPARITYERRORINTMASKf,IPMCVLANXPORTPARITYERRORf,
        MMU_IPMC_VLAN_TBLm, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        IPMCPARITYERRORPTRr, NULL, INVALIDf,
        INVALIDr, IPMCVLANXPORTPARITYERROR_CLRf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_NONE }, /* table terminator */
};
#endif /*_FL_SER_TEST_MMU */

static _soc_fl_ser_info_t _soc_fl_pgw_clport_ser_info[] = {
#if _FL_SER_TEST_CLPORT
    { _SOC_PARITY_TYPE_PORT_XL, _soc_fl_clport_ser_info,
        PM_INTRf, PM_INTRf,
        INVALIDm, "CL PORT INTR",
        INVALIDr, INVALIDf, NULL,
        CLPORT_INTR_ENABLEr, INVALIDf, NULL,
        CLPORT_INTR_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        TXFIFO0_DBEf, TXFIFO0_DBEf,
        INVALIDm, NULL,
        PGW_CL_ECC_CONTROLr, TXFIFO_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_CL_TXFIFO0_ECC_DBE_STATUSr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        TXFIFO1_DBEf, TXFIFO1_DBEf,
        INVALIDm, NULL,
        PGW_CL_ECC_CONTROLr, TXFIFO_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_CL_TXFIFO1_ECC_DBE_STATUSr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        TXFIFO2_DBEf, TXFIFO2_DBEf,
        INVALIDm, NULL,
        PGW_CL_ECC_CONTROLr, TXFIFO_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_CL_TXFIFO2_ECC_DBE_STATUSr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        TXFIFO3_DBEf, TXFIFO3_DBEf,
        INVALIDm, NULL,
        PGW_CL_ECC_CONTROLr, TXFIFO_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_CL_TXFIFO3_ECC_DBE_STATUSr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        RXFIFO0_DBEf, RXFIFO0_DBEf,
        INVALIDm, NULL,
        PGW_CL_ECC_CONTROLr, RXFIFO_ECC_ENABLEf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_CL_RXFIFO_ECC_DBE_STATUSr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
#endif /* _FL_SER_TEST_CLPORT */
    { _SOC_PARITY_TYPE_NONE }, /* table terminator */
};

#if _FL_SER_TEST_XLPORT
static _soc_fl_ser_info_t _soc_fl_xlport_ser_info[] = {
    { _SOC_PARITY_TYPE_ECC, NULL,
        MIB_RX_MEM_ERRf, MIB_RX_MEM_ERRf,
        INVALIDm, NULL,
        XLPORT_ECC_CONTROLr, MIB_RSC_MEM_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        XLPORT_MIB_RSC0_ECC_STATUSr, NULL, ECC_ERRf,
        XLPORT_INTR_STATUSr, MIB_RX_MEM_ERRf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        MIB_TX_MEM_ERRf, MIB_TX_MEM_ERRf,
        INVALIDm, NULL,
        XLPORT_ECC_CONTROLr, MIB_TSC_MEM_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        XLPORT_MIB_TSC0_ECC_STATUSr, NULL, ECC_ERRf,
        XLPORT_INTR_STATUSr, MIB_TX_MEM_ERRf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_NONE }, /* table terminator */
};
#endif /* _FL_SER_TEST_XLPORT */

static _soc_fl_ser_info_t _soc_fl_pgw_xlport_ser_info[] = {
#if _FL_SER_TEST_XLPORT
    { _SOC_PARITY_TYPE_PORT_XL, _soc_fl_xlport_ser_info,
        PM_INTRf, PM_INTRf,
        INVALIDm, "XL PORT INTR",
        INVALIDr, INVALIDf, NULL,
        XLPORT_INTR_ENABLEr, INVALIDf, NULL,
        XLPORT_INTR_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        RXFIFO_DBEf, RXFIFO_DBEf,
        INVALIDm, NULL,
        PGW_XL_ECC_CONTROLr, RXFIFO_ECC_ENABLEf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_XL_RXFIFO_ECC_DBE_STATUSr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        TXFIFO0_DBEf, TXFIFO0_DBEf,
        INVALIDm, NULL,
        PGW_XL_ECC_CONTROLr, TXFIFO_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_XL_TXFIFO0_ECC_DBE_STATUSr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        TXFIFO1_DBEf, TXFIFO1_DBEf,
        INVALIDm, NULL,
        PGW_XL_ECC_CONTROLr, TXFIFO_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_XL_TXFIFO1_ECC_DBE_STATUSr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        TXFIFO2_DBEf, TXFIFO2_DBEf,
        INVALIDm, NULL,
        PGW_XL_ECC_CONTROLr, TXFIFO_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_XL_TXFIFO2_ECC_DBE_STATUSr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        TXFIFO3_DBEf, TXFIFO3_DBEf,
        INVALIDm, NULL,
        PGW_XL_ECC_CONTROLr, TXFIFO_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_XL_TXFIFO3_ECC_DBE_STATUSr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        TXFIFO0_DBE_Hf, TXFIFO0_DBE_Hf,
        INVALIDm, NULL,
        PGW_XL_ECC_CONTROLr, TXFIFO_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_XL_TXFIFO0_ECC_DBE_STATUS_Hr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        TXFIFO1_DBE_Hf, TXFIFO1_DBE_Hf,
        INVALIDm, NULL,
        PGW_XL_ECC_CONTROLr, TXFIFO_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_XL_TXFIFO1_ECC_DBE_STATUS_Hr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        TXFIFO2_DBE_Hf, TXFIFO2_DBE_Hf,
        INVALIDm, NULL,
        PGW_XL_ECC_CONTROLr, TXFIFO_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_XL_TXFIFO2_ECC_DBE_STATUS_Hr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        TXFIFO3_DBE_Hf, TXFIFO3_DBE_Hf,
        INVALIDm, NULL,
        PGW_XL_ECC_CONTROLr, TXFIFO_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_XL_TXFIFO3_ECC_DBE_STATUS_Hr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
#endif /* _FL_SER_TEST_XLPORT */
    { _SOC_PARITY_TYPE_NONE }, /* table terminator */
};

static _soc_fl_ser_info_t _soc_fl_pgw_gport_ser_info[] = {
#if _FL_SER_TEST_GPORT
    { _SOC_PARITY_TYPE_ECC, NULL,
        TXFIFO0_DBEf, TXFIFO0_DBEf,
        INVALIDm, NULL,
        PGW_GE_ECC_CONTROLr, TXFIFO_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_GE_TXFIFO0_ECC_DBE_STATUSr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        TXFIFO1_DBEf, TXFIFO1_DBEf,
        INVALIDm, NULL,
        PGW_GE_ECC_CONTROLr, TXFIFO_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_GE_TXFIFO1_ECC_DBE_STATUSr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        TXFIFO2_DBEf, TXFIFO2_DBEf,
        INVALIDm, NULL,
        PGW_GE_ECC_CONTROLr, TXFIFO_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_GE_TXFIFO2_ECC_DBE_STATUSr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        TXFIFO3_DBEf, TXFIFO3_DBEf,
        INVALIDm, NULL,
        PGW_GE_ECC_CONTROLr, TXFIFO_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_GE_TXFIFO3_ECC_DBE_STATUSr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        RXFIFO0_DBEf, RXFIFO0_DBEf,
        INVALIDm, NULL,
        PGW_GE_ECC_CONTROLr, RXFIFO_ECC_ENABLEf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_GE_RXFIFO0_ECC_DBE_STATUSr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        RXFIFO1_DBEf, RXFIFO1_DBEf,
        INVALIDm, NULL,
        PGW_GE_ECC_CONTROLr, RXFIFO_ECC_ENABLEf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_GE_RXFIFO1_ECC_DBE_STATUSr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        RXFIFO2_DBEf, RXFIFO2_DBEf,
        INVALIDm, NULL,
        PGW_GE_ECC_CONTROLr, RXFIFO_ECC_ENABLEf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_GE_RXFIFO2_ECC_DBE_STATUSr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        RXFIFO3_DBEf, RXFIFO3_DBEf,
        INVALIDm, NULL,
        PGW_GE_ECC_CONTROLr, RXFIFO_ECC_ENABLEf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_GE_RXFIFO3_ECC_DBE_STATUSr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
#endif /* _FL_SER_TEST_GPORT */
    { _SOC_PARITY_TYPE_NONE }, /* table terminator */
};

static _soc_fl_ser_info_t _soc_fl_mmu_top_ser_info[] = {
#if _FL_SER_TEST_MMU
    { _SOC_PARITY_TYPE_MMU_SER, _soc_fl_mmu_ser_info,
        INVALIDf, INVALIDf,
        INVALIDm, "MMU MEM PAR",
        MISCCONFIGr, PARITY_CHECK_ENf, NULL,
        MEMFAILINTMASKr, INVALIDf, NULL,
        MEMFAILINTSTATUSr, NULL, INVALIDf,
        MEMFAILINT_CLRr, INVALIDf,
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
#endif /* _FL_SER_TEST_MMU */
    { _SOC_PARITY_TYPE_NONE }, /* table terminator */
};

#ifdef INCLUDE_XFLOW_MACSEC
static soc_field_t _soc_fl_sc_tbl_intr_flds[] = {
    SC_TABLE_SINGLE_BIT_ERRf,
    SC_TABLE_DOUBLE_BIT_ERRf,
    INVALIDf
};

static soc_field_t _soc_fl_sa_tbl_intr_flds[] = {
    SA_TABLE_SINGLE_BIT_ERRf,
    SA_TABLE_DOUBLE_BIT_ERRf,
    INVALIDf
};

static soc_field_t _soc_fl_hash_tbl_intr_flds[] = {
    HASH_TABLE_SINGLE_BIT_ERRf,
    HASH_TABLE_DOUBLE_BIT_ERRf,
    INVALIDf
};

static soc_field_t _soc_fl_sp_policy_tbl_intr_flds[] = {
    SP_POLICY_SINGLE_BIT_ERRf,
    SP_POLICY_DOUBLE_BIT_ERRf,
    INVALIDf
};

static soc_field_t _soc_fl_sp_map_tbl_intr_flds[] = {
    SP_MAP_SINGLE_BIT_ERRf,
    SP_MAP_SINGLE_BIT_ERRf,
    INVALIDf
};

static soc_field_t _soc_fl_mib_misc_tbl_intr_flds[] = {
    ESEC_MIB_MISC_SINGLE_BIT_ERRORf,
    ESEC_MIB_MISC_DOUBLE_BIT_ERRORf,
    INVALIDf
};

static soc_field_t _soc_fl_mib_sc_unctrl_tbl_intr_flds[] = {
    ESEC_MIB_SC_UNCTRL_SINGLE_BIT_ERRORf,
    ESEC_MIB_SC_UNCTRL_DOUBLE_BIT_ERRORf,
    INVALIDf
};

static soc_field_t _soc_fl_mib_sc_ctrl_tbl_intr_flds[] = {
    ESEC_MIB_SC_CTRL_SINGLE_BIT_ERRORf,
    ESEC_MIB_SC_CTRL_DOUBLE_BIT_ERRORf,
    INVALIDf
};

static soc_field_t _soc_fl_mib_sc_tbl_intr_flds[] = {
    ESEC_MIB_SC_SINGLE_BIT_ERRORf,
    ESEC_MIB_SC_DOUBLE_BIT_ERRORf,
    INVALIDf
};

static soc_field_t _soc_fl_mib_sa_tbl_intr_flds[] = {
    ESEC_MIB_SA_SINGLE_BIT_ERRORf,
    ESEC_MIB_SA_SINGLE_BIT_ERRORf,
    INVALIDf
};

static soc_field_t _soc_fl_mib_sptcam_hit_count_intr_flds[] = {
    ISEC_SPTCAM_HIT_COUNT_SINGLE_BIT_ERRORf,
    ISEC_SPTCAM_HIT_COUNT_DOUBLE_BIT_ERRORf,
    INVALIDf
};

static soc_field_t _soc_fl_mib_sctcam_hit_count_intr_flds[] = {
    ISEC_SCTCAM_HIT_COUNT_SINGLE_BIT_ERRORf,
    ISEC_SCTCAM_HIT_COUNT_DOUBLE_BIT_ERRORf,
    INVALIDf
};

static soc_field_t _soc_fl_mib_port_counter_intr_flds[] = {
    ISEC_PORT_COUNTERS_SINGLE_BIT_ERRORf,
    ISEC_PORT_COUNTERS_DOUBLE_BIT_ERRORf,
    INVALIDf
};

static soc_field_t _soc_fl_mib_sp_unctrl_intr_flds[] = {
    ISEC_MIB_SP_UNCTRL_SINGLE_BIT_ERRORf,
    ISEC_MIB_SP_UNCTRL_DOUBLE_BIT_ERRORf,
    INVALIDf
};

static soc_field_t _soc_fl_mib_sp_ctrl_1_intr_flds[] = {
    ISEC_MIB_SP_CTRL_1_SINGLE_BIT_ERRORf,
    ISEC_MIB_SP_CTRL_1_DOUBLE_BIT_ERRORf,
    INVALIDf
};

static soc_field_t _soc_fl_mib_sp_ctrl_2_intr_flds[] = {
    ISEC_MIB_SP_CTRL_2_SINGLE_BIT_ERRORf,
    ISEC_MIB_SP_CTRL_2_DOUBLE_BIT_ERRORf,
    INVALIDf
};

static soc_field_t _soc_fl_isec_mib_sc_intr_flds[] = {
    ISEC_MIB_SC_SINGLE_BIT_ERRORf,
    ISEC_MIB_SC_DOUBLE_BIT_ERRORf,
    INVALIDf
};

static soc_field_t _soc_fl_isec_mib_sa_intr_flds[] = {
    ISEC_MIB_SA_SINGLE_BIT_ERRORf,
    ISEC_MIB_SA_DOUBLE_BIT_ERRORf,
    INVALIDf
};

static _soc_fl_ser_info_t _soc_fl_macsec_ser_info[] = {
#if _FL_SER_TEST_MACSEC
    { _SOC_PARITY_TYPE_MACSEC_ECC, NULL,
        ESEC_SC_TABLE_SER_EVENTf, ESEC_SC_TABLE_SER_EVENTf,
        ESEC_SC_TABLEm, "ESEC_SC_TABLE 2 bit ECC",
        MACSEC_ECC_CTRLr, EG_SC_TBL_ECC_ENf, NULL,
        ESEC_INTR_ENABLEr, INVALIDf, _soc_fl_sc_tbl_intr_flds,
        ESEC_SC_TABLE_ECC_STATUSr, NULL, SINGLE_BIT_ERRf,
        INVALIDr, SECTAGLOCATIONf, /* Reuse as ECC test field. */
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_MACSEC_ECC, NULL,
        ISEC_SC_TABLE_SER_EVENTf, ISEC_SC_TABLE_SER_EVENTf,
        ISEC_SC_TABLEm, "ISEC_SC_TABLE 2 bit ECC",
        MACSEC_ECC_CTRLr, IG_SC_TBL_ECC_ENf, NULL,
        ISEC_INTR_ENABLEr, INVALIDf, _soc_fl_sc_tbl_intr_flds,
        ISEC_SC_TABLE_ECC_STATUSr, NULL, SINGLE_BIT_ERRf,
        INVALIDr, CONFIDENTIALITYOFFSETf, /* Reuse as ECC test field. */
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_MACSEC_ECC, NULL,
        ESEC_SA_TABLE_SER_EVENTf, ESEC_SA_TABLE_SER_EVENTf,
        ESEC_SA_TABLEm, "ESEC_SA_TABLE 2 bit ECC",
        MACSEC_ECC_CTRLr, EG_SA_TBL_ECC_ENf, NULL,
        ESEC_INTR_ENABLEr, INVALIDf, _soc_fl_sa_tbl_intr_flds,
        ESEC_SA_TABLE_ECC_STATUSr, NULL, SINGLE_BIT_ERRf,
        INVALIDr, SAKf, /* Reuse as ECC test field. */
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_MACSEC_ECC, NULL,
        ISEC_SA_TABLE_SER_EVENTf, ISEC_SA_TABLE_SER_EVENTf,
        ISEC_SA_TABLEm, "ISEC_SA_TABLE 2 bit ECC",
        MACSEC_ECC_CTRLr, IG_SA_TBL_ECC_ENf, NULL,
        ISEC_INTR_ENABLEr, INVALIDf, _soc_fl_sa_tbl_intr_flds,
        ISEC_SA_TABLE_ECC_STATUSr, NULL, SINGLE_BIT_ERRf,
        INVALIDr, SAKf, /* Reuse as ECC test field. */
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_MACSEC_ECC, NULL,
        ESEC_HASH_TABLE_SER_EVENTf, ESEC_HASH_TABLE_SER_EVENTf,
        ESEC_SA_HASH_TABLEm, "ESEC_SA_HASH_TABLE 2 bit ECC",
        MACSEC_ECC_CTRLr, EG_SA_TBL_ECC_ENf, NULL,
        ESEC_INTR_ENABLEr, INVALIDf, _soc_fl_hash_tbl_intr_flds,
        ESEC_HASH_TABLE_ECC_STATUSr, NULL, SINGLE_BIT_ERRf,
        INVALIDr, HASHf, /* Reuse as ECC test field. */
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_MACSEC_ECC, NULL,
        ISEC_HASH_TABLE_SER_EVENTf, ISEC_HASH_TABLE_SER_EVENTf,
        ISEC_SA_HASH_TABLEm, "ISEC_SA_HASH_TABLE 2 bit ECC",
        MACSEC_ECC_CTRLr, IG_SA_TBL_ECC_ENf, NULL,
        ISEC_INTR_ENABLEr, INVALIDf, _soc_fl_hash_tbl_intr_flds,
        ISEC_HASH_TABLE_ECC_STATUSr, NULL, SINGLE_BIT_ERRf,
        INVALIDr, HASHf, /* Reuse as ECC test field. */
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_MACSEC_ECC, NULL,
        ISEC_SP_POLICY_SER_EVENTf, ISEC_SP_POLICY_SER_EVENTf,
        SUB_PORT_POLICY_TABLEm, "SUB_PORT_POLICY_TABLE 2 bit ECC",
        MACSEC_ECC_CTRLr, IG_SP_POL_TBL_ECC_ENf, NULL,
        ISEC_INTR_ENABLEr, INVALIDf, _soc_fl_sp_policy_tbl_intr_flds,
        ISEC_SP_POLICY_ECC_STATUSr, NULL, SINGLE_BIT_ERRf,
        INVALIDr, UNTAG_CTRL_PORT_ENf, /* Reuse as ECC test field. */
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_MACSEC_ECC, NULL,
        ISEC_SP_MAP_SER_EVENTf, ISEC_SP_MAP_SER_EVENTf,
        SUB_PORT_MAP_TABLEm, "SUB_PORT_MAP_TABLE 2 bit ECC",
        MACSEC_ECC_CTRLr, IG_SP_MAP_TBL_ECC_ENf, NULL,
        ISEC_INTR_ENABLEr, INVALIDf, _soc_fl_sp_map_tbl_intr_flds,
        ISEC_SP_MAP_ECC_STATUSr, NULL, SINGLE_BIT_ERRf,
        INVALIDr, MANAGEMENT_PACKETf, /* Reuse as ECC test field. */
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    /* MACSEC MIBS */
    { _SOC_PARITY_TYPE_MACSEC_ECC, NULL,
        MIB_SER_EVENTf, MIB_SER_EVENTf,
        ESEC_MIB_MISCm, "ESEC_MIB_MISC 2 bit ECC",
        MACSEC_ECC_CTRLr, MIB_ECC_ENf, NULL,
        MACSEC_MIB_INTR_ENABLEr, INVALIDf, _soc_fl_mib_misc_tbl_intr_flds,
        ESEC_MIB_MISC_ECC_STATUSr, NULL, SINGLE_BIT_ERRf,
        INVALIDr, BADCUSTOMHDRf, /* Reuse as ECC test field. */
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_MACSEC_ECC, NULL,
        MIB_SER_EVENTf, MIB_SER_EVENTf,
        ESEC_MIB_SC_UNCTRLm, "ESEC_MIB_SC_UNCTRLm 2 bit ECC",
        MACSEC_ECC_CTRLr, MIB_ECC_ENf, NULL,
        MACSEC_MIB_INTR_ENABLEr, INVALIDf, _soc_fl_mib_sc_unctrl_tbl_intr_flds,
        ESEC_MIB_SC_UNCTRL_ECC_STATUSr, NULL, SINGLE_BIT_ERRf,
        INVALIDr, OUTERRORSf, /* Reuse as ECC test field. */
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_MACSEC_ECC, NULL,
        MIB_SER_EVENTf, MIB_SER_EVENTf,
        ESEC_MIB_SC_CTRLm, "ESEC_MIB_SC_CTRLm 2 bit ECC",
        MACSEC_ECC_CTRLr, MIB_ECC_ENf, NULL,
        MACSEC_MIB_INTR_ENABLEr, INVALIDf, _soc_fl_mib_sc_ctrl_tbl_intr_flds,
        ESEC_MIB_SC_UNCTRL_ECC_STATUSr, NULL, SINGLE_BIT_ERRf,
        INVALIDr, OUTERRORSf, /* Reuse as ECC test field. */
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_MACSEC_ECC, NULL,
        MIB_SER_EVENTf, MIB_SER_EVENTf,
        ESEC_MIB_SCm, "ESEC_MIB_SC 2 bit ECC",
        MACSEC_ECC_CTRLr, MIB_ECC_ENf, NULL,
        MACSEC_MIB_INTR_ENABLEr, INVALIDf, _soc_fl_mib_sc_tbl_intr_flds,
        ESEC_MIB_SC_ECC_STATUSr, NULL, SINGLE_BIT_ERRf,
        INVALIDr, SECYSTATSTXTOOLONGPKTSf, /* Reuse as ECC test field. */
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_MACSEC_ECC, NULL,
        MIB_SER_EVENTf, MIB_SER_EVENTf,
        ESEC_MIB_SAm, "ESEC_MIB_SA 2 bit ECC",
        MACSEC_ECC_CTRLr, MIB_ECC_ENf, NULL,
        MACSEC_MIB_INTR_ENABLEr, INVALIDf, _soc_fl_mib_sa_tbl_intr_flds,
        ESEC_MIB_SA_ECC_STATUSr, NULL, SINGLE_BIT_ERRf,
        INVALIDr, SECYTXSASTATSENCRYPTEDPKTSf, /* Reuse as ECC test field. */
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_MACSEC_ECC, NULL,
        MIB_SER_EVENTf, MIB_SER_EVENTf,
        ISEC_SPTCAM_HIT_COUNTm, "ISEC_SPTCAM_HIT_COUNT 2 bit ECC",
        MACSEC_ECC_CTRLr, MIB_ECC_ENf, NULL,
        MACSEC_MIB_INTR_ENABLEr, INVALIDf, _soc_fl_mib_sptcam_hit_count_intr_flds,
        ISEC_SPTCAM_HIT_COUNT_ECC_STATUSr, NULL, SINGLE_BIT_ERRf,
        INVALIDr, SPTCAM_HITf, /* Reuse as ECC test field. */
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_MACSEC_ECC, NULL,
        MIB_SER_EVENTf, MIB_SER_EVENTf,
        ISEC_SCTCAM_HIT_COUNTm, "ISEC_SCTCAM_HIT_COUNT 2 bit ECC",
        MACSEC_ECC_CTRLr, MIB_ECC_ENf, NULL,
        MACSEC_MIB_INTR_ENABLEr, INVALIDf, _soc_fl_mib_sctcam_hit_count_intr_flds,
        ISEC_SCTCAM_HIT_COUNT_ECC_STATUSr, NULL, SINGLE_BIT_ERRf,
        INVALIDr, SCTCAM_HITf, /* Reuse as ECC test field. */
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_MACSEC_ECC, NULL,
        MIB_SER_EVENTf, MIB_SER_EVENTf,
        ISEC_PORT_COUNTERSm, "ISEC_PORT_COUNTERS 2 bit ECC",
        MACSEC_ECC_CTRLr, MIB_ECC_ENf, NULL,
        MACSEC_MIB_INTR_ENABLEr, INVALIDf, _soc_fl_mib_port_counter_intr_flds,
        ISEC_PORT_COUNTERS_ECC_STATUSr, NULL, SINGLE_BIT_ERRf,
        INVALIDr, PKTDROPf, /* Reuse as ECC test field. */
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_MACSEC_ECC, NULL,
        MIB_SER_EVENTf, MIB_SER_EVENTf,
        ISEC_MIB_SP_UNCTRLm, "ISEC_MIB_SP_UNCTRL 2 bit ECC",
        MACSEC_ECC_CTRLr, MIB_ECC_ENf, NULL,
        MACSEC_MIB_INTR_ENABLEr, INVALIDf, _soc_fl_mib_sp_unctrl_intr_flds,
        ISEC_MIB_SP_UNCTRL_ECC_STATUSr, NULL, SINGLE_BIT_ERRf,
        INVALIDr, INOCTETSf, /* Reuse as ECC test field. */
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_MACSEC_ECC, NULL,
        MIB_SER_EVENTf, MIB_SER_EVENTf,
        ISEC_MIB_SP_CTRL_1m, "ISEC_MIB_SP_CTRL_1 2 bit ECC",
        MACSEC_ECC_CTRLr, MIB_ECC_ENf, NULL,
        MACSEC_MIB_INTR_ENABLEr, INVALIDf, _soc_fl_mib_sp_ctrl_1_intr_flds,
        ISEC_MIB_SP_CTRL_1_ECC_STATUSr, NULL, SINGLE_BIT_ERRf,
        INVALIDr, SECYSTATSRXNOTAGPKTSf, /* Reuse as ECC test field. */
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_MACSEC_ECC, NULL,
        MIB_SER_EVENTf, MIB_SER_EVENTf,
        ISEC_MIB_SP_CTRL_2m, "ISEC_MIB_SP_CTRL_2 2 bit ECC",
        MACSEC_ECC_CTRLr, MIB_ECC_ENf, NULL,
        MACSEC_MIB_INTR_ENABLEr, INVALIDf, _soc_fl_mib_sp_ctrl_2_intr_flds,
        ISEC_MIB_SP_CTRL_2_ECC_STATUSr, NULL, SINGLE_BIT_ERRf,
        INVALIDr, INOCTETSf, /* Reuse as ECC test field. */
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_MACSEC_ECC, NULL,
        MIB_SER_EVENTf, MIB_SER_EVENTf,
        ISEC_MIB_SCm, "ISEC_MIB_SCm 2 bit ECC",
        MACSEC_ECC_CTRLr, MIB_ECC_ENf, NULL,
        MACSEC_MIB_INTR_ENABLEr, INVALIDf, _soc_fl_isec_mib_sc_intr_flds,
        ISEC_MIB_SC_ECC_STATUSr, NULL, SINGLE_BIT_ERRf,
        INVALIDr, SECYRXSCSTATSOCTETSVALIDATEDf, /* Reuse as ECC test field. */
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_MACSEC_ECC, NULL,
        MIB_SER_EVENTf, MIB_SER_EVENTf,
        ISEC_MIB_SAm, "ISEC_MIB_SAm 2 bit ECC",
        MACSEC_ECC_CTRLr, MIB_ECC_ENf, NULL,
        MACSEC_MIB_INTR_ENABLEr, INVALIDf, _soc_fl_isec_mib_sa_intr_flds,
        ISEC_MIB_SA_ECC_STATUSr, NULL, SINGLE_BIT_ERRf,
        INVALIDr, SECYRXSASTATSNOTUSINGSAPKTSf, /* Reuse as ECC test field. */
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    /*
     * ISEC_SP_TCAM_KEY and ISEC_SP_TCAM_MASK does not use chip SER.
     * It has it's own SER mechanism.
     */
    { _SOC_PARITY_TYPE_MACSEC_ECC, NULL,
        ISEC_SP_TCAM_SER_EVENTf, ISEC_SP_TCAM_SER_EVENTf,
        ISEC_SP_TCAM_KEYm, "ISEC_SP_TCAM_KEY 2 bit ECC",
        ISEC_SER_CONTROLr, SP_TCAM_PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        ISEC_SPTCAM_SER_STATUSr, NULL, SER_BUSf,
        INVALIDr, FRAME_FORMATf, /* Reuse as ECC test field. */
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_MACSEC_ECC, NULL,
        ISEC_SP_TCAM_SER_EVENTf, ISEC_SP_TCAM_SER_EVENTf,
        ISEC_SP_TCAM_MASKm, "ISEC_SP_TCAM_MASK 2 bit ECC",
        ISEC_SER_CONTROLr, SP_TCAM_PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        ISEC_SPTCAM_SER_STATUSr, NULL, SER_BUSf,
        INVALIDr, FRAME_FORMAT_MASKf, /* Reuse as ECC test field. */
        INVALIDr, NULL, INVALIDr, INVALIDr,
        0
    },
#endif /* _FL_SER_TEST_MACSEC */
    { _SOC_PARITY_TYPE_NONE }, /* table terminator */
};
#endif

static _soc_fl_ser_route_block_t _soc_fl_ser_route_blocks[] = {
    {_FL_X_TO_CMIC_INTR(_FL_PAR_MMU), SOC_BLK_MMU, 0,
        INVALIDr, INVALIDr,
        _soc_fl_mmu_top_ser_info},
    {_FL_X_TO_CMIC_INTR(_FL_PAR_EP), SOC_BLK_EPIPE, 0,
        EGR_INTR_ENABLE_64r, EGR_INTR_STATUS_64r,
        _soc_fl_ep_ser_info},
    {_FL_X_TO_CMIC_INTR(_FL_PAR_IP0), SOC_BLK_IPIPE, 0,
        IP0_INTR_ENABLEr, IP0_INTR_STATUSr,
        _soc_fl_ip0_ser_info},
    {_FL_X_TO_CMIC_INTR(_FL_PAR_IP1), SOC_BLK_IPIPE, 0,
        IP1_INTR_ENABLEr, IP1_INTR_STATUSr,
        _soc_fl_ip1_ser_info},
    {_FL_X_TO_CMIC_INTR(_FL_PAR_IP2), SOC_BLK_IPIPE, 0,
        IP2_INTR_ENABLEr, IP2_INTR_STATUSr,
        _soc_fl_ip2_ser_info},
    {_FL_X_TO_CMIC_INTR(_FL_PAR_IP2_SR), SOC_BLK_IPIPE, 0,
        IP2_SR_INTR_ENABLEr, IP2_SR_INTR_STATUSr,
        _soc_fl_ip2_sr_ser_info},
    {_FL_X_TO_CMIC_INTR(_FL_PAR_IP2_SR_SN), SOC_BLK_IPIPE, 0,
        IP2_SR_SN_INTR_ENABLEr, IP2_SR_SN_INTR_STATUSr,
        _soc_fl_ip2_sr_sn_ser_info},
    {_FL_X_TO_CMIC_INTR(_FL_PAR_GE0), SOC_BLK_PGW_GE, 0,
        PGW_GE_INTR_ENABLEr, PGW_GE_INTR_STATUSr,
        _soc_fl_pgw_gport_ser_info},
    {_FL_X_TO_CMIC_INTR(_FL_PAR_GE1), SOC_BLK_PGW_GE, 1,
        PGW_GE_INTR_ENABLEr, PGW_GE_INTR_STATUSr,
        _soc_fl_pgw_gport_ser_info},
    {_FL_X_TO_CMIC_INTR(_FL_PAR_GE2), SOC_BLK_PGW_GE, 2,
        PGW_GE_INTR_ENABLEr, PGW_GE_INTR_STATUSr,
        _soc_fl_pgw_gport_ser_info},
    {_FL_X_TO_CMIC_INTR(_FL_PAR_XL0), SOC_BLK_XLPORT, 0,
        PGW_XL_INTR_ENABLEr, PGW_XL_INTR_STATUSr,
        _soc_fl_pgw_xlport_ser_info},
    {_FL_X_TO_CMIC_INTR(_FL_PAR_XL1), SOC_BLK_XLPORT, 1,
        PGW_XL_INTR_ENABLEr, PGW_XL_INTR_STATUSr,
        _soc_fl_pgw_xlport_ser_info},
    {_FL_X_TO_CMIC_INTR(_FL_PAR_XL2), SOC_BLK_XLPORT, 2,
        PGW_XL_INTR_ENABLEr, PGW_XL_INTR_STATUSr,
        _soc_fl_pgw_xlport_ser_info},
    {_FL_X_TO_CMIC_INTR(_FL_PAR_CL0), SOC_BLK_CLPORT, 0,
        PGW_CL_INTR_ENABLEr, PGW_CL_INTR_STATUSr,
        _soc_fl_pgw_clport_ser_info},
    {_FL_X_TO_CMIC_INTR(_FL_PAR_CL1), SOC_BLK_CLPORT, 1,
        PGW_CL_INTR_ENABLEr, PGW_CL_INTR_STATUSr,
        _soc_fl_pgw_clport_ser_info},
    {_FL_X_TO_CMIC_INTR(_FL_PAR_CL2), SOC_BLK_CLPORT, 2,
        PGW_CL_INTR_ENABLEr, PGW_CL_INTR_STATUSr,
        _soc_fl_pgw_clport_ser_info},
    {_FL_X_TO_CMIC_INTR(_FL_PAR_CL3), SOC_BLK_CLPORT, 3,
        PGW_CL_INTR_ENABLEr, PGW_CL_INTR_STATUSr,
        _soc_fl_pgw_clport_ser_info},
#ifdef INCLUDE_XFLOW_MACSEC
    {_FL_X_TO_CMIC_INTR(_FL_PAR_MACSEC), SOC_BLK_MACSEC, 0,
        MACSEC_INTR_ENABLEr, MACSEC_INTR_STATUSr,
        _soc_fl_macsec_ser_info},
#endif
    { 0 } /* table terminator */
};

STATIC int
_soc_fl_ser_process_is_per_port_mem(
    int unit,
    _soc_fl_ser_info_type_t type)
{
    if (type == _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP) {
        return TRUE;
    }
    return FALSE;
}

/* Skip those MMU ports (memories) which logical ports don't exist */
STATIC int
_soc_fl_ser_process_skip_disabled_mmu_port(
    int unit,
    _soc_fl_ser_info_t *info)
{
    soc_info_t *si = &SOC_INFO(unit);
    int logical_port, phy_port, mmu_port;
    _soc_fl_ser_reg_t *reg_ptr;
    int ptr;

    if (NULL == info) {
        return TRUE;
    }

    if (info->type == _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP &&
        info->intr_status_reg_list != NULL) {
        reg_ptr = info->intr_status_reg_list;
    } else {
        return FALSE;
    }

    switch (info->intr2_valid_reg) {
        case IPMC_GROUP_ERR_VLD_0r:
            {
                mmu_port = 0;
                break;
            }
        case IPMC_GROUP_ERR_VLD_1r:
            {
                mmu_port = 32;
                break;
            }
        case IPMC_GROUP_ERR_VLD_2r:
            {
                mmu_port = 64;
                break;
            }
        default:
            {
                return FALSE;
            }
    }
    for (ptr = 0; reg_ptr[ptr].reg != INVALIDr; ptr++) {
        if (reg_ptr[ptr].mem == info->mem) {
            break;
        }
        mmu_port++;
    }

    /* MMU to Physical port, Physical to Logical port  */
    phy_port = si->port_m2p_mapping[mmu_port];
    logical_port = si->port_p2l_mapping[phy_port];

    if (logical_port <= 1) {
        return TRUE;
    }
    return FALSE;
}

STATIC int
_soc_fl_ser_mem_skip(int unit, _soc_fl_ser_info_t *info)
{
    int skip = FALSE;
    uint16 dev_id;
    uint8 rev_id;

    if (NULL == info) {
        return TRUE;
    }

    soc_cm_get_id(unit, &dev_id, &rev_id);
    switch (rev_id){
        case (BCM56070_A0_REV_ID):
            if (info->sku_skip & _SOC_SER_SKIP_FL_A0) {
                skip = TRUE;
            }
            break;
        default:
            skip = FALSE;
            break;
    }

    /* skip invalid logical port mapped from mmu port */
    if (_soc_fl_ser_process_is_per_port_mem(unit, info->type)) {
        if (_soc_fl_ser_process_skip_disabled_mmu_port(unit, info)) {
            skip = TRUE;
        }
    }
    return skip;
}

int
_soc_fl_mem_parity_control(int unit, soc_mem_t mem,
                            int copyno, int enable)
{
    soc_reg_t   parity_enable_reg = INVALIDr;
    soc_field_t hw_parity_field = INVALIDf;
    uint8       rbi;
    _soc_fl_ser_route_block_t *rb;
    uint32      cmic_bit;
    int         block_info_idx;
    soc_mem_t   memTable;
    int         port = REG_PORT_ANY;
    _soc_fl_ser_info_t *info_list, *info;
    int         info_index;
    uint32      misc_cfg;

    if (!soc_property_get(unit, spn_PARITY_ENABLE, TRUE)) {
        /* Parity checking is not enabled, nothing to do */
        return SOC_E_NONE;
    }
    /* Convert component/aggregate memories to the table for which
     * the parity registers correspond. */
    switch(mem) {
        case VLAN_SUBNET_ONLYm:
        case VLAN_SUBNET_DATA_ONLYm:
            mem = VLAN_SUBNETm;
            break;
        case L2_ENTRY_ONLYm:
            mem = L2Xm;
            break;
        case L2_USER_ENTRY_ONLYm:
        case L2_USER_ENTRY_DATA_ONLYm:
            mem = L2_USER_ENTRYm;
            break;
        case L3_DEFIP_DATA_ONLYm:
            mem = L3_DEFIPm;
            break;
        case L3_ENTRY_IPV4_UNICASTm:
        case L3_ENTRY_IPV6_UNICASTm:
        case L3_ENTRY_IPV4_MULTICASTm:
        case L3_ENTRY_IPV6_MULTICASTm:
            mem = L3_ENTRY_ONLYm;
            break;
        case VLAN_MACm:
            mem = VLAN_XLATEm;
            break;
        case MODPORT_MAPm:
            mem = MODPORT_MAP_SWm;
            break;
        case MY_STATION_TCAM_DATA_ONLYm:
            mem = MY_STATION_TCAMm;
            break;
        case EGR_IP_TUNNEL_IPV6m:
            mem = EGR_IP_TUNNELm;
            break;
        default:
            /* Do nothing, keep memory as provided */
            break;
    }

    /* Loop through each place-and-route block entry */
    for (rbi = 0; ; rbi++) {
        rb = soc_fl_ser_route_blocks_get(rbi);
        cmic_bit = rb->cmic_bit;
        parity_enable_reg = INVALIDr;
        hw_parity_field = INVALIDf;
        if (cmic_bit == 0) {
            /* End of table */
            break;
        }
        SOC_BLOCK_ITER(unit, block_info_idx, rb->blocktype) {
            if (SOC_BLOCK_INFO(unit, block_info_idx).number == rb->id) {
                port = SOC_BLOCK_PORT(unit, block_info_idx);
                break;
            }
        }
        if ((copyno != MEM_BLOCK_ANY) && (copyno != block_info_idx)) {
            continue;
        }
        info_list = rb->info;
        if (info_list[0].type == _SOC_PARITY_TYPE_MMU_SER) {
            parity_enable_reg = info_list[0].enable_reg;
            hw_parity_field = info_list[0].enable_field;
            info_list = info_list[0].info;
        }
        for (info_index = 0; ; info_index++) {
            info = &info_list[info_index];
            if (info->type == _SOC_PARITY_TYPE_NONE) {
                /* End of table */
                break;
            }
            if (_soc_fl_ser_mem_skip(unit, info)) {
                continue;
            }
            memTable = info->mem;
            if (memTable == INVALIDm) {
                continue;
            }
            if (memTable == mem)  {
                if (parity_enable_reg == INVALIDr) {
                    parity_enable_reg = info->enable_reg;
                }
                if (hw_parity_field == INVALIDf) {
                    hw_parity_field = info->enable_field;
                }
                SOC_IF_ERROR_RETURN(
                    soc_reg_field32_modify(unit, parity_enable_reg, port,
                                           hw_parity_field,
                                           enable ? 1 : 0));

                return SOC_E_NONE;
            }
        }
    }
    /* MMU controls */
    SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &misc_cfg));
    if (enable) {
        soc_reg_field_set(unit, MISCCONFIGr, &misc_cfg, PARITY_CHECK_ENf, 1);
    } else {
        soc_reg_field_set(unit, MISCCONFIGr, &misc_cfg, PARITY_CHECK_ENf, 0);
    }
    SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, misc_cfg));

    return SOC_E_NONE;
}

STATIC int
_soc_fl_ser_2bit_ecc_mem(int unit, soc_mem_t memTable)
{
    int is_2bit_ecc_mem = FALSE;
    /* FOR _SOC_PARITY_TYPE_ECC_DUAL */
    switch (memTable){
        case MMU_IPMC_GROUP_TBL6m:
        case MMU_IPMC_GROUP_TBL7m:
        case MMU_IPMC_GROUP_TBL8m:
        case MMU_IPMC_GROUP_TBL9m:
        case MMU_IPMC_GROUP_TBL10m:
        case MMU_IPMC_GROUP_TBL11m:
        case MMU_IPMC_GROUP_TBL12m:
        case MMU_IPMC_GROUP_TBL13m:
        case MMU_IPMC_GROUP_TBL14m:
        case MMU_IPMC_GROUP_TBL15m:
        case MMU_IPMC_GROUP_TBL16m:
        case MMU_IPMC_GROUP_TBL17m:
        case MMU_IPMC_GROUP_TBL18m:
        case MMU_IPMC_GROUP_TBL19m:
        case MMU_IPMC_GROUP_TBL20m:
        case MMU_IPMC_GROUP_TBL21m:
        case MMU_IPMC_GROUP_TBL22m:
        case MMU_IPMC_GROUP_TBL23m:
        case MMU_IPMC_GROUP_TBL24m:
        case MMU_IPMC_GROUP_TBL25m:
        case MMU_IPMC_GROUP_TBL26m:
        case MMU_IPMC_GROUP_TBL27m:
        case MMU_IPMC_GROUP_TBL28m:
        case MMU_IPMC_GROUP_TBL29m:
        case MMU_IPMC_GROUP_TBL30m:
        case MMU_IPMC_GROUP_TBL31m:
        case MMU_IPMC_GROUP_TBL32m:
        case MMU_IPMC_GROUP_TBL33m:
        case MMU_IPMC_GROUP_TBL34m:
        case MMU_IPMC_GROUP_TBL35m:
        case MMU_IPMC_GROUP_TBL36m:
        case MMU_IPMC_GROUP_TBL37m:
        case MMU_IPMC_GROUP_TBL38m:
        case MMU_IPMC_GROUP_TBL39m:
        case MMU_IPMC_GROUP_TBL40m:
        case MMU_IPMC_GROUP_TBL41m:
        case MMU_IPMC_GROUP_TBL42m:
        case MMU_IPMC_GROUP_TBL43m:
        case MMU_IPMC_GROUP_TBL44m:
        case MMU_IPMC_GROUP_TBL45m:
        case MMU_IPMC_GROUP_TBL46m:
        case MMU_IPMC_GROUP_TBL47m:
        case MMU_IPMC_GROUP_TBL48m:
        case MMU_IPMC_GROUP_TBL49m:
        case MMU_IPMC_GROUP_TBL50m:
        case MMU_IPMC_GROUP_TBL51m:
        case MMU_IPMC_GROUP_TBL52m:
        case MMU_IPMC_GROUP_TBL53m:
        case MMU_IPMC_GROUP_TBL54m:
        case MMU_IPMC_GROUP_TBL55m:
        case MMU_IPMC_GROUP_TBL56m:
        case MMU_IPMC_GROUP_TBL57m:
        case MMU_IPMC_GROUP_TBL58m:
        case MMU_IPMC_GROUP_TBL59m:
        case MMU_IPMC_GROUP_TBL60m:
        case MMU_IPMC_GROUP_TBL61m:
        case MMU_IPMC_GROUP_TBL62m:
        case MMU_IPMC_GROUP_TBL63m:
        case MMU_IPMC_GROUP_TBL64m:
        case MMU_IPMC_GROUP_TBL65m:
        case MMU_IPMC_VLAN_TBLm:
        case EGR_MTU_CHECKm:
        case EGR_STU_CHECKm:
        case SR_FLOW_EGR_COUNTER_CONTROLm:
        case SR_RX_FLOW_ID_POOLm:
        case SR_TX_FLOW_ID_POOLm:
        case SR_MAC_PROXY_PROFILEm:
        case SR_FLOW_ING_COUNTER_CONTROLm:
        case SR_RXm:
        case SR_TXm:
        case ING_MTU_CHECK_1m:
        case ING_MTU_CHECK_2m:
        case TAF_GATE_ID_LOOKUPm:
            is_2bit_ecc_mem = TRUE;
            break;
        default:
            is_2bit_ecc_mem = FALSE;
            break;
    };
    return is_2bit_ecc_mem;
}

STATIC void
_soc_fl_mem_parity_info(int unit, int block_info_idx, int pipe,
                         soc_field_t field_enum, uint32 *minfo)
{
    *minfo = (SOC_BLOCK2SCH(unit, block_info_idx) << SOC_ERROR_BLK_BP)
        | ((pipe & 0xff) << SOC_ERROR_PIPE_BP)
        | (field_enum & SOC_ERROR_FIELD_ENUM_MASK);
}

#define _SOC_FL_MMU_E2EFC_MAX     4
static soc_reg_t e2efc_regs[_SOC_FL_MMU_E2EFC_MAX] = {
      INVALIDr,
      E2EFC_CNT_SET_LIMITr,
      E2EFC_CNT_RESET_LIMITr,
      E2EFC_CNT_DISC_LIMITr
};

STATIC int
_soc_fl_ser_process_mmu_e2efc(int unit,_soc_fl_ser_info_t *info_list,
                             int info_index, int block_info_idx, char *msg)
{
    _soc_fl_ser_info_t *info;
    soc_reg_t status_reg;
    uint32  intr_status;
    int index, mem_id;
    uint32 minfo;
    _soc_ser_correct_info_t spci;

    info = &info_list[info_index];
    status_reg = info->intr_status_reg;
    SOC_IF_ERROR_RETURN
        (soc_reg32_get(unit, status_reg, REG_PORT_ANY, 0,
                       &intr_status));
    mem_id = soc_reg_field_get(unit, status_reg,
                                   intr_status, MEM_IDf);
    /* CHECK if the error is valid */
    if (mem_id == 0) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s: parity hardware inconsistency\n"),
                   msg));
        return SOC_E_NONE;
    }
    index = soc_reg_field_get(unit, status_reg, intr_status, ENTRY_INDEXf);
    _soc_fl_mem_parity_info(unit, block_info_idx, 0,
                             info->group_reg_status_field, &minfo);
    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                       SOC_SWITCH_EVENT_DATA_ERROR_PARITY,
                       index, minfo);
    LOG_ERROR(BSL_LS_SOC_COMMON,
              (BSL_META_U(unit,
                          "unit %d MMU E2EFC entry idx %d : parity error\n"),
               unit, index));
    sal_memset(&spci, 0, sizeof(_soc_ser_correct_info_t));
    spci.flags = SOC_SER_SRC_REG | SOC_SER_REG_MEM_KNOWN;
    spci.reg = e2efc_regs[mem_id];
    spci.mem = INVALIDm;
    spci.blk_type = SOC_BLK_MMU;
    spci.index = index;
    spci.detect_time = sal_time_usecs();
    (void)soc_ser_correction(unit, &spci);

    return SOC_E_NONE;
}

STATIC int
_soc_fl_ser_process_port_m2l_mapping(
    int unit,
    _soc_fl_ser_info_t *info,
    uint32 valid_val,
    int *logical_port)
{
    soc_info_t *si = &SOC_INFO(unit);
    int port, phy_port, mmu_port;

    if (NULL == info || NULL == logical_port) {
        return SOC_E_PARAM;
    }

    port = 0;
    while (!(valid_val & (0x1 << port))) {
        port++;
    }

    if (info->intr2_valid_reg == IPMC_GROUP_ERR_VLD_0r) {
        mmu_port = port;
    } else if (info->intr2_valid_reg == IPMC_GROUP_ERR_VLD_1r) {
        mmu_port = port + 32;
    } else if (info->intr2_valid_reg == IPMC_GROUP_ERR_VLD_2r) {
        mmu_port = port + 64;
    } else {
        return SOC_E_NOT_FOUND;
    }
    /* MMU to Physical port, Physical to Logical port  */
    phy_port = si->port_m2p_mapping[mmu_port];
    *logical_port = si->port_p2l_mapping[phy_port];

    if (*logical_port <= 1) {
        /* Handle the invalid logical port */
        return SOC_E_UNAVAIL;
    }

    return SOC_E_NONE;
}

STATIC int
_soc_fl_ser_process_mmu_group_correct(int unit,_soc_fl_ser_info_t *info_list,
                                       int info_index, int block_info_idx,
                                       char *msg, int report_type)
{
    soc_error_t rv;
    _soc_fl_ser_info_t *info;
    _soc_fl_ser_reg_t *reg_ptr;
    soc_reg_t valid_reg = INVALIDr;
    soc_reg_t status_reg, clear_reg, multi_err_reg = INVALIDr;
    uint32 reg_val, valid_val = 0;
    int index, double_bit = 0, multiple = 0;
    uint32 minfo;
    int ptr;
    _soc_ser_correct_info_t spci;
    uint8 hw_inconsist = FALSE;
    int logical_port, port;

    info = &info_list[info_index];

    if (info->intr2_valid_reg_list != NULL) {
        /*
         * IPMC_GROUP_ERR_VLD_0/1/2 binded to the same IPMCGROUPPARITYERROR
         * one of VLD_0/1/2 should be 1 or there's hardware inconsistency.
         */
        reg_ptr = info->intr2_valid_reg_list;
        for (ptr = 0; reg_ptr[ptr].reg != INVALIDr; ptr++) {
            valid_reg = reg_ptr[ptr].reg;
            SOC_IF_ERROR_RETURN
                (soc_reg32_get(unit, valid_reg, REG_PORT_ANY, 0,
                               &reg_val));
            valid_val = soc_reg_field_get(unit, valid_reg, reg_val, ERR_VALIDf);
            if (valid_val) {
                break;
            }
        }
        if (reg_ptr[ptr].reg == INVALIDr) {
            hw_inconsist = TRUE;
        }
        if (valid_reg != info->intr2_valid_reg) {
            return SOC_E_NONE;
        }
    } else {
        valid_reg = info->intr2_valid_reg;
        SOC_IF_ERROR_RETURN
            (soc_reg32_get(unit, valid_reg, REG_PORT_ANY, 0,
                           &reg_val));
        valid_val = soc_reg_field_get(unit, valid_reg, reg_val, ERR_VALIDf);
        if (valid_val == 0) {
            hw_inconsist = TRUE;
        }
    }

    if (TRUE == hw_inconsist) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s: ecc hardware inconsistency"
                              "Please check %s.\n"),
                   msg,
                   SOC_FIELD_NAME(unit, info->group_reg_status_field)));
        return SOC_E_NONE;
    }

    if (SOC_REG_IS_VALID(unit, info->intr2_multi_err_reg) &&
        soc_reg_field_valid(unit, info->intr2_multi_err_reg, MULTIPLE_ERRf)) {
        multi_err_reg = info->intr2_multi_err_reg;
    } else if (soc_reg_field_valid(unit, valid_reg, MULTIPLE_ERRf)) {
        multi_err_reg = valid_reg;
    }
    if (INVALIDr != multi_err_reg) {
        multiple =
            soc_reg_field_get(unit, multi_err_reg, reg_val, MULTIPLE_ERRf);
    }

    if (info->intr_status_reg_list != NULL) {
        reg_ptr = info->intr_status_reg_list;
    } else {
        return SOC_E_INTERNAL;
    }

    for (ptr = 0; reg_ptr[ptr].reg != INVALIDr; ptr++) {
        if (ptr > 31) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "%s: left shifting by more"
                                  " than 31 bits, ptr = %d"),
                       msg, ptr));
            return SOC_E_INTERNAL;
        }
        if (!(valid_val & (0x1 << ptr))) {
            continue;
        }
        status_reg = reg_ptr[ptr].reg;

        /* convert to mmu port for mmu memories */
        if (_soc_fl_ser_process_is_per_port_mem(unit, info->type)) {
            rv = _soc_fl_ser_process_port_m2l_mapping(
                    unit, info, valid_val, &logical_port);
            if (SOC_SUCCESS(rv)) {
                port = logical_port;
            } else {
                return rv;
            }
        } else {
            port = REG_PORT_ANY;
        }
        SOC_IF_ERROR_RETURN(
            soc_reg32_get(unit, status_reg, port, 0, &reg_val));

        index = soc_reg_field_get(unit, status_reg, reg_val, ENTRY_INDEXf);

        sal_memset(&spci, 0, sizeof(_soc_ser_correct_info_t));
        spci.flags |= SOC_SER_SRC_MEM;
        if (soc_reg_field_valid(unit, status_reg, DOUBLE_BIT_ERRf)) {
            double_bit =
                soc_reg_field_get(unit, status_reg, reg_val, DOUBLE_BIT_ERRf);
            spci.double_bit = 1;
        }
        _soc_fl_mem_parity_info(unit, block_info_idx, 0,
                                 info->group_reg_status_field, &minfo);
        soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                           report_type,
                           index, minfo);

        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s:%s:entry idx %d:%s parity error\n"),
                   msg, reg_ptr[ptr].str, index,
                   double_bit ? "double-bit" : ""));

        if (multiple & (1 << ptr)) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "%s:%s:has multiple parity errors\n"),
                       msg, reg_ptr[ptr].str));
            spci.flags |= SOC_SER_ERR_MULTI;
        }
        spci.reg = INVALIDr;
        spci.mem = reg_ptr[ptr].mem;
        spci.flags |= SOC_SER_REG_MEM_KNOWN;
        spci.blk_type = SOC_BLK_MMU;
        spci.detect_time = sal_time_usecs();
        spci.index = index;
        (void)soc_ser_correction(unit, &spci);

    }
    /* Clear interrupt status */
    clear_reg = info->intr2_clr_reg;
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, clear_reg,
                                REG_PORT_ANY, 0, &reg_val));
    soc_reg_field_set(unit, clear_reg, &reg_val,
                            CLR_ERRf, valid_val);
    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, clear_reg,
                                REG_PORT_ANY, 0, reg_val));
    return SOC_E_NONE;
}

STATIC int
_soc_fl_ser_process_mmu_group_ecc(int unit,_soc_fl_ser_info_t *info_list,
                                   int info_index, int block_info_idx, char *msg)
{
    _soc_fl_ser_info_t *info;
    _soc_fl_ser_reg_t *reg_ptr;
    soc_reg_t valid_reg, status_reg, clear_reg;
    uint32  reg_val, valid_val;
    int index, double_bit = 0, multiple;
    uint32 minfo;
    int ptr;

    info = &info_list[info_index];
    valid_reg = info->intr2_valid_reg;
    SOC_IF_ERROR_RETURN
        (soc_reg32_get(unit, valid_reg, REG_PORT_ANY, 0,
                       &reg_val));
    valid_val = soc_reg_field_get(unit, valid_reg, reg_val, ERR_VALIDf);
    /* CBPPKTHDR_ERR */
    multiple =
        soc_reg_field_get(unit, valid_reg, reg_val, MULTIPLE_ERRf);
    if (valid_val == 0) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s: ecc hardware inconsistency\n"),
                   msg));
        return SOC_E_NONE;
    }

    if (info->intr_status_reg_list != NULL) {
        reg_ptr = info->intr_status_reg_list;
    } else {
        return SOC_E_INTERNAL;
    }
    for (ptr = 0; reg_ptr[ptr].reg != INVALIDr; ptr++) {
        if (!(valid_val & (0x1 << ptr))) {
            continue;
        }
        status_reg = reg_ptr[ptr].reg;

        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, status_reg,
                                    REG_PORT_ANY, 0, &reg_val));
        index =
                soc_reg_field_get(unit, status_reg, reg_val, ENTRY_INDEXf);
        if (soc_reg_field_valid(unit, status_reg, DOUBLE_BIT_ERRf)) {
            double_bit =
                soc_reg_field_get(unit, status_reg, reg_val, DOUBLE_BIT_ERRf);
        }

        _soc_fl_mem_parity_info(unit, block_info_idx, 0,
                                 info->group_reg_status_field, &minfo);
        soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                               SOC_SWITCH_EVENT_DATA_ERROR_ECC,
                               index, minfo);

        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s %s entry %d %s ECC error\n"),
                   msg, reg_ptr[ptr].str, index,
                   double_bit ? "double-bit" : ""));
        if (multiple & (1 << ptr)) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "%s (%s) has multiple ECC errors\n"),
                       msg, reg_ptr[ptr].str));
        }
    }
    /* Clear interrupt status */
    clear_reg = info->intr2_clr_reg;
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, clear_reg,
                                REG_PORT_ANY, 0, &reg_val));
    soc_reg_field_set(unit, clear_reg, &reg_val,
                            CLR_ERRf, valid_val);
    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, clear_reg,
                                REG_PORT_ANY, 0, reg_val));
    return SOC_E_NONE;
}

STATIC int
_soc_fl_ser_process_mmu_ecc2(int unit,_soc_fl_ser_info_t *info_list,
                              int info_index, int block_info_idx, char *msg)

{
    _soc_fl_ser_info_t *info;
    soc_reg_t valid_reg, status_reg, clear_reg, merr_reg;
    uint32  reg_val, valid_val;
    int index, double_bit = 0, multiple = 0;
    uint32 minfo;
    int port;

    info = &info_list[info_index];

    valid_reg = info->intr2_valid_reg;
    SOC_IF_ERROR_RETURN
        (soc_reg32_get(unit, valid_reg, REG_PORT_ANY, 0,
                       &reg_val));
    valid_val = soc_reg_field_get(unit, valid_reg, reg_val, ERR_VALIDf);
    if (valid_val == 0) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s: ecc hardware inconsistency\n"),
                   msg));
        return SOC_E_NONE;
    }
    port = 0;
    while (!(valid_val & (0x1 << port))) {
        port++;
    }
    if (info->intr_status_reg != INVALIDr){
        status_reg = info->intr_status_reg;
    } else {
        return SOC_E_INTERNAL;
    }
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, status_reg,
                                port, 0, &reg_val));
    index =
            soc_reg_field_get(unit, status_reg, reg_val, ENTRY_INDEXf);
    if (soc_reg_field_valid(unit, status_reg, DOUBLE_BIT_ERRf)) {
        double_bit =
            soc_reg_field_get(unit, status_reg, reg_val, DOUBLE_BIT_ERRf);
    }

    if (info->intr2_multi_err_reg != INVALIDr) {
        merr_reg = info->intr2_multi_err_reg;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, merr_reg,
                                port, 0, &reg_val));
        multiple =
            soc_reg_field_get(unit, merr_reg, reg_val, MULTIPLE_ERRf);
    }
    _soc_fl_mem_parity_info(unit, block_info_idx, 0,
                             info->group_reg_status_field, &minfo);
    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                           SOC_SWITCH_EVENT_DATA_ERROR_ECC,
                           index, minfo);
    LOG_ERROR(BSL_LS_SOC_COMMON,
              (BSL_META_U(unit,
                          "%s port %d entry %d %s ECC error\n"),
               msg, port, index, double_bit ? "double-bit" : ""));
    if (multiple) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s has multiple ECC errors\n"),
                   msg));
    }
    /* Clear interrupt status */
    clear_reg = info->intr2_clr_reg;
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, clear_reg,
                                REG_PORT_ANY, 0, &reg_val));
    soc_reg_field_set(unit, clear_reg, &reg_val,
                            CLR_ERRf, valid_val);
    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, clear_reg,
                                REG_PORT_ANY, 0, reg_val));
    return SOC_E_NONE;
}

STATIC int
_soc_fl_ser_process_mmu_ecc(int unit,_soc_fl_ser_info_t *info_list,
                             int info_index, int block_info_idx, char *msg,
                             int correctable)
{
    _soc_fl_ser_info_t *info;
    soc_reg_t status_reg;
    uint32  intr_status;
    int index, double_bit = 0;
    uint32 minfo;
    _soc_ser_correct_info_t spci;

    info = &info_list[info_index];
    status_reg = info->intr_status_reg;
    SOC_IF_ERROR_RETURN
        (soc_reg32_get(unit, status_reg, REG_PORT_ANY, 0,
                       &intr_status));
    index = soc_reg_field_get(unit, status_reg, intr_status, ENTRY_INDEXf);
    if (soc_reg_field_valid(unit, status_reg, DOUBLE_BIT_ERRf)) {
        double_bit = soc_reg_field_get(unit, status_reg,
                                       intr_status, DOUBLE_BIT_ERRf);
    }

    _soc_fl_mem_parity_info(unit, block_info_idx, 0,
                             info->group_reg_status_field, &minfo);

    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                           SOC_SWITCH_EVENT_DATA_ERROR_ECC,
                           index, minfo);
    LOG_ERROR(BSL_LS_SOC_COMMON,
              (BSL_META_U(unit,
                          "%s : entry idx %d : %s ECC error\n"),
               msg, index, double_bit ? "double-bit" : ""));
    if (correctable) {
        sal_memset(&spci, 0, sizeof(_soc_ser_correct_info_t));
        spci.flags = SOC_SER_SRC_MEM | SOC_SER_REG_MEM_KNOWN;
        spci.reg = INVALIDr;
        spci.mem = info->mem;
        spci.blk_type = SOC_BLK_MMU;
        spci.index = index;
        (void)soc_ser_correction(unit, &spci);
    }
    return SOC_E_NONE;
}

STATIC int
_soc_fl_ser_process_mmu_err(int unit, int block_info_idx,
                             soc_reg_t group_reg,
                             soc_reg_t clear_reg,
                             _soc_fl_ser_info_t *info_list)
{
    soc_reg_t grp_reg, clr_reg;
    uint32 rval, group_rval;
    int rv = SOC_E_NONE;
    int info_index;
    _soc_fl_ser_info_t *info;
    char *mem_str;

    if (info_list->type == _SOC_PARITY_TYPE_MMU_SER){
        grp_reg = info_list->intr_status_reg;
        clr_reg = info_list->intr_clr_reg;


        rv = _soc_fl_ser_process_mmu_err(unit, block_info_idx,
                                          grp_reg,
                                          clr_reg,
                                          info_list->info);
        if (SOC_FAILURE(rv)) {
            LOG_CLI((BSL_META_U(unit,
                                "process_mmu_err: Error processing %s !!\n"),
                     info_list->mem_str));
            return rv;
        }
        return rv;
    }
    for (info_index = 0; ; info_index++) {
        info = &info_list[info_index];
        if (info->type == _SOC_PARITY_TYPE_NONE) {
            /* End of table */
            break;
        }
        SOC_IF_ERROR_RETURN
            (soc_reg32_get(unit, group_reg, REG_PORT_ANY, 0,
                           &group_rval));
        if (!soc_reg_field_get(unit, group_reg, group_rval,
                                   info->group_reg_status_field)) {
            continue;
        }

        if (info->mem_str) {
            mem_str = info->mem_str;
        } else if (info->mem != INVALIDm) {
            mem_str = SOC_MEM_NAME(unit, info->mem);
        } else {
            mem_str = SOC_FIELD_NAME(unit, info->group_reg_status_field);
        }

        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                                "process_mmu_err %s analysis\n"),
                                mem_str));
        switch (info->type) {
        case _SOC_PARITY_TYPE_MMU_ECC:
            SOC_IF_ERROR_RETURN(
                _soc_fl_ser_process_mmu_ecc(unit, info_list, info_index,
                                             block_info_idx, mem_str, 0));
            break;
        case _SOC_PARITY_TYPE_MMU_ECC_XQ:
            SOC_IF_ERROR_RETURN(
                _soc_fl_ser_process_mmu_ecc2(unit, info_list, info_index,
                                             block_info_idx, mem_str));
            break;
        case _SOC_PARITY_TYPE_MMU_ECC_CBPH:
            SOC_IF_ERROR_RETURN(
                _soc_fl_ser_process_mmu_group_ecc(unit, info_list, info_index,
                                             block_info_idx, mem_str));
            break;
        case _SOC_PARITY_TYPE_MMU_PAR_E2EFC:
            SOC_IF_ERROR_RETURN(
                _soc_fl_ser_process_mmu_e2efc(unit, info_list, info_index,
                                             block_info_idx, mem_str));
            break;
        case _SOC_PARITY_TYPE_MMU_PAR_WRED:
            SOC_IF_ERROR_RETURN(_soc_fl_ser_process_mmu_group_correct(
                                unit, info_list, info_index,
                                block_info_idx, mem_str,
                                SOC_SWITCH_EVENT_DATA_ERROR_PARITY));
            break;
        case _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP:
            SOC_IF_ERROR_RETURN(_soc_fl_ser_process_mmu_group_correct(
                                unit, info_list, info_index,
                                block_info_idx, mem_str,
                                SOC_SWITCH_EVENT_DATA_ERROR_ECC));
            break;
        case _SOC_PARITY_TYPE_MMU_ECC_IPMCVLAN:
            SOC_IF_ERROR_RETURN(
                _soc_fl_ser_process_mmu_ecc(unit, info_list, info_index,
                                             block_info_idx, mem_str, 1));
            break;
        default:
            break;
        }
        /* clear interrupt */
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, clear_reg,  REG_PORT_ANY,
                            0, &rval));
        soc_reg_field_set(unit, clear_reg, &rval,
                          info->intr_clr_field, 1);
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, clear_reg,  REG_PORT_ANY,
                            0, rval));

    }
    return SOC_E_NONE;
}

STATIC int
_soc_fl_ser_process_parity_hash(int unit, int block_info_idx, int port,
                                _soc_fl_ser_info_t *info,
                                  char *mem_str,
                                 soc_block_t blocktype)
{
    _soc_fl_ser_reg_t reg_entry[2], *reg_ptr;
    soc_reg_t reg;
    _soc_ser_correct_info_t spci;
    uint32 bitmap = 0, len = 0, bits, rval, minfo;
    uint32 multiple = 0, bucket_index = 0, entry_idx, idx, has_error;
    char *mem_str_ptr;
    soc_field_t bitmapf;

    if (info->intr_status_reg != INVALIDr) {
        reg_entry[0].reg = info->intr_status_reg;
        reg_entry[0].str = NULL;
        reg_entry[1].reg = INVALIDr;
        reg_ptr = reg_entry;
    } else if (info->intr_status_reg_list != NULL) {
        reg_ptr = info->intr_status_reg_list;
    } else {
        return SOC_E_NONE;
    }

    has_error = FALSE;
    for (idx = 0; reg_ptr[idx].reg != INVALIDr; idx++) {
        reg = reg_ptr[idx].reg;
        mem_str_ptr = (reg_ptr[idx].str != NULL) ?
                       reg_ptr[idx].str : mem_str;
        sal_memset(&spci, 0, sizeof(spci));

        SOC_IF_ERROR_RETURN
            (soc_reg32_get(unit, reg, port, 0, &rval));

        if (soc_reg_field_valid(unit, reg, BUCKET_IDXf)) {
            bucket_index =
                soc_reg_field_get(unit, reg, rval, BUCKET_IDXf);
            multiple =
                soc_reg_field_get(unit, reg, rval, MULTIPLE_ERRf);
            bitmap =
                soc_reg_field_get(unit, reg, rval, PARITY_ERR_BMf);
            len = soc_reg_field_length(unit, reg, PARITY_ERR_BMf);
        } else if (soc_reg_field_valid(unit, reg, BUCKET_IDX_0f)) {
            bucket_index =
                soc_reg_field_get(unit, reg, rval, BUCKET_IDX_0f);
            multiple =
                soc_reg_field_get(unit, reg, rval, MULTIPLE_ERR_0f);
            if (SR_L2_ENTRYm == info->mem) {
                bitmapf = SR_PARITY_ERR_BM_0f;
            } else {
                bitmapf = PARITY_ERR_BM_0f;
            }
            bitmap =
                soc_reg_field_get(unit, reg, rval, bitmapf);
            len = soc_reg_field_length(unit, reg, bitmapf);
        } else if (soc_reg_field_valid(unit, reg, BUCKET_IDX_1f)) {
            bucket_index =
                soc_reg_field_get(unit, reg, rval, BUCKET_IDX_1f);
            multiple =
               soc_reg_field_get(unit, reg, rval, MULTIPLE_ERR_1f);
            if (SR_L2_ENTRYm == info->mem) {
                bitmapf = SR_PARITY_ERR_BM_1f;
            } else {
                bitmapf = PARITY_ERR_BM_1f;
            }
            bitmap =
                soc_reg_field_get(unit, reg, rval, bitmapf);
            len = soc_reg_field_length(unit, reg, bitmapf);
        }
        if (bitmap != 0) {
            for (bits = 0; bits < len; bits++) {
                if (bitmap & (1 << bits)) {
                    has_error = TRUE;
                    break;
                }
            }
            entry_idx = bucket_index * len * 2 + bits + (idx * len);
            _soc_fl_mem_parity_info(unit, block_info_idx, 0,
                                     info->group_reg_status_field, &minfo);
            soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                               SOC_SWITCH_EVENT_DATA_ERROR_PARITY,
                               entry_idx, minfo);
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unit %d %s : entry idx %d : parity error\n"),
                       unit, mem_str_ptr, entry_idx));
            if (multiple) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "unit %d %s has multiple parity errors\n"),
                           unit, mem_str_ptr));
            }
            spci.flags = SOC_SER_SRC_MEM;
            if (multiple) {
                spci.flags |= SOC_SER_ERR_MULTI;
            }
            spci.double_bit = 0;
            spci.reg = INVALIDr;
            spci.mem = info->mem;
            spci.blk_type = blocktype;
            spci.index = entry_idx;
            spci.detect_time = sal_time_usecs();
            spci.pipe_num = 0;
            spci.acc_type = -1;
            spci.addr = (spci.mem != INVALIDm)? SOC_MEM_BASE(unit, spci.mem) : 0;
            if (spci.mem != INVALIDm) {
                spci.flags |= SOC_SER_REG_MEM_KNOWN;
                (void)soc_ser_correction(unit, &spci);
            }
            /* Clear parity status */
            SOC_IF_ERROR_RETURN
                (soc_reg32_set(unit, reg, port, 0, 0));
        }
    }
    if (!has_error) {
        LOG_VERBOSE(BSL_LS_SOC_SER,
            (BSL_META_U(unit,
                        "unit %d %s parity hardware inconsistency\n"),
             unit, mem_str));
    }

    return SOC_E_NONE;
}

STATIC int
_soc_fl_ser_process_parity_ecc(int unit, int block_info_idx, int port,
                                _soc_fl_ser_info_t *info,
                                char *mem_str,
                                soc_block_t blocktype, int parity_type)
{
    _soc_fl_ser_reg_t reg_entry[2], *reg_ptr;
    soc_reg_t reg;
    soc_field_t parity_error_field = PARITY_ERRf;
    _soc_ser_correct_info_t spci;
    uint32 rval, minfo, double_bit = 0;
    uint32 multiple, entry_idx, idx, has_error;
    char *mem_str_ptr;
    int report_type = SOC_SWITCH_EVENT_DATA_ERROR_PARITY;

    if (info->intr_status_reg != INVALIDr) {
        reg_entry[0].reg = info->intr_status_reg;  
        reg_entry[0].str = NULL;
        reg_entry[1].reg = INVALIDr;
        reg_ptr = reg_entry;
    } else if (info->intr_status_reg_list != NULL) {
        reg_ptr = info->intr_status_reg_list;
    } else {
        return SOC_E_NONE;
    }
    if (INVALIDf != info->intr_status_field) {
        parity_error_field = info->intr_status_field;
    }

    has_error = FALSE;
    for (idx = 0; reg_ptr[idx].reg != INVALIDr; idx++) {
        reg = reg_ptr[idx].reg;
        mem_str_ptr = (reg_ptr[idx].str != NULL) ?
                       reg_ptr[idx].str : mem_str;
        sal_memset(&spci, 0, sizeof(spci));

        SOC_IF_ERROR_RETURN
            (soc_reg32_get(unit, reg, port, 0, &rval));
        if (soc_reg_field_get(unit, reg, rval, parity_error_field)) {
            has_error = TRUE;
            multiple = soc_reg_field_get(unit, reg, rval, MULTIPLE_ERRf);
            entry_idx = soc_reg_field_get(unit, reg, rval, ENTRY_IDXf);

            _soc_fl_mem_parity_info(unit, block_info_idx, 0,
                             info->group_reg_status_field, &minfo);
            if (parity_type == _SOC_PARITY_TYPE_ECC_DUAL) {
                report_type = SOC_SWITCH_EVENT_DATA_ERROR_ECC;
                double_bit = 1;
            } else if (parity_type == _SOC_PARITY_TYPE_ECC) {
                report_type = SOC_SWITCH_EVENT_DATA_ERROR_ECC;
                if (soc_reg_field_valid(unit, reg, DOUBLE_BIT_ERRf)) {
                    double_bit =
                        soc_reg_field_get(unit, reg, rval, DOUBLE_BIT_ERRf);
                } else {
                    return SOC_E_INTERNAL;
                }
            }

            soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                               report_type,
                               entry_idx, minfo);
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unit %d %s entry %d %s error\n"),
                       unit, mem_str_ptr, entry_idx,
                       ((parity_type == _SOC_PARITY_TYPE_ECC ||
                         parity_type == _SOC_PARITY_TYPE_ECC_DUAL) ?
                         "ecc" : "parity")));
            if (multiple) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "unit %d %s has multiple %s errors\n"),
                           unit, mem_str_ptr,
                       ((parity_type == _SOC_PARITY_TYPE_ECC ||
                         parity_type == _SOC_PARITY_TYPE_ECC_DUAL) ?
                             "ecc" : "parity")));
            }
            spci.flags = SOC_SER_SRC_MEM;
            if (multiple) {
                spci.flags |= SOC_SER_ERR_MULTI;
            }
            if (double_bit) {
                spci.double_bit = 1;
            }
            spci.reg = INVALIDr;
            spci.mem = info->mem;
            spci.blk_type = blocktype;
            spci.index = entry_idx;
            spci.detect_time = sal_time_usecs();
            spci.pipe_num = 0;
            spci.acc_type = -1;
            spci.addr = (spci.mem != INVALIDm)? SOC_MEM_BASE(unit, spci.mem) : 0;
            if (spci.mem != INVALIDm) {
                spci.flags |= SOC_SER_REG_MEM_KNOWN;
                (void)soc_ser_correction(unit, &spci);
            }
            /* Clear parity status */
            SOC_IF_ERROR_RETURN
                (soc_reg32_set(unit, reg, port, 0, 0));
        }
    }
    if (!has_error) {
        LOG_VERBOSE(BSL_LS_SOC_SER,
            (BSL_META_U(unit,
                        "unit %d %s parity hardware inconsistency\n"),
             unit, mem_str));
    }

    return SOC_E_NONE;

}

#ifdef INCLUDE_XFLOW_MACSEC
STATIC int
_soc_fl_ser_process_macsec_ecc(int unit, int block_info_idx, int port,
                                _soc_fl_ser_info_t *info,
                                char *mem_str,
                                soc_block_t blocktype, int parity_type)
{

    soc_fl_ecc_data_t data;

    data.block_info_idx = block_info_idx;
    data.info = info;
    data.mem_str = mem_str;
    data.blocktype = blocktype;
    data.port = REG_PORT_ANY;
    data.parity_type = parity_type;

    (void)xflow_macsec_process_ecc_intr(unit, (void*)&data);
    return SOC_E_NONE;
}
#endif

#define _SOC_FL_DBG_COUNTER_MAX     (12)
static soc_reg_t dbgc_regs[_SOC_FL_DBG_COUNTER_MAX] = {
    TDBGC0r, TDBGC1r,  TDBGC2r,  TDBGC3r,
    TDBGC4r, TDBGC5r,  TDBGC6r,  TDBGC7r,
    TDBGC8r, TDBGC9r, TDBGC10r, TDBGC11r
};

STATIC int
_soc_fl_ser_process_parity_counter(int unit, int block_info_idx, int port,
                                    _soc_fl_ser_info_t *info,
                                    char *mem_str,
                                    soc_block_t blocktype)
{
    soc_reg_t reg, counter_reg;
    uint32 rval, minfo;
    uint32 multiple, counter_idx, port_idx;
    char *counter_name;
    _soc_ser_correct_info_t spci;
    soc_field_t parity_error_field = PARITY_ERRf;

    reg = info->intr_status_reg;
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg,
                                      port, 0, &rval));
    if (soc_reg_field_get(unit, reg, rval, parity_error_field)) {
        multiple = soc_reg_field_get(unit, reg, rval, MULTIPLE_ERRf);
        counter_idx = soc_reg_field_get(unit, reg, rval, COUNTER_IDXf);
        port_idx = soc_reg_field_get(unit, reg, rval, PORT_IDXf);

        counter_reg = dbgc_regs[counter_idx];
        _soc_fl_mem_parity_info(unit, block_info_idx, 0,
                                 info->group_reg_status_field, &minfo);
        soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                           SOC_SWITCH_EVENT_DATA_ERROR_PARITY,
                           counter_idx, minfo);
        counter_name = SOC_REG_NAME(unit, counter_reg);
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "EGR STAT COUNTER port %d %s"
                              " : parity error\n"),
                   port_idx, counter_name));

        sal_memset(&spci, 0, sizeof(spci));
        spci.flags = SOC_SER_SRC_REG | SOC_SER_REG_MEM_KNOWN;
        spci.mem = INVALIDm;
        spci.port = port_idx;
        spci.index = -1;
        spci.reg = counter_reg;
        spci.blk_type = blocktype;
        (void)soc_ser_correction(unit, &spci);
        if (multiple) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "EGR STAT COUNTER has "
                                  "multiple parity errors\n")));
        }
    }else {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "EGR STAT COUNTER parity "
                              "hardware inconsistency\n")));
    }
    /* Clear parity status */
    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg,  port, 0, 0));

    return SOC_E_NONE;
}

#ifdef INCLUDE_XFLOW_MACSEC
/* parity enable for macsec block */
STATIC int
_soc_fl_macsec_ser_config(int unit, soc_reg_t enable_reg,
                          soc_field_t *enable_field_list, int port,
                          int enable)
{
    int idx;
    uint64 rval64;

    if (!SOC_REG_IS_VALID(unit, enable_reg)) {
        return SOC_E_NONE;
    }
    SOC_IF_ERROR_RETURN
        (soc_reg_get(unit, enable_reg, port, 0, &rval64));

    idx = 0;
    while (enable_field_list[idx] != INVALIDf) {
        soc_reg64_field32_set(unit, enable_reg, &rval64, enable_field_list[idx],
                                enable ? 1 : 0);
        idx++;
    }
    SOC_IF_ERROR_RETURN
        (soc_reg_set(unit, enable_reg, port, 0, rval64));

    return SOC_E_NONE;
}
#endif

/* parity enable for mmu block */
STATIC int
_soc_fl_mmu_ser_config(int unit, _soc_fl_ser_info_t *info_list,
                        soc_reg_t group_reg, soc_mem_t mem,
                        int enable)
{
    _soc_fl_ser_info_t *info;
    int info_index, rv;
    uint32 rval;

    rv = SOC_E_NOT_FOUND;
    SOC_IF_ERROR_RETURN
        (soc_reg32_get(unit, group_reg, REG_PORT_ANY, 0,
                       &rval));
    /* Loop through each info entry in the list */
    for (info_index = 0; ; info_index++) {
        info = &info_list[info_index];
        if (info->type == _SOC_PARITY_TYPE_NONE) {
            /* End of table */
            break;
        }
        if ((mem != INVALIDm) && (mem != info->mem)) {
            continue;
        }
        rv = SOC_E_NONE;
        soc_reg_field_set(unit, group_reg, &rval,
                          info->group_reg_enable_field,
                          enable ? 1 : 0);

        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, group_reg, REG_PORT_ANY, 0, rval));
    }
    return rv;
}
/* parity enable for xlport */
STATIC int
_soc_fl_pm_ser_config(int unit, _soc_fl_ser_info_t *info_list,
                       int block_info_idx, soc_reg_t group_reg,
                       int enable)
{
    _soc_fl_ser_info_t *info;
    int info_index, port;
    uint32 rval, group_rval;
    soc_reg_t reg;


    port = SOC_BLOCK_PORT(unit, block_info_idx);
    SOC_IF_ERROR_RETURN
        (soc_reg32_get(unit, group_reg, REG_PORT_ANY, 0,
                       &group_rval));
    /* Loop through each info entry in the list */
    for (info_index = 0; ; info_index++) {
        info = &info_list[info_index];
        if (info->type == _SOC_PARITY_TYPE_NONE) {
            /* End of table */
            break;
        }
        reg = info->enable_reg;
        SOC_IF_ERROR_RETURN
            (soc_reg32_get(unit, reg, port, 0, &rval));
        soc_reg_field_set(unit, reg, &rval, info->enable_field,
                          enable ? 1 : 0);
        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, reg, port, 0, rval));

        soc_reg_field_set(unit, group_reg, &group_rval,
                          info->group_reg_enable_field,
                          enable ? 1 : 0);

        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, group_reg, port, 0, group_rval));
    }
    return SOC_E_NONE;
}

int
soc_fl_ser_enable_info(int unit, int block_info_idx, int inst, int port,
                         soc_reg_t group_reg, uint64 *group_rval,
                         _soc_fl_ser_info_t *info_list,
                         soc_mem_t mem, int enable)
{
    _soc_fl_ser_info_t *info;
    int         info_index, rv;
    soc_reg_t   reg;
    uint64      rval64;

    rv = SOC_E_NOT_FOUND;

    /* Loop through each info entry in the list */
    for (info_index = 0; ; info_index++) {
        info = &info_list[info_index];
        if (info->type == _SOC_PARITY_TYPE_NONE) {
            /* End of table */
            break;
        }
        if (_soc_fl_ser_mem_skip(unit, info)) {
            continue;
        }
        if ((mem != INVALIDm) && (mem != info->mem)) {
            continue;
        }
        rv = SOC_E_NONE;
        if (group_reg != INVALIDr && info->group_reg_enable_field != INVALIDf) {
            if (!soc_reg_field_valid(unit, group_reg,
                                     info->group_reg_enable_field)) {
                continue;
            }
            /* Enable the info entry in the group register */
            soc_reg64_field32_set(unit, group_reg, group_rval,
                                  info->group_reg_enable_field, enable ? 1 : 0);
        }
        /* Handle different parity error reporting style */
        switch (info->type) {
        case _SOC_PARITY_TYPE_PORT_XL:
            /* only ecc in pm, don't need mem information */
            rv =_soc_fl_pm_ser_config(unit, info->info, block_info_idx,
                                       info->intr_enable_reg, enable);
            break;
        case _SOC_PARITY_TYPE_MMU_SER:
        case _SOC_PARITY_TYPE_ECC:
        case _SOC_PARITY_TYPE_ECC_DUAL:
        case _SOC_PARITY_TYPE_PARITY:
        case _SOC_PARITY_TYPE_PARITY_DUAL:
#ifdef INCLUDE_XFLOW_MACSEC
        case _SOC_PARITY_TYPE_MACSEC_ECC:
#endif
            reg = info->enable_reg;
            if (!SOC_REG_IS_VALID(unit, reg)) {
                break;
            }
            SOC_IF_ERROR_RETURN
                (soc_reg_get(unit, reg, port, 0, &rval64));
            soc_reg64_field32_set(unit, reg, &rval64, info->enable_field,
                                  enable ? 1 : 0);
            SOC_IF_ERROR_RETURN
                (soc_reg_set(unit, reg, port, 0, rval64));

            LOG_VERBOSE(BSL_LS_SOC_SOCMEM,
                        (BSL_META_U(unit,
                                    "SER enable for: %s\n"),
                         (info->mem == INVALIDm) ? info->mem_str :
                         SOC_MEM_NAME(unit, info->mem)));
            if (info->type == _SOC_PARITY_TYPE_MMU_SER) {
                rv = _soc_fl_mmu_ser_config(unit, info->info,
                                             info->intr_enable_reg,
                                             mem, enable);
            }

#ifdef INCLUDE_XFLOW_MACSEC
            if (info->type == _SOC_PARITY_TYPE_MACSEC_ECC) {
                rv = _soc_fl_macsec_ser_config(unit, info->intr_enable_reg,
                                        info->intr_enable_field_list,
                                        port, enable);
            }
#endif
            break;
        default: break;
        }
    }
    return rv;
}

#if defined(SER_TR_TEST_SUPPORT)
/* Overlay memory */
const soc_ser_overlay_test_t soc_ser_fl_overlay_mems[] = {
    {L3_ENTRY_IPV4_UNICASTm, L3_ENTRY_PARITY_CONTROLr, PARITY_ENf, L3_ENTRY_ONLYm,  _SOC_ACC_TYPE_PIPE_ANY},
    {L3_ENTRY_IPV4_MULTICASTm, L3_ENTRY_PARITY_CONTROLr, PARITY_ENf, L3_ENTRY_ONLYm,  _SOC_ACC_TYPE_PIPE_ANY},
    {L3_ENTRY_IPV6_MULTICASTm, L3_ENTRY_PARITY_CONTROLr, PARITY_ENf, L3_ENTRY_ONLYm,  _SOC_ACC_TYPE_PIPE_ANY},
    {L3_ENTRY_IPV6_UNICASTm, L3_ENTRY_PARITY_CONTROLr, PARITY_ENf, L3_ENTRY_ONLYm,  _SOC_ACC_TYPE_PIPE_ANY},
    {MODPORT_MAPm, MODPORT_MAP_SW_PARITY_CONTROLr, PARITY_ENf, MODPORT_MAP_SWm,  _SOC_ACC_TYPE_PIPE_ANY},
    {EGR_IP_TUNNEL_IPV6m, EGR_IP_TUNNEL_PARITY_CONTROLr, PARITY_ENf, EGR_IP_TUNNELm,  _SOC_ACC_TYPE_PIPE_ANY},
    {INVALIDm}
};

STATIC int
soc_fl_tcam_entry_is_invalid(int unit, soc_mem_t mem, int index)
{
    if (soc_feature(unit, soc_feature_field_slice_size128)) {
        if (mem == FP_GLOBAL_MASK_TCAMm ||  mem == FP_TCAMm) {
            if ((index / 64) % 2) {
                return TRUE;
            }
        }
    }
    return FALSE;
}

#ifdef INCLUDE_XFLOW_MACSEC
/*
 * Function:
 *      soc_fl_ser_sp_tcam_corrupt_parity_enable
 * Purpose:
 *      Enable/Disable corruption of SP TCAM entries. Enable ensures computed
 *      parity for new writes are corrupted.
 * Parameters:
 *      unit               - (IN) Device Number
 *      mem                - (IN) The memory to test
 *      enable             - (IN) Enable corrupting any further writes
 *
 * Returns:
 *      SOC_E_NONE
 */
STATIC int
soc_fl_ser_sp_tcam_corrupt_parity_enable(int unit, soc_mem_t mem, int enable)
{
    soc_reg_t reg = ISEC_SER_CONTROLr;
    soc_field_t field = SP_TCAM_ONE_BIT_ERR_INJECTf;
    uint32 rval;

    if (mem != ISEC_SP_TCAM_KEYm &&
        mem != ISEC_SP_TCAM_MASKm) {
        return SOC_E_NONE;
    }
    SOC_IF_ERROR_RETURN
        (soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
    soc_reg_field_set(unit, reg, &rval, field, enable);
    SOC_IF_ERROR_RETURN
        (soc_reg32_set(unit, reg, REG_PORT_ANY, 0, rval));
    return SOC_E_NONE;
}
#endif

/*
 * Function:
 *      soc_fl_ser_inject_error
 * Purpose:
 *       Injects an error into a single memory
 * Parameters:
 *      unit               - (IN) Device Number
 *      mem                - (IN) The memory to test
 *      pipeTarget  - (IN) The pipe (x/y) to use when injecting the error
 *      block - (IN) The index into which block will be injected.
 *      index  - (IN) The index into which the error will be injected.
 */
int soc_fl_ser_inject_error(int unit, uint32 flags, soc_mem_t mem,
                            int pipeTarget, int block, int index)
{
    /* _soc_generic_ser_info_t *tcam_ser_info = _soc_fl_tcam_ser_info[unit]; */
    _soc_generic_ser_info_t *tcam_ser_info = soc_fl_ser_tcam_ser_info_get(unit);
    soc_reg_t   parity_enable_reg = INVALIDr;
    soc_field_t hw_parity_field = INVALIDf;
    soc_field_t test_field = INVALIDf;
    uint8       rbi;
    _soc_fl_ser_route_block_t *rb;
    uint32      cmic_bit;
    int         block_info_idx;
    soc_mem_t   memTable;
    uint32 tmp_entry[SOC_MAX_MEM_WORDS], fieldData[SOC_MAX_REG_FIELD_WORDS];
    int         i, overlay_mem = 0;
    ser_test_data_t test_data;
    int         port = REG_PORT_ANY;
    _soc_fl_ser_info_t *info_list, *info;
    int         info_index;

    if (!SOC_MEM_IS_VALID(unit, mem)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d, mem %d is INVALID or not valid "
                              "for this unit !!\n"),
                   unit, mem));
        return SOC_E_UNAVAIL;
    }
    if (tcam_ser_info != NULL) {
        /*TCAM_test*/
        for (i = 0; tcam_ser_info[i].mem != INVALIDm; i++) {
            if (tcam_ser_info[i].mem == mem) {
                /* Check if this entry is invalid or not */
                if (soc_fl_tcam_entry_is_invalid(unit, mem, index)) {
                    return SOC_E_PARAM;
                }
                soc_ser_create_test_data(unit, tmp_entry, fieldData,
                                 SER_RANGE_ENABLEr, i, VALIDf, mem,
                                 VALIDf, MEM_BLOCK_ANY, REG_PORT_ANY,
                                 _SOC_ACC_TYPE_PIPE_ANY, index, &test_data);
                /*Disable parity*/
                SOC_IF_ERROR_RETURN(
                    _ser_test_parity_control(unit, &test_data, 0));
                /*Read the memory for successful injection*/
                SOC_IF_ERROR_RETURN(ser_test_mem_read(unit, 0, &test_data));
                /*Inject error*/
                SOC_IF_ERROR_RETURN(soc_ser_test_inject_full(unit, flags,
                                                             &test_data));
                /*Enable parity*/
                SOC_IF_ERROR_RETURN(
                    _ser_test_parity_control(unit, &test_data, 1));
                return SOC_E_NONE;
            }
        }
    }

    /* Loop through each place-and-route block entry */
    for (rbi = 0; ; rbi++) {
        rb = &_soc_fl_ser_route_blocks[rbi];
        cmic_bit = rb->cmic_bit;
        parity_enable_reg = INVALIDr;
        hw_parity_field = INVALIDf;
        if (cmic_bit == 0) {
            /* End of table */
            break;
        }
        SOC_BLOCK_ITER(unit, block_info_idx, rb->blocktype) {
            if (SOC_BLOCK_INFO(unit, block_info_idx).number == rb->id) {
                port = SOC_BLOCK_PORT(unit, block_info_idx);
                break;
            }
        }
        if ((block != MEM_BLOCK_ANY) && (block != block_info_idx)) {
            continue;
        }
        info_list = rb->info;
        if (info_list[0].type == _SOC_PARITY_TYPE_MMU_SER) {
            parity_enable_reg = info_list[0].enable_reg;
            hw_parity_field = info_list[0].enable_field;
            info_list = info_list[0].info;
        }
        for (info_index = 0; ; info_index++) {
            info = &info_list[info_index];
            if (info->type == _SOC_PARITY_TYPE_NONE) {
                /* End of table */
                break;
            }
            if (_soc_fl_ser_mem_skip(unit, info)) {
                continue;
            }
            memTable = info->mem;
            if (memTable == INVALIDm) {
                continue;
            }
            /* Check if overlay memory */
            for (i=0; soc_ser_fl_overlay_mems[i].mem != INVALIDm; i++) {
                if ((soc_ser_fl_overlay_mems[i].mem == mem) &&
                    (soc_ser_fl_overlay_mems[i].base_mem == memTable)) {
                    overlay_mem = 1;
                    break;
                }
            }
            if ((memTable == mem) || (overlay_mem)) {
                /* Inject error */
                test_data.mem = mem;
                test_data.tcam_parity_bit = -1;
                if (parity_enable_reg == INVALIDr) {
                    parity_enable_reg = info->enable_reg;
                }
                if (hw_parity_field == INVALIDf) {
                    hw_parity_field = info->enable_field;
                }
                if (_soc_fl_ser_2bit_ecc_mem(unit, memTable)) {
                    flags |= SOC_INJECT_ERROR_2BIT_ECC;
                    test_field = ECCf;
                } else {
                    test_field = EVEN_PARITYf;
                }
#ifdef INCLUDE_XFLOW_MACSEC
                if ((info->type == _SOC_PARITY_TYPE_MACSEC_ECC) &&
                    (info->intr_clr_reg == INVALIDr) &&
                    (info->intr_clr_field != INVALIDf)) {

                    /* Override test_field for Macsec memories. */
                    test_field = info->intr_clr_field;
                }
#endif
                soc_ser_create_test_data(unit, tmp_entry,
                                         fieldData,
                                         parity_enable_reg,
                                         SOC_INVALID_TCAM_PARITY_BIT,
                                         hw_parity_field,
                                         mem, test_field, block,
                                         port, _SOC_ACC_TYPE_PIPE_ANY,
                                         index, &test_data);
                /* Disable parity */
                SOC_IF_ERROR_RETURN(
                    _ser_test_parity_control(unit, &test_data, 0));

#ifdef INCLUDE_XFLOW_MACSEC
                /* Enable corruption if applicable. */
                SOC_IF_ERROR_RETURN(
                    soc_fl_ser_sp_tcam_corrupt_parity_enable(unit, mem, 1));
#endif

                /* Read the memory for successful injection */
                SOC_IF_ERROR_RETURN(
                    ser_test_mem_read(unit, 0, &test_data));

                /* Inject error */
                SOC_IF_ERROR_RETURN(
                    soc_ser_test_inject_full(unit, flags, &test_data));

#ifdef INCLUDE_XFLOW_MACSEC
                /* Disable corruption if applicable. */
                SOC_IF_ERROR_RETURN(
                    soc_fl_ser_sp_tcam_corrupt_parity_enable(unit, mem, 0));
#endif

                /* Enable parity */
                SOC_IF_ERROR_RETURN(
                    _ser_test_parity_control(unit, &test_data, 1));
                return SOC_E_NONE;
            }
        }
    }
    /* The tested memory is not found in SER enabled list, can't inject error of it */
    return SOC_E_UNAVAIL;
}

soc_error_t
ser_fl_ser_error_injection_support(int unit, soc_mem_t mem,
                                    int pipe_target)
{
    int rv = SOC_E_UNAVAIL;
    int i = 0, hw_enable_ix = 0;
    int overlay_mem = 0, block_info_idx = 0;
    uint32 range_enable;

    uint8       rbi;
    soc_mem_t   memTable;
    int         info_index;
    _soc_generic_ser_info_t *tcam_ser_info;
    _soc_fl_ser_route_block_t *rb;
    _soc_fl_ser_info_t *info_list, *info;

    if ((mem == MMU_WRED_AVG_QSIZEm) ||
        (mem == MMU_WRED_AVG_QSIZE_QGROUPm) ||
        (mem == MMU_WRED_MARK_THDm)) {
        /*
         * Inject function aim for SQA to test SER in an easiler way
         * To support above memories, soc_mem_read need to support
         * FUNCTIONAL_REFRESH_ENr which is not a general case of SER.
         * Also, TR144 & SER recovery have supported those memories.
         * Thus, we disable them on inject function.
         */
        return rv;
    }

    LOG_VERBOSE(BSL_LS_SOC_SER,
                    (BSL_META_U(unit,
                                "unit %d, mem %s, pipe_target %d\n"),
                     unit, SOC_MEM_NAME(unit,mem), pipe_target));

    if (!SOC_MEM_IS_VALID(unit, mem)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d, mem %d is INVALID or not valid "
                              "for this unit !!\n"),
                   unit, mem));
        return rv;
    }

    /*tcam_ser_info = _soc_fl_tcam_ser_info[unit]; */
    tcam_ser_info = soc_fl_ser_tcam_ser_info_get(unit);

    /* Search TCAMs */
    if (tcam_ser_info != NULL) {

        /* Check if enable */
        SOC_IF_ERROR_RETURN
            (READ_SER_RANGE_ENABLEr(unit, &range_enable));
        LOG_DEBUG(BSL_LS_SOC_SER,
                        (BSL_META_U(unit,
                                    "Search TCAMs: SER_RANGE_ENABLE 0x%X\n"),
                         range_enable));
        for (i = 0; tcam_ser_info[i].mem != INVALIDm; i++) {
            if (tcam_ser_info[i].mem == mem) {

                hw_enable_ix = tcam_ser_info[i].ser_hw_index;
                LOG_DEBUG(BSL_LS_SOC_SER,
                                (BSL_META_U(unit,
                                            "SER Range HW Enable index %d\n"),
                                 hw_enable_ix));
                if (((range_enable >> hw_enable_ix) & 0x1) == 0) {
                    LOG_WARN(BSL_LS_SOC_SER,
                                    (BSL_META_U(unit,
                                                "matched mem but SER detection is disabled\n"
                                                "SER_RANGE_ENABLE 0x%X, SER Range HW index %d\n"),
                                     range_enable,hw_enable_ix));
                    return rv; /* matched mem but ser_detection is disabled */
                }
                LOG_VERBOSE(BSL_LS_SOC_SER,
                                (BSL_META_U(unit,
                                            "TCAM found\n")));
                return SOC_E_NONE; /* found */
            }
        }
    }


    /* Search H/W memory (route blocks) */
    /* Loop through each place-and-route block entry */
    for (rbi = 0; ; rbi++) {
        rb = &_soc_fl_ser_route_blocks[rbi];
        if (rb->cmic_bit == 0) {
            /* End of table */
            break;
        }

        SOC_BLOCK_ITER(unit, block_info_idx, rb->blocktype) {
            if (SOC_BLOCK_INFO(unit, block_info_idx).number == rb->id) {
                break;
            }
        }

        info_list = rb->info;
        if (info_list[0].type == _SOC_PARITY_TYPE_MMU_SER) {
            info_list = info_list[0].info;
        }
        for (info_index = 0; ; info_index++) {
            info = &info_list[info_index];
            if (info->type == _SOC_PARITY_TYPE_NONE) {
                /* End of table */
                break;
            }
            if (_soc_fl_ser_mem_skip(unit, info)) {
                continue;
            }
            memTable = info->mem;
            if (memTable == INVALIDm) {
                continue;
            }
            /* Check if overlay memory */
            for (i=0; soc_ser_fl_overlay_mems[i].mem != INVALIDm; i++) {
                if ((soc_ser_fl_overlay_mems[i].mem == mem) &&
                    (soc_ser_fl_overlay_mems[i].base_mem == memTable)) {
                    overlay_mem = 1;
                    LOG_DEBUG(BSL_LS_SOC_SER,
                                    (BSL_META_U(unit,
                                                "mem %s base_mem %s\n"),
                                     SOC_MEM_NAME(unit,mem),SOC_MEM_NAME(unit,memTable)));
                    break;
                }
            }
            if ((memTable == mem) || (overlay_mem)) {
                LOG_VERBOSE(BSL_LS_SOC_SER,
                                (BSL_META_U(unit,
                                            "H/W memory (route blocks) found\n")));
                return SOC_E_NONE;
            }
        }
    }
    /* The tested memory is not found in SER enabled list, can't inject error of it */
    return rv;
}

/*
 * Function:
 *      soc_fl_ser_mem_test
 * Purpose:
 *      Performs a SER test on a single memory
 *      tr 144 = mem
 * Parameters:
 *      unit               - (IN) Device Number
 *      mem                - (IN) The memory to test
 *      test_type        - (IN) How many indices in the memory to test
 *      cmd         - (IN) TRUE if a command-line test is desired.
 */
int soc_fl_ser_test_mem(int unit, soc_mem_t mem,
                         _soc_ser_test_t test_type, int cmd)
{
    /*_soc_generic_ser_info_t *tcam_ser_info = _soc_fl_tcam_ser_info[unit]; */
    _soc_generic_ser_info_t *tcam_ser_info = soc_fl_ser_tcam_ser_info_get(unit);
    soc_reg_t   parity_enable_reg = INVALIDr;
    soc_field_t hw_parity_field = INVALIDf;
    uint8       rbi;
    _soc_fl_ser_route_block_t *rb;
    uint32      cmic_bit;
    int         block_info_idx;
    int         found_mem = FALSE;
    soc_mem_t   memTable;
    int         testErrors = 0;
    ser_test_data_t test_data;
    uint32 tmp_entry[SOC_MAX_MEM_WORDS], fieldData[SOC_MAX_REG_FIELD_WORDS];
    int         i, overlay_mem = 0;
    int         rv = SOC_E_NONE;
    int         port = REG_PORT_ANY;
    _soc_fl_ser_info_t *info_list, *info;
    int         info_index;
    uint32      wred_refresh = 0, reg_val;
    soc_field_t test_field = INVALIDf;

    if (!SOC_MEM_IS_VALID(unit, mem)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d, mem %d is INVALID or not valid "
                              "for this unit !!\n"),
                   unit, mem));
        return SOC_E_UNAVAIL;
    }

    if (!SAL_BOOT_QUICKTURN) {
        soc_ser_test_long_sleep = TRUE;
        soc_ser_test_long_sleep_time_us = 500000;
    }
    if (tcam_ser_info != NULL) {
        /*TCAM_test*/
        for (i = 0; tcam_ser_info[i].mem != INVALIDm; i++) {
            if (tcam_ser_info[i].mem == mem) {
                memTable = mem;
                found_mem = TRUE;
                soc_ser_create_test_data(unit, tmp_entry, fieldData,
                                         SER_RANGE_ENABLEr, i, INVALIDf, memTable,
                                         VALIDf, MEM_BLOCK_ANY, REG_PORT_ANY,
                                         _SOC_ACC_TYPE_PIPE_ANY, 0, &test_data);
               if (cmd) {
                    ser_test_cmd_generate(unit, &test_data);
                } else {
                    rv = ser_test_mem(unit, 0, &test_data,
                        test_type, &testErrors);
                    if (rv != SOC_E_NONE) {
                        LOG_CLI((BSL_META_U(unit,
                            "Error during TCAM test.  Aborting.\n")));
                        soc_ser_test_long_sleep = FALSE;
                        return rv;
                    }
                }
            }
        }
    }

    if (!found_mem) {
        /*H/W memory Test*/
        /* Loop through each place-and-route block entry */
        for (rbi = 0; ; rbi++) {
            rb = &_soc_fl_ser_route_blocks[rbi];
            cmic_bit = rb->cmic_bit;
            parity_enable_reg = INVALIDr;
            hw_parity_field = INVALIDf;
            if (cmic_bit == 0) {
                /* End of table */
                break;
            }
            SOC_BLOCK_ITER(unit, block_info_idx, rb->blocktype) {
                if (SOC_BLOCK_INFO(unit, block_info_idx).number == rb->id) {
                    port = SOC_BLOCK_PORT(unit, block_info_idx);
                    break;
                }
            }
            info_list = rb->info;
            if (info_list[0].type == _SOC_PARITY_TYPE_MMU_SER) {
                parity_enable_reg = info_list[0].enable_reg;
                hw_parity_field = info_list[0].enable_field;
                info_list = info_list[0].info;
            }
            for (info_index = 0; ; info_index++) {
                info = &info_list[info_index];
                if (info->type == _SOC_PARITY_TYPE_NONE) {
                    /* End of table */
                    break;
                }
                if (_soc_fl_ser_mem_skip(unit, info)) {
                    continue;
                }
                memTable = info->mem;
                if (memTable == INVALIDm) {
                    continue;
                }
                /* Check if overlay memory */
                for (i=0; soc_ser_fl_overlay_mems[i].mem != INVALIDm; i++) {
                    if ((soc_ser_fl_overlay_mems[i].mem == mem) &&
                        (soc_ser_fl_overlay_mems[i].base_mem == memTable)) {
                        overlay_mem = 1;
                        break;
                    }
                }
                if ((memTable == mem) || (overlay_mem)) {
                    found_mem = TRUE;
                    if (parity_enable_reg == INVALIDr) {
                        parity_enable_reg = info->enable_reg;
                    }
                    if (hw_parity_field == INVALIDf) {
                        hw_parity_field = info->enable_field;
                    }
                    if ((memTable == MMU_WRED_AVG_QSIZEm) ||
                        (memTable == MMU_WRED_AVG_QSIZE_QGROUPm) ||
                        (memTable == MMU_WRED_MARK_THDm)) {
                        rv = soc_reg32_get(unit,
                                        FUNCTIONAL_REFRESH_ENr, port, 0,
                                        &reg_val);
                        if (rv != SOC_E_NONE) {
                            LOG_CLI((BSL_META_U(unit,
                                     "Error of getting WRED "
                                     "refresh function  Aborting.\n")));
                            soc_ser_test_long_sleep = FALSE;
                            return rv;
                        }
                        wred_refresh = soc_reg_field_get(unit,
                            FUNCTIONAL_REFRESH_ENr,
                            reg_val, WRED_REFRESH_ENf);
                        if (wred_refresh) {
                            soc_reg_field_set(unit,
                                FUNCTIONAL_REFRESH_ENr, &reg_val,
                                WRED_REFRESH_ENf, 0);
                            rv = soc_reg32_set(unit,
                                FUNCTIONAL_REFRESH_ENr, port, 0,
                                reg_val);
                            if (rv != SOC_E_NONE) {
                                LOG_CLI((BSL_META_U(unit,
                                    "Error of disabling WRED "
                                    "refresh function  Aborting.\n")));
                                soc_ser_test_long_sleep = FALSE;
                                return rv;
                            }
                        }
                    }
                    test_field = INVALIDf;
#ifdef INCLUDE_XFLOW_MACSEC
                    if ((info->type == _SOC_PARITY_TYPE_MACSEC_ECC) &&
                        (info->intr_clr_reg == INVALIDr) &&
                        (info->intr_clr_field != INVALIDf)) {

                        /* Override test_field for Macsec memories. */
                        test_field = info->intr_clr_field;
                        port = REG_PORT_ANY;
                    }
                    /* Disable corruption if applicable. */
                    SOC_IF_ERROR_RETURN(
                        soc_fl_ser_sp_tcam_corrupt_parity_enable(unit, mem, 1));

#endif
                    soc_ser_create_test_data(unit, tmp_entry,
                                             fieldData,
                                             parity_enable_reg,
                                             SOC_INVALID_TCAM_PARITY_BIT,
                                             hw_parity_field,
                                             mem, test_field, block_info_idx,
                                             port, _SOC_ACC_TYPE_PIPE_ANY,
                                             0, &test_data);
                    if (cmd) {
                        ser_test_cmd_generate(unit, &test_data);
                    } else {
                        rv = ser_test_mem(unit, 0, &test_data,
                                          test_type, &testErrors);
                    }
                    if ((memTable == MMU_WRED_AVG_QSIZEm) ||
                        (memTable == MMU_WRED_AVG_QSIZE_QGROUPm) ||
                        (memTable == MMU_WRED_MARK_THDm)) {
                        /* restore WRED refresh configuration */
                        if (wred_refresh) {
                            soc_reg_field_set(unit,
                                FUNCTIONAL_REFRESH_ENr, &reg_val,
                                WRED_REFRESH_ENf, 1);
                            rv = soc_reg32_set(unit,
                                FUNCTIONAL_REFRESH_ENr, port, 0,
                                reg_val);
                            if (rv != SOC_E_NONE) {
                                LOG_CLI((BSL_META_U(unit,
                                    "Error of enabling WRED "
                                    "refresh function  Aborting.\n")));
                                soc_ser_test_long_sleep = FALSE;
                                return rv;
                            }
                        }
                    }
#ifdef INCLUDE_XFLOW_MACSEC
                    /* Disable corruption if applicable. */
                    SOC_IF_ERROR_RETURN(
                        soc_fl_ser_sp_tcam_corrupt_parity_enable(unit, mem, 0));
#endif
                    if (rv != SOC_E_NONE) {
                        LOG_CLI((BSL_META_U(unit,
                                            "Error during H/W test.  Aborting.\n")));
                        soc_ser_test_long_sleep = FALSE;
                        return rv;
                    }
                    break;
                }
            }
            if (found_mem) {
                break;
            }
        }

    }
    if (!found_mem) {
        LOG_CLI((BSL_META_U(unit,
                 "SER Test is unavaible on unit: %d for memory %s\n"), unit,
                 SOC_MEM_NAME(unit,mem)));
        return SOC_E_UNAVAIL;
    }

    if (testErrors == 0) {
        LOG_CLI((BSL_META_U(unit,
                            "SER Test passed on unit: %d for memory %s\n"), unit,
                 SOC_MEM_NAME(unit,mem)));
    }
    else {
        LOG_CLI((BSL_META_U(unit,
                            "SER Test failed on unit: %d for memory %s\n"), unit,
                 SOC_MEM_NAME(unit,mem)));
        soc_ser_test_long_sleep = FALSE;
        return SOC_E_MEMORY;
    }
    /* restore to default */
    soc_ser_test_long_sleep = FALSE;
    return SOC_E_NONE;

}

/*
 * Function:
 *      soc_fl_ser_test
 * Purpose:
 *      Performs a SER test on all Memories
 *      tr 144
 * Parameters:
 *      unit               - (IN) Device Number
 *      test_type        - (IN) Determines how comprehensive of a test to run
 */
int soc_fl_ser_test(int unit, _soc_ser_test_t test_type)
{
    /*_soc_generic_ser_info_t *tcam_ser_info = _soc_fl_tcam_ser_info[unit]; */
    _soc_generic_ser_info_t *tcam_ser_info = soc_fl_ser_tcam_ser_info_get(unit);
    int         numTCAMErr = 0;
    int         numHwMemErr   = 0;
    soc_reg_t   parity_enable_reg = INVALIDr;
    soc_field_t hw_parity_field = INVALIDf;
    int         port = REG_PORT_ANY;
    uint8       rbi;
    _soc_fl_ser_route_block_t *rb;
    uint32      cmic_bit, reg_val;
    int         block_info_idx;
    int         rv = SOC_E_NONE;
    _soc_fl_ser_info_t *info_list, *info;
    int         info_index;
    soc_mem_t   memTable = INVALIDm;
    uint32      wred_refresh = 0;

    if (!SAL_BOOT_QUICKTURN) {
        soc_ser_test_long_sleep = TRUE;
        soc_ser_test_long_sleep_time_us = 500000;
    }

    if (tcam_ser_info != NULL) {
        int         i;
        /* TCAM_test */
        for (i = 0; tcam_ser_info[i].mem != INVALIDm; i++) {
            rv = ser_test_mem_pipe(unit, SER_RANGE_ENABLEr, i, -1,
                    tcam_ser_info[i].mem, VALIDf, test_type,
                    MEM_BLOCK_ANY, REG_PORT_ANY,
                    _SOC_ACC_TYPE_PIPE_ANY, &numTCAMErr);
            if (rv != SOC_E_NONE) {
                LOG_CLI((BSL_META_U(unit,
                                    "TR 144 test failed. "
                                    "Error during TCAM test.  Aborting.\n")));
                soc_ser_test_long_sleep = FALSE;
                return rv;
            }
        }
    }

    for (rbi = 0; ; rbi++) {
        rb = &_soc_fl_ser_route_blocks[rbi];
        cmic_bit = rb->cmic_bit;
        parity_enable_reg = INVALIDr;
        hw_parity_field = INVALIDf;
        if (cmic_bit == 0) {
            /* End of table */
            break;
        }
        SOC_BLOCK_ITER(unit, block_info_idx, rb->blocktype) {
            if (SOC_BLOCK_INFO(unit, block_info_idx).number == rb->id) {
                port = SOC_BLOCK_PORT(unit, block_info_idx);
                break;
            }
        }
        info_list = rb->info;

        if (info_list[0].type == _SOC_PARITY_TYPE_MMU_SER) {
            parity_enable_reg = info_list[0].enable_reg;
            hw_parity_field = info_list[0].enable_field;
            info_list = info_list[0].info;
        }
        for (info_index = 0; ; info_index++) {
            info = &info_list[info_index];
            if (info->type == _SOC_PARITY_TYPE_NONE) {
                /* End of table */
                break;
            }
            if (_soc_fl_ser_mem_skip(unit, info)) {
                continue;
            }
            memTable = info->mem;
            if (memTable == INVALIDm){
                continue;
            }
            if (parity_enable_reg == INVALIDr) {
                parity_enable_reg = info->enable_reg;
            }
            if (hw_parity_field == INVALIDf) {
                hw_parity_field = info->enable_field;
            }

            if ((memTable == MMU_WRED_AVG_QSIZEm) ||
                (memTable == MMU_WRED_AVG_QSIZE_QGROUPm) ||
                (memTable == MMU_WRED_MARK_THDm)) {
                rv = soc_reg32_get(unit,
                                FUNCTIONAL_REFRESH_ENr, port, 0,
                                &reg_val);
                if (rv != SOC_E_NONE) {
                    LOG_CLI((BSL_META_U(unit,
                             "Error of getting WRED "
                             "refresh function  Aborting.\n")));
                    soc_ser_test_long_sleep = FALSE;
                    return rv;
                }
                wred_refresh = soc_reg_field_get(unit,
                    FUNCTIONAL_REFRESH_ENr,
                    reg_val, WRED_REFRESH_ENf);
                if (wred_refresh) {
                    soc_reg_field_set(unit,
                        FUNCTIONAL_REFRESH_ENr, &reg_val,
                        WRED_REFRESH_ENf, 0);
                    rv = soc_reg32_set(unit,
                        FUNCTIONAL_REFRESH_ENr, port, 0,
                        reg_val);
                    if (rv != SOC_E_NONE) {
                        LOG_CLI((BSL_META_U(unit,
                            "Error of disabling WRED "
                            "refresh function  Aborting.\n")));
                        soc_ser_test_long_sleep = FALSE;
                        return rv;
                    }
                }
            }
            rv = ser_test_mem_pipe(unit, parity_enable_reg, -1,
                                   hw_parity_field,
                                   memTable, INVALIDf, test_type,
                                   block_info_idx, port,
                                   _SOC_ACC_TYPE_PIPE_ANY, &numHwMemErr);

            if ((memTable == MMU_WRED_AVG_QSIZEm) ||
                (memTable == MMU_WRED_AVG_QSIZE_QGROUPm) ||
                (memTable == MMU_WRED_MARK_THDm)) {
                /* restore WRED refresh configuration */
                if (wred_refresh) {
                    soc_reg_field_set(unit,
                        FUNCTIONAL_REFRESH_ENr, &reg_val,
                        WRED_REFRESH_ENf, 1);
                    rv = soc_reg32_set(unit,
                        FUNCTIONAL_REFRESH_ENr, port, 0,
                        reg_val);
                    if (rv != SOC_E_NONE) {
                        LOG_CLI((BSL_META_U(unit,
                            "Error of enabling WRED "
                            "refresh function  Aborting.\n")));
                        soc_ser_test_long_sleep = FALSE;
                        return rv;
                    }
                }
            }

            if (rv != SOC_E_NONE) {
                LOG_CLI((BSL_META_U(unit,
                          "TR 144 test failed. "
                          "Error during H/W test.  Aborting.\n")));
                soc_ser_test_long_sleep = FALSE;
                return rv;
            }
            if (rb->blocktype != SOC_BLK_MMU){
                parity_enable_reg = INVALIDr;
                hw_parity_field = INVALIDf;
            }
        }
    }

    if((numTCAMErr != 0) || (numHwMemErr != 0)) {
        LOG_CLI((BSL_META_U(unit,
            "TR 144 test failed.\n")));
    }

    LOG_CLI((BSL_META_U(unit,
              "Total TCAM errors on unit %d: %d\n"), unit, numTCAMErr));
    LOG_CLI((BSL_META_U(unit,
              "Total H/W parity errors on unit %d: %d\n"),unit, numHwMemErr));
    soc_ser_test_long_sleep = FALSE;
    return SOC_E_NONE;
}

STATIC int
_soc_fl_process_ser(int unit, soc_block_t block_info_idx, int inst,
                     int port, soc_reg_t group_reg, uint64 group_rval,
                     _soc_fl_ser_info_t *info_list,
                     soc_block_t blocktype)

{
    _soc_fl_ser_info_t *info;
    int info_index;
    char *mem_str;

    for (info_index = 0; ; info_index++) {
        info = &info_list[info_index];
        if (info->type == _SOC_PARITY_TYPE_NONE) {
            /* End of table */
            break;
        }
        if (_soc_fl_ser_mem_skip(unit, info)) {
            continue;
        }
        if (group_reg != INVALIDr) {
            /* Check status for the info entry in the group register */
            /* for SOC_BLK_MMU, group_reg is INVALIDr */
            if (!soc_reg_field_valid(unit, group_reg,
                                     info->group_reg_status_field)) {
                continue;
            }
            if (!soc_reg64_field32_get(unit, group_reg, group_rval,
                                       info->group_reg_status_field)) {
                continue;
            }
        }
        if (info->mem_str) {
            mem_str = info->mem_str;
        } else if (info->mem != INVALIDm) {
            mem_str = SOC_MEM_NAME(unit, info->mem);
        } else {
            mem_str = SOC_FIELD_NAME(unit, info->group_reg_status_field);
        }
        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                                "unit %d _soc_fl_process_ser %s analysis\n"),
                                unit, mem_str));

        /* Handle different parity error reporting style */
        switch (info->type) {
            case _SOC_PARITY_TYPE_MMU_SER:
                SOC_IF_ERROR_RETURN
                    (_soc_fl_ser_process_mmu_err(unit, block_info_idx,
                                                  INVALIDr, INVALIDr,
                                                  info));
                    /* info points to _soc_fl_mmu_top_ser_info[0] */
                break;
            case _SOC_PARITY_TYPE_PARITY:
                SOC_IF_ERROR_RETURN
                    (_soc_fl_ser_process_parity_ecc(unit, block_info_idx, port,
                                                     info, mem_str, blocktype,
                                                     info->type));
                break;
            case _SOC_PARITY_TYPE_PARITY_DUAL:
                SOC_IF_ERROR_RETURN
                    (_soc_fl_ser_process_parity_hash(unit, block_info_idx, port,
                                                      info, mem_str, blocktype));
                break;
            case _SOC_PARITY_TYPE_ECC:
            case _SOC_PARITY_TYPE_ECC_DUAL:
                SOC_IF_ERROR_RETURN
                    (_soc_fl_ser_process_parity_ecc(unit, block_info_idx, port,
                                                     info, mem_str, blocktype,
                                                     info->type));
                break;
            case _SOC_PARITY_TYPE_COUNTER:
                SOC_IF_ERROR_RETURN
                    (_soc_fl_ser_process_parity_counter(unit, block_info_idx, port,
                                                         info, mem_str, blocktype));
                break;
#ifdef INCLUDE_XFLOW_MACSEC
            case _SOC_PARITY_TYPE_MACSEC_ECC:
                SOC_IF_ERROR_RETURN
                    (_soc_fl_ser_process_macsec_ecc(unit, block_info_idx, port,
                                                     info, mem_str, blocktype,
                                                     info->type));
                break;
#endif
            default:
                break;
        }

    }

    return SOC_E_NONE;
}

_soc_fl_ser_route_block_t *soc_fl_ser_route_blocks_get(int rbi) {
    return &_soc_fl_ser_route_blocks[rbi];
}

int
soc_fl_ser_process_all(int unit, int reg_type, int bit)
{
    uint8       rbi;
    _soc_fl_ser_route_block_t *rb;
    uint32     cmic_rval = 0, cmic_bit;
    int         port = REG_PORT_ANY;
    int         block_info_idx;
    uint64      rb_rval64, rb_enable64, temp64;
    soc_reg_t   tmp_reg;

    COMPILER_64_ZERO(rb_rval64);
    COMPILER_64_ZERO(rb_enable64);

    switch(reg_type) {
        case 0:
            READ_CMICx_INTC_INTR(unit, ICFG_CHIP_LP_INTR_RAW_STATUS_REG0r,
                                 &cmic_rval);
            if (cmic_rval == 0) {
                LOG_VERBOSE(BSL_LS_SOC_SER,
                    (BSL_META_U(unit,
                                "unit %d, _soc_firelight_ser_process_all: will not process intr because cmic_rval is 0\n"),
                     unit));
                return SOC_E_NONE;
            }
            break;
        case 1:
            READ_CMICx_INTC_INTR(unit, ICFG_CHIP_LP_INTR_RAW_STATUS_REG1r,
                                 &cmic_rval);
            if (cmic_rval == 0) {
                LOG_VERBOSE(BSL_LS_SOC_SER,
                    (BSL_META_U(unit,
                                "unit %d, _soc_firelight_ser_process_all: will not process intr because cmic_rval is 0\n"),
                     unit));
                return SOC_E_NONE;
            }
            break;
        case 2:
            READ_CMICx_INTC_INTR(unit, ICFG_CHIP_LP_INTR_RAW_STATUS_REG2r,
                                 &cmic_rval);
            if (cmic_rval == 0) {
                LOG_VERBOSE(BSL_LS_SOC_SER,
                    (BSL_META_U(unit,
                                "unit %d, _soc_firelight_ser_process_all: will not process intr because cmic_rval is 0\n"),
                     unit));
                return SOC_E_NONE;
            }
            break;
        case 3:
            READ_CMICx_INTC_INTR(unit, ICFG_CHIP_LP_INTR_RAW_STATUS_REG3r,
                                 &cmic_rval);
            if (cmic_rval == 0) {
                LOG_VERBOSE(BSL_LS_SOC_SER,
                    (BSL_META_U(unit,
                                "unit %d, _soc_firelight_ser_process_all: will not process intr because cmic_rval is 0\n"),
                     unit));
                return SOC_E_NONE;
            }
            break;
        default:
            return SOC_E_NONE;
    }

    /* Loop through each place-and-route block entry */
    for (rbi = 0; ; rbi++) {
        rb = &_soc_fl_ser_route_blocks[rbi];
        cmic_bit = rb->cmic_bit;
        if (cmic_bit == 0) {
            /* End of table */
            break;
        }

        if (!(cmic_rval & cmic_bit)) {
            /* Indicated bit not asserted for the route block */
            continue;
        }
        SOC_BLOCK_ITER(unit, block_info_idx, rb->blocktype) {
            if (SOC_BLOCK_INFO(unit, block_info_idx).number == rb->id) {
                port = SOC_BLOCK_PORT(unit, block_info_idx);
                break;
            }
        }
        if (rb->enable_reg != INVALIDr) {
            if (SOC_BLOCK_IN_LIST(unit, SOC_REG_INFO(unit, rb->enable_reg).block,
                SOC_BLK_PORT) && (port == REG_PORT_ANY)) {
                /* This port block is not configured */
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "unit %d SER error on disabled "
                                      "port block %d !!\n"),
                           unit, block_info_idx));
                continue;
            }
            SOC_IF_ERROR_RETURN(soc_reg_get(unit, rb->enable_reg,
                                port, 0, &rb_enable64));
        }

        /* Read per route block parity status register */
        if (rb->status_reg != INVALIDr) {
            tmp_reg = rb->status_reg;
            SOC_IF_ERROR_RETURN(
                soc_reg_get(unit, tmp_reg, port, 0, &rb_rval64));
            if (COMPILER_64_IS_ZERO(rb_rval64)) {
                continue;
            }
            if (!COMPILER_64_IS_ZERO(rb_enable64)) {
                /* mask out the disabled status */
                COMPILER_64_AND(rb_rval64, rb_enable64);
                if (COMPILER_64_IS_ZERO(rb_rval64)){
                    continue;
                }
            }
        }

        /* ser process per type */
        SOC_IF_ERROR_RETURN(
            _soc_fl_process_ser(unit, block_info_idx, rb->id,
                                 port, rb->status_reg, rb_rval64,
                                 rb->info, rb->blocktype));

        /* Enable interrupt */
        if (rb->enable_reg != INVALIDr) {
            SOC_IF_ERROR_RETURN(soc_reg_get(unit, rb->enable_reg,
                                port, 0, &rb_enable64));
            COMPILER_64_SET(temp64, COMPILER_64_HI(rb_rval64),
                                COMPILER_64_LO(rb_rval64));
            COMPILER_64_NOT(temp64);
            COMPILER_64_AND(rb_enable64, temp64);
            SOC_IF_ERROR_RETURN(soc_reg_set(unit, rb->enable_reg,
                port, 0, rb_enable64));
            COMPILER_64_OR(rb_enable64, rb_rval64);
            SOC_IF_ERROR_RETURN(soc_reg_set(unit, rb->enable_reg,
                port, 0, rb_enable64));
        }
    }/* for rbi */

#ifdef INCLUDE_XFLOW_MACSEC
    if ((reg_type == 1) && (cmic_rval & FL_REG1_MACSEC_INTR_MASK)) {
        soc_fl_process_macsec_intr(unit);
    }
#endif

    return SOC_E_NONE;
}

int
ser_test_fl_mem_index_remap(int unit, ser_test_data_t *test_data,
                                  int *mem_has_ecc)
{
    int uft_bkt_bank = 0;
    int uft_le_fv = 0;
    int uft_le_ecc = 0;
    int remap_status = 0;

    *mem_has_ecc = 0;
    test_data->mem = test_data->mem_fv;
    test_data->index = test_data->index_fv;

    if (_soc_fl_ser_2bit_ecc_mem(unit, test_data->mem_fv)) {
        *mem_has_ecc = 1;
    }

    if ((test_data->mem != test_data->mem_fv) ||
        (test_data->index != test_data->index_fv)) {
        LOG_VERBOSE(BSL_LS_SOC_SER,
            (BSL_META_U(unit,
                        "unit %d, ser_test_mem_index_remap: "
                        "mem_fv %s, index_fv %0d, mem %s, index %0d, "
                        "uft_bkt_bank %0d, uft_le_fv %0d, "
                        "uft_le_ecc %0d, remap_status %0d \n"),
             unit, SOC_MEM_NAME(unit, test_data->mem_fv), test_data->index_fv,
             SOC_MEM_NAME(unit, test_data->mem), test_data->index,
             uft_bkt_bank, uft_le_fv, uft_le_ecc, remap_status));
    }
    return remap_status;
}

soc_ser_test_functions_t ser_fl_test_fun;

void
soc_fl_ser_test_register(int unit)
{
    /*Initialize chip-specific functions for SER testing*/
    memset(&ser_fl_test_fun, 0, sizeof(soc_ser_test_functions_t));
    ser_fl_test_fun.inject_error_f = &soc_fl_ser_inject_error;
    ser_fl_test_fun.test_mem = &soc_fl_ser_test_mem;
    ser_fl_test_fun.test = &soc_fl_ser_test;
    ser_fl_test_fun.injection_support = &ser_fl_ser_error_injection_support;

    soc_ser_test_functions_register(unit, &ser_fl_test_fun);
}
#endif /* SER_TR_TEST_SUPPORT */

