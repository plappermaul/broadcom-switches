#include <soc/mcm/memregs.h>
#if defined(BCM_88650_A0)
/* 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
*/

#ifdef _ERR_MSG_MODULE_NAME
  #error "_ERR_MSG_MODULE_NAME redefined"
#endif

#define _ERR_MSG_MODULE_NAME BSL_SOC_TRUNK



#include <shared/bsl.h>
#include <shared/swstate/access/sw_state_access.h>
#include <soc/dcmn/error.h>

#include <soc/dpp/SAND/Utils/sand_header.h>

#include <soc/dpp/SAND/Management/sand_general_macros.h>
#include <soc/dpp/SAND/Management/sand_error_code.h>
#include <soc/dpp/SAND/Utils/sand_os_interface.h>


#include <soc/dpp/ARAD/ARAD_PP/arad_pp_framework.h>
#include <soc/dpp/ARAD/ARAD_PP/arad_pp_lag.h>
#include <soc/dpp/ARAD/ARAD_PP/arad_pp_sw_db.h>
#include <soc/dpp/ARAD/arad_parser.h>

#include <soc/dpp/ARAD/ARAD_PP/arad_pp_general.h>
#include <soc/dpp/ARAD/arad_tbl_access.h>

#include <soc/dpp/ARAD/arad_ports.h>
#include <soc/dpp/ARAD/arad_general.h>
#include <soc/dpp/JER/JER_PP/jer_pp_diag.h>
#include <soc/sand/sand_signals.h>




#define ARAD_PP_LAG_LAG_NDX_MAX(__unit)                     (arad_ports_lag_nof_lag_groups_get_unsafe(__unit))
#define ARAD_PP_LAG_SYS_PORT_MAX                                 (SOC_TMC_NOF_SYS_PHYS_PORTS_ARAD)
#define ARAD_PP_LAG_SEED_MAX                                     (SOC_SAND_U16_MAX)
#define ARAD_PP_LAG_HASH_FUNC_ID_MIN                             (0x3)
#define ARAD_PP_LAG_HASH_FUNC_ID_MAX                             (SOC_IS_ARADPLUS(unit)? SOC_PPC_LAG_LB_CRC_0x9019: SOC_PPC_LAG_LB_CRC_0x1105D)
#define ARAD_PP_LAG_KEY_SHIFT_MAX                                (15)
#define ARAD_PP_LAG_NOF_HEADERS_MAX                              (3)
#define ARAD_PP_LAG_FIRST_HEADER_TO_PARSE_MAX                    (SOC_PPC_NOF_LAG_HASH_FRST_HDRS-1)
#define SOC_PPC_LAG_MEMBER_ID_MAX                                (255)
#define ARAD_PP_LAG_NOF_ENTRIES_MAX(__unit)                  ((arad_ports_lag_nof_lag_entries_get_unsafe(__unit)))
#define SOC_PPC_LAG_LB_TYPE_MAX                                  (SOC_PPC_NOF_LAG_LB_TYPES-1)
#define ARAD_PP_LAG_MAX_ECMP_ENTRY(_unit)                      (SOC_DPP_DEFS_GET(_unit, nof_ecmp) - 1)
#define ARAD_PP_PFC_PROFILE_INDEX_PFC_OFFSET                  0
#define ARAD_PP_PFC_PROFILE_INDEX_PLC_OFFSET                  6
#define ARAD_PP_PFC_PROFILE_INDEX_PORT_PROFILE_OFFSET         7



#define ARAD_PP_LB_VECTOR_INDEX_NONE             0x0
#define ARAD_PP_LB_VECTOR_INDEX_ETHERNET         0x1
#define ARAD_PP_LB_VECTOR_INDEX_FC               0x2
#define ARAD_PP_LB_VECTOR_INDEX_IPV4             0x3
#define ARAD_PP_LB_VECTOR_INDEX_IPV6             0x4
#define ARAD_PP_LB_VECTOR_INDEX_MPLSX1           0x5
#define ARAD_PP_LB_VECTOR_INDEX_MPLSX2_LABEL1    0x6
#define ARAD_PP_LB_VECTOR_INDEX_MPLSX2_LABEL2    0x7
#define ARAD_PP_LB_VECTOR_INDEX_MPLSX3_LABEL1    0x8
#define ARAD_PP_LB_VECTOR_INDEX_MPLSX3_LABEL2    0x9
#define ARAD_PP_LB_VECTOR_INDEX_MPLSX3_LABEL3    0xa
#define ARAD_PP_LB_VECTOR_INDEX_TRILL            0xb
#define ARAD_PP_LB_VECTOR_INDEX_L4               0xc
#define ARAD_PP_LB_VECTOR_INDEX_FC_VFT           0xd
#define ARAD_PP_LB_VECTOR_INDEX_MPLSX5_LABEL4    0xe
#define ARAD_PP_LB_VECTOR_INDEX_CALC             0xf
#define ARAD_PP_LB_NOF_VECTOR_INDEXES            0xf


#define SOC_DPP_LB_VECTOR_INDEX_NONE             (SOC_IS_JERICHO(unit) ? 0x0  : 0x0)
#define SOC_DPP_LB_VECTOR_INDEX_ETHERNET         (SOC_IS_JERICHO(unit) ? 0x1  : 0x1)
#define SOC_DPP_LB_VECTOR_INDEX_ETHERNET_1       (SOC_IS_JERICHO(unit) ? 0x2  : 0x1)
#define SOC_DPP_LB_VECTOR_INDEX_ETHERNET_2       (SOC_IS_JERICHO(unit) ? 0x3  : 0x1)
#define SOC_DPP_LB_VECTOR_INDEX_ETHERNET_3       (SOC_IS_JERICHO(unit) ? 0x4  : 0x1)
#define SOC_DPP_LB_VECTOR_INDEX_FC               (SOC_IS_JERICHO(unit) ? 0x5  : 0x2)
#define SOC_DPP_LB_VECTOR_INDEX_IPV4             (SOC_IS_JERICHO(unit) ? 0x6  : 0x3)
#define SOC_DPP_LB_VECTOR_INDEX_IPV6             (SOC_IS_JERICHO(unit) ? 0x7  : 0x4)
#define SOC_DPP_LB_VECTOR_INDEX_MPLSX1           (SOC_IS_JERICHO(unit) ? 0x8  : 0x5)
#define SOC_DPP_LB_VECTOR_INDEX_MPLSX2_LABEL1    (SOC_IS_JERICHO(unit) ? 0x9  : 0x6)
#define SOC_DPP_LB_VECTOR_INDEX_MPLSX2_LABEL2    (SOC_IS_JERICHO(unit) ? 0xa  : 0x7)
#define SOC_DPP_LB_VECTOR_INDEX_MPLSX3_LABEL1    (SOC_IS_JERICHO(unit) ? 0xb  : 0x8)
#define SOC_DPP_LB_VECTOR_INDEX_MPLSX3_LABEL2    (SOC_IS_JERICHO(unit) ? 0xc  : 0x9)
#define SOC_DPP_LB_VECTOR_INDEX_MPLSX3_LABEL3    (SOC_IS_JERICHO(unit) ? 0xd  : 0xa)
#define SOC_DPP_LB_VECTOR_INDEX_MPLSX5_LABEL4    (SOC_IS_JERICHO(unit) ? 0x11 : 0xe)
#define SOC_DPP_LB_VECTOR_INDEX_TRILL            (SOC_IS_JERICHO(unit) ? 0xe  : 0xb)
#define SOC_DPP_LB_VECTOR_INDEX_L4               (SOC_IS_JERICHO(unit) ? 0xf  : 0xc)
#define SOC_DPP_LB_VECTOR_INDEX_FC_VFT           (SOC_IS_JERICHO(unit) ? 0x10 : 0xd)
#define SOC_DPP_LB_VECTOR_INDEX_CALC             (SOC_IS_JERICHO(unit) ? 0x1f : 0xf)
#define SOC_DPP_LB_NOF_VECTOR_INDEXES            (SOC_IS_JERICHO(unit) ? 0x1f : 0xf)


#define ARAD_PP_LB_VECTOR_NOF_BITS 48




#define ARAD_PP_LB_FIELD_TO_OFFSET(field) (soc_sand_log2_round_down(field))


#define ARAD_PP_LB_FIELD_TO_NIBLE(chunk_ofst, chunk_size)   (ARAD_PP_LB_VECTOR_NOF_BITS - chunk_ofst*2 - 2)

#define ARAD_PP_LB_MPLS_LBL1_VLD(key_indx) \
  ((key_indx== SOC_DPP_LB_VECTOR_INDEX_MPLSX1)||(key_indx== SOC_DPP_LB_VECTOR_INDEX_MPLSX2_LABEL1)||(key_indx==SOC_DPP_LB_VECTOR_INDEX_MPLSX3_LABEL1))

#define ARAD_PP_LB_MPLS_LBL2_VLD(key_indx) \
  ((key_indx >= SOC_DPP_LB_VECTOR_INDEX_MPLSX2_LABEL1) && (key_indx <= SOC_DPP_LB_VECTOR_INDEX_MPLSX3_LABEL2))

#define ARAD_PP_LB_MPLS_LBL3_VLD(key_indx) \
  ((key_indx >= SOC_DPP_LB_VECTOR_INDEX_MPLSX3_LABEL1) && (key_indx <= SOC_DPP_LB_VECTOR_INDEX_MPLSX3_LABEL3))

#define ARAD_PP_LB_MPLS_LBL4_VLD(key_indx) \
  (key_indx == SOC_DPP_LB_VECTOR_INDEX_MPLSX5_LABEL4)

#define ARAD_PP_LB_MPLS_LBL5_VLD(key_indx) \
  (key_indx == SOC_DPP_LB_VECTOR_INDEX_MPLSX5_LABEL4)

#define ARAD_PP_FRWR_ACTION_TO_FEC(fwrd_action)\
  ((0x1FFFF & fwrd_action))


#define ARAD_PP_LB_PFC_OFFSET_SET(lb_profile, _plc_, _pfc_) ((lb_profile << ARAD_PP_PFC_PROFILE_INDEX_PORT_PROFILE_OFFSET) |\
                                                            (_plc_ << ARAD_PP_PFC_PROFILE_INDEX_PLC_OFFSET) |\
                                                            (_pfc_<< ARAD_PP_PFC_PROFILE_INDEX_PFC_OFFSET))





typedef enum
{
 
 ARAD_PP_PORT_PROFILE_OFF = 0,
 
  ARAD_PP_PORT_PROFILE_ON,
  
  ARAD_PP_PORT_PROFILE_DC
} ARAD_PP_PORT_PROFILE_STATE;


typedef enum
{
 
  ARAD_PP_PLC_PROFILE_OFF = 0 ,
 
  ARAD_PP_PLC_PROFILE_ON

} ARAD_PP_PLC_PROFILE_BIT;





typedef struct
{
    uint32 key_index;
    uint32 nof_nibles;
    uint32 nbls[8];
}ARAD_PP_LB_HASH_FIELD_INFO;

typedef struct
{
    ARAD_PP_PORT_PROFILE_STATE  port_profile_state;
    DPP_PFC_E                   pfc_sw;
    ARAD_PP_PLC_PROFILE_BIT     plc_setbit;
    uint32                      index5;
    uint32                      index4;
    uint32                      index3;
    uint32                      index2;
    uint32                      index1;
}ARAD_PP_LB_HASH_MAP;

typedef struct
{
    uint32 key_index;
    uint8 chunk_size;
}ARAD_PP_LB_HASH_CHUNK_SIZE;





const char *arad_pp_lb_vector_names[] = {
    "LB_VECTOR_NONE",
    "LB_VECTOR_ETHERNET",
    "LB_VECTOR_ETHERNET_1",
    "LB_VECTOR_ETHERNET_2",
    "LB_VECTOR_ETHERNET_3",
    "LB_VECTOR_FC",
    "LB_VECTOR_IPV4",
    "LB_VECTOR_IPV6",
    "LB_VECTOR_MPLSX1",
    "LB_VECTOR_MPLSX2_LABEL1",
    "LB_VECTOR_MPLSX2_LABEL2",
    "LB_VECTOR_MPLSX3_LABEL1",
    "LB_VECTOR_MPLSX3_LABEL2",
    "LB_VECTOR_MPLSX3_LABEL3",
    "LB_VECTOR_TRILL",
    "LB_VECTOR_L4",
    "LB_VECTOR_FC_VFT",
    "LB_VECTOR_MPLSX5_LABEL4",
    "LB_VECTOR_INVALID",
    "LB_VECTOR_INVALID",
    "LB_VECTOR_INVALID",
    "LB_VECTOR_INVALID",
    "LB_VECTOR_INVALID",
    "LB_VECTOR_INVALID",
    "LB_VECTOR_INVALID",
    "LB_VECTOR_INVALID",
    "LB_VECTOR_INVALID",
    "LB_VECTOR_INVALID",
    "LB_VECTOR_INVALID",
    "LB_VECTOR_INVALID",
    "LB_VECTOR_INVALID",
    "LB_VECTOR_CALC",
    NULL
};

const char *arad_pp_lb_polynomial_names[] = {
    "polynomial 0x8003",
    "polynomial 0x8011",
    "polynomial 0x8423",
    "polynomial 0x8101",
    "polynomial 0x84a1",
    "polynomial 0x9019",
    "invalid polynomial",
    "invalid polynomial",
    "invalid polynomial",
    "invalid polynomial",
    "LB-Key-Packet-Data directly",
    "counter incremented every packet",
    "counter incremented every two clocks",
    "invalid polynomial",
    "invalid polynomial",
    "invalid polynomial",
    NULL
};

CONST STATIC SOC_PROCEDURE_DESC_ELEMENT
  Arad_pp_procedure_desc_element_lag[] =
{
  
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_LAG_SET),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_LAG_SET_PRINT),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_LAG_SET_UNSAFE),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_LAG_SET_VERIFY),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_LAG_GET),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_LAG_GET_PRINT),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_LAG_GET_VERIFY),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_LAG_GET_UNSAFE),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(SOC_PPC_LAG_MEMBER_ADD),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(SOC_PPC_LAG_MEMBER_ADD_PRINT),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(SOC_PPC_LAG_MEMBER_ADD_UNSAFE),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(SOC_PPC_LAG_MEMBER_ADD_VERIFY),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(SOC_PPC_LAG_MEMBER_REMOVE),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(SOC_PPC_LAG_MEMBER_REMOVE_PRINT),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(SOC_PPC_LAG_MEMBER_REMOVE_UNSAFE),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(SOC_PPC_LAG_MEMBER_REMOVE_VERIFY),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_LAG_HASHING_GLOBAL_INFO_SET),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_LAG_HASHING_GLOBAL_INFO_SET_PRINT),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_LAG_HASHING_GLOBAL_INFO_SET_UNSAFE),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_LAG_HASHING_GLOBAL_INFO_SET_VERIFY),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_LAG_HASHING_GLOBAL_INFO_GET),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_LAG_HASHING_GLOBAL_INFO_GET_PRINT),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_LAG_HASHING_GLOBAL_INFO_GET_VERIFY),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_LAG_HASHING_GLOBAL_INFO_GET_UNSAFE),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_LAG_HASHING_PORT_INFO_SET),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_LAG_HASHING_PORT_INFO_SET_PRINT),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_LAG_HASHING_PORT_INFO_SET_UNSAFE),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_LAG_HASHING_PORT_INFO_SET_VERIFY),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_LAG_HASHING_PORT_INFO_GET),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_LAG_HASHING_PORT_INFO_GET_PRINT),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_LAG_HASHING_PORT_INFO_GET_VERIFY),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_LAG_HASHING_PORT_INFO_GET_UNSAFE),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_LAG_HASHING_MASK_SET),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_LAG_HASHING_MASK_SET_PRINT),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_LAG_HASHING_MASK_SET_UNSAFE),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_LAG_HASHING_MASK_SET_VERIFY),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_LAG_HASHING_MASK_GET),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_LAG_HASHING_MASK_GET_PRINT),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_LAG_HASHING_MASK_GET_VERIFY),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_LAG_HASHING_MASK_GET_UNSAFE),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_LAG_GET_PROCS_PTR),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_LAG_GET_ERRS_PTR),
  

  
  SOC_PROCEDURE_DESC_ELEMENT_DEF_LAST
};

CONST STATIC SOC_ERROR_DESC_ELEMENT
  Arad_pp_error_desc_element_lag[] =
{
  
  {
    ARAD_PP_LAG_LAG_NDX_OUT_OF_RANGE_ERR,
    "ARAD_PP_LAG_LAG_NDX_OUT_OF_RANGE_ERR",
    "The parameter 'lag_ndx' is out of range. \n\r "
    "The range is: 0 - 255.\n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },
  {
    ARAD_PP_LAG_SUCCESS_OUT_OF_RANGE_ERR,
    "ARAD_PP_LAG_SUCCESS_OUT_OF_RANGE_ERR",
    "The parameter 'success' is out of range. \n\r "
    "The range is: 0 - SOC_SAND_NOF_SUCCESS_FAILURES-1.\n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },
  {
    ARAD_PP_LAG_SYS_PORT_OUT_OF_RANGE_ERR,
    "ARAD_PP_LAG_SYS_PORT_OUT_OF_RANGE_ERR",
    "The parameter 'sys_port' is out of range. \n\r "
    "The range is: 0 - 4095.\n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },
  {
    ARAD_PP_LAG_MASKS_OUT_OF_RANGE_ERR,
    "ARAD_PP_LAG_MASKS_OUT_OF_RANGE_ERR",
    "The parameter 'masks' is out of range. \n\r "
    "The range is: 0 - SOC_PPC_NOF_HASH_MASKS-1.\n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },
  {
    ARAD_PP_LAG_SEED_OUT_OF_RANGE_ERR,
    "ARAD_PP_LAG_SEED_OUT_OF_RANGE_ERR",
    "The parameter 'seed' is out of range. \n\r "
    "The range is: 0 - SOC_SAND_U16_MAX.\n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },
  {
    ARAD_PP_LAG_HASH_FUNC_ID_OUT_OF_RANGE_ERR,
    "ARAD_PP_LAG_HASH_FUNC_ID_OUT_OF_RANGE_ERR",
    "The parameter 'hash_func_id' is out of range. \n\r "
    "The range is: 3 - 15.\n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },
  {
    ARAD_PP_LAG_KEY_SHIFT_OUT_OF_RANGE_ERR,
    "ARAD_PP_LAG_KEY_SHIFT_OUT_OF_RANGE_ERR",
    "The parameter 'key_shift' is out of range. \n\r "
    "The range is: 0 - SOC_SAND_U8_MAX.\n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },
  {
    ARAD_PP_LAG_NOF_HEADERS_OUT_OF_RANGE_ERR,
    "ARAD_PP_LAG_NOF_HEADERS_OUT_OF_RANGE_ERR",
    "The parameter 'nof_headers' is out of range. \n\r "
    "The range is: 0 - SOC_SAND_U8_MAX.\n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },
  {
    ARAD_PP_LAG_FIRST_HEADER_TO_PARSE_OUT_OF_RANGE_ERR,
    "ARAD_PP_LAG_FIRST_HEADER_TO_PARSE_OUT_OF_RANGE_ERR",
    "The parameter 'first_header_to_parse' is out of range. \n\r "
    "The range is: 0 - SOC_PPC_NOF_LAG_HASH_FRST_HDRS-1.\n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },
  {
    ARAD_PP_LAG_MASK_OUT_OF_RANGE_ERR,
    "ARAD_PP_LAG_MASK_OUT_OF_RANGE_ERR",
    "The parameter 'mask' is out of range. \n\r "
    "The range is: 0 - SOC_PPC_NOF_HASH_MASKSS-1.\n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },

  {
    SOC_PPC_LAG_MEMBER_ID_OUT_OF_RANGE_ERR,
    "SOC_PPC_LAG_MEMBER_ID_OUT_OF_RANGE_ERR",
    "The parameter 'member_id' is out of range. \n\r "
    "The range is: 0 - 15.\n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },
  {
    ARAD_PP_LAG_NOF_ENTRIES_OUT_OF_RANGE_ERR,
    "ARAD_PP_LAG_NOF_ENTRIES_OUT_OF_RANGE_ERR",
    "The parameter 'nof_entries' is out of range. \n\r "
    "The range is: 0 - 16.\n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },
  {
    SOC_PPC_LAG_LB_TYPE_OUT_OF_RANGE_ERR,
    "SOC_PPC_LAG_LB_TYPE_OUT_OF_RANGE_ERR",
    "The parameter 'lb_type' is out of range. \n\r "
    "The range is: 0 - SOC_PPC_NOF_LAG_LB_TYPES-1.\n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },
  
   {
    ARAD_PP_LAG_ASYMETRIC_ERR,
    "ARAD_PP_LAG_ASYMETRIC_ERR",
    "When retrieving the LAG configuration, \n\r "
    "The incoming and the outgoing direction\n\r "
    "are configured differently",
    SOC_SAND_SVR_ERR,
    FALSE
  },
   {
    ARAD_PP_LAG_DOUPLICATE_MEMBER_ERR,
    "ARAD_PP_LAG_DOUPLICATE_MEMBER_ERR",
    "define lag with duplicated member",
    SOC_SAND_SVR_ERR,
    FALSE
  },
  

  
SOC_ERR_DESC_ELEMENT_DEF_LAST
};


#define ARAD_PP_PLC_FC_VFT 1
#define ARAD_PP_PLC_FC_NO_VFT 0

CONST STATIC ARAD_PP_LB_HASH_MAP
  Arad_pp_lb_hash_map_table[] =
{
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_ETH,            ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,     ARAD_PP_LB_VECTOR_INDEX_CALC,          ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_ETH_ETH,        ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,     ARAD_PP_LB_VECTOR_INDEX_ETHERNET,      ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_MPLS1_ETH,      ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,     ARAD_PP_LB_VECTOR_INDEX_MPLSX1,        ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_MPLS1_ETH,      ARAD_PP_PLC_PROFILE_ON,  ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,     ARAD_PP_LB_VECTOR_INDEX_MPLSX1,        ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_MPLS2_ETH,      ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,     ARAD_PP_LB_VECTOR_INDEX_MPLSX2_LABEL1, ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_MPLS2_ETH,      ARAD_PP_PLC_PROFILE_ON,  ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,     ARAD_PP_LB_VECTOR_INDEX_MPLSX2_LABEL1, ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_MPLS3_ETH,      ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,     ARAD_PP_LB_VECTOR_INDEX_MPLSX3_LABEL1, ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_MPLS3_ETH,      ARAD_PP_PLC_PROFILE_ON,  ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_MPLSX5_LABEL4,     ARAD_PP_LB_VECTOR_INDEX_MPLSX3_LABEL1, ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_ETH_MPLS1_ETH,  ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_ETHERNET, ARAD_PP_LB_VECTOR_INDEX_MPLSX1,        ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_ETH_MPLS2_ETH,  ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_ETHERNET, ARAD_PP_LB_VECTOR_INDEX_MPLSX2_LABEL1, ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_ETH_MPLS3_ETH,  ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_ETHERNET, ARAD_PP_LB_VECTOR_INDEX_MPLSX3_LABEL1, ARAD_PP_LB_VECTOR_INDEX_ETHERNET},

  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_IPV4_MPLS1_ETH, ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,   ARAD_PP_LB_VECTOR_INDEX_IPV4,     ARAD_PP_LB_VECTOR_INDEX_MPLSX1,        ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_IPV4_MPLS2_ETH, ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,   ARAD_PP_LB_VECTOR_INDEX_IPV4,     ARAD_PP_LB_VECTOR_INDEX_MPLSX2_LABEL1, ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_IPV4_MPLS3_ETH, ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,   ARAD_PP_LB_VECTOR_INDEX_IPV4,     ARAD_PP_LB_VECTOR_INDEX_MPLSX3_LABEL1, ARAD_PP_LB_VECTOR_INDEX_ETHERNET},

  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_IPV4_MPLS1_ETH, ARAD_PP_PLC_PROFILE_ON, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_L4,   ARAD_PP_LB_VECTOR_INDEX_IPV4,     ARAD_PP_LB_VECTOR_INDEX_MPLSX1,        ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_IPV4_MPLS2_ETH, ARAD_PP_PLC_PROFILE_ON, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_L4,   ARAD_PP_LB_VECTOR_INDEX_IPV4,     ARAD_PP_LB_VECTOR_INDEX_MPLSX2_LABEL1, ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_IPV4_MPLS3_ETH, ARAD_PP_PLC_PROFILE_ON, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_L4,   ARAD_PP_LB_VECTOR_INDEX_IPV4,     ARAD_PP_LB_VECTOR_INDEX_MPLSX3_LABEL1, ARAD_PP_LB_VECTOR_INDEX_ETHERNET},

  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_IPV6_MPLS1_ETH, ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,   ARAD_PP_LB_VECTOR_INDEX_IPV6,     ARAD_PP_LB_VECTOR_INDEX_MPLSX1,        ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_IPV6_MPLS2_ETH, ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,   ARAD_PP_LB_VECTOR_INDEX_IPV6,     ARAD_PP_LB_VECTOR_INDEX_MPLSX2_LABEL1, ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_IPV6_MPLS3_ETH, ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,   ARAD_PP_LB_VECTOR_INDEX_IPV6,     ARAD_PP_LB_VECTOR_INDEX_MPLSX3_LABEL1, ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_IPV6_MPLS1_ETH, ARAD_PP_PLC_PROFILE_ON, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_L4,   ARAD_PP_LB_VECTOR_INDEX_IPV6,     ARAD_PP_LB_VECTOR_INDEX_MPLSX1,        ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_IPV6_MPLS2_ETH, ARAD_PP_PLC_PROFILE_ON, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_L4,   ARAD_PP_LB_VECTOR_INDEX_IPV6,     ARAD_PP_LB_VECTOR_INDEX_MPLSX2_LABEL1, ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_IPV6_MPLS3_ETH, ARAD_PP_PLC_PROFILE_ON, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_L4,   ARAD_PP_LB_VECTOR_INDEX_IPV6,     ARAD_PP_LB_VECTOR_INDEX_MPLSX3_LABEL1, ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_IPV4_IPV4_ETH,  ARAD_PP_PLC_PROFILE_ON, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_L4,   ARAD_PP_LB_VECTOR_INDEX_IPV4,     ARAD_PP_LB_VECTOR_INDEX_IPV4,          ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_IPV4_IPV4_ETH,  ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_IPV4,     ARAD_PP_LB_VECTOR_INDEX_IPV4,          ARAD_PP_LB_VECTOR_INDEX_ETHERNET},  
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_IPV6_IPV4_ETH,  ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_L4,   ARAD_PP_LB_VECTOR_INDEX_IPV6,     ARAD_PP_LB_VECTOR_INDEX_IPV4,          ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_DC, DPP_PFC_IPV4_IPV6_ETH,  ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,   ARAD_PP_LB_VECTOR_INDEX_IPV4,     ARAD_PP_LB_VECTOR_INDEX_IPV6,          ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_DC, DPP_PFC_IPV4_IPV6_ETH,  ARAD_PP_PLC_PROFILE_ON, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,   ARAD_PP_LB_VECTOR_INDEX_IPV4,     ARAD_PP_LB_VECTOR_INDEX_IPV6,          ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_IPV4_ETH,       ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,   ARAD_PP_LB_VECTOR_INDEX_NONE,     ARAD_PP_LB_VECTOR_INDEX_IPV4,          ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_IPV4_ETH,       ARAD_PP_PLC_PROFILE_ON, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,   ARAD_PP_LB_VECTOR_INDEX_L4,     ARAD_PP_LB_VECTOR_INDEX_IPV4,          ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_IPV6_ETH,       ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,       ARAD_PP_LB_VECTOR_INDEX_IPV6,          ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_IPV6_ETH,       ARAD_PP_PLC_PROFILE_ON, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_L4,       ARAD_PP_LB_VECTOR_INDEX_IPV6,          ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_ETH_TRILL_ETH,  ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_ETHERNET, ARAD_PP_LB_VECTOR_INDEX_TRILL,         ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_ETH_IPV4_ETH,   ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_ETHERNET, ARAD_PP_LB_VECTOR_INDEX_IPV4,         ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_ETH_IPV4_ETH,   ARAD_PP_PLC_PROFILE_ON, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_IPV4, ARAD_PP_LB_VECTOR_INDEX_ETHERNET, ARAD_PP_LB_VECTOR_INDEX_IPV4,         ARAD_PP_LB_VECTOR_INDEX_ETHERNET},

  
  
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_FCOE_STD_ETH,ARAD_PP_PLC_FC_NO_VFT,   ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,     ARAD_PP_LB_VECTOR_INDEX_NONE,          ARAD_PP_LB_VECTOR_INDEX_FC, ARAD_PP_LB_VECTOR_INDEX_NONE},
  
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_FCOE_STD_ETH,ARAD_PP_PLC_FC_VFT,      ARAD_PP_LB_VECTOR_INDEX_NONE,  ARAD_PP_LB_VECTOR_INDEX_NONE,     ARAD_PP_LB_VECTOR_INDEX_FC,          ARAD_PP_LB_VECTOR_INDEX_FC_VFT, ARAD_PP_LB_VECTOR_INDEX_NONE},
  
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_FCOE_ENCAP_ETH,ARAD_PP_PLC_FC_VFT,    ARAD_PP_LB_VECTOR_INDEX_NONE,     ARAD_PP_LB_VECTOR_INDEX_FC,          ARAD_PP_LB_VECTOR_INDEX_FC_VFT, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE},
  
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_FCOE_ENCAP_ETH,ARAD_PP_PLC_FC_NO_VFT, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,     ARAD_PP_LB_VECTOR_INDEX_FC,         ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE},
};




CONST STATIC ARAD_PP_LB_HASH_MAP
    Arad_pp_lb_hash_map_table_new_lb_scheme[] =
{
  { ARAD_PP_PORT_PROFILE_DC,  DPP_PFC_ETH,            ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,   ARAD_PP_LB_VECTOR_INDEX_NONE,          ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_DC,  DPP_PFC_ETH,            ARAD_PP_PLC_PROFILE_ON, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,   ARAD_PP_LB_VECTOR_INDEX_NONE,          ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_DC,  DPP_PFC_ETH_ETH,        ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,   ARAD_PP_LB_VECTOR_INDEX_ETHERNET,      ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_DC,  DPP_PFC_ETH_ETH,        ARAD_PP_PLC_PROFILE_ON, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,   ARAD_PP_LB_VECTOR_INDEX_ETHERNET,      ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_MPLS1_ETH,      ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,   ARAD_PP_LB_VECTOR_INDEX_MPLSX1,        ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_MPLS1_ETH,      ARAD_PP_PLC_PROFILE_ON,  ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,   ARAD_PP_LB_VECTOR_INDEX_MPLSX1,        ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_MPLS2_ETH,      ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,   ARAD_PP_LB_VECTOR_INDEX_MPLSX2_LABEL1, ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_MPLS2_ETH,      ARAD_PP_PLC_PROFILE_ON,  ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,   ARAD_PP_LB_VECTOR_INDEX_MPLSX2_LABEL1, ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_MPLS3_ETH,      ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,   ARAD_PP_LB_VECTOR_INDEX_MPLSX3_LABEL1, ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_MPLS3_ETH,      ARAD_PP_PLC_PROFILE_ON,  ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,   ARAD_PP_LB_VECTOR_INDEX_MPLSX3_LABEL1, ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_MPLS4P_ETH,     ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_MPLSX1, ARAD_PP_LB_VECTOR_INDEX_MPLSX3_LABEL1, ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_OFF, DPP_PFC_MPLS4P_ETH,     ARAD_PP_PLC_PROFILE_ON,  ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_MPLSX1, ARAD_PP_LB_VECTOR_INDEX_MPLSX3_LABEL1, ARAD_PP_LB_VECTOR_INDEX_ETHERNET},




  
  { ARAD_PP_PORT_PROFILE_ON, DPP_PFC_MPLS1_ETH,      ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_CALC, ARAD_PP_LB_VECTOR_INDEX_MPLSX1, ARAD_PP_LB_VECTOR_INDEX_MPLSX1,        ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_ON, DPP_PFC_MPLS1_ETH,      ARAD_PP_PLC_PROFILE_ON,  ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_CALC, ARAD_PP_LB_VECTOR_INDEX_MPLSX1, ARAD_PP_LB_VECTOR_INDEX_MPLSX1,        ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_ON, DPP_PFC_MPLS2_ETH,      ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_CALC, ARAD_PP_LB_VECTOR_INDEX_MPLSX1, ARAD_PP_LB_VECTOR_INDEX_MPLSX2_LABEL1, ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_ON, DPP_PFC_MPLS2_ETH,      ARAD_PP_PLC_PROFILE_ON,  ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_CALC, ARAD_PP_LB_VECTOR_INDEX_MPLSX1, ARAD_PP_LB_VECTOR_INDEX_MPLSX2_LABEL1, ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_ON, DPP_PFC_MPLS3_ETH,      ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_CALC, ARAD_PP_LB_VECTOR_INDEX_MPLSX1, ARAD_PP_LB_VECTOR_INDEX_MPLSX3_LABEL1, ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_ON, DPP_PFC_MPLS3_ETH,      ARAD_PP_PLC_PROFILE_ON,  ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_CALC, ARAD_PP_LB_VECTOR_INDEX_MPLSX1, ARAD_PP_LB_VECTOR_INDEX_MPLSX3_LABEL1, ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_ON, DPP_PFC_MPLS4P_ETH,     ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_CALC, ARAD_PP_LB_VECTOR_INDEX_MPLSX1, ARAD_PP_LB_VECTOR_INDEX_MPLSX3_LABEL1, ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_ON, DPP_PFC_MPLS4P_ETH,     ARAD_PP_PLC_PROFILE_ON,  ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_CALC, ARAD_PP_LB_VECTOR_INDEX_MPLSX1, ARAD_PP_LB_VECTOR_INDEX_MPLSX3_LABEL1, ARAD_PP_LB_VECTOR_INDEX_ETHERNET},

  
  { ARAD_PP_PORT_PROFILE_DC, DPP_PFC_IPV4_IPV4_ETH,  ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_L4,   ARAD_PP_LB_VECTOR_INDEX_IPV4,     ARAD_PP_LB_VECTOR_INDEX_IPV4,          ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_DC, DPP_PFC_IPV6_IPV4_ETH,  ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_L4,   ARAD_PP_LB_VECTOR_INDEX_IPV6,     ARAD_PP_LB_VECTOR_INDEX_IPV4,          ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_DC, DPP_PFC_IPV4_IPV6_ETH,  ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,   ARAD_PP_LB_VECTOR_INDEX_IPV4,     ARAD_PP_LB_VECTOR_INDEX_IPV6,          ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_DC, DPP_PFC_IPV4_IPV6_ETH,  ARAD_PP_PLC_PROFILE_ON, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,   ARAD_PP_LB_VECTOR_INDEX_IPV4,     ARAD_PP_LB_VECTOR_INDEX_IPV6,          ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_DC, DPP_PFC_IPV4_ETH,       ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,   ARAD_PP_LB_VECTOR_INDEX_NONE,     ARAD_PP_LB_VECTOR_INDEX_IPV4,          ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_DC, DPP_PFC_IPV4_ETH,       ARAD_PP_PLC_PROFILE_ON, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,   ARAD_PP_LB_VECTOR_INDEX_L4,     ARAD_PP_LB_VECTOR_INDEX_IPV4,          ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_DC, DPP_PFC_IPV6_ETH,       ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,       ARAD_PP_LB_VECTOR_INDEX_IPV6,          ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_DC, DPP_PFC_IPV6_ETH,       ARAD_PP_PLC_PROFILE_ON, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_L4,       ARAD_PP_LB_VECTOR_INDEX_IPV6,          ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_DC, DPP_PFC_ETH_IPV4_ETH,   ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_ETHERNET, ARAD_PP_LB_VECTOR_INDEX_IPV4,         ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_DC, DPP_PFC_ETH_IPV4_ETH,   ARAD_PP_PLC_PROFILE_ON, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_IPV4, ARAD_PP_LB_VECTOR_INDEX_ETHERNET, ARAD_PP_LB_VECTOR_INDEX_IPV4,         ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_DC, DPP_PFC_ETH_IPV6_ETH,   ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_ETHERNET, ARAD_PP_LB_VECTOR_INDEX_IPV6,         ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
  { ARAD_PP_PORT_PROFILE_DC, DPP_PFC_ETH_IPV6_ETH,   ARAD_PP_PLC_PROFILE_ON, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_IPV4, ARAD_PP_LB_VECTOR_INDEX_ETHERNET, ARAD_PP_LB_VECTOR_INDEX_IPV6,         ARAD_PP_LB_VECTOR_INDEX_ETHERNET},

  
  { ARAD_PP_PORT_PROFILE_DC, DPP_PFC_IPV4isH3,            ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_IPV4,     ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE},
  { ARAD_PP_PORT_PROFILE_DC, DPP_PFC_IPV6isH3,            ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_IPV6,     ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE},
  { ARAD_PP_PORT_PROFILE_DC, DPP_PFC_IPV4isH4_ETHisH3,    ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_IPV4, ARAD_PP_LB_VECTOR_INDEX_ETHERNET, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE},
  { ARAD_PP_PORT_PROFILE_DC, DPP_PFC_IPV6isH4_ETHisH3,    ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_IPV6, ARAD_PP_LB_VECTOR_INDEX_ETHERNET, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE},
  { ARAD_PP_PORT_PROFILE_DC, DPP_PFC_L4_IPV4isH3,         ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_L4,   ARAD_PP_LB_VECTOR_INDEX_IPV4,     ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE},
  { ARAD_PP_PORT_PROFILE_DC, DPP_PFC_L4_IPV6isH3,         ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_L4,   ARAD_PP_LB_VECTOR_INDEX_IPV6,     ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE},
  { ARAD_PP_PORT_PROFILE_DC, DPP_PFC_ETHisH3,             ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_ETHERNET, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE},

};

CONST STATIC ARAD_PP_LB_HASH_MAP
    Arad_pp_lb_hash_map_table_trill_new_lb_scheme[] =
{
  { ARAD_PP_PORT_PROFILE_DC, DPP_PFC_ETH_TRILL_ETH,  ARAD_PP_PLC_PROFILE_OFF, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_ETHERNET, ARAD_PP_LB_VECTOR_INDEX_TRILL,         ARAD_PP_LB_VECTOR_INDEX_ETHERNET},
};


CONST STATIC ARAD_PP_LB_HASH_MAP
    Arad_pp_lb_hash_map_table_fcoe_new_lb_scheme[] =
{
  
  { ARAD_PP_PORT_PROFILE_DC, DPP_PFC_FCOE_STD_ETH,ARAD_PP_PLC_FC_NO_VFT,   ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,     ARAD_PP_LB_VECTOR_INDEX_NONE,          ARAD_PP_LB_VECTOR_INDEX_FC, ARAD_PP_LB_VECTOR_INDEX_NONE},
  
  { ARAD_PP_PORT_PROFILE_DC, DPP_PFC_FCOE_STD_ETH,ARAD_PP_PLC_FC_VFT,      ARAD_PP_LB_VECTOR_INDEX_NONE,  ARAD_PP_LB_VECTOR_INDEX_NONE,     ARAD_PP_LB_VECTOR_INDEX_FC,          ARAD_PP_LB_VECTOR_INDEX_FC_VFT, ARAD_PP_LB_VECTOR_INDEX_NONE},
  
  { ARAD_PP_PORT_PROFILE_DC, DPP_PFC_FCOE_ENCAP_ETH,ARAD_PP_PLC_FC_VFT,    ARAD_PP_LB_VECTOR_INDEX_NONE,     ARAD_PP_LB_VECTOR_INDEX_FC,          ARAD_PP_LB_VECTOR_INDEX_FC_VFT, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE},
  
  { ARAD_PP_PORT_PROFILE_DC, DPP_PFC_FCOE_ENCAP_ETH,ARAD_PP_PLC_FC_NO_VFT, ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE,     ARAD_PP_LB_VECTOR_INDEX_FC,         ARAD_PP_LB_VECTOR_INDEX_NONE, ARAD_PP_LB_VECTOR_INDEX_NONE},
};

CONST STATIC ARAD_PP_LB_HASH_FIELD_INFO Arad_pp_lag_hash_field_info []=
{
    
    
    
    {ARAD_PP_LB_VECTOR_INDEX_ETHERNET, 6 , {5,6,9,10,13,14}},
    
    {ARAD_PP_LB_VECTOR_INDEX_ETHERNET, 6 , {3,4,7,8,11,12}},
    
    {ARAD_PP_LB_VECTOR_INDEX_ETHERNET, 2 , {0,1,0,0,0,0}},
    
    {ARAD_PP_LB_VECTOR_INDEX_ETHERNET, 1 , {2,0,0,0,0,0}},
    
    {ARAD_PP_LB_VECTOR_INDEX_MPLSX1, 5 , {0,1,2,3,4,0}},
    
    {ARAD_PP_LB_VECTOR_INDEX_MPLSX2_LABEL1, 5 , {8,9,10,11,12,0}},
    
    {ARAD_PP_LB_VECTOR_INDEX_MPLSX3_LABEL1, 5 , {16,17,18,19,20,0}},
    
    {ARAD_PP_LB_VECTOR_INDEX_IPV4, 4 , {12,13,14,15,0,0}},
    
    {ARAD_PP_LB_VECTOR_INDEX_IPV4, 4 , {16,17,18,19,0,0}},
    
    {ARAD_PP_LB_VECTOR_INDEX_IPV4, 1 , {9,0,0,0,0,0}},
    
    {ARAD_PP_LB_VECTOR_INDEX_IPV6, 6 , {0,1,4,5,8,9}},
    
    {ARAD_PP_LB_VECTOR_INDEX_IPV6, 6 , {2,3,6,7,10,11}},
    
    {ARAD_PP_LB_VECTOR_INDEX_IPV6, 1 , {18,0,0,0,0,0}},
    
    {ARAD_PP_LB_VECTOR_INDEX_L4, 2 , {0,1,0,0,0,0}},
    
    {ARAD_PP_LB_VECTOR_INDEX_L4, 2 , {2,3,0,0,0,0}},
    
    {ARAD_PP_LB_VECTOR_INDEX_FC, 3 , {1,2,3,0,0,0}},
    
    {ARAD_PP_LB_VECTOR_INDEX_FC, 3 , {5,6,7,0,0,0}},
    
    {ARAD_PP_LB_VECTOR_INDEX_FC, 1 , {12,0,0,0,0,0}},
    
    {ARAD_PP_LB_VECTOR_INDEX_FC, 2 , {16,17,0,0,0,0}},
    
    {ARAD_PP_LB_VECTOR_INDEX_FC, 2 , {18,19,0,0,0,0}},
    
    {ARAD_PP_LB_VECTOR_INDEX_FC_VFT, 3 , {5,6,7,0,0,0}},
    
    {ARAD_PP_LB_VECTOR_INDEX_TRILL, 2 , {1,2,0,0,0,0}},
    
    {ARAD_PP_LB_VECTOR_INDEX_MPLSX5_LABEL4, 5, {0,1,2,3,4,0}},
    
    {ARAD_PP_LB_VECTOR_INDEX_MPLSX5_LABEL4, 5, {8,9,10,11,12,0}},
};

CONST STATIC ARAD_PP_LB_HASH_CHUNK_SIZE Arad_pp_lb_key_chunk_size[] = 
{   
    {ARAD_PP_LB_VECTOR_INDEX_NONE         , 0},
    {ARAD_PP_LB_VECTOR_INDEX_ETHERNET     , 1},
    {ARAD_PP_LB_VECTOR_INDEX_FC           , 1},
    {ARAD_PP_LB_VECTOR_INDEX_IPV4         , 1},
    {ARAD_PP_LB_VECTOR_INDEX_IPV6         , 1},
    {ARAD_PP_LB_VECTOR_INDEX_MPLSX1       , 0},
    {ARAD_PP_LB_VECTOR_INDEX_MPLSX2_LABEL1, 0},
    {ARAD_PP_LB_VECTOR_INDEX_MPLSX2_LABEL2, 0},
    {ARAD_PP_LB_VECTOR_INDEX_MPLSX3_LABEL1, 0},
    {ARAD_PP_LB_VECTOR_INDEX_MPLSX3_LABEL2, 0},
    {ARAD_PP_LB_VECTOR_INDEX_MPLSX3_LABEL3, 0},
    {ARAD_PP_LB_VECTOR_INDEX_TRILL        , 0},
    {ARAD_PP_LB_VECTOR_INDEX_L4           , 1},
    {ARAD_PP_LB_VECTOR_INDEX_FC_VFT       , 0},
    {ARAD_PP_LB_VECTOR_INDEX_MPLSX5_LABEL4, 0},
};





uint32
  arad_pp_lag_lb_vector_index_map(int unit, uint32 lb_vector_index_id)
{
    uint32 dev_lb_vector_index;

    switch (lb_vector_index_id) {
    case ARAD_PP_LB_VECTOR_INDEX_ETHERNET:
        dev_lb_vector_index = SOC_DPP_LB_VECTOR_INDEX_ETHERNET;
        break;
    case ARAD_PP_LB_VECTOR_INDEX_FC:
        dev_lb_vector_index = SOC_DPP_LB_VECTOR_INDEX_FC;
        break;
    case ARAD_PP_LB_VECTOR_INDEX_IPV4:
        dev_lb_vector_index = SOC_DPP_LB_VECTOR_INDEX_IPV4;
        break;
    case ARAD_PP_LB_VECTOR_INDEX_IPV6:
        dev_lb_vector_index = SOC_DPP_LB_VECTOR_INDEX_IPV6;
        break;
    case ARAD_PP_LB_VECTOR_INDEX_MPLSX1:
        dev_lb_vector_index = SOC_DPP_LB_VECTOR_INDEX_MPLSX1;
        break;
    case ARAD_PP_LB_VECTOR_INDEX_MPLSX2_LABEL1:
        dev_lb_vector_index = SOC_DPP_LB_VECTOR_INDEX_MPLSX2_LABEL1;
        break;
    case ARAD_PP_LB_VECTOR_INDEX_MPLSX2_LABEL2:
        dev_lb_vector_index = SOC_DPP_LB_VECTOR_INDEX_MPLSX2_LABEL2;
        break;
    case ARAD_PP_LB_VECTOR_INDEX_MPLSX3_LABEL1:
        dev_lb_vector_index = SOC_DPP_LB_VECTOR_INDEX_MPLSX3_LABEL1;
        break;
    case ARAD_PP_LB_VECTOR_INDEX_MPLSX3_LABEL2:
        dev_lb_vector_index = SOC_DPP_LB_VECTOR_INDEX_MPLSX3_LABEL2;
        break;
    case ARAD_PP_LB_VECTOR_INDEX_MPLSX3_LABEL3:
        dev_lb_vector_index = SOC_DPP_LB_VECTOR_INDEX_MPLSX3_LABEL3;
        break;
    case ARAD_PP_LB_VECTOR_INDEX_TRILL:
        dev_lb_vector_index = SOC_DPP_LB_VECTOR_INDEX_TRILL;
        break;
    case ARAD_PP_LB_VECTOR_INDEX_L4:
        dev_lb_vector_index = SOC_DPP_LB_VECTOR_INDEX_L4;
        break;
    case ARAD_PP_LB_VECTOR_INDEX_FC_VFT:
        dev_lb_vector_index = SOC_DPP_LB_VECTOR_INDEX_FC_VFT;
        break;
    case ARAD_PP_LB_VECTOR_INDEX_CALC:
        dev_lb_vector_index = SOC_DPP_LB_VECTOR_INDEX_CALC;
        break;
    case ARAD_PP_LB_VECTOR_INDEX_MPLSX5_LABEL4:
        dev_lb_vector_index= SOC_DPP_LB_VECTOR_INDEX_MPLSX5_LABEL4;
        break;
    case ARAD_PP_LB_VECTOR_INDEX_NONE:
    default:
        dev_lb_vector_index = SOC_DPP_LB_VECTOR_INDEX_NONE;
        break;
    }

    return dev_lb_vector_index;
}

uint32
  arad_pp_lag_hash_func_to_hw_val(
    SOC_SAND_IN  int       unit,
    SOC_SAND_IN  uint8         hash_func_id,
    SOC_SAND_OUT  uint32        *hw_val
  )
{
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  switch (hash_func_id)
  {
    case SOC_PPC_LAG_LB_KEY:
     *hw_val = 10;
    break;
    case SOC_PPC_LAG_LB_ROUND_ROBIN:
     *hw_val = 11;
    break;
    case SOC_PPC_LAG_LB_2_CLOCK:
     *hw_val = 12;
    break;
    case SOC_PPC_LAG_LB_CRC_0x10861:
    case SOC_PPC_LAG_LB_CRC_0x8003: 
     *hw_val = 0;
    break;
    case SOC_PPC_LAG_LB_CRC_0x10285:
    case SOC_PPC_LAG_LB_CRC_0x8011: 
     *hw_val = 1;
    break;
    case SOC_PPC_LAG_LB_CRC_0x101A1:
    case SOC_PPC_LAG_LB_CRC_0x8423: 
     *hw_val = 2;
    break;
    case SOC_PPC_LAG_LB_CRC_0x12499:
    case SOC_PPC_LAG_LB_CRC_0x8101: 
     *hw_val = 3;
    break;
    case SOC_PPC_LAG_LB_CRC_0x1F801:
    case SOC_PPC_LAG_LB_CRC_0x84a1: 
     *hw_val = 4;
    break;
    case SOC_PPC_LAG_LB_CRC_0x172E1:
    case SOC_PPC_LAG_LB_CRC_0x9019: 
     *hw_val = 5;
    break;
    case SOC_PPC_LAG_LB_CRC_0x1EB21:
     *hw_val = 6;
    break;
    case SOC_PPC_LAG_LB_CRC_0x13965:
     *hw_val = 7;
    break;
    case SOC_PPC_LAG_LB_CRC_0x1698D:
     *hw_val = 8;
    break;
    case SOC_PPC_LAG_LB_CRC_0x1105D:
     *hw_val = 9;
    break;

    case SOC_PPC_LAG_LB_CRC_0x14D:
    case SOC_PPC_LAG_LB_CRC_0x1C3:
    case SOC_PPC_LAG_LB_CRC_0x1CF:
  default:
    SOC_SAND_SET_ERROR_CODE(ARAD_PP_LAG_HASH_FUNC_ID_OUT_OF_RANGE_ERR, 10, exit);
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_lag_hash_func_to_hw_val()", 0, 0);
}

uint32
  arad_pp_lag_hash_func_from_hw_val(
    SOC_SAND_IN  int       unit,
    SOC_SAND_IN  uint32        hw_val,
    SOC_SAND_OUT  uint8        *hash_func_id
  )
{
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  switch (hw_val)
  {
    case 10:
     *hash_func_id = SOC_PPC_LAG_LB_KEY;
    break;
    case 11:
     *hash_func_id = SOC_PPC_LAG_LB_ROUND_ROBIN;
    break;
    case 12:
     *hash_func_id = SOC_PPC_LAG_LB_2_CLOCK;
    break;
    case 0:
#ifdef BCM_88660_A0
        
        if (SOC_IS_ARADPLUS(unit)) {
            *hash_func_id = SOC_PPC_LAG_LB_CRC_0x8003;
        }
        else
#endif 
        {
            *hash_func_id = SOC_PPC_LAG_LB_CRC_0x10861;
        }
    break;
    case 1:
#ifdef BCM_88660_A0
        
        if (SOC_IS_ARADPLUS(unit)) {
            *hash_func_id = SOC_PPC_LAG_LB_CRC_0x8011;
        }
        else
#endif 
        {
            *hash_func_id = SOC_PPC_LAG_LB_CRC_0x10285;
        }
    break;
    case 2:
#ifdef BCM_88660_A0
        
        if (SOC_IS_ARADPLUS(unit)) {
            *hash_func_id = SOC_PPC_LAG_LB_CRC_0x8423;
        }
        else
#endif 
        {
            *hash_func_id = SOC_PPC_LAG_LB_CRC_0x101A1;
        }
    break;
    case 3:
#ifdef BCM_88660_A0
        
        if (SOC_IS_ARADPLUS(unit)) {
            *hash_func_id = SOC_PPC_LAG_LB_CRC_0x8101;
        }
        else
#endif 
        {
            *hash_func_id = SOC_PPC_LAG_LB_CRC_0x12499;
        }
    break;
    case 4:
#ifdef BCM_88660_A0
        
        if (SOC_IS_ARADPLUS(unit)) {
            *hash_func_id = SOC_PPC_LAG_LB_CRC_0x84a1;
        }
        else
#endif 
        {
            *hash_func_id = SOC_PPC_LAG_LB_CRC_0x1F801;
        }
    break;
    case 5:
#ifdef BCM_88660_A0
        
        if (SOC_IS_ARADPLUS(unit)) {
            *hash_func_id = SOC_PPC_LAG_LB_CRC_0x9019;
        }
        else
#endif 
        {
            *hash_func_id = SOC_PPC_LAG_LB_CRC_0x172E1;
        }
    break;
    case 6:
     *hash_func_id = SOC_PPC_LAG_LB_CRC_0x1EB21;
    break;
    case 7:
     *hash_func_id = SOC_PPC_LAG_LB_CRC_0x13965;
    break;
    case 8:
     *hash_func_id = SOC_PPC_LAG_LB_CRC_0x1698D;
    break;
    case 9:
     *hash_func_id = SOC_PPC_LAG_LB_CRC_0x1105D;
    break;
  default:
    SOC_SAND_SET_ERROR_CODE(ARAD_PP_LAG_HASH_FUNC_ID_OUT_OF_RANGE_ERR, 10, exit);
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_lag_hash_func_to_hw_val()", 0, 0);
}

uint32
  arad_pp_lag_set_pfc_profile_tbl(
    SOC_SAND_IN  int                  unit,
    SOC_SAND_IN  int                  nof_entries,
    SOC_SAND_IN  ARAD_PP_LB_HASH_MAP  *lb_hash_map_table
  )
{
  uint32
    idx, port_profile_state, offset, pfc_hw, res = SOC_SAND_OK;
  ARAD_PP_IHB_LB_PFC_PROFILE_TBL_DATA
    ihb_lb_pfc_profile_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  for (idx = 0; idx < nof_entries; ++idx) {
      for (port_profile_state = 0; port_profile_state < ARAD_PP_PORT_PROFILE_DC; port_profile_state++) {

          if ((lb_hash_map_table[idx].port_profile_state == port_profile_state) || (lb_hash_map_table[idx].port_profile_state == ARAD_PP_PORT_PROFILE_DC)) {

              res = dpp_parser_pfc_get_hw_by_sw(unit, lb_hash_map_table[idx].pfc_sw, &pfc_hw, NULL);
              if(res == SOC_E_DISABLED)
                  continue;
              else
              {
                  SOC_SAND_CHECK_FUNC_RESULT(res, 17, exit);
              }

              offset = ARAD_PP_LB_PFC_OFFSET_SET(port_profile_state, lb_hash_map_table[idx].plc_setbit, pfc_hw);
              ihb_lb_pfc_profile_tbl.lb_vector_index_1   = arad_pp_lag_lb_vector_index_map(unit, lb_hash_map_table[idx].index1);
              ihb_lb_pfc_profile_tbl.lb_vector_index_2   = arad_pp_lag_lb_vector_index_map(unit, lb_hash_map_table[idx].index2);
              ihb_lb_pfc_profile_tbl.lb_vector_index_3   = arad_pp_lag_lb_vector_index_map(unit, lb_hash_map_table[idx].index3);
              ihb_lb_pfc_profile_tbl.lb_vector_index_4   = arad_pp_lag_lb_vector_index_map(unit, lb_hash_map_table[idx].index4);
              ihb_lb_pfc_profile_tbl.lb_vector_index_5   = arad_pp_lag_lb_vector_index_map(unit, lb_hash_map_table[idx].index5);

              res = arad_pp_ihb_lb_pfc_profile_tbl_set_unsafe(
                        unit,
                        offset,
                        &ihb_lb_pfc_profile_tbl);

              SOC_SAND_CHECK_FUNC_RESULT(res, 17, exit);
          }
      }
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_lag_set_pfc_profile_tbl()", 0, 0);
}



uint32
  arad_pp_lag_init_unsafe(
    SOC_SAND_IN  int                                 unit
  )
{
  int
    port_ndx,
    core_id,
    nof_pp_ports_per_core;
  SOC_PPC_HASH_MASK_INFO
    hash_info;
  ARAD_PP_IHB_PINFO_FER_TBL_DATA
    ihb_pinfo_fer_tbl_data;
  uint32
    res = SOC_SAND_OK,
    hw_val;
  SHR_BITDCL
    plc_profile_bitmap = 0;
  uint64
    reg_64;
  uint64
    field64_val;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);
  SOC_SAND_PCID_LITE_SKIP(unit);

  if (SOC_IS_JERICHO(unit) && (SOC_DPP_CONFIG(unit)->pp.parser_mode == 1)) {
    
    res = arad_pp_lag_set_pfc_profile_tbl(unit, sizeof(Arad_pp_lb_hash_map_table_new_lb_scheme) / sizeof(ARAD_PP_LB_HASH_MAP), Arad_pp_lb_hash_map_table_new_lb_scheme);
    SOC_SAND_CHECK_FUNC_RESULT(res, 19, exit);

    if (SOC_DPP_CONFIG(unit)->trill.mode) {
        res = arad_pp_lag_set_pfc_profile_tbl(unit, sizeof(Arad_pp_lb_hash_map_table_trill_new_lb_scheme) / sizeof(ARAD_PP_LB_HASH_MAP), Arad_pp_lb_hash_map_table_trill_new_lb_scheme);
        SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);
    }

    if(SOC_DPP_CONFIG(unit)->pp.fcoe_enable) {
        res = arad_pp_lag_set_pfc_profile_tbl(unit, sizeof(Arad_pp_lb_hash_map_table_fcoe_new_lb_scheme) / sizeof(ARAD_PP_LB_HASH_MAP), Arad_pp_lb_hash_map_table_fcoe_new_lb_scheme);
        SOC_SAND_CHECK_FUNC_RESULT(res, 21, exit);
    }

  } else {
    
    res = arad_pp_lag_set_pfc_profile_tbl(unit, sizeof(Arad_pp_lb_hash_map_table) / sizeof(ARAD_PP_LB_HASH_MAP), Arad_pp_lb_hash_map_table);
    SOC_SAND_CHECK_FUNC_RESULT(res, 22, exit);
  }

  SOC_PPC_HASH_MASK_INFO_clear(&hash_info);
  hash_info.mask = 0;

  res = arad_pp_lag_hashing_mask_set_unsafe(
          unit,
          &hash_info
        );
  SOC_SAND_CHECK_FUNC_RESULT(res, 21, exit);

  
#ifdef BCM_88675_A0
  if(SOC_IS_JERICHO(unit)) {

    SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  70,  exit, ARAD_REG_ACCESS_ERR, READ_IHB_LAG_LB_KEY_CFGr(unit, SOC_CORE_ALL, &reg_64));

    COMPILER_64_SET(field64_val, 0x0, 0);
    ARAD_FLD_TO_REG64(IHB_LAG_LB_KEY_CFGr, LAG_LB_HASH_INDEXf, field64_val, reg_64, 71, exit);
    
    COMPILER_64_SET(field64_val, 0x0, 0x6);
    ARAD_FLD_TO_REG64(IHB_LAG_LB_KEY_CFGr, LAG_LB_HASH_INDEX_1f, field64_val, reg_64, 72, exit);

    COMPILER_64_SET(field64_val, 0x0, SOC_PPC_MPLS_TERM_RESERVED_LABEL_ELI);
    ARAD_FLD_TO_REG64(IHB_LAG_LB_KEY_CFGr, LB_MPLS_ELI_LABELf, field64_val, reg_64, 73, exit);

    SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res, 77,  exit, ARAD_REG_ACCESS_ERR, WRITE_IHB_LAG_LB_KEY_CFGr(unit, SOC_CORE_ALL, reg_64));
  } else
#endif 
  if(SOC_IS_ARAD_B0_AND_ABOVE(unit)) {

    uint32 reg_val;

    SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  60,  exit, ARAD_REG_ACCESS_ERR,READ_IHB_REG_0090r(unit, &reg_val));

    ARAD_FLD_TO_REG(IHB_REG_0090r, ITEM_0_7f, 0xf0 , reg_val, 62, exit);
    ARAD_FLD_TO_REG(IHB_REG_0090r, ITEM_8_11f, 0xa, reg_val, 64, exit);

    SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  66,  exit, ARAD_REG_ACCESS_ERR,WRITE_IHB_REG_0090r(unit, reg_val));
  }

  
  if(SOC_SUPPORTS_ECMP_HASH_COMBINE(unit)) {
      arad_pp_lag_hashing_ecmp_hash_slb_combine_set(unit, FALSE);
  }

  
  SHR_BITSET(&plc_profile_bitmap, ARAD_PARSER_PLC_MPLS_5);
  SHR_BITSET(&plc_profile_bitmap, ARAD_PARSER_PLC_FCOE_VFT);
  SHR_BITSET(&plc_profile_bitmap, ARAD_PARSER_PLC_GAL_GACH_BFD);
  SHR_BITSET(&plc_profile_bitmap, ARAD_PARSER_PLC_PP_L4);
  if (((SOC_DPP_CONFIG(unit)->pp.bfd_ipv4_single_hop) || (SOC_DPP_CONFIG(unit)->pp.bfd_ipv6_enable == SOC_DPP_ARAD_BFD_IPV6_SUPPORT_WITH_LEM)) ){
      SHR_BITSET(&plc_profile_bitmap, ARAD_PARSER_PLC_BFD_SINGLE_HOP);
  }


  
  if(SOC_IS_JERICHO_PLUS_A0(unit) || SOC_IS_QUX(unit)) {
      nof_pp_ports_per_core = SOC_DPP_DEFS_GET(unit, nof_pp_ports_per_core);
      SOC_DPP_CORES_ITER(SOC_CORE_ALL, core_id) {
          for (port_ndx = 0; port_ndx < nof_pp_ports_per_core; port_ndx++) {
              res = arad_pp_ihb_pinfo_fer_tbl_get_unsafe(unit, core_id, port_ndx, &ihb_pinfo_fer_tbl_data);
              SOC_SAND_CHECK_FUNC_RESULT(res, 70, exit);
              ihb_pinfo_fer_tbl_data.ecmp_lb_key_count = 1;
              ihb_pinfo_fer_tbl_data.lag_lb_key_start  = 1;

              res = arad_pp_ihb_pinfo_fer_tbl_set_unsafe(unit, core_id, port_ndx, &ihb_pinfo_fer_tbl_data);
              SOC_SAND_CHECK_FUNC_RESULT(res, 71, exit);
          }
      }
      
      SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  72,  exit, ARAD_REG_ACCESS_ERR, READ_IHB_ECMP_LB_KEY_CFGr(unit, SOC_CORE_ALL, &reg_64));
      hw_val = arad_pp_frwrd_fec_hash_index_to_hw_val(SOC_PPC_FEC_LB_CRC_0x8101);
      COMPILER_64_SET(field64_val, 0x0, hw_val);
      ARAD_FLD_TO_REG64(IHB_ECMP_LB_KEY_CFGr, ECMP_2ND_HIER_LB_HASH_INDEXf, field64_val, reg_64, 74, exit);
      SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res, 75,  exit, ARAD_REG_ACCESS_ERR, WRITE_IHB_ECMP_LB_KEY_CFGr(unit, SOC_CORE_ALL, reg_64));
  }

  SOC_SAND_SOC_IF_ERROR_RETURN(res, 80, exit, WRITE_IHB_LB_KEY_PARSER_LEAF_CONTEXT_PROFILEr(unit, REG_PORT_ANY, plc_profile_bitmap));

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_lag_init_unsafe()", 0, 0);
}




uint32
    arad_pp_lag_init_polynomial_for_tm_mode(
    SOC_SAND_IN int unit
  )
{
  uint32 res = SOC_SAND_OK;
  uint64 reg_64, field64_val;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);
  SOC_SAND_PCID_LITE_SKIP(unit);


 SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  70,  exit, ARAD_REG_ACCESS_ERR, READ_IHB_LAG_LB_KEY_CFGr(unit, SOC_CORE_ALL, &reg_64));
 COMPILER_64_SET(field64_val, 0x0, 0);
 ARAD_FLD_TO_REG64(IHB_LAG_LB_KEY_CFGr, LAG_LB_HASH_INDEXf, field64_val, reg_64, 71, exit);
 if (SOC_IS_JERICHO(unit)) {
     COMPILER_64_SET(field64_val, 0x0, 0x6);
     ARAD_FLD_TO_REG64(IHB_LAG_LB_KEY_CFGr, LAG_LB_HASH_INDEX_1f, field64_val, reg_64, 72, exit);
 }
 SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res, 71,  exit, ARAD_REG_ACCESS_ERR, WRITE_IHB_LAG_LB_KEY_CFGr(unit, SOC_CORE_ALL, reg_64));


  
 SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  72,  exit, ARAD_REG_ACCESS_ERR, READ_IHB_ECMP_LB_KEY_CFGr(unit, SOC_CORE_ALL, &reg_64));
 COMPILER_64_SET(field64_val, 0x0, 0x7);
 ARAD_FLD_TO_REG64(IHB_ECMP_LB_KEY_CFGr, ECMP_LB_HASH_INDEXf, field64_val, reg_64, 74, exit);
 if (SOC_IS_JERICHO_PLUS_A0(unit) || SOC_IS_QUX(unit)) {
     COMPILER_64_SET(field64_val, 0x0, 0x8);
     ARAD_FLD_TO_REG64(IHB_ECMP_LB_KEY_CFGr, ECMP_2ND_HIER_LB_HASH_INDEXf, field64_val, reg_64, 74, exit);
 }
 SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res, 73,  exit, ARAD_REG_ACCESS_ERR, WRITE_IHB_ECMP_LB_KEY_CFGr(unit, SOC_CORE_ALL, reg_64));

 
 if (SOC_IS_ARADPLUS(unit) && (!(SOC_IS_ARDON(unit)))) {
     SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  74,  exit, ARAD_REG_ACCESS_ERR, READ_IHB_CONSISTENT_HASHING_LB_KEY_CFGr(unit, SOC_CORE_ALL, &reg_64));
     COMPILER_64_SET(field64_val, 0x0, 0x9);
     ARAD_FLD_TO_REG64(IHB_CONSISTENT_HASHING_LB_KEY_CFGr, CONSISTENT_HASHING_LAG_LB_HASH_INDEXf, field64_val, reg_64, 74, exit);
     SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res, 75,  exit, ARAD_REG_ACCESS_ERR, WRITE_IHB_CONSISTENT_HASHING_LB_KEY_CFGr(unit, SOC_CORE_ALL, reg_64));
 }

 exit:
     SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_lag_init_polynomial_for_tm_mode()", 0, 0);
}


STATIC void
  arad_pp_lag_members_ppd2tm(
    SOC_SAND_IN   SOC_PPC_LAG_INFO        *soc_ppd_lag,
    SOC_SAND_OUT  SOC_PPC_LAG_INFO  *tm_lag
  )
{
  uint32
    entry_idx;

  tm_lag->soc_sand_magic_num = SOC_SAND_MAGIC_NUM_VAL;
  tm_lag->nof_entries = soc_ppd_lag->nof_entries;

  for (entry_idx = 0; entry_idx < soc_ppd_lag->nof_entries; entry_idx++)
  {
    tm_lag->members[entry_idx].member_id = soc_ppd_lag->members[entry_idx].member_id;
    tm_lag->members[entry_idx].sys_port  = soc_ppd_lag->members[entry_idx].sys_port;
    tm_lag->members[entry_idx].flags     = soc_ppd_lag->members[entry_idx].flags;
  }
}

STATIC void
  arad_pp_lag_members_tm2ppd(
    SOC_SAND_IN  SOC_PPC_LAG_INFO  *tm_lag,
    SOC_SAND_OUT SOC_PPC_LAG_INFO        *soc_ppd_lag
  )
{
  uint32
    entry_idx;

  soc_ppd_lag->nof_entries = tm_lag->nof_entries;

  for (entry_idx = 0; entry_idx < tm_lag->nof_entries; entry_idx++)
  {
    soc_ppd_lag->members[entry_idx].member_id = tm_lag->members[entry_idx].member_id;
    soc_ppd_lag->members[entry_idx].sys_port = tm_lag->members[entry_idx].sys_port;
  }
}


 
uint32
  arad_pp_lag_set_unsafe(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_IN  uint32                                  lag_ndx,
    SOC_SAND_IN  SOC_PPC_LAG_INFO                            *lag_info
  )
{
  uint32
    res = SOC_SAND_OK;
  ARAD_IRR_LAG_TO_LAG_RANGE_TBL_DATA
    lag2lag_rng_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_LAG_SET_UNSAFE);

  SOC_SAND_CHECK_NULL_INPUT(lag_info);

  
  res = arad_irr_lag_to_lag_range_tbl_get_unsafe(unit, lag_ndx, &lag2lag_rng_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  
  switch (lag_info->lb_type) {
  case SOC_PPC_LAG_LB_TYPE_HASH:
      lag2lag_rng_tbl.mode = 0x0;
      break;
  case SOC_PPC_LAG_LB_TYPE_ROUND_ROBIN:
      lag2lag_rng_tbl.mode = 0x1;
      break;
  case SOC_PPC_LAG_LB_TYPE_SMOOTH_DIVISION:
      lag2lag_rng_tbl.mode = 0x2;
      break;
  default:
      lag2lag_rng_tbl.mode = 0x3; 
      break;
  }

#ifdef BCM_88660_A0
  if (SOC_IS_ARADPLUS(unit)) {
    lag2lag_rng_tbl.is_stateful = lag_info->is_stateful;
  }
#endif 

  res = arad_irr_lag_to_lag_range_tbl_set_unsafe(unit, lag_ndx, &lag2lag_rng_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

  
  
  
  res = arad_ports_lag_set_unsafe(unit, lag_ndx, lag_info);
  SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_lag_set_unsafe()", lag_ndx, 0);
}

uint32
  arad_pp_lag_set_verify(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_IN  uint32                                  lag_ndx,
    SOC_SAND_IN  SOC_PPC_LAG_INFO                          *lag_info
  )
{
  uint32
    res = SOC_SAND_OK;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_LAG_SET_VERIFY);

  SOC_SAND_ERR_IF_ABOVE_MAX(lag_ndx, ARAD_PP_LAG_LAG_NDX_MAX(unit), ARAD_PP_LAG_LAG_NDX_OUT_OF_RANGE_ERR, 10, exit);
  res = SOC_PPC_LAG_INFO_verify(unit,lag_info);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);
  

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_lag_set_verify()", lag_ndx, 0);
}

uint32
  arad_pp_lag_get_verify(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_IN  uint32                                  lag_ndx
  )
{
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_LAG_GET_VERIFY);

  SOC_SAND_ERR_IF_ABOVE_MAX(lag_ndx, ARAD_PP_LAG_LAG_NDX_MAX(unit), ARAD_PP_LAG_LAG_NDX_OUT_OF_RANGE_ERR, 10, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_lag_get_verify()", lag_ndx, 0);
}

uint32
  arad_pp_lag_get_unsafe(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_IN  uint32                                  lag_ndx,
    SOC_SAND_OUT SOC_PPC_LAG_INFO                            *lag_info
  )
{
  uint32
    res = SOC_SAND_OK;
  SOC_PPC_LAG_INFO
    *tm_lag_info_in = NULL,
    *tm_lag_info_out = NULL;
  ARAD_IRR_LAG_TO_LAG_RANGE_TBL_DATA
    lag2lag_rng_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_LAG_GET_UNSAFE);

  SOC_SAND_CHECK_NULL_INPUT(lag_info);

  SOC_PPC_LAG_INFO_clear(lag_info);

  
  res = arad_irr_lag_to_lag_range_tbl_get_unsafe(
          unit,
          lag_ndx,
          &lag2lag_rng_tbl
        );
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  switch (lag2lag_rng_tbl.mode) {
  case 0:
      lag_info->lb_type = SOC_PPC_LAG_LB_TYPE_HASH;
      break;
  case 1:
      lag_info->lb_type = SOC_PPC_LAG_LB_TYPE_ROUND_ROBIN;
      break;
  case 2:
      lag_info->lb_type = SOC_PPC_LAG_LB_TYPE_SMOOTH_DIVISION;
      break;
  }

#ifdef BCM_88660_A0
  if (SOC_IS_ARADPLUS(unit)) {
    lag_info->is_stateful = lag2lag_rng_tbl.is_stateful;
  }
#endif 

  
  
  

  ARAD_ALLOC(tm_lag_info_in, SOC_PPC_LAG_INFO, 1, "arad_pp_lag_get_unsafe.tm_lag_info_in");
  ARAD_ALLOC(tm_lag_info_out, SOC_PPC_LAG_INFO, 1, "arad_pp_lag_get_unsafe.tm_lag_info_out");

  res = arad_ports_lag_get_unsafe(
          unit,
          lag_ndx,
          tm_lag_info_in,
          tm_lag_info_out
        );
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  arad_pp_lag_members_tm2ppd(tm_lag_info_out, lag_info);
  
exit:
  ARAD_FREE(tm_lag_info_in);
  ARAD_FREE(tm_lag_info_out);
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_lag_get_unsafe()", lag_ndx, 0);
}


uint32
  arad_pp_lag_member_add_unsafe(
    SOC_SAND_IN  int                                unit,
    SOC_SAND_IN  uint32                             lag_ndx,
    SOC_SAND_IN  SOC_PPC_LAG_MEMBER                 *member,
    SOC_SAND_OUT SOC_SAND_SUCCESS_FAILURE           *success
  )
{
  uint32
    res = SOC_SAND_OK;
  ARAD_PORTS_LAG_MEMBER
    lag_member;

  SOC_SAND_INIT_ERROR_DEFINITIONS(SOC_PPC_LAG_MEMBER_ADD_UNSAFE);

  SOC_SAND_CHECK_NULL_INPUT(member);
  SOC_SAND_CHECK_NULL_INPUT(success);

  arad_ARAD_PORTS_LAG_MEMBER_clear(&lag_member);
  lag_member.member_id = member->member_id;
  lag_member.sys_port = member->sys_port;
  lag_member.flags    = member->flags;

  res = arad_ports_lag_member_add_unsafe( unit, lag_ndx, &lag_member );
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  *success = SOC_SAND_SUCCESS;
  
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_lag_member_add_unsafe()", lag_ndx, 0);
}

uint32
  arad_pp_lag_member_add_verify(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_IN  uint32                                  lag_ndx,
    SOC_SAND_IN  SOC_PPC_LAG_MEMBER                          *member
  )
{
  uint32
    res = SOC_SAND_OK;

  SOC_SAND_INIT_ERROR_DEFINITIONS(SOC_PPC_LAG_MEMBER_ADD_VERIFY);

  SOC_SAND_ERR_IF_ABOVE_MAX(lag_ndx, ARAD_PP_LAG_LAG_NDX_MAX(unit), ARAD_PP_LAG_LAG_NDX_OUT_OF_RANGE_ERR, 10, exit);
  ARAD_PP_STRUCT_VERIFY(SOC_PPC_LAG_MEMBER, member, 20, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_lag_member_add_verify()", lag_ndx, 0);
}


uint32
  arad_pp_lag_member_remove_unsafe(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_IN  uint32                                 lag_ndx,
    SOC_SAND_IN  SOC_PPC_LAG_MEMBER                     *member
  )
{
  uint32
    res = SOC_SAND_OK;
  ARAD_PORTS_LAG_MEMBER
    lag_member;

  SOC_SAND_INIT_ERROR_DEFINITIONS(SOC_PPC_LAG_MEMBER_REMOVE_UNSAFE);

  SOC_SAND_CHECK_NULL_INPUT(member);

  arad_ARAD_PORTS_LAG_MEMBER_clear(&lag_member);
  lag_member.member_id = member->member_id;
  lag_member.sys_port = member->sys_port;
  lag_member.flags    = member->flags;

  res = arad_ports_lag_sys_port_remove_unsafe( unit, lag_ndx, &lag_member );
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_lag_member_remove_unsafe()", lag_ndx, 0);
}

uint32
  arad_pp_lag_member_remove_verify(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_IN  uint32                                  lag_ndx,
    SOC_SAND_IN  SOC_PPC_LAG_MEMBER                     *member
  )
{
  uint32
    res = SOC_SAND_OK;
  SOC_SAND_INIT_ERROR_DEFINITIONS(SOC_PPC_LAG_MEMBER_REMOVE_VERIFY);

  SOC_SAND_ERR_IF_ABOVE_MAX(lag_ndx, ARAD_PP_LAG_LAG_NDX_MAX(unit), ARAD_PP_LAG_LAG_NDX_OUT_OF_RANGE_ERR, 10, exit);
  SOC_SAND_ERR_IF_ABOVE_MAX(member->sys_port, ARAD_PP_LAG_SYS_PORT_MAX, ARAD_PP_LAG_SYS_PORT_OUT_OF_RANGE_ERR, 20, exit);

  ARAD_PP_STRUCT_VERIFY(SOC_PPC_LAG_MEMBER, member, 30, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_lag_member_remove_verify()", lag_ndx, 0);
}


uint32
  arad_pp_lag_hashing_global_info_set_unsafe(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_IN  SOC_PPC_LAG_HASH_GLOBAL_INFO                *glbl_hash_info
  )
{
  uint64
    reg_val;
  uint64
      fld64_val;
  uint32
    fld_val;
  uint32
      res = SOC_SAND_OK;
    
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_LAG_HASHING_GLOBAL_INFO_SET_UNSAFE);
  SOC_SAND_CHECK_NULL_INPUT(glbl_hash_info);
  

  SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  8,  exit, ARAD_REG_ACCESS_ERR,READ_IHB_LAG_LB_KEY_CFGr(unit, SOC_CORE_ALL, &reg_val));

  COMPILER_64_SET(fld64_val, 0, glbl_hash_info->seed);  
  ARAD_FLD_TO_REG64(IHB_LAG_LB_KEY_CFGr, LAG_LB_KEY_SEEDf, fld64_val, reg_val, 10, exit);

  COMPILER_64_SET(fld64_val, 0, SOC_SAND_BOOL2NUM(glbl_hash_info->use_port_id));  
  ARAD_FLD_TO_REG64(IHB_LAG_LB_KEY_CFGr, LAG_LB_KEY_USE_IN_PORTf, fld64_val, reg_val, 14, exit);

  res = arad_pp_lag_hash_func_to_hw_val(unit,glbl_hash_info->hash_func_id,&fld_val);
  SOC_SAND_CHECK_FUNC_RESULT(res, 15, exit);

  if (glbl_hash_info->hash_func_id != SOC_PPC_LAG_LB_KEY) {
      res = arad_pp_frwrd_fec_unique_polynomial_check(unit, fld_val, ARAD_PP_FRWRD_FEC_HASH_INDEX_LAG);
      SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 17, exit);
  }

  COMPILER_64_SET(fld64_val, 0, fld_val);  
  ARAD_FLD_TO_REG64(IHB_LAG_LB_KEY_CFGr, LAG_LB_HASH_INDEXf, fld64_val, reg_val, 16, exit);

  COMPILER_64_SET(fld64_val, 0, glbl_hash_info->key_shift);  
  ARAD_FLD_TO_REG64(IHB_LAG_LB_KEY_CFGr, LAG_LB_KEY_SHIFTf, fld64_val, reg_val, 18, exit);

  if(SOC_IS_JERICHO(unit)) {
      COMPILER_64_SET(fld64_val, 0, glbl_hash_info->eli_search);
      ARAD_FLD_TO_REG64(IHB_LAG_LB_KEY_CFGr, LB_MPLS_ELI_LABEL_SEARCHf, fld64_val, reg_val, 22, exit);
  }

  SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  20,  exit, ARAD_REG_ACCESS_ERR,WRITE_IHB_LAG_LB_KEY_CFGr(unit, SOC_CORE_ALL,  reg_val));

 
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_lag_hashing_global_info_set_unsafe()", 0, 0);
}

uint32
  arad_pp_lag_hashing_global_info_set_verify(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_IN  SOC_PPC_LAG_HASH_GLOBAL_INFO                *glbl_hash_info
  )
{
  uint32
    res = SOC_SAND_OK;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_LAG_HASHING_GLOBAL_INFO_SET_VERIFY);

  res = SOC_PPC_LAG_HASH_GLOBAL_INFO_verify(unit, glbl_hash_info);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_lag_hashing_global_info_set_verify()", 0, 0);
}

uint32
  arad_pp_lag_hashing_global_info_get_verify(
    SOC_SAND_IN  int                                 unit
  )
{
  uint32
    res = SOC_SAND_OK;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_LAG_HASHING_GLOBAL_INFO_GET_VERIFY);

  ARAD_PP_DO_NOTHING_AND_EXIT;
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_lag_hashing_global_info_get_verify()", 0, 0);
}


uint32
  arad_pp_lag_hashing_global_info_get_unsafe(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_OUT SOC_PPC_LAG_HASH_GLOBAL_INFO                *glbl_hash_info
  )
{
  uint64
    reg_val;
  uint64
    fld_val;
  uint32
    res = SOC_SAND_OK;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_LAG_HASHING_GLOBAL_INFO_GET_UNSAFE);
  SOC_SAND_CHECK_NULL_INPUT(glbl_hash_info);
  SOC_PPC_LAG_HASH_GLOBAL_INFO_clear(glbl_hash_info);

  

  SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  8,  exit, ARAD_REG_ACCESS_ERR,READ_IHB_LAG_LB_KEY_CFGr(unit, SOC_CORE_ALL, &reg_val));

  glbl_hash_info->seed = soc_reg64_field32_get(unit, IHB_LAG_LB_KEY_CFGr, reg_val, LAG_LB_KEY_SEEDf);

  ARAD_FLD_FROM_REG64(IHB_LAG_LB_KEY_CFGr, LAG_LB_KEY_USE_IN_PORTf, fld_val, reg_val, 14, exit);
  glbl_hash_info->use_port_id = SOC_SAND_NUM2BOOL(COMPILER_64_LO(fld_val));

  ARAD_FLD_FROM_REG64(IHB_LAG_LB_KEY_CFGr, LAG_LB_HASH_INDEXf, fld_val, reg_val, 16, exit);

  res = arad_pp_lag_hash_func_from_hw_val(unit,COMPILER_64_LO(fld_val), &glbl_hash_info->hash_func_id);
  SOC_SAND_CHECK_FUNC_RESULT(res, 17, exit);
   
  ARAD_FLD_FROM_REG64(IHB_LAG_LB_KEY_CFGr, LAG_LB_KEY_SHIFTf, fld_val, reg_val, 18, exit);
  glbl_hash_info->key_shift = (uint8)COMPILER_64_LO(fld_val);

  if(SOC_IS_JERICHO(unit)) {
      ARAD_FLD_FROM_REG64(IHB_LAG_LB_KEY_CFGr, LB_MPLS_ELI_LABEL_SEARCHf, fld_val, reg_val, 22, exit);
      glbl_hash_info->eli_search = (uint8)COMPILER_64_LO(fld_val);
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_lag_hashing_global_info_get_unsafe()", 0, 0);
}


uint32
  arad_pp_lag_hashing_port_info_set_unsafe(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_IN  int                                 core_id,
    SOC_SAND_IN  SOC_PPC_PORT                                port_ndx,
    SOC_SAND_IN  SOC_PPC_LAG_HASH_PORT_INFO                  *lag_hash_info
  )
{
  uint32
    res = SOC_SAND_OK;
  ARAD_PP_IHB_PINFO_FER_TBL_DATA
    pinfo_fer_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_LAG_HASHING_PORT_INFO_SET_UNSAFE);

  SOC_SAND_CHECK_NULL_INPUT(lag_hash_info);

  res = arad_pp_ihb_pinfo_fer_tbl_get_unsafe(
          unit,
          core_id,
          port_ndx,
          &pinfo_fer_tbl
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 10, exit);

  pinfo_fer_tbl.lag_lb_key_start   = (lag_hash_info->first_header_to_parse == SOC_PPC_LAG_HASH_FRST_HDR_FARWARDING)?0x1:0x0;
  pinfo_fer_tbl.lag_lb_key_count   = lag_hash_info->nof_headers;
  pinfo_fer_tbl.lb_bos_search      = SOC_SAND_BOOL2NUM(lag_hash_info->start_from_bos);
  
  pinfo_fer_tbl.lb_profile         = pinfo_fer_tbl.lb_bos_search;


  res = arad_pp_ihb_pinfo_fer_tbl_set_unsafe(
          unit,
          core_id,
          port_ndx,
          &pinfo_fer_tbl
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 12, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_lag_hashing_port_info_set_unsafe()", port_ndx, 0);
}

uint32
  arad_pp_lag_hashing_port_info_set_verify(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_IN  SOC_PPC_PORT                                port_ndx,
    SOC_SAND_IN  SOC_PPC_LAG_HASH_PORT_INFO                  *lag_hash_info
  )
{
  uint32
    res = SOC_SAND_OK;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_LAG_HASHING_PORT_INFO_SET_VERIFY);

  SOC_SAND_ERR_IF_ABOVE_MAX(port_ndx, ARAD_PP_PORT_MAX, SOC_PPC_PORT_OUT_OF_RANGE_ERR, 10, exit);
  ARAD_PP_STRUCT_VERIFY(SOC_PPC_LAG_HASH_PORT_INFO, lag_hash_info, 20, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_lag_hashing_port_info_set_verify()", port_ndx, 0);
}

uint32
  arad_pp_lag_hashing_port_info_get_verify(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_IN  SOC_PPC_PORT                                port_ndx
  )
{
  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_LAG_HASHING_PORT_INFO_GET_VERIFY);

  SOC_SAND_ERR_IF_ABOVE_MAX(port_ndx, ARAD_PP_PORT_MAX, SOC_PPC_PORT_OUT_OF_RANGE_ERR, 10, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_lag_hashing_port_info_get_verify()", port_ndx, 0);
}


uint32
  arad_pp_lag_hashing_port_info_get_unsafe(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_IN  int                                 core_id,
    SOC_SAND_IN  SOC_PPC_PORT                                port_ndx,
    SOC_SAND_OUT SOC_PPC_LAG_HASH_PORT_INFO                  *lag_hash_info
  )
{
  uint32
    res = SOC_SAND_OK;
  ARAD_PP_IHB_PINFO_FER_TBL_DATA
    pinfo_fer_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_LAG_HASHING_PORT_INFO_GET_UNSAFE);

  SOC_SAND_CHECK_NULL_INPUT(lag_hash_info);

  SOC_PPC_LAG_HASH_PORT_INFO_clear(lag_hash_info);

  res = arad_pp_ihb_pinfo_fer_tbl_get_unsafe(
          unit,
          core_id,
          port_ndx,
          &pinfo_fer_tbl
        );
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 10, exit);

  lag_hash_info->first_header_to_parse = (pinfo_fer_tbl.lag_lb_key_start == 0x1)?SOC_PPC_LAG_HASH_FRST_HDR_FARWARDING:SOC_PPC_LAG_HASH_FRST_HDR_LAST_TERMINATED;
  lag_hash_info->nof_headers = (uint8)pinfo_fer_tbl.lag_lb_key_count;
  lag_hash_info->start_from_bos = SOC_SAND_NUM2BOOL(pinfo_fer_tbl.lb_bos_search);
  
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_lag_hashing_port_info_get_unsafe()", port_ndx, 0);
}



int
  arad_pp_lag_hashing_port_lb_profile_set(
    SOC_SAND_IN  int                            unit,
    SOC_SAND_IN  int                            core,
    SOC_SAND_IN  uint32                         pp_port,
    SOC_SAND_IN  uint32                         lb_profile
  )
{
    ARAD_PP_IHB_PINFO_FER_TBL_DATA pinfo_fer_tbl;

    SOCDNX_INIT_FUNC_DEFS;

    SOCDNX_IF_ERR_EXIT(arad_pp_ihb_pinfo_fer_tbl_get_unsafe(
          unit,
          core,
          pp_port,
          &pinfo_fer_tbl
        ));

    pinfo_fer_tbl.lb_profile = lb_profile;

    SOCDNX_IF_ERR_EXIT(arad_pp_ihb_pinfo_fer_tbl_set_unsafe(
          unit,
          core,
          pp_port,
          &pinfo_fer_tbl
        ));

exit:
    SOCDNX_FUNC_RETURN;
}

uint32
arad_pp_lag_hashing_ecmp_hash_slb_combine_set(
   int            unit,
   int            combine_slb
)
{
uint32
    rv, reg_val, fld_val;

    SOCDNX_INIT_FUNC_DEFS;

    reg_val = fld_val = 0;

    if (!SOC_SUPPORTS_ECMP_HASH_COMBINE(unit)) {
        SOCDNX_EXIT_WITH_ERR(SOC_E_UNAVAIL, (_BSL_SOCDNX_MSG("Combination of SLB and configured LB keys isn't supported on this device.")));
    }
    if (SOC_IS_JERICHO_PLUS_ONLY(unit) || SOC_IS_QUX_A0(unit))
    {
        
        rv = soc_reg32_get(unit,IHB_FER_GENERAL_CONFIGURATIONSr,REG_PORT_ANY,0,&reg_val);
        SOCDNX_IF_ERR_EXIT(rv);

        soc_reg_field_set(unit,IHB_FER_GENERAL_CONFIGURATIONSr,&reg_val, HIER_ECMP_TAKE_SEED_FROM_HASHf, combine_slb);

        
        rv = soc_reg32_set(unit,IHB_FER_GENERAL_CONFIGURATIONSr,REG_PORT_ANY,0,reg_val);
        SOCDNX_IF_ERR_EXIT(rv);
    }
    else
    {
        rv = soc_reg32_get(unit, IHB_RESERVED_SPARE_0r, REG_PORT_ANY, 0, &reg_val);
        SOCDNX_IF_ERR_EXIT(rv);

        fld_val = soc_reg_field_get(unit, IHB_RESERVED_SPARE_0r, reg_val, RESERVED_SPARE_0f);

        if (combine_slb) {
            fld_val |= 0x02;
        } else {
            fld_val &= 0xFFFFFFFD;
        }

        rv = soc_reg_above_64_field32_modify(unit, IHB_RESERVED_SPARE_0r, REG_PORT_ANY, 0, RESERVED_SPARE_0f, fld_val);
        SOCDNX_IF_ERR_EXIT(rv);
    }

exit:
    SOCDNX_FUNC_RETURN;
}

uint32
arad_pp_lag_hashing_ecmp_hash_slb_combine_get(
   int            unit,
   int            *combine_slb
)
{
uint32
    rv, reg_val, fld_val;

    SOCDNX_INIT_FUNC_DEFS;
    SOCDNX_NULL_CHECK(combine_slb);

    reg_val = fld_val = 0;

    if (!SOC_SUPPORTS_ECMP_HASH_COMBINE(unit)) {
        SOCDNX_EXIT_WITH_ERR(SOC_E_UNAVAIL, (_BSL_SOCDNX_MSG("Combination of SLB and configured LB keys isn't supported on this device.")));
    }
    if (SOC_IS_JERICHO_PLUS_ONLY(unit) || SOC_IS_QUX_A0(unit))
    {
        rv = soc_reg32_get(unit,IHB_FER_GENERAL_CONFIGURATIONSr,REG_PORT_ANY,0,&reg_val);
        SOCDNX_IF_ERR_EXIT(rv);

        fld_val = soc_reg_field_get(unit,IHB_FER_GENERAL_CONFIGURATIONSr, reg_val, HIER_ECMP_TAKE_SEED_FROM_HASHf);
        *combine_slb = (int)fld_val;
    }
    else
    {
        rv = soc_reg32_get(unit, IHB_RESERVED_SPARE_0r, REG_PORT_ANY, 0, &reg_val);
        SOCDNX_IF_ERR_EXIT(rv);

        fld_val = soc_reg_field_get(unit, IHB_RESERVED_SPARE_0r, reg_val, RESERVED_SPARE_0f);

        *combine_slb = (fld_val & 0x02) ? 1 : 0;
    }

exit:
    SOCDNX_FUNC_RETURN;
}


STATIC SOC_PPC_HASH_MASKS
  arad_pp_lag_hash_sym_peer(
    SOC_SAND_IN  SOC_PPC_HASH_MASKS            field
  )
{
    switch (field)
    {
  
    case SOC_PPC_HASH_MASKS_MAC_DA:
    return SOC_PPC_HASH_MASKS_MAC_SA;
    case SOC_PPC_HASH_MASKS_IPV6_SIP:
    return SOC_PPC_HASH_MASKS_IPV6_DIP;
  case SOC_PPC_HASH_MASKS_FC_ORG_EX_ID:
        return SOC_PPC_HASH_MASKS_FC_RES_EX_ID;
  
    case SOC_PPC_HASH_MASKS_IPV4_SIP:
    return SOC_PPC_HASH_MASKS_IPV4_DIP;
    case SOC_PPC_HASH_MASKS_FC_DEST_ID:
        return SOC_PPC_HASH_MASKS_FC_SRC_ID;
  case SOC_PPC_HASH_MASKS_L4_SRC_PORT:
    return SOC_PPC_HASH_MASKS_L4_DEST_PORT;
  
    case SOC_PPC_HASH_MASKS_MAC_SA:
    return SOC_PPC_HASH_MASKS_MAC_DA;
    case SOC_PPC_HASH_MASKS_IPV6_DIP:
    return SOC_PPC_HASH_MASKS_IPV6_SIP;
  case SOC_PPC_HASH_MASKS_FC_RES_EX_ID:
        return SOC_PPC_HASH_MASKS_FC_ORG_EX_ID;
  
    case SOC_PPC_HASH_MASKS_IPV4_DIP:
    return SOC_PPC_HASH_MASKS_IPV4_SIP;
    case SOC_PPC_HASH_MASKS_FC_SRC_ID:
        return SOC_PPC_HASH_MASKS_FC_DEST_ID;
  case SOC_PPC_HASH_MASKS_L4_DEST_PORT:
    return SOC_PPC_HASH_MASKS_L4_SRC_PORT;
  
    case SOC_PPC_HASH_MASKS_ETH_TYPE_CODE:
    case SOC_PPC_HASH_MASKS_VSI:
    case SOC_PPC_HASH_MASKS_MPLS_LABEL_1:
    case SOC_PPC_HASH_MASKS_MPLS_LABEL_2:
    case SOC_PPC_HASH_MASKS_MPLS_LABEL_3:
    case SOC_PPC_HASH_MASKS_MPLS_LABEL_4:
    case SOC_PPC_HASH_MASKS_MPLS_LABEL_5:
    case SOC_PPC_HASH_MASKS_IPV4_PROTOCOL:
    case SOC_PPC_HASH_MASKS_FC_SEQ_ID:
    default:
        return field;
    }

}



STATIC uint32
  arad_pp_lag_calc_nible_val(
    SOC_SAND_IN  SOC_PPC_HASH_MASKS            field,
    SOC_SAND_IN  uint8                   enable,
    SOC_SAND_IN  uint8                   peer_enable, 
    SOC_SAND_IN  uint8                   is_symmetric
  )
{
    
  if (!enable)
    {
        return 0;
    }
  
    if (!is_symmetric)
    {
        return 1;
    }
  
  if (!peer_enable)
  {
    return 1; 
  }
    switch (field)
    {
  
    case SOC_PPC_HASH_MASKS_MAC_DA:
    case SOC_PPC_HASH_MASKS_IPV6_SIP:
    case SOC_PPC_HASH_MASKS_L4_SRC_PORT:
    case SOC_PPC_HASH_MASKS_FC_ORG_EX_ID:
        return 2;
  
    case SOC_PPC_HASH_MASKS_IPV4_SIP:
    case SOC_PPC_HASH_MASKS_FC_DEST_ID:
        return 3;
  
  case SOC_PPC_HASH_MASKS_MAC_SA:
  case SOC_PPC_HASH_MASKS_IPV4_DIP:
  case SOC_PPC_HASH_MASKS_IPV6_DIP:
  case SOC_PPC_HASH_MASKS_L4_DEST_PORT:
  case SOC_PPC_HASH_MASKS_FC_SRC_ID:
  case SOC_PPC_HASH_MASKS_FC_RES_EX_ID:
    return 0;
  
    case SOC_PPC_HASH_MASKS_ETH_TYPE_CODE:
    case SOC_PPC_HASH_MASKS_VSI:
    case SOC_PPC_HASH_MASKS_MPLS_LABEL_1:
    case SOC_PPC_HASH_MASKS_MPLS_LABEL_2:
    case SOC_PPC_HASH_MASKS_MPLS_LABEL_3:
    case SOC_PPC_HASH_MASKS_MPLS_LABEL_4:
    case SOC_PPC_HASH_MASKS_MPLS_LABEL_5:
    case SOC_PPC_HASH_MASKS_IPV4_PROTOCOL:
    case SOC_PPC_HASH_MASKS_FC_SEQ_ID:
    default:
        return 1;
    }

}


uint32
  arad_pp_lag_hashing_mask_set_unsafe(
    SOC_SAND_IN  int                     unit,
    SOC_SAND_IN  SOC_PPC_HASH_MASK_INFO  *mask_info
  )
{
  uint32
   mask_idx,
   map_index,
   vc_indx,
   fld_val,
   field_nbl_indx,
   field_nof_nbls,
   field_info_offset,
   is_equal,
   nible_val;
  ARAD_PP_IHB_LB_VECTOR_PROGRAM_MAP_TBL_DATA
    lb_vector_program_map_tbl_data,
    old_val;
  uint8
    is_symmetric = FALSE,
    skip;
  SOC_PPC_HASH_MASKS
    masks,
    fld,
    peer_fld;
  uint32
    chunk_bitmap[2] = {0};
  uint32
    res = SOC_SAND_OK;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_LAG_HASHING_MASK_SET_UNSAFE);

  SOC_SAND_CHECK_NULL_INPUT(mask_info);

  masks = mask_info->mask;

  is_symmetric = mask_info->is_symmetric_key;

  
  for (vc_indx = 0; vc_indx < sizeof(Arad_pp_lb_key_chunk_size) / sizeof(ARAD_PP_LB_HASH_CHUNK_SIZE); ++vc_indx)
  {
    map_index = arad_pp_lag_lb_vector_index_map(unit, Arad_pp_lb_key_chunk_size[vc_indx].key_index);

    
    res = arad_pp_ihb_lb_vector_program_map_tbl_get_unsafe(
            unit,
            map_index,
            &lb_vector_program_map_tbl_data
          );
    SOC_SAND_CHECK_FUNC_RESULT(res, 19, exit);

    ARAD_COPY(&old_val,&lb_vector_program_map_tbl_data,ARAD_PP_IHB_LB_VECTOR_PROGRAM_MAP_TBL_DATA,1);

    chunk_bitmap[0] = 0;
    chunk_bitmap[1] = 0;

    lb_vector_program_map_tbl_data.chunk_size = Arad_pp_lb_key_chunk_size[vc_indx].chunk_size;

    
    for (mask_idx = 0; mask_idx < SOC_PPC_NOF_HASH_MASKS; ++mask_idx)
    {
      skip = TRUE;
      field_info_offset = mask_idx;

      if(arad_pp_lag_lb_vector_index_map(unit, Arad_pp_lag_hash_field_info[field_info_offset].key_index) == map_index)
      {
        skip = FALSE;
      }
      if ((SOC_SAND_BIT(mask_idx) == SOC_PPC_HASH_MASKS_MPLS_LABEL_1) && (ARAD_PP_LB_MPLS_LBL1_VLD(map_index)))
      {
        skip = FALSE;
      }
      else if ((SOC_SAND_BIT(mask_idx) == SOC_PPC_HASH_MASKS_MPLS_LABEL_2) && (ARAD_PP_LB_MPLS_LBL2_VLD(map_index)))
      {
        skip = FALSE;
      }
      else if ((SOC_SAND_BIT(mask_idx) == SOC_PPC_HASH_MASKS_MPLS_LABEL_3) && (ARAD_PP_LB_MPLS_LBL3_VLD(map_index)))
      {
        skip = FALSE;
      }
      else if ((SOC_SAND_BIT(mask_idx) == SOC_PPC_HASH_MASKS_MPLS_LABEL_4) && (ARAD_PP_LB_MPLS_LBL4_VLD(map_index))) {
        skip = FALSE;
      }
      else if ((SOC_SAND_BIT(mask_idx) == SOC_PPC_HASH_MASKS_MPLS_LABEL_5) && (ARAD_PP_LB_MPLS_LBL5_VLD(map_index))) {
        skip = FALSE;
      }
      if (skip)
      {
        continue;
      }

      fld = SOC_SAND_BIT(mask_idx);
      peer_fld = arad_pp_lag_hash_sym_peer(fld);
      
      nible_val = arad_pp_lag_calc_nible_val(fld, (uint8)((masks & fld)== 0), (uint8)((masks & peer_fld)== 0), is_symmetric);
      field_nof_nbls = Arad_pp_lag_hash_field_info[field_info_offset].nof_nibles;

      for (field_nbl_indx = 0 ; field_nbl_indx < field_nof_nbls; ++field_nbl_indx)
      {
          res = soc_sand_bitstream_set_any_field(
                  &nible_val,
                     ARAD_PP_LB_FIELD_TO_NIBLE(Arad_pp_lag_hash_field_info[field_info_offset].nbls[field_nbl_indx],lb_vector_program_map_tbl_data.chunk_size),
                    2,
                    chunk_bitmap
                );
          SOC_SAND_CHECK_FUNC_RESULT(res, 19, exit);
      }
    }

    COMPILER_64_SET(lb_vector_program_map_tbl_data.chunk_bitmap, chunk_bitmap[1], chunk_bitmap[0]);
    ARAD_COMP(&old_val,&lb_vector_program_map_tbl_data,ARAD_PP_IHB_LB_VECTOR_PROGRAM_MAP_TBL_DATA,1,is_equal);

    if (!is_equal)
    {
      res = arad_pp_ihb_lb_vector_program_map_tbl_set_unsafe(
                unit,
                map_index,
                &lb_vector_program_map_tbl_data
            );
      SOC_SAND_CHECK_FUNC_RESULT(res, 19, exit);
    }
  }
 
  fld_val = SOC_SAND_BOOL2NUM(mask_info->expect_cw);
  SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  112,  exit, ARAD_REG_ACCESS_ERR,soc_reg_above_64_field32_modify(unit, IHB_LAG_LB_KEY_CFGr, SOC_CORE_ALL, 0, LB_MPLS_CONTROL_WORDf,  fld_val));

  
  res = sw_state_access[unit].dpp.soc.arad.pp.lag.masks.set(unit, masks);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 120, exit);
  res = sw_state_access[unit].dpp.soc.arad.pp.lag.lb_key_is_symtrc.set(unit, is_symmetric);
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 130, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_lag_hashing_mask_set_unsafe()", 0, 0);
}

uint32
  arad_pp_lag_hashing_mask_set_verify(
    SOC_SAND_IN  int                  unit,
    SOC_SAND_IN  SOC_PPC_HASH_MASK_INFO       *mask_info
  )
{
  uint32
    res = SOC_SAND_OK;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_LAG_HASHING_MASK_SET_VERIFY);

  ARAD_PP_STRUCT_VERIFY(SOC_PPC_HASH_MASK_INFO, mask_info, 10, exit);

  SOC_SAND_TODO_IMPLEMENT_WARNING;
  ARAD_PP_DO_NOTHING_AND_EXIT;
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_lag_hashing_mask_set_verify()", 0, 0);
}

uint32
  arad_pp_lag_hashing_mask_get_verify(
    SOC_SAND_IN  int                                 unit
  )
{
  uint32
    res = SOC_SAND_OK;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_LAG_HASHING_MASK_GET_VERIFY);

  SOC_SAND_TODO_IMPLEMENT_WARNING;
  ARAD_PP_DO_NOTHING_AND_EXIT;
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_lag_hashing_mask_get_verify()", 0, 0);
}


uint32
  arad_pp_lag_hashing_mask_get_unsafe(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_OUT SOC_PPC_HASH_MASK_INFO       *mask_info
  )
{
  uint32
    res,
    fld_val;

  SOC_SAND_INIT_ERROR_DEFINITIONS(ARAD_PP_LAG_HASHING_MASK_GET_UNSAFE);

  SOC_SAND_CHECK_NULL_INPUT(mask_info);

  SOC_PPC_HASH_MASK_INFO_clear(mask_info);
  
  res = sw_state_access[unit].dpp.soc.arad.pp.lag.masks.get(unit, &(mask_info->mask));
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 10, exit);

  res = sw_state_access[unit].dpp.soc.arad.pp.lag.lb_key_is_symtrc.get(unit, &(mask_info->is_symmetric_key));
  SOC_SAND_SOC_CHECK_FUNC_RESULT(res, 20, exit);

 
  SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  112,  exit, ARAD_REG_ACCESS_ERR,soc_reg_above_64_field32_read(unit, IHB_LAG_LB_KEY_CFGr, SOC_CORE_ALL, 0, LB_MPLS_CONTROL_WORDf, &fld_val));
  mask_info->expect_cw = SOC_SAND_NUM2BOOL(fld_val);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_lag_hashing_mask_get_unsafe()", 0, 0);
}

uint32
  arad_pp_lag_lb_key_range_set_unsafe(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_IN  SOC_PPC_LAG_INFO                            *lag_info
  )
{
  uint32
    res = SOC_SAND_OK;
  SOC_PPC_LAG_INFO
    tm_lag_info;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  SOC_SAND_CHECK_NULL_INPUT(lag_info);

  
  
  
  arad_pp_lag_members_ppd2tm(lag_info, &tm_lag_info);

  res = arad_ports_lag_lb_key_range_set_unsafe(
          unit,
          &tm_lag_info
        );
  SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_lag_lb_key_range_set_unsafe()", 0, 0);
}


CONST SOC_PROCEDURE_DESC_ELEMENT*
  arad_pp_lag_get_procs_ptr(void)
{
  return Arad_pp_procedure_desc_element_lag;
}

CONST SOC_ERROR_DESC_ELEMENT*
  arad_pp_lag_get_errs_ptr(void)
{
  return Arad_pp_error_desc_element_lag;
}

uint32
  SOC_PPC_LAG_HASH_GLOBAL_INFO_verify(
    SOC_SAND_IN  int                        unit,
    SOC_SAND_IN  SOC_PPC_LAG_HASH_GLOBAL_INFO *info
  )
{
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);
  SOC_SAND_CHECK_NULL_INPUT(info);

   SOC_SAND_ERR_IF_OUT_OF_RANGE(info->hash_func_id, ARAD_PP_LAG_HASH_FUNC_ID_MIN, ARAD_PP_LAG_HASH_FUNC_ID_MAX, ARAD_PP_LAG_HASH_FUNC_ID_OUT_OF_RANGE_ERR, 14, exit);
   SOC_SAND_ERR_IF_ABOVE_MAX(info->key_shift, ARAD_PP_LAG_KEY_SHIFT_MAX, ARAD_PP_LAG_KEY_SHIFT_OUT_OF_RANGE_ERR, 15, exit);
   SOC_SAND_ERR_IF_ABOVE_MAX(info->seed, ARAD_PP_LAG_SEED_MAX, ARAD_PP_LAG_SEED_OUT_OF_RANGE_ERR, 16, exit);

  SOC_SAND_MAGIC_NUM_VERIFY(info);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in SOC_PPC_LAG_HASH_GLOBAL_INFO_verify()",0,0);
}

uint32
  SOC_PPC_LAG_HASH_PORT_INFO_verify(
    SOC_SAND_IN  SOC_PPC_LAG_HASH_PORT_INFO *info
  )
{
  SOC_SAND_INIT_ERROR_DEFINITIONS_NO_DEVID(0);
  SOC_SAND_CHECK_NULL_INPUT(info);

  
  SOC_SAND_ERR_IF_ABOVE_MAX(info->first_header_to_parse, ARAD_PP_LAG_FIRST_HEADER_TO_PARSE_MAX, ARAD_PP_LAG_FIRST_HEADER_TO_PARSE_OUT_OF_RANGE_ERR, 11, exit);

  SOC_SAND_MAGIC_NUM_VERIFY(info);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in SOC_PPC_LAG_HASH_PORT_INFO_verify()",0,0);
}

uint32
  SOC_PPC_HASH_MASK_INFO_verify(
    SOC_SAND_IN  SOC_PPC_HASH_MASK_INFO *info
  )
{
  uint32
    invalid_mask;
  SOC_SAND_INIT_ERROR_DEFINITIONS_NO_DEVID(0);
  SOC_SAND_CHECK_NULL_INPUT(info);

  invalid_mask = SOC_SAND_BITS_MASK(31,SOC_PPC_NOF_HASH_MASKS+1);
  
  if ((invalid_mask & info->mask) != 0)
  {
    SOC_SAND_SET_ERROR_CODE(ARAD_PP_LAG_MASK_OUT_OF_RANGE_ERR, 12, exit);
  }

  SOC_SAND_MAGIC_NUM_VERIFY(info);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in SOC_PPC_HASH_MASK_INFO_verify()",info->mask,0);
}

uint32
  SOC_PPC_LAG_MEMBER_verify(
    SOC_SAND_IN  SOC_PPC_LAG_MEMBER *info
  )
{
  SOC_SAND_INIT_ERROR_DEFINITIONS_NO_DEVID(0);
  SOC_SAND_CHECK_NULL_INPUT(info);

  SOC_SAND_ERR_IF_ABOVE_MAX(info->sys_port, ARAD_PP_LAG_SYS_PORT_MAX, ARAD_PP_LAG_SYS_PORT_OUT_OF_RANGE_ERR, 10, exit);
  SOC_SAND_ERR_IF_ABOVE_MAX(info->member_id, SOC_PPC_LAG_MEMBER_ID_MAX, SOC_PPC_LAG_MEMBER_ID_OUT_OF_RANGE_ERR, 11, exit);

  SOC_SAND_MAGIC_NUM_VERIFY(info);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in SOC_PPC_LAG_MEMBER_verify()",0,0);
}

uint32
  SOC_PPC_LAG_INFO_verify(
    SOC_SAND_IN  int unit,
    SOC_SAND_IN  SOC_PPC_LAG_INFO *info
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    ind;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);
  SOC_SAND_CHECK_NULL_INPUT(info);

  SOC_SAND_ERR_IF_ABOVE_MAX(info->nof_entries, ARAD_PP_LAG_NOF_ENTRIES_MAX(unit), ARAD_PP_LAG_NOF_ENTRIES_OUT_OF_RANGE_ERR, 10, exit);
  for (ind = 0; ind < SOC_PPC_LAG_MEMBERS_MAX; ++ind)
  {
    ARAD_PP_STRUCT_VERIFY(SOC_PPC_LAG_MEMBER, &(info->members[ind]), 11, exit);
  }
  SOC_SAND_ERR_IF_ABOVE_MAX(info->lb_type, SOC_PPC_LAG_LB_TYPE_MAX, SOC_PPC_LAG_LB_TYPE_OUT_OF_RANGE_ERR, 12, exit);

  SOC_SAND_MAGIC_NUM_VERIFY(info);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in SOC_PPC_LAG_INFO_verify()", info->nof_entries, 0);
}


uint32
ARAD_PP_LAG_is_ecmp_valid(
        int     unit,
        int     core_id,
        ARAD_PP_LB_PRINT_HIERARCHY_ECMP_SIGNALS* signals
        )
{
    uint32 ecmp_entry;

    SOCDNX_INIT_FUNC_DEFS;

    signals->ecmp_is_valid = FALSE;

    if(signals->ecmp_fec <= ARAD_PP_LAG_MAX_ECMP_ENTRY(unit)) {

        SOCDNX_IF_ERR_EXIT(soc_mem_read(unit, IHB_FEC_ECMPm, IHB_BLOCK(unit, core_id), signals->ecmp_fec, &ecmp_entry));
        signals->start_pointer   = soc_mem_field32_get(unit, IHB_FEC_ECMPm, &ecmp_entry, GROUP_START_POINTERf);
        signals->group_size      = soc_mem_field32_get(unit, IHB_FEC_ECMPm, &ecmp_entry, GROUP_SIZEf);
        signals->is_protected    = soc_mem_field32_get(unit, IHB_FEC_ECMPm, &ecmp_entry, PROTECTEDf);

        SOCDNX_SAND_IF_ERR_EXIT(dpp_dsig_read(unit, core_id, "IRPP", "FER", "LBP", "FEC_ECMP_Ptr", &signals->ecmp_fec_pointer, 1));

        if( signals->group_size > 0 &&
            signals->ecmp_fec_pointer > ARAD_PP_LAG_MAX_ECMP_ENTRY(unit) &&
            signals->start_pointer > ARAD_PP_LAG_MAX_ECMP_ENTRY(unit)) {
            signals->ecmp_is_valid = TRUE;
        }
    }
exit:
    SOCDNX_FUNC_RETURN;
}

soc_error_t
  soc_jer_pp_lag_get_configured_lb_signals(
          int                       unit,
          int                       core_id,
          ARAD_PP_LB_PRINT_SIGNALS* signals
          )
{
    uint32 pinfo_fer = 0, pfc_profile=0, pp_port_info = 0;
    uint64 reg_val, fld_val;
    int lb_vector_index;
    uint32 core_index = (core_id <= 0) ? 0 : core_id;
    SOCDNX_INIT_FUNC_DEFS;

    SOCDNX_SAND_IF_ERR_EXIT(dpp_dsig_read(unit, core_id, "IRPP", "TT", "FLP", "Parser_Leaf_Context", &signals->core[core_index].configured.plc, 1));
    SOCDNX_SAND_IF_ERR_EXIT(dpp_dsig_read(unit, core_id, "IRPP", "LL", "VT",  "Packet_Format_Code", &signals->core[core_index].configured.pfc_stage1, 1));
    SOCDNX_SAND_IF_ERR_EXIT(dpp_dsig_read(unit, core_id, "IRPP", "TT", "FLP", "Packet_Format_Code", &signals->core[core_index].configured.pfc_stage2, 1));
    SOCDNX_SAND_IF_ERR_EXIT(dpp_dsig_read(unit, core_id, "IRPP", "TT", "FLP", "Fwd_Offset_Index", &signals->core[core_index].configured.fwrd_index, 1));

    SOCDNX_IF_ERR_EXIT(soc_mem_read(unit, IHB_PINFO_FERm, IHB_BLOCK(unit, core_id), signals->core[core_index].in_port, &pinfo_fer));
    signals->core[core_index].configured.port_profile        = soc_mem_field32_get(unit, IHB_PINFO_FERm, &pinfo_fer, LB_PROFILEf);
    signals->core[core_index].configured.bos_search          = soc_mem_field32_get(unit, IHB_PINFO_FERm, &pinfo_fer, LB_BOS_SEARCHf);
    signals->core[core_index].configured.bos_include         = soc_mem_field32_get(unit, IHB_PINFO_FERm, &pinfo_fer, LB_INCLUDE_BOS_HDRf);

    SOCDNX_SAND_IF_ERR_EXIT(READ_IHB_LB_KEY_PARSER_LEAF_CONTEXT_PROFILEr(unit,core_id,&signals->core[core_index].configured.plc_profile));
    SOCDNX_SAND_IF_ERR_EXIT(soc_sand_bitstream_get_any_field(&signals->core[core_index].configured.plc_profile, signals->core[core_index].configured.plc, 1, &signals->core[core_index].configured.plc_bit));
    signals->core[core_index].configured.pfc_profile_index = 0xFF & ARAD_PP_LB_PFC_OFFSET_SET(signals->core[core_index].configured.port_profile,signals->core[core_index].configured.plc_bit,signals->core[core_index].configured.pfc_stage2);

    SOCDNX_SAND_IF_ERR_EXIT(READ_IHB_LB_PFC_PROFILEm(unit, MEM_BLOCK_ANY, signals->core[core_index].configured.pfc_profile_index, &pfc_profile));
    for (lb_vector_index = 0; lb_vector_index < ARAD_PP_LB_VECTOR_NOF;lb_vector_index++) {
        SOCDNX_SAND_IF_ERR_EXIT(soc_sand_bitstream_get_any_field(&pfc_profile, lb_vector_index*5, 5, &signals->core[core_index].configured.LB_vectors[lb_vector_index]));
    }

    SOCDNX_IF_ERR_EXIT(soc_mem_read(unit, IHP_PP_PORT_INFOm, IHP_BLOCK(unit, core_id), signals->core[core_index].in_port, &pp_port_info));
    signals->core[core_index].is_specualte = soc_mem_field32_get(unit, IHP_PP_PORT_INFOm, &pp_port_info, MPLS_NEXT_ADDRESS_USE_SPECUALTEf);

    SOCDNX_SAND_IF_ERR_EXIT(READ_IHB_LAG_LB_KEY_CFGr(unit, SOC_CORE_ALL, &reg_val));

    if (signals->diag_type == ARAD_PP_DIAG_LAG) {

        signals->core[core_index].configured.lag.header_count    = soc_mem_field32_get(unit, IHB_PINFO_FERm, &pinfo_fer, LAG_LB_KEY_COUNTf);
        signals->core[core_index].configured.lag.starting_header = soc_mem_field32_get(unit, IHB_PINFO_FERm, &pinfo_fer, LAG_LB_KEY_STARTf);

        signals->core[core_index].configured.lag.seed = soc_reg64_field32_get(unit, IHB_LAG_LB_KEY_CFGr, reg_val, LAG_LB_KEY_SEEDf);
        ARAD_FLD_FROM_REG64(IHB_LAG_LB_KEY_CFGr, LAG_LB_KEY_USE_IN_PORTf, fld_val, reg_val, 14, exit);
        signals->core[core_index].configured.lag.use_port_id = SOC_SAND_NUM2BOOL(COMPILER_64_LO(fld_val));
        ARAD_FLD_FROM_REG64(IHB_LAG_LB_KEY_CFGr, LAG_LB_HASH_INDEXf, fld_val, reg_val, 16, exit);
        signals->core[core_index].configured.lag.polynomial = COMPILER_64_LO(fld_val);
        ARAD_FLD_FROM_REG64(IHB_LAG_LB_KEY_CFGr, LAG_LB_KEY_SHIFTf, fld_val, reg_val, 18, exit);
        signals->core[core_index].configured.lag.key_shift = COMPILER_64_LO(fld_val);
    }

    ARAD_FLD_FROM_REG64(IHB_LAG_LB_KEY_CFGr, LB_MPLS_ELI_LABEL_SEARCHf, fld_val, reg_val, 22, exit);
    signals->core[core_index].configured.eli_search = COMPILER_64_LO(fld_val);

    if (signals->diag_type == ARAD_PP_DIAG_ECMP) {

        signals->core[core_index].configured.ecmp.header_count   = soc_mem_field32_get(unit, IHB_PINFO_FERm, &pinfo_fer, ECMP_LB_KEY_COUNTf);

        SOCDNX_SAND_IF_ERR_EXIT(READ_IHB_ECMP_LB_KEY_CFGr(unit, SOC_CORE_ALL, &reg_val));

        ARAD_FLD_FROM_REG64(IHB_ECMP_LB_KEY_CFGr, ECMP_LB_HASH_INDEXf, fld_val, reg_val, 14, exit);
        signals->core[core_index].configured.ecmp.polynomial = COMPILER_64_LO(fld_val);
        ARAD_FLD_FROM_REG64(IHB_ECMP_LB_KEY_CFGr, ECMP_LB_KEY_SHIFTf, fld_val, reg_val, 14, exit);
        signals->core[core_index].configured.ecmp.key_shift = COMPILER_64_LO(fld_val);
        ARAD_FLD_FROM_REG64(IHB_ECMP_LB_KEY_CFGr, ECMP_LB_KEY_SEEDf, fld_val, reg_val, 14, exit);
        signals->core[core_index].configured.ecmp.seed = COMPILER_64_LO(fld_val);
        ARAD_FLD_FROM_REG64(IHB_ECMP_LB_KEY_CFGr, ECMP_LB_KEY_USE_IN_PORTf, fld_val, reg_val, 14, exit);
        signals->core[core_index].configured.ecmp.use_port_id = SOC_SAND_NUM2BOOL(COMPILER_64_LO(fld_val));

        if (SOC_IS_JERICHO_PLUS_A0(unit) || SOC_IS_QUX(unit)) {
            ARAD_FLD_FROM_REG64(IHB_ECMP_LB_KEY_CFGr, ECMP_2ND_HIER_LB_HASH_INDEXf, fld_val, reg_val, 14, exit);
            signals->core[core_index].configured.ecmp_2nd.polynomial = COMPILER_64_LO(fld_val);
            ARAD_FLD_FROM_REG64(IHB_ECMP_LB_KEY_CFGr, ECMP_2ND_HIER_LB_KEY_SHIFTf, fld_val, reg_val, 14, exit);
            signals->core[core_index].configured.ecmp_2nd.key_shift = COMPILER_64_LO(fld_val);
        }
    }
exit:
    SOCDNX_FUNC_RETURN;
}



soc_error_t
soc_jer_pp_lag_get_load_balancing_diagnostic_signal(
  SOC_SAND_IN     int                       unit,
  SOC_SAND_INOUT  ARAD_PP_LB_PRINT_SIGNALS* signals
  )
{
    int   res , combine = 0;
    uint32 fwrd_action, size, core_id;
    uint64 reg_val, fld_val;
    bcm_l3_egress_t egr;

    SOCDNX_INIT_FUNC_DEFS;

    if(SOC_IS_JERICHO_B0(unit) || SOC_IS_QMX_B0(unit) || SOC_IS_QAX_B0(unit)) {
        SOCDNX_SAND_IF_ERR_EXIT(arad_pp_lag_hashing_ecmp_hash_slb_combine_get(unit, &combine));
    }

    signals->is_combine_flb_clb = combine;


    for(core_id = signals->first_core; core_id <= signals->last_core ; core_id++)
    {

        sal_memset(&(signals->core[core_id]), 0x0, sizeof(ARAD_PP_LB_PRINT_SIGNALS_PER_CORE));

        SOCDNX_SAND_IF_ERR_EXIT(dpp_dsig_read(unit, core_id, "IRPP", "FER", "LBP", "In_PP_Port", &signals->core[core_id].in_port, 1));

        if (signals->diag_type == ARAD_PP_DIAG_ECMP) {

            signals->core[core_id].hier_sig[ARAD_PP_HIERARCHY_2].ecmp_is_valid = FALSE;

            SOCDNX_SAND_IF_ERR_EXIT(dpp_dsig_read(unit, core_id, "IRPP", "FLP", "PMF", "Fwd_Action_Dst", &fwrd_action, 1));

            signals->core[core_id].hier_sig[ARAD_PP_HIERARCHY_1].ecmp_fec = ARAD_PP_FRWR_ACTION_TO_FEC(fwrd_action);

            SOCDNX_SAND_IF_ERR_EXIT(ARAD_PP_LAG_is_ecmp_valid(unit, core_id, &signals->core[core_id].hier_sig[ARAD_PP_HIERARCHY_1]));

            if(signals->core[core_id].hier_sig[ARAD_PP_HIERARCHY_1].ecmp_is_valid ) {


                SOCDNX_SAND_IF_ERR_EXIT(dpp_dsig_read(unit, core_id, "IRPP", "FER", "LBP", "FEC_ECMP_Ptr_is_Stateful", &signals->core[core_id].is_stateful, 1));

                signals->core[core_id].hier_sig[ARAD_PP_HIERARCHY_1].offset = signals->core[core_id].hier_sig[ARAD_PP_HIERARCHY_1].ecmp_fec_pointer - signals->core[core_id].hier_sig[ARAD_PP_HIERARCHY_1].start_pointer;

                bcm_l3_egress_t_init(&egr);

                res = bcm_petra_l3_egress_get(unit,signals->core[core_id].hier_sig[ARAD_PP_HIERARCHY_1].ecmp_fec_pointer,&egr);

                _SHR_GPORT_FORWARD_GROUP_TO_L3_ITF_FEC(signals->core[core_id].hier_sig[ARAD_PP_HIERARCHY_2].ecmp_fec, egr.port);

                
                if(res == BCM_E_NONE && _SHR_GPORT_IS_FORWARD_PORT(egr.port) && BCM_L3_ITF_TYPE_IS_FEC(signals->core[core_id].hier_sig[ARAD_PP_HIERARCHY_2].ecmp_fec))
                {
                    signals->core[core_id].hier_sig[ARAD_PP_HIERARCHY_2].ecmp_fec = _SHR_L3_ITF_VAL_GET(signals->core[core_id].hier_sig[ARAD_PP_HIERARCHY_2].ecmp_fec);

                    SOCDNX_SAND_IF_ERR_EXIT(ARAD_PP_LAG_is_ecmp_valid(unit, core_id, &signals->core[core_id].hier_sig[ARAD_PP_HIERARCHY_2]));

                    if(signals->core[core_id].hier_sig[ARAD_PP_HIERARCHY_2].ecmp_is_valid) {

                        SOCDNX_SAND_IF_ERR_EXIT(dpp_dsig_read(unit, core_id, "IRPP", "FER", "LBP", "ECMP_LB_Key", &signals->core[core_id].hier_sig[ARAD_PP_HIERARCHY_2].ecmp_lb_key, 1));

                        signals->core[core_id].hier_sig[ARAD_PP_HIERARCHY_2].offset = (signals->core[core_id].hier_sig[ARAD_PP_HIERARCHY_2].group_size * signals->core[core_id].hier_sig[ARAD_PP_HIERARCHY_2].ecmp_lb_key) >> 16;
                        signals->core[core_id].hier_sig[ARAD_PP_HIERARCHY_2].ecmp_fec_pointer = signals->core[core_id].hier_sig[ARAD_PP_HIERARCHY_2].start_pointer + (signals->core[core_id].hier_sig[ARAD_PP_HIERARCHY_2].is_protected + 1) * signals->core[core_id].hier_sig[ARAD_PP_HIERARCHY_2].offset;

                    }
                }

                if(signals->core[core_id].is_stateful) {

                    SOCDNX_SAND_IF_ERR_EXIT(dpp_dsig_read(unit, core_id, "IRPP", "PMF", "FER", "Consistent_Hashing_LEM_Key", signals->core[core_id].stateful.flow_label_dst, 3));
                    SOCDNX_SAND_IF_ERR_EXIT(READ_IHB_ECMP_LB_KEY_CFGr(unit, SOC_CORE_ALL, &reg_val));
                    ARAD_FLD_FROM_REG64(IHB_ECMP_LB_KEY_CFGr, ECMP_LB_KEY_CONSISTENT_HASHING_DATA_0_SHIFTf, fld_val, reg_val, 14, exit);
                    signals->core[core_id].stateful.key_0_shift = COMPILER_64_LO(fld_val);
                    ARAD_FLD_FROM_REG64(IHB_ECMP_LB_KEY_CFGr, ECMP_LB_KEY_CONSISTENT_HASHING_DATA_1_SHIFTf, fld_val, reg_val, 14, exit);
                    signals->core[core_id].stateful.key_1_shift = COMPILER_64_LO(fld_val);

                    SHR_BITCOPY_RANGE(signals->core[core_id].stateful.key_0_input, 0,signals->core[core_id].stateful.flow_label_dst, 0, signals->core[core_id].stateful.key_0_shift);

                    SHR_BITCOPY_RANGE(signals->core[core_id].stateful.key_0_input, 0,signals->core[core_id].stateful.flow_label_dst, 0, signals->core[core_id].stateful.key_0_shift);

                    size = ARAD_PP_FLEX_POST_HASH_KEYS_INPUT_SIZE - signals->core[core_id].stateful.key_1_shift;

                    SHR_BITCOPY_RANGE(signals->core[core_id].stateful.key_1_input, 0,signals->core[core_id].stateful.flow_label_dst, signals->core[core_id].stateful.key_1_shift, size);

                }

                SOCDNX_SAND_IF_ERR_EXIT(soc_jer_pp_lag_get_configured_lb_signals(unit, core_id,signals));
            }
        } else { 
            
            if (signals->core[core_id].in_port < SOC_DPP_DEFS_GET(unit, nof_pp_ports_per_core)) {
                SOCDNX_SAND_IF_ERR_EXIT(soc_jer_pp_lag_get_configured_lb_signals(unit, core_id,signals));
                signals->core[core_id].lag_valid = TRUE;
            } else {
                signals->core[core_id].lag_valid = FALSE;
            }
        }

    }

exit:
    SOCDNX_FUNC_RETURN;
}



#include <soc/dpp/SAND/Utils/sand_footer.h>


#endif 
