/*
 *         
 * 
 * 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 *         
 *     
 * DO NOT EDIT THIS FILE!
 */

#ifndef _PORTMOD_H__H_
#define _PORTMOD_H__H_

#include <phymod/phymod.h>
#include <phymod/phymod_diagnostics.h>
#include <phymod/phymod_reg.h>
#include <soc/cprimod/cprimod.h>
#include <soc/portmod/portmod_defs.h>
#include <sal/core/sync.h>

/*!
 * @enum portmod_dispatch_type_e
 * @brief Supported Drivers 
 */ 
typedef enum portmod_dispatch_type_e {
#ifdef PORTMOD_PM4X25_SUPPORT
    portmodDispatchTypePm4x25,
#endif /*PORTMOD_PM4X25_SUPPORT  */
#ifdef PORTMOD_PM4X10_SUPPORT
    portmodDispatchTypePm4x10,
#endif /*PORTMOD_PM4X10_SUPPORT  */
#ifdef PORTMOD_PM4X10TD_SUPPORT
    portmodDispatchTypePm4x10td,
#endif /*PORTMOD_PM4X10TD_SUPPORT  */
#ifdef PORTMOD_PM12X10_SUPPORT
    portmodDispatchTypePm12x10,
#endif /*PORTMOD_PM12X10_SUPPORT  */
#ifdef PORTMOD_PM4x10Q_SUPPORT
    portmodDispatchTypePm4x10Q,
#endif /*PORTMOD_PM4x10Q_SUPPORT  */
#ifdef PORTMOD_PM_QTC_SUPPORT
    portmodDispatchTypePm_qtc,
#endif /*PORTMOD_PM_QTC_SUPPORT  */
#ifdef PORTMOD_PM_OS_ILKN_SUPPORT
    portmodDispatchTypePmOsILKN,
#endif /*PORTMOD_PM_OS_ILKN_SUPPORT  */
#ifdef PORTMOD_PM_OS_ILKN_50G_SUPPORT
    portmodDispatchTypePmOsILKN_50G,
#endif /*PORTMOD_PM_OS_ILKN_50G_SUPPORT  */
#ifdef PORTMOD_DNX_FABRIC_SUPPORT
    portmodDispatchTypeDnx_fabric,
#endif /*PORTMOD_DNX_FABRIC_SUPPORT  */
#ifdef PORTMOD_DNX_FABRIC_O_NIF_SUPPORT
    portmodDispatchTypeDnx_fabric_o_nif,
#endif /*PORTMOD_DNX_FABRIC_O_NIF_SUPPORT  */
#ifdef PORTMOD_PM8X50_FABRIC_SUPPORT
    portmodDispatchTypePm8x50_fabric,
#endif /*PORTMOD_PM8X50_FABRIC_SUPPORT  */
#ifdef PORTMOD_PM4X25TD_SUPPORT
    portmodDispatchTypePm4x25td,
#endif /*PORTMOD_PM4X25TD_SUPPORT  */
#ifdef PORTMOD_PM12X10_XGS_SUPPORT
    portmodDispatchTypePm12x10_xgs,
#endif /*PORTMOD_PM12X10_XGS_SUPPORT  */
#ifdef PORTMOD_PM4X2P5_SUPPORT
    portmodDispatchTypePm4x2p5,
#endif /*PORTMOD_PM4X2P5_SUPPORT  */
#ifdef PORTMOD_CPM4X25_SUPPORT
    portmodDispatchTypeCpm4x25,
#endif /*PORTMOD_CPM4X25_SUPPORT  */
#ifdef PORTMOD_PM8X50_SUPPORT
    portmodDispatchTypePm8x50,
#endif /*PORTMOD_PM8X50_SUPPORT  */
#ifdef PORTMOD_PM4X10_QTC_SUPPORT
    portmodDispatchTypePm4x10_qtc,
#endif /*PORTMOD_PM4X10_QTC_SUPPORT  */
#ifdef PORTMOD_PMNULL_SUPPORT
    portmodDispatchTypePmNull,
#endif /*PORTMOD_PMNULL_SUPPORT  */
    portmodDispatchTypeCount
} portmod_dispatch_type_t;

#ifdef PORTMOD_DIAG
extern enum_mapping_t portmod_dispatch_type_t_mapping[];
#endif /*PORTMOD_DIAG*/

/* portmod_dispatch_type_t validation */
int portmod_dispatch_type_t_validate(int unit, portmod_dispatch_type_t portmod_dispatch_type);
/*! 
 * @brief Flags for user access struct 
 */ 
#define PORTMOD_USER_ACCESS_FW_LOAD_REVERSE 0x1 /**< Load FW in reverse mode */
#define PORTMOD_USER_ACCESS_REG_VAL_OFFSET_ZERO 0x2 /**< When reading register using UCMEM the data is in offset 0 */
#define PORTMOD_USER_ACCESS_FW_LOAD_BROADCAST 0x4 /**< Load FW in broadcast mode */

#define PORTMOD_USER_ACCESS_FW_LOAD_REVERSE_SET(user_data) ((user_data->flags) |= PORTMOD_USER_ACCESS_FW_LOAD_REVERSE)
#define PORTMOD_USER_ACCESS_REG_VAL_OFFSET_ZERO_SET(user_data) ((user_data->flags) |= PORTMOD_USER_ACCESS_REG_VAL_OFFSET_ZERO)
#define PORTMOD_USER_ACCESS_FW_LOAD_BROADCAST_SET(user_data) ((user_data->flags) |= PORTMOD_USER_ACCESS_FW_LOAD_BROADCAST)

#define PORTMOD_USER_ACCESS_FW_LOAD_REVERSE_CLR(user_data) ((user_data->flags) &= ~PORTMOD_USER_ACCESS_FW_LOAD_REVERSE)
#define PORTMOD_USER_ACCESS_REG_VAL_OFFSET_ZERO_CLR(user_data) ((user_data->flags) &= ~PORTMOD_USER_ACCESS_REG_VAL_OFFSET_ZERO)
#define PORTMOD_USER_ACCESS_FW_LOAD_BROADCAST_CLR(user_data) ((user_data->flags) &= ~PORTMOD_USER_ACCESS_FW_LOAD_BROADCAST)

#define PORTMOD_USER_ACCESS_FW_LOAD_REVERSE_GET(user_data) ((user_data->flags) & PORTMOD_USER_ACCESS_FW_LOAD_REVERSE ? 1 : 0)
#define PORTMOD_USER_ACCESS_REG_VAL_OFFSET_ZERO_GET(user_data) ((user_data->flags) & PORTMOD_USER_ACCESS_REG_VAL_OFFSET_ZERO ? 1 : 0)
#define PORTMOD_USER_ACCESS_FW_LOAD_BROADCAST_GET(user_data) ((user_data->flags) & PORTMOD_USER_ACCESS_FW_LOAD_BROADCAST ? 1 : 0)


/*!
 * @struct portmod_default_user_access_s
 * @brief Expected user access structure when using PM default bus 
 */ 
typedef struct portmod_default_user_access_s {
    int unit; /**< Unit that will be used for phy access */
    int blk_id; /**< block id */
    sal_mutex_t mutex; /**< Mutex operation for phy access */
    uint32 flags; /**< user access flags */
} portmod_default_user_access_t;

/* portmod_default_user_access_t initialization and validation */
int portmod_default_user_access_t_validate(int unit, const portmod_default_user_access_t* portmod_default_user_access);
int portmod_default_user_access_t_init(int unit, portmod_default_user_access_t* portmod_default_user_access);


/*!
 * @struct portmod_pm4x10q_user_data_s
 * @brief Expected qsgmii user access structure when using PMQ default bus 
 */ 
typedef struct portmod_pm4x10q_user_data_s {
    phymod_access_t pm4x10_access; /**< Unit that will be used for phy access */
    portmod_default_user_access_t qsgmiie_user_data; /**< qsgmii_access */
} portmod_pm4x10q_user_data_t;

/* portmod_pm4x10q_user_data_t initialization and validation */
int portmod_pm4x10q_user_data_t_validate(int unit, const portmod_pm4x10q_user_data_t* portmod_pm4x10q_user_data);
int portmod_pm4x10q_user_data_t_init(int unit, portmod_pm4x10q_user_data_t* portmod_pm4x10q_user_data);


/*!
 * @struct portmod_fifo_status_s
 * @brief In Fifo Time stamp and sequence id value. 
 */ 
typedef struct portmod_fifo_status_s {
    uint32 timestamps_in_fifo; /**< low 32bit of Timestamp in Fifo */
    uint32 timestamps_in_fifo_hi; /**< high 32 bit of timestamp in Fifo */
    uint32 sequence_id; /**< sequence id of sent ptp packet */
    uint32 timestamp_sub_nanosec; /**< sub-nanosecond of 1588 transmit packet */
} portmod_fifo_status_t;

/* portmod_fifo_status_t initialization and validation */
int portmod_fifo_status_t_validate(int unit, const portmod_fifo_status_t* portmod_fifo_status);
int portmod_fifo_status_t_init(int unit, portmod_fifo_status_t* portmod_fifo_status);


/*!
 * @struct portmod_pfc_config_s
 * @brief PFC Config Information. 
 */ 
typedef struct portmod_pfc_config_s {
    uint32 type; /**< PFC Ether Type */
    uint32 opcode; /**< PFC Message Opcode */
    uint32 classes; /**< PFC Classes */
    uint32 da_oui; /**< PFC OUI Msg OUI Dest Addr */
    uint32 da_nonoui; /**< PFC Non OUI Dest Addr */
    uint32 rxpass; /**< PFC rxpass */
} portmod_pfc_config_t;

/* portmod_pfc_config_t initialization and validation */
int portmod_pfc_config_t_validate(int unit, const portmod_pfc_config_t* portmod_pfc_config);
int portmod_pfc_config_t_init(int unit, portmod_pfc_config_t* portmod_pfc_config);


/*!
 * @struct portmod_eee_s
 * @brief EEE Timer Information. 
 */ 
typedef struct portmod_eee_s {
    uint32 enable; /**< EEE Enable */
    uint32 tx_idle_time; /**< EEE tx idle time */
    uint32 tx_wake_time; /**< EEE tx wake time */
} portmod_eee_t;

/* portmod_eee_t initialization and validation */
int portmod_eee_t_validate(int unit, const portmod_eee_t* portmod_eee);
int portmod_eee_t_init(int unit, portmod_eee_t* portmod_eee);


/*!
 * @struct portmod_eee_clock_s
 * @brief EEE clock gate Information. 
 */ 
typedef struct portmod_eee_clock_s {
    uint32 clock_gate; /**< EEE Clock Gate */
    uint32 clock_count; /**< EEE clock counter */
    uint32 timer_pulse; /**< EEE timer pulse */
} portmod_eee_clock_t;

/* portmod_eee_clock_t initialization and validation */
int portmod_eee_clock_t_validate(int unit, const portmod_eee_clock_t* portmod_eee_clock);
int portmod_eee_clock_t_init(int unit, portmod_eee_clock_t* portmod_eee_clock);


/*!
 * @struct portmod_vlan_tag_s
 * @brief Vlan Tag Inner/Outer Values. 
 */ 
typedef struct portmod_vlan_tag_s {
    int inner_vlan_tag; /**< Inner Vlan Tag */
    int outer_vlan_tag; /**< Outer Vlan Tag */
} portmod_vlan_tag_t;

/* portmod_vlan_tag_t initialization and validation */
int portmod_vlan_tag_t_validate(int unit, const portmod_vlan_tag_t* portmod_vlan_tag);
int portmod_vlan_tag_t_init(int unit, portmod_vlan_tag_t* portmod_vlan_tag);

#define PORTMOD_MAC_PASS_CONTROL_FRAME 0x1 /**< pass control frame to system side */
#define PORTMOD_MAC_PASS_PFC_FRAME 0x2 /**< pass pfc frame to system side */
#define PORTMOD_MAC_PASS_PAUSE_FRAME 0x4 /**< pass pause frame to system side */


/*!
 * @struct portmod_rx_control_s
 * @brief Rx Control Pass control frames. 
 */ 
typedef struct portmod_rx_control_s {
    uint32 flags; /**< bitmap for rx Frames */
    uint32 pass_control_frames; /**< Pass Control Frames */
    uint32 pass_pfc_frames; /**< Pass PFC Frames */
    uint32 pass_pause_frames; /**< Pass pause Frames */
} portmod_rx_control_t;

/* portmod_rx_control_t initialization and validation */
int portmod_rx_control_t_validate(int unit, const portmod_rx_control_t* portmod_rx_control);
int portmod_rx_control_t_init(int unit, portmod_rx_control_t* portmod_rx_control);

typedef struct portmod_multi_get_s {
    uint32 flags;
    uint32 dev_addr;
    uint32 offset;
    uint32 max_size;
    unsigned char* data;
    uint32* actual_size;
} portmod_multi_get_t;

/* portmod_multi_get_t initialization and validation */
int portmod_multi_get_t_validate(int unit, const portmod_multi_get_t* portmod_multi_get);
int portmod_multi_get_t_init(int unit, portmod_multi_get_t* portmod_multi_get);

#define PORTMOD_NUM_PATTERN_DATA_INTS (8)
#define PORTMOD_TSCE_LANE_NAME_LEN (30)

#define PORTMOD_PCS_8B9B_LFEC _SHR_PORT_PCS_8B9BLFEC
#define PORTMOD_PCS_8B10B _SHR_PORT_PCS_8B10B
#define PORTMOD_PCS_64B66B_FEC _SHR_PORT_PCS_64B66BFEC /**< 64/66b FEC */
#define PORTMOD_PCS_64B66B_BEC _SHR_PORT_PCS_64B66BBEC /**< 64/66b BEC */
#define PORTMOD_PCS_64B66B _SHR_PORT_PCS_64B66B /**< 64/66b without FEC */
#define PORTMOD_PCS_64B66B_RS_FEC _SHR_PORT_PCS_64B66B_RS_FEC /**< 64/66b reed solomon FEC */
#define PORTMOD_PCS_64B66B_LOW_LATENCY_RS_FEC _SHR_PORT_PCS_64B66B_LOW_LATENCY_RS_FEC /**< 64/66b low latency reed solomon FEC */
#define PORTMOD_PCS_64B66B_15T_RS_FEC _SHR_PORT_PCS_64B66B_15T_RS_FEC /**< 64/66b 15T reed solomon FEC */
#define PORTMOD_PCS_64B66B_15T_LOW_LATENCY_RS_FEC _SHR_PORT_PCS_64B66B_15T_LOW_LATENCY_RS_FEC /**< 64/66b 15T low latency reed solomon FEC */
#define PORTMOD_PCS_UNKNOWN _SHR_PORT_PCS_UNKNOWN /**< unknown pcs */

#define PORTMOD_CL37_DISABLE (0x0)
#define PORTMOD_CL37_W_BAM (0x1)
#define PORTMOD_CL37_WO_BAM (0x2)
#define PORTMOD_CL37_W_10G (0x3)
#define PORTMOD_CL37_HR2SPM (0x4)
#define PORTMOD_CL37_HR2SPM_W_10G (0x5)
#define PORTMOD_CL37_W_BAM_HG (0x6)
#define PORTMOD_CL37_SGMII_COMBO (0x7)

#define PORTMOD_CL73_DISABLE (0x0)
#define PORTMOD_CL73_WO_BAM (0x2)
#define PORTMOD_CL73_W_BAM (0x1)
#define PORTMOD_CL73_MSA (0x3)
#define PORTMOD_MSA (0x4)
#define PORTMOD_CL73_CL37 (0x5)
#define PORTMOD_CL73_HG (0x6)
#define PORTMOD_CL73_HPAM (0x7)
#define PORTMOD_CL73_HPAM_VS_SW (0x8)

typedef _shr_port_pcs_t portmod_port_pcs_t;

/*! 
 * @brief Flags for port enable set. no flags means RX+TX for MAC and PHY 
 */ 
#define PORTMOD_PORT_ENABLE_MAC 0x1 /**< enable/disable the MAC(RX/TX according to the flags) */
#define PORTMOD_PORT_ENABLE_PHY 0x2 /**< enable/disable the Serdes (RX/TX according to the flags) */
#define PORTMOD_PORT_ENABLE_TX 0x4 /**< enable/disable TX */
#define PORTMOD_PORT_ENABLE_RX 0x8 /**< enable/disable RX */
#define PORTMOD_PORT_ENABLE_INTERNAL_PHY_ONLY 0x10 /**< enable/disable only the internal phy */

#define PORTMOD_PORT_ENABLE_MAC_SET(flags) ((flags) |= PORTMOD_PORT_ENABLE_MAC)
#define PORTMOD_PORT_ENABLE_PHY_SET(flags) ((flags) |= PORTMOD_PORT_ENABLE_PHY)
#define PORTMOD_PORT_ENABLE_TX_SET(flags) ((flags) |= PORTMOD_PORT_ENABLE_TX)
#define PORTMOD_PORT_ENABLE_RX_SET(flags) ((flags) |= PORTMOD_PORT_ENABLE_RX)
#define PORTMOD_PORT_ENABLE_INTERNAL_PHY_ONLY_SET(flags) ((flags) |= PORTMOD_PORT_ENABLE_INTERNAL_PHY_ONLY)

#define PORTMOD_PORT_ENABLE_MAC_CLR(flags) ((flags) &= ~PORTMOD_PORT_ENABLE_MAC)
#define PORTMOD_PORT_ENABLE_PHY_CLR(flags) ((flags) &= ~PORTMOD_PORT_ENABLE_PHY)
#define PORTMOD_PORT_ENABLE_TX_CLR(flags) ((flags) &= ~PORTMOD_PORT_ENABLE_TX)
#define PORTMOD_PORT_ENABLE_RX_CLR(flags) ((flags) &= ~PORTMOD_PORT_ENABLE_RX)
#define PORTMOD_PORT_ENABLE_INTERNAL_PHY_ONLY_CLR(flags) ((flags) &= ~PORTMOD_PORT_ENABLE_INTERNAL_PHY_ONLY)

#define PORTMOD_PORT_ENABLE_MAC_GET(flags) ((flags) & PORTMOD_PORT_ENABLE_MAC ? 1 : 0)
#define PORTMOD_PORT_ENABLE_PHY_GET(flags) ((flags) & PORTMOD_PORT_ENABLE_PHY ? 1 : 0)
#define PORTMOD_PORT_ENABLE_TX_GET(flags) ((flags) & PORTMOD_PORT_ENABLE_TX ? 1 : 0)
#define PORTMOD_PORT_ENABLE_RX_GET(flags) ((flags) & PORTMOD_PORT_ENABLE_RX ? 1 : 0)
#define PORTMOD_PORT_ENABLE_INTERNAL_PHY_ONLY_GET(flags) ((flags) & PORTMOD_PORT_ENABLE_INTERNAL_PHY_ONLY ? 1 : 0)

/*! 
 * @brief Flags for TX paramas setting method 
 */ 
#define PORTMOD_USER_SET_TX_PREEMPHASIS_BY_CONFIG 0x1 /**< preemphasis by configuration setting */
#define PORTMOD_USER_SET_TX_AMP_BY_CONFIG 0x2 /**< preemphasis by configuration setting */
#define PORTMOD_USER_SET_TX_PREEMPHASIS_BY_API 0x4 /**< by api call */
#define PORTMOD_USER_SET_TX_AMP_BY_API 0x8 /**< by api call */

#define PORTMOD_USER_SET_TX_PREEMPHASIS_BY_CONFIG_SET(flags) ((flags) |= PORTMOD_USER_SET_TX_PREEMPHASIS_BY_CONFIG)
#define PORTMOD_USER_SET_TX_AMP_BY_CONFIG_SET(flags) ((flags) |= PORTMOD_USER_SET_TX_AMP_BY_CONFIG)
#define PORTMOD_USER_SET_TX_PREEMPHASIS_BY_API_SET(flags) ((flags) |= PORTMOD_USER_SET_TX_PREEMPHASIS_BY_API)
#define PORTMOD_USER_SET_TX_AMP_BY_API_SET(flags) ((flags) |= PORTMOD_USER_SET_TX_AMP_BY_API)

#define PORTMOD_USER_SET_TX_PREEMPHASIS_BY_CONFIG_CLR(flags) ((flags) &= ~PORTMOD_USER_SET_TX_PREEMPHASIS_BY_CONFIG)
#define PORTMOD_USER_SET_TX_AMP_BY_CONFIG_CLR(flags) ((flags) &= ~PORTMOD_USER_SET_TX_AMP_BY_CONFIG)
#define PORTMOD_USER_SET_TX_PREEMPHASIS_BY_API_CLR(flags) ((flags) &= ~PORTMOD_USER_SET_TX_PREEMPHASIS_BY_API)
#define PORTMOD_USER_SET_TX_AMP_BY_API_CLR(flags) ((flags) &= ~PORTMOD_USER_SET_TX_AMP_BY_API)

#define PORTMOD_USER_SET_TX_PREEMPHASIS_BY_CONFIG_GET(flags) ((flags) & PORTMOD_USER_SET_TX_PREEMPHASIS_BY_CONFIG ? 1 : 0)
#define PORTMOD_USER_SET_TX_AMP_BY_CONFIG_GET(flags) ((flags) & PORTMOD_USER_SET_TX_AMP_BY_CONFIG ? 1 : 0)
#define PORTMOD_USER_SET_TX_PREEMPHASIS_BY_API_GET(flags) ((flags) & PORTMOD_USER_SET_TX_PREEMPHASIS_BY_API ? 1 : 0)
#define PORTMOD_USER_SET_TX_AMP_BY_API_GET(flags) ((flags) & PORTMOD_USER_SET_TX_AMP_BY_API ? 1 : 0)

/*! 
 * @brief properties for portmod_port_encoding_set, portmod_port_encoding_get 
 */ 
#define PORTMOD_ENCODING_LOW_LATENCY_LLFC 0x1 /**< 0: flow control indications sent on cell header / 1: flow control indications sent on FEC frames */
#define PORTMOD_ENCODING_FEC_ERROR_DETECT 0x2 /**< enable/disable error marking (add/remove error indications on the frame) */
#define PORTMOD_ENCODING_EXTRCT_CIG_FROM_LLFC 0x4 /**< enable/disable extracting CIG information from LLFC cells */
#define PORTMOD_ENCODING_LLFC_AFTER_FEC 0x8 /**< enable/disable FEC on LLFC and congestion indication */
#define PORTMOD_ENCODING_CONTROL_CELLS_FEC_BYPASS 0x10 /**< enable/disable FEC bypass on flow status and credit control cells */

#define PORTMOD_ENCODING_LOW_LATENCY_LLFC_SET(properties) ((properties) |= PORTMOD_ENCODING_LOW_LATENCY_LLFC)
#define PORTMOD_ENCODING_FEC_ERROR_DETECT_SET(properties) ((properties) |= PORTMOD_ENCODING_FEC_ERROR_DETECT)
#define PORTMOD_ENCODING_EXTRCT_CIG_FROM_LLFC_SET(properties) ((properties) |= PORTMOD_ENCODING_EXTRCT_CIG_FROM_LLFC)
#define PORTMOD_ENCODING_LLFC_AFTER_FEC_SET(properties) ((properties) |= PORTMOD_ENCODING_LLFC_AFTER_FEC)
#define PORTMOD_ENCODING_CONTROL_CELLS_FEC_BYPASS_SET(properties) ((properties) |= PORTMOD_ENCODING_CONTROL_CELLS_FEC_BYPASS)

#define PORTMOD_ENCODING_LOW_LATENCY_LLFC_CLR(properties) ((properties) &= ~PORTMOD_ENCODING_LOW_LATENCY_LLFC)
#define PORTMOD_ENCODING_FEC_ERROR_DETECT_CLR(properties) ((properties) &= ~PORTMOD_ENCODING_FEC_ERROR_DETECT)
#define PORTMOD_ENCODING_EXTRCT_CIG_FROM_LLFC_CLR(properties) ((properties) &= ~PORTMOD_ENCODING_EXTRCT_CIG_FROM_LLFC)
#define PORTMOD_ENCODING_LLFC_AFTER_FEC_CLR(properties) ((properties) &= ~PORTMOD_ENCODING_LLFC_AFTER_FEC)
#define PORTMOD_ENCODING_CONTROL_CELLS_FEC_BYPASS_CLR(properties) ((properties) &= ~PORTMOD_ENCODING_CONTROL_CELLS_FEC_BYPASS)

#define PORTMOD_ENCODING_LOW_LATENCY_LLFC_GET(properties) ((properties) & PORTMOD_ENCODING_LOW_LATENCY_LLFC ? 1 : 0)
#define PORTMOD_ENCODING_FEC_ERROR_DETECT_GET(properties) ((properties) & PORTMOD_ENCODING_FEC_ERROR_DETECT ? 1 : 0)
#define PORTMOD_ENCODING_EXTRCT_CIG_FROM_LLFC_GET(properties) ((properties) & PORTMOD_ENCODING_EXTRCT_CIG_FROM_LLFC ? 1 : 0)
#define PORTMOD_ENCODING_LLFC_AFTER_FEC_GET(properties) ((properties) & PORTMOD_ENCODING_LLFC_AFTER_FEC ? 1 : 0)
#define PORTMOD_ENCODING_CONTROL_CELLS_FEC_BYPASS_GET(properties) ((properties) & PORTMOD_ENCODING_CONTROL_CELLS_FEC_BYPASS ? 1 : 0)

#define PORTMOD_MAX_CORES_PER_PORT (3)

#define PORTMOD_TS_ADJUST_NUM_OLD (8)
#define PORTMOD_TS_ADJUST_NUM (16)


/*!
 * @enum portmod_loopback_mode_e
 * @brief looopback modes for portmod_port_loopback_set, portmod_port_loopback_get 
 */ 
typedef enum portmod_loopback_mode_e {
    portmodLoopbackMacOuter = 0,
    portmodLoopbackMacCore = 1,
    portmodLoopbackMacPCS = 2,
    portmodLoopbackMacAsyncFifo = 3,
    portmodLoopbackPhyGloopPCS = 4,
    portmodLoopbackPhyGloopPMD = 5,
    portmodLoopbackPhyRloopPCS = 6, /**< remote PHY loopback in the PCS layer */
    portmodLoopbackPhyRloopPMD = 7, /**< remote PHY loopback in the PMD layer */
    portmodLoopbackMacRloop = 8, /**< remote MAC loopback */
    portmodLoopbackCount
} portmod_loopback_mode_t;

#ifdef PORTMOD_DIAG
extern enum_mapping_t portmod_loopback_mode_t_mapping[];
#endif /*PORTMOD_DIAG*/

/* portmod_loopback_mode_t validation */
int portmod_loopback_mode_t_validate(int unit, portmod_loopback_mode_t portmod_loopback_mode);

/*!
 * @enum portmod_core_port_mode_e
 * @brief Port Modes for MAC  
 */ 
typedef enum portmod_core_port_mode_e {
    portmodPortModeQuad = 0,
    portmodPortModeTri012 = 1,
    portmodPortModeTri023 = 2,
    portmodPortModeDual = 3,
    portmodPortModeSingle = 4,
    portmodPortModeCount
} portmod_core_port_mode_t;

#ifdef PORTMOD_DIAG
extern enum_mapping_t portmod_core_port_mode_t_mapping[];
#endif /*PORTMOD_DIAG*/

/* portmod_core_port_mode_t validation */
int portmod_core_port_mode_t_validate(int unit, portmod_core_port_mode_t portmod_core_port_mode);

/*!
 * @enum portmod_port_mode_aux_info_e
 * @brief auxiliary info for assigning port mode  
 */ 
typedef enum portmod_port_mode_aux_info_e {
    portmodModeInfoNone = 0,
    portmodModeInfoThreePorts = 1, /**< there are three ports in a core */
    portmodModeInfoTwoDualModePorts = 2, /**< there are two ports in a core and each lane is in dual port mode */
    portmodModeInfoCount
} portmod_port_mode_aux_info_t;

#ifdef PORTMOD_DIAG
extern enum_mapping_t portmod_port_mode_aux_info_t_mapping[];
#endif /*PORTMOD_DIAG*/

/* portmod_port_mode_aux_info_t validation */
int portmod_port_mode_aux_info_t_validate(int unit, portmod_port_mode_aux_info_t portmod_port_mode_aux_info);

/*!
 * @enum portmod_mac_soft_reset_mode_e
 * @brief soft reset mode  
 */ 
typedef enum portmod_mac_soft_reset_mode_e {
    portmodMacSoftResetModeIn_Out = 0, /**< get MAC IN reset and then out of reset */
    portmodMacSoftResetModeIn = 1, /**< set MAC in soft reset */
    portmodMacSoftResetModeOut = 2, /**< get MAC out of soft reset */
    portmodMacSoftResetModeCount
} portmod_mac_soft_reset_mode_t;

#ifdef PORTMOD_DIAG
extern enum_mapping_t portmod_mac_soft_reset_mode_t_mapping[];
#endif /*PORTMOD_DIAG*/

/* portmod_mac_soft_reset_mode_t validation */
int portmod_mac_soft_reset_mode_t_validate(int unit, portmod_mac_soft_reset_mode_t portmod_mac_soft_reset_mode);

/*!
 * @enum portmod_prbs_mode_e
 * @brief Psuedo Random Bit Stream (PRBS) modes  
 */ 
typedef enum portmod_prbs_mode_e {
    portmodPrbsModePhy = 0,
    portmodPrbsModeMac = 1,
    portmodPrbsModeCount
} portmod_prbs_mode_t;

#ifdef PORTMOD_DIAG
extern enum_mapping_t portmod_prbs_mode_t_mapping[];
#endif /*PORTMOD_DIAG*/

/* portmod_prbs_mode_t validation */
int portmod_prbs_mode_t_validate(int unit, portmod_prbs_mode_t portmod_prbs_mode);

/*!
 * @enum portmod_ext_to_int_phy_ctrlcode_e
 * @brief Control Codes to Call Internal Phy PortMod functions from legacy External Phy  
 */ 
typedef enum portmod_ext_to_int_phy_ctrlcode_e {
    portmodExtToInt_CtrlCode_Init = 0,
    portmodExtToInt_CtrlCode_Reset = 1,
    portmodExtToInt_CtrlCode_Link = 2,
    portmodExtToInt_CtrlCode_Enable = 3,
    portmodExtToInt_CtrlCode_Duplex = 4,
    portmodExtToInt_CtrlCode_Speed = 5,
    portmodExtToInt_CtrlCode_Master = 6,
    portmodExtToInt_CtrlCode_AN = 7,
    portmodExtToInt_CtrlCode_AdvLocal = 8,
    portmodExtToInt_CtrlCode_AdvRemote = 9,
    portmodExtToInt_CtrlCode_LB = 10,
    portmodExtToInt_CtrlCode_Interface = 11,
    portmodExtToInt_CtrlCode_Ability = 12,
    portmodExtToInt_CtrlCode_AbilityAdvert = 13,
    portmodExtToInt_CtrlCode_AbilityRemote = 14,
    portmodExtToInt_CtrlCode_AbilityLocal = 15,
    portmodExtToInt_CtrlCode_LinkupEvt = 16,
    portmodExtToInt_CtrlCode_LinkdnEvt = 17,
    portmodExtToInt_CtrlCode_MDIX = 18,
    portmodExtToInt_CtrlCode_MDIXStatus = 19,
    portmodExtToInt_CtrlCode_MediumConfig = 20,
    portmodExtToInt_CtrlCode_Medium = 21,
    portmodExtToInt_CtrlCode_CableDiag = 22,
    portmodExtToInt_CtrlCode_Control = 23,
    portmodExtToInt_CtrlCode_Firmware = 24,
    portmodExtToInt_CtrlCode_TimesyncConfig = 25,
    portmodExtToInt_CtrlCode_TimesyncControl = 26,
    portmodExtToInt_CtrlCode_TimesyncEnhancedCapture = 27,
    portmodExtToInt_CtrlCode_DiagCtrl = 28,
    portmodExtToInt_CtrlCode_LaneControl = 29,
    portmodExtToInt_CtrlCode_OAMConfig = 30,
    portmodExtToInt_CtrlCode_OAMControl = 31,
    portmodExtToInt_CtrlCode_Multi = 32,
    portmodExtToInt_CtrlCode_Probe = 33,
    portmodExtToInt_CtrlCode_PreconditionBeforeProbe = 34,
    portmodExtToInt_CtrlCode_LinkfaultGet = 35,
    portmodExtToInt_CtrlCode_SpeedLine = 36,
    portmodExtToInt_CtrlCode_Count
} portmod_ext_to_int_phy_ctrlcode_t;

#ifdef PORTMOD_DIAG
extern enum_mapping_t portmod_ext_to_int_phy_ctrlcode_t_mapping[];
#endif /*PORTMOD_DIAG*/

/* portmod_ext_to_int_phy_ctrlcode_t validation */
int portmod_ext_to_int_phy_ctrlcode_t_validate(int unit, portmod_ext_to_int_phy_ctrlcode_t portmod_ext_to_int_phy_ctrlcode);

/*!
 * @enum portmod_cpm_core_mode_e
 * @brief cpm core modes 
 */ 
typedef enum portmod_cpm_core_mode_e {
    portmodCpmAllCpri = 0,
    portmodCpmAllIEEE = 1,
    portmodCpmAllHIGIG = 2,
    portmodCpmMixEthCpri = 3,
    portmodCpmCount
} portmod_cpm_core_mode_t;

#ifdef PORTMOD_DIAG
extern enum_mapping_t portmod_cpm_core_mode_t_mapping[];
#endif /*PORTMOD_DIAG*/

/* portmod_cpm_core_mode_t validation */
int portmod_cpm_core_mode_t_validate(int unit, portmod_cpm_core_mode_t portmod_cpm_core_mode);

/*!
 * @enum portmod_core_port_enet_cpri_type_e
 * @brief Different ports cpri/ethernet 
 */ 
typedef enum portmod_core_port_enet_cpri_type_e {
    portmodCpmPrtEthMode = 0,
    portmodCpmPrtEthOfMixedMode = 1,
    portmodCpmPrtCpriMode = 2,
    portmodCpmPrtCpriOfMixedMode = 3,
    portmodCpmPrtRsvd4Mode = 4,
    portmodCpmPrtRsvd4OfMixedMode = 5,
    portmodCpmPrtCount
} portmod_core_port_enet_cpri_type_t;

#ifdef PORTMOD_DIAG
extern enum_mapping_t portmod_core_port_enet_cpri_type_t_mapping[];
#endif /*PORTMOD_DIAG*/

/* portmod_core_port_enet_cpri_type_t validation */
int portmod_core_port_enet_cpri_type_t_validate(int unit, portmod_core_port_enet_cpri_type_t portmod_core_port_enet_cpri_type);

/*!
 * @struct portmod_portphy_ability_s
 * @brief portmod version of port's ability mapping. 
 */ 
typedef struct portmod_portphy_ability_s {
    portmod_port_mode_t cur_mode;
    portmod_port_mode_t speed_half_duplex;
    portmod_port_mode_t speed_full_duplex;
    portmod_port_mode_t pause;
    portmod_port_mode_t interface;
    portmod_port_mode_t medium;
    portmod_port_mode_t loopback;
    portmod_port_mode_t flags;
    portmod_port_mode_t eee;
    portmod_port_mode_t fcmap;
    portmod_pa_encap_t encap;
} portmod_portphy_ability_t;

/* portmod_portphy_ability_t initialization and validation */
int portmod_portphy_ability_t_validate(int unit, const portmod_portphy_ability_t* portmod_portphy_ability);
int portmod_portphy_ability_t_init(int unit, portmod_portphy_ability_t* portmod_portphy_ability);


/*!
 * @struct portmod_pdata_s
 * @brief portmod version of port's pdata to transger data. 
 */ 
typedef struct portmod_pdata_s {
    uint32_t data;
    uint32_t enable;
    portmod_port_if_t pif;
    portmod_port_ability_t* ability;
} portmod_pdata_t;

/* portmod_pdata_t initialization and validation */
int portmod_pdata_t_validate(int unit, const portmod_pdata_t* portmod_pdata);
int portmod_pdata_t_init(int unit, portmod_pdata_t* portmod_pdata);


/*!
 * @struct portmod_port_mode_info_s
 * @brief port mode info. 
 */ 
typedef struct portmod_port_mode_info_s {
    portmod_core_port_mode_t cur_mode;
    int lanes;
    int port_index;
} portmod_port_mode_info_t;

/* portmod_port_mode_info_t initialization and validation */
int portmod_port_mode_info_t_validate(int unit, const portmod_port_mode_info_t* portmod_port_mode_info);
int portmod_port_mode_info_t_init(int unit, portmod_port_mode_info_t* portmod_port_mode_info);

typedef _shr_port_phy_fec_t portmod_fec_t;


/*!
 * @struct portmod_port_diag_info_s
 * @brief This structure return port diagnostics information from the PMM 
 */ 
typedef struct portmod_port_diag_info_s {
    int original_port; /**< in case of alias this field will be the original port */
    soc_port_if_t interface; /**< interface type */
    int pm_id; /**< pm id which the port belongs */
    portmod_pbmp_t phys; /**< The PHYs that assemble the port */
    int sub_phy; /**< qsgmii only; Sub PHY index */
    int medium; /**< Fiber or Copper; */
    portmod_port_mode_info_t core_mode; /**< core port mode */
    phymod_polarity_t polarity; /**< phy polority */
    portmod_fec_t fec; /**< FEC type */
} portmod_port_diag_info_t;

/* portmod_port_diag_info_t initialization and validation */
int portmod_port_diag_info_t_validate(int unit, const portmod_port_diag_info_t* portmod_port_diag_info);
int portmod_port_diag_info_t_init(int unit, portmod_port_diag_info_t* portmod_port_diag_info);


/*!
 * @struct portmod_pm_core_info_s
 * @brief This structure return port diagnostics information from the PMM 
 */ 
typedef struct portmod_pm_core_info_s {
    phymod_ref_clk_t ref_clk; /**< reference clock */
    phymod_lane_map_t lane_map; /**< lane map */
    int nof_phys; /**< internal + external phys */
} portmod_pm_core_info_t;

/* portmod_pm_core_info_t initialization and validation */
int portmod_pm_core_info_t_validate(int unit, const portmod_pm_core_info_t* portmod_pm_core_info);
int portmod_pm_core_info_t_init(int unit, portmod_pm_core_info_t* portmod_pm_core_info);


/*!
 * @struct portmod_pm_diag_info_s
 * @brief PM diagnostics information 
 */ 
typedef struct portmod_pm_diag_info_s {
    portmod_dispatch_type_t type; /**< PM type */
    portmod_pm_core_info_t core_info; /**< PM core information */
    portmod_pbmp_t phys; /**< Which PHYs are connected to the PM */
    soc_pbmp_t ports; /**< Which ports are connected to the PM */
    uint16 serdes_id0; /**< Serdes ID */
    uint16 phy_id0; /**< Phy ID0 */
    uint16 phy_id1; /**< Phy ID1 */
    char name[PORTMOD_TSCE_LANE_NAME_LEN];
} portmod_pm_diag_info_t;

/* portmod_pm_diag_info_t initialization and validation */
int portmod_pm_diag_info_t_validate(int unit, const portmod_pm_diag_info_t* portmod_pm_diag_info);
int portmod_pm_diag_info_t_init(int unit, portmod_pm_diag_info_t* portmod_pm_diag_info);


/*!
 * @struct portmod_port_ts_adjust_s
 * @brief Store time stamp adjust from configuration for MAC  
 */ 
typedef struct portmod_port_ts_adjust_s {
    int speed;
    uint32 osts_adjust; /**< MAC pipeline delay in OSTS */
    uint32 tsts_adjust; /**< Delay of TS timer from TS clk to TSC_Clk domain */
} portmod_port_ts_adjust_t;

/* portmod_port_ts_adjust_t initialization and validation */
int portmod_port_ts_adjust_t_validate(int unit, const portmod_port_ts_adjust_t* portmod_port_ts_adjust);
int portmod_port_ts_adjust_t_init(int unit, portmod_port_ts_adjust_t* portmod_port_ts_adjust);

typedef enum portmod_qtc_mode_e {
    portmodQtcModeInvalid = 0, /**< Invalid mode. */
    portmodQtcModeEthernet = 1, /**< PM core in Ethernet mode. */
    portmodQtcModeQsgmii = 2, /**< PM core in QSGMII mode. */
    portmodQtcModeUsxgmii = 3, /**< PM core in USXGMII mode. */
    portmodQtcModeCount
} portmod_qtc_mode_t;

#ifdef PORTMOD_DIAG
extern enum_mapping_t portmod_qtc_mode_t_mapping[];
#endif /*PORTMOD_DIAG*/

/* portmod_qtc_mode_t validation */
int portmod_qtc_mode_t_validate(int unit, portmod_qtc_mode_t portmod_qtc_mode);

/*!
 * @struct portmod_port_init_config_s
 * @brief port config information. 
 */ 
typedef struct portmod_port_init_config_s {
    phymod_phy_reset_t phy_reset_config;
    phymod_pattern_t pattern;
    int cx4_10g;
    int pdetect1000x;
    phymod_an_mode_type_t an_mode; /**< spn_PHY_AN_MODE - Specify the AN mode */
    int an_master_lane; /**< spn_PHY_AUTONEG_MASTER_LANE - Specify the AN master lane */
    int an_cl72; /**< spn_PHY_AN_C72 - Specify if the link training should be enabled */
    int fs_cl72; /**<  spn_FORCED_INIT_CL72 - if trainig should be enabled in Forced speed mode */
    int an_fec; /**<  spn_FORCED_INIT_FEC specify if FEC should be enabled in AN mode  */
    int serdes_fec_enable; /**<  spn_SERDES_FEC_ENABLE, 0 - no FEC(default), 1 - CL74, 2 - CL91 */
    int sgmii_mstr;
    int serdes_driver_current;
    int serdes_1000x_at_6250_vco; /**< run 1G at 6.25 VCO */
    int serdes_1000x_at_12500_vco; /**< run 1G at 12.5 VCO */
    int serdes_1000x_at_25g_vco; /**< run 1G at 25 VCO */
    int serdes_10g_at_25g_vco; /**< run 10GBase-R at 25 VCO */
    int pll_divider_req; /**< specify the PLL divider value to use for the speed */
    int rxaui_mode;
    int port_fallback_lane;
    int tx_params_user_flag[PHYMOD_MAX_LANES_PER_PORT];
    phymod_tx_t tx_params[PHYMOD_MAX_LANES_PER_PORT]; /**< tx params from config */
    int an_cl37; /**< AN CL37 */
    int cl37_sgmii_war;
    int cl37_sgmii_cnt;
    int cl37_sgmii_RESTART_CNT; /**< threshold for cl37_sgmii_cnt */
    int an_cl73; /**< AN_CL73 */
    int is_hg; /**< is higig port */
    int ext_phy_tx_params_user_flag[PHYMOD_MAX_LANES_PER_PORT];
    phymod_tx_t ext_phy_tx_params[PHYMOD_MAX_LANES_PER_PORT]; /**< external phy tx params from config */
    phymod_polarity_t polarity[PORTMOD_MAX_CORES_PER_PORT];
    uint8 polarity_overwrite; /**<  Get polarity form config to overwrite PM's polarity when port probe  */
    phymod_lane_map_t lane_map[PORTMOD_MAX_CORES_PER_PORT];
    uint8 lane_map_overwrite; /**<  Get lane map form config to overwrite PM's lane map when port probe  */
    phymod_firmware_load_method_t fw_load_method[PORTMOD_MAX_CORES_PER_PORT];
    uint8 fw_load_method_overwrite; /**<  Get fw load method form config to overwrite PM's fw load method when port probe  */
    phymod_ref_clk_t ref_clk;
    uint8 ref_clk_overwrite; /**<  Get ref clk form config to overwrite PM's ref clk when port probe  */
    portmod_port_mode_aux_info_t port_mode_aux_info; /**< auxiliary info for assigning the core port mode */
    portmod_port_ts_adjust_t port_ts_adjust[PORTMOD_TS_ADJUST_NUM]; /**<  Configure time stamp adjust for mac */
    uint32 txpi_mode; /**< PMD TXPI mode. 0 - disable, 1- Enable with external PD (Phase detector) */
    uint32 txpi_sdm_scheme; /**< TXPI SDM scheme type. 0 - 1st order scheme with floor, 1 - 1st order scheme with rounding, 2 - 2nd order scheme with rounding  */
    int roe_stuffing_bit; /**< 1bit value for Stuffing bit */
    int roe_reserved_bit; /**< 1bit value for Reserved bit */
    portmod_cpm_core_mode_t cpm_core_mode;
    portmod_qtc_mode_t qtc_mode;
    int parity_enable; /**< parity enable */
    int an_cl72_tx_init_skip_on_restart; /**< Skip the TXFIR initialization in a restart event during the AN link training */
} portmod_port_init_config_t;

/* portmod_port_init_config_t initialization and validation */
int portmod_port_init_config_t_validate(int unit, const portmod_port_init_config_t* portmod_port_init_config);
int portmod_port_init_config_t_init(int unit, portmod_port_init_config_t* portmod_port_init_config);

typedef _shr_port_encap_t portmod_encap_t;


/*!
 * @struct portmod_port_interface_config_s
 * @brief  This structure contains the rate, settings as medium, scrambler en, etc. and flags which allow/forbid the change of PLL/TX parameters/FW configuration/etc. 
 */ 
typedef struct portmod_port_interface_config_s {
    soc_port_if_t interface;
    soc_port_if_t line_interface;
    soc_port_if_t serdes_interface;
    uint32 interface_modes; /**< see PHYMOD_INTF_MODES_ */
    uint32 flags; /**< see PHYMOD_INTF_F_ */
    uint32 port_refclk_int;
    int port_num_lanes;
    int speed; /**< speed at which the port should be initialized */
    int max_speed; /**< Max Port Speed Supported */
    portmod_encap_t encap_mode; /**< Encap Mode */
    int pll_divider_req;
    int port_op_mode; /**< mainly used by ext phy for repeater/retimer */
    uint32 serdes_scrambler_seed; /**< scramblar seed for CPRI and RSVD4 mode */
    uint32 serdes_scrambler_enable; /**< 1bit value for scramblar enable for CPRI and RSVD4 mode */
} portmod_port_interface_config_t;

/* portmod_port_interface_config_t initialization and validation */
int portmod_port_interface_config_t_validate(int unit, const portmod_port_interface_config_t* portmod_port_interface_config);
int portmod_port_interface_config_t_init(int unit, portmod_port_interface_config_t* portmod_port_interface_config);

/*! 
 * @brief Port Add Flags 
 */ 
#define PORTMOD_PORT_ADD_F_INIT_PASS1 0x1 /**< phymod init PASS1:do some initializations before FW load.If broadcast is not supported, download FW unicast */
#define PORTMOD_PORT_ADD_F_INIT_PASS2 0x2 /**< phymod init PASS2:do some initializations after FW load */
#define PORTMOD_PORT_ADD_F_FIRMWARE_LOAD_VERIFY 0x4 /**< Verify FW loaded correctly */
#define PORTMOD_PORT_ADD_F_RX_SRIP_CRC 0x8 /**< Set port RX to strip CRC mode */
#define PORTMOD_PORT_ADD_F_TX_APPEND_CRC 0x10 /**< Set port TX to append CRC before sending the packet */
#define PORTMOD_PORT_ADD_F_TX_REPLACE_CRC 0x20 /**< Set port TX to replace CRC before sending the packet */
#define PORTMOD_PORT_ADD_F_TX_PASS_THROUGH_CRC 0x40 /**< Set port TX to pass through CRC */
#define PORTMOD_PORT_ADD_F_EGR_1588_TIMESTAMP_MODE_48BIT 0x80 /**< Enable 48-bit time stamping */
#define PORTMOD_PORT_ADD_F_INIT_CORE_PROBE 0x100 /**< Do Core Probe. This is stage 1 of 3 stage init. INIT_UNTIL, RESUME AFTER are other 2 stages. If no flag is set - all 3 will be performed. */
#define PORTMOD_PORT_ADD_F_PORT_ATTACH_EXT_PHY_SKIP 0x200 /**< Skip external phy port attach */
#define PORTMOD_PORT_ADD_F_ELK 0x400 /**< flag for ELK */
#define PORTMOD_PORT_ADD_F_SYS_16B_INTF_MODE 0x800 /**< flag for CLMAC 16B Mode */
#define PORTMOD_PORT_ADD_F_AUTONEG_CONFIG_SKIP 0x1000 /**< Skip autoneg configuration in port attach */
#define PORTMOD_PORT_ADD_F_FIRMWARE_DOWNLOAD_BCAST 0x2000 /**< FW download broadcast */
#define PORTMOD_PORT_ADD_F_SKIP_SPEED_INIT 0x4000 /**< Flag used by DNX to skip speed set duirng init */
#define PORTMOD_PORT_ADD_F_IS_ENHANCED_PM4X25_GEN2 0x8000 /**< enhanced pm 4x25 gen2 */
#define PORTMOD_PORT_ADD_F_DEFAULT_OSR2P5 0x10000 /**< Set OSR2P5 by default */
#define PORTMOD_PORT_ADD_F_PCS_BYPASSED 0x20000 /**< Bypass the PCS logic in PM */
#define PORTMOD_PORT_ADD_F_BYPASS_FW_CRC_CHECK 0x40000 /**< Bypass the FW CRC check */
#define PORTMOD_PORT_ADD_F_FLEXE_CONFIG 0x80000 /**< Flex ETHERNET config  */
#define PORTMOD_PORT_ADD_F_FLEXE_TVCO_26G_CONFIG 0x100000 /**< Flex ETHERNET set TVCO to 26G */

#define PORTMOD_PORT_ADD_F_INIT_PASS1_SET(info) ((info)->flags |= PORTMOD_PORT_ADD_F_INIT_PASS1)
#define PORTMOD_PORT_ADD_F_INIT_PASS2_SET(info) ((info)->flags |= PORTMOD_PORT_ADD_F_INIT_PASS2)
#define PORTMOD_PORT_ADD_F_FIRMWARE_LOAD_VERIFY_SET(info) ((info)->flags |= PORTMOD_PORT_ADD_F_FIRMWARE_LOAD_VERIFY)
#define PORTMOD_PORT_ADD_F_RX_SRIP_CRC_SET(info) ((info)->flags |= PORTMOD_PORT_ADD_F_RX_SRIP_CRC)
#define PORTMOD_PORT_ADD_F_TX_APPEND_CRC_SET(info) ((info)->flags |= PORTMOD_PORT_ADD_F_TX_APPEND_CRC)
#define PORTMOD_PORT_ADD_F_TX_REPLACE_CRC_SET(info) ((info)->flags |= PORTMOD_PORT_ADD_F_TX_REPLACE_CRC)
#define PORTMOD_PORT_ADD_F_TX_PASS_THROUGH_CRC_SET(info) ((info)->flags |= PORTMOD_PORT_ADD_F_TX_PASS_THROUGH_CRC)
#define PORTMOD_PORT_ADD_F_EGR_1588_TIMESTAMP_MODE_48BIT_SET(info) ((info)->flags |= PORTMOD_PORT_ADD_F_EGR_1588_TIMESTAMP_MODE_48BIT)
#define PORTMOD_PORT_ADD_F_INIT_CORE_PROBE_SET(info) ((info)->flags |= PORTMOD_PORT_ADD_F_INIT_CORE_PROBE)
#define PORTMOD_PORT_ADD_F_PORT_ATTACH_EXT_PHY_SKIP_SET(info) ((info)->flags |= PORTMOD_PORT_ADD_F_PORT_ATTACH_EXT_PHY_SKIP)
#define PORTMOD_PORT_ADD_F_ELK_SET(info) ((info)->flags |= PORTMOD_PORT_ADD_F_ELK)
#define PORTMOD_PORT_ADD_F_SYS_16B_INTF_MODE_SET(info) ((info)->flags |= PORTMOD_PORT_ADD_F_SYS_16B_INTF_MODE)
#define PORTMOD_PORT_ADD_F_AUTONEG_CONFIG_SKIP_SET(info) ((info)->flags |= PORTMOD_PORT_ADD_F_AUTONEG_CONFIG_SKIP)
#define PORTMOD_PORT_ADD_F_FIRMWARE_DOWNLOAD_BCAST_SET(info) ((info)->flags |= PORTMOD_PORT_ADD_F_FIRMWARE_DOWNLOAD_BCAST)
#define PORTMOD_PORT_ADD_F_SKIP_SPEED_INIT_SET(info) ((info)->flags |= PORTMOD_PORT_ADD_F_SKIP_SPEED_INIT)
#define PORTMOD_PORT_ADD_F_IS_ENHANCED_PM4X25_GEN2_SET(info) ((info)->flags |= PORTMOD_PORT_ADD_F_IS_ENHANCED_PM4X25_GEN2)
#define PORTMOD_PORT_ADD_F_DEFAULT_OSR2P5_SET(info) ((info)->flags |= PORTMOD_PORT_ADD_F_DEFAULT_OSR2P5)
#define PORTMOD_PORT_ADD_F_PCS_BYPASSED_SET(info) ((info)->flags |= PORTMOD_PORT_ADD_F_PCS_BYPASSED)
#define PORTMOD_PORT_ADD_F_BYPASS_FW_CRC_CHECK_SET(info) ((info)->flags |= PORTMOD_PORT_ADD_F_BYPASS_FW_CRC_CHECK)
#define PORTMOD_PORT_ADD_F_FLEXE_CONFIG_SET(info) ((info)->flags |= PORTMOD_PORT_ADD_F_FLEXE_CONFIG)
#define PORTMOD_PORT_ADD_F_FLEXE_TVCO_26G_CONFIG_SET(info) ((info)->flags |= PORTMOD_PORT_ADD_F_FLEXE_TVCO_26G_CONFIG)

#define PORTMOD_PORT_ADD_F_INIT_PASS1_CLR(info) ((info)->flags &= ~PORTMOD_PORT_ADD_F_INIT_PASS1)
#define PORTMOD_PORT_ADD_F_INIT_PASS2_CLR(info) ((info)->flags &= ~PORTMOD_PORT_ADD_F_INIT_PASS2)
#define PORTMOD_PORT_ADD_F_FIRMWARE_LOAD_VERIFY_CLR(info) ((info)->flags &= ~PORTMOD_PORT_ADD_F_FIRMWARE_LOAD_VERIFY)
#define PORTMOD_PORT_ADD_F_RX_SRIP_CRC_CLR(info) ((info)->flags &= ~PORTMOD_PORT_ADD_F_RX_SRIP_CRC)
#define PORTMOD_PORT_ADD_F_TX_APPEND_CRC_CLR(info) ((info)->flags &= ~PORTMOD_PORT_ADD_F_TX_APPEND_CRC)
#define PORTMOD_PORT_ADD_F_TX_REPLACE_CRC_CLR(info) ((info)->flags &= ~PORTMOD_PORT_ADD_F_TX_REPLACE_CRC)
#define PORTMOD_PORT_ADD_F_TX_PASS_THROUGH_CRC_CLR(info) ((info)->flags &= ~PORTMOD_PORT_ADD_F_TX_PASS_THROUGH_CRC)
#define PORTMOD_PORT_ADD_F_EGR_1588_TIMESTAMP_MODE_48BIT_CLR(info) ((info)->flags &= ~PORTMOD_PORT_ADD_F_EGR_1588_TIMESTAMP_MODE_48BIT)
#define PORTMOD_PORT_ADD_F_INIT_CORE_PROBE_CLR(info) ((info)->flags &= ~PORTMOD_PORT_ADD_F_INIT_CORE_PROBE)
#define PORTMOD_PORT_ADD_F_PORT_ATTACH_EXT_PHY_SKIP_CLR(info) ((info)->flags &= ~PORTMOD_PORT_ADD_F_PORT_ATTACH_EXT_PHY_SKIP)
#define PORTMOD_PORT_ADD_F_ELK_CLR(info) ((info)->flags &= ~PORTMOD_PORT_ADD_F_ELK)
#define PORTMOD_PORT_ADD_F_SYS_16B_INTF_MODE_CLR(info) ((info)->flags &= ~PORTMOD_PORT_ADD_F_SYS_16B_INTF_MODE)
#define PORTMOD_PORT_ADD_F_AUTONEG_CONFIG_SKIP_CLR(info) ((info)->flags &= ~PORTMOD_PORT_ADD_F_AUTONEG_CONFIG_SKIP)
#define PORTMOD_PORT_ADD_F_FIRMWARE_DOWNLOAD_BCAST_CLR(info) ((info)->flags &= ~PORTMOD_PORT_ADD_F_FIRMWARE_DOWNLOAD_BCAST)
#define PORTMOD_PORT_ADD_F_SKIP_SPEED_INIT_CLR(info) ((info)->flags &= ~PORTMOD_PORT_ADD_F_SKIP_SPEED_INIT)
#define PORTMOD_PORT_ADD_F_IS_ENHANCED_PM4X25_GEN2_CLR(info) ((info)->flags &= ~PORTMOD_PORT_ADD_F_IS_ENHANCED_PM4X25_GEN2)
#define PORTMOD_PORT_ADD_F_DEFAULT_OSR2P5_CLR(info) ((info)->flags &= ~PORTMOD_PORT_ADD_F_DEFAULT_OSR2P5)
#define PORTMOD_PORT_ADD_F_PCS_BYPASSED_CLR(info) ((info)->flags &= ~PORTMOD_PORT_ADD_F_PCS_BYPASSED)
#define PORTMOD_PORT_ADD_F_BYPASS_FW_CRC_CHECK_CLR(info) ((info)->flags &= ~PORTMOD_PORT_ADD_F_BYPASS_FW_CRC_CHECK)
#define PORTMOD_PORT_ADD_F_FLEXE_CONFIG_CLR(info) ((info)->flags &= ~PORTMOD_PORT_ADD_F_FLEXE_CONFIG)
#define PORTMOD_PORT_ADD_F_FLEXE_TVCO_26G_CONFIG_CLR(info) ((info)->flags &= ~PORTMOD_PORT_ADD_F_FLEXE_TVCO_26G_CONFIG)

#define PORTMOD_PORT_ADD_F_INIT_PASS1_GET(info) ((info)->flags & PORTMOD_PORT_ADD_F_INIT_PASS1 ? 1 : 0)
#define PORTMOD_PORT_ADD_F_INIT_PASS2_GET(info) ((info)->flags & PORTMOD_PORT_ADD_F_INIT_PASS2 ? 1 : 0)
#define PORTMOD_PORT_ADD_F_FIRMWARE_LOAD_VERIFY_GET(info) ((info)->flags & PORTMOD_PORT_ADD_F_FIRMWARE_LOAD_VERIFY ? 1 : 0)
#define PORTMOD_PORT_ADD_F_RX_SRIP_CRC_GET(info) ((info)->flags & PORTMOD_PORT_ADD_F_RX_SRIP_CRC ? 1 : 0)
#define PORTMOD_PORT_ADD_F_TX_APPEND_CRC_GET(info) ((info)->flags & PORTMOD_PORT_ADD_F_TX_APPEND_CRC ? 1 : 0)
#define PORTMOD_PORT_ADD_F_TX_REPLACE_CRC_GET(info) ((info)->flags & PORTMOD_PORT_ADD_F_TX_REPLACE_CRC ? 1 : 0)
#define PORTMOD_PORT_ADD_F_TX_PASS_THROUGH_CRC_GET(info) ((info)->flags & PORTMOD_PORT_ADD_F_TX_PASS_THROUGH_CRC ? 1 : 0)
#define PORTMOD_PORT_ADD_F_EGR_1588_TIMESTAMP_MODE_48BIT_GET(info) ((info)->flags & PORTMOD_PORT_ADD_F_EGR_1588_TIMESTAMP_MODE_48BIT ? 1 : 0)
#define PORTMOD_PORT_ADD_F_INIT_CORE_PROBE_GET(info) ((info)->flags & PORTMOD_PORT_ADD_F_INIT_CORE_PROBE ? 1 : 0)
#define PORTMOD_PORT_ADD_F_PORT_ATTACH_EXT_PHY_SKIP_GET(info) ((info)->flags & PORTMOD_PORT_ADD_F_PORT_ATTACH_EXT_PHY_SKIP ? 1 : 0)
#define PORTMOD_PORT_ADD_F_ELK_GET(info) ((info)->flags & PORTMOD_PORT_ADD_F_ELK ? 1 : 0)
#define PORTMOD_PORT_ADD_F_SYS_16B_INTF_MODE_GET(info) ((info)->flags & PORTMOD_PORT_ADD_F_SYS_16B_INTF_MODE ? 1 : 0)
#define PORTMOD_PORT_ADD_F_AUTONEG_CONFIG_SKIP_GET(info) ((info)->flags & PORTMOD_PORT_ADD_F_AUTONEG_CONFIG_SKIP ? 1 : 0)
#define PORTMOD_PORT_ADD_F_FIRMWARE_DOWNLOAD_BCAST_GET(info) ((info)->flags & PORTMOD_PORT_ADD_F_FIRMWARE_DOWNLOAD_BCAST ? 1 : 0)
#define PORTMOD_PORT_ADD_F_SKIP_SPEED_INIT_GET(info) ((info)->flags & PORTMOD_PORT_ADD_F_SKIP_SPEED_INIT ? 1 : 0)
#define PORTMOD_PORT_ADD_F_IS_ENHANCED_PM4X25_GEN2_GET(info) ((info)->flags & PORTMOD_PORT_ADD_F_IS_ENHANCED_PM4X25_GEN2 ? 1 : 0)
#define PORTMOD_PORT_ADD_F_DEFAULT_OSR2P5_GET(info) ((info)->flags & PORTMOD_PORT_ADD_F_DEFAULT_OSR2P5 ? 1 : 0)
#define PORTMOD_PORT_ADD_F_PCS_BYPASSED_GET(info) ((info)->flags & PORTMOD_PORT_ADD_F_PCS_BYPASSED ? 1 : 0)
#define PORTMOD_PORT_ADD_F_BYPASS_FW_CRC_CHECK_GET(info) ((info)->flags & PORTMOD_PORT_ADD_F_BYPASS_FW_CRC_CHECK ? 1 : 0)
#define PORTMOD_PORT_ADD_F_FLEXE_CONFIG_GET(info) ((info)->flags & PORTMOD_PORT_ADD_F_FLEXE_CONFIG ? 1 : 0)
#define PORTMOD_PORT_ADD_F_FLEXE_TVCO_26G_CONFIG_GET(info) ((info)->flags & PORTMOD_PORT_ADD_F_FLEXE_TVCO_26G_CONFIG ? 1 : 0)

/*! 
 * @brief flag defines for the core init 
 */ 
#define PORTMOD_CORE_INIT_FLAG_INITIALZIED 0x1
#define PORTMOD_CORE_INIT_FLAG_FIRMWARE_LOADED 0x2 /**< enable/disable the MAC(RX/TX according to the flags) */
#define PORTMOD_CORE_INIT_FLAG_CPRI_CORE_INITIALZIED 0x4 /**< CPRI core is initialized */

#define PORTMOD_CORE_INIT_FLAG_INITIALZIED_SET(flag) ((flag) |= PORTMOD_CORE_INIT_FLAG_INITIALZIED)
#define PORTMOD_CORE_INIT_FLAG_FIRMWARE_LOADED_SET(flag) ((flag) |= PORTMOD_CORE_INIT_FLAG_FIRMWARE_LOADED)
#define PORTMOD_CORE_INIT_FLAG_CPRI_CORE_INITIALZIED_SET(flag) ((flag) |= PORTMOD_CORE_INIT_FLAG_CPRI_CORE_INITIALZIED)

#define PORTMOD_CORE_INIT_FLAG_INITIALZIED_CLR(flag) ((flag) &= ~PORTMOD_CORE_INIT_FLAG_INITIALZIED)
#define PORTMOD_CORE_INIT_FLAG_FIRMWARE_LOADED_CLR(flag) ((flag) &= ~PORTMOD_CORE_INIT_FLAG_FIRMWARE_LOADED)
#define PORTMOD_CORE_INIT_FLAG_CPRI_CORE_INITIALZIED_CLR(flag) ((flag) &= ~PORTMOD_CORE_INIT_FLAG_CPRI_CORE_INITIALZIED)

#define PORTMOD_CORE_INIT_FLAG_INITIALZIED_GET(flag) ((flag) & PORTMOD_CORE_INIT_FLAG_INITIALZIED ? 1 : 0)
#define PORTMOD_CORE_INIT_FLAG_FIRMWARE_LOADED_GET(flag) ((flag) & PORTMOD_CORE_INIT_FLAG_FIRMWARE_LOADED ? 1 : 0)
#define PORTMOD_CORE_INIT_FLAG_CPRI_CORE_INITIALZIED_GET(flag) ((flag) & PORTMOD_CORE_INIT_FLAG_CPRI_CORE_INITIALZIED ? 1 : 0)

#define PORTMOD_PORT_PHY_FEC_INVALID _SHR_PORT_PHY_FEC_INVALID
#define PORTMOD_PORT_PHY_FEC_NONE _SHR_PORT_PHY_FEC_NONE /**< no FEC */
#define PORTMOD_PORT_PHY_FEC_BASE_R _SHR_PORT_PHY_FEC_BASE_R /**< CL74/Base-R. 64/66b KR FEC for fabric */
#define PORTMOD_PORT_PHY_FEC_RS_FEC _SHR_PORT_PHY_FEC_RS_FEC /**< CL91/RS-FEC */
#define PORTMOD_PORT_PHY_FEC_RS_544 _SHR_PORT_PHY_FEC_RS_544 /**< Rs544, using 1xN RS FEC architecture */
#define PORTMOD_PORT_PHY_FEC_RS_272 _SHR_PORT_PHY_FEC_RS_272 /**< Rs272, using 1xN RS FEC architecture */
#define PORTMOD_PORT_PHY_FEC_RS_206 _SHR_PORT_PHY_FEC_RS_206 /**< Rs206. 64/66b 5T RS FEC for fabric */
#define PORTMOD_PORT_PHY_FEC_RS_108 _SHR_PORT_PHY_FEC_RS_108 /**< Rs108. 64/66b 5T low latency RS FEC for fabric */
#define PORTMOD_PORT_PHY_FEC_RS_545 _SHR_PORT_PHY_FEC_RS_545 /**< Rs545. 64/66b 15T RS FEC for fabric */
#define PORTMOD_PORT_PHY_FEC_RS_304 _SHR_PORT_PHY_FEC_RS_304 /**< Rs304. 64/66b 15T low latency RS FEC for fabric */
#define PORTMOD_PORT_PHY_FEC_RS_544_2XN _SHR_PORT_PHY_FEC_RS_544_2XN /**< Rs544, using 2xN RS FEC architecture */
#define PORTMOD_PORT_PHY_FEC_RS_272_2XN _SHR_PORT_PHY_FEC_RS_272_2XN /**< Rs272, using 2xN RS FEC architecture */
#define PORTMOD_PORT_PHY_FEC_FEC_COUNT  _SHR_PORT_PHY_FEC_COUNT /**< Fec type count */

#define PORTMOD_PORT_PHY_MEDIUM_COPPER _SHR_PORT_MEDIUM_COPPER
#define PORTMOD_PORT_PHY_MEDIUM_BACKPLANE _SHR_PORT_MEDIUM_BACKPLANE
#define PORTMOD_PORT_PHY_MEDIUM_ALL _SHR_PORT_MEDIUM_ALL

typedef _shr_port_medium_t portmod_port_medium_t;

#define PORTMOD_PORT_PHY_PAUSE_NONE _SHR_PORT_PHY_PAUSE_NONE
#define PORTMOD_PORT_PHY_PAUSE_TX _SHR_PORT_PHY_PAUSE_TX
#define PORTMOD_PORT_PHY_PAUSE_RX _SHR_PORT_PHY_PAUSE_RX
#define PORTMOD_PORT_PHY_PAUSE_SYMM _SHR_PORT_PHY_PAUSE_SYMM
#define PORTMOD_PORT_PHY_PAUSE_ALL _SHR_PORT_PHY_PAUSE_ALL

typedef _shr_port_phy_pause_t portmod_port_phy_pause_t;

#define PORTMOD_PORT_PHY_CHANNEL_SHORT _SHR_PORT_PHY_CHANNEL_SHORT
#define PORTMOD_PORT_PHY_CHANNEL_LONG _SHR_PORT_PHY_CHANNEL_LONG
#define PORTMOD_PORT_PHY_CHANNEL_ALL _SHR_PORT_PHY_CHANNEL_ALL

typedef _shr_port_phy_channel_t portmod_port_phy_channel_t;

#define PORTMOD_PORT_PHY_CONTROL_AUTONEG_MODE_CL73 _SHR_PORT_PHY_CONTROL_AUTONEG_MODE_CL73
#define PORTMOD_PORT_PHY_CONTROL_AUTONEG_MODE_CL73_BAM _SHR_PORT_PHY_CONTROL_AUTONEG_MODE_CL73_BAM
#define PORTMOD_PORT_PHY_CONTROL_AUTONEG_MODE_CL73_MSA _SHR_PORT_PHY_CONTROL_AUTONEG_MODE_CL73_MSA
#define PORTMOD_PORT_PHY_CONTROL_AUTONEG_MODE_NONE _SHR_PORT_PHY_CONTROL_AUTONEG_MODE_NONE

typedef _shr_port_phy_control_autoneg_mode_t portmod_port_phy_control_autoneg_mode_t;


/*!
 * @struct portmod_port_speed_ability_s
 * @brief This is the PORTMOD version of bcm_port_speed_ability_t 
 */ 
typedef struct portmod_port_speed_ability_s {
    uint32 speed; /**< port speed in Mbps */
    uint32 num_lanes; /**< number of lanes */
    portmod_fec_t fec_type; /**< FEC type */
    portmod_port_medium_t medium; /**< medium */
    portmod_port_phy_pause_t pause; /**< pause ability */
    portmod_port_phy_channel_t channel; /**< channel type */
    portmod_port_phy_control_autoneg_mode_t an_mode; /**< autoneg mode such as cl73, bam or msa */
} portmod_port_speed_ability_t;

/* portmod_port_speed_ability_t initialization and validation */
int portmod_port_speed_ability_t_validate(int unit, const portmod_port_speed_ability_t* portmod_port_speed_ability);
int portmod_port_speed_ability_t_init(int unit, portmod_port_speed_ability_t* portmod_port_speed_ability);

/*! 
 * portmod_port_speed_ability_local_get
 *
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  max_num_abilities   - 
 * @param [out]  abilities       - 
 * @param [out]  num_abilities   - 
 */
int portmod_port_speed_ability_local_get(int unit, int port, int max_num_abilities, portmod_port_speed_ability_t* abilities, int* num_abilities);

/*! 
 * @brief Speed Config Flags 
 */ 
#define PORTMOD_SPEED_CONFIG_F_SKIP_FEC_CONFIGURATION 0x1 /**< don't set FEC configuration */

#define PORTMOD_SPEED_CONFIG_F_SKIP_FEC_CONFIGURATION_SET(speed_config) ((speed_config)->flags |= PORTMOD_SPEED_CONFIG_F_SKIP_FEC_CONFIGURATION)

#define PORTMOD_SPEED_CONFIG_F_SKIP_FEC_CONFIGURATION_CLR(speed_config) ((speed_config)->flags &= ~PORTMOD_SPEED_CONFIG_F_SKIP_FEC_CONFIGURATION)

#define PORTMOD_SPEED_CONFIG_F_SKIP_FEC_CONFIGURATION_GET(speed_config) ((speed_config)->flags & PORTMOD_SPEED_CONFIG_F_SKIP_FEC_CONFIGURATION ? 1 : 0)

typedef struct portmod_speed_config_s {
    int speed; /**< Port speed */
    int num_lane; /**< Number of lanes of the port */
    portmod_fec_t fec; /**< Fec type */
    int link_training; /**< Link training */
    int lane_config; /**< PMD lane configuration */
    uint32 flags; /**< Flags */
} portmod_speed_config_t;

/* portmod_speed_config_t initialization and validation */
int portmod_speed_config_t_validate(int unit, const portmod_speed_config_t* portmod_speed_config);
int portmod_speed_config_t_init(int unit, portmod_speed_config_t* portmod_speed_config);


/*!
 * @enum portmod_vco_type_e
 * @brief List of available VCOs for PM 
 */ 
typedef enum portmod_vco_type_e {
    portmodVCOInvalid = 0,
    portmodVCO20G = 1,
    portmodVCO21G = 2,
    portmodVCO25G = 3,
    portmodVCO26G = 4,
    portmodVCO27G = 5,
    portmodVCO20P625G = 6,
    portmodVCO20P937G = 7,
    portmodVCO22P5G = 8,
    portmodVCO23G = 9,
    portmodVCO25P781G = 11,
    portmodVCO26P562G = 12,
    portmodVCO6P25G = 13,
    portmodVCO6P5625G = 14,
    portmodVCO8P125G = 15,
    portmodVCO9P735G = 16,
    portmodVCO10G = 17,
    portmodVCO10P3125G = 18,
    portmodVCO10P9375G = 19,
    portmodVCO12P5G = 20,
    portmodVCO27P343G = 21,
    portmodVCO28P125G = 22,
    portmodVCO19P660G = 23,
    portmodVCO20P275G = 24,
    portmodVCO24P330G = 25,
    portmodVCO24P576G = 26,
    portmodVCOCount
} portmod_vco_type_t;

#ifdef PORTMOD_DIAG
extern enum_mapping_t portmod_vco_type_t_mapping[];
#endif /*PORTMOD_DIAG*/

/* portmod_vco_type_t validation */
int portmod_vco_type_t_validate(int unit, portmod_vco_type_t portmod_vco_type);
/*! 
 * portmod_ilkn_port_lane_map_callback_get_f
 *
 * @brief Callback function to get the ILKN core lane map info 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  nof_lanes       - Max lanes for this ILKN core
 * @param [out]  rx_lane_map     - Rx logical to physical mapping info
 * @param [out]  tx_lane_map     - Tx logcial to physical mapping info
 */
typedef int (*portmod_ilkn_port_lane_map_callback_get_f)(int unit, int port, int nof_lanes, int* rx_lane_map, int* tx_lane_map);

/*! 
 * portmod_ilkn_pm_lane_map_callback_get_f
 *
 * @brief Callback function to get the ILKN PM lane map info 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  nof_lanes       - Number of lanes for this ILKN PM
 * @param [in]  first_phy       - lower phy in the pm
 * @param [out]  lane_map        - physical mapping info
 */
typedef int (*portmod_ilkn_pm_lane_map_callback_get_f)(int unit, int port, int nof_lanes, int first_phy, phymod_lane_map_t* lane_map);

/*! 
 * portmod_ilkn_port_fec_units_set_callback_f
 *
 * @brief Callback function to set the ILKN port FEC units 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  is_reset        - indicates if FEC units need to be reset (in case of port remove)
 * @param [in]  fec_enable      - enable or disable fec for this port
 * @param [in]  fec_bypass_valid   - indicates if FEC bypass should be configured
 * @param [in]  fec_bypass_enable   - enable or disable fec bypass for this port
 */
typedef int (*portmod_ilkn_port_fec_units_set_callback_f)(int unit, int port, int is_reset, int fec_enable, int fec_bypass_valid, int fec_bypass_enable);


/*!
 * @struct portmod_pm_identifier_s
 * @brief This struct defines specific PM 
 */ 
typedef struct portmod_pm_identifier_s {
    portmod_dispatch_type_t type; /**< PM type */
    int phy; /**< First PHY of the PM */
} portmod_pm_identifier_t;

/* portmod_pm_identifier_t initialization and validation */
int portmod_pm_identifier_t_validate(int unit, const portmod_pm_identifier_t* portmod_pm_identifier);
int portmod_pm_identifier_t_init(int unit, portmod_pm_identifier_t* portmod_pm_identifier);

typedef struct portmod_port_add_info_s {
    portmod_port_interface_config_t interface_config;
    portmod_port_init_config_t init_config;
    portmod_speed_config_t speed_config; /**< used for TSCBH */
    portmod_vco_type_t tvco;
    portmod_vco_type_t ovco;
    portmod_pbmp_t phys;
    portmod_pbmp_t phy_ports; /**< phys with qsgmii offsets. to be removed */
    int sub_phy; /**< qsgmii only; Sub PHY index */
    uint8 autoneg_en;
    uint8 link_training_en;
    uint32 flags; /**< port add flags */
    uint32 is_fabric_o_nif; /**< dnx fabric over nif. fabric port is over nif serdes */
    uint32 ilkn_core_id; /**< ilkn only. core id (0-1) */
    uint32 ilkn_port_is_over_fabric; /**< ilkn only. port is over fabric serdes or nif */
    int ilkn_burst_max; /**< ilkn only. burst_max value. */
    int ilkn_burst_min; /**< ilkn only. burst_min value. */
    int ilkn_burst_short; /**< ilkn only. burst_short value. */
    int ilkn_nof_segments; /**< ilkn only. nof_segmnets value. */
    int ilkn_metaframe_period; /**< ilkn only. metaframe sync period value. */
    uint32 rx_retransmit; /**< rx retransmit enable */
    uint32 tx_retransmit; /**< tx retransmit enable */
    phymod_operation_mode_t phy_op_mode; /**< ext phy operation mode. */
    phymod_datapath_t phy_op_datapath; /**< ext phy data path mode (e.g. ULL ultra low latency. */
    int ilkn_inb_cal_len_rx; /**< calendar length for ILKN INB */
    int ilkn_inb_cal_len_tx; /**< calendar length for ILKN INB */
    int ilkn_oob_cal_len_rx; /**< calendar length for ILKN OOB */
    int ilkn_oob_cal_len_tx; /**< calendar length for ILKN OOB */
    uint32 reserved_channel_rx; /**< reserved channel id for rx retransmit */
    uint32 reserved_channel_tx; /**< reserved channel id for tx retransmit */
    portmod_pbmp_t ilkn_lanes;
    int nof_aggregated_pms; /**< Number of PMs controlled by this ILKN PM */
    portmod_pm_identifier_t controlled_pms[PORTMOD_MAX_ILKN_AGGREGATED_PMS]; /**< Array of PMs controlled by this ILKN PM */
} portmod_port_add_info_t;

/* portmod_port_add_info_t initialization and validation */
int portmod_port_add_info_t_validate(int unit, const portmod_port_add_info_t* portmod_port_add_info);
int portmod_port_add_info_t_init(int unit, portmod_port_add_info_t* portmod_port_add_info);


/*!
 * @struct portmod_dnx_fabric_create_info_s
 * @brief Dune Fabric PM specific information required for PM add API. 
 */ 
typedef struct portmod_dnx_fabric_create_info_s {
    phymod_ref_clk_t ref_clk; /**< SerDes quad ref clock */
    phymod_ref_clk_t com_clk; /**< SerDes quad common clock */
    phymod_access_t access; /**< phymod access structure; defines the register access for the SerDes Core */
    phymod_lane_map_t lane_map;
    phymod_firmware_load_method_t fw_load_method;
    phymod_firmware_loader_f external_fw_loader; /**< firmware loader that will be used in case that fw_load_method=phymodFirmwareLoadMethodExternal */
    phymod_polarity_t polarity; /**< Lanes Polarity */
    int fmac_schan_id; /**< FMAC schan id */
    int fsrd_schan_id; /**< FSRD schan id */
    int fsrd_internal_quad; /**< Core instance in FSRD */
    int first_phy_offset; /**< offset for phy index get */
    int core_index; /**< core index */
    int is_over_nif; /**< is fabric pm over nif */
    portmod_pm_identifier_t fabric_o_nif_pm; /**< PM used for fabric over nif */
} portmod_dnx_fabric_create_info_t;

/* portmod_dnx_fabric_create_info_t initialization and validation */
int portmod_dnx_fabric_create_info_t_validate(int unit, const portmod_dnx_fabric_create_info_t* portmod_dnx_fabric_create_info);
int portmod_dnx_fabric_create_info_t_init(int unit, portmod_dnx_fabric_create_info_t* portmod_dnx_fabric_create_info);

#define PORTMOD_NOF_FMACS_PER_PM8X50_FABRIC (2)

#define PORTMOD_NOF_WORDS_PER_PM8X50_FABRIC_LANES_BITMAP (1)


/*!
 * @struct portmod_pm8x50_fabric_create_info_s
 * @brief Dune Fabric PM specific information required for PM add API. 
 */ 
typedef struct portmod_pm8x50_fabric_create_info_s {
    phymod_ref_clk_t ref_clk; /**< SerDes quad ref clock */
    phymod_access_t access; /**< phymod access structure; defines the register access for the SerDes Core */
    phymod_firmware_load_method_t fw_load_method;
    phymod_firmware_loader_f external_fw_loader; /**< firmware loader that will be used in case that fw_load_method=phymodFirmwareLoadMethodExternal */
    phymod_polarity_t polarity; /**< Lanes Polarity */
    int fmac_schan_id[PORTMOD_NOF_FMACS_PER_PM8X50_FABRIC]; /**< FMACs schan ids */
    int fsrd_schan_id; /**< FSRD schan id */
    int first_phy_offset; /**< offset for phy index get */
    int core_index; /**< core index */
    uint32 force_single_pll0; /**< only PLL 0 can be used in this core */
    uint32 force_single_pll1; /**< only PLL 1 can be used in this core */
    uint32 bypass_lanes_bitmap[PORTMOD_NOF_WORDS_PER_PM8X50_FABRIC_LANES_BITMAP]; /**< bitmap containing the bypass lanes of the pm */
    int is_rx_ctrl_bypass_supported; /**< Is rx control bypass supported */
    int clock_buffer_disable_required; /**< Is unused clock repeater buffer required to be powered down */
    int clock_buffer_bw_update_required; /**< Is PLL0 RX clock buffer bandwidth required to be updated */
    int native_single_pll; /**< PMD has only one single PLL */
} portmod_pm8x50_fabric_create_info_t;

/* portmod_pm8x50_fabric_create_info_t initialization and validation */
int portmod_pm8x50_fabric_create_info_t_validate(int unit, const portmod_pm8x50_fabric_create_info_t* portmod_pm8x50_fabric_create_info);
int portmod_pm8x50_fabric_create_info_t_init(int unit, portmod_pm8x50_fabric_create_info_t* portmod_pm8x50_fabric_create_info);


/*!
 * @enum portmod_call_back_action_type_e
 * @brief Psuedo Random Bit Stream (PRBS) modes  
 */ 
typedef enum portmod_call_back_action_type_e {
    portmodCallBackActionTypePre = 0,
    portmodCallBackActionTypeDuring = 1,
    portmodCallBackActionTypePost = 2,
    portmodCallBackActionTypeCount
} portmod_call_back_action_type_t;

#ifdef PORTMOD_DIAG
extern enum_mapping_t portmod_call_back_action_type_t_mapping[];
#endif /*PORTMOD_DIAG*/

/* portmod_call_back_action_type_t validation */
int portmod_call_back_action_type_t_validate(int unit, portmod_call_back_action_type_t portmod_call_back_action_type);

/*!
 * @enum portmod_intr_type_e
 * @brief Interrupt types 
 */ 
typedef enum portmod_intr_type_e {
    portmodIntrTypeMibTxMemErr = 0, /**< clmac/xlmac mib Tx err */
    portmodIntrTypeMibRxMemErr = 1, /**< clmac/xlmac mib Rx err */
    portmodIntrTypeMacTxCdcMemErr = 2, /**< clmac/xlmac tx CDC */
    portmodIntrTypeMacRxCdcMemErr = 3, /**< clmac/xlmac Rx CDC */
    portmodIntrTypeMacRxTsCdcMemErr = 4, /**< clmac/xlmac Rx TS CDC err */
    portmodIntrTypeTscErr = 5, /**< clmac TSC err */
    portmodIntrTypePmdErr = 6, /**< clmac PMD err */
    portmodIntrTypeRxFcReqFull = 7, /**< 100G CXX Flow Control Req */
    portmodIntrTypeCore0Intr = 8, /**< 100G core-0 irq */
    portmodIntrTypeCore1Intr = 9, /**< 100G core-1 irq */
    portmodIntrTypeCore2Intr = 10, /**< 100G core-2 irq */
    portmodIntrTypeCore3Intr = 11, /**< 100G core-3 irq */
    portmodIntrTypeTsc0Intr = 12, /**< 100G Tsc-0 irq */
    portmodIntrTypeTsc1Intr = 13, /**< 100G Tsc-1 irq */
    portmodIntrTypeTsc2Intr = 14, /**< 100G Tsc-2 irq */
    portmodIntrTypeLinkdown = 15, /**< Link down */
    portmodIntrTypeMacErr = 16, /**< MAC error */
    portmodIntrTypeTxPktUnderflow = 17, /**< MAC tx packet fifo underflow */
    portmodIntrTypeTxPktOverflow = 18, /**< MAC tx packet fifo overflow */
    portmodIntrTypeTxLlfcMsgOverflow = 19, /**< MAC TX LLFC message fifo overflow */
    portmodIntrTypeTxTSFifoOverflow = 20, /**< Overflow in TX two-step Time Stamp FIFO */
    portmodIntrTypeRxPktOverflow = 21, /**< MAC RX packet fifo overflow */
    portmodIntrTypeRxMsgOverflow = 22, /**< MAC RX message fifo overflow */
    portmodIntrTypeTxCdcSingleBitErr = 23, /**< Single bit error in the MAC Tx CDC memory */
    portmodIntrTypeTxCdcDoubleBitErr = 24, /**< Double bit error in the MAC Tx CDC memory */
    portmodIntrTypeRxCdcSingleBitErr = 25, /**< Single bit error in the MAC Rx CDC memory */
    portmodIntrTypeRxCdcDoubleBitErr = 26, /**< Double bit error in the MAC Rx CDC memory */
    portmodIntrTypeRxTsMemSingleBitErr = 27, /**< Single bit error in the MAC Rx Timestamp memory */
    portmodIntrTypeRxTsMemDoubleBitErr = 28, /**< Double bit error in the MAC Rx Timestamp memory */
    portmodIntrTypeLocalFaultStatus = 29, /**< Local fault by RS layer */
    portmodIntrTypeRemoteFaultStatus = 30, /**< Remote fault by RS layer */
    portmodIntrTypeLinkInterruptionStatus = 31, /**< Link interruption by RS layer */
    portmodIntrTypeTsEntryValid = 32, /**< TimeStamp */
    portmodIntrTypeMibMemSingleBitErr = 33, /**< single-bit error in the MIB statistics counter memory in CDMAC */
    portmodIntrTypeMibMemDoubleBitErr = 34, /**< double-bit error in the MIB statistics counter memory in CDMAC */
    portmodIntrTypeMibMemMultipleBitErr = 35, /**< multiple-bit error in the MIB statistics counter memory in CDMAC */
    portmodIntrTypeTscCore0Err = 36, /**< Error occurred on TSC core (also called MPP) 0 of CDPORT */
    portmodIntrTypeTscCore1Err = 37, /**< Error occurred on TSC core (also called MPP) 1 of CDPORT */
    portmodIntrTypeFcReqFull = 38, /**< When set per subport 7:0, PM8x50 accumulates more than 2 Rx pfc outstanding requests from MAC or 2 Tx outstanding pfc requests. */
    portmodIntrTypeCount
} portmod_intr_type_t;

#ifdef PORTMOD_DIAG
extern enum_mapping_t portmod_intr_type_t_mapping[];
#endif /*PORTMOD_DIAG*/

/* portmod_intr_type_t validation */
int portmod_intr_type_t_validate(int unit, portmod_intr_type_t portmod_intr_type);
/*! 
 * portmod_mac_soft_reset_f
 *
 * @brief external reset function 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  action          - when is this callback called
 */
typedef int (*portmod_mac_soft_reset_f)(int unit, int port, portmod_call_back_action_type_t action);


/*!
 * @struct portmod_pm4x25_create_info_s
 * @brief PM4X25 specific information required for PM add API. 
 */ 
typedef struct portmod_pm4x25_create_info_s {
    phymod_ref_clk_t ref_clk; /**< SerDes quad ref clock */
    phymod_access_t access; /**< phymod access structure; defines the register access for the SerDes Core */
    phymod_lane_map_t lane_map;
    phymod_firmware_load_method_t fw_load_method;
    phymod_firmware_loader_f external_fw_loader; /**< firmware loader that will be used in case that fw_load_method=phymodFirmwareLoadMethodExternal */
    phymod_polarity_t polarity; /**< Lanes Polarity */
    uint8 in_pm_12x10; /**< is the PM part of a PM12x10 block */
    int core_num;
    int core_num_int;
    portmod_mac_soft_reset_f portmod_mac_soft_reset; /**< used when soft reset require external method. */
    phymod_afe_pll_t afe_pll; /**< override default value of AFE/PLL reg. */
    int rescal;
    portmod_port_mode_aux_info_t port_mode_aux_info; /**< auxiliary info for assigning the core port mode */
} portmod_pm4x25_create_info_t;

/* portmod_pm4x25_create_info_t initialization and validation */
int portmod_pm4x25_create_info_t_validate(int unit, const portmod_pm4x25_create_info_t* portmod_pm4x25_create_info);
int portmod_pm4x25_create_info_t_init(int unit, portmod_pm4x25_create_info_t* portmod_pm4x25_create_info);

/*! 
 * portmod_phy_external_reset_f
 *
 * @brief external reset function 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  in_reset        - whether to put phy in\out reset
 */
typedef int (*portmod_phy_external_reset_f)(int unit, int port, uint32 in_reset);


/*!
 * @struct portmod_pm4x10_create_info_s
 * @brief PM4X10 specific information required for PM add API. 
 */ 
typedef struct portmod_pm4x10_create_info_s {
    portmod_pbmp_t phy_ports; /**< phys with qsgmii offsets. to be removed */
    phymod_ref_clk_t ref_clk; /**< SerDes quad ref clock */
    phymod_access_t access; /**< phymod access structure; defines the register access for the SerDes Core */
    phymod_lane_map_t lane_map;
    phymod_firmware_load_method_t fw_load_method;
    phymod_firmware_loader_f external_fw_loader; /**< firmware loader that will be used in case that fw_load_method=phymodFirmwareLoadMethodExternal */
    phymod_polarity_t polarity; /**< Lanes Polarity */
    uint8 in_pm_12x10; /**< is the PM part of a PM12x10 block */
    portmod_phy_external_reset_f portmod_phy_external_reset; /**< used when phy required external method to be taken oor */
    portmod_mac_soft_reset_f portmod_mac_soft_reset; /**< used when soft reset require external method. */
    int core_num;
    int core_num_int;
    portmod_port_mode_aux_info_t port_mode_aux_info; /**< auxiliary info for assigning the core port mode */
    int rescal;
    int is_pm4x10q;
} portmod_pm4x10_create_info_t;

/* portmod_pm4x10_create_info_t initialization and validation */
int portmod_pm4x10_create_info_t_validate(int unit, const portmod_pm4x10_create_info_t* portmod_pm4x10_create_info);
int portmod_pm4x10_create_info_t_init(int unit, portmod_pm4x10_create_info_t* portmod_pm4x10_create_info);


/*!
 * @struct portmod_pm_qtc_create_info_s
 * @brief PM_QTC specific information required for PM add API. 
 */ 
typedef struct portmod_pm_qtc_create_info_s {
    phymod_ref_clk_t ref_clk; /**< SerDes quad ref clock */
    phymod_access_t access; /**< phymod access structure; defines the register access for the SerDes Core */
    phymod_lane_map_t lane_map;
    phymod_firmware_load_method_t fw_load_method;
    phymod_firmware_loader_f external_fw_loader; /**< firmware loader that will be used in case that fw_load_method=phymodFirmwareLoadMethodExternal */
    phymod_polarity_t polarity; /**< Lanes Polarity */
    portmod_phy_external_reset_f portmod_phy_external_reset; /**< used when phy required external method to be taken oor */
    portmod_mac_soft_reset_f portmod_mac_soft_reset; /**< used when soft reset require external method. */
    int core_num;
    uint32 core_clock_khz; /**< core clock Khz */
} portmod_pm_qtc_create_info_t;

/* portmod_pm_qtc_create_info_t initialization and validation */
int portmod_pm_qtc_create_info_t_validate(int unit, const portmod_pm_qtc_create_info_t* portmod_pm_qtc_create_info);
int portmod_pm_qtc_create_info_t_init(int unit, portmod_pm_qtc_create_info_t* portmod_pm_qtc_create_info);


/*!
 * @struct portmod_pm_gphy_create_info_s
 * @brief PM4X10 specific information required for PM add API. 
 */ 
typedef struct portmod_pm_gphy_create_info_s {
    phymod_ref_clk_t ref_clk; /**< SerDes quad ref clock */
    phymod_access_t access; /**< phymod access structure; defines the register access for the SerDes Core */
    phymod_lane_map_t lane_map;
    phymod_firmware_load_method_t fw_load_method;
    phymod_firmware_loader_f external_fw_loader; /**< firmware loader that will be used in case that fw_load_method=phymodFirmwareLoadMethodExternal */
    phymod_polarity_t polarity; /**< Lanes Polarity */
    portmod_phy_external_reset_f portmod_phy_external_reset; /**< used when phy required external method to be taken oor */
    portmod_mac_soft_reset_f portmod_mac_soft_reset; /**< used when soft reset require external method. */
    int core_num;
} portmod_pm_gphy_create_info_t;

/* portmod_pm_gphy_create_info_t initialization and validation */
int portmod_pm_gphy_create_info_t_validate(int unit, const portmod_pm_gphy_create_info_t* portmod_pm_gphy_create_info);
int portmod_pm_gphy_create_info_t_init(int unit, portmod_pm_gphy_create_info_t* portmod_pm_gphy_create_info);

/*! 
 * @brief Flags for adding PM12x10 
 */ 
#define PORTMOD_PM12x10_F_EXTERNAL_TOP_MODE 0x1 /**< Each PM4x10 handles its own access (use for default access/fw load functions) */
#define PORTMOD_PM12x10_F_USE_PM_TD 0x2 /**< Use TD version of PM4x25, PM4x10 */
#define PORTMOD_PM12x10_F_USE_PM_XGS 0x4 /**< Use XGS version PM12x10 */

#define PORTMOD_PM12x10_F_EXTERNAL_TOP_MODE_SET(flags) ((flags) |= PORTMOD_PM12x10_F_EXTERNAL_TOP_MODE)
#define PORTMOD_PM12x10_F_USE_PM_TD_SET(flags) ((flags) |= PORTMOD_PM12x10_F_USE_PM_TD)
#define PORTMOD_PM12x10_F_USE_PM_XGS_SET(flags) ((flags) |= PORTMOD_PM12x10_F_USE_PM_XGS)

#define PORTMOD_PM12x10_F_EXTERNAL_TOP_MODE_CLR(flags) ((flags) &= ~PORTMOD_PM12x10_F_EXTERNAL_TOP_MODE)
#define PORTMOD_PM12x10_F_USE_PM_TD_CLR(flags) ((flags) &= ~PORTMOD_PM12x10_F_USE_PM_TD)
#define PORTMOD_PM12x10_F_USE_PM_XGS_CLR(flags) ((flags) &= ~PORTMOD_PM12x10_F_USE_PM_XGS)

#define PORTMOD_PM12x10_F_EXTERNAL_TOP_MODE_GET(flags) ((flags) & PORTMOD_PM12x10_F_EXTERNAL_TOP_MODE ? 1 : 0)
#define PORTMOD_PM12x10_F_USE_PM_TD_GET(flags) ((flags) & PORTMOD_PM12x10_F_USE_PM_TD ? 1 : 0)
#define PORTMOD_PM12x10_F_USE_PM_XGS_GET(flags) ((flags) & PORTMOD_PM12x10_F_USE_PM_XGS ? 1 : 0)


/*!
 * @struct portmod_pm12x10_create_info_s
 * @brief PM12X10 specific information required for PM add API. 
 */ 
typedef struct portmod_pm12x10_create_info_s {
    portmod_pm4x10_create_info_t pm4x10_infos[3]; /**< initialization information for the three pm4x10 in the pm12x10 */
    portmod_pm4x25_create_info_t pm4x25_info;
    uint32 flags; /**< see PORTMOD_PM12x10_F_ */
    int blk_id; /**< block id of PM12x10 */
    int refclk_source; /**< select which quad in pm12x10 is refclk source for other 2 quads */
} portmod_pm12x10_create_info_t;

/* portmod_pm12x10_create_info_t initialization and validation */
int portmod_pm12x10_create_info_t_validate(int unit, const portmod_pm12x10_create_info_t* portmod_pm12x10_create_info);
int portmod_pm12x10_create_info_t_init(int unit, portmod_pm12x10_create_info_t* portmod_pm12x10_create_info);


/*!
 * @struct portmod_pm4x10q_create_info_s
 * @brief PM4X10Q specific information required for PM add API. 
 */ 
typedef struct portmod_pm4x10q_create_info_s {
    portmod_pm4x10_create_info_t pm4x10_info; /**< initialization information for the pm4x10 in the pm4x10Q */
    uint32 blk_id; /**< PMQ block id */
    void* qsgmii_user_acc; /**< qsgmii_access */
    uint32 core_clock_khz; /**< core clock Khz */
} portmod_pm4x10q_create_info_t;

/* portmod_pm4x10q_create_info_t initialization and validation */
int portmod_pm4x10q_create_info_t_validate(int unit, const portmod_pm4x10q_create_info_t* portmod_pm4x10q_create_info);
int portmod_pm4x10q_create_info_t_init(int unit, portmod_pm4x10q_create_info_t* portmod_pm4x10q_create_info);

#define PORTMOD_MAX_ILKN_PORTS_PER_ILKN_PM (2)


/*!
 * @struct portmod_ilkn_os_create_info_s
 * @brief Open Silicon ILKN information required for PM add API. 
 */ 
typedef struct portmod_ilkn_os_create_info_s {
    int nof_aggregated_pms; /**< Number of PMs controlled by this ILKN PM */
    portmod_pm_identifier_t* controlled_pms; /**< Array of PMs controlled by this ILKN PM */
    int wm_high[PORTMOD_MAX_ILKN_PORTS_PER_ILKN_PM]; /**< Tx fifo watermark high value for each port in the ILKN core */
    int wm_low[PORTMOD_MAX_ILKN_PORTS_PER_ILKN_PM]; /**< Tx fifo watermark low value for each port in the ILKN core */
    uint32 core_clock_khz; /**< core clock Khz */
    portmod_ilkn_port_lane_map_callback_get_f ilkn_port_lane_map_get; /**< ilkn port lane map get function */
    portmod_ilkn_pm_lane_map_callback_get_f ilkn_pm_lane_map_get; /**< ilkn pm lane map get function */
    portmod_ilkn_port_fec_units_set_callback_f ilkn_port_fec_units_set; /**< ilkn port fec units set function */
    uint32 ilkn_block_index; /**< ilkn interface block Index */
    uint32 fec_disable_by_bypass; /**< FEC is disabled by setting FEC bypass */
} portmod_ilkn_os_create_info_t;

/* portmod_ilkn_os_create_info_t initialization and validation */
int portmod_ilkn_os_create_info_t_validate(int unit, const portmod_ilkn_os_create_info_t* portmod_ilkn_os_create_info);
int portmod_ilkn_os_create_info_t_init(int unit, portmod_ilkn_os_create_info_t* portmod_ilkn_os_create_info);


/*!
 * @struct portmod_pm4x2p5_create_info_s
 * @brief PM4X2P5 specific information required for PM add API. 
 */ 
typedef struct portmod_pm4x2p5_create_info_s {
    soc_pbmp_t phy_ports; /**< phys with qsgmii offsets. to be removed */
    phymod_ref_clk_t ref_clk; /**< SerDes quad ref clock */
    phymod_access_t access; /**< phymod access structure; defines the register access for the SerDes Core */
    phymod_lane_map_t lane_map;
    phymod_firmware_load_method_t fw_load_method;
    phymod_firmware_loader_f external_fw_loader; /**< firmware loader that will be used in case that fw_load_method=phymodFirmwareLoadMethodExternal */
    phymod_polarity_t polarity; /**< Lanes Polarity */
    portmod_phy_external_reset_f portmod_phy_external_reset; /**< used when phy required external method to be taken oor */
    portmod_mac_soft_reset_f portmod_mac_soft_reset; /**< used when soft reset require external method. */
} portmod_pm4x2p5_create_info_t;

/* portmod_pm4x2p5_create_info_t initialization and validation */
int portmod_pm4x2p5_create_info_t_validate(int unit, const portmod_pm4x2p5_create_info_t* portmod_pm4x2p5_create_info);
int portmod_pm4x2p5_create_info_t_init(int unit, portmod_pm4x2p5_create_info_t* portmod_pm4x2p5_create_info);

/*! 
 * portmod_egress_buffer_reset_f
 *
 * @brief external egress reset function 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
typedef int (*portmod_egress_buffer_reset_f)(int unit, int port);


/*!
 * @struct portmod_pm8x50_create_info_s
 * @brief PM8X50 specific information required for PM add API. 
 */ 
typedef struct portmod_pm8x50_create_info_s {
    soc_pbmp_t phy_ports; /**< list of physical ports in PM */
    phymod_ref_clk_t ref_clk; /**< Ref clock 156Mhz etc */
    portmod_vco_type_t tvco; /**< VCO value to be used by PLL1 */
    portmod_vco_type_t ovco; /**< VCO value to be used by PLL0 */
    phymod_phy_access_t access; /**< phymod phy access structure; defines the register access for the SerDes Core */
    phymod_lane_map_t lane_map;
    phymod_firmware_load_method_t fw_load_method;
    phymod_firmware_loader_f external_fw_loader; /**< firmware loader that will be used in case that fw_load_method=phymodFirmwareLoadMethodExternal */
    phymod_polarity_t polarity; /**< Lanes Polarity */
    portmod_phy_external_reset_f portmod_phy_external_reset; /**< used when phy required external method to be taken oor */
    portmod_mac_soft_reset_f portmod_mac_soft_reset; /**< used when soft reset require external method. */
    int core_num;
    phymod_afe_pll_t afe_pll; /**< override default value of AFE/PLL reg. */
    int rescal;
    int is_master_pm;
    portmod_egress_buffer_reset_f portmod_egress_buffer_reset; /**< for 400G AN WAR */
    int allow_20p625g_tvco;
    int single_vco_used_by_ports; /**< Is PM limited to assign ports to a single VCO */
    int clock_buffer_disable_required; /**< Is unused clock repeater buffer required to be powered down */
    int clock_buffer_bw_update_required; /**< Is PLL0 RX clock buffer bandwidth required to be updated */
    uint32 pm_offset; /**< The delay from CMIC to PCS in nanoseconds. */
} portmod_pm8x50_create_info_t;

/* portmod_pm8x50_create_info_t initialization and validation */
int portmod_pm8x50_create_info_t_validate(int unit, const portmod_pm8x50_create_info_t* portmod_pm8x50_create_info);
int portmod_pm8x50_create_info_t_init(int unit, portmod_pm8x50_create_info_t* portmod_pm8x50_create_info);


/*!
 * @struct portmod_pm4x10_qtc_create_info_s
 * @brief PM4x10_qtc specific information required for PM add API. 
 */ 
typedef struct portmod_pm4x10_qtc_create_info_s {
    portmod_pm4x10_create_info_t pm4x10_info; /**< initialization information for pm4x10 in the pm4x10_qtc */
    portmod_pm_qtc_create_info_t pm_qtc_info; /**< initialization information for pm_qtc in the pm4x10_qtc */
} portmod_pm4x10_qtc_create_info_t;

/* portmod_pm4x10_qtc_create_info_t initialization and validation */
int portmod_pm4x10_qtc_create_info_t_validate(int unit, const portmod_pm4x10_qtc_create_info_t* portmod_pm4x10_qtc_create_info);
int portmod_pm4x10_qtc_create_info_t_init(int unit, portmod_pm4x10_qtc_create_info_t* portmod_pm4x10_qtc_create_info);

typedef union portmod_pm_specific_create_info_u {
    portmod_pm4x10_create_info_t pm4x10;
    portmod_pm4x10q_create_info_t pm4x10q;
    portmod_pm_qtc_create_info_t pm_qtc;
    portmod_pm_gphy_create_info_t pm_gphy;
    portmod_pm4x25_create_info_t pm4x25;
    portmod_pm12x10_create_info_t pm12x10;
    portmod_ilkn_os_create_info_t os_ilkn;
    portmod_dnx_fabric_create_info_t dnx_fabric;
    portmod_pm8x50_fabric_create_info_t pm8x50_fabric;
    portmod_pm4x2p5_create_info_t pm4x2p5;
    portmod_pm8x50_create_info_t pm8x50;
    portmod_pm4x10_qtc_create_info_t pm4x10_qtc;
} portmod_pm_specific_create_info_t;


/*!
 * @struct portmod_remote_fault_control_s
 * @brief  This struct contains the parameters that  
 */ 
typedef struct portmod_remote_fault_control_s {
    uint8 enable; /**< enable/disable processing of local fault messages */
    uint8 drop_tx_on_fault; /**< drop tx data in case of fault */
} portmod_remote_fault_control_t;

/* portmod_remote_fault_control_t initialization and validation */
int portmod_remote_fault_control_t_validate(int unit, const portmod_remote_fault_control_t* portmod_remote_fault_control);
int portmod_remote_fault_control_t_init(int unit, portmod_remote_fault_control_t* portmod_remote_fault_control);

typedef struct portmod_local_fault_control_s {
    uint8 enable; /**< enable/disable processing of remote fault messages */
    uint8 drop_tx_on_fault; /**< drop tx data in case of fault */
} portmod_local_fault_control_t;

/* portmod_local_fault_control_t initialization and validation */
int portmod_local_fault_control_t_validate(int unit, const portmod_local_fault_control_t* portmod_local_fault_control);
int portmod_local_fault_control_t_init(int unit, portmod_local_fault_control_t* portmod_local_fault_control);


/*!
 * @struct portmod_llfc_control_s
 * @brief  link level flow control configuration 
 */ 
typedef struct portmod_llfc_control_s {
    uint8 rx_enable; /**< enable LLFX in RX path */
    uint8 tx_enable; /**< enable LLFX in TX path */
    uint8 crc_ignore;
    uint8 in_ipg_only; /**< llfc messages will be inserted only during IPG */
} portmod_llfc_control_t;

/* portmod_llfc_control_t initialization and validation */
int portmod_llfc_control_t_validate(int unit, const portmod_llfc_control_t* portmod_llfc_control);
int portmod_llfc_control_t_init(int unit, portmod_llfc_control_t* portmod_llfc_control);


/*!
 * @struct portmod_pfc_control_s
 * @brief  priority flow control configuration 
 */ 
typedef struct portmod_pfc_control_s {
    uint8 rx_enable;
    uint8 tx_enable;
    uint8 stats_en; /**< enable PFC counters */
    uint8 force_xon; /**< Instructs MAC to send Xon message to all classes of service */
    int refresh_timer; /**< use 0 for disable this feature; Threshold for pause timer to cause XOFF to be resent */
    int xoff_timer; /**< Time value sent in the Timer Field for classes in XOFF state */
} portmod_pfc_control_t;

/* portmod_pfc_control_t initialization and validation */
int portmod_pfc_control_t_validate(int unit, const portmod_pfc_control_t* portmod_pfc_control);
int portmod_pfc_control_t_init(int unit, portmod_pfc_control_t* portmod_pfc_control);


/*!
 * @struct portmod_pause_control_s
 * @brief  pause flow control configuration 
 */ 
typedef struct portmod_pause_control_s {
    uint8 rx_enable;
    uint8 tx_enable;
    int refresh_timer; /**< use -1 for disable this feature; Threshold for pause timer to cause XOFF to be resent */
    int xoff_timer; /**< Time value sent in the Timer Field for classes in XOFF state */
} portmod_pause_control_t;

/* portmod_pause_control_t initialization and validation */
int portmod_pause_control_t_validate(int unit, const portmod_pause_control_t* portmod_pause_control);
int portmod_pause_control_t_init(int unit, portmod_pause_control_t* portmod_pause_control);


/*!
 * @struct portmod_drain_cells_s
 * @brief  Information needed to restore after drain cells 
 */ 
typedef struct portmod_drain_cells_s {
    int rx_pfc_en;
    int llfc_en;
    int rx_pause;
    int tx_pause;
} portmod_drain_cells_t;

/* portmod_drain_cells_t initialization and validation */
int portmod_drain_cells_t_validate(int unit, const portmod_drain_cells_t* portmod_drain_cells);
int portmod_drain_cells_t_init(int unit, portmod_drain_cells_t* portmod_drain_cells);


/*!
 * @struct portmod_pm_create_info_s
 * @brief This struct contains the required information in order to add new PM to the PMM and create PM DB. 
 */ 
typedef struct portmod_pm_create_info_s {
    portmod_dispatch_type_t type; /**< PM type */
    portmod_pbmp_t phys; /**< which PHYs belongs to the PM */
    portmod_pm_specific_create_info_t pm_specific_info;
} portmod_pm_create_info_t;

/* portmod_pm_create_info_t initialization and validation */
int portmod_pm_create_info_t_validate(int unit, const portmod_pm_create_info_t* portmod_pm_create_info);
int portmod_pm_create_info_t_init(int unit, portmod_pm_create_info_t* portmod_pm_create_info);

#define PORTMOD_SIDE_SYSTEM (0)
#define PORTMOD_SIDE_LINE (1)

#define PORTMOD_PHYN_LAST_ONE (-1)


/*!
 * @struct portmod_access_get_params_s
 * @brief This struct used to select the access structure that will return from port_phy_lane_access_get 
 */ 
typedef struct portmod_access_get_params_s {
    int phyn; /**< hop number. 0-internal phy. 1 and up- external phys. -1 means the last one */
    int sys_side; /**< sys/line side.values: PORTMOD_SIDE_LINE, PORTMOD_SIDE_SYSTEM */
    int lane; /**< specific lane index. -1 (PORTMOD_ALL_LANES_ARE_ACTIVE) means return all lanes. -2 (PORTMOD_NO_LANE_IS_ACTIVE) means return no lane */
    int apply_lane_mask; /**< do lane masked for int core pm12x10 */
} portmod_access_get_params_t;

/* portmod_access_get_params_t initialization and validation */
int portmod_access_get_params_t_validate(int unit, const portmod_access_get_params_t* portmod_access_get_params);
int portmod_access_get_params_t_init(int unit, portmod_access_get_params_t* portmod_access_get_params);

#define PORTMOD_ALL_LANES_ARE_ACTIVE (-1)
#define PORTMOD_NO_LANE_IS_ACTIVE (-2)


/*!
 * @struct portmod_pm_instances_s
 * @brief This struct contains information about number of instances for PM type 
 */ 
typedef struct portmod_pm_instances_s {
    portmod_dispatch_type_t type; /**< Port Macro type */
    int instances; /**< the number of instances of the specified Port Macro type */
} portmod_pm_instances_t;

/* portmod_pm_instances_t initialization and validation */
int portmod_pm_instances_t_validate(int unit, const portmod_pm_instances_t* portmod_pm_instances);
int portmod_pm_instances_t_init(int unit, portmod_pm_instances_t* portmod_pm_instances);

/*! 
 * @brief Portmod Create Flags 
 */ 
#define PORTMOD_CREATE_F_PM_NULL 0x1 /**< Add PortmodNull */

#define PORTMOD_CREATE_F_PM_NULL_SET(flags) (flags |= PORTMOD_CREATE_F_PM_NULL)

#define PORTMOD_CREATE_F_PM_NULL_CLR(flags) (flags &= ~PORTMOD_CREATE_F_PM_NULL)

#define PORTMOD_CREATE_F_PM_NULL_GET(flags) (flags & PORTMOD_CREATE_F_PM_NULL ? 1 : 0)

/*! 
 * @brief Portmod Create Flags 
 */ 
#define PORTMOD_CREATE_F_PORTMOD_THREAD_DISABLE 0x2 /**< Disable the port monitor */

#define PORTMOD_CREATE_F_PORTMOD_THREAD_DISABLE_SET(flags) (flags |= PORTMOD_CREATE_F_PORTMOD_THREAD_DISABLE)

#define PORTMOD_CREATE_F_PORTMOD_THREAD_DISABLE_CLR(flags) (flags &= ~PORTMOD_CREATE_F_PORTMOD_THREAD_DISABLE)

#define PORTMOD_CREATE_F_PORTMOD_THREAD_DISABLE_GET(flags) (flags & PORTMOD_CREATE_F_PORTMOD_THREAD_DISABLE ? 1 : 0)

#define PORTMOD_EEE_ENABLE_LPI_BYPASS PHYMOD_LPI_BYPASS /**< enable/disable LPI bypass */

#define PORTMOD_EEE_ENABLE_LPI_BYPASS_SET(flags) ((flags) |= PORTMOD_EEE_ENABLE_LPI_BYPASS)

#define PORTMOD_EEE_ENABLE_LPI_BYPASS_CLR(flags) ((flags) &= ~PORTMOD_EEE_ENABLE_LPI_BYPASS)

#define PORTMOD_EEE_ENABLE_LPI_BYPASS_GET(flags) ((flags) & PORTMOD_EEE_ENABLE_LPI_BYPASS ? 1 : 0)

/*! 
 * portmod_create
 *
 * @brief Allocate PMM memory for the specified unit.
                Should be recalled in case of Warm Boot 
 *
 * @param [in]  unit            - unit id
 * @param [in]  flags           - flags to indicate pmnull
 * @param [in]  max_ports       - Max ports that should be supported in portmod for the specified unit
 * @param [in]  max_phys        - Max PHYs that should be supported in portmod for the specified unit
 * @param [in]  nof_pm_instances   - Number of elements of the pm_instances array
 * @param [in]  pm_instances    - 
 */
int portmod_create(int unit, int flags, int max_ports, int max_phys, int nof_pm_instances, const portmod_pm_instances_t* pm_instances);

/*! 
 * portmod_destroy
 *
 * @brief Release unit PMM resources. 
 *
 * @param [in]  unit            - unit id
 */
int portmod_destroy(int unit);

/*! 
 * portmod_thread_stop
 *
 * @brief Stop unit PMM threads. 
 *
 * @param [in]  unit            - unit id
 */
int portmod_thread_stop(int unit);

/*! 
 * portmod_port_macro_add
 *
 * @brief Add new port macro to the unit PMM; <br> In case of warm boot should be re called in the same order as called in cold boot  
 *
 * @param [in]  unit            - unit id
 * @param [in]  pm_info         - 
 */
int portmod_port_macro_add(int unit, const portmod_pm_create_info_t* pm_info);




/*! 
 * portmod_port_add
 *
 * @brief Add new port. Add the port to the PM DB. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  add_info        - 
 */
int portmod_port_add(int unit, int port, const portmod_port_add_info_t* add_info);







/*! 
 * portmod_port_remove
 *
 * @brief Remove the port from the PM and PMM.
            portmod_port_enable_set(unit, port, 0); should be called before 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int portmod_port_remove(int unit, int port);


/*! 
 * portmod_port_callback_unregister
 *
 * @brief Unregister the callback function and clear the some state 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int portmod_port_callback_unregister(int unit, int port);


/*! 
 * portmod_port_first_phy_get
 *
 * @brief get the first phy of the specified port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  phy             - 
 * @param [out]  sub_phy         - 
 */
int portmod_port_first_phy_get(int unit, int port, int* phy, int* sub_phy);

/*! 
 * portmod_port_phys_get
 *
 * @brief get the phys bitmap of the specified port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  phys            - phys bitmap
 */
int portmod_port_phys_get(int unit, int port, portmod_pbmp_t* phys);

/*! 
 * portmod_port_is_valid
 *
 * @brief Get the specific port has valid pm. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  valid           - TRUE if port has valid pm_id
 */
int portmod_port_is_valid(int unit, int port, int* valid);

/*! 
 * portmod_port_pm_type_get
 *
 * @brief Get the pm type of a port. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  real_port       - real port num
 * @param [out]  pm_type         - dispatch type
 */
int portmod_port_pm_type_get(int unit, int port, int* real_port, portmod_dispatch_type_t* pm_type);

/*! 
 * portmod_port_enable_set
 *
 * @brief Port enable 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  flags           - see PORTMOD_PORT_ENABLE_...
 * @param [in]  enable          - 
 */
int portmod_port_enable_set(int unit, int port, int flags, int enable);
/*! 
 * portmod_port_enable_get
 *
 * @brief Port enable 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  flags           - see PORTMOD_PORT_ENABLE_...
 * @param [out]  enable          - 
 */
int portmod_port_enable_get(int unit, int port, int flags, int* enable);

/*! 
 * portmod_port_cdr_lock_get
 *
 * @brief Get if CDR is locked 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  is_locked       - is cdr locked
 */
int portmod_port_cdr_lock_get(int unit, int port, int* is_locked);

/*! 
 * portmod_port_electrical_idle_enable_set
 *
 * @brief Electrical idle enable 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - 
 */
int portmod_port_electrical_idle_enable_set(int unit, int port, int enable);

/*! 
 * portmod_port_interface_config_set
 *
 * @brief  set/get the interface, speed and encapsulation for the specified port.
            For the First port within core this function initialize the PM, MAC and PHY before configure the port. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  config          - 
 * @param [in]  phy_init_flags   - see PORTMOD_INIT_F_...
 */
int portmod_port_interface_config_set(int unit, int port, const portmod_port_interface_config_t* config, int phy_init_flags);
/*! 
 * portmod_port_interface_config_get
 *
 * @brief  set/get the interface, speed and encapsulation for the specified port.
            For the First port within core this function initialize the PM, MAC and PHY before configure the port. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  config          - 
 * @param [in]  phy_init_flags   - see PORTMOD_INIT_F_...
 */
int portmod_port_interface_config_get(int unit, int port, portmod_port_interface_config_t* config, int phy_init_flags);

/*! 
 * portmod_port_default_interface_get
 *
 * @brief  get the default line-side (outmost) interface type of a port based on its speed, encap, number of lanes, etc, when there is or there is not an ext PHY 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  config          - 
 * @param [out]  interface       - 
 */
int portmod_port_default_interface_get(int unit, int port, const portmod_port_interface_config_t* config, soc_port_if_t* interface);

/*! 
 * portmod_port_interface_check
 *
 * @brief  check whether the interface type is valid based on the port speed, #lanes, etc 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  config          - 
 * @param [in]  is_ext_phy      - 
 * @param [in]  interface       - 
 * @param [out]  is_valid        - 
 */
int portmod_port_interface_check(int unit, int port, const portmod_port_interface_config_t* config, int is_ext_phy, soc_port_if_t interface, int* is_valid);

/*! 
 * portmod_port_encoding_set
 *
 * @brief chage port PCS encoding  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  properties      - 
 * @param [in]  encoding        - 
 */
int portmod_port_encoding_set(int unit, int port, uint32 properties, portmod_port_pcs_t encoding);
/*! 
 * portmod_port_encoding_get
 *
 * @brief chage port PCS encoding  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  properties      - 
 * @param [out]  encoding        - 
 */
int portmod_port_encoding_get(int unit, int port, uint32* properties, portmod_port_pcs_t* encoding);

/*! 
 * portmod_port_cl72_set
 *
 * @brief Port cl72 set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - 
 */
int portmod_port_cl72_set(int unit, int port, uint32 enable);
/*! 
 * portmod_port_cl72_get
 *
 * @brief Port cl72 set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - 
 */
int portmod_port_cl72_get(int unit, int port, uint32* enable);

/*! 
 * portmod_port_cl72_status_get
 *
 * @brief Get port cl72 status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  status          - 
 */
int portmod_port_cl72_status_get(int unit, int port, phymod_cl72_status_t* status);

/*! 
 * portmod_port_loopback_set
 *
 * @brief Port speed set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  loopback_type   - 
 * @param [in]  enable          - 
 */
int portmod_port_loopback_set(int unit, int port, portmod_loopback_mode_t loopback_type, int enable);
/*! 
 * portmod_port_loopback_get
 *
 * @brief Port speed set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  loopback_type   - 
 * @param [out]  enable          - 
 */
int portmod_port_loopback_get(int unit, int port, portmod_loopback_mode_t loopback_type, int* enable);

/*! 
 * portmod_port_pass_through_set
 *
 * @brief Port pass through set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  loopback_en     - 
 * @param [in]  enable          - 
 */
int portmod_port_pass_through_set(int unit, int port, int loopback_en, int enable);
/*! 
 * portmod_port_pass_through_get
 *
 * @brief Port pass through set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  loopback_en     - 
 * @param [out]  enable          - 
 */
int portmod_port_pass_through_get(int unit, int port, int* loopback_en, int* enable);

/*! 
 * portmod_port_pass_through_calibrate
 *
 * @brief Port pass through calibration 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int portmod_port_pass_through_calibrate(int unit, int port);

/*! 
 * portmod_port_pass_through_fec_enable_set
 *
 * @brief Port pass through fec enable set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - 
 */
int portmod_port_pass_through_fec_enable_set(int unit, int port, int enable);
/*! 
 * portmod_port_pass_through_fec_enable_get
 *
 * @brief Port pass through fec enable set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - 
 */
int portmod_port_pass_through_fec_enable_get(int unit, int port, int* enable);

/*! 
 * portmod_port_rx_mac_enable_set
 *
 * @brief Port RX MAC ENABLE set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - 
 */
int portmod_port_rx_mac_enable_set(int unit, int port, int enable);
/*! 
 * portmod_port_rx_mac_enable_get
 *
 * @brief Port RX MAC ENABLE set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - 
 */
int portmod_port_rx_mac_enable_get(int unit, int port, int* enable);

/*! 
 * portmod_port_tx_mac_enable_set
 *
 * @brief Port TX MAC ENABLE set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - 
 */
int portmod_port_tx_mac_enable_set(int unit, int port, int enable);
/*! 
 * portmod_port_tx_mac_enable_get
 *
 * @brief Port TX MAC ENABLE set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - 
 */
int portmod_port_tx_mac_enable_get(int unit, int port, int* enable);

/*! 
 * portmod_port_ability_local_get
 *
 * @brief get port auto negotiation local ability 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  phy_flags       - which phy in the chain should be affected. see PORTMOD_INIT_F...
 * @param [out]  ability         - 
 */
int portmod_port_ability_local_get(int unit, int port, uint32 phy_flags, portmod_port_ability_t* ability);

/*! 
 * portmod_port_autoneg_set
 *
 * @brief Set/Get autoneg 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  phy_flags       - which phy in the chain should be affected. see PORTMOD_INIT_F...
 * @param [in]  an              - 
 */
int portmod_port_autoneg_set(int unit, int port, uint32 phy_flags, const phymod_autoneg_control_t* an);
/*! 
 * portmod_port_autoneg_get
 *
 * @brief Set/Get autoneg 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  phy_flags       - which phy in the chain should be affected. see PORTMOD_INIT_F...
 * @param [out]  an              - 
 */
int portmod_port_autoneg_get(int unit, int port, uint32 phy_flags, phymod_autoneg_control_t* an);

/*! 
 * portmod_port_autoneg_status_get
 *
 * @brief Get autoneg status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  an_status       - 
 */
int portmod_port_autoneg_status_get(int unit, int port, phymod_autoneg_status_t* an_status);

/*! 
 * portmod_port_link_get
 *
 * @brief get link status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           -  option flag to indicate where cmd coming from.
 * @param [out]  link            - link indication up/down
 */
int portmod_port_link_get(int unit, int port, int flags, int* link);

/*! 
 * @brief Port link latch down flags 
 */ 
#define PORTMOD_PORT_LINK_LATCH_DOWN_F_CLEAR 0x1 /**< clear the latch down indication */


/*! 
 * portmod_port_link_latch_down_get
 *
 * @brief get latch down link status (whether link was ever down since last clear) 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - see PORT_LINK_LATCH_DOWN_F
 * @param [out]  link            - link latch down indication
 */
int portmod_port_link_latch_down_get(int unit, int port, uint32 flags, int* link);

/*! 
 * portmod_port_phy_link_up_event
 *
 * @brief  link up event  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int portmod_port_phy_link_up_event(int unit, int port);

/*! 
 * portmod_port_phy_link_down_event
 *
 * @brief  link down event  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int portmod_port_phy_link_down_event(int unit, int port);

/*! 
 * portmod_port_prbs_config_set
 *
 * @brief PRBS configuration set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mode            - 0- PHY PRBS, 1- MAC PRBS
 * @param [in]  flags           - 
 * @param [in]  config          - PRBS configuration
 */
int portmod_port_prbs_config_set(int unit, int port, portmod_prbs_mode_t mode, int flags, const phymod_prbs_t* config);
/*! 
 * portmod_port_prbs_config_get
 *
 * @brief PRBS configuration set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mode            - 0- PHY PRBS, 1- MAC PRBS
 * @param [in]  flags           - 
 * @param [out]  config          - PRBS configuration
 */
int portmod_port_prbs_config_get(int unit, int port, portmod_prbs_mode_t mode, int flags, phymod_prbs_t* config);

/*! 
 * portmod_port_prbs_enable_set
 *
 * @brief PRBS enable set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mode            - 0- PHY PRBS, 1- MAC PRBS
 * @param [in]  flags           - 
 * @param [in]  enable          - 
 */
int portmod_port_prbs_enable_set(int unit, int port, portmod_prbs_mode_t mode, int flags, int enable);
/*! 
 * portmod_port_prbs_enable_get
 *
 * @brief PRBS enable set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mode            - 0- PHY PRBS, 1- MAC PRBS
 * @param [in]  flags           - 
 * @param [out]  enable          - 
 */
int portmod_port_prbs_enable_get(int unit, int port, portmod_prbs_mode_t mode, int flags, int* enable);

/*! 
 * portmod_port_prbs_status_get
 *
 * @brief PRBS status get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mode            - 0- PHY PRBS, 1- MAC PRBS
 * @param [in]  flags           - see PHYMOD_PRBS_STATUS_FLAGS_
 * @param [out]  status          - 
 */
int portmod_port_prbs_status_get(int unit, int port, portmod_prbs_mode_t mode, int flags, phymod_prbs_status_t* status);

/*! 
 * portmod_port_nof_lanes_get
 *
 * @brief Number of lanes get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  nof_lanes       - 
 */
int portmod_port_nof_lanes_get(int unit, int port, int* nof_lanes);

/*! 
 * portmod_port_ilkn_nof_segments_set
 *
 * @brief ILKN Number of segments set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  nof_segments    - Segemnts are a resource of the ILKN core, should be shared between the two ports on the same core.
 */
int portmod_port_ilkn_nof_segments_set(int unit, int port, uint32 nof_segments);
/*! 
 * portmod_port_ilkn_nof_segments_get
 *
 * @brief ILKN Number of segments set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  nof_segments    - Segemnts are a resource of the ILKN core, should be shared between the two ports on the same core.
 */
int portmod_port_ilkn_nof_segments_get(int unit, int port, uint32* nof_segments);

/*! 
 * portmod_ilkn_retranstmit_config_set
 *
 * @brief ILKN retransmit configuration set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  retransmit_config   - 
 */
int portmod_ilkn_retranstmit_config_set(int unit, int port, const ilkn_retransmit_config_t* retransmit_config);
/*! 
 * portmod_ilkn_retranstmit_config_get
 *
 * @brief ILKN retransmit configuration set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  retransmit_config   - 
 */
int portmod_ilkn_retranstmit_config_get(int unit, int port, ilkn_retransmit_config_t* retransmit_config);

/*! 
 * portmod_port_lanes_assign
 *
 * @brief assign lane map to specific port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  assign_map      - 
 */
int portmod_port_lanes_assign(int unit, int port, const portmod_lanes_assign_info_t* assign_map);

/*! 
 * portmod_port_lanes_retrieve
 *
 * @brief retrieve lane map of specific port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  assign_map      - 
 */
int portmod_port_lanes_retrieve(int unit, int port, portmod_lanes_assign_info_t* assign_map);

/*! 
 * portmod_port_firmware_mode_set
 *
 * @brief Set port PHYs' firmware mode 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  fw_mode         - 
 */
int portmod_port_firmware_mode_set(int unit, int port, phymod_firmware_mode_t fw_mode);
/*! 
 * portmod_port_firmware_mode_get
 *
 * @brief Set port PHYs' firmware mode 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  fw_mode         - 
 */
int portmod_port_firmware_mode_get(int unit, int port, phymod_firmware_mode_t* fw_mode);

/*! 
 * portmod_port_runt_threshold_set
 *
 * @brief Filter packets smaller than the specified threshold 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - packets smaller than the specified values will be filtered
 */
int portmod_port_runt_threshold_set(int unit, int port, int value);
/*! 
 * portmod_port_runt_threshold_get
 *
 * @brief Filter packets smaller than the specified threshold 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - packets smaller than this value are filtered
 */
int portmod_port_runt_threshold_get(int unit, int port, int* value);

/*! 
 * portmod_port_max_packet_size_set
 *
 * @brief Filter packets bigger than the specified value 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - the max packet size
 */
int portmod_port_max_packet_size_set(int unit, int port, int value);
/*! 
 * portmod_port_max_packet_size_get
 *
 * @brief Filter packets bigger than the specified value 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - the max packet size
 */
int portmod_port_max_packet_size_get(int unit, int port, int* value);

/*! 
 * portmod_port_pad_size_set
 *
 * @brief TX pad packets to the specified size. values smaller than 17 means pad is disabled. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - 
 */
int portmod_port_pad_size_set(int unit, int port, int value);
/*! 
 * portmod_port_pad_size_get
 *
 * @brief TX pad packets to the specified size. values smaller than 17 means pad is disabled. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - 
 */
int portmod_port_pad_size_get(int unit, int port, int* value);

/*! 
 * portmod_port_tx_mac_sa_set
 *
 * @brief set/get the MAC source address that will be sent in case of Pause/LLFC 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mac_sa          - 
 */
int portmod_port_tx_mac_sa_set(int unit, int port, sal_mac_addr_t mac_sa);
/*! 
 * portmod_port_tx_mac_sa_get
 *
 * @brief set/get the MAC source address that will be sent in case of Pause/LLFC 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  mac_sa          - 
 */
int portmod_port_tx_mac_sa_get(int unit, int port, sal_mac_addr_t mac_sa);

/*! 
 * portmod_port_rx_mac_sa_set
 *
 * @brief set/get SA recognized for MAC control packets in addition to the standard 0x0180C2000001 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mac_sa          - 
 */
int portmod_port_rx_mac_sa_set(int unit, int port, sal_mac_addr_t mac_sa);
/*! 
 * portmod_port_rx_mac_sa_get
 *
 * @brief set/get SA recognized for MAC control packets in addition to the standard 0x0180C2000001 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  mac_sa          - 
 */
int portmod_port_rx_mac_sa_get(int unit, int port, sal_mac_addr_t mac_sa);

/*! 
 * portmod_port_tx_average_ipg_set
 *
 * @brief set/get Average inter-packet gap 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - 
 */
int portmod_port_tx_average_ipg_set(int unit, int port, int value);
/*! 
 * portmod_port_tx_average_ipg_get
 *
 * @brief set/get Average inter-packet gap 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - 
 */
int portmod_port_tx_average_ipg_get(int unit, int port, int* value);

/*! 
 * portmod_port_tx_preamble_length_set
 *
 * @brief set/get Number of preamble bytes for transmit IEEE packets; this value should include the K.SOP and SFD character as well 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - 
 */
int portmod_port_tx_preamble_length_set(int unit, int port, int value);
/*! 
 * portmod_port_tx_preamble_length_get
 *
 * @brief set/get Number of preamble bytes for transmit IEEE packets; this value should include the K.SOP and SFD character as well 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - 
 */
int portmod_port_tx_preamble_length_get(int unit, int port, int* value);

/*! 
 * portmod_port_local_fault_control_set
 *
 * @brief local fault set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  control         - 
 */
int portmod_port_local_fault_control_set(int unit, int port, const portmod_local_fault_control_t* control);
/*! 
 * portmod_port_local_fault_control_get
 *
 * @brief local fault set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  control         - 
 */
int portmod_port_local_fault_control_get(int unit, int port, portmod_local_fault_control_t* control);

/*! 
 * portmod_port_remote_fault_control_set
 *
 * @brief remote fault set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  control         - 
 */
int portmod_port_remote_fault_control_set(int unit, int port, const portmod_remote_fault_control_t* control);
/*! 
 * portmod_port_remote_fault_control_get
 *
 * @brief remote fault set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  control         - 
 */
int portmod_port_remote_fault_control_get(int unit, int port, portmod_remote_fault_control_t* control);

/*! 
 * portmod_port_local_fault_status_get
 *
 * @brief local fault steatus get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - 
 */
int portmod_port_local_fault_status_get(int unit, int port, int* value);

/*! 
 * portmod_port_remote_fault_status_get
 *
 * @brief remote fault status get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - 
 */
int portmod_port_remote_fault_status_get(int unit, int port, int* value);

/*! 
 * portmod_port_local_fault_status_clear
 *
 * @brief local fault steatus clear 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int portmod_port_local_fault_status_clear(int unit, int port);

/*! 
 * portmod_port_remote_fault_status_clear
 *
 * @brief remote fault status clear 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int portmod_port_remote_fault_status_clear(int unit, int port);

/*! 
 * @brief Port Local Fault Reason Flags 
 */ 
#define PORTMOD_PORT_LOCAL_FAULT_REASON_NONE 0x1 /**< No Local Fault detected */
#define PORTMOD_PORT_LOCAL_FAULT_REASON_UNKNOWN 0x2 /**< Local Fault reason could not be determined */
#define PORTMOD_PORT_LOCAL_FAULT_REASON_PMD_NO_LOCK 0x4 /**< PMD Rx Lock not done */
#define PORTMOD_PORT_LOCAL_FAULT_REASON_AM_NO_LOCK 0x8 /**< Alignment Marker Lock not done */
#define PORTMOD_PORT_LOCAL_FAULT_REASON_NO_DESKEW 0x10 /**< Deskew not done */
#define PORTMOD_PORT_LOCAL_FAULT_REASON_FEC_NO_ALIGN 0x20 /**< FEC align not done */

#define PORTMOD_PORT_LOCAL_FAULT_REASON_NONE_SET(flags) ((flags) |= PORTMOD_PORT_LOCAL_FAULT_REASON_NONE)
#define PORTMOD_PORT_LOCAL_FAULT_REASON_UNKNOWN_SET(flags) ((flags) |= PORTMOD_PORT_LOCAL_FAULT_REASON_UNKNOWN)
#define PORTMOD_PORT_LOCAL_FAULT_REASON_PMD_NO_LOCK_SET(flags) ((flags) |= PORTMOD_PORT_LOCAL_FAULT_REASON_PMD_NO_LOCK)
#define PORTMOD_PORT_LOCAL_FAULT_REASON_AM_NO_LOCK_SET(flags) ((flags) |= PORTMOD_PORT_LOCAL_FAULT_REASON_AM_NO_LOCK)
#define PORTMOD_PORT_LOCAL_FAULT_REASON_NO_DESKEW_SET(flags) ((flags) |= PORTMOD_PORT_LOCAL_FAULT_REASON_NO_DESKEW)
#define PORTMOD_PORT_LOCAL_FAULT_REASON_FEC_NO_ALIGN_SET(flags) ((flags) |= PORTMOD_PORT_LOCAL_FAULT_REASON_FEC_NO_ALIGN)

#define PORTMOD_PORT_LOCAL_FAULT_REASON_NONE_CLR(flags) ((flags) &= ~PORTMOD_PORT_LOCAL_FAULT_REASON_NONE)
#define PORTMOD_PORT_LOCAL_FAULT_REASON_UNKNOWN_CLR(flags) ((flags) &= ~PORTMOD_PORT_LOCAL_FAULT_REASON_UNKNOWN)
#define PORTMOD_PORT_LOCAL_FAULT_REASON_PMD_NO_LOCK_CLR(flags) ((flags) &= ~PORTMOD_PORT_LOCAL_FAULT_REASON_PMD_NO_LOCK)
#define PORTMOD_PORT_LOCAL_FAULT_REASON_AM_NO_LOCK_CLR(flags) ((flags) &= ~PORTMOD_PORT_LOCAL_FAULT_REASON_AM_NO_LOCK)
#define PORTMOD_PORT_LOCAL_FAULT_REASON_NO_DESKEW_CLR(flags) ((flags) &= ~PORTMOD_PORT_LOCAL_FAULT_REASON_NO_DESKEW)
#define PORTMOD_PORT_LOCAL_FAULT_REASON_FEC_NO_ALIGN_CLR(flags) ((flags) &= ~PORTMOD_PORT_LOCAL_FAULT_REASON_FEC_NO_ALIGN)

#define PORTMOD_PORT_LOCAL_FAULT_REASON_NONE_GET(flags) ((flags) & PORTMOD_PORT_LOCAL_FAULT_REASON_NONE ? 1 : 0)
#define PORTMOD_PORT_LOCAL_FAULT_REASON_UNKNOWN_GET(flags) ((flags) & PORTMOD_PORT_LOCAL_FAULT_REASON_UNKNOWN ? 1 : 0)
#define PORTMOD_PORT_LOCAL_FAULT_REASON_PMD_NO_LOCK_GET(flags) ((flags) & PORTMOD_PORT_LOCAL_FAULT_REASON_PMD_NO_LOCK ? 1 : 0)
#define PORTMOD_PORT_LOCAL_FAULT_REASON_AM_NO_LOCK_GET(flags) ((flags) & PORTMOD_PORT_LOCAL_FAULT_REASON_AM_NO_LOCK ? 1 : 0)
#define PORTMOD_PORT_LOCAL_FAULT_REASON_NO_DESKEW_GET(flags) ((flags) & PORTMOD_PORT_LOCAL_FAULT_REASON_NO_DESKEW ? 1 : 0)
#define PORTMOD_PORT_LOCAL_FAULT_REASON_FEC_NO_ALIGN_GET(flags) ((flags) & PORTMOD_PORT_LOCAL_FAULT_REASON_FEC_NO_ALIGN ? 1 : 0)

/*! 
 * portmod_port_local_fault_reasons_get
 *
 * @brief local fault reasons get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  local_fault_reasons   - port local fault reasons flags
 */
int portmod_port_local_fault_reasons_get(int unit, int port, uint32* local_fault_reasons);

/*! 
 * portmod_port_pause_control_set
 *
 * @brief set/get Pause FC configuration 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  control         - 
 */
int portmod_port_pause_control_set(int unit, int port, const portmod_pause_control_t* control);
/*! 
 * portmod_port_pause_control_get
 *
 * @brief set/get Pause FC configuration 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  control         - 
 */
int portmod_port_pause_control_get(int unit, int port, portmod_pause_control_t* control);

/*! 
 * portmod_port_pfc_control_set
 *
 * @brief set/get PFC FC configuration 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  control         - 
 */
int portmod_port_pfc_control_set(int unit, int port, const portmod_pfc_control_t* control);
/*! 
 * portmod_port_pfc_control_get
 *
 * @brief set/get PFC FC configuration 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  control         - 
 */
int portmod_port_pfc_control_get(int unit, int port, portmod_pfc_control_t* control);

/*! 
 * portmod_port_llfc_control_set
 *
 * @brief set/get LLFC FC configuration 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  control         - 
 */
int portmod_port_llfc_control_set(int unit, int port, const portmod_llfc_control_t* control);
/*! 
 * portmod_port_llfc_control_get
 *
 * @brief set/get LLFC FC configuration 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  control         - 
 */
int portmod_port_llfc_control_get(int unit, int port, portmod_llfc_control_t* control);

/*! 
 * @brief Port Update Flags 
 */ 
#define PORTMOD_PORT_UPDATE_F_DISABLE_MAC 0x1 /**< disable MAC when phy link status is down */
#define PORTMOD_PORT_UPDATE_F_UPDATE_SERDES_LINK 0x2 /**< Force Serdes Link Status  */

#define PORTMOD_PORT_UPDATE_F_DISABLE_MAC_SET(control) ((control)->flags |= PORTMOD_PORT_UPDATE_F_DISABLE_MAC)
#define PORTMOD_PORT_UPDATE_F_UPDATE_SERDES_LINK_SET(control) ((control)->flags |= PORTMOD_PORT_UPDATE_F_UPDATE_SERDES_LINK)

#define PORTMOD_PORT_UPDATE_F_DISABLE_MAC_CLR(control) ((control)->flags &= ~PORTMOD_PORT_UPDATE_F_DISABLE_MAC)
#define PORTMOD_PORT_UPDATE_F_UPDATE_SERDES_LINK_CLR(control) ((control)->flags &= ~PORTMOD_PORT_UPDATE_F_UPDATE_SERDES_LINK)

#define PORTMOD_PORT_UPDATE_F_DISABLE_MAC_GET(control) ((control)->flags & PORTMOD_PORT_UPDATE_F_DISABLE_MAC ? 1 : 0)
#define PORTMOD_PORT_UPDATE_F_UPDATE_SERDES_LINK_GET(control) ((control)->flags & PORTMOD_PORT_UPDATE_F_UPDATE_SERDES_LINK ? 1 : 0)


/*!
 * @struct portmod_port_update_control_s
 * @brief Expected user access structure when using PM default bus 
 */ 
typedef struct portmod_port_update_control_s {
    int link_status; /**< Current link status, use -1 to retrive the status inside the function */
    uint32 flags;
} portmod_port_update_control_t;

/* portmod_port_update_control_t initialization and validation */
int portmod_port_update_control_t_validate(int unit, const portmod_port_update_control_t* portmod_port_update_control);
int portmod_port_update_control_t_init(int unit, portmod_port_update_control_t* portmod_port_update_control);

/*! 
 * portmod_port_update
 *
 * @brief Routine for MAC/PHY sync. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  update_control   - inputs for update operation
 */
int portmod_port_update(int unit, int port, const portmod_port_update_control_t* update_control);

/*! 
 * portmod_port_core_access_get
 *
 * @brief get port cores' phymod access 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  phyn            - the number of hops from the internal phy. 0 - internal, 1- first external PHY, etc.
 * @param [in]  max_cores       - the output array number of elements
 * @param [out]  core_access_arr   - port phymod cores array
 * @param [out]  nof_cores       - number of core access structutres filled by the function
 * @param [out]  is_most_ext     - Whether this phy is the most external, can be passed as NULL
 */
int portmod_port_core_access_get(int unit, int port, int phyn, int max_cores, phymod_core_access_t* core_access_arr, int* nof_cores, int* is_most_ext);

/*! 
 * portmod_port_phy_lane_access_get
 *
 * @brief Get lane phymod access structure. can be used for per lane operations 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  params          - 
 * @param [in]  max_phys        - the output array number of elements
 * @param [out]  access          - 
 * @param [out]  nof_phys        - number of phy access structutres filled by the function
 * @param [out]  is_most_ext     - Whether this phy is the most external, can be passed as NULL
 */
int portmod_port_phy_lane_access_get(int unit, int port, const portmod_access_get_params_t* params, int max_phys, phymod_phy_access_t* access, int* nof_phys, int* is_most_ext);

/*! 
 * portmod_pm_phy_lane_access_get
 *
 * @brief Get lane phymod access structure via pm id. Should be used only when there is no port attached  
 *
 * @param [in]  unit            - unit id
 * @param [in]  pm_id           - port macro id
 * @param [in]  params          - 
 * @param [in]  max_phys        - the output array number of elements
 * @param [out]  access          - 
 * @param [out]  nof_phys        - number of phy access structutres filled by the function
 * @param [out]  is_most_ext     - Whether this phy is the most external, can be passed as NULL
 */
int portmod_pm_phy_lane_access_get(int unit, int pm_id, const portmod_access_get_params_t* params, int max_phys, phymod_phy_access_t* access, int* nof_phys, int* is_most_ext);

/*! 
 * portmod_pm_diag_info_get
 *
 * @brief get PM diag info 
 *
 * @param [in]  unit            - unit id
 * @param [in]  pm_id           - pm id
 * @param [out]  diag_info       - 
 */
int portmod_pm_diag_info_get(int unit, int pm_id, portmod_pm_diag_info_t* diag_info);

/*! 
 * portmod_port_diag_info_get
 *
 * @brief get port diag info 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  diag_info       - 
 */
int portmod_port_diag_info_get(int unit, int port, portmod_port_diag_info_t* diag_info);

/*! 
 * portmod_port_duplex_set
 *
 * @brief Port duplex set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - 
 */
int portmod_port_duplex_set(int unit, int port, int enable);
/*! 
 * portmod_port_duplex_get
 *
 * @brief Port duplex set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - 
 */
int portmod_port_duplex_get(int unit, int port, int* enable);

/*! 
 * portmod_port_phy_reg_read
 *
 * @brief Port PHY Control register read 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  lane            - logic lane
 * @param [in]  flags           - flags
 * @param [in]  reg_addr        - register address
 * @param [out]  value           - read data
 */
int portmod_port_phy_reg_read(int unit, int port, int lane, int flags, int reg_addr, uint32* value);

/*! 
 * portmod_port_phy_reg_write
 *
 * @brief Port PHY Control register write 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  lane            - logic lane
 * @param [in]  flags           - see PORTMOD_PORT_PHY_CONTROL_
 * @param [in]  reg_addr        - register address
 * @param [in]  value           - 
 */
int portmod_port_phy_reg_write(int unit, int port, int lane, int flags, int reg_addr, uint32 value);

/*! 
 * portmod_port_reset_set
 *
 * @brief Port Reset set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mode            - 
 * @param [in]  opcode          - 
 * @param [in]  value           - 
 */
int portmod_port_reset_set(int unit, int port, int mode, int opcode, int value);
/*! 
 * portmod_port_reset_get
 *
 * @brief Port Reset set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mode            - 
 * @param [in]  opcode          - 
 * @param [out]  value           - 
 */
int portmod_port_reset_get(int unit, int port, int mode, int opcode, int* value);

/*! 
 * portmod_port_adv_remote_get
 *
 * @brief Port remote Adv get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - 
 */
int portmod_port_adv_remote_get(int unit, int port, int* value);

/*! 
 * portmod_port_drv_name
 *
 * @brief Port get drv name 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int portmod_port_drv_name(int unit, int port);

/*! 
 * portmod_port_drv_name_get
 *
 * @brief Drv Name Get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  name            - 
 * @param [in]  len             - 
 */
int portmod_port_drv_name_get(int unit, int port, char* name, int len);

/*! 
 * portmod_port_fec_enable_set
 *
 * @brief set/get port fec enable according to local/remote FEC ability 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  phy_flags       - which phy in the chain should be affected. see PORTMOD_INIT_F...
 * @param [in]  enable          - 
 */
int portmod_port_fec_enable_set(int unit, int port, uint32 phy_flags, uint32_t enable);
/*! 
 * portmod_port_fec_enable_get
 *
 * @brief set/get port fec enable according to local/remote FEC ability 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  phy_flags       - which phy in the chain should be affected. see PORTMOD_INIT_F...
 * @param [out]  enable          - 
 */
int portmod_port_fec_enable_get(int unit, int port, uint32 phy_flags, uint32_t* enable);

/*! 
 * portmod_port_ability_advert_set
 *
 * @brief get port auto negotiation local ability 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  phy_flags       - which phy in the chain should be affected. see PORTMOD_INIT_F...
 * @param [out]  ability         - 
 */
int portmod_port_ability_advert_set(int unit, int port, uint32 phy_flags, portmod_port_ability_t* ability);
/*! 
 * portmod_port_ability_advert_get
 *
 * @brief get port auto negotiation local ability 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  phy_flags       - which phy in the chain should be affected. see PORTMOD_INIT_F...
 * @param [out]  ability         - 
 */
int portmod_port_ability_advert_get(int unit, int port, uint32 phy_flags, portmod_port_ability_t* ability);

/*! 
 * portmod_port_ability_remote_get
 *
 * @brief Port ability remote Adv get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  phy_flags       - which phy in the chain should be affected. see PORTMOD_INIT_F...
 * @param [out]  ability         - 
 */
int portmod_port_ability_remote_get(int unit, int port, uint32 phy_flags, portmod_port_ability_t* ability);

/*! 
 * portmod_port_frame_spacing_stretch_set
 *
 * @brief Port Mac Control Spacing Stretch 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  spacing         - 
 */
int portmod_port_frame_spacing_stretch_set(int unit, int port, int spacing);
/*! 
 * portmod_port_frame_spacing_stretch_get
 *
 * @brief Port Mac Control Spacing Stretch 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  spacing         - 
 */
int portmod_port_frame_spacing_stretch_get(int unit, int port, const int* spacing);

/*! 
 * portmod_port_diag_fifo_status_get
 *
 * @brief get port timestamps in fifo 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  diag_info       - 
 */
int portmod_port_diag_fifo_status_get(int unit, int port, const portmod_fifo_status_t* diag_info);

/*! 
 * portmod_port_rx_control_set
 *
 * @brief set/get pass control frames. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  rx_ctrl         - 
 */
int portmod_port_rx_control_set(int unit, int port, const portmod_rx_control_t* rx_ctrl);
/*! 
 * portmod_port_rx_control_get
 *
 * @brief set/get pass control frames. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  rx_ctrl         - 
 */
int portmod_port_rx_control_get(int unit, int port, portmod_rx_control_t* rx_ctrl);

/*! 
 * portmod_port_pfc_config_set
 *
 * @brief set PFC config registers. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  pfc_cfg         - 
 */
int portmod_port_pfc_config_set(int unit, int port, const portmod_pfc_config_t* pfc_cfg);
/*! 
 * portmod_port_pfc_config_get
 *
 * @brief set PFC config registers. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  pfc_cfg         - 
 */
int portmod_port_pfc_config_get(int unit, int port, portmod_pfc_config_t* pfc_cfg);

/*! 
 * portmod_port_eee_set
 *
 * @brief set EEE Config. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  eee             - 
 */
int portmod_port_eee_set(int unit, int port, const portmod_eee_t* eee);
/*! 
 * portmod_port_eee_get
 *
 * @brief set EEE Config. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  eee             - 
 */
int portmod_port_eee_get(int unit, int port, portmod_eee_t* eee);

/*! 
 * portmod_port_eee_clock_set
 *
 * @brief set EEE Config. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  eee_clk         - 
 */
int portmod_port_eee_clock_set(int unit, int port, const portmod_eee_clock_t* eee_clk);
/*! 
 * portmod_port_eee_clock_get
 *
 * @brief set EEE Config. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  eee_clk         - 
 */
int portmod_port_eee_clock_get(int unit, int port, portmod_eee_clock_t* eee_clk);

/*! 
 * portmod_port_vlan_tag_set
 *
 * @brief set Vlan Inner/Outer tag. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  vlan_tag        - 
 */
int portmod_port_vlan_tag_set(int unit, int port, const portmod_vlan_tag_t* vlan_tag);
/*! 
 * portmod_port_vlan_tag_get
 *
 * @brief set Vlan Inner/Outer tag. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  vlan_tag        - 
 */
int portmod_port_vlan_tag_get(int unit, int port, portmod_vlan_tag_t* vlan_tag);

/*! 
 * portmod_port_to_phyaddr
 *
 * @brief Get Phy addr for a given port. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int portmod_port_to_phyaddr(int unit, int port);

/*! 
 * portmod_port_to_phyaddr_int
 *
 * @brief Get internal Phy addr for a given port. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int portmod_port_to_phyaddr_int(int unit, int port);

/*! 
 * portmod_port_modid_set
 *
 * @brief set modid field. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - 
 */
int portmod_port_modid_set(int unit, int port, int value);

/*! 
 * portmod_port_led_chain_config
 *
 * @brief set modid field. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - 
 */
int portmod_port_led_chain_config(int unit, int port, int value);

/*! 
 * portmod_port_clear_rx_lss_status_set
 *
 * @brief set modid field. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  lcl_fault       - 
 * @param [in]  rmt_fault       - 
 */
int portmod_port_clear_rx_lss_status_set(int unit, int port, int lcl_fault, int rmt_fault);
/*! 
 * portmod_port_clear_rx_lss_status_get
 *
 * @brief set modid field. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  lcl_fault       - 
 * @param [out]  rmt_fault       - 
 */
int portmod_port_clear_rx_lss_status_get(int unit, int port, int* lcl_fault, int* rmt_fault);

#define PORTMOD_PRIMARY_PORT_INVALID (-1)
#define PORTMOD_PORT_OFFSET_INVALID (-1)
#define PORTMOD_CORE_INDEX_INVALID (-1)
#define PORTMOD_LANE_INDEX_INVALID (-1)
#define PORTMOD_XPHY_ID_INVALID (0xFFFF)
#define PORTMOD_MAX_NUM_XPHY_SUPPORTED (512)
#define PORTMOD_XPHY_EXISTING_IDX (-2)


/*!
 * @struct portmod_lane_connection_s
 * @brief lane connection structture between internal and external phy 
 */ 
typedef struct portmod_lane_connection_s {
    int core_index; /**< the connected core in the external phy */
    int lane_index; /**< the connected lane in the external phy */
} portmod_lane_connection_t;

/* portmod_lane_connection_t initialization and validation */
int portmod_lane_connection_t_validate(int unit, const portmod_lane_connection_t* portmod_lane_connection);
int portmod_lane_connection_t_init(int unit, portmod_lane_connection_t* portmod_lane_connection);


/*!
 * @struct portmod_phy_core_info_s
 * @brief Core information structure for external phy db 
 */ 
typedef struct portmod_phy_core_info_s {
    phymod_core_access_t core_access; /**< core access */
} portmod_phy_core_info_t;

/* portmod_phy_core_info_t initialization and validation */
int portmod_phy_core_info_t_validate(int unit, const portmod_phy_core_info_t* portmod_phy_core_info);
int portmod_phy_core_info_t_init(int unit, portmod_phy_core_info_t* portmod_phy_core_info);


/*!
 * @struct portmod_xphy_lane_connection_s
 * @brief lane connection structture between internal and external phy 
 */ 
typedef struct portmod_xphy_lane_connection_s {
    uint32 xphy_id; /**< connected xphy id */
    int ss_lane_mask; /**< connected xphy system side lane mask */
    int ls_lane_mask; /**< connected xphy line side lane mask */
    int rsvd1; /**< connected xphy line side lane mask */
    int rsvd2; /**< connected xphy line side lane mask */
} portmod_xphy_lane_connection_t;

/* portmod_xphy_lane_connection_t initialization and validation */
int portmod_xphy_lane_connection_t_validate(int unit, const portmod_xphy_lane_connection_t* portmod_xphy_lane_connection);
int portmod_xphy_lane_connection_t_init(int unit, portmod_xphy_lane_connection_t* portmod_xphy_lane_connection);

/*! 
 * portmod_xphy_lane_attach
 *
 * @brief Attaches an external phy lane to a phy chain 
 *
 * @param [in]  unit            - unit id
 * @param [in]  iphy            - internal phy index representing the starting point of a phy chain
 * @param [in]  phyn            - indicate the external phy layer in the phy chain
 * @param [in]  lane_conn       - lane connection between internal and external phy
 */
int portmod_xphy_lane_attach(int unit, int iphy, int phyn, const portmod_xphy_lane_connection_t* lane_conn);

/*! 
 * portmod_xphy_lane_detach
 *
 * @brief Detaches an external phy lane from a phy chain 
 *
 * @param [in]  unit            - unit id
 * @param [in]  iphy            - internal phy index representing the starting point of a phy chain
 * @param [in]  phyn            - indicate the external phy layer in the phy chain
 */
int portmod_xphy_lane_detach(int unit, int iphy, int phyn);



/*! 
 * portmod_xphy_add
 *
 * @brief Add External Phy to DB.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  xphy_addr       - External Phy Address. Usually MDIO address.
 * @param [in]  core_access     - External Phy Access information
 * @param [out]  xphy_idx        - Indicate location of new entry.
 */
int portmod_xphy_add(int unit, int xphy_addr, const phymod_core_access_t* core_access, int* xphy_idx);

/*! 
 * portmod_xphy_delete
 *
 * @brief Remove External Phy from DB.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  xphy_addr       - External Phy Address. Usually MDIO address.
 */
int portmod_xphy_delete(int unit, int xphy_addr);

/*! 
 * portmod_xphy_wb_db_restore
 *
 * @brief  Restore External Phy  DB from WB buffer.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  xphy_idx        - index to the xphy db
 * @param [in]  xphy_addr       - external phy address
 * @param [in]  core_access     - the core_access to be used for external phys restored from WB database. external phy address , external phy type and external phy device_op_mode  will be override with values restored from WB DB.
 */
int portmod_xphy_wb_db_restore(int unit, int xphy_idx, int xphy_addr, const phymod_core_access_t* core_access);




/*! 
 * portmod_ext_phy_lane_attach
 *
 * @brief Attaches an external phy lane to a phy chain 
 *
 * @param [in]  unit            - unit id
 * @param [in]  iphy            - internal phy index representing the starting point of a phy chain
 * @param [in]  phyn            - indicate the external phy layer in the phy chain
 * @param [in]  lane_connection   - lane connection between internal and external phy
 */
int portmod_ext_phy_lane_attach(int unit, int iphy, int phyn, const portmod_lane_connection_t* lane_connection);

/*! 
 * portmod_ext_phy_lane_detach
 *
 * @brief Detaches an external phy lane from a phy chain 
 *
 * @param [in]  unit            - unit id
 * @param [in]  iphy            - internal phy index representing the starting point of a phy chain
 * @param [in]  phyn            - indicate the external phy layer in the phy chain
 */
int portmod_ext_phy_lane_detach(int unit, int iphy, int phyn);



/*! 
 * portmod_port_lag_failover_status_toggle
 *
 * @brief Toggle Lag Failover Status. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int portmod_port_lag_failover_status_toggle(int unit, int port);

/*! 
 * portmod_port_lag_failover_loopback_set
 *
 * @brief Toggle Lag Failover loopback set / get. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - 
 */
int portmod_port_lag_failover_loopback_set(int unit, int port, int value);
/*! 
 * portmod_port_lag_failover_loopback_get
 *
 * @brief Toggle Lag Failover loopback set / get. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - 
 */
int portmod_port_lag_failover_loopback_get(int unit, int port, int* value);

/*! 
 * portmod_port_mode_set
 *
 * @brief set port mode. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mode            - 
 */
int portmod_port_mode_set(int unit, int port, const portmod_port_mode_info_t* mode);
/*! 
 * portmod_port_mode_get
 *
 * @brief set port mode. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  mode            - 
 */
int portmod_port_mode_get(int unit, int port, portmod_port_mode_info_t* mode);

/*! 
 * portmod_port_encap_set
 *
 * @brief set port encap. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - 
 * @param [in]  encap           - 
 */
int portmod_port_encap_set(int unit, int port, int flags, portmod_encap_t encap);
/*! 
 * portmod_port_encap_get
 *
 * @brief set port encap. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  flags           - 
 * @param [out]  encap           - 
 */
int portmod_port_encap_get(int unit, int port, int* flags, portmod_encap_t* encap);

/*! 
 * portmod_port_higig_mode_set
 *
 * @brief set port register higig field. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mode            - 
 */
int portmod_port_higig_mode_set(int unit, int port, int mode);
/*! 
 * portmod_port_higig_mode_get
 *
 * @brief set port register higig field. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  mode            - 
 */
int portmod_port_higig_mode_get(int unit, int port, int* mode);

/*! 
 * portmod_port_higig2_mode_set
 *
 * @brief set port register higig field. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mode            - 
 */
int portmod_port_higig2_mode_set(int unit, int port, int mode);
/*! 
 * portmod_port_higig2_mode_get
 *
 * @brief set port register higig field. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  mode            - 
 */
int portmod_port_higig2_mode_get(int unit, int port, int* mode);

/*! 
 * portmod_port_config_port_type_set
 *
 * @brief set port register port type field. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  type            - 
 */
int portmod_port_config_port_type_set(int unit, int port, int type);
/*! 
 * portmod_port_config_port_type_get
 *
 * @brief set port register port type field. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  type            - 
 */
int portmod_port_config_port_type_get(int unit, int port, int* type);

/*! 
 * portmod_port_trunk_hwfailover_config_set
 *
 * @brief set/get hwfailover for trident. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  hw_count        - 
 */
int portmod_port_trunk_hwfailover_config_set(int unit, int port, int hw_count);
/*! 
 * portmod_port_trunk_hwfailover_config_get
 *
 * @brief set/get hwfailover for trident. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - 
 */
int portmod_port_trunk_hwfailover_config_get(int unit, int port, int* enable);

/*! 
 * portmod_port_trunk_hwfailover_status_get
 *
 * @brief set/get hwfailover for trident. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  loopback        - 
 */
int portmod_port_trunk_hwfailover_status_get(int unit, int port, int* loopback);

/*! 
 * portmod_port_diag_ctrl
 *
 * @brief port diagnostics control. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  inst            - 
 * @param [in]  op_type         - 
 * @param [in]  op_cmd          - 
 * @param [in]  arg             - 
 */
int portmod_port_diag_ctrl(int unit, int port, uint32 inst, int op_type, int op_cmd, const void* arg);

/*! 
 * portmod_port_ref_clk_get
 *
 * @brief Get the reference clock value 156 or 125. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  ref_clk         - 
 */
int portmod_port_ref_clk_get(int unit, int port, int* ref_clk);

/*! 
 * portmod_port_lag_failover_disable
 *
 * @brief Disable lag failover. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int portmod_port_lag_failover_disable(int unit, int port);

/*! 
 * portmod_port_lag_remove_failover_lpbk_set
 *
 * @brief Disable lag failover. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  val             - 
 */
int portmod_port_lag_remove_failover_lpbk_set(int unit, int port, int val);
/*! 
 * portmod_port_lag_remove_failover_lpbk_get
 *
 * @brief Disable lag failover. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  val             - 
 */
int portmod_port_lag_remove_failover_lpbk_get(int unit, int port, int* val);

/*! 
 * portmod_port_cntmaxsize_set
 *
 * @brief Disable lag failover. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  val             - 
 */
int portmod_port_cntmaxsize_set(int unit, int port, int val);
/*! 
 * portmod_port_cntmaxsize_get
 *
 * @brief Disable lag failover. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  val             - 
 */
int portmod_port_cntmaxsize_get(int unit, int port, int* val);

/*! 
 * portmod_port_multi_get
 *
 * @brief Read multiple bytes get. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [inout] multi_get       - 
 */
int portmod_port_multi_get(int unit, int port, portmod_multi_get_t* multi_get);

/*! 
 * portmod_port_drain_cell_get
 *
 * @brief Get Info needed to restore after drain cells. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  drain_cells     - 
 */
int portmod_port_drain_cell_get(int unit, int port, portmod_drain_cells_t* drain_cells);

/*! 
 * portmod_port_drain_cell_stop
 *
 * @brief Restore informaation after drain cells. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  drain_cells     - 
 */
int portmod_port_drain_cell_stop(int unit, int port, const portmod_drain_cells_t* drain_cells);

/*! 
 * portmod_port_drain_cell_start
 *
 * @brief Restore informaation after drain cells. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int portmod_port_drain_cell_start(int unit, int port);

/*! 
 * portmod_port_drain_cells_rx_enable
 *
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  rx_en           - 
 */
int portmod_port_drain_cells_rx_enable(int unit, int port, int rx_en);

/*! 
 * portmod_port_egress_queue_drain_rx_en
 *
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  rx_en           - 
 */
int portmod_port_egress_queue_drain_rx_en(int unit, int port, int rx_en);

/*! 
 * portmod_port_mac_ctrl_set
 *
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  ctrl            - 
 */
int portmod_port_mac_ctrl_set(int unit, int port, uint64 ctrl);

/*! 
 * portmod_port_txfifo_cell_cnt_get
 *
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  cnt             - 
 */
int portmod_port_txfifo_cell_cnt_get(int unit, int port, uint32* cnt);

/*! 
 * portmod_port_egress_queue_drain_get
 *
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  ctrl            - 
 * @param [out]  rxen            - 
 */
int portmod_port_egress_queue_drain_get(int unit, int port, uint64* ctrl, int* rxen);

/*! 
 * portmod_port_mac_reset_set
 *
 * @brief Set/get port mac reset  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  val             - 
 */
int portmod_port_mac_reset_set(int unit, int port, int val);
/*! 
 * portmod_port_mac_reset_get
 *
 * @brief Set/get port mac reset  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  val             - 
 */
int portmod_port_mac_reset_get(int unit, int port, int* val);

/*! 
 * portmod_port_soft_reset_toggle
 *
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  idx             - 
 */
int portmod_port_soft_reset_toggle(int unit, int port, int idx);

/*! 
 * portmod_port_soft_reset
 *
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  reset_mode      - reset mode,support IN,OUT,IN-OUT
 * @param [inout] saved_rx_enable   - When reset_mode=IN,it is output. When reset_mode=OUT,it is input
 * @param [inout] saved_mac_ctrl   - When reset_mode=IN,it is output. When reset_mode=OUT,it is input
 */
int portmod_port_soft_reset(int unit, int port, portmod_mac_soft_reset_mode_t reset_mode, int* saved_rx_enable, uint64* saved_mac_ctrl);

/*! 
 * portmod_port_mac_reset_check
 *
 * @brief Check if MAC needs to be reset. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - Check for enable or disable MAC
 * @param [out]  reset           - TRUE if MAC needs to be reset
 */
int portmod_port_mac_reset_check(int unit, int port, int enable, int* reset);

/*! 
 * portmod_port_core_num_get
 *
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  core_num        - 
 */
int portmod_port_core_num_get(int unit, int port, int* core_num);


/*!
 * @struct portmod_port_higig_e2ecc_hdr_s
 * @brief PM E2ECC header . 
 */ 
typedef struct portmod_port_higig_e2ecc_hdr_s {
    uint32 words[8];
} portmod_port_higig_e2ecc_hdr_t;

/* portmod_port_higig_e2ecc_hdr_t initialization and validation */
int portmod_port_higig_e2ecc_hdr_t_validate(int unit, const portmod_port_higig_e2ecc_hdr_t* portmod_port_higig_e2ecc_hdr);
int portmod_port_higig_e2ecc_hdr_t_init(int unit, portmod_port_higig_e2ecc_hdr_t* portmod_port_higig_e2ecc_hdr);

/*! 
 * portmod_port_e2ecc_hdr_set
 *
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  e2ecc_hdr       - 
 */
int portmod_port_e2ecc_hdr_set(int unit, int port, const portmod_port_higig_e2ecc_hdr_t* e2ecc_hdr);
/*! 
 * portmod_port_e2ecc_hdr_get
 *
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  e2ecc_hdr       - 
 */
int portmod_port_e2ecc_hdr_get(int unit, int port, portmod_port_higig_e2ecc_hdr_t* e2ecc_hdr);

/*! 
 * portmod_port_e2e_enable_set
 *
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - 
 */
int portmod_port_e2e_enable_set(int unit, int port, int enable);
/*! 
 * portmod_port_e2e_enable_get
 *
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - 
 */
int portmod_port_e2e_enable_get(int unit, int port, int* enable);

/*! 
 * portmod_port_fallback_lane_get
 *
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  fallback_lane   - 
 */
int portmod_port_fallback_lane_get(int unit, int port, int* fallback_lane);

/*! 
 * portmod_port_speed_get
 *
 * @brief get the speed for the specified port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  speed           - 
 */
int portmod_port_speed_get(int unit, int port, int* speed);

/*! 
 * portmod_pm_tsc_refclock_set
 *
 * @brief TSC refere clock input and output set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  pm_id           - port macro id
 * @param [in]  ref_in          - Selects between pad and LCREF as source of refclk into this TSC PLL. 0 -- pad, 1 -- LCREF
 * @param [in]  ref_out         - Enables LCREFOUT to be driven by this TSC. 0 -- disable, 1 -- enable
 */
int portmod_pm_tsc_refclock_set(int unit, int pm_id, int ref_in, int ref_out);
/*! 
 * portmod_pm_tsc_refclock_get
 *
 * @brief TSC refere clock input and output set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  pm_id           - port macro id
 * @param [out]  ref_in          - 
 * @param [out]  ref_out         - 
 */
int portmod_pm_tsc_refclock_get(int unit, int pm_id, int* ref_in, int* ref_out);

/*! 
 * portmod_port_discard_set
 *
 * @brief Port discard set 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  discard         - Set Discardf and EP_Discard
 */
int portmod_port_discard_set(int unit, int port, int discard);

/*! 
 * portmod_port_soft_reset_set
 *
 * @brief Port soft reset set set 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  idx             - index
 * @param [in]  val             - value 0/1
 * @param [in]  flags           - 
 */
int portmod_port_soft_reset_set(int unit, int port, int idx, int val, int flags);

/*! 
 * portmod_port_tx_down
 *
 * @brief Port tx_en=0 and softreset mac 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int portmod_port_tx_down(int unit, int port);

/*! 
 * portmod_port_logical_lane_order_set
 *
 * @brief "logical lane order" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  lane_order      - ILKN Logical lane order. For pmOsILKN_50G, lane_order[N] is represent for the Nth lane; otherwise it is represent for logical lane N
 * @param [in]  lane_order_size   - Nof lanes of the ILKN port
 */
int portmod_port_logical_lane_order_set(int unit, int port, const int* lane_order, int lane_order_size);
/*! 
 * portmod_port_logical_lane_order_get
 *
 * @brief "logical lane order" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  lane_order_max_size   - Max lane numbers when get ILKN lane order
 * @param [out]  lane_order      - Logical lane order, lane_order[N] is represent for the Nth lane
 * @param [out]  lane_order_actual_size   - The actual lane numbers when get ILKN lane order
 */
int portmod_port_logical_lane_order_get(int unit, int port, int lane_order_max_size, int* lane_order, int* lane_order_actual_size);

/*! 
 * portmod_port_pgw_reconfig
 *
 * @brief reconfig pgw. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  pmode           - 
 * @param [in]  phy_port        - 
 * @param [in]  flags           - 
 */
int portmod_port_pgw_reconfig(int unit, int port, const portmod_port_mode_info_t* pmode, int phy_port, int flags);

/*! 
 * portmod_port_notify
 *
 * @brief Routine to notify internal phy of external phy link state. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  link            - link status
 */
int portmod_port_notify(int unit, int port, int link);

typedef soc_port_phy_timesync_config_t portmod_phy_timesync_config_t;

typedef _shr_port_control_phy_timesync_t portmod_port_control_phy_timesync_t;

/*! 
 * portmod_port_control_phy_timesync_set
 *
 * @brief "port control phy timesync config set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  config          - 
 * @param [in]  value           - 
 */
int portmod_port_control_phy_timesync_set(int unit, int port, portmod_port_control_phy_timesync_t config, uint64 value);
/*! 
 * portmod_port_control_phy_timesync_get
 *
 * @brief "port control phy timesync config set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  config          - 
 * @param [out]  value           - 
 */
int portmod_port_control_phy_timesync_get(int unit, int port, portmod_port_control_phy_timesync_t config, uint64* value);

/*! 
 * portmod_port_timesync_config_set
 *
 * @brief "port timesync config set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  config          - 
 */
int portmod_port_timesync_config_set(int unit, int port, const portmod_phy_timesync_config_t* config);
/*! 
 * portmod_port_timesync_config_get
 *
 * @brief "port timesync config set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  config          - 
 */
int portmod_port_timesync_config_get(int unit, int port, portmod_phy_timesync_config_t* config);

/*! 
 * portmod_port_timesync_enable_set
 *
 * @brief "port timesync enable set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - 
 */
int portmod_port_timesync_enable_set(int unit, int port, uint32 enable);
/*! 
 * portmod_port_timesync_enable_get
 *
 * @brief "port timesync enable set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - 
 */
int portmod_port_timesync_enable_get(int unit, int port, uint32* enable);

/*! 
 * portmod_port_timesync_nco_addend_set
 *
 * @brief "port timesync nco addend  set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  freq_step       - NCO Frequency Step.
 */
int portmod_port_timesync_nco_addend_set(int unit, int port, uint32 freq_step);
/*! 
 * portmod_port_timesync_nco_addend_get
 *
 * @brief "port timesync nco addend  set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  freq_step       - NCO Frequency Step.
 */
int portmod_port_timesync_nco_addend_get(int unit, int port, uint32* freq_step);

typedef phymod_timesync_framesync_t portmod_timesync_framesync_t;

/*! 
 * portmod_port_timesync_framesync_mode_set
 *
 * @brief "port timesync framesync info  set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  framesync       - Framesync Info.
 */
int portmod_port_timesync_framesync_mode_set(int unit, int port, const portmod_timesync_framesync_t* framesync);
/*! 
 * portmod_port_timesync_framesync_mode_get
 *
 * @brief "port timesync framesync info  set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  framesync       - Framesync Info.
 */
int portmod_port_timesync_framesync_mode_get(int unit, int port, portmod_timesync_framesync_t* framesync);

/*! 
 * portmod_port_timesync_local_time_set
 *
 * @brief "port timesync local time  set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  local_time      - Local Time.
 */
int portmod_port_timesync_local_time_set(int unit, int port, uint64 local_time);
/*! 
 * portmod_port_timesync_local_time_get
 *
 * @brief "port timesync local time  set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  local_time      - Local Time.
 */
int portmod_port_timesync_local_time_get(int unit, int port, uint64* local_time);

/*! 
 * portmod_port_timesync_load_ctrl_set
 *
 * @brief "port timesync framesync info  set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  load_once       - Load Once.
 * @param [in]  load_always     - Load Always.
 */
int portmod_port_timesync_load_ctrl_set(int unit, int port, uint32 load_once, uint32 load_always);
/*! 
 * portmod_port_timesync_load_ctrl_get
 *
 * @brief "port timesync framesync info  set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  load_once       - Load Once.
 * @param [out]  load_always     - Load Always.
 */
int portmod_port_timesync_load_ctrl_get(int unit, int port, uint32* load_once, uint32* load_always);

/*! 
 * portmod_port_timesync_tx_timestamp_offset_set
 *
 * @brief "port timesync tx timestamp offset set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  ts_offset       - TX AFE Delay in ns.
 */
int portmod_port_timesync_tx_timestamp_offset_set(int unit, int port, uint32 ts_offset);
/*! 
 * portmod_port_timesync_tx_timestamp_offset_get
 *
 * @brief "port timesync tx timestamp offset set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  ts_offset       - TX AFE Delay in ns.
 */
int portmod_port_timesync_tx_timestamp_offset_get(int unit, int port, uint32* ts_offset);

/*! 
 * portmod_port_timesync_rx_timestamp_offset_set
 *
 * @brief "port timesync rx timestamp offset set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  ts_offset       - RX AFE Delay in ns.
 */
int portmod_port_timesync_rx_timestamp_offset_set(int unit, int port, uint32 ts_offset);
/*! 
 * portmod_port_timesync_rx_timestamp_offset_get
 *
 * @brief "port timesync rx timestamp offset set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  ts_offset       - RX AFE Delay in ns.
 */
int portmod_port_timesync_rx_timestamp_offset_get(int unit, int port, uint32* ts_offset);

/*! 
 * portmod_port_timestamp_adjust_set
 *
 * @brief "port timestamp adjust set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  ts_adjust       - TSTS,OSTS adjust.
 */
int portmod_port_timestamp_adjust_set(int unit, int port, const soc_port_timestamp_adjust_t* ts_adjust);
/*! 
 * portmod_port_timestamp_adjust_get
 *
 * @brief "port timestamp adjust set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  ts_adjust       - TSTS,OSTS adjust.
 */
int portmod_port_timestamp_adjust_get(int unit, int port, soc_port_timestamp_adjust_t* ts_adjust);

/*! 
 * portmod_port_phy_intr_enable_set
 *
 * @brief "port timesync interrupt mask set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  intr_enable     - Interrupt Eanble.
 */
int portmod_port_phy_intr_enable_set(int unit, int port, uint32 intr_enable);
/*! 
 * portmod_port_phy_intr_enable_get
 *
 * @brief "port timesync interrupt mask set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  intr_enable     - Interrupt Eanble.
 */
int portmod_port_phy_intr_enable_get(int unit, int port, uint32* intr_enable);

/*! 
 * portmod_port_phy_intr_status_get
 *
 * @brief "port phy interrupt status get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  intr_status     - Interrupt Status.
 */
int portmod_port_phy_intr_status_get(int unit, int port, uint32* intr_status);

/*! 
 * portmod_port_phy_intr_status_clear
 *
 * @brief "port phy interrupt status clear" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int portmod_port_phy_intr_status_clear(int unit, int port);

/*! 
 * portmod_port_phy_timesync_do_sync
 *
 * @brief "port timesync force frame sync." 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int portmod_port_phy_timesync_do_sync(int unit, int port);

/*! 
 * portmod_port_timesync_capture_timestamp_get
 *
 * @brief "port timesync capture timestamp get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  cap_ts          - Capture Timestamp.
 */
int portmod_port_timesync_capture_timestamp_get(int unit, int port, uint64* cap_ts);

/*! 
 * portmod_port_timesync_heartbeat_timestamp_get
 *
 * @brief "port timesync heartbeat timestamp get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  hb_ts           - Heartbeat Timestamp.
 */
int portmod_port_timesync_heartbeat_timestamp_get(int unit, int port, uint64* hb_ts);

typedef phymod_edc_config_t portmod_edc_config_t;

/*! 
 * portmod_port_edc_config_set
 *
 * @brief "port timesync tx timestamp offset set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  config          - Electronic Dispersion Compensation config.
 */
int portmod_port_edc_config_set(int unit, int port, const portmod_edc_config_t* config);
/*! 
 * portmod_port_edc_config_get
 *
 * @brief "port timesync tx timestamp offset set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  config          - Electronic Dispersion Compensation config..
 */
int portmod_port_edc_config_get(int unit, int port, portmod_edc_config_t* config);

/*! 
 * portmod_port_interrupt_enable_set
 *
 * @brief set/get interrupt enable value.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  intr_type       - portmod_intr_type_t enum
 * @param [out]  val             - value write
 */
int portmod_port_interrupt_enable_set(int unit, int port, int intr_type, uint32 val);
/*! 
 * portmod_port_interrupt_enable_get
 *
 * @brief set/get interrupt enable value.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  intr_type       - portmod_intr_type_t enum
 * @param [out]  val             - value read
 */
int portmod_port_interrupt_enable_get(int unit, int port, int intr_type, uint32* val);

/*! 
 * portmod_port_interrupt_get
 *
 * @brief get interrupt status value.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  intr_type       - portmod_intr_type_t enum
 * @param [out]  val             - value read
 */
int portmod_port_interrupt_get(int unit, int port, int intr_type, uint32* val);

/*! 
 * portmod_port_interrupts_get
 *
 * @brief get interrupt value array.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  arr_max_size    - maximum size of output array
 * @param [out]  intr_arr        - array of intr status
 * @param [out]  size            - actual siz of output array
 */
int portmod_port_interrupts_get(int unit, int port, int arr_max_size, uint32* intr_arr, uint32* size);

#define PORTMOD_PORT_REG_ACCESS_DEFAULT (0)
#define PORTMOD_PORT_REG_ACCESS_DIRECT (1)

#define PORTMOD_PORT_PGW_CONFIGURE (0)
#define PORTMOD_PORT_PGW_MAC_RESET (1)
#define PORTMOD_PORT_PGW_POWER_SAVE (2)
#define PORTMOD_PORT_PGW_MAC_UNRESET (3)


/*!
 * @enum portmod_stat_val_e
 * @brief portmod statistics  
 */ 
typedef enum portmod_stat_val_e {
    portmodIfInOctets = 0,
    portmodIfInUcastPkts = 1,
    portmodIfInNUcastPkts = 2,
    portmodIfInBroadcastPkts = 3,
    portmodIfInMulticastPkts = 4,
    portmodIfInDiscards = 5,
    portmodIfInErrors = 6,
    portmodIfOutOctets = 7,
    portmodIfOutUcastPkts = 8,
    portmodIfOutNUcastPkts = 9,
    portmodIfOutBroadcastPkts = 10,
    portmodIfOutMulticastPkts = 11,
    portmodIfOutDiscards = 12,
    portmodIfOutErrors = 13,
    portmodIpInReceives = 14,
    portmodIpInHdrErrors = 15,
    portmodIpForwDatagrams = 16,
    portmodIpInDiscards = 17,
    portmodDot1dBasePortMtuExceededDiscards = 18,
    portmodDot1dTpPortInFrames = 19,
    portmodDot1dTpPortOutFrames = 20,
    portmodDot1dPortInDiscards = 21,
    portmodEtherStatsDropEvents = 22,
    portmodEtherStatsOctets = 23,
    portmodEtherStatsPkts = 24,
    portmodEtherStatsBroadcastPkts = 25,
    portmodEtherStatsMulticastPkts = 26,
    portmodEtherStatsCRCAlignErrors = 27,
    portmodEtherStatsUndersizePkts = 28,
    portmodEtherStatsOversizePkts = 29,
    portmodEtherRxOversizePkts = 30,
    portmodEtherTxOversizePkts = 31,
    portmodEtherStatsFragments = 32,
    portmodEtherStatsJabbers = 33,
    portmodEtherStatsPkts64Octets = 34,
    portmodEtherStatsPkts65to127Octets = 35,
    portmodEtherStatsPkts128to255Octets = 36,
    portmodEtherStatsPkts256to511Octets = 37,
    portmodEtherStatsPkts512to1023Octets = 38,
    portmodEtherStatsPkts1024to1518Octets = 39,
    portmodBcmEtherStatsPkts1519to1522Octets = 40,
    portmodBcmEtherStatsPkts1522to2047Octets = 41,
    portmodBcmEtherStatsPkts2048to4095Octets = 42,
    portmodBcmEtherStatsPkts4095to9216Octets = 43,
    portmodBcmEtherStatsPkts9217to16383Octets = 44,
    portmodBcmReceivedPkts64Octets = 45,
    portmodBcmReceivedPkts65to127Octets = 46,
    portmodBcmReceivedPkts128to255Octets = 47,
    portmodBcmReceivedPkts256to511Octets = 48,
    portmodBcmReceivedPkts512to1023Octets = 49,
    portmodBcmReceivedPkts1024to1518Octets = 50,
    portmodBcmReceivedPkts1519to2047Octets = 51,
    portmodBcmReceivedPkts2048to4095Octets = 52,
    portmodBcmReceivedPkts4095to9216Octets = 53,
    portmodBcmReceivedPkts9217to16383Octets = 54,
    portmodBcmTransmittedPkts64Octets = 55,
    portmodBcmTransmittedPkts65to127Octets = 56,
    portmodBcmTransmittedPkts128to255Octets = 57,
    portmodBcmTransmittedPkts256to511Octets = 58,
    portmodBcmTransmittedPkts512to1023Octets = 59,
    portmodBcmTransmittedPkts1024to1518Octets = 60,
    portmodBcmTransmittedPkts1519to2047Octets = 61,
    portmodBcmTransmittedPkts2048to4095Octets = 62,
    portmodBcmTransmittedPkts4095to9216Octets = 63,
    portmodBcmTransmittedPkts9217to16383Octets = 64,
    portmodEtherStatsTXNoErrors = 65,
    portmodEtherStatsRXNoErrors = 66,
    portmodDot3StatsFCSErrors = 67,
    portmodDot3StatsInternalMacTransmitErrors = 68,
    portmodDot3StatsFrameTooLongs = 69,
    portmodDot3StatsSymbolErrors = 70,
    portmodDot3ControlInUnknownOpcodes = 71,
    portmodDot3InPauseFrames = 72,
    portmodDot3OutPauseFrames = 73,
    portmodIfHCInOctets = 74,
    portmodIfHCInUcastPkts = 75,
    portmodIfHCInMulticastPkts = 76,
    portmodIfHCInBroadcastPkts = 77,
    portmodIfHCOutOctets = 78,
    portmodIfHCOutUcastPkts = 79,
    portmodIfHCOutMulticastPkts = 80,
    portmodIfHCOutBroadcastPckts = 81,
    portmodIpv6IfStatsInReceives = 82,
    portmodIpv6IfStatsInHdrErrors = 83,
    portmodIpv6IfStatsInAddrErrors = 84,
    portmodIpv6IfStatsInDiscards = 85,
    portmodIpv6IfStatsOutForwDatagrams = 86,
    portmodIpv6IfStatsOutDiscards = 87,
    portmodIpv6IfStatsInMcastPkts = 88,
    portmodIpv6IfStatsOutMcastPkts = 89,
    portmodIeee8021PfcRequests = 90,
    portmodIeee8021PfcIndications = 91,
    portmodBcmIPMCBridgedPckts = 92,
    portmodBcmIPMCRoutedPckts = 93,
    portmodBcmIPMCInDroppedPckts = 94,
    portmodBcmIPMCOutDroppedPckts = 95,
    portmodBcmRxVlanTagFrame = 96,
    portmodBcmRxDoubleVlanTagFrame = 97,
    portmodBcmTxVlanTagFrame = 98,
    portmodBcmTxDoubleVlanTagFrame = 99,
    portmodBcmRxPFCControlFrame = 100,
    portmodBcmTxPFCControlFrame = 101,
    portmodBcmRxPFCFramePriority0 = 102,
    portmodBcmRxPFCFramePriority1 = 103,
    portmodBcmRxPFCFramePriority2 = 104,
    portmodBcmRxPFCFramePriority3 = 105,
    portmodBcmRxPFCFramePriority4 = 106,
    portmodBcmRxPFCFramePriority5 = 107,
    portmodBcmRxPFCFramePriority6 = 108,
    portmodBcmRxPFCFramePriority7 = 109,
    portmodBcmTxPFCFramePriority0 = 110,
    portmodBcmTxPFCFramePriority1 = 111,
    portmodBcmTxPFCFramePriority2 = 112,
    portmodBcmTxPFCFramePriority3 = 113,
    portmodBcmTxPFCFramePriority4 = 114,
    portmodBcmTxPFCFramePriority5 = 115,
    portmodBcmTxPFCFramePriority6 = 116,
    portmodBcmTxPFCFramePriority7 = 117,
    portmodCount
} portmod_stat_val_t;

#ifdef PORTMOD_DIAG
extern enum_mapping_t portmod_stat_val_t_mapping[];
#endif /*PORTMOD_DIAG*/

/* portmod_stat_val_t validation */
int portmod_stat_val_t_validate(int unit, portmod_stat_val_t portmod_stat_val);
/*! 
 * portmod_port_stats_read
 *
 * @brief  portmod stats read  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  cntr_type       - counter type
 * @param [out]  value           - read value
 */
int portmod_port_stats_read(int unit, int port, portmod_stat_val_t cntr_type, uint64* value);

/*! 
 * portmod_port_stats_clear
 *
 * @brief  portmod stats clear  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  cntr_type       - counter type
 */
int portmod_port_stats_clear(int unit, int port, portmod_stat_val_t cntr_type);

/*! 
 * portmod_port_check_legacy_phy
 *
 * @brief  portmod check if external phy is legacy 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  legacy_phy      - check if phy is legacy
 */
int portmod_port_check_legacy_phy(int unit, int port, int* legacy_phy);

/*! 
 * portmod_port_failover_mode_set
 *
 * @brief  portmod phy failover mode 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  failover        - Failover Mode set
 */
int portmod_port_failover_mode_set(int unit, int port, phymod_failover_mode_t failover);
/*! 
 * portmod_port_failover_mode_get
 *
 * @brief  portmod phy failover mode 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  failover        - Failover Mode get
 */
int portmod_port_failover_mode_get(int unit, int port, phymod_failover_mode_t* failover);



/*! 
 * portmod_port_warmboot_db_restore
 *
 * @brief  portmod restore information after warmboot 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  intf_config     - 
 * @param [in]  init_config     - 
 * @param [in]  phy_op_mode     - 
 */
int portmod_port_warmboot_db_restore(int unit, int port, const portmod_port_interface_config_t* intf_config, const portmod_port_init_config_t* init_config, phymod_operation_mode_t phy_op_mode);

/*! 
 * portmod_port_flow_control_set
 *
 * @brief  portmod port flow control config 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  merge_mode_en   - merge_mode
 * @param [in]  parallel_fc_en   - Parallel Flow control enable
 */
int portmod_port_flow_control_set(int unit, int port, int merge_mode_en, int parallel_fc_en);


/*! 
 * @brief Flags for phy init 
 */ 
#define PORTMOD_INIT_F_EXTERNAL_MOST_ONLY 0 /**< init external most phy */
#define PORTMOD_INIT_F_ALL_PHYS 1 /**< init all phys */
#define PORTMOD_INIT_F_INTERNAL_SERDES_ONLY 2 /**< init internal serdes */
#define PORTMOD_INIT_F_EXTERNAL_PHYS_ONLY 3 /**< init external phys */
#define PORTMOD_INIT_F_TX_ONLY 4 /**< init Tx side only */
#define PORTMOD_INIT_F_RX_ONLY 5 /**< init Rx side only */


/*! 
 * portmod_port_update_dynamic_state
 *
 * @brief Portmod state for any logical port dynamixc settings 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  port_dynamic_state   - flag to specify if the user updated any HW params from its defauklt value
 */
int portmod_port_update_dynamic_state(int unit, int port, uint32_t port_dynamic_state);

/*! 
 * portmod_port_phy_op_mode_get
 *
 * @brief get phy operation mode.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  val             - value read
 */
int portmod_port_phy_op_mode_get(int unit, int port, phymod_operation_mode_t* val);

/*! 
 * @brief Flags for port lane map 
 */ 
#define PORTMOD_LANE_MAP_MAC_ONLY 0x1 /**< mac only lane map */

#define PORTMOD_LANE_MAP_MAC_ONLY_SET(flags) ((flags) |= PORTMOD_LANE_MAP_MAC_ONLY)

#define PORTMOD_LANE_MAP_MAC_ONLY_CLR(flags) ((flags) &= ~PORTMOD_LANE_MAP_MAC_ONLY)

#define PORTMOD_LANE_MAP_MAC_ONLY_GET(flags) ((flags) & PORTMOD_LANE_MAP_MAC_ONLY ? 1 : 0)

/*! 
 * portmod_port_lane_map_set
 *
 * @brief override function for board lane swap.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - configuration flags
 * @param [in]  lane_map        - lane map
 */
int portmod_port_lane_map_set(int unit, int port, uint32 flags, const phymod_lane_map_t* lane_map);
/*! 
 * portmod_port_lane_map_get
 *
 * @brief override function for board lane swap.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - configuration flags
 * @param [out]  lane_map        - lane map
 */
int portmod_port_lane_map_get(int unit, int port, uint32 flags, phymod_lane_map_t* lane_map);

/*! 
 * portmod_port_polarity_set
 *
 * @brief override function for board lane swap.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  polarity        - polarity
 */
int portmod_port_polarity_set(int unit, int port, const phymod_polarity_t* polarity);
/*! 
 * portmod_port_polarity_get
 *
 * @brief override function for board lane swap.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  polarity        - polarity
 */
int portmod_port_polarity_get(int unit, int port, phymod_polarity_t* polarity);

/*! 
 * portmod_port_medium_config_set
 *
 * @brief set/get port medium type config.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  medium          - port medium
 * @param [out]  config          - phy config
 */
int portmod_port_medium_config_set(int unit, int port, soc_port_medium_t medium, soc_phy_config_t* config);
/*! 
 * portmod_port_medium_config_get
 *
 * @brief set/get port medium type config.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  medium          - port medium
 * @param [out]  config          - phy config
 */
int portmod_port_medium_config_get(int unit, int port, soc_port_medium_t medium, soc_phy_config_t* config);

/*! 
 * portmod_port_medium_get
 *
 * @brief get port medium type.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  medium          - port medium
 */
int portmod_port_medium_get(int unit, int port, soc_port_medium_t* medium);



/*! 
 * @brief Flags for user access struct 
 */ 
#define PORTMOD_SERDES_1000X_AT_6250 0x1 /**< 1000x working at 6.25g */
#define PORTMOD_SERDES_1000X_AT_12500 0x2 /**< 1000x working at 12.5g */
#define PORTMOD_SERDES_1000X_AT_25G 0x4 /**< 1000x working at 25g */
#define PORTMOD_SERDES_10G_AT_25G 0x8 /**< 10g working at 25g */

#define PORTMOD_SERDES_1000X_AT_6250_SET(flag) ((flag) |= PORTMOD_SERDES_1000X_AT_6250)
#define PORTMOD_SERDES_1000X_AT_12500_SET(flag) ((flag) |= PORTMOD_SERDES_1000X_AT_12500)
#define PORTMOD_SERDES_1000X_AT_25G_SET(flag) ((flag) |= PORTMOD_SERDES_1000X_AT_25G)
#define PORTMOD_SERDES_10G_AT_25G_SET(flag) ((flag) |= PORTMOD_SERDES_10G_AT_25G)

#define PORTMOD_SERDES_1000X_AT_6250_CLR(flag) ((flag) &= ~PORTMOD_SERDES_1000X_AT_6250)
#define PORTMOD_SERDES_1000X_AT_12500_CLR(flag) ((flag) &= ~PORTMOD_SERDES_1000X_AT_12500)
#define PORTMOD_SERDES_1000X_AT_25G_CLR(flag) ((flag) &= ~PORTMOD_SERDES_1000X_AT_25G)
#define PORTMOD_SERDES_10G_AT_25G_CLR(flag) ((flag) &= ~PORTMOD_SERDES_10G_AT_25G)

#define PORTMOD_SERDES_1000X_AT_6250_GET(flag) ((flag) & PORTMOD_SERDES_1000X_AT_6250 ? 1 : 0)
#define PORTMOD_SERDES_1000X_AT_12500_GET(flag) ((flag) & PORTMOD_SERDES_1000X_AT_12500 ? 1 : 0)
#define PORTMOD_SERDES_1000X_AT_25G_GET(flag) ((flag) & PORTMOD_SERDES_1000X_AT_25G ? 1 : 0)
#define PORTMOD_SERDES_10G_AT_25G_GET(flag) ((flag) & PORTMOD_SERDES_10G_AT_25G ? 1 : 0)


/*!
 * @struct portmod_port_resources_s
 * @brief portmod port resources for flex port 
 */ 
typedef struct portmod_port_resources_s {
    portmod_dispatch_type_t pm_type; /**< portmod dispatch type */
    int speed; /**< speed at which port will be flexed */
    int num_lane; /**< lanes of flex port */
    portmod_encap_t encap_mode; /**< flex port encap mode */
    uint32_t flag; /**< same speed working at different VCO */
} portmod_port_resources_t;

/* portmod_port_resources_t initialization and validation */
int portmod_port_resources_t_validate(int unit, const portmod_port_resources_t* portmod_port_resources);
int portmod_port_resources_t_init(int unit, portmod_port_resources_t* portmod_port_resources);

/*! 
 * portmod_pm_port_pll_div_get
 *
 * @brief dispatch [portmacro]_pll_div_get based on the pm_type in portmod_port_resources_t 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - port
 * @param [in]  phy_port        - physical port
 * @param [in]  port_resource   - port resource
 * @param [out]  pll_div         -  pll div
 */
int portmod_pm_port_pll_div_get(int unit, int port, int phy_port, const portmod_port_resources_t* port_resource, uint32_t* pll_div);


/*! 
 * portmod_port_master_set
 *
 * @brief set/get the port master mode if the port is running SGMII AN 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  master_mode     - set port master mode
 */
int portmod_port_master_set(int unit, int port, int master_mode);
/*! 
 * portmod_port_master_get
 *
 * @brief set/get the port master mode if the port is running SGMII AN 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  master_mode     - get port master mode
 */
int portmod_port_master_get(int unit, int port, int* master_mode);


/*!
 * @enum portmod_preemption_control_e
 * @brief Preemption controls for portmod_preemption_control_set, portmod_preemption_control_get 
 */ 
typedef enum portmod_preemption_control_e {
    portmodPreemptionControlInvalid = 0, /**< Invalid Control */
    portmodPreemptionControlPreemptionSupport = 1, /**< Support preemption operation. */
    portmodPreemptionControlEnableTx = 2, /**< Enable preemption in transmit direction. */
    portmodPreemptionControlVerifyEnable = 3, /**< Enable preemption verify operation. */
    portmodPreemptionControlVerifyTime = 4, /**< The wait time in ms between verification attempts. */
    portmodPreemptionControlVerifyAttempts = 5, /**< The number of verification attempts. */
    portmodPreemptionControlNonFinalFragSizeRx = 6, /**< The minimum size of non-final fragment of a packet in receive direction. */
    portmodPreemptionControlFinalFragSizeRx = 7, /**< The minimum size of final fragment of a packet in receive direction. */
    portmodPreemptionControlCount
} portmod_preemption_control_t;

#ifdef PORTMOD_DIAG
extern enum_mapping_t portmod_preemption_control_t_mapping[];
#endif /*PORTMOD_DIAG*/

/* portmod_preemption_control_t validation */
int portmod_preemption_control_t_validate(int unit, portmod_preemption_control_t portmod_preemption_control);
/*! 
 * portmod_preemption_control_set
 *
 * @brief Port preemption configuration set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  type            - preemption parameter of type portmod_preemption_control_t
 * @param [in]  value           - configured value
 */
int portmod_preemption_control_set(int unit, int port, portmod_preemption_control_t type, uint32 value);
/*! 
 * portmod_preemption_control_get
 *
 * @brief Port preemption configuration set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  type            - preemption parameter of type portmod_preemption_control_t
 * @param [out]  value           - returns configured value
 */
int portmod_preemption_control_get(int unit, int port, portmod_preemption_control_t type, uint32* value);


/*!
 * @enum portmod_preemption_tx_status_e
 * @brief Preemption status in the transmit direction, used by portmod_preemption_tx_status_get 
 */ 
typedef enum portmod_preemption_tx_status_e {
    portmodPreemptionTxStatusInactive = 0, /**< Verify is enabled but its status is either failed or not initiated. Or Preemption is not enabled. */
    portmodPreemptionTxStatusVerifying = 1, /**< Preemption is enabled and proceeding the verify operation. */
    portmodPreemptionTxStatusActive = 2, /**< Preemption is activated. */
    portmodPreemptionTxStatusCount
} portmod_preemption_tx_status_t;

#ifdef PORTMOD_DIAG
extern enum_mapping_t portmod_preemption_tx_status_t_mapping[];
#endif /*PORTMOD_DIAG*/

/* portmod_preemption_tx_status_t validation */
int portmod_preemption_tx_status_t_validate(int unit, portmod_preemption_tx_status_t portmod_preemption_tx_status);
/*! 
 * portmod_preemption_tx_status_get
 *
 * @brief Get the preemption status on the transmit side 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - returns preemption status of type portmod_preemption_tx_status_t
 */
int portmod_preemption_tx_status_get(int unit, int port, uint32* value);

typedef enum portmod_preemption_verify_status_type_e {
    portmodPreemptionVerifyStatus = 0, /**< Verify operation status. */
    portmodPreemptionVerifyCountStatus = 1, /**< Verify operation status of number of attempts. */
    portmodPreemptionVerifyCount
} portmod_preemption_verify_status_type_t;

#ifdef PORTMOD_DIAG
extern enum_mapping_t portmod_preemption_verify_status_type_t_mapping[];
#endif /*PORTMOD_DIAG*/

/* portmod_preemption_verify_status_type_t validation */
int portmod_preemption_verify_status_type_t_validate(int unit, portmod_preemption_verify_status_type_t portmod_preemption_verify_status_type);
typedef enum portmod_preemption_verify_status_e {
    portmodPreemptionVerifyStatusDisabled = 0, /**< Verify operation is not enabled. */
    portmodPreemptionVerifyStatusInitial = 1, /**< Verify operation is enabled but the not started yet. */
    portmodPreemptionVerifyStatusInProgress = 2, /**< Verify operation is in progress. */
    portmodPreemptionVerifyStatusSucceeded = 3, /**< Verify operation is succeeded. */
    portmodPreemptionVerifyStatusFailed = 4, /**< Verify operation is failed. */
    portmodPreemptionVerifyStatusCount
} portmod_preemption_verify_status_t;

#ifdef PORTMOD_DIAG
extern enum_mapping_t portmod_preemption_verify_status_t_mapping[];
#endif /*PORTMOD_DIAG*/

/* portmod_preemption_verify_status_t validation */
int portmod_preemption_verify_status_t_validate(int unit, portmod_preemption_verify_status_t portmod_preemption_verify_status);
/*! 
 * portmod_preemption_verify_status_get
 *
 * @brief Get the preemption verification status or status on number of verify attempts/messages if verification is not complete(failed/succeed) 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  type            - preemption verify operaton status of type portmod_preemption_verify_status_type_t
 * @param [out]  value           - returns verify operation status of type portmod_preemption_verify_status_t
 */
int portmod_preemption_verify_status_get(int unit, int port, portmod_preemption_verify_status_type_t type, uint32* value);

typedef enum portmod_preemption_force_rx_eop_mode_e {
    portmodPreemptionForceSwRxEop = 0, /**< Forced SW Rx lost EOP sequence */
    portmodPreemptionForceAutoHwEop = 1, /**< Forced Auto HW Rx lost EOP sequence */
    portmodPreemptionForceCount
} portmod_preemption_force_rx_eop_mode_t;

#ifdef PORTMOD_DIAG
extern enum_mapping_t portmod_preemption_force_rx_eop_mode_t_mapping[];
#endif /*PORTMOD_DIAG*/

/* portmod_preemption_force_rx_eop_mode_t validation */
int portmod_preemption_force_rx_eop_mode_t_validate(int unit, portmod_preemption_force_rx_eop_mode_t portmod_preemption_force_rx_eop_mode);
/*! 
 * portmod_preemption_force_rx_eop_mode_set
 *
 * @brief Set/Get preemption forced rx lost eop sequence mode setting. The rx  lost eop sequence can be either software or hardware enforced. If Hw based auto rx lost eop is enabled,  the rx eop sequence is initiated based on link events. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  type            - indicates SW or HW enforced EOP of type portmod_preemption_force_rx_eop_mode_t
 * @param [in]  value           - 0 - disable, 1 - enable
 */
int portmod_preemption_force_rx_eop_mode_set(int unit, int port, portmod_preemption_force_rx_eop_mode_t type, uint32 value);
/*! 
 * portmod_preemption_force_rx_eop_mode_get
 *
 * @brief Set/Get preemption forced rx lost eop sequence mode setting. The rx  lost eop sequence can be either software or hardware enforced. If Hw based auto rx lost eop is enabled,  the rx eop sequence is initiated based on link events. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  type            - indicates SW or HW enforced EOP of type portmod_preemption_force_rx_eop_mode_t
 * @param [out]  value           - returns enabled(1)/disabled(0)
 */
int portmod_preemption_force_rx_eop_mode_get(int unit, int port, portmod_preemption_force_rx_eop_mode_t type, uint32* value);

/*! 
 * portmod_preemption_rx_timeout_set
 *
 * @brief Set/Get specified preemption rx timeout and timeout count. This API is not exposed to end user, and needs to be called only during device init. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - enables timeout for rx preempt traffic
 * @param [in]  timeout_cnt     - timeout in microsecs
 */
int portmod_preemption_rx_timeout_set(int unit, int port, uint32 enable, uint32 timeout_cnt);
/*! 
 * portmod_preemption_rx_timeout_get
 *
 * @brief Set/Get specified preemption rx timeout and timeout count. This API is not exposed to end user, and needs to be called only during device init. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - returns status of timeout for rx preempt traffic
 * @param [out]  timeout_cnt     -  timeout in microsecs
 */
int portmod_preemption_rx_timeout_get(int unit, int port, uint32* enable, uint32* timeout_cnt);


/*! 
 * portmod_port_timesync_tx_info_get
 *
 * @brief Get timestamp and sequence id of tx 1588 packet. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  tx_info         - tx information of 1588 packet
 */
int portmod_port_timesync_tx_info_get(int unit, int port, portmod_fifo_status_t* tx_info);


#define PORTMOD_LINK_RECOVERY_STATE_LINK_GOOD 0x1 /**< link good state */
#define PORTMOD_LINK_RECOVERY_STATE_WAIT_FOR_LINK 0x2 /**< wait for link up state */
#define PORTMOD_LINK_RECOVERY_STATE_RESET_RX 0x3 /**< reset rx state */
#define PORTMOD_LINK_RECOVERY_LINK_WAIT_CNT_LIMIT 0x6 /**< timeout count before reset rx */


/*!
 * @struct portmod_link_recovery_s
 * @brief link recovery for optics. 
 */ 
typedef struct portmod_link_recovery_s {
    uint32 state; /**< state of the link recovery */
    uint32 enabled; /**< feature enabled or not */
    uint32 tick_cnt; /**< timeout counter */
} portmod_link_recovery_t;

/* portmod_link_recovery_t initialization and validation */
int portmod_link_recovery_t_validate(int unit, const portmod_link_recovery_t* portmod_link_recovery);
int portmod_link_recovery_t_init(int unit, portmod_link_recovery_t* portmod_link_recovery);

/*! 
 * @brief Flags for pm enable set. 
 */ 
#define PORTMOD_CORE_ADD_SKIP_MAC 0x1 /**< do not configure MAC */
#define PORTMOD_CORE_ADD_FORCE_MAC 0x2 /**< configure MAC even if core is initialized */

#define PORTMOD_CORE_ADD_SKIP_MAC_SET(flags) ((flags) |= PORTMOD_CORE_ADD_SKIP_MAC)
#define PORTMOD_CORE_ADD_FORCE_MAC_SET(flags) ((flags) |= PORTMOD_CORE_ADD_FORCE_MAC)

#define PORTMOD_CORE_ADD_SKIP_MAC_CLR(flags) ((flags) &= ~PORTMOD_CORE_ADD_SKIP_MAC)
#define PORTMOD_CORE_ADD_FORCE_MAC_CLR(flags) ((flags) &= ~PORTMOD_CORE_ADD_FORCE_MAC)

#define PORTMOD_CORE_ADD_SKIP_MAC_GET(flags) ((flags) & PORTMOD_CORE_ADD_SKIP_MAC ? 1 : 0)
#define PORTMOD_CORE_ADD_FORCE_MAC_GET(flags) ((flags) & PORTMOD_CORE_ADD_FORCE_MAC ? 1 : 0)

/*! 
 * portmod_core_add
 *
 * @brief PM Core init routine for DNX devices; XGS does not call this API but calls portmod_pm_serdes_core_init() directly 
 *
 * @param [in]  unit            - unit id
 * @param [in]  pm_id           - port macro id
 * @param [in]  flags           - flags
 * @param [in]  add_info        - 
 */
int portmod_core_add(int unit, int pm_id, int flags, const portmod_port_add_info_t* add_info);

/*! 
 * portmod_pm_serdes_core_init
 *
 * @brief PM Core init routine 
 *
 * @param [in]  unit            - unit id
 * @param [in]  pm_id           - port macro id
 * @param [in]  add_info        - 
 */
int portmod_pm_serdes_core_init(int unit, int pm_id, const portmod_port_add_info_t* add_info);

/*! 
 * portmod_pm_is_initialized
 *
 * @brief Returns if the PortMacro associated with the port is initialized or not 
 *
 * @param [in]  unit            - unit id
 * @param [in]  pm_id           - port macro id
 * @param [out]  is_initialized   - indicates if PM is initialized
 */
int portmod_pm_is_initialized(int unit, int pm_id, int* is_initialized);

typedef struct portmod_pmd_lane_config_s {
    phymod_firmware_lane_config_t pmd_firmware_lane_config; /**< pmd firmware_lane config info */
    uint32_t pam4_channel_loss; /**< pam4 channel loss in DB */
} portmod_pmd_lane_config_t;

/* portmod_pmd_lane_config_t initialization and validation */
int portmod_pmd_lane_config_t_validate(int unit, const portmod_pmd_lane_config_t* portmod_pmd_lane_config);
int portmod_pmd_lane_config_t_init(int unit, portmod_pmd_lane_config_t* portmod_pmd_lane_config);

/*! 
 * portmod_port_speed_config_validate
 *
 * @brief Port speed validation. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  speed_config    - port speed config
 * @param [out]  affected_pbmp   - Port bit map for affected ports
 */
int portmod_port_speed_config_validate(int unit, int port, const portmod_speed_config_t* speed_config, portmod_pbmp_t* affected_pbmp);

/*! 
 * @brief Flags for pm enable set. 
 */ 
#define PORTMOD_PM_ENABLE_SKIP_MAC 0x1 /**< do not configure MAC */
#define PORTMOD_PM_ENABLE_MAC_ONLY 0x2 /**< configure MAC only */

#define PORTMOD_PM_ENABLE_SKIP_MAC_SET(flags) ((flags) |= PORTMOD_PM_ENABLE_SKIP_MAC)
#define PORTMOD_PM_ENABLE_MAC_ONLY_SET(flags) ((flags) |= PORTMOD_PM_ENABLE_MAC_ONLY)

#define PORTMOD_PM_ENABLE_SKIP_MAC_CLR(flags) ((flags) &= ~PORTMOD_PM_ENABLE_SKIP_MAC)
#define PORTMOD_PM_ENABLE_MAC_ONLY_CLR(flags) ((flags) &= ~PORTMOD_PM_ENABLE_MAC_ONLY)

#define PORTMOD_PM_ENABLE_SKIP_MAC_GET(flags) ((flags) & PORTMOD_PM_ENABLE_SKIP_MAC ? 1 : 0)
#define PORTMOD_PM_ENABLE_MAC_ONLY_GET(flags) ((flags) & PORTMOD_PM_ENABLE_MAC_ONLY ? 1 : 0)

/*! 
 * portmod_pm_enable
 *
 * @brief Enable port macro. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  pm_id           - port macro id
 * @param [in]  flags           - flags
 * @param [in]  enable          - enable or disable
 */
int portmod_pm_enable(int unit, int pm_id, int flags, int enable);

/*! 
 * portmod_phy_pm_id_get
 *
 * @brief Geven the physical port ID, return the associated PM ID 
 *
 * @param [in]  unit            - unit id
 * @param [in]  pport           - physical port
 * @param [out]  pm_id           - the associated PM ID of the physical port
 */
int portmod_phy_pm_id_get(int unit, int pport, int* pm_id);

/*! 
 * portmod_pm_logical_pbmp_get
 *
 * @brief Get the logical port bitmap based on the input PM ID 
 *
 * @param [in]  unit            - unit id
 * @param [in]  pm_id           - port macro id
 * @param [out]  logical_pbmp    - logical port bitmap of the PM
 */
int portmod_pm_logical_pbmp_get(int unit, int pm_id, portmod_pbmp_t* logical_pbmp);

/*! 
 * portmod_pm_vco_reconfig
 *
 * @brief Reconfigure the vco rate for pm core. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  pm_id           - port macro id
 * @param [in]  vco             - vco rates; vco[0] is TVCO and vco[1] is OVCO; two VCO rates always have to present
 */
int portmod_pm_vco_reconfig(int unit, int pm_id, const portmod_vco_type_t* vco);

/*! 
 * portmod_port_speed_config_set
 *
 * @brief  set/get the speed config for the specified port. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  speed_config    - port speed config
 */
int portmod_port_speed_config_set(int unit, int port, const portmod_speed_config_t* speed_config);
/*! 
 * portmod_port_speed_config_get
 *
 * @brief  set/get the speed config for the specified port. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  speed_config    - port speed config
 */
int portmod_port_speed_config_get(int unit, int port, portmod_speed_config_t* speed_config);

/*! 
 * @brief Flags for pm_speed_validate. 
 */ 
#define PORTMOD_PM_SPEED_VALIDATE_F_PLL_SWITCH_DEFAULT 0x1 /**< TVCO change is allowed if the entire PM's speed config is provided; otherwise only OVCO change is allowed */
#define PORTMOD_PM_SPEED_VALIDATE_F_PLL_SWITCH_NOT_ALLOWED 0x2 /**< do not allow PLL change */
#define PORTMOD_PM_SPEED_VALIDATE_F_ONE_PLL_SWITCH_ALLOWED 0x4 /**< only allow one PLL (OVCO) change */
#define PORTMOD_PM_SPEED_VALIDATE_F_TWO_PLL_SWITCH_ALLOWED 0x8 /**< allow two PLL (TVCO and OVCO) change */
#define PORTMOD_PM_SPEED_VALIDATE_F_TVCO_PRIORITIZE_26P562G 0x10 /**< when Portmod is free to choose TVCO rate, use 26.562G as TVCO. */

#define PORTMOD_PM_SPEED_VALIDATE_F_PLL_SWITCH_DEFAULT_SET(flags) ((flags) |= PORTMOD_PM_SPEED_VALIDATE_F_PLL_SWITCH_DEFAULT)
#define PORTMOD_PM_SPEED_VALIDATE_F_PLL_SWITCH_NOT_ALLOWED_SET(flags) ((flags) |= PORTMOD_PM_SPEED_VALIDATE_F_PLL_SWITCH_NOT_ALLOWED)
#define PORTMOD_PM_SPEED_VALIDATE_F_ONE_PLL_SWITCH_ALLOWED_SET(flags) ((flags) |= PORTMOD_PM_SPEED_VALIDATE_F_ONE_PLL_SWITCH_ALLOWED)
#define PORTMOD_PM_SPEED_VALIDATE_F_TWO_PLL_SWITCH_ALLOWED_SET(flags) ((flags) |= PORTMOD_PM_SPEED_VALIDATE_F_TWO_PLL_SWITCH_ALLOWED)
#define PORTMOD_PM_SPEED_VALIDATE_F_TVCO_PRIORITIZE_26P562G_SET(flags) ((flags) |= PORTMOD_PM_SPEED_VALIDATE_F_TVCO_PRIORITIZE_26P562G)

#define PORTMOD_PM_SPEED_VALIDATE_F_PLL_SWITCH_DEFAULT_CLR(flags) ((flags) &= ~PORTMOD_PM_SPEED_VALIDATE_F_PLL_SWITCH_DEFAULT)
#define PORTMOD_PM_SPEED_VALIDATE_F_PLL_SWITCH_NOT_ALLOWED_CLR(flags) ((flags) &= ~PORTMOD_PM_SPEED_VALIDATE_F_PLL_SWITCH_NOT_ALLOWED)
#define PORTMOD_PM_SPEED_VALIDATE_F_ONE_PLL_SWITCH_ALLOWED_CLR(flags) ((flags) &= ~PORTMOD_PM_SPEED_VALIDATE_F_ONE_PLL_SWITCH_ALLOWED)
#define PORTMOD_PM_SPEED_VALIDATE_F_TWO_PLL_SWITCH_ALLOWED_CLR(flags) ((flags) &= ~PORTMOD_PM_SPEED_VALIDATE_F_TWO_PLL_SWITCH_ALLOWED)
#define PORTMOD_PM_SPEED_VALIDATE_F_TVCO_PRIORITIZE_26P562G_CLR(flags) ((flags) &= ~PORTMOD_PM_SPEED_VALIDATE_F_TVCO_PRIORITIZE_26P562G)

#define PORTMOD_PM_SPEED_VALIDATE_F_PLL_SWITCH_DEFAULT_GET(flags) ((flags) & PORTMOD_PM_SPEED_VALIDATE_F_PLL_SWITCH_DEFAULT ? 1 : 0)
#define PORTMOD_PM_SPEED_VALIDATE_F_PLL_SWITCH_NOT_ALLOWED_GET(flags) ((flags) & PORTMOD_PM_SPEED_VALIDATE_F_PLL_SWITCH_NOT_ALLOWED ? 1 : 0)
#define PORTMOD_PM_SPEED_VALIDATE_F_ONE_PLL_SWITCH_ALLOWED_GET(flags) ((flags) & PORTMOD_PM_SPEED_VALIDATE_F_ONE_PLL_SWITCH_ALLOWED ? 1 : 0)
#define PORTMOD_PM_SPEED_VALIDATE_F_TWO_PLL_SWITCH_ALLOWED_GET(flags) ((flags) & PORTMOD_PM_SPEED_VALIDATE_F_TWO_PLL_SWITCH_ALLOWED ? 1 : 0)
#define PORTMOD_PM_SPEED_VALIDATE_F_TVCO_PRIORITIZE_26P562G_GET(flags) ((flags) & PORTMOD_PM_SPEED_VALIDATE_F_TVCO_PRIORITIZE_26P562G ? 1 : 0)


/*!
 * @struct portmod_sbus_bcast_config_s
 * @brief SBUS broadcast configuration 
 */ 
typedef struct portmod_sbus_bcast_config_s {
    int flag; /**< broadcast phase */
    int bcast_id; /**< SBUS broadcast ID */
    int chain_last; /**< the last instance in SBUS ring */
} portmod_sbus_bcast_config_t;

/* portmod_sbus_bcast_config_t initialization and validation */
int portmod_sbus_bcast_config_t_validate(int unit, const portmod_sbus_bcast_config_t* portmod_sbus_bcast_config);
int portmod_sbus_bcast_config_t_init(int unit, portmod_sbus_bcast_config_t* portmod_sbus_bcast_config);


/*! 
 * portmod_port_credits_enable_set
 *
 * @brief  Enable credits for the port.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - 
 */
int portmod_port_credits_enable_set(int unit, int port, int enable);

#ifdef CPRIMOD_SUPPORT
typedef enum portmod_cpri_stage_e {
    portmodCpriStageRx = 0, /**< Rx Basic Frame Parser  */
    portmodCpriStageTx = 1, /**< Tx Basic Frame Assembly */
    portmodCpriStageCount
} portmod_cpri_stage_t;

#ifdef PORTMOD_DIAG
extern enum_mapping_t portmod_cpri_stage_t_mapping[];
#endif /*PORTMOD_DIAG*/

/* portmod_cpri_stage_t validation */
int portmod_cpri_stage_t_validate(int unit, portmod_cpri_stage_t portmod_cpri_stage);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_stage_activate
 *
 * @brief  Activate the basic framer standby table.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  stage           - 
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_stage_activate(int unit, int port, portmod_cpri_stage_t stage);
#endif /* CPRIMOD_SUPPORT */


/*!
 * @struct portmod_cpri_axc_frame_info_s
 * @brief CPRI Rx AxC Frame information. 
 */ 
#ifdef CPRIMOD_SUPPORT
typedef struct portmod_cpri_axc_frame_info_s {
    uint32 start_bit; /**< Start Bit */
    uint32 num_bits; /**< Number of  Bit */
    cprimod_cpri_container_config_t container_info; /**< Container Information. */
    cprimod_payload_size_info_t roe_payload_info; /**< Payload Information. */
    cprimod_encap_decap_data_config_t encap_data_info; /**< Encap Data Information. */
} portmod_cpri_axc_frame_info_t;

/* portmod_cpri_axc_frame_info_t initialization and validation */
int portmod_cpri_axc_frame_info_t_validate(int unit, const portmod_cpri_axc_frame_info_t* portmod_cpri_axc_frame_info);
int portmod_cpri_axc_frame_info_t_init(int unit, portmod_cpri_axc_frame_info_t* portmod_cpri_axc_frame_info);

#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_rsvd4_tx_fsm_state_set
 *
 * @brief Set rsvd4 fsm state  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  state           - State to set.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_tx_fsm_state_set(int unit, int port, cprimod_rsvd4_tx_fsm_state_t state);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_rsvd4_tx_override_set
 *
 * @brief Set rsvd4 tx override  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  parameter       - override parameter.
 * @param [in]  enable          - enable override.
 * @param [in]  value           - value override.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_tx_override_set(int unit, int port, cprimod_rsvd4_tx_overide_t parameter, int enable, int value);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_rsvd4_rx_override_set
 *
 * @brief Set rsvd4 rx override  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  parameter       - override parameter.
 * @param [in]  enable          - enable override.
 * @param [in]  value           - value override.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_rx_override_set(int unit, int port, cprimod_rsvd4_rx_overide_t parameter, int enable, int value);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_rx_axc_frame_add
 *
 * @brief Add Rx AxC to the framer.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  axc_id          - AxC ID.
 * @param [in]  frame_info      - frame configuration information.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_axc_frame_add(int unit, int port, uint32 axc_id, const portmod_cpri_axc_frame_info_t* frame_info);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_rx_frame_optional_config_set
 *
 * @brief Set/Get Rx required field.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  field           - Fild to set/get.
 * @param [in]  value           - value going to Field
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_frame_optional_config_set(int unit, int port, cprimod_rx_config_field_t field, int value);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_rx_frame_optional_config_get
 *
 * @brief Set/Get Rx required field.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  field           - Fild to set/get.
 * @param [out]  value           - value going to Field
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_frame_optional_config_get(int unit, int port, cprimod_rx_config_field_t field, int* value);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_tx_frame_optional_config_set
 *
 * @brief Set/Get Tx required field.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  field           - Fild to set/get.
 * @param [in]  value           - value going to Field
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_frame_optional_config_set(int unit, int port, cprimod_tx_config_field_t field, uint32 value);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_tx_frame_optional_config_get
 *
 * @brief Set/Get Tx required field.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  field           - Fild to set/get.
 * @param [out]  value           - value going to Field
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_frame_optional_config_get(int unit, int port, cprimod_tx_config_field_t field, uint32* value);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_port_rsvd4_rx_frame_optional_config_set
 *
 * @brief Set/Get Rx required field.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  field           - Fild to set/get.
 * @param [in]  value           - value going to Field
 */
#ifdef CPRIMOD_SUPPORT
int portmod_port_rsvd4_rx_frame_optional_config_set(int unit, int port, cprimod_rsvd4_rx_config_field_t field, int value);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_port_rsvd4_rx_frame_optional_config_get
 *
 * @brief Set/Get Rx required field.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  field           - Fild to set/get.
 * @param [out]  value           - value going to Field
 */
#ifdef CPRIMOD_SUPPORT
int portmod_port_rsvd4_rx_frame_optional_config_get(int unit, int port, cprimod_rsvd4_rx_config_field_t field, int* value);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_port_rsvd4_tx_frame_optional_config_set
 *
 * @brief Set/Get Tx required field.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  field           - Fild to set/get.
 * @param [in]  value           - value going to Field
 */
#ifdef CPRIMOD_SUPPORT
int portmod_port_rsvd4_tx_frame_optional_config_set(int unit, int port, cprimod_rsvd4_tx_config_field_t field, int value);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_port_rsvd4_tx_frame_optional_config_get
 *
 * @brief Set/Get Tx required field.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  field           - Fild to set/get.
 * @param [out]  value           - value going to Field
 */
#ifdef CPRIMOD_SUPPORT
int portmod_port_rsvd4_tx_frame_optional_config_get(int unit, int port, cprimod_rsvd4_tx_config_field_t field, int* value);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_port_rsvd4_rx_speed_set
 *
 * @brief Set/Get Tx required field.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  speed           - value going to Field
 */
#ifdef CPRIMOD_SUPPORT
int portmod_port_rsvd4_rx_speed_set(int unit, int port, cprimod_port_rsvd4_speed_mult_t speed);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_port_rsvd4_rx_speed_get
 *
 * @brief Set/Get Tx required field.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  speed           - value going to Field
 */
#ifdef CPRIMOD_SUPPORT
int portmod_port_rsvd4_rx_speed_get(int unit, int port, cprimod_port_rsvd4_speed_mult_t* speed);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_port_rsvd4_tx_speed_set
 *
 * @brief Set/Get Tx required field.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  speed           - value going to Field
 */
#ifdef CPRIMOD_SUPPORT
int portmod_port_rsvd4_tx_speed_set(int unit, int port, cprimod_port_rsvd4_speed_mult_t speed);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_port_rsvd4_tx_speed_get
 *
 * @brief Set/Get Tx required field.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  speed           - value going to Field
 */
#ifdef CPRIMOD_SUPPORT
int portmod_port_rsvd4_tx_speed_get(int unit, int port, cprimod_port_rsvd4_speed_mult_t* speed);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_rx_axc_frame_delete
 *
 * @brief Delete Rx AxC to the framer.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  axc_id          - AxC ID.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_axc_frame_delete(int unit, int port, uint32 axc_id);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_rx_axc_frame_get
 *
 * @brief Get Rx AxC to the framer.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  axc_id          - AxC ID.
 * @param [in]  from_get_all    - from get_all or get
 * @param [out]  frame_info      - frame configuration information.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_axc_frame_get(int unit, int port, uint32 axc_id, uint32 from_get_all, portmod_cpri_axc_frame_info_t* frame_info);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_rsvd4_rx_fsm_state_set
 *
 * @brief Set rsvd4 fsm state  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  state           - State to set.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_rx_fsm_state_set(int unit, int port, cprimod_rsvd4_rx_fsm_state_t state);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_tx_axc_frame_add
 *
 * @brief Add Tx AxC to the framer.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  axc_id          - AxC ID.
 * @param [in]  frame_info      - frame configuration information.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_axc_frame_add(int unit, int port, uint32 axc_id, const portmod_cpri_axc_frame_info_t* frame_info);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_tx_axc_frame_delete
 *
 * @brief Delete Tx AxC to the framer.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  axc_id          - AxC ID.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_axc_frame_delete(int unit, int port, uint32 axc_id);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_tx_axc_frame_get
 *
 * @brief Get Tx AxC to the framer.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  axc_id          - AxC ID.
 * @param [in]  from_get_all    - from get_all or get
 * @param [out]  frame_info      - frame configuration information.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_axc_frame_get(int unit, int port, uint32 axc_id, uint32 from_get_all, portmod_cpri_axc_frame_info_t* frame_info);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_encap_set
 *
 * @brief Encap Header Configuration.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  queue_num       - Queue Number.
 * @param [in]  config          - Encapsulate Header Configuration.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_encap_set(int unit, int port, uint32 queue_num, const cprimod_encap_header_config_t* config);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_encap_get
 *
 * @brief Encap Header Configuration.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  queue_num       - Queue Number.
 * @param [out]  config          - Encapsulate Header Configuration.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_encap_get(int unit, int port, uint32 queue_num, cprimod_encap_header_config_t* config);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_encap_roe_ordering_info_set
 *
 * @brief Encap Ordering info.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  index           - Index to ROE ordering info table.
 * @param [in]  config          - Encap Ordering info.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_encap_roe_ordering_info_set(int unit, int port, uint32 index, const cprimod_encap_ordering_info_entry_t* config);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_encap_roe_ordering_info_get
 *
 * @brief Encap Ordering info.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  index           - Index to ROE ordering info table.
 * @param [out]  config          - Encap Ordering info.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_encap_roe_ordering_info_get(int unit, int port, uint32 index, cprimod_encap_ordering_info_entry_t* config);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_encap_roe_ordering_sequence_offset_set
 *
 * @brief Encap Ordering info Offset.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  queue_num       - Queue number.
 * @param [in]  control         - 1 Control 0 Data.
 * @param [in]  config          - Encap Ordering info Offset for Queue.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_encap_roe_ordering_sequence_offset_set(int unit, int port, uint32 queue_num, uint32 control, const cprimod_cpri_ordering_info_offset_t* config);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_encap_roe_ordering_sequence_offset_get
 *
 * @brief Encap Ordering info Offset.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  queue_num       - Queue number.
 * @param [in]  control         - 1 Control 0 Data.
 * @param [out]  config          - Encap Ordering info Offset for Queue.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_encap_roe_ordering_sequence_offset_get(int unit, int port, uint32 queue_num, uint32 control, cprimod_cpri_ordering_info_offset_t* config);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_roe_encap_macda_entry_set
 *
 * @brief Encap Mac Da.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  index           - Index to MAC DA table.
 * @param [in]  mac_addr        - Mac Addr.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_roe_encap_macda_entry_set(int unit, int port, uint32 index, cprimod_mac_addr_t mac_addr);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_roe_encap_macda_entry_get
 *
 * @brief Encap Mac Da.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  index           - Index to MAC DA table.
 * @param [out]  mac_addr        - Mac Addr.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_roe_encap_macda_entry_get(int unit, int port, uint32 index, cprimod_mac_addr_t mac_addr);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_roe_encap_macsa_entry_set
 *
 * @brief Encap Mac Sa.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  index           - Index to MAC DA table.
 * @param [in]  mac_addr        - Mac Addr.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_roe_encap_macsa_entry_set(int unit, int port, uint32 index, cprimod_mac_addr_t mac_addr);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_roe_encap_macsa_entry_get
 *
 * @brief Encap Mac Sa.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  index           - Index to MAC DA table.
 * @param [out]  mac_addr        - Mac Addr.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_roe_encap_macsa_entry_get(int unit, int port, uint32 index, cprimod_mac_addr_t mac_addr);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_roe_encap_vlan_entry_set
 *
 * @brief Encap VLAN.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  index           - Index to VLAN table.
 * @param [in]  table_id        - VLAN0 or VLAN1 table.
 * @param [in]  vlan_id         - VLAN ID.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_roe_encap_vlan_entry_set(int unit, int port, uint32 index, cprimod_vlan_table_id_t table_id, uint32 vlan_id);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_roe_encap_vlan_entry_get
 *
 * @brief Encap VLAN.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  index           - Index to VLAN table.
 * @param [in]  table_id        - VLAN0 or VLAN1 table.
 * @param [out]  vlan_id         - VLAN ID.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_roe_encap_vlan_entry_get(int unit, int port, uint32 index, cprimod_vlan_table_id_t table_id, uint32* vlan_id);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_decap_ethertype_config_set
 *
 * @brief  Set Decap ethtype for a packet type.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  pkt_type        - Packet Type.
 * @param [in]  ethtype         - ETHTYPE.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_ethertype_config_set(int unit, int port, cprimod_ethertype_t pkt_type, uint16 ethtype);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_decap_ethertype_config_get
 *
 * @brief  Set Decap ethtype for a packet type.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  pkt_type        - Packet Type.
 * @param [out]  ethtype         - ETHTYPE.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_ethertype_config_get(int unit, int port, cprimod_ethertype_t pkt_type, uint16* ethtype);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_encap_ethertype_config_set
 *
 * @brief  Set Encap ethtype for a packet type.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  pkt_type        - Packet Type.
 * @param [in]  ethtype         - ETHTYPE.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_encap_ethertype_config_set(int unit, int port, cprimod_ethertype_t pkt_type, uint16 ethtype);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_encap_ethertype_config_get
 *
 * @brief  Set Encap ethtype for a packet type.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  pkt_type        - Packet Type.
 * @param [out]  ethtype         - ETHTYPE.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_encap_ethertype_config_get(int unit, int port, cprimod_ethertype_t pkt_type, uint16* ethtype);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_decap_flow_config_set
 *
 * @brief  Flow Classification.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  roe_subtype     - ROE SubType.
 * @param [in]  queue_num       - Queue Number.
 * @param [in]  cls_option      - Option.
 * @param [in]  flow_type       - Flow Type.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_flow_config_set(int unit, int port, uint8 roe_subtype, uint32 queue_num, cprimod_cls_option_t cls_option, cprimod_cls_flow_type_t flow_type);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_decap_flow_config_get
 *
 * @brief  Flow Classification.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  roe_subtype     - ROE SubType.
 * @param [out]  queue_num       - Queue Number.
 * @param [out]  cls_option      - Option.
 * @param [out]  flow_type       - Flow Type.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_flow_config_get(int unit, int port, uint8 roe_subtype, uint32* queue_num, cprimod_cls_option_t* cls_option, cprimod_cls_flow_type_t* flow_type);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_decap_flow_config_clear
 *
 * @brief  Clear Flow Classification.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  roe_subtype     - ROE SubType.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_flow_config_clear(int unit, int port, uint8 roe_subtype);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_decap_queue_to_ordering_info_index_set
 *
 * @brief  Queue to Ordering info Index.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  queue_num       - Queue Number.
 * @param [in]  ordering_info_index   - Index to decap ordering info table.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_queue_to_ordering_info_index_set(int unit, int port, uint32 queue_num, uint32 ordering_info_index);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_decap_queue_to_ordering_info_index_get
 *
 * @brief  Queue to Ordering info Index.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  queue_num       - Queue Number.
 * @param [out]  ordering_info_index   - Index to decap ordering info table.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_queue_to_ordering_info_index_get(int unit, int port, uint32 queue_num, uint32* ordering_info_index);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_decap_flow_to_queue_mapping_set
 *
 * @brief  Queue to Ordering info Index.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flow_id         - Flow Id.
 * @param [in]  queue_num       - Queue Number.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_flow_to_queue_mapping_set(int unit, int port, uint32 flow_id, uint32 queue_num);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_decap_flow_to_queue_mapping_get
 *
 * @brief  Queue to Ordering info Index.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flow_id         - Flow Id.
 * @param [out]  queue_num       - Queue Number.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_flow_to_queue_mapping_get(int unit, int port, uint32 flow_id, uint32* queue_num);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_decap_flow_to_queue_mapping_clear
 *
 * @brief  Mapping  the flow to Invalid Queue.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flow_id         - Flow Id.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_flow_to_queue_mapping_clear(int unit, int port, uint32 flow_id);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_decap_roe_ordering_info_set
 *
 * @brief Decap Ordering info.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  index           - Index to ROE ordering info table.
 * @param [in]  config          - Decap Ordering info.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_roe_ordering_info_set(int unit, int port, uint32 index, const cprimod_decap_ordering_info_entry_t* config);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_decap_roe_ordering_info_get
 *
 * @brief Decap Ordering info.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  index           - Index to ROE ordering info table.
 * @param [out]  config          - Decap Ordering info.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_roe_ordering_info_get(int unit, int port, uint32 index, cprimod_decap_ordering_info_entry_t* config);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_decap_roe_ordering_sequence_offset_set
 *
 * @brief Encap Ordering info Offset.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  queue_num       - Queue number.
 * @param [in]  config          - Encap Ordering info Offset for Queue.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_roe_ordering_sequence_offset_set(int unit, int port, uint32 queue_num, const cprimod_cpri_ordering_info_offset_t* config);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_decap_roe_ordering_sequence_offset_get
 *
 * @brief Encap Ordering info Offset.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  queue_num       - Queue number.
 * @param [out]  config          - Encap Ordering info Offset for Queue.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_roe_ordering_sequence_offset_get(int unit, int port, uint32 queue_num, cprimod_cpri_ordering_info_offset_t* config);
#endif /* CPRIMOD_SUPPORT */


/*!
 * @struct portmod_tx_frame_tgen_config_s
 * @brief TGEN Configuration. 
 */ 
#ifdef CPRIMOD_SUPPORT
typedef struct portmod_tx_frame_tgen_config_s {
    uint32 tx_tgen_hfn; /**< Hyper Frame Number */
    uint32 tx_tgen_bfn; /**< Radio Frame Number */
    cprimod_tgen_counter_select_t tx_gen_bfn_hfn_sel; /**< 1 select bfn, 0 select hfn. */
    uint64 tx_tgen_ts_offset; /**< timeout counter */
} portmod_tx_frame_tgen_config_t;

/* portmod_tx_frame_tgen_config_t initialization and validation */
int portmod_tx_frame_tgen_config_t_validate(int unit, const portmod_tx_frame_tgen_config_t* portmod_tx_frame_tgen_config);
int portmod_tx_frame_tgen_config_t_init(int unit, portmod_tx_frame_tgen_config_t* portmod_tx_frame_tgen_config);

#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_tx_frame_tgen_config_set
 *
 * @brief TGEN configuration. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  config          - TGEN Configuration.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_frame_tgen_config_set(int unit, int port, const portmod_tx_frame_tgen_config_t* config);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_tx_frame_tgen_config_get
 *
 * @brief TGEN configuration. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  config          - TGEN Configuration.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_frame_tgen_config_get(int unit, int port, portmod_tx_frame_tgen_config_t* config);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_tx_frame_tgen_enable
 *
 * @brief TGEN configuration. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - Enable/Disable.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_frame_tgen_enable(int unit, int port, uint32 enable);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_tx_frame_tgen_ts_offset_set
 *
 * @brief TGEN Offset. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  offset          - Enable/Disable.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_frame_tgen_ts_offset_set(int unit, int port, uint64 offset);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_tx_frame_tgen_ts_offset_get
 *
 * @brief TGEN Offset. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  offset          - Enable/Disable.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_frame_tgen_ts_offset_get(int unit, int port, uint64* offset);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_tx_frame_next_hfn_get
 *
 * @brief Get next hyper frame number. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  hfn             - HFN number.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_frame_next_hfn_get(int unit, int port, uint32* hfn);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_tx_frame_next_bfn_get
 *
 * @brief Get next radio frame/master frame number. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  bfn             - BFN number.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_frame_next_bfn_get(int unit, int port, uint32* bfn);
#endif /* CPRIMOD_SUPPORT */


/*!
 * @struct portmod_rsvd4_rx_flow_info_s
 * @brief  Rx Flow Information. 
 */ 
#ifdef CPRIMOD_SUPPORT
typedef struct portmod_rsvd4_rx_flow_info_s {
    uint32 axc_id; /**< AxC/Queue ID. */
    uint32 mask; /**< Msg Header Mask */
    uint32 match_data; /**< Msg Header Match Data */
    uint32 packet_size; /**< ROE Packet Payload size in Bits */
    uint32 last_packet_size; /**< ROE last packet Payload size in Bits */
    uint32 last_packet_num; /**< ROE last packet number if different size. */
    uint32 stuffing_cnt; /**< stuffing count */
    cprimod_rsvd4_msg_ts_mode_t msg_ts_mode; /**< msg ts mode */
    uint32 msg_ts_count; /**< Msg timeslot count */
    cprimod_rsvd4_frame_sync_mode_t frame_sync_mode; /**< frame sync mode. */
    uint32 master_frame_offset; /**< Master Frame Offset (bfn_offset) */
    uint32 message_number_offset; /**< Message Number Offset (rfrm_offset) */
    uint32 container_block_count; /**< Container Block Count (number of bits in 10ms frame). */
    uint32 queue_size; /**< Queue Size in bytes. */
    uint32 priority; /**< WorkQueue Prioirty.Rx Only */
    uint32 pad_size; /**< Pad Size. */
    uint32 extra_pad_size; /**< Extra Pad Size. */
    uint32 pad_enable; /**< Pad Enable. */
    uint32 control_location; /**< Control TSN location. */
    uint32 tsn_bitmap; /**< TSN bitmap. Rx only. */
} portmod_rsvd4_rx_flow_info_t;

/* portmod_rsvd4_rx_flow_info_t initialization and validation */
int portmod_rsvd4_rx_flow_info_t_validate(int unit, const portmod_rsvd4_rx_flow_info_t* portmod_rsvd4_rx_flow_info);
int portmod_rsvd4_rx_flow_info_t_init(int unit, portmod_rsvd4_rx_flow_info_t* portmod_rsvd4_rx_flow_info);

#endif /* CPRIMOD_SUPPORT */

/*!
 * @struct portmod_rsvd4_tx_flow_info_s
 * @brief Tx Flow Information. 
 */ 
#ifdef CPRIMOD_SUPPORT
typedef struct portmod_rsvd4_tx_flow_info_s {
    uint32 axc_id; /**< AxC/Queue ID. */
    uint32 packet_size; /**< ROE Packet Payload size in Bits */
    uint32 last_packet_size; /**< ROE last packet Payload size in Bits */
    uint32 last_packet_num; /**< ROE last packet number if different size. */
    uint32 stuffing_cnt; /**< stuffing count */
    cprimod_rsvd4_msg_ts_mode_t msg_ts_mode; /**< msg ts mode */
    uint32 msg_ts_count; /**< Msg timeslot count */
    cprimod_rsvd4_frame_sync_mode_t frame_sync_mode; /**< frame sync mode. */
    uint32 master_frame_offset; /**< Master Frame Offset (bfn_offset) */
    uint32 message_number_offset; /**< Message Number Offset (rfrm_offset) */
    uint32 container_block_count; /**< Container Block Size (number of bits in 10ms frame). */
    uint32 buffer_size; /**< Buffer Size in bytes. */
    uint32 cycle_size; /**< Number of Packet in Queue. */
    uint32 use_ts_dbm; /**< Use ts dbm (secondary dbm) Tx Only. */
    uint32 ts_dbm_profile_num; /**< ts dbm (secondary dbm) Profile Number. Tx Only */
    uint32 num_active_slot; /**< ts dbm (secondary dbm) number of slots. Tx Only */
    uint32 msg_addr; /**< msg addr. Tx Only. */
    uint32 msg_type; /**< msg type.Tx Only */
    uint32 msg_ts_offset; /**< msg type.Tx Only */
    uint32 pad_size; /**< Pad Size. */
    uint32 extra_pad_size; /**< Extra Pad Size. */
    uint32 pad_enable; /**< Pad Enable. */
    uint32 control_location; /**< Control TSN location. */
} portmod_rsvd4_tx_flow_info_t;

/* portmod_rsvd4_tx_flow_info_t initialization and validation */
int portmod_rsvd4_tx_flow_info_t_validate(int unit, const portmod_rsvd4_tx_flow_info_t* portmod_rsvd4_tx_flow_info);
int portmod_rsvd4_tx_flow_info_t_init(int unit, portmod_rsvd4_tx_flow_info_t* portmod_rsvd4_tx_flow_info);

#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_rsvd4_rx_flow_add
 *
 * @brief  RSVD4 rx data flow add. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flow_id         - Flow ID.
 * @param [in]  info            - Flow Information.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_rx_flow_add(int unit, int port, uint32 flow_id, const portmod_rsvd4_rx_flow_info_t* info);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_rsvd4_rx_flow_delete
 *
 * @brief  RSVD4 rx data flow delete. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flow_id         - Flow ID.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_rx_flow_delete(int unit, int port, uint32 flow_id);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_rsvd4_tx_flow_add
 *
 * @brief  RSVD4 Tx Flow add. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flow_id         - Flow ID.
 * @param [in]  info            - Flow Information.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_tx_flow_add(int unit, int port, uint32 flow_id, const portmod_rsvd4_tx_flow_info_t* info);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_rsvd4_tx_flow_delete
 *
 * @brief  RSVD4 tx data flow delete. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flow_id         - Flow ID.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_tx_flow_delete(int unit, int port, uint32 flow_id);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_rsvd4_dbm_entry_set
 *
 * @brief  RSVD4 Set/Get DBM Profile. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  profile_id      - DBM Profile ID.
 * @param [in]  profile         - DBM Profile Information.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_dbm_entry_set(int unit, int port, uint32 profile_id, const cprimod_dbm_rule_entry_t* profile);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_rsvd4_dbm_entry_get
 *
 * @brief  RSVD4 Set/Get DBM Profile. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  profile_id      - DBM Profile ID.
 * @param [out]  profile         - DBM Profile Information.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_dbm_entry_get(int unit, int port, uint32 profile_id, cprimod_dbm_rule_entry_t* profile);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_rsvd4_secondary_dbm_entry_set
 *
 * @brief  RSVD4 Set/Get Secondary DBM Profile. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  profile_id      - DBM Profile ID.
 * @param [in]  profile         - Secondary DBM Profile Information.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_secondary_dbm_entry_set(int unit, int port, uint32 profile_id, const cprimod_secondary_dbm_rule_entry_t* profile);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_rsvd4_secondary_dbm_entry_get
 *
 * @brief  RSVD4 Set/Get Secondary DBM Profile. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  profile_id      - DBM Profile ID.
 * @param [out]  profile         - Secondary DBM Profile Information.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_secondary_dbm_entry_get(int unit, int port, uint32 profile_id, cprimod_secondary_dbm_rule_entry_t* profile);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_rsvd4_modulo_rule_entry_set
 *
 * @brief  Modulo Rule Entry Set/Get.   
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  modulo_rule_num   - Modulo Rule Number 0-71 for data 0-15 for control.
 * @param [in]  modulo_rule_type   - Modulo Rule Type, Data or Ctrl.
 * @param [in]  modulo_rule     - Modulo Rule Entry.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_modulo_rule_entry_set(int unit, int port, uint32 modulo_rule_num, cprimod_transmission_rule_type_t modulo_rule_type, const cprimod_modulo_rule_entry_t* modulo_rule);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_rsvd4_modulo_rule_entry_get
 *
 * @brief  Modulo Rule Entry Set/Get.   
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  modulo_rule_num   - Modulo Rule Number 0-71 for data 0-15 for control.
 * @param [in]  modulo_rule_type   - Modulo Rule Type, Data or Ctrl.
 * @param [out]  modulo_rule     - Modulo Rule Entry.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_modulo_rule_entry_get(int unit, int port, uint32 modulo_rule_num, cprimod_transmission_rule_type_t modulo_rule_type, cprimod_modulo_rule_entry_t* modulo_rule);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_rsvd4_dbm_position_entry_set
 *
 * @brief  Dual Bitmap Position Table Entry Set/Get.   
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  index           - Index to Position Table Entry.
 * @param [in]  pos_entry       - DBM Position  Table  Entry.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_dbm_position_entry_set(int unit, int port, uint32 index, const cprimod_dbm_pos_table_entry_t* pos_entry);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_rsvd4_dbm_position_entry_get
 *
 * @brief  Dual Bitmap Position Table Entry Set/Get.   
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  index           - Index to Position Table Entry.
 * @param [out]  pos_entry       - DBM Position  Table  Entry.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_dbm_position_entry_get(int unit, int port, uint32 index, cprimod_dbm_pos_table_entry_t* pos_entry);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_rsvd4_rx_master_frame_sync_config_set
 *
 * @brief Set/Get Rx Master Frame Synchronizaiton  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  master_frame_number   - Master Frame Number when start countng.
 * @param [in]  master_frame_start_time   - Maser Frame Time to start count.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_rx_master_frame_sync_config_set(int unit, int port, uint32 master_frame_number, uint64 master_frame_start_time);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_rsvd4_rx_master_frame_sync_config_get
 *
 * @brief Set/Get Rx Master Frame Synchronizaiton  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  master_frame_number   - Master Frame Number when start countng.
 * @param [out]  master_frame_start_time   - Master Frame Time to start count.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_rx_master_frame_sync_config_get(int unit, int port, uint32* master_frame_number, uint64* master_frame_start_time);
#endif /* CPRIMOD_SUPPORT */


/*!
 * @struct portmod_vcos_speed_config_s
 * @brief Speed configuration 
 */ 
typedef struct portmod_vcos_speed_config_s {
    uint32 speed; /**< speed */
    uint8 num_lanes; /**< number of lanes */
    uint8 ieee_mode; /**< IEEE mode */
    uint8 higig_mode; /**< HIGIG mode */
    uint8 txpi_mode; /**< TXPI mode */
    uint8 eth_of_mixed_mode; /**< ETH port of mixed mode */
    portmod_core_port_enet_cpri_type_t port_type; /**< port type */
} portmod_vcos_speed_config_t;

/* portmod_vcos_speed_config_t initialization and validation */
int portmod_vcos_speed_config_t_validate(int unit, const portmod_vcos_speed_config_t* portmod_vcos_speed_config);
int portmod_vcos_speed_config_t_init(int unit, portmod_vcos_speed_config_t* portmod_vcos_speed_config);


/*!
 * @struct portmod_dual_vcos_s
 * @brief Dual VCOs 
 */ 
typedef struct portmod_dual_vcos_s {
    uint32 vco_0; /**< VCO_0 */
    uint32 vco_1; /**< VCO_1 */
} portmod_dual_vcos_t;

/* portmod_dual_vcos_t initialization and validation */
int portmod_dual_vcos_t_validate(int unit, const portmod_dual_vcos_t* portmod_dual_vcos);
int portmod_dual_vcos_t_init(int unit, portmod_dual_vcos_t* portmod_dual_vcos);

/*! 
 * portmod_pm_supported_vcos_get
 *
 * @brief Get Supported VCOs 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  pm_type         - PM type
 * @param [in]  speed_config_list   - port speed config param
 * @param [in]  size            - size of speed config list
 * @param [out]  dual_vco        - supported VCOs
 */
int portmod_pm_supported_vcos_get(int unit, int port, portmod_dispatch_type_t pm_type, const portmod_vcos_speed_config_t* speed_config_list, int size, portmod_dual_vcos_t* dual_vco);

/*! 
 * portmod_port_vcos_get
 *
 * @brief Get supported VCOs 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  speed_config_list   - port speed config param
 * @param [in]  size            - size of speed config list
 * @param [out]  dual_vco        - supported VCOs
 */
int portmod_port_vcos_get(int unit, int port, const portmod_vcos_speed_config_t* speed_config_list, int size, portmod_dual_vcos_t* dual_vco);

/*! 
 * portmod_port_mac_timestamp_enable_set
 *
 * @brief Port mac timestamp enable set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - set port mac timestamp enable
 */
int portmod_port_mac_timestamp_enable_set(int unit, int port, int enable);
/*! 
 * portmod_port_mac_timestamp_enable_get
 *
 * @brief Port mac timestamp enable set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - get port mac timestamp enable
 */
int portmod_port_mac_timestamp_enable_get(int unit, int port, int* enable);

/*! 
 * portmod_cpri_port_rx_cw_sync_info_get
 *
 * @brief  CPRI Sync information.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  hyper_frame_num   - Hyper Frame Number.
 * @param [out]  radio_frame_num   - Radio Frame Number.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_cw_sync_info_get(int unit, int port, uint32* hyper_frame_num, uint32* radio_frame_num);
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
typedef _shr_cpri_cw_l1_inband_info_t portmod_cpri_cw_l1_inband_info_t;

#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_rx_cw_l1_inband_info_get
 *
 * @brief Get L1 portocol information.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  l1_inband_info   - L1 Inband information
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_cw_l1_inband_info_get(int unit, int port, portmod_cpri_cw_l1_inband_info_t* l1_inband_info);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_rx_cw_l1_signal_signal_protection_set
 *
 * @brief Set/Get L1 Protection.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  signal_map      - Signal List - Bit Map
 * @param [in]  enable          -  0 - Disable 1- Enable
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_cw_l1_signal_signal_protection_set(int unit, int port, uint32 signal_map, uint32 enable);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_rx_cw_l1_signal_signal_protection_get
 *
 * @brief Set/Get L1 Protection.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  signal_map      - Signal List - Bit Map
 * @param [out]  enable          -  Bit Map - Corresponding Bit will have either enable 1 or disable 0
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_cw_l1_signal_signal_protection_get(int unit, int port, uint32 signal_map, uint32* enable);
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
typedef _shr_cpri_hdlc_fcs_size_t portmod_cpri_hdlc_fcs_size_t;

#endif /* CPRIMOD_SUPPORT */
#ifdef CPRIMOD_SUPPORT
#define PORTMOD_CPRI_HDLC_FCS_SIZE_8_BITS _shrCpriHdlcFcsSize8Bits
#define PORTMOD_CPRI_HDLC_FCS_SIZE_16_BITS _shrCpriHdlcFcsSize16Bits
#define PORTMOD_CPRI_HDLC_FCS_SIZE_32_BITS _shrCpriHdlcFcsSize32Bits
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
typedef _shr_cpri_hdlc_filling_flag_pattern_t portmod_cpri_hdlc_filling_flag_pattern_t;

#endif /* CPRIMOD_SUPPORT */
#ifdef CPRIMOD_SUPPORT
#define PORTMOD_CPRI_HDLC_FILLING_FLAG_PATTERN_7E _shrCpriHdlcFillingFlagPattern7E
#define PORTMOD_CPRI_HDLC_FILLING_FLAG_PATTERN_7F _shrCpriHdlcFillingFlagPattern7F
#define PORTMOD_CPRI_HDLC_FILLING_FLAG_PATTERN_FF _shrCpriHdlcFillingFlagPatternFF
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
typedef _shr_cpri_hdlc_flag_size_t portmod_cpri_hdlc_num_flag_bytes_t;

#endif /* CPRIMOD_SUPPORT */
#ifdef CPRIMOD_SUPPORT
#define PORTMOD_HDLC_FLAG_SIZE_1_BYTE _shrCpriHdlcNumFlagSizeOneByte
#define PORTMOD_HDLC_FLAG_SIZE_2_BYTE _shrCpriHdlcNumFlagSizeTwoByte
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
typedef _shr_cpri_hdlc_crc_mode_t portmod_cpri_crc_mode_t;

#endif /* CPRIMOD_SUPPORT */
#ifdef CPRIMOD_SUPPORT
#define PORTMOD_CPRI_HDLC_CRC_MODE_APPEND _shrCpriHdlcCrcAppend
#define PORTMOD_CPRI_HDLC_CRC_MODE_REPLACE _shrCpriHdlcCrcReplace
#define PORTMOD_CPRI_HDLC_CRC_MODE_NO_UPDATE _shrCpriHdlcCrcNoUpdate
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
typedef _shr_cpri_hdlc_crc_init_val_t portmod_cpri_hdlc_crc_init_val_t;

#endif /* CPRIMOD_SUPPORT */
#ifdef CPRIMOD_SUPPORT
#define PORTMOD_CPRI_HDLC_CRC_INIT_VAL_ALL_0 _shrCpriHdlcCrcInitValAll0
#define PORTMOD_CPRI_HDLC_CRC_INIT_VAL_ALL_1 _shrCpriHdlcCrcInitValAll1
#endif /* CPRIMOD_SUPPORT */


/*!
 * @struct portmod_cpri_slow_hdlc_config_info_s
 * @brief CPRI Slow HDLC configuration information. 
 */ 
#ifdef CPRIMOD_SUPPORT
typedef struct portmod_cpri_slow_hdlc_config_info_s {
    portmod_cpri_crc_mode_t tx_crc_mode; /**< Tx CRC Mode. Append/Replace/NoUpdate.   */
    portmod_cpri_hdlc_num_flag_bytes_t tx_flag_size; /**< Tx Num of Flag Bytes 1 or 2.   */
    portmod_cpri_hdlc_filling_flag_pattern_t tx_filling_flag_pattern; /**< Tx Filling Flag Pattern.   */
    portmod_cpri_hdlc_crc_init_val_t crc_init_val; /**< CRC init Value, all 0s or 1s.   */
    int use_fe_mac; /**<  Use FE Mac instead of HDLC.   */
    int crc_byte_swap; /**<  0 - 15..0  1- [7:0][15:8]   */
    int no_fcs_err_check; /**<  Turn off FCS error check.   */
    uint32 cw_sel; /**< control word subchannel Xs */
    uint32 cw_size; /**< control word size */
    portmod_cpri_hdlc_fcs_size_t fcs_size; /**< 8,16 or 16 bits FCS. */
    int runt_frame_drop; /**< Indicate frame smaller than 16 bits (runt) be dropped. */
    int long_frame_drop; /**< Indicate frame longer than max frame size be dropped. */
    uint32 min_frame_size; /**< Min HDLC Frame Size in Bits (including FCS). */
    uint32 max_frame_size; /**< Max HDLC Frame Size in Bits (including FCS). */
    uint32 queue_num; /**< Queue Number */
    uint32 priority; /**< Priority */
    uint32 queue_size; /**< Queue Size in Bytes */
    uint32 cycle_size; /**< Cycle Size */
    uint32 buffer_size; /**< Buffer Size */
} portmod_cpri_slow_hdlc_config_info_t;

/* portmod_cpri_slow_hdlc_config_info_t initialization and validation */
int portmod_cpri_slow_hdlc_config_info_t_validate(int unit, const portmod_cpri_slow_hdlc_config_info_t* portmod_cpri_slow_hdlc_config_info);
int portmod_cpri_slow_hdlc_config_info_t_init(int unit, portmod_cpri_slow_hdlc_config_info_t* portmod_cpri_slow_hdlc_config_info);

#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_cw_slow_hdlc_config_set
 *
 * @brief HDLC Config Set/Get.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  config_info     -  Config info.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_cw_slow_hdlc_config_set(int unit, int port, const portmod_cpri_slow_hdlc_config_info_t* config_info);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_cw_slow_hdlc_config_get
 *
 * @brief HDLC Config Set/Get.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  config_info     -  Config info.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_cw_slow_hdlc_config_get(int unit, int port, portmod_cpri_slow_hdlc_config_info_t* config_info);
#endif /* CPRIMOD_SUPPORT */


/*!
 * @struct portmod_cpri_fast_eth_config_info_s
 * @brief CPRI Fast Eth  configuration information. 
 */ 
#ifdef CPRIMOD_SUPPORT
typedef struct portmod_cpri_fast_eth_config_info_s {
    portmod_cpri_crc_mode_t tx_crc_mode; /**< Tx CRC Mode. Append/Replace/NoUpdate.   */
    uint32 schan_start; /**< sub channel start location */
    uint32 schan_size; /**< sub channel size. */
    uint32 cw_sel; /**< control word subchannel Xs */
    uint32 cw_size; /**< control word size */
    uint32 min_packet_size; /**< Min Packet Size in Bytes. */
    uint32 max_packet_size; /**< Max Packet Size in Bytes. */
    int min_packet_drop; /**< Indicate frame smaller than min_packet_size be dropped. */
    int max_packet_drop; /**< Indicate frame larger than max packet size be dropped. */
    int strip_crc; /**< CRC bytes are drop and not forwarded to encap. */
    uint32 min_ipg; /**< Min IPG Size in Bytes. */
    uint32 queue_num; /**< Queue Number */
    uint32 priority; /**< Priority */
    uint32 queue_size; /**< Queue Size in Bytes */
    uint32 cycle_size; /**< Cycle Size */
    uint32 buffer_size; /**< Buffer Size */
    int no_fcs_err_check; /**<  Turn off FCS error check.   */
} portmod_cpri_fast_eth_config_info_t;

/* portmod_cpri_fast_eth_config_info_t initialization and validation */
int portmod_cpri_fast_eth_config_info_t_validate(int unit, const portmod_cpri_fast_eth_config_info_t* portmod_cpri_fast_eth_config_info);
int portmod_cpri_fast_eth_config_info_t_init(int unit, portmod_cpri_fast_eth_config_info_t* portmod_cpri_fast_eth_config_info);

#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_cw_fast_eth_config_set
 *
 * @brief Fast ETH Config Set/Get.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  config_info     -  Config info.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_cw_fast_eth_config_set(int unit, int port, const portmod_cpri_fast_eth_config_info_t* config_info);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_cw_fast_eth_config_get
 *
 * @brief Fast ETH Config Set/Get.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  config_info     -  Config info.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_cw_fast_eth_config_get(int unit, int port, portmod_cpri_fast_eth_config_info_t* config_info);
#endif /* CPRIMOD_SUPPORT */

typedef _shr_cpri_vsd_control_subchan_num_bytes_t portmod_cpri_vsd_control_subchan_num_bytes_t;

#define PORTMOD_CPRI_VSD_CONTROL_SUBCHAN_NUM_BYTES_1 _shrVsdCtrlSubchanNumBytes1
#define PORTMOD_CPRI_VSD_CONTROL_SUBCHAN_NUM_BYTES_2 _shrVsdCtrlSubchanNumBytes2
#define PORTMOD_CPRI_VSD_CONTROL_SUBCHAN_NUM_BYTES_4 _shrVsdCtrlSubchanNumBytes4

typedef _shr_cpri_vsd_control_subchan_size_t portmod_cpri_vsd_control_subchan_size_t;

#define PORTMOD_CPRI_VSD_CONTROL_SUBCHAN_SIZE_2 _shrVsdCtrlSubchanSize2
#define PORTMOD_CPRI_VSD_CONTROL_SUBCHAN_SIZE_4 _shrVsdCtrlSubchanSize4

typedef _shr_cpri_vsd_control_flow_num_bytes_t portmod_cpri_vsd_control_flow_num_bytes_t;

#define PORTMOD_CPRI_CONTROL_FLOW_NUM_BYTES_2 _shrVsdCtrlFlowNumBytes2
#define PORTMOD_CPRI_CONTROL_FLOW_NUM_BYTES_4 _shrVsdCtrlFlowNumBytes2


/*!
 * @struct portmod_cpri_rx_vsd_config_info_s
 * @brief CPRI Rx VSD  configuration information. 
 */ 
#ifdef CPRIMOD_SUPPORT
typedef struct portmod_cpri_rx_vsd_config_info_s {
    uint32 subchan_start; /**< sub channel start location */
    portmod_cpri_vsd_control_subchan_size_t subchan_size; /**< sub channel size. */
    portmod_cpri_vsd_control_subchan_num_bytes_t subchan_bytes; /**< Number of bytes */
    uint32 subchan_steps; /**< control word steps */
    portmod_cpri_vsd_control_flow_num_bytes_t flow_bytes; /**< Number of Bytes per flow. */
    uint32 queue_num; /**< Queue Number */
    uint32 rsvd_sector_mask[4]; /**< Reserved Sector Mask up to 128 bits total.  */
    uint32 priority; /**< Priority */
    uint32 queue_size; /**< Queue Size in Bytes */
} portmod_cpri_rx_vsd_config_info_t;

/* portmod_cpri_rx_vsd_config_info_t initialization and validation */
int portmod_cpri_rx_vsd_config_info_t_validate(int unit, const portmod_cpri_rx_vsd_config_info_t* portmod_cpri_rx_vsd_config_info);
int portmod_cpri_rx_vsd_config_info_t_init(int unit, portmod_cpri_rx_vsd_config_info_t* portmod_cpri_rx_vsd_config_info);

#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_rx_vsd_config_set
 *
 * @brief CPRI Rx VSD  Config Set/Get.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  config_info     -  Config info.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_vsd_config_set(int unit, int port, const portmod_cpri_rx_vsd_config_info_t* config_info);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_rx_vsd_config_get
 *
 * @brief CPRI Rx VSD  Config Set/Get.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  config_info     -  Config info.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_vsd_config_get(int unit, int port, portmod_cpri_rx_vsd_config_info_t* config_info);
#endif /* CPRIMOD_SUPPORT */


/*!
 * @struct portmod_cpri_tx_vsd_config_info_s
 * @brief CPRI Tx VSD  configuration information. 
 */ 
#ifdef CPRIMOD_SUPPORT
typedef struct portmod_cpri_tx_vsd_config_info_s {
    uint32 subchan_start; /**< sub channel start location */
    portmod_cpri_vsd_control_subchan_size_t subchan_size; /**< sub channel size. */
    portmod_cpri_vsd_control_subchan_num_bytes_t subchan_bytes; /**< Number of bytes */
    uint32 subchan_steps; /**< control word steps */
    portmod_cpri_vsd_control_flow_num_bytes_t flow_bytes; /**< Number of Bytes per flow. */
    uint32 queue_num; /**< Queue Number */
    uint32 rsvd_sector_mask[4]; /**< Reserved Sector Mask up to 128 bits total.  */
    uint32 buffer_size; /**< Buffer Size in Bytes */
    uint32 cycle_size; /**< Cycle Size */
    int byte_order_swap; /**< Byte Order Swap. */
} portmod_cpri_tx_vsd_config_info_t;

/* portmod_cpri_tx_vsd_config_info_t initialization and validation */
int portmod_cpri_tx_vsd_config_info_t_validate(int unit, const portmod_cpri_tx_vsd_config_info_t* portmod_cpri_tx_vsd_config_info);
int portmod_cpri_tx_vsd_config_info_t_init(int unit, portmod_cpri_tx_vsd_config_info_t* portmod_cpri_tx_vsd_config_info);

#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_tx_vsd_config_set
 *
 * @brief CPRI Tx VSD Config Set/Get.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  config_info     -  Config info.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_vsd_config_set(int unit, int port, const portmod_cpri_tx_vsd_config_info_t* config_info);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_tx_vsd_config_get
 *
 * @brief CPRI Tx VSD Config Set/Get.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  config_info     -  Config info.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_vsd_config_get(int unit, int port, portmod_cpri_tx_vsd_config_info_t* config_info);
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
typedef _shr_cpri_rx_vsd_flow_info_t portmod_cpri_rx_vsd_flow_info_t;

#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_rx_vsd_flow_add
 *
 * @brief CPRI Rx VSD Config Flow Add.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  group_id        - group id
 * @param [in]  flow_info       -  Flow info.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_vsd_flow_add(int unit, int port, uint32 group_id, const portmod_cpri_rx_vsd_flow_info_t* flow_info);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_rx_vsd_flow_get
 *
 * @brief CPRI Rx VSD Config Flow Get.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  group_id        - group id
 * @param [out]  flow_info       -  Flow info.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_vsd_flow_get(int unit, int port, uint32 group_id, portmod_cpri_rx_vsd_flow_info_t* flow_info);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_rx_vsd_flow_delete
 *
 * @brief  Delete CPRI Rx VSD Group Flow.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  group_id        - group id
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_vsd_flow_delete(int unit, int port, uint32 group_id);
#endif /* CPRIMOD_SUPPORT */

typedef _shr_cpri_tx_vsd_flow_info_t portmod_cpri_tx_vsd_flow_info_t;

/*! 
 * portmod_cpri_port_tx_vsd_flow_add
 *
 * @brief CPRI Rx VSD Config Flow Add.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  group_id        - group id
 * @param [in]  flow_info       -  Flow info.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_vsd_flow_add(int unit, int port, uint32 group_id, const portmod_cpri_tx_vsd_flow_info_t* flow_info);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_tx_vsd_flow_delete
 *
 * @brief  Delete CPRI Rx VSD Group Flow.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  group_id        - group id
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_vsd_flow_delete(int unit, int port, uint32 group_id);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_tx_vsd_flow_get
 *
 * @brief CPRI Rx VSD Config Flow Get.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  group_id        - group id
 * @param [out]  flow_info       -  Flow info.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_vsd_flow_get(int unit, int port, uint32 group_id, portmod_cpri_tx_vsd_flow_info_t* flow_info);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_encap_queue_control_tag_to_flow_map_set
 *
 * @brief CPRI Rx VSD  Config Set/Get.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  tag_id          - Tag Id.
 * @param [in]  flow_id         -  Flow ID.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_encap_queue_control_tag_to_flow_map_set(int unit, int port, uint32 tag_id, uint32 flow_id);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_encap_queue_control_tag_to_flow_map_get
 *
 * @brief CPRI Rx VSD  Config Set/Get.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  tag_id          - Tag Id.
 * @param [out]  flow_id         -  FLow ID.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_encap_queue_control_tag_to_flow_map_get(int unit, int port, uint32 tag_id, uint32* flow_id);
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
typedef _shr_cpri_cw_filter_mode_t portmod_cpri_cw_filter_mode_t;

#endif /* CPRIMOD_SUPPORT */
#ifdef CPRIMOD_SUPPORT
#define PORTMOD_CPRI_CW_FILTER_DISABLE _shrCpriFilterDisable
#define PORTMOD_CPRI_CW_FILTER_NON_ZERO _shrCpriFilterNonZero
#define PORTMOD_CPRI_CW_FILTER_PERIODIC _shrCpriFilterPeriodic
#define PORTMOD_CPRI_CW_FILTER_CHANGE _shrCpriFilterChange
#define PORTMOD_CPRI_CW_FILTER_PATTERN_MATCH _shrCpriFilterPatternMatch
#endif /* CPRIMOD_SUPPORT */


/*!
 * @struct portmod_cpri_rx_vsd_raw_config_s
 * @brief CPRI Rx VSD Raw Configuration Information. 
 */ 
#ifdef CPRIMOD_SUPPORT
typedef struct portmod_cpri_rx_vsd_raw_config_s {
    uint32 schan_start; /**< Sub Channel Start */
    uint32 schan_size; /**< Sub Channel Size */
    uint32 cw_sel; /**< Control Word Select Bit Map */
    uint32 cw_size; /**< Control Word Size, number of bytes */
    portmod_cpri_cw_filter_mode_t filter_mode; /**< Filter Mode */
    uint32 hyper_frame_index; /**< Hyper Frame Index */
    uint32 hyper_frame_modulo; /**< Hyper Frame Modulo */
    uint32 match_offset; /**< Match Offset */
    uint32 match_value; /**< Match Value */
    uint32 match_mask; /**< Match Mask */
    uint32 queue_num; /**< Queue Number. */
    uint32 priority; /**< Priority */
    uint32 queue_size; /**< Queue Size in Bytes */
} portmod_cpri_rx_vsd_raw_config_t;

/* portmod_cpri_rx_vsd_raw_config_t initialization and validation */
int portmod_cpri_rx_vsd_raw_config_t_validate(int unit, const portmod_cpri_rx_vsd_raw_config_t* portmod_cpri_rx_vsd_raw_config);
int portmod_cpri_rx_vsd_raw_config_t_init(int unit, portmod_cpri_rx_vsd_raw_config_t* portmod_cpri_rx_vsd_raw_config);

#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_rx_vsd_raw_config_set
 *
 * @brief  Get/Set VSD Raw Configuration.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  index           - VSD Raw Group Index. 0-7 
 * @param [in]  config_info     - VSD Raw  Configuration info.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_vsd_raw_config_set(int unit, int port, uint32 index, const portmod_cpri_rx_vsd_raw_config_t* config_info);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_rx_vsd_raw_config_get
 *
 * @brief  Get/Set VSD Raw Configuration.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  index           - VSD Raw Group Index. 0-7 
 * @param [out]  config_info     - VSD Raw  Configuration info.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_vsd_raw_config_get(int unit, int port, uint32 index, portmod_cpri_rx_vsd_raw_config_t* config_info);
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
typedef _shr_vsd_raw_map_mode_t portmod_cpri_vsd_raw_map_mode_t;

#endif /* CPRIMOD_SUPPORT */
#ifdef CPRIMOD_SUPPORT
#define PORTMOD_CPRI_CW_MAP_MODE_PERIODIC _shrVsdRawMapModePeriodic
#define PORTMOD_CPRI_CW_MAP_MODE_ROE_FRAME _shrVsdRawMapModeRoeFrame
#endif /* CPRIMOD_SUPPORT */


/*!
 * @struct portmod_cpri_tx_vsd_raw_config_s
 * @brief CPRI Tx VSD Raw Configuration Information. 
 */ 
#ifdef CPRIMOD_SUPPORT
typedef struct portmod_cpri_tx_vsd_raw_config_s {
    uint32 schan_start; /**< Sub Channel Start */
    uint32 schan_size; /**< Sub Channel Size */
    uint32 cw_sel; /**< Control Word Select Bit Map */
    uint32 cw_size; /**< Control Word Size, number of bytes */
    uint32 hyper_frame_index; /**< Hyper Frame Index */
    uint32 hyper_frame_modulo; /**< Hyper Frame Modulo */
    uint32 queue_num; /**< Queue Number. */
    portmod_cpri_vsd_raw_map_mode_t map_mode; /**< Map Mode. */
    int repeat_enable; /**< Repeat until new data.. */
    int bfn0_filter_enable; /**< Enable Filter BFN0. */
    int bfn1_filter_enable; /**< Enable Filter BFN1. */
    uint32 idle_value; /**< Value to be insert when data is not available. */
    uint32 buffer_size; /**< Buffer Size in Bytes */
    uint32 cycle_size; /**< Cycle Size */
} portmod_cpri_tx_vsd_raw_config_t;

/* portmod_cpri_tx_vsd_raw_config_t initialization and validation */
int portmod_cpri_tx_vsd_raw_config_t_validate(int unit, const portmod_cpri_tx_vsd_raw_config_t* portmod_cpri_tx_vsd_raw_config);
int portmod_cpri_tx_vsd_raw_config_t_init(int unit, portmod_cpri_tx_vsd_raw_config_t* portmod_cpri_tx_vsd_raw_config);

#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_tx_vsd_raw_config_set
 *
 * @brief  Get/Set Tx VSD Raw Configuration.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  index           - VSD Raw Group Index. 0-7 
 * @param [in]  config_info     - VSD Raw  Configuration info.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_vsd_raw_config_set(int unit, int port, uint32 index, const portmod_cpri_tx_vsd_raw_config_t* config_info);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_tx_vsd_raw_config_get
 *
 * @brief  Get/Set Tx VSD Raw Configuration.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  index           - VSD Raw Group Index. 0-7 
 * @param [out]  config_info     - VSD Raw  Configuration info.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_vsd_raw_config_get(int unit, int port, uint32 index, portmod_cpri_tx_vsd_raw_config_t* config_info);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_tx_vsd_raw_filter_set
 *
 * @brief  VSD Raw Radio Frame Filter Set/Get.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  bfn0_value      - BFN0 Radio Frame Number. 
 * @param [in]  bfn0_mask       - BFN0 Radio Frame Mask. 
 * @param [in]  bfn1_value      - BFN1 Radio Frame Number. 
 * @param [in]  bfn1_mask       - BFN1 Radio Frame Mask. 
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_vsd_raw_filter_set(int unit, int port, uint32 bfn0_value, uint32 bfn0_mask, uint32 bfn1_value, uint32 bfn1_mask);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_tx_vsd_raw_filter_get
 *
 * @brief  VSD Raw Radio Frame Filter Set/Get.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  bfn0_value      - BFN0 Radio Frame Number. 
 * @param [out]  bfn0_mask       - BFN0 Radio Frame Mask. 
 * @param [out]  bfn1_value      - BFN1 Radio Frame Number. 
 * @param [out]  bfn1_mask       - BFN1 Radio Frame Mask. 
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_vsd_raw_filter_get(int unit, int port, uint32* bfn0_value, uint32* bfn0_mask, uint32* bfn1_value, uint32* bfn1_mask);
#endif /* CPRIMOD_SUPPORT */


/*!
 * @struct portmod_cpri_rx_brcm_rsvd5_config_s
 * @brief CPRI Rx RSVD5  Configuration Information. 
 */ 
#ifdef CPRIMOD_SUPPORT
typedef struct portmod_cpri_rx_brcm_rsvd5_config_s {
    uint32 schan_start; /**< Sub Channel Start */
    uint32 schan_size; /**< Sub Channel Size */
    int parity_disable; /**< Parity Disable. */
    uint32 queue_num; /**< Queue Number. */
    uint32 priority; /**< Priority */
    uint32 queue_size; /**< Queue Size in Bytes */
} portmod_cpri_rx_brcm_rsvd5_config_t;

/* portmod_cpri_rx_brcm_rsvd5_config_t initialization and validation */
int portmod_cpri_rx_brcm_rsvd5_config_t_validate(int unit, const portmod_cpri_rx_brcm_rsvd5_config_t* portmod_cpri_rx_brcm_rsvd5_config);
int portmod_cpri_rx_brcm_rsvd5_config_t_init(int unit, portmod_cpri_rx_brcm_rsvd5_config_t* portmod_cpri_rx_brcm_rsvd5_config);

#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_rx_brcm_rsvd5_config_set
 *
 * @brief  Get/Set Rx RSVD5 Configuration.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  config_info     - RSVD5  Configuration info.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_brcm_rsvd5_config_set(int unit, int port, const portmod_cpri_rx_brcm_rsvd5_config_t* config_info);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_rx_brcm_rsvd5_config_get
 *
 * @brief  Get/Set Rx RSVD5 Configuration.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  config_info     - RSVD5  Configuration info.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_brcm_rsvd5_config_get(int unit, int port, portmod_cpri_rx_brcm_rsvd5_config_t* config_info);
#endif /* CPRIMOD_SUPPORT */


/*!
 * @struct portmod_cpri_tx_brcm_rsvd5_config_s
 * @brief CPRI Rx RSVD5  Configuration Information. 
 */ 
#ifdef CPRIMOD_SUPPORT
typedef struct portmod_cpri_tx_brcm_rsvd5_config_s {
    uint32 schan_start; /**< Sub Channel Start */
    uint32 schan_size; /**< Sub Channel Size */
    int crc_enable; /**< Parity Disable. */
    uint32 queue_num; /**< Queue Number. */
    uint32 buffer_size; /**< Buffer Size in Bytes */
    uint32 cycle_size; /**< Cycle Size */
} portmod_cpri_tx_brcm_rsvd5_config_t;

/* portmod_cpri_tx_brcm_rsvd5_config_t initialization and validation */
int portmod_cpri_tx_brcm_rsvd5_config_t_validate(int unit, const portmod_cpri_tx_brcm_rsvd5_config_t* portmod_cpri_tx_brcm_rsvd5_config);
int portmod_cpri_tx_brcm_rsvd5_config_t_init(int unit, portmod_cpri_tx_brcm_rsvd5_config_t* portmod_cpri_tx_brcm_rsvd5_config);

#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_tx_brcm_rsvd5_config_set
 *
 * @brief  Get/Set Tx RSVD5 Configuration.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  config_info     - RSVD5  Configuration info.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_brcm_rsvd5_config_set(int unit, int port, const portmod_cpri_tx_brcm_rsvd5_config_t* config_info);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_tx_brcm_rsvd5_config_get
 *
 * @brief  Get/Set Tx RSVD5 Configuration.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  config_info     - RSVD5  Configuration info.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_brcm_rsvd5_config_get(int unit, int port, portmod_cpri_tx_brcm_rsvd5_config_t* config_info);
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
typedef _shr_cpri_gcw_mask_t portmod_cpri_gcw_mask_t;

#endif /* CPRIMOD_SUPPORT */
#ifdef CPRIMOD_SUPPORT
#define PORTMOD_CPRI_GCW_MASK_NONE _shrCpriGcwMaskNone
#define PORTMOD_CPRI_GCW_MASK_LSB _shrCpriGcwMaskLSB
#define PORTMOD_CPRI_GCW_MASK_MSB _shrCpriGcwMaskMSB
#define PORTMOD_CPRI_GCW_MASK_BOTH _shrCpriGcwMaskBOTH
#endif /* CPRIMOD_SUPPORT */


/*!
 * @struct portmod_cpri_rx_gcw_config_s
 * @brief CPRI Rx GCW Configuration Information. 
 */ 
#ifdef CPRIMOD_SUPPORT
typedef struct portmod_cpri_rx_gcw_config_s {
    uint32 Ns; /**< Sub Channel Number 0-63 */
    uint32 Xs; /**< Sub Channel Word 0-3. */
    uint32 Y; /**< Sub Channel First Byte Location . */
    portmod_cpri_gcw_mask_t mask; /**< Mask  */
    portmod_cpri_cw_filter_mode_t filter_mode; /**< Filter Mode */
    uint32 hyper_frame_index; /**< Hyper Frame Index */
    uint32 hyper_frame_modulo; /**< Hyper Frame Modulo */
    uint32 match_mask; /**< Match Mask */
    uint32 match_value; /**< Match Value */
} portmod_cpri_rx_gcw_config_t;

/* portmod_cpri_rx_gcw_config_t initialization and validation */
int portmod_cpri_rx_gcw_config_t_validate(int unit, const portmod_cpri_rx_gcw_config_t* portmod_cpri_rx_gcw_config);
int portmod_cpri_rx_gcw_config_t_init(int unit, portmod_cpri_rx_gcw_config_t* portmod_cpri_rx_gcw_config);

#endif /* CPRIMOD_SUPPORT */

/*!
 * @struct portmod_cpri_tx_gcw_config_s
 * @brief CPRI Tx GCW Configuration Information. 
 */ 
#ifdef CPRIMOD_SUPPORT
typedef struct portmod_cpri_tx_gcw_config_s {
    uint32 Ns; /**< Sub Channel Number 0-63 */
    uint32 Xs; /**< Sub Channel Word 0-3. */
    uint32 Y; /**< Sub Channel First Byte Location . */
    portmod_cpri_gcw_mask_t mask; /**< Mask  */
    uint32 hyper_frame_index; /**< Hyper Frame Index */
    uint32 hyper_frame_modulo; /**< Hyper Frame Modulo */
    int repeat_enable; /**< Repeat until new data.. */
    int bfn0_filter_enable; /**< Enable Filter BFN0. */
    int bfn1_filter_enable; /**< Enable Filter BFN1. */
} portmod_cpri_tx_gcw_config_t;

/* portmod_cpri_tx_gcw_config_t initialization and validation */
int portmod_cpri_tx_gcw_config_t_validate(int unit, const portmod_cpri_tx_gcw_config_t* portmod_cpri_tx_gcw_config);
int portmod_cpri_tx_gcw_config_t_init(int unit, portmod_cpri_tx_gcw_config_t* portmod_cpri_tx_gcw_config);

#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_rx_gcw_config_set
 *
 * @brief  Get/Set Rx GCW Configuration.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  index           - GCW  Index. 0-15 
 * @param [in]  config_info     - GCW  Configuration info.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_gcw_config_set(int unit, int port, uint32 index, const portmod_cpri_rx_gcw_config_t* config_info);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_rx_gcw_config_get
 *
 * @brief  Get/Set Rx GCW Configuration.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  index           - GCW  Index. 0-15 
 * @param [out]  config_info     - GCW  Configuration info.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_gcw_config_get(int unit, int port, uint32 index, portmod_cpri_rx_gcw_config_t* config_info);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_tx_gcw_config_set
 *
 * @brief  Get/Set Tx GCW Configuration.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  index           - GCW  Index. 0-15 
 * @param [in]  config_info     - GCW  Configuration info.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_gcw_config_set(int unit, int port, uint32 index, const portmod_cpri_tx_gcw_config_t* config_info);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_tx_gcw_config_get
 *
 * @brief  Get/Set Tx GCW Configuration.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  index           - GCW  Index. 0-15 
 * @param [out]  config_info     - GCW  Configuration info.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_gcw_config_get(int unit, int port, uint32 index, portmod_cpri_tx_gcw_config_t* config_info);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_tx_gcw_filter_set
 *
 * @brief  GCW Radio Frame Filter Set/Get.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  bfn0_value      - BFN0 Radio Frame Number. 
 * @param [in]  bfn0_mask       - BFN0 Radio Frame Mask. 
 * @param [in]  bfn1_value      - BFN1 Radio Frame Number. 
 * @param [in]  bfn1_mask       - BFN1 Radio Frame Mask. 
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_gcw_filter_set(int unit, int port, uint32 bfn0_value, uint32 bfn0_mask, uint32 bfn1_value, uint32 bfn1_mask);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_tx_gcw_filter_get
 *
 * @brief  GCW Radio Frame Filter Set/Get.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  bfn0_value      - BFN0 Radio Frame Number. 
 * @param [out]  bfn0_mask       - BFN0 Radio Frame Mask. 
 * @param [out]  bfn1_value      - BFN1 Radio Frame Number. 
 * @param [out]  bfn1_mask       - BFN1 Radio Frame Mask. 
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_gcw_filter_get(int unit, int port, uint32* bfn0_value, uint32* bfn0_mask, uint32* bfn1_value, uint32* bfn1_mask);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_tx_cw_sync_info_set
 *
 * @brief  CPRI Sync information.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  hyper_frame_num   - Hyper Frame Number.
 * @param [in]  radio_frame_num   - Radio Frame Number.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_cw_sync_info_set(int unit, int port, uint32 hyper_frame_num, uint32 radio_frame_num);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_tx_cw_sync_info_get
 *
 * @brief  CPRI Sync information.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  hyper_frame_num   - Hyper Frame Number.
 * @param [out]  radio_frame_num   - Radio Frame Number.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_cw_sync_info_get(int unit, int port, uint32* hyper_frame_num, uint32* radio_frame_num);
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
typedef _shr_cpri_cw_l1_inband_info_t portmod_cpri_cw_l1_config_info_t;

#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_tx_cw_l1_inband_info_set
 *
 * @brief  CPRI Tx Control Word L1 Inband information.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  l1_inband_info   - L1 inband info..
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_cw_l1_inband_info_set(int unit, int port, const portmod_cpri_cw_l1_inband_info_t* l1_inband_info);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_tx_cw_l1_inband_info_get
 *
 * @brief  CPRI Tx Control Word L1 Inband information.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  l1_inband_info   - L1 inband info..
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_cw_l1_inband_info_get(int unit, int port, portmod_cpri_cw_l1_inband_info_t* l1_inband_info);
#endif /* CPRIMOD_SUPPORT */

typedef _shr_rsvd4_control_msg_proc_type_t portmod_control_msg_proc_type_t;

#define PORTMOD_CONTROL_MSG_PROC_TYPE_FE _shrRsvd4CtrlMsgProcFE
#define PORTMOD_CONTROL_MSG_PROC_TYPE_FCB _shrRsvd4CtrlMsgProcFCB
#define PORTMOD_CONTROL_MSG_PROC_TYPE_PAYLOAD _shrRsvd4CtrlMsgProcPayload
#define PORTMOD_CONTROL_MSG_PROC_TYPE_FULL_MESSAGE _shrRsvd4CtrlMsgProcFull
#define PORTMOD_CONTROL_MSG_PROC_TYPE_FULL_MESSAGE_W_TAG _shrRsvd4CtrlMsgProcFullWithTag


/*!
 * @struct portmod_control_flow_config_s
 * @brief  Control Flow Configuration Information. 
 */ 
typedef struct portmod_control_flow_config_s {
    uint32 match_mask; /**< Match Mask */
    uint32 match_data; /**< Match data */
    portmod_control_msg_proc_type_t proc_type; /**< . */
    uint32 queue_num; /**< Queue Number . */
    uint32 sync_profile; /**< Sync Profile Number */
    int sync_enable; /**< Sync Profile Enable. */
    uint32 priority; /**< Priority */
    uint32 queue_size; /**< Queue Size in Bytes */
} portmod_control_flow_config_t;

/* portmod_control_flow_config_t initialization and validation */
int portmod_control_flow_config_t_validate(int unit, const portmod_control_flow_config_t* portmod_control_flow_config);
int portmod_control_flow_config_t_init(int unit, portmod_control_flow_config_t* portmod_control_flow_config);

/*! 
 * portmod_rsvd4_rx_control_flow_add
 *
 * @brief  Set Control Message Configuration..  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flow_id         - Control Flow ID. 
 * @param [in]  config          - Control Flow Configuration. 
 */
#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_rx_control_flow_add(int unit, int port, uint32 flow_id, const portmod_control_flow_config_t* config);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_rsvd4_rx_control_flow_delete
 *
 * @brief  Set Control Message Configuration..  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flow_id         - Control Flow ID. 
 * @param [in]  config          - Control Flow Configuration. 
 */
#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_rx_control_flow_delete(int unit, int port, uint32 flow_id, const portmod_control_flow_config_t* config);
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
typedef _shr_cpri_fast_eth_config_t portmod_cpri_fast_eth_config_t;

#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_rsvd4_fast_eth_config_set
 *
 * @brief  Set Fast Ethernet configuration..  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  config_info     - Fast Eth Configuration. 
 */
#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_fast_eth_config_set(int unit, int port, const portmod_cpri_fast_eth_config_t* config_info);
#endif /* CPRIMOD_SUPPORT */

typedef _shr_rsvd4_sync_count_cycle_t portmod_sync_count_cycle_t;

#define PORTMOD_SYNC_COUNT_CYCLE_EVERY_MF _shrRsvd4SyncCountCycleEveryMF
#define PORTMOD_SYNC_COUNT_CYCLE_UP_TO_6MF _shrRsvd4SyncCountCycleUpToSixMF


/*!
 * @struct portmod_sync_profile_entry_s
 * @brief  Control Flow Configuration Information. 
 */ 
typedef struct portmod_sync_profile_entry_s {
    portmod_sync_count_cycle_t count_cycle; /**< Count Cycle */
    uint32 message_offset; /**< Message offset within Master Frame . */
    uint32 master_frame_offset; /**< Master Frame Offset. bfn_offset */
} portmod_sync_profile_entry_t;

/* portmod_sync_profile_entry_t initialization and validation */
int portmod_sync_profile_entry_t_validate(int unit, const portmod_sync_profile_entry_t* portmod_sync_profile_entry);
int portmod_sync_profile_entry_t_init(int unit, portmod_sync_profile_entry_t* portmod_sync_profile_entry);

/*! 
 * portmod_rsvd4_rx_sync_profile_entry_set
 *
 * @brief  Sync Profile Entry..  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  profile_id      - Control Flow ID. 
 * @param [in]  entry           - Sync Profile Entry. 
 */
#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_rx_sync_profile_entry_set(int unit, int port, uint32 profile_id, const portmod_sync_profile_entry_t* entry);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_rsvd4_rx_sync_profile_entry_get
 *
 * @brief  Sync Profile Entry..  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  profile_id      - Control Flow ID. 
 * @param [out]  entry           - Sync Profile Entry. 
 */
#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_rx_sync_profile_entry_get(int unit, int port, uint32 profile_id, portmod_sync_profile_entry_t* entry);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_rx_tag_config_set
 *
 * @brief  Tag Generation Entry..  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  default_tag     - Default Tag . 
 * @param [in]  no_match_tag    - No Match Tag . 
 */
int portmod_rx_tag_config_set(int unit, int port, uint32 default_tag, uint32 no_match_tag);

typedef _shr_cpri_tag_gen_entry_t portmod_tag_gen_entry_t;

/*! 
 * portmod_rx_tag_gen_entry_add
 *
 * @brief  Tag Generation Entry..  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  entry           - Tag Generation Entry Info. 
 */
int portmod_rx_tag_gen_entry_add(int unit, int port, const portmod_tag_gen_entry_t* entry);

/*! 
 * portmod_rx_tag_gen_entry_delete
 *
 * @brief  Tag Generation Entry..  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  entry           - Tag Generation Entry Info. 
 */
int portmod_rx_tag_gen_entry_delete(int unit, int port, const portmod_tag_gen_entry_t* entry);

/*! 
 * portmod_rsvd4_tx_control_flow_group_member_add
 *
 * @brief  Add member to the Tx Control Flow Group..  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  group_id        - Group Number 0 or 1. 
 * @param [in]  priority        - Prioirty within the group 0-3. 
 * @param [in]  queue_num       - Queue Numer. 
 * @param [in]  proc_type       - Processing Type. 
 */
#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_tx_control_flow_group_member_add(int unit, int port, uint32 group_id, uint32 priority, uint32 queue_num, portmod_control_msg_proc_type_t proc_type);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_rsvd4_tx_control_flow_group_member_delete
 *
 * @brief  Delete member to the Tx Control Flow Group..  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  group_id        - Group Number 0 or 1. 
 * @param [in]  priority        - Prioirty within the group 0-3. 
 */
#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_tx_control_flow_group_member_delete(int unit, int port, uint32 group_id, uint32 priority);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_rsvd4_tx_eth_message_config_set
 *
 * @brief  Setting RSVD4 Fast Ethernet Control Message Configuration..  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  msg_node        - Message Node. 
 * @param [in]  msg_subnode     - Message SubNode. 
 * @param [in]  msg_type        - Message Type. 
 * @param [in]  msg_padding     - Padding Bit 0 or 1. 
 */
#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_tx_eth_message_config_set(int unit, int port, uint32 msg_node, uint32 msg_subnode, uint32 msg_type, uint32 msg_padding);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_rsvd4_tx_single_raw_message_config_set
 *
 * @brief  Setting RSVD4 Single Raw Control Message Configuration..  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  msg_id          - Message ID. 
 * @param [in]  msg_type        - Message Type. 
 */
#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_tx_single_raw_message_config_set(int unit, int port, uint32 msg_id, uint32 msg_type);
#endif /* CPRIMOD_SUPPORT */


/*!
 * @struct portmod_rsvd4_tx_config_info_s
 * @brief  Control Flow Configuration Information. 
 */ 
#ifdef CPRIMOD_SUPPORT
typedef struct portmod_rsvd4_tx_config_info_s {
    portmod_control_msg_proc_type_t proc_type; /**< Controm message process type */
    uint8 queue_num; /**< queue number */
    uint32 queue_size; /**< queue size */
    uint32 cycle_size; /**< cycle size */
    uint8 crc_mode; /**< crc mode */
} portmod_rsvd4_tx_config_info_t;

/* portmod_rsvd4_tx_config_info_t initialization and validation */
int portmod_rsvd4_tx_config_info_t_validate(int unit, const portmod_rsvd4_tx_config_info_t* portmod_rsvd4_tx_config_info);
int portmod_rsvd4_tx_config_info_t_init(int unit, portmod_rsvd4_tx_config_info_t* portmod_rsvd4_tx_config_info);

#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_rsvd4_tx_control_flow_config_set
 *
 * @brief  Set Control Message Configuration..  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flow_id         - Control Flow ID. 
 * @param [in]  config_info     - control config info. 
 */
#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_tx_control_flow_config_set(int unit, int port, uint32 flow_id, const portmod_rsvd4_tx_config_info_t* config_info);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_rsvd4_tx_control_flow_config_get
 *
 * @brief  Set Control Message Configuration..  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flow_id         - Control Flow ID. 
 * @param [out]  config_info     - control config info. 
 */
#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_tx_control_flow_config_get(int unit, int port, uint32 flow_id, portmod_rsvd4_tx_config_info_t* config_info);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_rsvd4_tx_control_flow_header_index_set
 *
 * @brief  Set Index to header config table for a particular flow..  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  roe_flow_id     -  Flow ID from ROE header. 
 * @param [in]  index           - Index to header config table. 
 */
#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_tx_control_flow_header_index_set(int unit, int port, uint32 roe_flow_id, uint32 index);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_rsvd4_tx_control_flow_header_index_get
 *
 * @brief  Set Index to header config table for a particular flow..  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  roe_flow_id     -  Flow ID from ROE header. 
 * @param [out]  index           - Index to header config table. 
 */
#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_tx_control_flow_header_index_get(int unit, int port, uint32 roe_flow_id, uint32* index);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_rsvd4_tx_control_header_entry_set
 *
 * @brief   Header Look up Entry..  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  index           -  Index to the table. 
 * @param [in]  header_node     - rsvd4 header node. 
 * @param [in]  header_subnode   - rsvd4 header subnode. 
 * @param [in]  payload_node    - rsvd4 payload node. 
 */
#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_tx_control_header_entry_set(int unit, int port, uint32 index, uint32 header_node, uint32 header_subnode, uint32 payload_node);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_rsvd4_tx_control_header_entry_get
 *
 * @brief   Header Look up Entry..  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  index           -  Index to the table. 
 * @param [out]  header_node     - rsvd4 header node. 
 * @param [out]  header_subnode   - rsvd4 header subnode. 
 * @param [out]  payload_node    - rsvd4 payload node. 
 */
#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_tx_control_header_entry_get(int unit, int port, uint32 index, uint32* header_node, uint32* header_subnode, uint32* payload_node);
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
typedef _shr_rsvd4_crc_option_t portmod_cpri_crc_option_t;

#endif /* CPRIMOD_SUPPORT */
#ifdef CPRIMOD_SUPPORT
#define PORTMOD_CPRI_CRC_USE_ROE _shrRsvd4CrcOptionUseRoe
#define PORTMOD_CPRI_CRC_REGENERATE _shrRsvd4CrcOptionRegenerate
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_rsvd4_tx_single_tunnel_message_config_set
 *
 * @brief  Setting RSVD4 Single Raw Control Message Configuration..  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  crc_option      - CRC option. 
 */
#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_tx_single_tunnel_message_config_set(int unit, int port, portmod_cpri_crc_option_t crc_option);
#endif /* CPRIMOD_SUPPORT */


/*!
 * @struct portmod_txpi_override_s
 * @brief TX phase interpolator DSM override configuration 
 */ 
typedef struct portmod_txpi_override_s {
    uint32 enable; /**< Enable/disable TXPI override */
    int value; /**< TXPI override value */
} portmod_txpi_override_t;

/* portmod_txpi_override_t initialization and validation */
int portmod_txpi_override_t_validate(int unit, const portmod_txpi_override_t* portmod_txpi_override);
int portmod_txpi_override_t_init(int unit, portmod_txpi_override_t* portmod_txpi_override);

/*! 
 * portmod_port_txpi_override_set
 *
 * @brief "Set/get Portmacro TXPI SDM override configuration. This function is for debug." 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  override        - Enable TXPI DSM override with value
 */
int portmod_port_txpi_override_set(int unit, int port, const portmod_txpi_override_t* override);
/*! 
 * portmod_port_txpi_override_get
 *
 * @brief "Set/get Portmacro TXPI SDM override configuration. This function is for debug." 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  override        - Get TXPI DSM override status
 */
int portmod_port_txpi_override_get(int unit, int port, portmod_txpi_override_t* override);

/*! 
 * portmod_port_txpi_sdm_data_get
 *
 * @brief "Get Portmacro TXPI SDM value. This funciont is for debug" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - The value for TXPI SDM, which is the final resolution.
 */
int portmod_port_txpi_sdm_data_get(int unit, int port, int* value);

/*! 
 * @brief PM8x50 Specific capabilities 
 */ 
#define PORTMOD_PM8x50_MAX_VCOS (3)
#define PORTMOD_PM8x50_NUM_PLLS (2)
#define PORTMOD_PM8x50_NUM_CORES (1)
#define PORTMOD_PM8x50_NUM_LANES (8)

typedef struct portmod_pm8x50_capability_s {
    uint8 num_lanes; /**< number of physical lanes(ports) supported by the PM */
    uint8 num_cores; /**< Number of Cores in the PM */
    uint8 num_plls; /**< Number of PLLs supported by the PM */
    uint8 num_vcos; /**< Number of VCOs available in the PM */
    uint8 vcos[PORTMOD_PM8x50_MAX_VCOS]; /**< Available VCO range values for the PM  */
} portmod_pm8x50_capability_t;

/* portmod_pm8x50_capability_t initialization and validation */
int portmod_pm8x50_capability_t_validate(int unit, const portmod_pm8x50_capability_t* portmod_pm8x50_capability);
int portmod_pm8x50_capability_t_init(int unit, portmod_pm8x50_capability_t* portmod_pm8x50_capability);

typedef union portmod_pm_specific_capability_u {
    portmod_pm8x50_capability_t pm8x50_cap;
} portmod_pm_specific_capability_t;

typedef struct portmod_pm_capability_s {
    portmod_dispatch_type_t type; /**< PM type */
    portmod_pm_specific_capability_t pm_capability; /**< PM capability */
} portmod_pm_capability_t;

/* portmod_pm_capability_t initialization and validation */
int portmod_pm_capability_t_validate(int unit, const portmod_pm_capability_t* portmod_pm_capability);
int portmod_pm_capability_t_init(int unit, portmod_pm_capability_t* portmod_pm_capability);

typedef struct portmod_pm_vco_setting_s {
    int num_speeds; /**< number of speed ids that need to be supported */
    portmod_speed_config_t* speed_config_list; /**< list of speed configs */
    int* port_starting_lane_list; /**< list of starting_lanes correspond to speed configs in speed_config_list */
    int* speed_for_pcs_bypass_port; /**< if speed is for PCS bypass port */
    portmod_vco_type_t tvco; /**< Higher VCO value */
    portmod_vco_type_t ovco; /**< Lower VCO value */
    int is_tvco_new; /**< tvco change is needed */
    int is_ovco_new; /**< ovco change is needed */
    portmod_core_port_enet_cpri_type_t* port_type_list; /**< list of port type only used in CMP CPRI-RSVD4-Enet size num_speeds */
} portmod_pm_vco_setting_t;

/* portmod_pm_vco_setting_t initialization and validation */
int portmod_pm_vco_setting_t_validate(int unit, const portmod_pm_vco_setting_t* portmod_pm_vco_setting);
int portmod_pm_vco_setting_t_init(int unit, portmod_pm_vco_setting_t* portmod_pm_vco_setting);

/*! 
 * portmod_pm_speed_config_validate
 *
 * @brief Validate a set of speed config within a port macro. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  pm_id           - port macro id
 * @param [in]  ports           - logical ports being validated
 * @param [in]  flag            - flag
 * @param [inout] vco_setting     - suggested vco setting
 */
int portmod_pm_speed_config_validate(int unit, int pm_id, const portmod_pbmp_t* ports, int flag, portmod_pm_vco_setting_t* vco_setting);

/*! 
 * portmod_pm_vcos_get
 *
 * @brief Get the suggested VCO values based on the speed config list of a PM 
 *
 * @param [in]  unit            - unit id
 * @param [in]  pm_type         - PM type
 * @param [in]  flags           - Flags, see PM_VERSION_F_
 * @param [inout] vco_select      - speed config list as the input and suggested VCO rates as the output
 */
int portmod_pm_vcos_get(int unit, portmod_dispatch_type_t pm_type, uint32 flags, portmod_pm_vco_setting_t* vco_select);

/*! 
 * @brief Flags for portmod_vcos_get function. 
 */ 
#define PORTMOD_PM8X50_REV0_16NM 0x1 /**< The target PM version is PM8x50 16nm revision0. */
#define PORTMOD_ALLOW_20P625G_TVCO 0x1000 /**< Allow TVCO to be 20.625G. */
#define PORTMOD_PRIORITIZE_26P562G_TVCO 0x2000 /**< When Portmod is free to choose TVCO, use 26.562G as TVCO. */

#define PORTMOD_PM8X50_REV0_16NM_SET(flags) ((flags) |= PORTMOD_PM8X50_REV0_16NM)
#define PORTMOD_ALLOW_20P625G_TVCO_SET(flags) ((flags) |= PORTMOD_ALLOW_20P625G_TVCO)
#define PORTMOD_PRIORITIZE_26P562G_TVCO_SET(flags) ((flags) |= PORTMOD_PRIORITIZE_26P562G_TVCO)

#define PORTMOD_PM8X50_REV0_16NM_CLR(flags) ((flags) &= ~PORTMOD_PM8X50_REV0_16NM)
#define PORTMOD_ALLOW_20P625G_TVCO_CLR(flags) ((flags) &= ~PORTMOD_ALLOW_20P625G_TVCO)
#define PORTMOD_PRIORITIZE_26P562G_TVCO_CLR(flags) ((flags) &= ~PORTMOD_PRIORITIZE_26P562G_TVCO)

#define PORTMOD_PM8X50_REV0_16NM_GET(flags) ((flags) & PORTMOD_PM8X50_REV0_16NM ? 1 : 0)
#define PORTMOD_ALLOW_20P625G_TVCO_GET(flags) ((flags) & PORTMOD_ALLOW_20P625G_TVCO ? 1 : 0)
#define PORTMOD_PRIORITIZE_26P562G_TVCO_GET(flags) ((flags) & PORTMOD_PRIORITIZE_26P562G_TVCO ? 1 : 0)


/*! 
 * portmod_port_autoneg_ability_advert_set
 *
 * @brief Set/get port auto negotiation ability 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  num_abilities   - Number of AN abilities to be set
 * @param [in]  abilities       - AN abilities array
 */
int portmod_port_autoneg_ability_advert_set(int unit, int port, int num_abilities, const portmod_port_speed_ability_t* abilities);
/*! 
 * portmod_port_autoneg_ability_advert_get
 *
 * @brief Set/get port auto negotiation ability 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  max_num_abilities   - Maximum abilities that can return in the ability array
 * @param [out]  abilities       - AN abilities array
 * @param [out]  actual_num_abilities   - Number of AN abilities to be set
 */
int portmod_port_autoneg_ability_advert_get(int unit, int port, int max_num_abilities, portmod_port_speed_ability_t* abilities, int* actual_num_abilities);

/*! 
 * portmod_port_autoneg_ability_remote_get
 *
 * @brief Port ability remote Adv get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  max_num_abilities   - Maximum abilities that can return in the ability array
 * @param [out]  abilities       - AN abilities array
 * @param [out]  actual_num_abilities   - Number of AN abilities to be set
 */
int portmod_port_autoneg_ability_remote_get(int unit, int port, int max_num_abilities, portmod_port_speed_ability_t* abilities, int* actual_num_abilities);


typedef _shr_cpri_interrupt_type_t portmod_cpri_port_intr_type_t;

typedef struct portmod_cpri_port_intr_info_s {
    portmod_cpri_port_intr_type_t cpri_intr_type; /**< cpri interrupt type */
    int axc_id; /**< AxC Id */
    int queue_num; /**< queu num */
    int data; /**< reserved */
    uint64 data64; /**< reserved */
} portmod_cpri_port_intr_info_t;

/* portmod_cpri_port_intr_info_t initialization and validation */
int portmod_cpri_port_intr_info_t_validate(int unit, const portmod_cpri_port_intr_info_t* portmod_cpri_port_intr_info);
int portmod_cpri_port_intr_info_t_init(int unit, portmod_cpri_port_intr_info_t* portmod_cpri_port_intr_info);

typedef _shr_cpri_port_interrupt_callback_t portmod_cpri_port_interrupt_callback_t;

/*! 
 * portmod_cpri_port_interrupt_callback_register
 *
 * @brief  Register callback for CPRI Interrupts  
 *
 * @param [in]  unit            - unit id
 * @param [in]  cpri_intr_type   - 
 * @param [in]  callback        - 
 * @param [out]  cb_data         - 
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_interrupt_callback_register(int unit, portmod_cpri_port_intr_type_t cpri_intr_type, portmod_cpri_port_interrupt_callback_t callback, void* cb_data);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_interrupt_callback_unregister
 *
 * @brief  Unregister callback for CPRI Interrupts  
 *
 * @param [in]  unit            - unit id
 * @param [in]  cpri_intr_type   - 
 * @param [in]  callback        - 
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_interrupt_callback_unregister(int unit, portmod_cpri_port_intr_type_t cpri_intr_type, cprimod_cpri_port_interrupt_callback_t callback);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_phy_pms_ids_get
 *
 * @brief get all the PMS info of specific phy 
 *
 * @param [in]  unit            - unit id
 * @param [in]  phy             - phy number
 * @param [in]  max_pms         - max number of returned pms
 * @param [out]  nof_pms         - retrieved number of pms
 * @param [out]  pms_types       - retrieved pms type
 * @param [out]  pms_ids         - retrieved pms ids
 */
int portmod_phy_pms_ids_get(int unit, int phy, int max_pms, int* nof_pms, portmod_dispatch_type_t* pms_types, int* pms_ids);

/*! 
 * portmod_port_pm_id_get
 *
 * @brief get PM id of specific port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  pm_id           - retrieved pm id
 */
int portmod_port_pm_id_get(int unit, int port, int* pm_id);

/*! 
 * portmod_cpri_port_interrupt_enable_set
 *
 * @brief  Get the CPRI Port interrupt status.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  cpri_intr_type   - 
 * @param [in]  data            - 
 * @param [in]  enable          - 
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_interrupt_enable_set(int unit, int port, portmod_cpri_port_intr_type_t cpri_intr_type, int data, int enable);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_interrupt_enable_get
 *
 * @brief  Get the CPRI Port interrupt status.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  cpri_intr_type   - 
 * @param [in]  data            - 
 * @param [out]  enable          - 
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_interrupt_enable_get(int unit, int port, portmod_cpri_port_intr_type_t cpri_intr_type, int data, int* enable);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_pm_interrupt_process
 *
 * @brief   Porcess CPRI PM interrupts.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  pm_id           - port macro id
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_pm_interrupt_process(int unit, int pm_id);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_fast_clk_bit_time_period_set
 *
 * @brief  set/get fast clk bit period  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  bit_time_period   - bit time 2 bit ns 12 bit sub ns
 */
#ifdef CPRIMOD_SUPPORT
int portmod_fast_clk_bit_time_period_set(int unit, int port, uint32 bit_time_period);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_fast_clk_bit_time_period_get
 *
 * @brief  set/get fast clk bit period  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  bit_time_period   - bit time 2 bit ns 12 bit sub ns
 */
#ifdef CPRIMOD_SUPPORT
int portmod_fast_clk_bit_time_period_get(int unit, int port, uint32* bit_time_period);
#endif /* CPRIMOD_SUPPORT */

typedef _shr_cpri_dir_t portmod_direction_t;

#define PORTMOD_DIR_TX _shrCpriDirTx
#define PORTMOD_DIR_RX _shrCpriDirRx

/*! 
 * portmod_1588_bit_time_period_set
 *
 * @brief  set/get time stamp bit period  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  direction       - TX/RX
 * @param [in]  speed           - speed
 */
#ifdef CPRIMOD_SUPPORT
int portmod_1588_bit_time_period_set(int unit, int port, portmod_direction_t direction, cprimod_port_speed_t speed);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_1588_bit_time_period_get
 *
 * @brief  set/get time stamp bit period  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  direction       - TX/RX
 * @param [out]  bit_time_period   - bit time
 */
#ifdef CPRIMOD_SUPPORT
int portmod_1588_bit_time_period_get(int unit, int port, portmod_direction_t direction, uint32* bit_time_period);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_1588_timestamp_capture_config_set
 *
 * @brief  set/get time stamp config  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  direction       - TX/RX
 * @param [in]  config          - Config
 */
#ifdef CPRIMOD_SUPPORT
int portmod_1588_timestamp_capture_config_set(int unit, int port, portmod_direction_t direction, const cprimod_1588_capture_config_t* config);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_1588_timestamp_capture_config_get
 *
 * @brief  set/get time stamp config  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  direction       - TX/RX
 * @param [out]  config          - Config
 */
#ifdef CPRIMOD_SUPPORT
int portmod_1588_timestamp_capture_config_get(int unit, int port, portmod_direction_t direction, cprimod_1588_capture_config_t* config);
#endif /* CPRIMOD_SUPPORT */

typedef _shr_cpri_1588_ts_type_t portmod_1588_ts_type_t;

#define PORTMOD_1588_TS_TYPE_FIFO _shrCpri1588TsTypeFifo
#define PORTMOD_1588_TS_TYPE_CMIC _shrCpri1588TsTypeCMIC
#define PORTMOD_1588_TS_TYPE_SW_CAP _shrCpri1588TsTypeSw

/*! 
 * portmod_1588_captured_timestamp_get
 *
 * @brief  Get timestemp  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  direction       - TX/RX
 * @param [in]  ts_type         - Fifo or capture timestamp
 * @param [in]  mx_cnt          - 
 * @param [out]  count           - 
 * @param [out]  captured_time   - captured time
 */
#ifdef CPRIMOD_SUPPORT
int portmod_1588_captured_timestamp_get(int unit, int port, portmod_direction_t direction, portmod_1588_ts_type_t ts_type, uint8 mx_cnt, uint8* count, uint64* captured_time);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_1588_timestamp_adjust_set
 *
 * @brief  set/get time stamp config  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  direction       - TX/RX
 * @param [in]  adjust_time     - adjest time
 */
#ifdef CPRIMOD_SUPPORT
int portmod_1588_timestamp_adjust_set(int unit, int port, portmod_direction_t direction, const cprimod_1588_time_t* adjust_time);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_1588_timestamp_adjust_get
 *
 * @brief  set/get time stamp config  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  direction       - TX/RX
 * @param [out]  adjust_time     - adjest time
 */
#ifdef CPRIMOD_SUPPORT
int portmod_1588_timestamp_adjust_get(int unit, int port, portmod_direction_t direction, cprimod_1588_time_t* adjust_time);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_1588_timestamp_fifo_config_set
 *
 * @brief  set/get time stamp modulo for fifo  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  direction       - TX/RX
 * @param [in]  modulo          - modulo
 */
#ifdef CPRIMOD_SUPPORT
int portmod_1588_timestamp_fifo_config_set(int unit, int port, portmod_direction_t direction, uint16 modulo);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_1588_timestamp_fifo_config_get
 *
 * @brief  set/get time stamp modulo for fifo  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  direction       - TX/RX
 * @param [out]  modulo          - modulo
 */
#ifdef CPRIMOD_SUPPORT
int portmod_1588_timestamp_fifo_config_get(int unit, int port, portmod_direction_t direction, uint16* modulo);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_1588_timestamp_cmic_config_set
 *
 * @brief  set/get time stamp modulo for cmic  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  direction       - TX/RX
 * @param [in]  modulo          - modulo
 */
#ifdef CPRIMOD_SUPPORT
int portmod_1588_timestamp_cmic_config_set(int unit, int port, portmod_direction_t direction, uint16 modulo);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_1588_timestamp_cmic_config_get
 *
 * @brief  set/get time stamp modulo for cmic  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  direction       - TX/RX
 * @param [out]  modulo          - modulo
 */
#ifdef CPRIMOD_SUPPORT
int portmod_1588_timestamp_cmic_config_get(int unit, int port, portmod_direction_t direction, uint16* modulo);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_port_tx_set
 *
 * @brief Port tx taps set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  tx              - 
 */
int portmod_port_tx_set(int unit, int port, const phymod_tx_t* tx);
/*! 
 * portmod_port_tx_get
 *
 * @brief Port tx taps set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  tx              - 
 */
int portmod_port_tx_get(int unit, int port, phymod_tx_t* tx);


/*!
 * @struct portmod_port_synce_clk_ctrl_s
 * @brief  Port SyncE configuration info 
 */ 
typedef struct portmod_port_synce_clk_ctrl_s {
    int stg0_mode; /**< stage 0 divider value */
    int stg1_mode; /**< stage 1 divider value */
    uint32 sdm_val; /**< modulator value */
} portmod_port_synce_clk_ctrl_t;

/* portmod_port_synce_clk_ctrl_t initialization and validation */
int portmod_port_synce_clk_ctrl_t_validate(int unit, const portmod_port_synce_clk_ctrl_t* portmod_port_synce_clk_ctrl);
int portmod_port_synce_clk_ctrl_t_init(int unit, portmod_port_synce_clk_ctrl_t* portmod_port_synce_clk_ctrl);

/*! 
 * portmod_port_synce_clk_ctrl_set
 *
 * @brief Port SyncE clock control config 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  cfg             - synce clock divisor config
 */
int portmod_port_synce_clk_ctrl_set(int unit, int port, const portmod_port_synce_clk_ctrl_t* cfg);
/*! 
 * portmod_port_synce_clk_ctrl_get
 *
 * @brief Port SyncE clock control config 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  cfg             - synce clock divisor config
 */
int portmod_port_synce_clk_ctrl_get(int unit, int port, portmod_port_synce_clk_ctrl_t* cfg);

typedef _shr_cpri_frame_sync_mode_t portmod_cpri_frame_sync_mode_t;

#define PORTMOD_CPRI_FRAME_SYNC_MODE_HYPER _shrCpriFrameSyncModeHyper
#define PORTMOD_CPRI_FRAME_SYNC_MODE_RADIO _shrCpriFrameSyncModeRadio
#define PORTMOD_CPRI_FRAME_SYNC_MODE_BASIC _shrCpriFrameSyncModeBasic
#define PORTMOD_CPRI_FRAME_SYNC_MODE_TUNNEL _shrCpriFrameSyncModeTunnel

typedef _shr_cpri_roe_payload_multiple_t portmod_cpri_roe_payload_multiple_t;

#define PORTMOD_CPRI_PAYLOAD_MULTIPLE_1X _shrCpriPayloadMultiple1X
#define PORTMOD_CPRI_PAYLOAD_MULTIPLE_1P5X _shrCpriPayloadMultiple1p5X
#define PORTMOD_CPRI_PAYLOAD_MULTIPLE_2X _shrCpriPayloadMultiple2X
#define PORTMOD_CPRI_PAYLOAD_MULTIPLE_4X _shrCpriPayloadMultiple4X

typedef _shr_cpri_roe_ordering_info_option_t portmod_cpri_roe_ordering_info_option_t;

#define PORTMOD_CPRI_ROE_ORDERING_INFO_OPTION_SEQ_NUM _shrCpriRoeOrderingInfoOptionSeqNum
#define PORTMOD_CPRI_ROE_ORDERING_INFO_OPTION_TIMESTAMP _shrCpriRoeOrderingInfoOptionTimestamp


/*!
 * @struct portmod_cpri_rx_agnostic_config_info_s
 * @brief  CPRI Rx Agnostic Configuration information. 
 */ 
#ifdef CPRIMOD_SUPPORT
typedef struct portmod_cpri_rx_agnostic_config_info_s {
    portmod_cpri_frame_sync_mode_t sync_mode; /**< Frame Sync Mode */
    uint32 basic_frame_offset; /**< Basic Frame Offset */
    uint32 hyper_frame_offset; /**< Hyper Frame Offset */
    uint32 radio_frame_offset; /**< Radio Frame Offset */
    portmod_cpri_roe_payload_multiple_t payload_multiple; /**< RoE Payload size multiple of Basic Frame Length.  */
    uint32 pres_mod_count; /**< Presentation Mod Count. */
    portmod_cpri_roe_ordering_info_option_t ordering_info_option; /**< Ordering Info Option. */
} portmod_cpri_rx_agnostic_config_info_t;

/* portmod_cpri_rx_agnostic_config_info_t initialization and validation */
int portmod_cpri_rx_agnostic_config_info_t_validate(int unit, const portmod_cpri_rx_agnostic_config_info_t* portmod_cpri_rx_agnostic_config_info);
int portmod_cpri_rx_agnostic_config_info_t_init(int unit, portmod_cpri_rx_agnostic_config_info_t* portmod_cpri_rx_agnostic_config_info);

#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_rx_agnostic_config_set
 *
 * @brief  Setup Rx framer for agnostic mode.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - enable
 * @param [in]  config_info     - Agnostic configuration information.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_agnostic_config_set(int unit, int port, int enable, const portmod_cpri_rx_agnostic_config_info_t* config_info);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_rx_agnostic_config_get
 *
 * @brief  Setup Rx framer for agnostic mode.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - enable
 * @param [out]  config_info     - Agnostic configuration information.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_agnostic_config_get(int unit, int port, int* enable, portmod_cpri_rx_agnostic_config_info_t* config_info);
#endif /* CPRIMOD_SUPPORT */


/*!
 * @struct portmod_cpri_tx_agnostic_config_info_s
 * @brief  CPRI Rx Agnostic Configuration information. 
 */ 
#ifdef CPRIMOD_SUPPORT
typedef struct portmod_cpri_tx_agnostic_config_info_s {
    portmod_cpri_frame_sync_mode_t sync_mode; /**< Frame Sync Mode */
    uint32 basic_frame_offset; /**< Basic Frame Offset */
    uint32 hyper_frame_offset; /**< Hyper Frame Offset */
    uint32 radio_frame_offset; /**< Radio Frame Offset */
    portmod_cpri_roe_payload_multiple_t payload_multiple; /**< RoE Payload size multiple of Basic Frame Length.  */
    uint32 queue_mod_count; /**< Queue  Mod Count for Jitter Buffer. */
    uint32 pres_mod_count; /**< Presentation  Mod Count for Filtering. */
    uint32 pres_mod_offset; /**< Presentation   Mod Offset. */
    portmod_cpri_roe_ordering_info_option_t ordering_info_option; /**< Ordering Info Option. */
} portmod_cpri_tx_agnostic_config_info_t;

/* portmod_cpri_tx_agnostic_config_info_t initialization and validation */
int portmod_cpri_tx_agnostic_config_info_t_validate(int unit, const portmod_cpri_tx_agnostic_config_info_t* portmod_cpri_tx_agnostic_config_info);
int portmod_cpri_tx_agnostic_config_info_t_init(int unit, portmod_cpri_tx_agnostic_config_info_t* portmod_cpri_tx_agnostic_config_info);

#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_tx_agnostic_config_set
 *
 * @brief  Setup Tx framer for agnostic mode.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - enable
 * @param [in]  config_info     - Agnostic configuration information.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_agnostic_config_set(int unit, int port, int enable, const portmod_cpri_tx_agnostic_config_info_t* config_info);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_tx_agnostic_config_get
 *
 * @brief  Setup Tx framer for agnostic mode.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - enable
 * @param [out]  config_info     - Agnostic configuration information.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_agnostic_config_get(int unit, int port, int* enable, portmod_cpri_tx_agnostic_config_info_t* config_info);
#endif /* CPRIMOD_SUPPORT */

typedef _shr_cpri_presentation_ts_attribute_t portmod_presentation_time_attribute_t;

#define PORTMOD_ENCAP_PRESENTATION_TIME_ADJUST _shrCpriEncapPresentationTsAdjust
#define PORTMOD_ENCAP_PRESENTATION_APPRIOX_INC _shrCpriEncapPresentationApproxInc
#define PORTMOD_ENCAP_PRESENTATION_PTP_TIME_ADJUST _shrCpriEncapPresentationPtpTsAdjust

typedef _shr_cpri_presentation_time_t portmod_presentation_time_t;

/*! 
 * portmod_cpri_port_encap_presentation_time_config_set
 *
 * @brief  Set/Get Encap Presentation time configuration.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  attribute       - Attribute to configure.
 * @param [in]  time            - Time
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_encap_presentation_time_config_set(int unit, int port, portmod_presentation_time_attribute_t attribute, const portmod_presentation_time_t* time);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_encap_presentation_time_config_get
 *
 * @brief  Set/Get Encap Presentation time configuration.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  attribute       - Attribute to configure.
 * @param [out]  time            - Time
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_encap_presentation_time_config_get(int unit, int port, portmod_presentation_time_attribute_t attribute, portmod_presentation_time_t* time);
#endif /* CPRIMOD_SUPPORT */

typedef _shr_cpri_decap_presentation_config_t portmod_decap_presentation_time_config_t;

/*! 
 * portmod_cpri_port_decap_presentation_time_config_set
 *
 * @brief  Set/Get Decap Presentation time configuration.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  config          - Decap Config
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_presentation_time_config_set(int unit, int port, const portmod_decap_presentation_time_config_t* config);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_decap_presentation_time_config_get
 *
 * @brief  Set/Get Decap Presentation time configuration.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  config          - Decap Config
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_presentation_time_config_get(int unit, int port, portmod_decap_presentation_time_config_t* config);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_compression_lookup_table_set
 *
 * @brief  Set/Get Compression Lookup Table.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  table_depth     - Input Table Depth
 * @param [in]  table           - Table array of 1024 entries, 23 bits
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_compression_lookup_table_set(int unit, int port, int table_depth, const uint32* table);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_compression_lookup_table_get
 *
 * @brief  Set/Get Compression Lookup Table.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  max_depth       - Buffer Size. 
 * @param [out]  table_depth     - Num of Table entries populated. 
 * @param [out]  table           - Table array of 1024 entries, 23 bits
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_compression_lookup_table_get(int unit, int port, int max_depth, int* table_depth, uint32* table);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_decompression_lookup_table_set
 *
 * @brief  Set/Get DeCompression Lookup Table.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  table_depth     - Input Table Depth
 * @param [in]  table           - Table array of 256 entries, 14 bits
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decompression_lookup_table_set(int unit, int port, int table_depth, const uint32* table);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_decompression_lookup_table_get
 *
 * @brief  Set/Get DeCompression Lookup Table.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  max_depth       - Buffer Size. 
 * @param [out]  table_depth     - Num of Table entries populated. 
 * @param [out]  table           - Table array of 256 entries, 14 bits
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decompression_lookup_table_get(int unit, int port, int max_depth, int* table_depth, uint32* table);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_decap_queue_flow_control_set
 *
 * @brief  Set/Get control queue flow control.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  queue_num       - Queue Number
 * @param [in]  enable          - Enable . 
 * @param [in]  xon_threshold   - Threshold to turn OFF back-pressure.
 * @param [in]  xoff_threshold   - Threshold to turn ON back-pressure.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_queue_flow_control_set(int unit, int port, uint32 queue_num, int enable, uint32_t xon_threshold, uint32_t xoff_threshold);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_decap_queue_flow_control_get
 *
 * @brief  Set/Get control queue flow control.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  queue_num       - Queue Number
 * @param [out]  enable          - Enable . 
 * @param [out]  xon_threshold   - Threshold to turn OFF back-pressure.
 * @param [out]  xoff_threshold   - Threshold to turn ON back-pressure.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_queue_flow_control_get(int unit, int port, uint32 queue_num, int* enable, uint32_t* xon_threshold, uint32_t* xoff_threshold);
#endif /* CPRIMOD_SUPPORT */

typedef _shr_cpri_fec_ts_source_t portmod_fec_ts_source_t;

#define PORTMOD_CPRI_FEC_TS_SOURCE_66B _shrCpriFecTsSource66b
#define PORTMOD_CPRI_FEC_TS_SOURCE_257B _shrCpriFecTsSource257b

typedef _shr_cpri_fec_aux_config_t portmod_fec_aux_config_para_t;

#define PORTMOD_CPRI_FEC_AUX_CONFIG_SCRAMBLE_BYPASS_TX _shrCpriFecAuxConfigScrambleBypassTx
#define PORTMOD_CPRI_FEC_AUX_CONFIG_DESCRAMBLE_BYPASS_RX _shrCpriFecAuxConfigDescrambleBypassRx
#define PORTMOD_CPRI_FEC_AUX_CONFIG_BYPASS_INDICATION_ENABLE _shrCpriFecAuxConfigBypassIndicationEnable
#define PORTMOD_CPRI_FEC_AUX_CONFIG_BYPASS_CORRECTION_ENABLE _shrCpriFecAuxConfigBypassCorrectionEnable
#define PORTMOD_CPRI_FEC_AUX_CONFIG_CORRUPT_ALTERNATE_BLOCK_ENABLE _shrCpriFecAuxConfigCorruptAlternateBlocksEnable
#define PORTMOD_CPRI_FEC_AUX_CONFIG_SYMBOL_ERROR_CORRUPT_ENABLE _shrCpriFecAuxConfigSymbolErrorCorruptEnable
#define PORTMOD_CPRI_FEC_AUX_CONFIG_SYMBOL_ERROR_TIMER_PERIOD _shrCpriFecAuxConfigSymbolErrorTmrPeriod
#define PORTMOD_CPRI_FEC_AUX_CONFIG_SYMBOL_ERROR_COUNT_THRESHOLD _shrCpriFecAuxConfigSymbolErrCntThreshold
#define PORTMOD_CPRI_FEC_AUX_CONFIG_SYMBOL_ERROR_WINDOW _shrCpriFecAuxConfigSetSymbErrWindow128
#define PORTMOD_CPRI_FEC_AUX_CONFIG_TICK_DENOMINATOR _shrCpriFecAuxConfigGboxTickDenominator
#define PORTMOD_CPRI_FEC_AUX_CONFIG_TICK_NUMERATOR _shrCpriFecAuxConfigGboxTickNumerator
#define PORTMOD_CPRI_FEC_AUX_CONFIG_SOFT_RESET _shrCpriFecAuxConfigSoftReset


/*!
 * @struct portmod_fec_timestamp_config_s
 * @brief  CPRI timestamp with FEC 
 */ 
#ifdef CPRIMOD_SUPPORT
typedef struct portmod_fec_timestamp_config_s {
    int enable; /**< Enable time stamp */
    portmod_fec_ts_source_t fec_fifo_ts_source_select; /**< src for time to fifo */
    portmod_fec_ts_source_t fec_cmic_ts_source_select; /**< src for time to dpll */
    uint32 control_bit_offset_0; /**< Ctrl wd in 1st 66b in 257b. */
    uint32 control_bit_offset_1; /**< Ctrl wd in 2nd 66b in 257b. */
    uint32 control_bit_offset_2; /**< Ctrl wd in 3rd 66b in 257b. */
    uint32 control_bit_offset_3; /**< Ctrl wd in 4th 66b in 257b. */
} portmod_fec_timestamp_config_t;

/* portmod_fec_timestamp_config_t initialization and validation */
int portmod_fec_timestamp_config_t_validate(int unit, const portmod_fec_timestamp_config_t* portmod_fec_timestamp_config);
int portmod_fec_timestamp_config_t_init(int unit, portmod_fec_timestamp_config_t* portmod_fec_timestamp_config);

#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_fec_enable_set
 *
 * @brief  Set/Get FEC enable.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  dir             - TX/RX
 * @param [in]  enable          - Fec enable.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_fec_enable_set(int unit, int port, portmod_direction_t dir, int enable);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_fec_enable_get
 *
 * @brief  Set/Get FEC enable.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  dir             - TX/RX
 * @param [out]  enable          - Fec enable.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_fec_enable_get(int unit, int port, portmod_direction_t dir, int* enable);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_fec_timestamp_config_set
 *
 * @brief  Set/Get Fec timestamp config.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  dir             - TX/RX
 * @param [in]  config          - Fec timestamp config.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_fec_timestamp_config_set(int unit, int port, portmod_direction_t dir, const portmod_fec_timestamp_config_t* config);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_fec_timestamp_config_get
 *
 * @brief  Set/Get Fec timestamp config.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  dir             - TX/RX
 * @param [out]  config          - Fec timestamp config.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_fec_timestamp_config_get(int unit, int port, portmod_direction_t dir, portmod_fec_timestamp_config_t* config);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_fec_aux_config_set
 *
 * @brief  Set/Get Fec Auxiliry config.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  parameter_id    - Auxiliry config type
 * @param [in]  value           - Auxiliry config value.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_fec_aux_config_set(int unit, int port, portmod_fec_aux_config_para_t parameter_id, uint32 value);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_fec_aux_config_get
 *
 * @brief  Set/Get Fec Auxiliry config.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  parameter_id    - Auxiliry config type
 * @param [out]  value           - Auxiliry config value.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_fec_aux_config_get(int unit, int port, portmod_fec_aux_config_para_t parameter_id, uint32* value);
#endif /* CPRIMOD_SUPPORT */

typedef _shr_cpri_fec_stat_type_t portmod_cpri_fec_stat_type_t;

#define PORTMOD_CPRI_FEC_STAT_TYPE_CORRECTED_CODEWORD _shrCpriFecStatTypeCorrectedCodeword
#define PORTMOD_CPRI_FEC_STAT_TYPE_UNCORRECTED_CODEWORD _shrCpriFecStatTypeUncorrectedCodeword
#define PORTMOD_CPRI_FEC_STAT_TYPE_BIT_ERROR _shrCpriFecStatTypeBitError
#define PORTMOD_CPRI_FEC_STAT_TYPE_SYMBOL_ERROR _shrCpriFecStatTypeSymbolError
#define PORTMOD_CPRI_FEC_STAT_TYPE_INVALID _shrCpriFecStatTypeInvalid

/*! 
 * portmod_cpri_port_fec_stat_get
 *
 * @brief   GET FEC Statistics.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  stat_type       - FEC Counter Type
 * @param [out]  value           - Counter Value..
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_fec_stat_get(int unit, int port, portmod_cpri_fec_stat_type_t stat_type, uint32* value);
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
#define PORTMOD_PM_CPRI_ECC_ERR_NONE _shrCpriEccErrTypeNone
#define PORTMOD_PM_CPRI_ECC_ERR_1_BIT _shrCpriEccErrType1Bit
#define PORTMOD_PM_CPRI_ECC_ERR_2_BIT _shrCpriEccErrType2Bit
#define PORTMOD_PM_CPRI_ECC_ERR_MULTI_BIT _shrCpriEccErrTypeMultiBit
#endif /* CPRIMOD_SUPPORT */


/*!
 * @struct portmod_ecc_intr_info_s
 * @brief  ECC error interrupt information report 
 */ 
typedef struct portmod_ecc_intr_info_s {
    int port; /**< port */
    soc_mem_t err_mem_info; /**< ecc error memory */
    soc_reg_t ecc_reg_info; /**< ecc error register */
    int ecc_num_bits_err; /**< num bits ecc error */
    uint32 err_addr; /**< error address */
    char* mem_str; /**< error address */
} portmod_ecc_intr_info_t;

/* portmod_ecc_intr_info_t initialization and validation */
int portmod_ecc_intr_info_t_validate(int unit, const portmod_ecc_intr_info_t* portmod_ecc_intr_info);
int portmod_ecc_intr_info_t_init(int unit, portmod_ecc_intr_info_t* portmod_ecc_intr_info);

#ifdef CPRIMOD_SUPPORT
typedef portmod_ecc_intr_info_t portmod_cpri_ecc_intr_info_t;

#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_ecc_interrupt_enable_set
 *
 * @brief  Enable/Disable ECC interrupts.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - enable/disable ECC interrupts
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_ecc_interrupt_enable_set(int unit, int port, int enable);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_pm_ecc_interrupt_status_get
 *
 * @brief  ECC PM interrupt status and information get.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  pm_id           - port macro id
 * @param [out]  ecc_err_info    - ecc error info
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_pm_ecc_interrupt_status_get(int unit, int pm_id, portmod_cpri_ecc_intr_info_t* ecc_err_info);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_init
 *
 * @brief  Reset cpri port  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_init(int unit, int port);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_rx_gcw_word_get
 *
 * @brief  Get Rx GCW word  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  group_index     - GCW group index
 * @param [out]  gcw_word        - GCW word.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_gcw_word_get(int unit, int port, int group_index, uint16* gcw_word);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_tx_gcw_word_set
 *
 * @brief  Get Tx GCW word  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  group_index     - GCW group index
 * @param [in]  gcw_word        - GCW word.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_gcw_word_set(int unit, int port, int group_index, uint16 gcw_word);
#endif /* CPRIMOD_SUPPORT */

#define PORTMOD_PM_ECC_NO_ERR 0x0
#define PORTMOD_PM_ECC_1B_ERR 0x1
#define PORTMOD_PM_ECC_2B_ERR 0x2
#define PORTMOD_PM_ECC_MULTIB_ERR 0x4

/*! 
 * portmod_pm_interrupt_process
 *
 * @brief Process PM interrupts. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  pm_id           - port macro id
 * @param [out]  ecc_err_info    - ecc error info
 */
int portmod_pm_interrupt_process(int unit, int pm_id, portmod_ecc_intr_info_t* ecc_err_info);



/*!
 * @struct portmod_port_rlm_config_s
 * @brief RLM config 
 */ 
typedef struct portmod_port_rlm_config_s {
    int is_initiator; /**< is initiator */
    uint32 active_lane_bit_map; /**< rlm active bit map */
} portmod_port_rlm_config_t;

/* portmod_port_rlm_config_t initialization and validation */
int portmod_port_rlm_config_t_validate(int unit, const portmod_port_rlm_config_t* portmod_port_rlm_config);
int portmod_port_rlm_config_t_init(int unit, portmod_port_rlm_config_t* portmod_port_rlm_config);

/*! 
 * portmod_port_rlm_config_set
 *
 * @brief RLM config set  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - RLM enable
 * @param [in]  rlm_config      - RLM config set
 */
int portmod_port_rlm_config_set(int unit, int port, int enable, const portmod_port_rlm_config_t* rlm_config);

/*! 
 * portmod_port_rlm_config_get
 *
 * @brief RLM status get  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - RLM enable
 * @param [out]  rlm_status      - RLM config get
 */
int portmod_port_rlm_config_get(int unit, int port, int* enable, portmod_port_rlm_config_t* rlm_status);


/*!
 * @struct portmod_port_rlm_status_s
 * @brief RLM status 
 */ 
typedef struct portmod_port_rlm_status_s {
    int rlm_disabled; /**< rlm is not enabled */
    int rlm_busy; /**< rlm is not enabled */
    int rlm_done; /**< rlm is complete */
    int rlm_failed; /**< rlm failed */
    int rlm_status_count; /**< rlm status count */
} portmod_port_rlm_status_t;

/* portmod_port_rlm_status_t initialization and validation */
int portmod_port_rlm_status_t_validate(int unit, const portmod_port_rlm_status_t* portmod_port_rlm_status);
int portmod_port_rlm_status_t_init(int unit, portmod_port_rlm_status_t* portmod_port_rlm_status);

/*! 
 * portmod_port_rlm_status_get
 *
 * @brief RLM status get  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  rlm_status      - RLM status
 */
int portmod_port_rlm_status_get(int unit, int port, portmod_port_rlm_status_t* rlm_status);


/*!
 * @struct portmod_cpri_rx_tunnel_mode_config_s
 * @brief  CPRI Rx Tunnel  Configuration information. 
 */ 
#ifdef CPRIMOD_SUPPORT
typedef struct portmod_cpri_rx_tunnel_mode_config_s {
    uint32 payload_size; /**< RoE Payload size in bytes.  */
    uint32 pres_mod_count; /**< Presentation Mod Count. */
    portmod_cpri_roe_ordering_info_option_t ordering_info_option; /**< Ordering Info Option. */
} portmod_cpri_rx_tunnel_mode_config_t;

/* portmod_cpri_rx_tunnel_mode_config_t initialization and validation */
int portmod_cpri_rx_tunnel_mode_config_t_validate(int unit, const portmod_cpri_rx_tunnel_mode_config_t* portmod_cpri_rx_tunnel_mode_config);
int portmod_cpri_rx_tunnel_mode_config_t_init(int unit, portmod_cpri_rx_tunnel_mode_config_t* portmod_cpri_rx_tunnel_mode_config);

#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_rx_tunnel_mode_config_set
 *
 * @brief  Setup Rx framer for Tunnel  mode.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - enable
 * @param [in]  config_info     - Tunnel Mode configuration information.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_tunnel_mode_config_set(int unit, int port, int enable, const portmod_cpri_rx_tunnel_mode_config_t* config_info);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_rx_tunnel_mode_config_get
 *
 * @brief  Setup Rx framer for Tunnel  mode.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - enable
 * @param [out]  config_info     - Tunnel Mode configuration information.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_tunnel_mode_config_get(int unit, int port, int* enable, portmod_cpri_rx_tunnel_mode_config_t* config_info);
#endif /* CPRIMOD_SUPPORT */


/*!
 * @struct portmod_cpri_tx_tunnel_mode_config_s
 * @brief  CPRI Rx Tunnel  Configuration information. 
 */ 
#ifdef CPRIMOD_SUPPORT
typedef struct portmod_cpri_tx_tunnel_mode_config_s {
    uint32 payload_size; /**< RoE Payload size in bytes.  */
    uint32 queue_mod_count; /**< Mod Count for Jitter Buffer. */
    uint32 pres_mod_count; /**< Presentation Mod Count. */
    uint32 pres_mod_offset; /**< Presentation   Mod Offset. */
    portmod_cpri_roe_ordering_info_option_t ordering_info_option; /**< Ordering Info Option. */
} portmod_cpri_tx_tunnel_mode_config_t;

/* portmod_cpri_tx_tunnel_mode_config_t initialization and validation */
int portmod_cpri_tx_tunnel_mode_config_t_validate(int unit, const portmod_cpri_tx_tunnel_mode_config_t* portmod_cpri_tx_tunnel_mode_config);
int portmod_cpri_tx_tunnel_mode_config_t_init(int unit, portmod_cpri_tx_tunnel_mode_config_t* portmod_cpri_tx_tunnel_mode_config);

#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_tx_tunnel_mode_config_set
 *
 * @brief  Setup Tx framer for Tunnel  mode.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - enable
 * @param [in]  config_info     - Tunnel Mode configuration information.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_tunnel_mode_config_set(int unit, int port, int enable, const portmod_cpri_tx_tunnel_mode_config_t* config_info);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_tx_tunnel_mode_config_get
 *
 * @brief  Setup Tx framer for Tunnel  mode.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - enable
 * @param [out]  config_info     - Tunnel Mode configuration information.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_tunnel_mode_config_get(int unit, int port, int* enable, portmod_cpri_tx_tunnel_mode_config_t* config_info);
#endif /* CPRIMOD_SUPPORT */


/*!
 * @struct portmod_rsvd4_rx_agnostic_config_s
 * @brief  CPRI Rx RSVD4  Configuration information. 
 */ 
#ifdef CPRIMOD_SUPPORT
typedef struct portmod_rsvd4_rx_agnostic_config_s {
    cprimod_rsvd4_frame_sync_mode_t frame_sync_mode; /**< frame sync mode. */
    uint32 master_frame_offset; /**< Master Frame Offset (bfn_offset) */
    uint32 message_group_number; /**< Message Group Number (rfrm_offset) */
    uint32 payload_multiple; /**< RoE Payload size in multiple of Message Group 1-3.  */
    uint32 pres_mod_count; /**< Presentation Mod Count. */
    portmod_cpri_roe_ordering_info_option_t ordering_info_option; /**< Ordering Info Option. */
} portmod_rsvd4_rx_agnostic_config_t;

/* portmod_rsvd4_rx_agnostic_config_t initialization and validation */
int portmod_rsvd4_rx_agnostic_config_t_validate(int unit, const portmod_rsvd4_rx_agnostic_config_t* portmod_rsvd4_rx_agnostic_config);
int portmod_rsvd4_rx_agnostic_config_t_init(int unit, portmod_rsvd4_rx_agnostic_config_t* portmod_rsvd4_rx_agnostic_config);

#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_rsvd4_port_rx_agnostic_config_set
 *
 * @brief  Setup Rx framer for RSVD4 Agnostic.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - enable
 * @param [in]  config_info     - RSVD4 Agnostic configuration information.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_port_rx_agnostic_config_set(int unit, int port, int enable, const portmod_rsvd4_rx_agnostic_config_t* config_info);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_rsvd4_port_rx_agnostic_config_get
 *
 * @brief  Setup Rx framer for RSVD4 Agnostic.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - enable
 * @param [out]  config_info     - RSVD4 Agnostic  configuration information.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_port_rx_agnostic_config_get(int unit, int port, int* enable, portmod_rsvd4_rx_agnostic_config_t* config_info);
#endif /* CPRIMOD_SUPPORT */


/*!
 * @struct portmod_rsvd4_tx_agnostic_config_s
 * @brief  CPRI Tx RSVD4 Agnstic  Configuration information. 
 */ 
#ifdef CPRIMOD_SUPPORT
typedef struct portmod_rsvd4_tx_agnostic_config_s {
    cprimod_rsvd4_frame_sync_mode_t frame_sync_mode; /**< frame sync mode. */
    uint32 master_frame_offset; /**< Master Frame Offset (bfn_offset) */
    uint32 message_group_number; /**< Message Group Number (rfrm_offset) */
    uint32 payload_multiple; /**< RoE Payload size in Multiple of Message Group 1-3.  */
    uint32 queue_mod_count; /**< Mod Count for Jitter Buffer. */
    uint32 pres_mod_count; /**< Presentation Mod Count. */
    uint32 pres_mod_offset; /**< Presentation   Mod Offset. */
    portmod_cpri_roe_ordering_info_option_t ordering_info_option; /**< Ordering Info Option. */
} portmod_rsvd4_tx_agnostic_config_t;

/* portmod_rsvd4_tx_agnostic_config_t initialization and validation */
int portmod_rsvd4_tx_agnostic_config_t_validate(int unit, const portmod_rsvd4_tx_agnostic_config_t* portmod_rsvd4_tx_agnostic_config);
int portmod_rsvd4_tx_agnostic_config_t_init(int unit, portmod_rsvd4_tx_agnostic_config_t* portmod_rsvd4_tx_agnostic_config);

#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_rsvd4_port_tx_agnostic_config_set
 *
 * @brief  Setup Tx framer for RSVD4 Agnstic.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - enable
 * @param [in]  config_info     - RSVD4 Agnostic  configuration information.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_port_tx_agnostic_config_set(int unit, int port, int enable, const portmod_rsvd4_tx_agnostic_config_t* config_info);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_rsvd4_port_tx_agnostic_config_get
 *
 * @brief  Setup Tx framer for RSVD4 Agnstic.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - enable
 * @param [out]  config_info     - RSVD4 Agnostic  configuration information.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_port_tx_agnostic_config_get(int unit, int port, int* enable, portmod_rsvd4_tx_agnostic_config_t* config_info);
#endif /* CPRIMOD_SUPPORT */

typedef _shr_cpri_ecpri_header_field_t portmod_cpri_ecpri_header_field_t;

#ifdef CPRIMOD_SUPPORT
#define PORTMOD_CPRI_ECPRI_HEADER_FIELD_BYTE_0 _shrCpriEcpriHeaderFieldByte0
#define PORTMOD_CPRI_ECPRI_HEADER_FIELD_BYTE_1 _shrCpriEcpriHeaderFieldByte1
#define PORTMOD_CPRI_ECPRI_HEADER_FIELD_BYTE_2 _shrCpriEcpriHeaderFieldByte2
#define PORTMOD_CPRI_ECPRI_HEADER_FIELD_BYTE_3 _shrCpriEcpriHeaderFieldByte3
#define PORTMOD_CPRI_ECPRI_HEADER_FIELD_BYTE_4 _shrCpriEcpriHeaderFieldByte4
#define PORTMOD_CPRI_ECPRI_HEADER_FIELD_BYTE_5 _shrCpriEcpriHeaderFieldByte5
#define PORTMOD_CPRI_ECPRI_HEADER_FIELD_BYTE_6 _shrCpriEcpriHeaderFieldByte6
#define PORTMOD_CPRI_ECPRI_HEADER_FIELD_BYTE_7 _shrCpriEcpriHeaderFieldByte7
#define PORTMOD_CPRI_ECPRI_HEADER_FIELD_BYTE_8 _shrCpriEcpriHeaderFieldByte8
#define PORTMOD_CPRI_ECPRI_HEADER_FIELD_BYTE_9 _shrCpriEcpriHeaderFieldByte9
#define PORTMOD_CPRI_ECPRI_HEADER_FIELD_BYTE_10 _shrCpriEcpriHeaderFieldByte10
#define PORTMOD_CPRI_ECPRI_HEADER_FIELD_BYTE_11 _shrCpriEcpriHeaderFieldByte11
#define PORTMOD_CPRI_ECPRI_HEADER_FIELD_VLAN_0_BYTE_0 _shrCpriEcpriHeaderFieldVlan0Byte0
#define PORTMOD_CPRI_ECPRI_HEADER_FIELD_VLAN_0_BYTE_1 _shrCpriEcpriHeaderFieldVlan0Byte1
#define PORTMOD_CPRI_ECPRI_HEADER_FIELD_VLAN_1_BYTE_0 _shrCpriEcpriHeaderFieldVlan1Byte0
#define PORTMOD_CPRI_ECPRI_HEADER_FIELD_VLAN_1_BYTE_1 _shrCpriEcpriHeaderFieldVlan1Byte1
#endif /* CPRIMOD_SUPPORT */

typedef _shr_cpri_roe_frame_format_t portmod_cpri_roe_frame_format_t;

#ifdef CPRIMOD_SUPPORT
#define PORTMOD_CPRI_ROE_FRAME_FORMAT_IEEE1914 _shrCpriRoeFrameFormatIEEE1914
#define PORTMOD_CPRI_ROE_FRAME_FORMAT_RSVD3 _shrCpriRoeFrameFormatRsvd3
#define PORTMOD_CPRI_ROE_FRAME_FORMAT_ECPRI8 _shrCpriRoeFrameFormatEcpri8
#define PORTMOD_CPRI_ROE_FRAME_FORMAT_ECPRI12 _shrCpriRoeFrameFormatEcpri12
#endif /* CPRIMOD_SUPPORT */


/*!
 * @struct portmod_cpri_port_frame_config_s
 * @brief  CPRI RoE frame configuration.. 
 */ 
#ifdef CPRIMOD_SUPPORT
typedef struct portmod_cpri_port_frame_config_s {
    portmod_cpri_roe_frame_format_t frame_type; /**< frame sync mode. */
    portmod_cpri_ecpri_header_field_t decap_primary_key; /**< Primary Key */
    portmod_cpri_ecpri_header_field_t decap_secondary_key; /**< Secondary Key */
} portmod_cpri_port_frame_config_t;

/* portmod_cpri_port_frame_config_t initialization and validation */
int portmod_cpri_port_frame_config_t_validate(int unit, const portmod_cpri_port_frame_config_t* portmod_cpri_port_frame_config);
int portmod_cpri_port_frame_config_t_init(int unit, portmod_cpri_port_frame_config_t* portmod_cpri_port_frame_config);

#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_frame_config_set
 *
 * @brief  Set CPRI port RoE frame formation configuration.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  config          - Configuration
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_frame_config_set(int unit, int port, const portmod_cpri_port_frame_config_t* config);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_compression_saturation_config_set
 *
 * @brief  Setting the compression saturation threshold.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  threshold_value   - Threshold Value
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_compression_saturation_config_set(int unit, int port, uint32 threshold_value);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_compression_saturation_config_get
 *
 * @brief  Setting the compression saturation threshold.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  threshold_value   - Threshold Value
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_compression_saturation_config_get(int unit, int port, uint32* threshold_value);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_decompression_saturation_config_set
 *
 * @brief  Setting the decompression saturation value.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  sat_value       - Saturation Value
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decompression_saturation_config_set(int unit, int port, uint32 sat_value);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_decompression_saturation_config_get
 *
 * @brief  Setting the decompression saturation value.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  sat_value       - Saturation Value
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decompression_saturation_config_get(int unit, int port, uint32* sat_value);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_port_mac_enable_set
 *
 * @brief  Enable port MAC settings. This function sets MAC rx enable and soft reset.
                  This should only be invoked during fast reboot,
                  where the application layer do not wait to drain
                  the packets on a port and should not be called
                  during normal operation. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - 
 */
int portmod_port_mac_enable_set(int unit, int port, int enable);

/*! 
 * portmod_port_pcs_fsm_check
 *
 * @brief Check the PCS TX fsm status. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  status          - 0 --  OK, 1 -- error
 */
int portmod_port_pcs_fsm_check(int unit, int port, int* status);

/*! 
 * portmod_port_txpi_rxcdr_clk_get
 *
 * @brief get both tx/rx clocks in Hz. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  txpi_clk        - tx pi clk in Hz
 * @param [out]  rxcdr_clk       - rx cdr clk in Hz
 */
int portmod_port_txpi_rxcdr_clk_get(int unit, int port, uint32* txpi_clk, uint32* rxcdr_clk);


/*!
 * @enum portmod_timestamp_mode_e
 * @brief  PM based EGR 1588 timestamping mode type. 
 */ 
typedef enum portmod_timestamp_mode_e {
    portmodTimestampMode32bit = 0, /**< 32bit timestamping mode for 1588 packets. */
    portmodTimestampMode48bit = 1, /**< 48bit timestamping mode for 1588 packets. */
    portmodTimestampModeCount
} portmod_timestamp_mode_t;

#ifdef PORTMOD_DIAG
extern enum_mapping_t portmod_timestamp_mode_t_mapping[];
#endif /*PORTMOD_DIAG*/

/* portmod_timestamp_mode_t validation */
int portmod_timestamp_mode_t_validate(int unit, portmod_timestamp_mode_t portmod_timestamp_mode);

/*!
 * @struct portmod_egr_1588_timestamp_config_s
 * @brief PM based EGR 1588 timestamp setting. 
 */ 
typedef struct portmod_egr_1588_timestamp_config_s {
    portmod_timestamp_mode_t timestamp_mode; /**< PM EGR 1588 timestamping mode. */
    int cmic_48_overr_en; /**< Set to enable CMIC's 48bit ts timer override value to MAC. */
} portmod_egr_1588_timestamp_config_t;

/* portmod_egr_1588_timestamp_config_t initialization and validation */
int portmod_egr_1588_timestamp_config_t_validate(int unit, const portmod_egr_1588_timestamp_config_t* portmod_egr_1588_timestamp_config);
int portmod_egr_1588_timestamp_config_t_init(int unit, portmod_egr_1588_timestamp_config_t* portmod_egr_1588_timestamp_config);

/*! 
 * portmod_egr_1588_timestamp_config_set
 *
 * @brief Set PM based EGR 1588 timestamping configuration. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  timestamp_config   - PM EGR 1588 timestamping config.
 */
int portmod_egr_1588_timestamp_config_set(int unit, int port, portmod_egr_1588_timestamp_config_t timestamp_config);
/*! 
 * portmod_egr_1588_timestamp_config_get
 *
 * @brief Set PM based EGR 1588 timestamping configuration. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  timestamp_config   - PM EGR 1588 timestamping config.
 */
int portmod_egr_1588_timestamp_config_get(int unit, int port, portmod_egr_1588_timestamp_config_t* timestamp_config);

/*! 
 * portmod_cpri_port_rx_pipeline_clear
 *
 * @brief  Clean up the Rx Framer and Encap Pipeline.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_pipeline_clear(int unit, int port);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_tx_pipeline_clear
 *
 * @brief  Clean up the Tx Framer and Decap Pipeline.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_pipeline_clear(int unit, int port);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_tx_enable_set
 *
 * @brief  Get tx enable status.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - Tx Enable
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_enable_set(int unit, int port, int enable);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_tx_enable_get
 *
 * @brief  Get tx enable status.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - Tx Enable
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_enable_get(int unit, int port, int* enable);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_port_pcs_lane_map_reconfig
 *
 * @brief function for reconfig PCS lane swap.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  tx_lane_swap    - pcs tx lane mapping
 * @param [in]  rx_lane_swap    - pcs rx lane mapping
 */
int portmod_port_pcs_lane_map_reconfig(int unit, int port, uint32 tx_lane_swap, uint32 rx_lane_swap);

/*! 
 * portmod_port_pmd_lock_counter_get
 *
 * @brief  Get the sum of pmd_lock_counters of all the port's lanes  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  pmd_lock_counter_sum   - pmd lock counter sum
 */
int portmod_port_pmd_lock_counter_get(int unit, int port, uint32* pmd_lock_counter_sum);

/*! 
 * portmod_cpri_port_speed_set
 *
 * @brief  Setting the Port Speed.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  speed_id        - Speed Information
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_speed_set(int unit, int port, cprimod_supported_port_speed_t speed_id);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_port_tx_stall_set
 *
 * @brief Control MAC tx stall 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - set MAC tx stall
 */
int portmod_port_tx_stall_set(int unit, int port, int enable);
/*! 
 * portmod_port_tx_stall_get
 *
 * @brief Control MAC tx stall 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - get MAC tx stall
 */
int portmod_port_tx_stall_get(int unit, int port, int* enable);

/*! 
 * portmod_wb_debug_log
 *
 * @brief  Debug logging of warmboot cached information. Needs boot flag BOOT_F_EARLY_DBG to be set.  
             
 *
 * @param [in]  unit            - unit id
 */
int portmod_wb_debug_log(int unit);


/*! 
 * portmod_pms_num_get
 *
 * @brief get pm numbers 
 *
 * @param [in]  unit            - unit id
 * @param [out]  pms_num         - pms in use
 */
int portmod_pms_num_get(int unit, int* pms_num);

typedef phymod_fec_error_mask_t portmod_fec_error_mask_t;

/*! 
 * portmod_port_fec_error_inject_set
 *
 * @brief Control one time fec error injection. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  error_control_map   - lanemap/80-bit block map
 * @param [in]  bit_error_mask   - Bit mask to generate errors
 */
int portmod_port_fec_error_inject_set(int unit, int port, uint16 error_control_map, portmod_fec_error_mask_t bit_error_mask);
/*! 
 * portmod_port_fec_error_inject_get
 *
 * @brief Control one time fec error injection. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  error_control_map   - lanemap/80-bit block map
 * @param [out]  bit_error_mask   - Bit mask to generate errors
 */
int portmod_port_fec_error_inject_get(int unit, int port, uint16* error_control_map, portmod_fec_error_mask_t* bit_error_mask);

typedef _shr_cpri_deubg_attr_t portmod_cpri_debug_attr_t;

#ifdef CPRIMOD_SUPPORT
#define PORTMOD_CPRI_DEBUG_DECAP_QUEUE_STATUS _shrCpriDeubgAttrDecapQueueStatus
#define PORTMOD_CPRI_DEBUG_ENCAP_QUEUE_STATUS _shrCpriDeubgAttrEncapQueueStatus
#define PORTMOD_CPRI_DEBUG_DECAP_QUEUE_COUNTER _shrCpriDeubgAttrDecapQueueCounter
#define PORTMOD_CPRI_DEBUG_ENCAP_QUEUE_COUNTER _shrCpriDeubgAttrEncapQueueCounter
#define PORTMOD_CPRI_DEBUG_DECAP_DROPPED_COUNTER _shrCpriDeubgAttrDecapDroppedCounter
#define PORTMOD_CPRI_DEBUG_COUNT _shrCpriDeubgAttrDecapDroppedCounter
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_debug_set
 *
 * @brief Set/Get CPRI debug attribute. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  type            - CPRI debug attriute
 * @param [in]  index           - Index queue, axc, etc.
 * @param [in]  buffer_size     - buffer size in number of 32 bit words.
 * @param [in]  data            - Data Pointer
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_debug_set(int unit, int port, portmod_cpri_debug_attr_t type, int index, int buffer_size, const uint32* data);
#endif /* CPRIMOD_SUPPORT */
/*! 
 * portmod_cpri_port_debug_get
 *
 * @brief Set/Get CPRI debug attribute. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  type            - CPRI debug attriute
 * @param [in]  index           - Index queue, axc, etc.
 * @param [in]  buffer_size     - buffer size in number of 32 bit words.
 * @param [out]  data            - Data Pointer
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_debug_get(int unit, int port, portmod_cpri_debug_attr_t type, int index, int buffer_size, uint32* data);
#endif /* CPRIMOD_SUPPORT */

/*! 
 * portmod_cpri_port_debug_clear
 *
 * @brief Clear  CPRI debug attribute. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  type            - CPRI debug attriute
 * @param [in]  index           - Index queue, axc, etc.
 */
#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_debug_clear(int unit, int port, portmod_cpri_debug_attr_t type, int index);
#endif /* CPRIMOD_SUPPORT */

#endif /*_PORTMOD_H_*/
