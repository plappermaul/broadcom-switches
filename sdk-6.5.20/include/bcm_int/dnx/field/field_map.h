/**
 * \file bcm_int/dnx/field/field_map.h
 *
 * Field Processor definitions for BCM to DNX qualifier/action translations and fetching DNX params
 *
 * Purpose:
 *     'Field Processor' (FP) Procedures for mapping BCM to DNX qualifiers & actions
 *     Providing info per DNX qualifier/actions
 */
/*
 * 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#ifndef FIELD_FIELD_MAP_H_INCLUDED
/* { */
#define FIELD_FIELD_MAP_H_INCLUDED

#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif
/*
 * Include files
 * {
 */
#include <shared/utilex/utilex_rhlist.h>
#include <bcm_int/dnx/field/field.h>
#include <bcm_int/dnx/field/field_entry.h>
#include <bcm_int/dnx/field/field_presel.h>
#include <bcm_int/dnx/field/field_range.h>
#include <bcm_int/dnx/field/tcam/tcam_handler.h>
#include <include/bcm_int/dnx/lif/in_lif_profile.h>
#include <include/bcm_int/dnx/lif/out_lif_profile.h>
#include <soc/dnx/swstate/auto_generated/types/dnx_field_qualifier_types.h>
#include <soc/dnx/swstate/auto_generated/types/dnx_field_actions_types.h>
#include <soc/dnx/swstate/auto_generated/types/dnx_field_context_types.h>
#include <soc/dnx/swstate/auto_generated/types/dnx_field_group_types.h>
#include <bcm/field.h>
#include <soc/dnx/pp_stage.h>
#include <include/soc/dnx/pemladrv/pemladrv_virtual_wires.h>
/*
 * }
 */

/*
 * Defines
 * {
 */
/**
 * The number of the bit, on output 'offset' (of bcm_field_qualifier_info_get())
 * on which we indicate whether the original qualifier was of class 'META2'.
 * A value of '1' indicates 'META2 offset'.
 */
#define QUAL_OFFSET_META2_BIT                       31
/**
 * Maximum offset value(6b) for DNX_FIELD_INPUT_TYPE_LAYER_RECORDS qualifiers
 */
#define DNX_INPUT_TYPE_MAX_OFFSET_LAYER_RECORDS     63
/**
 * General purpose invalid value.
 */
#define DNX_BCM_ID_INVALID          -1
/**
 * Position of qualifier class inside dnx qualifier
 */
#define DNX_QUAL_CLASS_SHIFT        24
/**
 * Represents actual max size of qualifier class - 8b
 * In spite of the fact that actual type is enum, it will never go beyond 256 values
 */
#define DNX_QUAL_CLASS_MASK         0xFF

/**
 * Position of dnx stage inside dnx qualifier
 */
#define DNX_QUAL_STAGE_SHIFT        16
/**
 * Represents actual max size of dnx stage - 8b
 * In spite of the fact that actual type is enum, it will never go beyond 256 values
 */
#define DNX_QUAL_STAGE_MASK         0xFF
/**
 * Represents actual max size of qualifier id - 16b
 * In spite of the fact that actual underlying type may different per class, it will never go beyond
 */
#define DNX_QUAL_INDEX_MASK         0xFFFF

/**
 * \brief Calculates BCM qualifier from DNX qualifier id for user defined qualifiers, used only internally
 *        in special cases where DNX qual id value is important
 * \param [in] dnx_qual_id - user defined dnx qualifier id
 * \return
 *      bcm_field_qualify_t
 */
#define DNX_USER_ID_TO_BCM(dnx_qual_id) (dnx_qual_id  + dnx_data_field.qual.user_1st_get(unit))

/**
 * \brief Checks if a BCM qualifier is within the range of the user defined qualifiers.
 * \param [in] unit        - Unit ID
 * \param [in] bcm_qual_id - BCM qual ID
 * \return
 *      TRUE  - If bcm_qual_id is within the range of user defined qualifiers.
 *      FALSE - Otherwise.
 */
#define DNX_FIELD_BCM_QUAL_IS_USER(unit, bcm_qual_id)                                                               \
    (((bcm_qual_id >= dnx_data_field.qual.user_1st_get(unit))                                                       \
        && (bcm_qual_id < dnx_data_field.qual.user_1st_get(unit) + dnx_data_field.qual.user_nof_get(unit))))

/**
 * \brief Checks if a BCM action is within the range of the user defined actions.
 * \param [in] unit          - Unit ID
 * \param [in] bcm_action_id - BCM qual ID
 * \return
 *      TRUE  - If bcm_action_id is within the range of user defined actions.
 *      FALSE - Otherwise.
 */
#define DNX_FIELD_BCM_ACTION_IS_USER(unit, bcm_action_id)                                                            \
    (((bcm_action_id >= dnx_data_field.action.user_1st_get(unit))                                                    \
        && (bcm_action_id < dnx_data_field.action.user_1st_get(unit) + dnx_data_field.action.user_nof_get(unit))))

/**
 * \brief Retrieve Qualifier class from dnx qualifier
 * \param [in] dnx_field_qual - Encoded DNX qualifier
 * \return
 *      dnx_field_qual_class_e
 */
#define DNX_QUAL_CLASS(dnx_field_qual)  ((dnx_field_qual >> DNX_QUAL_CLASS_SHIFT) & DNX_QUAL_CLASS_MASK)
/**
 * \brief Retrieve Field Stage from dnx qualifier
 * \param [in] dnx_field_qual - Encoded DNX qualifier
 * \return
 *      dnx_field_stage_e
 */
#define DNX_QUAL_STAGE(dnx_field_qual)  ((dnx_field_qual >> DNX_QUAL_STAGE_SHIFT) & DNX_QUAL_STAGE_MASK)
/**
 * \brief Retrieve Qualifier ID from dnx qualifier
 * \param [in] dnx_field_qual - Encoded DNX qualifier
 * \return
 *      dnx_field_qual_id_t(16 bit)
 * \remark
 *   Meaning of ID is different per CLass
 *   DNX_FIELD_QUAL_CLASS_META(2)       - per stage metadata enum
 *   DNX_FIELD_QUAL_CLASS_LAYER_RECORD  - dnx_field_layer_record_qual_e
 *   DNX_FIELD_QUAL_CLASS_USER          - Id provided by user or generated by algo
 *   DNX_FIELD_QUAL_CLASS_HEADER        - dnx_field_header_qual_e
 *   DNX_FIELD_QUAL_CLASS_SW            - dnx_field_sw_qual_e
 */
#define DNX_QUAL_ID(dnx_field_qual)      (dnx_field_qual & DNX_QUAL_INDEX_MASK)

/**
 * \brief Check if 2 qualifier are the same (Little bit strange FMPOV, but whatever ...)
 * \param [in] dnx_qual1 - Encoded DNX qualifier
 * \param [in] dnx_qual2 - Encoded DNX qualifier
 * \return
 *   \retval TRUE  - if they are the same
 *   \retval FALSE - if they are different
 */
#define DNX_QUAL_IS_SAME(dnx_qual1,dnx_qual2) \
        (dnx_qual1 == dnx_qual2) ||  \
        ((DNX_QUAL_CLASS(dnx_qual1) == DNX_FIELD_QUAL_CLASS_USER) && \
         (DNX_QUAL_CLASS(dnx_qual2) == DNX_FIELD_QUAL_CLASS_USER) && \
         (DNX_QUAL_ID(dnx_qual1) == DNX_QUAL_ID(dnx_qual2)))
/**
 * \brief Verify QUAL CLass
 * \param [in] qual_class - DNX qualifier class encoded in qualifier itself
 * \return
 *   \retval TRUE  - if class is valid one
 *   \retval FALSE - if it is not valid
 */
#define DNX_QUAL_CLASS_VERIFY(qual_class)                                                       \
    if((qual_class < DNX_FIELD_QUAL_CLASS_FIRST) || (qual_class >= DNX_FIELD_QUAL_CLASS_NOF))   \
    {                                                                                           \
        SHR_ERR_EXIT(_SHR_E_PARAM, "Qualifier Class:%d is out of range\n", qual_class);         \
    }

/**
 * MAximum number of dnx actions that may be assigned to one bcm action
 */
#define MAX_DNX_ACTION_PER_BCM      3

/**
 * Position of action class inside dnx qualifier
 */
#define DNX_ACTION_CLASS_SHIFT        24
/**
 * Represents actual max size of action class - 8b
 * In spite of the fact that actual type is enum, it will never go beyond 256 values
 */
#define DNX_ACTION_CLASS_MASK         0xFF

/**
 * Position of field stage inside dnx action
 */
#define DNX_ACTION_STAGE_SHIFT        16
/**
 * Represents actual max size of dnx stage - 8b
 * In spite of the fact that actual type is enum, it will never go beyond 256 values
 */
#define DNX_ACTION_STAGE_MASK         0xFF
/**
 * Represents actual max size of action id - 16b
 * In spite of the fact that actual underlying type may different per class, it will never go beyond
 */
#define DNX_ACTION_INDEX_MASK         0xFFFF

/**
 * \brief Retrieve Qualifier class from dnx action
 * \param [in] dnx_field_action - Encoded DNX action
 * \return
 *      dnx_field_action_class_e
 */
#define DNX_ACTION_CLASS(dnx_field_action)  ((dnx_field_action >> DNX_ACTION_CLASS_SHIFT) & DNX_ACTION_CLASS_MASK)
/**
 * \brief Retrieve Field Stage from dnx action
 * \param [in] dnx_field_action - Encoded DNX action
 * \return
 *      dnx_field_stage_e
 */
#define DNX_ACTION_STAGE(dnx_field_action)  ((dnx_field_action >> DNX_ACTION_STAGE_SHIFT) & DNX_ACTION_STAGE_MASK)
/**
 * \brief Retrieve Action ID from dnx qualifier
 * \param [in] dnx_field_action - Encoded DNX action
 * \return
 *      dnx_field_action_id_t(16 bit)
 * \remark
 *   Meaning of ID is different per CLass
 *   DNX_FIELD_ACTION_CLASS_STATIC  - per stage action enum - action type as unified typedef
 *   DNX_FIELD_ACTION_CLASS_USER    - Id provided by user or generated by algo
 *   DNX_FIELD_ACTION_CLASS_SW      - dnx_field_sw_action_e
 */
#define DNX_ACTION_ID(dnx_field_action)      (dnx_field_action & DNX_QUAL_INDEX_MASK)

/**
 * Invalid DNX qualifier serving as undefined(or initial) value
 */
#define DNX_FIELD_QUAL_TYPE_INVALID  DNX_QUAL(DNX_FIELD_QUAL_CLASS_INVALID, DNX_FIELD_STAGE_INVALID, DNX_FIELD_QUAL_ID_INVALID)

/**
 * The maximum number of virtual wire qualifiers.
 */
#define DNX_FIELD_MAP_MAX_VW_QUAL (100)
/**
 * The maximum number of virtual wire actions.
 */
#define DNX_FIELD_MAP_MAX_VW_ACTION (100)
/**
 * The maximum number of virtual wires that have field actions associated with them.
 */
#define DNX_FIELD_MAP_MAX_VW_WITH_ACTION (100)
/**
 * The maximum number of actions per virtual write.
 * For now every virtual wire uses one mapping only, so we use the maximum actions per mapping.
 */
#define DNX_FIELD_ACTION_MAX_ACTION_PER_VM (DNX_DATA_MAX_FIELD_VIRTUAL_WIRE_ACTIONS_PER_SIGNAL_NOF)

typedef enum
{
    DNX_FIELD_IFWD2_QUAL_INVALID = DNX_FIELD_QUAL_ID_INVALID,
    DNX_FIELD_IFWD2_QUAL_FIRST = DNX_FIELD_QUAL_ID_FIRST,
    /*
     * Starts from MS qualifier - taken from pmfSpec.doc
     */
    DNX_FIELD_IFWD2_QUAL_FWD_LAYER_INDEX = DNX_FIELD_IFWD2_QUAL_FIRST,
    DNX_FIELD_IFWD2_QUAL_RPF_ROUTE_VALID,
    DNX_FIELD_IFWD2_QUAL_FWD1_PRIORITY_DECODER_FWD_PROFILE,
    DNX_FIELD_IFWD2_QUAL_FWD1_PRIORITY_DECODER_FWD_RESULT,
    DNX_FIELD_IFWD2_QUAL_FWD1_PRIORITY_DECODER_RPF_PROFILE,
    DNX_FIELD_IFWD2_QUAL_FWD1_PRIORITY_DECODER_RPF_RESULT,
    DNX_FIELD_IFWD2_QUAL_MP_PROFILE_SEL,
    DNX_FIELD_IFWD2_QUAL_RPF_DEFAULT_ROUTE_FOUND,
    DNX_FIELD_IFWD2_QUAL_ACL_CONTEXT,
    DNX_FIELD_IFWD2_QUAL_CONTEXT,
    DNX_FIELD_IFWD2_QUAL_NASID,
    DNX_FIELD_IFWD2_QUAL_ENABLE_PP_INJECT,
    DNX_FIELD_IFWD2_QUAL_EEI,
    DNX_FIELD_IFWD2_QUAL_EGRESS_LEARN_ENABLE,
    DNX_FIELD_IFWD2_QUAL_FWD_ACTION_CPU_TRAP_CODE,
    DNX_FIELD_IFWD2_QUAL_FWD_ACTION_CPU_TRAP_QUAL,
    DNX_FIELD_IFWD2_QUAL_FWD_ACTION_DESTINATION,
    DNX_FIELD_IFWD2_QUAL_FWD_ACTION_STRENGTH,
    DNX_FIELD_IFWD2_QUAL_FWD_DOMAIN,
    DNX_FIELD_IFWD2_QUAL_FWD_DOMAIN_PROFILE,
    DNX_FIELD_IFWD2_QUAL_FWD_LAYER_ADDITIONAL_INFO,
    DNX_FIELD_IFWD2_QUAL_GENERAL_DATA_0,
    DNX_FIELD_IFWD2_QUAL_GENERAL_DATA_1,
    DNX_FIELD_IFWD2_QUAL_GENERAL_DATA_2,
    DNX_FIELD_IFWD2_QUAL_GENERAL_DATA_3,
    DNX_FIELD_IFWD2_QUAL_IEEE1588_COMMAND,
    DNX_FIELD_IFWD2_QUAL_IEEE1588_COMPENSATE_TIME_STAMP,
    DNX_FIELD_IFWD2_QUAL_IEEE1588_ENCAPSULATION,
    DNX_FIELD_IFWD2_QUAL_IEEE1588_HEADER_OFFSET,
    DNX_FIELD_IFWD2_QUAL_IN_LIF_PROFILE_0,
    DNX_FIELD_IFWD2_QUAL_IN_LIF_PROFILE_1,
    DNX_FIELD_IFWD2_QUAL_GLOB_IN_LIF_0,
    DNX_FIELD_IFWD2_QUAL_GLOB_IN_LIF_1,
    DNX_FIELD_IFWD2_QUAL_PP_PORT,
    DNX_FIELD_IFWD2_QUAL_INCOMING_TAG_STRUCTURE,
    DNX_FIELD_IFWD2_QUAL_INGRESS_LEARN_ENABLE,
    DNX_FIELD_IFWD2_QUAL_LEARN_INFO,
    DNX_FIELD_IFWD2_QUAL_MEM_SOFT_ERR,
    DNX_FIELD_IFWD2_QUAL_NWK_QOS,
    DNX_FIELD_IFWD2_QUAL_OAM_OFFSET,
    DNX_FIELD_IFWD2_QUAL_OAM_STAMP_OFFSET,
    DNX_FIELD_IFWD2_QUAL_OAM_OPCODE,
    DNX_FIELD_IFWD2_QUAL_OAM_YOUR_DISCR,
    DNX_FIELD_IFWD2_QUAL_MY_CFM_MAC,
    DNX_FIELD_IFWD2_QUAL_PACKET_IS_OAM,
    DNX_FIELD_IFWD2_QUAL_PACKET_IS_BFD,
    DNX_FIELD_IFWD2_QUAL_MDL,
    DNX_FIELD_IFWD2_QUAL_VTT_OAM_LIF_0,
    DNX_FIELD_IFWD2_QUAL_VTT_OAM_LIF_0_VALID,
    DNX_FIELD_IFWD2_QUAL_VTT_OAM_LIF_1,
    DNX_FIELD_IFWD2_QUAL_VTT_OAM_LIF_1_VALID,
    DNX_FIELD_IFWD2_QUAL_VTT_OAM_LIF_2,
    DNX_FIELD_IFWD2_QUAL_VTT_OAM_LIF_2_VALID,
    DNX_FIELD_IFWD2_QUAL_VTT_OAM_PCP_0,
    DNX_FIELD_IFWD2_QUAL_VTT_OAM_PCP_1,
    DNX_FIELD_IFWD2_QUAL_VTT_OAM_PCP_2,
    DNX_FIELD_IFWD2_QUAL_GLOB_OUT_LIF_0,
    DNX_FIELD_IFWD2_QUAL_GLOB_OUT_LIF_1,
    DNX_FIELD_IFWD2_QUAL_PRT_QUALIFIER,
    DNX_FIELD_IFWD2_QUAL_PACKET_HEADER_SIZE,
    DNX_FIELD_IFWD2_QUAL_PACKET_IS_APPLET,
    DNX_FIELD_IFWD2_QUAL_PACKET_IS_COMPATIBLE_MC,
    DNX_FIELD_IFWD2_QUAL_PACKET_IS_IEEE1588,
    DNX_FIELD_IFWD2_QUAL_DP,
    DNX_FIELD_IFWD2_QUAL_ECN,
    DNX_FIELD_IFWD2_QUAL_TC,
    DNX_FIELD_IFWD2_QUAL_PTC,
    DNX_FIELD_IFWD2_QUAL_RPF_DST,
    DNX_FIELD_IFWD2_QUAL_RPF_DST_VALID,
    DNX_FIELD_IFWD2_QUAL_SNOOP_CODE,
    DNX_FIELD_IFWD2_QUAL_SNOOP_STRENGTH,
    DNX_FIELD_IFWD2_QUAL_MIRROR_CODE,
    DNX_FIELD_IFWD2_QUAL_STATISTICAL_SAMPLING_CODE,
    DNX_FIELD_IFWD2_QUAL_SRC_SYS_PORT,
    DNX_FIELD_IFWD2_QUAL_FLP_STATISTICS_ID_0,
    DNX_FIELD_IFWD2_QUAL_FLP_STATISTICS_ID_1,
    DNX_FIELD_IFWD2_QUAL_FLP_STATISTICS_ID_2,
    DNX_FIELD_IFWD2_QUAL_FLP_STATISTICS_ID_3,
    DNX_FIELD_IFWD2_QUAL_FLP_STATISTICS_ID_4,
    DNX_FIELD_IFWD2_QUAL_FLP_STATISTICS_ID_5,
    DNX_FIELD_IFWD2_QUAL_FLP_STATISTICS_ATR_0,
    DNX_FIELD_IFWD2_QUAL_FLP_STATISTICS_ATR_1,
    DNX_FIELD_IFWD2_QUAL_FLP_STATISTICS_ATR_2,
    DNX_FIELD_IFWD2_QUAL_FLP_STATISTICS_ATR_3,
    DNX_FIELD_IFWD2_QUAL_FLP_STATISTICS_ATR_4,
    DNX_FIELD_IFWD2_QUAL_FLP_STATISTICS_ATR_5,
    DNX_FIELD_IFWD2_QUAL_VLAN_EDIT_CMD,
    DNX_FIELD_IFWD2_QUAL_TRACE_PACKET,
    DNX_FIELD_IFWD2_QUAL_IN_TTL,
    DNX_FIELD_IFWD2_QUAL_LIF_OAM_TRAP_PROFILE,
    DNX_FIELD_IFWD2_QUAL_VISIBILITY_CLEAR,
    DNX_FIELD_IFWD2_QUAL_VISIBILITY,
    DNX_FIELD_IFWD2_QUAL_RPF_OUT_LIF,
    DNX_FIELD_IFWD2_QUAL_ACTION_PROFILE_SA_DROP_INDEX,
    DNX_FIELD_IFWD2_QUAL_ACTION_PROFILE_SA_NOT_FOUND_INDEX,
    DNX_FIELD_IFWD2_QUAL_ACTION_PROFILE_DA_NOT_FOUND_INDEX,
    DNX_FIELD_IFWD2_QUAL_SAVED_CONTEXT_PROFILE,
    DNX_FIELD_IFWD2_QUAL_IPV4_VERSION_ERROR,
    DNX_FIELD_IFWD2_QUAL_IPV4_CHECKSUM_ERROR,
    DNX_FIELD_IFWD2_QUAL_IPV4_TOTAL_LENGTH_ERROR,
    DNX_FIELD_IFWD2_QUAL_IPV4_OPTIONS_ERROR,
    DNX_FIELD_IFWD2_QUAL_IPV4_SIP_EQUAL_DIP_ERROR,
    DNX_FIELD_IFWD2_QUAL_IPV4_DIP_ZERO_ERROR,
    DNX_FIELD_IFWD2_QUAL_IPV4_SIP_IS_MC_ERROR,
    DNX_FIELD_IFWD2_QUAL_IPV4_HEADER_LENGTH_ERROR,
    DNX_FIELD_IFWD2_QUAL_IN_LIF_UNKNOWN_DA_PROFILE,
    DNX_FIELD_IFWD2_QUAL_NOF_VALID_LM_LIFS,
    DNX_FIELD_IFWD2_QUAL_IS_IN_LIF_VALID_FOR_LM,
    DNX_FIELD_IFWD2_QUAL_FWD1_PRIORITY_DECODER_FWD_STRENGTH,
    DNX_FIELD_IFWD2_QUAL_FWD1_PRIORITY_DECODER_RPF_STRENGTH,
    DNX_FIELD_IFWD2_QUAL_FWD1_PRIORITY_DECODER_FWD_FOUND,
    DNX_FIELD_IFWD2_QUAL_FWD1_PRIORITY_DECODER_RPF_FOUND,
    DNX_FIELD_IFWD2_QUAL_STATISTICS_META_DATA,
    DNX_FIELD_IFWD2_QUAL_FWD_STAT_ATTRIBUTE_OBJ_CMD,
    DNX_FIELD_IFWD2_QUAL_FWD_STAT_ATTRIBUTE_OBJ,
    DNX_FIELD_IFWD2_QUAL_VSI_UNKNOWN_DA_DESTINATION,
    DNX_FIELD_IFWD2_QUAL_ECMP_LB_KEY_0,
    DNX_FIELD_IFWD2_QUAL_ECMP_LB_KEY_1,
    DNX_FIELD_IFWD2_QUAL_ECMP_LB_KEY_2,
    DNX_FIELD_IFWD2_QUAL_LAG_LB_KEY,
    DNX_FIELD_IFWD2_QUAL_NWK_LB_KEY,
    DNX_FIELD_IFWD2_QUAL_CONTEXT_CONSTANTS,
    DNX_FIELD_IFWD2_QUAL_PMF_ETH_RIF_PROFILE,
    DNX_FIELD_IFWD2_QUAL_VRF_VALUE,
    DNX_FIELD_IFWD2_QUAL_UNKNOWN_ADDRESS,
    DNX_FIELD_IFWD2_QUAL_INGRESS_PROTOCOL_TRAP_IN_LIF_PROFILE,
    DNX_FIELD_IFWD2_QUAL_AC_IN_LIF_WIDE_DATA,
    DNX_FIELD_IFWD2_QUAL_VW_VIP_VALID,
    DNX_FIELD_IFWD2_QUAL_VW_VIP_ID,
    DNX_FIELD_IFWD2_QUAL_VW_MEMBER_REFERENCE,
    DNX_FIELD_IFWD2_QUAL_VW_PCC_HIT,
    DNX_FIELD_IFWD2_QUAL_AC_IN_LIF_WIDE_DATA_EXTENDED,
    DNX_FIELD_IFWD2_QUAL_MACT_ENTRY_GROUPING,

    DNX_FIELD_IFWD2_QUAL_NOF
} dnx_field_ifwd2_qual_e;

typedef enum
{
    DNX_FIELD_IPMF1_QUAL_INVALID = DNX_FIELD_QUAL_ID_INVALID,
    DNX_FIELD_IPMF1_QUAL_FIRST = DNX_FIELD_QUAL_ID_FIRST,
    /*
     * Starts from MS qualifier - taken from pmfSpec.doc
     */
    DNX_FIELD_IPMF1_QUAL_ALL_ONES = DNX_FIELD_IPMF1_QUAL_FIRST,
    DNX_FIELD_IPMF1_QUAL_MEM_SOFT_ERR,
    DNX_FIELD_IPMF1_QUAL_ACL_CONTEXT,
    DNX_FIELD_IPMF1_QUAL_NASID,
    DNX_FIELD_IPMF1_QUAL_FWD_CONTEXT,
    DNX_FIELD_IPMF1_QUAL_RPF_OUT_LIF,
    DNX_FIELD_IPMF1_QUAL_RPF_DEFAULT_ROUTE_FOUND,
    DNX_FIELD_IPMF1_QUAL_RPF_ROUTE_VALID,
    DNX_FIELD_IPMF1_QUAL_PACKET_IS_APPLET,
    DNX_FIELD_IPMF1_QUAL_GENERAL_DATA_0,
    DNX_FIELD_IPMF1_QUAL_GENERAL_DATA_1,
    DNX_FIELD_IPMF1_QUAL_GENERAL_DATA_2,
    DNX_FIELD_IPMF1_QUAL_FWD_DOMAIN,
    DNX_FIELD_IPMF1_QUAL_FWD_DOMAIN_PROFILE,
    DNX_FIELD_IPMF1_QUAL_VLAN_EDIT_VID_2,
    DNX_FIELD_IPMF1_QUAL_VLAN_EDIT_VID_1,
    DNX_FIELD_IPMF1_QUAL_VLAN_EDIT_PCP_DEI_2,
    DNX_FIELD_IPMF1_QUAL_VLAN_EDIT_DEI_2,
    DNX_FIELD_IPMF1_QUAL_VLAN_EDIT_PCP_2,
    DNX_FIELD_IPMF1_QUAL_VLAN_EDIT_PCP_DEI_1,
    DNX_FIELD_IPMF1_QUAL_VLAN_EDIT_DEI_1,
    DNX_FIELD_IPMF1_QUAL_VLAN_EDIT_PCP_1,
    DNX_FIELD_IPMF1_QUAL_VLAN_EDIT_CMD_INDEX,
    DNX_FIELD_IPMF1_QUAL_VLAN_EDIT_CMD, /* Data contains VID1(12), VID2(12), PCP_DEI1(4), PCP_DEI2(4), CMD(7) */
    DNX_FIELD_IPMF1_QUAL_SRC_SYS_PORT,
    DNX_FIELD_IPMF1_QUAL_SNOOP_CODE,
    DNX_FIELD_IPMF1_QUAL_SNOOP_STRENGTH,
    DNX_FIELD_IPMF1_QUAL_FWD_LAYER_ADDITIONAL_INFO,
    DNX_FIELD_IPMF1_QUAL_RPF_DST,
    DNX_FIELD_IPMF1_QUAL_RPF_DST_VALID,
    DNX_FIELD_IPMF1_QUAL_PACKET_IS_IEEE1588,
    DNX_FIELD_IPMF1_QUAL_IEEE1588_COMPENSATE_TIME_STAMP,
    DNX_FIELD_IPMF1_QUAL_IEEE1588_COMMAND,
    DNX_FIELD_IPMF1_QUAL_IEEE1588_ENCAPSULATION,
    DNX_FIELD_IPMF1_QUAL_IEEE1588_HEADER_OFFSET,
    DNX_FIELD_IPMF1_QUAL_PACKET_IS_COMPATIBLE_MC,
    DNX_FIELD_IPMF1_QUAL_PRT_QUALIFIER,
    DNX_FIELD_IPMF1_QUAL_PACKET_HEADER_SIZE,
    DNX_FIELD_IPMF1_QUAL_OAM_ID,
    DNX_FIELD_IPMF1_QUAL_OAM_UP_MEP,
    DNX_FIELD_IPMF1_QUAL_OAM_SUB_TYPE,
    DNX_FIELD_IPMF1_QUAL_OAM_OFFSET,
    DNX_FIELD_IPMF1_QUAL_OAM_STAMP_OFFSET,
    DNX_FIELD_IPMF1_QUAL_MIRROR_CODE,
    DNX_FIELD_IPMF1_QUAL_VISIBILITY,
    DNX_FIELD_IPMF1_QUAL_LEARN_INFO,
    DNX_FIELD_IPMF1_QUAL_INGRESS_LEARN_ENABLE,
    DNX_FIELD_IPMF1_QUAL_EGRESS_LEARN_ENABLE,
    DNX_FIELD_IPMF1_QUAL_GLOB_IN_LIF_0,
    DNX_FIELD_IPMF1_QUAL_GLOB_IN_LIF_1,
    DNX_FIELD_IPMF1_QUAL_IN_LIF_PROFILE_0,
    DNX_FIELD_IPMF1_QUAL_IN_LIF_PROFILE_1,
    DNX_FIELD_IPMF1_QUAL_FWD_ACTION_STRENGTH,
    DNX_FIELD_IPMF1_QUAL_FWD_ACTION_DESTINATION,
    DNX_FIELD_IPMF1_QUAL_FWD_ACTION_CPU_TRAP_CODE,
    DNX_FIELD_IPMF1_QUAL_FWD_ACTION_CPU_TRAP_QUAL,
    DNX_FIELD_IPMF1_QUAL_EEI,
    DNX_FIELD_IPMF1_QUAL_ELK_LKP_HIT_7,
    DNX_FIELD_IPMF1_QUAL_ELK_LKP_HIT_6,
    DNX_FIELD_IPMF1_QUAL_ELK_LKP_HIT_5,
    DNX_FIELD_IPMF1_QUAL_ELK_LKP_HIT_4,
    DNX_FIELD_IPMF1_QUAL_ELK_LKP_HIT_3,
    DNX_FIELD_IPMF1_QUAL_ELK_LKP_HIT_2,
    DNX_FIELD_IPMF1_QUAL_ELK_LKP_HIT_1,
    DNX_FIELD_IPMF1_QUAL_ELK_LKP_HIT_0,
    /*
     * Note that DNX_FIELD_IPMF1_QUAL_ELK_LKP_PAYLOAD_ALL_PART_0 and DNX_FIELD_IPMF1_QUAL_ELK_LKP_PAYLOAD_ALL_PART_1
     * do not  represent two different qualifiers, but the 248 bits used for the payload of all six ELK_LKP (KBP)
     * lookups are larger than the maximum size (160) for a qualifier.
     */
    DNX_FIELD_IPMF1_QUAL_ELK_LKP_PAYLOAD_ALL_PART_1,
    DNX_FIELD_IPMF1_QUAL_ELK_LKP_PAYLOAD_ALL_PART_0,
    DNX_FIELD_IPMF1_QUAL_IN_PORT,
    DNX_FIELD_IPMF1_QUAL_PTC,
    DNX_FIELD_IPMF1_QUAL_ECMP_LB_KEY_0,
    DNX_FIELD_IPMF1_QUAL_ECMP_LB_KEY_1,
    DNX_FIELD_IPMF1_QUAL_ECMP_LB_KEY_2,
    DNX_FIELD_IPMF1_QUAL_NWK_LB_KEY,
    DNX_FIELD_IPMF1_QUAL_LAG_LB_KEY,
    DNX_FIELD_IPMF1_QUAL_GLOB_OUT_LIF_0,
    DNX_FIELD_IPMF1_QUAL_GLOB_OUT_LIF_1,
    DNX_FIELD_IPMF1_QUAL_IN_TTL,
    DNX_FIELD_IPMF1_QUAL_BIER_STR_OFFSET,
    DNX_FIELD_IPMF1_QUAL_BIER_STR_SIZE,
    DNX_FIELD_IPMF1_QUAL_PACKET_IS_BIER,
    DNX_FIELD_IPMF1_QUAL_SAVED_CONTEXT_PROFILE,
    DNX_FIELD_IPMF1_QUAL_OAM_METER_DISABLE,
    DNX_FIELD_IPMF1_QUAL_INCOMING_TAG_STRUCTURE,
    DNX_FIELD_IPMF1_QUAL_TC,
    DNX_FIELD_IPMF1_QUAL_DP,
    DNX_FIELD_IPMF1_QUAL_ECN,
    DNX_FIELD_IPMF1_QUAL_NWK_QOS,
    DNX_FIELD_IPMF1_QUAL_TRACE_PACKET,
    DNX_FIELD_IPMF1_QUAL_PACKET_HEADER_SIZE_RANGE,
    DNX_FIELD_IPMF1_QUAL_IN_PORT_KEY_GEN_VAR,
    DNX_FIELD_IPMF1_QUAL_IN_PORT_MAPPED_PP_PORT,
    DNX_FIELD_IPMF1_QUAL_PTC_KEY_GEN_VAR,
    DNX_FIELD_IPMF1_QUAL_VID_VALID,
    DNX_FIELD_IPMF1_QUAL_L4OPS,
    DNX_FIELD_IPMF1_QUAL_STATISTICS_OBJECT10,
    DNX_FIELD_IPMF1_QUAL_CPU_TRAP_CODE_PROFILE,
    DNX_FIELD_IPMF1_QUAL_TM_FLOW_ID,
    DNX_FIELD_IPMF1_QUAL_EXT_STATISTICS_ID_3,
    DNX_FIELD_IPMF1_QUAL_EXT_STATISTICS_ID_2,
    DNX_FIELD_IPMF1_QUAL_EXT_STATISTICS_ID_1,
    DNX_FIELD_IPMF1_QUAL_EXT_STATISTICS_ID_0,
    DNX_FIELD_IPMF1_QUAL_STATISTICS_ID_9,
    DNX_FIELD_IPMF1_QUAL_STATISTICS_ID_8,
    DNX_FIELD_IPMF1_QUAL_STATISTICS_ID_7,
    DNX_FIELD_IPMF1_QUAL_STATISTICS_ID_6,
    DNX_FIELD_IPMF1_QUAL_STATISTICS_ID_5,
    DNX_FIELD_IPMF1_QUAL_STATISTICS_ID_4,
    DNX_FIELD_IPMF1_QUAL_STATISTICS_ID_3,
    DNX_FIELD_IPMF1_QUAL_STATISTICS_ID_2,
    DNX_FIELD_IPMF1_QUAL_STATISTICS_ID_1,
    DNX_FIELD_IPMF1_QUAL_STATISTICS_ID_0,
    DNX_FIELD_IPMF1_QUAL_TM_FLOW_ATR,
    DNX_FIELD_IPMF1_QUAL_EXT_STATISTICS_ATR_3,
    DNX_FIELD_IPMF1_QUAL_EXT_STATISTICS_ATR_2,
    DNX_FIELD_IPMF1_QUAL_EXT_STATISTICS_ATR_1,
    DNX_FIELD_IPMF1_QUAL_EXT_STATISTICS_ATR_0,
    DNX_FIELD_IPMF1_QUAL_STATISTICS_ATR_9,
    DNX_FIELD_IPMF1_QUAL_STATISTICS_ATR_8,
    DNX_FIELD_IPMF1_QUAL_STATISTICS_ATR_7,
    DNX_FIELD_IPMF1_QUAL_STATISTICS_ATR_6,
    DNX_FIELD_IPMF1_QUAL_STATISTICS_ATR_5,
    DNX_FIELD_IPMF1_QUAL_STATISTICS_ATR_4,
    DNX_FIELD_IPMF1_QUAL_STATISTICS_ATR_3,
    DNX_FIELD_IPMF1_QUAL_STATISTICS_ATR_2,
    DNX_FIELD_IPMF1_QUAL_STATISTICS_ATR_1,
    DNX_FIELD_IPMF1_QUAL_STATISTICS_ATR_0,
    DNX_FIELD_IPMF1_QUAL_STATISTICS_META_DATA,
    DNX_FIELD_IPMF1_QUAL_CONTEXT_KEY_GEN_VAR,
    DNX_FIELD_IPMF1_QUAL_EGRESS_PARSING_INDEX,
    DNX_FIELD_IPMF1_QUAL_FWD_LAYER_INDEX,
    DNX_FIELD_IPMF1_QUAL_AC_IN_LIF_WIDE_DATA,
    DNX_FIELD_IPMF1_QUAL_NATIVE_AC_IN_LIF_WIDE_DATA,
    DNX_FIELD_IPMF1_QUAL_PP_PORT_PMF_PROFILE,
    DNX_FIELD_IPMF1_QUAL_TM_PORT_PMF_PROFILE,
    DNX_FIELD_IPMF1_QUAL_PP_PORT_PMF_GENERAL_DATA,
    DNX_FIELD_IPMF1_QUAL_PMF_ETH_RIF_PROFILE,
    DNX_FIELD_IPMF1_QUAL_UNKNOWN_ADDRESS,
    DNX_FIELD_IPMF1_QUAL_L4OPS_ENCODER0,
    DNX_FIELD_IPMF1_QUAL_L4OPS_ENCODER1,
    DNX_FIELD_IPMF1_QUAL_L4OPS_ENCODER2,
    DNX_FIELD_IPMF1_QUAL_L4OPS_ENCODER3,
    DNX_FIELD_IPMF1_QUAL_LEARN_SRC_MAC,
    DNX_FIELD_IPMF1_QUAL_LEARN_VLAN,
    DNX_FIELD_IPMF1_QUAL_LEARN_VSI,
    DNX_FIELD_IPMF1_QUAL_LEARN_DATA,
    DNX_FIELD_IPMF1_QUAL_LEARN_STATION_MOVE,
    DNX_FIELD_IPMF1_QUAL_LEARN_MATCH,
    DNX_FIELD_IPMF1_QUAL_LEARN_FOUND,
    DNX_FIELD_IPMF1_QUAL_LEARN_EXPECTED_WON,
    DNX_FIELD_IPMF1_QUAL_VRF_VALUE,
    DNX_FIELD_IPMF1_QUAL_PP_PORT,
    DNX_FIELD_IPMF1_QUAL_CORE_ID,
    DNX_FIELD_IPMF1_QUAL_VW_VIP_VALID,
    DNX_FIELD_IPMF1_QUAL_VW_VIP_ID,
    DNX_FIELD_IPMF1_QUAL_VW_MEMBER_REFERENCE,
    DNX_FIELD_IPMF1_QUAL_VW_PCC_HIT,
    DNX_FIELD_IPMF1_QUAL_AC_IN_LIF_WIDE_DATA_EXTENDED,
    DNX_FIELD_IPMF1_QUAL_MACT_ENTRY_GROUPING,

    DNX_FIELD_IPMF1_QUAL_NOF
} dnx_field_ipmf1_qual_e;

typedef enum
{
    DNX_FIELD_IPMF2_QUAL_INVALID = DNX_FIELD_QUAL_ID_INVALID,
    DNX_FIELD_IPMF2_QUAL_FIRST = DNX_FIELD_QUAL_ID_FIRST,
    /*
     * Starts from MS qualifier - taken from pmfSpec.doc
     */
    DNX_FIELD_IPMF2_QUAL_PMF1_TCAM_ACTION_0 = DNX_FIELD_IPMF2_QUAL_FIRST,
    DNX_FIELD_IPMF2_QUAL_PMF1_TCAM_ACTION_1,
    DNX_FIELD_IPMF2_QUAL_PMF1_TCAM_ACTION_2,
    DNX_FIELD_IPMF2_QUAL_PMF1_TCAM_ACTION_3,
    DNX_FIELD_IPMF2_QUAL_PMF1_EXEM_ACTION,
    DNX_FIELD_IPMF2_QUAL_PMF1_DIRECT_ACTION,
    DNX_FIELD_IPMF2_QUAL_STATE_ADDRESS,
    DNX_FIELD_IPMF2_QUAL_STATE_DATA,
    DNX_FIELD_IPMF2_QUAL_KEY_F_INITIAL,
    DNX_FIELD_IPMF2_QUAL_KEY_G_INITIAL,
    DNX_FIELD_IPMF2_QUAL_KEY_H_INITIAL,
    DNX_FIELD_IPMF2_QUAL_KEY_I_INITIAL,
    DNX_FIELD_IPMF2_QUAL_KEY_J_INITIAL,
    DNX_FIELD_IPMF2_QUAL_ECMP_LB_KEY_0,
    DNX_FIELD_IPMF2_QUAL_ECMP_LB_KEY_1,
    DNX_FIELD_IPMF2_QUAL_ECMP_LB_KEY_2,
    DNX_FIELD_IPMF2_QUAL_NWK_LB_KEY,
    DNX_FIELD_IPMF2_QUAL_LAG_LB_KEY,
    DNX_FIELD_IPMF2_QUAL_TRJ_HASH,
    DNX_FIELD_IPMF2_QUAL_CMP_KEY_0_DECODED,
    DNX_FIELD_IPMF2_QUAL_CMP_KEY_1_DECODED,
    DNX_FIELD_IPMF2_QUAL_CMP_KEY_TCAM_0_DECODED,
    DNX_FIELD_IPMF2_QUAL_CMP_KEY_TCAM_1_DECODED,
    DNX_FIELD_IPMF2_QUAL_NASID,
    DNX_FIELD_IPMF2_QUAL_STATE_DATA_WRITE,

    DNX_FIELD_IPMF2_QUAL_NOF
} dnx_field_ipmf2_qual_e;

typedef enum
{
    DNX_FIELD_IPMF3_QUAL_INVALID = DNX_FIELD_QUAL_ID_INVALID,
    DNX_FIELD_IPMF3_QUAL_FIRST = DNX_FIELD_QUAL_ID_FIRST,
    /*
     * Starts from MS qualifier - taken from pmBfSpec.doc
     */
    DNX_FIELD_IPMF3_QUAL_ALL_ONES = DNX_FIELD_IPMF3_QUAL_FIRST,
    DNX_FIELD_IPMF3_QUAL_LEARN_INFO,
    DNX_FIELD_IPMF3_QUAL_RPF_ECMP_MODE,
    DNX_FIELD_IPMF3_QUAL_RPF_ECMP_GROUP,
    DNX_FIELD_IPMF3_QUAL_ADMT_PROFILE,
    DNX_FIELD_IPMF3_QUAL_BIER_STR_OFFSET,
    DNX_FIELD_IPMF3_QUAL_BIER_STR_SIZE,
    DNX_FIELD_IPMF3_QUAL_BYTES_TO_REMOVE,
    DNX_FIELD_IPMF3_QUAL_WEAK_TM_VALID,
    DNX_FIELD_IPMF3_QUAL_WEAK_TM_PROFILE,
    DNX_FIELD_IPMF3_QUAL_STAT_OBJ_LM_READ_INDEX,
    DNX_FIELD_IPMF3_QUAL_CONGESTION_INFO,
    DNX_FIELD_IPMF3_QUAL_END_OF_PACKET_EDITING,
    DNX_FIELD_IPMF3_QUAL_EEI,
    DNX_FIELD_IPMF3_QUAL_EGRESS_LEARN_ENABLE,
    DNX_FIELD_IPMF3_QUAL_FWD_ACTION_CPU_TRAP_CODE,
    DNX_FIELD_IPMF3_QUAL_FWD_ACTION_CPU_TRAP_QUAL,
    DNX_FIELD_IPMF3_QUAL_FWD_ACTION_DP_METER_COMMAND,
    DNX_FIELD_IPMF3_QUAL_FWD_ACTION_DP,
    DNX_FIELD_IPMF3_QUAL_FWD_ACTION_TC,
    DNX_FIELD_IPMF3_QUAL_FWD_ACTION_DESTINATION,
    DNX_FIELD_IPMF3_QUAL_FWD_ACTION_STRENGTH,
    DNX_FIELD_IPMF3_QUAL_FWD_PAYLOAD,
    DNX_FIELD_IPMF3_QUAL_FWD_DOMAIN,
    DNX_FIELD_IPMF3_QUAL_FWD_DOMAIN_PROFILE,
    DNX_FIELD_IPMF3_QUAL_GENERAL_DATA_PMF_CONTAINER,
    DNX_FIELD_IPMF3_QUAL_GENERAL_DATA,
    DNX_FIELD_IPMF3_QUAL_IEEE1588_COMMAND,
    DNX_FIELD_IPMF3_QUAL_IEEE1588_COMPENSATE_TIME_STAMP,
    DNX_FIELD_IPMF3_QUAL_IEEE1588_ENCAPSULATION,
    DNX_FIELD_IPMF3_QUAL_IEEE1588_HEADER_OFFSET,
    DNX_FIELD_IPMF3_QUAL_GLOB_IN_LIF_0,
    DNX_FIELD_IPMF3_QUAL_GLOB_IN_LIF_1,
    DNX_FIELD_IPMF3_QUAL_IN_LIF_PROFILE_0,
    DNX_FIELD_IPMF3_QUAL_IN_LIF_PROFILE_1,
    DNX_FIELD_IPMF3_QUAL_IN_PORT,
    DNX_FIELD_IPMF3_QUAL_CORE_ID,
    DNX_FIELD_IPMF3_QUAL_IN_TTL,
    DNX_FIELD_IPMF3_QUAL_INGRESS_LEARN_ENABLE,
    DNX_FIELD_IPMF3_QUAL_ITPP_DELTA,
    DNX_FIELD_IPMF3_QUAL_LAG_LB_KEY,
    DNX_FIELD_IPMF3_QUAL_LATENCY_FLOW_ID_VALID,
    DNX_FIELD_IPMF3_QUAL_LATENCY_FLOW_ID,
    DNX_FIELD_IPMF3_QUAL_MIRROR_CODE,
    DNX_FIELD_IPMF3_QUAL_MIRROR_QUALIFIER,
    DNX_FIELD_IPMF3_QUAL_NWK_LB_KEY,
    DNX_FIELD_IPMF3_QUAL_NWK_QOS,
    DNX_FIELD_IPMF3_QUAL_OAM_ID,
    DNX_FIELD_IPMF3_QUAL_OAM_OFFSET,
    DNX_FIELD_IPMF3_QUAL_OAM_STAMP_OFFSET,
    DNX_FIELD_IPMF3_QUAL_OAM_SUB_TYPE,
    DNX_FIELD_IPMF3_QUAL_OAM_UP_MEP,
    DNX_FIELD_IPMF3_QUAL_GLOB_OUT_LIF_0,
    DNX_FIELD_IPMF3_QUAL_GLOB_OUT_LIF_1,
    DNX_FIELD_IPMF3_QUAL_GLOB_OUT_LIF_2,
    DNX_FIELD_IPMF3_QUAL_GLOB_OUT_LIF_3,
    DNX_FIELD_IPMF3_QUAL_PACKET_IS_APPLET,
    DNX_FIELD_IPMF3_QUAL_NASID,
    DNX_FIELD_IPMF3_QUAL_PACKET_IS_BIER,
    DNX_FIELD_IPMF3_QUAL_PACKET_IS_IEEE1588,
    DNX_FIELD_IPMF3_QUAL_EGRESS_PARSING_INDEX,
    DNX_FIELD_IPMF3_QUAL_PTC,
    DNX_FIELD_IPMF3_QUAL_EXT_STATISTICS_VALID,
    DNX_FIELD_IPMF3_QUAL_PPH_RESERVED,
    DNX_FIELD_IPMF3_QUAL_PPH_TYPE,
    DNX_FIELD_IPMF3_QUAL_RPF_DST,
    DNX_FIELD_IPMF3_QUAL_RPF_DST_VALID,
    DNX_FIELD_IPMF3_QUAL_SNOOP_CODE,
    DNX_FIELD_IPMF3_QUAL_SNOOP_STRENGTH,
    DNX_FIELD_IPMF3_QUAL_SNOOP_QUALIFIER,
    DNX_FIELD_IPMF3_QUAL_SRC_SYS_PORT,
    DNX_FIELD_IPMF3_QUAL_ST_VSQ_PTR,
    DNX_FIELD_IPMF3_QUAL_STATISTICAL_SAMPLING_CODE,
    DNX_FIELD_IPMF3_QUAL_STATISTICAL_SAMPLING_QUALIFIER,
    DNX_FIELD_IPMF3_QUAL_STACKING_ROUTE_HISTORY_BITMAP,
    DNX_FIELD_IPMF3_QUAL_STATISTICS_META_DATA,
    DNX_FIELD_IPMF3_QUAL_STATISTICS_OBJECT10,
    DNX_FIELD_IPMF3_QUAL_SYSTEM_HEADER_PROFILE_INDEX,
    DNX_FIELD_IPMF3_QUAL_TM_PROFILE,
    DNX_FIELD_IPMF3_QUAL_USER_HEADER_1,
    DNX_FIELD_IPMF3_QUAL_USER_HEADER_2,
    DNX_FIELD_IPMF3_QUAL_USER_HEADER_3,
    DNX_FIELD_IPMF3_QUAL_USER_HEADER_4,
    DNX_FIELD_IPMF3_QUAL_USER_HEADER_1_TYPE,
    DNX_FIELD_IPMF3_QUAL_USER_HEADER_2_TYPE,
    DNX_FIELD_IPMF3_QUAL_USER_HEADER_3_TYPE,
    DNX_FIELD_IPMF3_QUAL_USER_HEADER_4_TYPE,
    DNX_FIELD_IPMF3_QUAL_USER_HEADERS_TYPE,
    DNX_FIELD_IPMF3_QUAL_VISIBILITY,
    DNX_FIELD_IPMF3_QUAL_VLAN_EDIT_VID_2,
    DNX_FIELD_IPMF3_QUAL_VLAN_EDIT_VID_1,
    DNX_FIELD_IPMF3_QUAL_VLAN_EDIT_PCP_DEI_2,
    DNX_FIELD_IPMF3_QUAL_VLAN_EDIT_DEI_2,
    DNX_FIELD_IPMF3_QUAL_VLAN_EDIT_PCP_2,
    DNX_FIELD_IPMF3_QUAL_VLAN_EDIT_PCP_DEI_1,
    DNX_FIELD_IPMF3_QUAL_VLAN_EDIT_DEI_1,
    DNX_FIELD_IPMF3_QUAL_VLAN_EDIT_PCP_1,
    DNX_FIELD_IPMF3_QUAL_VLAN_EDIT_CMD_INDEX,
    DNX_FIELD_IPMF3_QUAL_VLAN_EDIT_CMD, /* Data contains VID1(12), VID2(12), PCP_DEI1(4), PCP_DEI2(4), CMD(7) */
    DNX_FIELD_IPMF3_QUAL_FWD_LAYER_ADDITIONAL_INFO,
    DNX_FIELD_IPMF3_QUAL_SLB_LEARN_NEEDED,
    DNX_FIELD_IPMF3_QUAL_SLB_KEY,
    DNX_FIELD_IPMF3_QUAL_SLB_PAYLOAD,
    DNX_FIELD_IPMF3_QUAL_PTC_KEY_GEN_VAR,
    DNX_FIELD_IPMF3_QUAL_IN_PORT_KEY_GEN_VAR,
    DNX_FIELD_IPMF3_QUAL_IN_PORT_MAPPED_PP_PORT,
    DNX_FIELD_IPMF3_QUAL_CONTEXT_KEY_GEN_VAR,
    DNX_FIELD_IPMF3_QUAL_FER_STATISTICS_OBJ,
    DNX_FIELD_IPMF3_QUAL_FWD_LAYER_INDEX,
    DNX_FIELD_IPMF3_QUAL_PP_PORT_PMF_PROFILE,
    DNX_FIELD_IPMF3_QUAL_TM_PORT_PMF_PROFILE,
    DNX_FIELD_IPMF3_QUAL_PP_PORT_PMF_GENERAL_DATA,
    DNX_FIELD_IPMF3_QUAL_PMF_ETH_RIF_PROFILE,
    DNX_FIELD_IPMF3_QUAL_DUAL_QUEUE,
    DNX_FIELD_IPMF3_QUAL_ELEPHANT_TRAP_INFO,
    DNX_FIELD_IPMF3_QUAL_ELEPHANT_LEARN_NEEDED,
    DNX_FIELD_IPMF3_QUAL_PRT_QUALIFIER,
    DNX_FIELD_IPMF3_QUAL_ECL_VALID,
    DNX_FIELD_IPMF3_QUAL_BTK_OFFSET_SOP,
    DNX_FIELD_IPMF3_QUAL_BTC_OFFSET_SOP,
    DNX_FIELD_IPMF3_QUAL_BTC_MINUS_BTK,
    DNX_FIELD_IPMF3_QUAL_LEARN_SRC_MAC,
    DNX_FIELD_IPMF3_QUAL_LEARN_VLAN,
    DNX_FIELD_IPMF3_QUAL_LEARN_VSI,
    DNX_FIELD_IPMF3_QUAL_LEARN_DATA,
    DNX_FIELD_IPMF3_QUAL_LEARN_STATION_MOVE,
    DNX_FIELD_IPMF3_QUAL_LEARN_MATCH,
    DNX_FIELD_IPMF3_QUAL_LEARN_FOUND,
    DNX_FIELD_IPMF3_QUAL_LEARN_EXPECTED_WON,
    DNX_FIELD_IPMF3_QUAL_VRF_VALUE,
    DNX_FIELD_IPMF3_QUAL_PP_PORT,

    DNX_FIELD_IPMF3_QUAL_NOF
} dnx_field_ipmf3_qual_e;

typedef enum
{
    DNX_FIELD_EPMF_QUAL_INVALID = DNX_FIELD_QUAL_ID_INVALID,
    DNX_FIELD_EPMF_QUAL_FIRST = DNX_FIELD_QUAL_ID_FIRST,
    /*
     * Starts from MS qualifier - taken from pmBfSpec.doc
     */
    DNX_FIELD_EPMF_QUAL_FTMH_RESERVED = DNX_FIELD_EPMF_QUAL_FIRST,
    DNX_FIELD_EPMF_QUAL_FTMH_VISIBILITY,
    DNX_FIELD_EPMF_QUAL_FTMH_TM_PROFILE,
    DNX_FIELD_EPMF_QUAL_FTMH_ECN_ENABLE,
    DNX_FIELD_EPMF_QUAL_FTMH_CNI,
    DNX_FIELD_EPMF_QUAL_FTMH_BIER_BFR_EXT_PRESENT,
    DNX_FIELD_EPMF_QUAL_FTMH_FLOW_ID_EXT_PRESENT,
    DNX_FIELD_EPMF_QUAL_FTMH_APPLICATION_SPECIFIC_EXT_PRESENT,
    DNX_FIELD_EPMF_QUAL_FTMH_TM_DESTINATION_EXT_PRESENT,
    DNX_FIELD_EPMF_QUAL_FTMH_MCID_OR_OUTLIF_0_OR_MCDB_PTR,
    DNX_FIELD_EPMF_QUAL_FTMH_TM_ACTION_IS_MC,
    DNX_FIELD_EPMF_QUAL_FTMH_PPH_PRESENT,
    DNX_FIELD_EPMF_QUAL_FTMH_TSH_EXT_PRESENT,
    DNX_FIELD_EPMF_QUAL_FTMH_TM_ACTION_TYPE,
    DNX_FIELD_EPMF_QUAL_FTMH_DP,
    DNX_FIELD_EPMF_QUAL_PP_DSP,
    DNX_FIELD_EPMF_QUAL_FTMH_SRC_SYS_PORT,
    DNX_FIELD_EPMF_QUAL_FTMH_TC,
    DNX_FIELD_EPMF_QUAL_FTMH_PACKET_SIZE,
    DNX_FIELD_EPMF_QUAL_LB_KEY,
    DNX_FIELD_EPMF_QUAL_NWK_KEY,
    DNX_FIELD_EPMF_QUAL_STACKING_EXT,
    DNX_FIELD_EPMF_QUAL_BIER_BFR_EXT,
    DNX_FIELD_EPMF_QUAL_TM_DESTINATION_EXT,
    DNX_FIELD_EPMF_QUAL_APPLICATION_SPECIFIC_EXT,
    DNX_FIELD_EPMF_QUAL_TSH_EXT,
    DNX_FIELD_EPMF_QUAL_FWD_STRENGTH,
    DNX_FIELD_EPMF_QUAL_PPH_PARSING_START_TYPE,
    DNX_FIELD_EPMF_QUAL_PPH_PARSING_START_OFFSET,
    DNX_FIELD_EPMF_QUAL_PPH_LIF_EXT_TYPE,
    DNX_FIELD_EPMF_QUAL_PPH_FHEI_SIZE,
    DNX_FIELD_EPMF_QUAL_PPH_LEARN_EXT_PRESENT,
    DNX_FIELD_EPMF_QUAL_PPH_TTL,
    DNX_FIELD_EPMF_QUAL_PPH_NWK_QOS,
    DNX_FIELD_EPMF_QUAL_PPH_IN_LIF,
    DNX_FIELD_EPMF_QUAL_PPH_FWD_DOMAIN,
    DNX_FIELD_EPMF_QUAL_PPH_IN_LIF_PROFILE,
    DNX_FIELD_EPMF_QUAL_PPH_END_OF_PACKET_EDITING,
    DNX_FIELD_EPMF_QUAL_PPH_FWD_LAYER_ADDITIONAL_INFO,
    DNX_FIELD_EPMF_QUAL_PPH_VALUE1,
    DNX_FIELD_EPMF_QUAL_PPH_VALUE2,
    DNX_FIELD_EPMF_QUAL_FHEI_EXT,
    DNX_FIELD_EPMF_QUAL_LEARN_EXT,
    DNX_FIELD_EPMF_QUAL_LIF_EXT,
    DNX_FIELD_EPMF_QUAL_USER_HEADER_1,
    DNX_FIELD_EPMF_QUAL_USER_HEADER_2,
    DNX_FIELD_EPMF_QUAL_USER_HEADER_3,
    DNX_FIELD_EPMF_QUAL_USER_HEADER_4,
    DNX_FIELD_EPMF_QUAL_USER_HEADER_1_TYPE,
    DNX_FIELD_EPMF_QUAL_USER_HEADER_2_TYPE,
    DNX_FIELD_EPMF_QUAL_USER_HEADER_3_TYPE,
    DNX_FIELD_EPMF_QUAL_USER_HEADER_4_TYPE,
    DNX_FIELD_EPMF_QUAL_IS_TDM,
    DNX_FIELD_EPMF_QUAL_CUD_OUTLIF_OR_MCDB_PTR,
    DNX_FIELD_EPMF_QUAL_DISCARD,
    DNX_FIELD_EPMF_QUAL_OUT_LIF_PROFILE,
    DNX_FIELD_EPMF_QUAL_PMF_ETH_RIF_PROFILE,
    DNX_FIELD_EPMF_QUAL_ETH_TAG_FORMAT,
    DNX_FIELD_EPMF_QUAL_UPDATED_TPIDS_PACKET_DATA,
    DNX_FIELD_EPMF_QUAL_IVE_BYTES_TO_ADD,
    DNX_FIELD_EPMF_QUAL_IVE_BYTES_TO_REMOVE,
    DNX_FIELD_EPMF_QUAL_ETHER_TYPE_CODE,
    DNX_FIELD_EPMF_QUAL_FABRIC_OR_EGRESS_MC,
    DNX_FIELD_EPMF_QUAL_ESTIMATED_BTR,
    DNX_FIELD_EPMF_QUAL_FWD_CONTEXT,
    DNX_FIELD_EPMF_QUAL_GLOB_OUT_LIF_0,
    DNX_FIELD_EPMF_QUAL_GLOB_OUT_LIF_1,
    DNX_FIELD_EPMF_QUAL_GLOB_OUT_LIF_2,
    DNX_FIELD_EPMF_QUAL_GLOB_OUT_LIF_3,
    DNX_FIELD_EPMF_QUAL_GLOB_IN_LIF_0,
    DNX_FIELD_EPMF_QUAL_IN_LIF_PROFILE_0,
    DNX_FIELD_EPMF_QUAL_IP_MC_ELIGIBLE,
    DNX_FIELD_EPMF_QUAL_IP_MC_SHOULD_BE_BRIDGED,
    DNX_FIELD_EPMF_QUAL_LEARN_VALID,
    DNX_FIELD_EPMF_QUAL_LOCAL_OUT_LIF,
    DNX_FIELD_EPMF_QUAL_FWD_ACTION_PROFILE_INDEX,
    DNX_FIELD_EPMF_QUAL_SNOOP_ACTION_PROFILE_INDEX,
    DNX_FIELD_EPMF_QUAL_SNOOP_STRENGTH,
    DNX_FIELD_EPMF_QUAL_SYSTEM_HEADERS_SIZE,
    DNX_FIELD_EPMF_QUAL_DST_SYS_PORT,
    DNX_FIELD_EPMF_QUAL_OUT_TM_PORT,
    DNX_FIELD_EPMF_QUAL_OUT_PP_PORT,
    DNX_FIELD_EPMF_QUAL_PACKET_IS_APPLET,
    DNX_FIELD_EPMF_QUAL_MEM_SOFT_ERR,
    DNX_FIELD_EPMF_QUAL_TC_MAP_PROFILE,
    DNX_FIELD_EPMF_QUAL_L4_PORT_IN_RANGE,
    DNX_FIELD_EPMF_QUAL_PROGRAM_INDEX,
    DNX_FIELD_EPMF_QUAL_PER_PORT_TABLE_DATA,
    DNX_FIELD_EPMF_QUAL_PP_PORT_PMF_PROFILE,
    DNX_FIELD_EPMF_QUAL_TM_PORT_PMF_PROFILE,
    DNX_FIELD_EPMF_QUAL_PPH_VRF_VALUE,
    DNX_FIELD_EPMF_QUAL_LEARN_EXT_DATA,
    DNX_FIELD_EPMF_QUAL_LEARN_EXT_SRC_MAC,
    DNX_FIELD_EPMF_QUAL_LEARN_EXT_VSI,
    DNX_FIELD_EPMF_QUAL_LEARN_EXT_VLAN,

    DNX_FIELD_EPMF_QUAL_NOF
} dnx_field_epmf_qual_e;

typedef enum
{
    DNX_FIELD_L4OPS_QUAL_INVALID = DNX_FIELD_QUAL_ID_INVALID,
    DNX_FIELD_L4OPS_QUAL_FIRST = DNX_FIELD_QUAL_ID_FIRST,
    /*
     * Starts from MS qualifier - taken from pmfSpec.doc
     */
    DNX_FIELD_L4OPS_QUAL_DP = DNX_FIELD_L4OPS_QUAL_FIRST,
    DNX_FIELD_L4OPS_QUAL_ECN,
    DNX_FIELD_L4OPS_QUAL_EEI,
    DNX_FIELD_L4OPS_QUAL_ELK_LKP_HIT_0,
    DNX_FIELD_L4OPS_QUAL_ELK_LKP_HIT_1,
    DNX_FIELD_L4OPS_QUAL_ELK_LKP_HIT_2,
    DNX_FIELD_L4OPS_QUAL_ELK_LKP_HIT_3,
    DNX_FIELD_L4OPS_QUAL_ELK_LKP_HIT_4,
    DNX_FIELD_L4OPS_QUAL_ELK_LKP_HIT_5,
    DNX_FIELD_L4OPS_QUAL_ELK_LKP_HIT_6,
    DNX_FIELD_L4OPS_QUAL_ELK_LKP_HIT_7,
    DNX_FIELD_L4OPS_QUAL_ELK_LKP_PAYLOAD_ALL_PART_1,
    DNX_FIELD_L4OPS_QUAL_ELK_LKP_PAYLOAD_ALL_PART_0,
    DNX_FIELD_L4OPS_QUAL_FWD_DOMAIN,
    DNX_FIELD_L4OPS_QUAL_FWD_LAYER_ADDITIONAL_INFO,
    DNX_FIELD_L4OPS_QUAL_GENERAL_DATA_2,
    DNX_FIELD_L4OPS_QUAL_GENERAL_DATA_1,
    DNX_FIELD_L4OPS_QUAL_GENERAL_DATA_0,
    DNX_FIELD_L4OPS_QUAL_GLOB_IN_LIF_1,
    DNX_FIELD_L4OPS_QUAL_GLOB_IN_LIF_0,
    DNX_FIELD_L4OPS_QUAL_NWK_QOS,
    DNX_FIELD_L4OPS_QUAL_GLOB_OUT_LIF_1,
    DNX_FIELD_L4OPS_QUAL_GLOB_OUT_LIF_0,
    DNX_FIELD_L4OPS_QUAL_PRT_QUALIFIER,
    DNX_FIELD_L4OPS_QUAL_RPF_DST,
    DNX_FIELD_L4OPS_QUAL_RPF_DST_VALID,
    DNX_FIELD_L4OPS_QUAL_RPF_OUT_LIF,
    DNX_FIELD_L4OPS_QUAL_SRC_SYS_PORT,
    DNX_FIELD_L4OPS_QUAL_STATISTICS_OBJ_12,
    DNX_FIELD_L4OPS_QUAL_STATISTICS_OBJ_11,
    DNX_FIELD_L4OPS_QUAL_STATISTICS_OBJ_10,
    DNX_FIELD_L4OPS_QUAL_STATISTICS_OBJ_9,
    DNX_FIELD_L4OPS_QUAL_STATISTICS_OBJ_8,
    DNX_FIELD_L4OPS_QUAL_STATISTICS_OBJ_7,
    DNX_FIELD_L4OPS_QUAL_STATISTICS_OBJ_6,
    DNX_FIELD_L4OPS_QUAL_STATISTICS_OBJ_5,
    DNX_FIELD_L4OPS_QUAL_STATISTICS_OBJ_4,
    DNX_FIELD_L4OPS_QUAL_STATISTICS_OBJ_3,
    DNX_FIELD_L4OPS_QUAL_STATISTICS_OBJ_2,
    DNX_FIELD_L4OPS_QUAL_STATISTICS_OBJ_1,
    DNX_FIELD_L4OPS_QUAL_STATISTICS_OBJ_0,
    DNX_FIELD_L4OPS_QUAL_OAM_STATISTICS_OBJ_2,
    DNX_FIELD_L4OPS_QUAL_OAM_STATISTICS_OBJ_1,
    DNX_FIELD_L4OPS_QUAL_OAM_STATISTICS_OBJ_0,
    DNX_FIELD_L4OPS_QUAL_TC,
    DNX_FIELD_L4OPS_QUAL_CORE_ID,
    DNX_FIELD_L4OPS_QUAL_IN_PORT,
    DNX_FIELD_L4OPS_QUAL_FWD_LAYER_INDEX,

    DNX_FIELD_L4OPS_QUAL_NOF
} dnx_field_l4ops_qual_e;

#define BCM_FIELD_HEADER_TYPE_STRINGS   \
{                                       \
    "Ethernet",                         \
    "Inner Ethernet",                   \
    "VALN",                             \
    "MPLS",                             \
    "IPv4",                             \
    "Inner IPv4",                       \
    "IPv6",                             \
    "Inner IPv6",                       \
    "UDP",                              \
    "Invalid"                           \
}

typedef enum
{
    DNX_FIELD_HEADER_QUAL_INVALID = 0,
    DNX_FIELD_HEADER_QUAL_FIRST = 1,
    /*
     * Ethernet Header Qualifiers
     */
    DNX_FIELD_HEADER_QUAL_MAC_DST = DNX_FIELD_HEADER_QUAL_FIRST,
    DNX_FIELD_HEADER_QUAL_MAC_SRC,
    DNX_FIELD_HEADER_QUAL_ETHERTYPE,
    /*
     * VLAN Header Qualifiers
     */
    DNX_FIELD_HEADER_QUAL_VLAN_TPID,
    DNX_FIELD_HEADER_QUAL_VLAN_ID,
    DNX_FIELD_HEADER_QUAL_VLAN_PRI,
    DNX_FIELD_HEADER_QUAL_VLAN_CFI,
    DNX_FIELD_HEADER_QUAL_VLAN_PRI_CFI,
    DNX_FIELD_HEADER_QUAL_VLAN_TCI,
    /*
     * MPLS Header Qualifiers
     */
    DNX_FIELD_HEADER_QUAL_MPLS_LABEL,   /* Shim Layer header */
    DNX_FIELD_HEADER_QUAL_MPLS_LABEL_ID,
    DNX_FIELD_HEADER_QUAL_MPLS_TC,
    DNX_FIELD_HEADER_QUAL_MPLS_BOS,
    DNX_FIELD_HEADER_QUAL_MPLS_TTL,
    /*
     * ARP Header Qualifiers
     */
    DNX_FIELD_HEADER_QUAL_ARP_OPCODE,
    DNX_FIELD_HEADER_QUAL_ARP_SENDER_IP,
    DNX_FIELD_HEADER_QUAL_ARP_TARGET_IP,
    /*
     * IPv4 Header Qualifiers
     */
    DNX_FIELD_HEADER_QUAL_IPV4_TOS,
    DNX_FIELD_HEADER_QUAL_IPV4_DSCP,
    DNX_FIELD_HEADER_QUAL_IPV4_ECN,
    DNX_FIELD_HEADER_QUAL_IPV4_FLAGS,
    DNX_FIELD_HEADER_QUAL_IPV4_TTL,
    DNX_FIELD_HEADER_QUAL_IPV4_PROTOCOL,
    DNX_FIELD_HEADER_QUAL_IPV4_SRC,
    DNX_FIELD_HEADER_QUAL_IPV4_DST,
    /*
     * IPv6 Header Qualifiers
     */
    DNX_FIELD_HEADER_QUAL_IPV6_SIP,
    DNX_FIELD_HEADER_QUAL_IPV6_DIP,
    DNX_FIELD_HEADER_QUAL_IPV6_SIP_LOW,
    DNX_FIELD_HEADER_QUAL_IPV6_SIP_HIGH,
    DNX_FIELD_HEADER_QUAL_IPV6_DIP_LOW,
    DNX_FIELD_HEADER_QUAL_IPV6_DIP_HIGH,
    DNX_FIELD_HEADER_QUAL_IPV6_TC,
    DNX_FIELD_HEADER_QUAL_IPV6_FLOW_LABEL,
    DNX_FIELD_HEADER_QUAL_IPV6_NEXT_HEADER,
    DNX_FIELD_HEADER_QUAL_IPV6_HOP_LIMIT,
    DNX_FIELD_HEADER_QUAL_IPV6_EXTENSION_HEADER_TYPE,
    /*
     * TCP/UDP Common Fields
     */
    DNX_FIELD_HEADER_QUAL_L4_SRC_PORT,
    DNX_FIELD_HEADER_QUAL_L4_DST_PORT,
    /*
     * TCP Requested Fields
     */
    DNX_FIELD_HEADER_QUAL_TCP_CTL,
    /*
     *  Number of types in dnx_field_header_qual_e
     */
    DNX_FIELD_HEADER_QUAL_NOF
} dnx_field_header_qual_e;

typedef enum
{
    DNX_FIELD_LR_QUAL_INVALID = 0,
    DNX_FIELD_LR_QUAL_FIRST = 1,
    /*
     * Basic Layer Header Qualifiers
     */
    DNX_FIELD_LR_QUAL_OFFSET = DNX_FIELD_LR_QUAL_FIRST,
    DNX_FIELD_LR_QUAL_PROTOCOL,
    DNX_FIELD_LR_QUAL_QUALIFIER,
    /*
     * Specific fields in relevant Layer Record Qualifiers
     */
    DNX_FIELD_LR_QUAL_ETH_IS_DA_MC,
    DNX_FIELD_LR_QUAL_ETH_IS_DA_BC,
    DNX_FIELD_LR_QUAL_ETH_1ST_TPID_EXIST,
    DNX_FIELD_LR_QUAL_ETH_1ST_TPID_INDEX,
    DNX_FIELD_LR_QUAL_ETH_2ND_TPID_EXIST,
    DNX_FIELD_LR_QUAL_ETH_2ND_TPID_INDEX,
    DNX_FIELD_LR_QUAL_ETH_3RD_TPID_EXIST,
    DNX_FIELD_LR_QUAL_ETH_3RD_TPID_INDEX,
    DNX_FIELD_LR_QUAL_ETH_IS_ETH1,
    DNX_FIELD_LR_QUAL_IPV4_IS_MC,
    DNX_FIELD_LR_QUAL_IPV4_HAS_OPTION,
    DNX_FIELD_LR_QUAL_IPV4_IS_FRAGMENTED,
    DNX_FIELD_LR_QUAL_IPV4_IS_1ST_FRAGMENT,
    DNX_FIELD_LR_QUAL_IPV4_1ST_ADD_HEADER_EXIST,
    DNX_FIELD_LR_QUAL_IPV4_1ST_ADD_HEADER,
    DNX_FIELD_LR_QUAL_IPV4_2ND_ADD_HEADER_EXISTS,
    DNX_FIELD_LR_QUAL_IPV4_TUNNEL_TYPE,
    DNX_FIELD_LR_QUAL_IPV4_TUNNEL_TYPE_RAW,
    DNX_FIELD_LR_QUAL_IPV6_IS_MC,
    DNX_FIELD_LR_QUAL_IPV6_1ST_ADD_HEADER_EXIST,
    DNX_FIELD_LR_QUAL_IPV6_1ST_ADD_HEADER,
    DNX_FIELD_LR_QUAL_IPV6_2ND_ADD_HEADER_EXISTS,
    DNX_FIELD_LR_QUAL_IPV6_2ND_ADD_HEADER,
    DNX_FIELD_LR_QUAL_IPV6_3RD_ADD_HEADER_EXISTS,
    DNX_FIELD_LR_QUAL_IPV6_FRAGMENTED_NON_FIRST,
    DNX_FIELD_LR_QUAL_SRV6_EP_SEGMENT_LEFT_MINUS_ONE,
    DNX_FIELD_LR_QUAL_MPLS_NOF_LABELS,
    DNX_FIELD_LR_QUAL_BIER_BITSTRINGLENGTH,
    DNX_FIELD_LR_QUAL_FCOE_IS_FIP,
    DNX_FIELD_LR_QUAL_FCOE_IS_ENCAP,
    DNX_FIELD_LR_QUAL_FCOE_VFT_EXIST,
    DNX_FIELD_LR_QUAL_ITMH_PPH_TYPE,
/*
     *  Number of types in dnx_field_layer_record_qual_e
     */
    DNX_FIELD_LR_QUAL_NOF
} dnx_field_layer_record_qual_e;

typedef enum
{
    DNX_FIELD_SW_QUAL_INVALID = 0,
    DNX_FIELD_SW_QUAL_FIRST = 1,
    DNX_FIELD_SW_QUAL_ALL_ZERO = DNX_FIELD_SW_QUAL_FIRST,
    /*
     *  Number of types in dnx_field_sw_qual_e
     */
    DNX_FIELD_SW_QUAL_NOF
} dnx_field_sw_qual_e;

typedef enum
{
    DNX_FIELD_SW_ACTION_INVALID = 0,
    DNX_FIELD_SW_ACTION_FIRST = 1,
    DNX_FIELD_SW_ACTION_VOID = DNX_FIELD_SW_ACTION_FIRST,
    /*
     *  Number of types in dnx_field_sw_action_e
     */
    DNX_FIELD_SW_ACTION_NOF
} dnx_field_sw_action_e;

/**
 * Enum for FFC types, one of the four HW options for each FFC. not every FFC type is available to all FFCs.
 */
typedef enum
{
    DNX_FIELD_FFC_TYPE_INVALID = -1,
    /**
     * Takes information from the header according to a layer relative to the forwarding layer.
     */
    DNX_FIELD_FFC_RELATIVE_HEADER = 0,
    /**
     * Takes information from the header according to a given layer (disregarding the forwarding layer)
     */
    DNX_FIELD_FFC_ABSOLUTE_HEADER = 1,
    /**
     * Takes information from a given offset anywhere in the PBUS. Used to take data from the metadata or
     * layer records, when we don't take which layer is the forwarding layer into account.
     */
    DNX_FIELD_FFC_LITERALLY = 2,
    /**
     * Takes information from the layer record, which is information given by the parser about different layers in the
     * header, from a layer relative to the forwarding layer.
     */
    DNX_FIELD_FFC_LAYER_RECORD = 3,
    /**
     * Number of enum valid values for FFC types */
    DNX_FIELD_FFC_NOF
} dnx_field_ffc_type_e;

#define DNX_FIELD_FFC_TYPE_VERIFY(type)                                                 \
    if((type < 0) || (type >= DNX_FIELD_FFC_NOF))                                       \
    {                                                                                   \
        SHR_ERR_EXIT(_SHR_E_PARAM, "FFC type:%d is out of range\n", type);              \
    }

typedef struct
{
    dbal_fields_e field_id;
    uint32 value;
} dnx_field_dbal_pair_t;

/**
 * \brief - Structure provided to facilitate context parameter setting
 */
typedef struct
{
    dbal_tables_e table_id;
    dnx_field_dbal_pair_t key_dbal_pair[DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_DBAL_PAIRS];
    dnx_field_dbal_pair_t res_dbal_pair[DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_DBAL_PAIRS];
} dnx_field_dbal_entry_t;

/**
 * \brief - Structure provided to facilitate field range setting
 */
typedef struct
{
    dbal_tables_e table_id;
    dbal_fields_e range_id_dbal_field;
    dbal_fields_e range_min_dbal_field;
    dbal_fields_e range_max_dbal_field;
    uint8 id_not_bitmap;
} dnx_field_map_range_type_info_t;

struct dnx_field_context_param_e;
/**
 * \brief Typedef for context param conversion routine
 * \param [in] unit unit id
 * \param [in] bcm_data pointer to bcm param data, which is BCM_FIELD_QUAL_WIDTH_IN_WORDS long
 * \param [in] dnx_data pointer to dnx param data, which is BCM_FIELD_QUAL_WIDTH_IN_WORDS long
 * \return
 *     \retval _SHR_E_NONE for success
 *     \retval _SHR_E_PARAM problem with input parameters, usage should be printed
 *     \retval other errors for other failure type
 * \remark automatically frees the list
 */
typedef shr_error_e(
    *context_param_conversion_cb) (
    int unit,
    dnx_field_stage_e stage,
    dnx_field_context_t field_context_id,
    uint32 param_value,
    struct dnx_field_context_param_e * context_param,
    dnx_field_dbal_entry_t * field_dbal_entry);

/**
 * \brief - Static mapping for context param set
 */
typedef struct dnx_field_context_param_e
{
    dbal_tables_e table_id;
    dbal_fields_e key_field_id[DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_DBAL_PAIRS];
    dbal_fields_e res_field_id[DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_DBAL_PAIRS];
    context_param_conversion_cb conversion_cb;
} dnx_field_context_param_t;

/**
 * \brief - Static mapping for range set
 */
typedef struct dnx_field_range_map_e
{
    /** The name of the range type.*/
    char *name;
    /** The DBAL table for setting the range.*/
    dbal_tables_e table_id;
    /** The DBAL field of the range ID.*/
    dbal_fields_e range_id_dbal_field;
    /** The DBAL field of the minimum value of the range.*/
    dbal_fields_e range_min_dbal_field;
    /** The DBAL field of the maximum value of the range.*/
    dbal_fields_e range_max_dbal_field;
    /** Indicates if the HW provides the first ID that was hit, or a bitmap of the range IDs and whether they were hit.*/
    uint8 id_not_bitmap;
} dnx_field_range_map_t;

/**
 * \brief Typedef for qualifier/action value conversion routine
 * \par DIRECT INPUT:
 *     \param [in] unit unit id
 *     \param [in] flags
 *           First flag is marking bare metal support
 *     \param [in] core - Identifier of core.
 *     \param [in] bcm_data pointer to bcm qualifier/action value, which is BCM_FIELD_QUAL_WIDTH_IN_WORDS long
 *     \param [in] dnx_data pointer to dnx qualifier/action value, which is BCM_FIELD_QUAL_WIDTH_IN_WORDS long
 * \par DIRECT OUTPUT:
 *     \retval _SHR_E_NONE for success
 *     \retval _SHR_E_PARAM problem with input parameters, usage should be printed
 *     \retval other errors for other failure type
 * \remark automatically frees the list
 */
typedef shr_error_e(
    *field_data_conversion_cb) (
    int unit,
    uint32 flags,
    int core,
    uint32 *bcm_data,
    uint32 *dnx_data);

/**
 * \brief Typedef for CS qualifier type conversion routine from BCM to DNX.
 * \par DIRECT INPUT:
 *     \param [in] unit           unit id
 *     \param [in] cs_qual_index  The index given by the user for the CS qualifier.
 *     \param [in] context_id     The context ID that uses the qualifier.
 *     \param [in] bcm_qual       The BCM qualifier.
 *     \param [out] cs_dnx_qual_p The DBAL field representing the DNX qualifier.
 * \par DIRECT OUTPUT:
 *     \retval _SHR_E_NONE for success
 *     \retval _SHR_E_PARAM problem with input parameters, usage should be printed
 *     \retval other errors for other failure type
 */
typedef shr_error_e(
    *cs_qual_type_bcm_to_dnx_conversion_cb) (
    int unit,
    uint32 cs_qual_index,
    dnx_field_context_t context_id,
    bcm_field_qualify_t bcm_qual,
    dbal_fields_e * cs_dnx_qual_p);

/**
 * \brief Typedef for CS qualifier type conversion routine from DNX to BCM.
 * \par DIRECT INPUT:
 *     \param [in] unit             unit id
 *     \param [in] context_id       The context ID that uses the qualifier.
 *     \param [in] cs_dnx_qual      The DBAL field representing the DNX qualifier.
 *     \param [out] bcm_qual_p      The BCM qualifier.
 *     \param [out] cs_qual_index_p The index given by the user for the CS qualifier.
 * \par DIRECT OUTPUT:
 *     \retval _SHR_E_NONE for success
 *     \retval _SHR_E_PARAM problem with input parameters, usage should be printed
 *     \retval other errors for other failure type
 */
typedef shr_error_e(
    *cs_qual_type_dnx_to_bcm_conversion_cb) (
    int unit,
    dnx_field_context_t context_id,
    dbal_fields_e cs_dnx_qual,
    bcm_field_qualify_t * bcm_qual_p,
    uint32 *cs_qual_index_p);

/**
 * \brief Structure used to create dump list for context selection bcm qualifiers
 */
typedef struct
{
    /**
     * Mandatory first member for structures added to the rhlist
     */
    rhentry_t entry;
    /**
     * bcm qualifier
     */
    bcm_field_qualify_t bcm_qual;
    int field_id[DNX_FIELD_STAGE_NOF];
} cs_dnx_dump_t;

/**
 * \brief Structure used to map bcm qualifier to context selection field ID
 *        map may be regular - 1 bcm qual to 1 dbal field
 *        or indexed - 1 dbal qualifier to array of dbal fields according to index, which is provided along bcm qual
 */
typedef struct
{
    /**
     * Number of dbal_fields per bcm qualifier
     * 0 - Invalid - bcm qualifier not supported in context selection
     * 1 - means regular
 */
    int nof;
    /**
     * In case of (nof == 1) and (qual_type_conversion_cb == NULL) dbal field id is used
     */
    dbal_fields_e field_id;
    /**
     * First flag is marking basic bcm qualifier - the one that will be chosen for dnx to bcm mapping
     */
    uint32 flags;
    /**
     * Pointer to array of dbal fields for specific bcm qual
     */
    dbal_fields_e *field_id_array;
    /**
     * Increase index of qual_arg for certain qualifiers (currently only ForwardingType)
     */
    int index_shift;
    /*
     * Routine that will translate the bcm qualifier to a dnx qualifier for cases when using
     * field_id_array is not enough.
     */
    cs_qual_type_bcm_to_dnx_conversion_cb qual_type_bcm_to_dnx_conversion_cb;
    /*
     * Routine that will translate the dnx qualifier back to a bcm qualifier for cases when using
     * field_id_array is not enough.
     */
    cs_qual_type_dnx_to_bcm_conversion_cb qual_type_dnx_to_bcm_conversion_cb;
    /*
     * Routine that will translate the qualifier's bcm value into its corresponding dnx value
     */
    field_data_conversion_cb conversion_cb;
} dnx_field_cs_qual_map_t;

/**
 * \brief Structure describing input type based information for dnx qualifiers
 */
typedef struct
{
    /*
     * Valid flag serves to mark initialized input types, by default is FALSE(0)
     */
    int valid;
    /**
     * Bitmap that represents for each input type which FFC ranges to use
     */
    uint8 ranges;
} dnx_field_qual_input_type_info_t;

/**
 * \brief Structure used to store information per SW qualifier
 */
typedef struct
{
    /**
     * Field ID associated with this qualifier, to be used while configuring TCAM entries
     */
    dbal_fields_e field_id;
    int size;
    /*
     * bcm qualifier that is mapped to this dnx one, if 0 no bcm qualifier is mapped to it
     */
    bcm_field_qualify_t bcm_qual;
} dnx_field_sw_qual_info_t;

/**
 * \brief Structure used to store signal information per qualifier
 */
typedef struct
{
    /*
     * Name of stage signal comes from, If null any from
     * stages will be searched for match.
     */
    char *from;
    /*
     * Name of stage signal goes to, if null any to stage
     * will be searched for match.
     */
    char *to;
    /*
     * Name of the signal, which is corresponding to the qualifier.
     */
    char *name;
} dnx_field_map_qual_signal_info_t;

/**
 * \brief Structure used to store information per metadata qualifier
 */
typedef struct
{
    /**
     * Field ID associated with this qualifier, to be used while configuring TCAM entries
     */
    dbal_fields_e field_id;
    /*
     * bcm qualifier that is mapped to this dnx one, if 0 no bcm qualifier is mapped to it
     */
    bcm_field_qualify_t bcm_qual;
    /*
     * Info about signal or signals, which are corresponding to the qualifier.
     */
    dnx_field_map_qual_signal_info_t signal_info[DNX_DATA_MAX_FIELD_DIAG_NOF_SIGNALS_PER_QUALIFIER];
} dnx_field_meta_qual_info_t;

/**
 * \brief Structure used to store information per virtual wire qualifier
 */
typedef struct
{
    /**
     * Field ID associated with this qualifier, to be used while configuring TCAM entries
     */
    dbal_fields_e field_id;
    /**
     * The stages the VW is available for.
     */
    uint32 stage_bmp;
} dnx_field_vw_qual_info_t;

/**
 * \brief Structure used to store information per virtual wire action
 */
typedef struct
{
    /**
     * Field ID associated with this action, to be used while configuring TCAM entries
     * The first field_id has the name of the virtual wire.
     */
    dbal_fields_e field_id[DNX_FIELD_ACTION_MAX_ACTION_PER_VM];
    /**
     * The number of actions in field_id and action size for each stage
     */
    uint8 nof_actions_per_stage[DNX_FIELD_STAGE_NOF];
    /**
     * The static action upon which the action is based on for each stage.
     */
    dnx_field_action_t base_dnx_action_per_stage[DNX_FIELD_ACTION_MAX_ACTION_PER_VM][DNX_FIELD_STAGE_NOF];
} dnx_field_per_vw_action_info_t;

/**
 * \brief Structure used to store information per virtual wire action
 */
typedef struct
{
    /**
     * The index in dnx_per_vw_action_info of the VW using this action.
     */
    int vw_index;
    /**
     * The index of the action in the VW info in dnx_per_vw_action_info.
     */
    int action_index_within_vw;
} dnx_field_vw_action_info_t;

/**
 * \brief Structure used to store information per packet header qualifiers
 */
typedef struct
{
    /*
     * Name that may be parsed using signal facility
     * If the name was not found, use statically defined size and offset (see below)
     * If size is 0 and name not found - qualifier will be invalid
     * If size is not 0 and field was found, found parameters takes precedence over static with info message
     */
    char *name;
    /**
     * Field ID associated with this qualifier, to be used while configuring TCAM entries
     * If field_id is 0, it will be obtained dynamically from DBAL
     */
    dbal_fields_e field_id;
    /*
     * Qualifier Size in bits, if 0 should be filled via name resolution
     * Used when qualifier name is not present in NetworkStructures.xml
     * On the fly we can decide to overwrite size and offset by XML
     */
    int size;
    /**
     * For packet header - Offset from base - type of base depends on FCC type (in bits), filled together with size
     * For layer record  - Offset inside layer record
     */
    int offset;
    /*
     * Validity - mark if there was a problem in obtaining header qualifier parameters
     */
    int valid;
    /*
     * bcm qualifier that is mapped to this dnx one, if 0 no bcm qualifier is mapped to it
     */
    bcm_field_qualify_t bcm_qual;
    /*
     * Info about signal or signals, which are corresponding to the qualifier.
     */
    dnx_field_map_qual_signal_info_t signal_info[DNX_DATA_MAX_FIELD_DIAG_NOF_SIGNALS_PER_QUALIFIER];
} dnx_field_header_qual_info_t;

/**
 * \brief Structure used to store information per packet layer record qualifiers
 */
typedef struct
{
    /**
     * DBAL Field ID associated with this qualifier, to be used while configuring TCAM entries
     */
    dbal_fields_e dbal_field_id;
    /*
     * bcm qualifier that is mapped to this dnx one, if 0 no bcm qualifier is mapped to it
     */
    bcm_field_qualify_t bcm_qual;
} dnx_field_layer_record_qual_info_t;

/** Structure to hold the in parameters of dnx_field_qualifier_create()*/
typedef struct
{
    /**
     * Size of the created qualifier
     */
    int size;
    /**
     * Name of the qualifier.
     */
    char name[DBAL_MAX_STRING_LENGTH];

} dnx_field_qualifier_in_info_t;

/** Flags for BCM to DNX qualifiers/action map */
#define         BCM_TO_DNX_BASIC_OBJECT      0x01

/**
 * \brief
 *      Structure to hold miscellaneous parameters for bcm to dnx mapping process
 */
typedef struct
{
    /**
     * Encoded dnx qualifier to which bcm one is mapped
     */
    dnx_field_qual_t dnx_qual;
    /**
     * First flag is marking basic bcm qualifier - the one that will be chosen for dnx to bcm mapping
     */
    uint32 flags;
    /*
     * Routine that will translate the qualifier's bcm value into its corresponding dnx value
     */
    field_data_conversion_cb conversion_cb;
} dnx_field_qual_map_t;

typedef struct
{
    /**
     * Encoded dnx action to which bcm one is mapped
     */
    dnx_field_action_t dnx_action;
    /**
     * First flag is marking basic bcm action - the one that will be chosen for dnx to bcm mapping
     */
    uint32 flags;
    /*
     * Routine that will translate the action's bcm value into its corresponding dnx value
     */
    field_data_conversion_cb conversion_cb;
} dnx_field_action_map_t;

/**
 * Information assigned to each static 'dnx action'
 */
typedef struct
{
    /**
     * Field ID associated with this action, to be used while configuring TCAM entries
     */
    dbal_fields_e field_id;
    /**
     * Number of bits assigned to this action (1 - 32)
     * To serve only SW action - for others size should be obtained dynamically from DBAL
     */
    uint32 size_sw;
    /**
     * BCM action assigned on init
     */
    bcm_field_action_t bcm_action;
    /**
     * Signal or signals, which are corresponding to the action.
     */
    char *signal_name[DNX_DATA_MAX_FIELD_DIAG_NOF_SIGNALS_PER_ACTION];
} dnx_field_base_action_info_t;

/** Structure to hold the in parameters of dnx_field_action_create()
* Action create does not actually create new action just set a different size for existing action
* Hence this struct must indicate what is the base action and the new size
*/
typedef struct
{
    /** Field stage the action was created for*/
    dnx_field_stage_e stage;

    /** BCM action type we use to configure the action */
    bcm_field_action_t bcm_action;
    /**
     * Size of the created action
     * Cannot exceed the size of the base action.
     */
    unsigned int size;

    /**
     * A constant value that is apended to the MSB each action value that will be given to the action.
     * The prefix is not found in the TCAM/MDB payload (or key in direct extraction) and does not waste space there.
     * However, we implement it using FES action masks, which are a limited resource.
     */
    uint32 prefix;

    /**
     * The size in bit of the prefix. the sum of 'size'+'prefix_size' cannot exceed the size of the base action.
     * If the 'prefix_size' lsb bits of 'prefix' are all zeros, the prefix size will be zero.
     * As a safetly measurement, to make sure the user is cognisant of the base action size, the prefix size must fill
     * the remaining space in the base action, that is size+prefix_size=base_action_size.
     */
    unsigned int prefix_size;
    /**
     * Name of the action.
     */
    char name[DBAL_MAX_STRING_LENGTH];

} dnx_field_action_in_info_t;

/**
 * \brief Structure to keep all stage related pointers and other information
 */
typedef struct
{
    /*
     * Temporary adding PP_STAGE to be able to reach dnx data
     * Once FIELD_STAGE will be replaced by PP_STAGE it wont be needed
     */
    dnx_pp_stage_e pp_stage;
    /**
     * Associated BCM Stage
     */
    bcm_field_stage_t bcm_stage;
    /**
     * Next 3 parameters are to provide information on context selection qualifiers per stage
     */
    /**
     * DBAL table id for cs qualifiers
     */
    dbal_tables_e cs_table_id;
    /**
     * Number of dnx context selection qualifiers per stage
     */
    int cs_qual_nof;
    /**
     * Pointer to array of dbal fields per dnx context selection qualifier
     */
    const dbal_fields_e *cs_qual_info;
    /**
     * DBAL table id for cs hit indication
     */
    dbal_tables_e cs_hit_indication_table_id;
    /*
     * Mapping arrays from bcm to dnx parameters
     */
    /**
     * DBAL table id for lookup enabler
     */
    dbal_tables_e lookup_enabler_table_id;
    /**
     * Max ID for metadata qualifier for this stage
     */
    int meta_qual_nof;
    /**
     * Pointer to array of info per metadata dnx qualifier
     */
    dnx_field_meta_qual_info_t *meta_qual_info;
    /**
     * Pointer to array of info per layer record dnx qualifier
     */
    dnx_field_layer_record_qual_info_t *layer_qual_info;
    /*
     * array of ffc type dbal field ids
     */
    dbal_fields_e ffc_type_field_a[DNX_FIELD_FFC_NOF];
    dbal_fields_e ffc_instruction;
    dbal_fields_e ctx_id;
    dbal_fields_e key_field;
    dbal_tables_e ffc_table;
    /*
     * Structured fields to contain all qualifiers and actions per stage
     * Used to have an ability to obtain the lists directly from DBAl and field sizes for FP entry
     */
    dbal_field_types_defs_e container_qual_field_type;
    dbal_field_types_defs_e container_act_field_type;
    /**
     * Next 3 parameters are to provide information on action per stage
     */
    /**
     * DBAL field id for action
     */
    dbal_fields_e action_field_id;
    /**
     * Max ID for DBAL action
     */
    dnx_field_action_type_t static_action_nof;
    /**
     * Pointer to array of info per dnx action
     */
    dnx_field_base_action_info_t *static_action_info;
    /*
     * BCM to DNX maps
     */
    const dnx_field_cs_qual_map_t *cs_qual_map;
    const dnx_field_qual_map_t *meta_qual_map;
    const dnx_field_action_map_t *static_action_id_map;
} dnx_field_map_stage_info_t;

/**
 * \brief Structure to keep AppType to KBP OPCODE mapping.
 */
typedef struct
{
    /*
     * The OPCODE_ID to which the static apptype is mapped. 0 means invalid.
     */
    dbal_enum_value_field_kbp_fwd_opcode_e opcode_id;
} dnx_field_static_apptype_map_t;

/**
 * \brief Structure to keep AppType to KBP OPCODE mapping.
 *        Also include context selection profile.
 */
typedef struct
{
    /*
     * The BCM apptype indicating the KBP OPCODE ID.
     */
    bcm_field_AppType_t app_type;
    /*
     * Value to be used for context selection.
     */
    uint32 cs_profile_id;
    /*
     * Indicated if the OPCODE has valid information.
     */
    uint8 is_valid;
    /*
     * Indicated if the OPCODE being used, that is if it has any context associated with it.
     */
    uint8 in_use;
} dnx_field_static_opcode_info_t;

/**
 * Enum for indicating the port profile type, whether it refers to port or LIF or a RIF.
 */
typedef enum
{
    DNX_FIELD_PORT_PROFILE_TYPE_INVALID = 0,
    DNX_FIELD_PORT_PROFILE_TYPE_FIRST = 1,
    /**
     * The profile of a port, whether is be in port or out port, PP port or TM port.
     */
    DNX_FIELD_PORT_PROFILE_TYPE_PORT = DNX_FIELD_PORT_PROFILE_TYPE_FIRST,
    /**
     * An extra profile of a port, whether is be in port or out port, PP port or TM port.
     */
    DNX_FIELD_PORT_PROFILE_TYPE_PORT_GENERAL_DATA,
    /**
     * An extra profile of a port, beyond the first 32 bits, whether is be in port or out port, PP port or TM port.
     */
    DNX_FIELD_PORT_PROFILE_TYPE_PORT_GENERAL_DATA_HIGH,
    /**
     * The profile of an in LIF in the ingress.
     */
    DNX_FIELD_PORT_PROFILE_TYPE_IN_LIF_INGRESS,
    /**
     * The profile of an in RIF in the the ingress.
     */
    DNX_FIELD_PORT_PROFILE_TYPE_IN_ETH_RIF_INGRESS,
    /**
     * The profile of an out LIF in the egress.
     */
    DNX_FIELD_PORT_PROFILE_TYPE_OUT_LIF_INGRESS,
    /**
     * The profile of an out RIF in the the egress.
     */
    DNX_FIELD_PORT_PROFILE_TYPE_OUT_ETH_RIF_EGRESS,
    /**
     * Number of enum valid values for port profile types */
    DNX_FIELD_PORT_PROFILE_TYPE_NOF
} dnx_field_port_porfile_type_e;

/**
 * \brief Structure that maps port profile properties
 * See dnx_field_port_profile_port_set.
 * See dnx_field_port_profile_port_get.
 * See dnx_field_map_port_profile_port_info_get.
 */
typedef struct
{
    /**
     * Whether the port profile refers to a port of a LIF.
     */
    dnx_field_port_porfile_type_e port_profile_type;
    /** The following attributes are only relevant for profile that are used for PP/TM ports.*/
    /**
     * The DBAL table where the port profile is found, relevant only for port profile of type port.
     */
    dbal_tables_e dbal_table_id;
    /*
     * The key field used by the DBAL table, relevant only for port profile of type port.
     */
    dbal_fields_e dbal_key_field;
    /*
     * The result field used by the DBAL table, relevant only for port profile of type port.
     */
    dbal_fields_e dbal_result_field;
} dnx_field_map_port_profile_info_t;

/**
 * \brief Structure that stores field PP-APP enum to TCAM PP Table mapping.
 */
typedef struct
{
    /*
     * The Table ID to which the PP-APP enum is mapped.
     */
    dbal_tables_e dbal_table_id;
    /*
     * Specifies whether the entry is valid
     */
    uint8 valid;
} dnx_field_pp_app_map_t;

/*
 * }
 */
/*
 * Globals
 *    Used by MACROs available for any FP users
 * {
 */
extern const dnx_field_map_stage_info_t dnx_field_map_stage_info[DNX_FIELD_STAGE_NOF];
extern dnx_field_vw_qual_info_t dnx_vw_qual_info[DNX_FIELD_MAP_MAX_VW_QUAL];
extern dnx_field_per_vw_action_info_t dnx_per_vw_action_info[DNX_FIELD_MAP_MAX_VW_WITH_ACTION];
extern dnx_field_vw_action_info_t dnx_vw_action_info[DNX_FIELD_MAP_MAX_VW_ACTION];
extern dnx_field_static_opcode_info_t dnx_field_static_opcode_info[DBAL_NOF_ENUM_KBP_FWD_OPCODE_VALUES];
extern const dnx_field_static_apptype_map_t dnx_field_standard_1_static_apptype_map[bcmFieldAppTypeCount];
extern const dnx_field_map_port_profile_info_t dnx_field_map_port_profile_info[bcmPortClassCount];
extern const dnx_field_pp_app_map_t dnx_field_pp_app_map[bcmFieldAppDbCount];

/*
 * }
 */

/*
 * Macros
 * {
 */
/*
 * Macro to indicate whether specified stage is initialized by FP.
 * 'FP' stages are those that have 'name' in stage_info array:
 *   DNX_FIELD_STAGE_IPMF1, DNX_FIELD_STAGE_IPMF2,
 *   DNX_FIELD_STAGE_IPMF3, DNX_FIELD_STAGE_EPMF
 */
#define DNX_FIELD_IS_FP_STAGE(stage) (dnx_field_map_stage_info[stage].pp_stage != DNX_PP_STAGE_INVALID)

#define DNX_FIELD_STAGE_ITERATOR(stage)                                                 \
        for(stage = DNX_FIELD_STAGE_FIRST; stage < DNX_FIELD_STAGE_NOF; stage++)        \
            if(DNX_FIELD_IS_FP_STAGE(stage))

#define DNX_FIELD_STAGE_CS_QUAL_ITERATOR(stage)                                         \
        for(stage = DNX_FIELD_STAGE_FIRST; stage < DNX_FIELD_STAGE_NOF; stage++)        \
            if(dnx_field_map_stage_info[stage].cs_qual_map != NULL)

#define DNX_FIELD_STAGE_QUAL_ITERATOR(stage)                                            \
        for(stage = DNX_FIELD_STAGE_FIRST; stage < DNX_FIELD_STAGE_NOF; stage++)        \
            if(dnx_field_map_stage_info[stage].meta_qual_map != NULL)

#define DNX_FIELD_STAGE_LAYER_QUAL_ITERATOR(stage)                                      \
        for(stage = DNX_FIELD_STAGE_FIRST; stage < DNX_FIELD_STAGE_NOF; stage++)        \
            if(dnx_field_map_stage_info[stage].layer_qual_info != NULL)

#define DNX_FIELD_STAGE_ACTION_ITERATOR(stage)                                          \
        for(stage = DNX_FIELD_STAGE_FIRST; stage < DNX_FIELD_STAGE_NOF; stage++)        \
            if(dnx_field_map_stage_info[stage].static_action_id_map != NULL)

#define DNX_FIELD_KBP_OPCODE_ITERATOR(_opcode_id)                                           \
        for(_opcode_id = 0; _opcode_id < DBAL_NOF_ENUM_KBP_FWD_OPCODE_VALUES; _opcode_id++) \
            if(dnx_field_static_opcode_info[_opcode_id].is_valid)

#define DNX_FIELD_KBP_OPCODE_IN_USE_ITERATOR(_opcode_id)                                           \
                for(_opcode_id = 0; _opcode_id < DBAL_NOF_ENUM_KBP_FWD_OPCODE_VALUES; _opcode_id++) \
                    if(dnx_field_static_opcode_info[_opcode_id].is_valid &&                         \
                       dnx_field_static_opcode_info[_opcode_id].in_use)

#define DNX_FIELD_KBP_APPTYPE_ITERATOR(_apptype_id)                                           \
        for(_apptype_id = 0; _apptype_id < bcmFieldAppTypeCount; _apptype_id++) \
            if(dnx_field_static_opcode_info[dnx_field_static_apptype_map[_apptype_id].opcode_id].is_valid)

    /**
     * \brief Return if an Apptype is within the user defined range
     * \param [in] unit            - Device ID
     * \param [in] _tested_apptype - The apptype
     * \return
     *      True if the apptype is within the predefiend range
     * \remark
     */
#define DNX_FIELD_APPTYPE_IS_USER_DEF(unit, _tested_apptype)  \
        ((_tested_apptype >= dnx_data_field.kbp.apptype_user_1st_get(unit)) && \
         (_tested_apptype < dnx_data_field.kbp.apptype_user_1st_get(unit) + \
                            dnx_data_field.kbp.apptype_user_nof_get(unit)))

#define DNX_FIELD_HEADER_QUAL_VERIFY(qual_id)                                               \
    if((qual_id < DNX_FIELD_HEADER_QUAL_FIRST) || (qual_id >= DNX_FIELD_HEADER_QUAL_NOF))   \
    {                                                                                       \
        SHR_ERR_EXIT(_SHR_E_PARAM, "Header qual id:%d is out of range\n", qual_id);         \
    }

#define DNX_FIELD_SW_QUAL_VERIFY(qual_id)                                                   \
    if((qual_id < DNX_FIELD_SW_QUAL_FIRST) || (qual_id >= DNX_FIELD_SW_QUAL_NOF))           \
    {                                                                                       \
        SHR_ERR_EXIT(_SHR_E_PARAM, "SW qual id:%d is out of range\n", qual_id);             \
    }

#define DNX_FIELD_META_QUAL_VERIFY(stage, qual_id)                                          \
    if((qual_id < DNX_FIELD_QUAL_ID_FIRST) || (qual_id >= dnx_field_map_stage_info[stage].meta_qual_nof))        \
    {                                                                                       \
        SHR_ERR_EXIT(_SHR_E_PARAM, "meta qual id:%d is out of range for stage:%s\n",        \
                                              qual_id, dnx_field_stage_text(unit,stage));   \
    }

#define DNX_FIELD_LAYER_QUAL_VERIFY(stage, qual_id)                                         \
    if((qual_id < DNX_FIELD_LR_QUAL_FIRST) || (qual_id >= DNX_FIELD_LR_QUAL_NOF))           \
    {                                                                                       \
        SHR_ERR_EXIT(_SHR_E_PARAM, "layer record qual id:%d is out of range for stage:%s\n",\
                                               qual_id, dnx_field_stage_text(unit,stage));  \
    }

#define DNX_FIELD_LAYER_INDEX_VERIFY(stage, layer_id)                                       \
    if(dnx_field_map_stage_info[stage].layer_qual_info == NULL)                             \
    {                                                                                       \
        SHR_ERR_EXIT(_SHR_E_PARAM, "Stage:%s does not support layer record qualifiers\n",   \
                                                        dnx_field_stage_text(unit,stage));  \
    }                                                                                       \
    if((layer_id < 0 ) ||                                                                   \
       (layer_id >= dnx_data_field.stage.stage_info_get(unit, stage)->nof_layer_records))   \
    {                                                                                       \
        SHR_ERR_EXIT(_SHR_E_PARAM, "Layer Index:%d is invalid for stage: %s. "              \
                     "Number of layers available to stage is %d.\n",                        \
                     layer_id, dnx_field_stage_text(unit,stage),                            \
                     dnx_data_field.stage.stage_info_get(unit, stage)->nof_layer_records);  \
    }

#define DNX_FIELD_BCM_QUAL_VERIFY(bcm_qual)                                             \
    if((bcm_qual < 0) || (bcm_qual >= bcmFieldQualifyCount))                            \
    {                                                                                   \
        SHR_ERR_EXIT(_SHR_E_PARAM, "BCM qualifier:%d is out of range\n", bcm_qual);     \
    }

#define DNX_FIELD_BCM_ACTION_VERIFY(bcm_action)                                         \
    if((bcm_action < 0) || (bcm_action >= bcmFieldActionCount))                         \
    {                                                                                   \
        SHR_ERR_EXIT(_SHR_E_PARAM, "BCM action:%d is out of range\n", bcm_action);      \
    }

#define DNX_FIELD_DBAL_FIELD_ID_VERIFY(dbal_field_id)                                   \
{                                                                                       \
    if((dbal_field_id <= DBAL_FIELD_EMPTY) || (dbal_field_id >= DBAL_NOF_FIELDS))       \
    {                                                                                   \
        SHR_ERR_EXIT(_SHR_E_PARAM, "Invalid dbal field id:%d\n", dbal_field_id);        \
    }                                                                                   \
}

#define DNX_FIELD_QUAL_SIZE_VERIFY(size)                                                \
{                                                                                       \
    if((size < 1) || (size > dnx_data_field.qual.max_bits_in_qual_get(unit)))           \
    {                                                                                   \
        SHR_ERR_EXIT(_SHR_E_PARAM, "Qualifier size (%d) must be between %d and %d\n",   \
                     size, 1, dnx_data_field.qual.max_bits_in_qual_get(unit));          \
    }                                                                                   \
}

#define DNX_FIELD_NCM_PORT_CLASS_VERIFY(bcm_port_class)                                    \
{                                                                                          \
    if((bcm_port_class < 0) || (bcm_port_class > bcmPortClassCount))                       \
    {                                                                                      \
        SHR_ERR_EXIT(_SHR_E_PARAM, "BCM port class:%d is out of range\n", bcm_port_class); \
    }                                                                                      \
    if(dnx_field_map_port_profile_info[bcm_port_class].port_profile_type == DNX_FIELD_PORT_PROFILE_TYPE_INVALID) \
    {                                                                                      \
        SHR_ERR_EXIT(_SHR_E_PARAM, "BCM port class:%d is unsupported for field map.\n", bcm_port_class); \
    }                                                                                      \
}

#define DNX_FIELD_ACTION_ID_NOF(stage)                                                  \
    (dnx_field_map_stage_info[stage].static_action_nof)

#define DNX_FIELD_CS_QUAL_NOF(stage)                                                  \
    (dnx_field_map_stage_info[stage].cs_qual_nof)

/*
 * }
 */
/**
* \brief
*  Init the Sw state of Field Map module
* \param [in] unit  - Device id
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_sw_state_init(
    int unit);

/**
 * \brief  Return name of bcm qualifier
 * \param [in] unit     - Identifier of HW platform.
 * \param [in] bcm_qual - bcm qualifier ID
 * \return
 *   \retval bcmQualifierName      - On success
 *   \retval NULL                  - ON Failure
 * \remark
 */
CONST char *dnx_field_bcm_qual_text(
    int unit,
    bcm_field_qualify_t bcm_qual);

/**
 * \brief  Return name of bcm action
 * \param [in] unit       - Identifier of HW platform.
 * \param [in] bcm_action - bcm action ID
 * \return
 *   \retval bcmActionName              - On success
 *   \retval NULL                       - On Failure
 * \remark
 */
CONST char *dnx_field_bcm_action_text(
    int unit,
    bcm_field_action_t bcm_action);

/**
 * \brief  Return name of pipeline stage
 * \param [in] unit  - Identifier of HW platform.
 * \param [in] stage - stage ID
 * \return
 *   \retval bcmStageName               - On success
 *   \retval NULL                       - On Failure
 * \remark
 */
char *dnx_field_stage_text(
    int unit,
    dnx_field_stage_e stage);

/**
 * \brief  Return name of BCM stage
 * \param [in] bcm_stage - BCM stage ID
 * \return
 *   \retval bcmStageName               - On success
 *   \retval NULL                       - On Failure
 * \remark
 */
char *dnx_field_bcm_stage_text(
    bcm_field_stage_t bcm_stage);

/**
 * \brief  Return name of BCM Layer Type
 * \param [in] bcm_layer_type - BCM Layer Type ID
 * \return
 *   \retval bcmLayerTypeName           - On success
 *   \retval NULL                       - On Failure
 * \remark
 */
char *dnx_field_bcm_layer_type_text(
    bcm_field_layer_type_t bcm_layer_type);

/**
 * \brief  Return name of dnx qualifier class
 * \param [in] qual_class - dnx qualifier class
 * \return
 *   \retval class name       - On success
 *   \retval "Invalid Class"  - If invalid class provided
 *   \retval "Unnamed Class"  - If for valid class name was not assigned
 * \remark
 */
char *dnx_field_qual_class_text(
    dnx_field_qual_class_e qual_class);

/**
 * \brief  Return name of dnx input type
 * \param [in] input_type - qual input type
 * \return
 *   \retval input_type name        - On success
 *   \retval "Invalid Input Type"   - If invalid input type provided
 *   \retval "Unnamed Input Type"   - If for valid input type, name was not assigned
 * \remark
 */
char *dnx_field_input_type_text(
    dnx_field_input_type_e input_type);

/**
 * \brief  Return name of bcm input type
 * \param [in] bcm_input_type - BCM qual input type
 * \return
 *   \retval input_type name        - On success
 *   \retval "Invalid Input Type"   - If invalid input type provided
 *   \retval "Unnamed Input Type"   - If for valid input type, name was not assigned
 * \remark
 */
char *dnx_field_bcm_input_type_text(
    bcm_field_input_types_t bcm_input_type);

/**
 * \brief  Return name of bcm packet remove layer
 * \param [in] bcm_packet_remove_layer - BCM packet remove layer
 * \return
 *   \retval packet_remove_layer name  - On success
 *   \retval "Invalid Packet Remove Layer"   - If invalid Packet Remove Layer provided
 *   \retval "Unnamed Packet Remove Layer"   - If for valid Packet Remove Layer, name was not assigned
 * \remark
 */
char *dnx_field_bcm_packet_remove_layer_text(
    bcm_field_packet_remove_layers_t bcm_packet_remove_layer);

/**
 * \brief  Return name of bcm tcam bank allocation mode
 * \param [in] bcm_tcam_bank_allocation_mode - BCM tcam bank allocation mode
 * \return
 *   \retval input_type name        - On success
 *   \retval "Invalid Input Type"   - If invalid input type provided
 *   \retval "Unnamed Input Type"   - If for valid input type, name was not assigned
 * \remark
 */
char *dnx_field_bcm_tcam_bank_allocation_mode_text(
    bcm_field_tcam_bank_allocation_mode_t bcm_tcam_bank_allocation_mode);

/**
 * \brief  Return name of bcm Apptype
 * \param [in] bcm_apptype - BCM Apptype
 * \return
 *   \retval Apptype name        - On success
 *   \retval "Invalid Apptype Type"   - If invalid Apptype provided
 *   \retval "Unnamed Apptype Type"   - If for valid Apptype, name was not assigned
 * \remark
 */
char *dnx_field_bcm_apptype_text(
    bcm_field_AppType_t bcm_apptype);

/**
 * \brief  Return name of bcm RangeType
 * \param [in] bcm_rangetype - BCM RangeType
 * \return
 *   \retval RangeType name        - On success
 *   \retval "Invalid RangeType Type"   - If invalid RangeType provided
 * \remark
 */
char *dnx_field_bcm_range_type_text(
    bcm_field_range_type_t bcm_rangetype);

/**
 * \brief  Return name of bcm RangeResultMap
 * \param [in] bcm_rangeresultmap - BCM RangeResultMap
 * \return
 *   \retval RangeResultMap name        - On success
 *   \retval "Invalid RangeResultMap Type"   - If invalid RangeResultMap provided
 * \remark
 */
char *dnx_field_bcm_range_result_map_text(
    bcm_switch_range_result_map_t bcm_rangeresultmap);

/**
 * \brief  Return name of bcm RangeOperator
 * \param [in] bcm_rangeoperator - BCM RangeOperator
 * \return
 *   \retval RangeOperator name        - On success
 *   \retval "Invalid RangeOperator Type"   - If invalid RangeOperator provided
 * \remark
 */
char *dnx_field_bcm_range_operator_text(
    bcm_switch_range_operator_t bcm_rangeoperator);

/**
 * \brief  Return name of dnx action class
 * \param [in] action_class - dnx action class
 * \return
 *   \retval class name       - On success
 *   \retval "Invalid Class"  - If invalid class provided
 *   \retval "Unnamed Class"  - If for valid class name was not assigned
 * \remark
 */
char *dnx_field_action_class_text(
    dnx_field_action_class_e action_class);

/**
 * \brief  Return Name of DNX Action
 * \param [in] unit       - Identifier of HW platform.
 * \param [in] dnx_action - Encoded DNX Action
 * \return
 *   \retval dbal field name    - On success
 *   \retval Invalid DNX Action - When DNX Action is not valid
 * \remark
 *  Name is actually DBAL field name
 */
CONST char *dnx_field_dnx_action_text(
    int unit,
    dnx_field_action_t dnx_action);

/**
 * \brief  Return Name of DNX Qualifier
 * \param [in] unit       - Identifier of HW platform.
 * \param [in] dnx_qual   - Encoded DNX Qualifier
 * \return
 *   \retval dbal field name       - On success
 *   \retval Invalid DNX Qualifier - When DNX Qualifier is not valid
 * \remark
 *  Name is actually DBAL field name
 */
CONST char *dnx_field_dnx_qual_text(
    int unit,
    dnx_field_qual_t dnx_qual);

/**
 * \brief  Return Protocol Name for Header Qualifier
 * \param [in] unit       - Identifier of HW platform.
 * \param [in] dnx_qual   - Encoded DNX Qualifier
 * \return
 *   \retval Protocol Stack name       - On success
 *   \retval NULL - if dnx_qual is not Header one or id does not match
 *   \retval ""   - empty string if there is no name for header qualifier
 * \remark
 *  Name is actually DBAL field name
 */
char *dnx_field_header_qual_name(
    int unit,
    dnx_field_qual_t dnx_qual);

/**
* \brief
*  Gets the actions and offsets that write to aspecific VW mapping.
* \param [in] unit - Device ID.
* \param [in] stage - Stage
* \param [in] mapping_info_p - The mapping of VM to a signal.
* \param [out] nof_actions_p - Number of actions mapped to the signal by the VM.
* \param [out] dnx_actions- The list of action ids used by the signal.
* \param [out] offsets- The offsets on the signal of the actions
* \param [out] action_sizes- The sizes of the actions.
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_action_vw_single_mapping_actions_offsets(
    int unit,
    dnx_field_stage_e stage,
    VirtualWireMappingInfo * mapping_info_p,
    int *nof_actions_p,
    dnx_field_action_t dnx_actions[DNX_DATA_MAX_FIELD_VIRTUAL_WIRE_ACTIONS_PER_SIGNAL_NOF],
    int offsets[DNX_DATA_MAX_FIELD_VIRTUAL_WIRE_ACTIONS_PER_SIGNAL_NOF],
    int action_sizes[DNX_DATA_MAX_FIELD_VIRTUAL_WIRE_ACTIONS_PER_SIGNAL_NOF]);

shr_error_e dnx_field_map_vw_qual_action_init(
    int unit);

shr_error_e dnx_field_map_action_init(
    int unit);

shr_error_e dnx_field_map_qual_init(
    int unit);

shr_error_e dnx_field_map_cs_qual_init(
    int unit);

shr_error_e dnx_field_map_init(
    int unit);

shr_error_e dnx_field_map_deinit(
    int unit);

/**
 * \brief  Indicade if any mapping exists for a qualifier in the the context selection of a specific stage.
 * \param [in] unit - Identifier of HW platform.
 * \param [in] stage - Stage identifier
 * \param [in] bcm_qual - BCM qualifier id
 * \param [out] exists_p - Indicates if the mapping exists
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 */
shr_error_e dnx_field_map_cs_qual_bcm_mapping_exists(
    int unit,
    dnx_field_stage_e stage,
    bcm_field_qualify_t bcm_qual,
    int *exists_p);

/**
 * \brief  Translate bcm qualifier into CS qualifier, this is one2one conversion
 * \param [in] unit - Identifier of HW platform.
 * \param [in] stage - Stage identifier
 * \param [in] context_id - Context ID of the preselection quals
 * \param [in] bcm_qual - BCM qualifier id
 * \param [in] cs_qual_index - index for arrayed DNX CS qualifiers, for non arrayed will be ignored (probably best to set at 0)
 * \param [out] cs_dnx_qual_p - pointer to dnx cs qualifier - DBAL Field ID
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_NOT_FOUND - When there is no support for such bcm qualifier in CS
 *   \retval _SHR_E_PARAM     - One of input params is out of range
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 */
shr_error_e dnx_field_map_cs_qual_bcm_to_dnx(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_context_t context_id,
    bcm_field_qualify_t bcm_qual,
    int cs_qual_index,
    dbal_fields_e * cs_dnx_qual_p);

/**
 * \brief  Translate bcm qualifier into CS qualifier, this is one2one conversion
 * \param [in] unit - Identifier of HW platform.
 * \param [in] core - Identifier of core.
 * \param [in] stage  - Stage identifier
 * \param [in] context_id - Context ID of the preselection quals
 * \param [in] bcm_cs_qual_info - BCM presel qualifier info, source of information here
 * \param [in] dnx_cs_qual_info - DNX presel qualifier info, destination here
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_NOT_FOUND - When there is no support for such bcm qualifier in CS
 *   \retval _SHR_E_PARAM     - One of input params is out of range
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 */
shr_error_e dnx_field_map_cs_qual_info_bcm_to_dnx(
    int unit,
    bcm_core_t core,
    dnx_field_stage_e stage,
    dnx_field_context_t context_id,
    bcm_field_presel_qualify_data_t * bcm_cs_qual_info,
    dnx_field_presel_qual_data_t * dnx_cs_qual_info);

/**
 * \brief  Translate CS DNX qualifier into BCM qualifier, this
 *         is one2one conversion
 * \param [in] unit - Identifier of HW platform.
 * \param [in] stage - Stage identifier
 * \param [in] context_id - Context ID of the preselection quals
 * \param [in] dnx_cs_qual - DNX qualifier id - DBAL Field ID
 * \param [out] bcm_qual_p - pointer to BCM qualifier
 * \param [out] cs_qual_index_p - pointer to CS qual index (0 for non-arrayed qualifiers)
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_NOT_FOUND - When there is no support for such bcm qualifier in CS
 *   \retval _SHR_E_PARAM     - One of input params is out of range
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 */
shr_error_e dnx_field_map_cs_qual_dnx_to_bcm(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_context_t context_id,
    dbal_fields_e dnx_cs_qual,
    bcm_field_qualify_t * bcm_qual_p,
    uint32 *cs_qual_index_p);

/**
 * \brief  Translate bcm qualifier into the set of DNX qualifiers
 * \param [in] unit - Identifier of HW platform.
 * \param [in] stage - Stage identifier
 * \param [out] cs_table_id_p - pointer to Context Selection qualifiers DBAL table id
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_PARAM     - One of input params is out of range
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 */
shr_error_e dnx_field_map_cs_qual_table_id(
    int unit,
    dnx_field_stage_e stage,
    dbal_tables_e * cs_table_id_p);

/**
 * \brief  Dump all available mappings from bcm qualifier to cs fields
 * \param [in] unit - Identifier of HW platform.
 * \param [in,out] cs_dnx_list_p - pointer to the list of dnx cs qualifiers set
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_NOT_FOUND - When there is no support for such bcm qualifier
 *   \retval _SHR_E_PARAM     - One of input params is out of range
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 */
shr_error_e dnx_field_map_cs_qual_dump(
    int unit,
    rhlist_t ** cs_dnx_list_p);

/**
 * \brief  Get all available cs fields for given stage, for all units.
 * \param [in] unit - Identifier of HW platform. Only used for error reporting.
 * \param [in] stage - Stage identifier
 * \param [out] dnx_cs_qual_info_p - pointer to the array of dnx cs quals sets, dbal field ids
 * \param [out] dnx_cs_qual_nof_p - pointer to the number of dnx cs quals
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_PARAM     - One of input params is out of range
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 */
shr_error_e dnx_field_map_cs_qual_dnx_get(
    int unit,
    dnx_field_stage_e stage,
    const dbal_fields_e ** dnx_cs_qual_info_p,
    int *dnx_cs_qual_nof_p);

/**
* \brief
*  Verify input parameters for preselection ID
* \param [in] unit           - Device ID
* \param [in] stage      - dnx stage identifier
* \param [in,out] cs_nof_lines_p - pointer to number of cs lines to be assigned in the routine
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_cs_qual_nof_lines(
    int unit,
    dnx_field_stage_e stage,
    uint32 *cs_nof_lines_p);

/**
* \brief
* This function decrement the number fo group reference to that specific qualifier id
* of groups referenced by
* \param [in] unit   - Device Id
* \param [in] qual  -  Dnx Qualifier
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_qual_ref_dec(
    int unit,
    dnx_field_qual_t qual);

/**
* \brief
* This function increment the number fo group reference to that specific qualifier id
* increments the number of groups referenced by
* \param [in] unit - Device Id
* \param [in] qual  - Dnx Qualifier
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_qual_ref_inc(
    int unit,
    dnx_field_qual_t qual);

/**
* \brief
*  Clear the dnx_field_qualifier_in_info_t, set it to preferred init values
* \param [in] unit              - Device ID
* \param [in] qual_info_in_p    - Pointer to input structure of qual_info_in_p that needs to be initiated
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_qual_in_info_init(
    int unit,
    dnx_field_qualifier_in_info_t * qual_info_in_p);

/**
* \brief
*  Create User qualifier
* \param [in] unit           - Device ID
* \param [in] flags          - Flags to create the qualifier with
* \param [in] qual_info_p    - Qualifier information for creation.
* \param [in,out] bcm_qual_p - For the case with_id bcm_qual will be input, otherwise output
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_qual_create(
    int unit,
    dnx_field_qual_flags_e flags,
    dnx_field_qualifier_in_info_t * qual_info_p,
    bcm_field_qualify_t * bcm_qual_p);

/**
* \brief
*  Destroy User created qualifier
* \param [in] unit      - Device ID
* \param [in] bcm_qual  - BCM Qualifier to destroy
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_qual_destroy(
    int unit,
    bcm_field_qualify_t bcm_qual);

shr_error_e dnx_field_map_qual_description_get(
    int unit,
    bcm_field_qualify_t bcm_qual,
    char **qual_description);

/**
* \brief
*  Gets the info for the qualifier which is relevant to the end user.
*  It fills it in qual_in_info_p.
* \param [in] unit              - Device ID.
* \param [in] bcm_qual          - BCM Qualifier ID.
* \param [out] qual_info_p      - holds all relevant info for the action, size, stage and name.
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_qual_get(
    int unit,
    bcm_field_qualify_t bcm_qual,
    dnx_field_qualifier_in_info_t * qual_info_p);

/**
 * \brief  Translate bcm qualifier into the set of DNX qualifiers
 * \param [in] unit - Identifier of HW platform.
 * \param [in] stage - Stage identifier
 * \param [in] print_errors - Bool to decide whether to display the errors
 * \param [in] bcm_qual - BCM qualifier id
 * \param [in,out] dnx_qual_p - pointer to dnx qualifier array
 * \param [out] qual_map_entry_p - place to assign pointer of bcm qual entry ignore if NULL
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_NOT_FOUND - When there is no support for such bcm qualifier
 *   \retval _SHR_E_PARAM     - One of input params is illegal or out of range
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 */
shr_error_e dnx_field_map_qual_bcm_to_dnx_int(
    int unit,
    dnx_field_stage_e stage,
    uint32 print_errors,
    bcm_field_qualify_t bcm_qual,
    dnx_field_qual_t * dnx_qual_p,
    const dnx_field_qual_map_t ** qual_map_entry_p);

/**
 * \brief  Translate bcm qualifier into the set of DNX qualifiers
 * \param [in] unit - Identifier of HW platform.
 * \param [in] stage - Stage identifier
 * \param [in] bcm_qual - BCM qualifier id
 * \param [in,out] dnx_qual_p - pointer to dnx qualifier array
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_NOT_FOUND - When there is no support for such bcm qualifier
 *   \retval _SHR_E_PARAM     - One of input params is illegal or out of range
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 */
shr_error_e dnx_field_map_qual_bcm_to_dnx(
    int unit,
    dnx_field_stage_e stage,
    bcm_field_qualify_t bcm_qual,
    dnx_field_qual_t * dnx_qual_p);

/**
 * \brief  Translate bcm qualifier into the set of DNX qualifiers
 * \param [in] unit - Identifier of HW platform.
 * \param [in] core - Identifier of core.
 * \param [in] stage - Stage identifier
 * \param [in] bcm_qual_info - pointer to BCM qualifier info
 * \param [out] dnx_qual_info - pointer to DNX qualifier array
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_NOT_FOUND - When there is no support for such bcm qualifier
 *   \retval _SHR_E_PARAM     - One of input params is out of range
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 */
shr_error_e dnx_field_map_qual_info_bcm_to_dnx(
    int unit,
    bcm_core_t core,
    dnx_field_stage_e stage,
    bcm_field_entry_qual_t * bcm_qual_info,
    dnx_field_entry_qual_t * dnx_qual_info);

/**
 * \brief  Indicates if the mapping of a qaulifier includes value conversion.
 * \param [in] unit - Identifier of HW platform.
 * \param [in] bcm_stage - Stage identifier
 * \param [in] bcm_qual - The mapped qualifier
 * \param [out] has_conversion_p - Indicates if there is a value conversion.
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_NOT_FOUND - When there is no support for such bcm qualifier
 *   \retval _SHR_E_PARAM     - One of input params is out of range
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 */
shr_error_e dnx_field_map_qual_has_conversion(
    int unit,
    bcm_field_stage_t bcm_stage,
    bcm_field_qualify_t bcm_qual,
    int *has_conversion_p);

/**
 * \brief  Translate dnx qualifier into BCM one
 * \param [in] unit - Identifier of HW platform.
 * \param [in] stage - Stage identifier
 * \param [in] dnx_qual - dnx qualifier
 * \param [in] bcm_qual_p - pointer where BCM qualifier id should be placed
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_NOT_FOUND - When there is no support for such dnx qualifier
 *   \retval _SHR_E_PARAM     - One of input params is out of range
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 */
shr_error_e dnx_field_map_qual_dnx_to_bcm(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_qual_t dnx_qual,
    bcm_field_qualify_t * bcm_qual_p);

/**
 * \brief  Create the list of all available dnx qualifiers per stage
 * \param [in] unit - Identifier of HW platform.
 * \param [in] stage - Stage identifier
 * \param [in,out] dnx_qual_list_p - pointer to the list of dnx qualifiers
 * \param [in,out] dnx_qual_num_p - pointer to the number dnx qualifier
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_PARAM     - One of input params is out of range
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 */
shr_error_e dnx_field_map_qual_list(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_qual_t ** dnx_qual_list_p,
    int *dnx_qual_num_p);

/**
 * \brief  Fetch the FFC range associated with a specific class.
 * \param [in] unit - Identifier of HW platform.
 * \param [in] stage - Stage identifier
 * \param [in] input_type - The input type given in attach info.
 * \param [in] offset - The offset given in attach info. Relevant only for Metadata.
 * \param [in,out] ranges_p - Pointer to the a bitmap indicating legitimate ranges for iPMF1 FFCs
 *                            (or 0 if stage isn't iPMF1 or iPMF2 with non-naive qualifiers).
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_PARAM     - For class out of range or class without FFC mapping info (if the stage is iPMF1,
 *                              or non native qualifiers for iPMF2).
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 */
shr_error_e dnx_field_map_qual_input_type_to_ranges(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_input_type_e input_type,
    int offset,
    uint8 *ranges_p);

/**
 * \brief  Fetch the FFC range associated with a specific key.
 * \param [in] unit - Identifier of HW platform.
 * \param [in] stage - Stage identifier
 * \param [in] key_id - The key to use the FFC in
 * \param [in,out] ranges_p - Pointer to the a bitmap indicating legitimate ranges for iPMF1 FFCs
 *                            (or all ones if stage isn't iPMF1).
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 */
shr_error_e dnx_field_map_qual_key_to_ranges(
    int unit,
    dnx_field_stage_e stage,
    dbal_enum_value_field_field_key_e key_id,
    uint8 *ranges_p);

/**
 * \brief  Convert a negative layer index to a positive one (given that layer indices are translated as modulo,
 *         that would have the same effect).
 * \param [in] unit - Identifier of HW platform.
 * \param [in] stage - Stage identifier. If iPMF2, assumes that the data is taken from iPMF1.
 * \param [in] layer_index_in - absolute number of layer record, which offset is requested
 * \param [in,out] layer_index_out - pointer to be filled with positive layer index.
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_PARAM     - For layer index out of range or stage without layer record support
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 *   At the moment this function doesn't perform modulo, just negative to positive conversion.
 *   This function is used for relative layer indices (input type FWD).
 */
shr_error_e dnx_field_map_layer_index_modulo(
    int unit,
    dnx_field_stage_e stage,
    int layer_index_in,
    int *layer_index_out);

/**
 * \brief  Fetch the pbus absolute offset of chosen layer record
 * \param [in] unit - Identifier of HW platform.
 * \param [in] stage - Stage identifier. If iPMF2, assumes that the data is taken from iPMF1.
 * \param [in] layer_index - absolute number of layer record, which offset is requested
 * \param [in,out] offset_p - pointer to the offset from pbus start
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_PARAM     - For layer index out of range or stage without layer record support
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 */
shr_error_e dnx_field_map_layer_record_offset(
    int unit,
    dnx_field_stage_e stage,
    int layer_index,
    int *offset_p);

/**
* \brief
* This function decrement the number fo group reference to that specific action
* of groups referenced by
* \param [in] unit   - Device Id
* \param [in] action  -  Dnx Action
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_action_ref_dec(
    int unit,
    dnx_field_action_t action);

/**
* \brief
* This function increment the number fo group reference to that specific action
* increments the number of groups referenced by
* \param [in] unit - Device Id
* \param [in] action  - Dnx Action
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_action_ref_inc(
    int unit,
    dnx_field_action_t action);

/**
* \brief
*  Clear the dnx_field_action_in_info_t, set it to preferred init values
* \param [in] unit              - Device ID
* \param [in] action_info_in_p  - Pointer to input structure of action_info_in_p that needs to be init
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_action_in_info_t_init(
    int unit,
    dnx_field_action_in_info_t * action_info_in_p);

/**
* \brief
*  Creates user action based on existing action, i.e. set new size.
* \param [in] unit              - Device ID
* \param [in] flags             - as per dnx_field_action_flags_e
* \param [in] action_in_info_p  - holds all relevant info for the action set-up(creation), size, stage, action and name.
* \param [in,out] bcm_action_p  - for with_id, bcm_action is input inside this ptr, otherwise, output created by routine
*                                 must be always provided, NULL will result in ERROR
* \param [in,out] dnx_action_p  - created action ID, encoded class is USER
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_action_create(
    int unit,
    dnx_field_action_flags_e flags,
    dnx_field_action_in_info_t * action_in_info_p,
    bcm_field_action_t * bcm_action_p,
    dnx_field_action_t * dnx_action_p);

/**
* \brief
*  Destroys an existing user action based .
* \param [in] unit           - Device ID
* \param [out] bcm_action    - BCM action to be destroyed
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_action_destroy(
    int unit,
    bcm_field_action_t bcm_action);

shr_error_e dnx_field_action_description_get(
    int unit,
    bcm_field_action_t bcm_action,
    char **action_description);
/**
 * \brief  Translate bcm action into the set of DNX action
 * \param [in] unit - Identifier of HW platform.
 * \param [in] stage - Stage identifier
 * \param [in] print_errors - Bool to decide whether to display the errors
 * \param [in] bcm_action - BCM action id
 * \param [in,out] dnx_action_p - pointer to dnx action
 * \param [out] action_map_entry_p - action map entry should be returned if the pointer is not NULL
 * \return *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_NOT_FOUND - When there is no support for such bcm action
 *   \retval _SHR_E_PARAM     - One of input params is out of range
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 */
shr_error_e dnx_field_map_action_bcm_to_dnx_int(
    int unit,
    dnx_field_stage_e stage,
    uint32 print_errors,
    bcm_field_action_t bcm_action,
    dnx_field_action_t * dnx_action_p,
    const dnx_field_action_map_t ** action_map_entry_p);

/**
 * \brief  Translate bcm action into the set of DNX action
 * \param [in] unit - Identifier of HW platform.
 * \param [in] stage - Stage identifier
 * \param [in] bcm_action - BCM action id
 * \param [in,out] dnx_action_p - pointer to dnx action
 * \return *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_NOT_FOUND - When there is no support for such bcm action
 *   \retval _SHR_E_PARAM     - One of input params is out of range
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 */
shr_error_e dnx_field_map_action_bcm_to_dnx(
    int unit,
    dnx_field_stage_e stage,
    bcm_field_action_t bcm_action,
    dnx_field_action_t * dnx_action_p);

/**
 * \brief  Translate bcm action into the set of DNX qualifiers
 * \param [in] unit - Identifier of HW platform.
 * \param [in] core - Identifier of core.
 * \param [in] stage - Stage identifier
 * \param [in] bcm_action_info - pointer to BCM qualifier info
 * \param [out] dnx_action_info - pointer to DNX action info
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_NOT_FOUND - When there is no support for such bcm action
 *   \retval _SHR_E_PARAM     - One of input params is out of range
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 */
shr_error_e dnx_field_map_action_info_bcm_to_dnx(
    int unit,
    bcm_core_t core,
    dnx_field_stage_e stage,
    bcm_field_entry_action_t * bcm_action_info,
    dnx_field_entry_action_t * dnx_action_info);

/**
 * \brief  Translate dnx action into BCM one
 * \param [in] unit - Identifier of HW platform.
 * \param [in] stage - Stage identifier
 * \param [in] dnx_action - dnx action
 * \param [in] bcm_action_p - pointer where BCM action id should be placed
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_NOT_FOUND - When there is no support for such dnx action
 *   \retval _SHR_E_PARAM     - One of input params is out of range
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 */
shr_error_e dnx_field_map_action_dnx_to_bcm(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_action_t dnx_action,
    bcm_field_action_t * bcm_action_p);

/**
 * \brief  Create list of all available dnx actions per stage
 * \param [in] unit - Identifier of HW platform.
 * \param [in] stage - Stage identifier
 * \param [in,out] dnx_action_list_p - pointer to the array of dnx actions
 * \param [in,out] dnx_action_nof_p - pointer to the number of dnx actions
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_PARAM     - One of input params is out of range
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 */
shr_error_e dnx_field_map_action_list(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_action_t ** dnx_action_list_p,
    int *dnx_action_nof_p);

/**
* \brief
*  Gets all relevant action info that the end user might need and fills it in action_info_in_p.
* \param [in] unit              - Device ID
* \param [in] bcm_action        - BCM Action ID
* \param [out] action_info_p    - holds all relevant info for the action, size, stage, action and name.
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_action_get(
    int unit,
    bcm_field_action_t bcm_action,
    dnx_field_action_in_info_t * action_info_p);

/**
* \brief
*  Maps the DNX qualifier to DBAL field
* \param [in] unit          - Device ID
* \param [in] stage   - Stage identifier
* \param [in] dnx_qual      - DNX qualifier
* \param [out] dbal_field_p - DBAL field
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_dnx_to_dbal_qual(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_qual_t dnx_qual,
    dbal_fields_e * dbal_field_p);

/**
* \brief
*  Maps DNX action to DBAL field
* \param [in] unit          - Device ID
* \param [in] stage      -Stage identifier
* \param [in] dnx_action      - DNX action
* \param [out] dbal_field_p  - DBAL field
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_dnx_to_dbal_action(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_action_t dnx_action,
    dbal_fields_e * dbal_field_p);

/**
* \brief
*  Maps DNX action to action type
* \param [in] unit          - Device ID
* \param [in] stage      -Stage identifier
* \param [in] dnx_action      - DNX action
* \param [out] action_type_p  - action type
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_dnx_to_action_type(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_action_t dnx_action,
    dnx_field_action_type_t * action_type_p);

/**
* \brief
*  Retruns if the action is legal for the specific device.
* \param [in] unit          - Device ID
* \param [in] stage      -Stage identifier
* \param [in] dnx_action      - DNX action
* \param [out] action_is_legal_p  - if the action type is legal for the device
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_action_is_legal(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_action_t dnx_action,
    int *action_is_legal_p);

/**
* \brief
*  Maps DNX action to action type
* \param [in] unit          - Device ID
* \param [in] dnx_stage     -Stage identifier
* \param [in] action_type   - action type, the value to be written to the DBAL ENUM for the action.
* \param [out] dnx_action_p - The static action that uses the action type.
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_action_type_to_predef_dnx_action(
    int unit,
    dnx_field_stage_e dnx_stage,
    dnx_field_action_type_t action_type,
    dnx_field_action_t * dnx_action_p);

/**
* \brief
*  Maps the DNX qualifier to its size in bits
* \param [in] unit          - Device ID
* \param [in] stage      -Stage identifier
* \param [in] dnx_qual      - DNX qualifier
* \param [out] qual_size_p  - Qualifier size in bits
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_dnx_qual_size(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_qual_t dnx_qual,
    uint32 *qual_size_p);

/**
* \brief
*  Maps DNX action to its size
* \param [in] unit          - Device ID
* \param [in] stage      -Stage identifier
* \param [in] dnx_action      - DNX action
* \param [out] action_size_p  - action size in bits
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_dnx_action_size(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_action_t dnx_action,
    unsigned int *action_size_p);

/**
* \brief
*  Maps DNX action to its size
* \param [in] unit          - Device ID
* \param [in] stage      - Stage identifier
* \param [in] dnx_action      - DNX action
* \param [out] action_signals  - Output array, which will store
*  all signals, which are relevant for the given action.
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_dnx_action_signals(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_action_t dnx_action,
    char *action_signals[DNX_DATA_MAX_FIELD_DIAG_NOF_SIGNALS_PER_ACTION]);

/**
* \brief
*  Finds the prefix and prefix size of a user defined action.
* \param [in] unit                - Device ID
* \param [in] stage               - Stage identifier.
* \param [in] dnx_action          - The user defined action.
* \param [out] prefix_p           - The prefix of the user defined action.
* \param [out] prefix_size_p      - The size in bits of the prefix of the user defined action.
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_dnx_action_prefix(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_action_t dnx_action,
    uint32 *prefix_p,
    unsigned int *prefix_size_p);

/**
* \brief
*  Finds the base action of a user defined action, both as DNX actions.
* \param [in] unit                - Device ID
* \param [in] stage               - Stage identifier
* \param [in] dnx_action          - The user defined action.
* \param [out] base_dnx_action_p  - The base action of the user defined action.
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_dnx_action_base_action(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_action_t dnx_action,
    dnx_field_action_t * base_dnx_action_p);

/**
* \brief
*  Finds the base action of a user defined action, both as BCM actions.
*  If action is not a user defined action, returns an invalid action.
* \param [in] unit                - Device ID
* \param [in] bcm_action          - The action.
* \param [out] base_bcm_action_p  - The base action of the user defined action or bcmFieldActionCount othereise.
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_bcm_action_base_action(
    int unit,
    bcm_field_action_t bcm_action,
    bcm_field_action_t * base_bcm_action_p);

/**
* \brief
*  Check if the action is the predefined void action or a user defined action based on the predefined void action.
*  Void actions are used to write data to payload without automatically performing a FES action on that data.
* \param [in] unit               - Device ID
* \param [in] stage              - Stage identifier
* \param [in] dnx_action         - DNX action
* \param [out] action_is_void_p  - Whether the action is a void action.
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_dnx_action_is_void(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_action_t dnx_action,
    int *action_is_void_p);

/**
* \brief
*  Get the FFC instructions table name for the required stage
* \param [in] unit              - Device ID
* \param [in] stage             - Stage identifier
* \param [in] ffc_type          - FFC type
* \param [out] ffc_type_field_p - output DBAL field of FFC type
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_ffc_type_to_field(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_ffc_type_e ffc_type,
    dbal_fields_e * ffc_type_field_p);

/**
* \brief
*  Get the FFC instructions table name for the required stage
* \param [in] unit              - Device ID
* \param [in] stage             - Stage identifier
* \param [out] ffc_table_name_p - output ffc instruction table name for current stage
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_stage_to_ffc_table(
    int unit,
    dnx_field_stage_e stage,
    dbal_tables_e * ffc_table_name_p);

/**
* \brief
*  Get the FFC instructions name for the required stage
* \param [in] unit              - Device ID
* \param [in] stage             - Stage identifier
* \param [out] ffc_instruction_name_p - output ffc instruction name for current stage
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_stage_to_ffc_instruction(
    int unit,
    dnx_field_stage_e stage,
    dbal_fields_e * ffc_instruction_name_p);
shr_error_e
/**
* \brief
*  Get the ctx_id dbal field name for the required stage
* \param [in] unit              - Device ID
* \param [in] stage             - Stage identifier
* \param [out] dbal_ctx_id      - output ctx_id dbal name for current stage
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
    dnx_field_map_ctx_id_to_field(
    int unit,
    dnx_field_stage_e stage,
    dbal_fields_e * dbal_ctx_id);

/**
* \brief
*  Get the key_field dbal field name for the required stage
* \param [in] unit              - Device ID
* \param [in] stage             - Stage identifier
* \param [out] dbal_key         - output key_field dbal name for current stage
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_key_to_field(
    int unit,
    dnx_field_stage_e stage,
    dbal_fields_e * dbal_key);

/**
* \brief
*  Returns the lookup_enabler DBAL table according to the given stage.
* \param [in] unit        - Device ID
* \param [in] stage - The stage of the table we want to get
* \param [out] table_id - Table ID for lookup enable DBAL table per given stage
* \return
*   shr_error_e             - Error Type
* \remark
*   * None
* \see
*   * dnx_field_key_lookup_change_state
*/
shr_error_e dnx_field_map_lookup_dbal_table_get(
    int unit,
    dnx_field_stage_e stage,
    dbal_tables_e * table_id);

/**
* \brief
*  Returns the invalid action id per given stage.
* \param [in] unit        - Device ID
* \param [in] stage - The stage of the table we want to get
* \param [out] dnx_action_p - pointer to max dnx_action
* \return
*   shr_error_e             - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_get_max_dnx_action(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_action_t * dnx_action_p);

/**
* \brief
*  Returns the invalid action id per given stage.
* \param [in] unit        - Device ID
* \param [in] stage - The stage of the table we want to get
* \param [out] dnx_action_p - pointer to illegal dnx_action
* \return
*   shr_error_e             - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_get_invalid_dnx_action(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_action_t * dnx_action_p);

/**
* \brief
*  Returns the invalid action type per given stage.
* \param [in] unit        - Device ID
* \param [in] dnx_stage - The stage of the table we want to get
* \param [out] action_type_p - pointer to action type invalid
* \return
*   shr_error_e             - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_get_invalid_action_type(
    int unit,
    dnx_field_stage_e dnx_stage,
    dnx_field_action_type_t * action_type_p);

/**
* \brief
*  Returns the invalidate next action type per given stage.
* \param [in] unit        - Device ID
* \param [in] dnx_stage - The stage of the table we want to get
* \param [out] action_type_p - pointer to action type invalidate next
* \return
*   shr_error_e             - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_get_invalidate_next_action_type(
    int unit,
    dnx_field_stage_e dnx_stage,
    dnx_field_action_type_t * action_type_p);

/**
* \brief
*  Retrieve the metadata DNX qualifier that is mapped to a certain field ID for a field stage.
* \param [in] unit          - Device ID
* \param [in] stage         - The stage of the table we want to get
* \param [in] field_id      - The field ID used by the DNX action.
* \param [out] dnx_qual_p   - pointer to the metadata DNX qualifier
* \return
*   shr_error_e             - Error Type
* \remark
*   * Note that the procedure only searches for metadata qualifiers. other qualifier classes do not change per stage.
* \see
*   * None
*/
shr_error_e dnx_field_map_field_id_dnx_qual(
    int unit,
    dnx_field_stage_e stage,
    dbal_fields_e field_id,
    dnx_field_qual_t * dnx_qual_p);

/**
* \brief
*  Get a BCM qualifier based on its name.
* \param [in] unit          - Device ID
* \param [in] name          - The qualifier's name. Number of elements DBAL_MAX_STRING_LENGTH.
* \param [out] bcm_qual_p   - pointer to BCM qualifier. Return bcmFieldQualifyCount if none found.
* \return
*   shr_error_e             - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_name_to_qual(
    int unit,
    char name[DBAL_MAX_STRING_LENGTH],
    bcm_field_qualify_t * bcm_qual_p);

/**
* \brief
*  Get a BCM action based on its name.
* \param [in] unit          - Device ID
* \param [in] name          - The action's name. Number of elements DBAL_MAX_STRING_LENGTH.
* \param [in] nof_actions   - The number of actions returned for the name in bcm_action.
* \param [out] bcm_action   - Array with DNX_FIELD_ACTION_MAX_ACTION_PER_VM elements.
*                             List of DNX actions used for the name.
* \return
*   shr_error_e             - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_name_to_action(
    int unit,
    char name[DBAL_MAX_STRING_LENGTH],
    int *nof_actions,
    bcm_field_action_t bcm_action[DNX_FIELD_ACTION_MAX_ACTION_PER_VM]);

/**
* \brief
*  Retrieve the DNX action that is mapped to a certain field ID for a field stage.
* \param [in] unit          - Device ID
* \param [in] stage         - The stage of the table we want to get
* \param [in] field_id      - The field ID used by the DNX action.
* \param [out] dnx_action_p - pointer to the DNX action
* \return
*   shr_error_e             - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_field_id_dnx_action(
    int unit,
    dnx_field_stage_e stage,
    dbal_fields_e field_id,
    dnx_field_action_t * dnx_action_p);

/**
* \brief
*  Maps the DNX qualifier to its offset.
* \param [in] unit            - Device ID
* \param [in] stage           -Stage identifier
* \param [in] dnx_qual        - Qualifier type to check (can be predefined or user-defined/Dataqual)
* \param [out] offset_p       - True if the qual is based on ConstZero
* \return
*   shr_error_e - Error Type
* \remark
*   * User defined qulifiers don't have any offset. As we don't have a definition of an illegal offset, we return 0.
* \see
*   * None
*/
shr_error_e dnx_field_map_dnx_qual_offset(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_qual_t dnx_qual,
    int *offset_p);

/**
* \brief
*  Maps the DNX qualifier to its offset.
* \param [in] unit            - Device ID
* \param [in] stage           - Stage identifier
* \param [in] dnx_qual        - Qualifier type to check (can be predefined or user-defined/Dataqual)
* \param [out] signals_p       - Output array, which will store
*  all signals and 'from' 'to' information, which are relevant for the given qualifier.
* \return
*   shr_error_e - Error Type
* \remark
*   * User defined qulifiers don't have any offset. As we don't have a definition of an illegal offset, we return 0.
* \see
*   * None
*/
shr_error_e dnx_field_map_dnx_qual_signals(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_qual_t dnx_qual,
    dnx_field_map_qual_signal_info_t * signals_p);

/**
* \brief
*  Maps BCM field stage to DNX field Stage
* \param [in] unit           - Device Id
* \param [in] bcm_stage      - BCM field stage
* \param [out] field_stage_p  - The mapped DNX field stage
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_stage_bcm_to_dnx(
    int unit,
    bcm_field_stage_t bcm_stage,
    dnx_field_stage_e * field_stage_p);

/**
* \brief
*  Maps DNX field stage to BCM field stage
* \param [in] unit         - Device Id
* \param [in] stage  - DNX field Stage
* \param [out] bcm_stage_p  - The mapped BCM field stage
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_stage_dnx_to_bcm(
    int unit,
    dnx_field_stage_e stage,
    bcm_field_stage_t * bcm_stage_p);

/**
* \brief
*  Maps BCM field group mode to DNX field group type
* \param [in] unit           - Device Id
* \param [in] bcm_fg_type      - BCM field group mode
* \param [out] dnx_fg_type_p  - The mapped DNX field group type
* \return
*   shr_error_e - Error Type
* \remark
*   * Used by (for example) bcm_dnx_field_group_add
* \see
*   * None
*/
shr_error_e dnx_field_map_group_type_bcm_to_dnx(
    int unit,
    bcm_field_group_type_t bcm_fg_type,
    dnx_field_group_type_e * dnx_fg_type_p);

/**
* \brief
*  Maps DNX field group type to BCM field group mode
* \param [in] unit           - Device Id
* \param [in] dnx_fg_type      - DNX field group type
* \param [out] bcm_fg_type_p   - The mapped BCM field group mode
* \return
*   shr_error_e - Error Type
* \remark
*   * Used by (for example) bcm_dnx_field_group_info_get
* \see
*   * None
*/
shr_error_e dnx_field_map_group_type_dnx_to_bcm(
    int unit,
    dnx_field_group_type_e dnx_fg_type,
    bcm_field_group_type_t * bcm_fg_type_p);

/**
* \brief
*  Maps BCM tcam bank allocation mode to DNX bcm allocation mode
* \param [in] unit                      - Device Id
* \param [in] bcm_bank_allocation_mode  - BCM bank allocation mode
* \param [out] dnx_bank_allocation_mode - DNX bank allocation mode
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_bank_allocation_mode_bcm_to_dnx(
    int unit,
    bcm_field_tcam_bank_allocation_mode_t bcm_bank_allocation_mode,
    dnx_field_tcam_bank_allocation_mode_e * dnx_bank_allocation_mode);

/**
* \brief
*  Maps DNX tcam bank allocation mode to BCM bcm allocation mode
* \param [in] unit                      - Device Id
* \param [in] dnx_bank_allocation_mode  - DNX bank allocation mode
* \param [out] bcm_bank_allocation_mode_p - BCM bank allocation mode
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_bank_allocation_mode_dnx_to_bcm(
    int unit,
    dnx_field_tcam_bank_allocation_mode_e dnx_bank_allocation_mode,
    bcm_field_tcam_bank_allocation_mode_t * bcm_bank_allocation_mode_p);

/**
* \brief
*  Maps BCM field context compare type to
*  DNX field context compare mode
* \param [in] unit -
*  Device Id
* \param [in] bcm_context_compare_type -
*  BCM field context compare type
* \param [out] dnx_context_compare_mode_p -
*  The mapped DNX field context compare mode
* \return
*   shr_error_e - Error Type
* \remark
*   * Used by (for example) bcm_dnx_field_context_create
* \see
*   * None
*/
shr_error_e dnx_field_map_context_compare_type_bcm_to_dnx(
    int unit,
    bcm_field_context_compare_type_t bcm_context_compare_type,
    dnx_field_context_compare_mode_e * dnx_context_compare_mode_p);

/**
* \brief
*  Maps DNX field context compare mode to
*  BCM field context compare type
* \param [in] unit -
*  Device Id
* \param [in] dnx_context_compare_mode -
*  DNX field context compare mode
* \param [out] bcm_context_compare_type_p -
*  The mapped BCM field context compare type
* \return
*   shr_error_e - Error Type
* \remark
*   * Used by (for example) bcm_dnx_field_context_mode_get
* \see
*   * None
*/
shr_error_e dnx_field_map_context_compare_type_dnx_to_bcm(
    int unit,
    dnx_field_context_compare_mode_e dnx_context_compare_mode,
    bcm_field_context_compare_type_t * bcm_context_compare_type_p);

/**
* \brief
*  Maps BCM layer type to
*  DNX layer type
* \param [in] unit -
*  Device Id
* \param [in] bcm_layer_type -
*  BCM layer type
* \param [out] dnx_layer_type -
*  The mapped DNX layer type
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_layer_type_bcm_to_dnx(
    int unit,
    bcm_field_layer_type_t bcm_layer_type,
    dbal_enum_value_field_layer_types_e * dnx_layer_type);

/**
* \brief
*  Maps BCM tunnel type to
*  DNX tunnel type
* \param [in] unit -
*  Device Id
* \param [in] flags for conversion
* \param [in] core - Identifier of core.
* \param [in] bcm_data -
*  BCM tunnel type
* \param [out] dnx_data -
*  The mapped DNX tunnel type
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_convert_tunnel_type(
    int unit,
    uint32 flags,
    int core,
    uint32 *bcm_data,
    uint32 *dnx_data);
/**
* \brief
*  Maps DNX layer type to
*  BCM layer type
* \param [in] unit -
*  Device Id
* \param [in] flags for conversion
* \param [in] core - Identifier of core.
* \param [in] bcm_data -
*  BCM layer type
* \param [out] dnx_data -
*  The mapped DNX layer type
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_convert_forwarding_context(
    int unit,
    uint32 flags,
    int core,
    uint32 *bcm_data,
    uint32 *dnx_data);

/**
* \brief
*  Maps DNX ACE context value to
*  BCM ACE context value
* \param [in] unit -
*  Device Id
* \param [in] flags for conversion
* \param [in] core - Identifier of core.
* \param [in] bcm_data -
*  BCM ACE context value
* \param [out] dnx_data -
*  The mapped DNX ACE context value
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_convert_ace_context(
    int unit,
    uint32 flags,
    int core,
    uint32 *bcm_data,
    uint32 *dnx_data);

/**
* \brief
*  Maps BCM layer type to
*  DNX layer type
* \param [in] unit -
*  Device Id
* \param [in] dnx_layer_type -
*  DNX layer type
* \param [out] bcm_layer_type_p -
*  The mapped BCM layer type
* \return
*   shr_error_e - Error Type
* \remark
*   * Used by (for example) dnx_field_presel_data_dnx_to_bcm_convert
* \see
*   * None
*/
shr_error_e dnx_field_map_layer_type_dnx_to_bcm(
    int unit,
    dbal_enum_value_field_layer_types_e dnx_layer_type,
    bcm_field_layer_type_t * bcm_layer_type_p);

/**
* \brief
*  Maps DNX Vlan format to
*  BCM vlan format
* \param [in] unit -
*  Device Id
* \param [in] dnx_vlan_format -
*  DNX vlan format
* \param [out] bcm_vlan_format_p -
*  The mapped BCM vlan format
* \return
*   shr_error_e - Error Type
* \remark
*   * Used by (for example) dnx_field_presel_data_dnx_to_bcm_convert
* \see
*   * None
*/
shr_error_e dnx_field_map_vlan_format_dnx_to_bcm(
    int unit,
    dbal_enum_value_field_incoming_tag_structure_e dnx_vlan_format,
    uint32 *bcm_vlan_format_p);

/**
* \brief
*  Maps BCM qual input type to
*  DNX qual input type
* \param [in] unit -
*  Device Id
* \param [in] dnx_input_type -
*  DNX qual input type
* \param [out] bcm_input_type_p -
*  The mapped BCM qual input type
* \return
*   shr_error_e - Error Type
* \see
*   * None
*/
shr_error_e dnx_field_map_qual_input_type_dnx_to_bcm(
    int unit,
    dnx_field_input_type_e dnx_input_type,
    bcm_field_input_types_t * bcm_input_type_p);

/**
* \brief
*  Maps DNX qual input type to
*  BCM qual input type
* \param [in] unit -
*  Device Id
* \param [in] bcm_input_type -
*  BCM qual input type
* \param [out] dnx_input_type_p -
*  The mapped DNX qual input type
* \return
*   shr_error_e - Error Type
* \see
*   * None
*/
shr_error_e dnx_field_map_qual_input_type_bcm_to_dnx(
    int unit,
    bcm_field_input_types_t bcm_input_type,
    dnx_field_input_type_e * dnx_input_type_p);
/**
* \brief
*  Maps BCM compare id input type to
*  DNX compare ID type
* \param [in] unit -
*  Device Id
* \param [in] compare_id -
*  BCM compare ID
* \param [out] dnx_compare_id_p -
*  The mapped DNX compare Id
* \return
*   shr_error_e - Error Type
* \remark
*   * Used by (for example) bcm_dnx_field_group_context_attach
* \see
*   * None
*/
shr_error_e dnx_field_map_compare_id_bcm_to_dnx(
    int unit,
    int compare_id,
    dnx_field_group_compare_id_e * dnx_compare_id_p);

/**
* \brief
*       Maps BCM context param set to dbal parameters
* \param [in] unit - Device Id
* \param [in] bcm_stage - bcm stage id
* \param [in] context_id - context id
  \param [in] bcm_context_param_set_p - pointer to structure containing all details for context parameter setting
  \param [out] field_dbal_entry_p - pointer to the structure that should be filled by the routine
* \return
*   shr_error_e - Error Type
* \remark
*   * Used by (for example) bcm_dnx_field_context_param_set
* \see
*   * None
*/
shr_error_e dnx_field_map_context_param_bcm_to_dnx(
    int unit,
    bcm_field_stage_t bcm_stage,
    dnx_field_context_t context_id,
    bcm_field_context_param_info_t * bcm_context_param_set_p,
    dnx_field_dbal_entry_t * field_dbal_entry_p);

/**
* \brief
*  Maps BCM FEM extraction output source type to
*  DNX FEM bit format.
* \param [in] unit -
*  Device Id
* \param [in] bcm_fem_ext_output_src_type -
*  BCM FEM extraction output source type.
* \param [out] dnx_fem_bit_format_p -
*  The mapped DNX FEM bit format.
* \return
*   shr_error_e - Error Type
* \remark
*   * Used by (for example) bcm_dnx_field_fem_action_add()
* \see
*   * None
*/
shr_error_e dnx_field_map_fem_ext_output_src_type_bcm_to_dnx(
    int unit,
    bcm_field_fem_extraction_output_source_type_t bcm_fem_ext_output_src_type,
    dnx_field_fem_bit_format_e * dnx_fem_bit_format_p);

/**
* \brief
*  Maps DNX FEM bit format to
*  BCM FEM extraction output source type.
* \param [in] unit -
*  Device Id
* \param [in] dnx_fem_bit_format -
*  DNX FEM bit format.
* \param [out] bcm_fem_ext_output_src_type_p -
*  The mapped BCM FEM extraction output source type.
* \return
*   shr_error_e - Error Type
* \remark
*   * Used by (for example) bcm_dnx_field_fem_action_info_get()
* \see
*   * None
*/
shr_error_e dnx_field_map_fem_ext_output_src_type_dnx_to_bcm(
    int unit,
    dnx_field_fem_bit_format_e dnx_fem_bit_format,
    bcm_field_fem_extraction_output_source_type_t * bcm_fem_ext_output_src_type_p);

/**
* \brief
*  Maps BCM Hash Function to DBAL hash function ENUMS
* \param [in] unit              - Device Id.
* \param [in] bcm_hash_func     - BCM Hash Function Enum.
* \param [out] dbal_hash_func_p - DBAL Hash Function Enum.
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_hash_func_bcm_to_dbal(
    int unit,
    bcm_field_context_hash_function_t bcm_hash_func,
    dbal_enum_value_field_context_hash_function_e * dbal_hash_func_p);

/**
* \brief
*  Maps DBAL Hash Function to BCM hash function ENUMS
* \param [in] unit              - Device Id.
* \param [in] dbal_hash_func - DBAL Hash Function Enum.
* \param [out] bcm_hash_func_p     - BCM Hash Function Enum.
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_hash_func_dbal_to_bcm(
    int unit,
    dbal_enum_value_field_context_hash_function_e dbal_hash_func,
    bcm_field_context_hash_function_t * bcm_hash_func_p);

/**
* \brief
*  Maps BCM Hahsing LB key to DBAL Hashing LB key ENUMS
* \param [in] unit                - Device Id.
* \param [in] bcm_hash_lb_key     - BCM Hashing LB key Enum.
* \param [out] dbal_hash_lb_key_p - DBAL Hashing LB key Enum.
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_hash_lb_key_bcm_to_dbal(
    int unit,
    bcm_field_context_hash_action_key_t bcm_hash_lb_key,
    dbal_enum_value_field_field_hash_lb_key_e * dbal_hash_lb_key_p);

/**
* \brief
*  Maps DBAL Hahsing LB key to BCM Hashing LB key ENUMS
* \param [in] unit                - Device Id.
* \param [in] dbal_hash_lb_key - DBAL Hashing LB key Enum.
* \param [out] bcm_hash_lb_key_p     - BCM Hashing LB key Enum.
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_hash_lb_key_dbal_to_bcm(
    int unit,
    dbal_enum_value_field_field_hash_lb_key_e dbal_hash_lb_key,
    bcm_field_context_hash_action_key_t * bcm_hash_lb_key_p);

/**
* \brief
*  Maps BCM Hash Action to DNX Hash Action ENUMS
* \param [in] unit                 - Device Id.
* \param [in] bcm_hash_action      - BCM Hash Action Enum.
* \param [out] dbal_hash_action_p  - DBAL Hash Action Enum.
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_hash_action_bcm_to_dbal(
    int unit,
    bcm_field_context_hash_action_value_t bcm_hash_action,
    dbal_enum_value_field_hash_action_e * dbal_hash_action_p);

/**
* \brief
*  Maps DBAL Hash Action to BCM Hash Action ENUMS
* \param [in] unit                - Device Id.
* \param [in] dbal_hash_action    - DBAL Hash Action Enum.
* \param [out] bcm_hash_action_p  - BCM Hash Action Enum.
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_hash_action_dbal_to_bcm(
    int unit,
    dbal_enum_value_field_hash_action_e dbal_hash_action,
    bcm_field_context_hash_action_value_t * bcm_hash_action_p);

/**
* \brief
*  Maps CRC Select Action to DBAL CRC Select ENUMS
* \param [in] unit                - Device Id.
* \param [in] bcm_crc_select      - BCM CRC Select Enum.
* \param [out] dbal_crc_select_p  - DBAL CRC Select Enum.
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_crc_select_bcm_to_dbal(
    int unit,
    bcm_field_crc_select_t bcm_crc_select,
    dbal_enum_value_field_crc_select_e * dbal_crc_select_p);

/**
* \brief
*  Maps DBAL CRC Select to BCM CRC Select ENUMS
* \param [in] unit                - Device Id.
* \param [in] dbal_crc_select     - DBAL CRC Select Enum.
* \param [out] bcm_crc_select_p   - BCM CRC Select Enum.
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_crc_select_dbal_to_bcm(
    int unit,
    dbal_enum_value_field_crc_select_e dbal_crc_select,
    bcm_field_crc_select_t * bcm_crc_select_p);

/**
* \brief
*  Maps BCM range info to DNX range info without printing an error message if not found.
* \param [in] unit -
*  Device Id
* \param [in] bcm_range_type -
*  BCM range type
* \param [out] dnx_range_type_p -
*  The mapped DNX range type
* \return
*   shr_error_e - Error Type
* \remark
*   * Used by (for example) bcm_dnx_field_range_set
* \see
*   * None
*/
shr_error_e dnx_field_map_range_type_bcm_to_dnx_int(
    int unit,
    bcm_field_range_type_t bcm_range_type,
    dnx_field_range_type_e * dnx_range_type_p);

/**
* \brief
*  Maps BCM range info to
*  DNX range info
* \param [in] unit -
*  Device Id
* \param [in] bcm_range_type -
*  BCM range type
* \param [out] dnx_range_type_p -
*  The mapped DNX range type
* \return
*   shr_error_e - Error Type
* \remark
*   * Used by (for example) bcm_dnx_field_range_set
* \see
*   * None
*/
shr_error_e dnx_field_map_range_type_bcm_to_dnx(
    int unit,
    bcm_field_range_type_t bcm_range_type,
    dnx_field_range_type_e * dnx_range_type_p);
/**
* \brief
*  Maps DNX range info to
*  BCM range info.
* \param [in] unit -
*  Device Id
* \param [in] dnx_range_type -
*  DNX range type
* \param [out] bcm_range_type_p -
*  The mapped BCM range tpe
* \return
*   shr_error_e - Error Type
* \remark
*   * Used by (for example) bcm_dnx_field_range_info_get
* \see
*   * None
*/
shr_error_e dnx_field_map_range_type_dnx_to_bcm(
    int unit,
    dnx_field_range_type_e dnx_range_type,
    bcm_field_range_type_t * bcm_range_type_p);

/**
* \brief
*  Provides mapped information about a range type for legacy range types
* \param [in] unit      - Device Id.
* \param [in] field_stage - The Field stage.
* \param [in] dnx_range_type    - The range type
* \param [out] range_type_info_p - The information about the range type.
* \return
*   shr_error_e - Error Type
* \see
*   * None
*/
shr_error_e dnx_field_map_range_type_info_legacy(
    int unit,
    dnx_field_stage_e field_stage,
    dnx_field_range_type_e dnx_range_type,
    dnx_field_map_range_type_info_t * range_type_info_p);

/**
* \brief
*  Maps Apptype (BCM ID) to OPCODE ID (DNX ID). Does not print an error if no such Apptype found,
*  just returns E_NOT_FOUND.
* \param [in] unit     - Device Id
* \param [in] app_type - AppType
* \param [out] opcode_id_p - KBP OPCODE ID
* \return
*   shr_error_e - Error Type
* \remark
* \see
*   * None
*/
shr_error_e dnx_field_map_apptype_to_opcode_bcm_to_dnx_int(
    int unit,
    bcm_field_AppType_t app_type,
    dbal_enum_value_field_kbp_fwd_opcode_e * opcode_id_p);

/**
* \brief
*  Maps Apptype (BCM ID) to OPCODE ID (DNX ID)
* \param [in] unit     - Device Id
* \param [in] app_type - AppType
* \param [out] opcode_id_p - KBP OPCODE ID
* \return
*   shr_error_e - Error Type
* \remark
* \see
*   * None
*/
shr_error_e dnx_field_map_apptype_to_opcode_bcm_to_dnx(
    int unit,
    bcm_field_AppType_t app_type,
    dbal_enum_value_field_kbp_fwd_opcode_e * opcode_id_p);

/**
* \brief
*  Maps OPCODE ID (DNX ID) to Apptype (BCM ID).
* \param [in] unit     - Device Id
* \param [in] opcode_id - KBP OPCODE ID
* \param [out] app_type_p - AppType
* \return
*   shr_error_e - Error Type
* \remark
* \see
*   * None
*/
shr_error_e dnx_field_map_opcode_to_apptype_dnx_to_bcm(
    int unit,
    dbal_enum_value_field_kbp_fwd_opcode_e opcode_id,
    bcm_field_AppType_t * app_type_p);

/**
* \brief        Get the CS profile for a certain opcode.
* \param [in] unit     - Device Id
* \param [in] opcode_id - KBP OPCODE ID
* \param [out] cs_profile_id_p - FWD context profile Id
* \return
*   shr_error_e - Error Type
* \remark
* \see
*   * None
*/
shr_error_e dnx_field_map_opcode_to_profile_get(
    int unit,
    dbal_enum_value_field_kbp_fwd_opcode_e opcode_id,
    uint32 *cs_profile_id_p);

/**
* \brief        Get the CS profile for a certain Apptype.
* \param [in] unit     - Device Id
* \param [in] app_type - KBP Apptype
* \param [out] cs_profile_id_p - FWD context profile Id
* \return
*   shr_error_e - Error Type
* \remark
* \see
*   * None
*/
shr_error_e dnx_field_map_apptype_to_profile_get(
    int unit,
    bcm_field_AppType_t app_type,
    uint32 *cs_profile_id_p);

/**
* \brief        Get the Apptype that uses a certain CS profile
* \param [in] unit     - Device Id
* \param [in] cs_profile_id - FWD context profile Id
* \param [out] app_type_p - KBP Apptype
* \return
*   shr_error_e - Error Type
* \remark
* \see
*   * None
*/
shr_error_e dnx_field_map_profile_to_apptype_get(
    int unit,
    uint32 cs_profile_id,
    bcm_field_AppType_t * app_type_p);

/**
* \brief        Get the FWD and ACL contexts used by and Apptype
* \param [in] unit     - Device Id
* \param [in] apptype - The Apptype
* \param [out] nof_contexts_p - The number of FWD context used by the apptype.
* \param [out] fwd_contexts - The FWD contexts used by the apptype.
*                             An array with DNX_DATA_MAX_FIELD_KBP_MAX_FWD_CONTEXT_NUM_FOR_ONE_APPTYPE elements.
* \param [out] acl_contexts - The ACL context corresponding to each FWD context.
*                             An array with DNX_DATA_MAX_FIELD_KBP_MAX_FWD_CONTEXT_NUM_FOR_ONE_APPTYPE elements.
* \return
*   shr_error_e - Error Type
* \remark
* \see
*   * None
*/
shr_error_e dnx_field_map_apptype_to_fwd_contexts(
    int unit,
    bcm_field_AppType_t apptype,
    int *nof_contexts_p,
    dnx_field_context_t fwd_contexts[DNX_DATA_MAX_FIELD_KBP_MAX_FWD_CONTEXT_NUM_FOR_ONE_APPTYPE],
    dnx_field_context_t acl_contexts[DNX_DATA_MAX_FIELD_KBP_MAX_FWD_CONTEXT_NUM_FOR_ONE_APPTYPE]);

/**
* \brief        Get the type of a port profile.
* \param [in] unit     - Device Id
* \param [in] bcm_port_class - The BCM class of port profile
* \param [out] port_profile_type_p - The DNX type of port profile class
* \return
*   shr_error_e - Error Type
* \remark
* \see
*   * None
*/
shr_error_e dnx_field_map_port_profile_type_get(
    int unit,
    bcm_port_class_t bcm_port_class,
    dnx_field_port_porfile_type_e * port_profile_type_p);

/**
* \brief        Get the properties of a port profile. Only relevant to port types that relate to a TM/PP port.
* \param [in] unit     - Device Id
* \param [in] bcm_port_class - The BCM class of port profile
* \param [out] port_profile_info_p - Information regarding the port profile mapping.
* \return
*   shr_error_e - Error Type
* \remark
* \see
*   * None
*/
shr_error_e dnx_field_map_port_profile_info_get(
    int unit,
    bcm_port_class_t bcm_port_class,
    dnx_field_map_port_profile_info_t * port_profile_info_p);

/**
* \brief  Get the DBAL table ID for the given BCM PP APP DB
* \param [in] unit     - Device Id
* \param [in] bcm_pp_app - The BCM PP APP DB
* \param [out] dbal_table_id_p - The DBAL table ID for the given PP APP DB
* \return
*   shr_error_e - Error Type
* \remark
* \see
*   * None
*/
shr_error_e dnx_field_map_pp_app_dbal_table_get(
    int unit,
    bcm_field_app_db_t bcm_pp_app,
    dbal_tables_e * dbal_table_id_p);

/**
 * \brief  Get the placement of the state table key (or if is is being accressd by ACR).
 * \param [in] unit     - Device Id
 * \param [out] use_acr_p - If TRUE, state table is accress by the state table actions and not by any key.
 * \param [out] stage_p - If use_acr_p is FALSE, the stage from which the state tabke is accessed.
 * \param [out] key_id_p - If use_acr_p is FALSE, the key from which the state tabke is accessed.
 * \param [out] lsb_on_key_p - If use_acr_p is FALSE, the lsb on the key where the state table key is read from.
 * \return
 *   shr_error_e - Error Type
 * \remark
 * \see
 *   * None
 */
shr_error_e dnx_field_map_state_table_source_get(
    int unit,
    int *use_acr_p,
    dnx_field_stage_e * stage_p,
    dbal_enum_value_field_field_key_e * key_id_p,
    int *lsb_on_key_p);

/**
* \brief
*  Get the Key-Id for a given compare pair,
*  First pair gets F and G keys,
*  Second pair gets H and I keys
* \param [in] unit   - Device id
* \param [in] compare_pair  - First/Second Pair
* \param [out] key_id_1_p  - F or H according to First/Second pair
* \param [out] key_id_2_p  - G or I according to First/Second pair
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_compare_key_id_get(
    int unit,
    dnx_field_context_compare_mode_pair_e compare_pair,
    dnx_field_key_id_t *key_id_1_p,
    dnx_field_key_id_t *key_id_2_p);

/**
* \brief
*  Get the Key-Id used for Hash capability of a context.
* \param [in] unit       - Device id
* \param [out] key_id_p  - The key/keys used by Compare.
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_hash_key_id_get(
    int unit,
    dnx_field_key_id_t *key_id_p);

/**
* \brief
*  Get the Key-Id used for State Table capability of a context.
* \param [in] unit       - Device id
* \param [out] key_id_p  - The key/keys used by State table
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_state_table_key_id_get(
    int unit,
    dnx_field_key_id_t *key_id_p);

/* } */
#endif
