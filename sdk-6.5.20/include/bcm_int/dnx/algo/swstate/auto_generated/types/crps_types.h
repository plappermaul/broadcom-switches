/** \file algo/swstate/auto_generated/types/crps_types.h
 *
 * sw state types (structs/enums/typedefs)
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */
/*
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#ifndef __CRPS_TYPES_H__
#define __CRPS_TYPES_H__

#include <soc/dnxc/swstate/dnxc_sw_state_h_includes.h>
#include <bcm_int/dnx/algo/res_mngr/res_mngr.h>
#include <bcm_int/dnx/algo/res_mngr/res_mngr_internal.h>
#include <include/bcm/stat.h>
#include <include/soc/dnx/dnx_data/auto_generated/dnx_data_max_crps.h>
/*
 * STRUCTs
 */

/**
 * defines the eviction conditional configuration
 */
typedef struct {
    /**
     * defines the source data type
     */
    bcm_stat_eviction_conditional_source_t condition_source_select;
    /**
     * defines the source user data
     */
    uint64 condition_user_data;
    /**
     * define the qualifier type
     */
    bcm_stat_eviction_conditional_qual_t qualifier;
    /**
     * define the actions
     */
    uint32 action_flags;
    /**
     * is conditional eviction enable
     */
    int enable;
} dnx_eviction_conditional_t;

/**
 * defines the engine eviction configuration
 */
typedef struct {
    /**
     * defines the eviction type (internal host or external)
     */
    bcm_eviction_destination_type_t eviction_type;
    /**
     * defines the record eviction format
     */
    bcm_eviction_record_format_t record_format;
    /**
     * id which is added for each eviction record
     */
    int eviction_event_id;
    /**
     * sequential timer value
     */
    uint32 sequential_timer_value;
    /**
     * select which dma fifo to use for the eviction
     */
    int dma_fifo;
    /**
     * select whether eviction is enabled/disabled
     */
    int eviction_algorithmic_disable;
    /**
     * conditional eviction config
     */
    dnx_eviction_conditional_t conditional;
} dnx_engine_eviction_t;

/**
 * set of parameters unique for each type
 */
typedef struct {
    /**
     * defines if the type has admission for the database as configured in API.
     */
    uint32 valid;
    /**
     * Counter offset for the type which is add in the counter mapping process, as configured in the API
     */
    uint32 offset;
    /**
     * start range
     */
    int start;
    /**
     * end range
     */
    int end;
} dnx_type_config_t;

/**
 * defines the engine interface configuration
 */
typedef struct {
    /**
     * next engine id (-1 for none). the start range of the next engine id will concatante to the current engine
     */
    int next_engine_id;
    /**
     * prev engine id (-1 for none). (this is not API parameter)
     */
    int prev_engine_id;
    /**
     * identify of the database that engine belong to
     */
    int database_id;
    /**
     * defines the engine mode configuration
     */
    bcm_stat_counter_interface_type_t src_type;
    /**
     * Select between different commands per source types
     */
    int command_id;
    /**
     * defines the counter format and the arithmetic operation
     */
    bcm_stat_counter_format_type_t format;
    /**
     * defines the size of the counter set (group size)
     */
    int counter_set_size;
    /**
     * type valid as configure in the hw. (Not all types valid in API, is valid in HW, it depends on the range)
     */
    int type_hw_valid[BCM_STAT_MAX_NUMBER_OF_OBJECT_TYPES];
} dnx_engine_interface_info_t;

/**
 * defines if engine input and output enable
 */
typedef struct {
    /**
     * enable input data to the engine
     */
    int counting_enable;
    /**
     * enable eviction/output data from the engine
     */
    int eviction_enable;
} dnx_engine_enablers_t;

/**
 * logical-object-id range admmited to an engine
 */
typedef struct {
    /**
     * first logical-object-id that is admmited for an engine.
     */
    uint32 logical_object_id_first;
    /**
     * last logical-object-id that is admmited for an engine.
     */
    uint32 logical_object_id_last;
} dnx_engine_log_obj_id_range_t;

/**
 * database which holds the engine configuration
 */
typedef struct {
    /**
     * indicates if the engine memory is used for meter or for counter.
     */
    int used_for_meter;
    /**
     * the configuration started, completed when config_done=TRUE
     */
    int config_started;
    /**
     * indicates that configuration is done.
     */
    int config_done;
    /**
     * input and output engine enable
     */
    dnx_engine_enablers_t enablers;
    /**
     * engine interface config
     */
    dnx_engine_interface_info_t interface;
    /**
     * eviction config
     */
    dnx_engine_eviction_t eviction;
    /**
     * logical-object-id range admmited to an engine
     */
    dnx_engine_log_obj_id_range_t log_obj_id_range;
    /**
     * SW cache counter memory. each HW counter has 2 SW counters
     */
    uint64* counter;
} dnx_engine_info_t;

/**
 * information per database that cannot be saved per engine
 */
typedef struct {
    /**
     * holds the base engine per database.
     */
    int base_engine;
    /**
     * information about the source types (range, valid) as configured in the interface set API.
     */
    dnx_type_config_t type[BCM_STAT_MAX_NUMBER_OF_OBJECT_TYPES];
} dnx_database_info_t;

/**
 * CRPS DB per unit
 */
typedef struct {
    /**
     * engine config. array of [core][engine_id]
     */
    dnx_engine_info_t** proc;
    /**
     * is BG thread enabled (updated SOC property or API)
     */
    int bg_thread_enable;
    /**
     * array that holds per database, information that unique to the database and cannot be per engine (array [nof_cores][nof_databases=nof_engines]
     */
    dnx_database_info_t** database;
    /**
     * holds crps databse allocation manager
     */
    dnx_algo_res_t* database_res;
} dnx_crps_db_t;


#endif /* __CRPS_TYPES_H__ */
