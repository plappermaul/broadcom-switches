/** \file algo/swstate/auto_generated/types/dnx_algo_field_key_alloc_types.h
 *
 * sw state types (structs/enums/typedefs)
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */
/*
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#ifndef __DNX_ALGO_FIELD_KEY_ALLOC_TYPES_H__
#define __DNX_ALGO_FIELD_KEY_ALLOC_TYPES_H__

#include <soc/dnxc/swstate/dnxc_sw_state_h_includes.h>
#include <bcm_int/dnx/algo/res_mngr/res_mngr.h>
#include <bcm_int/dnx/algo/res_mngr/res_mngr_internal.h>
#include <soc/dnx/swstate/auto_generated/types/dnx_field_types.h>
#include <soc/dnx/swstate/auto_generated/types/dnx_field_key_types.h>
/*
 * MACROs
 */

/**
 * Index of MSB half within 'half-key's in one standard (single) key (160 bits).
 * Key is, then, assumed to be: MSB (80 bits), LSB (80 bits)
 */
#define DNX_FIELD_KEY_INDEX_OF_MSB_HALF 0

/**
 * Number of 'half-key's in one standard (single) key (160 bits)
 */
#define DNX_FIELD_KEY_NUM_HALVES_IN_KEY (DNX_DATA_MAX_FIELD_TCAM_KEY_SIZE_SINGLE/DNX_DATA_MAX_FIELD_TCAM_KEY_SIZE_HALF)

/*
 * ENUMs
 */

/**
 * Describes occupation state for each of the half-keys available on each stage.
 * All keys are assumed to be 160 bits long (double is 320) and occupation may be:
 * MSB 80, LSB 80, all, MSB of double, LSB of double.
 * When more than one half key is required (e.g., 160 bits) then each half-key is marked by its specific
 * location value (e.g., 'DNX_FIELD_KEY_OCCUPY_SINGLE_MSB,DNX_FIELD_KEY_OCCUPY_SINGLE_SECOND'
 * Initially, all half-keys are marked 'DNX_FIELD_KEY_OCCUPY_NONE'.
 */
typedef enum {
    /**
     * Invalid occupation state
     */
    DNX_FIELD_KEY_OCCUPY_INVALID = -1,
    DNX_FIELD_KEY_OCCUPY_FIRST = 0,
    /**
     * Half-key is free (not occupied)
     */
    DNX_FIELD_KEY_OCCUPY_NONE = DNX_FIELD_KEY_OCCUPY_FIRST,
    /**
     * Occupying first (MSB) 80 bits
     */
    DNX_FIELD_KEY_OCCUPY_MSB_HALF,
    /**
     * Occupying second (LSB) 80 bits
     */
    DNX_FIELD_KEY_OCCUPY_LSB_HALF,
    /**
     * Occupying first 80 (MSB) of a standard 160 bits key
     */
    DNX_FIELD_KEY_OCCUPY_SINGLE_MSB,
    /**
     * Occupying second 80 (LSB) of a standard 160 bits key
     */
    DNX_FIELD_KEY_OCCUPY_SINGLE_LSB,
    /**
     * Occupying first 80 (MSB) of the first (MSB) 160 bits out of a 320 bits key
     */
    DNX_FIELD_KEY_OCCUPY_DOUBLE_FIRST_HALF,
    /**
     * Occupying second 80 (LSB) of the first (MSB) 160 bits out of a 320 bits key
     */
    DNX_FIELD_KEY_OCCUPY_DOUBLE_SECOND_HALF,
    /**
     * Occupying first 80 (MSB) of the second (LSB) 160 bits out of a 320 bits key
     */
    DNX_FIELD_KEY_OCCUPY_DOUBLE_THIRD_HALF,
    /**
     * Occupying second 80 (LSB) of the second (LSB) 160 bits out of a 320 bits key
     */
    DNX_FIELD_KEY_OCCUPY_DOUBLE_FOURTH_HALF,
    /**
     * Number of types in dnx_field_key_occupy_e
     */
    DNX_FIELD_KEY_OCCUPY_NOF
} dnx_field_key_half_occupation_state_e;

/*
 * STRUCTs
 */

/**
 * Holds info regarding availability of keys per stage (dnx_field_stage_e) per
 * field group type (dnx_field_group_type_e).
 */
typedef struct {
    /**
     * Indicates whether this structure contains meaningful info (non-zero) or not (zero).
     */
    uint8 structure_is_valid;
    /**
     * Number of keys available for this stage and field group type.
     */
    uint8 nof_available_keys;
    /**
     * Indicates the first key that is available for this group type.
     * Uint8 is used here, to save swstate space by the implied type is dbal_enum_value_field_field_key_e
     */
    uint8 first_available_key;
    /**
     * Indicates whether this (stage,field_group_type) combination supports allocation of a few
     * bit-ranges on the same half-key (as opposed to allocation of a full half key). This property
     * comes in addition to the standard allocation which is in units of full half keys.The two
     * allocation methods live together, side by side. If this flag is 'zero' then allocation can
     * only be done in units of 'full half key'
     */
    uint8 supports_bitmap_allocation;
} dnx_field_key_alloc_instruction_t;

/**
 * Holds info regarding availability of keys on all field group types (dnx_field_group_type_e).
 */
typedef struct {
    /**
     * Information on availability of keys per field group type.
     */
    dnx_field_key_alloc_instruction_t keys_availability_group_info[DNX_FIELD_GROUP_TYPE_NOF];
    /**
     * Number of keys available for this stage.
     */
    uint8 nof_available_keys_on_stage;
    /**
     * Indicates the first key that is available for this stage.
     * 'uint8' is used here, to save swstate space, but the implied
     * type is dbal_enum_value_field_field_key_e
     */
    uint8 first_available_key_on_stage;
} dnx_field_key_alloc_group_instruction_t;

/**
 * Holds info regarding availability of keys on all stages (dnx_field_stage_e).
 */
typedef struct {
    /**
     * Information on availability of keys per stage.
     */
    dnx_field_key_alloc_group_instruction_t keys_availability_stage_info[DNX_FIELD_STAGE_NOF];
} dnx_field_key_alloc_stage_instruction_info_t;

/**
 * Descriptor of a single range of bits which has been
 * allocated to a specific context,stage,'field group type'. See dnx_field_key_alloc_detail_t.
 */
typedef struct {
    /**
     * Number of bits assigned to this range. If set to '0' then this whole structure has NO meaningful info
     */
    uint8 bit_range_size;
    /**
     * This variable is of type 'dnx_field_group_type_e' and is set to 'uint8' to save memory space.
     * This is the 'field group type' under which rules this bit-range was allocated.
     */
    uint8 fg_type;
} __ATTRIBUTE_PACKED__ dnx_field_key_bit_range_detail_t;

/**
 * Holds info regarding state of a single allocated half-key.
 */
typedef struct {
    /**
     * Indication on whether specified half-key is in use. If it is then enum indicates how it is occupied.
     */
    dnx_field_key_half_occupation_state_e key_occupation_state;
    /**
     * Indication: If key is in use then on which type of 'field group' specified key is in use.
     */
    dnx_field_group_type_e key_field_group_type;
    /**
     * Identifier of the allocation of this key. All half-keys of a specific allocation are
     * assigned the same identifier. Identifiers are assigned consecutice numbers in a
     * cyclic manner (cycle = 2^32). Only meaningful if 'key_occupation_state' is not
     * 'DNX_FIELD_KEY_OCCUPY_NONE'
     * All items following this one are only relevant if the 'bit-range' feature is enabled.
     */
    uint32 key_allocation_id;
    /**
     * This is a bitmap representing all bits on the corresponding full key. It is only meaningful for entries
     * corresponding to half keys on the LS side so, on 'key_occupation' array, they are only 'created' on odd
     * indices (key_occupation[1], key_occupation[3], key_occupation[5], ...
     * The first bits, on this occ array, correspond to the LS bits of the key (LS half key) while the last
     * bits correspond to the MS bits of the key (MS half key).
     */
    dnx_algo_res_t* bit_range_key_occ_bmp;
    /**
     * This is an up-down counter of the number of bit-ranges allocated on this half key. For LS half keys, when
     * this number is 'zero' then it indicates that no bits are allocated on this half key and it is 'free'. However,
     * for MS half keys, this number may be zero but some bits may be occupied by a bit-range which has been allocated
     * on the LS half key. This can be because the first allocated bit was on the LS half key but number of bits required
     * resulted in occupying some bits on the MS half key. Therefore, it is best, in all cases, to use the
     * 'is_half_key_range_free' flag.
     */
    uint8 num_bit_ranges;
    /**
     * This is a flag indicating whether this half key is free from any allocated bit-ranges. If non-zero then this
     * half key is considered 'occupied' for 'full half key' allocation.
     */
    uint8 is_half_key_range_occupied;
    /**
     * This array is allocated only for half keys which have the 'bit-range' feature enabled. Each element represents a single
     * bit and contains info on the number of the bits allocated starting at that point plus the corresponding  triplet
     * 'field group type,stage,context'. Most items are used for diisplay/debug purposes. The number of bits is used mainly to free the
     * 'allocation requestor' from remembering the allocated size but also for consistency checking (since the swstate-occ does not
     * remember the number of bits assigned on 'allocate_several'.
     */
    dnx_field_key_bit_range_detail_t* bit_range_desc;
} __ATTRIBUTE_PACKED__ dnx_field_key_alloc_detail_t;

/**
 * Holds info regarding allocation state of all keys of a specific stage.
 */
typedef struct {
    /**
     * Dimension of this array is the number of half keys assigned to the using stage. Each element
     * contains indication on whether specified half-key is in use. If it is then 'key_occupation_state'
     * indicates how it is occupied and 'key_field_group_type' indicates for which type of field group it
     * has been allocated.
     * Index is half-key identifier as per dbal_enum_value_field_field_key_e. For example, for IPMF1, it
     * is DBAL_NOF_ENUM_FIELD_KEY_VALUES.
     */
    dnx_field_key_alloc_detail_t* key_occupation;
    /**
     * Number of elements on the array pointed by 'key_occupation'
     */
    uint8 key_occupation_nof;
} __ATTRIBUTE_PACKED__ dnx_field_key_alloc_info_t;

/**
 * Holds info regarding allocated keys per each stage per each PMF program.
 */
typedef struct {
    /**
     * Information on occupied half-keys per stage per PMF program.
     * First index is stage identifier as per dnx_field_stage_e. Second index is PMF program
     */
    dnx_field_key_alloc_info_t key_stage_prog_occupation[DNX_FIELD_STAGE_NOF][DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_NOF_CONTEXTS];
    /**
     * Information on whether specified key, on specified stage, is under a filed group type that supports.
     * The bit-range feature. If this is the case, then all other field group types should mark half-key allocation,
     * for that key, also on the bit-range system
     */
    uint8 key_on_stage_supports_bitmap_allocation[DNX_FIELD_STAGE_NOF][DBAL_NOF_ENUM_FIELD_KEY_VALUES];
} dnx_field_key_in_stage_alloc_info_t;

/**
 * Contains information about allocated keys per stage per PMF program
 */
typedef struct {
    /**
     * Structure containing arrays holding info regarding allocated keys per each stage per each PMF program
     */
    dnx_field_key_in_stage_alloc_info_t keys_per_stage;
    /**
     * Structure containing arrays holding info regarding initial availability
     * of keys per each stage per each field group type
     */
    dnx_field_key_alloc_stage_instruction_info_t keys_availability;
} dnx_field_keys_per_stage_allocation_t;


#endif /* __DNX_ALGO_FIELD_KEY_ALLOC_TYPES_H__ */
