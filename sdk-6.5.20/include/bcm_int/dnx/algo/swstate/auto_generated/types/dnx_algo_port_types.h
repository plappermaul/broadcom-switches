/** \file algo/swstate/auto_generated/types/dnx_algo_port_types.h
 *
 * sw state types (structs/enums/typedefs)
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */
/*
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#ifndef __DNX_ALGO_PORT_TYPES_H__
#define __DNX_ALGO_PORT_TYPES_H__

#include <soc/dnxc/swstate/dnxc_sw_state_h_includes.h>
#include <bcm/port.h>
#include <bcm_int/dnx/algo/port/algo_port_mgmt.h>
#include <bcm_int/dnx/algo/res_mngr/res_mngr.h>
#include <bcm_int/dnx/algo/res_mngr/res_mngr_internal.h>
#include <bcm_int/dnx/algo/template_mngr/template_mngr.h>
#include <bcm_int/dnx/algo/template_mngr/template_mngr_internal.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_nif.h>
#include <soc/dnxc/swstate/types/sw_state_bitmap.h>
#include <soc/dnxc/swstate/types/sw_state_pbmp.h>
/*
 * ENUMs
 */

/**
 * An enum that represents port state
 */
typedef enum {
    /**
     * Invalid (free) port
     */
    DNX_ALGO_PORT_STATE_INVALID = 0,
    /**
     * In the proccess of adding a port
     */
    DNX_ALGO_PORT_STATE_ADDED = 1,
    /**
     * In the proccess of removing a port
     */
    DNX_ALGO_PORT_STATE_REMOVED = 2,
    /**
     * Valid port
     */
    DNX_ALGO_PORT_STATE_VALID = 3
} dnx_algo_port_state_e;

/*
 * STRUCTs
 */

/**
 * handle with two keys
 */
typedef struct {
    /**
     * First key
     */
    int h0;
    /**
     * Second key
     */
    int h1;
} dnx_algo_port_db_2d_handle_t;

/**
 * General info about port
 */
typedef struct {
    /**
     * Port state - see dnx_algo_port_state_e
     */
    dnx_algo_port_state_e state;
    /**
     * Port info
     */
    dnx_algo_port_info_s info;
    /**
     * port inteface
     */
    bcm_port_if_t interface_type;
    /**
     * inteface offset
     */
    int interface_offset;
    /**
     * NIF DB handle - first phy
     */
    int nif_handle;
    /**
     * TM DB  2d handle
     */
    dnx_algo_port_db_2d_handle_t tm_handle;
    /**
     * SCH DB  2d handle
     */
    dnx_algo_port_db_2d_handle_t sch_handle;
    /**
     * SCH Interface
     */
    dnx_algo_port_db_2d_handle_t sch_if_handle;
    /**
     * PP DB  2d handle
     */
    dnx_algo_port_db_2d_handle_t pp_handle;
    /**
     * ILKN DB handle - ilkn id
     */
    int ilkn_handle;
    /**
     * FLEXE client DB handle - client index
     */
    int flexe_client_handle;
    /**
     * FLEXE MAC DB handle - client index
     */
    int flexe_mac_handle;
    /**
     * FLEXE SAR DB handle - client index
     */
    int flexe_sar_handle;
    /**
     * FLEXE phy DB - PHY ID
     */
    int flexe_phy_handle;
    /**
     * TM interface DB handle - interface id
     */
    dnx_algo_port_db_2d_handle_t tm_interface_handle;
    /**
     * Interface DB handle - interface id
     */
    dnx_algo_port_db_2d_handle_t interface_handle;
    /**
     * handle to fabric DB - link-id
     */
    int fabric_handle;
    /**
     * channel id
     */
    int channel;
} dnx_algo_port_db_logical_t;

/**
 * General NIF info about port
 */
typedef struct {
    /**
     * Boolean, is nif valid.
     */
    int valid;
    /**
     * phy bitmap
     */
    bcm_pbmp_t phys;
    /**
     * first phy used by nif port
     */
    int first_phy;
    /**
     * master logical port
     */
    bcm_port_t master_logical_port;
    /**
     * port logical FIFOs information
     */
    dnx_algo_port_rmc_info_t logical_fifos[BCM_PORT_MAX_NOF_PRIORITY_GROUPS];
    /**
     * Boolean, is latch down indication
     */
    int latch_down;
    /**
     * Boolean, original link training state stored before setting loopback
     */
    int loopback_original_link_training;
    /**
     * original phy lane configuration stored before setting loopback
     */
    int loopback_original_phy_lane_config;
} dnx_algo_port_db_nif_t;

/**
 * General PP info about port
 */
typedef struct {
    /**
     * How may ports point to this PP DB. 0, if pp port is invalid .
     */
    int ref_count;
    /**
     * pp port
     */
    uint32 pp_port;
    /**
     * core id of pp port
     */
    bcm_core_t core;
    /**
     * Boolean, true if the PP port is allocated for LAG
     */
    int is_lag;
    /**
     * If the PP port is allocated for LAG holds the LAG ID
     */
    bcm_trunk_t lag_id;
    /**
     * master logical port
     */
    bcm_port_t master_logical_port;
    /**
     * header mode
     */
    dnx_algo_port_header_mode_e header_mode;
    /**
     * Boolean, is ingress llvp valid.
     */
    int ingress_llvp_profile_valid;
    /**
     * Boolean, is ingress llvp valid.
     */
    int egress_llvp_profile_valid;
} dnx_algo_port_db_pp_t;

/**
 * General TM info about port
 */
typedef struct {
    /**
     * How may ports point to this TM DB. 0, if TM port is invalid .
     */
    int ref_count;
    /**
     * tm port
     */
    uint32 tm_port;
    /**
     * core id of tm port
     */
    bcm_core_t core;
    /**
     * egress base queue pair
     */
    int base_q_pair;
    /**
     * flags to indicate port channelized application
     */
    uint32 port_app_flags;
    /**
     * number of port priorities
     */
    int priorities;
    /**
     * tdm mode of tm port
     */
    dnx_algo_port_tdm_mode_e tdm_mode;
    /**
     * BCM_SWITCH_PORT_HEADER_TYPE_X macros
     */
    int header_type_in;
    /**
     * BCM_SWITCH_PORT_HEADER_TYPE_X macros
     */
    int header_type_out;
    /**
     * master logical port
     */
    bcm_port_t master_logical_port;
} dnx_algo_port_db_tm_t;

/**
 * TM interface info
 */
typedef struct {
    /**
     * Boolean, is tm interface valid.
     */
    int valid;
    /**
     * A flag that added with the master port
     */
    int is_channelized;
    /**
     * interface works in interleaved mode in ingress
     */
    int is_ingress_interleave;
    /**
     * A flag that added with the master port
     */
    int is_egress_interleave;
    /**
     * egress interface id
     */
    int egr_if;
    /**
     * tdm mode of interface
     */
    dnx_algo_port_if_tdm_mode_e tdm_mode;
    /**
     * master logical port - represents tdm channels only
     */
    bcm_port_t master_tdm_logical_port;
    /**
     * master logical port - represents non_tdm channels only
     */
    bcm_port_t master_non_tdm_logical_port;
    /**
     * master logical port
     */
    bcm_port_t master_logical_port;
} dnx_algo_port_db_tm_interface_t;

/**
 * Interface info
 */
typedef struct {
    /**
     * Boolean, is tm interface valid.
     */
    int valid;
    /**
     * intrface core
     */
    bcm_core_t core;
    /**
     * Interface rate in Rx direction
     */
    int rx_speed;
    /**
     * Interface rate in tx direction
     */
    int tx_speed;
    /**
     * master logical port
     */
    bcm_port_t master_logical_port;
} dnx_algo_port_db_interface_t;

/**
 * Scheduler info
 */
typedef struct {
    /**
     * Boolean, is sch port valid.
     */
    int valid;
    /**
     * sch base hr id
     */
    int base_hr;
    /**
     * egr scheduler number priorities (HRs)
     */
    int sch_priorities;
    /**
     * master logical port
     */
    bcm_port_t master_logical_port;
} dnx_algo_port_db_sch_t;

/**
 * Scheduler interface_info
 */
typedef struct {
    /**
     * Boolean, is sch interface valid.
     */
    int valid;
    /**
     * scheduler interface id
     */
    int sch_if;
    /**
     * scheduler interface is in port priority propagation mode
     */
    int priority_propagation_enable;
    /**
     * master logical port
     */
    bcm_port_t master_logical_port;
} dnx_algo_port_db_sch_if_t;

/**
 * General fabric info about port
 */
typedef struct {
    /**
     * Boolean, is fabric link valid.
     */
    int valid;
    /**
     * fabric link id
     */
    int link;
    /**
     * master logical port
     */
    bcm_port_t master_logical_port;
    /**
     * link PRBS mode (PHY or MAC)
     */
    int prbs_mode;
    /**
     * fabric link rate
     */
    int speed;
    /**
     * Boolean, original link training state stored before setting loopback
     */
    int loopback_original_link_training;
    /**
     * original phy lane configuration stored before setting loopback
     */
    int loopback_original_phy_lane_config;
} dnx_algo_port_db_fabric_t;

/**
 * General ilkn info about port
 */
typedef struct {
    /**
     * Boolean, is ilkn id valid.
     */
    int valid;
    /**
     * master logical port
     */
    bcm_port_t master_logical_port;
    /**
     * How many segments the ILKN port takes
     */
    int nof_segments;
    /**
     * Boolean, is ilkn over fabric
     */
    int is_over_fabric;
    /**
     * Boolean, is interface allocated for ELK
     */
    int is_elk;
    /**
     * ILKN lanes bitmap (bits 0-23)
     */
    bcm_pbmp_t lanes;
    /**
     * Data HRF priority (Low, High)
     */
    bcm_port_nif_scheduler_t priority;
} dnx_algo_port_db_ilkn_t;

/**
 * General FLEXE client (Bus A) info about port
 */
typedef struct {
    /**
     * Boolean, is client_index valid.
     */
    int valid;
    /**
     * Bus A client index
     */
    int client_index;
    /**
     * Bus A client ID, used for Overhead
     */
    int client_id;
    /**
     * master logical port
     */
    bcm_port_t master_logical_port;
    /**
     * if the port is used for bypass channel
     */
    int is_bypass;
} dnx_algo_port_db_flexe_client_t;

/**
 * General FLEXE MAC (Bus B) info about port
 */
typedef struct {
    /**
     * Boolean, is ilkn id valid.
     */
    int valid;
    /**
     * master logical port
     */
    bcm_port_t master_logical_port;
    /**
     * Bus B client index
     */
    int client_index;
    /**
     * port logical FIFOs information
     */
    dnx_algo_port_rmc_info_t logical_fifos[DNX_DATA_MAX_NIF_FLEXE_PRIORITY_GROUPS_NOF];
    /**
     * Timeslots allocated for this port
     */
    SHR_BITDCL timeslot_bitmap[((DNX_DATA_MAX_NIF_FLEXE_NOF_MAC_TIMESLOTS)/SHR_BITWID)+1];
} dnx_algo_port_db_flexe_mac_t;

/**
 * General FLEXE SAR (Bus C) info about port
 */
typedef struct {
    /**
     * Boolean, is ilkn id valid.
     */
    int valid;
    /**
     * master logical port
     */
    bcm_port_t master_logical_port;
    /**
     * Bus C client index
     */
    int client_index;
    /**
     * Timeslots allocated for this port
     */
    SHR_BITDCL timeslot_bitmap[((DNX_DATA_MAX_NIF_FLEXE_NOF_SAR_TIMESLOTS)/SHR_BITWID)+1];
} dnx_algo_port_db_flexe_sar_t;

/**
 * General FLEXE phy info about port
 */
typedef struct {
    /**
     * Boolean, is ilkn id valid.
     */
    int valid;
    /**
     * master logical port
     */
    bcm_port_t master_logical_port;
    /**
     * The logical PHY ID required by FlexE spec.
     */
    int logical_phy_id;
    /**
     * FlexE core port that connects to the PCS of FlexE physical port
     */
    int core_port;
    /**
     * Base FlexE instance allocated for this PHY
     */
    uint8 instance_base;
    /**
     * Logical PHY bitmap allocated for this port
     */
    SHR_BITDCL lphy_bitmap[((DNX_DATA_MAX_NIF_FLEXE_NOF_FLEXE_LPHYS)/SHR_BITWID)+1];
} dnx_algo_port_db_flexe_phy_t;

/**
 * General data about algo port
 */
typedef struct {
    /**
     * dummy
     */
    int dummy;
} dnx_algo_port_db_general_t;

/**
 * FlexE DBs
 */
typedef struct {
    /**
     * FLEXE client (Bus A) info about port. Key is client index
     */
    dnx_algo_port_db_flexe_client_t* client;
    /**
     * FLEXE MAC (Bus B) info about port. Key is client index
     */
    dnx_algo_port_db_flexe_mac_t* mac;
    /**
     * FLEXE SAR (Bus C) info about port. Key is client index
     */
    dnx_algo_port_db_flexe_sar_t* sar;
    /**
     * FLEXE phy info about port. Key is first phy
     */
    dnx_algo_port_db_flexe_phy_t* phy;
} dnx_algo_port_db_flexe_t;

/**
 * prd info
 */
typedef struct {
    /**
     * prd port to profile map
     */
    uint32 port_to_profile_map;
} dnx_algo_prd_info_t;

/**
 * skip first header info
 */
typedef struct {
    /**
     * size of first header size to skip
     */
    uint32 first_header_size_to_skip;
    /**
     * port type - eth, ptch1, ptch2
     */
    uint32 port_type;
    /**
     * used for skpping first header size before ETH,PTCH1,PTCH2 header
     */
    uint32 is_before;
    /**
     * used for skpping first header size after PTCH1 header
     */
    uint32 is_after;
} dnx_algo_skip_first_header_info_t;

/**
 * DB for used by algo port
 */
typedef struct {
    /**
     * General data about algo port
     */
    dnx_algo_port_db_general_t general;
    /**
     * General info about port. key is logical port
     */
    dnx_algo_port_db_logical_t logical[SOC_MAX_NUM_PORTS];
    /**
     * General NIF info about port. Key is first phy
     */
    dnx_algo_port_db_nif_t* nif;
    /**
     * TM info about port. Per core X TM port. Keys are core X TM port
     */
    dnx_algo_port_db_tm_t** tm;
    /**
     * SCH info about port. Per core X base HR. Keys are core X base HR
     */
    dnx_algo_port_db_sch_t** sch;
    /**
     * PP info about port. Per core X PP port. Keys are core X PP port
     */
    dnx_algo_port_db_pp_t** pp;
    /**
     * PP PORT allcation manager
     */
    dnx_algo_res_t* pp_alloc;
    /**
     * ILKN info about port. Key is ILKN ID
     */
    dnx_algo_port_db_ilkn_t* ilkn;
    /**
     * FLEXE DBs
     */
    dnx_algo_port_db_flexe_t flexe;
    /**
     * Fabric info about port. Key is link ID
     */
    dnx_algo_port_db_fabric_t* fabric;
    /**
     * Info Port TM interface. Key is TM interface ID
     */
    dnx_algo_port_db_tm_interface_t** tm_interface;
    /**
     * Info Port interface. Key is Interface ID
     */
    dnx_algo_port_db_interface_t** interface;
    /**
     * Info of SCH interface. Key is Interface ID
     */
    dnx_algo_port_db_sch_if_t** sch_interface;
    /**
     * Profile data for skipping user defined first header size
     */
    dnx_algo_template_t skip_first_user_defined_header_size_profile_data;
    /**
     * PRD port to profile map. key is logical port
     */
    dnx_algo_prd_info_t prd[SOC_MAX_NUM_PORTS];
} dnx_algo_port_db_t;


#endif /* __DNX_ALGO_PORT_TYPES_H__ */
