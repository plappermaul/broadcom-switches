/*! \file template_mngr_internal.h
 * 
 * Internal DNX template manager APIs
 * This is an interface for the sw state layer, not to be used by developers.
 * 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */
#ifndef DNX_ALGO_TEMPLATE_MNGR_INTERNAL_H_INCLUDED
/*
 * {
 */
#define DNX_ALGO_TEMPLATE_MNGR_INTERNAL_H_INCLUDED

#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif


#include <soc/dnxc/swstate/sw_state_defs.h>
#include <bcm_int/dnx/algo/template_mngr/multi_set.h>
#include <soc/dnxc/swstate/dnxc_sw_state_plain.h>
#include <bcm_int/dnx/algo/template_mngr/template_manager_types.h>
#include <bcm_int/dnx/algo/template_mngr/template_mngr_callbacks.h>
#include <shared/shrextend/shrextend_debug.h>
#include <soc/dnxc/swstate/dnx_sw_state_pretty_dump.h>
/*
 * DEFINES 
 * { 
 */

/*
 * }
 */

extern const dnx_algo_template_advanced_alogrithm_cb_t
    Template_callbacks_map_sw[DNX_ALGO_TEMPLATE_ADVANCED_ALGORITHM_COUNT];

/**
 * This structure contains the information required for managing and verifying template use.
 * This data is taken from the dnx_algo_template_create call.
 */
typedef struct
{
    /*
     * Template name.
     */
    char name[DNX_ALGO_TEMPLATE_MNGR_MAX_NAME_LENGTH];
    /**
     * Flags used to create this template.
     */
    uint32 flags;
    /**
     * First profile id of the template.
     */
    int first_profile;
    /**
     * How many profiles are in the template.
     */
    int nof_profiles;
    /**
     * Maximum number of pointers to each profile.
     */
    int max_references;
    /**
     * Default profile for the template. To be used if flag DNX_ALGO_TEMPLATE_CREATE_USE_DEFAULT_PROFILE is set.
     */
    int default_profile;
    /**
     * Size of the template's data.
     */
    int data_size;
    /**
     * Advanced algorithm enum.
     */
    dnx_algo_template_advanced_algorithms_e advanced_algorithm;
    /**
     * If flag DNX_ALGO_TEMPLATE_CREATE_USE_DEFAULT_PROFILE is set, put here the data that it will contain.
     */
    DNX_SW_STATE_BUFF *default_data;
    /*
     * Multi set templates.
     */
    multi_set_t multi_set_template;
}  *dnx_algo_template_t;

/**
 * \brief Template information
 *
 * This structure contains the information that will be displayed with the dump command.
 *
 *  \see
 * dnx_algo_template_dump_info_get
 */
typedef struct
{
    /*
     *This structure contains the information required for creating a new template.
     */
    dnx_algo_template_create_data_t create_data;
    /*
     * *
     * *How many profiles are used in the template.
     */
    int nof_used_profiles;
    /*
     * *
     * *How many profiles are free in the template.
     */
    int nof_free_profiles;
} dnx_algo_template_dump_data_t;

/*
 * SW State wrapper MACROs, used by the autogenerated sw state layer
 */
#define DNX_ALGO_TEMP_MNGR_CREATE(module_id, algo_temp, data, extra_arguments, alloc_flags)\
        SHR_IF_ERR_EXIT(dnx_algo_template_create(unit, module_id, &algo_temp, data, extra_arguments, alloc_flags))

#define DNX_ALGO_TEMP_MNGR_DESTROY(module_id, algo_temp, extra_arguments)\
        SHR_IF_ERR_EXIT(dnx_algo_template_destroy(unit, module_id, &algo_temp, extra_arguments))

#define DNX_ALGO_TEMP_MNGR_ALLOCATE_SINGLE(module_id, algo_temp, flags, profile_data, extra_arguments, profile, first_reference)\
        SHR_IF_ERR_EXIT(dnx_algo_template_allocate(unit, module_id, algo_temp, flags, profile_data, \
                                                        extra_arguments, profile, first_reference))

#define DNX_ALGO_TEMP_MNGR_FREE_SINGLE(module_id, algo_temp, profile, last_reference)\
        SHR_IF_ERR_EXIT(dnx_algo_template_free(unit, module_id, algo_temp, profile, last_reference))

#define DNX_ALGO_TEMP_MNGR_EXCHANGE(module_id, algo_temp, flags, profile_data, old_profile,extra_arguments, new_profile, first_reference, last_reference)\
        SHR_IF_ERR_EXIT(dnx_algo_template_exchange(unit, module_id, algo_temp, flags, profile_data, old_profile, \
                        extra_arguments, new_profile, first_reference, last_reference))

#define DNX_ALGO_TEMP_MNGR_REPLACE_DATA(module_id, algo_temp, profile, new_profile_data)\
        SHR_IF_ERR_EXIT(dnx_algo_template_replace_data(unit, module_id, algo_temp, profile, new_profile_data))

#define DNX_ALGO_TEMP_MNGR_PROFILE_DATA_GET(module_id, algo_temp, profile, ref_count, profile_data)\
        SHR_IF_ERR_EXIT(dnx_algo_template_profile_data_get(unit, module_id, algo_temp, profile, ref_count, profile_data))

#define DNX_ALGO_TEMP_MNGR_PROFILE_GET(module_id, algo_temp, profile_data, profile)\
        SHR_IF_ERR_EXIT_NO_MSG(dnx_algo_template_profile_get(unit, module_id, algo_temp, profile_data, profile))

#define DNX_ALGO_TEMP_MNGR_CLEAR(module_id, algo_temp)\
        SHR_IF_ERR_EXIT(dnx_algo_template_clear(unit, module_id, algo_temp))

#define DNX_ALGO_TEMP_MNGR_FREE_ALL(module_id, algo_temp, profile)\
        SHR_IF_ERR_EXIT(dnx_algo_template_free_all(unit, module_id, algo_temp, profile))

#define DNX_ALGO_TEMP_MNGR_GET_NEXT(module_id, algo_temp, current_profile)\
        SHR_IF_ERR_EXIT(dnx_algo_template_get_next(unit, module_id, algo_temp, current_profile))

#define DNX_ALGO_TEMP_MNGR_DUMP_INFO_GET(module_id, algo_temp, info)\
        SHR_IF_ERR_EXIT(dnx_algo_template_dump_info_get(unit, module_id, algo_temp, info))

#define DNX_ALGO_TEMP_MNGR_PRINT(unit, module_id, algo_temp, print_cb)\
        SHR_IF_ERR_EXIT(dnx_algo_template_print(unit, module_id, algo_temp, print_cb))

#define DNX_ALGO_TEMP_MNGR_ADVANCED_ALGORITHM_INFO_SET(module_id, algo_temp, algorithm_info)\
        SHR_IF_ERR_EXIT(dnx_algo_template_advanced_algorithm_info_set\
                (unit, module_id, algo_temp, algorithm_info))

#define DNX_ALGO_TEMP_MNGR_ADVANCED_ALGORITHM_INFO_GET(module_id, algo_temp, algorithm_info)\
        SHR_IF_ERR_EXIT(dnx_algo_template_advanced_algorithm_info_get\
                (unit, module_id, algo_temp, algorithm_info))

/**
 * FUNCTIONS 
 * { 
 */
/**
* \brief
*   Create a new instance of template manager.
*
*
*    \param [in] unit - Relevant unit.
*    \param [in] module_id - Module ID.
*    \param [in] algo_temp - Template to be created.
*    \param [in] data - Pointed memory contains setup parameters required for the
*      creation of the template.
*    \param [in] extra_arguments - Pointer for extra arguments to be passed to the create function of an advanced algorithm.
*      Leave NULL if data->flags doesn't contain \ref DNX_ALGO_TEMPLATE_CREATE_USE_ADVANCED_ALGORITHM
*    \param [in] alloc_flags - SW state allocation flags.
*       This flags value is determend by the variable type (dnx data for example) of the additional variables specified in the xml
*   \return
*    \retval Zero if no error was detected
*    \retval Negative if error was detected.
*  \remark
*    None
*  \see
*    dnx_algo_template_create_data_t
*    dnx_algo_template_advanced_alogrithm_cb_t
*    shr_error_e
 */
shr_error_e dnx_algo_template_create(
    int unit,
    uint32 module_id,
    dnx_algo_template_t * algo_temp,
    dnx_algo_template_create_data_t * data,
    void *extra_arguments,
    uint32 alloc_flags);

/**
* \brief
*   Destroy an instance of template manager.
*
*
*    \param [in] unit - Relevant unit.
*    \param [in] module_id - Module ID.
*    \param [in] algo_temp - Template to be destroyed.
*    \param [in] extra_arguments - Pointed memory to hold extra arguemnts required for destroying this template. \n
*       The content of this pointer depends on the algorithm. It's the algorithm's \n
*       responsibility to verify it.
*       If the algorithm doesn't require extra arguemnts, this can be set to NULL.
*   \return
*    \retval Zero if no error was detected
*    \retval Negative if error was detected.
*  \remark
*    None
*  \see
*    dnx_algo_template_destroy_cb
*    dnx_algo_template_advanced_alogrithm_cb_t
*    dnx_algo_template_create
*    shr_error_e
*/
shr_error_e dnx_algo_template_destroy(
    int unit,
    uint32 module_id,
    dnx_algo_template_t * algo_temp,
    void *extra_arguments);

/**
* \brief
*   Allocate a reference to profile_data. If this is the first reference, the first_reference
*     indication output will be set to true.
*
*
*    \param [in] unit - Relevant unit.
*    \param [in] module_id - SW State Module ID.
*    \param [in] algo_temp - Template instance.
*    \param [in] flags - DNX_ALGO_TEMPLATE_ALLOCATE_* flags.
*    \param [in] profile_data - Pointer to memory holding template data to be saved to a profile.
*        Fill with the data to be saved.
*    \param [in] extra_arguments - Pointer to memory holding extra arguments to be passed to the allocation function of an advanced algorithm.
*      If no advanced algorithm is used, use NULL.
*    \param [in,out] profile - Pointer to place the allocated
*           profile.
*      \b As \b output - \n
*        Holds the allocated profile.
*      \b As \b input - \n
*        If flag \ref DNX_ALGO_TEMPLATE_ALLOCATE_WITH_ID is set, pass the profile to be allocated here.
*    \param [out] first_reference
*      Pointer to memory to load output into. \n
*        Will be filled with boolean indication of the profile's prior existence. \n
*   \return
*    \retval Zero if no error was detected
*    \retval Negative if error was detected.
*  \remark
*      If \ref DNX_ALGO_TEMPLATE_ALLOCATE_WITH_ID (WITH_ID) is set and the specified
*      profile is not yet allocated, this will allocate it and set its data to the
*      specified data.
*
*      If WITH_ID is set and the specified profile is allocated, this will first
*      verify that the new data is 'equal' to the existing data for the profile,
*      and: if so, will increment the reference count for the specified profile;
*      if not, will return _SHR_E_EXISTS.
*
*      If WITH_ID is not set, the manager will look for a in-use
*      profile whose data is 'equal' to the specified data.  If
*      it finds such a profile, it will increment the profile's
*      reference count and return it.  If it does not find such
*      a profile, it marks an unused profile as in use, sets
*      its reference count to 1, copies the data to the
*      profile's data, and returns this profile.  If there is no
*      matching in-use profile or free profile the manager will
*      return _SHR_E_RESOURCE.
*
*      Whether WITH_ID is provided or not, on success the int pointed to by the
*      is_allocated argument will be updated.  It will be set TRUE if the profile
*      was free before, and FALSE if the profile was already in use.  If the
*      value is TRUE, appropriate resources should be updated by the caller (such
*      as programming the data values to hardware registers).
*
*  \see
*    dnx_algo_template_create_data_t
*    dnx_algo_template_advanced_alogrithm_cb_t
*    shr_error_e
 */
shr_error_e dnx_algo_template_allocate(
    int unit,
    uint32 module_id,
    dnx_algo_template_t algo_temp,
    uint32 flags,
    void *profile_data,
    void *extra_arguments,
    int *profile,
    uint8 *first_reference);

/**
* \brief
*   This function frees one reference from old_profile, and add
*   one to new_profile.
*
*    \param [in] unit - Relevant unit.
*    \param [in] module_id - Module ID.
*    \param [in] algo_temp - Template instance.
*    \param [in] flags -
*      DNX_ALGO_TEMPLATE_ALLOCATE_* or DNX_ALGO_TEMPLATE_EXCHANGE_* flags. See remarks below.
*    \param [in] profile_data -
*      Pointer to memory holding template data to be saved to a profile. Not in use if IGNORE_DATA flag is set.
*      \b As \b input - \n
*        Fill with the data to be saved.
*    \param [in] old_profile -
*      One reference will be freed from this profile.
*    \param [in] extra_arguments -
*      Pointer to memory holding extra arguments to be passed to the allocation function of an advanced algorithm.
*      If no advanced algorithm is used, use NULL.
*    \param [in,out] new_profile -
*      Pointer to place the allocated profile.
*      \b As \b output - \n
*        Holds the allocated profile.
*      \b As \b input - \n
*        If flag \ref DNX_ALGO_TEMPLATE_ALLOCATE_WITH_ID is set, pass the profile to be allocated here.
*    \param [out] first_reference
*      Pointer to memory to load output into. \n
*      \b As \b output - \n
*        Will be filled with boolean indication of the new profile's prior existence. \n
*    \param [out] last_reference -
*      Pointer to memory to load output into. \n
*      \b As \b output - \n
*        Will be filled with boolean indication of whether it's the last reference to old_profile.
*   \return
*    \retval Zero if no error was detected
*    \retval Negative if error was detected.
*  \remark
*
*      Whether DNX_ALGO_TEMPLATE_ALLOCATE_WITH_ID is provided or not, if the allocation / update was successful,
*      the profile with ID provided in old_profile will be freed.  Note this only
*      happens if the selection of a new profile succeeds, so the old profile
*      should not be cleared if this function fails.
*      If old_profile wasn't allocated before, and the flag
*      DNX_ALGO_TEMPLATE_EXCHANGE_IGNORE_NOT_EXIST_OLD_TEMPLATE is not set,
*      then _SHR_E_PARAM will be returned. If the flag is set,
*      then a new reference will be allocated without deleting
*      the old one.
*
*      If DNX_ALGO_TEMPLATE_ALLOCATE_WITH_ID is set and the profile specified in *new_profile is not yet allocated,
*      this will allocate it and set its data to the specified data.
*
*      If DNX_ALGO_TEMPLATE_ALLOCATE_WITH_ID is clear, this procedure will look for a in-use profile whose data is
*      identical to profile_data.  If it finds such a profile, it will
*      increment that profile's reference count and return it. If it does not
*      find such a profile, it will allocate a new free profile.
*      If there is no 'equal' or free profile, _SHR_E_RESOURCE
*      is returned.
*
*
*      Whether WITH_ID is provided or not, on success the int pointed to by the
*      first_reference argument will be updated.  It will be set TRUE if the new
*      profile was free before, and FALSE if the new profile was already in use.
*      If the value is TRUE, appropriate resources should be updated by the caller
*      (such as programming the data values to hardware registers).
*
*      It is not valid to specify IGNORE_DATA without WITH_ID.
*  \see
*    dnx_algo_template_allocate
*    dnx_algo_template_free
*    shr_error_e
 */
shr_error_e dnx_algo_template_exchange(
    int unit,
    uint32 module_id,
    dnx_algo_template_t algo_temp,
    uint32 flags,
    const void *profile_data,
    int old_profile,
    const void *extra_arguments,
    int *new_profile,
    uint8 *first_reference,
    uint8 *last_reference);

/**
* \brief
*   Template manager API, which can replace a data pointer with new data.
*
*
*   \param [in] unit - Relevant unit.
*   \param [in] module_id - Module ID.
*   \param [in] algo_temp - Template instance.
*   \param [in] profile - The data for this profile will be replaced with the provided new data.
*   \param [in] new_profile_data - Pointer to memory holding template data to be saved to a profile. Not in use if IGNORE_DATA flag is set.
*   \return
*       \retval Zero if no error was detected
*       \retval Negative if error was detected.
*   \remark
*       None
*   \see
*    dnx_algo_template_allocate
*    dnx_algo_template_free
*    shr_error_e
 */

shr_error_e dnx_algo_template_replace_data(
    int unit,
    uint32 module_id,
    dnx_algo_template_t algo_temp,
    int profile,
    const void *new_profile_data);

/**
* \brief
*   Get the data pointed by a template's profile.
*
*    \param [in] unit - Relevant unit.
*    \param [in] module_id - Module ID.
*    \param [in] algo_temp - Template instance.
*    \param [in] profile - Profile to get the data from.
*    \param [in] ref_count - Pointer to memory to load output into. \n
*      \b As \b output - \n
*        Will be filled with number of refernces to this profile.
*        This can be set to NULL, if the user doesn't require ref_count as an output, but then
*          profile_data must not be NULL.
*    \param [in] profile_data -
*      Pointer to memory to load output into. \n
*      \b As \b output - \n
*        Will be filled with data stored in this profile.
*        This can be set to NULL, if the user doesn't require profile_data as an output, but then
*          ref_count must not be NULL.
*   \return
*    \retval Zero if no error was detected
*    \retval Negative if error was detected.
*  \remark
*    None
*  \see
*    dnx_algo_template_create_data_t
*    dnx_algo_template_advanced_alogrithm_cb_t
*    shr_error_e
 */
shr_error_e dnx_algo_template_profile_data_get(
    int unit,
    uint32 module_id,
    dnx_algo_template_t algo_temp,
    int profile,
    int *ref_count,
    void *profile_data);

/**
* \brief
*   Get a template's profile by given data.
*
*    \param [in] unit - Relevant unit.
*    \param [in] module_id - Module ID.
*    \param [in] algo_temp - Template instance.
*    \param [in] profile_data -
*      Pointer to memory for data to lookup. \n
*      \b As \b input - \n
*        Fill this with the data to find.
*    \param [in] profile -
*      Pointer to place the allocated profile.
*      \b As \b output - \n
*        Holds the profile that holds given data.
*   \return
*    \retval Zero if no error was detected
*    \retval Negative if error was detected.
*  \remark
*    None
*  \see
*    dnx_algo_template_create_data_t
*    dnx_algo_template_advanced_alogrithm_cb_t
*    shr_error_e
 */
shr_error_e dnx_algo_template_profile_get(
    int unit,
    uint32 module_id,
    dnx_algo_template_t algo_temp,
    const void *profile_data,
    int *profile);

/**
* \brief
*   Free a reference to a template profile.
*
*
*    \param [in] unit - Relevant unit.
*    \param [in] module_id - Module ID.
*    \param [in] algo_temp - Template instance.
*    \param [in] profile - Profile to be freed.
*    \param [in] last_reference - Pointer to memory to load output into. \n
*      \b As \b output - \n
*        Will be filled with boolean indication of whether it's the last reference to this profile.
*   \return
*    \retval Zero if no error was detected
*    \retval Negative if error was detected.
*  \remark
*    None
*  \see
*    dnx_algo_template_create_data_t
*    dnx_algo_template_advanced_alogrithm_cb_t
*    shr_error_e
 */
shr_error_e dnx_algo_template_free(
    int unit,
    uint32 module_id,
    dnx_algo_template_t algo_temp,
    int profile,
    uint8 *last_reference);

/**
* \brief
*   Free all reference to all profiles of this template.
*
*    \param [in] unit - Relevant unit.
*    \param [in] module_id - Module ID.
*    \param [in] algo_temp - Template instance.
*   \return
*     \retval Zero if no error was detected
*     \retval Negative if error was detected.
*  \remark
*    None
*  \see
*    dnx_algo_template_create_data_t
*    dnx_algo_template_advanced_alogrithm_cb_t
*    shr_error_e
 */
shr_error_e dnx_algo_template_clear(
    int unit,
    uint32 module_id,
    dnx_algo_template_t algo_temp);

/**
* \brief
*   Free all references to a profile.
*
*
*   \param [in] unit - Relevant unit.
*   \param [in] module_id - Module ID.
*   \param [in] algo_temp - Template instance.
*   \param [in] profile - All references, and the data, for this profile will be freed.
*   \return
*       \retval Zero if no error was detected
*       \retval Negative if error was detected.
*   \remark
*       None
*   \see
*    dnx_algo_template_free
 */
shr_error_e dnx_algo_template_free_all(
    int unit,
    uint32 module_id,
    dnx_algo_template_t algo_temp,
    int profile);

/**
 * \brief
 *      Given a template name and profile, returns the next allocated profile
 *      for this template.
 *      The returned profile will be equal to or greater than the given profile. It is the user's
 *      responsibility to update it between iterations.
 *      When there are no more allocated profiles, DNX_ALGO_TEMPLATE_ILLEGAL_PROFILE will be returned.
 *
 *  \param [in] unit - Relevant unit.
 *  \param [in] module_id - Module ID.
 *  \param [in] algo_temp - Template instance.
 *  \param [in,out] current_profile -
 *       \b As \b input - \n
 *       The profile to start searching for the next allocated profile from.
 *       \b As \b output - \n
 *       The next allocated profile. It will be >= from the
 *       profile given as input.
 *
 * \return
 *   shr_error_e
 *
 * \remark
 *      It is the user's responsibility to update the current_profile between iterations. This usually means
 *       giving it a ++.
 * \see
 *      None
 */
shr_error_e dnx_algo_template_get_next(
    int unit,
    uint32 module_id,
    dnx_algo_template_t algo_temp,
    int *current_profile);

/**
* \brief
*   Returns data for the relevant template.
*
*
*   \param [in] unit - Relevant unit.
*   \param [in] module_id - Module ID.
*   \param [in] algo_temp - Template instance.
*   \param [out] info -
*      Pointed memory to save the template info See \ref dnx_algo_template_dump_data_t
*  \return
*    \retval Zero if no error was detected
*    \retval Negative if error was detected. See \ref shr_error_e
*  \remark
*    None
*  \see
*    dnx_algo_res_dump_data_t
*    shr_error_e
 */
shr_error_e dnx_algo_template_dump_info_get(
    int unit,
    uint32 module_id,
    dnx_algo_template_t algo_temp,
    dnx_algo_template_dump_data_t * info);

/**
* \brief
*   Prints template data
*
*   \param [in] unit -  Relevant unit.
*   \param [in] module_id - Module ID.
*   \param [in] algo_temp - template.
*   \param [in] print_cb - Template print cb.
*  \return
*    \retval Zero if no error was detected
*    \retval Negative if error was detected. See \ref shr_error_e
*  \remark
*    None
*  \see
*    None
 */

int dnx_algo_template_print(
    int unit,
    uint32 module_id,
    dnx_algo_template_t * algo_temp,
    dnx_algo_template_print_data_cb print_cb);

/**
* \brief
*   Set advanced algorithm info.
*
*    \param [in] unit - Relevant unit.
*    \param [in] module_id - Module ID.
*    \param [in] algo_temp - Template.
*    \param [in] algorithm_info - algorithm info to be set
*  \return
*    shr_error_e - Error return value
*  \remark
*    None
*  \see
*    shr_error_e
 */
shr_error_e dnx_algo_template_advanced_algorithm_info_set(
    int unit,
    uint32 module_id,
    dnx_algo_template_t algo_temp,
    void *algorithm_info);

/**
* \brief
*   Get advanced algorithm info.
*
*    \param [in] unit - Relevant unit.
*    \param [in] module_id - Module ID.
*    \param [in] algo_temp - Template.
*    \param [out] algorithm_info - Pointer where the algorithm will be save.
*  \return
*    shr_error_e - Error return value
*  \remark
*    None
*  \see
*    shr_error_e
 */
shr_error_e dnx_algo_template_advanced_algorithm_info_get(
    int unit,
    uint32 module_id,
    dnx_algo_template_t algo_temp,
    void *algorithm_info);

/**
 * \brief
 *   Given a template name, return the callback of the print function printing this template.
 *   
 *  \par DIRECT INPUT:
 *    \param [in] name -
 *      Name used to create this template.
 *    \param [in] *print_cb-
 *        dnx_algo_template_print_data_cb pointer to memory to load output into. \n
 *      \b As \b output - \n
 *        Will be filled with the template's print callback (see above). \n
 *        If the template doesn't exist, will be filled with NULL.
 *  \par DIRECT OUTPUT:
 *    \retval Zero if no error was detected
 *    \retval Negative if error was detected. See \ref shr_error_e
 *  \par INDIRECT OUTPUT:
 *    \b *print_cb_index \n
 *     See DIRECT INPUT above
 *  \remark
 *    None
 *  \see
 *    dnx_algo_template_print_data_cb
 *    shr_error_e
 */
shr_error_e dnx_algo_template_print_callback_get(
    dnx_algo_template_name_t name,
    dnx_algo_template_print_data_cb * print_cb);

/**
 * \brief
 *   Adding a entry to the template map, by given template name and a callback of the print function.
 *  \param [in] template_name -
 *      Name used to create the template.
 *  \param [in] print_cb-
 *      dnx_algo_template_print_data_cb variable that needs to
 *      be added.
 *      \n
 *  \return
 *      BCM_E_NONE if successful
 *      BCM_E_* as appropriate otherwise
 *  \remark
 *      None
 *  \see
 *    dnx_algo_template_print_data_cb
 *    shr_error_e
 */
shr_error_e dnx_algo_template_test_print_cb_add(
    dnx_algo_template_name_t template_name,
    dnx_algo_template_print_data_cb print_cb);

/**
 * \brief
 *   Removing a entry from the template map, by given template name.
 *  \param [in] template_name -
 *      Name used to create this template.
 *  \return
 *      BCM_E_NONE if successful
 *      BCM_E_* as appropriate otherwise
 *  \remark
 *      None
 *  \see
 *    dnx_algo_template_print_data_cb
 *    shr_error_e
 */
shr_error_e dnx_algo_template_test_print_cb_remove(
    dnx_algo_template_name_t template_name);

/**
* \brief
*   Print an entry of the unit test data template. See
*       \ref dnx_algo_template_print_data_cb for more details.
*
*  \par DIRECT INPUT:
*    \param [in] unit -
*     Identifier of the device to access.
*    \param [in] data -
*      Pointer of the struct to be printed.
*      \b As \b input - \n
*       The pointer is expected to hold a struct of type template_data_t. \n
*       It's the user's responsibility to verify it beforehand.
*  \par INDIRECT INPUT:
*    \b *data \n
*     See DIRECT INPUT above
*  \par DIRECT OUTPUT:
*    None.
*  \par INDIRECT OUTPUT:
*      The default output stream.
*  \remark
*    None
*  \see
*    dnx_algo_template_print_data_cb
*    shr_error_e
 */
void dnx_algo_template_test_print_cb(
    int unit,
    const void *data);

/**
 * } 
 */

/*
 * Internal template manager tests print functions declarations. 
 * { 
 */

/*
 * }
 */

#endif /* DNX_ALGO_TEMPLATE_MNGR_INTERNAL_H_INCLUDED */
