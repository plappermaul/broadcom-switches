
/*
 *         
 * 
 * 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 *         
 *     
 * DO NOT EDIT THIS FILE!
 */

#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX family only!"
#endif /* BCM_DNX_SUPPORT */

#ifndef _IMB_H__H_
#define _IMB_H__H_

#include <soc/portmod/portmod.h>
#include <bcm/port.h>
#include <bcm/cosq.h>
#include <bcm_int/dnx/port/imb/imb_diag.h>
#include <bcm_int/dnx/cosq/ingress/cosq_ingress_port.h>
#include <soc/dnxc/dnxc_port.h>

/*!
 * @enum imb_dispatch_type_e
 * @brief Supported Drivers 
 */
typedef enum imb_dispatch_type_e
{
    imbDispatchTypeNone,
    imbDispatchTypeImb_cdu,
    imbDispatchTypeImb_clu,
    imbDispatchTypeImb_ile,
    imbDispatchTypeImb_ilu,
    imbDispatchTypeImb_feu,
    imbDispatchTypeImb_feu_phy,
    imbDispatchTypeImb_fabric,
    imbDispatchTypeCount
} imb_dispatch_type_t;

extern const enum_mapping_t imb_dispatch_type_t_mapping[];
/* imb_dispatch_type_t validation */
int imb_dispatch_type_t_validate(
    int unit,
    imb_dispatch_type_t imb_dispatch_type);

/*!
 * @struct imb_cdu_create_info_s
 * @brief CDU specific information required for IMB init. 
 */
typedef struct imb_cdu_create_info_s
{
    void *user_acc; /**< user access information to be passed to portmod layer. */
} imb_cdu_create_info_t;

/* imb_cdu_create_info_t initialization and validation */
int imb_cdu_create_info_t_validate(
    int unit,
    const imb_cdu_create_info_t * imb_cdu_create_info);
int imb_cdu_create_info_t_init(
    int unit,
    imb_cdu_create_info_t * imb_cdu_create_info);

/*!
 * @struct imb_clu_create_info_s
 * @brief CLU specific information required for IMB init. 
 */
typedef struct imb_clu_create_info_s
{
    void *user_acc; /**< user access information to be passed to portmod layer. */
} imb_clu_create_info_t;

/* imb_clu_create_info_t initialization and validation */
int imb_clu_create_info_t_validate(
    int unit,
    const imb_clu_create_info_t * imb_clu_create_info);
int imb_clu_create_info_t_init(
    int unit,
    imb_clu_create_info_t * imb_clu_create_info);

/*!
 * @struct imb_ile_create_info_s
 * @brief ILU specific information required for IMB init. 
 */
typedef struct imb_ile_create_info_s
{
    int stub; /**< temp stub until ILKN is implemented */
} imb_ile_create_info_t;

/* imb_ile_create_info_t initialization and validation */
int imb_ile_create_info_t_validate(
    int unit,
    const imb_ile_create_info_t * imb_ile_create_info);
int imb_ile_create_info_t_init(
    int unit,
    imb_ile_create_info_t * imb_ile_create_info);

/*!
 * @struct imb_feu_create_info_s
 * @brief FEU specific information required for IMB init. 
 */
typedef struct imb_feu_create_info_s
{
    int stub; /**< temp stub for FEU */
} imb_feu_create_info_t;

/* imb_feu_create_info_t initialization and validation */
int imb_feu_create_info_t_validate(
    int unit,
    const imb_feu_create_info_t * imb_feu_create_info);
int imb_feu_create_info_t_init(
    int unit,
    imb_feu_create_info_t * imb_feu_create_info);

/*!
 * @struct imb_feu_phy_create_info_s
 * @brief FEU_PHY specific information required for IMB init. 
 */
typedef struct imb_feu_phy_create_info_s
{
    int stub; /**< temp stub for FEU_PHY */
} imb_feu_phy_create_info_t;

/* imb_feu_phy_create_info_t initialization and validation */
int imb_feu_phy_create_info_t_validate(
    int unit,
    const imb_feu_phy_create_info_t * imb_feu_phy_create_info);
int imb_feu_phy_create_info_t_init(
    int unit,
    imb_feu_phy_create_info_t * imb_feu_phy_create_info);

/*!
 * @struct imb_fabric_create_info_s
 * @brief Fabric specific information required for IMB init. 
 */
typedef struct imb_fabric_create_info_s
{
    int stub; /**< temp stub until Fabric is implemented */
} imb_fabric_create_info_t;

/* imb_fabric_create_info_t initialization and validation */
int imb_fabric_create_info_t_validate(
    int unit,
    const imb_fabric_create_info_t * imb_fabric_create_info);
int imb_fabric_create_info_t_init(
    int unit,
    imb_fabric_create_info_t * imb_fabric_create_info);

typedef union imb_specific_create_info_u
{
    imb_cdu_create_info_t cdu;
    imb_clu_create_info_t clu;
    imb_ile_create_info_t ile;
    imb_feu_create_info_t feu;
    imb_feu_phy_create_info_t feu_phy;
    imb_fabric_create_info_t fabric;
} imb_specific_create_info_t;

/*!
 * @struct imb_create_info_s
 * @brief This struct contains the required information in order to add new IMB. 
 */
typedef struct imb_create_info_s
{
    imb_dispatch_type_t type; /**< IMB type */
    int inst_id; /**< instatnce number. The physical phys will be deducted from the instance id. */
    imb_specific_create_info_t imb_specific_info;
} imb_create_info_t;

/* imb_create_info_t initialization and validation */
int imb_create_info_t_validate(
    int unit,
    const imb_create_info_t * imb_create_info);
int imb_create_info_t_init(
    int unit,
    imb_create_info_t * imb_create_info);

#define IMB_PRD_PRIORITY_ALL (BCM_PORT_F_PRIORITY_0 | BCM_PORT_F_PRIORITY_1 | BCM_PORT_F_PRIORITY_2 | BCM_PORT_F_PRIORITY_3 | BCM_PORT_F_PRIORITY_TDM) /**< Abbriviation to set all PRD priorities */

/*! 
 * imb_init_all
 *
 * @brief Initialize all IMBs on the specified unit. 
 *
 * @param [in]  unit            - unit id
 */
int imb_init_all(
    int unit);

/*! 
 * imb_deinit_all
 *
 * @brief De-initialize all IMBs on the specified unit. 
 *
 * @param [in]  unit            - unit id
 */
int imb_deinit_all(
    int unit);

/*! 
 * imb_init
 *
 * @brief initialize an IMB. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  imb_info        - IMB information required for the IMB to initialize.
 * @param [out]  imb_specific_info   - IMB information to be initialized by the specific IMB type.
 */
int imb_init(
    int unit,
    const imb_create_info_t * imb_info,
    imb_specific_create_info_t * imb_specific_info);

/*! 
 * imb_deinit
 *
 * @brief De-initialize an existing IMB. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  imb_info        - IMB information required for the IMB to de-init
 * @param [out]  imb_specific_info   - IMB information to be deinitialized by the IMB type.
 */
int imb_deinit(
    int unit,
    const imb_create_info_t * imb_info,
    imb_specific_create_info_t * imb_specific_info);

/*! 
 * imb_port_pad_size_set
 *
 * @brief TX pad packets to the specified size. value less than 17 means pad is disabled.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - TX packet pad size
 */
int imb_port_pad_size_set(
    int unit,
    bcm_port_t port,
    int value);
/*! 
 * imb_port_pad_size_get
 *
 * @brief TX pad packets to the specified size. value less than 17 means pad is disabled.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - TX packet pad size
 */
int imb_port_pad_size_get(
    int unit,
    bcm_port_t port,
    int *value);

/*! 
 * @brief Port Add Flags 
 */
#define IMB_PORT_ADD_F_INIT_PASS1 0x1 /**< imb port add PASS1: init port until firmware load */
#define IMB_PORT_ADD_F_INIT_PASS2 0x2 /**< imb port add PASS2: resume init port after firmware load */
#define IMB_PORT_ADD_F_SKIP_SETTINGS 0x4 /**< Skip IMB port settings */

#define IMB_PORT_ADD_F_INIT_PASS1_SET(flags) (flags |= IMB_PORT_ADD_F_INIT_PASS1)
#define IMB_PORT_ADD_F_INIT_PASS2_SET(flags) (flags |= IMB_PORT_ADD_F_INIT_PASS2)
#define IMB_PORT_ADD_F_SKIP_SETTINGS_SET(flags) (flags |= IMB_PORT_ADD_F_SKIP_SETTINGS)

#define IMB_PORT_ADD_F_INIT_PASS1_CLR(flags) (flags &= ~IMB_PORT_ADD_F_INIT_PASS1)
#define IMB_PORT_ADD_F_INIT_PASS2_CLR(flags) (flags &= ~IMB_PORT_ADD_F_INIT_PASS2)
#define IMB_PORT_ADD_F_SKIP_SETTINGS_CLR(flags) (flags &= ~IMB_PORT_ADD_F_SKIP_SETTINGS)

#define IMB_PORT_ADD_F_INIT_PASS1_GET(flags) (flags & IMB_PORT_ADD_F_INIT_PASS1 ? 1 : 0)
#define IMB_PORT_ADD_F_INIT_PASS2_GET(flags) (flags & IMB_PORT_ADD_F_INIT_PASS2 ? 1 : 0)
#define IMB_PORT_ADD_F_SKIP_SETTINGS_GET(flags) (flags & IMB_PORT_ADD_F_SKIP_SETTINGS ? 1 : 0)

/*! 
 * imb_port_add
 *
 * @brief Add new IMB (Interface Management Block) port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - Which pass through port add. see IMB_PORT_ADD_F_INIT_...
 */
int imb_port_add(
    int unit,
    bcm_port_t port,
    uint32 flags);

/*! 
 * imb_port_remove
 *
 * @brief Remove an existing IMB (Interface Management Block) port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int imb_port_remove(
    int unit,
    bcm_port_t port);

/*! 
 * imb_port_attach
 *
 * @brief Add new IMB (Interface Management Block) port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - Which pass through port add. see IMB_PORT_ADD_F_INIT_...
 */
int imb_port_attach(
    int unit,
    bcm_port_t port,
    uint32 flags);

/*! 
 * imb_port_detach
 *
 * @brief Remove an existing IMB (Interface Management Block) port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int imb_port_detach(
    int unit,
    bcm_port_t port);

/*! 
 * @brief Port Add Flags 
 */
#define IMB_PORT_ENABLE_F_SKIP_PORTMOD 0x1 /**< Skip portmod enable */

#define IMB_PORT_ENABLE_F_SKIP_PORTMOD_SET(flags) (flags |= IMB_PORT_ENABLE_F_SKIP_PORTMOD)

#define IMB_PORT_ENABLE_F_SKIP_PORTMOD_CLR(flags) (flags &= ~IMB_PORT_ENABLE_F_SKIP_PORTMOD)

#define IMB_PORT_ENABLE_F_SKIP_PORTMOD_GET(flags) (flags & IMB_PORT_ENABLE_F_SKIP_PORTMOD ? 1 : 0)

/*! 
 * imb_port_enable_set
 *
 * @brief Enable / disable a port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - flags
 * @param [in]  enable          - Port enable/disable indication
 */
int imb_port_enable_set(
    int unit,
    bcm_port_t port,
    uint32 flags,
    int enable);
/*! 
 * imb_port_enable_get
 *
 * @brief Enable / disable a port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - Port enabled indication
 */
int imb_port_enable_get(
    int unit,
    bcm_port_t port,
    int *enable);

/*! 
 * imb_port_rx_data_enable_set
 *
 * @brief Enable / disable port RX 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - Port Rx enable/disable
 */
int imb_port_rx_data_enable_set(
    int unit,
    bcm_port_t port,
    int enable);

/*! 
 * imb_port_loopback_set
 *
 * @brief Enable / disable loopback on a port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  loopback        - Port loopback indication
 */
int imb_port_loopback_set(
    int unit,
    bcm_port_t port,
    int loopback);
/*! 
 * imb_port_loopback_get
 *
 * @brief Enable / disable loopback on a port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  loopback        - Port loopback enabled indication
 */
int imb_port_loopback_get(
    int unit,
    bcm_port_t port,
    int *loopback);

/*! 
 * imb_port_link_state_get
 *
 * @brief Get port link state 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  clear_status    - clear latch down indication
 * @param [out]  link_state      - Port link state
 */
int imb_port_link_state_get(
    int unit,
    bcm_port_t port,
    int clear_status,
    bcm_port_link_state_t * link_state);

/*! 
 * imb_port_eee_enable_set
 *
 * @brief Enable / disable EEE for a port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - Port EEE enable/disable indication
 */
int imb_port_eee_enable_set(
    int unit,
    bcm_port_t port,
    int enable);
/*! 
 * imb_port_eee_enable_get
 *
 * @brief Enable / disable EEE for a port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - Port EEE enabled indication
 */
int imb_port_eee_enable_get(
    int unit,
    bcm_port_t port,
    int *enable);

/*! 
 * imb_port_link_up_mac_update
 *
 * @brief Set Mac link according to Phy status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  link            - link status info
 */
int imb_port_link_up_mac_update(
    int unit,
    bcm_port_t port,
    int link);

/*! 
 * imb_port_priority_config_set
 *
 * @brief Set / get priority configuration for the port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  priority_config   - Priority config info
 */
int imb_port_priority_config_set(
    int unit,
    bcm_port_t port,
    const bcm_port_prio_config_t * priority_config);
/*! 
 * imb_port_priority_config_get
 *
 * @brief Set / get priority configuration for the port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  priority_config   - Priority config info
 */
int imb_port_priority_config_get(
    int unit,
    bcm_port_t port,
    bcm_port_prio_config_t * priority_config);

/*! 
 * imb_port_phy_measure_get
 *
 * @brief We can't measure the serdes freq directly, but we can measure the sync_eth counter, 
            and reconstruct the serdes freq from it by multiplying it with the blocks dividers. 
            In PML and PMH GSMII the dividers are:
            VCO                                                   Sync_eth counter
              _        --> PM synce_div --> NBIL/H synce div -->         _
            _| |_                                                      _| |_
            So 
            VCO = Fsynce * PMH_40_PML_20 * PM_1_7_11
            and we need to do:
            SerDes_rate = VCO/Oversample = Fsynce * PMH_40_PML_20 * PM_1_7_11 / Oversample

            In PMH which is not GSMII the dividers are:
            Serdes freq                                            Sync_eth counter
              _         --> PM synce_div --> NBIL/H synce div -->        _
            _| |_                                                      _| |_
            So we need to do:
            SerDes_rate = Fsynce * PMH_40_PML_20 * PM_1_7_11  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  is_rx           - use RX or TX FIFO to measure Serdes rate, only relevant for Fabric Serdes.
 * @param [out]  phy_measure     - PHY measure structure
 */
int imb_port_phy_measure_get(
    int unit,
    bcm_port_t port,
    int is_rx,
    soc_dnxc_port_phy_measure_t * phy_measure);

/*! 
 * imb_port_over_sampling_get
 *
 * @brief Get the over-sampling factor for the port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  os_int          - Over-sampling integer
 * @param [out]  os_remainder    - Over-sampling remainder after the decimal point
 */
int imb_port_over_sampling_get(
    int unit,
    bcm_port_t port,
    uint32 *os_int,
    uint32 *os_remainder);

/*! 
 * imb_port_autoneg_set
 *
 * @brief Set/Get autoneg properties 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  phy_flags       - Which phy in the chain should be affected. see PORTMOD_INIT_F...
 * @param [in]  an              - Auto Negotioation properties
 */
int imb_port_autoneg_set(
    int unit,
    bcm_port_t port,
    uint32 phy_flags,
    const phymod_autoneg_control_t * an);
/*! 
 * imb_port_autoneg_get
 *
 * @brief Set/Get autoneg properties 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  phy_flags       - Which phy in the chain should be affected. see PORTMOD_INIT_F...
 * @param [out]  an              - Auto Negotioation properties
 */
int imb_port_autoneg_get(
    int unit,
    bcm_port_t port,
    uint32 phy_flags,
    phymod_autoneg_control_t * an);

/*! 
 * imb_port_link_get
 *
 * @brief Get link status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - Which phy in the chain should be affected. see PORTMOD_INIT_F...
 * @param [out]  link            - Link status indication up/down
 */
int imb_port_link_get(
    int unit,
    bcm_port_t port,
    int flags,
    int *link);

/*! 
 * imb_port_max_packet_size_set
 *
 * @brief Filter packets bigger than the specified value 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - Max packet size
 */
int imb_port_max_packet_size_set(
    int unit,
    bcm_port_t port,
    int value);
/*! 
 * imb_port_max_packet_size_get
 *
 * @brief Filter packets bigger than the specified value 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - Max packet size
 */
int imb_port_max_packet_size_get(
    int unit,
    bcm_port_t port,
    int *value);

/*! 
 * imb_port_tx_average_ipg_set
 *
 * @brief Set/get Average inter-packet gap 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  ipg_value       - Inter-packet gap to set
 */
int imb_port_tx_average_ipg_set(
    int unit,
    bcm_port_t port,
    int ipg_value);
/*! 
 * imb_port_tx_average_ipg_get
 *
 * @brief Set/get Average inter-packet gap 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  ipg_value       - Get inter-packet gap
 */
int imb_port_tx_average_ipg_get(
    int unit,
    bcm_port_t port,
    int *ipg_value);

/*! 
 * imb_port_duplex_set
 *
 * @brief Port duplex set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - Enable / disable port duplex. true=full duplex, false=half duplex
 */
int imb_port_duplex_set(
    int unit,
    bcm_port_t port,
    int enable);
/*! 
 * imb_port_duplex_get
 *
 * @brief Port duplex set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - Get port duplex. true=full duplex, false=half duplex
 */
int imb_port_duplex_get(
    int unit,
    bcm_port_t port,
    int *enable);

/*! 
 * imb_port_cntmaxsize_set
 *
 * @brief Config MIB counter max size. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  val             - Set max packet size that is used in statistics counter updates.
 */
int imb_port_cntmaxsize_set(
    int unit,
    bcm_port_t port,
    int val);
/*! 
 * imb_port_cntmaxsize_get
 *
 * @brief Config MIB counter max size. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  val             - Get max packet size that is used in statistics counter updates.
 */
int imb_port_cntmaxsize_get(
    int unit,
    bcm_port_t port,
    int *val);

/*! 
 * imb_port_local_fault_status_get
 *
 * @brief Local fault steatus get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  local_fault     - Get local fault status
 */
int imb_port_local_fault_status_get(
    int unit,
    bcm_port_t port,
    int *local_fault);

/*! 
 * imb_port_local_fault_status_clear
 *
 * @brief Clear Local fault steatus 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int imb_port_local_fault_status_clear(
    int unit,
    bcm_port_t port);

/*! 
 * imb_port_remote_fault_status_get
 *
 * @brief Remote fault status get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  remote_fault    - Get remote fault status
 */
int imb_port_remote_fault_status_get(
    int unit,
    bcm_port_t port,
    int *remote_fault);

/*! 
 * imb_port_remote_fault_status_clear
 *
 * @brief Clear Remote fault status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int imb_port_remote_fault_status_clear(
    int unit,
    bcm_port_t port);

/*! 
 * imb_port_local_fault_enable_set
 *
 * @brief local fault enable set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - 
 */
int imb_port_local_fault_enable_set(
    int unit,
    bcm_port_t port,
    int enable);
/*! 
 * imb_port_local_fault_enable_get
 *
 * @brief local fault enable set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - 
 */
int imb_port_local_fault_enable_get(
    int unit,
    bcm_port_t port,
    int *enable);

/*! 
 * imb_port_remote_fault_enable_set
 *
 * @brief remote fault enable set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - 
 */
int imb_port_remote_fault_enable_set(
    int unit,
    bcm_port_t port,
    int enable);
/*! 
 * imb_port_remote_fault_enable_get
 *
 * @brief remote fault enable set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - 
 */
int imb_port_remote_fault_enable_get(
    int unit,
    bcm_port_t port,
    int *enable);

/*! 
 * imb_port_tx_mac_sa_set
 *
 * @brief Set/get the MAC source address that will be sent in case of Pause/LLFC 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mac_sa          - Source address for PAUSE/PFC packets generated by the MAC
 */
int imb_port_tx_mac_sa_set(
    int unit,
    bcm_port_t port,
    sal_mac_addr_t mac_sa);
/*! 
 * imb_port_tx_mac_sa_get
 *
 * @brief Set/get the MAC source address that will be sent in case of Pause/LLFC 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  mac_sa          - Source address for PAUSE/PFC packets generated by the MAC
 */
int imb_port_tx_mac_sa_get(
    int unit,
    bcm_port_t port,
    sal_mac_addr_t mac_sa);

/*! 
 * imb_port_rx_mac_sa_set
 *
 * @brief Set/get SA recognized for MAC control packets in addition to the standard 0x0180C2000001 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mac_sa          - Source Address recognized for MAC control packets in addition to the standard 0x0180C2000001
 */
int imb_port_rx_mac_sa_set(
    int unit,
    bcm_port_t port,
    sal_mac_addr_t mac_sa);
/*! 
 * imb_port_rx_mac_sa_get
 *
 * @brief Set/get SA recognized for MAC control packets in addition to the standard 0x0180C2000001 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  mac_sa          - Source Address recognized for MAC control packets in addition to the standard 0x0180C2000001
 */
int imb_port_rx_mac_sa_get(
    int unit,
    bcm_port_t port,
    sal_mac_addr_t mac_sa);

/*! 
 * imb_port_reset_set
 *
 * @brief Port Reset set/get - [this is not really supported in PHYMOD layer] 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mode            - Phy reset mode. see phymod_reset_mode_t
 * @param [in]  opcode          - TBD
 * @param [in]  direction       - Phy reset direction. see phymod_reset_direction_t
 */
int imb_port_reset_set(
    int unit,
    bcm_port_t port,
    int mode,
    int opcode,
    int direction);
/*! 
 * imb_port_reset_get
 *
 * @brief Port Reset set/get - [this is not really supported in PHYMOD layer] 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mode            - Phy reset mode. see phymod_reset_mode_t
 * @param [in]  opcode          - TBD
 * @param [out]  direction       - Phy reset direction. see phymod_reset_direction_t
 */
int imb_port_reset_get(
    int unit,
    bcm_port_t port,
    int mode,
    int opcode,
    int *direction);

/*! 
 * imb_port_pfc_control_set
 *
 * @brief Set/get PFC FC configuration 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  control         - Priority flow control configuration 
 */
int imb_port_pfc_control_set(
    int unit,
    bcm_port_t port,
    const portmod_pfc_control_t * control);
/*! 
 * imb_port_pfc_control_get
 *
 * @brief Set/get PFC FC configuration 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  control         - Priority flow control configuration 
 */
int imb_port_pfc_control_get(
    int unit,
    bcm_port_t port,
    portmod_pfc_control_t * control);

/*! 
 * imb_port_eee_set
 *
 * @brief Set/get EEE Config. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  eee             - EEE (Energy Eficient Ethernet) Timer Information.
 */
int imb_port_eee_set(
    int unit,
    bcm_port_t port,
    const portmod_eee_t * eee);
/*! 
 * imb_port_eee_get
 *
 * @brief Set/get EEE Config. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  eee             - EEE (Energy Eficient Ethernet) Timer Information.
 */
int imb_port_eee_get(
    int unit,
    bcm_port_t port,
    portmod_eee_t * eee);

/*! 
 * imb_bandwidth_get
 *
 * @brief Get the Bandwidth for the CDU. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  is_port_include   - indication wether to include the specified port in the BW calculation
 * @param [out]  bandwidth       - bandwidth for all ports in CDU.
 */
int imb_bandwidth_get(
    int unit,
    bcm_port_t port,
    int is_port_include,
    int *bandwidth);

/*! 
 * imb_port_tx_start_thr_set
 *
 * @brief Set the Start TX threshold. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  speed           - Port interface rate
 */
int imb_port_tx_start_thr_set(
    int unit,
    bcm_port_t port,
    int speed);

/*! 
 * imb_prd_port_profile_map_is_supported
 *
 * @brief Is port profile map supported for this port dispatch type. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  is_supported    - is supported
 */
int imb_prd_port_profile_map_is_supported(
    int unit,
    bcm_port_t port,
    int *is_supported);

/*! 
 * imb_prd_nof_port_profiles_get
 *
 * @brief Get the number of prfiles for this port dispatch type.. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  nof_port_profiles   - number of port profiles
 */
int imb_prd_nof_port_profiles_get(
    int unit,
    bcm_port_t port,
    int *nof_port_profiles);

/*! 
 * imb_prd_enable_set
 *
 * @brief Set/get the PRD Enable mode. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable_mode     - PRD enable mode (0=>disable, 1=>only hard stage, 2=>hard and soft stgae)
 */
int imb_prd_enable_set(
    int unit,
    bcm_port_t port,
    int enable_mode);
/*! 
 * imb_prd_enable_get
 *
 * @brief Set/get the PRD Enable mode. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable_mode     - PRD enable mode (0=>disable, 1=>only hard stage, 2=>hard and soft stgae)
 */
int imb_prd_enable_get(
    int unit,
    bcm_port_t port,
    int *enable_mode);

/*!
 * @enum imb_prd_properties_e
 * @brief PRD properties 
 */
typedef enum imb_prd_properties_e
{
    imbImbPrdIgnoreIpDscp = 0,
    imbImbPrdIgnoreMplsExp = 1,
    imbImbPrdIgnoreInnerTag = 2,
    imbImbPrdIgnoreOuterTag = 3,
    imbImbPrdDefaultPriority = 4,
    imbImbPrdCount
} imb_prd_properties_t;

extern const enum_mapping_t imb_prd_properties_t_mapping[];
/* imb_prd_properties_t validation */
int imb_prd_properties_t_validate(
    int unit,
    imb_prd_properties_t imb_prd_properties);
/*! 
 * imb_prd_properties_set
 *
 * @brief Set/get PRD Properties. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  property        - PRD property to configure
 * @param [in]  val             - PRD Proeprty value
 */
int imb_prd_properties_set(
    int unit,
    bcm_port_t port,
    imb_prd_properties_t property,
    uint32 val);
/*! 
 * imb_prd_properties_get
 *
 * @brief Set/get PRD Properties. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  property        - PRD property to configure
 * @param [out]  val             - PRD Proeprty value
 */
int imb_prd_properties_get(
    int unit,
    bcm_port_t port,
    imb_prd_properties_t property,
    uint32 *val);

/*! 
 * imb_prd_port_profile_map_set
 *
 * @brief Set/get PRD Port Profile. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  profile         - PRD Port Profile value
 */
int imb_prd_port_profile_map_set(
    int unit,
    bcm_port_t port,
    uint32 profile);
/*! 
 * imb_prd_port_profile_map_get
 *
 * @brief Set/get PRD Port Profile. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  profile         - PRD Port Profile value
 */
int imb_prd_port_profile_map_get(
    int unit,
    bcm_port_t port,
    uint32 *profile);

/*! 
 * imb_prd_map_set
 *
 * @brief Configure PRD priority maps. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  map             - PRD Map to configure
 * @param [in]  key             - Map key. composed differently according to the map type.              should be set by the user using the following MACROs:                 BCM_COSQ_INGRESS_PORT_DROP_ETH_MAP_KEY(pcp, dei)                   BCM_COSQ_INGRESS_PORT_DROP_TM_MAP_KEY(tc, dp)                   BCM_COSQ_INGRESS_PORT_DROP_IP_MAP_KEY(dscp)                   BCM_COSQ_INGRESS_PORT_DROP_MPLS_MAP_KEY(exp)
 * @param [in]  priority        - PRD priority value
 * @param [in]  is_tdm          - PRD is_tdm indication
 */
int imb_prd_map_set(
    int unit,
    bcm_port_t port,
    bcm_cosq_ingress_port_drop_map_t map,
    uint32 key,
    uint32 priority,
    uint32 is_tdm);
/*! 
 * imb_prd_map_get
 *
 * @brief Configure PRD priority maps. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  map             - PRD Map to configure
 * @param [in]  key             - Map key. composed differently according to the map type.              should be set by the user using the following MACROs:                 BCM_COSQ_INGRESS_PORT_DROP_ETH_MAP_KEY(pcp, dei)                   BCM_COSQ_INGRESS_PORT_DROP_TM_MAP_KEY(tc, dp)                   BCM_COSQ_INGRESS_PORT_DROP_IP_MAP_KEY(dscp)                   BCM_COSQ_INGRESS_PORT_DROP_MPLS_MAP_KEY(exp)
 * @param [out]  priority        - PRD priority value
 * @param [out]  is_tdm          - PRD is_tdm indication
 */
int imb_prd_map_get(
    int unit,
    bcm_port_t port,
    bcm_cosq_ingress_port_drop_map_t map,
    uint32 key,
    uint32 *priority,
    uint32 *is_tdm);

/*! 
 * imb_prd_threshold_set
 *
 * @brief Configure PRD thresholds. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  priority        - PRD priority
 * @param [in]  threshold       - PRD threshols value (in entries) for the priority. threshold will be set for the RMC for which the priority is mapped.
 */
int imb_prd_threshold_set(
    int unit,
    bcm_port_t port,
    uint32 priority,
    uint32 threshold);
/*! 
 * imb_prd_threshold_get
 *
 * @brief Configure PRD thresholds. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  priority        - PRD priority
 * @param [out]  threshold       - PRD priority value (in entries) for the priority. threshold will be taken from the RMC for which the priority is mapped.
 */
int imb_prd_threshold_get(
    int unit,
    bcm_port_t port,
    uint32 priority,
    uint32 *threshold);

/*! 
 * imb_prd_threshold_max_get
 *
 * @brief Get maximum PRD threshold value. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  threshold       - PRD threshold max value.
 */
int imb_prd_threshold_max_get(
    int unit,
    bcm_port_t port,
    uint32 *threshold);

/*! 
 * imb_prd_tpid_set
 *
 * @brief Configure PRD TPIDs per port. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  tpid_index      - TPID index to set (0-3)
 * @param [in]  tpid_value      - TPID to be recognized by the port
 */
int imb_prd_tpid_set(
    int unit,
    bcm_port_t port,
    uint32 tpid_index,
    uint32 tpid_value);
/*! 
 * imb_prd_tpid_get
 *
 * @brief Configure PRD TPIDs per port. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  tpid_index      - TPID index to set (0-3)
 * @param [out]  tpid_value      - TPID recognized by the port
 */
int imb_prd_tpid_get(
    int unit,
    bcm_port_t port,
    uint32 tpid_index,
    uint32 *tpid_value);

/*! 
 * imb_prd_drop_count_get
 *
 * @brief Get PRD counter for the corresponding FIFO (RMC). 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  sch_priority    - which scheduler is the PRD fifo mapped to
 * @param [out]  count           - PRD counter value
 */
int imb_prd_drop_count_get(
    int unit,
    bcm_port_t port,
    bcm_port_nif_scheduler_t sch_priority,
    uint64 *count);

/*! 
 * imb_prd_custom_ether_type_set
 *
 * @brief Set/Get PRD Configurable Ether types. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  ether_type_code   - Custom Ether type code to assign to the Ether type(1-6)
 * @param [in]  ether_type_val   - Ether type value
 */
int imb_prd_custom_ether_type_set(
    int unit,
    bcm_port_t port,
    uint32 ether_type_code,
    uint32 ether_type_val);
/*! 
 * imb_prd_custom_ether_type_get
 *
 * @brief Set/Get PRD Configurable Ether types. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  ether_type_code   - Custom Ether type code to assign to the Ether type(1-6)
 * @param [out]  ether_type_val   - Ether type value
 */
int imb_prd_custom_ether_type_get(
    int unit,
    bcm_port_t port,
    uint32 ether_type_code,
    uint32 *ether_type_val);

/*! 
 * imb_prd_flex_key_entry_set
 *
 * @brief Set/Get PRD TCAM entries (for the soft stage). 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  key_index       - TCAM index to configure
 * @param [in]  entry_info      - TCAM entry information
 */
int imb_prd_flex_key_entry_set(
    int unit,
    bcm_port_t port,
    uint32 key_index,
    const dnx_cosq_prd_tcam_entry_info_t * entry_info);
/*! 
 * imb_prd_flex_key_entry_get
 *
 * @brief Set/Get PRD TCAM entries (for the soft stage). 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  key_index       - TCAM index to configure
 * @param [out]  entry_info      - TCAM entry information
 */
int imb_prd_flex_key_entry_get(
    int unit,
    bcm_port_t port,
    uint32 key_index,
    dnx_cosq_prd_tcam_entry_info_t * entry_info);

/*! 
 * imb_prd_ether_type_size_set
 *
 * @brief Set/Get PRD TCAM key size per Ether type (for the soft stage). 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  ether_type_code   - Ether type code of the key
 * @param [in]  ether_type_size   - Ether type size
 */
int imb_prd_ether_type_size_set(
    int unit,
    bcm_port_t port,
    uint32 ether_type_code,
    uint32 ether_type_size);
/*! 
 * imb_prd_ether_type_size_get
 *
 * @brief Set/Get PRD TCAM key size per Ether type (for the soft stage). 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  ether_type_code   - Ether type code of the key
 * @param [out]  ether_type_size   - Ether type size
 */
int imb_prd_ether_type_size_get(
    int unit,
    bcm_port_t port,
    uint32 ether_type_code,
    uint32 *ether_type_size);

/*! 
 * imb_prd_tcam_entry_key_offset_base_set
 *
 * @brief Set/Get PRD TCAM key offset base per Ether type (for the soft stage). 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  ether_type_code   - Ether type code of the key
 * @param [in]  offset_base     - Ether type offset base
 */
int imb_prd_tcam_entry_key_offset_base_set(
    int unit,
    bcm_port_t port,
    uint32 ether_type_code,
    uint32 offset_base);
/*! 
 * imb_prd_tcam_entry_key_offset_base_get
 *
 * @brief Set/Get PRD TCAM key offset base per Ether type (for the soft stage). 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  ether_type_code   - Ether type code of the key
 * @param [out]  offset_base     - Ether type offset base
 */
int imb_prd_tcam_entry_key_offset_base_get(
    int unit,
    bcm_port_t port,
    uint32 ether_type_code,
    uint32 *offset_base);

/*! 
 * imb_prd_tcam_entry_key_offset_set
 *
 * @brief Set/Get PRD TCAM key offset value per Ether type (for the soft stage). 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  ether_type_code   - Ether type code of the key
 * @param [in]  offset_index    - Ether type offset index
 * @param [in]  offset_value    - Ether type offset value
 */
int imb_prd_tcam_entry_key_offset_set(
    int unit,
    bcm_port_t port,
    uint32 ether_type_code,
    uint32 offset_index,
    uint32 offset_value);
/*! 
 * imb_prd_tcam_entry_key_offset_get
 *
 * @brief Set/Get PRD TCAM key offset value per Ether type (for the soft stage). 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  ether_type_code   - Ether type code of the key
 * @param [in]  offset_index    - Ether type offset index
 * @param [out]  offset_value    - Ether type offset value
 */
int imb_prd_tcam_entry_key_offset_get(
    int unit,
    bcm_port_t port,
    uint32 ether_type_code,
    uint32 offset_index,
    uint32 *offset_value);

/*! 
 * imb_prd_control_frame_set
 *
 * @brief Set/Get PRD Control Frame proeprties. if a packet is identified as control frame, it will automatically get the highest priority. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  control_frame_index   - Index of the control frame.
 * @param [in]  control_frame_config   - Control Frame properties
 */
int imb_prd_control_frame_set(
    int unit,
    bcm_port_t port,
    uint32 control_frame_index,
    const bcm_cosq_ingress_drop_control_frame_config_t * control_frame_config);
/*! 
 * imb_prd_control_frame_get
 *
 * @brief Set/Get PRD Control Frame proeprties. if a packet is identified as control frame, it will automatically get the highest priority. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  control_frame_index   - Index of the control frame.
 * @param [out]  control_frame_config   - Control Frame properties
 */
int imb_prd_control_frame_get(
    int unit,
    bcm_port_t port,
    uint32 control_frame_index,
    bcm_cosq_ingress_drop_control_frame_config_t * control_frame_config);

/*! 
 * imb_prd_mpls_special_label_set
 *
 * @brief Set/Get PRD MPLS special label proeprties. if a packet is identified as MPLS special label and the label value matches to one of the saved special labels, the priority and TDM indication will be taken from the label properties. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  label_index     - Index of the control frame.
 * @param [in]  label_config    - MPLS special label properties
 */
int imb_prd_mpls_special_label_set(
    int unit,
    bcm_port_t port,
    uint32 label_index,
    const bcm_cosq_ingress_port_drop_mpls_special_label_config_t * label_config);
/*! 
 * imb_prd_mpls_special_label_get
 *
 * @brief Set/Get PRD MPLS special label proeprties. if a packet is identified as MPLS special label and the label value matches to one of the saved special labels, the priority and TDM indication will be taken from the label properties. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  label_index     - Index of the control frame.
 * @param [out]  label_config    - MPLS special label properties
 */
int imb_prd_mpls_special_label_get(
    int unit,
    bcm_port_t port,
    uint32 label_index,
    bcm_cosq_ingress_port_drop_mpls_special_label_config_t * label_config);

/*! 
 * imb_port_logical_lane_order_set
 *
 * @brief Set/Get the logical lane order for ILKN ports 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  lane_order      - ILKN Logical lane order. For pmOsILKN_50G, lane_order[N] is represent for the Nth lane; otherwise it is represent for logical lane N
 * @param [in]  lane_order_size   - Nof lanes of the ILKN port
 */
int imb_port_logical_lane_order_set(
    int unit,
    bcm_port_t port,
    const int *lane_order,
    int lane_order_size);
/*! 
 * imb_port_logical_lane_order_get
 *
 * @brief Set/Get the logical lane order for ILKN ports 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  lane_order_max_size   - Max lane numbers when get ILKN lane order
 * @param [out]  lane_order      - Logical lane order, lane_order[N] is represent for the Nth lane
 * @param [out]  lane_order_actual_size   - The actual lane numbers when get ILKN lane order
 */
int imb_port_logical_lane_order_get(
    int unit,
    bcm_port_t port,
    int lane_order_max_size,
    int *lane_order,
    int *lane_order_actual_size);

/*! 
 * imb_port_prbs_polynomial_set
 *
 * @brief Set/Get prbs polnomial value 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  prbs_mode       - prbs mode
 * @param [in]  value           - prbs polynomial value
 */
int imb_port_prbs_polynomial_set(
    int unit,
    bcm_port_t port,
    portmod_prbs_mode_t prbs_mode,
    bcm_port_prbs_t value);
/*! 
 * imb_port_prbs_polynomial_get
 *
 * @brief Set/Get prbs polnomial value 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  prbs_mode       - prbs mode
 * @param [out]  value           - prbs polynomial value
 */
int imb_port_prbs_polynomial_get(
    int unit,
    bcm_port_t port,
    portmod_prbs_mode_t prbs_mode,
    bcm_port_prbs_t * value);

/*! 
 * imb_port_prbs_invert_data_set
 *
 * @brief Set/Get prbs rx or tx data inversion status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  type            - indicate rx or tx prbs
 * @param [in]  prbs_mode       - prbs mode
 * @param [in]  invert          - Enable or disable data inversion
 */
int imb_port_prbs_invert_data_set(
    int unit,
    bcm_port_t port,
    int type,
    portmod_prbs_mode_t prbs_mode,
    int invert);
/*! 
 * imb_port_prbs_invert_data_get
 *
 * @brief Set/Get prbs rx or tx data inversion status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  type            - indicate rx or tx prbs
 * @param [in]  prbs_mode       - prbs mode
 * @param [out]  invert          - Enable or disablei data inversion
 */
int imb_port_prbs_invert_data_get(
    int unit,
    bcm_port_t port,
    int type,
    portmod_prbs_mode_t prbs_mode,
    int *invert);

/*! 
 * imb_port_prbs_enable_set
 *
 * @brief Set prbs rx or tx enable status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  type            - indicate rx or tx prbs
 * @param [in]  prbs_mode       - prbs mode
 * @param [in]  enable          - Enable or disable prbs
 */
int imb_port_prbs_enable_set(
    int unit,
    bcm_port_t port,
    int type,
    portmod_prbs_mode_t prbs_mode,
    int enable);

/*! 
 * imb_port_prbs_enable_get
 *
 * @brief Get prbs rx or tx enable status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  type            - indicate rx or tx prbs
 * @param [in]  prbs_mode       - prbs mode
 * @param [out]  enable          - Enable or disable prbs
 */
int imb_port_prbs_enable_get(
    int unit,
    bcm_port_t port,
    int type,
    portmod_prbs_mode_t prbs_mode,
    int *enable);

/*! 
 * imb_port_prbs_rx_status_get
 *
 * @brief Set/Get prbs status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  prbs_mode       - prbs mode
 * @param [out]  status          - Prbs status
 */
int imb_port_prbs_rx_status_get(
    int unit,
    bcm_port_t port,
    portmod_prbs_mode_t prbs_mode,
    int *status);

/*! 
 * imb_port_phy_reg_set
 *
 * @brief Read or write PHY registers associated with a port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - Indicate how to access the PHY, and which PHY if the port has an internal serdes
 * @param [in]  phy_reg_addr    - Register address in the PHY
 * @param [in]  phy_data        - Data to be written or data read
 */
int imb_port_phy_reg_set(
    int unit,
    bcm_port_t port,
    uint32 flags,
    uint32 phy_reg_addr,
    uint32 phy_data);
/*! 
 * imb_port_phy_reg_get
 *
 * @brief Read or write PHY registers associated with a port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - Indicate how to access the PHY, and which PHY if the port has an internal serdes
 * @param [in]  phy_reg_addr    - Register address in the PHY
 * @param [out]  phy_data        - Data to be written or data read
 */
int imb_port_phy_reg_get(
    int unit,
    bcm_port_t port,
    uint32 flags,
    uint32 phy_reg_addr,
    uint32 *phy_data);

/*! 
 * imb_port_rx_fifo_status_get
 *
 * @brief Get rx fifo status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  sch_priority    - which scheduler is the PRD fifo mapped to
 * @param [out]  max_occupancy   - Indicates the corresponding lane MLF MAX fullness level of the FIFO
 * @param [out]  fifo_level      - Indicates the corresponding lane MLF fullness level of the FIFO
 */
int imb_port_rx_fifo_status_get(
    int unit,
    bcm_port_t port,
    bcm_port_nif_scheduler_t sch_priority,
    uint32 *max_occupancy,
    uint32 *fifo_level);

/*! 
 * imb_port_tx_fifo_status_get
 *
 * @brief Get tx fifo status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  max_occupancy   - Indicates the corresponding lane MLF MAX fullness level of the FIFO
 * @param [out]  fifo_level      - Indicates the corresponding lane MLF fullness level of the FIFO
 * @param [out]  pm_credits      - the number of credits received from the port-macro Tx buffer
 */
int imb_port_tx_fifo_status_get(
    int unit,
    bcm_port_t port,
    uint32 *max_occupancy,
    uint32 *fifo_level,
    uint32 *pm_credits);

/*! 
 * imb_port_low_latency_llfc_enable_set
 *
 * @brief Enable/Disable Low Latency LLFC 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - Enable/Disable Low Latency LLFC
 */
int imb_port_low_latency_llfc_enable_set(
    int unit,
    bcm_port_t port,
    int value);
/*! 
 * imb_port_low_latency_llfc_enable_get
 *
 * @brief Enable/Disable Low Latency LLFC 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - Enable/Disable Low Latency LLFC
 */
int imb_port_low_latency_llfc_enable_get(
    int unit,
    bcm_port_t port,
    int *value);

/*! 
 * imb_port_fec_error_detect_enable_set
 *
 * @brief Enable/Disable FEC error detect 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - Enable/Disable Low Latency LLFC
 */
int imb_port_fec_error_detect_enable_set(
    int unit,
    bcm_port_t port,
    int value);
/*! 
 * imb_port_fec_error_detect_enable_get
 *
 * @brief Enable/Disable FEC error detect 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - Enable/Disable FEC error detect
 */
int imb_port_fec_error_detect_enable_get(
    int unit,
    bcm_port_t port,
    int *value);

/*! 
 * imb_port_llfc_after_fec_enable_set
 *
 * @brief Enable/Disable LLFC after FEC 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - Enable/Disable LLFC after FEC
 */
int imb_port_llfc_after_fec_enable_set(
    int unit,
    bcm_port_t port,
    int value);
/*! 
 * imb_port_llfc_after_fec_enable_get
 *
 * @brief Enable/Disable LLFC after FEC 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - Enable/Disable LLFC after FEC
 */
int imb_port_llfc_after_fec_enable_get(
    int unit,
    bcm_port_t port,
    int *value);

/*! 
 * imb_port_extract_congestion_indication_from_llfc_enable_set
 *
 * @brief Enable/Disable extract congestion indication from LLFC cells 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - Enable/Disable extract congestion indication from LLFC cells
 */
int imb_port_extract_congestion_indication_from_llfc_enable_set(
    int unit,
    bcm_port_t port,
    int value);
/*! 
 * imb_port_extract_congestion_indication_from_llfc_enable_get
 *
 * @brief Enable/Disable extract congestion indication from LLFC cells 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - Enable/Disable extract congestion indication from LLFC cells
 */
int imb_port_extract_congestion_indication_from_llfc_enable_get(
    int unit,
    bcm_port_t port,
    int *value);

/*! 
 * imb_port_control_cells_fec_bypass_enable_set
 *
 * @brief Enable/Disable FEC bypass on control cells 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - Enable/Disable FEC bypass on control cells
 */
int imb_port_control_cells_fec_bypass_enable_set(
    int unit,
    bcm_port_t port,
    int value);
/*! 
 * imb_port_control_cells_fec_bypass_enable_get
 *
 * @brief Enable/Disable FEC bypass on control cells 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - Enable/Disable FEC bypass on control cells
 */
int imb_port_control_cells_fec_bypass_enable_get(
    int unit,
    bcm_port_t port,
    int *value);

/*! 
 * imb_port_speed_config_set
 *
 * @brief Port speed configuration 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  speed_config    - Port speed configuration
 */
int imb_port_speed_config_set(
    int unit,
    bcm_port_t port,
    const portmod_speed_config_t * speed_config);
/*! 
 * imb_port_speed_config_get
 *
 * @brief Port speed configuration 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  speed_config    - Port speed configuration
 */
int imb_port_speed_config_get(
    int unit,
    bcm_port_t port,
    portmod_speed_config_t * speed_config);

/*! 
 * imb_port_mib_counter_get
 *
 * @brief Get mib counter 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  counter_type    - counter type
 * @param [out]  counter_val     - counter value
 */
int imb_port_mib_counter_get(
    int unit,
    bcm_port_t port,
    int counter_type,
    uint64 *counter_val);

/*! 
 * imb_port_mib_counter_set
 *
 * @brief Set mib counter 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  counter_type    - counter type
 * @param [in]  counter_val     - counter value
 */
int imb_port_mib_counter_set(
    int unit,
    bcm_port_t port,
    int counter_type,
    const uint64 *counter_val);

/*! 
 * imb_port_mib_counter_clear
 *
 * @brief Clear mib counter 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int imb_port_mib_counter_clear(
    int unit,
    bcm_port_t port);

/*! 
 * imb_port_autoneg_ability_advert_set
 *
 * @brief Set/Get port advertise abilities 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  num_ability     - number of ability the port will advertise
 * @param [in]  abilities       - local advertisement for each ability
 */
int imb_port_autoneg_ability_advert_set(
    int unit,
    bcm_port_t port,
    int num_ability,
    const bcm_port_speed_ability_t * abilities);
/*! 
 * imb_port_autoneg_ability_advert_get
 *
 * @brief Set/Get port advertise abilities 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  max_num_ability   - the max num of autoneg ability this port can advertise
 * @param [out]  abilities       - indicate the ability this port can advertise
 * @param [out]  actual_num_ability   - the actual num of ability that this port can advertise
 */
int imb_port_autoneg_ability_advert_get(
    int unit,
    bcm_port_t port,
    int max_num_ability,
    bcm_port_speed_ability_t * abilities,
    int *actual_num_ability);

/*! 
 * imb_port_speed_ability_local_get
 *
 * @brief Get the local speed abilities 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  max_num_ability   - the max num of autoneg ability this port can advertise
 * @param [out]  abilities       - indicate the ability this port can advertise
 * @param [out]  actual_num_ability   - the actual num of ability that this port can advertise
 */
int imb_port_speed_ability_local_get(
    int unit,
    bcm_port_t port,
    int max_num_ability,
    bcm_port_speed_ability_t * abilities,
    int *actual_num_ability);

/*! 
 * imb_port_autoneg_ability_remote_get
 *
 * @brief Get the remote abilities 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  max_num_ability   - the max num of autoneg ability this port can advertise
 * @param [out]  abilities       - indicate the ability this port can advertise
 * @param [out]  actual_num_ability   - the actual num of ability that this port can advertise
 */
int imb_port_autoneg_ability_remote_get(
    int unit,
    bcm_port_t port,
    int max_num_ability,
    bcm_port_speed_ability_t * abilities,
    int *actual_num_ability);

/*! 
 * imb_port_scheduler_config_set
 *
 * @brief Set port scheduler 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - enable port scheduler
 */
int imb_port_scheduler_config_set(
    int unit,
    bcm_port_t port,
    int enable);

/*! 
 * imb_port_scheduler_priority_update
 *
 * @brief Update scheduler reset for High/Low priority 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int imb_port_scheduler_priority_update(
    int unit,
    bcm_port_t port);

/*! 
 * imb_port_resource_default_get
 *
 * @brief Get port's default resource configurations 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - Flags
 * @param [out]  resource        - Port default resource configurations
 */
int imb_port_resource_default_get(
    int unit,
    bcm_port_t port,
    uint32 flags,
    bcm_port_resource_t * resource);

/*! 
 * imb_port_to_stif_instance_map_set
 *
 * @brief Map STIF instance ID with given port. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  instace_id      - STIF instance id to map
 * @param [in]  instace_core    - STIF instance core to map
 * @param [in]  connect         - if TRUE connect the SIF instance to the port, if FALSE, disconnect the SIF instance
 */
int imb_port_to_stif_instance_map_set(
    int unit,
    bcm_port_t port,
    int instace_id,
    int instace_core,
    int connect);

/*! 
 * imb_phys_get
 *
 * @brief Get phys associated with imb instance 
 *
 * @param [in]  unit            - unit id
 * @param [in]  imb_id          - imb instance id
 * @param [out]  phys            - phys associated with imb instance
 */
int imb_phys_get(
    int unit,
    int imb_id,
    bcm_pbmp_t * phys);

/*! 
 * imb_port_gen_pfc_from_rmc_enable_set
 *
 * @brief Enable / disable a port's RMCs to produce PFC for the specified priority 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  priority        - Priority for the PFC that will be produced from the RMCs
 * @param [in]  enable          - Port RMCs to produce PFC enable/disable indication
 */
int imb_port_gen_pfc_from_rmc_enable_set(
    int unit,
    bcm_port_t port,
    uint32 priority,
    uint32 enable);
/*! 
 * imb_port_gen_pfc_from_rmc_enable_get
 *
 * @brief Enable / disable a port's RMCs to produce PFC for the specified priority 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  priority        - Priority for the PFC that will be produced from the RMCs
 * @param [out]  enable          - Port RMCs to produce PFC enabled indication
 */
int imb_port_gen_pfc_from_rmc_enable_get(
    int unit,
    bcm_port_t port,
    uint32 priority,
    uint32 *enable);

/*! 
 * imb_port_gen_llfc_from_rmc_enable_set
 *
 * @brief Enable / disable port's RMCs(all lanes) to generate LLFC 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - Port's RMCs(all lanes) to generate LLFC enable/disable indication
 */
int imb_port_gen_llfc_from_rmc_enable_set(
    int unit,
    bcm_port_t port,
    uint32 enable);

/*! 
 * imb_port_stop_pm_from_cfc_llfc_enable_set
 *
 * @brief Enable / disable PM to stop TX on all of a port's lanes according to a LLFC signal from CFC 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - PM to stop TX on all of a port's lanes enable/disable indication
 */
int imb_port_stop_pm_from_cfc_llfc_enable_set(
    int unit,
    bcm_port_t port,
    uint32 enable);

/*! 
 * imb_port_stop_pm_from_pfc_enable_set
 *
 * @brief Enable / disable PM to stop TX on a NIF port according to received PFC signal 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  pfc             - PFC that is enabled/disabled to stop the PM
 * @param [in]  enable          - PM to stop TX on a NIF port enable/disable indication
 */
int imb_port_stop_pm_from_pfc_enable_set(
    int unit,
    bcm_port_t port,
    int pfc,
    uint32 enable);
/*! 
 * imb_port_stop_pm_from_pfc_enable_get
 *
 * @brief Enable / disable PM to stop TX on a NIF port according to received PFC signal 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  pfc             - PFC that is enabled/disabled to stop the PM
 * @param [out]  enable          - PM to stop TX on a NIF port enable/disable indication
 */
int imb_port_stop_pm_from_pfc_enable_get(
    int unit,
    bcm_port_t port,
    int pfc,
    uint32 *enable);

/*! 
 * imb_port_gen_pfc_from_llfc_thresh_enable_set
 *
 * @brief Enable / disable LLFC RMC threshold to generate PFC on the specified port. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - Enable/disable LLFC RMC threshold to generate PFC on the specified port.
 */
int imb_port_gen_pfc_from_llfc_thresh_enable_set(
    int unit,
    bcm_port_t port,
    uint32 enable);
/*! 
 * imb_port_gen_pfc_from_llfc_thresh_enable_get
 *
 * @brief Enable / disable LLFC RMC threshold to generate PFC on the specified port. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - Get enable indication for LLFC RMC threshold to generate PFC on the specified port.
 */
int imb_port_gen_pfc_from_llfc_thresh_enable_get(
    int unit,
    bcm_port_t port,
    uint32 *enable);

/*! 
 * imb_port_fc_rx_qmlf_threshold_set
 *
 * @brief Set / get a port's Rx Quad MAC Lane FIFO (QMLF) Flow Control generation thresholds. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - Flags to determine the threshold type (set/clear for PFC of set/clear for LLFC)
 * @param [in]  threshold       - Rx Quad MAC Lane FIFO (QMLF) Flow Control generation threshold value
 */
int imb_port_fc_rx_qmlf_threshold_set(
    int unit,
    bcm_port_t port,
    uint32 flags,
    uint32 threshold);
/*! 
 * imb_port_fc_rx_qmlf_threshold_get
 *
 * @brief Set / get a port's Rx Quad MAC Lane FIFO (QMLF) Flow Control generation thresholds. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - Flags to determine the threshold type (set/clear for PFC of set/clear for LLFC)
 * @param [out]  threshold       - Rx Quad MAC Lane FIFO (QMLF) Flow Control generation threshold value
 */
int imb_port_fc_rx_qmlf_threshold_get(
    int unit,
    bcm_port_t port,
    uint32 flags,
    uint32 *threshold);

/*! 
 * imb_fc_reset_all
 *
 * @brief Set the Flow Control Interface in/out of reset for all CDUs. 
 *
 * @param [in]  unit            - Unit ID
 * @param [in]  in_reset        - 1 - reset, 0 - out of reset
 */
int imb_fc_reset_all(
    int unit,
    uint32 in_reset);

/*! 
 * imb_fc_reset_set
 *
 * @brief Set the Flow Control Interface in/out of reset for a specified CDU. 
 *
 * @param [in]  unit            - Unit ID
 * @param [in]  imb_info        - IMB info structure for IMB to retrieve the IMB type and CDU
 * @param [in]  in_reset        - 1 - reset, 0 - out of reset
 */
int imb_fc_reset_set(
    int unit,
    const imb_create_info_t * imb_info,
    uint32 in_reset);

/*! 
 * imb_llfc_from_glb_rsc_enable_all
 *
 * @brief Enable / disable the generation of a LLFC based on a signal from Global Resources thresholds for all CDUs 
 *
 * @param [in]  unit            - Unit ID
 * @param [in]  enable          - PM to stop TX on all of a port's lanes enable/disable indication
 */
int imb_llfc_from_glb_rsc_enable_all(
    int unit,
    uint32 enable);

/*! 
 * imb_llfc_from_glb_rsc_enable_set
 *
 * @brief Enable / disable the generation of a LLFC based on a signal from Global Resources thresholds for a specified CDU 
 *
 * @param [in]  unit            - Unit ID
 * @param [in]  imb_info        - IMB info structure for IMB to retrieve the IMB type and CDU
 * @param [in]  enable          - PM to stop TX on all of a port's lanes enable/disable indication
 */
int imb_llfc_from_glb_rsc_enable_set(
    int unit,
    const imb_create_info_t * imb_info,
    uint32 enable);

/*! 
 * imb_pfc_rec_priority_map
 *
 * @brief Per CDU map the received PFC - each priority received by NIF should be mapped to a priority that will be sent to EGQ in order to stop a Q-pair 
 *
 * @param [in]  unit            - unit id
 * @param [in]  imb_id          - imb instance id
 * @param [in]  nif_priority    - Priority of the PFC received by NIF
 * @param [in]  egq_priority    - Priority of the PFC sent to EGQ
 */
int imb_pfc_rec_priority_map(
    int unit,
    int imb_id,
    uint32 nif_priority,
    uint32 egq_priority);

/*! 
 * imb_pfc_rec_priority_unmap
 *
 * @brief Per CDU unmap all priorities of the received PFC 
 *
 * @param [in]  unit            - unit id
 * @param [in]  imb_id          - imb instance id
 */
int imb_pfc_rec_priority_unmap(
    int unit,
    int imb_id);

/*! 
 * imb_port_fec_speed_validate
 *
 * @brief Validate the FEC+SPEED combinations 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  fec_type        - fec type
 * @param [in]  speed           - speed
 */
int imb_port_fec_speed_validate(
    int unit,
    bcm_port_t port,
    bcm_port_phy_fec_t fec_type,
    int speed);

/*! 
 * imb_inband_ilkn_fc_init
 *
 * @brief Configure the specified ILKN core's Inband Flow Control parameters. 
 *
 * @param [in]  unit            - Unit ID
 * @param [in]  imb_info        - IMB info structure for IMB to retrieve the IMB type and CDU
 */
int imb_inband_ilkn_fc_init(
    int unit,
    const imb_create_info_t * imb_info);

/*! 
 * imb_inband_ilkn_fc_init_all
 *
 * @brief Configure all ILKN interfaces' Inband Flow Control parameters. 
 *
 * @param [in]  unit            - Unit ID
 */
int imb_inband_ilkn_fc_init_all(
    int unit);

/*! 
 * @brief IMB FlexE related defines 
 */
#define IMB_FLEXE_DIRECTION_RX_ONLY 0x1 /**< Rx direction */
#define IMB_FLEXE_DIRECTION_TX_ONLY 0x2 /**< Tx direction */
#define IMB_FLEXE_SINGLE_NB_TDM_SLOT 0x4 /**< USE SINGLE TMD slots for in NB calendar for specific port */
#define IMB_FLEXE_DOUBLE_NB_TDM_SLOT 0x8 /**< USE DOUBLE TMD slots for in NB calendar for specific port */

#define IMB_FLEXE_DIRECTION_RX_ONLY_SET(flags) (flags |= IMB_FLEXE_DIRECTION_RX_ONLY)
#define IMB_FLEXE_DIRECTION_TX_ONLY_SET(flags) (flags |= IMB_FLEXE_DIRECTION_TX_ONLY)
#define IMB_FLEXE_SINGLE_NB_TDM_SLOT_SET(flags) (flags |= IMB_FLEXE_SINGLE_NB_TDM_SLOT)
#define IMB_FLEXE_DOUBLE_NB_TDM_SLOT_SET(flags) (flags |= IMB_FLEXE_DOUBLE_NB_TDM_SLOT)

#define IMB_FLEXE_DIRECTION_RX_ONLY_CLR(flags) (flags &= ~IMB_FLEXE_DIRECTION_RX_ONLY)
#define IMB_FLEXE_DIRECTION_TX_ONLY_CLR(flags) (flags &= ~IMB_FLEXE_DIRECTION_TX_ONLY)
#define IMB_FLEXE_SINGLE_NB_TDM_SLOT_CLR(flags) (flags &= ~IMB_FLEXE_SINGLE_NB_TDM_SLOT)
#define IMB_FLEXE_DOUBLE_NB_TDM_SLOT_CLR(flags) (flags &= ~IMB_FLEXE_DOUBLE_NB_TDM_SLOT)

#define IMB_FLEXE_DIRECTION_RX_ONLY_GET(flags) (flags & IMB_FLEXE_DIRECTION_RX_ONLY ? 1 : 0)
#define IMB_FLEXE_DIRECTION_TX_ONLY_GET(flags) (flags & IMB_FLEXE_DIRECTION_TX_ONLY ? 1 : 0)
#define IMB_FLEXE_SINGLE_NB_TDM_SLOT_GET(flags) (flags & IMB_FLEXE_SINGLE_NB_TDM_SLOT ? 1 : 0)
#define IMB_FLEXE_DOUBLE_NB_TDM_SLOT_GET(flags) (flags & IMB_FLEXE_DOUBLE_NB_TDM_SLOT ? 1 : 0)

/*! 
 * imb_calendar_set
 *
 * @brief Configure calendar for FlexE related ports 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - flags for resource set API
 */
int imb_calendar_set(
    int unit,
    bcm_port_t port,
    uint32 flags);

/*! 
 * imb_port_fifo_resource_set
 *
 * @brief Configure FIFO resources for flexe client 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - flags for resource set API
 */
int imb_port_fifo_resource_set(
    int unit,
    bcm_port_t port,
    uint32 flags);

/*! 
 * imb_post_init
 *
 * @brief IMB post init after speed configuration is ready 
 *
 * @param [in]  unit            - unit id
 * @param [in]  imb_id          - imb instance id
 */
int imb_post_init(
    int unit,
    int imb_id);

/*! 
 * imb_instru_counters_reset_all
 *
 * @brief Reset per IMB instrumentation counters for all IMBs. 
 *
 * @param [in]  unit            - Unit ID
 */
int imb_instru_counters_reset_all(
    int unit);

/*! 
 * imb_instru_counters_reset
 *
 * @brief Reset per IMB instrumentation counters 
 *
 * @param [in]  unit            - Unit ID
 * @param [in]  imb_info        - IMB info structure for IMB to retrieve the IMB type
 */
int imb_instru_counters_reset(
    int unit,
    const imb_create_info_t * imb_info);

/*! 
 * imb_pfc_deadlock_counters_reset_all
 *
 * @brief Reset per IMB instrumentation counters for all IMBs. 
 *
 * @param [in]  unit            - Unit ID
 */
int imb_pfc_deadlock_counters_reset_all(
    int unit);

/*! 
 * imb_pfc_deadlock_counters_reset
 *
 * @brief Reset per IMB counters for PFC Deadlock detection 
 *
 * @param [in]  unit            - Unit ID
 * @param [in]  imb_info        - IMB info structure for IMB to retrieve the IMB type
 */
int imb_pfc_deadlock_counters_reset(
    int unit,
    const imb_create_info_t * imb_info);

/*! 
 * imb_port_pfc_deadlock_counters_reset
 *
 * @brief Reset per port counters for PFC Deadlock detection 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int imb_port_pfc_deadlock_counters_reset(
    int unit,
    bcm_port_t port);

/*! 
 * imb_pfc_deadlock_debug_info_get
 *
 * @brief Get PFC Deadlock mechanism debug info 
 *
 * @param [in]  unit            - unit id
 * @param [in]  ethu_id         - Ethrnet unit ID
 * @param [out]  ethu_port_num   - Port internal for the ETHU that is currently in deadlock
 * @param [out]  pfc_num         - PFC that is currently in deadlock
 */
int imb_pfc_deadlock_debug_info_get(
    int unit,
    int ethu_id,
    int *ethu_port_num,
    int *pfc_num);

/*! 
 * imb_pfc_deadlock_max_duration_set
 *
 * @brief PFC Deadlock recovery mechanism max duration of PFC set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  ethu_id         - Ethrnet unit ID
 * @param [in]  max_duration    - PFC duration that will trigger the Deadlock breaking mechanism
 */
int imb_pfc_deadlock_max_duration_set(
    int unit,
    int ethu_id,
    uint32 max_duration);
/*! 
 * imb_pfc_deadlock_max_duration_get
 *
 * @brief PFC Deadlock recovery mechanism max duration of PFC set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  ethu_id         - Ethrnet unit ID
 * @param [out]  max_duration    - PFC duration that will trigger the Deadlock breaking mechanism
 */
int imb_pfc_deadlock_max_duration_get(
    int unit,
    int ethu_id,
    uint32 *max_duration);

/*! 
 * imb_port_phy_control_validate
 *
 * @brief Check if phy control is supported for current PM. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  type            - Phy Control type
 * @param [in]  is_set          - if this fuction is called by set function
 */
int imb_port_phy_control_validate(
    int unit,
    bcm_port_t port,
    bcm_port_phy_control_t type,
    int is_set);

/*! 
 * imb_port_pre_add_validate_wrap
 *
 * @brief Finds port relevant IMB info and dispatches. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  phys            - port phys
 */
int imb_port_pre_add_validate_wrap(
    int unit,
    bcm_port_t port,
    bcm_pbmp_t phys);

/*! 
 * imb_port_pre_add_validate
 *
 * @brief  Checks port validaity in a early stage before any DB is modified 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  phys            - port phys
 */
int imb_port_pre_add_validate(
    int unit,
    bcm_port_t port,
    bcm_pbmp_t phys);

/*! 
 * imb_port_autoneg_ability_verify
 *
 * @brief Verify input AN abilities. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  num_ability     - number of abilities
 * @param [in]  abilities       - array of abilities
 */
int imb_port_autoneg_ability_verify(
    int unit,
    bcm_port_t port,
    int num_ability,
    const bcm_port_speed_ability_t * abilities);

/*! 
 * imb_port_pcs_lane_map_set
 *
 * @brief Configure PCS lane map. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  tx_lane_swap    - Tx lane map
 * @param [in]  rx_lane_swap    - Rx lane map
 */
int imb_port_pcs_lane_map_set(
    int unit,
    bcm_port_t port,
    uint32 tx_lane_swap,
    uint32 rx_lane_swap);

/*! 
 * imb_port_link_status_change_event
 *
 * @brief Action on link status change 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int imb_port_link_status_change_event(
    int unit,
    bcm_port_t port);

/*! 
 * imb_alternative_port_set
 *
 * @brief Configure alternative ports for FlexE PHY ports. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  alter_ports     - phys associated with imb instance
 */
int imb_alternative_port_set(
    int unit,
    bcm_port_t port,
    const bcm_pbmp_t * alter_ports);

/*! 
 * imb_port_l1_mismatch_rate_rx_config_set
 *
 * @brief Configure L1 Mismatch rate configuration for RMC. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  tx_speed        - the Tx speed
 * @param [in]  enable          - enable or disable the L1 mismatch rate config in Rx
 */
int imb_port_l1_mismatch_rate_rx_config_set(
    int unit,
    bcm_port_t port,
    int tx_speed,
    int enable);

/*! 
 * imb_port_post_ber_proj_get
 *
 * @brief Get th BER histogram and port-FEC estimation values 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  lane            - lane number
 * @param [in]  ber_proj        - pointer to the BER projection parameters
 * @param [in]  max_errcnt      - size of max_errcnt
 * @param [out]  errcnt_array    - pointer to the errcnt_array array for storing post-FEC estimation values
 * @param [out]  actual_errcnt   - actual number of errcnt in errcnt_array
 */
int imb_port_post_ber_proj_get(
    int unit,
    bcm_port_t port,
    int lane,
    const bcm_port_ber_proj_params_t * ber_proj,
    int max_errcnt,
    bcm_port_ber_proj_analyzer_errcnt_t * errcnt_array,
    int *actual_errcnt);

/*! 
 * imb_flexe_core_port_config_set
 *
 * @brief FlexE core port related configuration. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flexe_core_port   - flexe_core_port
 * @param [in]  speed           - flexe physical port speed
 */
int imb_flexe_core_port_config_set(
    int unit,
    bcm_port_t port,
    int flexe_core_port,
    int speed);

/*! 
 * imb_portmod_add_info_config
 *
 * @brief Initialize Portmod add_info before calling portmod_port_add. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  add_info        - Portmod port add info
 */
int imb_portmod_add_info_config(
    int unit,
    bcm_port_t port,
    portmod_port_add_info_t * add_info);

#endif /*_IMB_H_*/
