/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#ifndef BCMINT_LTSW_L2_INT_H
#define BCMINT_LTSW_L2_INT_H

#include <bcm/l2.h>
#include <bcm/types.h>
#include <bcm/trunk.h>

#include <bcmlt/bcmlt.h>
#include <sal/sal_types.h>

/*!
 * \brief HA subcomponent id for L2 module.
 */
/*! L2 station control structure. */
#define BCMINT_L2_SUB_COMP_ID_STATION_CTRL 0

/*! L2 age interval. */
#define BCMINT_L2_SUB_COMP_ID_AGE_INTERVAL 1

/*! L2 table view. */
#define BCMINT_L2_SUB_COMP_ID_L2_TABLE_VIEW 2

/*! L2 pvlan port info. */
#define BCMINT_L2_SUB_COMP_ID_L2_PVLAN_PORT_INFO 3

/*! L2 flexctr info for L2 hitbit. */
#define BCMINT_L2_SUB_COMP_ID_L2_FLEXCTR_INFO 4

/*! L2 opaque tag. */
#define BCMINT_L2_SUB_COMP_ID_OPAQUE_TAG 5

/*!
 * \brief Internal L2 traverse callback function.
 *
 * \param [in] unit Unit Number.
 * \param [in] trav_st Traverse cookie.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
typedef int (*l2_traverse_cb_f)(
    int unit,
    void *trav_st);

/*! Traverse entries from H/W. */
#define BCMINT_L2_TRAVERSE_HW 0x0001

/*! Traverse entry with lock. */
#define BCMINT_L2_TRAVERSE_WITH_LOCK 0x0002

/*! Traverse entry with snapshot. */
#define BCMINT_L2_TRAVERSE_WITH_SNAPSHOT 0x0004

/*!
 * \brief L2 traverse structure. This data structure is used to specify LT name, LT entry handle, internal callback for traversing operation.
 */
typedef struct bcmint_l2_traverse_s {

    /*! LT name. */
    const char *lt;

    /*! LT entry handle. */
    bcmlt_entry_handle_t eh;

    /*! Traverse flags. */
    uint32_t flags;

    /*! User callback function. */
    bcm_l2_traverse_cb user_cb;

    /*! Data provided by the user, cookie. */
    void *user_data;

    /*! Internal callback function. */
    l2_traverse_cb_f int_cb;

    /*! Table id(used for ID based API). */
    uint32_t tid;

    /*! Field count in the table(used for ID based API). */
    size_t fld_cnt;

    /*! Internal data. */
    void *internal_data;

} bcmint_l2_traverse_t;

/*!
 * \brief L2 replace destination structure. This data structure is used to specify destination structure for L2 replace op.
 */
typedef struct bcmint_l2_replace_dest_s {

    /*! Module id. */
    bcm_module_t module;

    /*! Port number. */
    bcm_port_t port;

    /*! Trunk group id. */
    bcm_trunk_t trunk;

    /*! Virtual port id. */
    int vp;

} bcmint_l2_replace_dest_t;

/*! Internal flags for L2 replace op. */
#define BCMINT_L2_REPLACE_IGNORE_PORTID 0x0001

/*! Internal flags for L2 hit bit clear op. */
#define BCMINT_L2_REPLACE_CLEAR_HIT_ONLY 0x0002

/*!
 * \brief L2 replace structure. This structure specifies flags, keys, destination, etc info needed for L2 replace op.
 */
typedef struct bcmint_l2_replace_s {

    /*! Replace flags (BCM_L2_REPLACE_XXX). */
    uint32_t flags;

    /*! Internal flags (BCMINT_L2_REPLACE_XXX). */
    uint32_t int_flags;

    /*! L2 address flags. */
    uint32_t key_l2_flags;

    /*! Match key type. */
    int key_type;

    /*! Match mac address. */
    bcm_mac_t key_mac;

    /*! Match vlan. */
    bcm_vlan_t key_vlan;

    /*! Match class id. */
    int key_class_id;

    /*! Match internal priority. */
    int key_int_pri;

    /*! Match destination. */
    bcmint_l2_replace_dest_t match_dest;

    /*! Replacing destination. */
    bcmint_l2_replace_dest_t new_dest;

    /*! User callback. */
    bcm_l2_traverse_cb trav_fn;

    /*! User data. */
    void *user_data;

} bcmint_l2_replace_t;

/*! This flag indicates enable all tunnels termination. */
#define BCMINT_L2_STATION_TUNNEL 0x00000001

/*! This flag indicates configure data to MY_STATION tables. */
#define BCMINT_L2_STATION_OVERLAY 0x00000002

/*!
 * \brief The tupple structure carries one (vlan, gport) tuple info.
 */
typedef struct bcmint_l2_vlan_gport_tuple_s {

    /*! Vlan info. */
    int vlan;

    /*! Gport info. */
    bcm_gport_t gport;

} bcmint_l2_vlan_gport_tuple_t;

/*!
 * \brief This is a tuple link list, each node stores one (vlan, gport) tuple used to exact-match in deleting op.
 */
typedef struct bcmint_l2_tuple_list_s {

    /*! Pointer of next tuple. */
    struct bcmint_l2_tuple_list_s *next;

    /*! Tuple element. */
    bcmint_l2_vlan_gport_tuple_t tuple;

} bcmint_l2_tuple_list_t;

/*! Number of tupple list in hash table. */
#define BCMINT_L2_MAX_HASH_TUPLE_COUNT 61

/*!
 * \brief Internal flags used by tupple control structure.
 */
/*! Do not care VLAN when matching (vlan, gport) tuple. */
#define BCMINT_L2_DONT_CARE_VLAN (1 << 0)

/*! Do not care GPORT when matching (vlan, gport) tuple. */
#define BCMINT_L2_DONT_CARE_GPORT (1 << 1)

/*!
 * \brief The tuple control structure, it contains control info and one hash table of BCMINT_MAX_HASH_TUPLE_COUNT depth, which saves tuple list.
 */
typedef struct bcmint_l2_tuple_ctrl_s {

    /*! Internal flags to indicate there is tuple does not care vlan,gport when matching. */
    uint32_t int_flags;

    /*! Tuple list hash table. */
    bcmint_l2_tuple_list_t *tuple_list[BCMINT_L2_MAX_HASH_TUPLE_COUNT];

    /*! API flags BCM_L2_REPLACE_xxx. */
    uint32_t flags;

} bcmint_l2_tuple_ctrl_t;

/*!
 * \brief L2 event type.
 */
typedef enum bcmint_l2_event_type_s {

    /*! Add event. */
    L2_EVENT_ADD = 0,

    /*! Delete event. */
    L2_EVENT_DELETE = 1,

    /*! Update event. */
    L2_EVENT_UPDATE = 2,

    /*! Learn event. */
    L2_EVENT_LEARN = 3,

    /*! Age event. */
    L2_EVENT_AGE = 4,

    /*! Station movement event. */
    L2_EVENT_MOVE = 5,

    /*! Last of enum, invalid. */
    L2_EVENT_MAX = 6

} bcmint_l2_event_type_t;

#define BCMINT_L2_EVENT_TYPE_STR \
{ \
    "ADD", \
    "DELETE", \
    "UPDATE", \
    "LEARN", \
    "AGE", \
    "MOVE", \
    "MAX" \
}

/*!
 * \brief L2 event info structure.
 */
typedef struct bcmint_l2_event_info_s {

    /*! Deleted L2 entry. */
    bcm_l2_addr_t del;

    /*! Added L2 entry. */
    bcm_l2_addr_t add;

    /*! Event type. */
    bcmint_l2_event_type_t type;

} bcmint_l2_event_info_t;

/*!
 * \brief L2 host table enum.
 */
typedef enum bcmint_l2_host_table_s {

    /*! L2 host table. */
    BCMINT_L2_HOST_TBL = 0,

    /*! MAC address field. */
    BCMINT_L2_HOST_FLD_MAC_ADDR = 1,

    /*! Virtual forwarding domain field. */
    BCMINT_L2_HOST_FLD_VFI = 2,

    /*! Index of the strength profile table. */
    BCMINT_L2_HOST_FLD_STRENGTH_PROFILE_INDEX = 3,

    /*! Destination object field. */
    BCMINT_L2_HOST_FLD_DESTINATION = 4,

    /*! Destination type field. */
    BCMINT_L2_HOST_FLD_DESTINATION_TYPE = 5,

    /*! Class id field. */
    BCMINT_L2_HOST_FLD_CLASS_ID = 6,

    /*! Destination private VLAN port type field. */
    BCMINT_L2_HOST_FLD_DST_PVLAN_PORT_TYPE = 7,

    /*! VP LAG indicator field. */
    BCMINT_L2_HOST_FLD_DST_VP_GROUP = 8,

    /*! Community private VLAN id field. */
    BCMINT_L2_HOST_FLD_COMMUNITY_PVLAN_ID = 9,

    /*! Nexthop 2 table index or ECMP group 2 table index field. */
    BCMINT_L2_HOST_FLD_NHOP_2_OR_ECMP_GROUP_INDEX_1 = 10,

    /*! ECMP and protection switch profile index field. */
    BCMINT_L2_HOST_FLD_ECMP_AND_PROT_SWT_SFC_PROFILE_INDEX = 11,

    /*! Flex ctr action field. */
    BCMINT_L2_HOST_FLD_FLEX_CTR_ACTION = 12,

    /*! Misc ctrl 0 field. */
    BCMINT_L2_HOST_FLD_MISC_CTRL_0 = 13,

    /*! Misc ctrl 1 field. */
    BCMINT_L2_HOST_FLD_MISC_CTRL_1 = 14,

    /*! Destination entry index field. */
    BCMINT_L2_HOST_FLD_DST_ENTRY_INDEX = 15,

    /*! Source entry index field. */
    BCMINT_L2_HOST_FLD_SRC_ENTRY_INDEX = 16,

    /*! Field element count. */
    BCMINT_L2_HOST_FLD_ELEMENT_CNT = 17,

    /*! The last one, not valid. */
    BCMINT_L2_HOST_COUNT = 18

} bcmint_l2_host_table_t;

#define BCMINT_L2_HOST_TABLE_STR \
{ \
    "TBL", \
    "FLD_MAC_ADDR", \
    "FLD_VFI", \
    "FLD_STRENGTH_PROFILE_INDEX", \
    "FLD_DESTINATION", \
    "FLD_DESTINATION_TYPE", \
    "FLD_CLASS_ID", \
    "FLD_DST_PVLAN_PORT_TYPE", \
    "FLD_DST_VP_GROUP", \
    "FLD_COMMUNITY_PVLAN_ID", \
    "FLD_NHOP_2_OR_ECMP_GROUP_INDEX_1", \
    "FLD_ECMP_AND_PROT_SWT_SFC_PROFILE_INDEX", \
    "FLD_FLEX_CTR_ACTION", \
    "FLD_MISC_CTRL_0", \
    "FLD_MISC_CTRL_1", \
    "FLD_DST_ENTRY_INDEX", \
    "FLD_SRC_ENTRY_INDEX", \
    "FLD_ELEMENT_CNT" \
}

/*!
 * \brief L2 host narrow table enum.
 */
typedef enum bcmint_l2_host_narrow_table_s {

    /*! L2 host narrow table. */
    BCMINT_L2_HOST_NARROW_TBL = 0,

    /*! MAC address field. */
    BCMINT_L2_HOST_NARROW_FLD_MAC_ADDR = 1,

    /*! Virtual forwarding domain field. */
    BCMINT_L2_HOST_NARROW_FLD_VFI = 2,

    /*! Index of the strength profile table. */
    BCMINT_L2_HOST_NARROW_FLD_STRENGTH_PROFILE_INDEX = 3,

    /*! Destination object field. */
    BCMINT_L2_HOST_NARROW_FLD_DESTINATION = 4,

    /*! Destination type field. */
    BCMINT_L2_HOST_NARROW_FLD_DESTINATION_TYPE = 5,

    /*! Misc ctrl 0 field. */
    BCMINT_L2_HOST_NARROW_FLD_MISC_CTRL_0 = 6,

    /*! Misc ctrl 1 field. */
    BCMINT_L2_HOST_NARROW_FLD_MISC_CTRL_1 = 7,

    /*! Flex ctr action field. */
    BCMINT_L2_HOST_NARROW_FLD_FLEX_CTR_ACTION = 8,

    /*! Destination entry index field. */
    BCMINT_L2_HOST_NARROW_FLD_DST_ENTRY_INDEX = 9,

    /*! Source entry index field. */
    BCMINT_L2_HOST_NARROW_FLD_SRC_ENTRY_INDEX = 10,

    /*! Field element count. */
    BCMINT_L2_HOST_NARROW_FLD_ELEMENT_CNT = 11,

    /*! The last one, not valid. */
    BCMINT_L2_HOST_NARROW_COUNT = 12

} bcmint_l2_host_narrow_table_t;

#define BCMINT_L2_HOST_NARROW_TABLE_STR \
{ \
    "TBL", \
    "FLD_MAC_ADDR", \
    "FLD_VFI", \
    "FLD_STRENGTH_PROFILE_INDEX", \
    "FLD_DESTINATION", \
    "FLD_DESTINATION_TYPE", \
    "FLD_MISC_CTRL_0", \
    "FLD_MISC_CTRL_1", \
    "FLD_FLEX_CTR_ACTION", \
    "FLD_DST_ENTRY_INDEX", \
    "FLD_SRC_ENTRY_INDEX", \
    "FLD_ELEMENT_CNT" \
}

/*!
 * \brief L2 learn cache data table enum.
 */
typedef enum bcmint_l2_learn_cache_data_table_s {

    /*! L2 learn cache data table. */
    BCMINT_L2_LEARN_CACHE_DATA_TBL = 0,

    /*! Cache field 0. */
    BCMINT_L2_LEARN_CACHE_DATA_FLD_CACHE_FIELD0 = 1,

    /*! Cache field 1. */
    BCMINT_L2_LEARN_CACHE_DATA_FLD_CACHE_FIELD1 = 2,

    /*! Cache field 2. */
    BCMINT_L2_LEARN_CACHE_DATA_FLD_CACHE_FIELD2 = 3,

    /*! Cache field 3. */
    BCMINT_L2_LEARN_CACHE_DATA_FLD_CACHE_FIELD3 = 4,

    /*! Cache field 4. */
    BCMINT_L2_LEARN_CACHE_DATA_FLD_CACHE_FIELD4 = 5,

    /*! Cache field 5. */
    BCMINT_L2_LEARN_CACHE_DATA_FLD_CACHE_FIELD5 = 6,

    /*! Cache field 6. */
    BCMINT_L2_LEARN_CACHE_DATA_FLD_CACHE_FIELD6 = 7,

    /*! Cache field 7. */
    BCMINT_L2_LEARN_CACHE_DATA_FLD_CACHE_FIELD7 = 8,

    /*! LEARN_CACHE_DATA_INFO logical table index. */
    BCMINT_L2_LEARN_CACHE_DATA_FLD_LEARN_CACHE_DATA_INFO_ID = 9,

    /*! LEARN_CACHE_DATA logical table pipe index. */
    BCMINT_L2_LEARN_CACHE_DATA_FLD_PIPE = 10,

    /*! LEARN_CACHE_DATA logical table index. */
    BCMINT_L2_LEARN_CACHE_DATA_FLD_LEARN_CACHE_DATA_ID = 11,

    /*! Field element count. */
    BCMINT_L2_LEARN_CACHE_DATA_FLD_ELEMENT_CNT = 12,

    /*! The last one, not valid. */
    BCMINT_L2_LEARN_CACHE_DATA_COUNT = 13

} bcmint_l2_learn_cache_data_table_t;

#define BCMINT_L2_LEARN_CACHE_DATA_TABLE_STR \
{ \
    "TBL", \
    "FLD_CACHE_FIELD0", \
    "FLD_CACHE_FIELD1", \
    "FLD_CACHE_FIELD2", \
    "FLD_CACHE_FIELD3", \
    "FLD_CACHE_FIELD4", \
    "FLD_CACHE_FIELD5", \
    "FLD_CACHE_FIELD6", \
    "FLD_CACHE_FIELD7", \
    "FLD_LEARN_CACHE_DATA_INFO_ID", \
    "FLD_PIPE", \
    "FLD_LEARN_CACHE_DATA_ID", \
    "FLD_ELEMENT_CNT" \
}

/*!
 * \brief L2 destination type enum.
 */
typedef enum bcmint_l2_dest_type_s {

    /*! No operation. */
    BCMINT_L2_DEST_TYPE_NO_OP = 0,

    /*! L2 out interface. */
    BCMINT_L2_DEST_TYPE_L2_OIF = 1,

    /*! Reserved. */
    BCMINT_L2_DEST_TYPE_RSVD = 2,

    /*! Virtual port. */
    BCMINT_L2_DEST_TYPE_VP = 3,

    /*! ECMP group. */
    BCMINT_L2_DEST_TYPE_ECMP = 4,

    /*! Nexthop. */
    BCMINT_L2_DEST_TYPE_NHOP = 5,

    /*! L2 multicast group. */
    BCMINT_L2_DEST_TYPE_L2MC_GROUP = 6,

    /*! L3 multicast group. */
    BCMINT_L2_DEST_TYPE_L3MC_GROUP = 7,

    /*! Reserved. */
    BCMINT_L2_DEST_TYPE_RSVD_1 = 8,

    /*! ECMP member. */
    BCMINT_L2_DEST_TYPE_ECMP_MEMBER = 9,

    /*! The last one, not valid. */
    BCMINT_L2_DEST_TYPE_COUNT = 10

} bcmint_l2_dest_type_t;

#define BCMINT_L2_DEST_TYPE_STR \
{ \
    "NO_OP", \
    "L2_OIF", \
    "RSVD", \
    "VP", \
    "ECMP", \
    "NHOP", \
    "L2MC_GROUP", \
    "L3MC_GROUP", \
    "RSVD_1", \
    "ECMP_MEMBER" \
}

/*!
 * \brief L2 destination Private VLAN port type enum.
 */
typedef enum bcmint_l2_dst_pvlan_port_type_s {

    /*! Promiscuous type. */
    BCMINT_L2_DST_PVLAN_PORT_TYPE_PROMISCUOUS = 0,

    /*! Community type. */
    BCMINT_L2_DST_PVLAN_PORT_TYPE_COMMUNITY = 1,

    /*! Isolated type. */
    BCMINT_L2_DST_PVLAN_PORT_TYPE_ISOLATED = 2,

    /*! The last one, not valid. */
    BCMINT_L2_DST_PVLAN_PORT_TYPE_COUNT = 3

} bcmint_l2_dst_pvlan_port_type_t;

#define BCMINT_L2_DST_PVLAN_PORT_TYPE_STR \
{ \
    "PROMISCUOUS", \
    "COMMUNITY", \
    "ISOLATED" \
}

/*!
 * \brief LT ID defined by HSDK.
 */
typedef enum bcmint_l2_xgs_lt_id_s {

    /*! L2 host table. */
    XGS_L2_HOST_TAB_ID = 0,

    /*! L2 my station table. */
    XGS_L2_MY_STATION_ID = 1,

    /*! L2 my station table. */
    XGS_L2_MY_STATION_TRUNK_ID = 2,

    /*! L2 my station table. */
    XGS_L2_MY_STATION_MODPORT_ID = 3,

    /*! L2 underlay my station table. */
    XGS_L2_UNDERLAY_MY_STATION_ID = 4,

    /*! L2 underlay my station table. */
    XGS_L2_UNDERLAY_MY_STATION_TRUNK_ID = 5,

    /*! L2 underlay my station table. */
    XGS_L2_UNDERLAY_MY_STATION_MODPORT_ID = 6,

    /*! L2 cache table. */
    XGS_L2_CACHE_ID = 7,

    /*! L2 dst block table. */
    XGS_L2_DST_BLOCK_ID = 8,

    /*! L2 learn cache table. */
    XGS_L2_LEARN_DATA_ID = 9,

    /*! L2 learn control table. */
    XGS_L2_LEARN_CTRL_ID = 10,

    /*! L2 opaque tag table. */
    XGS_L2_OPAQUE_TAG_ID = 11,

    /*! L2 learn override table. */
    XGS_L2_LEARN_OVERRIDE_ID = 12,

    /*! L2 payload opaque tag table. */
    XGS_L2_PAYLOAD_OPAQUE_TAG_ID = 13,

    /*! Number of L2 table. */
    XGS_L2_MAX_NUM = 14

} bcmint_l2_xgs_lt_id_t;

#define BCMINT_L2_XGS_LT_ID_STR \
{ \
    "HOST_TAB_ID", \
    "MY_STATION_ID", \
    "MY_STATION_TRUNK_ID", \
    "MY_STATION_MODPORT_ID", \
    "UNDERLAY_MY_STATION_ID", \
    "UNDERLAY_MY_STATION_TRUNK_ID", \
    "UNDERLAY_MY_STATION_MODPORT_ID", \
    "CACHE_ID", \
    "DST_BLOCK_ID", \
    "LEARN_DATA_ID", \
    "LEARN_CTRL_ID", \
    "OPAQUE_TAG_ID", \
    "LEARN_OVERRIDE_ID", \
    "PAYLOAD_OPAQUE_TAG_ID", \
    "MAX_NUM" \
}

/*!
 * \brief User data passed to transfer routines.
 */
typedef struct bcmint_l2_trans_data_s {

    /*! LT ID defined by HSDK. */
    bcmint_l2_xgs_lt_id_t hsdk_tid;

    /*! Base address of data structure. */
    void *struct_data;

    /*! Internal offset of a structure member. */
    uint64_t offset;

    /*! Type of a structure member. */
    const char *type;

    /*! Value gotten from or set to a LT field. */
    uint64_t *fld_val;

    /*! String value gotten from or set to a LT field. */
    const char **fld_str_val;

    /*! Value gotten from or set to assistant fields. */
    uint64_t *ass_fld_val;

    /*! Depth of an array field. */
    int array_depth;

    /*! User data. */
    void *cookie;

} bcmint_l2_trans_data_t;

/*!
 * \brief Transfer data of LT field to value of structure member variables. Vice versa.
 *
 * \param [in] unit Unit Number.
 * \param [in/out] param Parameters used to transfer data.
 * \param [in] dir Parse data from LT field, or populate data to LT field.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
typedef int (*l2_fld_to_mem_trans_f)(
    int unit,
    bcmint_l2_trans_data_t *param,
    int dir);

/*!
 * \brief Map value of a master field to value of a structure member.
 */
typedef struct bcmint_l2_sym_map_s {

    /*! String value of master field. */
    const char *sym_str_val;

    /*! Value of master field. */
    uint64_t sym_val;

    /*! If field value is matched, value of mem_val will be assigned to the structure member. */
    uint64_t mem_val;

    /*! |, =, & or n. */
    char op;

    /*! ID of assist fields. */
    uint32_t ass_fid;

} bcmint_l2_sym_map_t;

/*!
 * \brief Map value of fields to value of a structure member.
 */
typedef struct bcmint_l2_fld_map_s {

    /*! Internal offset of a structure member. */
    uint64_t offset;

    /*! Type of a structure member. */
    const char *type;

    /*! Master field can have slave fields.\n One slave field can be selected and decoded \n according to current value of master field. */
    const bcmint_l2_sym_map_t *sym_map;

    /*! If field value is 1, the value of flags_val will be used by | mode. */
    uint32_t flag_val;

    /*! Routine transfers field data to structure member value. Vice versa. */
    l2_fld_to_mem_trans_f trans;

    /*! Depth of an array field. */
    int array_depth;

    /*! Field can be filtered out. */
    uint32_t filter;

} bcmint_l2_fld_map_t;

/*!
 * \brief L2 id map structure.
 */
typedef struct bcmint_l2_id_map_s {

    /*! Index of the mapped object. */
    int idx;

    /*! Map value. */
    uint32_t val;

    /*! Bind LT field to structure member variable. */
    const bcmint_l2_fld_map_t *map;

} bcmint_l2_id_map_t;

/*!
 * \brief Transfer data of fields to value of members of structure. Vice versa.\n And map global LT ID defined by HSDK with chip specific LT ID defined by SDKLT.
 */
typedef struct bcmint_l2_map_info_s {

    /*!  LT ID defined by HSDK. */
    bcmint_l2_xgs_lt_id_t hsdk_tid;

    /*! LT ID defined by SDKLT per chip. */
    uint32_t sdklt_tid;

    /*! LT Name defined by SDKLT per chip. */
    const char *lt_name;

    /*! Field count of LT. */
    uint32_t fld_cnt;

    /*! Information used to transfer data. */
    const bcmint_l2_id_map_t *id_map;

    /*! Depth of id_map. */
    int depth;

} bcmint_l2_map_info_t;

/*!
 * \brief L2 id map handle.
 */
/*! L2 host table handle. */
#define BCMINT_L2_MAP_IH_HOST_TABLE 0

/*! L2 host narrow table handle. */
#define BCMINT_L2_MAP_IH_HOST_NARROW_TABLE 1

/*! L2 learn cache data table handle. */
#define BCMINT_L2_MAP_IH_LEARN_CACHE_DATA_TABLE 2

/*!
 * \brief L2 id map database structure.
 */
typedef struct bcmint_l2_id_map_db_s {

    /*! L2 id map handle(BCMINT_L2_MAP_IH_XXX). */
    int hdl;

    /*! Map info. */
    const bcmint_l2_id_map_t *info;

    /*! Num of elements in map info. */
    int num;

} bcmint_l2_id_map_db_t;

/*!
 * \brief L2 string map structure.
 */
typedef struct bcmint_l2_str_map_s {

    /*! Index of the mapped object. */
    int idx;

    /*! Map string. */
    const char * str;

} bcmint_l2_str_map_t;

/*!
 * \brief L2 string map handle.
 */
/*! L2 destination type handle. */
#define BCMINT_L2_MAP_SH_DEST_TYPE 0

/*! Destination Private VLAN port type handle. */
#define BCMINT_L2_MAP_SH_DST_PVLAN_PORT_TYPE 1

/*!
 * \brief L2 string map database structure.
 */
typedef struct bcmint_l2_str_map_db_s {

    /*! L2 string map handle(BCMINT_L2_MAP_SH_XXX). */
    int hdl;

    /*! Map info. */
    const bcmint_l2_str_map_t *info;

    /*! Num of elements in map info. */
    int num;

} bcmint_l2_str_map_db_t;

/*!
 * \brief L2 map database structure.
 */
typedef struct bcmint_l2_map_db_s {

    /*! ID database. */
    const bcmint_l2_id_map_db_t *id_db;

    /*! Num of elements in ID database. */
    int id_num;

    /*! String database. */
    const bcmint_l2_str_map_db_t *str_db;

    /*! Num of elements in string database. */
    int str_num;

} bcmint_l2_map_db_t;

/*!
 * \brief Flexctr info structure for L2 hit.
 */
typedef struct bcmint_l2_flexctr_info_s {

    /*! Counter id for UFT dest hit action. */
    uint32_t uft_dst_id;

    /*! Counter id for UFT src hit action. */
    uint32_t uft_src_id;

    /*! counter id for non-UFT dst hit action. */
    uint32_t dst_id;

    /*! Counter id for non-UFT src hit action. */
    uint32_t src_id;

    /*! Counter group id for dst group action. */
    uint32_t dst_grp_id;

    /*! Counter group id for src group action. */
    uint32_t src_grp_id;

} bcmint_l2_flexctr_info_t;

/*!
 * \brief The function is to find if one (vlan, gport) tuple exists in given tuple array.
 *
 * \param [in] unit Unit Number.
 * \param [in] tuple_ctrl Tuple control structure.
 * \param [in] tuple Tuple to match.
 */
extern bool
bcmint_l2_tuple_find(
    int unit,
    bcmint_l2_tuple_ctrl_t *tuple_ctrl,
    bcmint_l2_vlan_gport_tuple_t tuple);

/*!
 * \brief Get L2 station entry from data base with given key.
 *
 * \param [in] unit Unit Number.
 * \param [in] station L2 station entry.
 * \param [out] tnl tunnel.
 */
extern bool
bcmint_l2_station_db_get(
    int unit,
    bcm_l2_station_t *station,
    bool *tnl);

/*!
 * \brief Get amount of customer callbacks.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
extern int
bcmint_l2_callback_num(int unit);

/*!
 * \brief This function is to notify assist thread of corresponding L2 event.
 *
 * \param [in] unit Unit Number.
 * \param [in] l2_addr_add Added L2 entry.
 * \param [in] l2_addr_del Deleted L2 entry.
 * \param [in] type Entry type.
 */
extern void
bcmint_l2_event_notify(
    int unit,
    bcm_l2_addr_t *l2_addr_add,
    bcm_l2_addr_t *l2_addr_del,
    bcmint_l2_event_type_t type);

#endif /* BCMINT_LTSW_L2_INT_H */
