/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#ifndef BCMINT_LTSW_FLOW_INT_H
#define BCMINT_LTSW_FLOW_INT_H

#include <bcm/types.h>

#include <sal/sal_types.h>

/*!
 * \brief Defines handle ID for each flow.
 */
typedef struct bcmint_flow_handle_rec_s {

    /*! A string to identify flow. */
    char *flow_name;

    /*! Internal ID for flow. */
    uint32_t flow_handle;

} bcmint_flow_handle_rec_t;

/*!
 * \brief FLOW vairant specific LT field description.
 */
typedef struct bcmint_flow_fld_s {

    /*! LT field name. */
    const char *name;

} bcmint_flow_fld_t;

/*!
 * \brief FLOW vairant specific LT description.
 */
typedef struct bcmint_flow_lt_s {

    /*! LT name. */
    const char *name;

    /*! Bitmap of valid fields. */
    uint64_t fld_bmp;

    /*! LT fields. */
    const bcmint_flow_fld_t *flds;

} bcmint_flow_lt_t;

/*!
 * \brief FLOW variant specific LT database description.
 */
typedef struct bcmint_flow_lt_db_s {

    /*! LT bitmap. */
    uint32_t lt_bmp;

    /*! LT array. */
    const bcmint_flow_lt_t *lts;

} bcmint_flow_lt_db_t;

/*!
 * \brief EGR_DVP variant specific LT fields.
 */
typedef enum bcmint_flow_fld_egr_dvp_s {

    /*! Layer 2 MTU check value. */
    BCMINT_LTSW_FLOW_FLD_EGR_DVP_L2_MTU_VALUE = 0,

    /*! Process control 2. */
    BCMINT_LTSW_FLOW_FLD_EGR_DVP_PROCESS_CTRL_2 = 1,

    /*! EGR_DVP vairant specific LT field count. */
    BCMINT_LTSW_FLOW_FLD_EGR_DVP_FLD_CNT = 2

} bcmint_flow_fld_egr_dvp_t;

#define BCMINT_FLOW_FLD_EGR_DVP_STR \
{ \
    "L2_MTU_VALUE", \
    "PROCESS_CTRL_2", \
    "FLD_CNT" \
}

/*!
 * \brief FLOW variant specific LTs.
 */
typedef enum bcmint_flow_lt_id_s {

    /*! LT EGR_DVP. */
    BCMINT_LTSW_FLOW_LT_EGR_DVP = 0,

    /*! FLOW variant specific LT count. */
    BCMINT_LTSW_FLOW_LT_CNT = 1

} bcmint_flow_lt_id_t;

#define BCMINT_FLOW_LT_ID_STR \
{ \
    "EGR_DVP", \
    "CNT" \
}

/*!
 * \brief Flow HA subcomponent ID.
 */
typedef enum bcmint_flow_ha_sub_comp_id_s {

    /*! HA sub component id for tunnel ID mapping. */
    bcmintFlowHaTnlInitIdMap = 0,

    /*! HA sub component id for L2 ingress interface mapping. */
    bcmintFlowHaL2iifMap = 1,

    /*! HA sub component id for VP match info. */
    bcmintFlowHaVpMatch = 2,

    /*! Flow HA sub component ID count. */
    bcmintFlowHaCount = 3

} bcmint_flow_ha_sub_comp_id_t;

#define BCMINT_FLOW_HA_SUB_COMP_ID_STR \
{ \
    "TnlInitIdMap", \
    "L2iifMap", \
    "VpMatch" \
}

/*!
 * \brief  Internal ID for flow.
 */
/*! Virtual Extensible LAN With IPv4 Encapsulation. */
#define BCMINT_FLOW_ID_CLASSIC_VXLAN 1

/*! Generic Network Virtualization Encapsulation. */
#define BCMINT_FLOW_ID_GENEVE 2

/*! Generic Protocol Extension for VXLAN. */
#define BCMINT_FLOW_ID_GPE 3

/*! In-band Network Telemetry. */
#define BCMINT_FLOW_ID_INT 4

/*! MPLS packets over generic routing encapsulation. */
#define BCMINT_FLOW_ID_MPLS_OVER_GRE 5

/*! Network Service Header. */
#define BCMINT_FLOW_ID_NSH 6

/*! Virtual Extensible LAN With IPv6 Encapsulation. */
#define BCMINT_FLOW_ID_VXLAN 7

/*!
 * \brief  Internal ID for flow function.
 */
/*! Flow function ID start delimiter. */
#define BCMINT_FLOW_FUNC_ID_START 0

/*! Flow match ID. */
#define BCMINT_FLOW_FUNC_MATCH_ID 1

/*! Flow encap ID */
#define BCMINT_FLOW_FUNC_ENCAP_ID 2

/*! Flow tunnel initiator ID */
#define BCMINT_FLOW_FUNC_TUNNEL_INITIATOR_ID 3

/*! Flow tunnel terminator ID */
#define BCMINT_FLOW_FUNC_TUNNEL_TERMINATOR_ID 4

/*! Flow encap set ID */
#define BCMINT_FLOW_FUNC_ENCAP_SET_ID 5

/*! Flow L2 switch ID */
#define BCMINT_FLOW_FUNC_L2_SWITCH_ID 6

/*! Flow L3 host lookup ID */
#define BCMINT_FLOW_FUNC_L3_HOST_ID 7

/*! Flow L3 route lookup ID */
#define BCMINT_FLOW_FUNC_L3_ROUTE_ID 8

/*! Flow egress object ID */
#define BCMINT_FLOW_FUNC_EGRESS_OBJ_ID 9

/*! Flow egress interface ID */
#define BCMINT_FLOW_FUNC_EGRESS_INTF_ID 10

/*! Flow function ID end delimiter */
#define BCMINT_FLOW_FUNC_ID_END 11

/*!
 * \brief  Internal ID for logical field.
 */
/*! Device ID */
#define BCMINT_FLOW_LF_ID_INT_DEVICE_ID 1

/*! Template ID */
#define BCMINT_FLOW_LF_ID_INT_TEMPLATE_ID 2

/*! Opaque meta data 1 */
#define BCMINT_FLOW_LF_ID_INT_OPAQUE_MD1 3

/*! Opaque meta data 2 */
#define BCMINT_FLOW_LF_ID_INT_OPAQUE_MD2 4

/*! Invalid logical field ID. */
#define BCMINT_FLOW_LF_ID_INVALID (0xFFFFFFFF)

/*! Max length of logical field name. */
#define BCMINT_FLOW_LF_NAME_LEN_MAX (0x20)

/*!
 * \brief  Defines mapping of logical field name and internal ID.
 */
typedef struct bcmint_flow_lf_map_rec_s {

    /*! A string to identify legacy logical field name. */
    char *lf_name;

    /*! Internal ID for logical field. */
    uint32_t lf_id;

    /*! A string to identify new logical field name. */
    const char *new_lf_name;

} bcmint_flow_lf_map_rec_t;

/*!
 * \brief  Internal ID for flow option.
 */
/*! VXLAN IPv6 match, lookup VNID to assign VFI. */
#define BCMINT_FLOW_OPT_ID_LOOKUP_VNID_ASSIGN_VFI 1

/*! VXLAN IPv6 match, lookup IPv6 SIP to assign SVP. */
#define BCMINT_FLOW_OPT_ID_LOOKUP_IPV6_SIP_ASSIGN_SVP 2

/*! VXLAN IPv6 encap, lookup DVP 7 VFI to assign VNID. */
#define BCMINT_FLOW_OPT_ID_LOOKUP_DVP_VFI_ASSIGN_VNID 3

/*! VXLAN IPv6 encap, lookup VFI to assign VNID. */
#define BCMINT_FLOW_OPT_ID_LOOKUP_VFI_ASSIGN_VNID 4

/*! VXLAN IPv6 encap_set, VFI as lookup key. */
#define BCMINT_FLOW_OPT_ID_IPV6_EVXLT_KEY_TYPE_VFI 5

/*! VXLAN IPv6 encap_set, VFI and DVP as lookup key. */
#define BCMINT_FLOW_OPT_ID_IPV6 6

/*! VXLAN IPv6 terminator, lookup IPv6 DIP. */
#define BCMINT_FLOW_OPT_ID_LOOKUP_IPV6_DIP_TERM_TUNNEL 7

/*! VXLAN IPv6 initiator, use entropy as flow label. */
#define BCMINT_FLOW_OPT_ID_IPV6_FLOW_LABEL_USE_ENTROPY 8

/*! INT encap_set, assign device ID and template ID. */
#define BCMINT_FLOW_OPT_ID_ASSIGN_DEVICE_ID_TEMPLATE_ID 9

/*! flow option ID for not care case. */
#define BCMINT_FLOW_OPT_ID_ANY (0xFFFFFFFF - 1)

/*! Max length of flow option name. */
#define BCMINT_FLOW_OPT_NAME_LEN_MAX (0x40)

/*!
 * \brief Defines mapping of option name and internal ID.
 */
typedef struct bcmint_flow_op_map_rec_s {

    /*! A string to identify legacy logical field name. */
    char *op_name;

    /*! Internal ID for logical field. */
    uint32_t op_id;

} bcmint_flow_op_map_rec_t;

/*! Max length of logical table name. */
#define BCMINT_FLOW_LT_NAME_LEN_MAX (0x20)

/*!
 * \brief Defines mapping of internal option ID and logical table name.
 */
typedef struct bcmint_flow_op_lt_map_rec_s {

    /*! Internal ID for flow option. */
    uint32_t op_id;

    /*! A string to identify logical table name. */
    const char *lt_name;

} bcmint_flow_op_lt_map_rec_t;

/*!
 * \brief Enumerator for mapping info type.
 */
typedef enum bcmint_flow_mapping_info_type_s {

    /*! Flow handle. */
    INFO_SEL_HANDLE = 0,

    /*! Flow option. */
    INFO_SEL_OP = 1,

    /*! Logical field. */
    INFO_SEL_LOGICAL_FIELD = 2,

    /*! Flow option to logical table. */
    INFO_SEL_OP_LOGICAL_TABLE = 3,

    /*! Mapping info type count. */
    INFO_SEL_CNT = 4

} bcmint_flow_mapping_info_type_t;

#define BCMINT_FLOW_MAPPING_INFO_TYPE_STR \
{ \
    "HANDLE", \
    "OP", \
    "LOGICAL_FIELD", \
    "OP_LOGICAL_TABLE", \
    "CNT" \
}

/*!
 * \brief Enumerator for HW operation type.
 */
typedef enum bcmint_flow_hw_opt_type_s {

    /*! Get info from table. */
    HW_OPT_GET = 0,

    /*! Set info to table. */
    HW_OPT_SET = 1,

    /*! Clear table entry. */
    HW_OPT_CLR = 2,

    /*! Operation type count. */
    HW_OPT_CNT = 3

} bcmint_flow_hw_opt_type_t;

#define BCMINT_FLOW_HW_OPT_TYPE_STR \
{ \
    "GET", \
    "SET", \
    "CLR", \
    "CNT" \
}

/*! Reserved VNID for internal use. */
#define BCMINT_FLOW_VNID_RESERVED (0x0)

/*! Reserved class ID for internal use */
#define BCMINT_FLOW_CLASS_ID_RESERVED (0x0)

/*! Reserved virtual port for internal use  */
#define BCMINT_FLOW_VP_RESERVED (0x0)

/*! Reserved VFI for internal use  */
#define BCMINT_FLOW_VFI_RESERVED (0x0)

/*! Reserved L3 ingress interface for internal use  */
#define BCMINT_FLOW_L3_IIF_RESERVED (0x0)

/*! Reserved egress tunnel index for internal use  */
#define BCMINT_FLOW_EGR_TUNNEL_RESERVED (0x0)

/*! Default VP group for clear operation. */
#define BCMINT_FLOW_VP_GROUP_DEF (0x0)

/*! Default network VP group for clear operation */
#define BCMINT_FLOW_NETWORK_GROUP_DEF (0x0)

/*!
 * \brief Check if given FLOW VPN is valid.
 *
 * \param [in] unit Unit Number.
 * \param [in] vpn VPN ID.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
extern int
bcmint_flow_vpn_is_valid(
    int unit,
    bcm_vpn_t vpn);

/*!
 * \brief Get physical tunnel index based on logical tunnel index.
 *
 * \param [in] unit Unit Number.
 * \param [in] soft_tnl_idx Logical tunnel index.
 * \param [out] tnl_idx Physical tunnel index.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
extern int
bcmint_flow_tunnel_idx_get(
    int unit,
    uint32_t soft_tnl_idx,
    uint32_t *tnl_idx);

/*!
 * \brief Set physical tunnel index to logical tunnel index mapping.
 *
 * \param [in] unit Unit Number.
 * \param [in] soft_tnl_idx Logical tunnel index.
 * \param [in] tnl_idx Physical tunnel index.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
extern int
bcmint_flow_tunnel_idx_set(
    int unit,
    uint32_t soft_tnl_idx,
    uint32_t tnl_idx);

/*!
 * \brief Get physical tunnel index based on logical tunnel index during warmboot.
 *
 * \param [in] unit Unit Number.
 * \param [in] soft_tnl_idx Logical tunnel index.
 * \param [out] tnl_idx Physical tunnel index.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
extern int
bcmint_flow_warmboot_tunnel_idx_get(
    int unit,
    uint32_t soft_tnl_idx,
    uint32_t *tnl_idx);

/*!
 * \brief Get logical tunnel index based on physical tunnel index.
 *
 * \param [in] unit Unit Number.
 * \param [in] tnl_idx Physical tunnel index.
 * \param [out] soft_tnl_idx Logical tunnel index.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
extern int
bcmint_flow_tunnel_sw_idx_get(
    int unit,
    uint32_t tnl_idx,
    uint32_t *soft_tnl_idx);

/*!
 * \brief Get the LT info with a LT ID.
 *
 * \param [in] unit Unit Number.
 * \param [in] lt_id LT ID.
 * \param [out] lt_info LT info.
 *
 * \retval SHR_E_NONE No errors.
 * \retval !SHR_E_NONE Failure.
 */
extern int
bcmint_flow_lt_get(
    int unit,
    bcmint_flow_lt_id_t lt_id,
    const bcmint_flow_lt_t **lt_info);

#endif /* BCMINT_LTSW_FLOW_INT_H */
