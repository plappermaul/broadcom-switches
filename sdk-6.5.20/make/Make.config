# $Id: Make.config,v 1.429.8.1.4.2 2013/07/22 01:39:00 xueming Exp $
# $Copyright: (c) 2005 Broadcom Corp.
# All Rights Reserved.$
#
# Make command configuration for SOC driver and diags.
ifeq (${BCM_HIDE_DISPATCHABLE},1)
# {
CFGFLAGS += -DBCM_HIDE_DISPATCHABLE
# }
endif

ifeq (${WAN_PORT_SUPPORT},1)
# {
CFGFLAGS += -DWAN_PORT_SUPPORT
# }
endif

ifeq (${IPROC_NO_ATL},1)
# {
CFGFLAGS += -DIPROC_NO_ATL
# }
endif

#
# Set a default target if one is not set. If override-target is set,
# then the target will become override-target and a warning is printed
# if the assigned TARGET was different.
#
ifneq ($(strip $(override-target)),)
# {
override TARGET=$(override-target)
# }
endif

#
# If TARGET is not set, default to a Unix target based on host type
#
ifndef TARGET
# {
 uname := $(shell uname -s)
 ifeq ($(filter-out Linux Darwin,$(uname)),)
  ifeq ($(shell uname -m),x86_64)
   TARGET=unix-linux-64
  else
   TARGET=unix-linux
  endif
 endif
 ifeq ($(uname),SunOS)
  TARGET=unix-solaris
 endif
 ifeq ($(uname),NetBSD)
  TARGET=unix-netbsd
 endif
 ifndef	TARGET
  $(error Cannot determine TARGET in Make.config, uname = $(uname))
 endif
# }
endif

export TARGET


#
# Set up the target name, and the target base variables.
#
# target = The full name of the target such as vxworks-bmw
# targetbase = 1st part of target (e.g. vxworks)
# targetplat = 2nd part of target (e.g. x86) if any; otherwise same as 1st
#
target     = ${TARGET}
targetsplt = $(subst -, , ${target})	# change hyphens to spaces
targetbase = $(word 1,${targetsplt})
targetplat = $(subst ${targetbase}-,,${TARGET})
#targetplat = $(lastword ,${targetsplt})

#
# Common configuration for all platforms
# (Additional platform-dependent configurations are in Makefile.xxx)
#

#
# THIS FILE SHOULD NOT BE MODIFIED LOCALLY, to override, add a file
# $SDK/make/Make.local that sets your local settings, and/or provide
# a path to your settings using the MAKE_LOCAL variable.  If 
# either of these files exists, their values will override those in this makefile.
#
ifdef MAKE_LOCAL
# {
include        ${MAKE_LOCAL}
# }
else
# {
-include	${SDK}/make/Make.local
# }
endif

ifndef	VENDOR_LIST
# {
VENDOR_LIST =	CALHOUN GAMMA BROADCOM
# }
endif
CFGFLAGS += $(foreach vendor,$(VENDOR_LIST), -DVENDOR_$(vendor))
ifeq (BROADCOM,$(findstring BROADCOM,$(VENDOR_LIST)))
    VENDOR_BROADCOM = 1
endif

# Make sure some chip is supported

# Here list EA chipsets
TOMAHAWK3_CHIP_NAMES = BCM_56980_A0 BCM_56980_B0

ESW_CHIP_NAMES = BCM_5675_A0 BCM_56504_A0 BCM_56504_B0 BCM_56314_A0 BCM_56112_A0 \
  BCM_56304_B0 BCM_56102_A0 BCM_56580_A0 BCM_56700_A0 BCM_56800_A0 BCM_56218_A0 \
  BCM_56514_A0 BCM_56624_A0 BCM_56680_A0 BCM_56680_B0 BCM_56224_A0 BCM_56224_B0 BCM_56820_A0 \
  BCM_53314_A0 BCM_56725_A0 BCM_56624_B0 BCM_56634_A0 BCM_56634_B0 \
  BCM_56524_A0 BCM_56524_B0 BCM_56685_A0 BCM_56685_B0 BCM_56334_A0 BCM_56334_B0 \
  BCM_56840_A0 BCM_56840_B0 BCM_56142_A0 BCM_53324_A0 BCM_88732_A0 BCM_56440_A0 \
  BCM_56440_B0 BCM_56640_A0 BCM_56850_A0 BCM_56450_A0 BCM_56450_B0 BCM_56450_B1 BCM_56340_A0 \
  BCM_56150_A0 BCM_53400_A0 BCM_56960_A0 BCM_56860_A0 BCM_56560_A0 BCM_56260_A0 BCM_56260_B0 \
  BCM_56160_A0 BCM_56560_B0 BCM_56270_A0 BCM_56965_A0 BCM_56970_A0 BCM_56980_A0 BCM_56980_B0 \
  BCM_53570_A0 BCM_56870_A0 BCM_53570_B0 BCM_53540_A0 BCM_56670_A0 BCM_56370_A0 BCM_56770_A0 BCM_56670_B0 \
  BCM_56275_A0 BCM_56470_A0 BCM_56070_A0 BCM_56670_C0


# In order to keep backward compatability for J2 gen compilation we map ALL_DNX_CHIPS to ALL_DNX2_CHIPS
ifdef ALL_DNX_CHIPS
# {
ALL_DNX2_CHIPS = 1
# }
endif

DPP_CHIP_NAMES = BCM_88650_A0 BCM_88650_B0 BCM_88660_A0 BCM_88675_A0 BCM_88675_B0 BCM_88375_A0 BCM_88375_B0 BCM_88680_A0 BCM_88470_A0 BCM_88470_B0 BCM_88270_A0 BCM_8206_A0 BCM_88202_A0
DFE_CHIP_NAMES = BCM_88750_A0 BCM_88750_B0 BCM_88754_A0 BCM_88950_A0 BCM_88950_A1 BCM_88770_A1
DNX2_CHIP_NAMES = BCM_88690_A0 BCM_88690_B0 BCM_88800_A0 BCM_88850_A0 BCM_88480_A0 BCM_88480_B0
DNXF_CHIP_NAMES = BCM_88790_A0 BCM_88790_B0

LTSW_XGS_CHIP_NAMES = BCM_56990_A0 BCM_56990_B0 BCM_56996_A0
LTSW_XFS_CHIP_NAMES = BCM_56880_A0 BCM_56780_A0
LTSW_TM_CHIP_NAMES = BCM_56880_A0 BCM_56780_A0 BCM_56990_A0 BCM_56990_B0 BCM_56996_A0
LTSW_CHIP_NAMES = $(LTSW_XGS_CHIP_NAMES) $(LTSW_XFS_CHIP_NAMES)
LTSW_SDKLT_CHIP_NAMES := $(LTSW_CHIP_NAMES)

whereischip = $(origin $(chipname))
seekesw = $(foreach chipname,$(ESW_CHIP_NAMES),$(whereischip))
seekdpp = $(foreach chipname,$(DPP_CHIP_NAMES),$(whereischip))
seekdfe = $(foreach chipname,$(DFE_CHIP_NAMES),$(whereischip))
seekdnx2 = $(foreach chipname,$(DNX2_CHIP_NAMES),$(whereischip))
seekdnxf = $(foreach chipname,$(DNXF_CHIP_NAMES),$(whereischip))
seekltsw = $(foreach chipname,$(LTSW_CHIP_NAMES),$(whereischip))
 
seekth3 = $(foreach chipname,$(TOMAHAWK3_CHIP_NAMES),$(whereischip))

setallesw = $(foreach chipname,$(ESW_CHIP_NAMES),$(eval export $(chipname) = 1))
setalldpp = $(foreach chipname,$(DPP_CHIP_NAMES),$(eval export $(chipname) = 1))
setalldfe = $(foreach chipname,$(DFE_CHIP_NAMES),$(eval export $(chipname) = 1))
setalldnx2 = $(foreach chipname,$(DNX2_CHIP_NAMES),$(eval export $(chipname) = 1))
setalldnxf = $(foreach chipname,$(DNXF_CHIP_NAMES),$(eval export $(chipname) = 1))
setallth3 = $(foreach chipname,$(TOMAHAWK3_CHIP_NAMES),$(eval export $(chipname) = 1))
setallltsw = $(foreach chipname,$(LTSW_CHIP_NAMES),$(eval export $(chipname) = 1))

ifeq (1,$(PORTMOD_STAND_ALONE))
# {
export PORTMOD_STAND_ALONE
BCM_PTL_SPT=1
PHYMOD_SUPPORT=1
PORTMOD_SUPPORT=1
CFLAGS += -DPORTMOD_STAND_ALONE
# }
endif

ifdef BCM_PTL_SPT
# {
  ifdef ALL_TOMAHAWK3_CHIPS
    $(setallth3)
    export BCM_ESW_SUPPORT = 1
    export BCM_TOMAHAWK3_SUPPORT = 1
    export BCM_ALL_CHIPS = 1
    CFGFLAGS+=-DBCM_ALL_CHIPS
  endif

  ifdef ALL_ESW_CHIPS
    $(setallesw)
    export BCM_ESW_SUPPORT = 1
    export BCM_ALL_CHIPS = 1
    CFGFLAGS+=-DBCM_ALL_CHIPS
  endif

  ifdef ALL_DPP_CHIPS
    $(setalldpp)
  endif

  ifdef ALL_DFE_CHIPS
    $(setalldfe)
  endif

  ifdef ALL_DNX2_CHIPS
    $(setalldnx2)
  endif

  ifdef ALL_DNXF_CHIPS
    $(setalldnxf)
  endif

  ifdef ALL_LTSW_CHIPS
    $(setallltsw)
  endif

  ifneq "$(findstring file,$(seekesw))" ""
    ESW_CHIPS = 1
    export ESW_CHIPS
  endif

  ifneq "$(findstring file,$(seekdpp))" ""
    DPP_CHIPS = 1
    export DPP_CHIPS
  endif
  
  ifneq "$(findstring file,$(seekdfe))" ""
    DFE_CHIPS = 1
    export DFE_CHIPS
  endif
  
  ifneq "$(findstring file,$(seekdnx2))" ""
    DNX2_CHIPS = 1
    export DNX2_CHIPS
  endif

  ifneq "$(findstring file,$(seekdnxf))" ""
    DNXF_CHIPS = 1
    export DNXF_CHIPS
  endif

  ifneq "$(findstring file,$(seekth3))" ""
    TOMAHAWK3_CHIPS = 1
  endif

  ifneq "$(findstring file,$(seekltsw))" ""
    LTSW_CHIPS = 1
    export LTSW_CHIPS
  endif

ifndef ESW_CHIPS
# {
ifndef DPP_CHIPS
# {
ifndef DFE_CHIPS
# {
ifndef DNX2_CHIPS
# {
ifndef DNXF_CHIPS
# {
ifndef TOMAHAWK3_CHIPS
# {
ifndef LTSW_CHIPS
# {
ifndef PORTMOD_STAND_ALONE #Compile without chips is allowed in case of portmod stand alone
# {
ifneq (C_COMPILER,$(MAKECMDGOALS))
# {
  $(error "BCM_PTL_SPT defined, and no valid chip names were defined")
# }
endif
# }
endif
# }
endif
# }
endif
# }
endif
# }
endif
# }
endif
# }
endif
# }
endif

# }
else # BCM_PTL_SPT
# {

ifdef ALL_CHIPS
# {
  ESW_CHIPS = 1
  DPP_CHIPS = 1
  DFE_CHIPS = 1
  DNX2_CHIPS = 1
  DNXF_CHIPS = 1
  TOMAHAWK3_CHIPS = 1
  LTSW_CHIPS = 1
# }
else
# {
  ifndef ESW_CHIPS
	# Check if ESW support exist
	ifeq ($(shell test -d $(SDK)/src/bcm/esw; echo $$?),0)
            ESW_CHIPS = 1
            export ESW_CHIPS
      	endif
  endif
  ifndef TOMAHAWK3_CHIPS
	# Check if Tomahawk3 support exist
        ifeq ($(shell test -d $(SDK)/src/bcm/tomahawk3; echo $$?),0)
            TOMAHAWK3_CHIPS = 1
            export TOMAHAWK3_CHIPS
        endif
  endif

  ifdef ALL_DPP_CHIPS
    DPP_CHIPS=1
    export DPP_CHIPS
  endif

  ifdef ALL_DFE_CHIPS
    DFE_CHIPS=1
    export DFE_CHIPS
  endif

  ifdef ALL_DNX2_CHIPS
    DNX2_CHIPS=1
    export DNX2_CHIPS
  endif

  ifdef ALL_DNXF_CHIPS
    DNXF_CHIPS=1
    export DNXF_CHIPS
  endif

  ifdef ALL_LTSW_CHIPS
    LTSW_CHIPS=1
    export LTSW_CHIPS
  endif

# }
endif # ALL_CHIPS

# }
endif # BCM_PTL_SPT

#
# Check for incompatible reload options
#

ifneq (,$(findstring -DBCM_WARM_BOOT_SUPPORT,$(CFGFLAGS)))
# {
ifneq (,$(findstring -DBCM_EASY_RELOAD_SUPPORT,$(CFGFLAGS)))
# {
 $(error "BCM_WARM_BOOT_SUPPORT and BCM_EASY_RELOAD_SUPPORT should not be enabled at the same time")
# }
endif
# }
endif

#
# SDKLT-based devices should specify the $$SDKLT envrionment.
#
ifdef LTSW_CHIPS

ifeq ($(shell test -d $(SDK)/libs/sdklt; echo $$?),0)
SDKLT = $(SDK)/libs/sdklt
ifndef SDKLT_IS_INTERNAL_LIB
SDKLT_IS_INTERNAL_LIB = 0
endif
else

ifeq (1,1)
$(error 'Can not find sdklt source tree under $(SDK)/libs directory.')
endif
endif

BUILD_SDKLT=1
ifneq (,$(findstring -DBCM_WARM_BOOT_SUPPORT,$(CFGFLAGS)))
ISSU_SUPPORT=1
endif

endif # LTSW_CHIPS

#
# Required for building ISSU support.
#
ifeq (1,$(ISSU_SUPPORT))
ifneq (,$(SDK_VER_START))
BUILD_BCMISSU_DLL = 1
BUILD_ISSU_DLL = 1
endif

ifeq (1,$(SDKLT_IS_INTERNAL_LIB))
SDKLT_VER_START ?= $(SDK_VER_START)
endif

ifneq (,$(SDKLT_VER_START))
BUILD_SDKISSU_DLL = 1
BUILD_ISSU_DLL = 1
endif

ifndef LINK_STATIC
LINK_STATIC = 0
endif
endif # ISSU_SUPPORT == 1

#
# SDKLT needs the version information for construct ISSU DB.
#
ifeq (1,$(BUILD_SDKLT))
ifeq (,$(SDK_VER))
SDK_VER = $(subst sdk-,,$(shell cat $(SDK)/RELEASE))
endif

ifeq (1,$(SDKLT_IS_INTERNAL_LIB))
SDKLT_VER ?= $(SDK_VER)
endif

ifeq (,$(SDKLT_VER))
SDKLT_VER = $(shell cat $(SDKLT)/RELEASE)
endif
endif # BUILD_SDKLT == 1

#
# SDKLT needs to link libdl library.
#
ifeq (1,$(BUILD_SDKLT))
ifndef LINK_DL
LINK_DL = 1
endif
endif # BUILD_SDKLT == 1

#
# By default, turn off the "changing directory" message.
#

MAKEFLAGS += --no-print-directory

#
# Use gmake by default
#

include ${SDK}/make/Make.tools
include	${SDK}/make/Makefile.${target}

# For make v3.80, eval function cannot be placed inside any ifxxx-endif section
# The bug is fixed in v3.81
eval_fixed_ver := 3.81
eval_fixed := $(filter $(eval_fixed_ver),$(firstword $(sort $(MAKE_VERSION) $(eval_fixed_ver))))

# See Make.local (Make.local.template) to configure chip support

ifndef BCM_PTL_SPT
# {

# Support all chips by default
CFGFLAGS += -DBCM_ALL_CHIPS

ifdef ESW_CHIPS
# {
ifeq ($(eval_fixed),$(eval_fixed_ver))
# {
$(setallesw)
# }
else
# {
BCM_5675_A0 = 1
BCM_56504_A0 = 1
BCM_56504_B0 = 1
BCM_56314_A0 = 1
BCM_56112_A0 = 1
BCM_56304_B0 = 1
BCM_56102_A0 = 1
BCM_56580_A0 = 1
BCM_56700_A0 = 1
BCM_56800_A0 = 1
BCM_56218_A0 = 1
BCM_56514_A0 = 1
BCM_56624_A0 = 1
BCM_56224_A0 = 1
BCM_56224_B0 = 1
BCM_56820_A0 = 1
BCM_53314_A0 = 1
BCM_56725_A0 = 1
BCM_56624_B0 = 1
BCM_56634_A0 = 1
BCM_56634_B0 = 1
BCM_56524_A0 = 1
BCM_56524_B0 = 1
BCM_56685_A0 = 1
BCM_56685_B0 = 1
BCM_56334_A0 = 1
BCM_56334_B0 = 1
BCM_56840_A0 = 1
BCM_56840_B0 = 1
BCM_56142_A0 = 1
BCM_53324_A0 = 1
BCM_56440_A0 = 1
BCM_56440_B0 = 1
BCM_56450_A0 = 1
BCM_56450_B0 = 1
BCM_56450_B1 = 1
BCM_56640_A0 = 1
BCM_56850_A0 = 1
BCM_56340_A0 = 1
BCM_56150_A0 = 1
BCM_53400_A0 = 1
BCM_56960_A0 = 1
BCM_56980_A0 = 1
BCM_56980_B0 = 1
BCM_56160_A0 = 1
BCM_56860_A0 = 1
BCM_56560_A0 = 1
BCM_56260_A0 = 1
BCM_56260_B0 = 1
BCM_56870_A0 = 1
BCM_56275_A0 = 1
BCM_56370_A0 = 1
BCM_56470_A0 = 1
BCM_56770_A0 = 1
BCM_56270_A0 = 1
BCM_56560_B0 = 1
BCM_56670_A0 = 1
BCM_56670_B0 = 1
BCM_56670_C0 = 1
BCM_56965_A0 = 1
BCM_56970_A0 = 1
BCM_53570_A0 = 1
BCM_53570_B0 = 1
BCM_53540_A0 = 1
BCM_56070_A0 = 1
# }
endif
# }
endif

ifdef DNXF_CHIPS
CFGFLAGS += $(strip $(foreach chipname,$(DNXF_CHIP_NAMES), $(if $(value $(chipname)),,-DNO_$(chipname))))
endif # DNXF_CHIPS
ifdef TOMAHAWK3_CHIPS
ifeq ($(eval_fixed),$(eval_fixed_ver))
$(setallth3)
else
BCM_56980_A0 = 1
BCM_56980_B0 = 1
endif
endif

ifdef DPP_CHIPS
# {
$(setalldpp)
# }
endif

ifdef DFE_CHIPS
# {
$(setalldfe)
# }
endif

ifdef DNX2_CHIPS
# {
$(setalldnx2)
# }
endif

ifdef DNXF_CHIPS
# {
$(setalldnxf)
# }
endif

ifdef LTSW_CHIPS
# {
$(setallltsw)
# }
endif

# }
else # BCM_PTL_SPT
# {

# Some chip or chips excluded

ifdef TOMAHAWK3_CHIPS
CFGFLAGS += $(strip $(foreach chipname,$(TOMAHAWK3_CHIP_NAMES), $(if $(value $(chipname)),,-DNO_$(chipname))))
ifdef BCM_56980_A0
BCM_56980_A0 = 1
endif
ifdef BCM_56980_B0
BCM_56980_B0 = 1
endif
endif

ifdef ESW_CHIPS
# {
CFGFLAGS += $(strip $(foreach chipname,$(ESW_CHIP_NAMES), $(if $(value $(chipname)),,-DNO_$(chipname))))
CFGFLAGS += -DUSE_SCACHE_DIRTY_BIT
ifdef BCM_56340_A0
# {
BCM_56640_A0 = 1
# }
endif
ifdef BCM_56440_A0
# {
BCM_56840_A0 = 1
# }
endif
ifdef BCM_56440_B0
# {
BCM_56840_A0 = 1
# }
endif
ifdef BCM_56450_A0
# {
BCM_56840_A0 = 1
# }
endif
ifdef BCM_56450_B0
# {
BCM_56840_A0 = 1
# }
endif
ifdef BCM_56450_B1
# {
BCM_56840_A0 = 1
# }
endif
ifdef BCM_56260_A0
# {
BCM_56450_A0 = 1
BCM_56840_A0 = 1
# }
endif
ifdef BCM_56260_B0
# {
BCM_56450_A0 = 1
BCM_56840_A0 = 1
# }
endif
ifdef BCM_56270_A0
# {
BCM_56260_A0 = 1
BCM_56450_A0 = 1
BCM_56840_A0 = 1
# }
endif
ifdef BCM_56560_B0
# {
BCM_56560_A0 = 1
# }
endif
ifdef BCM_56670_A0
#{
BCM_56670_A0 = 1
# }
endif
ifdef BCM_56670_B0
#{
BCM_56670_B0 = 1
# }
endif
ifdef BCM_56670_C0
#{
BCM_56670_C0 = 1
# }
endif
endif # ESW_CHIPS

ifdef DPP_CHIPS
# {
CFGFLAGS += $(strip $(foreach chipname,$(DPP_CHIP_NAMES), $(if $(value $(chipname)),,-DNO_$(chipname))))
# }
endif # DPP_CHIPS

ifdef DFE_CHIPS
# {
CFGFLAGS += $(strip $(foreach chipname,$(DFE_CHIP_NAMES), $(if $(value $(chipname)),,-DNO_$(chipname))))
# }
endif # DFE_CHIPS

ifdef DNX2_CHIPS
# {
CFGFLAGS += $(strip $(foreach chipname,$(DNX2_CHIP_NAMES), $(if $(value $(chipname)),,-DNO_$(chipname))))
# }
endif # DNX2_CHIPS

ifdef DNXF_CHIPS
# {
CFGFLAGS += $(strip $(foreach chipname,$(DNXF_CHIP_NAMES), $(if $(value $(chipname)),,-DNO_$(chipname))))
# }
endif # DNXF_CHIPS

# }
endif # BCM_PTL_SPT

ifdef LTSW_CHIPS
LTSW_CHIP_CFGFLAGS = -DBCMDRD_INCLUDE_CUSTOM_CONFIG
LTSW_INCLUDE_XGS_CHIP_NAMES = $(strip $(foreach chipname,$(LTSW_XGS_CHIP_NAMES),\
                                        $(if $(value $(chipname)),$(chipname),)))
LTSW_INCLUDE_XFS_CHIP_NAMES = $(strip $(foreach chipname,$(LTSW_XFS_CHIP_NAMES),\
                                        $(if $(value $(chipname)),$(chipname),)))
LTSW_INCLUDE_TM_CHIP_NAMES = $(strip $(foreach chipname,$(LTSW_TM_CHIP_NAMES),\
                                        $(if $(value $(chipname)),$(chipname),)))

ifneq (,$(LTSW_INCLUDE_XGS_CHIP_NAMES))
LTSW_INCLUDE_XGS=1
endif
ifneq (,$(LTSW_INCLUDE_XFS_CHIP_NAMES))
LTSW_INCLUDE_XFS=1
endif
ifneq (,$(LTSW_INCLUDE_TM_CHIP_NAMES))
LTSW_INCLUDE_TM=1
endif
LTSW_INCLUDE_CHIP_NAMES = $(LTSW_INCLUDE_XGS_CHIP_NAMES) \
                          $(LTSW_INCLUDE_XFS_CHIP_NAMES)
LTSW_INCLUDE_CHIPS = $(strip $(subst BCM_,BCM,$(LTSW_INCLUDE_CHIP_NAMES)))
LTSW_INCLUDE_CHIP_DEVS = $(strip $(foreach chipname,$(LTSW_INCLUDE_CHIPS),\
                                   $(word 1,$(subst _, ,$(chipname)))))

LTSW_CHIP_STD_NAMES = $(strip $(subst BCM_,BCM,$(LTSW_CHIP_NAMES)))
LTSW_CHIP_DEVS = $(strip $(foreach chipname,$(LTSW_CHIP_STD_NAMES),\
                                   $(word 1,$(subst _, ,$(chipname)))))
LTSW_CHIP_REVS = A0 B0 C0
devid = $(strip $(word 1,$(subst _, ,$(1))))
devid_cnt = $(words $(filter $(1),$(2)))
revid = $(strip $(word 2,$(subst _, ,$(1))))
revid_converter = $(if $(findstring $(1),$(strip $(2))),$(shell echo $(1) | tr 0 x),$(1))
revid_suffix = $(call revid_converter,$(call revid,$(1)),$(2))
revid_no_need = $(findstring x0x,x$(shell expr $(call devid_cnt,$(1),$(2)) - 1)x)
chip_def = $(call devid,$(1))$(if $(call revid_no_need,$(call devid,$(1)),$(2)),,_$(call revid_suffix,$(1),$(3)))
chip_def_construct = $(call chip_def,$(1),$(LTSW_CHIP_DEVS),$(LTSW_CHIP_REVS))

LTSW_INCLUDE_CHIP_DEFS = $(foreach devname,$(LTSW_INCLUDE_CHIPS),\
                                   $(call chip_def_construct,$(devname)))
LTSW_CHIP_CFGFLAGS += $(foreach chipname,$(LTSW_INCLUDE_CHIP_DEFS),\
                        -DBCMDRD_CONFIG_INCLUDE_$(chipname)=1)
LTSW_CHIP_CFGFLAGS += -DBCMDRD_CONFIG_INCLUDE_CHIP_DEFAULT=0
LTSW_LKM_ADD_CPPFLAGS = $(LTSW_CHIP_CFGFLAGS)
LTSW_LKM_ADD_CFLAGS = $(LTSW_CHIP_CFGFLAGS)
CFGFLAGS += $(LTSW_CHIP_CFGFLAGS)
SDK_CHIPS = $(shell echo $(LTSW_INCLUDE_CHIPS) | tr A-Z a-z)
export SDK_CHIPS

ifndef ISSU_CHIPS
ISSU_CHIPS = $(LTSW_INCLUDE_CHIPS)
endif
endif # LTSW_CHIPS

ifndef	FEATURE_LIST
# {

ifdef ESW_CHIPS
# {
_ESW_FEATURE_LIST = L3 I2C MEM_SCAN EDITLINE RCPU OOB_RCPU CUSTOMER \
    TEST CHASSIS CINT PTP BFD TCB PSTATS
#
# CES is only supported on Katana devices.
#
ifdef BCM_56440_A0 
# {
_ESW_FEATURE_LIST += CES
# }
endif
ifdef BCM_56440_B0 
# {
_ESW_FEATURE_LIST += CES
# }
endif
# }
endif

ifdef TOMAHAWK3_CHIPS
_TOMAHAWK3_FEATURE_LIST = L3 I2C MEM_SCAN EDITLINE RCPU OOB_RCPU CUSTOMER \
    TEST CHASSIS CINT PTP BFD
endif

ifdef DPP_CHIPS
# {
_DPP_FEATURE_LIST = L3 EDITLINE CUSTOMER TEST CHASSIS CINT BFD
# }
endif

ifdef DFE_CHIPS
# {
_DFE_FEATURE_LIST = L3 EDITLINE CUSTOMER TEST CHASSIS CINT
# }
endif

ifdef DNX2_CHIPS
# {
  _DNX2_FEATURE_LIST = L3 EDITLINE CUSTOMER TEST CHASSIS CINT BFD
# }
endif # DNX2_CHIPS

ifdef DNXF_CHIPS
# {
_DNXF_FEATURE_LIST = L3 EDITLINE CUSTOMER TEST CHASSIS CINT
# }
endif

ifdef LTSW_CHIPS
# {
_LTSW_FEATURE_LIST = L3 EDITLINE CUSTOMER CINT PTP BFD TCB PSTATS
# }
endif

_ALL_FEATURE_LIST = ${_ESW_FEATURE_LIST} \
    ${_DPP_FEATURE_LIST} \
    ${_DFE_FEATURE_LIST} ${_DNX2_FEATURE_LIST} ${_DNXF_FEATURE_LIST} \
    ${_TOMAHAWK3_FEATURE_LIST} ${_LTSW_FEATURE_LIST}

FEATURE_LIST = $(sort ${_ALL_FEATURE_LIST})

ifeq ($(targetbase),vxworks)
# {
FEATURE_LIST +=	TELNET
FEATURE_LIST += DRIVERS
# }
endif


# end ifndef FEATURE_LIST
# }
endif

ifeq ($(EXTERNAL_FEATURES),ALL)
# {
  FEATURE_LIST += XFLOW_MACSEC 
  FEATURE_LIST += FLEXE
  FEATURE_LIST += FLEXE_DBG
# }
endif
ifeq ($(EXTERNAL_FEATURES),FLEXE)
# {
  FEATURE_LIST += FLEXE
# }
endif
ifeq ($(EXTERNAL_FEATURES),FLEXE_DBG)
# {
  FEATURE_LIST += FLEXE_DBG
# }
endif
ifeq ($(EXTERNAL_FEATURES),XFLOW_MACSEC)
# {
  FEATURE_LIST += XFLOW_MACSEC
# }
endif


# Include board make rules if present
-include ${SDK}/make/Make.boards

# Enable TCL interface
ifdef DNX_TCL
# {
FEATURE_LIST += TCL
# }
endif

# If TCL is enabled then add EDITLINE and ASE_TEST
ifeq (TCL,$(findstring TCL,$(FEATURE_LIST)))

TCLVER=tcl8.3.3
ifdef TCL840
TCLVER=tcl8.4.0
endif

# {
ifneq (EDITLINE,$(findstring EDITLINE,$(FEATURE_LIST)))
# {
FEATURE_LIST += EDITLINE
# }
endif

ifneq (ASE_TEST,$(findstring ASE_TEST,$(FEATURE_LIST)))
# {
FEATURE_LIST += ASE_TEST
# }
endif
# }
endif

# DPP only compiles with BFD
ifdef DPP_CHIPS
# {
ifneq (BFD,$(findstring BFD,$(FEATURE_LIST)))
# {
FEATURE_LIST += BFD
# }
endif
# Uncomment the next three lines to force PTP inclusion for DPP chipsets
#ifneq (PTP,$(findstring PTP,$(FEATURE_LIST)))
#FEATURE_LIST += PTP
#endif
# }
endif

# DNX2 only compiles with BFD
ifdef DNX2_CHIPS
# {
ifneq (BFD,$(findstring BFD,$(FEATURE_LIST)))
# {
FEATURE_LIST += BFD
# }
endif
# Uncomment the next three lines to force PTP inclusion for DNX chipsets
#ifneq (PTP,$(findstring PTP,$(FEATURE_LIST)))
#FEATURE_LIST += PTP
#endif
# }
endif

# If BFD is enabled then add L3
ifeq (BFD,$(findstring BFD,$(FEATURE_LIST)))
# {
ifneq (L3,$(findstring L3,$(FEATURE_LIST)))
# {
FEATURE_LIST += L3
# }
endif
# }
endif

# If CINT is not enabled, filter out APIMODE
ifeq (,$(findstring CINT,$(FEATURE_LIST)))
# {
FEATURE_EXCLUDE_LIST += APIMODE
# }
endif

ifdef NO_SAL_APPL
# {
FEATURE_EXCLUDE_LIST += TCL EDITLINE I2C TELNET DRIVERS CINT APIMODE
CFGFLAGS += -DNO_SAL_APPL -DNO_CTRL_C -DNO_FILEIO -DNO_MEMTUNE
# }
endif


ifdef FEATURE_EXCLUDE_LIST
# {
FEATURE_LIST := $(filter-out $(FEATURE_EXCLUDE_LIST), $(FEATURE_LIST))
# }
endif

# If L3 is not defined, remove MPLS_LM_DM if present.
ifeq (MPLS_LM_DM,$(findstring MPLS_LM_DM,$(FEATURE_LIST)))
# {
ifneq (L3,$(findstring L3,$(FEATURE_LIST)))
# {
FEATURE_LIST := $(filter-out MPLS_LM_DM, $(FEATURE_LIST))
# }
endif
# }
endif

CFGFLAGS += $(foreach feature,$(FEATURE_LIST), -DINCLUDE_$(feature))

ifeq (IPSEC,$(findstring IPSEC,$(FEATURE_LIST)))
DIAG_IPSEC=1
endif

ifneq ($(targetbase),vxworks)
# {
# Make sure that VX_VERSION doesnot indicate VX_WORKS even if set
VX_VERSION = ''
# }
endif

ifndef	DISPATCH_LIST
# {
    ifdef ESW_CHIPS
# {
        DISPATCH_LIST += RPC ESW
# }
    endif
    ifdef TOMAHAWK3_CHIPS
        DISPATCH_LIST += RPC TOMAHAWK3
        ifeq (PKTIO,$(findstring PKTIO,$(FEATURE_LIST)))
            DISPATCH_LIST += TOMAHAWK3X
        endif
    endif
    ifdef LTSW_CHIPS
# {
        DISPATCH_LIST += RPC LTSW
# }
    endif
else # if DISPATCH_LIST defined
#   Since TH3 is a new dispatch table and still comes under ESW,
#   we add TH3 to the dispatch_list
    ifeq (ESW,$(findstring ESW,$(DISPATCH_LIST)))
        ESW_CHIPS = 1
        export ESW_CHIPS
        ifdef TOMAHAWK3_CHIPS
            DISPATCH_LIST += TOMAHAWK3
            ifeq (PKTIO,$(findstring PKTIO,$(FEATURE_LIST)))
                DISPATCH_LIST += TOMAHAWK3X
            endif
            export TOMAHAWK3_CHIPS
        endif
    endif
# }
endif #end of dispatch_list

ifdef BCM_88732_A0
# {
DISPATCH_LIST += SHADOW
# }
endif

#
# SAND_CHIPS means that at least one of Dune chip family defined
# aka DPP_CHIPS || DFE_CHIPS || DNX2_CHIPS || DNXF_CHIPS
#
# If ANY 'dune chip' is supported (SAND_CHIPS = 1) then define
# BCM_SAND_SUPPORT (for C-preprocessor usage) to indicate that.
#

ifdef DPP_CHIPS
# {
DISPATCH_LIST += PETRA
SAND_CHIPS = 1
# }
endif

ifdef DFE_CHIPS
# {
DISPATCH_LIST += DFE
SAND_CHIPS = 1
# }
endif

#
# For 'dnx2', we use DNX dispatcher
#
ifdef DNX2_CHIPS
# {
DISPATCH_LIST += DNX
SAND_CHIPS = 1
# }
endif

ifdef DNXF_CHIPS
# {
DISPATCH_LIST += DNXF
SAND_CHIPS = 1
# }
endif

# although DNX2 don't need dispatcher
# we need to define their BCM_*_SUPPORT flag, do it here
ifdef ALL_DNX2_CHIPS
# {
CFGFLAGS += -DBCM_DNX2_SUPPORT
# }
endif

#
# If ANY 'dune chip' is supported then define BCM_SAND_SUPPORT to
# indicate that.
#
ifdef SAND_CHIPS
# {
CFGFLAGS += -DBCM_SAND_SUPPORT
export SAND_CHIPS
# }
endif

CFGFLAGS += $(foreach dispatch,$(DISPATCH_LIST), -DBCM_$(dispatch)_SUPPORT)
ifneq (,$(findstring -DBCM_RPC_SUPPORT,$(CFGFLAGS)))
# {
CFGFLAGS += -DINCLUDE_LIB_CPUDB
CFGFLAGS += -DINCLUDE_LIB_CPUTRANS
CFGFLAGS += -DINCLUDE_LIB_DISCOVER
CFGFLAGS += -DINCLUDE_LIB_STKTASK
CFGFLAGS += -DDISCOVER_APP_DATA_BOARDID
# }
endif

ifdef DPP_CHIPS
# {
CFLAGS += -DDUNE_BCM -DLINK_PETRA_LIBRARIES -DLINK_PPD_LIBRARIES
ifdef BCM_88675_A0
# {
CFLAGS += -DBCM_JERICHO_SUPPORT
# }
endif
ifdef BCM_88375_A0
# {
CFLAGS += -DBCM_JERICHO_SUPPORT
# }
endif
ifdef BCM_88680_A0
# {
CFLAGS += -DBCM_JERICHO_PLUS_SUPPORT
# }
endif
ifdef BCM_88470_A0
# {
CFLAGS += -DBCM_QAX_SUPPORT
# }
endif
ifdef BCM_88270_A0
# {
CFLAGS += -DBCM_QUX_SUPPORT
# }
endif
ifdef BCM_8206_A0
# {
CFLAGS += -DBCM_FLAIR_SUPPORT
# }
endif
ifneq (,$(findstring -DPLISIM,$(CFLAGS)))
# {
CFLAGS += -DSAND_LOW_LEVEL_SIMULATION -DUSING_CHIP_SIM
# }
endif
ifneq (, $(findstring PIONEER,$(FEATURE_LIST)))
# {
CFGFLAGS += -DINCLUDE_LIB_PIONEER_HOST  
# }
endif
# }
endif

ifdef DNX2_CHIPS
# {
ifdef BCM_88690_A0
# {
CFLAGS += -DBCM_JERICHO_2_SUPPORT
# }
else
ifdef BCM_88690_B0
# {
CFLAGS += -DBCM_JERICHO_2_SUPPORT
# }
endif

ifdef BCM_88480_A0
CFLAGS += -DBCM_Q2A_SUPPORT
else
ifdef BCM_88480_B0
CFLAGS += -DBCM_Q2A_SUPPORT
endif
endif

endif
ifneq (,$(findstring -DPLISIM,$(CFLAGS)))
# {
CFLAGS += -DSAND_LOW_LEVEL_SIMULATION -DUSING_CHIP_SIM
# }
endif
ifneq (, $(findstring PIONEER,$(FEATURE_LIST)))
# {
CFGFLAGS += -DINCLUDE_LIB_PIONEER_HOST  
# }
endif
# }
endif

ifdef DFE_CHIPS
# {
CFLAGS += -DDUNE_BCM
ifneq (,$(findstring -DPLISIM,$(CFLAGS)))
# {
CFLAGS += -DSAND_LOW_LEVEL_SIMULATION -DUSING_CHIP_SIM
# }
endif
# }
endif

ifdef DNXF_CHIPS
# {
ifneq (,$(findstring -DPLISIM,$(CFLAGS)))
# {
CFLAGS += -DSAND_LOW_LEVEL_SIMULATION -DUSING_CHIP_SIM
# }
endif
# }
endif

ifneq (,$(findstring I2C,$(FEATURE_LIST)))
# {
CFGFLAGS += -DINCLUDE_I2C
# }
endif

ifneq (,$(findstring AEDEV,$(FEATURE_LIST)))
# {
CFGFLAGS += -DINCLUDE_LIB_AEDEV
# }
endif

ifneq (,$(findstring CINT,$(FEATURE_LIST)))
# {
CFGFLAGS += -DINCLUDE_LIB_CINT
CFGFLAGS += -DCINT_CONFIG_INCLUDE_SDK_SAL=1 -DCINT_CONFIG_INCLUDE_PARSER=1 -DCINT_CONFIG_INCLUDE_CINT_LOAD=0
ifeq (${BCM_API_VERBOSE_LOGGING},1)
# {
CFGFLAGS += -DCINT_CONFIG_INCLUDE_CINT_LOGGER=1 -DBCM_API_VERBOSE_LOGGING
# }
endif
ifeq (,$(findstring EDITLINE,$(FEATURE_LIST)))
# {
CFGFLAGS += -DCINT_CONFIG_INCLUDE_PARSER_READLINE=0 -DCINT_CONFIG_INCLUDE_PARSER_ADD_HISTORY=0
# }
endif
# }
endif

ifneq (,$(findstring C_UNIT,$(FEATURE_LIST)))
# {
CFGFLAGS += -DINCLUDE_LIB_C_UNIT
CFGFLAGS += -DC_UNIT_CONFIG_INCLUDE_SDK_SAL=1
# }
endif

ifndef	BCM_PHY_LIST
# {
BCM_PHY_LIST=522X 54XX 5464 5421S 5482 54616 54680 54680E 52681E 54880E 54682 54684 54640 54640E 54880 SERDES SIMUL 8703 8705 8706 8072 8040 8481 8750 8729 84740 84756 54380 542XX 84334 84728 84749 84328 84793 82328 82381 82780
BCM_PHY_LIST += 82764 EGPHY28 82864 82109 EGPHY16
ifdef ESW_CHIPS
# {
BCM_PHY_LIST += 8806X
# }
endif
# }
endif

CFGFLAGS += $(foreach phy,$(BCM_PHY_LIST), -DINCLUDE_PHY_$(phy))

ifneq (,(findstring 54880,$(BCM_PHY_LIST)))
# {
CFGFLAGS += -DINCLUDE_LONGREACH
# }
endif

# use QUIET=1 to control printing of compilation lines
ifdef	QUIET
# {
Q:=@
# }
else
# {
Q:=
# }
endif

#
# Suffix to add to the "target" files to allow local builds with different
# flags. Set "target_suffix" to XXX to cause the build to put built objects
# in ${target}${target_suffix}. This allows things like building a debug
# version with different flags.  This may also be set in another Makefile.
#

#target_suffix :=

#
# Optional suffix to add to the build directory and output binary files
# to allow multiple builds to co-exist for various reasons.
#
#chip_suffix := -$(shell echo $(CHIP) | tr A-Z a-z)

#
# Combined suffixes
#
all_suffix = ${chip_suffix}${target_suffix}

#
# Default location to place binaries and make depend files for building
# purposes.
#
ifeq "$(HOSTTYPE)" "Windows2000PC"
# {
BLDROOTWITHDRIVE = ${SDK}/build/${target}${all_suffix}${bldroot_suffix}
BLDROOT = ${SDK_NO_DRIVE_NAME}/build/${target}${all_suffix}${bldroot_suffix}
# }
else # ifeq "$(HOSTTYPE)" "Windows2000PC"
# {

ifndef SDKBUILD
# {
SDKBUILD :=build
# }
endif

BLDROOT = ${SDK}/${SDKBUILD}/$(if ${BLDCONFIG},${BLDCONFIG}/)${target}${all_suffix}${bldroot_suffix}

# }
endif # ifeq "$(HOSTTYPE)" "Windows2000PC"

# This is needed because we cannot include Make.vxworks before Make.config
ifndef DEST_DIR_SUFFIX
# {
export DEST_DIR_SUFFIX :=$(subst $(realpath $(SDK))/systems,,$(realpath $(CURDIR)/$(dir ($(firstword $(MAKEFILE_LIST))))))
ifeq ($(MAKELEVEL),0)
# {
# }
endif
# }
endif

ifeq ($(DEST_DIR),)
# {
export DEST_DIR :=${SDK}/${SDKBUILD}$(if ${BLDCONFIG},/${BLDCONFIG})$(DEST_DIR_SUFFIX)
# }
endif

ifdef LOCALDIR
# {
BLDDIR = ${BLDROOT}/${LOCALDIR}
ifeq "$(HOSTTYPE)" "Windows2000PC"
# {
BLDDIRWITHDRIVE = ${BLDROOTWITHDRIVE}/${LOCALDIR}
# }
endif
# }
else # ifdef LOCALDIR
# {
BLDDIR = ${BLDROOT}
ifeq "$(HOSTTYPE)" "Windows2000PC"
# {
BLDDIRWITHDRIVE = ${BLDROOTWITHDRIVE}
# }
endif
# }
endif # ifdef LOCALDIR

LIBDIR = ${BLDROOT}

#
# Export directory, where build objects used by the outside world are
# placed (exported header files, libs, bins)
#
EXPDIR = ${SDK}/export/${target}${all_suffix}

#
# Standard include paths
#
ifeq (wrx-opennsa, $(platform))
CPU_PLATFORM = wrx
endif
ifeq (wrx,$(findstring wrx,$(platform)))
CPU_PLATFORM = wrx
endif
ifeq (slk,$(findstring slk,$(platform)))
CPU_PLATFORM = slk
endif
ifeq (gts,$(findstring gts,$(platform)))
CPU_PLATFORM = gts
endif
ifeq (gto,$(findstring gto,$(platform)))
CPU_PLATFORM = gto
endif
ifeq (xlr-3_14,$(findstring xlr-3_14,$(platform)))
CPU_PLATFORM = xlr-3_14
endif

export CPU_PLATFORM

INCDIR	= ${SDK}/include
ifneq (,$(findstring -DBCM_PTP_EXT_SERVO_SUPPORT,$(CFGFLAGS)))
INCDIR += -I${EXT_SERVO_ROOT}/idtSystem/osAdaptation/linux.${CPU_PLATFORM}/include \
          -I${EXT_SERVO_ROOT}/idtSystem/deviceAdaptors/timeStamp/api/include/ \
          -I${EXT_SERVO_ROOT}/idtCommon/include \
		  -I${EXT_SERVO_ROOT}/idtCore/management/include \
		  -I${EXT_SERVO_ROOT}/idtCore/servo/include
endif

# XFLOW_MACSEC include paths
ifneq (,$(findstring XFLOW_MACSEC,$(FEATURE_LIST)))
# {
BUILD_XFLOW_MACSEC = 1
FEATURE_XFLOW_MACSEC = 1
XFLOW_MACSEC_BUILD_FLAG=-DBROADCOM_SAL -I${SDK} -I${SDK}/include -g -Wall -Werror -fno-strict-aliasing
ifdef LTSW_CHIPS
XFLOW_MACSEC_BUILD_FLAG += -DBSL_CONFIG_INCLUDE_CUSTOM_ENUM -DBSL_HYBRID
endif

XFLOW_MACSEC_BUILD_FLAG += ${STD_CFLAGS}

ifndef XFLOW_MACSEC_HOME
# {
export XFLOW_MACSEC_HOME := ${SDK}/libs/xflow_macsec
ifneq ($(shell test -d $(XFLOW_MACSEC_HOME); echo $$?),0)
$(error "The $$XFLOW_MACSEC_HOME environment variable is not set")
endif
# }
endif
INCDIR += -I${SDK} -I${XFLOW_MACSEC_HOME}/include
CFGFLAGS += -DBROADCOM_SAL
# }
else
# {
# MACSEC include paths
ifneq (,$(findstring MACSEC,$(FEATURE_LIST)))
# {
BUILD_MACSEC = 1
FEATURE_MACSEC = 1
MACSEC_BUILD_FLAG=-DBROADCOM_SAL -I${SDK} -I${SDK}/include -g -Wall -Werror -fno-strict-aliasing

MACSEC_BUILD_FLAG += ${STD_CFLAGS}

ifndef MACSEC_HOME
# {
toast:; $(error 'The $$MACSEC_HOME environment variable is not set')
# }
endif
INCDIR += -I${SDK} -I${MACSEC_HOME}/include -I${MACSEC_HOME}/cli -I${MACSEC_HOME}/phy/bcm54380  -I${MACSEC_HOME}/phy/bcm8729 -I${MACSEC_HOME}/phy/bcm84756 -I${MACSEC_HOME}/phy/bcm84334  -I${MACSEC_HOME}/phy/bcm84749  -I${MACSEC_HOME}/phy/dummyphy
CFGFLAGS += -DBROADCOM_SAL
# }
endif
# }
endif

ifneq (,$(findstring -DBCM_PTP_EXT_SERVO_SUPPORT,$(CFGFLAGS)))
BUILD_EXT_SERVO = 1
FEATURE_EXT_SERVO = 1
EXT_SERVO_BUILD_FLAG = CPU_TARGET=${CPU_PLATFORM} USER_ARFLAGS=rcvs CLOCK_TYPE=BC NUMBER_OF_STACK_INSTANCES=10 DCO_DEVICE=softwareDco TIMESTAMP_DEVICE=softwareTimestamping
endif

# FCMAP include paths
ifneq (,$(findstring FCMAP,$(FEATURE_LIST)))
# {
FEATURE_FCMAP = 1
INCDIR += -I${SDK}  -I${SDK}/include -I${SDK}/src/soc/phy/fcmap/include
CFGFLAGS += -DBROADCOM_SAL
# }
endif
INCDIR += -I${SDK}  -I${SDK}/include -I${SDK}/src/soc/phy/chip/koi/merlin_koi_src -I${SDK}/libs/phymod/chip
INCDIR += -I${SDK}  -I${SDK}/include -I${SDK}/src/soc/phy/chip/orca/eagle_orca_src

ifdef IMACSEC_HOME
INCDIR += -I${SDK}/src/soc/phy -I${SDK}/src/soc/phy/imacsec/include -I${IMACSEC_HOME}/bcm_plp_base_t_sec
CFGFLAGS += -DINCLUDE_PLP_IMACSEC
CFGFLAGS += -DINCLUDE_PLP_UNIMAC
endif

# EAV APPL in diag is intended to be built
#ifneq (,$(findstring EAV_APPL,$(FEATURE_LIST)))
#BUILD_EAV_APPL = 1
#endif

ifneq (,$(findstring KNET,$(FEATURE_LIST)))
# {
BUILD_KNET = 1

ifneq (,$(findstring KNETSYNC,$(FEATURE_LIST)))
# {
BUILD_KNETSYNC = 1
# }
endif

# }
endif

# Start Checking for KBP feature
#
ifeq (KBP,$(findstring KBP,$(FEATURE_LIST)))
# {
ifndef KBP_DEVICE
# {
$(error "KBP Feature is Enabled, and no valid Device was defined. Define KBP_DEVICE=KBP_11K or KBP_DEVICE=KBP_ALG")
# }
else
# {
ifeq (KBP_12K,$(findstring KBP_12K,$(KBP_DEVICE)))
# {
$(error "KBP_12K device not supported. Only KBP_11K and KBP_ALG devices are supported for KBP feature")
# }
endif
# }
endif

ifeq (KBP_11K,$(findstring KBP_11K,$(KBP_DEVICE)))
# {
DEVICE=nlm2
INCDIR += -I${SDK}/include/soc/kbp/nlm2/diagnostic
INCDIR += -I${SDK}/include/soc/kbp/nlm2/nlmxpt
INCDIR += -I${SDK}/include/soc/kbp/nlm2/simxpt
# }
endif

ifeq (KBP_12K,$(findstring KBP_12K,$(KBP_DEVICE)))
# {
DEVICE=nlm3
INCDIR += -I${SDK}/include/soc/kbp/nlm3/model
INCDIR += -I${SDK}/include/soc/kbp/nlm3/blackholexpt
INCDIR += -I${SDK}/include/soc/kbp/nlm3/xpt
# }
endif

ifneq (KBP_ALG,$(findstring KBP_ALG,$(KBP_DEVICE)))
# {
KBP_LIBDIR=${SDK}/src/soc/kbp/${DEVICE}/lib/${targetbase}-${targetplat}/${platform}/

CFLAGS += -DNLMPLATFORM_BCM
INCDIR += -I${SDK}/include
INCDIR += -I${SDK}/include/soc/kbp/${DEVICE}/nlmdevmgr
INCDIR += -I${SDK}/include/soc/kbp/${DEVICE}/arch
INCDIR += -I${SDK}/include/soc/kbp/common
INCDIR += -I${SDK}/include/soc/kbp/${DEVICE}/nlmrangemgr
INCDIR += -I${SDK}/include/soc/kbp/${DEVICE}/nlmgenerictblmgr
INCDIR += -I${SDK}/include/soc/kbp/${DEVICE}/nlmfibtblmgr/api
INCDIR += -I${SDK}/include/soc/kbp/${DEVICE}/nlmfibtblmgr/common
# }
else
# {
INCDIR += -I${SDK}/include/soc/kbp/alg_kbp/include
CFLAGS += -DNLMPLATFORM_UNIX -DNLMPLATFORM_LINUX
# }
endif


ifeq ($(shell uname -m),x86_64)
# {
ifeq (DLONGS_ARE_64BITS,$(findstring DLONGS_ARE_64BITS,$(CFLAGS)))
# {
ifeq (DPTRS_ARE_64BITS,$(findstring DPTRS_ARE_64BITS,$(CFLAGS)))
# {
CFLAGS += -DNLM_BUILD64
# }
endif
# }
endif
# }
endif
# }
endif

# End Checking for KBP feature

#
# PHYMOD library support
#
# PHYMOD_CHIP_NAMES defines which internal PHYs require PHYMOD support.
# PHYMOD_PHY_LIST defines which external PHYs require PHYMOD support.
#
PHYMOD_CHIP_NAMES = BCM_53400_A0 BCM_88650_A0 BCM_88950_A0 BCM_88790_A0 BCM_88675_A0 BCM_56860_A0 BCM_88375_A0 BCM_88680_A0 BCM_88690_A0 BCM_88690_B0 BCM_88480_A0 BCM_88480_B0 BCM_88470_A0   BCM_88270_A0 BCM_8206_A0 BCM_56960_A0 BCM_88202_A0 BCM_56560_A0 BCM_56560_B0 BCM_56260_A0 BCM_56160_A0 BCM_56260_B0 BCM_56965_A0 BCM_56970_A0 BCM_53570_A0 BCM_56870_A0 BCM_53570_B0 BCM_53540_A0 BCM_56670_A0 BCM_56980_A0 BCM_56980_B0 BCM_56370_A0 BCM_56770_A0 BCM_56670_B0 BCM_56275_A0 BCM_56470_A0 BCM_56070_A0 BCM_56670_C0


ifdef LTSW_CHIPS
ifneq (1,$(PHYMOD_EXCLUDE_LTSW_CHIP))
PHYMOD_CHIP_NAMES += $(LTSW_CHIP_NAMES)
endif
endif

PHYMOD_PHY_LIST = 82381 82764 8806X 82864 82109

# Define default PHYMOD support based on included PHYs
ifeq (,$(PHYMOD_SUPPORT))
# {
seekphymodchips = $(foreach chipname,$(PHYMOD_CHIP_NAMES),$(whereischip))
ifneq "$(findstring file,$(seekphymodchips))" ""
# {
PHYMOD_SUPPORT = 1
# }
endif
# }
endif
ifeq (,$(PHYMOD_SUPPORT))
# {
ifneq (,$(filter $(PHYMOD_PHY_LIST),$(BCM_PHY_LIST)))
# {
PHYMOD_SUPPORT = 1
# }
endif
# }
endif

ifeq (wrx-opennsa, $(platform))
PHYMOD_SUPPORT = 1
endif

# Include PHYMOD diagnotics by default
ifeq (,$(PHYMOD_DIAG))
# {
PHYMOD_DIAG = $(PHYMOD_SUPPORT)
# }
endif

# Configure PHYMOD build
ifeq (1,$(PHYMOD_SUPPORT))
# {
BUILD_PHYMOD = 1
ifdef PHYMOD_PRE_BUILD_PATH
PHYMOD_DIR := $(PHYMOD_PRE_BUILD_PATH)/libs/phymod
else
PHYMOD_DIR := $(SDK)/libs/phymod
endif
INCDIR += -I${PHYMOD_DIR}/include
PHYMOD_ADD_CFLAGS += -DPHYMOD_SUPPORT
PHYMOD_ADD_CFLAGS += -DPHYMOD_TIER1_SUPPORT
PHYMOD_ADD_CFLAGS += -DPHYMOD_INCLUDE_CUSTOM_CONFIG
ifeq (1,$(PHYMOD_DIAG))
# {
PHYMOD_ADD_CFLAGS += -DPHYMOD_DIAG
# }
endif
CFLAGS += ${PHYMOD_ADD_CFLAGS}
ifdef LTSW_CHIPS
LTSW_ADD_CPPFLAGS += ${PHYMOD_ADD_CFLAGS}
LTSW_ADD_CPPFLAGS += -I${PHYMOD_DIR}/include
endif
# }
endif

#
# Required for building SDKLT phymod library.
#
ifdef LTSW_CHIPS
ifeq (,$(BUILD_PHYMOD))
LTSW_ADD_CPPFLAGS += -DPHYMOD_DIAG
LTSW_ADD_CPPFLAGS += -I$(SDKLT)/phymod/../phymod/include
endif
endif

#Add the devices that has CPRI module.
CPRIMOD_CHIP_NAMES = BCM_56670_A0 BCM_56670_B0 BCM_56670_C0

seekportmod =  $(foreach chipname,$(CPRIMOD_CHIP_NAMES),$(whereischip))
#portmod support)
ifeq (,$(CPRIMOD_SUPPORT))
# {
ifneq "$(findstring file,$(seekportmod))" ""
# {
CPRIMOD_SUPPORT = 1
# }
endif
# }
endif

ifeq (1,$(CPRIMOD_SUPPORT))
# {
BUILD_PORTMOD = 1
CFLAGS += -DCPRIMOD_DIAG
CFLAGS += -DCPRIMOD_SUPPORT
CFLAGS += -DCPRI_DIAG_SUPPORT
CFLAGS += -DCPRIMOD_CPRI_FALCON_SUPPORT
export CPRIMOD_SUPPORT
# }
endif


PORTMOD_CHIP_NAMES = BCM_53400_A0 BCM_88950_A0 BCM_88790_A0 BCM_88670_A0 BCM_88675_A0 BCM_56860_A0 BCM_88375_A0  BCM_88680_A0 BCM_88690_A0 BCM_88690_B0 BCM_88480_A0 BCM_88480_B0 BCM_88470_A0  BCM_88270_A0 BCM_8206_A0 BCM_56960_A0 BCM_56560_A0 BCM_56560_B0 BCM_56160_A0 BCM_56965_A0 BCM_56970_A0 BCM_53570_A0 BCM_56870_A0 BCM_53570_B0 BCM_53540_A0 BCM_56670_A0 BCM_56980_A0 BCM_56980_B0 BCM_56370_A0 BCM_56770_A0 BCM_56670_B0 BCM_56275_A0 BCM_56470_A0 BCM_56070_A0 BCM_56670_C0

seekportmod =  $(foreach chipname,$(PORTMOD_CHIP_NAMES),$(whereischip))
#portmod support)
ifeq (,$(PORTMOD_SUPPORT))
# {
ifneq "$(findstring file,$(seekportmod))" ""
# {
PORTMOD_SUPPORT = 1
# }
endif
# }
endif

ifeq (1,$(PORTMOD_SUPPORT))
# {
BUILD_PORTMOD = 1
CFLAGS += -DPORTMOD_DIAG
CFLAGS += -DPORTMOD_SUPPORT
export PORTMOD_SUPPORT
# }
endif


#
# CANCUN support
#
# CANCUN_CHIP_NAMES defines which chips require CANCUN support
#
CANCUN_CHIP_NAMES = BCM_56870_A0 BCM_56870_B0 BCM_56370_A0 BCM_56770_A0 BCM_56275_A0 BCM_56470_A0






ifeq (,$(CANCUN_SUPPORT))
seekcancunchips = $(foreach chipname,$(CANCUN_CHIP_NAMES),$(whereischip))
ifneq "$(findstring file,$(seekcancunchips))" ""
CANCUN_SUPPORT = 1
endif
endif

ifeq (1,$(CANCUN_SUPPORT))

CFLAGS += -DCANCUN_SUPPORT
export CANCUN_SUPPORT
endif

#
# CMICFW support
#
# CMICFW_CHIP_NAMES defines which chips require CMICFW support
#
CMICFW_CHIP_NAMES = BCM_56870_A0 BCM_56980_A0 BCM_56980_B0


ifeq (,$(CMICFW_SUPPORT))
seekcmicfwchips = $(foreach chipname,$(CMICFW_CHIP_NAMES),$(whereischip))
ifneq "$(findstring file,$(seekcmicfwchips))" ""
CMICFW_SUPPORT = 1
endif
endif

ifeq (1,$(CMICFW_SUPPORT))

endif

#Add the devices that supports SW Autoneg to the lst below 
SW_AN_CHIP_NAMES = BCM_56965_A0 BCM_56560_B0 BCM_56565_B0 BCM_56969_A0 BCM_56966_A0 BCM_56967_A0 BCM_56970_A0

ifeq (,$(SW_AUTONEG_SUPPORT))
# {
seekswanchips = $(foreach chipname,$(SW_AN_CHIP_NAMES),$(whereischip))
ifneq "$(findstring file,$(seekswanchips))" ""
# {
SW_AUTONEG_SUPPORT = 1
# }
endif
# }
endif

ifeq (1,$(SW_AUTONEG_SUPPORT))
# {
CFLAGS += -DSW_AUTONEG_SUPPORT
#}
endif

#
# PCIE PHY library support
#
# PCIEPHY_CHIP_NAMES defines which chips require PCIE PHY library support.
#
PCIEPHY_CHIP_NAMES = BCM_56870_A0 BCM_88690_A0 BCM_88690_B0 BCM_88480_A0 BCM_88480_B0 BCM_88790_A0 BCM_56980_A0 BCM_56980_B0 BCM_56770_A0 BCM_56370_A0 BCM_56275_A0 BCM_56470_A0 BCM_56070_A0


# Define default PCIEPHY support based on included PHYs
ifeq (,$(PCIEPHY_SUPPORT))
seekpciephychips = $(foreach chipname,$(PCIEPHY_CHIP_NAMES),$(whereischip))
ifneq "$(findstring file,$(seekpciephychips))" ""
PCIEPHY_SUPPORT = 1
endif
endif

# Include PCIEPHY PHY diagnotics by default
ifeq (,$(PCIEPHY_DIAG))
# {
PCIEPHY_DIAG = $(PCIEPHY_SUPPORT)
# }
endif

ifdef LTSW_CHIPS
ifeq (,$(PCIEPHY_SUPPORT))
PCIEPHY_SUPPORT = 1
endif
endif

# Configure PCIEPHY build
ifeq (1,$(PCIEPHY_SUPPORT))
# {
BUILD_PCIEPHY = 1
PCIEPHY_DIR = ${SDK}/libs/pciephy
INCDIR += -I${PCIEPHY_DIR}/include
PCIEPHY_ADD_CFLAGS += -DPCIEPHY_SUPPORT
ifeq (1,$(PCIEPHY_DIAG))
# {
PCIEPHY_ADD_CFLAGS += -DPCIEPHY_DIAG_SUPPORT
# }
endif
CFLAGS += ${PCIEPHY_ADD_CFLAGS}
ifdef LTSW_CHIPS
LTSW_ADD_CPPFLAGS += -I${PCIEPHY_DIR}/include
endif
# }
endif

ifeq (1,$(BUILD_SDKLT))
SDKLT_EXPORT_COMPONENT = bcma bcmpkt bcmlt bcmltm bcmltd bcmmgmt bcmha bcmissu bcmlrd bcmdrd bcmcfg bcmbd shr bsl sal bcmpc
INCDIR += $(foreach component,$(SDKLT_EXPORT_COMPONENT),-I$(SDKLT)/$(component)/include)
endif

#
# BUILD KAPS if at least one of Dune chip family defined
# aka DPP_CHIPS || DFE_CHIPS || DNX2_CHIPS || DNXF_CHIPS
#

ifdef DPP_CHIPS
# {
BUILD_KAPS = 1
# }
endif
ifdef DFE_CHIPS
# {
BUILD_KAPS = 1
# }
endif
ifdef DNX2_CHIPS
# {
BUILD_KAPS = 1
# }
endif
ifdef DNXF_CHIPS
# {
BUILD_KAPS = 1
# }
endif


# Configure FLEXE build
ifeq (FLEXE,$(findstring FLEXE,$(filter-out FLEXE_DBG,$(FEATURE_LIST))))
# {
BUILD_FLEXE = 1
export BUILD_FLEXE
INCDIR += -I${SDK}/libs/flexe_core/std
# }
endif


# Configure FLEXE build
ifeq (FLEXE_DBG,$(findstring FLEXE_DBG,$(FEATURE_LIST)))
# {
BUILD_FLEXE_DBG = 1
export BUILD_FLEXE_DBG
INCDIR += -I${SDK}/libs/flexe_core/dbg/adapt/inc
INCDIR += -I${SDK}/libs/flexe_core/dbg/bsp/inc
INCDIR += -I${SDK}/libs/flexe_core/dbg/chip/module/66bswitch
INCDIR += -I${SDK}/libs/flexe_core/dbg/chip/module/cpb
INCDIR += -I${SDK}/libs/flexe_core/dbg/chip/module/demux
INCDIR += -I${SDK}/libs/flexe_core/dbg/chip/module/mux
INCDIR += -I${SDK}/libs/flexe_core/dbg/chip/module/sar
INCDIR += -I${SDK}/libs/flexe_core/dbg/chip/module/flexe_oh
INCDIR += -I${SDK}/libs/flexe_core/dbg/chip/module/module1588
INCDIR += -I${SDK}/libs/flexe_core/dbg/chip/module/oam
INCDIR += -I${SDK}/libs/flexe_core/dbg/chip/module/init
INCDIR += -I${SDK}/libs/flexe_core/dbg/chip/module/mcmac
INCDIR += -I${SDK}/libs/flexe_core/dbg/chip/module/rateadpt
INCDIR += -I${SDK}/libs/flexe_core/dbg/lib/inc
INCDIR += -I${SDK}/libs/flexe_core/dbg/protocal/demux/inc
INCDIR += -I${SDK}/libs/flexe_core/dbg/protocal/mux/inc
INCDIR += -I${SDK}/libs/flexe_core/dbg/top
INCDIR += -I${SDK}/libs/flexe_core/dbg
# }
endif

#
# Paths of where we install files for make install
#
# install_headers - where to install header files.
# install_lib     - where to install libs
# install_bin	  - where to install completely linked binaries
#
install_headers	= ${SDK}/export/include
install_lib	= ${SDK}/export/lib/${target}
install_bin	= ${SDK}/export/bin/${target}

#
# Compilation Flags
#
# Flags may be added to (see below)
#

INCDIR += -I${SDK}/src/soc/phy/phy8806x/include

INCFLAGS = -I${INCDIR} -I${SDK}/systems

CFLAGS += ${INCFLAGS}
CXXFLAGS += ${INCFLAGS}
CPPFLAGS += ${INCFLAGS}

#
# Debug #ifdef control
#
# Compiling out #ifdef DEBUG code saves about 1.3% on executable size.
# It is recommended to leave debug enabled when developing applications.
#
ifndef DEBUG_IFDEFS
# {
DEBUG_IFDEFS=TRUE
# }
endif

ifeq ($(DEBUG_IFDEFS),TRUE)
# {
CFLAGS += -DBROADCOM_DEBUG
CXXFLAGS += -DBROADCOM_DEBUG
CPPFLAGS += -DBROADCOM_DEBUG
# }
endif

#
# Debug symbol information control
#
ifneq ($(targetbase),ghs)
# {
ifndef DEBUG_SYMBOLS
# {
DEBUG_SYMBOLS=TRUE
# }
endif
# }
endif

ifeq ($(DEBUG_SYMBOLS),TRUE)
# {
CFLAGS += -g
CXXFLAGS += -g
CPPFLAGS += -g
ifdef LTSW_CHIPS
# {
LTSW_ADD_CFLAGS += -g
# }
endif
# }
else
# {
CFLAGS += -g0
CXXFLAGS += -g0
CPPFLAGS += -g0
ifdef LTSW_CHIPS
# {
LTSW_ADD_CFLAGS += -g0
# }
endif
# }
endif

ifndef BCM_88732_A0
# {
CFGFLAGS += -DNO_BCM_88732_A0
# }
endif

#
# If DEBUG_CFLAGS is set, add its contents to CFLAGS.
# May be useful for setting on the command line or adding to Make.local.
# Example: gmake DEBUG_CFLAGS=-save-temps system.c
#

ifneq ($(DEBUG_CFLAGS),)
# {
CFLAGS += $(DEBUG_CFLAGS)
CXXFLAGS += $(DEBUG_CFLAGS)
CPPFLAGS += $(DEBUG_CFLAGS)
ifdef LTSW_CHIPS
LTSW_ADD_CFLAGS += $(DEBUG_CFLAGS)
endif
# }
endif

#
# Optimization level
#
# Set DEBUG_OPTIMIZE to TRUE (default) to use a normal optimization
#		determined by OPTFLAGS_DEFAULT in the platform Makefile.
# Set DEBUG_OPTIMIZE to FALSE to use no optimization,
#		strongly recommended when using any debugger.
# Set DEBUG_OPTIMIZE to any other option string to request specific
#		optimization flags (for example -O2).
#
ifndef DEBUG_OPTIMIZE
# {
DEBUG_OPTIMIZE=TRUE
# }
endif

ifeq ($(DEBUG_OPTIMIZE),TRUE)
# {
OPTFLAGS += $(OPTFLAGS_DEFAULT)
# }
else
# {
ifneq ($(DEBUG_OPTIMIZE),FALSE)
# {
OPTFLAGS += $(DEBUG_OPTIMIZE)
# }
endif
# }
endif

ifdef LTSW_CHIPS
LTSW_ADD_CFLAGS += $(BCM_CFLAGS)
LTSW_ADD_CFLAGS += $(OPTFLAGS)
ifneq (,$(findstring -fPIC,$(STD_CFLAGS)))
LTSW_ADD_CFLAGS += -fPIC
endif
LTSW_ADD_CPPFLAGS += $(BCM_CPPFLAGS)
ifneq (,$(findstring -DCINT_CONFIG_INCLUDE_SDK_SAL=1,$(STD_CPPFLAGS)))
LTSW_ADD_CPPFLAGS += $(filter-out -DCINT_CONFIG_INCLUDE_SDK_SAL=1,$(STD_CPPFLAGS))
else
LTSW_ADD_CPPFLAGS += $(STD_CPPFLAGS)
endif
endif # LTSW_CHIPS

#
# Required for building SDKLT SAL library
#
ifdef LTSW_CHIPS
CFLAGS += -DSAL_INCLUDE_CUSTOM_CONFIG
CXXFLAGS += -DSAL_INCLUDE_CUSTOM_CONFIG
CPPFLAGS += -DSAL_INCLUDE_CUSTOM_CONFIG
LTSW_ADD_CPPFLAGS += -DSAL_INCLUDE_CUSTOM_CONFIG
endif

#
# Required for building customize BSL library
#
ifdef LTSW_CHIPS
CFLAGS += -DBSL_CONFIG_INCLUDE_CUSTOM_ENUM -DBSL_HYBRID
LTSW_ADD_CPPFLAGS += -DBSL_CONFIG_INCLUDE_CUSTOM_ENUM -DBSL_HYBRID
endif

#
# Required for SDKLT to search the header files
#
ifdef LTSW_CHIPS
LTSW_ADD_CPPFLAGS += -I$(SDK)/include
LTSW_LKM_ADD_CFLAGS += -I$(SDK)/include
endif

#
# PKTIO: streamlined packet I/O using imported drivers for legacy chips
#
ifeq (PKTIO,$(findstring PKTIO,$(FEATURE_LIST)))

# Default list of chips that support PKTIO
ifndef PKTIO_CHIPS
PKTIO_CHIPIDS = 56980_A0 56980_B0
endif # PKTIO_CHIPS

# Public header files required by PKTIO API
ifndef LTSW_CHIPS
INCDIR += -I${SDK}/src/bcm/esw/pktio/bcmpkt/include
endif # !LTSW_CHIPS

# For PKTIO implementation files
ifdef PKTIO_IMPL

CFLAGS += -DPKTIO_IMPL=1
INCDIR += -I${SDK}/src/bcm/esw/pktio
INCDIR += -I${SDK}/src/bcm/esw/pktio/bcmcnet/include

ifdef LTSW_CHIPS

SDKLT = ${SDK}/src/bcm/esw/pktio

else # !LTSW_CHIPS

INCDIR += -I${SDK}/src/bcm/esw/pktio/bcmdrd/include
INCDIR += -I${SDK}/src/bcm/esw/pktio/bcmlrd/include
INCDIR += -I${SDK}/src/bcm/esw/pktio/bcmltd/include

endif # LTSW_CHIPS

# Build chip-specific drivers for PKTIO enabled chips
CFLAGS += -DBCMDRD_CONFIG_INCLUDE_CHIP_DEFAULT=0
$(foreach v,${PKTIO_CHIPIDS},$(if $(BCM_$v),$(eval CFLAGS+=-DBCMDRD_CONFIG_INCLUDE_BCM$v=1),))

# Rename public imported functions on the fly
$(foreach v,${PKTIO_FUNCS},$(eval CFLAGS+=-D$v=pktio_$v))

endif # PKTIO_IMPL

# We need shrextend for compatibility with imported modules
SHR_EXTEND = 1

# Enable full BSL enums for imported modules
CFLAGS += -DBSL_CONFIG_INCLUDE_CUSTOM_ENUM -DBSL_HYBRID

endif # PKTIO

#
# Debug assertion control.
#
# Compiling out assert() saves about 1.1% on executable size,
# however doing so is VERY MUCH discouraged.
#
ifndef DEBUG_ASSERTS
# {
DEBUG_ASSERTS=TRUE
# }
endif

ifeq ($(DEBUG_ASSERTS),FALSE)
# {
CFLAGS += -DNDEBUG
CXXFLAGS += -DNDEBUG
CPPFLAGS += -DNDEBUG
# }
endif

#
# GCC pedantic mode.
#
ifeq ($(DEBUG_PEDANTIC),TRUE)
# {
CFGFLAGS += -D__PEDANTIC__
CFLAGS += --pedantic
CXXFLAGS += --pedantic
# }
endif

#
# Dynamic Load Enabled
#
ifeq ($(DL_ENABLE),TRUE)
# {
CFLAGS += -DDL_ENABLE
LDFLAGS += -ldl -export-dynamic
# }
endif

#
# In each directory, build a list of local sources, objects, and headers
#
LSRCS	=	$(wildcard *.c *.cpp *.s *.cc *.C)
LOBJS	=	$(addsuffix .o, $(basename ${LSRCS}))
BOBJS	= 	$(addprefix ${BLDDIR}/,${LOBJS})
LHDRS	=	$(wildcard *.h *.H)
LDOTIS	=	$(wildcard *.i)


ifeq ($(TOOLS),Borland)
# {
BORLAND_LOBJS	=	$(addsuffix .obj, $(basename ${LSRCS}))
#BORLAND_BLDDIR	= 	$(subst, \,/, $(subst -,_,$(BLDDIR)))
BORLAND_BLDDIR	= 	$(BLDDIR)
BORLAND_BOBJS	= 	$(addprefix ${BORLAND_BLDDIR}/,${BORLAND_LOBJS})
# }
endif

#
# Rule to create object file (build) directory
#

.PHONY: all install clean distclean

.PRECIOUS: ${BLDDIR}/.tree

%/.tree:
	@$(ECHO) Creating build directory $(dir $@)
	$Q($(MKDIR) $(dir $@); $(TOUCH) $@)

# Rule allowing build through CPP only, creates .E file from .c file.

%.E: %.c
	$Q$(CC) -E ${CFLAGS} $< | $(SED) -e '/^ *$$/d' -e p -e d > $@

# Rule allowing build through source only, creates .s file from .c file.

%.s: %.c
	$Q$(CC) -S ${CFLAGS} $<

# allow disabling of dependency file generation
# enable partial recompilation through use of included
# dependency make files
#
ifndef NO_SDK_DEPS
# {
# take the compiler generated .d file and reparse it 
# to generate a dependency graph rule for this object
# file
# the two steps generate:
#  file.o: file.c \
#	file.h ...
#
#  file.h: 
#  header.h: 
# some compilers will generate errors without the latter
# part of the list

.PHONY: .phony

DEPS_SED = \
	$(CP) $(BLDDIR)/$*.d $(BLDDIR)/$*.tmp;\
	$(ECHO) >> $(BLDDIR)/$*.tmp;\
	$(SED) -e 's/\#.*//' -e 's/^[^:]*: *//' \
	-e 's/ *\\$$//' -e '/^$$/ d' -e 's/$$/ :/' \
	-e '/^ .$$/d' \
	< $(BLDDIR)/$*.d >> $(BLDDIR)/$*.tmp; \
	$(SED) -e 's|^\([^\/ ].*\.o\):|'$(BLDDIR)/'\1:|g'  \
	-e 's|.*?/\(.*\.o\):|'$(BLDDIR)/'\1:|g'  \
	< $(BLDDIR)/$*.tmp > $(BLDDIR)/$*.P; \
	$(RM) -f $(BLDDIR)/$*.d $(BLDDIR)/$*.tmp
DEPS_CMD = $(DEPS_SED)

ifeq ($(targetbase),ghs)
# {
DEPS_CMD = $(DEPS_SED)
# }
else
# {
ifeq ($(VX_VERSION),55)
# {
# this supports the tornado 2.x.x compiler
# (VxWorks 5.x)
DEPS_CMD = $(DEPS_SED)
# }
else
# {
ifneq ($(findstring gnu,$(TOOL)),)
# {
# Gnu compilers always support -MD -MF
DEPS_OPT = -MD -MF $(BLDDIR)/$*.d
DEPS_CMD = $(DEPS_SED)
# }
else
# {
ifneq (,$(filter 64 65,$(VX_VERSION)))
# {
BCM_CFLAGS = -Xstop-on-warning -Xlint
DEPS_OPT = -Xmake-dependency=4 -Xmake-dependency-savefile=$(BLDDIR)/$*.d
DEPS_CMD = $(DEPS_SED)
# }
else
# {
ifneq ($(findstring i686,$(CROSS_COMPILE)),)
# {
# Gcc 2.95 does not support -MD -MF with -o and -c
# }
else
# {
# newer gnu-based compilers allow -MD -MF
DEPS_OPT = -MD -MF $(BLDDIR)/$*.d
DEPS_CMD = $(DEPS_SED)
# }
endif
# }
endif
# }
endif
# }
endif
# }
endif

# From gmsl

# Standard definitions for true and false.  true is any non-empty
# string, false is an empty string. These are intended for use with
# $(if).

true  := T
false :=

# ----------------------------------------------------------------------------
# Function:  not
# Arguments: 1: A boolean value
# Returns:   Returns the opposite of the arg. (true -> false, false -> true)
# ----------------------------------------------------------------------------
not = $(if $1,$(false),$(true))

# ----------------------------------------------------------------------------
# Function:  map
# Arguments: 1: Name of function to $(call) for each element of list
#            2: List to iterate over calling the function in 1
# Returns:   The list after calling the function on each element
# ----------------------------------------------------------------------------
map = $(strip $(foreach a,$2,$(call $1,$a)))

# ----------------------------------------------------------------------------
# Function:  seq
# Arguments: 1: A string to compare against...
#            2: ...this string
# Returns:   Returns $(true) if the two strings are identical
# ----------------------------------------------------------------------------
seq = $(if $(filter-out xx,x$(subst $1,,$2)$(subst $2,,$1)x),$(false),$(true))

# ----------------------------------------------------------------------------
# Function:  sne
# Arguments: 1: A string to compare against...
#            2: ...this string
# Returns:   Returns $(true) if the two strings are not the same
# ----------------------------------------------------------------------------
sne = $(call not,$(call seq,$1,$2))

# End from gmsl

# Define comma symbol so we can repace it with a variable
comma :=,

# Signature
last_target :=

dump_var = $$(eval $1 := $($1))

define new_rule
@echo '$(call map,dump_var,@ < *)' > $S
@$(if $(wildcard $F),,touch $F)
@echo $@: $F >> $S
endef

define do
$(eval S := $(BLDDIR)/$*.sig)$(eval F := $(BLDDIR)/$*.force)$(eval C := $1)
$(if $(call sne,$@,$(last_target)),$(call new_rule),$(eval last_target := $@))
@echo '$$(if $$(call sne,$$(sort $1),$(sort $(subst $(comma),$$(comma),$C))),$$(shell touch $F))' >> $S
$Q$C
endef

# end of Signature


# }
else # ifndef NO_SDK_DEPS
# {
# No dependency files, faster compile times
# no partial compile support
DEPS_SED =
DEPS_OPT =
DEPS_CPY =
DEPS_CMD = /bin/true

define do
$(eval C := $1)
$Q$C
endef

# }
endif

#
# Default Build rules for .c --> .o, leaving the binary in BLDDIR/X.o,
# even if file not built from directory of source.
#
ifeq ($(FAST),1)
# {
${BLDDIR}/%.o: %.c
# }
else
# {
ifdef GENERATE_C_FILES
# {
${BLDDIR}/%.o: %.c
# }
else
# {

${BLDDIR}/%.o: %.c
# }
endif
# }
endif
# echo Compiling needed to properly process errors 
	@$Q$(ECHO) Compiling ${LOCALDIR}/$< 
	$Q$(MKDIR) $(@D)
	$Q$(RM) -f $@
# 55 is VERY different
ifeq ($(VX_VERSION),55)
# {
	$Q$(CC) -M $(CFLAGS) $(EXTRA_CFLAGS)  $(realpath $<) > $(BLDDIR)/$*.d && ($(DEPS_CMD))
	$(call do,$$(CC) $$(CFLAGS) $$(EXTRA_CFLAGS) -o $$@  -c $$(realpath $$<))
# }
else
# {
	$(call do,$$(CC) $$(DEPS_OPT) $$(CFLAGS) $$(EXTRA_CFLAGS) -o $$@ -c $$(realpath $$<))  && ($(DEPS_CMD))
# }
endif

${BLDDIR}/%.o: %.s
ifdef QUIET
# {
	@$(ECHO) Assembling ${LOCALDIR}/$<
# }
endif
	$Q$(CC) ${CFLAGS} ${EXTRA_CFLAGS} -o $@ -c $(realpath $<)

${BLDDIR}/%.o: %.cpp
ifdef QUIET
# {
	@$(ECHO) Compiling ${LOCALDIR}/$<
# }
endif
	$Q$(CXX) ${CXXFLAGS}  -o $@ -c $(realpath $<)

${BLDDIR}/%.o: %.cc ${BLDDIR}/.tree
ifdef QUIET
# {
	@$(ECHO) Compiling ${LOCALDIR}/$<
# }
endif
	$Q$(CXX) ${CXXFLAGS} -o $@ -c $(realpath $<)

#
# Cause "make foo.o" in any subdirectory to put the object in the build
# directory instead of the local directory.
#
%.o: ${BLDDIR}/%.o
	@

#
# Borland/NT
#
ifeq ($(TOOLS),Borland)
# {
${BLDDIR}/%.obj: %.c
	bcc32 -D__BORLAND__ $(CFGFLAGS) \
		-I$(subst /,\,$(SDK)\include) \
		$(SYSINCLUDES) -o$@ -c $<
# }
endif

#
# Java Support
#
JAVAC	= /bin/javac
JAVACFLAGS= -nowarn

${BLDDIR}/%.class: %.java
	$(JAVAC) ${JAVACFLAGS} -d ${BLDDIR} $<

%.Z: %
	@$(ECHO) Compressing $< .....
	@$(COMPRESS) -c $< > $@

%.gz: %
	@$(ECHO) Compressing $< .....
	@$(GZIP) -c $< > $@


#
# Some Basic tools
#
INSTALL = /usr/ucb/install
INSTALLFLAGS =
CTAGS   = ctags
ETAGS	= etags

#
# List of directories where built objects live.
# (we are not making the export directories for now)
#
#DIRS =	${BLDDIR} ${EXPDIR}/lib ${EXPDIR}/bin ${EXPDIR}/include
DIRS =	${BLDDIR}

#
# Targets for build
#
include ${SDK}/make/Make.targets

ifeq (C_COMPILER,$(MAKECMDGOALS))
# {
C_COMPILER:
	@echo $(CC)
# }
endif

ifeq (CXX_COMPILER,$(MAKECMDGOALS))
# {
CXX_COMPILER:
	@echo $(CXX)
# }
endif

#
# Required for building PHYMOD library
#
ifeq (1,$(BUILD_PHYMOD))
# {
export CC
export AR
export ARFLAGS
export CROSS_COMPILE
export PHYMOD_BLDDIR = $(LIBDIR)
export PHYMOD_OBJDIR = $(BLDDIR)
export PHYMOD_EPIL_BLDDIR = $(LIBDIR)
export PHYMOD_EPIL_OBJDIR = $(BLDDIR)
export PHYMOD_CPPFLAGS = $(CFLAGS)
ifdef PHYMOD_PRE_BUILD_LIB
export PHYMOD_MAKE_RULES = $(SDK)/make/Make.phymod_prebuild
else
export PHYMOD_MAKE_RULES = $(SDK)/make/Make.phymod
endif
# }
endif

#
# Required for building PCIEPHY library
#
ifeq (1,$(BUILD_PCIEPHY))
# {
export CC
export AR
export ARFLAGS
export CROSS_COMPILE
export PCIEPHY_BLDDIR = $(LIBDIR)
export PCIEPHY_OBJDIR = $(BLDDIR)
export PCIEPHY_CPPFLAGS = $(CFLAGS)
export PCIEPHY_MAKE_RULES = $(SDK)/make/Make.pciephy
# }
endif

#
# Required for building SDKLT library
#
ifeq (1,$(BUILD_SDKLT))
# {
# Export toolchain.
export CC
export AR
export ARFLAGS
export LD
export TOOLSDIR
export CROSS_COMPILE
export KDIR=$(KERNDIR)

# Configure SDKLT libraries.
export Q
export SDK_BLDDIR = $(LIBDIR)/sdklt
export SDK_DSTDIR = $(LIBDIR)
export SDK_CPPFLAGS = $(LTSW_ADD_CPPFLAGS)
export SDK_CFLAGS = $(LTSW_ADD_CFLAGS)
export BCMA_EXCLUDE_TARGETS=sal bsl
ifeq (1,$(BUILD_PHYMOD))
SDK_EXCLUDE_TARGETS += phymod
endif
ifeq (1,$(BUILD_PCIEPHY))
SDK_EXCLUDE_TARGETS += pciephy
endif
ifneq (,(SDK_EXCLUDE_TARGETS))
export SDK_EXCLUDE_TARGETS
endif

# Configure SDKLT ISSU.
ifdef ISSU_CHIPS
export INCLUDE_DEVICES = $(addprefix -c ,$(ISSU_CHIPS))
endif
export ISSU_SDK_BLDDIR = $(SDK_BLDDIR)
export ISSU_SDK_DSTDIR = $(SDK_DSTDIR)
# }
endif

#
# Required for building FLEXE library
#
ifneq (,$(filter FLEXE FLEXE_DBG,$(FEATURE_LIST)))
# {
export CC
export AR
export ARFLAGS
export CROSS_COMPILE
export FLEXE_BLDDIR = $(LIBDIR)
export FLEXE_OBJDIR = $(BLDDIR)
export FLEXE_CPPFLAGS = $(CFLAGS)
export FLEXE_MAKE_RULES = $(SDK)/make/Make.flexe
# }
endif

#
# Required for building KAPS library
#
ifeq (1,$(BUILD_KAPS))
# {
export CC
export AR
export ARFLAGS
export CROSS_COMPILE
export KAPS_BLDDIR = $(LIBDIR)
export KAPS_OBJDIR = $(BLDDIR)
export KAPS_CPPFLAGS = $(CFLAGS)
export KAPS_MAKE_RULES = $(SDK)/make/Make.kaps
# }
endif

# Go test framework
ifeq (GO,$(findstring GO,$(FEATURE_LIST)))
# {
BUILD_GO = 1
# Not sure what the limitations of Go will be.
# When this is determined, should set GO_SUPPORT based on the limitations.
GO_SUPPORT = 1
# }
endif
