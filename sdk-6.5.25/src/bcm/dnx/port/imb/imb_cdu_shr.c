
/*
 *         
 * 
 * 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2021 Broadcom Inc. All rights reserved.
 *     
 * DO NOT EDIT THIS FILE!
 *
 */

#include <shared/shrextend/shrextend_debug.h>
#include <soc/dnxc/drv_dnxc_utils.h>

#include <bcm/port.h>
#include <bcm_int/dnx/port/imb/imb_common.h>
#include <bcm_int/dnx/port/imb/imb_internal.h>
#include <bcm_int/dnx/port/nif/dnx_port_nif_arb.h>
#include <bcm_int/dnx/port/nif/dnx_port_nif_ofr.h>
#include <bcm_int/dnx/port/nif/dnx_port_nif_oft.h>
#include <soc/portmod/portmod.h>
#include <soc/phy/phymod_sim.h>
#include <soc/dnx/swstate/auto_generated/access/dnx_port_imb_access.h>
#include <soc/dnx/swstate/auto_generated/types/dnx_port_imb_types.h>
#include <shared/shrextend/shrextend_debug.h>
#include <bcm_int/dnx/algo/swstate/auto_generated/access/dnx_algo_port_access.h>
#include <bcm_int/dnx/port/imb/imb.h>
#include <bcm_int/dnx/port/imb/imb_dispatch.h>
#include "imb_utils.h"
#include "imb_cdu_internal.h"
#include <soc/dnx/pll/pll.h>
#include <soc/dnx/dnx_err_recovery_manager.h>

#include <bcm_int/dnx/cosq/egress/egr_queuing.h>
#include <bcm_int/dnx/cosq/egress/esb.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_port.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_pll.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_esb.h>
#include <bcm_int/dnx/algo/port/algo_port_imb.h>
#include <bcm_int/dnx/algo/lane_map/algo_lane_map.h>
#ifdef INCLUDE_XFLOW_MACSEC
#include <dnx/dnx_sec.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_macsec.h>
#endif

#ifdef BSL_LOG_MODULE
#error "BSL_LOG_MODULE redefined"
#endif
#define BSL_LOG_MODULE BSL_LS_BCMDNX_PORT

#ifdef BCM_DNX2_SUPPORT

/**
 * \brief - call back function to portmod to reset port credit
 *
 */
int
imb_cdu_shr_portmod_soft_reset(
    int unit,
    soc_port_t port,
    portmod_call_back_action_type_t action)
{
    dnx_algo_port_info_s port_info;
    int is_port_enable;
    SHR_FUNC_INIT_VARS(unit);

    SHR_IF_ERR_EXIT(dnx_algo_port_info_get(unit, port, &port_info));

    if (DNX_ALGO_PORT_TYPE_IS_NIF_ETH(unit, port_info, DNX_ALGO_PORT_TYPE_INCLUDE_L1))
    {
        switch (action)
        {
            case portmodCallBackActionTypeDuring:
                break;

            case portmodCallBackActionTypePre:
                SHR_IF_ERR_EXIT(dnx_port_arb_pm_port_reset(unit, port, ARB_TX_DIRECTION, IMB_COMMON_IN_RESET));
                break;

            case portmodCallBackActionTypePost:
                SHR_IF_ERR_EXIT(imb_port_enable_get(unit, port, &is_port_enable));
                if (is_port_enable)
                {
                    SHR_IF_ERR_EXIT(dnx_port_arb_pm_port_reset(unit, port, ARB_TX_DIRECTION, IMB_COMMON_OUT_OF_RESET));
                }
                break;

            case portmodCallBackActionTypeLock:
                SHR_IF_ERR_EXIT(dnx_algo_port_db.general.portmod_mac_soft_reset_cb_lock.take(unit, sal_mutex_FOREVER));
                break;

            case portmodCallBackActionTypeUnlock:
                SHR_IF_ERR_EXIT(dnx_algo_port_db.general.portmod_mac_soft_reset_cb_lock.give(unit));
                break;

            default:
                break;
        }
    }

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief - this function will configure a struct of type portmod_pm_create_info_t
 *          before it is sent to portmod_port_macro_add
 *
 * \param [in] unit - chip unit id
 * \param [in] imb_info - imb info to retrive CDU id
 * \param [in] pm_in_cdu_index - pm index inside cdu
 * \param [in] pm_info - pm configuration sturct
 *
 * \return
 *   int - see _SHR_E_*
 *
 * \remarks
 *   * None
 * \see
 *   * None
 */
static int
imb_cdu_shr_port_macro_config(
    int unit,
    int pm_in_cdu_index,
    const imb_create_info_t * imb_info,
    portmod_pm_create_info_t * pm_info)
{
    bcm_port_t phy;
    bcm_pbmp_t pm_pbmp;
    int is_sim;
    int pm_index;
    int lane;
    uint32 rx_polarity, tx_polarity;
    phymod_lane_map_t lane_map = { 0 };
    DNX_SERDES_REF_CLOCK_TYPE ref_clk = DNX_SERDES_NOF_REF_CLOCKS;
    int lcpll;
    phymod_dispatch_type_t sim_type;

    SHR_FUNC_INIT_VARS(unit);

    if (dnx_data_nif.global.nof_lcplls_get(unit) > 1)
    {
        lcpll = imb_info->inst_id >= dnx_data_nif.eth.cdu_nof_per_core_get(unit) ? 1 : 0;
    }
    else
    {
        /** For devices w/o LCPLL, use fixed index 0 to retrieve ref clock from DNX-DATA */
        lcpll = 0;
    }
    /** update type and phys */
    /** CDU is always at index 0 */
    pm_info->type = dnx_data_nif.portmod.pm_types_and_interfaces_get(unit, 0)->type;
    pm_index = dnx_data_nif.eth.ethu_properties_get(unit, imb_info->inst_id)->pms[pm_in_cdu_index];
    pm_pbmp = dnx_data_nif.eth.pm_properties_get(unit, pm_index)->phys;
    BCM_PBMP_ITER(pm_pbmp, phy)
    {
        BCM_PBMP_PORT_ADD(pm_info->phys, phy);
        /** lane polarity get */
        rx_polarity = dnx_data_nif.phys.polarity_get(unit, (int) phy)->rx_polarity;
        tx_polarity = dnx_data_nif.phys.polarity_get(unit, (int) phy)->tx_polarity;
        lane = (int) phy % dnx_data_nif.eth.nof_lanes_in_cdu_get(unit);
        pm_info->pm_specific_info.pm8x50_flexe_gen2.polarity.rx_polarity |= ((rx_polarity & 0x1) << lane);
        pm_info->pm_specific_info.pm8x50_flexe_gen2.polarity.tx_polarity |= ((tx_polarity & 0x1) << lane);
    }

    ref_clk = dnx_data_pll.general.nif_pll_get(unit, lcpll)->out_freq;
    if (ref_clk == DNX_SERDES_REF_CLOCK_BYPASS)
    {
        ref_clk = dnx_data_pll.general.nif_pll_get(unit, lcpll)->in_freq;
    }

    SHR_IF_ERR_EXIT(dnx_to_phymod_ref_clk(unit, ref_clk, &(pm_info->pm_specific_info.pm8x50_flexe_gen2.ref_clk)));

    /** As we do not know the speeds of the ports on the PM yet,we set vco to null */

    /** update access struct with cdu info */
    SHR_IF_ERR_EXIT(phymod_access_t_init(&(pm_info->pm_specific_info.pm8x50_flexe_gen2.access.access)));
    pm_info->pm_specific_info.pm8x50_flexe_gen2.access.access.user_acc = imb_info->imb_specific_info.cdu.user_acc;
    pm_info->pm_specific_info.pm8x50_flexe_gen2.access.access.addr =
        dnx_data_nif.eth.pm_properties_get(unit, pm_index)->phy_addr;
    pm_info->pm_specific_info.pm8x50_flexe_gen2.access.access.bus = NULL;       /* Use default bus */

    sim_type = dnx_data_nif.simulator.cdu_type_get(unit);
    SHR_IF_ERR_EXIT(soc_physim_check_sim
                    (unit, sim_type, &(pm_info->pm_specific_info.pm8x50_flexe_gen2.access.access),
                     (imb_info->inst_id << 16), &is_sim));

    if (is_sim)
    {
        pm_info->pm_specific_info.pm8x50_flexe_gen2.fw_load_method = phymodFirmwareLoadMethodNone;
        /** enable clause45 just for sim - used by phy sim */
        PHYMOD_ACC_F_CLAUSE45_SET(&pm_info->pm_specific_info.pm8x50_flexe_gen2.access.access);
        PHYMOD_ACC_F_PHYSIM_SET(&pm_info->pm_specific_info.pm8x50_flexe_gen2.access.access);
    }
    else
    {
        pm_info->pm_specific_info.pm8x50_flexe_gen2.fw_load_method =
            dnx_data_port.static_add.nif_fw_load_method_get(unit);
    }

    pm_info->pm_specific_info.pm8x50_flexe_gen2.lane_map = lane_map; /** lane map soc property will be read at a later stage, we pass an empty lane map for now*/

    pm_info->pm_specific_info.pm8x50_flexe_gen2.external_fw_loader = NULL; /**Tells Portmod to use default external loader */

    pm_info->pm_specific_info.pm8x50_flexe_gen2.portmod_mac_soft_reset = imb_cdu_shr_portmod_soft_reset;
    /** pm_info->pm_specific_info.pm8x50_flexe_gen2.portmod_egress_buffer_reset = imb_ethu_port_credit_tx_reset; */

exit:
    SHR_FUNC_EXIT;
}

int
imb_cdu_shr_init(
    int unit,
    const imb_create_info_t * imb_info,
    imb_specific_create_info_t * imb_specific_info)
{
    int pm_i;
    int nof_cdus_per_core, cdu_id;
    bcm_core_t core;
    portmod_pm_create_info_t pm_info;
    portmod_default_user_access_t *user_acc;

    SHR_FUNC_INIT_VARS(unit);

    /**
     * 1. Initialize CDU DB
     */
    user_acc = sal_alloc(sizeof(portmod_default_user_access_t), "CDU user access");
    SHR_NULL_CHECK(user_acc, _SHR_E_MEMORY, "user_access");
    SHR_IF_ERR_EXIT(portmod_default_user_access_t_init(unit, user_acc));
    PORTMOD_USER_ACCESS_FW_LOAD_REVERSE_SET(user_acc);
    user_acc->unit = unit;
    user_acc->blk_id = dnx_drv_cdport_block(unit, imb_info->inst_id);
    user_acc->mutex = sal_mutex_create("pm mutex");
    SHR_NULL_CHECK(user_acc->mutex, _SHR_E_MEMORY, "user_access->mutex");
    imb_specific_info->cdu.user_acc = user_acc;

    /**
     * 2. initialize register values
     */
    if (!sw_state_is_warm_boot(unit))
    {
        nof_cdus_per_core = dnx_data_nif.eth.cdu_nof_per_core_get(unit);
        core = imb_info->inst_id >= nof_cdus_per_core ? 1 : 0;
        cdu_id = imb_info->inst_id % nof_cdus_per_core;

        /*
         * Take PM out of reset
         */
        SHR_IF_ERR_EXIT(imb_cdu_pm_reset(unit, core, cdu_id, IMB_COMMON_OUT_OF_RESET));

        /*
         * Enable EEE for the CDU - this does not actually enable the EEE for the ports, but if this bit is not set,
         * EEE will not work
         */
        SHR_IF_ERR_EXIT(imb_cdu_eee_enable_set(unit, core, cdu_id, 1));

        SHR_IF_ERR_EXIT(imb_cdu_iddq_enable_set(unit, core, cdu_id, 0));

    }

     /**
     * 3. initialize portmod_pm_create_info_t
     */
    for (pm_i = 0; pm_i < dnx_data_nif.eth.nof_pms_in_cdu_get(unit); pm_i++)
    {
        SHR_IF_ERR_EXIT(portmod_pm_create_info_t_init(unit, &pm_info));
        SHR_IF_ERR_EXIT(imb_cdu_shr_port_macro_config(unit, pm_i, imb_info, &pm_info));

        /*
         * Initialize specific pm8x50 info - after pm8x50 is implemented
         */
        SHR_IF_ERR_EXIT(portmod_port_macro_add(unit, &pm_info));
    }

exit:

    if (SHR_FUNC_ERR())
    {
        if (user_acc != NULL)
        {
            if (user_acc->mutex != NULL)
            {
                sal_mutex_destroy(user_acc->mutex);
            }

            sal_free(user_acc);
            imb_specific_info->cdu.user_acc = NULL;
        }
    }

    SHR_FUNC_EXIT;
}

int
imb_cdu_shr_deinit(
    int unit,
    const imb_create_info_t * imb_info,
    imb_specific_create_info_t * imb_specific_info)
{
    portmod_default_user_access_t *user_acc;
    SHR_FUNC_INIT_VARS(unit);

    user_acc = imb_specific_info->cdu.user_acc;

    if (user_acc != NULL)
    {
        if (user_acc->mutex != NULL)
        {
            sal_mutex_destroy(user_acc->mutex);
        }

        sal_free(user_acc);
        imb_specific_info->cdu.user_acc = NULL;
    }

    SHR_FUNC_EXIT;

}
/**
 * \brief - initialize Portmod add_info before calling
 *        portmod_port_add
 *
 * \param [in] unit - chip unit id.
 * \param [in] port - logical port
 * \param [in] add_info - portmod add info
 *
 * \return
 *   int - see _SHR_E_*
 *
 * \remarks
 *   * None
 * \see
 *   * None
 */
int
imb_cdu_shr_portmod_add_info_config(
    int unit,
    bcm_port_t port,
    portmod_port_add_info_t * add_info)
{
    int i, nof_phys;
    int pm_lower_bound, pm_upper_bound;
    soc_dnxc_lane_map_db_map_t lane2serdes[DNX_DATA_MAX_NIF_ETH_NOF_LANES_IN_CDU];

    SHR_FUNC_INIT_VARS(unit);
    SHR_IF_ERR_EXIT(portmod_port_add_info_t_init(unit, add_info));

    /*
     * Configure lane map info. Get the lane map info from swstate
     */
    SHR_IF_ERR_EXIT(dnx_algo_port_imb_ethu_port_pm_boundary_get(unit, port, &pm_lower_bound, &pm_upper_bound));
    SHR_IF_ERR_EXIT(dnx_algo_lane_map_pm_lane_to_serdes_map_get
                    (unit, DNX_ALGO_LANE_MAP_NIF_SIDE, pm_lower_bound, pm_upper_bound, lane2serdes));

    for (i = 0; i < dnx_data_nif.eth.nof_lanes_in_cdu_get(unit); i++)
    {
        add_info->init_config.lane_map[0].lane_map_rx[i] = lane2serdes[i].rx_id;
        add_info->init_config.lane_map[0].lane_map_tx[i] = lane2serdes[i].tx_id;
    }
    add_info->init_config.lane_map[0].num_of_lanes = dnx_data_nif.eth.nof_lanes_in_cdu_get(unit);
    add_info->init_config.lane_map_overwrite = 1; /** we always overwrite lane map*/
    add_info->init_config.polarity_overwrite = 0; /** same as in pm create, we don't need to overwrite*/
    add_info->init_config.fw_load_method_overwrite = 0; /** same as in pm create, we don't need to overwrite*/
    add_info->init_config.ref_clk_overwrite = 0; /** same as in pm create, we don't need to overwrite*/
    /** get port phys */
    SHR_IF_ERR_EXIT(dnx_algo_port_nif_phys_get(unit, port, 0, (bcm_pbmp_t *) & (add_info->phys)));
    /** get Max speed */
    PORTMOD_PBMP_COUNT(add_info->phys, nof_phys);
    add_info->interface_config.max_speed = dnx_data_nif.eth.max_speed_get(unit, nof_phys)->speed;

    PORTMOD_PORT_ADD_F_SKIP_SPEED_INIT_SET(add_info);
    PORTMOD_PORT_ADD_F_AUTONEG_CONFIG_SKIP_SET(add_info);
    PORTMOD_PORT_ADD_F_RX_SRIP_CRC_SET(add_info);

    if (dnx_data_port.static_add.nif_fw_crc_check_get(unit))
    {
        PORTMOD_PORT_ADD_F_BYPASS_FW_CRC_CHECK_CLR(add_info);
    }
    else
    {
        PORTMOD_PORT_ADD_F_BYPASS_FW_CRC_CHECK_SET(add_info);
    }

    if (dnx_data_port.static_add.nif_fw_load_verify_get(unit))
    {
        PORTMOD_PORT_ADD_F_FIRMWARE_LOAD_VERIFY_SET(add_info);
    }
    else
    {
        PORTMOD_PORT_ADD_F_FIRMWARE_LOAD_VERIFY_CLR(add_info);
    }

    add_info->interface_config.interface = SOC_PORT_IF_NIF_ETH;

exit:
    SHR_FUNC_EXIT;
}

int
imb_cdu_shr_port_attach(
    int unit,
    bcm_port_t port,
    uint32 flags)
{
    int is_master_port;
    portmod_port_add_info_t add_info;

    SHR_FUNC_INIT_VARS(unit);

    SHR_IF_ERR_EXIT(dnx_algo_port_is_master_get(unit, port, 0, &is_master_port));

    if (is_master_port)
    {
        /*
         * Adding shared blocks
         */
        SHR_IF_ERR_EXIT(dnx_port_ofr_port_add(unit, port));
        SHR_IF_ERR_EXIT(dnx_port_oft_port_add(unit, port));
        SHR_IF_ERR_EXIT(dnx_port_arb_port_add(unit, port));

#ifdef INCLUDE_XFLOW_MACSEC
        if (dnx_data_macsec.general.feature_get(unit, dnx_data_macsec_general_macsec_block_exists))
        {
        /** enable the MACSec core clk */
            SHR_IF_ERR_EXIT(dnx_xflow_macsec_shared_macsec_core_power_down_set(unit, 0));
        }
#endif
    }

    /*
     * 7.  Call Portmod API
     *
     */
    SHR_IF_ERR_EXIT(imb_cdu_shr_portmod_add_info_config(unit, port, &add_info));
    SHR_IF_ERR_EXIT(imb_er_portmod_port_add(unit, port, &add_info));

    if (is_master_port)
    {
        DNX_ERR_RECOVERY_SUPPRESS(unit);
        SHR_IF_ERR_EXIT(portmod_port_enable_set(unit, port, 0, 0));
        DNX_ERR_RECOVERY_UNSUPPRESS(unit);
    }
exit:
    SHR_FUNC_EXIT;

}

int
imb_cdu_shr_port_detach(
    int unit,
    bcm_port_t port)
{
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Removing shared blocks
     */
    SHR_IF_ERR_EXIT(dnx_port_arb_port_remove(unit, port));
    SHR_IF_ERR_EXIT(dnx_port_ofr_port_remove(unit, port));
    SHR_IF_ERR_EXIT(dnx_port_oft_port_remove(unit, port));

#ifdef INCLUDE_XFLOW_MACSEC
    if (dnx_data_macsec.general.feature_get(unit, dnx_data_macsec_general_macsec_block_exists))
    {
        /*
         * handle MACSec clean up
         */
        SHR_IF_ERR_EXIT(imb_common_port_macsec_port_enable_set(unit, port, 0 /** disable */ ));

        /*
         * disable the MACSec core clk ONLY in case this is the last port in the entire MACSec instance.
         */
        SHR_IF_ERR_EXIT(dnx_xflow_macsec_shared_macsec_core_power_down_set(unit, 1));
    }
#endif
    /*
     * 13.  Call Portmod API
     */
    SHR_IF_ERR_EXIT(imb_er_portmod_port_remove(unit, port));

exit:
    SHR_FUNC_EXIT;

}

int
imb_cdu_shr_port_enable_set(
    int unit,
    bcm_port_t port,
    uint32 flags,
    int enable)
{
    dnx_algo_port_info_s port_info;
    SHR_FUNC_INIT_VARS(unit);

    SHR_IF_ERR_EXIT(dnx_algo_port_info_get(unit, port, &port_info));

    /*
     * Enable port in OFT
     */
    SHR_IF_ERR_EXIT(dnx_port_oft_port_enable_set(unit, port, enable));

    /*
     * Enable port in Arb. Rx
     */
    SHR_IF_ERR_EXIT(dnx_port_arb_port_enable(unit, port, ARB_RX_DIRECTION, enable));

    /*
     * Enable port in OFR
     */
    SHR_IF_ERR_EXIT(dnx_port_ofr_port_enable(unit, port, enable));

    /*
     * Enable port in Arb. TX
     */
    SHR_IF_ERR_EXIT(dnx_port_arb_port_enable(unit, port, ARB_TX_DIRECTION, enable));

    /*
     * Enable credits in Arb. Tx
     */
    SHR_IF_ERR_EXIT(dnx_port_arb_credits_init(unit, port, enable));

    /*
     * Configure TXI logic and IRDY threshold
     */
    if (dnx_data_esb.general.feature_get(unit, dnx_data_esb_general_esb_support)
        && DNX_ALGO_PORT_TYPE_IS_EGR_TM(unit, port_info))
    {
        SHR_IF_ERR_EXIT(dnx_esb_port_txi_config_set(unit, port, enable));
    }

    if (enable)
    {
        /*
         * override the egress credits
         */
        if (DNX_ALGO_PORT_TYPE_IS_EGR_TM(unit, port_info))
        {
            /*
             * Wait for NIF to finish transmitting initial credits
             */
            sal_usleep(10);

            SHR_IF_ERR_EXIT(dnx_egr_queuing_nif_credit_default_set(unit, port));
        }
    }

    /*
     * enable the port in Portmod
     */
    SHR_IF_ERR_EXIT(imb_er_portmod_port_enable_set(unit, port, 0, enable));
exit:
    SHR_FUNC_EXIT;

}

int
imb_cdu_shr_port_enable_get(
    int unit,
    bcm_port_t port,
    int *enable)
{
    SHR_FUNC_INIT_VARS(unit);

    DNX_ERR_RECOVERY_SUPPRESS(unit);
    /*
     * Get the indication from Portmod
     */

    SHR_IF_ERR_CONT(portmod_port_enable_get(unit, port, 0, enable));
    if (SHR_FUNC_ERR())
    {
        DNX_ERR_RECOVERY_UNSUPPRESS(unit);
        SHR_EXIT();
    }

    DNX_ERR_RECOVERY_UNSUPPRESS(unit);

exit:
    SHR_FUNC_EXIT;

}

#endif /* BCM_DNX2_SUPPORT */

#undef BSL_LOG_MODULE
