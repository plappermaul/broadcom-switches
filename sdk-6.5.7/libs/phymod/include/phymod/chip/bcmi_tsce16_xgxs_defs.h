#ifndef __BCMI_TSCE16_XGXS_DEFS_H__
#define __BCMI_TSCE16_XGXS_DEFS_H__
/*******************************************************************************
 *
 * $Id: $
 * $Copyright: (c) 2016 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 *
 * Definition file for the BCMI_TSCE16_XGXS.
 * This file provides all basic definitions required to program the BCMI_TSCE16_XGXS.
 *
 * This file is autogenerated. Please do not edit.
 *
 ******************************************************************************/

#ifndef _DV_TB_
#include <phymod/acc/phymod_tsc_iblk.h>
#endif /* _DV_TB_ */

/*******************************************************************************
 *
 *                    CHIP DEFINITIONS BEGIN HERE
 *
 ******************************************************************************/



/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PHYID2
 * BLOCKS:   CL22_B0
 * REGADDR:  0x0002
 * DESC:     IEEE phyID2 Register
 * RESETVAL: 0x600d (24589)
 * ACCESS:   R/O
 * FIELDS:
 *     REGID1           PHYID2 register
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PHYID2r (0x00000002 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PHYID2r_SIZE 4

/*
 * This structure should be used to declare and program PHYID2.
 *
 */
typedef union BCMI_TSCE16_XGXS_PHYID2r_s {
	uint32_t v[1];
	uint32_t phyid2[1];
	uint32_t _phyid2;
} BCMI_TSCE16_XGXS_PHYID2r_t;

#define BCMI_TSCE16_XGXS_PHYID2r_CLR(r) (r).phyid2[0] = 0
#define BCMI_TSCE16_XGXS_PHYID2r_SET(r,d) (r).phyid2[0] = d
#define BCMI_TSCE16_XGXS_PHYID2r_GET(r) (r).phyid2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PHYID2r_REGID1f_GET(r) (((r).phyid2[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PHYID2r_REGID1f_SET(r,f) (r).phyid2[0]=(((r).phyid2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PHYID2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PHYID2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PHYID2r,(_r._phyid2))
#define BCMI_TSCE16_XGXS_WRITE_PHYID2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PHYID2r,(_r._phyid2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PHYID2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PHYID2r,(_r._phyid2))
#define BCMI_TSCE16_XGXS_READLN_PHYID2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PHYID2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._phyid2))
#define BCMI_TSCE16_XGXS_WRITELN_PHYID2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PHYID2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._phyid2))
#define BCMI_TSCE16_XGXS_WRITEALL_PHYID2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PHYID2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._phyid2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PHYID2r BCMI_TSCE16_XGXS_PHYID2r
#define PHYID2r_SIZE BCMI_TSCE16_XGXS_PHYID2r_SIZE
typedef BCMI_TSCE16_XGXS_PHYID2r_t PHYID2r_t;
#define PHYID2r_CLR BCMI_TSCE16_XGXS_PHYID2r_CLR
#define PHYID2r_SET BCMI_TSCE16_XGXS_PHYID2r_SET
#define PHYID2r_GET BCMI_TSCE16_XGXS_PHYID2r_GET
#define PHYID2r_REGID1f_GET BCMI_TSCE16_XGXS_PHYID2r_REGID1f_GET
#define PHYID2r_REGID1f_SET BCMI_TSCE16_XGXS_PHYID2r_REGID1f_SET
#define READ_PHYID2r BCMI_TSCE16_XGXS_READ_PHYID2r
#define WRITE_PHYID2r BCMI_TSCE16_XGXS_WRITE_PHYID2r
#define MODIFY_PHYID2r BCMI_TSCE16_XGXS_MODIFY_PHYID2r
#define READLN_PHYID2r BCMI_TSCE16_XGXS_READLN_PHYID2r
#define WRITELN_PHYID2r BCMI_TSCE16_XGXS_WRITELN_PHYID2r
#define WRITEALL_PHYID2r BCMI_TSCE16_XGXS_WRITEALL_PHYID2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PHYID2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PHYID3
 * BLOCKS:   CL22_B0
 * REGADDR:  0x0003
 * DESC:     IEEE phyID3 Register
 * RESETVAL: 0x8770 (34672)
 * ACCESS:   R/O
 * FIELDS:
 *     REGID2           PHYID3 register
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PHYID3r (0x00000003 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PHYID3r_SIZE 4

/*
 * This structure should be used to declare and program PHYID3.
 *
 */
typedef union BCMI_TSCE16_XGXS_PHYID3r_s {
	uint32_t v[1];
	uint32_t phyid3[1];
	uint32_t _phyid3;
} BCMI_TSCE16_XGXS_PHYID3r_t;

#define BCMI_TSCE16_XGXS_PHYID3r_CLR(r) (r).phyid3[0] = 0
#define BCMI_TSCE16_XGXS_PHYID3r_SET(r,d) (r).phyid3[0] = d
#define BCMI_TSCE16_XGXS_PHYID3r_GET(r) (r).phyid3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PHYID3r_REGID2f_GET(r) (((r).phyid3[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PHYID3r_REGID2f_SET(r,f) (r).phyid3[0]=(((r).phyid3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PHYID3.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PHYID3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PHYID3r,(_r._phyid3))
#define BCMI_TSCE16_XGXS_WRITE_PHYID3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PHYID3r,(_r._phyid3)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PHYID3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PHYID3r,(_r._phyid3))
#define BCMI_TSCE16_XGXS_READLN_PHYID3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PHYID3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._phyid3))
#define BCMI_TSCE16_XGXS_WRITELN_PHYID3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PHYID3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._phyid3))
#define BCMI_TSCE16_XGXS_WRITEALL_PHYID3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PHYID3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._phyid3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PHYID3r BCMI_TSCE16_XGXS_PHYID3r
#define PHYID3r_SIZE BCMI_TSCE16_XGXS_PHYID3r_SIZE
typedef BCMI_TSCE16_XGXS_PHYID3r_t PHYID3r_t;
#define PHYID3r_CLR BCMI_TSCE16_XGXS_PHYID3r_CLR
#define PHYID3r_SET BCMI_TSCE16_XGXS_PHYID3r_SET
#define PHYID3r_GET BCMI_TSCE16_XGXS_PHYID3r_GET
#define PHYID3r_REGID2f_GET BCMI_TSCE16_XGXS_PHYID3r_REGID2f_GET
#define PHYID3r_REGID2f_SET BCMI_TSCE16_XGXS_PHYID3r_REGID2f_SET
#define READ_PHYID3r BCMI_TSCE16_XGXS_READ_PHYID3r
#define WRITE_PHYID3r BCMI_TSCE16_XGXS_WRITE_PHYID3r
#define MODIFY_PHYID3r BCMI_TSCE16_XGXS_MODIFY_PHYID3r
#define READLN_PHYID3r BCMI_TSCE16_XGXS_READLN_PHYID3r
#define WRITELN_PHYID3r BCMI_TSCE16_XGXS_WRITELN_PHYID3r
#define WRITEALL_PHYID3r BCMI_TSCE16_XGXS_WRITEALL_PHYID3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PHYID3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  ACC_CTL
 * BLOCKS:   MDIO_CL22_IEEE
 * REGADDR:  0x000d
 * DESC:     MMD_access_control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MDIO_DEVAD       Device address
 *     MDIO_FUNCTION    00 = address01 = data, no post increment10 = data, post increment on reads and write11 = data, post increment on writes only
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_ACC_CTLr (0x0000000d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_ACC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program ACC_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_ACC_CTLr_s {
	uint32_t v[1];
	uint32_t acc_ctl[1];
	uint32_t _acc_ctl;
} BCMI_TSCE16_XGXS_ACC_CTLr_t;

#define BCMI_TSCE16_XGXS_ACC_CTLr_CLR(r) (r).acc_ctl[0] = 0
#define BCMI_TSCE16_XGXS_ACC_CTLr_SET(r,d) (r).acc_ctl[0] = d
#define BCMI_TSCE16_XGXS_ACC_CTLr_GET(r) (r).acc_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_ACC_CTLr_MDIO_FUNCTIONf_GET(r) ((((r).acc_ctl[0]) >> 14) & 0x3)
#define BCMI_TSCE16_XGXS_ACC_CTLr_MDIO_FUNCTIONf_SET(r,f) (r).acc_ctl[0]=(((r).acc_ctl[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCE16_XGXS_ACC_CTLr_MDIO_DEVADf_GET(r) (((r).acc_ctl[0]) & 0x1f)
#define BCMI_TSCE16_XGXS_ACC_CTLr_MDIO_DEVADf_SET(r,f) (r).acc_ctl[0]=(((r).acc_ctl[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access ACC_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_ACC_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_ACC_CTLr,(_r._acc_ctl))
#define BCMI_TSCE16_XGXS_WRITE_ACC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_ACC_CTLr,(_r._acc_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_ACC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_ACC_CTLr,(_r._acc_ctl))
#define BCMI_TSCE16_XGXS_READLN_ACC_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_ACC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._acc_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_ACC_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_ACC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._acc_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_ACC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_ACC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._acc_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ACC_CTLr BCMI_TSCE16_XGXS_ACC_CTLr
#define ACC_CTLr_SIZE BCMI_TSCE16_XGXS_ACC_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_ACC_CTLr_t ACC_CTLr_t;
#define ACC_CTLr_CLR BCMI_TSCE16_XGXS_ACC_CTLr_CLR
#define ACC_CTLr_SET BCMI_TSCE16_XGXS_ACC_CTLr_SET
#define ACC_CTLr_GET BCMI_TSCE16_XGXS_ACC_CTLr_GET
#define ACC_CTLr_MDIO_FUNCTIONf_GET BCMI_TSCE16_XGXS_ACC_CTLr_MDIO_FUNCTIONf_GET
#define ACC_CTLr_MDIO_FUNCTIONf_SET BCMI_TSCE16_XGXS_ACC_CTLr_MDIO_FUNCTIONf_SET
#define ACC_CTLr_MDIO_DEVADf_GET BCMI_TSCE16_XGXS_ACC_CTLr_MDIO_DEVADf_GET
#define ACC_CTLr_MDIO_DEVADf_SET BCMI_TSCE16_XGXS_ACC_CTLr_MDIO_DEVADf_SET
#define READ_ACC_CTLr BCMI_TSCE16_XGXS_READ_ACC_CTLr
#define WRITE_ACC_CTLr BCMI_TSCE16_XGXS_WRITE_ACC_CTLr
#define MODIFY_ACC_CTLr BCMI_TSCE16_XGXS_MODIFY_ACC_CTLr
#define READLN_ACC_CTLr BCMI_TSCE16_XGXS_READLN_ACC_CTLr
#define WRITELN_ACC_CTLr BCMI_TSCE16_XGXS_WRITELN_ACC_CTLr
#define WRITEALL_ACC_CTLr BCMI_TSCE16_XGXS_WRITEALL_ACC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_ACC_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  ACC_ADDR_DATA
 * BLOCKS:   MDIO_CL22_IEEE
 * REGADDR:  0x000e
 * DESC:     MMD_access_addr_data
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MDIO_ADDR_DATA   If function field in PMD access control register is set to 00then this is the address register. Otherwise it is the data register
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_ACC_ADDR_DATAr (0x0000000e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_ACC_ADDR_DATAr_SIZE 4

/*
 * This structure should be used to declare and program ACC_ADDR_DATA.
 *
 */
typedef union BCMI_TSCE16_XGXS_ACC_ADDR_DATAr_s {
	uint32_t v[1];
	uint32_t acc_addr_data[1];
	uint32_t _acc_addr_data;
} BCMI_TSCE16_XGXS_ACC_ADDR_DATAr_t;

#define BCMI_TSCE16_XGXS_ACC_ADDR_DATAr_CLR(r) (r).acc_addr_data[0] = 0
#define BCMI_TSCE16_XGXS_ACC_ADDR_DATAr_SET(r,d) (r).acc_addr_data[0] = d
#define BCMI_TSCE16_XGXS_ACC_ADDR_DATAr_GET(r) (r).acc_addr_data[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_ACC_ADDR_DATAr_MDIO_ADDR_DATAf_GET(r) (((r).acc_addr_data[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_ACC_ADDR_DATAr_MDIO_ADDR_DATAf_SET(r,f) (r).acc_addr_data[0]=(((r).acc_addr_data[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access ACC_ADDR_DATA.
 *
 */
#define BCMI_TSCE16_XGXS_READ_ACC_ADDR_DATAr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_ACC_ADDR_DATAr,(_r._acc_addr_data))
#define BCMI_TSCE16_XGXS_WRITE_ACC_ADDR_DATAr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_ACC_ADDR_DATAr,(_r._acc_addr_data)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_ACC_ADDR_DATAr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_ACC_ADDR_DATAr,(_r._acc_addr_data))
#define BCMI_TSCE16_XGXS_READLN_ACC_ADDR_DATAr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_ACC_ADDR_DATAr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._acc_addr_data))
#define BCMI_TSCE16_XGXS_WRITELN_ACC_ADDR_DATAr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_ACC_ADDR_DATAr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._acc_addr_data))
#define BCMI_TSCE16_XGXS_WRITEALL_ACC_ADDR_DATAr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_ACC_ADDR_DATAr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._acc_addr_data))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ACC_ADDR_DATAr BCMI_TSCE16_XGXS_ACC_ADDR_DATAr
#define ACC_ADDR_DATAr_SIZE BCMI_TSCE16_XGXS_ACC_ADDR_DATAr_SIZE
typedef BCMI_TSCE16_XGXS_ACC_ADDR_DATAr_t ACC_ADDR_DATAr_t;
#define ACC_ADDR_DATAr_CLR BCMI_TSCE16_XGXS_ACC_ADDR_DATAr_CLR
#define ACC_ADDR_DATAr_SET BCMI_TSCE16_XGXS_ACC_ADDR_DATAr_SET
#define ACC_ADDR_DATAr_GET BCMI_TSCE16_XGXS_ACC_ADDR_DATAr_GET
#define ACC_ADDR_DATAr_MDIO_ADDR_DATAf_GET BCMI_TSCE16_XGXS_ACC_ADDR_DATAr_MDIO_ADDR_DATAf_GET
#define ACC_ADDR_DATAr_MDIO_ADDR_DATAf_SET BCMI_TSCE16_XGXS_ACC_ADDR_DATAr_MDIO_ADDR_DATAf_SET
#define READ_ACC_ADDR_DATAr BCMI_TSCE16_XGXS_READ_ACC_ADDR_DATAr
#define WRITE_ACC_ADDR_DATAr BCMI_TSCE16_XGXS_WRITE_ACC_ADDR_DATAr
#define MODIFY_ACC_ADDR_DATAr BCMI_TSCE16_XGXS_MODIFY_ACC_ADDR_DATAr
#define READLN_ACC_ADDR_DATAr BCMI_TSCE16_XGXS_READLN_ACC_ADDR_DATAr
#define WRITELN_ACC_ADDR_DATAr BCMI_TSCE16_XGXS_WRITELN_ACC_ADDR_DATAr
#define WRITEALL_ACC_ADDR_DATAr BCMI_TSCE16_XGXS_WRITEALL_ACC_ADDR_DATAr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_ACC_ADDR_DATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  CL72IT_BASE_R_PMD_CTL
 * BLOCKS:   CL72_IEEE_TX
 * REGADDR:  0x0096
 * DESC:     BASE-R PMD control register 150
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL72_IEEE_RESTART_TRAINING 1 = Restart 10GBASE-KR cl72 training0 = Normal operation(self clearing)
 *     CL72_IEEE_TRAINING_ENABLE 1 = Enable the 10GBASE-KR start-up protocol0 = Disable the 10GBASE-KR start-up protocol
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_CTLr (0x00000096 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CL72IT_BASE_R_PMD_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_CTLr_s {
	uint32_t v[1];
	uint32_t cl72it_base_r_pmd_ctl[1];
	uint32_t _cl72it_base_r_pmd_ctl;
} BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_CTLr_t;

#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_CTLr_CLR(r) (r).cl72it_base_r_pmd_ctl[0] = 0
#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_CTLr_SET(r,d) (r).cl72it_base_r_pmd_ctl[0] = d
#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_CTLr_GET(r) (r).cl72it_base_r_pmd_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_CTLr_CL72_IEEE_TRAINING_ENABLEf_GET(r) ((((r).cl72it_base_r_pmd_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_CTLr_CL72_IEEE_TRAINING_ENABLEf_SET(r,f) (r).cl72it_base_r_pmd_ctl[0]=(((r).cl72it_base_r_pmd_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_CTLr_CL72_IEEE_RESTART_TRAININGf_GET(r) (((r).cl72it_base_r_pmd_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_CTLr_CL72_IEEE_RESTART_TRAININGf_SET(r,f) (r).cl72it_base_r_pmd_ctl[0]=(((r).cl72it_base_r_pmd_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL72IT_BASE_R_PMD_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_CL72IT_BASE_R_PMD_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_CTLr,(_r._cl72it_base_r_pmd_ctl))
#define BCMI_TSCE16_XGXS_WRITE_CL72IT_BASE_R_PMD_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_CTLr,(_r._cl72it_base_r_pmd_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_CL72IT_BASE_R_PMD_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_CTLr,(_r._cl72it_base_r_pmd_ctl))
#define BCMI_TSCE16_XGXS_READLN_CL72IT_BASE_R_PMD_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72it_base_r_pmd_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_CL72IT_BASE_R_PMD_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72it_base_r_pmd_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_CL72IT_BASE_R_PMD_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72it_base_r_pmd_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL72IT_BASE_R_PMD_CTLr BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_CTLr
#define CL72IT_BASE_R_PMD_CTLr_SIZE BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_CTLr_t CL72IT_BASE_R_PMD_CTLr_t;
#define CL72IT_BASE_R_PMD_CTLr_CLR BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_CTLr_CLR
#define CL72IT_BASE_R_PMD_CTLr_SET BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_CTLr_SET
#define CL72IT_BASE_R_PMD_CTLr_GET BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_CTLr_GET
#define CL72IT_BASE_R_PMD_CTLr_CL72_IEEE_TRAINING_ENABLEf_GET BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_CTLr_CL72_IEEE_TRAINING_ENABLEf_GET
#define CL72IT_BASE_R_PMD_CTLr_CL72_IEEE_TRAINING_ENABLEf_SET BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_CTLr_CL72_IEEE_TRAINING_ENABLEf_SET
#define CL72IT_BASE_R_PMD_CTLr_CL72_IEEE_RESTART_TRAININGf_GET BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_CTLr_CL72_IEEE_RESTART_TRAININGf_GET
#define CL72IT_BASE_R_PMD_CTLr_CL72_IEEE_RESTART_TRAININGf_SET BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_CTLr_CL72_IEEE_RESTART_TRAININGf_SET
#define READ_CL72IT_BASE_R_PMD_CTLr BCMI_TSCE16_XGXS_READ_CL72IT_BASE_R_PMD_CTLr
#define WRITE_CL72IT_BASE_R_PMD_CTLr BCMI_TSCE16_XGXS_WRITE_CL72IT_BASE_R_PMD_CTLr
#define MODIFY_CL72IT_BASE_R_PMD_CTLr BCMI_TSCE16_XGXS_MODIFY_CL72IT_BASE_R_PMD_CTLr
#define READLN_CL72IT_BASE_R_PMD_CTLr BCMI_TSCE16_XGXS_READLN_CL72IT_BASE_R_PMD_CTLr
#define WRITELN_CL72IT_BASE_R_PMD_CTLr BCMI_TSCE16_XGXS_WRITELN_CL72IT_BASE_R_PMD_CTLr
#define WRITEALL_CL72IT_BASE_R_PMD_CTLr BCMI_TSCE16_XGXS_WRITEALL_CL72IT_BASE_R_PMD_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  CL72IT_BASE_R_PMD_STS
 * BLOCKS:   CL72_IEEE_TX
 * REGADDR:  0x0097
 * DESC:     BASE-R PMD status register 151
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL72_IEEE_RECEIVER_STATUS 1 = Receiver trained and ready to receive data0 = Receiver training
 *     CL72_IEEE_FRAME_LOCK 1 = Training frame delineation detected0 = Training frame delineation not detected
 *     CL72_IEEE_TRAINING_STATUS 1 = Start-up protocol in progress0 = Start-up protocol complete
 *     CL72_IEEE_TRAINING_FAILURE 1 = Training failure has been detected0 = Training failure has not been detected
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr (0x00000097 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr_SIZE 4

/*
 * This structure should be used to declare and program CL72IT_BASE_R_PMD_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr_s {
	uint32_t v[1];
	uint32_t cl72it_base_r_pmd_sts[1];
	uint32_t _cl72it_base_r_pmd_sts;
} BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr_t;

#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr_CLR(r) (r).cl72it_base_r_pmd_sts[0] = 0
#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr_SET(r,d) (r).cl72it_base_r_pmd_sts[0] = d
#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr_GET(r) (r).cl72it_base_r_pmd_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr_CL72_IEEE_TRAINING_FAILUREf_GET(r) ((((r).cl72it_base_r_pmd_sts[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr_CL72_IEEE_TRAINING_FAILUREf_SET(r,f) (r).cl72it_base_r_pmd_sts[0]=(((r).cl72it_base_r_pmd_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr_CL72_IEEE_TRAINING_STATUSf_GET(r) ((((r).cl72it_base_r_pmd_sts[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr_CL72_IEEE_TRAINING_STATUSf_SET(r,f) (r).cl72it_base_r_pmd_sts[0]=(((r).cl72it_base_r_pmd_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr_CL72_IEEE_FRAME_LOCKf_GET(r) ((((r).cl72it_base_r_pmd_sts[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr_CL72_IEEE_FRAME_LOCKf_SET(r,f) (r).cl72it_base_r_pmd_sts[0]=(((r).cl72it_base_r_pmd_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr_CL72_IEEE_RECEIVER_STATUSf_GET(r) (((r).cl72it_base_r_pmd_sts[0]) & 0x1)
#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr_CL72_IEEE_RECEIVER_STATUSf_SET(r,f) (r).cl72it_base_r_pmd_sts[0]=(((r).cl72it_base_r_pmd_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL72IT_BASE_R_PMD_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_CL72IT_BASE_R_PMD_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr,(_r._cl72it_base_r_pmd_sts))
#define BCMI_TSCE16_XGXS_WRITE_CL72IT_BASE_R_PMD_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr,(_r._cl72it_base_r_pmd_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_CL72IT_BASE_R_PMD_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr,(_r._cl72it_base_r_pmd_sts))
#define BCMI_TSCE16_XGXS_READLN_CL72IT_BASE_R_PMD_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72it_base_r_pmd_sts))
#define BCMI_TSCE16_XGXS_WRITELN_CL72IT_BASE_R_PMD_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72it_base_r_pmd_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_CL72IT_BASE_R_PMD_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72it_base_r_pmd_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL72IT_BASE_R_PMD_STSr BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr
#define CL72IT_BASE_R_PMD_STSr_SIZE BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr_SIZE
typedef BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr_t CL72IT_BASE_R_PMD_STSr_t;
#define CL72IT_BASE_R_PMD_STSr_CLR BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr_CLR
#define CL72IT_BASE_R_PMD_STSr_SET BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr_SET
#define CL72IT_BASE_R_PMD_STSr_GET BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr_GET
#define CL72IT_BASE_R_PMD_STSr_CL72_IEEE_TRAINING_FAILUREf_GET BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr_CL72_IEEE_TRAINING_FAILUREf_GET
#define CL72IT_BASE_R_PMD_STSr_CL72_IEEE_TRAINING_FAILUREf_SET BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr_CL72_IEEE_TRAINING_FAILUREf_SET
#define CL72IT_BASE_R_PMD_STSr_CL72_IEEE_TRAINING_STATUSf_GET BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr_CL72_IEEE_TRAINING_STATUSf_GET
#define CL72IT_BASE_R_PMD_STSr_CL72_IEEE_TRAINING_STATUSf_SET BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr_CL72_IEEE_TRAINING_STATUSf_SET
#define CL72IT_BASE_R_PMD_STSr_CL72_IEEE_FRAME_LOCKf_GET BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr_CL72_IEEE_FRAME_LOCKf_GET
#define CL72IT_BASE_R_PMD_STSr_CL72_IEEE_FRAME_LOCKf_SET BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr_CL72_IEEE_FRAME_LOCKf_SET
#define CL72IT_BASE_R_PMD_STSr_CL72_IEEE_RECEIVER_STATUSf_GET BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr_CL72_IEEE_RECEIVER_STATUSf_GET
#define CL72IT_BASE_R_PMD_STSr_CL72_IEEE_RECEIVER_STATUSf_SET BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr_CL72_IEEE_RECEIVER_STATUSf_SET
#define READ_CL72IT_BASE_R_PMD_STSr BCMI_TSCE16_XGXS_READ_CL72IT_BASE_R_PMD_STSr
#define WRITE_CL72IT_BASE_R_PMD_STSr BCMI_TSCE16_XGXS_WRITE_CL72IT_BASE_R_PMD_STSr
#define MODIFY_CL72IT_BASE_R_PMD_STSr BCMI_TSCE16_XGXS_MODIFY_CL72IT_BASE_R_PMD_STSr
#define READLN_CL72IT_BASE_R_PMD_STSr BCMI_TSCE16_XGXS_READLN_CL72IT_BASE_R_PMD_STSr
#define WRITELN_CL72IT_BASE_R_PMD_STSr BCMI_TSCE16_XGXS_WRITELN_CL72IT_BASE_R_PMD_STSr
#define WRITEALL_CL72IT_BASE_R_PMD_STSr BCMI_TSCE16_XGXS_WRITEALL_CL72IT_BASE_R_PMD_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_CL72IT_BASE_R_PMD_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  CL72IR_BASE_R_LP_COEFF_UPD
 * BLOCKS:   CL72_IEEE_RX
 * REGADDR:  0x0098
 * DESC:     BASE-R LP coeff update register 152
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL72_IEEE_LP_COEFF_UPDATE This register reflects the first 16-bit Word of the training framemost recently recieived from the Link PartnerThis register is not writeable when cl72 training is disabled asindicated in the IEEE spec.15:14 Reserved13   Preset1 = Preset coefficients0 = Normal operation12   Initialize 1 = Initialize coefficients0 = Normal operation11:6 Reserved5:4  Coefficient (+1) update5 41 1 = reserved0 1 = increment1 0 = decrement0 0 = hold3:2  Coefficient (0) update3 21 1 = reserved0 1 = increment1 0 = decrement0 0 = hold1:0  Coefficient (-1) update1 01 1 = reserved0 1 = increment1 0 = decrement0 0 = hold
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_COEFF_UPDr (0x00000098 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_COEFF_UPDr_SIZE 4

/*
 * This structure should be used to declare and program CL72IR_BASE_R_LP_COEFF_UPD.
 *
 */
typedef union BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_COEFF_UPDr_s {
	uint32_t v[1];
	uint32_t cl72ir_base_r_lp_coeff_upd[1];
	uint32_t _cl72ir_base_r_lp_coeff_upd;
} BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_COEFF_UPDr_t;

#define BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_COEFF_UPDr_CLR(r) (r).cl72ir_base_r_lp_coeff_upd[0] = 0
#define BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_COEFF_UPDr_SET(r,d) (r).cl72ir_base_r_lp_coeff_upd[0] = d
#define BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_COEFF_UPDr_GET(r) (r).cl72ir_base_r_lp_coeff_upd[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_COEFF_UPDr_CL72_IEEE_LP_COEFF_UPDATEf_GET(r) (((r).cl72ir_base_r_lp_coeff_upd[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_COEFF_UPDr_CL72_IEEE_LP_COEFF_UPDATEf_SET(r,f) (r).cl72ir_base_r_lp_coeff_upd[0]=(((r).cl72ir_base_r_lp_coeff_upd[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CL72IR_BASE_R_LP_COEFF_UPD.
 *
 */
#define BCMI_TSCE16_XGXS_READ_CL72IR_BASE_R_LP_COEFF_UPDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_COEFF_UPDr,(_r._cl72ir_base_r_lp_coeff_upd))
#define BCMI_TSCE16_XGXS_WRITE_CL72IR_BASE_R_LP_COEFF_UPDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_COEFF_UPDr,(_r._cl72ir_base_r_lp_coeff_upd)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_CL72IR_BASE_R_LP_COEFF_UPDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_COEFF_UPDr,(_r._cl72ir_base_r_lp_coeff_upd))
#define BCMI_TSCE16_XGXS_READLN_CL72IR_BASE_R_LP_COEFF_UPDr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_COEFF_UPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72ir_base_r_lp_coeff_upd))
#define BCMI_TSCE16_XGXS_WRITELN_CL72IR_BASE_R_LP_COEFF_UPDr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_COEFF_UPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72ir_base_r_lp_coeff_upd))
#define BCMI_TSCE16_XGXS_WRITEALL_CL72IR_BASE_R_LP_COEFF_UPDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_COEFF_UPDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72ir_base_r_lp_coeff_upd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL72IR_BASE_R_LP_COEFF_UPDr BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_COEFF_UPDr
#define CL72IR_BASE_R_LP_COEFF_UPDr_SIZE BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_COEFF_UPDr_SIZE
typedef BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_COEFF_UPDr_t CL72IR_BASE_R_LP_COEFF_UPDr_t;
#define CL72IR_BASE_R_LP_COEFF_UPDr_CLR BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_COEFF_UPDr_CLR
#define CL72IR_BASE_R_LP_COEFF_UPDr_SET BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_COEFF_UPDr_SET
#define CL72IR_BASE_R_LP_COEFF_UPDr_GET BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_COEFF_UPDr_GET
#define CL72IR_BASE_R_LP_COEFF_UPDr_CL72_IEEE_LP_COEFF_UPDATEf_GET BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_COEFF_UPDr_CL72_IEEE_LP_COEFF_UPDATEf_GET
#define CL72IR_BASE_R_LP_COEFF_UPDr_CL72_IEEE_LP_COEFF_UPDATEf_SET BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_COEFF_UPDr_CL72_IEEE_LP_COEFF_UPDATEf_SET
#define READ_CL72IR_BASE_R_LP_COEFF_UPDr BCMI_TSCE16_XGXS_READ_CL72IR_BASE_R_LP_COEFF_UPDr
#define WRITE_CL72IR_BASE_R_LP_COEFF_UPDr BCMI_TSCE16_XGXS_WRITE_CL72IR_BASE_R_LP_COEFF_UPDr
#define MODIFY_CL72IR_BASE_R_LP_COEFF_UPDr BCMI_TSCE16_XGXS_MODIFY_CL72IR_BASE_R_LP_COEFF_UPDr
#define READLN_CL72IR_BASE_R_LP_COEFF_UPDr BCMI_TSCE16_XGXS_READLN_CL72IR_BASE_R_LP_COEFF_UPDr
#define WRITELN_CL72IR_BASE_R_LP_COEFF_UPDr BCMI_TSCE16_XGXS_WRITELN_CL72IR_BASE_R_LP_COEFF_UPDr
#define WRITEALL_CL72IR_BASE_R_LP_COEFF_UPDr BCMI_TSCE16_XGXS_WRITEALL_CL72IR_BASE_R_LP_COEFF_UPDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_COEFF_UPDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  CL72IR_BASE_R_LP_STS_REP
 * BLOCKS:   CL72_IEEE_RX
 * REGADDR:  0x0099
 * DESC:     BASE-R LP status report register 153
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL72_IEEE_LP_STATUS_REPORT This register reflects the second 16-bit Word of the training framemost recently recieived from the Link Partner15   Receiver Ready1 =  The LP receiver has determined that training iscomplete and is prepared to receive data0 =  The LP receiver is requesting that training continue14:6 Reserved5:4  Coefficient (+1) status5 41 1 = maximum1 0 = minimum0 1 = updated0 0 = not_updated3:2  Coefficient (0) status3 21 1 = maximum1 0 = minimum0 1 = updated0 0 = not_updated1:0  Coefficient (-1) status1 01 1 = maximum1 0 = minimum0 1 = updated0 0 = not_updated
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_STS_REPr (0x00000099 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_STS_REPr_SIZE 4

/*
 * This structure should be used to declare and program CL72IR_BASE_R_LP_STS_REP.
 *
 */
typedef union BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_STS_REPr_s {
	uint32_t v[1];
	uint32_t cl72ir_base_r_lp_sts_rep[1];
	uint32_t _cl72ir_base_r_lp_sts_rep;
} BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_STS_REPr_t;

#define BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_STS_REPr_CLR(r) (r).cl72ir_base_r_lp_sts_rep[0] = 0
#define BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_STS_REPr_SET(r,d) (r).cl72ir_base_r_lp_sts_rep[0] = d
#define BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_STS_REPr_GET(r) (r).cl72ir_base_r_lp_sts_rep[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_STS_REPr_CL72_IEEE_LP_STATUS_REPORTf_GET(r) (((r).cl72ir_base_r_lp_sts_rep[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_STS_REPr_CL72_IEEE_LP_STATUS_REPORTf_SET(r,f) (r).cl72ir_base_r_lp_sts_rep[0]=(((r).cl72ir_base_r_lp_sts_rep[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CL72IR_BASE_R_LP_STS_REP.
 *
 */
#define BCMI_TSCE16_XGXS_READ_CL72IR_BASE_R_LP_STS_REPr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_STS_REPr,(_r._cl72ir_base_r_lp_sts_rep))
#define BCMI_TSCE16_XGXS_WRITE_CL72IR_BASE_R_LP_STS_REPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_STS_REPr,(_r._cl72ir_base_r_lp_sts_rep)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_CL72IR_BASE_R_LP_STS_REPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_STS_REPr,(_r._cl72ir_base_r_lp_sts_rep))
#define BCMI_TSCE16_XGXS_READLN_CL72IR_BASE_R_LP_STS_REPr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_STS_REPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72ir_base_r_lp_sts_rep))
#define BCMI_TSCE16_XGXS_WRITELN_CL72IR_BASE_R_LP_STS_REPr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_STS_REPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72ir_base_r_lp_sts_rep))
#define BCMI_TSCE16_XGXS_WRITEALL_CL72IR_BASE_R_LP_STS_REPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_STS_REPr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72ir_base_r_lp_sts_rep))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL72IR_BASE_R_LP_STS_REPr BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_STS_REPr
#define CL72IR_BASE_R_LP_STS_REPr_SIZE BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_STS_REPr_SIZE
typedef BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_STS_REPr_t CL72IR_BASE_R_LP_STS_REPr_t;
#define CL72IR_BASE_R_LP_STS_REPr_CLR BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_STS_REPr_CLR
#define CL72IR_BASE_R_LP_STS_REPr_SET BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_STS_REPr_SET
#define CL72IR_BASE_R_LP_STS_REPr_GET BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_STS_REPr_GET
#define CL72IR_BASE_R_LP_STS_REPr_CL72_IEEE_LP_STATUS_REPORTf_GET BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_STS_REPr_CL72_IEEE_LP_STATUS_REPORTf_GET
#define CL72IR_BASE_R_LP_STS_REPr_CL72_IEEE_LP_STATUS_REPORTf_SET BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_STS_REPr_CL72_IEEE_LP_STATUS_REPORTf_SET
#define READ_CL72IR_BASE_R_LP_STS_REPr BCMI_TSCE16_XGXS_READ_CL72IR_BASE_R_LP_STS_REPr
#define WRITE_CL72IR_BASE_R_LP_STS_REPr BCMI_TSCE16_XGXS_WRITE_CL72IR_BASE_R_LP_STS_REPr
#define MODIFY_CL72IR_BASE_R_LP_STS_REPr BCMI_TSCE16_XGXS_MODIFY_CL72IR_BASE_R_LP_STS_REPr
#define READLN_CL72IR_BASE_R_LP_STS_REPr BCMI_TSCE16_XGXS_READLN_CL72IR_BASE_R_LP_STS_REPr
#define WRITELN_CL72IR_BASE_R_LP_STS_REPr BCMI_TSCE16_XGXS_WRITELN_CL72IR_BASE_R_LP_STS_REPr
#define WRITEALL_CL72IR_BASE_R_LP_STS_REPr BCMI_TSCE16_XGXS_WRITEALL_CL72IR_BASE_R_LP_STS_REPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_CL72IR_BASE_R_LP_STS_REPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  CL72IT_BASE_R_LD_COEFF_UPD
 * BLOCKS:   CL72_IEEE_TX
 * REGADDR:  0x009a
 * DESC:     BASE-R LD coeff update register 154
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL72_IEEE_LD_COEFF_UPDATE This register reflects the first 16-bit Word of the outgoing training framesent by the Local Device15:14 Reserved13   Preset1 = Preset coefficients0 = Normal operation12   Initialize 1 = Initialize coefficients0 = Normal operation11:6 Reserved5:4  Coefficient (+1) update5 41 1 = reserved0 1 = increment1 0 = decrement0 0 = hold3:2  Coefficient (0) update3 21 1 = reserved0 1 = increment1 0 = decrement0 0 = hold1:0  Coefficient (-1) update1 01 1 = reserved0 1 = increment1 0 = decrement0 0 = hold
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_COEFF_UPDr (0x0000009a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_COEFF_UPDr_SIZE 4

/*
 * This structure should be used to declare and program CL72IT_BASE_R_LD_COEFF_UPD.
 *
 */
typedef union BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_COEFF_UPDr_s {
	uint32_t v[1];
	uint32_t cl72it_base_r_ld_coeff_upd[1];
	uint32_t _cl72it_base_r_ld_coeff_upd;
} BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_COEFF_UPDr_t;

#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_COEFF_UPDr_CLR(r) (r).cl72it_base_r_ld_coeff_upd[0] = 0
#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_COEFF_UPDr_SET(r,d) (r).cl72it_base_r_ld_coeff_upd[0] = d
#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_COEFF_UPDr_GET(r) (r).cl72it_base_r_ld_coeff_upd[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_COEFF_UPDr_CL72_IEEE_LD_COEFF_UPDATEf_GET(r) (((r).cl72it_base_r_ld_coeff_upd[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_COEFF_UPDr_CL72_IEEE_LD_COEFF_UPDATEf_SET(r,f) (r).cl72it_base_r_ld_coeff_upd[0]=(((r).cl72it_base_r_ld_coeff_upd[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CL72IT_BASE_R_LD_COEFF_UPD.
 *
 */
#define BCMI_TSCE16_XGXS_READ_CL72IT_BASE_R_LD_COEFF_UPDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_COEFF_UPDr,(_r._cl72it_base_r_ld_coeff_upd))
#define BCMI_TSCE16_XGXS_WRITE_CL72IT_BASE_R_LD_COEFF_UPDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_COEFF_UPDr,(_r._cl72it_base_r_ld_coeff_upd)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_CL72IT_BASE_R_LD_COEFF_UPDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_COEFF_UPDr,(_r._cl72it_base_r_ld_coeff_upd))
#define BCMI_TSCE16_XGXS_READLN_CL72IT_BASE_R_LD_COEFF_UPDr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_COEFF_UPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72it_base_r_ld_coeff_upd))
#define BCMI_TSCE16_XGXS_WRITELN_CL72IT_BASE_R_LD_COEFF_UPDr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_COEFF_UPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72it_base_r_ld_coeff_upd))
#define BCMI_TSCE16_XGXS_WRITEALL_CL72IT_BASE_R_LD_COEFF_UPDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_COEFF_UPDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72it_base_r_ld_coeff_upd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL72IT_BASE_R_LD_COEFF_UPDr BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_COEFF_UPDr
#define CL72IT_BASE_R_LD_COEFF_UPDr_SIZE BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_COEFF_UPDr_SIZE
typedef BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_COEFF_UPDr_t CL72IT_BASE_R_LD_COEFF_UPDr_t;
#define CL72IT_BASE_R_LD_COEFF_UPDr_CLR BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_COEFF_UPDr_CLR
#define CL72IT_BASE_R_LD_COEFF_UPDr_SET BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_COEFF_UPDr_SET
#define CL72IT_BASE_R_LD_COEFF_UPDr_GET BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_COEFF_UPDr_GET
#define CL72IT_BASE_R_LD_COEFF_UPDr_CL72_IEEE_LD_COEFF_UPDATEf_GET BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_COEFF_UPDr_CL72_IEEE_LD_COEFF_UPDATEf_GET
#define CL72IT_BASE_R_LD_COEFF_UPDr_CL72_IEEE_LD_COEFF_UPDATEf_SET BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_COEFF_UPDr_CL72_IEEE_LD_COEFF_UPDATEf_SET
#define READ_CL72IT_BASE_R_LD_COEFF_UPDr BCMI_TSCE16_XGXS_READ_CL72IT_BASE_R_LD_COEFF_UPDr
#define WRITE_CL72IT_BASE_R_LD_COEFF_UPDr BCMI_TSCE16_XGXS_WRITE_CL72IT_BASE_R_LD_COEFF_UPDr
#define MODIFY_CL72IT_BASE_R_LD_COEFF_UPDr BCMI_TSCE16_XGXS_MODIFY_CL72IT_BASE_R_LD_COEFF_UPDr
#define READLN_CL72IT_BASE_R_LD_COEFF_UPDr BCMI_TSCE16_XGXS_READLN_CL72IT_BASE_R_LD_COEFF_UPDr
#define WRITELN_CL72IT_BASE_R_LD_COEFF_UPDr BCMI_TSCE16_XGXS_WRITELN_CL72IT_BASE_R_LD_COEFF_UPDr
#define WRITEALL_CL72IT_BASE_R_LD_COEFF_UPDr BCMI_TSCE16_XGXS_WRITEALL_CL72IT_BASE_R_LD_COEFF_UPDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_COEFF_UPDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  CL72IT_BASE_R_LD_STS_REP
 * BLOCKS:   CL72_IEEE_TX
 * REGADDR:  0x009b
 * DESC:     BASE-R LD status report register 155
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL72_IEEE_LD_STATUS_REPORT This register reflects the second 16-bit Word of the outgoing training framesent by the Local Device15   Receiver Ready1 =  The LD receiver has determined that training iscomplete and is prepared to receive data0 =  The LD receiver is requesting that training continue14:6 Reserved5:4  Coefficient (+1) status5 41 1 = maximum1 0 = minimum0 1 = updated0 0 = not_updated3:2  Coefficient (0) status3 21 1 = maximum1 0 = minimum0 1 = updated0 0 = not_updated1:0  Coefficient (-1) status1 01 1 = maximum1 0 = minimum0 1 = updated0 0 = not_updated
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_STS_REPr (0x0000009b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_STS_REPr_SIZE 4

/*
 * This structure should be used to declare and program CL72IT_BASE_R_LD_STS_REP.
 *
 */
typedef union BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_STS_REPr_s {
	uint32_t v[1];
	uint32_t cl72it_base_r_ld_sts_rep[1];
	uint32_t _cl72it_base_r_ld_sts_rep;
} BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_STS_REPr_t;

#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_STS_REPr_CLR(r) (r).cl72it_base_r_ld_sts_rep[0] = 0
#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_STS_REPr_SET(r,d) (r).cl72it_base_r_ld_sts_rep[0] = d
#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_STS_REPr_GET(r) (r).cl72it_base_r_ld_sts_rep[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_STS_REPr_CL72_IEEE_LD_STATUS_REPORTf_GET(r) (((r).cl72it_base_r_ld_sts_rep[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_STS_REPr_CL72_IEEE_LD_STATUS_REPORTf_SET(r,f) (r).cl72it_base_r_ld_sts_rep[0]=(((r).cl72it_base_r_ld_sts_rep[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CL72IT_BASE_R_LD_STS_REP.
 *
 */
#define BCMI_TSCE16_XGXS_READ_CL72IT_BASE_R_LD_STS_REPr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_STS_REPr,(_r._cl72it_base_r_ld_sts_rep))
#define BCMI_TSCE16_XGXS_WRITE_CL72IT_BASE_R_LD_STS_REPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_STS_REPr,(_r._cl72it_base_r_ld_sts_rep)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_CL72IT_BASE_R_LD_STS_REPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_STS_REPr,(_r._cl72it_base_r_ld_sts_rep))
#define BCMI_TSCE16_XGXS_READLN_CL72IT_BASE_R_LD_STS_REPr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_STS_REPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72it_base_r_ld_sts_rep))
#define BCMI_TSCE16_XGXS_WRITELN_CL72IT_BASE_R_LD_STS_REPr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_STS_REPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72it_base_r_ld_sts_rep))
#define BCMI_TSCE16_XGXS_WRITEALL_CL72IT_BASE_R_LD_STS_REPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_STS_REPr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72it_base_r_ld_sts_rep))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL72IT_BASE_R_LD_STS_REPr BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_STS_REPr
#define CL72IT_BASE_R_LD_STS_REPr_SIZE BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_STS_REPr_SIZE
typedef BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_STS_REPr_t CL72IT_BASE_R_LD_STS_REPr_t;
#define CL72IT_BASE_R_LD_STS_REPr_CLR BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_STS_REPr_CLR
#define CL72IT_BASE_R_LD_STS_REPr_SET BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_STS_REPr_SET
#define CL72IT_BASE_R_LD_STS_REPr_GET BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_STS_REPr_GET
#define CL72IT_BASE_R_LD_STS_REPr_CL72_IEEE_LD_STATUS_REPORTf_GET BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_STS_REPr_CL72_IEEE_LD_STATUS_REPORTf_GET
#define CL72IT_BASE_R_LD_STS_REPr_CL72_IEEE_LD_STATUS_REPORTf_SET BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_STS_REPr_CL72_IEEE_LD_STATUS_REPORTf_SET
#define READ_CL72IT_BASE_R_LD_STS_REPr BCMI_TSCE16_XGXS_READ_CL72IT_BASE_R_LD_STS_REPr
#define WRITE_CL72IT_BASE_R_LD_STS_REPr BCMI_TSCE16_XGXS_WRITE_CL72IT_BASE_R_LD_STS_REPr
#define MODIFY_CL72IT_BASE_R_LD_STS_REPr BCMI_TSCE16_XGXS_MODIFY_CL72IT_BASE_R_LD_STS_REPr
#define READLN_CL72IT_BASE_R_LD_STS_REPr BCMI_TSCE16_XGXS_READLN_CL72IT_BASE_R_LD_STS_REPr
#define WRITELN_CL72IT_BASE_R_LD_STS_REPr BCMI_TSCE16_XGXS_WRITELN_CL72IT_BASE_R_LD_STS_REPr
#define WRITEALL_CL72IT_BASE_R_LD_STS_REPr BCMI_TSCE16_XGXS_WRITEALL_CL72IT_BASE_R_LD_STS_REPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_CL72IT_BASE_R_LD_STS_REPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  MAIN0_SETUP
 * BLOCKS:   MAIN0
 * REGADDR:  0x9000
 * DESC:     main control register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     STAND_ALONE_MODE This mode is used for testing without a MAC.The credits from the TSC and loopbed back into the TSC as DVs.The same is true for the PORT and TDM fields
 *     SINGLE_PORT_MODE Indicates TSC is in single port mode.  Used by AN logic to determine whether to reset the PLL after AN completes.If set, when AN completes, the PLL will be reset to operate consistent with the resolved AN speed.If not set, the PLL will not change once AN completes.
 *     PORT_MODE_SEL    port configuration selects3'h0 : 4 port mode - lanes 3,2,1,0 as 4 ports3'h1 : 3 port mode - lanes 3,2 aggregated and 1,0 as 3 ports3'h2 : 3 port mode - lanes 1,0 aggregated and 3,2 as 3 ports3'h3 : 2 port mode - lanes 1,0 aggregated and 3,2 aggregated as 2 ports3'h4 : 1 port mode - lanes 3,2,1,0 aggregated as 1 port3'h5-7 : invalid
 *     AN_HIGH_VCO      N/A for tsce_28nm(gen1).For tsce_16nm(gen2),If set to 1, Switch to 12.5G VCO based speed mode after Auto Negotiation(Common to both Cl37 and Cl73).By default, TSCE selects 10.3125G VCO based speed mode after Auto Negotiation(Common to both Cl37 and Cl73).
 *     MASTER_PORT_NUM  Port that will control PMD core logic and PLL reset0 : port 0 is master1 : port 1 is master2 : port 2 is master3 : port 3 is master
 *     PLL_RESET_EN     Enable reseting PMD core logic and PLL by Speed control. The port that will reset the pll is selected by master_port_number
 *     CL73_LOW_VCO     N/A for tsce_16nm(gen2).For tsce_28nm(gen1), Switch to 6.25G VCO if resolved speed is 1G. By default 10.3125G VCO based speed is used.
 *     CL37_HIGH_VCO    N/A for tsce_16nm(gen2).For tsce_28nm(gen1),If set to 1, Use 10.3125G VCO based speed for CL37 AN. By default 6.25G VCO based speed is used.This bit will also make the resolved speeds to use 10.3125 VCO when possible.
 *     REFCLK_SEL       Specifies refclk frequency
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_MAIN0_SETUPr (0x00109000 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_MAIN0_SETUPr_SIZE 4

/*
 * This structure should be used to declare and program MAIN0_SETUP.
 *
 */
typedef union BCMI_TSCE16_XGXS_MAIN0_SETUPr_s {
	uint32_t v[1];
	uint32_t main0_setup[1];
	uint32_t _main0_setup;
} BCMI_TSCE16_XGXS_MAIN0_SETUPr_t;

#define BCMI_TSCE16_XGXS_MAIN0_SETUPr_CLR(r) (r).main0_setup[0] = 0
#define BCMI_TSCE16_XGXS_MAIN0_SETUPr_SET(r,d) (r).main0_setup[0] = d
#define BCMI_TSCE16_XGXS_MAIN0_SETUPr_GET(r) (r).main0_setup[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_MAIN0_SETUPr_REFCLK_SELf_GET(r) ((((r).main0_setup[0]) >> 13) & 0x7)
#define BCMI_TSCE16_XGXS_MAIN0_SETUPr_REFCLK_SELf_SET(r,f) (r).main0_setup[0]=(((r).main0_setup[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13)) | (7 << (16 + 13))
#define BCMI_TSCE16_XGXS_MAIN0_SETUPr_CL37_HIGH_VCOf_GET(r) ((((r).main0_setup[0]) >> 12) & 0x1)
#define BCMI_TSCE16_XGXS_MAIN0_SETUPr_CL37_HIGH_VCOf_SET(r,f) (r).main0_setup[0]=(((r).main0_setup[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCE16_XGXS_MAIN0_SETUPr_CL73_LOW_VCOf_GET(r) ((((r).main0_setup[0]) >> 11) & 0x1)
#define BCMI_TSCE16_XGXS_MAIN0_SETUPr_CL73_LOW_VCOf_SET(r,f) (r).main0_setup[0]=(((r).main0_setup[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCE16_XGXS_MAIN0_SETUPr_PLL_RESET_ENf_GET(r) ((((r).main0_setup[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_MAIN0_SETUPr_PLL_RESET_ENf_SET(r,f) (r).main0_setup[0]=(((r).main0_setup[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_MAIN0_SETUPr_MASTER_PORT_NUMf_GET(r) ((((r).main0_setup[0]) >> 8) & 0x3)
#define BCMI_TSCE16_XGXS_MAIN0_SETUPr_MASTER_PORT_NUMf_SET(r,f) (r).main0_setup[0]=(((r).main0_setup[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_TSCE16_XGXS_MAIN0_SETUPr_AN_HIGH_VCOf_GET(r) ((((r).main0_setup[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_MAIN0_SETUPr_AN_HIGH_VCOf_SET(r,f) (r).main0_setup[0]=(((r).main0_setup[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_MAIN0_SETUPr_PORT_MODE_SELf_GET(r) ((((r).main0_setup[0]) >> 4) & 0x7)
#define BCMI_TSCE16_XGXS_MAIN0_SETUPr_PORT_MODE_SELf_SET(r,f) (r).main0_setup[0]=(((r).main0_setup[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_TSCE16_XGXS_MAIN0_SETUPr_SINGLE_PORT_MODEf_GET(r) ((((r).main0_setup[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_MAIN0_SETUPr_SINGLE_PORT_MODEf_SET(r,f) (r).main0_setup[0]=(((r).main0_setup[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_MAIN0_SETUPr_STAND_ALONE_MODEf_GET(r) ((((r).main0_setup[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_MAIN0_SETUPr_STAND_ALONE_MODEf_SET(r,f) (r).main0_setup[0]=(((r).main0_setup[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))

/*
 * These macros can be used to access MAIN0_SETUP.
 *
 */
#define BCMI_TSCE16_XGXS_READ_MAIN0_SETUPr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MAIN0_SETUPr,(_r._main0_setup))
#define BCMI_TSCE16_XGXS_WRITE_MAIN0_SETUPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MAIN0_SETUPr,(_r._main0_setup)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_MAIN0_SETUPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MAIN0_SETUPr,(_r._main0_setup))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0_SETUPr BCMI_TSCE16_XGXS_MAIN0_SETUPr
#define MAIN0_SETUPr_SIZE BCMI_TSCE16_XGXS_MAIN0_SETUPr_SIZE
typedef BCMI_TSCE16_XGXS_MAIN0_SETUPr_t MAIN0_SETUPr_t;
#define MAIN0_SETUPr_CLR BCMI_TSCE16_XGXS_MAIN0_SETUPr_CLR
#define MAIN0_SETUPr_SET BCMI_TSCE16_XGXS_MAIN0_SETUPr_SET
#define MAIN0_SETUPr_GET BCMI_TSCE16_XGXS_MAIN0_SETUPr_GET
#define MAIN0_SETUPr_REFCLK_SELf_GET BCMI_TSCE16_XGXS_MAIN0_SETUPr_REFCLK_SELf_GET
#define MAIN0_SETUPr_REFCLK_SELf_SET BCMI_TSCE16_XGXS_MAIN0_SETUPr_REFCLK_SELf_SET
#define MAIN0_SETUPr_CL37_HIGH_VCOf_GET BCMI_TSCE16_XGXS_MAIN0_SETUPr_CL37_HIGH_VCOf_GET
#define MAIN0_SETUPr_CL37_HIGH_VCOf_SET BCMI_TSCE16_XGXS_MAIN0_SETUPr_CL37_HIGH_VCOf_SET
#define MAIN0_SETUPr_CL73_LOW_VCOf_GET BCMI_TSCE16_XGXS_MAIN0_SETUPr_CL73_LOW_VCOf_GET
#define MAIN0_SETUPr_CL73_LOW_VCOf_SET BCMI_TSCE16_XGXS_MAIN0_SETUPr_CL73_LOW_VCOf_SET
#define MAIN0_SETUPr_PLL_RESET_ENf_GET BCMI_TSCE16_XGXS_MAIN0_SETUPr_PLL_RESET_ENf_GET
#define MAIN0_SETUPr_PLL_RESET_ENf_SET BCMI_TSCE16_XGXS_MAIN0_SETUPr_PLL_RESET_ENf_SET
#define MAIN0_SETUPr_MASTER_PORT_NUMf_GET BCMI_TSCE16_XGXS_MAIN0_SETUPr_MASTER_PORT_NUMf_GET
#define MAIN0_SETUPr_MASTER_PORT_NUMf_SET BCMI_TSCE16_XGXS_MAIN0_SETUPr_MASTER_PORT_NUMf_SET
#define MAIN0_SETUPr_AN_HIGH_VCOf_GET BCMI_TSCE16_XGXS_MAIN0_SETUPr_AN_HIGH_VCOf_GET
#define MAIN0_SETUPr_AN_HIGH_VCOf_SET BCMI_TSCE16_XGXS_MAIN0_SETUPr_AN_HIGH_VCOf_SET
#define MAIN0_SETUPr_PORT_MODE_SELf_GET BCMI_TSCE16_XGXS_MAIN0_SETUPr_PORT_MODE_SELf_GET
#define MAIN0_SETUPr_PORT_MODE_SELf_SET BCMI_TSCE16_XGXS_MAIN0_SETUPr_PORT_MODE_SELf_SET
#define MAIN0_SETUPr_SINGLE_PORT_MODEf_GET BCMI_TSCE16_XGXS_MAIN0_SETUPr_SINGLE_PORT_MODEf_GET
#define MAIN0_SETUPr_SINGLE_PORT_MODEf_SET BCMI_TSCE16_XGXS_MAIN0_SETUPr_SINGLE_PORT_MODEf_SET
#define MAIN0_SETUPr_STAND_ALONE_MODEf_GET BCMI_TSCE16_XGXS_MAIN0_SETUPr_STAND_ALONE_MODEf_GET
#define MAIN0_SETUPr_STAND_ALONE_MODEf_SET BCMI_TSCE16_XGXS_MAIN0_SETUPr_STAND_ALONE_MODEf_SET
#define READ_MAIN0_SETUPr BCMI_TSCE16_XGXS_READ_MAIN0_SETUPr
#define WRITE_MAIN0_SETUPr BCMI_TSCE16_XGXS_WRITE_MAIN0_SETUPr
#define MODIFY_MAIN0_SETUPr BCMI_TSCE16_XGXS_MODIFY_MAIN0_SETUPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_MAIN0_SETUPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  MAIN0_SYNCE_CTL
 * BLOCKS:   MAIN0
 * REGADDR:  0x9001
 * DESC:     SyncE (Stage 1) mode register
 * RESETVAL: 0xaa (170)
 * ACCESS:   R/W
 * FIELDS:
 *     SYNCE_MODE_PHY_LN0 Stage1 clock divider for synce clock generation
 *     SYNCE_MODE_PHY_LN1 Stage1 clock divider for synce clock generation
 *     SYNCE_MODE_PHY_LN2 Stage1 clock divider for synce clock generation
 *     SYNCE_MODE_PHY_LN3 Stage1 clock divider for synce clock generation
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTLr (0x00109001 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MAIN0_SYNCE_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTLr_s {
	uint32_t v[1];
	uint32_t main0_synce_ctl[1];
	uint32_t _main0_synce_ctl;
} BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTLr_t;

#define BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTLr_CLR(r) (r).main0_synce_ctl[0] = 0
#define BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTLr_SET(r,d) (r).main0_synce_ctl[0] = d
#define BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTLr_GET(r) (r).main0_synce_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LN3f_GET(r) ((((r).main0_synce_ctl[0]) >> 6) & 0x3)
#define BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LN3f_SET(r,f) (r).main0_synce_ctl[0]=(((r).main0_synce_ctl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LN2f_GET(r) ((((r).main0_synce_ctl[0]) >> 4) & 0x3)
#define BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LN2f_SET(r,f) (r).main0_synce_ctl[0]=(((r).main0_synce_ctl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LN1f_GET(r) ((((r).main0_synce_ctl[0]) >> 2) & 0x3)
#define BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LN1f_SET(r,f) (r).main0_synce_ctl[0]=(((r).main0_synce_ctl[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LN0f_GET(r) (((r).main0_synce_ctl[0]) & 0x3)
#define BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LN0f_SET(r,f) (r).main0_synce_ctl[0]=(((r).main0_synce_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access MAIN0_SYNCE_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_MAIN0_SYNCE_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTLr,(_r._main0_synce_ctl))
#define BCMI_TSCE16_XGXS_WRITE_MAIN0_SYNCE_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTLr,(_r._main0_synce_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_MAIN0_SYNCE_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTLr,(_r._main0_synce_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0_SYNCE_CTLr BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTLr
#define MAIN0_SYNCE_CTLr_SIZE BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTLr_t MAIN0_SYNCE_CTLr_t;
#define MAIN0_SYNCE_CTLr_CLR BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTLr_CLR
#define MAIN0_SYNCE_CTLr_SET BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTLr_SET
#define MAIN0_SYNCE_CTLr_GET BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTLr_GET
#define MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LN3f_GET BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LN3f_GET
#define MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LN3f_SET BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LN3f_SET
#define MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LN2f_GET BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LN2f_GET
#define MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LN2f_SET BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LN2f_SET
#define MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LN1f_GET BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LN1f_GET
#define MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LN1f_SET BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LN1f_SET
#define MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LN0f_GET BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LN0f_GET
#define MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LN0f_SET BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LN0f_SET
#define READ_MAIN0_SYNCE_CTLr BCMI_TSCE16_XGXS_READ_MAIN0_SYNCE_CTLr
#define WRITE_MAIN0_SYNCE_CTLr BCMI_TSCE16_XGXS_WRITE_MAIN0_SYNCE_CTLr
#define MODIFY_MAIN0_SYNCE_CTLr BCMI_TSCE16_XGXS_MODIFY_MAIN0_SYNCE_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  MAIN0_SYNCE_CTL_STAGE0
 * BLOCKS:   MAIN0
 * REGADDR:  0x9002
 * DESC:     SyncE Stage 0 mode register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SYNCE_STAGE0_MODE_PHY_LN0 Stage 0 clock divider for synce clock generation
 *     SYNCE_STAGE0_MODE_PHY_LN1 Stage 0 clock divider for synce clock generation
 *     SYNCE_STAGE0_MODE_PHY_LN2 Stage 0 clock divider for synce clock generation
 *     SYNCE_STAGE0_MODE_PHY_LN3 Stage 0 clock divider for synce clock generation
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTL_STAGE0r (0x00109002 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SIZE 4

/*
 * This structure should be used to declare and program MAIN0_SYNCE_CTL_STAGE0.
 *
 */
typedef union BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTL_STAGE0r_s {
	uint32_t v[1];
	uint32_t main0_synce_ctl_stage0[1];
	uint32_t _main0_synce_ctl_stage0;
} BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTL_STAGE0r_t;

#define BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTL_STAGE0r_CLR(r) (r).main0_synce_ctl_stage0[0] = 0
#define BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SET(r,d) (r).main0_synce_ctl_stage0[0] = d
#define BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTL_STAGE0r_GET(r) (r).main0_synce_ctl_stage0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LN3f_GET(r) ((((r).main0_synce_ctl_stage0[0]) >> 6) & 0x3)
#define BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LN3f_SET(r,f) (r).main0_synce_ctl_stage0[0]=(((r).main0_synce_ctl_stage0[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LN2f_GET(r) ((((r).main0_synce_ctl_stage0[0]) >> 4) & 0x3)
#define BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LN2f_SET(r,f) (r).main0_synce_ctl_stage0[0]=(((r).main0_synce_ctl_stage0[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LN1f_GET(r) ((((r).main0_synce_ctl_stage0[0]) >> 2) & 0x3)
#define BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LN1f_SET(r,f) (r).main0_synce_ctl_stage0[0]=(((r).main0_synce_ctl_stage0[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LN0f_GET(r) (((r).main0_synce_ctl_stage0[0]) & 0x3)
#define BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LN0f_SET(r,f) (r).main0_synce_ctl_stage0[0]=(((r).main0_synce_ctl_stage0[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access MAIN0_SYNCE_CTL_STAGE0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_MAIN0_SYNCE_CTL_STAGE0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTL_STAGE0r,(_r._main0_synce_ctl_stage0))
#define BCMI_TSCE16_XGXS_WRITE_MAIN0_SYNCE_CTL_STAGE0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTL_STAGE0r,(_r._main0_synce_ctl_stage0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_MAIN0_SYNCE_CTL_STAGE0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTL_STAGE0r,(_r._main0_synce_ctl_stage0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0_SYNCE_CTL_STAGE0r BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTL_STAGE0r
#define MAIN0_SYNCE_CTL_STAGE0r_SIZE BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SIZE
typedef BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTL_STAGE0r_t MAIN0_SYNCE_CTL_STAGE0r_t;
#define MAIN0_SYNCE_CTL_STAGE0r_CLR BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTL_STAGE0r_CLR
#define MAIN0_SYNCE_CTL_STAGE0r_SET BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SET
#define MAIN0_SYNCE_CTL_STAGE0r_GET BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTL_STAGE0r_GET
#define MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LN3f_GET BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LN3f_GET
#define MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LN3f_SET BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LN3f_SET
#define MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LN2f_GET BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LN2f_GET
#define MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LN2f_SET BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LN2f_SET
#define MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LN1f_GET BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LN1f_GET
#define MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LN1f_SET BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LN1f_SET
#define MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LN0f_GET BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LN0f_GET
#define MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LN0f_SET BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LN0f_SET
#define READ_MAIN0_SYNCE_CTL_STAGE0r BCMI_TSCE16_XGXS_READ_MAIN0_SYNCE_CTL_STAGE0r
#define WRITE_MAIN0_SYNCE_CTL_STAGE0r BCMI_TSCE16_XGXS_WRITE_MAIN0_SYNCE_CTL_STAGE0r
#define MODIFY_MAIN0_SYNCE_CTL_STAGE0r BCMI_TSCE16_XGXS_MODIFY_MAIN0_SYNCE_CTL_STAGE0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_MAIN0_SYNCE_CTL_STAGE0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  MAIN0_LN_SWP
 * BLOCKS:   MAIN0
 * REGADDR:  0x9003
 * DESC:     Lane Swap Control Register
 * RESETVAL: 0xe4e4 (58596)
 * ACCESS:   R/W
 * FIELDS:
 *     LOG0_TO_PHY_TX_LNSWAP_SEL TX Lane0 logical to physical swap selectTX LOGICAL to PHYSICAL lane mapping controlIndicates for TX LOGICAL lane 0 which PHYSICAL lane to send data to
 *     LOG1_TO_PHY_TX_LNSWAP_SEL TX Lane1 logical to physical swap selectTX LOGICAL to PHYSICAL lane mapping controlIndicates for TX LOGICAL lane 1 which PHYSICAL lane to send data to
 *     LOG2_TO_PHY_TX_LNSWAP_SEL TX Lane2 logical to physical swap selectTX LOGICAL to PHYSICAL lane mapping controlIndicates for TX LOGICAL lane 2 which PHYSICAL lane to send data to
 *     LOG3_TO_PHY_TX_LNSWAP_SEL TX Lane3 logical to physical swap selectTX LOGICAL to PHYSICAL lane mapping controlIndicates for TX LOGICAL lane 3 which PHYSICAL lane to send data to
 *     LOG0_TO_PHY_RX_LNSWAP_SEL RX Lane0 logical to physical swap selectRX LOGICAL to PHYSICAL lane mapping controlIndicates for RX LOGICAL lane 0 which PHYSICAL lane to source data from
 *     LOG1_TO_PHY_RX_LNSWAP_SEL RX Lane1 logical to physical swap selectRX LOGICAL to PHYSICAL lane mapping controlIndicates for RX LOGICAL lane 1 which PHYSICAL lane to source data from
 *     LOG2_TO_PHY_RX_LNSWAP_SEL RX Lane2 logical to physical swap selectRX LOGICAL to PHYSICAL lane mapping controlIndicates for RX LOGICAL lane 2 which PHYSICAL lane to source data from
 *     LOG3_TO_PHY_RX_LNSWAP_SEL RX Lane3 logical to physical swap selectRX LOGICAL to PHYSICAL lane mapping controlIndicates for RX LOGICAL lane 3 which PHYSICAL lane to source data from
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_MAIN0_LN_SWPr (0x00109003 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_SIZE 4

/*
 * This structure should be used to declare and program MAIN0_LN_SWP.
 *
 */
typedef union BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_s {
	uint32_t v[1];
	uint32_t main0_ln_swp[1];
	uint32_t _main0_ln_swp;
} BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_t;

#define BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_CLR(r) (r).main0_ln_swp[0] = 0
#define BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_SET(r,d) (r).main0_ln_swp[0] = d
#define BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_GET(r) (r).main0_ln_swp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_LOG3_TO_PHY_RX_LNSWAP_SELf_GET(r) ((((r).main0_ln_swp[0]) >> 14) & 0x3)
#define BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_LOG3_TO_PHY_RX_LNSWAP_SELf_SET(r,f) (r).main0_ln_swp[0]=(((r).main0_ln_swp[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_LOG2_TO_PHY_RX_LNSWAP_SELf_GET(r) ((((r).main0_ln_swp[0]) >> 12) & 0x3)
#define BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_LOG2_TO_PHY_RX_LNSWAP_SELf_SET(r,f) (r).main0_ln_swp[0]=(((r).main0_ln_swp[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_LOG1_TO_PHY_RX_LNSWAP_SELf_GET(r) ((((r).main0_ln_swp[0]) >> 10) & 0x3)
#define BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_LOG1_TO_PHY_RX_LNSWAP_SELf_SET(r,f) (r).main0_ln_swp[0]=(((r).main0_ln_swp[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_LOG0_TO_PHY_RX_LNSWAP_SELf_GET(r) ((((r).main0_ln_swp[0]) >> 8) & 0x3)
#define BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_LOG0_TO_PHY_RX_LNSWAP_SELf_SET(r,f) (r).main0_ln_swp[0]=(((r).main0_ln_swp[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_LOG3_TO_PHY_TX_LNSWAP_SELf_GET(r) ((((r).main0_ln_swp[0]) >> 6) & 0x3)
#define BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_LOG3_TO_PHY_TX_LNSWAP_SELf_SET(r,f) (r).main0_ln_swp[0]=(((r).main0_ln_swp[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_LOG2_TO_PHY_TX_LNSWAP_SELf_GET(r) ((((r).main0_ln_swp[0]) >> 4) & 0x3)
#define BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_LOG2_TO_PHY_TX_LNSWAP_SELf_SET(r,f) (r).main0_ln_swp[0]=(((r).main0_ln_swp[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_LOG1_TO_PHY_TX_LNSWAP_SELf_GET(r) ((((r).main0_ln_swp[0]) >> 2) & 0x3)
#define BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_LOG1_TO_PHY_TX_LNSWAP_SELf_SET(r,f) (r).main0_ln_swp[0]=(((r).main0_ln_swp[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_LOG0_TO_PHY_TX_LNSWAP_SELf_GET(r) (((r).main0_ln_swp[0]) & 0x3)
#define BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_LOG0_TO_PHY_TX_LNSWAP_SELf_SET(r,f) (r).main0_ln_swp[0]=(((r).main0_ln_swp[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access MAIN0_LN_SWP.
 *
 */
#define BCMI_TSCE16_XGXS_READ_MAIN0_LN_SWPr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MAIN0_LN_SWPr,(_r._main0_ln_swp))
#define BCMI_TSCE16_XGXS_WRITE_MAIN0_LN_SWPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MAIN0_LN_SWPr,(_r._main0_ln_swp)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_MAIN0_LN_SWPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MAIN0_LN_SWPr,(_r._main0_ln_swp))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0_LN_SWPr BCMI_TSCE16_XGXS_MAIN0_LN_SWPr
#define MAIN0_LN_SWPr_SIZE BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_SIZE
typedef BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_t MAIN0_LN_SWPr_t;
#define MAIN0_LN_SWPr_CLR BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_CLR
#define MAIN0_LN_SWPr_SET BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_SET
#define MAIN0_LN_SWPr_GET BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_GET
#define MAIN0_LN_SWPr_LOG3_TO_PHY_RX_LNSWAP_SELf_GET BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_LOG3_TO_PHY_RX_LNSWAP_SELf_GET
#define MAIN0_LN_SWPr_LOG3_TO_PHY_RX_LNSWAP_SELf_SET BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_LOG3_TO_PHY_RX_LNSWAP_SELf_SET
#define MAIN0_LN_SWPr_LOG2_TO_PHY_RX_LNSWAP_SELf_GET BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_LOG2_TO_PHY_RX_LNSWAP_SELf_GET
#define MAIN0_LN_SWPr_LOG2_TO_PHY_RX_LNSWAP_SELf_SET BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_LOG2_TO_PHY_RX_LNSWAP_SELf_SET
#define MAIN0_LN_SWPr_LOG1_TO_PHY_RX_LNSWAP_SELf_GET BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_LOG1_TO_PHY_RX_LNSWAP_SELf_GET
#define MAIN0_LN_SWPr_LOG1_TO_PHY_RX_LNSWAP_SELf_SET BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_LOG1_TO_PHY_RX_LNSWAP_SELf_SET
#define MAIN0_LN_SWPr_LOG0_TO_PHY_RX_LNSWAP_SELf_GET BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_LOG0_TO_PHY_RX_LNSWAP_SELf_GET
#define MAIN0_LN_SWPr_LOG0_TO_PHY_RX_LNSWAP_SELf_SET BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_LOG0_TO_PHY_RX_LNSWAP_SELf_SET
#define MAIN0_LN_SWPr_LOG3_TO_PHY_TX_LNSWAP_SELf_GET BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_LOG3_TO_PHY_TX_LNSWAP_SELf_GET
#define MAIN0_LN_SWPr_LOG3_TO_PHY_TX_LNSWAP_SELf_SET BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_LOG3_TO_PHY_TX_LNSWAP_SELf_SET
#define MAIN0_LN_SWPr_LOG2_TO_PHY_TX_LNSWAP_SELf_GET BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_LOG2_TO_PHY_TX_LNSWAP_SELf_GET
#define MAIN0_LN_SWPr_LOG2_TO_PHY_TX_LNSWAP_SELf_SET BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_LOG2_TO_PHY_TX_LNSWAP_SELf_SET
#define MAIN0_LN_SWPr_LOG1_TO_PHY_TX_LNSWAP_SELf_GET BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_LOG1_TO_PHY_TX_LNSWAP_SELf_GET
#define MAIN0_LN_SWPr_LOG1_TO_PHY_TX_LNSWAP_SELf_SET BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_LOG1_TO_PHY_TX_LNSWAP_SELf_SET
#define MAIN0_LN_SWPr_LOG0_TO_PHY_TX_LNSWAP_SELf_GET BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_LOG0_TO_PHY_TX_LNSWAP_SELf_GET
#define MAIN0_LN_SWPr_LOG0_TO_PHY_TX_LNSWAP_SELf_SET BCMI_TSCE16_XGXS_MAIN0_LN_SWPr_LOG0_TO_PHY_TX_LNSWAP_SELf_SET
#define READ_MAIN0_LN_SWPr BCMI_TSCE16_XGXS_READ_MAIN0_LN_SWPr
#define WRITE_MAIN0_LN_SWPr BCMI_TSCE16_XGXS_WRITE_MAIN0_LN_SWPr
#define MODIFY_MAIN0_LN_SWPr BCMI_TSCE16_XGXS_MODIFY_MAIN0_LN_SWPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_MAIN0_LN_SWPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  MAIN0_DEVINPKG5
 * BLOCKS:   MAIN0
 * REGADDR:  0x9004
 * DESC:     Devices in Package5
 * RESETVAL: 0x83 (131)
 * ACCESS:   R/O
 * FIELDS:
 *     CLAUSE22         1 = Clause 22 registers present in package0 = Clause 22 registers not present in package
 *     PMA_PMD          1 = PMA/PMD present in package0 = PMA/PMD not present in package
 *     WIS              1 = WIS present in package0 = WIS not present in package
 *     PCS_XS           1 = PCS present in package0 = PCS not present in package
 *     PHY_XS           1 = PHY XS present in package0 = PHY XS not present in package
 *     DTE_XS           1 = DTE XS present in package0 = DTE XS not present in package
 *     TC               1 = TC present in package0 = TC not present in package
 *     AN               1 = Auto-Negotiation present in package0 = Auto-Negotiation not present in package
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r (0x00109004 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_SIZE 4

/*
 * This structure should be used to declare and program MAIN0_DEVINPKG5.
 *
 */
typedef union BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_s {
	uint32_t v[1];
	uint32_t main0_devinpkg5[1];
	uint32_t _main0_devinpkg5;
} BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_t;

#define BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_CLR(r) (r).main0_devinpkg5[0] = 0
#define BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_SET(r,d) (r).main0_devinpkg5[0] = d
#define BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_GET(r) (r).main0_devinpkg5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_ANf_GET(r) ((((r).main0_devinpkg5[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_ANf_SET(r,f) (r).main0_devinpkg5[0]=(((r).main0_devinpkg5[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_TCf_GET(r) ((((r).main0_devinpkg5[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_TCf_SET(r,f) (r).main0_devinpkg5[0]=(((r).main0_devinpkg5[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_DTE_XSf_GET(r) ((((r).main0_devinpkg5[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_DTE_XSf_SET(r,f) (r).main0_devinpkg5[0]=(((r).main0_devinpkg5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_PHY_XSf_GET(r) ((((r).main0_devinpkg5[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_PHY_XSf_SET(r,f) (r).main0_devinpkg5[0]=(((r).main0_devinpkg5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_PCS_XSf_GET(r) ((((r).main0_devinpkg5[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_PCS_XSf_SET(r,f) (r).main0_devinpkg5[0]=(((r).main0_devinpkg5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_WISf_GET(r) ((((r).main0_devinpkg5[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_WISf_SET(r,f) (r).main0_devinpkg5[0]=(((r).main0_devinpkg5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_PMA_PMDf_GET(r) ((((r).main0_devinpkg5[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_PMA_PMDf_SET(r,f) (r).main0_devinpkg5[0]=(((r).main0_devinpkg5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_CLAUSE22f_GET(r) (((r).main0_devinpkg5[0]) & 0x1)
#define BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_CLAUSE22f_SET(r,f) (r).main0_devinpkg5[0]=(((r).main0_devinpkg5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MAIN0_DEVINPKG5.
 *
 */
#define BCMI_TSCE16_XGXS_READ_MAIN0_DEVINPKG5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r,(_r._main0_devinpkg5))
#define BCMI_TSCE16_XGXS_WRITE_MAIN0_DEVINPKG5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r,(_r._main0_devinpkg5)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_MAIN0_DEVINPKG5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r,(_r._main0_devinpkg5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0_DEVINPKG5r BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r
#define MAIN0_DEVINPKG5r_SIZE BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_SIZE
typedef BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_t MAIN0_DEVINPKG5r_t;
#define MAIN0_DEVINPKG5r_CLR BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_CLR
#define MAIN0_DEVINPKG5r_SET BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_SET
#define MAIN0_DEVINPKG5r_GET BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_GET
#define MAIN0_DEVINPKG5r_ANf_GET BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_ANf_GET
#define MAIN0_DEVINPKG5r_ANf_SET BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_ANf_SET
#define MAIN0_DEVINPKG5r_TCf_GET BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_TCf_GET
#define MAIN0_DEVINPKG5r_TCf_SET BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_TCf_SET
#define MAIN0_DEVINPKG5r_DTE_XSf_GET BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_DTE_XSf_GET
#define MAIN0_DEVINPKG5r_DTE_XSf_SET BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_DTE_XSf_SET
#define MAIN0_DEVINPKG5r_PHY_XSf_GET BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_PHY_XSf_GET
#define MAIN0_DEVINPKG5r_PHY_XSf_SET BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_PHY_XSf_SET
#define MAIN0_DEVINPKG5r_PCS_XSf_GET BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_PCS_XSf_GET
#define MAIN0_DEVINPKG5r_PCS_XSf_SET BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_PCS_XSf_SET
#define MAIN0_DEVINPKG5r_WISf_GET BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_WISf_GET
#define MAIN0_DEVINPKG5r_WISf_SET BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_WISf_SET
#define MAIN0_DEVINPKG5r_PMA_PMDf_GET BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_PMA_PMDf_GET
#define MAIN0_DEVINPKG5r_PMA_PMDf_SET BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_PMA_PMDf_SET
#define MAIN0_DEVINPKG5r_CLAUSE22f_GET BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_CLAUSE22f_GET
#define MAIN0_DEVINPKG5r_CLAUSE22f_SET BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r_CLAUSE22f_SET
#define READ_MAIN0_DEVINPKG5r BCMI_TSCE16_XGXS_READ_MAIN0_DEVINPKG5r
#define WRITE_MAIN0_DEVINPKG5r BCMI_TSCE16_XGXS_WRITE_MAIN0_DEVINPKG5r
#define MODIFY_MAIN0_DEVINPKG5r BCMI_TSCE16_XGXS_MODIFY_MAIN0_DEVINPKG5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_MAIN0_DEVINPKG5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  MAIN0_MISC
 * BLOCKS:   MAIN0
 * REGADDR:  0x9005
 * DESC:     Miscellaneous Controls
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL82_MLD_PHYS_MAP THIS IS A TSC_12 ONLY CONTROLThis field only used when cl82_multi_pipe_mode in 100g mode.Physical Lanes used:   TSC0(0-3)   TSC1(4-7)   TSC2(8-11)i---------------------------------------------------------------------i2'b00 - 3,4,3 Mode     x,0,1,2,     3,4,5,6,   7,8,9,x2'b01 - 2,4,4 Mode     x,x,0,1,     2,3,4,5,   6,7,8,92'b10 - 4,4,2 Mode     0,1,2,3      4,5,6,7,   8,9,x,x2'b11 - unused.i
 *     CL82_MULTI_PIPE_MODE THIS IS A TSC_12 ONLY CONTROL2'b00 - disabled, operate in normal TSC_4 mode2'b01 - 100G mode.  Use 20 Virtual Lanes for 100G operation.2'b10 - 120G mode.  Use 24 Virtual Lanes for 120G operation.2'b11 - reserved/unused.
 *     CL49_LOW_LATENCY_EN Enables low latency mode on all lanes.  May only be used if all lanes are in cl49 mode.
 *     TX_PCS_BIT_REPL_EN Enables the transmit PCS bit replication for aggregate lane speeds working in OS2 or OS4 modes.This bit is a dont care for ports operating in OS modes other than OS2 0r OS4.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_MAIN0_MISCr (0x00109005 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_MAIN0_MISCr_SIZE 4

/*
 * This structure should be used to declare and program MAIN0_MISC.
 *
 */
typedef union BCMI_TSCE16_XGXS_MAIN0_MISCr_s {
	uint32_t v[1];
	uint32_t main0_misc[1];
	uint32_t _main0_misc;
} BCMI_TSCE16_XGXS_MAIN0_MISCr_t;

#define BCMI_TSCE16_XGXS_MAIN0_MISCr_CLR(r) (r).main0_misc[0] = 0
#define BCMI_TSCE16_XGXS_MAIN0_MISCr_SET(r,d) (r).main0_misc[0] = d
#define BCMI_TSCE16_XGXS_MAIN0_MISCr_GET(r) (r).main0_misc[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_MAIN0_MISCr_TX_PCS_BIT_REPL_ENf_GET(r) ((((r).main0_misc[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_MAIN0_MISCr_TX_PCS_BIT_REPL_ENf_SET(r,f) (r).main0_misc[0]=(((r).main0_misc[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_MAIN0_MISCr_CL49_LOW_LATENCY_ENf_GET(r) ((((r).main0_misc[0]) >> 11) & 0x1)
#define BCMI_TSCE16_XGXS_MAIN0_MISCr_CL49_LOW_LATENCY_ENf_SET(r,f) (r).main0_misc[0]=(((r).main0_misc[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCE16_XGXS_MAIN0_MISCr_CL82_MULTI_PIPE_MODEf_GET(r) ((((r).main0_misc[0]) >> 9) & 0x3)
#define BCMI_TSCE16_XGXS_MAIN0_MISCr_CL82_MULTI_PIPE_MODEf_SET(r,f) (r).main0_misc[0]=(((r).main0_misc[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9)) | (3 << (16 + 9))
#define BCMI_TSCE16_XGXS_MAIN0_MISCr_CL82_MLD_PHYS_MAPf_GET(r) ((((r).main0_misc[0]) >> 7) & 0x3)
#define BCMI_TSCE16_XGXS_MAIN0_MISCr_CL82_MLD_PHYS_MAPf_SET(r,f) (r).main0_misc[0]=(((r).main0_misc[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7)) | (3 << (16 + 7))

/*
 * These macros can be used to access MAIN0_MISC.
 *
 */
#define BCMI_TSCE16_XGXS_READ_MAIN0_MISCr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MAIN0_MISCr,(_r._main0_misc))
#define BCMI_TSCE16_XGXS_WRITE_MAIN0_MISCr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MAIN0_MISCr,(_r._main0_misc)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_MAIN0_MISCr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MAIN0_MISCr,(_r._main0_misc))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0_MISCr BCMI_TSCE16_XGXS_MAIN0_MISCr
#define MAIN0_MISCr_SIZE BCMI_TSCE16_XGXS_MAIN0_MISCr_SIZE
typedef BCMI_TSCE16_XGXS_MAIN0_MISCr_t MAIN0_MISCr_t;
#define MAIN0_MISCr_CLR BCMI_TSCE16_XGXS_MAIN0_MISCr_CLR
#define MAIN0_MISCr_SET BCMI_TSCE16_XGXS_MAIN0_MISCr_SET
#define MAIN0_MISCr_GET BCMI_TSCE16_XGXS_MAIN0_MISCr_GET
#define MAIN0_MISCr_TX_PCS_BIT_REPL_ENf_GET BCMI_TSCE16_XGXS_MAIN0_MISCr_TX_PCS_BIT_REPL_ENf_GET
#define MAIN0_MISCr_TX_PCS_BIT_REPL_ENf_SET BCMI_TSCE16_XGXS_MAIN0_MISCr_TX_PCS_BIT_REPL_ENf_SET
#define MAIN0_MISCr_CL49_LOW_LATENCY_ENf_GET BCMI_TSCE16_XGXS_MAIN0_MISCr_CL49_LOW_LATENCY_ENf_GET
#define MAIN0_MISCr_CL49_LOW_LATENCY_ENf_SET BCMI_TSCE16_XGXS_MAIN0_MISCr_CL49_LOW_LATENCY_ENf_SET
#define MAIN0_MISCr_CL82_MULTI_PIPE_MODEf_GET BCMI_TSCE16_XGXS_MAIN0_MISCr_CL82_MULTI_PIPE_MODEf_GET
#define MAIN0_MISCr_CL82_MULTI_PIPE_MODEf_SET BCMI_TSCE16_XGXS_MAIN0_MISCr_CL82_MULTI_PIPE_MODEf_SET
#define MAIN0_MISCr_CL82_MLD_PHYS_MAPf_GET BCMI_TSCE16_XGXS_MAIN0_MISCr_CL82_MLD_PHYS_MAPf_GET
#define MAIN0_MISCr_CL82_MLD_PHYS_MAPf_SET BCMI_TSCE16_XGXS_MAIN0_MISCr_CL82_MLD_PHYS_MAPf_SET
#define READ_MAIN0_MISCr BCMI_TSCE16_XGXS_READ_MAIN0_MISCr
#define WRITE_MAIN0_MISCr BCMI_TSCE16_XGXS_WRITE_MAIN0_MISCr
#define MODIFY_MAIN0_MISCr BCMI_TSCE16_XGXS_MODIFY_MAIN0_MISCr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_MAIN0_MISCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  MAIN0_TICK_CTL1
 * BLOCKS:   MAIN0
 * REGADDR:  0x9007
 * DESC:     TICK GENERATION CONTROL REGISTER 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TICK_NUMERATOR_UPPER Bits [18:4] of the tick numerator.  Used when tick_override is true
 *     TICK_OVERRIDE    Enables override of tick counts instead of using refclk_sel
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_MAIN0_TICK_CTL1r (0x00109007 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_MAIN0_TICK_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program MAIN0_TICK_CTL1.
 *
 */
typedef union BCMI_TSCE16_XGXS_MAIN0_TICK_CTL1r_s {
	uint32_t v[1];
	uint32_t main0_tick_ctl1[1];
	uint32_t _main0_tick_ctl1;
} BCMI_TSCE16_XGXS_MAIN0_TICK_CTL1r_t;

#define BCMI_TSCE16_XGXS_MAIN0_TICK_CTL1r_CLR(r) (r).main0_tick_ctl1[0] = 0
#define BCMI_TSCE16_XGXS_MAIN0_TICK_CTL1r_SET(r,d) (r).main0_tick_ctl1[0] = d
#define BCMI_TSCE16_XGXS_MAIN0_TICK_CTL1r_GET(r) (r).main0_tick_ctl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_MAIN0_TICK_CTL1r_TICK_OVERRIDEf_GET(r) ((((r).main0_tick_ctl1[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_MAIN0_TICK_CTL1r_TICK_OVERRIDEf_SET(r,f) (r).main0_tick_ctl1[0]=(((r).main0_tick_ctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_MAIN0_TICK_CTL1r_TICK_NUMERATOR_UPPERf_GET(r) (((r).main0_tick_ctl1[0]) & 0x7fff)
#define BCMI_TSCE16_XGXS_MAIN0_TICK_CTL1r_TICK_NUMERATOR_UPPERf_SET(r,f) (r).main0_tick_ctl1[0]=(((r).main0_tick_ctl1[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff)) | (0x7fff << 16)

/*
 * These macros can be used to access MAIN0_TICK_CTL1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_MAIN0_TICK_CTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MAIN0_TICK_CTL1r,(_r._main0_tick_ctl1))
#define BCMI_TSCE16_XGXS_WRITE_MAIN0_TICK_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MAIN0_TICK_CTL1r,(_r._main0_tick_ctl1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_MAIN0_TICK_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MAIN0_TICK_CTL1r,(_r._main0_tick_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0_TICK_CTL1r BCMI_TSCE16_XGXS_MAIN0_TICK_CTL1r
#define MAIN0_TICK_CTL1r_SIZE BCMI_TSCE16_XGXS_MAIN0_TICK_CTL1r_SIZE
typedef BCMI_TSCE16_XGXS_MAIN0_TICK_CTL1r_t MAIN0_TICK_CTL1r_t;
#define MAIN0_TICK_CTL1r_CLR BCMI_TSCE16_XGXS_MAIN0_TICK_CTL1r_CLR
#define MAIN0_TICK_CTL1r_SET BCMI_TSCE16_XGXS_MAIN0_TICK_CTL1r_SET
#define MAIN0_TICK_CTL1r_GET BCMI_TSCE16_XGXS_MAIN0_TICK_CTL1r_GET
#define MAIN0_TICK_CTL1r_TICK_OVERRIDEf_GET BCMI_TSCE16_XGXS_MAIN0_TICK_CTL1r_TICK_OVERRIDEf_GET
#define MAIN0_TICK_CTL1r_TICK_OVERRIDEf_SET BCMI_TSCE16_XGXS_MAIN0_TICK_CTL1r_TICK_OVERRIDEf_SET
#define MAIN0_TICK_CTL1r_TICK_NUMERATOR_UPPERf_GET BCMI_TSCE16_XGXS_MAIN0_TICK_CTL1r_TICK_NUMERATOR_UPPERf_GET
#define MAIN0_TICK_CTL1r_TICK_NUMERATOR_UPPERf_SET BCMI_TSCE16_XGXS_MAIN0_TICK_CTL1r_TICK_NUMERATOR_UPPERf_SET
#define READ_MAIN0_TICK_CTL1r BCMI_TSCE16_XGXS_READ_MAIN0_TICK_CTL1r
#define WRITE_MAIN0_TICK_CTL1r BCMI_TSCE16_XGXS_WRITE_MAIN0_TICK_CTL1r
#define MODIFY_MAIN0_TICK_CTL1r BCMI_TSCE16_XGXS_MODIFY_MAIN0_TICK_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_MAIN0_TICK_CTL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  MAIN0_TICK_CTL0
 * BLOCKS:   MAIN0
 * REGADDR:  0x9008
 * DESC:     TICK GENERATION CONTROL REGISTER 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TICK_DENOMINATOR Tick denominator.  Used when tick_override is true
 *     TICK_NUMERATOR_LOWER Bits [3:0] of the tick numerator.  Used when tick_override is true
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_MAIN0_TICK_CTL0r (0x00109008 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_MAIN0_TICK_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program MAIN0_TICK_CTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_MAIN0_TICK_CTL0r_s {
	uint32_t v[1];
	uint32_t main0_tick_ctl0[1];
	uint32_t _main0_tick_ctl0;
} BCMI_TSCE16_XGXS_MAIN0_TICK_CTL0r_t;

#define BCMI_TSCE16_XGXS_MAIN0_TICK_CTL0r_CLR(r) (r).main0_tick_ctl0[0] = 0
#define BCMI_TSCE16_XGXS_MAIN0_TICK_CTL0r_SET(r,d) (r).main0_tick_ctl0[0] = d
#define BCMI_TSCE16_XGXS_MAIN0_TICK_CTL0r_GET(r) (r).main0_tick_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_MAIN0_TICK_CTL0r_TICK_NUMERATOR_LOWERf_GET(r) ((((r).main0_tick_ctl0[0]) >> 12) & 0xf)
#define BCMI_TSCE16_XGXS_MAIN0_TICK_CTL0r_TICK_NUMERATOR_LOWERf_SET(r,f) (r).main0_tick_ctl0[0]=(((r).main0_tick_ctl0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCE16_XGXS_MAIN0_TICK_CTL0r_TICK_DENOMINATORf_GET(r) ((((r).main0_tick_ctl0[0]) >> 2) & 0x3ff)
#define BCMI_TSCE16_XGXS_MAIN0_TICK_CTL0r_TICK_DENOMINATORf_SET(r,f) (r).main0_tick_ctl0[0]=(((r).main0_tick_ctl0[0] & ~((uint32_t)0x3ff << 2)) | ((((uint32_t)f) & 0x3ff) << 2)) | (1023 << (16 + 2))

/*
 * These macros can be used to access MAIN0_TICK_CTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_MAIN0_TICK_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MAIN0_TICK_CTL0r,(_r._main0_tick_ctl0))
#define BCMI_TSCE16_XGXS_WRITE_MAIN0_TICK_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MAIN0_TICK_CTL0r,(_r._main0_tick_ctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_MAIN0_TICK_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MAIN0_TICK_CTL0r,(_r._main0_tick_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0_TICK_CTL0r BCMI_TSCE16_XGXS_MAIN0_TICK_CTL0r
#define MAIN0_TICK_CTL0r_SIZE BCMI_TSCE16_XGXS_MAIN0_TICK_CTL0r_SIZE
typedef BCMI_TSCE16_XGXS_MAIN0_TICK_CTL0r_t MAIN0_TICK_CTL0r_t;
#define MAIN0_TICK_CTL0r_CLR BCMI_TSCE16_XGXS_MAIN0_TICK_CTL0r_CLR
#define MAIN0_TICK_CTL0r_SET BCMI_TSCE16_XGXS_MAIN0_TICK_CTL0r_SET
#define MAIN0_TICK_CTL0r_GET BCMI_TSCE16_XGXS_MAIN0_TICK_CTL0r_GET
#define MAIN0_TICK_CTL0r_TICK_NUMERATOR_LOWERf_GET BCMI_TSCE16_XGXS_MAIN0_TICK_CTL0r_TICK_NUMERATOR_LOWERf_GET
#define MAIN0_TICK_CTL0r_TICK_NUMERATOR_LOWERf_SET BCMI_TSCE16_XGXS_MAIN0_TICK_CTL0r_TICK_NUMERATOR_LOWERf_SET
#define MAIN0_TICK_CTL0r_TICK_DENOMINATORf_GET BCMI_TSCE16_XGXS_MAIN0_TICK_CTL0r_TICK_DENOMINATORf_GET
#define MAIN0_TICK_CTL0r_TICK_DENOMINATORf_SET BCMI_TSCE16_XGXS_MAIN0_TICK_CTL0r_TICK_DENOMINATORf_SET
#define READ_MAIN0_TICK_CTL0r BCMI_TSCE16_XGXS_READ_MAIN0_TICK_CTL0r
#define WRITE_MAIN0_TICK_CTL0r BCMI_TSCE16_XGXS_WRITE_MAIN0_TICK_CTL0r
#define MODIFY_MAIN0_TICK_CTL0r BCMI_TSCE16_XGXS_MODIFY_MAIN0_TICK_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_MAIN0_TICK_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  MAIN0_LPBK_CTL
 * BLOCKS:   MAIN0
 * REGADDR:  0x9009
 * DESC:     LOOPBACK CONTROL REGISTER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LOCAL_PCS_LOOPBACK_ENABLE Per LOGICAL LANE control to enable PCS based local (TX to RX) loopback
 *     REMOTE_PMD_LOOPBACK_ENABLE Per LOGICAL LANE control to enable PMD (raw data) based remote (RX to TX) loopback
 *     REMOTE_PCS_LOOPBACK_ENABLE Per LOGICAL LANE control to enable PCS based remote (RX to TX) loopback
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_MAIN0_LPBK_CTLr (0x00109009 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_MAIN0_LPBK_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MAIN0_LPBK_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_MAIN0_LPBK_CTLr_s {
	uint32_t v[1];
	uint32_t main0_lpbk_ctl[1];
	uint32_t _main0_lpbk_ctl;
} BCMI_TSCE16_XGXS_MAIN0_LPBK_CTLr_t;

#define BCMI_TSCE16_XGXS_MAIN0_LPBK_CTLr_CLR(r) (r).main0_lpbk_ctl[0] = 0
#define BCMI_TSCE16_XGXS_MAIN0_LPBK_CTLr_SET(r,d) (r).main0_lpbk_ctl[0] = d
#define BCMI_TSCE16_XGXS_MAIN0_LPBK_CTLr_GET(r) (r).main0_lpbk_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_MAIN0_LPBK_CTLr_REMOTE_PCS_LOOPBACK_ENABLEf_GET(r) ((((r).main0_lpbk_ctl[0]) >> 12) & 0xf)
#define BCMI_TSCE16_XGXS_MAIN0_LPBK_CTLr_REMOTE_PCS_LOOPBACK_ENABLEf_SET(r,f) (r).main0_lpbk_ctl[0]=(((r).main0_lpbk_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCE16_XGXS_MAIN0_LPBK_CTLr_REMOTE_PMD_LOOPBACK_ENABLEf_GET(r) ((((r).main0_lpbk_ctl[0]) >> 8) & 0xf)
#define BCMI_TSCE16_XGXS_MAIN0_LPBK_CTLr_REMOTE_PMD_LOOPBACK_ENABLEf_SET(r,f) (r).main0_lpbk_ctl[0]=(((r).main0_lpbk_ctl[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_TSCE16_XGXS_MAIN0_LPBK_CTLr_LOCAL_PCS_LOOPBACK_ENABLEf_GET(r) ((((r).main0_lpbk_ctl[0]) >> 4) & 0xf)
#define BCMI_TSCE16_XGXS_MAIN0_LPBK_CTLr_LOCAL_PCS_LOOPBACK_ENABLEf_SET(r,f) (r).main0_lpbk_ctl[0]=(((r).main0_lpbk_ctl[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))

/*
 * These macros can be used to access MAIN0_LPBK_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_MAIN0_LPBK_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MAIN0_LPBK_CTLr,(_r._main0_lpbk_ctl))
#define BCMI_TSCE16_XGXS_WRITE_MAIN0_LPBK_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MAIN0_LPBK_CTLr,(_r._main0_lpbk_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_MAIN0_LPBK_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MAIN0_LPBK_CTLr,(_r._main0_lpbk_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0_LPBK_CTLr BCMI_TSCE16_XGXS_MAIN0_LPBK_CTLr
#define MAIN0_LPBK_CTLr_SIZE BCMI_TSCE16_XGXS_MAIN0_LPBK_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_MAIN0_LPBK_CTLr_t MAIN0_LPBK_CTLr_t;
#define MAIN0_LPBK_CTLr_CLR BCMI_TSCE16_XGXS_MAIN0_LPBK_CTLr_CLR
#define MAIN0_LPBK_CTLr_SET BCMI_TSCE16_XGXS_MAIN0_LPBK_CTLr_SET
#define MAIN0_LPBK_CTLr_GET BCMI_TSCE16_XGXS_MAIN0_LPBK_CTLr_GET
#define MAIN0_LPBK_CTLr_REMOTE_PCS_LOOPBACK_ENABLEf_GET BCMI_TSCE16_XGXS_MAIN0_LPBK_CTLr_REMOTE_PCS_LOOPBACK_ENABLEf_GET
#define MAIN0_LPBK_CTLr_REMOTE_PCS_LOOPBACK_ENABLEf_SET BCMI_TSCE16_XGXS_MAIN0_LPBK_CTLr_REMOTE_PCS_LOOPBACK_ENABLEf_SET
#define MAIN0_LPBK_CTLr_REMOTE_PMD_LOOPBACK_ENABLEf_GET BCMI_TSCE16_XGXS_MAIN0_LPBK_CTLr_REMOTE_PMD_LOOPBACK_ENABLEf_GET
#define MAIN0_LPBK_CTLr_REMOTE_PMD_LOOPBACK_ENABLEf_SET BCMI_TSCE16_XGXS_MAIN0_LPBK_CTLr_REMOTE_PMD_LOOPBACK_ENABLEf_SET
#define MAIN0_LPBK_CTLr_LOCAL_PCS_LOOPBACK_ENABLEf_GET BCMI_TSCE16_XGXS_MAIN0_LPBK_CTLr_LOCAL_PCS_LOOPBACK_ENABLEf_GET
#define MAIN0_LPBK_CTLr_LOCAL_PCS_LOOPBACK_ENABLEf_SET BCMI_TSCE16_XGXS_MAIN0_LPBK_CTLr_LOCAL_PCS_LOOPBACK_ENABLEf_SET
#define READ_MAIN0_LPBK_CTLr BCMI_TSCE16_XGXS_READ_MAIN0_LPBK_CTLr
#define WRITE_MAIN0_LPBK_CTLr BCMI_TSCE16_XGXS_WRITE_MAIN0_LPBK_CTLr
#define MODIFY_MAIN0_LPBK_CTLr BCMI_TSCE16_XGXS_MODIFY_MAIN0_LPBK_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_MAIN0_LPBK_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  MAIN0_MDIO_BCST
 * BLOCKS:   MAIN0
 * REGADDR:  0x900a
 * DESC:     PRTAD Broadcast Values
 * RESETVAL: 0xf800 (63488)
 * ACCESS:   R/W
 * FIELDS:
 *     MULTIPRTS_EN     per port Broadcast enable
 *     PRTAD_BCST       PORT VALUE FOR BROADCASTING TO MULTIPLE PORTS
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_MAIN0_MDIO_BCSTr (0x0010900a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_MAIN0_MDIO_BCSTr_SIZE 4

/*
 * This structure should be used to declare and program MAIN0_MDIO_BCST.
 *
 */
typedef union BCMI_TSCE16_XGXS_MAIN0_MDIO_BCSTr_s {
	uint32_t v[1];
	uint32_t main0_mdio_bcst[1];
	uint32_t _main0_mdio_bcst;
} BCMI_TSCE16_XGXS_MAIN0_MDIO_BCSTr_t;

#define BCMI_TSCE16_XGXS_MAIN0_MDIO_BCSTr_CLR(r) (r).main0_mdio_bcst[0] = 0
#define BCMI_TSCE16_XGXS_MAIN0_MDIO_BCSTr_SET(r,d) (r).main0_mdio_bcst[0] = d
#define BCMI_TSCE16_XGXS_MAIN0_MDIO_BCSTr_GET(r) (r).main0_mdio_bcst[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_MAIN0_MDIO_BCSTr_PRTAD_BCSTf_GET(r) ((((r).main0_mdio_bcst[0]) >> 11) & 0x1f)
#define BCMI_TSCE16_XGXS_MAIN0_MDIO_BCSTr_PRTAD_BCSTf_SET(r,f) (r).main0_mdio_bcst[0]=(((r).main0_mdio_bcst[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_TSCE16_XGXS_MAIN0_MDIO_BCSTr_MULTIPRTS_ENf_GET(r) ((((r).main0_mdio_bcst[0]) >> 7) & 0xf)
#define BCMI_TSCE16_XGXS_MAIN0_MDIO_BCSTr_MULTIPRTS_ENf_SET(r,f) (r).main0_mdio_bcst[0]=(((r).main0_mdio_bcst[0] & ~((uint32_t)0xf << 7)) | ((((uint32_t)f) & 0xf) << 7)) | (15 << (16 + 7))

/*
 * These macros can be used to access MAIN0_MDIO_BCST.
 *
 */
#define BCMI_TSCE16_XGXS_READ_MAIN0_MDIO_BCSTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MAIN0_MDIO_BCSTr,(_r._main0_mdio_bcst))
#define BCMI_TSCE16_XGXS_WRITE_MAIN0_MDIO_BCSTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MAIN0_MDIO_BCSTr,(_r._main0_mdio_bcst)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_MAIN0_MDIO_BCSTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MAIN0_MDIO_BCSTr,(_r._main0_mdio_bcst))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0_MDIO_BCSTr BCMI_TSCE16_XGXS_MAIN0_MDIO_BCSTr
#define MAIN0_MDIO_BCSTr_SIZE BCMI_TSCE16_XGXS_MAIN0_MDIO_BCSTr_SIZE
typedef BCMI_TSCE16_XGXS_MAIN0_MDIO_BCSTr_t MAIN0_MDIO_BCSTr_t;
#define MAIN0_MDIO_BCSTr_CLR BCMI_TSCE16_XGXS_MAIN0_MDIO_BCSTr_CLR
#define MAIN0_MDIO_BCSTr_SET BCMI_TSCE16_XGXS_MAIN0_MDIO_BCSTr_SET
#define MAIN0_MDIO_BCSTr_GET BCMI_TSCE16_XGXS_MAIN0_MDIO_BCSTr_GET
#define MAIN0_MDIO_BCSTr_PRTAD_BCSTf_GET BCMI_TSCE16_XGXS_MAIN0_MDIO_BCSTr_PRTAD_BCSTf_GET
#define MAIN0_MDIO_BCSTr_PRTAD_BCSTf_SET BCMI_TSCE16_XGXS_MAIN0_MDIO_BCSTr_PRTAD_BCSTf_SET
#define MAIN0_MDIO_BCSTr_MULTIPRTS_ENf_GET BCMI_TSCE16_XGXS_MAIN0_MDIO_BCSTr_MULTIPRTS_ENf_GET
#define MAIN0_MDIO_BCSTr_MULTIPRTS_ENf_SET BCMI_TSCE16_XGXS_MAIN0_MDIO_BCSTr_MULTIPRTS_ENf_SET
#define READ_MAIN0_MDIO_BCSTr BCMI_TSCE16_XGXS_READ_MAIN0_MDIO_BCSTr
#define WRITE_MAIN0_MDIO_BCSTr BCMI_TSCE16_XGXS_WRITE_MAIN0_MDIO_BCSTr
#define MODIFY_MAIN0_MDIO_BCSTr BCMI_TSCE16_XGXS_MODIFY_MAIN0_MDIO_BCSTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_MAIN0_MDIO_BCSTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  MAIN0_SERDESID
 * BLOCKS:   MAIN0
 * REGADDR:  0x900e
 * DESC:     Serdes ID Register
 * RESETVAL: 0x2d2 (722)
 * ACCESS:   R/O
 * FIELDS:
 *     MODEL_NUMBER     Same as phyID model number00 = SERDES_CL73 (ComboCore, 65nm)01 = XGXS_16G02 = Hypercore03 = Hyperlite04 = PCIE_G2_PIPE05 = 1.25GBd Serdes06 = SATA207 = QSGMII08 = XGXS10G09 = WarpCore0A = XFICore0B = RXFI, Reduced XFI0C = WarpLite0D = PentaCore0E = ESM0F = Quad_SGMII10 = WarpCore 311 = TSC12 = TSCE413 = TSCE121D = XGXS_CL73, 90nm1E = SERDES_CL73, 90nm20 = WarpCore321 = WarpCore4 TSC22 = RXAUI
 *     TECH_PROC        0 = 90nm1 = 65nm2 = 40nm3 = 28nm4 = 16nm5-7 = reserved
 *     BONDING          0 = wire bond1 = flip chip2-3 = reserved
 *     REV_NUMBER       0 = rev 01 = rev 1...7 = rev 7
 *     REV_LETTER       0 = rev A1 = rev B2 = rev C3 = rev D
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_MAIN0_SERDESIDr (0x0010900e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_MAIN0_SERDESIDr_SIZE 4

/*
 * This structure should be used to declare and program MAIN0_SERDESID.
 *
 */
typedef union BCMI_TSCE16_XGXS_MAIN0_SERDESIDr_s {
	uint32_t v[1];
	uint32_t main0_serdesid[1];
	uint32_t _main0_serdesid;
} BCMI_TSCE16_XGXS_MAIN0_SERDESIDr_t;

#define BCMI_TSCE16_XGXS_MAIN0_SERDESIDr_CLR(r) (r).main0_serdesid[0] = 0
#define BCMI_TSCE16_XGXS_MAIN0_SERDESIDr_SET(r,d) (r).main0_serdesid[0] = d
#define BCMI_TSCE16_XGXS_MAIN0_SERDESIDr_GET(r) (r).main0_serdesid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_MAIN0_SERDESIDr_REV_LETTERf_GET(r) ((((r).main0_serdesid[0]) >> 14) & 0x3)
#define BCMI_TSCE16_XGXS_MAIN0_SERDESIDr_REV_LETTERf_SET(r,f) (r).main0_serdesid[0]=(((r).main0_serdesid[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCE16_XGXS_MAIN0_SERDESIDr_REV_NUMBERf_GET(r) ((((r).main0_serdesid[0]) >> 11) & 0x7)
#define BCMI_TSCE16_XGXS_MAIN0_SERDESIDr_REV_NUMBERf_SET(r,f) (r).main0_serdesid[0]=(((r).main0_serdesid[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_TSCE16_XGXS_MAIN0_SERDESIDr_BONDINGf_GET(r) ((((r).main0_serdesid[0]) >> 9) & 0x3)
#define BCMI_TSCE16_XGXS_MAIN0_SERDESIDr_BONDINGf_SET(r,f) (r).main0_serdesid[0]=(((r).main0_serdesid[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9)) | (3 << (16 + 9))
#define BCMI_TSCE16_XGXS_MAIN0_SERDESIDr_TECH_PROCf_GET(r) ((((r).main0_serdesid[0]) >> 6) & 0x7)
#define BCMI_TSCE16_XGXS_MAIN0_SERDESIDr_TECH_PROCf_SET(r,f) (r).main0_serdesid[0]=(((r).main0_serdesid[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_TSCE16_XGXS_MAIN0_SERDESIDr_MODEL_NUMBERf_GET(r) (((r).main0_serdesid[0]) & 0x3f)
#define BCMI_TSCE16_XGXS_MAIN0_SERDESIDr_MODEL_NUMBERf_SET(r,f) (r).main0_serdesid[0]=(((r).main0_serdesid[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access MAIN0_SERDESID.
 *
 */
#define BCMI_TSCE16_XGXS_READ_MAIN0_SERDESIDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MAIN0_SERDESIDr,(_r._main0_serdesid))
#define BCMI_TSCE16_XGXS_WRITE_MAIN0_SERDESIDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MAIN0_SERDESIDr,(_r._main0_serdesid)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_MAIN0_SERDESIDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MAIN0_SERDESIDr,(_r._main0_serdesid))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0_SERDESIDr BCMI_TSCE16_XGXS_MAIN0_SERDESIDr
#define MAIN0_SERDESIDr_SIZE BCMI_TSCE16_XGXS_MAIN0_SERDESIDr_SIZE
typedef BCMI_TSCE16_XGXS_MAIN0_SERDESIDr_t MAIN0_SERDESIDr_t;
#define MAIN0_SERDESIDr_CLR BCMI_TSCE16_XGXS_MAIN0_SERDESIDr_CLR
#define MAIN0_SERDESIDr_SET BCMI_TSCE16_XGXS_MAIN0_SERDESIDr_SET
#define MAIN0_SERDESIDr_GET BCMI_TSCE16_XGXS_MAIN0_SERDESIDr_GET
#define MAIN0_SERDESIDr_REV_LETTERf_GET BCMI_TSCE16_XGXS_MAIN0_SERDESIDr_REV_LETTERf_GET
#define MAIN0_SERDESIDr_REV_LETTERf_SET BCMI_TSCE16_XGXS_MAIN0_SERDESIDr_REV_LETTERf_SET
#define MAIN0_SERDESIDr_REV_NUMBERf_GET BCMI_TSCE16_XGXS_MAIN0_SERDESIDr_REV_NUMBERf_GET
#define MAIN0_SERDESIDr_REV_NUMBERf_SET BCMI_TSCE16_XGXS_MAIN0_SERDESIDr_REV_NUMBERf_SET
#define MAIN0_SERDESIDr_BONDINGf_GET BCMI_TSCE16_XGXS_MAIN0_SERDESIDr_BONDINGf_GET
#define MAIN0_SERDESIDr_BONDINGf_SET BCMI_TSCE16_XGXS_MAIN0_SERDESIDr_BONDINGf_SET
#define MAIN0_SERDESIDr_TECH_PROCf_GET BCMI_TSCE16_XGXS_MAIN0_SERDESIDr_TECH_PROCf_GET
#define MAIN0_SERDESIDr_TECH_PROCf_SET BCMI_TSCE16_XGXS_MAIN0_SERDESIDr_TECH_PROCf_SET
#define MAIN0_SERDESIDr_MODEL_NUMBERf_GET BCMI_TSCE16_XGXS_MAIN0_SERDESIDr_MODEL_NUMBERf_GET
#define MAIN0_SERDESIDr_MODEL_NUMBERf_SET BCMI_TSCE16_XGXS_MAIN0_SERDESIDr_MODEL_NUMBERf_SET
#define READ_MAIN0_SERDESIDr BCMI_TSCE16_XGXS_READ_MAIN0_SERDESIDr
#define WRITE_MAIN0_SERDESIDr BCMI_TSCE16_XGXS_WRITE_MAIN0_SERDESIDr
#define MODIFY_MAIN0_SERDESIDr BCMI_TSCE16_XGXS_MODIFY_MAIN0_SERDESIDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_MAIN0_SERDESIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PMD_X1_CTL
 * BLOCKS:   PMD_X1
 * REGADDR:  0x9010
 * DESC:     Global PMD reset controls
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CORE_DP_H_RSTB   PMD Core data path reset override valueOnly used for Speed Control bypass operationby default is zero too keep PMD in reset till enabled
 *     POR_H_RSTB       PMD Core power on resetby default is zero too keep PMD in reset till enabled
 *     PRAM_ABILITY     enable direct pram interface writes
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PMD_X1_CTLr (0x00109010 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PMD_X1_CTLr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X1_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_PMD_X1_CTLr_s {
	uint32_t v[1];
	uint32_t pmd_x1_ctl[1];
	uint32_t _pmd_x1_ctl;
} BCMI_TSCE16_XGXS_PMD_X1_CTLr_t;

#define BCMI_TSCE16_XGXS_PMD_X1_CTLr_CLR(r) (r).pmd_x1_ctl[0] = 0
#define BCMI_TSCE16_XGXS_PMD_X1_CTLr_SET(r,d) (r).pmd_x1_ctl[0] = d
#define BCMI_TSCE16_XGXS_PMD_X1_CTLr_GET(r) (r).pmd_x1_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PMD_X1_CTLr_PRAM_ABILITYf_GET(r) ((((r).pmd_x1_ctl[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X1_CTLr_PRAM_ABILITYf_SET(r,f) (r).pmd_x1_ctl[0]=(((r).pmd_x1_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_PMD_X1_CTLr_POR_H_RSTBf_GET(r) ((((r).pmd_x1_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X1_CTLr_POR_H_RSTBf_SET(r,f) (r).pmd_x1_ctl[0]=(((r).pmd_x1_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_PMD_X1_CTLr_CORE_DP_H_RSTBf_GET(r) (((r).pmd_x1_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X1_CTLr_CORE_DP_H_RSTBf_SET(r,f) (r).pmd_x1_ctl[0]=(((r).pmd_x1_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PMD_X1_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PMD_X1_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PMD_X1_CTLr,(_r._pmd_x1_ctl))
#define BCMI_TSCE16_XGXS_WRITE_PMD_X1_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X1_CTLr,(_r._pmd_x1_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PMD_X1_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X1_CTLr,(_r._pmd_x1_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X1_CTLr BCMI_TSCE16_XGXS_PMD_X1_CTLr
#define PMD_X1_CTLr_SIZE BCMI_TSCE16_XGXS_PMD_X1_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_PMD_X1_CTLr_t PMD_X1_CTLr_t;
#define PMD_X1_CTLr_CLR BCMI_TSCE16_XGXS_PMD_X1_CTLr_CLR
#define PMD_X1_CTLr_SET BCMI_TSCE16_XGXS_PMD_X1_CTLr_SET
#define PMD_X1_CTLr_GET BCMI_TSCE16_XGXS_PMD_X1_CTLr_GET
#define PMD_X1_CTLr_PRAM_ABILITYf_GET BCMI_TSCE16_XGXS_PMD_X1_CTLr_PRAM_ABILITYf_GET
#define PMD_X1_CTLr_PRAM_ABILITYf_SET BCMI_TSCE16_XGXS_PMD_X1_CTLr_PRAM_ABILITYf_SET
#define PMD_X1_CTLr_POR_H_RSTBf_GET BCMI_TSCE16_XGXS_PMD_X1_CTLr_POR_H_RSTBf_GET
#define PMD_X1_CTLr_POR_H_RSTBf_SET BCMI_TSCE16_XGXS_PMD_X1_CTLr_POR_H_RSTBf_SET
#define PMD_X1_CTLr_CORE_DP_H_RSTBf_GET BCMI_TSCE16_XGXS_PMD_X1_CTLr_CORE_DP_H_RSTBf_GET
#define PMD_X1_CTLr_CORE_DP_H_RSTBf_SET BCMI_TSCE16_XGXS_PMD_X1_CTLr_CORE_DP_H_RSTBf_SET
#define READ_PMD_X1_CTLr BCMI_TSCE16_XGXS_READ_PMD_X1_CTLr
#define WRITE_PMD_X1_CTLr BCMI_TSCE16_XGXS_WRITE_PMD_X1_CTLr
#define MODIFY_PMD_X1_CTLr BCMI_TSCE16_XGXS_MODIFY_PMD_X1_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PMD_X1_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PMD_X1_MODE
 * BLOCKS:   PMD_X1
 * REGADDR:  0x9011
 * DESC:     Global PMD mode configuration
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CORE_MODE        PMD core modeUse the following format: {reserved[3:0], otp_options[3:0], speed_id[7:0]}Only used when Speed Control logic is bypassed
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PMD_X1_MODEr (0x00109011 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PMD_X1_MODEr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X1_MODE.
 *
 */
typedef union BCMI_TSCE16_XGXS_PMD_X1_MODEr_s {
	uint32_t v[1];
	uint32_t pmd_x1_mode[1];
	uint32_t _pmd_x1_mode;
} BCMI_TSCE16_XGXS_PMD_X1_MODEr_t;

#define BCMI_TSCE16_XGXS_PMD_X1_MODEr_CLR(r) (r).pmd_x1_mode[0] = 0
#define BCMI_TSCE16_XGXS_PMD_X1_MODEr_SET(r,d) (r).pmd_x1_mode[0] = d
#define BCMI_TSCE16_XGXS_PMD_X1_MODEr_GET(r) (r).pmd_x1_mode[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PMD_X1_MODEr_CORE_MODEf_GET(r) (((r).pmd_x1_mode[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PMD_X1_MODEr_CORE_MODEf_SET(r,f) (r).pmd_x1_mode[0]=(((r).pmd_x1_mode[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PMD_X1_MODE.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PMD_X1_MODEr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PMD_X1_MODEr,(_r._pmd_x1_mode))
#define BCMI_TSCE16_XGXS_WRITE_PMD_X1_MODEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X1_MODEr,(_r._pmd_x1_mode)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PMD_X1_MODEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X1_MODEr,(_r._pmd_x1_mode))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X1_MODEr BCMI_TSCE16_XGXS_PMD_X1_MODEr
#define PMD_X1_MODEr_SIZE BCMI_TSCE16_XGXS_PMD_X1_MODEr_SIZE
typedef BCMI_TSCE16_XGXS_PMD_X1_MODEr_t PMD_X1_MODEr_t;
#define PMD_X1_MODEr_CLR BCMI_TSCE16_XGXS_PMD_X1_MODEr_CLR
#define PMD_X1_MODEr_SET BCMI_TSCE16_XGXS_PMD_X1_MODEr_SET
#define PMD_X1_MODEr_GET BCMI_TSCE16_XGXS_PMD_X1_MODEr_GET
#define PMD_X1_MODEr_CORE_MODEf_GET BCMI_TSCE16_XGXS_PMD_X1_MODEr_CORE_MODEf_GET
#define PMD_X1_MODEr_CORE_MODEf_SET BCMI_TSCE16_XGXS_PMD_X1_MODEr_CORE_MODEf_SET
#define READ_PMD_X1_MODEr BCMI_TSCE16_XGXS_READ_PMD_X1_MODEr
#define WRITE_PMD_X1_MODEr BCMI_TSCE16_XGXS_WRITE_PMD_X1_MODEr
#define MODIFY_PMD_X1_MODEr BCMI_TSCE16_XGXS_MODIFY_PMD_X1_MODEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PMD_X1_MODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PMD_X1_STS
 * BLOCKS:   PMD_X1
 * REGADDR:  0x9012
 * DESC:     Global PMD live status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PLL_LOCK_STS     PMD PLL lock indication
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PMD_X1_STSr (0x00109012 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PMD_X1_STSr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X1_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_PMD_X1_STSr_s {
	uint32_t v[1];
	uint32_t pmd_x1_sts[1];
	uint32_t _pmd_x1_sts;
} BCMI_TSCE16_XGXS_PMD_X1_STSr_t;

#define BCMI_TSCE16_XGXS_PMD_X1_STSr_CLR(r) (r).pmd_x1_sts[0] = 0
#define BCMI_TSCE16_XGXS_PMD_X1_STSr_SET(r,d) (r).pmd_x1_sts[0] = d
#define BCMI_TSCE16_XGXS_PMD_X1_STSr_GET(r) (r).pmd_x1_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PMD_X1_STSr_PLL_LOCK_STSf_GET(r) (((r).pmd_x1_sts[0]) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X1_STSr_PLL_LOCK_STSf_SET(r,f) (r).pmd_x1_sts[0]=(((r).pmd_x1_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PMD_X1_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PMD_X1_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PMD_X1_STSr,(_r._pmd_x1_sts))
#define BCMI_TSCE16_XGXS_WRITE_PMD_X1_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X1_STSr,(_r._pmd_x1_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PMD_X1_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X1_STSr,(_r._pmd_x1_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X1_STSr BCMI_TSCE16_XGXS_PMD_X1_STSr
#define PMD_X1_STSr_SIZE BCMI_TSCE16_XGXS_PMD_X1_STSr_SIZE
typedef BCMI_TSCE16_XGXS_PMD_X1_STSr_t PMD_X1_STSr_t;
#define PMD_X1_STSr_CLR BCMI_TSCE16_XGXS_PMD_X1_STSr_CLR
#define PMD_X1_STSr_SET BCMI_TSCE16_XGXS_PMD_X1_STSr_SET
#define PMD_X1_STSr_GET BCMI_TSCE16_XGXS_PMD_X1_STSr_GET
#define PMD_X1_STSr_PLL_LOCK_STSf_GET BCMI_TSCE16_XGXS_PMD_X1_STSr_PLL_LOCK_STSf_GET
#define PMD_X1_STSr_PLL_LOCK_STSf_SET BCMI_TSCE16_XGXS_PMD_X1_STSr_PLL_LOCK_STSf_SET
#define READ_PMD_X1_STSr BCMI_TSCE16_XGXS_READ_PMD_X1_STSr
#define WRITE_PMD_X1_STSr BCMI_TSCE16_XGXS_WRITE_PMD_X1_STSr
#define MODIFY_PMD_X1_STSr BCMI_TSCE16_XGXS_MODIFY_PMD_X1_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PMD_X1_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PMD_X1_LATCH_STS
 * BLOCKS:   PMD_X1
 * REGADDR:  0x9013
 * DESC:     Global PMD latched status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PLL_LOCK_LL      PMD PLL lock indication negedge detected
 *     PLL_LOCK_LH      PMD PLL lock indication posedge detected
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PMD_X1_LATCH_STSr (0x00109013 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PMD_X1_LATCH_STSr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X1_LATCH_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_PMD_X1_LATCH_STSr_s {
	uint32_t v[1];
	uint32_t pmd_x1_latch_sts[1];
	uint32_t _pmd_x1_latch_sts;
} BCMI_TSCE16_XGXS_PMD_X1_LATCH_STSr_t;

#define BCMI_TSCE16_XGXS_PMD_X1_LATCH_STSr_CLR(r) (r).pmd_x1_latch_sts[0] = 0
#define BCMI_TSCE16_XGXS_PMD_X1_LATCH_STSr_SET(r,d) (r).pmd_x1_latch_sts[0] = d
#define BCMI_TSCE16_XGXS_PMD_X1_LATCH_STSr_GET(r) (r).pmd_x1_latch_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PMD_X1_LATCH_STSr_PLL_LOCK_LHf_GET(r) ((((r).pmd_x1_latch_sts[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X1_LATCH_STSr_PLL_LOCK_LHf_SET(r,f) (r).pmd_x1_latch_sts[0]=(((r).pmd_x1_latch_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_PMD_X1_LATCH_STSr_PLL_LOCK_LLf_GET(r) (((r).pmd_x1_latch_sts[0]) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X1_LATCH_STSr_PLL_LOCK_LLf_SET(r,f) (r).pmd_x1_latch_sts[0]=(((r).pmd_x1_latch_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PMD_X1_LATCH_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PMD_X1_LATCH_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PMD_X1_LATCH_STSr,(_r._pmd_x1_latch_sts))
#define BCMI_TSCE16_XGXS_WRITE_PMD_X1_LATCH_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X1_LATCH_STSr,(_r._pmd_x1_latch_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PMD_X1_LATCH_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X1_LATCH_STSr,(_r._pmd_x1_latch_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X1_LATCH_STSr BCMI_TSCE16_XGXS_PMD_X1_LATCH_STSr
#define PMD_X1_LATCH_STSr_SIZE BCMI_TSCE16_XGXS_PMD_X1_LATCH_STSr_SIZE
typedef BCMI_TSCE16_XGXS_PMD_X1_LATCH_STSr_t PMD_X1_LATCH_STSr_t;
#define PMD_X1_LATCH_STSr_CLR BCMI_TSCE16_XGXS_PMD_X1_LATCH_STSr_CLR
#define PMD_X1_LATCH_STSr_SET BCMI_TSCE16_XGXS_PMD_X1_LATCH_STSr_SET
#define PMD_X1_LATCH_STSr_GET BCMI_TSCE16_XGXS_PMD_X1_LATCH_STSr_GET
#define PMD_X1_LATCH_STSr_PLL_LOCK_LHf_GET BCMI_TSCE16_XGXS_PMD_X1_LATCH_STSr_PLL_LOCK_LHf_GET
#define PMD_X1_LATCH_STSr_PLL_LOCK_LHf_SET BCMI_TSCE16_XGXS_PMD_X1_LATCH_STSr_PLL_LOCK_LHf_SET
#define PMD_X1_LATCH_STSr_PLL_LOCK_LLf_GET BCMI_TSCE16_XGXS_PMD_X1_LATCH_STSr_PLL_LOCK_LLf_GET
#define PMD_X1_LATCH_STSr_PLL_LOCK_LLf_SET BCMI_TSCE16_XGXS_PMD_X1_LATCH_STSr_PLL_LOCK_LLf_SET
#define READ_PMD_X1_LATCH_STSr BCMI_TSCE16_XGXS_READ_PMD_X1_LATCH_STSr
#define WRITE_PMD_X1_LATCH_STSr BCMI_TSCE16_XGXS_WRITE_PMD_X1_LATCH_STSr
#define MODIFY_PMD_X1_LATCH_STSr BCMI_TSCE16_XGXS_MODIFY_PMD_X1_LATCH_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PMD_X1_LATCH_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PMD_X1_OVRR
 * BLOCKS:   PMD_X1
 * REGADDR:  0x9014
 * DESC:     Global PMD override
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PLL_LOCK_OVRD    PMD PLL lock indicationOnly used for Speed Control bypass operation
 *     CORE_MODE_OEN    Override enable for core modeOnly used for Speed Control bypass operation
 *     CORE_DP_H_RSTB_OEN Override enable for PMD Core data path resetOnly used for Speed Control bypass operation
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PMD_X1_OVRRr (0x00109014 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PMD_X1_OVRRr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X1_OVRR.
 *
 */
typedef union BCMI_TSCE16_XGXS_PMD_X1_OVRRr_s {
	uint32_t v[1];
	uint32_t pmd_x1_ovrr[1];
	uint32_t _pmd_x1_ovrr;
} BCMI_TSCE16_XGXS_PMD_X1_OVRRr_t;

#define BCMI_TSCE16_XGXS_PMD_X1_OVRRr_CLR(r) (r).pmd_x1_ovrr[0] = 0
#define BCMI_TSCE16_XGXS_PMD_X1_OVRRr_SET(r,d) (r).pmd_x1_ovrr[0] = d
#define BCMI_TSCE16_XGXS_PMD_X1_OVRRr_GET(r) (r).pmd_x1_ovrr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PMD_X1_OVRRr_CORE_DP_H_RSTB_OENf_GET(r) ((((r).pmd_x1_ovrr[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X1_OVRRr_CORE_DP_H_RSTB_OENf_SET(r,f) (r).pmd_x1_ovrr[0]=(((r).pmd_x1_ovrr[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_PMD_X1_OVRRr_CORE_MODE_OENf_GET(r) ((((r).pmd_x1_ovrr[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X1_OVRRr_CORE_MODE_OENf_SET(r,f) (r).pmd_x1_ovrr[0]=(((r).pmd_x1_ovrr[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_PMD_X1_OVRRr_PLL_LOCK_OVRDf_GET(r) (((r).pmd_x1_ovrr[0]) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X1_OVRRr_PLL_LOCK_OVRDf_SET(r,f) (r).pmd_x1_ovrr[0]=(((r).pmd_x1_ovrr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PMD_X1_OVRR.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PMD_X1_OVRRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PMD_X1_OVRRr,(_r._pmd_x1_ovrr))
#define BCMI_TSCE16_XGXS_WRITE_PMD_X1_OVRRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X1_OVRRr,(_r._pmd_x1_ovrr)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PMD_X1_OVRRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X1_OVRRr,(_r._pmd_x1_ovrr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X1_OVRRr BCMI_TSCE16_XGXS_PMD_X1_OVRRr
#define PMD_X1_OVRRr_SIZE BCMI_TSCE16_XGXS_PMD_X1_OVRRr_SIZE
typedef BCMI_TSCE16_XGXS_PMD_X1_OVRRr_t PMD_X1_OVRRr_t;
#define PMD_X1_OVRRr_CLR BCMI_TSCE16_XGXS_PMD_X1_OVRRr_CLR
#define PMD_X1_OVRRr_SET BCMI_TSCE16_XGXS_PMD_X1_OVRRr_SET
#define PMD_X1_OVRRr_GET BCMI_TSCE16_XGXS_PMD_X1_OVRRr_GET
#define PMD_X1_OVRRr_CORE_DP_H_RSTB_OENf_GET BCMI_TSCE16_XGXS_PMD_X1_OVRRr_CORE_DP_H_RSTB_OENf_GET
#define PMD_X1_OVRRr_CORE_DP_H_RSTB_OENf_SET BCMI_TSCE16_XGXS_PMD_X1_OVRRr_CORE_DP_H_RSTB_OENf_SET
#define PMD_X1_OVRRr_CORE_MODE_OENf_GET BCMI_TSCE16_XGXS_PMD_X1_OVRRr_CORE_MODE_OENf_GET
#define PMD_X1_OVRRr_CORE_MODE_OENf_SET BCMI_TSCE16_XGXS_PMD_X1_OVRRr_CORE_MODE_OENf_SET
#define PMD_X1_OVRRr_PLL_LOCK_OVRDf_GET BCMI_TSCE16_XGXS_PMD_X1_OVRRr_PLL_LOCK_OVRDf_GET
#define PMD_X1_OVRRr_PLL_LOCK_OVRDf_SET BCMI_TSCE16_XGXS_PMD_X1_OVRRr_PLL_LOCK_OVRDf_SET
#define READ_PMD_X1_OVRRr BCMI_TSCE16_XGXS_READ_PMD_X1_OVRRr
#define WRITE_PMD_X1_OVRRr BCMI_TSCE16_XGXS_WRITE_PMD_X1_OVRRr
#define MODIFY_PMD_X1_OVRRr BCMI_TSCE16_XGXS_MODIFY_PMD_X1_OVRRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PMD_X1_OVRRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PKTGEN_CTL1
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x9030
 * DESC:     Number of Packets
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PKT_OR_PRTP      test source select0 packet generator (10M to 40G)1 cl49 Pseudo Random Test Pattern(PRTP) generator
 *     TX_TEST_PORT_SEL Port for which Packet generator or PRTP generator should be enabledPacket generator and PRTP generator are shared across all port, so only one port can have either of them enabled
 *     LPI_EN           replace idles with lpi (eee)
 *     PRTP_DATA_PATTERN_SEL 0: Local Fault Pattern, 1: Zeros Data Pattern
 *     TX_PRTP_EN       Enable Pseudo Random Test Pattern(PRTP) Generator
 *     RX_PORT_SEL      Port for which Packet checker or PRTP checker should be enabledPacket checker and PRTP checker are shared across all port, so only one port can have either of them enabled
 *     CLR_CRCCNT       Clear CRC error count in Packet Checker
 *     RX_MSBUS_TYPE    1: MII/GMII type octet, 0: XGMII/XLGMII type octet
 *     RX_PKT_CHECK_EN  Eanble Rx Packet CRC checker
 *     NUMBER_PKT       number of packets0: Idles1: single packet2: unlimited packets3-15 (RESERVED)
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PKTGEN_CTL1r (0x00109030 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PKTGEN_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_CTL1.
 *
 */
typedef union BCMI_TSCE16_XGXS_PKTGEN_CTL1r_s {
	uint32_t v[1];
	uint32_t pktgen_ctl1[1];
	uint32_t _pktgen_ctl1;
} BCMI_TSCE16_XGXS_PKTGEN_CTL1r_t;

#define BCMI_TSCE16_XGXS_PKTGEN_CTL1r_CLR(r) (r).pktgen_ctl1[0] = 0
#define BCMI_TSCE16_XGXS_PKTGEN_CTL1r_SET(r,d) (r).pktgen_ctl1[0] = d
#define BCMI_TSCE16_XGXS_PKTGEN_CTL1r_GET(r) (r).pktgen_ctl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PKTGEN_CTL1r_NUMBER_PKTf_GET(r) ((((r).pktgen_ctl1[0]) >> 12) & 0xf)
#define BCMI_TSCE16_XGXS_PKTGEN_CTL1r_NUMBER_PKTf_SET(r,f) (r).pktgen_ctl1[0]=(((r).pktgen_ctl1[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCE16_XGXS_PKTGEN_CTL1r_RX_PKT_CHECK_ENf_GET(r) ((((r).pktgen_ctl1[0]) >> 11) & 0x1)
#define BCMI_TSCE16_XGXS_PKTGEN_CTL1r_RX_PKT_CHECK_ENf_SET(r,f) (r).pktgen_ctl1[0]=(((r).pktgen_ctl1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCE16_XGXS_PKTGEN_CTL1r_RX_MSBUS_TYPEf_GET(r) ((((r).pktgen_ctl1[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_PKTGEN_CTL1r_RX_MSBUS_TYPEf_SET(r,f) (r).pktgen_ctl1[0]=(((r).pktgen_ctl1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_PKTGEN_CTL1r_CLR_CRCCNTf_GET(r) ((((r).pktgen_ctl1[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_PKTGEN_CTL1r_CLR_CRCCNTf_SET(r,f) (r).pktgen_ctl1[0]=(((r).pktgen_ctl1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_PKTGEN_CTL1r_RX_PORT_SELf_GET(r) ((((r).pktgen_ctl1[0]) >> 7) & 0x3)
#define BCMI_TSCE16_XGXS_PKTGEN_CTL1r_RX_PORT_SELf_SET(r,f) (r).pktgen_ctl1[0]=(((r).pktgen_ctl1[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7)) | (3 << (16 + 7))
#define BCMI_TSCE16_XGXS_PKTGEN_CTL1r_TX_PRTP_ENf_GET(r) ((((r).pktgen_ctl1[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_PKTGEN_CTL1r_TX_PRTP_ENf_SET(r,f) (r).pktgen_ctl1[0]=(((r).pktgen_ctl1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_PKTGEN_CTL1r_PRTP_DATA_PATTERN_SELf_GET(r) ((((r).pktgen_ctl1[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_PKTGEN_CTL1r_PRTP_DATA_PATTERN_SELf_SET(r,f) (r).pktgen_ctl1[0]=(((r).pktgen_ctl1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_PKTGEN_CTL1r_LPI_ENf_GET(r) ((((r).pktgen_ctl1[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_PKTGEN_CTL1r_LPI_ENf_SET(r,f) (r).pktgen_ctl1[0]=(((r).pktgen_ctl1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_PKTGEN_CTL1r_TX_TEST_PORT_SELf_GET(r) ((((r).pktgen_ctl1[0]) >> 1) & 0x3)
#define BCMI_TSCE16_XGXS_PKTGEN_CTL1r_TX_TEST_PORT_SELf_SET(r,f) (r).pktgen_ctl1[0]=(((r).pktgen_ctl1[0] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1)) | (3 << (16 + 1))
#define BCMI_TSCE16_XGXS_PKTGEN_CTL1r_PKT_OR_PRTPf_GET(r) (((r).pktgen_ctl1[0]) & 0x1)
#define BCMI_TSCE16_XGXS_PKTGEN_CTL1r_PKT_OR_PRTPf_SET(r,f) (r).pktgen_ctl1[0]=(((r).pktgen_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PKTGEN_CTL1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PKTGEN_CTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PKTGEN_CTL1r,(_r._pktgen_ctl1))
#define BCMI_TSCE16_XGXS_WRITE_PKTGEN_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_CTL1r,(_r._pktgen_ctl1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PKTGEN_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_CTL1r,(_r._pktgen_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_CTL1r BCMI_TSCE16_XGXS_PKTGEN_CTL1r
#define PKTGEN_CTL1r_SIZE BCMI_TSCE16_XGXS_PKTGEN_CTL1r_SIZE
typedef BCMI_TSCE16_XGXS_PKTGEN_CTL1r_t PKTGEN_CTL1r_t;
#define PKTGEN_CTL1r_CLR BCMI_TSCE16_XGXS_PKTGEN_CTL1r_CLR
#define PKTGEN_CTL1r_SET BCMI_TSCE16_XGXS_PKTGEN_CTL1r_SET
#define PKTGEN_CTL1r_GET BCMI_TSCE16_XGXS_PKTGEN_CTL1r_GET
#define PKTGEN_CTL1r_NUMBER_PKTf_GET BCMI_TSCE16_XGXS_PKTGEN_CTL1r_NUMBER_PKTf_GET
#define PKTGEN_CTL1r_NUMBER_PKTf_SET BCMI_TSCE16_XGXS_PKTGEN_CTL1r_NUMBER_PKTf_SET
#define PKTGEN_CTL1r_RX_PKT_CHECK_ENf_GET BCMI_TSCE16_XGXS_PKTGEN_CTL1r_RX_PKT_CHECK_ENf_GET
#define PKTGEN_CTL1r_RX_PKT_CHECK_ENf_SET BCMI_TSCE16_XGXS_PKTGEN_CTL1r_RX_PKT_CHECK_ENf_SET
#define PKTGEN_CTL1r_RX_MSBUS_TYPEf_GET BCMI_TSCE16_XGXS_PKTGEN_CTL1r_RX_MSBUS_TYPEf_GET
#define PKTGEN_CTL1r_RX_MSBUS_TYPEf_SET BCMI_TSCE16_XGXS_PKTGEN_CTL1r_RX_MSBUS_TYPEf_SET
#define PKTGEN_CTL1r_CLR_CRCCNTf_GET BCMI_TSCE16_XGXS_PKTGEN_CTL1r_CLR_CRCCNTf_GET
#define PKTGEN_CTL1r_CLR_CRCCNTf_SET BCMI_TSCE16_XGXS_PKTGEN_CTL1r_CLR_CRCCNTf_SET
#define PKTGEN_CTL1r_RX_PORT_SELf_GET BCMI_TSCE16_XGXS_PKTGEN_CTL1r_RX_PORT_SELf_GET
#define PKTGEN_CTL1r_RX_PORT_SELf_SET BCMI_TSCE16_XGXS_PKTGEN_CTL1r_RX_PORT_SELf_SET
#define PKTGEN_CTL1r_TX_PRTP_ENf_GET BCMI_TSCE16_XGXS_PKTGEN_CTL1r_TX_PRTP_ENf_GET
#define PKTGEN_CTL1r_TX_PRTP_ENf_SET BCMI_TSCE16_XGXS_PKTGEN_CTL1r_TX_PRTP_ENf_SET
#define PKTGEN_CTL1r_PRTP_DATA_PATTERN_SELf_GET BCMI_TSCE16_XGXS_PKTGEN_CTL1r_PRTP_DATA_PATTERN_SELf_GET
#define PKTGEN_CTL1r_PRTP_DATA_PATTERN_SELf_SET BCMI_TSCE16_XGXS_PKTGEN_CTL1r_PRTP_DATA_PATTERN_SELf_SET
#define PKTGEN_CTL1r_LPI_ENf_GET BCMI_TSCE16_XGXS_PKTGEN_CTL1r_LPI_ENf_GET
#define PKTGEN_CTL1r_LPI_ENf_SET BCMI_TSCE16_XGXS_PKTGEN_CTL1r_LPI_ENf_SET
#define PKTGEN_CTL1r_TX_TEST_PORT_SELf_GET BCMI_TSCE16_XGXS_PKTGEN_CTL1r_TX_TEST_PORT_SELf_GET
#define PKTGEN_CTL1r_TX_TEST_PORT_SELf_SET BCMI_TSCE16_XGXS_PKTGEN_CTL1r_TX_TEST_PORT_SELf_SET
#define PKTGEN_CTL1r_PKT_OR_PRTPf_GET BCMI_TSCE16_XGXS_PKTGEN_CTL1r_PKT_OR_PRTPf_GET
#define PKTGEN_CTL1r_PKT_OR_PRTPf_SET BCMI_TSCE16_XGXS_PKTGEN_CTL1r_PKT_OR_PRTPf_SET
#define READ_PKTGEN_CTL1r BCMI_TSCE16_XGXS_READ_PKTGEN_CTL1r
#define WRITE_PKTGEN_CTL1r BCMI_TSCE16_XGXS_WRITE_PKTGEN_CTL1r
#define MODIFY_PKTGEN_CTL1r BCMI_TSCE16_XGXS_MODIFY_PKTGEN_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PKTGEN_CTL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PKTGEN_CTL2
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x9031
 * DESC:     Packet and IPG Size
 * RESETVAL: 0x28 (40)
 * ACCESS:   R/W
 * FIELDS:
 *     IPG_SIZE         number of bytesrange is 0 to 32 bytes
 *     PKT_SIZE         number of 256 bytesrange is 256 to 16384 bytesthere is a dependency with respect to ipg_size programming in non GMII mode because of SOP alignmentneed to meet this requirement: (pkt_size+ipg_size) / 8 = 4
 *     PAYLOAD_TYPE     payload type0 repeat two bytes1 ramping2 CL48 CRPAT (can be used with XGMII/XLGMII)3 CL48 CJPAT (can be used with XGMII/XLGMII)4 CL36 Long CRPAT (can be used with GMII/MII)5 CL36 Short CRPAT (can be used with GMII/MII)
 *     TX_MSBUS_TYPE    1: MII/GMII type octet, 0: XGMII/XLGMII type octet
 *     PKTGEN_EN        packet gen enable
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PKTGEN_CTL2r (0x00109031 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PKTGEN_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_CTL2.
 *
 */
typedef union BCMI_TSCE16_XGXS_PKTGEN_CTL2r_s {
	uint32_t v[1];
	uint32_t pktgen_ctl2[1];
	uint32_t _pktgen_ctl2;
} BCMI_TSCE16_XGXS_PKTGEN_CTL2r_t;

#define BCMI_TSCE16_XGXS_PKTGEN_CTL2r_CLR(r) (r).pktgen_ctl2[0] = 0
#define BCMI_TSCE16_XGXS_PKTGEN_CTL2r_SET(r,d) (r).pktgen_ctl2[0] = d
#define BCMI_TSCE16_XGXS_PKTGEN_CTL2r_GET(r) (r).pktgen_ctl2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PKTGEN_CTL2r_PKTGEN_ENf_GET(r) ((((r).pktgen_ctl2[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_PKTGEN_CTL2r_PKTGEN_ENf_SET(r,f) (r).pktgen_ctl2[0]=(((r).pktgen_ctl2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_PKTGEN_CTL2r_TX_MSBUS_TYPEf_GET(r) ((((r).pktgen_ctl2[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_PKTGEN_CTL2r_TX_MSBUS_TYPEf_SET(r,f) (r).pktgen_ctl2[0]=(((r).pktgen_ctl2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_PKTGEN_CTL2r_PAYLOAD_TYPEf_GET(r) ((((r).pktgen_ctl2[0]) >> 11) & 0x7)
#define BCMI_TSCE16_XGXS_PKTGEN_CTL2r_PAYLOAD_TYPEf_SET(r,f) (r).pktgen_ctl2[0]=(((r).pktgen_ctl2[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_TSCE16_XGXS_PKTGEN_CTL2r_PKT_SIZEf_GET(r) ((((r).pktgen_ctl2[0]) >> 5) & 0x3f)
#define BCMI_TSCE16_XGXS_PKTGEN_CTL2r_PKT_SIZEf_SET(r,f) (r).pktgen_ctl2[0]=(((r).pktgen_ctl2[0] & ~((uint32_t)0x3f << 5)) | ((((uint32_t)f) & 0x3f) << 5)) | (63 << (16 + 5))
#define BCMI_TSCE16_XGXS_PKTGEN_CTL2r_IPG_SIZEf_GET(r) (((r).pktgen_ctl2[0]) & 0x1f)
#define BCMI_TSCE16_XGXS_PKTGEN_CTL2r_IPG_SIZEf_SET(r,f) (r).pktgen_ctl2[0]=(((r).pktgen_ctl2[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PKTGEN_CTL2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PKTGEN_CTL2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PKTGEN_CTL2r,(_r._pktgen_ctl2))
#define BCMI_TSCE16_XGXS_WRITE_PKTGEN_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_CTL2r,(_r._pktgen_ctl2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PKTGEN_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_CTL2r,(_r._pktgen_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_CTL2r BCMI_TSCE16_XGXS_PKTGEN_CTL2r
#define PKTGEN_CTL2r_SIZE BCMI_TSCE16_XGXS_PKTGEN_CTL2r_SIZE
typedef BCMI_TSCE16_XGXS_PKTGEN_CTL2r_t PKTGEN_CTL2r_t;
#define PKTGEN_CTL2r_CLR BCMI_TSCE16_XGXS_PKTGEN_CTL2r_CLR
#define PKTGEN_CTL2r_SET BCMI_TSCE16_XGXS_PKTGEN_CTL2r_SET
#define PKTGEN_CTL2r_GET BCMI_TSCE16_XGXS_PKTGEN_CTL2r_GET
#define PKTGEN_CTL2r_PKTGEN_ENf_GET BCMI_TSCE16_XGXS_PKTGEN_CTL2r_PKTGEN_ENf_GET
#define PKTGEN_CTL2r_PKTGEN_ENf_SET BCMI_TSCE16_XGXS_PKTGEN_CTL2r_PKTGEN_ENf_SET
#define PKTGEN_CTL2r_TX_MSBUS_TYPEf_GET BCMI_TSCE16_XGXS_PKTGEN_CTL2r_TX_MSBUS_TYPEf_GET
#define PKTGEN_CTL2r_TX_MSBUS_TYPEf_SET BCMI_TSCE16_XGXS_PKTGEN_CTL2r_TX_MSBUS_TYPEf_SET
#define PKTGEN_CTL2r_PAYLOAD_TYPEf_GET BCMI_TSCE16_XGXS_PKTGEN_CTL2r_PAYLOAD_TYPEf_GET
#define PKTGEN_CTL2r_PAYLOAD_TYPEf_SET BCMI_TSCE16_XGXS_PKTGEN_CTL2r_PAYLOAD_TYPEf_SET
#define PKTGEN_CTL2r_PKT_SIZEf_GET BCMI_TSCE16_XGXS_PKTGEN_CTL2r_PKT_SIZEf_GET
#define PKTGEN_CTL2r_PKT_SIZEf_SET BCMI_TSCE16_XGXS_PKTGEN_CTL2r_PKT_SIZEf_SET
#define PKTGEN_CTL2r_IPG_SIZEf_GET BCMI_TSCE16_XGXS_PKTGEN_CTL2r_IPG_SIZEf_GET
#define PKTGEN_CTL2r_IPG_SIZEf_SET BCMI_TSCE16_XGXS_PKTGEN_CTL2r_IPG_SIZEf_SET
#define READ_PKTGEN_CTL2r BCMI_TSCE16_XGXS_READ_PKTGEN_CTL2r
#define WRITE_PKTGEN_CTL2r BCMI_TSCE16_XGXS_WRITE_PKTGEN_CTL2r
#define MODIFY_PKTGEN_CTL2r BCMI_TSCE16_XGXS_MODIFY_PKTGEN_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PKTGEN_CTL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PKTGEN_PRTPCTL
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x9032
 * DESC:     PRTP CONTROLS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_PRTP_EN       Enable Pseudo Random Test Pattern(PRTP) checker
 *     ERRGEN_EN        PER LANE control to enable 80-bit error gen maskNote that for MLD modes this control is per Virtual LaneNote: Setting this bit results in a one time application of the error mask
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PKTGEN_PRTPCTLr (0x00109032 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PKTGEN_PRTPCTLr_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_PRTPCTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_PKTGEN_PRTPCTLr_s {
	uint32_t v[1];
	uint32_t pktgen_prtpctl[1];
	uint32_t _pktgen_prtpctl;
} BCMI_TSCE16_XGXS_PKTGEN_PRTPCTLr_t;

#define BCMI_TSCE16_XGXS_PKTGEN_PRTPCTLr_CLR(r) (r).pktgen_prtpctl[0] = 0
#define BCMI_TSCE16_XGXS_PKTGEN_PRTPCTLr_SET(r,d) (r).pktgen_prtpctl[0] = d
#define BCMI_TSCE16_XGXS_PKTGEN_PRTPCTLr_GET(r) (r).pktgen_prtpctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PKTGEN_PRTPCTLr_ERRGEN_ENf_GET(r) ((((r).pktgen_prtpctl[0]) >> 5) & 0xf)
#define BCMI_TSCE16_XGXS_PKTGEN_PRTPCTLr_ERRGEN_ENf_SET(r,f) (r).pktgen_prtpctl[0]=(((r).pktgen_prtpctl[0] & ~((uint32_t)0xf << 5)) | ((((uint32_t)f) & 0xf) << 5)) | (15 << (16 + 5))
#define BCMI_TSCE16_XGXS_PKTGEN_PRTPCTLr_RX_PRTP_ENf_GET(r) ((((r).pktgen_prtpctl[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_PKTGEN_PRTPCTLr_RX_PRTP_ENf_SET(r,f) (r).pktgen_prtpctl[0]=(((r).pktgen_prtpctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))

/*
 * These macros can be used to access PKTGEN_PRTPCTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PKTGEN_PRTPCTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PKTGEN_PRTPCTLr,(_r._pktgen_prtpctl))
#define BCMI_TSCE16_XGXS_WRITE_PKTGEN_PRTPCTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_PRTPCTLr,(_r._pktgen_prtpctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PKTGEN_PRTPCTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_PRTPCTLr,(_r._pktgen_prtpctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_PRTPCTLr BCMI_TSCE16_XGXS_PKTGEN_PRTPCTLr
#define PKTGEN_PRTPCTLr_SIZE BCMI_TSCE16_XGXS_PKTGEN_PRTPCTLr_SIZE
typedef BCMI_TSCE16_XGXS_PKTGEN_PRTPCTLr_t PKTGEN_PRTPCTLr_t;
#define PKTGEN_PRTPCTLr_CLR BCMI_TSCE16_XGXS_PKTGEN_PRTPCTLr_CLR
#define PKTGEN_PRTPCTLr_SET BCMI_TSCE16_XGXS_PKTGEN_PRTPCTLr_SET
#define PKTGEN_PRTPCTLr_GET BCMI_TSCE16_XGXS_PKTGEN_PRTPCTLr_GET
#define PKTGEN_PRTPCTLr_ERRGEN_ENf_GET BCMI_TSCE16_XGXS_PKTGEN_PRTPCTLr_ERRGEN_ENf_GET
#define PKTGEN_PRTPCTLr_ERRGEN_ENf_SET BCMI_TSCE16_XGXS_PKTGEN_PRTPCTLr_ERRGEN_ENf_SET
#define PKTGEN_PRTPCTLr_RX_PRTP_ENf_GET BCMI_TSCE16_XGXS_PKTGEN_PRTPCTLr_RX_PRTP_ENf_GET
#define PKTGEN_PRTPCTLr_RX_PRTP_ENf_SET BCMI_TSCE16_XGXS_PKTGEN_PRTPCTLr_RX_PRTP_ENf_SET
#define READ_PKTGEN_PRTPCTLr BCMI_TSCE16_XGXS_READ_PKTGEN_PRTPCTLr
#define WRITE_PKTGEN_PRTPCTLr BCMI_TSCE16_XGXS_WRITE_PKTGEN_PRTPCTLr
#define MODIFY_PKTGEN_PRTPCTLr BCMI_TSCE16_XGXS_MODIFY_PKTGEN_PRTPCTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PKTGEN_PRTPCTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PKTGEN_CRCERRCNT
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x9033
 * DESC:     CRC Error Count Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CRCERRCNT        Count of received packet with bad crc.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PKTGEN_CRCERRCNTr (0x00109033 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PKTGEN_CRCERRCNTr_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_CRCERRCNT.
 *
 */
typedef union BCMI_TSCE16_XGXS_PKTGEN_CRCERRCNTr_s {
	uint32_t v[1];
	uint32_t pktgen_crcerrcnt[1];
	uint32_t _pktgen_crcerrcnt;
} BCMI_TSCE16_XGXS_PKTGEN_CRCERRCNTr_t;

#define BCMI_TSCE16_XGXS_PKTGEN_CRCERRCNTr_CLR(r) (r).pktgen_crcerrcnt[0] = 0
#define BCMI_TSCE16_XGXS_PKTGEN_CRCERRCNTr_SET(r,d) (r).pktgen_crcerrcnt[0] = d
#define BCMI_TSCE16_XGXS_PKTGEN_CRCERRCNTr_GET(r) (r).pktgen_crcerrcnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PKTGEN_CRCERRCNTr_CRCERRCNTf_GET(r) (((r).pktgen_crcerrcnt[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PKTGEN_CRCERRCNTr_CRCERRCNTf_SET(r,f) (r).pktgen_crcerrcnt[0]=(((r).pktgen_crcerrcnt[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_CRCERRCNT.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PKTGEN_CRCERRCNTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PKTGEN_CRCERRCNTr,(_r._pktgen_crcerrcnt))
#define BCMI_TSCE16_XGXS_WRITE_PKTGEN_CRCERRCNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_CRCERRCNTr,(_r._pktgen_crcerrcnt)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PKTGEN_CRCERRCNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_CRCERRCNTr,(_r._pktgen_crcerrcnt))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_CRCERRCNTr BCMI_TSCE16_XGXS_PKTGEN_CRCERRCNTr
#define PKTGEN_CRCERRCNTr_SIZE BCMI_TSCE16_XGXS_PKTGEN_CRCERRCNTr_SIZE
typedef BCMI_TSCE16_XGXS_PKTGEN_CRCERRCNTr_t PKTGEN_CRCERRCNTr_t;
#define PKTGEN_CRCERRCNTr_CLR BCMI_TSCE16_XGXS_PKTGEN_CRCERRCNTr_CLR
#define PKTGEN_CRCERRCNTr_SET BCMI_TSCE16_XGXS_PKTGEN_CRCERRCNTr_SET
#define PKTGEN_CRCERRCNTr_GET BCMI_TSCE16_XGXS_PKTGEN_CRCERRCNTr_GET
#define PKTGEN_CRCERRCNTr_CRCERRCNTf_GET BCMI_TSCE16_XGXS_PKTGEN_CRCERRCNTr_CRCERRCNTf_GET
#define PKTGEN_CRCERRCNTr_CRCERRCNTf_SET BCMI_TSCE16_XGXS_PKTGEN_CRCERRCNTr_CRCERRCNTf_SET
#define READ_PKTGEN_CRCERRCNTr BCMI_TSCE16_XGXS_READ_PKTGEN_CRCERRCNTr
#define WRITE_PKTGEN_CRCERRCNTr BCMI_TSCE16_XGXS_WRITE_PKTGEN_CRCERRCNTr
#define MODIFY_PKTGEN_CRCERRCNTr BCMI_TSCE16_XGXS_MODIFY_PKTGEN_CRCERRCNTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PKTGEN_CRCERRCNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PKTGEN_PRTPERRCTR
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x9034
 * DESC:     PRTP Error Count Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PRTP_ERR_COUNT   Pseudo Random Test Pattern block error count
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PKTGEN_PRTPERRCTRr (0x00109034 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PKTGEN_PRTPERRCTRr_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_PRTPERRCTR.
 *
 */
typedef union BCMI_TSCE16_XGXS_PKTGEN_PRTPERRCTRr_s {
	uint32_t v[1];
	uint32_t pktgen_prtperrctr[1];
	uint32_t _pktgen_prtperrctr;
} BCMI_TSCE16_XGXS_PKTGEN_PRTPERRCTRr_t;

#define BCMI_TSCE16_XGXS_PKTGEN_PRTPERRCTRr_CLR(r) (r).pktgen_prtperrctr[0] = 0
#define BCMI_TSCE16_XGXS_PKTGEN_PRTPERRCTRr_SET(r,d) (r).pktgen_prtperrctr[0] = d
#define BCMI_TSCE16_XGXS_PKTGEN_PRTPERRCTRr_GET(r) (r).pktgen_prtperrctr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PKTGEN_PRTPERRCTRr_PRTP_ERR_COUNTf_GET(r) (((r).pktgen_prtperrctr[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PKTGEN_PRTPERRCTRr_PRTP_ERR_COUNTf_SET(r,f) (r).pktgen_prtperrctr[0]=(((r).pktgen_prtperrctr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_PRTPERRCTR.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PKTGEN_PRTPERRCTRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PKTGEN_PRTPERRCTRr,(_r._pktgen_prtperrctr))
#define BCMI_TSCE16_XGXS_WRITE_PKTGEN_PRTPERRCTRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_PRTPERRCTRr,(_r._pktgen_prtperrctr)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PKTGEN_PRTPERRCTRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_PRTPERRCTRr,(_r._pktgen_prtperrctr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_PRTPERRCTRr BCMI_TSCE16_XGXS_PKTGEN_PRTPERRCTRr
#define PKTGEN_PRTPERRCTRr_SIZE BCMI_TSCE16_XGXS_PKTGEN_PRTPERRCTRr_SIZE
typedef BCMI_TSCE16_XGXS_PKTGEN_PRTPERRCTRr_t PKTGEN_PRTPERRCTRr_t;
#define PKTGEN_PRTPERRCTRr_CLR BCMI_TSCE16_XGXS_PKTGEN_PRTPERRCTRr_CLR
#define PKTGEN_PRTPERRCTRr_SET BCMI_TSCE16_XGXS_PKTGEN_PRTPERRCTRr_SET
#define PKTGEN_PRTPERRCTRr_GET BCMI_TSCE16_XGXS_PKTGEN_PRTPERRCTRr_GET
#define PKTGEN_PRTPERRCTRr_PRTP_ERR_COUNTf_GET BCMI_TSCE16_XGXS_PKTGEN_PRTPERRCTRr_PRTP_ERR_COUNTf_GET
#define PKTGEN_PRTPERRCTRr_PRTP_ERR_COUNTf_SET BCMI_TSCE16_XGXS_PKTGEN_PRTPERRCTRr_PRTP_ERR_COUNTf_SET
#define READ_PKTGEN_PRTPERRCTRr BCMI_TSCE16_XGXS_READ_PKTGEN_PRTPERRCTRr
#define WRITE_PKTGEN_PRTPERRCTRr BCMI_TSCE16_XGXS_WRITE_PKTGEN_PRTPERRCTRr
#define MODIFY_PKTGEN_PRTPERRCTRr BCMI_TSCE16_XGXS_MODIFY_PKTGEN_PRTPERRCTRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PKTGEN_PRTPERRCTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PKTGEN_PRTPLOCKSTS
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x9035
 * DESC:     Prtp Lock Status  Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PRTP_LOCK        PRTP pattern is locked
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PKTGEN_PRTPLOCKSTSr (0x00109035 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PKTGEN_PRTPLOCKSTSr_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_PRTPLOCKSTS.
 *
 */
typedef union BCMI_TSCE16_XGXS_PKTGEN_PRTPLOCKSTSr_s {
	uint32_t v[1];
	uint32_t pktgen_prtplocksts[1];
	uint32_t _pktgen_prtplocksts;
} BCMI_TSCE16_XGXS_PKTGEN_PRTPLOCKSTSr_t;

#define BCMI_TSCE16_XGXS_PKTGEN_PRTPLOCKSTSr_CLR(r) (r).pktgen_prtplocksts[0] = 0
#define BCMI_TSCE16_XGXS_PKTGEN_PRTPLOCKSTSr_SET(r,d) (r).pktgen_prtplocksts[0] = d
#define BCMI_TSCE16_XGXS_PKTGEN_PRTPLOCKSTSr_GET(r) (r).pktgen_prtplocksts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PKTGEN_PRTPLOCKSTSr_PRTP_LOCKf_GET(r) (((r).pktgen_prtplocksts[0]) & 0x1)
#define BCMI_TSCE16_XGXS_PKTGEN_PRTPLOCKSTSr_PRTP_LOCKf_SET(r,f) (r).pktgen_prtplocksts[0]=(((r).pktgen_prtplocksts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PKTGEN_PRTPLOCKSTS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PKTGEN_PRTPLOCKSTSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PKTGEN_PRTPLOCKSTSr,(_r._pktgen_prtplocksts))
#define BCMI_TSCE16_XGXS_WRITE_PKTGEN_PRTPLOCKSTSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_PRTPLOCKSTSr,(_r._pktgen_prtplocksts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PKTGEN_PRTPLOCKSTSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_PRTPLOCKSTSr,(_r._pktgen_prtplocksts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_PRTPLOCKSTSr BCMI_TSCE16_XGXS_PKTGEN_PRTPLOCKSTSr
#define PKTGEN_PRTPLOCKSTSr_SIZE BCMI_TSCE16_XGXS_PKTGEN_PRTPLOCKSTSr_SIZE
typedef BCMI_TSCE16_XGXS_PKTGEN_PRTPLOCKSTSr_t PKTGEN_PRTPLOCKSTSr_t;
#define PKTGEN_PRTPLOCKSTSr_CLR BCMI_TSCE16_XGXS_PKTGEN_PRTPLOCKSTSr_CLR
#define PKTGEN_PRTPLOCKSTSr_SET BCMI_TSCE16_XGXS_PKTGEN_PRTPLOCKSTSr_SET
#define PKTGEN_PRTPLOCKSTSr_GET BCMI_TSCE16_XGXS_PKTGEN_PRTPLOCKSTSr_GET
#define PKTGEN_PRTPLOCKSTSr_PRTP_LOCKf_GET BCMI_TSCE16_XGXS_PKTGEN_PRTPLOCKSTSr_PRTP_LOCKf_GET
#define PKTGEN_PRTPLOCKSTSr_PRTP_LOCKf_SET BCMI_TSCE16_XGXS_PKTGEN_PRTPLOCKSTSr_PRTP_LOCKf_SET
#define READ_PKTGEN_PRTPLOCKSTSr BCMI_TSCE16_XGXS_READ_PKTGEN_PRTPLOCKSTSr
#define WRITE_PKTGEN_PRTPLOCKSTSr BCMI_TSCE16_XGXS_WRITE_PKTGEN_PRTPLOCKSTSr
#define MODIFY_PKTGEN_PRTPLOCKSTSr BCMI_TSCE16_XGXS_MODIFY_PKTGEN_PRTPLOCKSTSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PKTGEN_PRTPLOCKSTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PKTGEN_PCS_SEEDA0
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x9037
 * DESC:     10GBASE-R PCS 0022 test pattern seed A word bits 15:00
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SEEDA0           10GBASE-R PCS test pattern seed A bits 0-15, seedA0[15:0]
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA0r (0x00109037 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA0r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_PCS_SEEDA0.
 *
 */
typedef union BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA0r_s {
	uint32_t v[1];
	uint32_t pktgen_pcs_seeda0[1];
	uint32_t _pktgen_pcs_seeda0;
} BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA0r_t;

#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA0r_CLR(r) (r).pktgen_pcs_seeda0[0] = 0
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA0r_SET(r,d) (r).pktgen_pcs_seeda0[0] = d
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA0r_GET(r) (r).pktgen_pcs_seeda0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA0r_SEEDA0f_GET(r) (((r).pktgen_pcs_seeda0[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA0r_SEEDA0f_SET(r,f) (r).pktgen_pcs_seeda0[0]=(((r).pktgen_pcs_seeda0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_PCS_SEEDA0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PKTGEN_PCS_SEEDA0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA0r,(_r._pktgen_pcs_seeda0))
#define BCMI_TSCE16_XGXS_WRITE_PKTGEN_PCS_SEEDA0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA0r,(_r._pktgen_pcs_seeda0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PKTGEN_PCS_SEEDA0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA0r,(_r._pktgen_pcs_seeda0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_PCS_SEEDA0r BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA0r
#define PKTGEN_PCS_SEEDA0r_SIZE BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA0r_SIZE
typedef BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA0r_t PKTGEN_PCS_SEEDA0r_t;
#define PKTGEN_PCS_SEEDA0r_CLR BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA0r_CLR
#define PKTGEN_PCS_SEEDA0r_SET BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA0r_SET
#define PKTGEN_PCS_SEEDA0r_GET BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA0r_GET
#define PKTGEN_PCS_SEEDA0r_SEEDA0f_GET BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA0r_SEEDA0f_GET
#define PKTGEN_PCS_SEEDA0r_SEEDA0f_SET BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA0r_SEEDA0f_SET
#define READ_PKTGEN_PCS_SEEDA0r BCMI_TSCE16_XGXS_READ_PKTGEN_PCS_SEEDA0r
#define WRITE_PKTGEN_PCS_SEEDA0r BCMI_TSCE16_XGXS_WRITE_PKTGEN_PCS_SEEDA0r
#define MODIFY_PKTGEN_PCS_SEEDA0r BCMI_TSCE16_XGXS_MODIFY_PKTGEN_PCS_SEEDA0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PKTGEN_PCS_SEEDA1
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x9038
 * DESC:     10GBASE-R PCS 0023 test pattern seed A word bits 31:16
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SEEDA1           10GBASE-R PCS test pattern seed A bits 16-31, seedA1[15:0]
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA1r (0x00109038 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA1r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_PCS_SEEDA1.
 *
 */
typedef union BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA1r_s {
	uint32_t v[1];
	uint32_t pktgen_pcs_seeda1[1];
	uint32_t _pktgen_pcs_seeda1;
} BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA1r_t;

#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA1r_CLR(r) (r).pktgen_pcs_seeda1[0] = 0
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA1r_SET(r,d) (r).pktgen_pcs_seeda1[0] = d
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA1r_GET(r) (r).pktgen_pcs_seeda1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA1r_SEEDA1f_GET(r) (((r).pktgen_pcs_seeda1[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA1r_SEEDA1f_SET(r,f) (r).pktgen_pcs_seeda1[0]=(((r).pktgen_pcs_seeda1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_PCS_SEEDA1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PKTGEN_PCS_SEEDA1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA1r,(_r._pktgen_pcs_seeda1))
#define BCMI_TSCE16_XGXS_WRITE_PKTGEN_PCS_SEEDA1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA1r,(_r._pktgen_pcs_seeda1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PKTGEN_PCS_SEEDA1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA1r,(_r._pktgen_pcs_seeda1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_PCS_SEEDA1r BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA1r
#define PKTGEN_PCS_SEEDA1r_SIZE BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA1r_SIZE
typedef BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA1r_t PKTGEN_PCS_SEEDA1r_t;
#define PKTGEN_PCS_SEEDA1r_CLR BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA1r_CLR
#define PKTGEN_PCS_SEEDA1r_SET BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA1r_SET
#define PKTGEN_PCS_SEEDA1r_GET BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA1r_GET
#define PKTGEN_PCS_SEEDA1r_SEEDA1f_GET BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA1r_SEEDA1f_GET
#define PKTGEN_PCS_SEEDA1r_SEEDA1f_SET BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA1r_SEEDA1f_SET
#define READ_PKTGEN_PCS_SEEDA1r BCMI_TSCE16_XGXS_READ_PKTGEN_PCS_SEEDA1r
#define WRITE_PKTGEN_PCS_SEEDA1r BCMI_TSCE16_XGXS_WRITE_PKTGEN_PCS_SEEDA1r
#define MODIFY_PKTGEN_PCS_SEEDA1r BCMI_TSCE16_XGXS_MODIFY_PKTGEN_PCS_SEEDA1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PKTGEN_PCS_SEEDA2
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x9039
 * DESC:     10GBASE-R PCS 0024 test pattern seed A word bits 47:32
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SEEDA2           10GBASE-R PCS test pattern seed A bits 32-47, seedA2[15:0]
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA2r (0x00109039 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA2r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_PCS_SEEDA2.
 *
 */
typedef union BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA2r_s {
	uint32_t v[1];
	uint32_t pktgen_pcs_seeda2[1];
	uint32_t _pktgen_pcs_seeda2;
} BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA2r_t;

#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA2r_CLR(r) (r).pktgen_pcs_seeda2[0] = 0
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA2r_SET(r,d) (r).pktgen_pcs_seeda2[0] = d
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA2r_GET(r) (r).pktgen_pcs_seeda2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA2r_SEEDA2f_GET(r) (((r).pktgen_pcs_seeda2[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA2r_SEEDA2f_SET(r,f) (r).pktgen_pcs_seeda2[0]=(((r).pktgen_pcs_seeda2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_PCS_SEEDA2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PKTGEN_PCS_SEEDA2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA2r,(_r._pktgen_pcs_seeda2))
#define BCMI_TSCE16_XGXS_WRITE_PKTGEN_PCS_SEEDA2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA2r,(_r._pktgen_pcs_seeda2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PKTGEN_PCS_SEEDA2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA2r,(_r._pktgen_pcs_seeda2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_PCS_SEEDA2r BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA2r
#define PKTGEN_PCS_SEEDA2r_SIZE BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA2r_SIZE
typedef BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA2r_t PKTGEN_PCS_SEEDA2r_t;
#define PKTGEN_PCS_SEEDA2r_CLR BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA2r_CLR
#define PKTGEN_PCS_SEEDA2r_SET BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA2r_SET
#define PKTGEN_PCS_SEEDA2r_GET BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA2r_GET
#define PKTGEN_PCS_SEEDA2r_SEEDA2f_GET BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA2r_SEEDA2f_GET
#define PKTGEN_PCS_SEEDA2r_SEEDA2f_SET BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA2r_SEEDA2f_SET
#define READ_PKTGEN_PCS_SEEDA2r BCMI_TSCE16_XGXS_READ_PKTGEN_PCS_SEEDA2r
#define WRITE_PKTGEN_PCS_SEEDA2r BCMI_TSCE16_XGXS_WRITE_PKTGEN_PCS_SEEDA2r
#define MODIFY_PKTGEN_PCS_SEEDA2r BCMI_TSCE16_XGXS_MODIFY_PKTGEN_PCS_SEEDA2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PKTGEN_PCS_SEEDA3
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x903a
 * DESC:     10GBASE-R PCS 0025 test pattern seed A word bits 57:48
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SEEDA3           10GBASE-R PCS test pattern seed A bits 48-57, seedA3[9:0]
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA3r (0x0010903a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA3r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_PCS_SEEDA3.
 *
 */
typedef union BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA3r_s {
	uint32_t v[1];
	uint32_t pktgen_pcs_seeda3[1];
	uint32_t _pktgen_pcs_seeda3;
} BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA3r_t;

#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA3r_CLR(r) (r).pktgen_pcs_seeda3[0] = 0
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA3r_SET(r,d) (r).pktgen_pcs_seeda3[0] = d
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA3r_GET(r) (r).pktgen_pcs_seeda3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA3r_SEEDA3f_GET(r) (((r).pktgen_pcs_seeda3[0]) & 0x3ff)
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA3r_SEEDA3f_SET(r,f) (r).pktgen_pcs_seeda3[0]=(((r).pktgen_pcs_seeda3[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access PKTGEN_PCS_SEEDA3.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PKTGEN_PCS_SEEDA3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA3r,(_r._pktgen_pcs_seeda3))
#define BCMI_TSCE16_XGXS_WRITE_PKTGEN_PCS_SEEDA3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA3r,(_r._pktgen_pcs_seeda3)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PKTGEN_PCS_SEEDA3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA3r,(_r._pktgen_pcs_seeda3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_PCS_SEEDA3r BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA3r
#define PKTGEN_PCS_SEEDA3r_SIZE BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA3r_SIZE
typedef BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA3r_t PKTGEN_PCS_SEEDA3r_t;
#define PKTGEN_PCS_SEEDA3r_CLR BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA3r_CLR
#define PKTGEN_PCS_SEEDA3r_SET BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA3r_SET
#define PKTGEN_PCS_SEEDA3r_GET BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA3r_GET
#define PKTGEN_PCS_SEEDA3r_SEEDA3f_GET BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA3r_SEEDA3f_GET
#define PKTGEN_PCS_SEEDA3r_SEEDA3f_SET BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA3r_SEEDA3f_SET
#define READ_PKTGEN_PCS_SEEDA3r BCMI_TSCE16_XGXS_READ_PKTGEN_PCS_SEEDA3r
#define WRITE_PKTGEN_PCS_SEEDA3r BCMI_TSCE16_XGXS_WRITE_PKTGEN_PCS_SEEDA3r
#define MODIFY_PKTGEN_PCS_SEEDA3r BCMI_TSCE16_XGXS_MODIFY_PKTGEN_PCS_SEEDA3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDA3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PKTGEN_PCS_SEEDB0
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x903b
 * DESC:     10GBASE-R PCS 0026 test pattern seed B word bits 15:00
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SEEDB0           10GBASE-R PCS test pattern seed B bits 0-15, seedB0[15:0]
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB0r (0x0010903b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB0r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_PCS_SEEDB0.
 *
 */
typedef union BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB0r_s {
	uint32_t v[1];
	uint32_t pktgen_pcs_seedb0[1];
	uint32_t _pktgen_pcs_seedb0;
} BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB0r_t;

#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB0r_CLR(r) (r).pktgen_pcs_seedb0[0] = 0
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB0r_SET(r,d) (r).pktgen_pcs_seedb0[0] = d
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB0r_GET(r) (r).pktgen_pcs_seedb0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB0r_SEEDB0f_GET(r) (((r).pktgen_pcs_seedb0[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB0r_SEEDB0f_SET(r,f) (r).pktgen_pcs_seedb0[0]=(((r).pktgen_pcs_seedb0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_PCS_SEEDB0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PKTGEN_PCS_SEEDB0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB0r,(_r._pktgen_pcs_seedb0))
#define BCMI_TSCE16_XGXS_WRITE_PKTGEN_PCS_SEEDB0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB0r,(_r._pktgen_pcs_seedb0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PKTGEN_PCS_SEEDB0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB0r,(_r._pktgen_pcs_seedb0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_PCS_SEEDB0r BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB0r
#define PKTGEN_PCS_SEEDB0r_SIZE BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB0r_SIZE
typedef BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB0r_t PKTGEN_PCS_SEEDB0r_t;
#define PKTGEN_PCS_SEEDB0r_CLR BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB0r_CLR
#define PKTGEN_PCS_SEEDB0r_SET BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB0r_SET
#define PKTGEN_PCS_SEEDB0r_GET BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB0r_GET
#define PKTGEN_PCS_SEEDB0r_SEEDB0f_GET BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB0r_SEEDB0f_GET
#define PKTGEN_PCS_SEEDB0r_SEEDB0f_SET BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB0r_SEEDB0f_SET
#define READ_PKTGEN_PCS_SEEDB0r BCMI_TSCE16_XGXS_READ_PKTGEN_PCS_SEEDB0r
#define WRITE_PKTGEN_PCS_SEEDB0r BCMI_TSCE16_XGXS_WRITE_PKTGEN_PCS_SEEDB0r
#define MODIFY_PKTGEN_PCS_SEEDB0r BCMI_TSCE16_XGXS_MODIFY_PKTGEN_PCS_SEEDB0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PKTGEN_PCS_SEEDB1
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x903c
 * DESC:     10GBASE-R PCS 0027 test pattern seed B word bits 31:16
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SEEDB1           10GBASE-R PCS test pattern seed B bits 16-31, seedB1[15:0]
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB1r (0x0010903c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB1r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_PCS_SEEDB1.
 *
 */
typedef union BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB1r_s {
	uint32_t v[1];
	uint32_t pktgen_pcs_seedb1[1];
	uint32_t _pktgen_pcs_seedb1;
} BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB1r_t;

#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB1r_CLR(r) (r).pktgen_pcs_seedb1[0] = 0
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB1r_SET(r,d) (r).pktgen_pcs_seedb1[0] = d
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB1r_GET(r) (r).pktgen_pcs_seedb1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB1r_SEEDB1f_GET(r) (((r).pktgen_pcs_seedb1[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB1r_SEEDB1f_SET(r,f) (r).pktgen_pcs_seedb1[0]=(((r).pktgen_pcs_seedb1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_PCS_SEEDB1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PKTGEN_PCS_SEEDB1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB1r,(_r._pktgen_pcs_seedb1))
#define BCMI_TSCE16_XGXS_WRITE_PKTGEN_PCS_SEEDB1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB1r,(_r._pktgen_pcs_seedb1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PKTGEN_PCS_SEEDB1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB1r,(_r._pktgen_pcs_seedb1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_PCS_SEEDB1r BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB1r
#define PKTGEN_PCS_SEEDB1r_SIZE BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB1r_SIZE
typedef BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB1r_t PKTGEN_PCS_SEEDB1r_t;
#define PKTGEN_PCS_SEEDB1r_CLR BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB1r_CLR
#define PKTGEN_PCS_SEEDB1r_SET BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB1r_SET
#define PKTGEN_PCS_SEEDB1r_GET BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB1r_GET
#define PKTGEN_PCS_SEEDB1r_SEEDB1f_GET BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB1r_SEEDB1f_GET
#define PKTGEN_PCS_SEEDB1r_SEEDB1f_SET BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB1r_SEEDB1f_SET
#define READ_PKTGEN_PCS_SEEDB1r BCMI_TSCE16_XGXS_READ_PKTGEN_PCS_SEEDB1r
#define WRITE_PKTGEN_PCS_SEEDB1r BCMI_TSCE16_XGXS_WRITE_PKTGEN_PCS_SEEDB1r
#define MODIFY_PKTGEN_PCS_SEEDB1r BCMI_TSCE16_XGXS_MODIFY_PKTGEN_PCS_SEEDB1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PKTGEN_PCS_SEEDB2
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x903d
 * DESC:     10GBASE-R PCS 0028 test pattern seed B word bits 47:32
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SEEDB2           10GBASE-R PCS test pattern seed B bits 32-47, seedB2[15:0]
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB2r (0x0010903d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB2r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_PCS_SEEDB2.
 *
 */
typedef union BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB2r_s {
	uint32_t v[1];
	uint32_t pktgen_pcs_seedb2[1];
	uint32_t _pktgen_pcs_seedb2;
} BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB2r_t;

#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB2r_CLR(r) (r).pktgen_pcs_seedb2[0] = 0
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB2r_SET(r,d) (r).pktgen_pcs_seedb2[0] = d
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB2r_GET(r) (r).pktgen_pcs_seedb2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB2r_SEEDB2f_GET(r) (((r).pktgen_pcs_seedb2[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB2r_SEEDB2f_SET(r,f) (r).pktgen_pcs_seedb2[0]=(((r).pktgen_pcs_seedb2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_PCS_SEEDB2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PKTGEN_PCS_SEEDB2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB2r,(_r._pktgen_pcs_seedb2))
#define BCMI_TSCE16_XGXS_WRITE_PKTGEN_PCS_SEEDB2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB2r,(_r._pktgen_pcs_seedb2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PKTGEN_PCS_SEEDB2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB2r,(_r._pktgen_pcs_seedb2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_PCS_SEEDB2r BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB2r
#define PKTGEN_PCS_SEEDB2r_SIZE BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB2r_SIZE
typedef BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB2r_t PKTGEN_PCS_SEEDB2r_t;
#define PKTGEN_PCS_SEEDB2r_CLR BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB2r_CLR
#define PKTGEN_PCS_SEEDB2r_SET BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB2r_SET
#define PKTGEN_PCS_SEEDB2r_GET BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB2r_GET
#define PKTGEN_PCS_SEEDB2r_SEEDB2f_GET BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB2r_SEEDB2f_GET
#define PKTGEN_PCS_SEEDB2r_SEEDB2f_SET BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB2r_SEEDB2f_SET
#define READ_PKTGEN_PCS_SEEDB2r BCMI_TSCE16_XGXS_READ_PKTGEN_PCS_SEEDB2r
#define WRITE_PKTGEN_PCS_SEEDB2r BCMI_TSCE16_XGXS_WRITE_PKTGEN_PCS_SEEDB2r
#define MODIFY_PKTGEN_PCS_SEEDB2r BCMI_TSCE16_XGXS_MODIFY_PKTGEN_PCS_SEEDB2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PKTGEN_PCS_SEEDB3
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x903e
 * DESC:     10GBASE-R PCS 0029 test pattern seed B word bits 57:48
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SEEDB3           10GBASE-R PCS test pattern seed B bits 48-57, seedB3[9:0]
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB3r (0x0010903e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB3r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_PCS_SEEDB3.
 *
 */
typedef union BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB3r_s {
	uint32_t v[1];
	uint32_t pktgen_pcs_seedb3[1];
	uint32_t _pktgen_pcs_seedb3;
} BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB3r_t;

#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB3r_CLR(r) (r).pktgen_pcs_seedb3[0] = 0
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB3r_SET(r,d) (r).pktgen_pcs_seedb3[0] = d
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB3r_GET(r) (r).pktgen_pcs_seedb3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB3r_SEEDB3f_GET(r) (((r).pktgen_pcs_seedb3[0]) & 0x3ff)
#define BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB3r_SEEDB3f_SET(r,f) (r).pktgen_pcs_seedb3[0]=(((r).pktgen_pcs_seedb3[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access PKTGEN_PCS_SEEDB3.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PKTGEN_PCS_SEEDB3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB3r,(_r._pktgen_pcs_seedb3))
#define BCMI_TSCE16_XGXS_WRITE_PKTGEN_PCS_SEEDB3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB3r,(_r._pktgen_pcs_seedb3)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PKTGEN_PCS_SEEDB3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB3r,(_r._pktgen_pcs_seedb3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_PCS_SEEDB3r BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB3r
#define PKTGEN_PCS_SEEDB3r_SIZE BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB3r_SIZE
typedef BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB3r_t PKTGEN_PCS_SEEDB3r_t;
#define PKTGEN_PCS_SEEDB3r_CLR BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB3r_CLR
#define PKTGEN_PCS_SEEDB3r_SET BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB3r_SET
#define PKTGEN_PCS_SEEDB3r_GET BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB3r_GET
#define PKTGEN_PCS_SEEDB3r_SEEDB3f_GET BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB3r_SEEDB3f_GET
#define PKTGEN_PCS_SEEDB3r_SEEDB3f_SET BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB3r_SEEDB3f_SET
#define READ_PKTGEN_PCS_SEEDB3r BCMI_TSCE16_XGXS_READ_PKTGEN_PCS_SEEDB3r
#define WRITE_PKTGEN_PCS_SEEDB3r BCMI_TSCE16_XGXS_WRITE_PKTGEN_PCS_SEEDB3r
#define MODIFY_PKTGEN_PCS_SEEDB3r BCMI_TSCE16_XGXS_MODIFY_PKTGEN_PCS_SEEDB3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PKTGEN_PCS_SEEDB3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PKTGEN_PAYLOADBYTES
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x9040
 * DESC:     Repeated Payload Bytes
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BYTE0            repeated payload byte0
 *     BYTE1            repeated payload byte1
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PKTGEN_PAYLOADBYTESr (0x00109040 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PKTGEN_PAYLOADBYTESr_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_PAYLOADBYTES.
 *
 */
typedef union BCMI_TSCE16_XGXS_PKTGEN_PAYLOADBYTESr_s {
	uint32_t v[1];
	uint32_t pktgen_payloadbytes[1];
	uint32_t _pktgen_payloadbytes;
} BCMI_TSCE16_XGXS_PKTGEN_PAYLOADBYTESr_t;

#define BCMI_TSCE16_XGXS_PKTGEN_PAYLOADBYTESr_CLR(r) (r).pktgen_payloadbytes[0] = 0
#define BCMI_TSCE16_XGXS_PKTGEN_PAYLOADBYTESr_SET(r,d) (r).pktgen_payloadbytes[0] = d
#define BCMI_TSCE16_XGXS_PKTGEN_PAYLOADBYTESr_GET(r) (r).pktgen_payloadbytes[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PKTGEN_PAYLOADBYTESr_BYTE1f_GET(r) ((((r).pktgen_payloadbytes[0]) >> 8) & 0xff)
#define BCMI_TSCE16_XGXS_PKTGEN_PAYLOADBYTESr_BYTE1f_SET(r,f) (r).pktgen_payloadbytes[0]=(((r).pktgen_payloadbytes[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCE16_XGXS_PKTGEN_PAYLOADBYTESr_BYTE0f_GET(r) (((r).pktgen_payloadbytes[0]) & 0xff)
#define BCMI_TSCE16_XGXS_PKTGEN_PAYLOADBYTESr_BYTE0f_SET(r,f) (r).pktgen_payloadbytes[0]=(((r).pktgen_payloadbytes[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access PKTGEN_PAYLOADBYTES.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PKTGEN_PAYLOADBYTESr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PKTGEN_PAYLOADBYTESr,(_r._pktgen_payloadbytes))
#define BCMI_TSCE16_XGXS_WRITE_PKTGEN_PAYLOADBYTESr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_PAYLOADBYTESr,(_r._pktgen_payloadbytes)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PKTGEN_PAYLOADBYTESr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_PAYLOADBYTESr,(_r._pktgen_payloadbytes))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_PAYLOADBYTESr BCMI_TSCE16_XGXS_PKTGEN_PAYLOADBYTESr
#define PKTGEN_PAYLOADBYTESr_SIZE BCMI_TSCE16_XGXS_PKTGEN_PAYLOADBYTESr_SIZE
typedef BCMI_TSCE16_XGXS_PKTGEN_PAYLOADBYTESr_t PKTGEN_PAYLOADBYTESr_t;
#define PKTGEN_PAYLOADBYTESr_CLR BCMI_TSCE16_XGXS_PKTGEN_PAYLOADBYTESr_CLR
#define PKTGEN_PAYLOADBYTESr_SET BCMI_TSCE16_XGXS_PKTGEN_PAYLOADBYTESr_SET
#define PKTGEN_PAYLOADBYTESr_GET BCMI_TSCE16_XGXS_PKTGEN_PAYLOADBYTESr_GET
#define PKTGEN_PAYLOADBYTESr_BYTE1f_GET BCMI_TSCE16_XGXS_PKTGEN_PAYLOADBYTESr_BYTE1f_GET
#define PKTGEN_PAYLOADBYTESr_BYTE1f_SET BCMI_TSCE16_XGXS_PKTGEN_PAYLOADBYTESr_BYTE1f_SET
#define PKTGEN_PAYLOADBYTESr_BYTE0f_GET BCMI_TSCE16_XGXS_PKTGEN_PAYLOADBYTESr_BYTE0f_GET
#define PKTGEN_PAYLOADBYTESr_BYTE0f_SET BCMI_TSCE16_XGXS_PKTGEN_PAYLOADBYTESr_BYTE0f_SET
#define READ_PKTGEN_PAYLOADBYTESr BCMI_TSCE16_XGXS_READ_PKTGEN_PAYLOADBYTESr
#define WRITE_PKTGEN_PAYLOADBYTESr BCMI_TSCE16_XGXS_WRITE_PKTGEN_PAYLOADBYTESr
#define MODIFY_PKTGEN_PAYLOADBYTESr BCMI_TSCE16_XGXS_MODIFY_PKTGEN_PAYLOADBYTESr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PKTGEN_PAYLOADBYTESr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PKTGEN_ERRMASK4
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x9041
 * DESC:     Error mask bits 79:64
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERROR_MASK_79_64 Error Mask used to generate errors
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PKTGEN_ERRMASK4r (0x00109041 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PKTGEN_ERRMASK4r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_ERRMASK4.
 *
 */
typedef union BCMI_TSCE16_XGXS_PKTGEN_ERRMASK4r_s {
	uint32_t v[1];
	uint32_t pktgen_errmask4[1];
	uint32_t _pktgen_errmask4;
} BCMI_TSCE16_XGXS_PKTGEN_ERRMASK4r_t;

#define BCMI_TSCE16_XGXS_PKTGEN_ERRMASK4r_CLR(r) (r).pktgen_errmask4[0] = 0
#define BCMI_TSCE16_XGXS_PKTGEN_ERRMASK4r_SET(r,d) (r).pktgen_errmask4[0] = d
#define BCMI_TSCE16_XGXS_PKTGEN_ERRMASK4r_GET(r) (r).pktgen_errmask4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PKTGEN_ERRMASK4r_ERROR_MASK_79_64f_GET(r) (((r).pktgen_errmask4[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PKTGEN_ERRMASK4r_ERROR_MASK_79_64f_SET(r,f) (r).pktgen_errmask4[0]=(((r).pktgen_errmask4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_ERRMASK4.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PKTGEN_ERRMASK4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PKTGEN_ERRMASK4r,(_r._pktgen_errmask4))
#define BCMI_TSCE16_XGXS_WRITE_PKTGEN_ERRMASK4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_ERRMASK4r,(_r._pktgen_errmask4)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PKTGEN_ERRMASK4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_ERRMASK4r,(_r._pktgen_errmask4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_ERRMASK4r BCMI_TSCE16_XGXS_PKTGEN_ERRMASK4r
#define PKTGEN_ERRMASK4r_SIZE BCMI_TSCE16_XGXS_PKTGEN_ERRMASK4r_SIZE
typedef BCMI_TSCE16_XGXS_PKTGEN_ERRMASK4r_t PKTGEN_ERRMASK4r_t;
#define PKTGEN_ERRMASK4r_CLR BCMI_TSCE16_XGXS_PKTGEN_ERRMASK4r_CLR
#define PKTGEN_ERRMASK4r_SET BCMI_TSCE16_XGXS_PKTGEN_ERRMASK4r_SET
#define PKTGEN_ERRMASK4r_GET BCMI_TSCE16_XGXS_PKTGEN_ERRMASK4r_GET
#define PKTGEN_ERRMASK4r_ERROR_MASK_79_64f_GET BCMI_TSCE16_XGXS_PKTGEN_ERRMASK4r_ERROR_MASK_79_64f_GET
#define PKTGEN_ERRMASK4r_ERROR_MASK_79_64f_SET BCMI_TSCE16_XGXS_PKTGEN_ERRMASK4r_ERROR_MASK_79_64f_SET
#define READ_PKTGEN_ERRMASK4r BCMI_TSCE16_XGXS_READ_PKTGEN_ERRMASK4r
#define WRITE_PKTGEN_ERRMASK4r BCMI_TSCE16_XGXS_WRITE_PKTGEN_ERRMASK4r
#define MODIFY_PKTGEN_ERRMASK4r BCMI_TSCE16_XGXS_MODIFY_PKTGEN_ERRMASK4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PKTGEN_ERRMASK4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PKTGEN_ERRMASK3
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x9042
 * DESC:     Error mask bits 63:48
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERROR_MASK_63_48 Error Mask used to generate errors
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PKTGEN_ERRMASK3r (0x00109042 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PKTGEN_ERRMASK3r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_ERRMASK3.
 *
 */
typedef union BCMI_TSCE16_XGXS_PKTGEN_ERRMASK3r_s {
	uint32_t v[1];
	uint32_t pktgen_errmask3[1];
	uint32_t _pktgen_errmask3;
} BCMI_TSCE16_XGXS_PKTGEN_ERRMASK3r_t;

#define BCMI_TSCE16_XGXS_PKTGEN_ERRMASK3r_CLR(r) (r).pktgen_errmask3[0] = 0
#define BCMI_TSCE16_XGXS_PKTGEN_ERRMASK3r_SET(r,d) (r).pktgen_errmask3[0] = d
#define BCMI_TSCE16_XGXS_PKTGEN_ERRMASK3r_GET(r) (r).pktgen_errmask3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PKTGEN_ERRMASK3r_ERROR_MASK_63_48f_GET(r) (((r).pktgen_errmask3[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PKTGEN_ERRMASK3r_ERROR_MASK_63_48f_SET(r,f) (r).pktgen_errmask3[0]=(((r).pktgen_errmask3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_ERRMASK3.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PKTGEN_ERRMASK3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PKTGEN_ERRMASK3r,(_r._pktgen_errmask3))
#define BCMI_TSCE16_XGXS_WRITE_PKTGEN_ERRMASK3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_ERRMASK3r,(_r._pktgen_errmask3)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PKTGEN_ERRMASK3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_ERRMASK3r,(_r._pktgen_errmask3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_ERRMASK3r BCMI_TSCE16_XGXS_PKTGEN_ERRMASK3r
#define PKTGEN_ERRMASK3r_SIZE BCMI_TSCE16_XGXS_PKTGEN_ERRMASK3r_SIZE
typedef BCMI_TSCE16_XGXS_PKTGEN_ERRMASK3r_t PKTGEN_ERRMASK3r_t;
#define PKTGEN_ERRMASK3r_CLR BCMI_TSCE16_XGXS_PKTGEN_ERRMASK3r_CLR
#define PKTGEN_ERRMASK3r_SET BCMI_TSCE16_XGXS_PKTGEN_ERRMASK3r_SET
#define PKTGEN_ERRMASK3r_GET BCMI_TSCE16_XGXS_PKTGEN_ERRMASK3r_GET
#define PKTGEN_ERRMASK3r_ERROR_MASK_63_48f_GET BCMI_TSCE16_XGXS_PKTGEN_ERRMASK3r_ERROR_MASK_63_48f_GET
#define PKTGEN_ERRMASK3r_ERROR_MASK_63_48f_SET BCMI_TSCE16_XGXS_PKTGEN_ERRMASK3r_ERROR_MASK_63_48f_SET
#define READ_PKTGEN_ERRMASK3r BCMI_TSCE16_XGXS_READ_PKTGEN_ERRMASK3r
#define WRITE_PKTGEN_ERRMASK3r BCMI_TSCE16_XGXS_WRITE_PKTGEN_ERRMASK3r
#define MODIFY_PKTGEN_ERRMASK3r BCMI_TSCE16_XGXS_MODIFY_PKTGEN_ERRMASK3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PKTGEN_ERRMASK3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PKTGEN_ERRMASK2
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x9043
 * DESC:     Error mask bits 47:32
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERROR_MASK_47_32 Error Mask used to generate errors
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PKTGEN_ERRMASK2r (0x00109043 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PKTGEN_ERRMASK2r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_ERRMASK2.
 *
 */
typedef union BCMI_TSCE16_XGXS_PKTGEN_ERRMASK2r_s {
	uint32_t v[1];
	uint32_t pktgen_errmask2[1];
	uint32_t _pktgen_errmask2;
} BCMI_TSCE16_XGXS_PKTGEN_ERRMASK2r_t;

#define BCMI_TSCE16_XGXS_PKTGEN_ERRMASK2r_CLR(r) (r).pktgen_errmask2[0] = 0
#define BCMI_TSCE16_XGXS_PKTGEN_ERRMASK2r_SET(r,d) (r).pktgen_errmask2[0] = d
#define BCMI_TSCE16_XGXS_PKTGEN_ERRMASK2r_GET(r) (r).pktgen_errmask2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PKTGEN_ERRMASK2r_ERROR_MASK_47_32f_GET(r) (((r).pktgen_errmask2[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PKTGEN_ERRMASK2r_ERROR_MASK_47_32f_SET(r,f) (r).pktgen_errmask2[0]=(((r).pktgen_errmask2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_ERRMASK2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PKTGEN_ERRMASK2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PKTGEN_ERRMASK2r,(_r._pktgen_errmask2))
#define BCMI_TSCE16_XGXS_WRITE_PKTGEN_ERRMASK2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_ERRMASK2r,(_r._pktgen_errmask2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PKTGEN_ERRMASK2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_ERRMASK2r,(_r._pktgen_errmask2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_ERRMASK2r BCMI_TSCE16_XGXS_PKTGEN_ERRMASK2r
#define PKTGEN_ERRMASK2r_SIZE BCMI_TSCE16_XGXS_PKTGEN_ERRMASK2r_SIZE
typedef BCMI_TSCE16_XGXS_PKTGEN_ERRMASK2r_t PKTGEN_ERRMASK2r_t;
#define PKTGEN_ERRMASK2r_CLR BCMI_TSCE16_XGXS_PKTGEN_ERRMASK2r_CLR
#define PKTGEN_ERRMASK2r_SET BCMI_TSCE16_XGXS_PKTGEN_ERRMASK2r_SET
#define PKTGEN_ERRMASK2r_GET BCMI_TSCE16_XGXS_PKTGEN_ERRMASK2r_GET
#define PKTGEN_ERRMASK2r_ERROR_MASK_47_32f_GET BCMI_TSCE16_XGXS_PKTGEN_ERRMASK2r_ERROR_MASK_47_32f_GET
#define PKTGEN_ERRMASK2r_ERROR_MASK_47_32f_SET BCMI_TSCE16_XGXS_PKTGEN_ERRMASK2r_ERROR_MASK_47_32f_SET
#define READ_PKTGEN_ERRMASK2r BCMI_TSCE16_XGXS_READ_PKTGEN_ERRMASK2r
#define WRITE_PKTGEN_ERRMASK2r BCMI_TSCE16_XGXS_WRITE_PKTGEN_ERRMASK2r
#define MODIFY_PKTGEN_ERRMASK2r BCMI_TSCE16_XGXS_MODIFY_PKTGEN_ERRMASK2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PKTGEN_ERRMASK2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PKTGEN_ERRMASK1
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x9044
 * DESC:     Error mask bits 31:16
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERROR_MASK_31_16 Error Mask used to generate errors
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PKTGEN_ERRMASK1r (0x00109044 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PKTGEN_ERRMASK1r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_ERRMASK1.
 *
 */
typedef union BCMI_TSCE16_XGXS_PKTGEN_ERRMASK1r_s {
	uint32_t v[1];
	uint32_t pktgen_errmask1[1];
	uint32_t _pktgen_errmask1;
} BCMI_TSCE16_XGXS_PKTGEN_ERRMASK1r_t;

#define BCMI_TSCE16_XGXS_PKTGEN_ERRMASK1r_CLR(r) (r).pktgen_errmask1[0] = 0
#define BCMI_TSCE16_XGXS_PKTGEN_ERRMASK1r_SET(r,d) (r).pktgen_errmask1[0] = d
#define BCMI_TSCE16_XGXS_PKTGEN_ERRMASK1r_GET(r) (r).pktgen_errmask1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PKTGEN_ERRMASK1r_ERROR_MASK_31_16f_GET(r) (((r).pktgen_errmask1[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PKTGEN_ERRMASK1r_ERROR_MASK_31_16f_SET(r,f) (r).pktgen_errmask1[0]=(((r).pktgen_errmask1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_ERRMASK1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PKTGEN_ERRMASK1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PKTGEN_ERRMASK1r,(_r._pktgen_errmask1))
#define BCMI_TSCE16_XGXS_WRITE_PKTGEN_ERRMASK1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_ERRMASK1r,(_r._pktgen_errmask1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PKTGEN_ERRMASK1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_ERRMASK1r,(_r._pktgen_errmask1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_ERRMASK1r BCMI_TSCE16_XGXS_PKTGEN_ERRMASK1r
#define PKTGEN_ERRMASK1r_SIZE BCMI_TSCE16_XGXS_PKTGEN_ERRMASK1r_SIZE
typedef BCMI_TSCE16_XGXS_PKTGEN_ERRMASK1r_t PKTGEN_ERRMASK1r_t;
#define PKTGEN_ERRMASK1r_CLR BCMI_TSCE16_XGXS_PKTGEN_ERRMASK1r_CLR
#define PKTGEN_ERRMASK1r_SET BCMI_TSCE16_XGXS_PKTGEN_ERRMASK1r_SET
#define PKTGEN_ERRMASK1r_GET BCMI_TSCE16_XGXS_PKTGEN_ERRMASK1r_GET
#define PKTGEN_ERRMASK1r_ERROR_MASK_31_16f_GET BCMI_TSCE16_XGXS_PKTGEN_ERRMASK1r_ERROR_MASK_31_16f_GET
#define PKTGEN_ERRMASK1r_ERROR_MASK_31_16f_SET BCMI_TSCE16_XGXS_PKTGEN_ERRMASK1r_ERROR_MASK_31_16f_SET
#define READ_PKTGEN_ERRMASK1r BCMI_TSCE16_XGXS_READ_PKTGEN_ERRMASK1r
#define WRITE_PKTGEN_ERRMASK1r BCMI_TSCE16_XGXS_WRITE_PKTGEN_ERRMASK1r
#define MODIFY_PKTGEN_ERRMASK1r BCMI_TSCE16_XGXS_MODIFY_PKTGEN_ERRMASK1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PKTGEN_ERRMASK1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PKTGEN_ERRMASK0
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x9045
 * DESC:     Error mask bits 15:0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERROR_MASK_15_0  Error Mask used to generate errors
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PKTGEN_ERRMASK0r (0x00109045 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PKTGEN_ERRMASK0r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_ERRMASK0.
 *
 */
typedef union BCMI_TSCE16_XGXS_PKTGEN_ERRMASK0r_s {
	uint32_t v[1];
	uint32_t pktgen_errmask0[1];
	uint32_t _pktgen_errmask0;
} BCMI_TSCE16_XGXS_PKTGEN_ERRMASK0r_t;

#define BCMI_TSCE16_XGXS_PKTGEN_ERRMASK0r_CLR(r) (r).pktgen_errmask0[0] = 0
#define BCMI_TSCE16_XGXS_PKTGEN_ERRMASK0r_SET(r,d) (r).pktgen_errmask0[0] = d
#define BCMI_TSCE16_XGXS_PKTGEN_ERRMASK0r_GET(r) (r).pktgen_errmask0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PKTGEN_ERRMASK0r_ERROR_MASK_15_0f_GET(r) (((r).pktgen_errmask0[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PKTGEN_ERRMASK0r_ERROR_MASK_15_0f_SET(r,f) (r).pktgen_errmask0[0]=(((r).pktgen_errmask0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_ERRMASK0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PKTGEN_ERRMASK0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PKTGEN_ERRMASK0r,(_r._pktgen_errmask0))
#define BCMI_TSCE16_XGXS_WRITE_PKTGEN_ERRMASK0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_ERRMASK0r,(_r._pktgen_errmask0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PKTGEN_ERRMASK0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PKTGEN_ERRMASK0r,(_r._pktgen_errmask0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_ERRMASK0r BCMI_TSCE16_XGXS_PKTGEN_ERRMASK0r
#define PKTGEN_ERRMASK0r_SIZE BCMI_TSCE16_XGXS_PKTGEN_ERRMASK0r_SIZE
typedef BCMI_TSCE16_XGXS_PKTGEN_ERRMASK0r_t PKTGEN_ERRMASK0r_t;
#define PKTGEN_ERRMASK0r_CLR BCMI_TSCE16_XGXS_PKTGEN_ERRMASK0r_CLR
#define PKTGEN_ERRMASK0r_SET BCMI_TSCE16_XGXS_PKTGEN_ERRMASK0r_SET
#define PKTGEN_ERRMASK0r_GET BCMI_TSCE16_XGXS_PKTGEN_ERRMASK0r_GET
#define PKTGEN_ERRMASK0r_ERROR_MASK_15_0f_GET BCMI_TSCE16_XGXS_PKTGEN_ERRMASK0r_ERROR_MASK_15_0f_GET
#define PKTGEN_ERRMASK0r_ERROR_MASK_15_0f_SET BCMI_TSCE16_XGXS_PKTGEN_ERRMASK0r_ERROR_MASK_15_0f_SET
#define READ_PKTGEN_ERRMASK0r BCMI_TSCE16_XGXS_READ_PKTGEN_ERRMASK0r
#define WRITE_PKTGEN_ERRMASK0r BCMI_TSCE16_XGXS_WRITE_PKTGEN_ERRMASK0r
#define MODIFY_PKTGEN_ERRMASK0r BCMI_TSCE16_XGXS_MODIFY_PKTGEN_ERRMASK0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PKTGEN_ERRMASK0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  MEM_ECC_ECC_INT_1BIT
 * BLOCKS:   MEM_ECC
 * REGADDR:  0x9050
 * DESC:     1-bit ecc error interrupt register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     INT_1B           Single bit, correctable error detected, one bit per memorybit 0 is for deskew memorybit 1 is for rfec0 memorybit 2 is for rfec1 memorybit 3 reserved/unused
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_1BITr (0x00109050 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_1BITr_SIZE 4

/*
 * This structure should be used to declare and program MEM_ECC_ECC_INT_1BIT.
 *
 */
typedef union BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_1BITr_s {
	uint32_t v[1];
	uint32_t mem_ecc_ecc_int_1bit[1];
	uint32_t _mem_ecc_ecc_int_1bit;
} BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_1BITr_t;

#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_1BITr_CLR(r) (r).mem_ecc_ecc_int_1bit[0] = 0
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_1BITr_SET(r,d) (r).mem_ecc_ecc_int_1bit[0] = d
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_1BITr_GET(r) (r).mem_ecc_ecc_int_1bit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_1BITr_INT_1Bf_GET(r) (((r).mem_ecc_ecc_int_1bit[0]) & 0xf)
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_1BITr_INT_1Bf_SET(r,f) (r).mem_ecc_ecc_int_1bit[0]=(((r).mem_ecc_ecc_int_1bit[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access MEM_ECC_ECC_INT_1BIT.
 *
 */
#define BCMI_TSCE16_XGXS_READ_MEM_ECC_ECC_INT_1BITr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_1BITr,(_r._mem_ecc_ecc_int_1bit))
#define BCMI_TSCE16_XGXS_WRITE_MEM_ECC_ECC_INT_1BITr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_1BITr,(_r._mem_ecc_ecc_int_1bit)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_MEM_ECC_ECC_INT_1BITr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_1BITr,(_r._mem_ecc_ecc_int_1bit))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MEM_ECC_ECC_INT_1BITr BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_1BITr
#define MEM_ECC_ECC_INT_1BITr_SIZE BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_1BITr_SIZE
typedef BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_1BITr_t MEM_ECC_ECC_INT_1BITr_t;
#define MEM_ECC_ECC_INT_1BITr_CLR BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_1BITr_CLR
#define MEM_ECC_ECC_INT_1BITr_SET BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_1BITr_SET
#define MEM_ECC_ECC_INT_1BITr_GET BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_1BITr_GET
#define MEM_ECC_ECC_INT_1BITr_INT_1Bf_GET BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_1BITr_INT_1Bf_GET
#define MEM_ECC_ECC_INT_1BITr_INT_1Bf_SET BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_1BITr_INT_1Bf_SET
#define READ_MEM_ECC_ECC_INT_1BITr BCMI_TSCE16_XGXS_READ_MEM_ECC_ECC_INT_1BITr
#define WRITE_MEM_ECC_ECC_INT_1BITr BCMI_TSCE16_XGXS_WRITE_MEM_ECC_ECC_INT_1BITr
#define MODIFY_MEM_ECC_ECC_INT_1BITr BCMI_TSCE16_XGXS_MODIFY_MEM_ECC_ECC_INT_1BITr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_1BITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  MEM_ECC_ECC_INT_2BIT
 * BLOCKS:   MEM_ECC
 * REGADDR:  0x9051
 * DESC:     2-bit ecc error interrupt register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     INT_2B           Two bit, uncorrectable error detected, one bit per memorybit 0 is for deskew memory
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_2BITr (0x00109051 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_2BITr_SIZE 4

/*
 * This structure should be used to declare and program MEM_ECC_ECC_INT_2BIT.
 *
 */
typedef union BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_2BITr_s {
	uint32_t v[1];
	uint32_t mem_ecc_ecc_int_2bit[1];
	uint32_t _mem_ecc_ecc_int_2bit;
} BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_2BITr_t;

#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_2BITr_CLR(r) (r).mem_ecc_ecc_int_2bit[0] = 0
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_2BITr_SET(r,d) (r).mem_ecc_ecc_int_2bit[0] = d
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_2BITr_GET(r) (r).mem_ecc_ecc_int_2bit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_2BITr_INT_2Bf_GET(r) (((r).mem_ecc_ecc_int_2bit[0]) & 0xf)
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_2BITr_INT_2Bf_SET(r,f) (r).mem_ecc_ecc_int_2bit[0]=(((r).mem_ecc_ecc_int_2bit[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access MEM_ECC_ECC_INT_2BIT.
 *
 */
#define BCMI_TSCE16_XGXS_READ_MEM_ECC_ECC_INT_2BITr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_2BITr,(_r._mem_ecc_ecc_int_2bit))
#define BCMI_TSCE16_XGXS_WRITE_MEM_ECC_ECC_INT_2BITr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_2BITr,(_r._mem_ecc_ecc_int_2bit)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_MEM_ECC_ECC_INT_2BITr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_2BITr,(_r._mem_ecc_ecc_int_2bit))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MEM_ECC_ECC_INT_2BITr BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_2BITr
#define MEM_ECC_ECC_INT_2BITr_SIZE BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_2BITr_SIZE
typedef BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_2BITr_t MEM_ECC_ECC_INT_2BITr_t;
#define MEM_ECC_ECC_INT_2BITr_CLR BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_2BITr_CLR
#define MEM_ECC_ECC_INT_2BITr_SET BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_2BITr_SET
#define MEM_ECC_ECC_INT_2BITr_GET BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_2BITr_GET
#define MEM_ECC_ECC_INT_2BITr_INT_2Bf_GET BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_2BITr_INT_2Bf_GET
#define MEM_ECC_ECC_INT_2BITr_INT_2Bf_SET BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_2BITr_INT_2Bf_SET
#define READ_MEM_ECC_ECC_INT_2BITr BCMI_TSCE16_XGXS_READ_MEM_ECC_ECC_INT_2BITr
#define WRITE_MEM_ECC_ECC_INT_2BITr BCMI_TSCE16_XGXS_WRITE_MEM_ECC_ECC_INT_2BITr
#define MODIFY_MEM_ECC_ECC_INT_2BITr BCMI_TSCE16_XGXS_MODIFY_MEM_ECC_ECC_INT_2BITr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_MEM_ECC_ECC_INT_2BITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  MEM_ECC_ECC_MSK_1BIT
 * BLOCKS:   MEM_ECC
 * REGADDR:  0x9052
 * DESC:     1-bit ecc error interrupt enable register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MSK_1B           Enable for correctable error interrupt, one bit per memoryWrite 1 to enable the interruptbit 0 is for deskew memory
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_1BITr (0x00109052 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_1BITr_SIZE 4

/*
 * This structure should be used to declare and program MEM_ECC_ECC_MSK_1BIT.
 *
 */
typedef union BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_1BITr_s {
	uint32_t v[1];
	uint32_t mem_ecc_ecc_msk_1bit[1];
	uint32_t _mem_ecc_ecc_msk_1bit;
} BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_1BITr_t;

#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_1BITr_CLR(r) (r).mem_ecc_ecc_msk_1bit[0] = 0
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_1BITr_SET(r,d) (r).mem_ecc_ecc_msk_1bit[0] = d
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_1BITr_GET(r) (r).mem_ecc_ecc_msk_1bit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_1BITr_MSK_1Bf_GET(r) (((r).mem_ecc_ecc_msk_1bit[0]) & 0xf)
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_1BITr_MSK_1Bf_SET(r,f) (r).mem_ecc_ecc_msk_1bit[0]=(((r).mem_ecc_ecc_msk_1bit[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access MEM_ECC_ECC_MSK_1BIT.
 *
 */
#define BCMI_TSCE16_XGXS_READ_MEM_ECC_ECC_MSK_1BITr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_1BITr,(_r._mem_ecc_ecc_msk_1bit))
#define BCMI_TSCE16_XGXS_WRITE_MEM_ECC_ECC_MSK_1BITr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_1BITr,(_r._mem_ecc_ecc_msk_1bit)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_MEM_ECC_ECC_MSK_1BITr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_1BITr,(_r._mem_ecc_ecc_msk_1bit))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MEM_ECC_ECC_MSK_1BITr BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_1BITr
#define MEM_ECC_ECC_MSK_1BITr_SIZE BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_1BITr_SIZE
typedef BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_1BITr_t MEM_ECC_ECC_MSK_1BITr_t;
#define MEM_ECC_ECC_MSK_1BITr_CLR BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_1BITr_CLR
#define MEM_ECC_ECC_MSK_1BITr_SET BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_1BITr_SET
#define MEM_ECC_ECC_MSK_1BITr_GET BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_1BITr_GET
#define MEM_ECC_ECC_MSK_1BITr_MSK_1Bf_GET BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_1BITr_MSK_1Bf_GET
#define MEM_ECC_ECC_MSK_1BITr_MSK_1Bf_SET BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_1BITr_MSK_1Bf_SET
#define READ_MEM_ECC_ECC_MSK_1BITr BCMI_TSCE16_XGXS_READ_MEM_ECC_ECC_MSK_1BITr
#define WRITE_MEM_ECC_ECC_MSK_1BITr BCMI_TSCE16_XGXS_WRITE_MEM_ECC_ECC_MSK_1BITr
#define MODIFY_MEM_ECC_ECC_MSK_1BITr BCMI_TSCE16_XGXS_MODIFY_MEM_ECC_ECC_MSK_1BITr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_1BITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  MEM_ECC_ECC_MSK_2BIT
 * BLOCKS:   MEM_ECC
 * REGADDR:  0x9053
 * DESC:     2-bit ecc error interrupt enable register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MSK_2B           Enable for uncorrectable error interrupt, one bit per memoryWrite 1 to enable the interruptbit 0 is for deskew memory
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_2BITr (0x00109053 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_2BITr_SIZE 4

/*
 * This structure should be used to declare and program MEM_ECC_ECC_MSK_2BIT.
 *
 */
typedef union BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_2BITr_s {
	uint32_t v[1];
	uint32_t mem_ecc_ecc_msk_2bit[1];
	uint32_t _mem_ecc_ecc_msk_2bit;
} BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_2BITr_t;

#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_2BITr_CLR(r) (r).mem_ecc_ecc_msk_2bit[0] = 0
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_2BITr_SET(r,d) (r).mem_ecc_ecc_msk_2bit[0] = d
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_2BITr_GET(r) (r).mem_ecc_ecc_msk_2bit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_2BITr_MSK_2Bf_GET(r) (((r).mem_ecc_ecc_msk_2bit[0]) & 0xf)
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_2BITr_MSK_2Bf_SET(r,f) (r).mem_ecc_ecc_msk_2bit[0]=(((r).mem_ecc_ecc_msk_2bit[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access MEM_ECC_ECC_MSK_2BIT.
 *
 */
#define BCMI_TSCE16_XGXS_READ_MEM_ECC_ECC_MSK_2BITr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_2BITr,(_r._mem_ecc_ecc_msk_2bit))
#define BCMI_TSCE16_XGXS_WRITE_MEM_ECC_ECC_MSK_2BITr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_2BITr,(_r._mem_ecc_ecc_msk_2bit)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_MEM_ECC_ECC_MSK_2BITr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_2BITr,(_r._mem_ecc_ecc_msk_2bit))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MEM_ECC_ECC_MSK_2BITr BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_2BITr
#define MEM_ECC_ECC_MSK_2BITr_SIZE BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_2BITr_SIZE
typedef BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_2BITr_t MEM_ECC_ECC_MSK_2BITr_t;
#define MEM_ECC_ECC_MSK_2BITr_CLR BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_2BITr_CLR
#define MEM_ECC_ECC_MSK_2BITr_SET BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_2BITr_SET
#define MEM_ECC_ECC_MSK_2BITr_GET BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_2BITr_GET
#define MEM_ECC_ECC_MSK_2BITr_MSK_2Bf_GET BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_2BITr_MSK_2Bf_GET
#define MEM_ECC_ECC_MSK_2BITr_MSK_2Bf_SET BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_2BITr_MSK_2Bf_SET
#define READ_MEM_ECC_ECC_MSK_2BITr BCMI_TSCE16_XGXS_READ_MEM_ECC_ECC_MSK_2BITr
#define WRITE_MEM_ECC_ECC_MSK_2BITr BCMI_TSCE16_XGXS_WRITE_MEM_ECC_ECC_MSK_2BITr
#define MODIFY_MEM_ECC_ECC_MSK_2BITr BCMI_TSCE16_XGXS_MODIFY_MEM_ECC_ECC_MSK_2BITr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_MEM_ECC_ECC_MSK_2BITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  MEM_ECC_ECC_DIS
 * BLOCKS:   MEM_ECC
 * REGADDR:  0x9054
 * DESC:     Disable ECC check and generation
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DESKEW_DISABLE_ECC disable ECC check/generation
 *     RFEC0_DISABLE_ECC disable ECC check/generation
 *     RFEC1_DISABLE_ECC disable ECC check/generation
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_DISr (0x00109054 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_DISr_SIZE 4

/*
 * This structure should be used to declare and program MEM_ECC_ECC_DIS.
 *
 */
typedef union BCMI_TSCE16_XGXS_MEM_ECC_ECC_DISr_s {
	uint32_t v[1];
	uint32_t mem_ecc_ecc_dis[1];
	uint32_t _mem_ecc_ecc_dis;
} BCMI_TSCE16_XGXS_MEM_ECC_ECC_DISr_t;

#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_DISr_CLR(r) (r).mem_ecc_ecc_dis[0] = 0
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_DISr_SET(r,d) (r).mem_ecc_ecc_dis[0] = d
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_DISr_GET(r) (r).mem_ecc_ecc_dis[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_DISr_RFEC1_DISABLE_ECCf_GET(r) ((((r).mem_ecc_ecc_dis[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_DISr_RFEC1_DISABLE_ECCf_SET(r,f) (r).mem_ecc_ecc_dis[0]=(((r).mem_ecc_ecc_dis[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_DISr_RFEC0_DISABLE_ECCf_GET(r) ((((r).mem_ecc_ecc_dis[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_DISr_RFEC0_DISABLE_ECCf_SET(r,f) (r).mem_ecc_ecc_dis[0]=(((r).mem_ecc_ecc_dis[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_DISr_DESKEW_DISABLE_ECCf_GET(r) (((r).mem_ecc_ecc_dis[0]) & 0x1)
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_DISr_DESKEW_DISABLE_ECCf_SET(r,f) (r).mem_ecc_ecc_dis[0]=(((r).mem_ecc_ecc_dis[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MEM_ECC_ECC_DIS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_MEM_ECC_ECC_DISr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MEM_ECC_ECC_DISr,(_r._mem_ecc_ecc_dis))
#define BCMI_TSCE16_XGXS_WRITE_MEM_ECC_ECC_DISr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MEM_ECC_ECC_DISr,(_r._mem_ecc_ecc_dis)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_MEM_ECC_ECC_DISr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MEM_ECC_ECC_DISr,(_r._mem_ecc_ecc_dis))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MEM_ECC_ECC_DISr BCMI_TSCE16_XGXS_MEM_ECC_ECC_DISr
#define MEM_ECC_ECC_DISr_SIZE BCMI_TSCE16_XGXS_MEM_ECC_ECC_DISr_SIZE
typedef BCMI_TSCE16_XGXS_MEM_ECC_ECC_DISr_t MEM_ECC_ECC_DISr_t;
#define MEM_ECC_ECC_DISr_CLR BCMI_TSCE16_XGXS_MEM_ECC_ECC_DISr_CLR
#define MEM_ECC_ECC_DISr_SET BCMI_TSCE16_XGXS_MEM_ECC_ECC_DISr_SET
#define MEM_ECC_ECC_DISr_GET BCMI_TSCE16_XGXS_MEM_ECC_ECC_DISr_GET
#define MEM_ECC_ECC_DISr_RFEC1_DISABLE_ECCf_GET BCMI_TSCE16_XGXS_MEM_ECC_ECC_DISr_RFEC1_DISABLE_ECCf_GET
#define MEM_ECC_ECC_DISr_RFEC1_DISABLE_ECCf_SET BCMI_TSCE16_XGXS_MEM_ECC_ECC_DISr_RFEC1_DISABLE_ECCf_SET
#define MEM_ECC_ECC_DISr_RFEC0_DISABLE_ECCf_GET BCMI_TSCE16_XGXS_MEM_ECC_ECC_DISr_RFEC0_DISABLE_ECCf_GET
#define MEM_ECC_ECC_DISr_RFEC0_DISABLE_ECCf_SET BCMI_TSCE16_XGXS_MEM_ECC_ECC_DISr_RFEC0_DISABLE_ECCf_SET
#define MEM_ECC_ECC_DISr_DESKEW_DISABLE_ECCf_GET BCMI_TSCE16_XGXS_MEM_ECC_ECC_DISr_DESKEW_DISABLE_ECCf_GET
#define MEM_ECC_ECC_DISr_DESKEW_DISABLE_ECCf_SET BCMI_TSCE16_XGXS_MEM_ECC_ECC_DISr_DESKEW_DISABLE_ECCf_SET
#define READ_MEM_ECC_ECC_DISr BCMI_TSCE16_XGXS_READ_MEM_ECC_ECC_DISr
#define WRITE_MEM_ECC_ECC_DISr BCMI_TSCE16_XGXS_WRITE_MEM_ECC_ECC_DISr
#define MODIFY_MEM_ECC_ECC_DISr BCMI_TSCE16_XGXS_MODIFY_MEM_ECC_ECC_DISr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_MEM_ECC_ECC_DISr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  MEM_ECC_ECC_CORRUPT
 * BLOCKS:   MEM_ECC
 * REGADDR:  0x9055
 * DESC:     inject ECC errors
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DESKEW_ECC_CORRUPT ECC error injectionWrite b01 for 2-bit error on write dataWrite b10 for 1-bit error on read dataWrite b11 for 2-bit error on read data
 *     RFEC0_ECC_CORRUPT ECC error injectionWrite b01 for 2-bit error on write dataWrite b10 for 1-bit error on read dataWrite b11 for 2-bit error on read data
 *     RFEC1_ECC_CORRUPT ECC error injectionWrite b01 for 2-bit error on write dataWrite b10 for 1-bit error on read dataWrite b11 for 2-bit error on read data
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_CORRUPTr (0x00109055 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_CORRUPTr_SIZE 4

/*
 * This structure should be used to declare and program MEM_ECC_ECC_CORRUPT.
 *
 */
typedef union BCMI_TSCE16_XGXS_MEM_ECC_ECC_CORRUPTr_s {
	uint32_t v[1];
	uint32_t mem_ecc_ecc_corrupt[1];
	uint32_t _mem_ecc_ecc_corrupt;
} BCMI_TSCE16_XGXS_MEM_ECC_ECC_CORRUPTr_t;

#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_CORRUPTr_CLR(r) (r).mem_ecc_ecc_corrupt[0] = 0
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_CORRUPTr_SET(r,d) (r).mem_ecc_ecc_corrupt[0] = d
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_CORRUPTr_GET(r) (r).mem_ecc_ecc_corrupt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_CORRUPTr_RFEC1_ECC_CORRUPTf_GET(r) ((((r).mem_ecc_ecc_corrupt[0]) >> 4) & 0x3)
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_CORRUPTr_RFEC1_ECC_CORRUPTf_SET(r,f) (r).mem_ecc_ecc_corrupt[0]=(((r).mem_ecc_ecc_corrupt[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_CORRUPTr_RFEC0_ECC_CORRUPTf_GET(r) ((((r).mem_ecc_ecc_corrupt[0]) >> 2) & 0x3)
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_CORRUPTr_RFEC0_ECC_CORRUPTf_SET(r,f) (r).mem_ecc_ecc_corrupt[0]=(((r).mem_ecc_ecc_corrupt[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_CORRUPTr_DESKEW_ECC_CORRUPTf_GET(r) (((r).mem_ecc_ecc_corrupt[0]) & 0x3)
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_CORRUPTr_DESKEW_ECC_CORRUPTf_SET(r,f) (r).mem_ecc_ecc_corrupt[0]=(((r).mem_ecc_ecc_corrupt[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access MEM_ECC_ECC_CORRUPT.
 *
 */
#define BCMI_TSCE16_XGXS_READ_MEM_ECC_ECC_CORRUPTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MEM_ECC_ECC_CORRUPTr,(_r._mem_ecc_ecc_corrupt))
#define BCMI_TSCE16_XGXS_WRITE_MEM_ECC_ECC_CORRUPTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MEM_ECC_ECC_CORRUPTr,(_r._mem_ecc_ecc_corrupt)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_MEM_ECC_ECC_CORRUPTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MEM_ECC_ECC_CORRUPTr,(_r._mem_ecc_ecc_corrupt))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MEM_ECC_ECC_CORRUPTr BCMI_TSCE16_XGXS_MEM_ECC_ECC_CORRUPTr
#define MEM_ECC_ECC_CORRUPTr_SIZE BCMI_TSCE16_XGXS_MEM_ECC_ECC_CORRUPTr_SIZE
typedef BCMI_TSCE16_XGXS_MEM_ECC_ECC_CORRUPTr_t MEM_ECC_ECC_CORRUPTr_t;
#define MEM_ECC_ECC_CORRUPTr_CLR BCMI_TSCE16_XGXS_MEM_ECC_ECC_CORRUPTr_CLR
#define MEM_ECC_ECC_CORRUPTr_SET BCMI_TSCE16_XGXS_MEM_ECC_ECC_CORRUPTr_SET
#define MEM_ECC_ECC_CORRUPTr_GET BCMI_TSCE16_XGXS_MEM_ECC_ECC_CORRUPTr_GET
#define MEM_ECC_ECC_CORRUPTr_RFEC1_ECC_CORRUPTf_GET BCMI_TSCE16_XGXS_MEM_ECC_ECC_CORRUPTr_RFEC1_ECC_CORRUPTf_GET
#define MEM_ECC_ECC_CORRUPTr_RFEC1_ECC_CORRUPTf_SET BCMI_TSCE16_XGXS_MEM_ECC_ECC_CORRUPTr_RFEC1_ECC_CORRUPTf_SET
#define MEM_ECC_ECC_CORRUPTr_RFEC0_ECC_CORRUPTf_GET BCMI_TSCE16_XGXS_MEM_ECC_ECC_CORRUPTr_RFEC0_ECC_CORRUPTf_GET
#define MEM_ECC_ECC_CORRUPTr_RFEC0_ECC_CORRUPTf_SET BCMI_TSCE16_XGXS_MEM_ECC_ECC_CORRUPTr_RFEC0_ECC_CORRUPTf_SET
#define MEM_ECC_ECC_CORRUPTr_DESKEW_ECC_CORRUPTf_GET BCMI_TSCE16_XGXS_MEM_ECC_ECC_CORRUPTr_DESKEW_ECC_CORRUPTf_GET
#define MEM_ECC_ECC_CORRUPTr_DESKEW_ECC_CORRUPTf_SET BCMI_TSCE16_XGXS_MEM_ECC_ECC_CORRUPTr_DESKEW_ECC_CORRUPTf_SET
#define READ_MEM_ECC_ECC_CORRUPTr BCMI_TSCE16_XGXS_READ_MEM_ECC_ECC_CORRUPTr
#define WRITE_MEM_ECC_ECC_CORRUPTr BCMI_TSCE16_XGXS_WRITE_MEM_ECC_ECC_CORRUPTr
#define MODIFY_MEM_ECC_ECC_CORRUPTr BCMI_TSCE16_XGXS_MODIFY_MEM_ECC_ECC_CORRUPTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_MEM_ECC_ECC_CORRUPTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  MEM_ECC_ECC_DESKEW_STS
 * BLOCKS:   MEM_ECC
 * REGADDR:  0x9056
 * DESC:     ECC error status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DESKEW_ADDRESS   ECC error location, valid only if 1-bit or 1-bit error bit is set
 *     DESKEW_2BIT_ERROR 2-bit ECC error detected
 *     DESKEW_1BIT_ERROR 1-bit ECC error detected
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_DESKEW_STSr (0x00109056 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_DESKEW_STSr_SIZE 4

/*
 * This structure should be used to declare and program MEM_ECC_ECC_DESKEW_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_MEM_ECC_ECC_DESKEW_STSr_s {
	uint32_t v[1];
	uint32_t mem_ecc_ecc_deskew_sts[1];
	uint32_t _mem_ecc_ecc_deskew_sts;
} BCMI_TSCE16_XGXS_MEM_ECC_ECC_DESKEW_STSr_t;

#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_DESKEW_STSr_CLR(r) (r).mem_ecc_ecc_deskew_sts[0] = 0
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_DESKEW_STSr_SET(r,d) (r).mem_ecc_ecc_deskew_sts[0] = d
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_DESKEW_STSr_GET(r) (r).mem_ecc_ecc_deskew_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_DESKEW_STSr_DESKEW_1BIT_ERRORf_GET(r) ((((r).mem_ecc_ecc_deskew_sts[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_DESKEW_STSr_DESKEW_1BIT_ERRORf_SET(r,f) (r).mem_ecc_ecc_deskew_sts[0]=(((r).mem_ecc_ecc_deskew_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_DESKEW_STSr_DESKEW_2BIT_ERRORf_GET(r) ((((r).mem_ecc_ecc_deskew_sts[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_DESKEW_STSr_DESKEW_2BIT_ERRORf_SET(r,f) (r).mem_ecc_ecc_deskew_sts[0]=(((r).mem_ecc_ecc_deskew_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_DESKEW_STSr_DESKEW_ADDRESSf_GET(r) (((r).mem_ecc_ecc_deskew_sts[0]) & 0x7f)
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_DESKEW_STSr_DESKEW_ADDRESSf_SET(r,f) (r).mem_ecc_ecc_deskew_sts[0]=(((r).mem_ecc_ecc_deskew_sts[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access MEM_ECC_ECC_DESKEW_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_MEM_ECC_ECC_DESKEW_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MEM_ECC_ECC_DESKEW_STSr,(_r._mem_ecc_ecc_deskew_sts))
#define BCMI_TSCE16_XGXS_WRITE_MEM_ECC_ECC_DESKEW_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MEM_ECC_ECC_DESKEW_STSr,(_r._mem_ecc_ecc_deskew_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_MEM_ECC_ECC_DESKEW_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MEM_ECC_ECC_DESKEW_STSr,(_r._mem_ecc_ecc_deskew_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MEM_ECC_ECC_DESKEW_STSr BCMI_TSCE16_XGXS_MEM_ECC_ECC_DESKEW_STSr
#define MEM_ECC_ECC_DESKEW_STSr_SIZE BCMI_TSCE16_XGXS_MEM_ECC_ECC_DESKEW_STSr_SIZE
typedef BCMI_TSCE16_XGXS_MEM_ECC_ECC_DESKEW_STSr_t MEM_ECC_ECC_DESKEW_STSr_t;
#define MEM_ECC_ECC_DESKEW_STSr_CLR BCMI_TSCE16_XGXS_MEM_ECC_ECC_DESKEW_STSr_CLR
#define MEM_ECC_ECC_DESKEW_STSr_SET BCMI_TSCE16_XGXS_MEM_ECC_ECC_DESKEW_STSr_SET
#define MEM_ECC_ECC_DESKEW_STSr_GET BCMI_TSCE16_XGXS_MEM_ECC_ECC_DESKEW_STSr_GET
#define MEM_ECC_ECC_DESKEW_STSr_DESKEW_1BIT_ERRORf_GET BCMI_TSCE16_XGXS_MEM_ECC_ECC_DESKEW_STSr_DESKEW_1BIT_ERRORf_GET
#define MEM_ECC_ECC_DESKEW_STSr_DESKEW_1BIT_ERRORf_SET BCMI_TSCE16_XGXS_MEM_ECC_ECC_DESKEW_STSr_DESKEW_1BIT_ERRORf_SET
#define MEM_ECC_ECC_DESKEW_STSr_DESKEW_2BIT_ERRORf_GET BCMI_TSCE16_XGXS_MEM_ECC_ECC_DESKEW_STSr_DESKEW_2BIT_ERRORf_GET
#define MEM_ECC_ECC_DESKEW_STSr_DESKEW_2BIT_ERRORf_SET BCMI_TSCE16_XGXS_MEM_ECC_ECC_DESKEW_STSr_DESKEW_2BIT_ERRORf_SET
#define MEM_ECC_ECC_DESKEW_STSr_DESKEW_ADDRESSf_GET BCMI_TSCE16_XGXS_MEM_ECC_ECC_DESKEW_STSr_DESKEW_ADDRESSf_GET
#define MEM_ECC_ECC_DESKEW_STSr_DESKEW_ADDRESSf_SET BCMI_TSCE16_XGXS_MEM_ECC_ECC_DESKEW_STSr_DESKEW_ADDRESSf_SET
#define READ_MEM_ECC_ECC_DESKEW_STSr BCMI_TSCE16_XGXS_READ_MEM_ECC_ECC_DESKEW_STSr
#define WRITE_MEM_ECC_ECC_DESKEW_STSr BCMI_TSCE16_XGXS_WRITE_MEM_ECC_ECC_DESKEW_STSr
#define MODIFY_MEM_ECC_ECC_DESKEW_STSr BCMI_TSCE16_XGXS_MODIFY_MEM_ECC_ECC_DESKEW_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_MEM_ECC_ECC_DESKEW_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  MEM_ECC_ECC_RFEC0_STS
 * BLOCKS:   MEM_ECC
 * REGADDR:  0x9057
 * DESC:     ECC error status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RFEC0_ADDRESS    ECC error location, valid only if 1-bit or 1-bit error bit is set
 *     RFEC0_2BIT_ERROR 2-bit ECC error detected
 *     RFEC0_1BIT_ERROR 1-bit ECC error detected
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC0_STSr (0x00109057 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC0_STSr_SIZE 4

/*
 * This structure should be used to declare and program MEM_ECC_ECC_RFEC0_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC0_STSr_s {
	uint32_t v[1];
	uint32_t mem_ecc_ecc_rfec0_sts[1];
	uint32_t _mem_ecc_ecc_rfec0_sts;
} BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC0_STSr_t;

#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC0_STSr_CLR(r) (r).mem_ecc_ecc_rfec0_sts[0] = 0
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC0_STSr_SET(r,d) (r).mem_ecc_ecc_rfec0_sts[0] = d
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC0_STSr_GET(r) (r).mem_ecc_ecc_rfec0_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC0_STSr_RFEC0_1BIT_ERRORf_GET(r) ((((r).mem_ecc_ecc_rfec0_sts[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC0_STSr_RFEC0_1BIT_ERRORf_SET(r,f) (r).mem_ecc_ecc_rfec0_sts[0]=(((r).mem_ecc_ecc_rfec0_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC0_STSr_RFEC0_2BIT_ERRORf_GET(r) ((((r).mem_ecc_ecc_rfec0_sts[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC0_STSr_RFEC0_2BIT_ERRORf_SET(r,f) (r).mem_ecc_ecc_rfec0_sts[0]=(((r).mem_ecc_ecc_rfec0_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC0_STSr_RFEC0_ADDRESSf_GET(r) (((r).mem_ecc_ecc_rfec0_sts[0]) & 0xff)
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC0_STSr_RFEC0_ADDRESSf_SET(r,f) (r).mem_ecc_ecc_rfec0_sts[0]=(((r).mem_ecc_ecc_rfec0_sts[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access MEM_ECC_ECC_RFEC0_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_MEM_ECC_ECC_RFEC0_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC0_STSr,(_r._mem_ecc_ecc_rfec0_sts))
#define BCMI_TSCE16_XGXS_WRITE_MEM_ECC_ECC_RFEC0_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC0_STSr,(_r._mem_ecc_ecc_rfec0_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_MEM_ECC_ECC_RFEC0_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC0_STSr,(_r._mem_ecc_ecc_rfec0_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MEM_ECC_ECC_RFEC0_STSr BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC0_STSr
#define MEM_ECC_ECC_RFEC0_STSr_SIZE BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC0_STSr_SIZE
typedef BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC0_STSr_t MEM_ECC_ECC_RFEC0_STSr_t;
#define MEM_ECC_ECC_RFEC0_STSr_CLR BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC0_STSr_CLR
#define MEM_ECC_ECC_RFEC0_STSr_SET BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC0_STSr_SET
#define MEM_ECC_ECC_RFEC0_STSr_GET BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC0_STSr_GET
#define MEM_ECC_ECC_RFEC0_STSr_RFEC0_1BIT_ERRORf_GET BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC0_STSr_RFEC0_1BIT_ERRORf_GET
#define MEM_ECC_ECC_RFEC0_STSr_RFEC0_1BIT_ERRORf_SET BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC0_STSr_RFEC0_1BIT_ERRORf_SET
#define MEM_ECC_ECC_RFEC0_STSr_RFEC0_2BIT_ERRORf_GET BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC0_STSr_RFEC0_2BIT_ERRORf_GET
#define MEM_ECC_ECC_RFEC0_STSr_RFEC0_2BIT_ERRORf_SET BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC0_STSr_RFEC0_2BIT_ERRORf_SET
#define MEM_ECC_ECC_RFEC0_STSr_RFEC0_ADDRESSf_GET BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC0_STSr_RFEC0_ADDRESSf_GET
#define MEM_ECC_ECC_RFEC0_STSr_RFEC0_ADDRESSf_SET BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC0_STSr_RFEC0_ADDRESSf_SET
#define READ_MEM_ECC_ECC_RFEC0_STSr BCMI_TSCE16_XGXS_READ_MEM_ECC_ECC_RFEC0_STSr
#define WRITE_MEM_ECC_ECC_RFEC0_STSr BCMI_TSCE16_XGXS_WRITE_MEM_ECC_ECC_RFEC0_STSr
#define MODIFY_MEM_ECC_ECC_RFEC0_STSr BCMI_TSCE16_XGXS_MODIFY_MEM_ECC_ECC_RFEC0_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC0_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  MEM_ECC_ECC_RFEC1_STS
 * BLOCKS:   MEM_ECC
 * REGADDR:  0x9058
 * DESC:     ECC error status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RFEC1_ADDRESS    ECC error location, valid only if 1-bit or 1-bit error bit is set
 *     RFEC1_2BIT_ERROR 2-bit ECC error detected
 *     RFEC1_1BIT_ERROR 1-bit ECC error detected
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC1_STSr (0x00109058 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC1_STSr_SIZE 4

/*
 * This structure should be used to declare and program MEM_ECC_ECC_RFEC1_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC1_STSr_s {
	uint32_t v[1];
	uint32_t mem_ecc_ecc_rfec1_sts[1];
	uint32_t _mem_ecc_ecc_rfec1_sts;
} BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC1_STSr_t;

#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC1_STSr_CLR(r) (r).mem_ecc_ecc_rfec1_sts[0] = 0
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC1_STSr_SET(r,d) (r).mem_ecc_ecc_rfec1_sts[0] = d
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC1_STSr_GET(r) (r).mem_ecc_ecc_rfec1_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC1_STSr_RFEC1_1BIT_ERRORf_GET(r) ((((r).mem_ecc_ecc_rfec1_sts[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC1_STSr_RFEC1_1BIT_ERRORf_SET(r,f) (r).mem_ecc_ecc_rfec1_sts[0]=(((r).mem_ecc_ecc_rfec1_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC1_STSr_RFEC1_2BIT_ERRORf_GET(r) ((((r).mem_ecc_ecc_rfec1_sts[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC1_STSr_RFEC1_2BIT_ERRORf_SET(r,f) (r).mem_ecc_ecc_rfec1_sts[0]=(((r).mem_ecc_ecc_rfec1_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC1_STSr_RFEC1_ADDRESSf_GET(r) (((r).mem_ecc_ecc_rfec1_sts[0]) & 0xff)
#define BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC1_STSr_RFEC1_ADDRESSf_SET(r,f) (r).mem_ecc_ecc_rfec1_sts[0]=(((r).mem_ecc_ecc_rfec1_sts[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access MEM_ECC_ECC_RFEC1_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_MEM_ECC_ECC_RFEC1_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC1_STSr,(_r._mem_ecc_ecc_rfec1_sts))
#define BCMI_TSCE16_XGXS_WRITE_MEM_ECC_ECC_RFEC1_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC1_STSr,(_r._mem_ecc_ecc_rfec1_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_MEM_ECC_ECC_RFEC1_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC1_STSr,(_r._mem_ecc_ecc_rfec1_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MEM_ECC_ECC_RFEC1_STSr BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC1_STSr
#define MEM_ECC_ECC_RFEC1_STSr_SIZE BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC1_STSr_SIZE
typedef BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC1_STSr_t MEM_ECC_ECC_RFEC1_STSr_t;
#define MEM_ECC_ECC_RFEC1_STSr_CLR BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC1_STSr_CLR
#define MEM_ECC_ECC_RFEC1_STSr_SET BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC1_STSr_SET
#define MEM_ECC_ECC_RFEC1_STSr_GET BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC1_STSr_GET
#define MEM_ECC_ECC_RFEC1_STSr_RFEC1_1BIT_ERRORf_GET BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC1_STSr_RFEC1_1BIT_ERRORf_GET
#define MEM_ECC_ECC_RFEC1_STSr_RFEC1_1BIT_ERRORf_SET BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC1_STSr_RFEC1_1BIT_ERRORf_SET
#define MEM_ECC_ECC_RFEC1_STSr_RFEC1_2BIT_ERRORf_GET BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC1_STSr_RFEC1_2BIT_ERRORf_GET
#define MEM_ECC_ECC_RFEC1_STSr_RFEC1_2BIT_ERRORf_SET BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC1_STSr_RFEC1_2BIT_ERRORf_SET
#define MEM_ECC_ECC_RFEC1_STSr_RFEC1_ADDRESSf_GET BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC1_STSr_RFEC1_ADDRESSf_GET
#define MEM_ECC_ECC_RFEC1_STSr_RFEC1_ADDRESSf_SET BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC1_STSr_RFEC1_ADDRESSf_SET
#define READ_MEM_ECC_ECC_RFEC1_STSr BCMI_TSCE16_XGXS_READ_MEM_ECC_ECC_RFEC1_STSr
#define WRITE_MEM_ECC_ECC_RFEC1_STSr BCMI_TSCE16_XGXS_WRITE_MEM_ECC_ECC_RFEC1_STSr
#define MODIFY_MEM_ECC_ECC_RFEC1_STSr BCMI_TSCE16_XGXS_MODIFY_MEM_ECC_ECC_RFEC1_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_MEM_ECC_ECC_RFEC1_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  MEM_ECC_EXT_INT
 * BLOCKS:   MEM_ECC
 * REGADDR:  0x9059
 * DESC:     PMD external micro interrupt
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_EXT_INT    PMD Micro external Interrupt
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_MEM_ECC_EXT_INTr (0x00109059 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_MEM_ECC_EXT_INTr_SIZE 4

/*
 * This structure should be used to declare and program MEM_ECC_EXT_INT.
 *
 */
typedef union BCMI_TSCE16_XGXS_MEM_ECC_EXT_INTr_s {
	uint32_t v[1];
	uint32_t mem_ecc_ext_int[1];
	uint32_t _mem_ecc_ext_int;
} BCMI_TSCE16_XGXS_MEM_ECC_EXT_INTr_t;

#define BCMI_TSCE16_XGXS_MEM_ECC_EXT_INTr_CLR(r) (r).mem_ecc_ext_int[0] = 0
#define BCMI_TSCE16_XGXS_MEM_ECC_EXT_INTr_SET(r,d) (r).mem_ecc_ext_int[0] = d
#define BCMI_TSCE16_XGXS_MEM_ECC_EXT_INTr_GET(r) (r).mem_ecc_ext_int[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_MEM_ECC_EXT_INTr_MICRO_EXT_INTf_GET(r) (((r).mem_ecc_ext_int[0]) & 0x1)
#define BCMI_TSCE16_XGXS_MEM_ECC_EXT_INTr_MICRO_EXT_INTf_SET(r,f) (r).mem_ecc_ext_int[0]=(((r).mem_ecc_ext_int[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MEM_ECC_EXT_INT.
 *
 */
#define BCMI_TSCE16_XGXS_READ_MEM_ECC_EXT_INTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MEM_ECC_EXT_INTr,(_r._mem_ecc_ext_int))
#define BCMI_TSCE16_XGXS_WRITE_MEM_ECC_EXT_INTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MEM_ECC_EXT_INTr,(_r._mem_ecc_ext_int)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_MEM_ECC_EXT_INTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MEM_ECC_EXT_INTr,(_r._mem_ecc_ext_int))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MEM_ECC_EXT_INTr BCMI_TSCE16_XGXS_MEM_ECC_EXT_INTr
#define MEM_ECC_EXT_INTr_SIZE BCMI_TSCE16_XGXS_MEM_ECC_EXT_INTr_SIZE
typedef BCMI_TSCE16_XGXS_MEM_ECC_EXT_INTr_t MEM_ECC_EXT_INTr_t;
#define MEM_ECC_EXT_INTr_CLR BCMI_TSCE16_XGXS_MEM_ECC_EXT_INTr_CLR
#define MEM_ECC_EXT_INTr_SET BCMI_TSCE16_XGXS_MEM_ECC_EXT_INTr_SET
#define MEM_ECC_EXT_INTr_GET BCMI_TSCE16_XGXS_MEM_ECC_EXT_INTr_GET
#define MEM_ECC_EXT_INTr_MICRO_EXT_INTf_GET BCMI_TSCE16_XGXS_MEM_ECC_EXT_INTr_MICRO_EXT_INTf_GET
#define MEM_ECC_EXT_INTr_MICRO_EXT_INTf_SET BCMI_TSCE16_XGXS_MEM_ECC_EXT_INTr_MICRO_EXT_INTf_SET
#define READ_MEM_ECC_EXT_INTr BCMI_TSCE16_XGXS_READ_MEM_ECC_EXT_INTr
#define WRITE_MEM_ECC_EXT_INTr BCMI_TSCE16_XGXS_WRITE_MEM_ECC_EXT_INTr
#define MODIFY_MEM_ECC_EXT_INTr BCMI_TSCE16_XGXS_MODIFY_MEM_ECC_EXT_INTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_MEM_ECC_EXT_INTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  MEM_ECC_EXT_MSK
 * BLOCKS:   MEM_ECC
 * REGADDR:  0x905a
 * DESC:     PMD external interrupt enable register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_EXT_MSK    Enable for PMD micro external interrupt
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_MEM_ECC_EXT_MSKr (0x0010905a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_MEM_ECC_EXT_MSKr_SIZE 4

/*
 * This structure should be used to declare and program MEM_ECC_EXT_MSK.
 *
 */
typedef union BCMI_TSCE16_XGXS_MEM_ECC_EXT_MSKr_s {
	uint32_t v[1];
	uint32_t mem_ecc_ext_msk[1];
	uint32_t _mem_ecc_ext_msk;
} BCMI_TSCE16_XGXS_MEM_ECC_EXT_MSKr_t;

#define BCMI_TSCE16_XGXS_MEM_ECC_EXT_MSKr_CLR(r) (r).mem_ecc_ext_msk[0] = 0
#define BCMI_TSCE16_XGXS_MEM_ECC_EXT_MSKr_SET(r,d) (r).mem_ecc_ext_msk[0] = d
#define BCMI_TSCE16_XGXS_MEM_ECC_EXT_MSKr_GET(r) (r).mem_ecc_ext_msk[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_MEM_ECC_EXT_MSKr_MICRO_EXT_MSKf_GET(r) (((r).mem_ecc_ext_msk[0]) & 0x1)
#define BCMI_TSCE16_XGXS_MEM_ECC_EXT_MSKr_MICRO_EXT_MSKf_SET(r,f) (r).mem_ecc_ext_msk[0]=(((r).mem_ecc_ext_msk[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MEM_ECC_EXT_MSK.
 *
 */
#define BCMI_TSCE16_XGXS_READ_MEM_ECC_EXT_MSKr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MEM_ECC_EXT_MSKr,(_r._mem_ecc_ext_msk))
#define BCMI_TSCE16_XGXS_WRITE_MEM_ECC_EXT_MSKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MEM_ECC_EXT_MSKr,(_r._mem_ecc_ext_msk)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_MEM_ECC_EXT_MSKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MEM_ECC_EXT_MSKr,(_r._mem_ecc_ext_msk))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MEM_ECC_EXT_MSKr BCMI_TSCE16_XGXS_MEM_ECC_EXT_MSKr
#define MEM_ECC_EXT_MSKr_SIZE BCMI_TSCE16_XGXS_MEM_ECC_EXT_MSKr_SIZE
typedef BCMI_TSCE16_XGXS_MEM_ECC_EXT_MSKr_t MEM_ECC_EXT_MSKr_t;
#define MEM_ECC_EXT_MSKr_CLR BCMI_TSCE16_XGXS_MEM_ECC_EXT_MSKr_CLR
#define MEM_ECC_EXT_MSKr_SET BCMI_TSCE16_XGXS_MEM_ECC_EXT_MSKr_SET
#define MEM_ECC_EXT_MSKr_GET BCMI_TSCE16_XGXS_MEM_ECC_EXT_MSKr_GET
#define MEM_ECC_EXT_MSKr_MICRO_EXT_MSKf_GET BCMI_TSCE16_XGXS_MEM_ECC_EXT_MSKr_MICRO_EXT_MSKf_GET
#define MEM_ECC_EXT_MSKr_MICRO_EXT_MSKf_SET BCMI_TSCE16_XGXS_MEM_ECC_EXT_MSKr_MICRO_EXT_MSKf_SET
#define READ_MEM_ECC_EXT_MSKr BCMI_TSCE16_XGXS_READ_MEM_ECC_EXT_MSKr
#define WRITE_MEM_ECC_EXT_MSKr BCMI_TSCE16_XGXS_WRITE_MEM_ECC_EXT_MSKr
#define MODIFY_MEM_ECC_EXT_MSKr BCMI_TSCE16_XGXS_MODIFY_MEM_ECC_EXT_MSKr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_MEM_ECC_EXT_MSKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  MEM_TM_DESKEW
 * BLOCKS:   MEM_DBG
 * REGADDR:  0x9060
 * DESC:     TM bits for deskew memory
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DESKEW_TM        TM bits for deskew memory
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_MEM_TM_DESKEWr (0x00109060 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_MEM_TM_DESKEWr_SIZE 4

/*
 * This structure should be used to declare and program MEM_TM_DESKEW.
 *
 */
typedef union BCMI_TSCE16_XGXS_MEM_TM_DESKEWr_s {
	uint32_t v[1];
	uint32_t mem_tm_deskew[1];
	uint32_t _mem_tm_deskew;
} BCMI_TSCE16_XGXS_MEM_TM_DESKEWr_t;

#define BCMI_TSCE16_XGXS_MEM_TM_DESKEWr_CLR(r) (r).mem_tm_deskew[0] = 0
#define BCMI_TSCE16_XGXS_MEM_TM_DESKEWr_SET(r,d) (r).mem_tm_deskew[0] = d
#define BCMI_TSCE16_XGXS_MEM_TM_DESKEWr_GET(r) (r).mem_tm_deskew[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_MEM_TM_DESKEWr_DESKEW_TMf_GET(r) (((r).mem_tm_deskew[0]) & 0xfff)
#define BCMI_TSCE16_XGXS_MEM_TM_DESKEWr_DESKEW_TMf_SET(r,f) (r).mem_tm_deskew[0]=(((r).mem_tm_deskew[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff)) | (0xfff << 16)

/*
 * These macros can be used to access MEM_TM_DESKEW.
 *
 */
#define BCMI_TSCE16_XGXS_READ_MEM_TM_DESKEWr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MEM_TM_DESKEWr,(_r._mem_tm_deskew))
#define BCMI_TSCE16_XGXS_WRITE_MEM_TM_DESKEWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MEM_TM_DESKEWr,(_r._mem_tm_deskew)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_MEM_TM_DESKEWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MEM_TM_DESKEWr,(_r._mem_tm_deskew))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MEM_TM_DESKEWr BCMI_TSCE16_XGXS_MEM_TM_DESKEWr
#define MEM_TM_DESKEWr_SIZE BCMI_TSCE16_XGXS_MEM_TM_DESKEWr_SIZE
typedef BCMI_TSCE16_XGXS_MEM_TM_DESKEWr_t MEM_TM_DESKEWr_t;
#define MEM_TM_DESKEWr_CLR BCMI_TSCE16_XGXS_MEM_TM_DESKEWr_CLR
#define MEM_TM_DESKEWr_SET BCMI_TSCE16_XGXS_MEM_TM_DESKEWr_SET
#define MEM_TM_DESKEWr_GET BCMI_TSCE16_XGXS_MEM_TM_DESKEWr_GET
#define MEM_TM_DESKEWr_DESKEW_TMf_GET BCMI_TSCE16_XGXS_MEM_TM_DESKEWr_DESKEW_TMf_GET
#define MEM_TM_DESKEWr_DESKEW_TMf_SET BCMI_TSCE16_XGXS_MEM_TM_DESKEWr_DESKEW_TMf_SET
#define READ_MEM_TM_DESKEWr BCMI_TSCE16_XGXS_READ_MEM_TM_DESKEWr
#define WRITE_MEM_TM_DESKEWr BCMI_TSCE16_XGXS_WRITE_MEM_TM_DESKEWr
#define MODIFY_MEM_TM_DESKEWr BCMI_TSCE16_XGXS_MODIFY_MEM_TM_DESKEWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_MEM_TM_DESKEWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  MEM_TM_RFEC0
 * BLOCKS:   MEM_DBG
 * REGADDR:  0x9061
 * DESC:     TM bits for rfec0 memory
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RFEC0_TM         TM bits for rfec0 memory
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_MEM_TM_RFEC0r (0x00109061 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_MEM_TM_RFEC0r_SIZE 4

/*
 * This structure should be used to declare and program MEM_TM_RFEC0.
 *
 */
typedef union BCMI_TSCE16_XGXS_MEM_TM_RFEC0r_s {
	uint32_t v[1];
	uint32_t mem_tm_rfec0[1];
	uint32_t _mem_tm_rfec0;
} BCMI_TSCE16_XGXS_MEM_TM_RFEC0r_t;

#define BCMI_TSCE16_XGXS_MEM_TM_RFEC0r_CLR(r) (r).mem_tm_rfec0[0] = 0
#define BCMI_TSCE16_XGXS_MEM_TM_RFEC0r_SET(r,d) (r).mem_tm_rfec0[0] = d
#define BCMI_TSCE16_XGXS_MEM_TM_RFEC0r_GET(r) (r).mem_tm_rfec0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_MEM_TM_RFEC0r_RFEC0_TMf_GET(r) (((r).mem_tm_rfec0[0]) & 0xfff)
#define BCMI_TSCE16_XGXS_MEM_TM_RFEC0r_RFEC0_TMf_SET(r,f) (r).mem_tm_rfec0[0]=(((r).mem_tm_rfec0[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff)) | (0xfff << 16)

/*
 * These macros can be used to access MEM_TM_RFEC0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_MEM_TM_RFEC0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MEM_TM_RFEC0r,(_r._mem_tm_rfec0))
#define BCMI_TSCE16_XGXS_WRITE_MEM_TM_RFEC0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MEM_TM_RFEC0r,(_r._mem_tm_rfec0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_MEM_TM_RFEC0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MEM_TM_RFEC0r,(_r._mem_tm_rfec0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MEM_TM_RFEC0r BCMI_TSCE16_XGXS_MEM_TM_RFEC0r
#define MEM_TM_RFEC0r_SIZE BCMI_TSCE16_XGXS_MEM_TM_RFEC0r_SIZE
typedef BCMI_TSCE16_XGXS_MEM_TM_RFEC0r_t MEM_TM_RFEC0r_t;
#define MEM_TM_RFEC0r_CLR BCMI_TSCE16_XGXS_MEM_TM_RFEC0r_CLR
#define MEM_TM_RFEC0r_SET BCMI_TSCE16_XGXS_MEM_TM_RFEC0r_SET
#define MEM_TM_RFEC0r_GET BCMI_TSCE16_XGXS_MEM_TM_RFEC0r_GET
#define MEM_TM_RFEC0r_RFEC0_TMf_GET BCMI_TSCE16_XGXS_MEM_TM_RFEC0r_RFEC0_TMf_GET
#define MEM_TM_RFEC0r_RFEC0_TMf_SET BCMI_TSCE16_XGXS_MEM_TM_RFEC0r_RFEC0_TMf_SET
#define READ_MEM_TM_RFEC0r BCMI_TSCE16_XGXS_READ_MEM_TM_RFEC0r
#define WRITE_MEM_TM_RFEC0r BCMI_TSCE16_XGXS_WRITE_MEM_TM_RFEC0r
#define MODIFY_MEM_TM_RFEC0r BCMI_TSCE16_XGXS_MODIFY_MEM_TM_RFEC0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_MEM_TM_RFEC0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  MEM_TM_RFEC1
 * BLOCKS:   MEM_DBG
 * REGADDR:  0x9062
 * DESC:     TM bits for rfec1 memory
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RFEC1_TM         TM bits for rfec1 memory
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_MEM_TM_RFEC1r (0x00109062 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_MEM_TM_RFEC1r_SIZE 4

/*
 * This structure should be used to declare and program MEM_TM_RFEC1.
 *
 */
typedef union BCMI_TSCE16_XGXS_MEM_TM_RFEC1r_s {
	uint32_t v[1];
	uint32_t mem_tm_rfec1[1];
	uint32_t _mem_tm_rfec1;
} BCMI_TSCE16_XGXS_MEM_TM_RFEC1r_t;

#define BCMI_TSCE16_XGXS_MEM_TM_RFEC1r_CLR(r) (r).mem_tm_rfec1[0] = 0
#define BCMI_TSCE16_XGXS_MEM_TM_RFEC1r_SET(r,d) (r).mem_tm_rfec1[0] = d
#define BCMI_TSCE16_XGXS_MEM_TM_RFEC1r_GET(r) (r).mem_tm_rfec1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_MEM_TM_RFEC1r_RFEC1_TMf_GET(r) (((r).mem_tm_rfec1[0]) & 0xfff)
#define BCMI_TSCE16_XGXS_MEM_TM_RFEC1r_RFEC1_TMf_SET(r,f) (r).mem_tm_rfec1[0]=(((r).mem_tm_rfec1[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff)) | (0xfff << 16)

/*
 * These macros can be used to access MEM_TM_RFEC1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_MEM_TM_RFEC1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MEM_TM_RFEC1r,(_r._mem_tm_rfec1))
#define BCMI_TSCE16_XGXS_WRITE_MEM_TM_RFEC1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MEM_TM_RFEC1r,(_r._mem_tm_rfec1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_MEM_TM_RFEC1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MEM_TM_RFEC1r,(_r._mem_tm_rfec1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MEM_TM_RFEC1r BCMI_TSCE16_XGXS_MEM_TM_RFEC1r
#define MEM_TM_RFEC1r_SIZE BCMI_TSCE16_XGXS_MEM_TM_RFEC1r_SIZE
typedef BCMI_TSCE16_XGXS_MEM_TM_RFEC1r_t MEM_TM_RFEC1r_t;
#define MEM_TM_RFEC1r_CLR BCMI_TSCE16_XGXS_MEM_TM_RFEC1r_CLR
#define MEM_TM_RFEC1r_SET BCMI_TSCE16_XGXS_MEM_TM_RFEC1r_SET
#define MEM_TM_RFEC1r_GET BCMI_TSCE16_XGXS_MEM_TM_RFEC1r_GET
#define MEM_TM_RFEC1r_RFEC1_TMf_GET BCMI_TSCE16_XGXS_MEM_TM_RFEC1r_RFEC1_TMf_GET
#define MEM_TM_RFEC1r_RFEC1_TMf_SET BCMI_TSCE16_XGXS_MEM_TM_RFEC1r_RFEC1_TMf_SET
#define READ_MEM_TM_RFEC1r BCMI_TSCE16_XGXS_READ_MEM_TM_RFEC1r
#define WRITE_MEM_TM_RFEC1r BCMI_TSCE16_XGXS_WRITE_MEM_TM_RFEC1r
#define MODIFY_MEM_TM_RFEC1r BCMI_TSCE16_XGXS_MODIFY_MEM_TM_RFEC1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_MEM_TM_RFEC1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  XGXSSTS0
 * BLOCKS:   MISC
 * REGADDR:  0x90b1
 * DESC:     XGXS status register
 * RESETVAL: 0x8000 (32768)
 * ACCESS:   R/O
 * FIELDS:
 *     SKEW_STATUS      Skew status: OK (from rx_link)
 *     STATUS_EN        0 = register is a control register1 = register is a status register
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_XGXSSTS0r (0x001090b1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_XGXSSTS0r_SIZE 4

/*
 * This structure should be used to declare and program XGXSSTS0.
 *
 */
typedef union BCMI_TSCE16_XGXS_XGXSSTS0r_s {
	uint32_t v[1];
	uint32_t xgxssts0[1];
	uint32_t _xgxssts0;
} BCMI_TSCE16_XGXS_XGXSSTS0r_t;

#define BCMI_TSCE16_XGXS_XGXSSTS0r_CLR(r) (r).xgxssts0[0] = 0
#define BCMI_TSCE16_XGXS_XGXSSTS0r_SET(r,d) (r).xgxssts0[0] = d
#define BCMI_TSCE16_XGXS_XGXSSTS0r_GET(r) (r).xgxssts0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_XGXSSTS0r_STATUS_ENf_GET(r) ((((r).xgxssts0[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_XGXSSTS0r_STATUS_ENf_SET(r,f) (r).xgxssts0[0]=(((r).xgxssts0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_XGXSSTS0r_SKEW_STATUSf_GET(r) (((r).xgxssts0[0]) & 0x1)
#define BCMI_TSCE16_XGXS_XGXSSTS0r_SKEW_STATUSf_SET(r,f) (r).xgxssts0[0]=(((r).xgxssts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access XGXSSTS0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_XGXSSTS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_XGXSSTS0r,(_r._xgxssts0))
#define BCMI_TSCE16_XGXS_WRITE_XGXSSTS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_XGXSSTS0r,(_r._xgxssts0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_XGXSSTS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_XGXSSTS0r,(_r._xgxssts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define XGXSSTS0r BCMI_TSCE16_XGXS_XGXSSTS0r
#define XGXSSTS0r_SIZE BCMI_TSCE16_XGXS_XGXSSTS0r_SIZE
typedef BCMI_TSCE16_XGXS_XGXSSTS0r_t XGXSSTS0r_t;
#define XGXSSTS0r_CLR BCMI_TSCE16_XGXS_XGXSSTS0r_CLR
#define XGXSSTS0r_SET BCMI_TSCE16_XGXS_XGXSSTS0r_SET
#define XGXSSTS0r_GET BCMI_TSCE16_XGXS_XGXSSTS0r_GET
#define XGXSSTS0r_STATUS_ENf_GET BCMI_TSCE16_XGXS_XGXSSTS0r_STATUS_ENf_GET
#define XGXSSTS0r_STATUS_ENf_SET BCMI_TSCE16_XGXS_XGXSSTS0r_STATUS_ENf_SET
#define XGXSSTS0r_SKEW_STATUSf_GET BCMI_TSCE16_XGXS_XGXSSTS0r_SKEW_STATUSf_GET
#define XGXSSTS0r_SKEW_STATUSf_SET BCMI_TSCE16_XGXS_XGXSSTS0r_SKEW_STATUSf_SET
#define READ_XGXSSTS0r BCMI_TSCE16_XGXS_READ_XGXSSTS0r
#define WRITE_XGXSSTS0r BCMI_TSCE16_XGXS_WRITE_XGXSSTS0r
#define MODIFY_XGXSSTS0r BCMI_TSCE16_XGXS_MODIFY_XGXSSTS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_XGXSSTS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_RATE_MISMATCH
 * BLOCKS:   MISC
 * REGADDR:  0x90b3
 * DESC:     TX rate mismatch status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_LANE_RATE_MISMATCH bit N indicates that there is a rate mismatch error on a fifo assosiated physical lane NIn modes with more than 4 virtual lanes,bit N indicates that there is a rate mismatch error on a fifo assosiated with first virtual lane mapped to physical lane NSee spec for virtual line assigments
 *     TX_LANE_RATE_MISMATCH_VL1 Only used in modes with more than 4 virtual lanesbit N indicates that there is a rate mismatch error on a fifo assosiated with second virtual lane mapped to physical lane NSee spec for virtual line assigments
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_RATE_MISMATCHr (0x001090b3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_RATE_MISMATCHr_SIZE 4

/*
 * This structure should be used to declare and program TX_RATE_MISMATCH.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_RATE_MISMATCHr_s {
	uint32_t v[1];
	uint32_t tx_rate_mismatch[1];
	uint32_t _tx_rate_mismatch;
} BCMI_TSCE16_XGXS_TX_RATE_MISMATCHr_t;

#define BCMI_TSCE16_XGXS_TX_RATE_MISMATCHr_CLR(r) (r).tx_rate_mismatch[0] = 0
#define BCMI_TSCE16_XGXS_TX_RATE_MISMATCHr_SET(r,d) (r).tx_rate_mismatch[0] = d
#define BCMI_TSCE16_XGXS_TX_RATE_MISMATCHr_GET(r) (r).tx_rate_mismatch[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_RATE_MISMATCHr_TX_LANE_RATE_MISMATCH_VL1f_GET(r) ((((r).tx_rate_mismatch[0]) >> 4) & 0xf)
#define BCMI_TSCE16_XGXS_TX_RATE_MISMATCHr_TX_LANE_RATE_MISMATCH_VL1f_SET(r,f) (r).tx_rate_mismatch[0]=(((r).tx_rate_mismatch[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_TSCE16_XGXS_TX_RATE_MISMATCHr_TX_LANE_RATE_MISMATCHf_GET(r) (((r).tx_rate_mismatch[0]) & 0xf)
#define BCMI_TSCE16_XGXS_TX_RATE_MISMATCHr_TX_LANE_RATE_MISMATCHf_SET(r,f) (r).tx_rate_mismatch[0]=(((r).tx_rate_mismatch[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access TX_RATE_MISMATCH.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_RATE_MISMATCHr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_RATE_MISMATCHr,(_r._tx_rate_mismatch))
#define BCMI_TSCE16_XGXS_WRITE_TX_RATE_MISMATCHr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_RATE_MISMATCHr,(_r._tx_rate_mismatch)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_RATE_MISMATCHr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_RATE_MISMATCHr,(_r._tx_rate_mismatch))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_RATE_MISMATCHr BCMI_TSCE16_XGXS_TX_RATE_MISMATCHr
#define TX_RATE_MISMATCHr_SIZE BCMI_TSCE16_XGXS_TX_RATE_MISMATCHr_SIZE
typedef BCMI_TSCE16_XGXS_TX_RATE_MISMATCHr_t TX_RATE_MISMATCHr_t;
#define TX_RATE_MISMATCHr_CLR BCMI_TSCE16_XGXS_TX_RATE_MISMATCHr_CLR
#define TX_RATE_MISMATCHr_SET BCMI_TSCE16_XGXS_TX_RATE_MISMATCHr_SET
#define TX_RATE_MISMATCHr_GET BCMI_TSCE16_XGXS_TX_RATE_MISMATCHr_GET
#define TX_RATE_MISMATCHr_TX_LANE_RATE_MISMATCH_VL1f_GET BCMI_TSCE16_XGXS_TX_RATE_MISMATCHr_TX_LANE_RATE_MISMATCH_VL1f_GET
#define TX_RATE_MISMATCHr_TX_LANE_RATE_MISMATCH_VL1f_SET BCMI_TSCE16_XGXS_TX_RATE_MISMATCHr_TX_LANE_RATE_MISMATCH_VL1f_SET
#define TX_RATE_MISMATCHr_TX_LANE_RATE_MISMATCHf_GET BCMI_TSCE16_XGXS_TX_RATE_MISMATCHr_TX_LANE_RATE_MISMATCHf_GET
#define TX_RATE_MISMATCHr_TX_LANE_RATE_MISMATCHf_SET BCMI_TSCE16_XGXS_TX_RATE_MISMATCHr_TX_LANE_RATE_MISMATCHf_SET
#define READ_TX_RATE_MISMATCHr BCMI_TSCE16_XGXS_READ_TX_RATE_MISMATCHr
#define WRITE_TX_RATE_MISMATCHr BCMI_TSCE16_XGXS_WRITE_TX_RATE_MISMATCHr
#define MODIFY_TX_RATE_MISMATCHr BCMI_TSCE16_XGXS_MODIFY_TX_RATE_MISMATCHr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_RATE_MISMATCHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SCRMBLR_CTL
 * BLOCKS:   MISC
 * REGADDR:  0x90b4
 * DESC:     Scrambler enable for 6.26G baud rate based speeds
 * RESETVAL: 0x1d (29)
 * ACCESS:   R/W
 * FIELDS:
 *     SCRAMBLER_EN_MASK Mask used to enable scrambler for 6.25G baud rate based speedsby default compatible with TSC40 AN settingsbit 0: enable scrambler for 5G_X1 speedbit 1: enable scrambler for 20G_CX4 speedbit 2: enable scrambler for 20G_X4 speedbit 3: enable scrambler for 10G_CX2 speedbit 4: enable scrambler for 10G_X2 speed
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SCRMBLR_CTLr (0x001090b4 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SCRMBLR_CTLr_SIZE 4

/*
 * This structure should be used to declare and program SCRMBLR_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_SCRMBLR_CTLr_s {
	uint32_t v[1];
	uint32_t scrmblr_ctl[1];
	uint32_t _scrmblr_ctl;
} BCMI_TSCE16_XGXS_SCRMBLR_CTLr_t;

#define BCMI_TSCE16_XGXS_SCRMBLR_CTLr_CLR(r) (r).scrmblr_ctl[0] = 0
#define BCMI_TSCE16_XGXS_SCRMBLR_CTLr_SET(r,d) (r).scrmblr_ctl[0] = d
#define BCMI_TSCE16_XGXS_SCRMBLR_CTLr_GET(r) (r).scrmblr_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SCRMBLR_CTLr_SCRAMBLER_EN_MASKf_GET(r) (((r).scrmblr_ctl[0]) & 0x1f)
#define BCMI_TSCE16_XGXS_SCRMBLR_CTLr_SCRAMBLER_EN_MASKf_SET(r,f) (r).scrmblr_ctl[0]=(((r).scrmblr_ctl[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access SCRMBLR_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SCRMBLR_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SCRMBLR_CTLr,(_r._scrmblr_ctl))
#define BCMI_TSCE16_XGXS_WRITE_SCRMBLR_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SCRMBLR_CTLr,(_r._scrmblr_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SCRMBLR_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SCRMBLR_CTLr,(_r._scrmblr_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SCRMBLR_CTLr BCMI_TSCE16_XGXS_SCRMBLR_CTLr
#define SCRMBLR_CTLr_SIZE BCMI_TSCE16_XGXS_SCRMBLR_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_SCRMBLR_CTLr_t SCRMBLR_CTLr_t;
#define SCRMBLR_CTLr_CLR BCMI_TSCE16_XGXS_SCRMBLR_CTLr_CLR
#define SCRMBLR_CTLr_SET BCMI_TSCE16_XGXS_SCRMBLR_CTLr_SET
#define SCRMBLR_CTLr_GET BCMI_TSCE16_XGXS_SCRMBLR_CTLr_GET
#define SCRMBLR_CTLr_SCRAMBLER_EN_MASKf_GET BCMI_TSCE16_XGXS_SCRMBLR_CTLr_SCRAMBLER_EN_MASKf_GET
#define SCRMBLR_CTLr_SCRAMBLER_EN_MASKf_SET BCMI_TSCE16_XGXS_SCRMBLR_CTLr_SCRAMBLER_EN_MASKf_SET
#define READ_SCRMBLR_CTLr BCMI_TSCE16_XGXS_READ_SCRMBLR_CTLr
#define WRITE_SCRMBLR_CTLr BCMI_TSCE16_XGXS_WRITE_SCRMBLR_CTLr
#define MODIFY_SCRMBLR_CTLr BCMI_TSCE16_XGXS_MODIFY_SCRMBLR_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SCRMBLR_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  CL72_EN_MASK
 * BLOCKS:   MISC
 * REGADDR:  0x90b5
 * DESC:     CL72 Per Speed Enable Control Register
 * RESETVAL: 0xffff (65535)
 * ACCESS:   R/W
 * FIELDS:
 *     CL72_EN_MASK     The cl72_en_mask_en controls whether CL72 may be enabled for certain speeds.bit 0:  actual_speed = 0x12 : dr_20G_X4bit 1:  actual_speed = 0x13 : dr_21G_X4bit 2:  actual_speed = 0x14 : dr_25G_X4bit 3:  actual_speed = 0x2c : dr_15p75G_DXGXSbit 4:  N/Abit 5:  actual_speed = 0x17 : dr_10p5G_HiG_DXGXSbit 6:  N/Abit 7:  actual_speed = 0x19 : dr_12p773G_HiG_DXGXSbit 8:  N/Abit 9:  actual_speed = 0x1c : dr_40Gbit 10:  actual_speed = 0x20 : dr_31p5Gbit 11:  actual_speed = 0x22 : dr_20G_SCRbit 12:  actual_speed = 0x23 : dr_10G_HiG_DXGXS_SCRbit 13:  actual_speed = 0x24 : dr_10G_DXGXS_SCRbit 14:  actual_speed = 0x1d : dr_20G_HiG_DXGXSbit 15:  actual_speed = 0x1e : dr_20G_DXGXS
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_CL72_EN_MASKr (0x001090b5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_CL72_EN_MASKr_SIZE 4

/*
 * This structure should be used to declare and program CL72_EN_MASK.
 *
 */
typedef union BCMI_TSCE16_XGXS_CL72_EN_MASKr_s {
	uint32_t v[1];
	uint32_t cl72_en_mask[1];
	uint32_t _cl72_en_mask;
} BCMI_TSCE16_XGXS_CL72_EN_MASKr_t;

#define BCMI_TSCE16_XGXS_CL72_EN_MASKr_CLR(r) (r).cl72_en_mask[0] = 0
#define BCMI_TSCE16_XGXS_CL72_EN_MASKr_SET(r,d) (r).cl72_en_mask[0] = d
#define BCMI_TSCE16_XGXS_CL72_EN_MASKr_GET(r) (r).cl72_en_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_CL72_EN_MASKr_CL72_EN_MASKf_GET(r) (((r).cl72_en_mask[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_CL72_EN_MASKr_CL72_EN_MASKf_SET(r,f) (r).cl72_en_mask[0]=(((r).cl72_en_mask[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CL72_EN_MASK.
 *
 */
#define BCMI_TSCE16_XGXS_READ_CL72_EN_MASKr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72_EN_MASKr,(_r._cl72_en_mask))
#define BCMI_TSCE16_XGXS_WRITE_CL72_EN_MASKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72_EN_MASKr,(_r._cl72_en_mask)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_CL72_EN_MASKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72_EN_MASKr,(_r._cl72_en_mask))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL72_EN_MASKr BCMI_TSCE16_XGXS_CL72_EN_MASKr
#define CL72_EN_MASKr_SIZE BCMI_TSCE16_XGXS_CL72_EN_MASKr_SIZE
typedef BCMI_TSCE16_XGXS_CL72_EN_MASKr_t CL72_EN_MASKr_t;
#define CL72_EN_MASKr_CLR BCMI_TSCE16_XGXS_CL72_EN_MASKr_CLR
#define CL72_EN_MASKr_SET BCMI_TSCE16_XGXS_CL72_EN_MASKr_SET
#define CL72_EN_MASKr_GET BCMI_TSCE16_XGXS_CL72_EN_MASKr_GET
#define CL72_EN_MASKr_CL72_EN_MASKf_GET BCMI_TSCE16_XGXS_CL72_EN_MASKr_CL72_EN_MASKf_GET
#define CL72_EN_MASKr_CL72_EN_MASKf_SET BCMI_TSCE16_XGXS_CL72_EN_MASKr_CL72_EN_MASKf_SET
#define READ_CL72_EN_MASKr BCMI_TSCE16_XGXS_READ_CL72_EN_MASKr
#define WRITE_CL72_EN_MASKr BCMI_TSCE16_XGXS_WRITE_CL72_EN_MASKr
#define MODIFY_CL72_EN_MASKr BCMI_TSCE16_XGXS_MODIFY_CL72_EN_MASKr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_CL72_EN_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  CL82_RX_AM_TMR
 * BLOCKS:   CL82_SHARED
 * REGADDR:  0x9123
 * DESC:     cl82 rx AM timer register
 * RESETVAL: 0x3fff (16383)
 * ACCESS:   R/W
 * FIELDS:
 *     AM_TIMER_INIT_RX_VAL Alignment marker initial timer value
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_CL82_RX_AM_TMRr (0x00109123 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_CL82_RX_AM_TMRr_SIZE 4

/*
 * This structure should be used to declare and program CL82_RX_AM_TMR.
 *
 */
typedef union BCMI_TSCE16_XGXS_CL82_RX_AM_TMRr_s {
	uint32_t v[1];
	uint32_t cl82_rx_am_tmr[1];
	uint32_t _cl82_rx_am_tmr;
} BCMI_TSCE16_XGXS_CL82_RX_AM_TMRr_t;

#define BCMI_TSCE16_XGXS_CL82_RX_AM_TMRr_CLR(r) (r).cl82_rx_am_tmr[0] = 0
#define BCMI_TSCE16_XGXS_CL82_RX_AM_TMRr_SET(r,d) (r).cl82_rx_am_tmr[0] = d
#define BCMI_TSCE16_XGXS_CL82_RX_AM_TMRr_GET(r) (r).cl82_rx_am_tmr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_CL82_RX_AM_TMRr_AM_TIMER_INIT_RX_VALf_GET(r) (((r).cl82_rx_am_tmr[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_CL82_RX_AM_TMRr_AM_TIMER_INIT_RX_VALf_SET(r,f) (r).cl82_rx_am_tmr[0]=(((r).cl82_rx_am_tmr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CL82_RX_AM_TMR.
 *
 */
#define BCMI_TSCE16_XGXS_READ_CL82_RX_AM_TMRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL82_RX_AM_TMRr,(_r._cl82_rx_am_tmr))
#define BCMI_TSCE16_XGXS_WRITE_CL82_RX_AM_TMRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL82_RX_AM_TMRr,(_r._cl82_rx_am_tmr)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_CL82_RX_AM_TMRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL82_RX_AM_TMRr,(_r._cl82_rx_am_tmr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL82_RX_AM_TMRr BCMI_TSCE16_XGXS_CL82_RX_AM_TMRr
#define CL82_RX_AM_TMRr_SIZE BCMI_TSCE16_XGXS_CL82_RX_AM_TMRr_SIZE
typedef BCMI_TSCE16_XGXS_CL82_RX_AM_TMRr_t CL82_RX_AM_TMRr_t;
#define CL82_RX_AM_TMRr_CLR BCMI_TSCE16_XGXS_CL82_RX_AM_TMRr_CLR
#define CL82_RX_AM_TMRr_SET BCMI_TSCE16_XGXS_CL82_RX_AM_TMRr_SET
#define CL82_RX_AM_TMRr_GET BCMI_TSCE16_XGXS_CL82_RX_AM_TMRr_GET
#define CL82_RX_AM_TMRr_AM_TIMER_INIT_RX_VALf_GET BCMI_TSCE16_XGXS_CL82_RX_AM_TMRr_AM_TIMER_INIT_RX_VALf_GET
#define CL82_RX_AM_TMRr_AM_TIMER_INIT_RX_VALf_SET BCMI_TSCE16_XGXS_CL82_RX_AM_TMRr_AM_TIMER_INIT_RX_VALf_SET
#define READ_CL82_RX_AM_TMRr BCMI_TSCE16_XGXS_READ_CL82_RX_AM_TMRr
#define WRITE_CL82_RX_AM_TMRr BCMI_TSCE16_XGXS_WRITE_CL82_RX_AM_TMRr
#define MODIFY_CL82_RX_AM_TMRr BCMI_TSCE16_XGXS_MODIFY_CL82_RX_AM_TMRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_CL82_RX_AM_TMRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  CL82_LN_0_AM_BYTE10
 * BLOCKS:   CL82_AM_REGS
 * REGADDR:  0x9130
 * DESC:     cl82 LANE 0 AM BYTES 1 AND 0 register
 * RESETVAL: 0x7690 (30352)
 * ACCESS:   R/W
 * FIELDS:
 *     LANE_0_AM_1_0    MLD Alignment Market Bytes 1 and 0 for LANE 0.  Used in MLD20G and MLD120G modes only
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_CL82_LN_0_AM_BYTE10r (0x00109130 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_CL82_LN_0_AM_BYTE10r_SIZE 4

/*
 * This structure should be used to declare and program CL82_LN_0_AM_BYTE10.
 *
 */
typedef union BCMI_TSCE16_XGXS_CL82_LN_0_AM_BYTE10r_s {
	uint32_t v[1];
	uint32_t cl82_ln_0_am_byte10[1];
	uint32_t _cl82_ln_0_am_byte10;
} BCMI_TSCE16_XGXS_CL82_LN_0_AM_BYTE10r_t;

#define BCMI_TSCE16_XGXS_CL82_LN_0_AM_BYTE10r_CLR(r) (r).cl82_ln_0_am_byte10[0] = 0
#define BCMI_TSCE16_XGXS_CL82_LN_0_AM_BYTE10r_SET(r,d) (r).cl82_ln_0_am_byte10[0] = d
#define BCMI_TSCE16_XGXS_CL82_LN_0_AM_BYTE10r_GET(r) (r).cl82_ln_0_am_byte10[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_CL82_LN_0_AM_BYTE10r_LANE_0_AM_1_0f_GET(r) (((r).cl82_ln_0_am_byte10[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_CL82_LN_0_AM_BYTE10r_LANE_0_AM_1_0f_SET(r,f) (r).cl82_ln_0_am_byte10[0]=(((r).cl82_ln_0_am_byte10[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CL82_LN_0_AM_BYTE10.
 *
 */
#define BCMI_TSCE16_XGXS_READ_CL82_LN_0_AM_BYTE10r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL82_LN_0_AM_BYTE10r,(_r._cl82_ln_0_am_byte10))
#define BCMI_TSCE16_XGXS_WRITE_CL82_LN_0_AM_BYTE10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL82_LN_0_AM_BYTE10r,(_r._cl82_ln_0_am_byte10)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_CL82_LN_0_AM_BYTE10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL82_LN_0_AM_BYTE10r,(_r._cl82_ln_0_am_byte10))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL82_LN_0_AM_BYTE10r BCMI_TSCE16_XGXS_CL82_LN_0_AM_BYTE10r
#define CL82_LN_0_AM_BYTE10r_SIZE BCMI_TSCE16_XGXS_CL82_LN_0_AM_BYTE10r_SIZE
typedef BCMI_TSCE16_XGXS_CL82_LN_0_AM_BYTE10r_t CL82_LN_0_AM_BYTE10r_t;
#define CL82_LN_0_AM_BYTE10r_CLR BCMI_TSCE16_XGXS_CL82_LN_0_AM_BYTE10r_CLR
#define CL82_LN_0_AM_BYTE10r_SET BCMI_TSCE16_XGXS_CL82_LN_0_AM_BYTE10r_SET
#define CL82_LN_0_AM_BYTE10r_GET BCMI_TSCE16_XGXS_CL82_LN_0_AM_BYTE10r_GET
#define CL82_LN_0_AM_BYTE10r_LANE_0_AM_1_0f_GET BCMI_TSCE16_XGXS_CL82_LN_0_AM_BYTE10r_LANE_0_AM_1_0f_GET
#define CL82_LN_0_AM_BYTE10r_LANE_0_AM_1_0f_SET BCMI_TSCE16_XGXS_CL82_LN_0_AM_BYTE10r_LANE_0_AM_1_0f_SET
#define READ_CL82_LN_0_AM_BYTE10r BCMI_TSCE16_XGXS_READ_CL82_LN_0_AM_BYTE10r
#define WRITE_CL82_LN_0_AM_BYTE10r BCMI_TSCE16_XGXS_WRITE_CL82_LN_0_AM_BYTE10r
#define MODIFY_CL82_LN_0_AM_BYTE10r BCMI_TSCE16_XGXS_MODIFY_CL82_LN_0_AM_BYTE10r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_CL82_LN_0_AM_BYTE10r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  CL82_LN_1_AM_BYTE10
 * BLOCKS:   CL82_AM_REGS
 * REGADDR:  0x9131
 * DESC:     cl82 LANE 1 AM BYTES 1 AND 0 register
 * RESETVAL: 0xc4f0 (50416)
 * ACCESS:   R/W
 * FIELDS:
 *     LANE_1_AM_1_0    MLD Alignment Market Bytes 1 and 0 for LANE 1.  Used in MLD20G and MLD120G modes only
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_CL82_LN_1_AM_BYTE10r (0x00109131 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_CL82_LN_1_AM_BYTE10r_SIZE 4

/*
 * This structure should be used to declare and program CL82_LN_1_AM_BYTE10.
 *
 */
typedef union BCMI_TSCE16_XGXS_CL82_LN_1_AM_BYTE10r_s {
	uint32_t v[1];
	uint32_t cl82_ln_1_am_byte10[1];
	uint32_t _cl82_ln_1_am_byte10;
} BCMI_TSCE16_XGXS_CL82_LN_1_AM_BYTE10r_t;

#define BCMI_TSCE16_XGXS_CL82_LN_1_AM_BYTE10r_CLR(r) (r).cl82_ln_1_am_byte10[0] = 0
#define BCMI_TSCE16_XGXS_CL82_LN_1_AM_BYTE10r_SET(r,d) (r).cl82_ln_1_am_byte10[0] = d
#define BCMI_TSCE16_XGXS_CL82_LN_1_AM_BYTE10r_GET(r) (r).cl82_ln_1_am_byte10[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_CL82_LN_1_AM_BYTE10r_LANE_1_AM_1_0f_GET(r) (((r).cl82_ln_1_am_byte10[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_CL82_LN_1_AM_BYTE10r_LANE_1_AM_1_0f_SET(r,f) (r).cl82_ln_1_am_byte10[0]=(((r).cl82_ln_1_am_byte10[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CL82_LN_1_AM_BYTE10.
 *
 */
#define BCMI_TSCE16_XGXS_READ_CL82_LN_1_AM_BYTE10r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL82_LN_1_AM_BYTE10r,(_r._cl82_ln_1_am_byte10))
#define BCMI_TSCE16_XGXS_WRITE_CL82_LN_1_AM_BYTE10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL82_LN_1_AM_BYTE10r,(_r._cl82_ln_1_am_byte10)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_CL82_LN_1_AM_BYTE10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL82_LN_1_AM_BYTE10r,(_r._cl82_ln_1_am_byte10))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL82_LN_1_AM_BYTE10r BCMI_TSCE16_XGXS_CL82_LN_1_AM_BYTE10r
#define CL82_LN_1_AM_BYTE10r_SIZE BCMI_TSCE16_XGXS_CL82_LN_1_AM_BYTE10r_SIZE
typedef BCMI_TSCE16_XGXS_CL82_LN_1_AM_BYTE10r_t CL82_LN_1_AM_BYTE10r_t;
#define CL82_LN_1_AM_BYTE10r_CLR BCMI_TSCE16_XGXS_CL82_LN_1_AM_BYTE10r_CLR
#define CL82_LN_1_AM_BYTE10r_SET BCMI_TSCE16_XGXS_CL82_LN_1_AM_BYTE10r_SET
#define CL82_LN_1_AM_BYTE10r_GET BCMI_TSCE16_XGXS_CL82_LN_1_AM_BYTE10r_GET
#define CL82_LN_1_AM_BYTE10r_LANE_1_AM_1_0f_GET BCMI_TSCE16_XGXS_CL82_LN_1_AM_BYTE10r_LANE_1_AM_1_0f_GET
#define CL82_LN_1_AM_BYTE10r_LANE_1_AM_1_0f_SET BCMI_TSCE16_XGXS_CL82_LN_1_AM_BYTE10r_LANE_1_AM_1_0f_SET
#define READ_CL82_LN_1_AM_BYTE10r BCMI_TSCE16_XGXS_READ_CL82_LN_1_AM_BYTE10r
#define WRITE_CL82_LN_1_AM_BYTE10r BCMI_TSCE16_XGXS_WRITE_CL82_LN_1_AM_BYTE10r
#define MODIFY_CL82_LN_1_AM_BYTE10r BCMI_TSCE16_XGXS_MODIFY_CL82_LN_1_AM_BYTE10r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_CL82_LN_1_AM_BYTE10r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  CL82_LANES_1_0_AM_BYTE2
 * BLOCKS:   CL82_AM_REGS
 * REGADDR:  0x9132
 * DESC:     cl82 LANES 1 and 0 AM BYTE 2 register
 * RESETVAL: 0xe647 (58951)
 * ACCESS:   R/W
 * FIELDS:
 *     LANE_0_AM_2      MLD Alignment Market Byte 2 for LANE 0.  Used in MLD20G and MLD120G modes only
 *     LANE_1_AM_2      MLD Alignment Market Byte 2 for LANE 1.  Used in MLD20G and MLD120G modes only
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_CL82_LANES_1_0_AM_BYTE2r (0x00109132 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_CL82_LANES_1_0_AM_BYTE2r_SIZE 4

/*
 * This structure should be used to declare and program CL82_LANES_1_0_AM_BYTE2.
 *
 */
typedef union BCMI_TSCE16_XGXS_CL82_LANES_1_0_AM_BYTE2r_s {
	uint32_t v[1];
	uint32_t cl82_lanes_1_0_am_byte2[1];
	uint32_t _cl82_lanes_1_0_am_byte2;
} BCMI_TSCE16_XGXS_CL82_LANES_1_0_AM_BYTE2r_t;

#define BCMI_TSCE16_XGXS_CL82_LANES_1_0_AM_BYTE2r_CLR(r) (r).cl82_lanes_1_0_am_byte2[0] = 0
#define BCMI_TSCE16_XGXS_CL82_LANES_1_0_AM_BYTE2r_SET(r,d) (r).cl82_lanes_1_0_am_byte2[0] = d
#define BCMI_TSCE16_XGXS_CL82_LANES_1_0_AM_BYTE2r_GET(r) (r).cl82_lanes_1_0_am_byte2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_CL82_LANES_1_0_AM_BYTE2r_LANE_1_AM_2f_GET(r) ((((r).cl82_lanes_1_0_am_byte2[0]) >> 8) & 0xff)
#define BCMI_TSCE16_XGXS_CL82_LANES_1_0_AM_BYTE2r_LANE_1_AM_2f_SET(r,f) (r).cl82_lanes_1_0_am_byte2[0]=(((r).cl82_lanes_1_0_am_byte2[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCE16_XGXS_CL82_LANES_1_0_AM_BYTE2r_LANE_0_AM_2f_GET(r) (((r).cl82_lanes_1_0_am_byte2[0]) & 0xff)
#define BCMI_TSCE16_XGXS_CL82_LANES_1_0_AM_BYTE2r_LANE_0_AM_2f_SET(r,f) (r).cl82_lanes_1_0_am_byte2[0]=(((r).cl82_lanes_1_0_am_byte2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access CL82_LANES_1_0_AM_BYTE2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_CL82_LANES_1_0_AM_BYTE2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL82_LANES_1_0_AM_BYTE2r,(_r._cl82_lanes_1_0_am_byte2))
#define BCMI_TSCE16_XGXS_WRITE_CL82_LANES_1_0_AM_BYTE2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL82_LANES_1_0_AM_BYTE2r,(_r._cl82_lanes_1_0_am_byte2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_CL82_LANES_1_0_AM_BYTE2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL82_LANES_1_0_AM_BYTE2r,(_r._cl82_lanes_1_0_am_byte2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL82_LANES_1_0_AM_BYTE2r BCMI_TSCE16_XGXS_CL82_LANES_1_0_AM_BYTE2r
#define CL82_LANES_1_0_AM_BYTE2r_SIZE BCMI_TSCE16_XGXS_CL82_LANES_1_0_AM_BYTE2r_SIZE
typedef BCMI_TSCE16_XGXS_CL82_LANES_1_0_AM_BYTE2r_t CL82_LANES_1_0_AM_BYTE2r_t;
#define CL82_LANES_1_0_AM_BYTE2r_CLR BCMI_TSCE16_XGXS_CL82_LANES_1_0_AM_BYTE2r_CLR
#define CL82_LANES_1_0_AM_BYTE2r_SET BCMI_TSCE16_XGXS_CL82_LANES_1_0_AM_BYTE2r_SET
#define CL82_LANES_1_0_AM_BYTE2r_GET BCMI_TSCE16_XGXS_CL82_LANES_1_0_AM_BYTE2r_GET
#define CL82_LANES_1_0_AM_BYTE2r_LANE_1_AM_2f_GET BCMI_TSCE16_XGXS_CL82_LANES_1_0_AM_BYTE2r_LANE_1_AM_2f_GET
#define CL82_LANES_1_0_AM_BYTE2r_LANE_1_AM_2f_SET BCMI_TSCE16_XGXS_CL82_LANES_1_0_AM_BYTE2r_LANE_1_AM_2f_SET
#define CL82_LANES_1_0_AM_BYTE2r_LANE_0_AM_2f_GET BCMI_TSCE16_XGXS_CL82_LANES_1_0_AM_BYTE2r_LANE_0_AM_2f_GET
#define CL82_LANES_1_0_AM_BYTE2r_LANE_0_AM_2f_SET BCMI_TSCE16_XGXS_CL82_LANES_1_0_AM_BYTE2r_LANE_0_AM_2f_SET
#define READ_CL82_LANES_1_0_AM_BYTE2r BCMI_TSCE16_XGXS_READ_CL82_LANES_1_0_AM_BYTE2r
#define WRITE_CL82_LANES_1_0_AM_BYTE2r BCMI_TSCE16_XGXS_WRITE_CL82_LANES_1_0_AM_BYTE2r
#define MODIFY_CL82_LANES_1_0_AM_BYTE2r BCMI_TSCE16_XGXS_MODIFY_CL82_LANES_1_0_AM_BYTE2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_CL82_LANES_1_0_AM_BYTE2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  LN_2_AM_BYTE10TSC_12
 * BLOCKS:   CL82_AM_REGS_TSC_12
 * REGADDR:  0x9140
 * DESC:     cl82 LANE 2 AM BYTES 1 AND 0 register
 * RESETVAL: 0x65c5 (26053)
 * ACCESS:   R/W
 * FIELDS:
 *     LANE_2_AM_1_0    TSC_12_ONLY: MLD Alignment Market Bytes 1 and 0 for VIRTUAL LANE 22.  Used in MLD120G mode only
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_LN_2_AM_BYTE10TSC_12r (0x00109140 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_LN_2_AM_BYTE10TSC_12r_SIZE 4

/*
 * This structure should be used to declare and program LN_2_AM_BYTE10TSC_12.
 *
 */
typedef union BCMI_TSCE16_XGXS_LN_2_AM_BYTE10TSC_12r_s {
	uint32_t v[1];
	uint32_t ln_2_am_byte10tsc_12[1];
	uint32_t _ln_2_am_byte10tsc_12;
} BCMI_TSCE16_XGXS_LN_2_AM_BYTE10TSC_12r_t;

#define BCMI_TSCE16_XGXS_LN_2_AM_BYTE10TSC_12r_CLR(r) (r).ln_2_am_byte10tsc_12[0] = 0
#define BCMI_TSCE16_XGXS_LN_2_AM_BYTE10TSC_12r_SET(r,d) (r).ln_2_am_byte10tsc_12[0] = d
#define BCMI_TSCE16_XGXS_LN_2_AM_BYTE10TSC_12r_GET(r) (r).ln_2_am_byte10tsc_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_LN_2_AM_BYTE10TSC_12r_LANE_2_AM_1_0f_GET(r) (((r).ln_2_am_byte10tsc_12[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_LN_2_AM_BYTE10TSC_12r_LANE_2_AM_1_0f_SET(r,f) (r).ln_2_am_byte10tsc_12[0]=(((r).ln_2_am_byte10tsc_12[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access LN_2_AM_BYTE10TSC_12.
 *
 */
#define BCMI_TSCE16_XGXS_READ_LN_2_AM_BYTE10TSC_12r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_LN_2_AM_BYTE10TSC_12r,(_r._ln_2_am_byte10tsc_12))
#define BCMI_TSCE16_XGXS_WRITE_LN_2_AM_BYTE10TSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_LN_2_AM_BYTE10TSC_12r,(_r._ln_2_am_byte10tsc_12)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_LN_2_AM_BYTE10TSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_LN_2_AM_BYTE10TSC_12r,(_r._ln_2_am_byte10tsc_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_2_AM_BYTE10TSC_12r BCMI_TSCE16_XGXS_LN_2_AM_BYTE10TSC_12r
#define LN_2_AM_BYTE10TSC_12r_SIZE BCMI_TSCE16_XGXS_LN_2_AM_BYTE10TSC_12r_SIZE
typedef BCMI_TSCE16_XGXS_LN_2_AM_BYTE10TSC_12r_t LN_2_AM_BYTE10TSC_12r_t;
#define LN_2_AM_BYTE10TSC_12r_CLR BCMI_TSCE16_XGXS_LN_2_AM_BYTE10TSC_12r_CLR
#define LN_2_AM_BYTE10TSC_12r_SET BCMI_TSCE16_XGXS_LN_2_AM_BYTE10TSC_12r_SET
#define LN_2_AM_BYTE10TSC_12r_GET BCMI_TSCE16_XGXS_LN_2_AM_BYTE10TSC_12r_GET
#define LN_2_AM_BYTE10TSC_12r_LANE_2_AM_1_0f_GET BCMI_TSCE16_XGXS_LN_2_AM_BYTE10TSC_12r_LANE_2_AM_1_0f_GET
#define LN_2_AM_BYTE10TSC_12r_LANE_2_AM_1_0f_SET BCMI_TSCE16_XGXS_LN_2_AM_BYTE10TSC_12r_LANE_2_AM_1_0f_SET
#define READ_LN_2_AM_BYTE10TSC_12r BCMI_TSCE16_XGXS_READ_LN_2_AM_BYTE10TSC_12r
#define WRITE_LN_2_AM_BYTE10TSC_12r BCMI_TSCE16_XGXS_WRITE_LN_2_AM_BYTE10TSC_12r
#define MODIFY_LN_2_AM_BYTE10TSC_12r BCMI_TSCE16_XGXS_MODIFY_LN_2_AM_BYTE10TSC_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_LN_2_AM_BYTE10TSC_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  LN_3_AM_BYTE10TSC_12
 * BLOCKS:   CL82_AM_REGS_TSC_12
 * REGADDR:  0x9141
 * DESC:     cl82 LANE 3 AM BYTES 1 AND 0 register
 * RESETVAL: 0x79a2 (31138)
 * ACCESS:   R/W
 * FIELDS:
 *     LANE_3_AM_1_0    TSC_12_ONLY: MLD Alignment Market Bytes 1 and 0 for VIRTUAL LANE 23.  Used in MLD120G mode only
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_LN_3_AM_BYTE10TSC_12r (0x00109141 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_LN_3_AM_BYTE10TSC_12r_SIZE 4

/*
 * This structure should be used to declare and program LN_3_AM_BYTE10TSC_12.
 *
 */
typedef union BCMI_TSCE16_XGXS_LN_3_AM_BYTE10TSC_12r_s {
	uint32_t v[1];
	uint32_t ln_3_am_byte10tsc_12[1];
	uint32_t _ln_3_am_byte10tsc_12;
} BCMI_TSCE16_XGXS_LN_3_AM_BYTE10TSC_12r_t;

#define BCMI_TSCE16_XGXS_LN_3_AM_BYTE10TSC_12r_CLR(r) (r).ln_3_am_byte10tsc_12[0] = 0
#define BCMI_TSCE16_XGXS_LN_3_AM_BYTE10TSC_12r_SET(r,d) (r).ln_3_am_byte10tsc_12[0] = d
#define BCMI_TSCE16_XGXS_LN_3_AM_BYTE10TSC_12r_GET(r) (r).ln_3_am_byte10tsc_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_LN_3_AM_BYTE10TSC_12r_LANE_3_AM_1_0f_GET(r) (((r).ln_3_am_byte10tsc_12[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_LN_3_AM_BYTE10TSC_12r_LANE_3_AM_1_0f_SET(r,f) (r).ln_3_am_byte10tsc_12[0]=(((r).ln_3_am_byte10tsc_12[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access LN_3_AM_BYTE10TSC_12.
 *
 */
#define BCMI_TSCE16_XGXS_READ_LN_3_AM_BYTE10TSC_12r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_LN_3_AM_BYTE10TSC_12r,(_r._ln_3_am_byte10tsc_12))
#define BCMI_TSCE16_XGXS_WRITE_LN_3_AM_BYTE10TSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_LN_3_AM_BYTE10TSC_12r,(_r._ln_3_am_byte10tsc_12)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_LN_3_AM_BYTE10TSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_LN_3_AM_BYTE10TSC_12r,(_r._ln_3_am_byte10tsc_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_3_AM_BYTE10TSC_12r BCMI_TSCE16_XGXS_LN_3_AM_BYTE10TSC_12r
#define LN_3_AM_BYTE10TSC_12r_SIZE BCMI_TSCE16_XGXS_LN_3_AM_BYTE10TSC_12r_SIZE
typedef BCMI_TSCE16_XGXS_LN_3_AM_BYTE10TSC_12r_t LN_3_AM_BYTE10TSC_12r_t;
#define LN_3_AM_BYTE10TSC_12r_CLR BCMI_TSCE16_XGXS_LN_3_AM_BYTE10TSC_12r_CLR
#define LN_3_AM_BYTE10TSC_12r_SET BCMI_TSCE16_XGXS_LN_3_AM_BYTE10TSC_12r_SET
#define LN_3_AM_BYTE10TSC_12r_GET BCMI_TSCE16_XGXS_LN_3_AM_BYTE10TSC_12r_GET
#define LN_3_AM_BYTE10TSC_12r_LANE_3_AM_1_0f_GET BCMI_TSCE16_XGXS_LN_3_AM_BYTE10TSC_12r_LANE_3_AM_1_0f_GET
#define LN_3_AM_BYTE10TSC_12r_LANE_3_AM_1_0f_SET BCMI_TSCE16_XGXS_LN_3_AM_BYTE10TSC_12r_LANE_3_AM_1_0f_SET
#define READ_LN_3_AM_BYTE10TSC_12r BCMI_TSCE16_XGXS_READ_LN_3_AM_BYTE10TSC_12r
#define WRITE_LN_3_AM_BYTE10TSC_12r BCMI_TSCE16_XGXS_WRITE_LN_3_AM_BYTE10TSC_12r
#define MODIFY_LN_3_AM_BYTE10TSC_12r BCMI_TSCE16_XGXS_MODIFY_LN_3_AM_BYTE10TSC_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_LN_3_AM_BYTE10TSC_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  LANES_3_2_AM_BYTE2TSC_12
 * BLOCKS:   CL82_AM_REGS_TSC_12
 * REGADDR:  0x9142
 * DESC:     cl82 LANES 3 and 2 AM BYTE 2 register
 * RESETVAL: 0x3d9b (15771)
 * ACCESS:   R/W
 * FIELDS:
 *     LANE_2_AM_2      TSC_12_ONLY: MLD Alignment Market Byte 2 for VIRTUAL LANE 22.  Used in MLD120G mode only
 *     LANE_3_AM_2      TSC_12_ONLY: MLD Alignment Market Byte 2 for VIRTUAL LANE 23.  Used in MLD120G mode only
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_LANES_3_2_AM_BYTE2TSC_12r (0x00109142 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_LANES_3_2_AM_BYTE2TSC_12r_SIZE 4

/*
 * This structure should be used to declare and program LANES_3_2_AM_BYTE2TSC_12.
 *
 */
typedef union BCMI_TSCE16_XGXS_LANES_3_2_AM_BYTE2TSC_12r_s {
	uint32_t v[1];
	uint32_t lanes_3_2_am_byte2tsc_12[1];
	uint32_t _lanes_3_2_am_byte2tsc_12;
} BCMI_TSCE16_XGXS_LANES_3_2_AM_BYTE2TSC_12r_t;

#define BCMI_TSCE16_XGXS_LANES_3_2_AM_BYTE2TSC_12r_CLR(r) (r).lanes_3_2_am_byte2tsc_12[0] = 0
#define BCMI_TSCE16_XGXS_LANES_3_2_AM_BYTE2TSC_12r_SET(r,d) (r).lanes_3_2_am_byte2tsc_12[0] = d
#define BCMI_TSCE16_XGXS_LANES_3_2_AM_BYTE2TSC_12r_GET(r) (r).lanes_3_2_am_byte2tsc_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_LANES_3_2_AM_BYTE2TSC_12r_LANE_3_AM_2f_GET(r) ((((r).lanes_3_2_am_byte2tsc_12[0]) >> 8) & 0xff)
#define BCMI_TSCE16_XGXS_LANES_3_2_AM_BYTE2TSC_12r_LANE_3_AM_2f_SET(r,f) (r).lanes_3_2_am_byte2tsc_12[0]=(((r).lanes_3_2_am_byte2tsc_12[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCE16_XGXS_LANES_3_2_AM_BYTE2TSC_12r_LANE_2_AM_2f_GET(r) (((r).lanes_3_2_am_byte2tsc_12[0]) & 0xff)
#define BCMI_TSCE16_XGXS_LANES_3_2_AM_BYTE2TSC_12r_LANE_2_AM_2f_SET(r,f) (r).lanes_3_2_am_byte2tsc_12[0]=(((r).lanes_3_2_am_byte2tsc_12[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access LANES_3_2_AM_BYTE2TSC_12.
 *
 */
#define BCMI_TSCE16_XGXS_READ_LANES_3_2_AM_BYTE2TSC_12r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_LANES_3_2_AM_BYTE2TSC_12r,(_r._lanes_3_2_am_byte2tsc_12))
#define BCMI_TSCE16_XGXS_WRITE_LANES_3_2_AM_BYTE2TSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_LANES_3_2_AM_BYTE2TSC_12r,(_r._lanes_3_2_am_byte2tsc_12)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_LANES_3_2_AM_BYTE2TSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_LANES_3_2_AM_BYTE2TSC_12r,(_r._lanes_3_2_am_byte2tsc_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LANES_3_2_AM_BYTE2TSC_12r BCMI_TSCE16_XGXS_LANES_3_2_AM_BYTE2TSC_12r
#define LANES_3_2_AM_BYTE2TSC_12r_SIZE BCMI_TSCE16_XGXS_LANES_3_2_AM_BYTE2TSC_12r_SIZE
typedef BCMI_TSCE16_XGXS_LANES_3_2_AM_BYTE2TSC_12r_t LANES_3_2_AM_BYTE2TSC_12r_t;
#define LANES_3_2_AM_BYTE2TSC_12r_CLR BCMI_TSCE16_XGXS_LANES_3_2_AM_BYTE2TSC_12r_CLR
#define LANES_3_2_AM_BYTE2TSC_12r_SET BCMI_TSCE16_XGXS_LANES_3_2_AM_BYTE2TSC_12r_SET
#define LANES_3_2_AM_BYTE2TSC_12r_GET BCMI_TSCE16_XGXS_LANES_3_2_AM_BYTE2TSC_12r_GET
#define LANES_3_2_AM_BYTE2TSC_12r_LANE_3_AM_2f_GET BCMI_TSCE16_XGXS_LANES_3_2_AM_BYTE2TSC_12r_LANE_3_AM_2f_GET
#define LANES_3_2_AM_BYTE2TSC_12r_LANE_3_AM_2f_SET BCMI_TSCE16_XGXS_LANES_3_2_AM_BYTE2TSC_12r_LANE_3_AM_2f_SET
#define LANES_3_2_AM_BYTE2TSC_12r_LANE_2_AM_2f_GET BCMI_TSCE16_XGXS_LANES_3_2_AM_BYTE2TSC_12r_LANE_2_AM_2f_GET
#define LANES_3_2_AM_BYTE2TSC_12r_LANE_2_AM_2f_SET BCMI_TSCE16_XGXS_LANES_3_2_AM_BYTE2TSC_12r_LANE_2_AM_2f_SET
#define READ_LANES_3_2_AM_BYTE2TSC_12r BCMI_TSCE16_XGXS_READ_LANES_3_2_AM_BYTE2TSC_12r
#define WRITE_LANES_3_2_AM_BYTE2TSC_12r BCMI_TSCE16_XGXS_WRITE_LANES_3_2_AM_BYTE2TSC_12r
#define MODIFY_LANES_3_2_AM_BYTE2TSC_12r BCMI_TSCE16_XGXS_MODIFY_LANES_3_2_AM_BYTE2TSC_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_LANES_3_2_AM_BYTE2TSC_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X1_DEC_CTL0
 * BLOCKS:   RX_X1_CONTROL0
 * REGADDR:  0x9220
 * DESC:     Sync code word statemachine control register
 * RESETVAL: 0x101 (257)
 * ACCESS:   R/W
 * FIELDS:
 *     HYSTCOUNT        Only used for BRCM 66/64 CL48 speedsWait for hystCount bad code words in a row before traversing from SYNC_ACQD1->LOSS_OF_SYNC state in the code word sync state machine.
 *     GCWCOUNT         Only used for BRCM 66/64 CL48 speedsWait for gcwCount good code words in a row before traversing from SYNC_ACQD2->SYNC_ACQD1 state in the code word sync state machine.
 *     SCWCOUNT         Only used for BRCM 66/64 CL48 speedsWait for scwCount CWs=SCWs in a row before traversing from COMMA_DETECT->SYNC_ACQD1 state in the code word sync state machine.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X1_DEC_CTL0r (0x00109220 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X1_DEC_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_DEC_CTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X1_DEC_CTL0r_s {
	uint32_t v[1];
	uint32_t rx_x1_dec_ctl0[1];
	uint32_t _rx_x1_dec_ctl0;
} BCMI_TSCE16_XGXS_RX_X1_DEC_CTL0r_t;

#define BCMI_TSCE16_XGXS_RX_X1_DEC_CTL0r_CLR(r) (r).rx_x1_dec_ctl0[0] = 0
#define BCMI_TSCE16_XGXS_RX_X1_DEC_CTL0r_SET(r,d) (r).rx_x1_dec_ctl0[0] = d
#define BCMI_TSCE16_XGXS_RX_X1_DEC_CTL0r_GET(r) (r).rx_x1_dec_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X1_DEC_CTL0r_SCWCOUNTf_GET(r) ((((r).rx_x1_dec_ctl0[0]) >> 8) & 0xf)
#define BCMI_TSCE16_XGXS_RX_X1_DEC_CTL0r_SCWCOUNTf_SET(r,f) (r).rx_x1_dec_ctl0[0]=(((r).rx_x1_dec_ctl0[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_TSCE16_XGXS_RX_X1_DEC_CTL0r_GCWCOUNTf_GET(r) ((((r).rx_x1_dec_ctl0[0]) >> 4) & 0xf)
#define BCMI_TSCE16_XGXS_RX_X1_DEC_CTL0r_GCWCOUNTf_SET(r,f) (r).rx_x1_dec_ctl0[0]=(((r).rx_x1_dec_ctl0[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_TSCE16_XGXS_RX_X1_DEC_CTL0r_HYSTCOUNTf_GET(r) (((r).rx_x1_dec_ctl0[0]) & 0xf)
#define BCMI_TSCE16_XGXS_RX_X1_DEC_CTL0r_HYSTCOUNTf_SET(r,f) (r).rx_x1_dec_ctl0[0]=(((r).rx_x1_dec_ctl0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access RX_X1_DEC_CTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X1_DEC_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X1_DEC_CTL0r,(_r._rx_x1_dec_ctl0))
#define BCMI_TSCE16_XGXS_WRITE_RX_X1_DEC_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X1_DEC_CTL0r,(_r._rx_x1_dec_ctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X1_DEC_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X1_DEC_CTL0r,(_r._rx_x1_dec_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_DEC_CTL0r BCMI_TSCE16_XGXS_RX_X1_DEC_CTL0r
#define RX_X1_DEC_CTL0r_SIZE BCMI_TSCE16_XGXS_RX_X1_DEC_CTL0r_SIZE
typedef BCMI_TSCE16_XGXS_RX_X1_DEC_CTL0r_t RX_X1_DEC_CTL0r_t;
#define RX_X1_DEC_CTL0r_CLR BCMI_TSCE16_XGXS_RX_X1_DEC_CTL0r_CLR
#define RX_X1_DEC_CTL0r_SET BCMI_TSCE16_XGXS_RX_X1_DEC_CTL0r_SET
#define RX_X1_DEC_CTL0r_GET BCMI_TSCE16_XGXS_RX_X1_DEC_CTL0r_GET
#define RX_X1_DEC_CTL0r_SCWCOUNTf_GET BCMI_TSCE16_XGXS_RX_X1_DEC_CTL0r_SCWCOUNTf_GET
#define RX_X1_DEC_CTL0r_SCWCOUNTf_SET BCMI_TSCE16_XGXS_RX_X1_DEC_CTL0r_SCWCOUNTf_SET
#define RX_X1_DEC_CTL0r_GCWCOUNTf_GET BCMI_TSCE16_XGXS_RX_X1_DEC_CTL0r_GCWCOUNTf_GET
#define RX_X1_DEC_CTL0r_GCWCOUNTf_SET BCMI_TSCE16_XGXS_RX_X1_DEC_CTL0r_GCWCOUNTf_SET
#define RX_X1_DEC_CTL0r_HYSTCOUNTf_GET BCMI_TSCE16_XGXS_RX_X1_DEC_CTL0r_HYSTCOUNTf_GET
#define RX_X1_DEC_CTL0r_HYSTCOUNTf_SET BCMI_TSCE16_XGXS_RX_X1_DEC_CTL0r_HYSTCOUNTf_SET
#define READ_RX_X1_DEC_CTL0r BCMI_TSCE16_XGXS_READ_RX_X1_DEC_CTL0r
#define WRITE_RX_X1_DEC_CTL0r BCMI_TSCE16_XGXS_WRITE_RX_X1_DEC_CTL0r
#define MODIFY_RX_X1_DEC_CTL0r BCMI_TSCE16_XGXS_MODIFY_RX_X1_DEC_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X1_DEC_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X1_DEC_CTL1
 * BLOCKS:   RX_X1_CONTROL0
 * REGADDR:  0x9221
 * DESC:     decode_control_1 register
 * RESETVAL: 0x6140 (24896)
 * ACCESS:   R/W
 * FIELDS:
 *     CL49_BER_LIMIT   Number of Error Blocks before HI_BER is determined for CL49
 *     CL82_BER_LIMIT   Number of Error Blocks before HI_BER is determined for CL82
 *     SET_BER_WINDOW_512 Sets the BER measurement window to 512 blocks instead of the IEEE definition.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X1_DEC_CTL1r (0x00109221 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X1_DEC_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_DEC_CTL1.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X1_DEC_CTL1r_s {
	uint32_t v[1];
	uint32_t rx_x1_dec_ctl1[1];
	uint32_t _rx_x1_dec_ctl1;
} BCMI_TSCE16_XGXS_RX_X1_DEC_CTL1r_t;

#define BCMI_TSCE16_XGXS_RX_X1_DEC_CTL1r_CLR(r) (r).rx_x1_dec_ctl1[0] = 0
#define BCMI_TSCE16_XGXS_RX_X1_DEC_CTL1r_SET(r,d) (r).rx_x1_dec_ctl1[0] = d
#define BCMI_TSCE16_XGXS_RX_X1_DEC_CTL1r_GET(r) (r).rx_x1_dec_ctl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X1_DEC_CTL1r_SET_BER_WINDOW_512f_GET(r) ((((r).rx_x1_dec_ctl1[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X1_DEC_CTL1r_SET_BER_WINDOW_512f_SET(r,f) (r).rx_x1_dec_ctl1[0]=(((r).rx_x1_dec_ctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_RX_X1_DEC_CTL1r_CL82_BER_LIMITf_GET(r) ((((r).rx_x1_dec_ctl1[0]) >> 8) & 0x7f)
#define BCMI_TSCE16_XGXS_RX_X1_DEC_CTL1r_CL82_BER_LIMITf_SET(r,f) (r).rx_x1_dec_ctl1[0]=(((r).rx_x1_dec_ctl1[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8)) | (127 << (16 + 8))
#define BCMI_TSCE16_XGXS_RX_X1_DEC_CTL1r_CL49_BER_LIMITf_GET(r) ((((r).rx_x1_dec_ctl1[0]) >> 2) & 0x3f)
#define BCMI_TSCE16_XGXS_RX_X1_DEC_CTL1r_CL49_BER_LIMITf_SET(r,f) (r).rx_x1_dec_ctl1[0]=(((r).rx_x1_dec_ctl1[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2)) | (63 << (16 + 2))

/*
 * These macros can be used to access RX_X1_DEC_CTL1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X1_DEC_CTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X1_DEC_CTL1r,(_r._rx_x1_dec_ctl1))
#define BCMI_TSCE16_XGXS_WRITE_RX_X1_DEC_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X1_DEC_CTL1r,(_r._rx_x1_dec_ctl1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X1_DEC_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X1_DEC_CTL1r,(_r._rx_x1_dec_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_DEC_CTL1r BCMI_TSCE16_XGXS_RX_X1_DEC_CTL1r
#define RX_X1_DEC_CTL1r_SIZE BCMI_TSCE16_XGXS_RX_X1_DEC_CTL1r_SIZE
typedef BCMI_TSCE16_XGXS_RX_X1_DEC_CTL1r_t RX_X1_DEC_CTL1r_t;
#define RX_X1_DEC_CTL1r_CLR BCMI_TSCE16_XGXS_RX_X1_DEC_CTL1r_CLR
#define RX_X1_DEC_CTL1r_SET BCMI_TSCE16_XGXS_RX_X1_DEC_CTL1r_SET
#define RX_X1_DEC_CTL1r_GET BCMI_TSCE16_XGXS_RX_X1_DEC_CTL1r_GET
#define RX_X1_DEC_CTL1r_SET_BER_WINDOW_512f_GET BCMI_TSCE16_XGXS_RX_X1_DEC_CTL1r_SET_BER_WINDOW_512f_GET
#define RX_X1_DEC_CTL1r_SET_BER_WINDOW_512f_SET BCMI_TSCE16_XGXS_RX_X1_DEC_CTL1r_SET_BER_WINDOW_512f_SET
#define RX_X1_DEC_CTL1r_CL82_BER_LIMITf_GET BCMI_TSCE16_XGXS_RX_X1_DEC_CTL1r_CL82_BER_LIMITf_GET
#define RX_X1_DEC_CTL1r_CL82_BER_LIMITf_SET BCMI_TSCE16_XGXS_RX_X1_DEC_CTL1r_CL82_BER_LIMITf_SET
#define RX_X1_DEC_CTL1r_CL49_BER_LIMITf_GET BCMI_TSCE16_XGXS_RX_X1_DEC_CTL1r_CL49_BER_LIMITf_GET
#define RX_X1_DEC_CTL1r_CL49_BER_LIMITf_SET BCMI_TSCE16_XGXS_RX_X1_DEC_CTL1r_CL49_BER_LIMITf_SET
#define READ_RX_X1_DEC_CTL1r BCMI_TSCE16_XGXS_READ_RX_X1_DEC_CTL1r
#define WRITE_RX_X1_DEC_CTL1r BCMI_TSCE16_XGXS_WRITE_RX_X1_DEC_CTL1r
#define MODIFY_RX_X1_DEC_CTL1r BCMI_TSCE16_XGXS_MODIFY_RX_X1_DEC_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X1_DEC_CTL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X1_DESKEW_WINS
 * BLOCKS:   RX_X1_CONTROL0
 * REGADDR:  0x9222
 * DESC:     deskew_windows register
 * RESETVAL: 0xeea7 (61095)
 * ACCESS:   R/W
 * FIELDS:
 *     CL48_DSWIN8B10B  CL48 Byte based deskew window sizedeskew_window = (cl48_dswin8B10B+1)bytes
 *     CL48_DSWIN64B66B CL48 Block based deskew window sizedeskew_window = (cl48_dswin64B66B+1)blocks
 *     CL82_DSWIN       CL82 Block based deskew window size for 20g and 40g configurationsdeskew_window = (cl82_dswin+1)blocks
 *     CL82_DSWIN_100G  CL82 Block based deskew window size for 100g and higher configurationsdeskew_window = (cl82_dswin_100g+1)blocks
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X1_DESKEW_WINSr (0x00109222 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X1_DESKEW_WINSr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_DESKEW_WINS.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X1_DESKEW_WINSr_s {
	uint32_t v[1];
	uint32_t rx_x1_deskew_wins[1];
	uint32_t _rx_x1_deskew_wins;
} BCMI_TSCE16_XGXS_RX_X1_DESKEW_WINSr_t;

#define BCMI_TSCE16_XGXS_RX_X1_DESKEW_WINSr_CLR(r) (r).rx_x1_deskew_wins[0] = 0
#define BCMI_TSCE16_XGXS_RX_X1_DESKEW_WINSr_SET(r,d) (r).rx_x1_deskew_wins[0] = d
#define BCMI_TSCE16_XGXS_RX_X1_DESKEW_WINSr_GET(r) (r).rx_x1_deskew_wins[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X1_DESKEW_WINSr_CL82_DSWIN_100Gf_GET(r) ((((r).rx_x1_deskew_wins[0]) >> 12) & 0xf)
#define BCMI_TSCE16_XGXS_RX_X1_DESKEW_WINSr_CL82_DSWIN_100Gf_SET(r,f) (r).rx_x1_deskew_wins[0]=(((r).rx_x1_deskew_wins[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCE16_XGXS_RX_X1_DESKEW_WINSr_CL82_DSWINf_GET(r) ((((r).rx_x1_deskew_wins[0]) >> 7) & 0x1f)
#define BCMI_TSCE16_XGXS_RX_X1_DESKEW_WINSr_CL82_DSWINf_SET(r,f) (r).rx_x1_deskew_wins[0]=(((r).rx_x1_deskew_wins[0] & ~((uint32_t)0x1f << 7)) | ((((uint32_t)f) & 0x1f) << 7)) | (31 << (16 + 7))
#define BCMI_TSCE16_XGXS_RX_X1_DESKEW_WINSr_CL48_DSWIN64B66Bf_GET(r) ((((r).rx_x1_deskew_wins[0]) >> 4) & 0x7)
#define BCMI_TSCE16_XGXS_RX_X1_DESKEW_WINSr_CL48_DSWIN64B66Bf_SET(r,f) (r).rx_x1_deskew_wins[0]=(((r).rx_x1_deskew_wins[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_TSCE16_XGXS_RX_X1_DESKEW_WINSr_CL48_DSWIN8B10Bf_GET(r) (((r).rx_x1_deskew_wins[0]) & 0xf)
#define BCMI_TSCE16_XGXS_RX_X1_DESKEW_WINSr_CL48_DSWIN8B10Bf_SET(r,f) (r).rx_x1_deskew_wins[0]=(((r).rx_x1_deskew_wins[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access RX_X1_DESKEW_WINS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X1_DESKEW_WINSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X1_DESKEW_WINSr,(_r._rx_x1_deskew_wins))
#define BCMI_TSCE16_XGXS_WRITE_RX_X1_DESKEW_WINSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X1_DESKEW_WINSr,(_r._rx_x1_deskew_wins)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X1_DESKEW_WINSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X1_DESKEW_WINSr,(_r._rx_x1_deskew_wins))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_DESKEW_WINSr BCMI_TSCE16_XGXS_RX_X1_DESKEW_WINSr
#define RX_X1_DESKEW_WINSr_SIZE BCMI_TSCE16_XGXS_RX_X1_DESKEW_WINSr_SIZE
typedef BCMI_TSCE16_XGXS_RX_X1_DESKEW_WINSr_t RX_X1_DESKEW_WINSr_t;
#define RX_X1_DESKEW_WINSr_CLR BCMI_TSCE16_XGXS_RX_X1_DESKEW_WINSr_CLR
#define RX_X1_DESKEW_WINSr_SET BCMI_TSCE16_XGXS_RX_X1_DESKEW_WINSr_SET
#define RX_X1_DESKEW_WINSr_GET BCMI_TSCE16_XGXS_RX_X1_DESKEW_WINSr_GET
#define RX_X1_DESKEW_WINSr_CL82_DSWIN_100Gf_GET BCMI_TSCE16_XGXS_RX_X1_DESKEW_WINSr_CL82_DSWIN_100Gf_GET
#define RX_X1_DESKEW_WINSr_CL82_DSWIN_100Gf_SET BCMI_TSCE16_XGXS_RX_X1_DESKEW_WINSr_CL82_DSWIN_100Gf_SET
#define RX_X1_DESKEW_WINSr_CL82_DSWINf_GET BCMI_TSCE16_XGXS_RX_X1_DESKEW_WINSr_CL82_DSWINf_GET
#define RX_X1_DESKEW_WINSr_CL82_DSWINf_SET BCMI_TSCE16_XGXS_RX_X1_DESKEW_WINSr_CL82_DSWINf_SET
#define RX_X1_DESKEW_WINSr_CL48_DSWIN64B66Bf_GET BCMI_TSCE16_XGXS_RX_X1_DESKEW_WINSr_CL48_DSWIN64B66Bf_GET
#define RX_X1_DESKEW_WINSr_CL48_DSWIN64B66Bf_SET BCMI_TSCE16_XGXS_RX_X1_DESKEW_WINSr_CL48_DSWIN64B66Bf_SET
#define RX_X1_DESKEW_WINSr_CL48_DSWIN8B10Bf_GET BCMI_TSCE16_XGXS_RX_X1_DESKEW_WINSr_CL48_DSWIN8B10Bf_GET
#define RX_X1_DESKEW_WINSr_CL48_DSWIN8B10Bf_SET BCMI_TSCE16_XGXS_RX_X1_DESKEW_WINSr_CL48_DSWIN8B10Bf_SET
#define READ_RX_X1_DESKEW_WINSr BCMI_TSCE16_XGXS_READ_RX_X1_DESKEW_WINSr
#define WRITE_RX_X1_DESKEW_WINSr BCMI_TSCE16_XGXS_WRITE_RX_X1_DESKEW_WINSr
#define MODIFY_RX_X1_DESKEW_WINSr BCMI_TSCE16_XGXS_MODIFY_RX_X1_DESKEW_WINSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X1_DESKEW_WINSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X1_SHCNT_CL49
 * BLOCKS:   RX_X1_CONTROL1
 * REGADDR:  0x9230
 * DESC:     CL49 sync header valid/invalid counters
 * RESETVAL: 0x4010 (16400)
 * ACCESS:   R/W
 * FIELDS:
 *     CL49_INVALID_SH_CNT invalid sync header count for block lock fsm in cl49 mode
 *     CL49_VALID_SH_CNT valid sync header count for block lock fsm in cl49 mode
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X1_SHCNT_CL49r (0x00109230 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X1_SHCNT_CL49r_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_SHCNT_CL49.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X1_SHCNT_CL49r_s {
	uint32_t v[1];
	uint32_t rx_x1_shcnt_cl49[1];
	uint32_t _rx_x1_shcnt_cl49;
} BCMI_TSCE16_XGXS_RX_X1_SHCNT_CL49r_t;

#define BCMI_TSCE16_XGXS_RX_X1_SHCNT_CL49r_CLR(r) (r).rx_x1_shcnt_cl49[0] = 0
#define BCMI_TSCE16_XGXS_RX_X1_SHCNT_CL49r_SET(r,d) (r).rx_x1_shcnt_cl49[0] = d
#define BCMI_TSCE16_XGXS_RX_X1_SHCNT_CL49r_GET(r) (r).rx_x1_shcnt_cl49[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X1_SHCNT_CL49r_CL49_VALID_SH_CNTf_GET(r) ((((r).rx_x1_shcnt_cl49[0]) >> 8) & 0xff)
#define BCMI_TSCE16_XGXS_RX_X1_SHCNT_CL49r_CL49_VALID_SH_CNTf_SET(r,f) (r).rx_x1_shcnt_cl49[0]=(((r).rx_x1_shcnt_cl49[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCE16_XGXS_RX_X1_SHCNT_CL49r_CL49_INVALID_SH_CNTf_GET(r) (((r).rx_x1_shcnt_cl49[0]) & 0xff)
#define BCMI_TSCE16_XGXS_RX_X1_SHCNT_CL49r_CL49_INVALID_SH_CNTf_SET(r,f) (r).rx_x1_shcnt_cl49[0]=(((r).rx_x1_shcnt_cl49[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access RX_X1_SHCNT_CL49.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X1_SHCNT_CL49r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X1_SHCNT_CL49r,(_r._rx_x1_shcnt_cl49))
#define BCMI_TSCE16_XGXS_WRITE_RX_X1_SHCNT_CL49r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X1_SHCNT_CL49r,(_r._rx_x1_shcnt_cl49)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X1_SHCNT_CL49r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X1_SHCNT_CL49r,(_r._rx_x1_shcnt_cl49))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_SHCNT_CL49r BCMI_TSCE16_XGXS_RX_X1_SHCNT_CL49r
#define RX_X1_SHCNT_CL49r_SIZE BCMI_TSCE16_XGXS_RX_X1_SHCNT_CL49r_SIZE
typedef BCMI_TSCE16_XGXS_RX_X1_SHCNT_CL49r_t RX_X1_SHCNT_CL49r_t;
#define RX_X1_SHCNT_CL49r_CLR BCMI_TSCE16_XGXS_RX_X1_SHCNT_CL49r_CLR
#define RX_X1_SHCNT_CL49r_SET BCMI_TSCE16_XGXS_RX_X1_SHCNT_CL49r_SET
#define RX_X1_SHCNT_CL49r_GET BCMI_TSCE16_XGXS_RX_X1_SHCNT_CL49r_GET
#define RX_X1_SHCNT_CL49r_CL49_VALID_SH_CNTf_GET BCMI_TSCE16_XGXS_RX_X1_SHCNT_CL49r_CL49_VALID_SH_CNTf_GET
#define RX_X1_SHCNT_CL49r_CL49_VALID_SH_CNTf_SET BCMI_TSCE16_XGXS_RX_X1_SHCNT_CL49r_CL49_VALID_SH_CNTf_SET
#define RX_X1_SHCNT_CL49r_CL49_INVALID_SH_CNTf_GET BCMI_TSCE16_XGXS_RX_X1_SHCNT_CL49r_CL49_INVALID_SH_CNTf_GET
#define RX_X1_SHCNT_CL49r_CL49_INVALID_SH_CNTf_SET BCMI_TSCE16_XGXS_RX_X1_SHCNT_CL49r_CL49_INVALID_SH_CNTf_SET
#define READ_RX_X1_SHCNT_CL49r BCMI_TSCE16_XGXS_READ_RX_X1_SHCNT_CL49r
#define WRITE_RX_X1_SHCNT_CL49r BCMI_TSCE16_XGXS_WRITE_RX_X1_SHCNT_CL49r
#define MODIFY_RX_X1_SHCNT_CL49r BCMI_TSCE16_XGXS_MODIFY_RX_X1_SHCNT_CL49r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X1_SHCNT_CL49r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X1_VALID_SHCNT_CL82
 * BLOCKS:   RX_X1_CONTROL1
 * REGADDR:  0x9231
 * DESC:     CL49 sync header valid counter
 * RESETVAL: 0x400 (1024)
 * ACCESS:   R/W
 * FIELDS:
 *     CL82_VALID_SH_CNT valid sync header count for block lock fsm in cl82 mode
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X1_VALID_SHCNT_CL82r (0x00109231 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X1_VALID_SHCNT_CL82r_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_VALID_SHCNT_CL82.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X1_VALID_SHCNT_CL82r_s {
	uint32_t v[1];
	uint32_t rx_x1_valid_shcnt_cl82[1];
	uint32_t _rx_x1_valid_shcnt_cl82;
} BCMI_TSCE16_XGXS_RX_X1_VALID_SHCNT_CL82r_t;

#define BCMI_TSCE16_XGXS_RX_X1_VALID_SHCNT_CL82r_CLR(r) (r).rx_x1_valid_shcnt_cl82[0] = 0
#define BCMI_TSCE16_XGXS_RX_X1_VALID_SHCNT_CL82r_SET(r,d) (r).rx_x1_valid_shcnt_cl82[0] = d
#define BCMI_TSCE16_XGXS_RX_X1_VALID_SHCNT_CL82r_GET(r) (r).rx_x1_valid_shcnt_cl82[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X1_VALID_SHCNT_CL82r_CL82_VALID_SH_CNTf_GET(r) (((r).rx_x1_valid_shcnt_cl82[0]) & 0xfff)
#define BCMI_TSCE16_XGXS_RX_X1_VALID_SHCNT_CL82r_CL82_VALID_SH_CNTf_SET(r,f) (r).rx_x1_valid_shcnt_cl82[0]=(((r).rx_x1_valid_shcnt_cl82[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff)) | (0xfff << 16)

/*
 * These macros can be used to access RX_X1_VALID_SHCNT_CL82.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X1_VALID_SHCNT_CL82r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X1_VALID_SHCNT_CL82r,(_r._rx_x1_valid_shcnt_cl82))
#define BCMI_TSCE16_XGXS_WRITE_RX_X1_VALID_SHCNT_CL82r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X1_VALID_SHCNT_CL82r,(_r._rx_x1_valid_shcnt_cl82)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X1_VALID_SHCNT_CL82r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X1_VALID_SHCNT_CL82r,(_r._rx_x1_valid_shcnt_cl82))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_VALID_SHCNT_CL82r BCMI_TSCE16_XGXS_RX_X1_VALID_SHCNT_CL82r
#define RX_X1_VALID_SHCNT_CL82r_SIZE BCMI_TSCE16_XGXS_RX_X1_VALID_SHCNT_CL82r_SIZE
typedef BCMI_TSCE16_XGXS_RX_X1_VALID_SHCNT_CL82r_t RX_X1_VALID_SHCNT_CL82r_t;
#define RX_X1_VALID_SHCNT_CL82r_CLR BCMI_TSCE16_XGXS_RX_X1_VALID_SHCNT_CL82r_CLR
#define RX_X1_VALID_SHCNT_CL82r_SET BCMI_TSCE16_XGXS_RX_X1_VALID_SHCNT_CL82r_SET
#define RX_X1_VALID_SHCNT_CL82r_GET BCMI_TSCE16_XGXS_RX_X1_VALID_SHCNT_CL82r_GET
#define RX_X1_VALID_SHCNT_CL82r_CL82_VALID_SH_CNTf_GET BCMI_TSCE16_XGXS_RX_X1_VALID_SHCNT_CL82r_CL82_VALID_SH_CNTf_GET
#define RX_X1_VALID_SHCNT_CL82r_CL82_VALID_SH_CNTf_SET BCMI_TSCE16_XGXS_RX_X1_VALID_SHCNT_CL82r_CL82_VALID_SH_CNTf_SET
#define READ_RX_X1_VALID_SHCNT_CL82r BCMI_TSCE16_XGXS_READ_RX_X1_VALID_SHCNT_CL82r
#define WRITE_RX_X1_VALID_SHCNT_CL82r BCMI_TSCE16_XGXS_WRITE_RX_X1_VALID_SHCNT_CL82r
#define MODIFY_RX_X1_VALID_SHCNT_CL82r BCMI_TSCE16_XGXS_MODIFY_RX_X1_VALID_SHCNT_CL82r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X1_VALID_SHCNT_CL82r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X1_INVALID_SHCNT_CL82
 * BLOCKS:   RX_X1_CONTROL1
 * REGADDR:  0x9232
 * DESC:     CL49 sync header invalid counter
 * RESETVAL: 0x41 (65)
 * ACCESS:   R/W
 * FIELDS:
 *     CL82_INVALID_SH_CNT invalid sync header count for block lock fsm in cl82 mode
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X1_INVALID_SHCNT_CL82r (0x00109232 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X1_INVALID_SHCNT_CL82r_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_INVALID_SHCNT_CL82.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X1_INVALID_SHCNT_CL82r_s {
	uint32_t v[1];
	uint32_t rx_x1_invalid_shcnt_cl82[1];
	uint32_t _rx_x1_invalid_shcnt_cl82;
} BCMI_TSCE16_XGXS_RX_X1_INVALID_SHCNT_CL82r_t;

#define BCMI_TSCE16_XGXS_RX_X1_INVALID_SHCNT_CL82r_CLR(r) (r).rx_x1_invalid_shcnt_cl82[0] = 0
#define BCMI_TSCE16_XGXS_RX_X1_INVALID_SHCNT_CL82r_SET(r,d) (r).rx_x1_invalid_shcnt_cl82[0] = d
#define BCMI_TSCE16_XGXS_RX_X1_INVALID_SHCNT_CL82r_GET(r) (r).rx_x1_invalid_shcnt_cl82[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X1_INVALID_SHCNT_CL82r_CL82_INVALID_SH_CNTf_GET(r) (((r).rx_x1_invalid_shcnt_cl82[0]) & 0xfff)
#define BCMI_TSCE16_XGXS_RX_X1_INVALID_SHCNT_CL82r_CL82_INVALID_SH_CNTf_SET(r,f) (r).rx_x1_invalid_shcnt_cl82[0]=(((r).rx_x1_invalid_shcnt_cl82[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff)) | (0xfff << 16)

/*
 * These macros can be used to access RX_X1_INVALID_SHCNT_CL82.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X1_INVALID_SHCNT_CL82r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X1_INVALID_SHCNT_CL82r,(_r._rx_x1_invalid_shcnt_cl82))
#define BCMI_TSCE16_XGXS_WRITE_RX_X1_INVALID_SHCNT_CL82r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X1_INVALID_SHCNT_CL82r,(_r._rx_x1_invalid_shcnt_cl82)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X1_INVALID_SHCNT_CL82r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X1_INVALID_SHCNT_CL82r,(_r._rx_x1_invalid_shcnt_cl82))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_INVALID_SHCNT_CL82r BCMI_TSCE16_XGXS_RX_X1_INVALID_SHCNT_CL82r
#define RX_X1_INVALID_SHCNT_CL82r_SIZE BCMI_TSCE16_XGXS_RX_X1_INVALID_SHCNT_CL82r_SIZE
typedef BCMI_TSCE16_XGXS_RX_X1_INVALID_SHCNT_CL82r_t RX_X1_INVALID_SHCNT_CL82r_t;
#define RX_X1_INVALID_SHCNT_CL82r_CLR BCMI_TSCE16_XGXS_RX_X1_INVALID_SHCNT_CL82r_CLR
#define RX_X1_INVALID_SHCNT_CL82r_SET BCMI_TSCE16_XGXS_RX_X1_INVALID_SHCNT_CL82r_SET
#define RX_X1_INVALID_SHCNT_CL82r_GET BCMI_TSCE16_XGXS_RX_X1_INVALID_SHCNT_CL82r_GET
#define RX_X1_INVALID_SHCNT_CL82r_CL82_INVALID_SH_CNTf_GET BCMI_TSCE16_XGXS_RX_X1_INVALID_SHCNT_CL82r_CL82_INVALID_SH_CNTf_GET
#define RX_X1_INVALID_SHCNT_CL82r_CL82_INVALID_SH_CNTf_SET BCMI_TSCE16_XGXS_RX_X1_INVALID_SHCNT_CL82r_CL82_INVALID_SH_CNTf_SET
#define READ_RX_X1_INVALID_SHCNT_CL82r BCMI_TSCE16_XGXS_READ_RX_X1_INVALID_SHCNT_CL82r
#define WRITE_RX_X1_INVALID_SHCNT_CL82r BCMI_TSCE16_XGXS_WRITE_RX_X1_INVALID_SHCNT_CL82r
#define MODIFY_RX_X1_INVALID_SHCNT_CL82r BCMI_TSCE16_XGXS_MODIFY_RX_X1_INVALID_SHCNT_CL82r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X1_INVALID_SHCNT_CL82r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X1_SCW0
 * BLOCKS:   RX_X1_CONTROL1
 * REGADDR:  0x9233
 * DESC:     Sync code word bits 65:50
 * RESETVAL: 0x8090 (32912)
 * ACCESS:   R/W
 * FIELDS:
 *     SCW0             16 MSBs of the sync code word to match during synchronization, scw[65:50]
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X1_SCW0r (0x00109233 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X1_SCW0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_SCW0.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X1_SCW0r_s {
	uint32_t v[1];
	uint32_t rx_x1_scw0[1];
	uint32_t _rx_x1_scw0;
} BCMI_TSCE16_XGXS_RX_X1_SCW0r_t;

#define BCMI_TSCE16_XGXS_RX_X1_SCW0r_CLR(r) (r).rx_x1_scw0[0] = 0
#define BCMI_TSCE16_XGXS_RX_X1_SCW0r_SET(r,d) (r).rx_x1_scw0[0] = d
#define BCMI_TSCE16_XGXS_RX_X1_SCW0r_GET(r) (r).rx_x1_scw0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X1_SCW0r_SCW0f_GET(r) (((r).rx_x1_scw0[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_RX_X1_SCW0r_SCW0f_SET(r,f) (r).rx_x1_scw0[0]=(((r).rx_x1_scw0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X1_SCW0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X1_SCW0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X1_SCW0r,(_r._rx_x1_scw0))
#define BCMI_TSCE16_XGXS_WRITE_RX_X1_SCW0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X1_SCW0r,(_r._rx_x1_scw0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X1_SCW0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X1_SCW0r,(_r._rx_x1_scw0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_SCW0r BCMI_TSCE16_XGXS_RX_X1_SCW0r
#define RX_X1_SCW0r_SIZE BCMI_TSCE16_XGXS_RX_X1_SCW0r_SIZE
typedef BCMI_TSCE16_XGXS_RX_X1_SCW0r_t RX_X1_SCW0r_t;
#define RX_X1_SCW0r_CLR BCMI_TSCE16_XGXS_RX_X1_SCW0r_CLR
#define RX_X1_SCW0r_SET BCMI_TSCE16_XGXS_RX_X1_SCW0r_SET
#define RX_X1_SCW0r_GET BCMI_TSCE16_XGXS_RX_X1_SCW0r_GET
#define RX_X1_SCW0r_SCW0f_GET BCMI_TSCE16_XGXS_RX_X1_SCW0r_SCW0f_GET
#define RX_X1_SCW0r_SCW0f_SET BCMI_TSCE16_XGXS_RX_X1_SCW0r_SCW0f_SET
#define READ_RX_X1_SCW0r BCMI_TSCE16_XGXS_READ_RX_X1_SCW0r
#define WRITE_RX_X1_SCW0r BCMI_TSCE16_XGXS_WRITE_RX_X1_SCW0r
#define MODIFY_RX_X1_SCW0r BCMI_TSCE16_XGXS_MODIFY_RX_X1_SCW0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X1_SCW0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X1_SCW1
 * BLOCKS:   RX_X1_CONTROL1
 * REGADDR:  0x9234
 * DESC:     Sync code word bits 49;34
 * RESETVAL: 0xa0b0 (41136)
 * ACCESS:   R/W
 * FIELDS:
 *     SCW1             16 middle MSBs of the sync code word to match during synchronization, scw[49:34]
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X1_SCW1r (0x00109234 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X1_SCW1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_SCW1.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X1_SCW1r_s {
	uint32_t v[1];
	uint32_t rx_x1_scw1[1];
	uint32_t _rx_x1_scw1;
} BCMI_TSCE16_XGXS_RX_X1_SCW1r_t;

#define BCMI_TSCE16_XGXS_RX_X1_SCW1r_CLR(r) (r).rx_x1_scw1[0] = 0
#define BCMI_TSCE16_XGXS_RX_X1_SCW1r_SET(r,d) (r).rx_x1_scw1[0] = d
#define BCMI_TSCE16_XGXS_RX_X1_SCW1r_GET(r) (r).rx_x1_scw1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X1_SCW1r_SCW1f_GET(r) (((r).rx_x1_scw1[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_RX_X1_SCW1r_SCW1f_SET(r,f) (r).rx_x1_scw1[0]=(((r).rx_x1_scw1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X1_SCW1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X1_SCW1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X1_SCW1r,(_r._rx_x1_scw1))
#define BCMI_TSCE16_XGXS_WRITE_RX_X1_SCW1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X1_SCW1r,(_r._rx_x1_scw1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X1_SCW1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X1_SCW1r,(_r._rx_x1_scw1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_SCW1r BCMI_TSCE16_XGXS_RX_X1_SCW1r
#define RX_X1_SCW1r_SIZE BCMI_TSCE16_XGXS_RX_X1_SCW1r_SIZE
typedef BCMI_TSCE16_XGXS_RX_X1_SCW1r_t RX_X1_SCW1r_t;
#define RX_X1_SCW1r_CLR BCMI_TSCE16_XGXS_RX_X1_SCW1r_CLR
#define RX_X1_SCW1r_SET BCMI_TSCE16_XGXS_RX_X1_SCW1r_SET
#define RX_X1_SCW1r_GET BCMI_TSCE16_XGXS_RX_X1_SCW1r_GET
#define RX_X1_SCW1r_SCW1f_GET BCMI_TSCE16_XGXS_RX_X1_SCW1r_SCW1f_GET
#define RX_X1_SCW1r_SCW1f_SET BCMI_TSCE16_XGXS_RX_X1_SCW1r_SCW1f_SET
#define READ_RX_X1_SCW1r BCMI_TSCE16_XGXS_READ_RX_X1_SCW1r
#define WRITE_RX_X1_SCW1r BCMI_TSCE16_XGXS_WRITE_RX_X1_SCW1r
#define MODIFY_RX_X1_SCW1r BCMI_TSCE16_XGXS_MODIFY_RX_X1_SCW1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X1_SCW1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X1_SCW2
 * BLOCKS:   RX_X1_CONTROL1
 * REGADDR:  0x9235
 * DESC:     Sync code word bits 33:18
 * RESETVAL: 0xc0d0 (49360)
 * ACCESS:   R/W
 * FIELDS:
 *     SCW2             16 middle LSBs of the sync code word to match during synchronization, scw[33:18]
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X1_SCW2r (0x00109235 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X1_SCW2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_SCW2.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X1_SCW2r_s {
	uint32_t v[1];
	uint32_t rx_x1_scw2[1];
	uint32_t _rx_x1_scw2;
} BCMI_TSCE16_XGXS_RX_X1_SCW2r_t;

#define BCMI_TSCE16_XGXS_RX_X1_SCW2r_CLR(r) (r).rx_x1_scw2[0] = 0
#define BCMI_TSCE16_XGXS_RX_X1_SCW2r_SET(r,d) (r).rx_x1_scw2[0] = d
#define BCMI_TSCE16_XGXS_RX_X1_SCW2r_GET(r) (r).rx_x1_scw2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X1_SCW2r_SCW2f_GET(r) (((r).rx_x1_scw2[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_RX_X1_SCW2r_SCW2f_SET(r,f) (r).rx_x1_scw2[0]=(((r).rx_x1_scw2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X1_SCW2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X1_SCW2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X1_SCW2r,(_r._rx_x1_scw2))
#define BCMI_TSCE16_XGXS_WRITE_RX_X1_SCW2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X1_SCW2r,(_r._rx_x1_scw2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X1_SCW2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X1_SCW2r,(_r._rx_x1_scw2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_SCW2r BCMI_TSCE16_XGXS_RX_X1_SCW2r
#define RX_X1_SCW2r_SIZE BCMI_TSCE16_XGXS_RX_X1_SCW2r_SIZE
typedef BCMI_TSCE16_XGXS_RX_X1_SCW2r_t RX_X1_SCW2r_t;
#define RX_X1_SCW2r_CLR BCMI_TSCE16_XGXS_RX_X1_SCW2r_CLR
#define RX_X1_SCW2r_SET BCMI_TSCE16_XGXS_RX_X1_SCW2r_SET
#define RX_X1_SCW2r_GET BCMI_TSCE16_XGXS_RX_X1_SCW2r_GET
#define RX_X1_SCW2r_SCW2f_GET BCMI_TSCE16_XGXS_RX_X1_SCW2r_SCW2f_GET
#define RX_X1_SCW2r_SCW2f_SET BCMI_TSCE16_XGXS_RX_X1_SCW2r_SCW2f_SET
#define READ_RX_X1_SCW2r BCMI_TSCE16_XGXS_READ_RX_X1_SCW2r
#define WRITE_RX_X1_SCW2r BCMI_TSCE16_XGXS_WRITE_RX_X1_SCW2r
#define MODIFY_RX_X1_SCW2r BCMI_TSCE16_XGXS_MODIFY_RX_X1_SCW2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X1_SCW2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X1_SCW3
 * BLOCKS:   RX_X1_CONTROL1
 * REGADDR:  0x9236
 * DESC:     Sync code word bits 17:2
 * RESETVAL: 0xe070 (57456)
 * ACCESS:   R/W
 * FIELDS:
 *     SCW3             16 LSBs of the sync code word to match during synchronization, scw[17:2]
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X1_SCW3r (0x00109236 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X1_SCW3r_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_SCW3.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X1_SCW3r_s {
	uint32_t v[1];
	uint32_t rx_x1_scw3[1];
	uint32_t _rx_x1_scw3;
} BCMI_TSCE16_XGXS_RX_X1_SCW3r_t;

#define BCMI_TSCE16_XGXS_RX_X1_SCW3r_CLR(r) (r).rx_x1_scw3[0] = 0
#define BCMI_TSCE16_XGXS_RX_X1_SCW3r_SET(r,d) (r).rx_x1_scw3[0] = d
#define BCMI_TSCE16_XGXS_RX_X1_SCW3r_GET(r) (r).rx_x1_scw3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X1_SCW3r_SCW3f_GET(r) (((r).rx_x1_scw3[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_RX_X1_SCW3r_SCW3f_SET(r,f) (r).rx_x1_scw3[0]=(((r).rx_x1_scw3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X1_SCW3.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X1_SCW3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X1_SCW3r,(_r._rx_x1_scw3))
#define BCMI_TSCE16_XGXS_WRITE_RX_X1_SCW3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X1_SCW3r,(_r._rx_x1_scw3)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X1_SCW3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X1_SCW3r,(_r._rx_x1_scw3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_SCW3r BCMI_TSCE16_XGXS_RX_X1_SCW3r
#define RX_X1_SCW3r_SIZE BCMI_TSCE16_XGXS_RX_X1_SCW3r_SIZE
typedef BCMI_TSCE16_XGXS_RX_X1_SCW3r_t RX_X1_SCW3r_t;
#define RX_X1_SCW3r_CLR BCMI_TSCE16_XGXS_RX_X1_SCW3r_CLR
#define RX_X1_SCW3r_SET BCMI_TSCE16_XGXS_RX_X1_SCW3r_SET
#define RX_X1_SCW3r_GET BCMI_TSCE16_XGXS_RX_X1_SCW3r_GET
#define RX_X1_SCW3r_SCW3f_GET BCMI_TSCE16_XGXS_RX_X1_SCW3r_SCW3f_GET
#define RX_X1_SCW3r_SCW3f_SET BCMI_TSCE16_XGXS_RX_X1_SCW3r_SCW3f_SET
#define READ_RX_X1_SCW3r BCMI_TSCE16_XGXS_READ_RX_X1_SCW3r
#define WRITE_RX_X1_SCW3r BCMI_TSCE16_XGXS_WRITE_RX_X1_SCW3r
#define MODIFY_RX_X1_SCW3r BCMI_TSCE16_XGXS_MODIFY_RX_X1_SCW3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X1_SCW3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X1_SCW4
 * BLOCKS:   RX_X1_CONTROL1
 * REGADDR:  0x9237
 * DESC:     Sync code word bits 1:0
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     SCW4             2 sync bits of the sync code word to match during synchronization scw[1:0]
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X1_SCW4r (0x00109237 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X1_SCW4r_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_SCW4.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X1_SCW4r_s {
	uint32_t v[1];
	uint32_t rx_x1_scw4[1];
	uint32_t _rx_x1_scw4;
} BCMI_TSCE16_XGXS_RX_X1_SCW4r_t;

#define BCMI_TSCE16_XGXS_RX_X1_SCW4r_CLR(r) (r).rx_x1_scw4[0] = 0
#define BCMI_TSCE16_XGXS_RX_X1_SCW4r_SET(r,d) (r).rx_x1_scw4[0] = d
#define BCMI_TSCE16_XGXS_RX_X1_SCW4r_GET(r) (r).rx_x1_scw4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X1_SCW4r_SCW4f_GET(r) (((r).rx_x1_scw4[0]) & 0x3)
#define BCMI_TSCE16_XGXS_RX_X1_SCW4r_SCW4f_SET(r,f) (r).rx_x1_scw4[0]=(((r).rx_x1_scw4[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access RX_X1_SCW4.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X1_SCW4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X1_SCW4r,(_r._rx_x1_scw4))
#define BCMI_TSCE16_XGXS_WRITE_RX_X1_SCW4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X1_SCW4r,(_r._rx_x1_scw4)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X1_SCW4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X1_SCW4r,(_r._rx_x1_scw4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_SCW4r BCMI_TSCE16_XGXS_RX_X1_SCW4r
#define RX_X1_SCW4r_SIZE BCMI_TSCE16_XGXS_RX_X1_SCW4r_SIZE
typedef BCMI_TSCE16_XGXS_RX_X1_SCW4r_t RX_X1_SCW4r_t;
#define RX_X1_SCW4r_CLR BCMI_TSCE16_XGXS_RX_X1_SCW4r_CLR
#define RX_X1_SCW4r_SET BCMI_TSCE16_XGXS_RX_X1_SCW4r_SET
#define RX_X1_SCW4r_GET BCMI_TSCE16_XGXS_RX_X1_SCW4r_GET
#define RX_X1_SCW4r_SCW4f_GET BCMI_TSCE16_XGXS_RX_X1_SCW4r_SCW4f_GET
#define RX_X1_SCW4r_SCW4f_SET BCMI_TSCE16_XGXS_RX_X1_SCW4r_SCW4f_SET
#define READ_RX_X1_SCW4r BCMI_TSCE16_XGXS_READ_RX_X1_SCW4r
#define WRITE_RX_X1_SCW4r BCMI_TSCE16_XGXS_WRITE_RX_X1_SCW4r
#define MODIFY_RX_X1_SCW4r BCMI_TSCE16_XGXS_MODIFY_RX_X1_SCW4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X1_SCW4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X1_SCW0_MASK
 * BLOCKS:   RX_X1_CONTROL1
 * REGADDR:  0x9238
 * DESC:     Sync code word mask bits 65:50
 * RESETVAL: 0xf0f0 (61680)
 * ACCESS:   R/W
 * FIELDS:
 *     SCW0_MASK        16 MSBs of the sync code word mask, scw_mask[65:50].  A 1 in a specific bit position indicates that bit is to be compared during code word synchronization.  A 0 in a specific bit position indicates that bit is not to be compared during code word synchronizationDefault set for SBX Polaris project
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X1_SCW0_MASKr (0x00109238 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X1_SCW0_MASKr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_SCW0_MASK.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X1_SCW0_MASKr_s {
	uint32_t v[1];
	uint32_t rx_x1_scw0_mask[1];
	uint32_t _rx_x1_scw0_mask;
} BCMI_TSCE16_XGXS_RX_X1_SCW0_MASKr_t;

#define BCMI_TSCE16_XGXS_RX_X1_SCW0_MASKr_CLR(r) (r).rx_x1_scw0_mask[0] = 0
#define BCMI_TSCE16_XGXS_RX_X1_SCW0_MASKr_SET(r,d) (r).rx_x1_scw0_mask[0] = d
#define BCMI_TSCE16_XGXS_RX_X1_SCW0_MASKr_GET(r) (r).rx_x1_scw0_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X1_SCW0_MASKr_SCW0_MASKf_GET(r) (((r).rx_x1_scw0_mask[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_RX_X1_SCW0_MASKr_SCW0_MASKf_SET(r,f) (r).rx_x1_scw0_mask[0]=(((r).rx_x1_scw0_mask[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X1_SCW0_MASK.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X1_SCW0_MASKr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X1_SCW0_MASKr,(_r._rx_x1_scw0_mask))
#define BCMI_TSCE16_XGXS_WRITE_RX_X1_SCW0_MASKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X1_SCW0_MASKr,(_r._rx_x1_scw0_mask)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X1_SCW0_MASKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X1_SCW0_MASKr,(_r._rx_x1_scw0_mask))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_SCW0_MASKr BCMI_TSCE16_XGXS_RX_X1_SCW0_MASKr
#define RX_X1_SCW0_MASKr_SIZE BCMI_TSCE16_XGXS_RX_X1_SCW0_MASKr_SIZE
typedef BCMI_TSCE16_XGXS_RX_X1_SCW0_MASKr_t RX_X1_SCW0_MASKr_t;
#define RX_X1_SCW0_MASKr_CLR BCMI_TSCE16_XGXS_RX_X1_SCW0_MASKr_CLR
#define RX_X1_SCW0_MASKr_SET BCMI_TSCE16_XGXS_RX_X1_SCW0_MASKr_SET
#define RX_X1_SCW0_MASKr_GET BCMI_TSCE16_XGXS_RX_X1_SCW0_MASKr_GET
#define RX_X1_SCW0_MASKr_SCW0_MASKf_GET BCMI_TSCE16_XGXS_RX_X1_SCW0_MASKr_SCW0_MASKf_GET
#define RX_X1_SCW0_MASKr_SCW0_MASKf_SET BCMI_TSCE16_XGXS_RX_X1_SCW0_MASKr_SCW0_MASKf_SET
#define READ_RX_X1_SCW0_MASKr BCMI_TSCE16_XGXS_READ_RX_X1_SCW0_MASKr
#define WRITE_RX_X1_SCW0_MASKr BCMI_TSCE16_XGXS_WRITE_RX_X1_SCW0_MASKr
#define MODIFY_RX_X1_SCW0_MASKr BCMI_TSCE16_XGXS_MODIFY_RX_X1_SCW0_MASKr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X1_SCW0_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X1_SCW1_MASK
 * BLOCKS:   RX_X1_CONTROL1
 * REGADDR:  0x9239
 * DESC:     Sync code word mask bits 49:34
 * RESETVAL: 0xf0f0 (61680)
 * ACCESS:   R/W
 * FIELDS:
 *     SCW1_MASK        16 middle MSBs of the sync code word mask, scw_mask[49:34].  A 1 in a specific bit position indicates that bit is to be compared during code word synchronization.  A 0 in a specific bit position indicates that bit is not to be compared during code word synchronizationDefault set for SBX Polaris project
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X1_SCW1_MASKr (0x00109239 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X1_SCW1_MASKr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_SCW1_MASK.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X1_SCW1_MASKr_s {
	uint32_t v[1];
	uint32_t rx_x1_scw1_mask[1];
	uint32_t _rx_x1_scw1_mask;
} BCMI_TSCE16_XGXS_RX_X1_SCW1_MASKr_t;

#define BCMI_TSCE16_XGXS_RX_X1_SCW1_MASKr_CLR(r) (r).rx_x1_scw1_mask[0] = 0
#define BCMI_TSCE16_XGXS_RX_X1_SCW1_MASKr_SET(r,d) (r).rx_x1_scw1_mask[0] = d
#define BCMI_TSCE16_XGXS_RX_X1_SCW1_MASKr_GET(r) (r).rx_x1_scw1_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X1_SCW1_MASKr_SCW1_MASKf_GET(r) (((r).rx_x1_scw1_mask[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_RX_X1_SCW1_MASKr_SCW1_MASKf_SET(r,f) (r).rx_x1_scw1_mask[0]=(((r).rx_x1_scw1_mask[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X1_SCW1_MASK.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X1_SCW1_MASKr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X1_SCW1_MASKr,(_r._rx_x1_scw1_mask))
#define BCMI_TSCE16_XGXS_WRITE_RX_X1_SCW1_MASKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X1_SCW1_MASKr,(_r._rx_x1_scw1_mask)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X1_SCW1_MASKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X1_SCW1_MASKr,(_r._rx_x1_scw1_mask))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_SCW1_MASKr BCMI_TSCE16_XGXS_RX_X1_SCW1_MASKr
#define RX_X1_SCW1_MASKr_SIZE BCMI_TSCE16_XGXS_RX_X1_SCW1_MASKr_SIZE
typedef BCMI_TSCE16_XGXS_RX_X1_SCW1_MASKr_t RX_X1_SCW1_MASKr_t;
#define RX_X1_SCW1_MASKr_CLR BCMI_TSCE16_XGXS_RX_X1_SCW1_MASKr_CLR
#define RX_X1_SCW1_MASKr_SET BCMI_TSCE16_XGXS_RX_X1_SCW1_MASKr_SET
#define RX_X1_SCW1_MASKr_GET BCMI_TSCE16_XGXS_RX_X1_SCW1_MASKr_GET
#define RX_X1_SCW1_MASKr_SCW1_MASKf_GET BCMI_TSCE16_XGXS_RX_X1_SCW1_MASKr_SCW1_MASKf_GET
#define RX_X1_SCW1_MASKr_SCW1_MASKf_SET BCMI_TSCE16_XGXS_RX_X1_SCW1_MASKr_SCW1_MASKf_SET
#define READ_RX_X1_SCW1_MASKr BCMI_TSCE16_XGXS_READ_RX_X1_SCW1_MASKr
#define WRITE_RX_X1_SCW1_MASKr BCMI_TSCE16_XGXS_WRITE_RX_X1_SCW1_MASKr
#define MODIFY_RX_X1_SCW1_MASKr BCMI_TSCE16_XGXS_MODIFY_RX_X1_SCW1_MASKr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X1_SCW1_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X1_SCW2_MASK
 * BLOCKS:   RX_X1_CONTROL1
 * REGADDR:  0x923a
 * DESC:     Sync code word mask bits 33:18
 * RESETVAL: 0xf0f0 (61680)
 * ACCESS:   R/W
 * FIELDS:
 *     SCW2_MASK        16 middle LSBs of the sync code word mask, scw_mask[33:18].  A 1 in a specific bit position indicates that bit is to be compared during code word synchronization.  A 0 in a specific bit position indicates that bit is not to be compared during code word synchronizationDefault set for SBX Polaris project
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X1_SCW2_MASKr (0x0010923a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X1_SCW2_MASKr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_SCW2_MASK.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X1_SCW2_MASKr_s {
	uint32_t v[1];
	uint32_t rx_x1_scw2_mask[1];
	uint32_t _rx_x1_scw2_mask;
} BCMI_TSCE16_XGXS_RX_X1_SCW2_MASKr_t;

#define BCMI_TSCE16_XGXS_RX_X1_SCW2_MASKr_CLR(r) (r).rx_x1_scw2_mask[0] = 0
#define BCMI_TSCE16_XGXS_RX_X1_SCW2_MASKr_SET(r,d) (r).rx_x1_scw2_mask[0] = d
#define BCMI_TSCE16_XGXS_RX_X1_SCW2_MASKr_GET(r) (r).rx_x1_scw2_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X1_SCW2_MASKr_SCW2_MASKf_GET(r) (((r).rx_x1_scw2_mask[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_RX_X1_SCW2_MASKr_SCW2_MASKf_SET(r,f) (r).rx_x1_scw2_mask[0]=(((r).rx_x1_scw2_mask[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X1_SCW2_MASK.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X1_SCW2_MASKr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X1_SCW2_MASKr,(_r._rx_x1_scw2_mask))
#define BCMI_TSCE16_XGXS_WRITE_RX_X1_SCW2_MASKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X1_SCW2_MASKr,(_r._rx_x1_scw2_mask)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X1_SCW2_MASKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X1_SCW2_MASKr,(_r._rx_x1_scw2_mask))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_SCW2_MASKr BCMI_TSCE16_XGXS_RX_X1_SCW2_MASKr
#define RX_X1_SCW2_MASKr_SIZE BCMI_TSCE16_XGXS_RX_X1_SCW2_MASKr_SIZE
typedef BCMI_TSCE16_XGXS_RX_X1_SCW2_MASKr_t RX_X1_SCW2_MASKr_t;
#define RX_X1_SCW2_MASKr_CLR BCMI_TSCE16_XGXS_RX_X1_SCW2_MASKr_CLR
#define RX_X1_SCW2_MASKr_SET BCMI_TSCE16_XGXS_RX_X1_SCW2_MASKr_SET
#define RX_X1_SCW2_MASKr_GET BCMI_TSCE16_XGXS_RX_X1_SCW2_MASKr_GET
#define RX_X1_SCW2_MASKr_SCW2_MASKf_GET BCMI_TSCE16_XGXS_RX_X1_SCW2_MASKr_SCW2_MASKf_GET
#define RX_X1_SCW2_MASKr_SCW2_MASKf_SET BCMI_TSCE16_XGXS_RX_X1_SCW2_MASKr_SCW2_MASKf_SET
#define READ_RX_X1_SCW2_MASKr BCMI_TSCE16_XGXS_READ_RX_X1_SCW2_MASKr
#define WRITE_RX_X1_SCW2_MASKr BCMI_TSCE16_XGXS_WRITE_RX_X1_SCW2_MASKr
#define MODIFY_RX_X1_SCW2_MASKr BCMI_TSCE16_XGXS_MODIFY_RX_X1_SCW2_MASKr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X1_SCW2_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X1_SCW3_MASK
 * BLOCKS:   RX_X1_CONTROL1
 * REGADDR:  0x923b
 * DESC:     Sync code word mask bits 17:2
 * RESETVAL: 0xf0f0 (61680)
 * ACCESS:   R/W
 * FIELDS:
 *     SCW3_MASK        16 LSBs of the sync code word mask, scw_mask[17:2].  A 1 in a specific bit position indicates that bit is to be compared during code word synchronization.  A 0 in a specific bit position indicates that bit is not to be compared during code word synchronizationDefault set for SBX Polaris project
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X1_SCW3_MASKr (0x0010923b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X1_SCW3_MASKr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_SCW3_MASK.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X1_SCW3_MASKr_s {
	uint32_t v[1];
	uint32_t rx_x1_scw3_mask[1];
	uint32_t _rx_x1_scw3_mask;
} BCMI_TSCE16_XGXS_RX_X1_SCW3_MASKr_t;

#define BCMI_TSCE16_XGXS_RX_X1_SCW3_MASKr_CLR(r) (r).rx_x1_scw3_mask[0] = 0
#define BCMI_TSCE16_XGXS_RX_X1_SCW3_MASKr_SET(r,d) (r).rx_x1_scw3_mask[0] = d
#define BCMI_TSCE16_XGXS_RX_X1_SCW3_MASKr_GET(r) (r).rx_x1_scw3_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X1_SCW3_MASKr_SCW3_MASKf_GET(r) (((r).rx_x1_scw3_mask[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_RX_X1_SCW3_MASKr_SCW3_MASKf_SET(r,f) (r).rx_x1_scw3_mask[0]=(((r).rx_x1_scw3_mask[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X1_SCW3_MASK.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X1_SCW3_MASKr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X1_SCW3_MASKr,(_r._rx_x1_scw3_mask))
#define BCMI_TSCE16_XGXS_WRITE_RX_X1_SCW3_MASKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X1_SCW3_MASKr,(_r._rx_x1_scw3_mask)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X1_SCW3_MASKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X1_SCW3_MASKr,(_r._rx_x1_scw3_mask))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_SCW3_MASKr BCMI_TSCE16_XGXS_RX_X1_SCW3_MASKr
#define RX_X1_SCW3_MASKr_SIZE BCMI_TSCE16_XGXS_RX_X1_SCW3_MASKr_SIZE
typedef BCMI_TSCE16_XGXS_RX_X1_SCW3_MASKr_t RX_X1_SCW3_MASKr_t;
#define RX_X1_SCW3_MASKr_CLR BCMI_TSCE16_XGXS_RX_X1_SCW3_MASKr_CLR
#define RX_X1_SCW3_MASKr_SET BCMI_TSCE16_XGXS_RX_X1_SCW3_MASKr_SET
#define RX_X1_SCW3_MASKr_GET BCMI_TSCE16_XGXS_RX_X1_SCW3_MASKr_GET
#define RX_X1_SCW3_MASKr_SCW3_MASKf_GET BCMI_TSCE16_XGXS_RX_X1_SCW3_MASKr_SCW3_MASKf_GET
#define RX_X1_SCW3_MASKr_SCW3_MASKf_SET BCMI_TSCE16_XGXS_RX_X1_SCW3_MASKr_SCW3_MASKf_SET
#define READ_RX_X1_SCW3_MASKr BCMI_TSCE16_XGXS_READ_RX_X1_SCW3_MASKr
#define WRITE_RX_X1_SCW3_MASKr BCMI_TSCE16_XGXS_WRITE_RX_X1_SCW3_MASKr
#define MODIFY_RX_X1_SCW3_MASKr BCMI_TSCE16_XGXS_MODIFY_RX_X1_SCW3_MASKr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X1_SCW3_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X1_SCW4_MASK
 * BLOCKS:   RX_X1_CONTROL1
 * REGADDR:  0x923c
 * DESC:     Sync code word mask bits 1:0
 * RESETVAL: 0x3 (3)
 * ACCESS:   R/W
 * FIELDS:
 *     SCW4_MASK        2 sync bits mask of the sync code word mask.  A 1 in a specific bit position indicates that bit is to be compared during code word synchronization.  A 0 in a specific bit position indicates that bit is not to be compared during code word synchronization
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X1_SCW4_MASKr (0x0010923c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X1_SCW4_MASKr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_SCW4_MASK.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X1_SCW4_MASKr_s {
	uint32_t v[1];
	uint32_t rx_x1_scw4_mask[1];
	uint32_t _rx_x1_scw4_mask;
} BCMI_TSCE16_XGXS_RX_X1_SCW4_MASKr_t;

#define BCMI_TSCE16_XGXS_RX_X1_SCW4_MASKr_CLR(r) (r).rx_x1_scw4_mask[0] = 0
#define BCMI_TSCE16_XGXS_RX_X1_SCW4_MASKr_SET(r,d) (r).rx_x1_scw4_mask[0] = d
#define BCMI_TSCE16_XGXS_RX_X1_SCW4_MASKr_GET(r) (r).rx_x1_scw4_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X1_SCW4_MASKr_SCW4_MASKf_GET(r) (((r).rx_x1_scw4_mask[0]) & 0x3)
#define BCMI_TSCE16_XGXS_RX_X1_SCW4_MASKr_SCW4_MASKf_SET(r,f) (r).rx_x1_scw4_mask[0]=(((r).rx_x1_scw4_mask[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access RX_X1_SCW4_MASK.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X1_SCW4_MASKr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X1_SCW4_MASKr,(_r._rx_x1_scw4_mask))
#define BCMI_TSCE16_XGXS_WRITE_RX_X1_SCW4_MASKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X1_SCW4_MASKr,(_r._rx_x1_scw4_mask)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X1_SCW4_MASKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X1_SCW4_MASKr,(_r._rx_x1_scw4_mask))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_SCW4_MASKr BCMI_TSCE16_XGXS_RX_X1_SCW4_MASKr
#define RX_X1_SCW4_MASKr_SIZE BCMI_TSCE16_XGXS_RX_X1_SCW4_MASKr_SIZE
typedef BCMI_TSCE16_XGXS_RX_X1_SCW4_MASKr_t RX_X1_SCW4_MASKr_t;
#define RX_X1_SCW4_MASKr_CLR BCMI_TSCE16_XGXS_RX_X1_SCW4_MASKr_CLR
#define RX_X1_SCW4_MASKr_SET BCMI_TSCE16_XGXS_RX_X1_SCW4_MASKr_SET
#define RX_X1_SCW4_MASKr_GET BCMI_TSCE16_XGXS_RX_X1_SCW4_MASKr_GET
#define RX_X1_SCW4_MASKr_SCW4_MASKf_GET BCMI_TSCE16_XGXS_RX_X1_SCW4_MASKr_SCW4_MASKf_GET
#define RX_X1_SCW4_MASKr_SCW4_MASKf_SET BCMI_TSCE16_XGXS_RX_X1_SCW4_MASKr_SCW4_MASKf_SET
#define READ_RX_X1_SCW4_MASKr BCMI_TSCE16_XGXS_READ_RX_X1_SCW4_MASKr
#define WRITE_RX_X1_SCW4_MASKr BCMI_TSCE16_XGXS_WRITE_RX_X1_SCW4_MASKr
#define MODIFY_RX_X1_SCW4_MASKr BCMI_TSCE16_XGXS_MODIFY_RX_X1_SCW4_MASKr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X1_SCW4_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X1_OUI_UPR
 * BLOCKS:   AN_X1_CONTROL
 * REGADDR:  0x9240
 * DESC:     OUI UPPER BITS REGISTER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     OUI_UPPER_DATA   UPPER 8 BITS OF OUI FIELD
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X1_OUI_UPRr (0x00109240 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X1_OUI_UPRr_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_OUI_UPR.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X1_OUI_UPRr_s {
	uint32_t v[1];
	uint32_t an_x1_oui_upr[1];
	uint32_t _an_x1_oui_upr;
} BCMI_TSCE16_XGXS_AN_X1_OUI_UPRr_t;

#define BCMI_TSCE16_XGXS_AN_X1_OUI_UPRr_CLR(r) (r).an_x1_oui_upr[0] = 0
#define BCMI_TSCE16_XGXS_AN_X1_OUI_UPRr_SET(r,d) (r).an_x1_oui_upr[0] = d
#define BCMI_TSCE16_XGXS_AN_X1_OUI_UPRr_GET(r) (r).an_x1_oui_upr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X1_OUI_UPRr_OUI_UPPER_DATAf_GET(r) (((r).an_x1_oui_upr[0]) & 0xff)
#define BCMI_TSCE16_XGXS_AN_X1_OUI_UPRr_OUI_UPPER_DATAf_SET(r,f) (r).an_x1_oui_upr[0]=(((r).an_x1_oui_upr[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access AN_X1_OUI_UPR.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X1_OUI_UPRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X1_OUI_UPRr,(_r._an_x1_oui_upr))
#define BCMI_TSCE16_XGXS_WRITE_AN_X1_OUI_UPRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_OUI_UPRr,(_r._an_x1_oui_upr)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X1_OUI_UPRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_OUI_UPRr,(_r._an_x1_oui_upr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_OUI_UPRr BCMI_TSCE16_XGXS_AN_X1_OUI_UPRr
#define AN_X1_OUI_UPRr_SIZE BCMI_TSCE16_XGXS_AN_X1_OUI_UPRr_SIZE
typedef BCMI_TSCE16_XGXS_AN_X1_OUI_UPRr_t AN_X1_OUI_UPRr_t;
#define AN_X1_OUI_UPRr_CLR BCMI_TSCE16_XGXS_AN_X1_OUI_UPRr_CLR
#define AN_X1_OUI_UPRr_SET BCMI_TSCE16_XGXS_AN_X1_OUI_UPRr_SET
#define AN_X1_OUI_UPRr_GET BCMI_TSCE16_XGXS_AN_X1_OUI_UPRr_GET
#define AN_X1_OUI_UPRr_OUI_UPPER_DATAf_GET BCMI_TSCE16_XGXS_AN_X1_OUI_UPRr_OUI_UPPER_DATAf_GET
#define AN_X1_OUI_UPRr_OUI_UPPER_DATAf_SET BCMI_TSCE16_XGXS_AN_X1_OUI_UPRr_OUI_UPPER_DATAf_SET
#define READ_AN_X1_OUI_UPRr BCMI_TSCE16_XGXS_READ_AN_X1_OUI_UPRr
#define WRITE_AN_X1_OUI_UPRr BCMI_TSCE16_XGXS_WRITE_AN_X1_OUI_UPRr
#define MODIFY_AN_X1_OUI_UPRr BCMI_TSCE16_XGXS_MODIFY_AN_X1_OUI_UPRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X1_OUI_UPRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X1_OUI_LWR
 * BLOCKS:   AN_X1_CONTROL
 * REGADDR:  0x9241
 * DESC:     OUI LOWEr BITS REGISTER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     OUI_LOWER_DATA   LOWER 16 BITS OF OUI FIELD
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X1_OUI_LWRr (0x00109241 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X1_OUI_LWRr_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_OUI_LWR.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X1_OUI_LWRr_s {
	uint32_t v[1];
	uint32_t an_x1_oui_lwr[1];
	uint32_t _an_x1_oui_lwr;
} BCMI_TSCE16_XGXS_AN_X1_OUI_LWRr_t;

#define BCMI_TSCE16_XGXS_AN_X1_OUI_LWRr_CLR(r) (r).an_x1_oui_lwr[0] = 0
#define BCMI_TSCE16_XGXS_AN_X1_OUI_LWRr_SET(r,d) (r).an_x1_oui_lwr[0] = d
#define BCMI_TSCE16_XGXS_AN_X1_OUI_LWRr_GET(r) (r).an_x1_oui_lwr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X1_OUI_LWRr_OUI_LOWER_DATAf_GET(r) (((r).an_x1_oui_lwr[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_AN_X1_OUI_LWRr_OUI_LOWER_DATAf_SET(r,f) (r).an_x1_oui_lwr[0]=(((r).an_x1_oui_lwr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X1_OUI_LWR.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X1_OUI_LWRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X1_OUI_LWRr,(_r._an_x1_oui_lwr))
#define BCMI_TSCE16_XGXS_WRITE_AN_X1_OUI_LWRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_OUI_LWRr,(_r._an_x1_oui_lwr)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X1_OUI_LWRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_OUI_LWRr,(_r._an_x1_oui_lwr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_OUI_LWRr BCMI_TSCE16_XGXS_AN_X1_OUI_LWRr
#define AN_X1_OUI_LWRr_SIZE BCMI_TSCE16_XGXS_AN_X1_OUI_LWRr_SIZE
typedef BCMI_TSCE16_XGXS_AN_X1_OUI_LWRr_t AN_X1_OUI_LWRr_t;
#define AN_X1_OUI_LWRr_CLR BCMI_TSCE16_XGXS_AN_X1_OUI_LWRr_CLR
#define AN_X1_OUI_LWRr_SET BCMI_TSCE16_XGXS_AN_X1_OUI_LWRr_SET
#define AN_X1_OUI_LWRr_GET BCMI_TSCE16_XGXS_AN_X1_OUI_LWRr_GET
#define AN_X1_OUI_LWRr_OUI_LOWER_DATAf_GET BCMI_TSCE16_XGXS_AN_X1_OUI_LWRr_OUI_LOWER_DATAf_GET
#define AN_X1_OUI_LWRr_OUI_LOWER_DATAf_SET BCMI_TSCE16_XGXS_AN_X1_OUI_LWRr_OUI_LOWER_DATAf_SET
#define READ_AN_X1_OUI_LWRr BCMI_TSCE16_XGXS_READ_AN_X1_OUI_LWRr
#define WRITE_AN_X1_OUI_LWRr BCMI_TSCE16_XGXS_WRITE_AN_X1_OUI_LWRr
#define MODIFY_AN_X1_OUI_LWRr BCMI_TSCE16_XGXS_MODIFY_AN_X1_OUI_LWRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X1_OUI_LWRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X1_BAM_SPD_PRI_5_0
 * BLOCKS:   AN_X1_CONTROL
 * REGADDR:  0x9242
 * DESC:     REMAP PRIORITY REGISTER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AN_PRIORITY_1000M HCD PRIORITY OVERRIDE FOR PRIORITY 1000M SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_100M HCD PRIORITY OVERRIDE FOR PRIORITY 100M SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_10M  HCD PRIORITY OVERRIDE FOR PRIORITY 10M SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_5GX4 HCD PRIORITY OVERRIDE FOR PRIORITY 5GX4 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_2P5GX1 HCD PRIORITY OVERRIDE FOR PRIORITY 2p5GX1 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_1GKX HCD PRIORITY OVERRIDE FOR PRIORITY 1GKX SPEED.  ZERO MEANS USE HW PRIORITY
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r (0x00109242 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_BAM_SPD_PRI_5_0.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r_s {
	uint32_t v[1];
	uint32_t an_x1_bam_spd_pri_5_0[1];
	uint32_t _an_x1_bam_spd_pri_5_0;
} BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r_t;

#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r_CLR(r) (r).an_x1_bam_spd_pri_5_0[0] = 0
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r_SET(r,d) (r).an_x1_bam_spd_pri_5_0[0] = d
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r_GET(r) (r).an_x1_bam_spd_pri_5_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_1GKXf_GET(r) ((((r).an_x1_bam_spd_pri_5_0[0]) >> 10) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_1GKXf_SET(r,f) (r).an_x1_bam_spd_pri_5_0[0]=(((r).an_x1_bam_spd_pri_5_0[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_2P5GX1f_GET(r) ((((r).an_x1_bam_spd_pri_5_0[0]) >> 8) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_2P5GX1f_SET(r,f) (r).an_x1_bam_spd_pri_5_0[0]=(((r).an_x1_bam_spd_pri_5_0[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_5GX4f_GET(r) ((((r).an_x1_bam_spd_pri_5_0[0]) >> 6) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_5GX4f_SET(r,f) (r).an_x1_bam_spd_pri_5_0[0]=(((r).an_x1_bam_spd_pri_5_0[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_10Mf_GET(r) ((((r).an_x1_bam_spd_pri_5_0[0]) >> 4) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_10Mf_SET(r,f) (r).an_x1_bam_spd_pri_5_0[0]=(((r).an_x1_bam_spd_pri_5_0[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_100Mf_GET(r) ((((r).an_x1_bam_spd_pri_5_0[0]) >> 2) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_100Mf_SET(r,f) (r).an_x1_bam_spd_pri_5_0[0]=(((r).an_x1_bam_spd_pri_5_0[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_1000Mf_GET(r) (((r).an_x1_bam_spd_pri_5_0[0]) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_1000Mf_SET(r,f) (r).an_x1_bam_spd_pri_5_0[0]=(((r).an_x1_bam_spd_pri_5_0[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access AN_X1_BAM_SPD_PRI_5_0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X1_BAM_SPD_PRI_5_0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r,(_r._an_x1_bam_spd_pri_5_0))
#define BCMI_TSCE16_XGXS_WRITE_AN_X1_BAM_SPD_PRI_5_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r,(_r._an_x1_bam_spd_pri_5_0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X1_BAM_SPD_PRI_5_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r,(_r._an_x1_bam_spd_pri_5_0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_BAM_SPD_PRI_5_0r BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r
#define AN_X1_BAM_SPD_PRI_5_0r_SIZE BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r_SIZE
typedef BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r_t AN_X1_BAM_SPD_PRI_5_0r_t;
#define AN_X1_BAM_SPD_PRI_5_0r_CLR BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r_CLR
#define AN_X1_BAM_SPD_PRI_5_0r_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r_SET
#define AN_X1_BAM_SPD_PRI_5_0r_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r_GET
#define AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_1GKXf_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_1GKXf_GET
#define AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_1GKXf_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_1GKXf_SET
#define AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_2P5GX1f_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_2P5GX1f_GET
#define AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_2P5GX1f_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_2P5GX1f_SET
#define AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_5GX4f_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_5GX4f_GET
#define AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_5GX4f_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_5GX4f_SET
#define AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_10Mf_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_10Mf_GET
#define AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_10Mf_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_10Mf_SET
#define AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_100Mf_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_100Mf_GET
#define AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_100Mf_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_100Mf_SET
#define AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_1000Mf_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_1000Mf_GET
#define AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_1000Mf_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r_AN_PRIORITY_1000Mf_SET
#define READ_AN_X1_BAM_SPD_PRI_5_0r BCMI_TSCE16_XGXS_READ_AN_X1_BAM_SPD_PRI_5_0r
#define WRITE_AN_X1_BAM_SPD_PRI_5_0r BCMI_TSCE16_XGXS_WRITE_AN_X1_BAM_SPD_PRI_5_0r
#define MODIFY_AN_X1_BAM_SPD_PRI_5_0r BCMI_TSCE16_XGXS_MODIFY_AN_X1_BAM_SPD_PRI_5_0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_5_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X1_BAM_SPD_PRI_11_6
 * BLOCKS:   AN_X1_CONTROL
 * REGADDR:  0x9243
 * DESC:     REMAP PRIORITY REGISTER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AN_PRIORITY_10GCX4 HCD PRIORITY OVERRIDE FOR PRIORITY 10GCX4 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_10GCX1 HCD PRIORITY OVERRIDE FOR PRIORITY 10GCX1 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_6GX4 HCD PRIORITY OVERRIDE FOR PRIORITY 6GX4 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_10GX4 HCD PRIORITY OVERRIDE FOR PRIORITY 10GX4 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_10GKX4 HCD PRIORITY OVERRIDE FOR PRIORITY 10GKX4 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_10GKR HCD PRIORITY OVERRIDE FOR PRIORITY 10GKR SPEED.  ZERO MEANS USE HW PRIORITY
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r (0x00109243 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_BAM_SPD_PRI_11_6.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r_s {
	uint32_t v[1];
	uint32_t an_x1_bam_spd_pri_11_6[1];
	uint32_t _an_x1_bam_spd_pri_11_6;
} BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r_t;

#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r_CLR(r) (r).an_x1_bam_spd_pri_11_6[0] = 0
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r_SET(r,d) (r).an_x1_bam_spd_pri_11_6[0] = d
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r_GET(r) (r).an_x1_bam_spd_pri_11_6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_10GKRf_GET(r) ((((r).an_x1_bam_spd_pri_11_6[0]) >> 10) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_10GKRf_SET(r,f) (r).an_x1_bam_spd_pri_11_6[0]=(((r).an_x1_bam_spd_pri_11_6[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_10GKX4f_GET(r) ((((r).an_x1_bam_spd_pri_11_6[0]) >> 8) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_10GKX4f_SET(r,f) (r).an_x1_bam_spd_pri_11_6[0]=(((r).an_x1_bam_spd_pri_11_6[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_10GX4f_GET(r) ((((r).an_x1_bam_spd_pri_11_6[0]) >> 6) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_10GX4f_SET(r,f) (r).an_x1_bam_spd_pri_11_6[0]=(((r).an_x1_bam_spd_pri_11_6[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_6GX4f_GET(r) ((((r).an_x1_bam_spd_pri_11_6[0]) >> 4) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_6GX4f_SET(r,f) (r).an_x1_bam_spd_pri_11_6[0]=(((r).an_x1_bam_spd_pri_11_6[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_10GCX1f_GET(r) ((((r).an_x1_bam_spd_pri_11_6[0]) >> 2) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_10GCX1f_SET(r,f) (r).an_x1_bam_spd_pri_11_6[0]=(((r).an_x1_bam_spd_pri_11_6[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_10GCX4f_GET(r) (((r).an_x1_bam_spd_pri_11_6[0]) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_10GCX4f_SET(r,f) (r).an_x1_bam_spd_pri_11_6[0]=(((r).an_x1_bam_spd_pri_11_6[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access AN_X1_BAM_SPD_PRI_11_6.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X1_BAM_SPD_PRI_11_6r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r,(_r._an_x1_bam_spd_pri_11_6))
#define BCMI_TSCE16_XGXS_WRITE_AN_X1_BAM_SPD_PRI_11_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r,(_r._an_x1_bam_spd_pri_11_6)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X1_BAM_SPD_PRI_11_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r,(_r._an_x1_bam_spd_pri_11_6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_BAM_SPD_PRI_11_6r BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r
#define AN_X1_BAM_SPD_PRI_11_6r_SIZE BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r_SIZE
typedef BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r_t AN_X1_BAM_SPD_PRI_11_6r_t;
#define AN_X1_BAM_SPD_PRI_11_6r_CLR BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r_CLR
#define AN_X1_BAM_SPD_PRI_11_6r_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r_SET
#define AN_X1_BAM_SPD_PRI_11_6r_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r_GET
#define AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_10GKRf_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_10GKRf_GET
#define AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_10GKRf_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_10GKRf_SET
#define AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_10GKX4f_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_10GKX4f_GET
#define AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_10GKX4f_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_10GKX4f_SET
#define AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_10GX4f_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_10GX4f_GET
#define AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_10GX4f_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_10GX4f_SET
#define AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_6GX4f_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_6GX4f_GET
#define AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_6GX4f_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_6GX4f_SET
#define AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_10GCX1f_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_10GCX1f_GET
#define AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_10GCX1f_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_10GCX1f_SET
#define AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_10GCX4f_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_10GCX4f_GET
#define AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_10GCX4f_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r_AN_PRIORITY_10GCX4f_SET
#define READ_AN_X1_BAM_SPD_PRI_11_6r BCMI_TSCE16_XGXS_READ_AN_X1_BAM_SPD_PRI_11_6r
#define WRITE_AN_X1_BAM_SPD_PRI_11_6r BCMI_TSCE16_XGXS_WRITE_AN_X1_BAM_SPD_PRI_11_6r
#define MODIFY_AN_X1_BAM_SPD_PRI_11_6r BCMI_TSCE16_XGXS_MODIFY_AN_X1_BAM_SPD_PRI_11_6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_11_6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X1_BAM_SPD_PRI_17_12
 * BLOCKS:   AN_X1_CONTROL
 * REGADDR:  0x9244
 * DESC:     REMAP PRIORITY REGISTER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AN_PRIORITY_10P5GX2 HCD PRIORITY OVERRIDE FOR PRIORITY 10p5GX2 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_10GX2 HCD PRIORITY OVERRIDE FOR PRIORITY 10GX2 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_10GCX2 HCD PRIORITY OVERRIDE FOR PRIORITY 10GCX2 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_12P7GX2 HCD PRIORITY OVERRIDE FOR PRIORITY 12p7GX2 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_12P5GX4 HCD PRIORITY OVERRIDE FOR PRIORITY 12p5GX4 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_12GX4 HCD PRIORITY OVERRIDE FOR PRIORITY 12GX4 SPEED.  ZERO MEANS USE HW PRIORITY
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r (0x00109244 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_BAM_SPD_PRI_17_12.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r_s {
	uint32_t v[1];
	uint32_t an_x1_bam_spd_pri_17_12[1];
	uint32_t _an_x1_bam_spd_pri_17_12;
} BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r_t;

#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r_CLR(r) (r).an_x1_bam_spd_pri_17_12[0] = 0
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r_SET(r,d) (r).an_x1_bam_spd_pri_17_12[0] = d
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r_GET(r) (r).an_x1_bam_spd_pri_17_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_12GX4f_GET(r) ((((r).an_x1_bam_spd_pri_17_12[0]) >> 10) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_12GX4f_SET(r,f) (r).an_x1_bam_spd_pri_17_12[0]=(((r).an_x1_bam_spd_pri_17_12[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_12P5GX4f_GET(r) ((((r).an_x1_bam_spd_pri_17_12[0]) >> 8) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_12P5GX4f_SET(r,f) (r).an_x1_bam_spd_pri_17_12[0]=(((r).an_x1_bam_spd_pri_17_12[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_12P7GX2f_GET(r) ((((r).an_x1_bam_spd_pri_17_12[0]) >> 6) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_12P7GX2f_SET(r,f) (r).an_x1_bam_spd_pri_17_12[0]=(((r).an_x1_bam_spd_pri_17_12[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_10GCX2f_GET(r) ((((r).an_x1_bam_spd_pri_17_12[0]) >> 4) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_10GCX2f_SET(r,f) (r).an_x1_bam_spd_pri_17_12[0]=(((r).an_x1_bam_spd_pri_17_12[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_10GX2f_GET(r) ((((r).an_x1_bam_spd_pri_17_12[0]) >> 2) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_10GX2f_SET(r,f) (r).an_x1_bam_spd_pri_17_12[0]=(((r).an_x1_bam_spd_pri_17_12[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_10P5GX2f_GET(r) (((r).an_x1_bam_spd_pri_17_12[0]) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_10P5GX2f_SET(r,f) (r).an_x1_bam_spd_pri_17_12[0]=(((r).an_x1_bam_spd_pri_17_12[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access AN_X1_BAM_SPD_PRI_17_12.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X1_BAM_SPD_PRI_17_12r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r,(_r._an_x1_bam_spd_pri_17_12))
#define BCMI_TSCE16_XGXS_WRITE_AN_X1_BAM_SPD_PRI_17_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r,(_r._an_x1_bam_spd_pri_17_12)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X1_BAM_SPD_PRI_17_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r,(_r._an_x1_bam_spd_pri_17_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_BAM_SPD_PRI_17_12r BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r
#define AN_X1_BAM_SPD_PRI_17_12r_SIZE BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r_SIZE
typedef BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r_t AN_X1_BAM_SPD_PRI_17_12r_t;
#define AN_X1_BAM_SPD_PRI_17_12r_CLR BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r_CLR
#define AN_X1_BAM_SPD_PRI_17_12r_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r_SET
#define AN_X1_BAM_SPD_PRI_17_12r_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r_GET
#define AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_12GX4f_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_12GX4f_GET
#define AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_12GX4f_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_12GX4f_SET
#define AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_12P5GX4f_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_12P5GX4f_GET
#define AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_12P5GX4f_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_12P5GX4f_SET
#define AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_12P7GX2f_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_12P7GX2f_GET
#define AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_12P7GX2f_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_12P7GX2f_SET
#define AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_10GCX2f_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_10GCX2f_GET
#define AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_10GCX2f_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_10GCX2f_SET
#define AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_10GX2f_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_10GX2f_GET
#define AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_10GX2f_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_10GX2f_SET
#define AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_10P5GX2f_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_10P5GX2f_GET
#define AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_10P5GX2f_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r_AN_PRIORITY_10P5GX2f_SET
#define READ_AN_X1_BAM_SPD_PRI_17_12r BCMI_TSCE16_XGXS_READ_AN_X1_BAM_SPD_PRI_17_12r
#define WRITE_AN_X1_BAM_SPD_PRI_17_12r BCMI_TSCE16_XGXS_WRITE_AN_X1_BAM_SPD_PRI_17_12r
#define MODIFY_AN_X1_BAM_SPD_PRI_17_12r BCMI_TSCE16_XGXS_MODIFY_AN_X1_BAM_SPD_PRI_17_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_17_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X1_BAM_SPD_PRI_23_18
 * BLOCKS:   AN_X1_CONTROL
 * REGADDR:  0x9245
 * DESC:     REMAP PRIORITY REGISTER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AN_PRIORITY_15P75GX2 HCD PRIORITY OVERRIDE FOR PRIORITY 15p75GX2 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_15GX4 HCD PRIORITY OVERRIDE FOR PRIORITY 15GX4 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_13GX4 HCD PRIORITY OVERRIDE FOR PRIORITY 13GX4 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_100GCR10 HCD PRIORITY OVERRIDE FOR PRIORITY 100GCR10 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_40GKR4 HCD PRIORITY OVERRIDE FOR PRIORITY 40GKR4 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_40GCR4 HCD PRIORITY OVERRIDE FOR PRIORITY 40GCR4 SPEED.  ZERO MEANS USE HW PRIORITY
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r (0x00109245 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_BAM_SPD_PRI_23_18.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r_s {
	uint32_t v[1];
	uint32_t an_x1_bam_spd_pri_23_18[1];
	uint32_t _an_x1_bam_spd_pri_23_18;
} BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r_t;

#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r_CLR(r) (r).an_x1_bam_spd_pri_23_18[0] = 0
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r_SET(r,d) (r).an_x1_bam_spd_pri_23_18[0] = d
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r_GET(r) (r).an_x1_bam_spd_pri_23_18[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_40GCR4f_GET(r) ((((r).an_x1_bam_spd_pri_23_18[0]) >> 10) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_40GCR4f_SET(r,f) (r).an_x1_bam_spd_pri_23_18[0]=(((r).an_x1_bam_spd_pri_23_18[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_40GKR4f_GET(r) ((((r).an_x1_bam_spd_pri_23_18[0]) >> 8) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_40GKR4f_SET(r,f) (r).an_x1_bam_spd_pri_23_18[0]=(((r).an_x1_bam_spd_pri_23_18[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_100GCR10f_GET(r) ((((r).an_x1_bam_spd_pri_23_18[0]) >> 6) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_100GCR10f_SET(r,f) (r).an_x1_bam_spd_pri_23_18[0]=(((r).an_x1_bam_spd_pri_23_18[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_13GX4f_GET(r) ((((r).an_x1_bam_spd_pri_23_18[0]) >> 4) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_13GX4f_SET(r,f) (r).an_x1_bam_spd_pri_23_18[0]=(((r).an_x1_bam_spd_pri_23_18[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_15GX4f_GET(r) ((((r).an_x1_bam_spd_pri_23_18[0]) >> 2) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_15GX4f_SET(r,f) (r).an_x1_bam_spd_pri_23_18[0]=(((r).an_x1_bam_spd_pri_23_18[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_15P75GX2f_GET(r) (((r).an_x1_bam_spd_pri_23_18[0]) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_15P75GX2f_SET(r,f) (r).an_x1_bam_spd_pri_23_18[0]=(((r).an_x1_bam_spd_pri_23_18[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access AN_X1_BAM_SPD_PRI_23_18.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X1_BAM_SPD_PRI_23_18r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r,(_r._an_x1_bam_spd_pri_23_18))
#define BCMI_TSCE16_XGXS_WRITE_AN_X1_BAM_SPD_PRI_23_18r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r,(_r._an_x1_bam_spd_pri_23_18)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X1_BAM_SPD_PRI_23_18r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r,(_r._an_x1_bam_spd_pri_23_18))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_BAM_SPD_PRI_23_18r BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r
#define AN_X1_BAM_SPD_PRI_23_18r_SIZE BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r_SIZE
typedef BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r_t AN_X1_BAM_SPD_PRI_23_18r_t;
#define AN_X1_BAM_SPD_PRI_23_18r_CLR BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r_CLR
#define AN_X1_BAM_SPD_PRI_23_18r_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r_SET
#define AN_X1_BAM_SPD_PRI_23_18r_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r_GET
#define AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_40GCR4f_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_40GCR4f_GET
#define AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_40GCR4f_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_40GCR4f_SET
#define AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_40GKR4f_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_40GKR4f_GET
#define AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_40GKR4f_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_40GKR4f_SET
#define AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_100GCR10f_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_100GCR10f_GET
#define AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_100GCR10f_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_100GCR10f_SET
#define AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_13GX4f_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_13GX4f_GET
#define AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_13GX4f_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_13GX4f_SET
#define AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_15GX4f_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_15GX4f_GET
#define AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_15GX4f_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_15GX4f_SET
#define AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_15P75GX2f_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_15P75GX2f_GET
#define AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_15P75GX2f_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r_AN_PRIORITY_15P75GX2f_SET
#define READ_AN_X1_BAM_SPD_PRI_23_18r BCMI_TSCE16_XGXS_READ_AN_X1_BAM_SPD_PRI_23_18r
#define WRITE_AN_X1_BAM_SPD_PRI_23_18r BCMI_TSCE16_XGXS_WRITE_AN_X1_BAM_SPD_PRI_23_18r
#define MODIFY_AN_X1_BAM_SPD_PRI_23_18r BCMI_TSCE16_XGXS_MODIFY_AN_X1_BAM_SPD_PRI_23_18r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_23_18r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X1_BAM_SPD_PRI_29_24
 * BLOCKS:   AN_X1_CONTROL
 * REGADDR:  0x9246
 * DESC:     REMAP PRIORITY REGISTER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AN_PRIORITY_20GCR2 HCD PRIORITY OVERRIDE FOR PRIORITY 20GCR2 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_20GCX2 HCD PRIORITY OVERRIDE FOR PRIORITY 20GCX2 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_16GX4 HCD PRIORITY OVERRIDE FOR PRIORITY 16GX4 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_20GX2 HCD PRIORITY OVERRIDE FOR PRIORITY 20GX2 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_20GCX4 HCD PRIORITY OVERRIDE FOR PRIORITY 20GCX4 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_20GKR2 HCD PRIORITY OVERRIDE FOR PRIORITY 20GKR2 SPEED.  ZERO MEANS USE HW PRIORITY
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r (0x00109246 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_BAM_SPD_PRI_29_24.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r_s {
	uint32_t v[1];
	uint32_t an_x1_bam_spd_pri_29_24[1];
	uint32_t _an_x1_bam_spd_pri_29_24;
} BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r_t;

#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r_CLR(r) (r).an_x1_bam_spd_pri_29_24[0] = 0
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r_SET(r,d) (r).an_x1_bam_spd_pri_29_24[0] = d
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r_GET(r) (r).an_x1_bam_spd_pri_29_24[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_20GKR2f_GET(r) ((((r).an_x1_bam_spd_pri_29_24[0]) >> 10) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_20GKR2f_SET(r,f) (r).an_x1_bam_spd_pri_29_24[0]=(((r).an_x1_bam_spd_pri_29_24[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_20GCX4f_GET(r) ((((r).an_x1_bam_spd_pri_29_24[0]) >> 8) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_20GCX4f_SET(r,f) (r).an_x1_bam_spd_pri_29_24[0]=(((r).an_x1_bam_spd_pri_29_24[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_20GX2f_GET(r) ((((r).an_x1_bam_spd_pri_29_24[0]) >> 6) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_20GX2f_SET(r,f) (r).an_x1_bam_spd_pri_29_24[0]=(((r).an_x1_bam_spd_pri_29_24[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_16GX4f_GET(r) ((((r).an_x1_bam_spd_pri_29_24[0]) >> 4) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_16GX4f_SET(r,f) (r).an_x1_bam_spd_pri_29_24[0]=(((r).an_x1_bam_spd_pri_29_24[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_20GCX2f_GET(r) ((((r).an_x1_bam_spd_pri_29_24[0]) >> 2) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_20GCX2f_SET(r,f) (r).an_x1_bam_spd_pri_29_24[0]=(((r).an_x1_bam_spd_pri_29_24[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_20GCR2f_GET(r) (((r).an_x1_bam_spd_pri_29_24[0]) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_20GCR2f_SET(r,f) (r).an_x1_bam_spd_pri_29_24[0]=(((r).an_x1_bam_spd_pri_29_24[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access AN_X1_BAM_SPD_PRI_29_24.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X1_BAM_SPD_PRI_29_24r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r,(_r._an_x1_bam_spd_pri_29_24))
#define BCMI_TSCE16_XGXS_WRITE_AN_X1_BAM_SPD_PRI_29_24r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r,(_r._an_x1_bam_spd_pri_29_24)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X1_BAM_SPD_PRI_29_24r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r,(_r._an_x1_bam_spd_pri_29_24))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_BAM_SPD_PRI_29_24r BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r
#define AN_X1_BAM_SPD_PRI_29_24r_SIZE BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r_SIZE
typedef BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r_t AN_X1_BAM_SPD_PRI_29_24r_t;
#define AN_X1_BAM_SPD_PRI_29_24r_CLR BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r_CLR
#define AN_X1_BAM_SPD_PRI_29_24r_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r_SET
#define AN_X1_BAM_SPD_PRI_29_24r_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r_GET
#define AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_20GKR2f_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_20GKR2f_GET
#define AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_20GKR2f_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_20GKR2f_SET
#define AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_20GCX4f_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_20GCX4f_GET
#define AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_20GCX4f_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_20GCX4f_SET
#define AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_20GX2f_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_20GX2f_GET
#define AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_20GX2f_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_20GX2f_SET
#define AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_16GX4f_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_16GX4f_GET
#define AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_16GX4f_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_16GX4f_SET
#define AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_20GCX2f_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_20GCX2f_GET
#define AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_20GCX2f_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_20GCX2f_SET
#define AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_20GCR2f_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_20GCR2f_GET
#define AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_20GCR2f_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r_AN_PRIORITY_20GCR2f_SET
#define READ_AN_X1_BAM_SPD_PRI_29_24r BCMI_TSCE16_XGXS_READ_AN_X1_BAM_SPD_PRI_29_24r
#define WRITE_AN_X1_BAM_SPD_PRI_29_24r BCMI_TSCE16_XGXS_WRITE_AN_X1_BAM_SPD_PRI_29_24r
#define MODIFY_AN_X1_BAM_SPD_PRI_29_24r BCMI_TSCE16_XGXS_MODIFY_AN_X1_BAM_SPD_PRI_29_24r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_29_24r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X1_BAM_SPD_PRI_35_30
 * BLOCKS:   AN_X1_CONTROL
 * REGADDR:  0x9247
 * DESC:     REMAP PRIORITY REGISTER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AN_PRIORITY_25P45GX4 HCD PRIORITY OVERRIDE FOR PRIORITY 25p45GX4 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_21GX4 HCD PRIORITY OVERRIDE FOR PRIORITY 21GX4 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_20GX4 HCD PRIORITY OVERRIDE FOR PRIORITY 20GX4 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_40GX4 HCD PRIORITY OVERRIDE FOR PRIORITY 40GX4 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_32P7G HCD PRIORITY OVERRIDE FOR PRIORITY 32p7G SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_31P5G HCD PRIORITY OVERRIDE FOR PRIORITY 31p5G SPEED.  ZERO MEANS USE HW PRIORITY
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r (0x00109247 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_BAM_SPD_PRI_35_30.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r_s {
	uint32_t v[1];
	uint32_t an_x1_bam_spd_pri_35_30[1];
	uint32_t _an_x1_bam_spd_pri_35_30;
} BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r_t;

#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r_CLR(r) (r).an_x1_bam_spd_pri_35_30[0] = 0
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r_SET(r,d) (r).an_x1_bam_spd_pri_35_30[0] = d
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r_GET(r) (r).an_x1_bam_spd_pri_35_30[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_31P5Gf_GET(r) ((((r).an_x1_bam_spd_pri_35_30[0]) >> 10) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_31P5Gf_SET(r,f) (r).an_x1_bam_spd_pri_35_30[0]=(((r).an_x1_bam_spd_pri_35_30[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_32P7Gf_GET(r) ((((r).an_x1_bam_spd_pri_35_30[0]) >> 8) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_32P7Gf_SET(r,f) (r).an_x1_bam_spd_pri_35_30[0]=(((r).an_x1_bam_spd_pri_35_30[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_40GX4f_GET(r) ((((r).an_x1_bam_spd_pri_35_30[0]) >> 6) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_40GX4f_SET(r,f) (r).an_x1_bam_spd_pri_35_30[0]=(((r).an_x1_bam_spd_pri_35_30[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_20GX4f_GET(r) ((((r).an_x1_bam_spd_pri_35_30[0]) >> 4) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_20GX4f_SET(r,f) (r).an_x1_bam_spd_pri_35_30[0]=(((r).an_x1_bam_spd_pri_35_30[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_21GX4f_GET(r) ((((r).an_x1_bam_spd_pri_35_30[0]) >> 2) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_21GX4f_SET(r,f) (r).an_x1_bam_spd_pri_35_30[0]=(((r).an_x1_bam_spd_pri_35_30[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_25P45GX4f_GET(r) (((r).an_x1_bam_spd_pri_35_30[0]) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_25P45GX4f_SET(r,f) (r).an_x1_bam_spd_pri_35_30[0]=(((r).an_x1_bam_spd_pri_35_30[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access AN_X1_BAM_SPD_PRI_35_30.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X1_BAM_SPD_PRI_35_30r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r,(_r._an_x1_bam_spd_pri_35_30))
#define BCMI_TSCE16_XGXS_WRITE_AN_X1_BAM_SPD_PRI_35_30r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r,(_r._an_x1_bam_spd_pri_35_30)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X1_BAM_SPD_PRI_35_30r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r,(_r._an_x1_bam_spd_pri_35_30))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_BAM_SPD_PRI_35_30r BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r
#define AN_X1_BAM_SPD_PRI_35_30r_SIZE BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r_SIZE
typedef BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r_t AN_X1_BAM_SPD_PRI_35_30r_t;
#define AN_X1_BAM_SPD_PRI_35_30r_CLR BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r_CLR
#define AN_X1_BAM_SPD_PRI_35_30r_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r_SET
#define AN_X1_BAM_SPD_PRI_35_30r_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r_GET
#define AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_31P5Gf_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_31P5Gf_GET
#define AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_31P5Gf_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_31P5Gf_SET
#define AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_32P7Gf_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_32P7Gf_GET
#define AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_32P7Gf_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_32P7Gf_SET
#define AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_40GX4f_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_40GX4f_GET
#define AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_40GX4f_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_40GX4f_SET
#define AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_20GX4f_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_20GX4f_GET
#define AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_20GX4f_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_20GX4f_SET
#define AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_21GX4f_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_21GX4f_GET
#define AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_21GX4f_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_21GX4f_SET
#define AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_25P45GX4f_GET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_25P45GX4f_GET
#define AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_25P45GX4f_SET BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r_AN_PRIORITY_25P45GX4f_SET
#define READ_AN_X1_BAM_SPD_PRI_35_30r BCMI_TSCE16_XGXS_READ_AN_X1_BAM_SPD_PRI_35_30r
#define WRITE_AN_X1_BAM_SPD_PRI_35_30r BCMI_TSCE16_XGXS_WRITE_AN_X1_BAM_SPD_PRI_35_30r
#define MODIFY_AN_X1_BAM_SPD_PRI_35_30r BCMI_TSCE16_XGXS_MODIFY_AN_X1_BAM_SPD_PRI_35_30r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X1_BAM_SPD_PRI_35_30r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X1_CFG_CTL
 * BLOCKS:   AN_X1_CONTROL
 * REGADDR:  0x9248
 * DESC:     REMAP PRIORITY REGISTER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AN_PD_TO_CL37_RETRY_COUNT Number of times to retry cl37 AN in parallel detect
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X1_CFG_CTLr (0x00109248 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X1_CFG_CTLr_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_CFG_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X1_CFG_CTLr_s {
	uint32_t v[1];
	uint32_t an_x1_cfg_ctl[1];
	uint32_t _an_x1_cfg_ctl;
} BCMI_TSCE16_XGXS_AN_X1_CFG_CTLr_t;

#define BCMI_TSCE16_XGXS_AN_X1_CFG_CTLr_CLR(r) (r).an_x1_cfg_ctl[0] = 0
#define BCMI_TSCE16_XGXS_AN_X1_CFG_CTLr_SET(r,d) (r).an_x1_cfg_ctl[0] = d
#define BCMI_TSCE16_XGXS_AN_X1_CFG_CTLr_GET(r) (r).an_x1_cfg_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X1_CFG_CTLr_AN_PD_TO_CL37_RETRY_COUNTf_GET(r) (((r).an_x1_cfg_ctl[0]) & 0xff)
#define BCMI_TSCE16_XGXS_AN_X1_CFG_CTLr_AN_PD_TO_CL37_RETRY_COUNTf_SET(r,f) (r).an_x1_cfg_ctl[0]=(((r).an_x1_cfg_ctl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access AN_X1_CFG_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X1_CFG_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X1_CFG_CTLr,(_r._an_x1_cfg_ctl))
#define BCMI_TSCE16_XGXS_WRITE_AN_X1_CFG_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_CFG_CTLr,(_r._an_x1_cfg_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X1_CFG_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_CFG_CTLr,(_r._an_x1_cfg_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_CFG_CTLr BCMI_TSCE16_XGXS_AN_X1_CFG_CTLr
#define AN_X1_CFG_CTLr_SIZE BCMI_TSCE16_XGXS_AN_X1_CFG_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_AN_X1_CFG_CTLr_t AN_X1_CFG_CTLr_t;
#define AN_X1_CFG_CTLr_CLR BCMI_TSCE16_XGXS_AN_X1_CFG_CTLr_CLR
#define AN_X1_CFG_CTLr_SET BCMI_TSCE16_XGXS_AN_X1_CFG_CTLr_SET
#define AN_X1_CFG_CTLr_GET BCMI_TSCE16_XGXS_AN_X1_CFG_CTLr_GET
#define AN_X1_CFG_CTLr_AN_PD_TO_CL37_RETRY_COUNTf_GET BCMI_TSCE16_XGXS_AN_X1_CFG_CTLr_AN_PD_TO_CL37_RETRY_COUNTf_GET
#define AN_X1_CFG_CTLr_AN_PD_TO_CL37_RETRY_COUNTf_SET BCMI_TSCE16_XGXS_AN_X1_CFG_CTLr_AN_PD_TO_CL37_RETRY_COUNTf_SET
#define READ_AN_X1_CFG_CTLr BCMI_TSCE16_XGXS_READ_AN_X1_CFG_CTLr
#define WRITE_AN_X1_CFG_CTLr BCMI_TSCE16_XGXS_WRITE_AN_X1_CFG_CTLr
#define MODIFY_AN_X1_CFG_CTLr BCMI_TSCE16_XGXS_MODIFY_AN_X1_CFG_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X1_CFG_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X1_CL37_RESTART
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9250
 * DESC:     CL37 AUTO-NEG RESTART TIMER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL37_RESTART_TIMER_PERIOD Period/range is 10 mssingle copyCL37 auto-neg restart timer. Timer for the amout of time to send restart pages.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X1_CL37_RESTARTr (0x00109250 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X1_CL37_RESTARTr_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_CL37_RESTART.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X1_CL37_RESTARTr_s {
	uint32_t v[1];
	uint32_t an_x1_cl37_restart[1];
	uint32_t _an_x1_cl37_restart;
} BCMI_TSCE16_XGXS_AN_X1_CL37_RESTARTr_t;

#define BCMI_TSCE16_XGXS_AN_X1_CL37_RESTARTr_CLR(r) (r).an_x1_cl37_restart[0] = 0
#define BCMI_TSCE16_XGXS_AN_X1_CL37_RESTARTr_SET(r,d) (r).an_x1_cl37_restart[0] = d
#define BCMI_TSCE16_XGXS_AN_X1_CL37_RESTARTr_GET(r) (r).an_x1_cl37_restart[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X1_CL37_RESTARTr_CL37_RESTART_TIMER_PERIODf_GET(r) (((r).an_x1_cl37_restart[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_AN_X1_CL37_RESTARTr_CL37_RESTART_TIMER_PERIODf_SET(r,f) (r).an_x1_cl37_restart[0]=(((r).an_x1_cl37_restart[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X1_CL37_RESTART.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X1_CL37_RESTARTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X1_CL37_RESTARTr,(_r._an_x1_cl37_restart))
#define BCMI_TSCE16_XGXS_WRITE_AN_X1_CL37_RESTARTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_CL37_RESTARTr,(_r._an_x1_cl37_restart)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X1_CL37_RESTARTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_CL37_RESTARTr,(_r._an_x1_cl37_restart))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_CL37_RESTARTr BCMI_TSCE16_XGXS_AN_X1_CL37_RESTARTr
#define AN_X1_CL37_RESTARTr_SIZE BCMI_TSCE16_XGXS_AN_X1_CL37_RESTARTr_SIZE
typedef BCMI_TSCE16_XGXS_AN_X1_CL37_RESTARTr_t AN_X1_CL37_RESTARTr_t;
#define AN_X1_CL37_RESTARTr_CLR BCMI_TSCE16_XGXS_AN_X1_CL37_RESTARTr_CLR
#define AN_X1_CL37_RESTARTr_SET BCMI_TSCE16_XGXS_AN_X1_CL37_RESTARTr_SET
#define AN_X1_CL37_RESTARTr_GET BCMI_TSCE16_XGXS_AN_X1_CL37_RESTARTr_GET
#define AN_X1_CL37_RESTARTr_CL37_RESTART_TIMER_PERIODf_GET BCMI_TSCE16_XGXS_AN_X1_CL37_RESTARTr_CL37_RESTART_TIMER_PERIODf_GET
#define AN_X1_CL37_RESTARTr_CL37_RESTART_TIMER_PERIODf_SET BCMI_TSCE16_XGXS_AN_X1_CL37_RESTARTr_CL37_RESTART_TIMER_PERIODf_SET
#define READ_AN_X1_CL37_RESTARTr BCMI_TSCE16_XGXS_READ_AN_X1_CL37_RESTARTr
#define WRITE_AN_X1_CL37_RESTARTr BCMI_TSCE16_XGXS_WRITE_AN_X1_CL37_RESTARTr
#define MODIFY_AN_X1_CL37_RESTARTr BCMI_TSCE16_XGXS_MODIFY_AN_X1_CL37_RESTARTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X1_CL37_RESTARTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X1_CL37_ACK
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9251
 * DESC:     CL37 AUTO-NEG COMPLETE-ACKNOWLEDGE TIMER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL37_ACK_TIMER_PERIOD Period/range is 10 mssingle copyCL37 auto-neg complete-acknowledge timer.  Timer for the amount of time to sent CL37 acknowledges.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X1_CL37_ACKr (0x00109251 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X1_CL37_ACKr_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_CL37_ACK.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X1_CL37_ACKr_s {
	uint32_t v[1];
	uint32_t an_x1_cl37_ack[1];
	uint32_t _an_x1_cl37_ack;
} BCMI_TSCE16_XGXS_AN_X1_CL37_ACKr_t;

#define BCMI_TSCE16_XGXS_AN_X1_CL37_ACKr_CLR(r) (r).an_x1_cl37_ack[0] = 0
#define BCMI_TSCE16_XGXS_AN_X1_CL37_ACKr_SET(r,d) (r).an_x1_cl37_ack[0] = d
#define BCMI_TSCE16_XGXS_AN_X1_CL37_ACKr_GET(r) (r).an_x1_cl37_ack[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X1_CL37_ACKr_CL37_ACK_TIMER_PERIODf_GET(r) (((r).an_x1_cl37_ack[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_AN_X1_CL37_ACKr_CL37_ACK_TIMER_PERIODf_SET(r,f) (r).an_x1_cl37_ack[0]=(((r).an_x1_cl37_ack[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X1_CL37_ACK.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X1_CL37_ACKr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X1_CL37_ACKr,(_r._an_x1_cl37_ack))
#define BCMI_TSCE16_XGXS_WRITE_AN_X1_CL37_ACKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_CL37_ACKr,(_r._an_x1_cl37_ack)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X1_CL37_ACKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_CL37_ACKr,(_r._an_x1_cl37_ack))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_CL37_ACKr BCMI_TSCE16_XGXS_AN_X1_CL37_ACKr
#define AN_X1_CL37_ACKr_SIZE BCMI_TSCE16_XGXS_AN_X1_CL37_ACKr_SIZE
typedef BCMI_TSCE16_XGXS_AN_X1_CL37_ACKr_t AN_X1_CL37_ACKr_t;
#define AN_X1_CL37_ACKr_CLR BCMI_TSCE16_XGXS_AN_X1_CL37_ACKr_CLR
#define AN_X1_CL37_ACKr_SET BCMI_TSCE16_XGXS_AN_X1_CL37_ACKr_SET
#define AN_X1_CL37_ACKr_GET BCMI_TSCE16_XGXS_AN_X1_CL37_ACKr_GET
#define AN_X1_CL37_ACKr_CL37_ACK_TIMER_PERIODf_GET BCMI_TSCE16_XGXS_AN_X1_CL37_ACKr_CL37_ACK_TIMER_PERIODf_GET
#define AN_X1_CL37_ACKr_CL37_ACK_TIMER_PERIODf_SET BCMI_TSCE16_XGXS_AN_X1_CL37_ACKr_CL37_ACK_TIMER_PERIODf_SET
#define READ_AN_X1_CL37_ACKr BCMI_TSCE16_XGXS_READ_AN_X1_CL37_ACKr
#define WRITE_AN_X1_CL37_ACKr BCMI_TSCE16_XGXS_WRITE_AN_X1_CL37_ACKr
#define MODIFY_AN_X1_CL37_ACKr BCMI_TSCE16_XGXS_MODIFY_AN_X1_CL37_ACKr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X1_CL37_ACKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X1_CL37_ERR
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9252
 * DESC:     CL37 AUTO-NEG TIMEOUT-ERROR TIMER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL37_ERROR_TIMER_PERIOD Period/range is 20.6 mssingle copyCL37 auto-neg timeout-error timer Timer for the amout ot time to receive a page from the link partner.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X1_CL37_ERRr (0x00109252 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X1_CL37_ERRr_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_CL37_ERR.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X1_CL37_ERRr_s {
	uint32_t v[1];
	uint32_t an_x1_cl37_err[1];
	uint32_t _an_x1_cl37_err;
} BCMI_TSCE16_XGXS_AN_X1_CL37_ERRr_t;

#define BCMI_TSCE16_XGXS_AN_X1_CL37_ERRr_CLR(r) (r).an_x1_cl37_err[0] = 0
#define BCMI_TSCE16_XGXS_AN_X1_CL37_ERRr_SET(r,d) (r).an_x1_cl37_err[0] = d
#define BCMI_TSCE16_XGXS_AN_X1_CL37_ERRr_GET(r) (r).an_x1_cl37_err[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X1_CL37_ERRr_CL37_ERROR_TIMER_PERIODf_GET(r) (((r).an_x1_cl37_err[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_AN_X1_CL37_ERRr_CL37_ERROR_TIMER_PERIODf_SET(r,f) (r).an_x1_cl37_err[0]=(((r).an_x1_cl37_err[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X1_CL37_ERR.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X1_CL37_ERRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X1_CL37_ERRr,(_r._an_x1_cl37_err))
#define BCMI_TSCE16_XGXS_WRITE_AN_X1_CL37_ERRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_CL37_ERRr,(_r._an_x1_cl37_err)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X1_CL37_ERRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_CL37_ERRr,(_r._an_x1_cl37_err))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_CL37_ERRr BCMI_TSCE16_XGXS_AN_X1_CL37_ERRr
#define AN_X1_CL37_ERRr_SIZE BCMI_TSCE16_XGXS_AN_X1_CL37_ERRr_SIZE
typedef BCMI_TSCE16_XGXS_AN_X1_CL37_ERRr_t AN_X1_CL37_ERRr_t;
#define AN_X1_CL37_ERRr_CLR BCMI_TSCE16_XGXS_AN_X1_CL37_ERRr_CLR
#define AN_X1_CL37_ERRr_SET BCMI_TSCE16_XGXS_AN_X1_CL37_ERRr_SET
#define AN_X1_CL37_ERRr_GET BCMI_TSCE16_XGXS_AN_X1_CL37_ERRr_GET
#define AN_X1_CL37_ERRr_CL37_ERROR_TIMER_PERIODf_GET BCMI_TSCE16_XGXS_AN_X1_CL37_ERRr_CL37_ERROR_TIMER_PERIODf_GET
#define AN_X1_CL37_ERRr_CL37_ERROR_TIMER_PERIODf_SET BCMI_TSCE16_XGXS_AN_X1_CL37_ERRr_CL37_ERROR_TIMER_PERIODf_SET
#define READ_AN_X1_CL37_ERRr BCMI_TSCE16_XGXS_READ_AN_X1_CL37_ERRr
#define WRITE_AN_X1_CL37_ERRr BCMI_TSCE16_XGXS_WRITE_AN_X1_CL37_ERRr
#define MODIFY_AN_X1_CL37_ERRr BCMI_TSCE16_XGXS_MODIFY_AN_X1_CL37_ERRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X1_CL37_ERRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X1_CL73_BRK_LNK
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9253
 * DESC:     CL73 AUTO-NEG BREAK-LINK TIMER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_DISABLE_TIMER_PERIOD Period/range is 60 tosingle copyCL73 auto-neg break-link timer.  Timer for the amount of time to disable transmission in order to assure that the link parner enters a Link Fail state.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X1_CL73_BRK_LNKr (0x00109253 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X1_CL73_BRK_LNKr_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_CL73_BRK_LNK.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X1_CL73_BRK_LNKr_s {
	uint32_t v[1];
	uint32_t an_x1_cl73_brk_lnk[1];
	uint32_t _an_x1_cl73_brk_lnk;
} BCMI_TSCE16_XGXS_AN_X1_CL73_BRK_LNKr_t;

#define BCMI_TSCE16_XGXS_AN_X1_CL73_BRK_LNKr_CLR(r) (r).an_x1_cl73_brk_lnk[0] = 0
#define BCMI_TSCE16_XGXS_AN_X1_CL73_BRK_LNKr_SET(r,d) (r).an_x1_cl73_brk_lnk[0] = d
#define BCMI_TSCE16_XGXS_AN_X1_CL73_BRK_LNKr_GET(r) (r).an_x1_cl73_brk_lnk[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X1_CL73_BRK_LNKr_TX_DISABLE_TIMER_PERIODf_GET(r) (((r).an_x1_cl73_brk_lnk[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_AN_X1_CL73_BRK_LNKr_TX_DISABLE_TIMER_PERIODf_SET(r,f) (r).an_x1_cl73_brk_lnk[0]=(((r).an_x1_cl73_brk_lnk[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X1_CL73_BRK_LNK.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X1_CL73_BRK_LNKr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X1_CL73_BRK_LNKr,(_r._an_x1_cl73_brk_lnk))
#define BCMI_TSCE16_XGXS_WRITE_AN_X1_CL73_BRK_LNKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_CL73_BRK_LNKr,(_r._an_x1_cl73_brk_lnk)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X1_CL73_BRK_LNKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_CL73_BRK_LNKr,(_r._an_x1_cl73_brk_lnk))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_CL73_BRK_LNKr BCMI_TSCE16_XGXS_AN_X1_CL73_BRK_LNKr
#define AN_X1_CL73_BRK_LNKr_SIZE BCMI_TSCE16_XGXS_AN_X1_CL73_BRK_LNKr_SIZE
typedef BCMI_TSCE16_XGXS_AN_X1_CL73_BRK_LNKr_t AN_X1_CL73_BRK_LNKr_t;
#define AN_X1_CL73_BRK_LNKr_CLR BCMI_TSCE16_XGXS_AN_X1_CL73_BRK_LNKr_CLR
#define AN_X1_CL73_BRK_LNKr_SET BCMI_TSCE16_XGXS_AN_X1_CL73_BRK_LNKr_SET
#define AN_X1_CL73_BRK_LNKr_GET BCMI_TSCE16_XGXS_AN_X1_CL73_BRK_LNKr_GET
#define AN_X1_CL73_BRK_LNKr_TX_DISABLE_TIMER_PERIODf_GET BCMI_TSCE16_XGXS_AN_X1_CL73_BRK_LNKr_TX_DISABLE_TIMER_PERIODf_GET
#define AN_X1_CL73_BRK_LNKr_TX_DISABLE_TIMER_PERIODf_SET BCMI_TSCE16_XGXS_AN_X1_CL73_BRK_LNKr_TX_DISABLE_TIMER_PERIODf_SET
#define READ_AN_X1_CL73_BRK_LNKr BCMI_TSCE16_XGXS_READ_AN_X1_CL73_BRK_LNKr
#define WRITE_AN_X1_CL73_BRK_LNKr BCMI_TSCE16_XGXS_WRITE_AN_X1_CL73_BRK_LNKr
#define MODIFY_AN_X1_CL73_BRK_LNKr BCMI_TSCE16_XGXS_MODIFY_AN_X1_CL73_BRK_LNKr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X1_CL73_BRK_LNKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X1_CL73_ERR
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9254
 * DESC:     CL73 AUTO-NEG TIMEOUT-ERROR TIMER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL73_ERROR_TIMER_PERIOD Period/range is 20.6 mssingle copyCL73 auto-neg timeout-error timer Timer for the amout ot time to wait to receive a page from the link partner.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X1_CL73_ERRr (0x00109254 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X1_CL73_ERRr_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_CL73_ERR.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X1_CL73_ERRr_s {
	uint32_t v[1];
	uint32_t an_x1_cl73_err[1];
	uint32_t _an_x1_cl73_err;
} BCMI_TSCE16_XGXS_AN_X1_CL73_ERRr_t;

#define BCMI_TSCE16_XGXS_AN_X1_CL73_ERRr_CLR(r) (r).an_x1_cl73_err[0] = 0
#define BCMI_TSCE16_XGXS_AN_X1_CL73_ERRr_SET(r,d) (r).an_x1_cl73_err[0] = d
#define BCMI_TSCE16_XGXS_AN_X1_CL73_ERRr_GET(r) (r).an_x1_cl73_err[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X1_CL73_ERRr_CL73_ERROR_TIMER_PERIODf_GET(r) (((r).an_x1_cl73_err[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_AN_X1_CL73_ERRr_CL73_ERROR_TIMER_PERIODf_SET(r,f) (r).an_x1_cl73_err[0]=(((r).an_x1_cl73_err[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X1_CL73_ERR.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X1_CL73_ERRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X1_CL73_ERRr,(_r._an_x1_cl73_err))
#define BCMI_TSCE16_XGXS_WRITE_AN_X1_CL73_ERRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_CL73_ERRr,(_r._an_x1_cl73_err)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X1_CL73_ERRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_CL73_ERRr,(_r._an_x1_cl73_err))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_CL73_ERRr BCMI_TSCE16_XGXS_AN_X1_CL73_ERRr
#define AN_X1_CL73_ERRr_SIZE BCMI_TSCE16_XGXS_AN_X1_CL73_ERRr_SIZE
typedef BCMI_TSCE16_XGXS_AN_X1_CL73_ERRr_t AN_X1_CL73_ERRr_t;
#define AN_X1_CL73_ERRr_CLR BCMI_TSCE16_XGXS_AN_X1_CL73_ERRr_CLR
#define AN_X1_CL73_ERRr_SET BCMI_TSCE16_XGXS_AN_X1_CL73_ERRr_SET
#define AN_X1_CL73_ERRr_GET BCMI_TSCE16_XGXS_AN_X1_CL73_ERRr_GET
#define AN_X1_CL73_ERRr_CL73_ERROR_TIMER_PERIODf_GET BCMI_TSCE16_XGXS_AN_X1_CL73_ERRr_CL73_ERROR_TIMER_PERIODf_GET
#define AN_X1_CL73_ERRr_CL73_ERROR_TIMER_PERIODf_SET BCMI_TSCE16_XGXS_AN_X1_CL73_ERRr_CL73_ERROR_TIMER_PERIODf_SET
#define READ_AN_X1_CL73_ERRr BCMI_TSCE16_XGXS_READ_AN_X1_CL73_ERRr
#define WRITE_AN_X1_CL73_ERRr BCMI_TSCE16_XGXS_WRITE_AN_X1_CL73_ERRr
#define MODIFY_AN_X1_CL73_ERRr BCMI_TSCE16_XGXS_MODIFY_AN_X1_CL73_ERRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X1_CL73_ERRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X1_CL73_DME_LOCK
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9255
 * DESC:     CL73 PARALLEL-DETECT DME-CLOCK TIMER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PD_DME_LOCK_TIMER_PERIOD Period/range is 25 tosingle copyCL73 parallel-detect DME-clock timer Timer for the amount of time to wait before evaluating the DME_locked signal.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X1_CL73_DME_LOCKr (0x00109255 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X1_CL73_DME_LOCKr_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_CL73_DME_LOCK.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X1_CL73_DME_LOCKr_s {
	uint32_t v[1];
	uint32_t an_x1_cl73_dme_lock[1];
	uint32_t _an_x1_cl73_dme_lock;
} BCMI_TSCE16_XGXS_AN_X1_CL73_DME_LOCKr_t;

#define BCMI_TSCE16_XGXS_AN_X1_CL73_DME_LOCKr_CLR(r) (r).an_x1_cl73_dme_lock[0] = 0
#define BCMI_TSCE16_XGXS_AN_X1_CL73_DME_LOCKr_SET(r,d) (r).an_x1_cl73_dme_lock[0] = d
#define BCMI_TSCE16_XGXS_AN_X1_CL73_DME_LOCKr_GET(r) (r).an_x1_cl73_dme_lock[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X1_CL73_DME_LOCKr_PD_DME_LOCK_TIMER_PERIODf_GET(r) (((r).an_x1_cl73_dme_lock[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_AN_X1_CL73_DME_LOCKr_PD_DME_LOCK_TIMER_PERIODf_SET(r,f) (r).an_x1_cl73_dme_lock[0]=(((r).an_x1_cl73_dme_lock[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X1_CL73_DME_LOCK.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X1_CL73_DME_LOCKr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X1_CL73_DME_LOCKr,(_r._an_x1_cl73_dme_lock))
#define BCMI_TSCE16_XGXS_WRITE_AN_X1_CL73_DME_LOCKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_CL73_DME_LOCKr,(_r._an_x1_cl73_dme_lock)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X1_CL73_DME_LOCKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_CL73_DME_LOCKr,(_r._an_x1_cl73_dme_lock))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_CL73_DME_LOCKr BCMI_TSCE16_XGXS_AN_X1_CL73_DME_LOCKr
#define AN_X1_CL73_DME_LOCKr_SIZE BCMI_TSCE16_XGXS_AN_X1_CL73_DME_LOCKr_SIZE
typedef BCMI_TSCE16_XGXS_AN_X1_CL73_DME_LOCKr_t AN_X1_CL73_DME_LOCKr_t;
#define AN_X1_CL73_DME_LOCKr_CLR BCMI_TSCE16_XGXS_AN_X1_CL73_DME_LOCKr_CLR
#define AN_X1_CL73_DME_LOCKr_SET BCMI_TSCE16_XGXS_AN_X1_CL73_DME_LOCKr_SET
#define AN_X1_CL73_DME_LOCKr_GET BCMI_TSCE16_XGXS_AN_X1_CL73_DME_LOCKr_GET
#define AN_X1_CL73_DME_LOCKr_PD_DME_LOCK_TIMER_PERIODf_GET BCMI_TSCE16_XGXS_AN_X1_CL73_DME_LOCKr_PD_DME_LOCK_TIMER_PERIODf_GET
#define AN_X1_CL73_DME_LOCKr_PD_DME_LOCK_TIMER_PERIODf_SET BCMI_TSCE16_XGXS_AN_X1_CL73_DME_LOCKr_PD_DME_LOCK_TIMER_PERIODf_SET
#define READ_AN_X1_CL73_DME_LOCKr BCMI_TSCE16_XGXS_READ_AN_X1_CL73_DME_LOCKr
#define WRITE_AN_X1_CL73_DME_LOCKr BCMI_TSCE16_XGXS_WRITE_AN_X1_CL73_DME_LOCKr
#define MODIFY_AN_X1_CL73_DME_LOCKr BCMI_TSCE16_XGXS_MODIFY_AN_X1_CL73_DME_LOCKr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X1_CL73_DME_LOCKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X1_LNK_UP
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9256
 * DESC:     CL73 LINK-UP TIMER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL73_LINK_UP_TIMER_PERIOD Period/range is 100 tosingle copyCL73 link-up timer.  Timer for the amount of time for the link to come up.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X1_LNK_UPr (0x00109256 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X1_LNK_UPr_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_LNK_UP.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X1_LNK_UPr_s {
	uint32_t v[1];
	uint32_t an_x1_lnk_up[1];
	uint32_t _an_x1_lnk_up;
} BCMI_TSCE16_XGXS_AN_X1_LNK_UPr_t;

#define BCMI_TSCE16_XGXS_AN_X1_LNK_UPr_CLR(r) (r).an_x1_lnk_up[0] = 0
#define BCMI_TSCE16_XGXS_AN_X1_LNK_UPr_SET(r,d) (r).an_x1_lnk_up[0] = d
#define BCMI_TSCE16_XGXS_AN_X1_LNK_UPr_GET(r) (r).an_x1_lnk_up[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X1_LNK_UPr_CL73_LINK_UP_TIMER_PERIODf_GET(r) (((r).an_x1_lnk_up[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_AN_X1_LNK_UPr_CL73_LINK_UP_TIMER_PERIODf_SET(r,f) (r).an_x1_lnk_up[0]=(((r).an_x1_lnk_up[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X1_LNK_UP.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X1_LNK_UPr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X1_LNK_UPr,(_r._an_x1_lnk_up))
#define BCMI_TSCE16_XGXS_WRITE_AN_X1_LNK_UPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_LNK_UPr,(_r._an_x1_lnk_up)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X1_LNK_UPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_LNK_UPr,(_r._an_x1_lnk_up))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_LNK_UPr BCMI_TSCE16_XGXS_AN_X1_LNK_UPr
#define AN_X1_LNK_UPr_SIZE BCMI_TSCE16_XGXS_AN_X1_LNK_UPr_SIZE
typedef BCMI_TSCE16_XGXS_AN_X1_LNK_UPr_t AN_X1_LNK_UPr_t;
#define AN_X1_LNK_UPr_CLR BCMI_TSCE16_XGXS_AN_X1_LNK_UPr_CLR
#define AN_X1_LNK_UPr_SET BCMI_TSCE16_XGXS_AN_X1_LNK_UPr_SET
#define AN_X1_LNK_UPr_GET BCMI_TSCE16_XGXS_AN_X1_LNK_UPr_GET
#define AN_X1_LNK_UPr_CL73_LINK_UP_TIMER_PERIODf_GET BCMI_TSCE16_XGXS_AN_X1_LNK_UPr_CL73_LINK_UP_TIMER_PERIODf_GET
#define AN_X1_LNK_UPr_CL73_LINK_UP_TIMER_PERIODf_SET BCMI_TSCE16_XGXS_AN_X1_LNK_UPr_CL73_LINK_UP_TIMER_PERIODf_SET
#define READ_AN_X1_LNK_UPr BCMI_TSCE16_XGXS_READ_AN_X1_LNK_UPr
#define WRITE_AN_X1_LNK_UPr BCMI_TSCE16_XGXS_WRITE_AN_X1_LNK_UPr
#define MODIFY_AN_X1_LNK_UPr BCMI_TSCE16_XGXS_MODIFY_AN_X1_LNK_UPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X1_LNK_UPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X1_LNK_FAIL_INHBT_TMR_CL72
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9257
 * DESC:     TIMER FOR QUALIFYING A LINK_STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LINK_FAIL_INHIBIT_TIMER_CL72_PERIOD Period/range is typically 500mssingle copyTimer for qualifying a link_status==FAIL indication or a link_status==OK indication when a link is first being established and cl72 training is being run.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r (0x00109257 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_LNK_FAIL_INHBT_TMR_CL72.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_s {
	uint32_t v[1];
	uint32_t an_x1_lnk_fail_inhbt_tmr_cl72[1];
	uint32_t _an_x1_lnk_fail_inhbt_tmr_cl72;
} BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_t;

#define BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_CLR(r) (r).an_x1_lnk_fail_inhbt_tmr_cl72[0] = 0
#define BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_SET(r,d) (r).an_x1_lnk_fail_inhbt_tmr_cl72[0] = d
#define BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_GET(r) (r).an_x1_lnk_fail_inhbt_tmr_cl72[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_LINK_FAIL_INHIBIT_TIMER_CL72_PERIODf_GET(r) (((r).an_x1_lnk_fail_inhbt_tmr_cl72[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_LINK_FAIL_INHIBIT_TIMER_CL72_PERIODf_SET(r,f) (r).an_x1_lnk_fail_inhbt_tmr_cl72[0]=(((r).an_x1_lnk_fail_inhbt_tmr_cl72[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X1_LNK_FAIL_INHBT_TMR_CL72.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X1_LNK_FAIL_INHBT_TMR_CL72r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r,(_r._an_x1_lnk_fail_inhbt_tmr_cl72))
#define BCMI_TSCE16_XGXS_WRITE_AN_X1_LNK_FAIL_INHBT_TMR_CL72r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r,(_r._an_x1_lnk_fail_inhbt_tmr_cl72)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X1_LNK_FAIL_INHBT_TMR_CL72r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r,(_r._an_x1_lnk_fail_inhbt_tmr_cl72))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_LNK_FAIL_INHBT_TMR_CL72r BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r
#define AN_X1_LNK_FAIL_INHBT_TMR_CL72r_SIZE BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_SIZE
typedef BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_t AN_X1_LNK_FAIL_INHBT_TMR_CL72r_t;
#define AN_X1_LNK_FAIL_INHBT_TMR_CL72r_CLR BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_CLR
#define AN_X1_LNK_FAIL_INHBT_TMR_CL72r_SET BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_SET
#define AN_X1_LNK_FAIL_INHBT_TMR_CL72r_GET BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_GET
#define AN_X1_LNK_FAIL_INHBT_TMR_CL72r_LINK_FAIL_INHIBIT_TIMER_CL72_PERIODf_GET BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_LINK_FAIL_INHIBIT_TIMER_CL72_PERIODf_GET
#define AN_X1_LNK_FAIL_INHBT_TMR_CL72r_LINK_FAIL_INHIBIT_TIMER_CL72_PERIODf_SET BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_LINK_FAIL_INHIBIT_TIMER_CL72_PERIODf_SET
#define READ_AN_X1_LNK_FAIL_INHBT_TMR_CL72r BCMI_TSCE16_XGXS_READ_AN_X1_LNK_FAIL_INHBT_TMR_CL72r
#define WRITE_AN_X1_LNK_FAIL_INHBT_TMR_CL72r BCMI_TSCE16_XGXS_WRITE_AN_X1_LNK_FAIL_INHBT_TMR_CL72r
#define MODIFY_AN_X1_LNK_FAIL_INHBT_TMR_CL72r BCMI_TSCE16_XGXS_MODIFY_AN_X1_LNK_FAIL_INHBT_TMR_CL72r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9258
 * DESC:     Timer FOR QUALIFYING A LINK_STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LINK_FAIL_INHIBIT_TIMER_NCL72_PERIOD Period/range is typically 40mssingle copyTimer for qualifying a link_status==FAIL indication or a link_status==OK indication when a link is first being established and cl72 training is not being run.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r (0x00109258 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_s {
	uint32_t v[1];
	uint32_t an_x1_lnk_fail_inhbt_tmr_not_cl72[1];
	uint32_t _an_x1_lnk_fail_inhbt_tmr_not_cl72;
} BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_t;

#define BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_CLR(r) (r).an_x1_lnk_fail_inhbt_tmr_not_cl72[0] = 0
#define BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_SET(r,d) (r).an_x1_lnk_fail_inhbt_tmr_not_cl72[0] = d
#define BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_GET(r) (r).an_x1_lnk_fail_inhbt_tmr_not_cl72[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIODf_GET(r) (((r).an_x1_lnk_fail_inhbt_tmr_not_cl72[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIODf_SET(r,f) (r).an_x1_lnk_fail_inhbt_tmr_not_cl72[0]=(((r).an_x1_lnk_fail_inhbt_tmr_not_cl72[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r,(_r._an_x1_lnk_fail_inhbt_tmr_not_cl72))
#define BCMI_TSCE16_XGXS_WRITE_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r,(_r._an_x1_lnk_fail_inhbt_tmr_not_cl72)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r,(_r._an_x1_lnk_fail_inhbt_tmr_not_cl72))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r
#define AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_SIZE BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_SIZE
typedef BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_t AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_t;
#define AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_CLR BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_CLR
#define AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_SET BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_SET
#define AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_GET BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_GET
#define AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIODf_GET BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIODf_GET
#define AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIODf_SET BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIODf_SET
#define READ_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r BCMI_TSCE16_XGXS_READ_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r
#define WRITE_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r BCMI_TSCE16_XGXS_WRITE_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r
#define MODIFY_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r BCMI_TSCE16_XGXS_MODIFY_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X1_PD_SD_TMR
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9259
 * DESC:     PARALLEL-DETECT SIGNAL DETECT TIMER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PD_SD_TIMER_PERIOD single copyParallel-Detect Signal Detect timer.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X1_PD_SD_TMRr (0x00109259 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X1_PD_SD_TMRr_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_PD_SD_TMR.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X1_PD_SD_TMRr_s {
	uint32_t v[1];
	uint32_t an_x1_pd_sd_tmr[1];
	uint32_t _an_x1_pd_sd_tmr;
} BCMI_TSCE16_XGXS_AN_X1_PD_SD_TMRr_t;

#define BCMI_TSCE16_XGXS_AN_X1_PD_SD_TMRr_CLR(r) (r).an_x1_pd_sd_tmr[0] = 0
#define BCMI_TSCE16_XGXS_AN_X1_PD_SD_TMRr_SET(r,d) (r).an_x1_pd_sd_tmr[0] = d
#define BCMI_TSCE16_XGXS_AN_X1_PD_SD_TMRr_GET(r) (r).an_x1_pd_sd_tmr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X1_PD_SD_TMRr_PD_SD_TIMER_PERIODf_GET(r) (((r).an_x1_pd_sd_tmr[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_AN_X1_PD_SD_TMRr_PD_SD_TIMER_PERIODf_SET(r,f) (r).an_x1_pd_sd_tmr[0]=(((r).an_x1_pd_sd_tmr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X1_PD_SD_TMR.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X1_PD_SD_TMRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X1_PD_SD_TMRr,(_r._an_x1_pd_sd_tmr))
#define BCMI_TSCE16_XGXS_WRITE_AN_X1_PD_SD_TMRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_PD_SD_TMRr,(_r._an_x1_pd_sd_tmr)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X1_PD_SD_TMRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_PD_SD_TMRr,(_r._an_x1_pd_sd_tmr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_PD_SD_TMRr BCMI_TSCE16_XGXS_AN_X1_PD_SD_TMRr
#define AN_X1_PD_SD_TMRr_SIZE BCMI_TSCE16_XGXS_AN_X1_PD_SD_TMRr_SIZE
typedef BCMI_TSCE16_XGXS_AN_X1_PD_SD_TMRr_t AN_X1_PD_SD_TMRr_t;
#define AN_X1_PD_SD_TMRr_CLR BCMI_TSCE16_XGXS_AN_X1_PD_SD_TMRr_CLR
#define AN_X1_PD_SD_TMRr_SET BCMI_TSCE16_XGXS_AN_X1_PD_SD_TMRr_SET
#define AN_X1_PD_SD_TMRr_GET BCMI_TSCE16_XGXS_AN_X1_PD_SD_TMRr_GET
#define AN_X1_PD_SD_TMRr_PD_SD_TIMER_PERIODf_GET BCMI_TSCE16_XGXS_AN_X1_PD_SD_TMRr_PD_SD_TIMER_PERIODf_GET
#define AN_X1_PD_SD_TMRr_PD_SD_TIMER_PERIODf_SET BCMI_TSCE16_XGXS_AN_X1_PD_SD_TMRr_PD_SD_TIMER_PERIODf_SET
#define READ_AN_X1_PD_SD_TMRr BCMI_TSCE16_XGXS_READ_AN_X1_PD_SD_TMRr
#define WRITE_AN_X1_PD_SD_TMRr BCMI_TSCE16_XGXS_WRITE_AN_X1_PD_SD_TMRr
#define MODIFY_AN_X1_PD_SD_TMRr BCMI_TSCE16_XGXS_MODIFY_AN_X1_PD_SD_TMRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X1_PD_SD_TMRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X1_CL37_SYNC_STS_FILTER_TMR
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x925a
 * DESC:     PERIOD TO IGNORE CL37 SYNC_STATUS DOWN INDICATION
 * RESETVAL: 0x2 (2)
 * ACCESS:   R/W
 * FIELDS:
 *     CL37_SYNC_STATUS_FILTER_TIMER_PERIOD Period is in tickssingle copyPeriod to ignore the cl37 sync_status down indication if it is less than 10ms
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X1_CL37_SYNC_STS_FILTER_TMRr (0x0010925a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X1_CL37_SYNC_STS_FILTER_TMRr_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_CL37_SYNC_STS_FILTER_TMR.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X1_CL37_SYNC_STS_FILTER_TMRr_s {
	uint32_t v[1];
	uint32_t an_x1_cl37_sync_sts_filter_tmr[1];
	uint32_t _an_x1_cl37_sync_sts_filter_tmr;
} BCMI_TSCE16_XGXS_AN_X1_CL37_SYNC_STS_FILTER_TMRr_t;

#define BCMI_TSCE16_XGXS_AN_X1_CL37_SYNC_STS_FILTER_TMRr_CLR(r) (r).an_x1_cl37_sync_sts_filter_tmr[0] = 0
#define BCMI_TSCE16_XGXS_AN_X1_CL37_SYNC_STS_FILTER_TMRr_SET(r,d) (r).an_x1_cl37_sync_sts_filter_tmr[0] = d
#define BCMI_TSCE16_XGXS_AN_X1_CL37_SYNC_STS_FILTER_TMRr_GET(r) (r).an_x1_cl37_sync_sts_filter_tmr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X1_CL37_SYNC_STS_FILTER_TMRr_CL37_SYNC_STATUS_FILTER_TIMER_PERIODf_GET(r) (((r).an_x1_cl37_sync_sts_filter_tmr[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_AN_X1_CL37_SYNC_STS_FILTER_TMRr_CL37_SYNC_STATUS_FILTER_TIMER_PERIODf_SET(r,f) (r).an_x1_cl37_sync_sts_filter_tmr[0]=(((r).an_x1_cl37_sync_sts_filter_tmr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X1_CL37_SYNC_STS_FILTER_TMR.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X1_CL37_SYNC_STS_FILTER_TMRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X1_CL37_SYNC_STS_FILTER_TMRr,(_r._an_x1_cl37_sync_sts_filter_tmr))
#define BCMI_TSCE16_XGXS_WRITE_AN_X1_CL37_SYNC_STS_FILTER_TMRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_CL37_SYNC_STS_FILTER_TMRr,(_r._an_x1_cl37_sync_sts_filter_tmr)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X1_CL37_SYNC_STS_FILTER_TMRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_CL37_SYNC_STS_FILTER_TMRr,(_r._an_x1_cl37_sync_sts_filter_tmr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_CL37_SYNC_STS_FILTER_TMRr BCMI_TSCE16_XGXS_AN_X1_CL37_SYNC_STS_FILTER_TMRr
#define AN_X1_CL37_SYNC_STS_FILTER_TMRr_SIZE BCMI_TSCE16_XGXS_AN_X1_CL37_SYNC_STS_FILTER_TMRr_SIZE
typedef BCMI_TSCE16_XGXS_AN_X1_CL37_SYNC_STS_FILTER_TMRr_t AN_X1_CL37_SYNC_STS_FILTER_TMRr_t;
#define AN_X1_CL37_SYNC_STS_FILTER_TMRr_CLR BCMI_TSCE16_XGXS_AN_X1_CL37_SYNC_STS_FILTER_TMRr_CLR
#define AN_X1_CL37_SYNC_STS_FILTER_TMRr_SET BCMI_TSCE16_XGXS_AN_X1_CL37_SYNC_STS_FILTER_TMRr_SET
#define AN_X1_CL37_SYNC_STS_FILTER_TMRr_GET BCMI_TSCE16_XGXS_AN_X1_CL37_SYNC_STS_FILTER_TMRr_GET
#define AN_X1_CL37_SYNC_STS_FILTER_TMRr_CL37_SYNC_STATUS_FILTER_TIMER_PERIODf_GET BCMI_TSCE16_XGXS_AN_X1_CL37_SYNC_STS_FILTER_TMRr_CL37_SYNC_STATUS_FILTER_TIMER_PERIODf_GET
#define AN_X1_CL37_SYNC_STS_FILTER_TMRr_CL37_SYNC_STATUS_FILTER_TIMER_PERIODf_SET BCMI_TSCE16_XGXS_AN_X1_CL37_SYNC_STS_FILTER_TMRr_CL37_SYNC_STATUS_FILTER_TIMER_PERIODf_SET
#define READ_AN_X1_CL37_SYNC_STS_FILTER_TMRr BCMI_TSCE16_XGXS_READ_AN_X1_CL37_SYNC_STS_FILTER_TMRr
#define WRITE_AN_X1_CL37_SYNC_STS_FILTER_TMRr BCMI_TSCE16_XGXS_WRITE_AN_X1_CL37_SYNC_STS_FILTER_TMRr
#define MODIFY_AN_X1_CL37_SYNC_STS_FILTER_TMRr BCMI_TSCE16_XGXS_MODIFY_AN_X1_CL37_SYNC_STS_FILTER_TMRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X1_CL37_SYNC_STS_FILTER_TMRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X1_PD_TO_CL37_LNK_WAIT_TMR
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x925b
 * DESC:     PERIOD TO WAIT FOR LINK WHEN SWITCHING  TO CL37 IN PD
 * RESETVAL: 0x6b (107)
 * ACCESS:   R/W
 * FIELDS:
 *     PD_TO_CL37_LINK_WAIT_TIMER This timer is used in PD to wait for CL73 link to come back
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X1_PD_TO_CL37_LNK_WAIT_TMRr (0x0010925b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X1_PD_TO_CL37_LNK_WAIT_TMRr_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_PD_TO_CL37_LNK_WAIT_TMR.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X1_PD_TO_CL37_LNK_WAIT_TMRr_s {
	uint32_t v[1];
	uint32_t an_x1_pd_to_cl37_lnk_wait_tmr[1];
	uint32_t _an_x1_pd_to_cl37_lnk_wait_tmr;
} BCMI_TSCE16_XGXS_AN_X1_PD_TO_CL37_LNK_WAIT_TMRr_t;

#define BCMI_TSCE16_XGXS_AN_X1_PD_TO_CL37_LNK_WAIT_TMRr_CLR(r) (r).an_x1_pd_to_cl37_lnk_wait_tmr[0] = 0
#define BCMI_TSCE16_XGXS_AN_X1_PD_TO_CL37_LNK_WAIT_TMRr_SET(r,d) (r).an_x1_pd_to_cl37_lnk_wait_tmr[0] = d
#define BCMI_TSCE16_XGXS_AN_X1_PD_TO_CL37_LNK_WAIT_TMRr_GET(r) (r).an_x1_pd_to_cl37_lnk_wait_tmr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X1_PD_TO_CL37_LNK_WAIT_TMRr_PD_TO_CL37_LINK_WAIT_TIMERf_GET(r) (((r).an_x1_pd_to_cl37_lnk_wait_tmr[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_AN_X1_PD_TO_CL37_LNK_WAIT_TMRr_PD_TO_CL37_LINK_WAIT_TIMERf_SET(r,f) (r).an_x1_pd_to_cl37_lnk_wait_tmr[0]=(((r).an_x1_pd_to_cl37_lnk_wait_tmr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X1_PD_TO_CL37_LNK_WAIT_TMR.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X1_PD_TO_CL37_LNK_WAIT_TMRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X1_PD_TO_CL37_LNK_WAIT_TMRr,(_r._an_x1_pd_to_cl37_lnk_wait_tmr))
#define BCMI_TSCE16_XGXS_WRITE_AN_X1_PD_TO_CL37_LNK_WAIT_TMRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_PD_TO_CL37_LNK_WAIT_TMRr,(_r._an_x1_pd_to_cl37_lnk_wait_tmr)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X1_PD_TO_CL37_LNK_WAIT_TMRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_PD_TO_CL37_LNK_WAIT_TMRr,(_r._an_x1_pd_to_cl37_lnk_wait_tmr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_PD_TO_CL37_LNK_WAIT_TMRr BCMI_TSCE16_XGXS_AN_X1_PD_TO_CL37_LNK_WAIT_TMRr
#define AN_X1_PD_TO_CL37_LNK_WAIT_TMRr_SIZE BCMI_TSCE16_XGXS_AN_X1_PD_TO_CL37_LNK_WAIT_TMRr_SIZE
typedef BCMI_TSCE16_XGXS_AN_X1_PD_TO_CL37_LNK_WAIT_TMRr_t AN_X1_PD_TO_CL37_LNK_WAIT_TMRr_t;
#define AN_X1_PD_TO_CL37_LNK_WAIT_TMRr_CLR BCMI_TSCE16_XGXS_AN_X1_PD_TO_CL37_LNK_WAIT_TMRr_CLR
#define AN_X1_PD_TO_CL37_LNK_WAIT_TMRr_SET BCMI_TSCE16_XGXS_AN_X1_PD_TO_CL37_LNK_WAIT_TMRr_SET
#define AN_X1_PD_TO_CL37_LNK_WAIT_TMRr_GET BCMI_TSCE16_XGXS_AN_X1_PD_TO_CL37_LNK_WAIT_TMRr_GET
#define AN_X1_PD_TO_CL37_LNK_WAIT_TMRr_PD_TO_CL37_LINK_WAIT_TIMERf_GET BCMI_TSCE16_XGXS_AN_X1_PD_TO_CL37_LNK_WAIT_TMRr_PD_TO_CL37_LINK_WAIT_TIMERf_GET
#define AN_X1_PD_TO_CL37_LNK_WAIT_TMRr_PD_TO_CL37_LINK_WAIT_TIMERf_SET BCMI_TSCE16_XGXS_AN_X1_PD_TO_CL37_LNK_WAIT_TMRr_PD_TO_CL37_LINK_WAIT_TIMERf_SET
#define READ_AN_X1_PD_TO_CL37_LNK_WAIT_TMRr BCMI_TSCE16_XGXS_READ_AN_X1_PD_TO_CL37_LNK_WAIT_TMRr
#define WRITE_AN_X1_PD_TO_CL37_LNK_WAIT_TMRr BCMI_TSCE16_XGXS_WRITE_AN_X1_PD_TO_CL37_LNK_WAIT_TMRr
#define MODIFY_AN_X1_PD_TO_CL37_LNK_WAIT_TMRr BCMI_TSCE16_XGXS_MODIFY_AN_X1_PD_TO_CL37_LNK_WAIT_TMRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X1_PD_TO_CL37_LNK_WAIT_TMRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X1_IGNORE_LNK_TMR
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x925c
 * DESC:     PERIOD TO IGNORE THE LINK
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     IGNORE_LINK_TIMER_PERIOD Period is in tickssingle copyPeriod to ignore the link while CL73 and possibly CL72 are running
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X1_IGNORE_LNK_TMRr (0x0010925c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X1_IGNORE_LNK_TMRr_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_IGNORE_LNK_TMR.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X1_IGNORE_LNK_TMRr_s {
	uint32_t v[1];
	uint32_t an_x1_ignore_lnk_tmr[1];
	uint32_t _an_x1_ignore_lnk_tmr;
} BCMI_TSCE16_XGXS_AN_X1_IGNORE_LNK_TMRr_t;

#define BCMI_TSCE16_XGXS_AN_X1_IGNORE_LNK_TMRr_CLR(r) (r).an_x1_ignore_lnk_tmr[0] = 0
#define BCMI_TSCE16_XGXS_AN_X1_IGNORE_LNK_TMRr_SET(r,d) (r).an_x1_ignore_lnk_tmr[0] = d
#define BCMI_TSCE16_XGXS_AN_X1_IGNORE_LNK_TMRr_GET(r) (r).an_x1_ignore_lnk_tmr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X1_IGNORE_LNK_TMRr_IGNORE_LINK_TIMER_PERIODf_GET(r) (((r).an_x1_ignore_lnk_tmr[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_AN_X1_IGNORE_LNK_TMRr_IGNORE_LINK_TIMER_PERIODf_SET(r,f) (r).an_x1_ignore_lnk_tmr[0]=(((r).an_x1_ignore_lnk_tmr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X1_IGNORE_LNK_TMR.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X1_IGNORE_LNK_TMRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X1_IGNORE_LNK_TMRr,(_r._an_x1_ignore_lnk_tmr))
#define BCMI_TSCE16_XGXS_WRITE_AN_X1_IGNORE_LNK_TMRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_IGNORE_LNK_TMRr,(_r._an_x1_ignore_lnk_tmr)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X1_IGNORE_LNK_TMRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_IGNORE_LNK_TMRr,(_r._an_x1_ignore_lnk_tmr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_IGNORE_LNK_TMRr BCMI_TSCE16_XGXS_AN_X1_IGNORE_LNK_TMRr
#define AN_X1_IGNORE_LNK_TMRr_SIZE BCMI_TSCE16_XGXS_AN_X1_IGNORE_LNK_TMRr_SIZE
typedef BCMI_TSCE16_XGXS_AN_X1_IGNORE_LNK_TMRr_t AN_X1_IGNORE_LNK_TMRr_t;
#define AN_X1_IGNORE_LNK_TMRr_CLR BCMI_TSCE16_XGXS_AN_X1_IGNORE_LNK_TMRr_CLR
#define AN_X1_IGNORE_LNK_TMRr_SET BCMI_TSCE16_XGXS_AN_X1_IGNORE_LNK_TMRr_SET
#define AN_X1_IGNORE_LNK_TMRr_GET BCMI_TSCE16_XGXS_AN_X1_IGNORE_LNK_TMRr_GET
#define AN_X1_IGNORE_LNK_TMRr_IGNORE_LINK_TIMER_PERIODf_GET BCMI_TSCE16_XGXS_AN_X1_IGNORE_LNK_TMRr_IGNORE_LINK_TIMER_PERIODf_GET
#define AN_X1_IGNORE_LNK_TMRr_IGNORE_LINK_TIMER_PERIODf_SET BCMI_TSCE16_XGXS_AN_X1_IGNORE_LNK_TMRr_IGNORE_LINK_TIMER_PERIODf_SET
#define READ_AN_X1_IGNORE_LNK_TMRr BCMI_TSCE16_XGXS_READ_AN_X1_IGNORE_LNK_TMRr
#define WRITE_AN_X1_IGNORE_LNK_TMRr BCMI_TSCE16_XGXS_WRITE_AN_X1_IGNORE_LNK_TMRr
#define MODIFY_AN_X1_IGNORE_LNK_TMRr BCMI_TSCE16_XGXS_MODIFY_AN_X1_IGNORE_LNK_TMRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X1_IGNORE_LNK_TMRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X1_DME_PAGE_TMR
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x925d
 * DESC:     DME PAGE TIMERS
 * RESETVAL: 0x3b5f (15199)
 * ACCESS:   R/W
 * FIELDS:
 *     CL73_PAGE_TEST_MIN_TIMER Specifies the minimum length of a CL73 DME page.  Units are 8 samples.  Each sample represents 0.4 ns
 *     CL73_PAGE_TEST_MAX_TIMER Specifies the maximum length of a CL73 DME page.  Units are 8 samples.  Each sample represents 0.4 ns
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X1_DME_PAGE_TMRr (0x0010925d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X1_DME_PAGE_TMRr_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_DME_PAGE_TMR.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X1_DME_PAGE_TMRr_s {
	uint32_t v[1];
	uint32_t an_x1_dme_page_tmr[1];
	uint32_t _an_x1_dme_page_tmr;
} BCMI_TSCE16_XGXS_AN_X1_DME_PAGE_TMRr_t;

#define BCMI_TSCE16_XGXS_AN_X1_DME_PAGE_TMRr_CLR(r) (r).an_x1_dme_page_tmr[0] = 0
#define BCMI_TSCE16_XGXS_AN_X1_DME_PAGE_TMRr_SET(r,d) (r).an_x1_dme_page_tmr[0] = d
#define BCMI_TSCE16_XGXS_AN_X1_DME_PAGE_TMRr_GET(r) (r).an_x1_dme_page_tmr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X1_DME_PAGE_TMRr_CL73_PAGE_TEST_MAX_TIMERf_GET(r) ((((r).an_x1_dme_page_tmr[0]) >> 7) & 0x7f)
#define BCMI_TSCE16_XGXS_AN_X1_DME_PAGE_TMRr_CL73_PAGE_TEST_MAX_TIMERf_SET(r,f) (r).an_x1_dme_page_tmr[0]=(((r).an_x1_dme_page_tmr[0] & ~((uint32_t)0x7f << 7)) | ((((uint32_t)f) & 0x7f) << 7)) | (127 << (16 + 7))
#define BCMI_TSCE16_XGXS_AN_X1_DME_PAGE_TMRr_CL73_PAGE_TEST_MIN_TIMERf_GET(r) (((r).an_x1_dme_page_tmr[0]) & 0x7f)
#define BCMI_TSCE16_XGXS_AN_X1_DME_PAGE_TMRr_CL73_PAGE_TEST_MIN_TIMERf_SET(r,f) (r).an_x1_dme_page_tmr[0]=(((r).an_x1_dme_page_tmr[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access AN_X1_DME_PAGE_TMR.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X1_DME_PAGE_TMRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X1_DME_PAGE_TMRr,(_r._an_x1_dme_page_tmr))
#define BCMI_TSCE16_XGXS_WRITE_AN_X1_DME_PAGE_TMRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_DME_PAGE_TMRr,(_r._an_x1_dme_page_tmr)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X1_DME_PAGE_TMRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_DME_PAGE_TMRr,(_r._an_x1_dme_page_tmr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_DME_PAGE_TMRr BCMI_TSCE16_XGXS_AN_X1_DME_PAGE_TMRr
#define AN_X1_DME_PAGE_TMRr_SIZE BCMI_TSCE16_XGXS_AN_X1_DME_PAGE_TMRr_SIZE
typedef BCMI_TSCE16_XGXS_AN_X1_DME_PAGE_TMRr_t AN_X1_DME_PAGE_TMRr_t;
#define AN_X1_DME_PAGE_TMRr_CLR BCMI_TSCE16_XGXS_AN_X1_DME_PAGE_TMRr_CLR
#define AN_X1_DME_PAGE_TMRr_SET BCMI_TSCE16_XGXS_AN_X1_DME_PAGE_TMRr_SET
#define AN_X1_DME_PAGE_TMRr_GET BCMI_TSCE16_XGXS_AN_X1_DME_PAGE_TMRr_GET
#define AN_X1_DME_PAGE_TMRr_CL73_PAGE_TEST_MAX_TIMERf_GET BCMI_TSCE16_XGXS_AN_X1_DME_PAGE_TMRr_CL73_PAGE_TEST_MAX_TIMERf_GET
#define AN_X1_DME_PAGE_TMRr_CL73_PAGE_TEST_MAX_TIMERf_SET BCMI_TSCE16_XGXS_AN_X1_DME_PAGE_TMRr_CL73_PAGE_TEST_MAX_TIMERf_SET
#define AN_X1_DME_PAGE_TMRr_CL73_PAGE_TEST_MIN_TIMERf_GET BCMI_TSCE16_XGXS_AN_X1_DME_PAGE_TMRr_CL73_PAGE_TEST_MIN_TIMERf_GET
#define AN_X1_DME_PAGE_TMRr_CL73_PAGE_TEST_MIN_TIMERf_SET BCMI_TSCE16_XGXS_AN_X1_DME_PAGE_TMRr_CL73_PAGE_TEST_MIN_TIMERf_SET
#define READ_AN_X1_DME_PAGE_TMRr BCMI_TSCE16_XGXS_READ_AN_X1_DME_PAGE_TMRr
#define WRITE_AN_X1_DME_PAGE_TMRr BCMI_TSCE16_XGXS_WRITE_AN_X1_DME_PAGE_TMRr
#define MODIFY_AN_X1_DME_PAGE_TMRr BCMI_TSCE16_XGXS_MODIFY_AN_X1_DME_PAGE_TMRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X1_DME_PAGE_TMRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X1_SGMII_CL73_TMR_TYPE
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x925e
 * DESC:     CL73 SGMII TIMER
 * RESETVAL: 0x6b (107)
 * ACCESS:   R/W
 * FIELDS:
 *     SGMII_TIMER      This timer is used in CL73 for all SGMII time related functions such as link timer, send timer, ...
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X1_SGMII_CL73_TMR_TYPEr (0x0010925e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X1_SGMII_CL73_TMR_TYPEr_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_SGMII_CL73_TMR_TYPE.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X1_SGMII_CL73_TMR_TYPEr_s {
	uint32_t v[1];
	uint32_t an_x1_sgmii_cl73_tmr_type[1];
	uint32_t _an_x1_sgmii_cl73_tmr_type;
} BCMI_TSCE16_XGXS_AN_X1_SGMII_CL73_TMR_TYPEr_t;

#define BCMI_TSCE16_XGXS_AN_X1_SGMII_CL73_TMR_TYPEr_CLR(r) (r).an_x1_sgmii_cl73_tmr_type[0] = 0
#define BCMI_TSCE16_XGXS_AN_X1_SGMII_CL73_TMR_TYPEr_SET(r,d) (r).an_x1_sgmii_cl73_tmr_type[0] = d
#define BCMI_TSCE16_XGXS_AN_X1_SGMII_CL73_TMR_TYPEr_GET(r) (r).an_x1_sgmii_cl73_tmr_type[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X1_SGMII_CL73_TMR_TYPEr_SGMII_TIMERf_GET(r) (((r).an_x1_sgmii_cl73_tmr_type[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_AN_X1_SGMII_CL73_TMR_TYPEr_SGMII_TIMERf_SET(r,f) (r).an_x1_sgmii_cl73_tmr_type[0]=(((r).an_x1_sgmii_cl73_tmr_type[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X1_SGMII_CL73_TMR_TYPE.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X1_SGMII_CL73_TMR_TYPEr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X1_SGMII_CL73_TMR_TYPEr,(_r._an_x1_sgmii_cl73_tmr_type))
#define BCMI_TSCE16_XGXS_WRITE_AN_X1_SGMII_CL73_TMR_TYPEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_SGMII_CL73_TMR_TYPEr,(_r._an_x1_sgmii_cl73_tmr_type)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X1_SGMII_CL73_TMR_TYPEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X1_SGMII_CL73_TMR_TYPEr,(_r._an_x1_sgmii_cl73_tmr_type))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_SGMII_CL73_TMR_TYPEr BCMI_TSCE16_XGXS_AN_X1_SGMII_CL73_TMR_TYPEr
#define AN_X1_SGMII_CL73_TMR_TYPEr_SIZE BCMI_TSCE16_XGXS_AN_X1_SGMII_CL73_TMR_TYPEr_SIZE
typedef BCMI_TSCE16_XGXS_AN_X1_SGMII_CL73_TMR_TYPEr_t AN_X1_SGMII_CL73_TMR_TYPEr_t;
#define AN_X1_SGMII_CL73_TMR_TYPEr_CLR BCMI_TSCE16_XGXS_AN_X1_SGMII_CL73_TMR_TYPEr_CLR
#define AN_X1_SGMII_CL73_TMR_TYPEr_SET BCMI_TSCE16_XGXS_AN_X1_SGMII_CL73_TMR_TYPEr_SET
#define AN_X1_SGMII_CL73_TMR_TYPEr_GET BCMI_TSCE16_XGXS_AN_X1_SGMII_CL73_TMR_TYPEr_GET
#define AN_X1_SGMII_CL73_TMR_TYPEr_SGMII_TIMERf_GET BCMI_TSCE16_XGXS_AN_X1_SGMII_CL73_TMR_TYPEr_SGMII_TIMERf_GET
#define AN_X1_SGMII_CL73_TMR_TYPEr_SGMII_TIMERf_SET BCMI_TSCE16_XGXS_AN_X1_SGMII_CL73_TMR_TYPEr_SGMII_TIMERf_SET
#define READ_AN_X1_SGMII_CL73_TMR_TYPEr BCMI_TSCE16_XGXS_READ_AN_X1_SGMII_CL73_TMR_TYPEr
#define WRITE_AN_X1_SGMII_CL73_TMR_TYPEr BCMI_TSCE16_XGXS_WRITE_AN_X1_SGMII_CL73_TMR_TYPEr
#define MODIFY_AN_X1_SGMII_CL73_TMR_TYPEr BCMI_TSCE16_XGXS_MODIFY_AN_X1_SGMII_CL73_TMR_TYPEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X1_SGMII_CL73_TMR_TYPEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_PLL_LOCK_TMR
 * BLOCKS:   SC_X1_CONTROL
 * REGADDR:  0x9260
 * DESC:     PLL lock timeout period
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PLL_LOCK_TIMER_PERIOD Period/range is XXX msTimer for the maximin amount of time required for PLL to lockIf PLL is not locked during this period of time,the Speed Control logic will report an error and go to Initial state.The Speed Control logic can we restarted after that by SW or AN.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_PLL_LOCK_TMRr (0x00109260 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_PLL_LOCK_TMRr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_PLL_LOCK_TMR.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_PLL_LOCK_TMRr_s {
	uint32_t v[1];
	uint32_t sc_x1_pll_lock_tmr[1];
	uint32_t _sc_x1_pll_lock_tmr;
} BCMI_TSCE16_XGXS_SC_X1_PLL_LOCK_TMRr_t;

#define BCMI_TSCE16_XGXS_SC_X1_PLL_LOCK_TMRr_CLR(r) (r).sc_x1_pll_lock_tmr[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_PLL_LOCK_TMRr_SET(r,d) (r).sc_x1_pll_lock_tmr[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_PLL_LOCK_TMRr_GET(r) (r).sc_x1_pll_lock_tmr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_PLL_LOCK_TMRr_PLL_LOCK_TIMER_PERIODf_GET(r) (((r).sc_x1_pll_lock_tmr[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_SC_X1_PLL_LOCK_TMRr_PLL_LOCK_TIMER_PERIODf_SET(r,f) (r).sc_x1_pll_lock_tmr[0]=(((r).sc_x1_pll_lock_tmr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SC_X1_PLL_LOCK_TMR.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_PLL_LOCK_TMRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_PLL_LOCK_TMRr,(_r._sc_x1_pll_lock_tmr))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_PLL_LOCK_TMRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_PLL_LOCK_TMRr,(_r._sc_x1_pll_lock_tmr)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_PLL_LOCK_TMRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_PLL_LOCK_TMRr,(_r._sc_x1_pll_lock_tmr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_PLL_LOCK_TMRr BCMI_TSCE16_XGXS_SC_X1_PLL_LOCK_TMRr
#define SC_X1_PLL_LOCK_TMRr_SIZE BCMI_TSCE16_XGXS_SC_X1_PLL_LOCK_TMRr_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_PLL_LOCK_TMRr_t SC_X1_PLL_LOCK_TMRr_t;
#define SC_X1_PLL_LOCK_TMRr_CLR BCMI_TSCE16_XGXS_SC_X1_PLL_LOCK_TMRr_CLR
#define SC_X1_PLL_LOCK_TMRr_SET BCMI_TSCE16_XGXS_SC_X1_PLL_LOCK_TMRr_SET
#define SC_X1_PLL_LOCK_TMRr_GET BCMI_TSCE16_XGXS_SC_X1_PLL_LOCK_TMRr_GET
#define SC_X1_PLL_LOCK_TMRr_PLL_LOCK_TIMER_PERIODf_GET BCMI_TSCE16_XGXS_SC_X1_PLL_LOCK_TMRr_PLL_LOCK_TIMER_PERIODf_GET
#define SC_X1_PLL_LOCK_TMRr_PLL_LOCK_TIMER_PERIODf_SET BCMI_TSCE16_XGXS_SC_X1_PLL_LOCK_TMRr_PLL_LOCK_TIMER_PERIODf_SET
#define READ_SC_X1_PLL_LOCK_TMRr BCMI_TSCE16_XGXS_READ_SC_X1_PLL_LOCK_TMRr
#define WRITE_SC_X1_PLL_LOCK_TMRr BCMI_TSCE16_XGXS_WRITE_SC_X1_PLL_LOCK_TMRr
#define MODIFY_SC_X1_PLL_LOCK_TMRr BCMI_TSCE16_XGXS_MODIFY_SC_X1_PLL_LOCK_TMRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_PLL_LOCK_TMRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_PMD_LOCK_TMR
 * BLOCKS:   SC_X1_CONTROL
 * REGADDR:  0x9261
 * DESC:     PMD lock timeout period
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMD_LOCK_TIMER_PERIOD Period/range is XXX msTimer for the maximin amount of time required for PMD RX to lockIf PMD RX is not locked during this period of time,the Speed Control logic will report an error and go to Initial state.The Speed Control logic can we restarted after that by SW or AN.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_PMD_LOCK_TMRr (0x00109261 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_PMD_LOCK_TMRr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_PMD_LOCK_TMR.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_PMD_LOCK_TMRr_s {
	uint32_t v[1];
	uint32_t sc_x1_pmd_lock_tmr[1];
	uint32_t _sc_x1_pmd_lock_tmr;
} BCMI_TSCE16_XGXS_SC_X1_PMD_LOCK_TMRr_t;

#define BCMI_TSCE16_XGXS_SC_X1_PMD_LOCK_TMRr_CLR(r) (r).sc_x1_pmd_lock_tmr[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_PMD_LOCK_TMRr_SET(r,d) (r).sc_x1_pmd_lock_tmr[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_PMD_LOCK_TMRr_GET(r) (r).sc_x1_pmd_lock_tmr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_PMD_LOCK_TMRr_PMD_LOCK_TIMER_PERIODf_GET(r) (((r).sc_x1_pmd_lock_tmr[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_SC_X1_PMD_LOCK_TMRr_PMD_LOCK_TIMER_PERIODf_SET(r,f) (r).sc_x1_pmd_lock_tmr[0]=(((r).sc_x1_pmd_lock_tmr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SC_X1_PMD_LOCK_TMR.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_PMD_LOCK_TMRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_PMD_LOCK_TMRr,(_r._sc_x1_pmd_lock_tmr))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_PMD_LOCK_TMRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_PMD_LOCK_TMRr,(_r._sc_x1_pmd_lock_tmr)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_PMD_LOCK_TMRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_PMD_LOCK_TMRr,(_r._sc_x1_pmd_lock_tmr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_PMD_LOCK_TMRr BCMI_TSCE16_XGXS_SC_X1_PMD_LOCK_TMRr
#define SC_X1_PMD_LOCK_TMRr_SIZE BCMI_TSCE16_XGXS_SC_X1_PMD_LOCK_TMRr_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_PMD_LOCK_TMRr_t SC_X1_PMD_LOCK_TMRr_t;
#define SC_X1_PMD_LOCK_TMRr_CLR BCMI_TSCE16_XGXS_SC_X1_PMD_LOCK_TMRr_CLR
#define SC_X1_PMD_LOCK_TMRr_SET BCMI_TSCE16_XGXS_SC_X1_PMD_LOCK_TMRr_SET
#define SC_X1_PMD_LOCK_TMRr_GET BCMI_TSCE16_XGXS_SC_X1_PMD_LOCK_TMRr_GET
#define SC_X1_PMD_LOCK_TMRr_PMD_LOCK_TIMER_PERIODf_GET BCMI_TSCE16_XGXS_SC_X1_PMD_LOCK_TMRr_PMD_LOCK_TIMER_PERIODf_GET
#define SC_X1_PMD_LOCK_TMRr_PMD_LOCK_TIMER_PERIODf_SET BCMI_TSCE16_XGXS_SC_X1_PMD_LOCK_TMRr_PMD_LOCK_TIMER_PERIODf_SET
#define READ_SC_X1_PMD_LOCK_TMRr BCMI_TSCE16_XGXS_READ_SC_X1_PMD_LOCK_TMRr
#define WRITE_SC_X1_PMD_LOCK_TMRr BCMI_TSCE16_XGXS_WRITE_SC_X1_PMD_LOCK_TMRr
#define MODIFY_SC_X1_PMD_LOCK_TMRr BCMI_TSCE16_XGXS_MODIFY_SC_X1_PMD_LOCK_TMRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_PMD_LOCK_TMRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_PIPE_RST_CNT
 * BLOCKS:   SC_X1_CONTROL
 * REGADDR:  0x9262
 * DESC:     Pipeline reset count
 * RESETVAL: 0xff (255)
 * ACCESS:   R/W
 * FIELDS:
 *     PIPELINE_RESET_COUNT period in clock cyclesshould be set to 0xffCounter for amount of time to keep pipeline in resetduring speed change process
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_PIPE_RST_CNTr (0x00109262 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_PIPE_RST_CNTr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_PIPE_RST_CNT.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_PIPE_RST_CNTr_s {
	uint32_t v[1];
	uint32_t sc_x1_pipe_rst_cnt[1];
	uint32_t _sc_x1_pipe_rst_cnt;
} BCMI_TSCE16_XGXS_SC_X1_PIPE_RST_CNTr_t;

#define BCMI_TSCE16_XGXS_SC_X1_PIPE_RST_CNTr_CLR(r) (r).sc_x1_pipe_rst_cnt[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_PIPE_RST_CNTr_SET(r,d) (r).sc_x1_pipe_rst_cnt[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_PIPE_RST_CNTr_GET(r) (r).sc_x1_pipe_rst_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_PIPE_RST_CNTr_PIPELINE_RESET_COUNTf_GET(r) (((r).sc_x1_pipe_rst_cnt[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_SC_X1_PIPE_RST_CNTr_PIPELINE_RESET_COUNTf_SET(r,f) (r).sc_x1_pipe_rst_cnt[0]=(((r).sc_x1_pipe_rst_cnt[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SC_X1_PIPE_RST_CNT.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_PIPE_RST_CNTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_PIPE_RST_CNTr,(_r._sc_x1_pipe_rst_cnt))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_PIPE_RST_CNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_PIPE_RST_CNTr,(_r._sc_x1_pipe_rst_cnt)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_PIPE_RST_CNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_PIPE_RST_CNTr,(_r._sc_x1_pipe_rst_cnt))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_PIPE_RST_CNTr BCMI_TSCE16_XGXS_SC_X1_PIPE_RST_CNTr
#define SC_X1_PIPE_RST_CNTr_SIZE BCMI_TSCE16_XGXS_SC_X1_PIPE_RST_CNTr_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_PIPE_RST_CNTr_t SC_X1_PIPE_RST_CNTr_t;
#define SC_X1_PIPE_RST_CNTr_CLR BCMI_TSCE16_XGXS_SC_X1_PIPE_RST_CNTr_CLR
#define SC_X1_PIPE_RST_CNTr_SET BCMI_TSCE16_XGXS_SC_X1_PIPE_RST_CNTr_SET
#define SC_X1_PIPE_RST_CNTr_GET BCMI_TSCE16_XGXS_SC_X1_PIPE_RST_CNTr_GET
#define SC_X1_PIPE_RST_CNTr_PIPELINE_RESET_COUNTf_GET BCMI_TSCE16_XGXS_SC_X1_PIPE_RST_CNTr_PIPELINE_RESET_COUNTf_GET
#define SC_X1_PIPE_RST_CNTr_PIPELINE_RESET_COUNTf_SET BCMI_TSCE16_XGXS_SC_X1_PIPE_RST_CNTr_PIPELINE_RESET_COUNTf_SET
#define READ_SC_X1_PIPE_RST_CNTr BCMI_TSCE16_XGXS_READ_SC_X1_PIPE_RST_CNTr
#define WRITE_SC_X1_PIPE_RST_CNTr BCMI_TSCE16_XGXS_WRITE_SC_X1_PIPE_RST_CNTr
#define MODIFY_SC_X1_PIPE_RST_CNTr BCMI_TSCE16_XGXS_MODIFY_SC_X1_PIPE_RST_CNTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_PIPE_RST_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_TX_RST_CNT
 * BLOCKS:   SC_X1_CONTROL
 * REGADDR:  0x9263
 * DESC:     tx pipeline reset count
 * RESETVAL: 0x2 (2)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_RESET_COUNT   period in clock cyclesCounter for amount of time to keep after pll is lockedduring speed change process
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_TX_RST_CNTr (0x00109263 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_TX_RST_CNTr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_TX_RST_CNT.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_TX_RST_CNTr_s {
	uint32_t v[1];
	uint32_t sc_x1_tx_rst_cnt[1];
	uint32_t _sc_x1_tx_rst_cnt;
} BCMI_TSCE16_XGXS_SC_X1_TX_RST_CNTr_t;

#define BCMI_TSCE16_XGXS_SC_X1_TX_RST_CNTr_CLR(r) (r).sc_x1_tx_rst_cnt[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_TX_RST_CNTr_SET(r,d) (r).sc_x1_tx_rst_cnt[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_TX_RST_CNTr_GET(r) (r).sc_x1_tx_rst_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_TX_RST_CNTr_TX_RESET_COUNTf_GET(r) (((r).sc_x1_tx_rst_cnt[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_SC_X1_TX_RST_CNTr_TX_RESET_COUNTf_SET(r,f) (r).sc_x1_tx_rst_cnt[0]=(((r).sc_x1_tx_rst_cnt[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SC_X1_TX_RST_CNT.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_TX_RST_CNTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_TX_RST_CNTr,(_r._sc_x1_tx_rst_cnt))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_TX_RST_CNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_TX_RST_CNTr,(_r._sc_x1_tx_rst_cnt)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_TX_RST_CNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_TX_RST_CNTr,(_r._sc_x1_tx_rst_cnt))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_TX_RST_CNTr BCMI_TSCE16_XGXS_SC_X1_TX_RST_CNTr
#define SC_X1_TX_RST_CNTr_SIZE BCMI_TSCE16_XGXS_SC_X1_TX_RST_CNTr_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_TX_RST_CNTr_t SC_X1_TX_RST_CNTr_t;
#define SC_X1_TX_RST_CNTr_CLR BCMI_TSCE16_XGXS_SC_X1_TX_RST_CNTr_CLR
#define SC_X1_TX_RST_CNTr_SET BCMI_TSCE16_XGXS_SC_X1_TX_RST_CNTr_SET
#define SC_X1_TX_RST_CNTr_GET BCMI_TSCE16_XGXS_SC_X1_TX_RST_CNTr_GET
#define SC_X1_TX_RST_CNTr_TX_RESET_COUNTf_GET BCMI_TSCE16_XGXS_SC_X1_TX_RST_CNTr_TX_RESET_COUNTf_GET
#define SC_X1_TX_RST_CNTr_TX_RESET_COUNTf_SET BCMI_TSCE16_XGXS_SC_X1_TX_RST_CNTr_TX_RESET_COUNTf_SET
#define READ_SC_X1_TX_RST_CNTr BCMI_TSCE16_XGXS_READ_SC_X1_TX_RST_CNTr
#define WRITE_SC_X1_TX_RST_CNTr BCMI_TSCE16_XGXS_WRITE_SC_X1_TX_RST_CNTr
#define MODIFY_SC_X1_TX_RST_CNTr BCMI_TSCE16_XGXS_MODIFY_SC_X1_TX_RST_CNTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_TX_RST_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_STS
 * BLOCKS:   SC_X1_CONTROL
 * REGADDR:  0x9264
 * DESC:     Status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RESOLVED_PORT_MODE resolved port mode
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_STSr (0x00109264 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_STSr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_STSr_s {
	uint32_t v[1];
	uint32_t sc_x1_sts[1];
	uint32_t _sc_x1_sts;
} BCMI_TSCE16_XGXS_SC_X1_STSr_t;

#define BCMI_TSCE16_XGXS_SC_X1_STSr_CLR(r) (r).sc_x1_sts[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_STSr_SET(r,d) (r).sc_x1_sts[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_STSr_GET(r) (r).sc_x1_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_STSr_RESOLVED_PORT_MODEf_GET(r) (((r).sc_x1_sts[0]) & 0x7)
#define BCMI_TSCE16_XGXS_SC_X1_STSr_RESOLVED_PORT_MODEf_SET(r,f) (r).sc_x1_sts[0]=(((r).sc_x1_sts[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SC_X1_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_STSr,(_r._sc_x1_sts))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_STSr,(_r._sc_x1_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_STSr,(_r._sc_x1_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_STSr BCMI_TSCE16_XGXS_SC_X1_STSr
#define SC_X1_STSr_SIZE BCMI_TSCE16_XGXS_SC_X1_STSr_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_STSr_t SC_X1_STSr_t;
#define SC_X1_STSr_CLR BCMI_TSCE16_XGXS_SC_X1_STSr_CLR
#define SC_X1_STSr_SET BCMI_TSCE16_XGXS_SC_X1_STSr_SET
#define SC_X1_STSr_GET BCMI_TSCE16_XGXS_SC_X1_STSr_GET
#define SC_X1_STSr_RESOLVED_PORT_MODEf_GET BCMI_TSCE16_XGXS_SC_X1_STSr_RESOLVED_PORT_MODEf_GET
#define SC_X1_STSr_RESOLVED_PORT_MODEf_SET BCMI_TSCE16_XGXS_SC_X1_STSr_RESOLVED_PORT_MODEf_SET
#define READ_SC_X1_STSr BCMI_TSCE16_XGXS_READ_SC_X1_STSr
#define WRITE_SC_X1_STSr BCMI_TSCE16_XGXS_WRITE_SC_X1_STSr
#define MODIFY_SC_X1_STSr BCMI_TSCE16_XGXS_MODIFY_SC_X1_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR0_SPD
 * BLOCKS:   SC_X1_SPEED_OVERRIDE0
 * REGADDR:  0x9270
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     NUM_LANES        Number of lanes0   : NUM_LANES_01 - use 1 lane1   : NUM_LANES_02 - use 2 lanes2   : NUM_LANES_04 - use 4 lanes3   : NUM_LANES_10 - use 10 lanes4   : NUM_LANES_12 - use 12 lanes
 *     SPEED            Speed ID to use for this configuration
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_SPDr (0x00109270 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_SPDr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR0_SPD.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_SPDr_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr0_spd[1];
	uint32_t _sc_x1_spd_ovrr0_spd;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_SPDr_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_SPDr_CLR(r) (r).sc_x1_spd_ovrr0_spd[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_SPDr_SET(r,d) (r).sc_x1_spd_ovrr0_spd[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_SPDr_GET(r) (r).sc_x1_spd_ovrr0_spd[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_SPDr_SPEEDf_GET(r) ((((r).sc_x1_spd_ovrr0_spd[0]) >> 8) & 0xff)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_SPDr_SPEEDf_SET(r,f) (r).sc_x1_spd_ovrr0_spd[0]=(((r).sc_x1_spd_ovrr0_spd[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_SPDr_NUM_LANESf_GET(r) (((r).sc_x1_spd_ovrr0_spd[0]) & 0x7)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_SPDr_NUM_LANESf_SET(r,f) (r).sc_x1_spd_ovrr0_spd[0]=(((r).sc_x1_spd_ovrr0_spd[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR0_SPD.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR0_SPDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_SPDr,(_r._sc_x1_spd_ovrr0_spd))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR0_SPDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_SPDr,(_r._sc_x1_spd_ovrr0_spd)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR0_SPDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_SPDr,(_r._sc_x1_spd_ovrr0_spd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR0_SPDr BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_SPDr
#define SC_X1_SPD_OVRR0_SPDr_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_SPDr_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_SPDr_t SC_X1_SPD_OVRR0_SPDr_t;
#define SC_X1_SPD_OVRR0_SPDr_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_SPDr_CLR
#define SC_X1_SPD_OVRR0_SPDr_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_SPDr_SET
#define SC_X1_SPD_OVRR0_SPDr_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_SPDr_GET
#define SC_X1_SPD_OVRR0_SPDr_SPEEDf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_SPDr_SPEEDf_GET
#define SC_X1_SPD_OVRR0_SPDr_SPEEDf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_SPDr_SPEEDf_SET
#define SC_X1_SPD_OVRR0_SPDr_NUM_LANESf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_SPDr_NUM_LANESf_GET
#define SC_X1_SPD_OVRR0_SPDr_NUM_LANESf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_SPDr_NUM_LANESf_SET
#define READ_SC_X1_SPD_OVRR0_SPDr BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR0_SPDr
#define WRITE_SC_X1_SPD_OVRR0_SPDr BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR0_SPDr
#define MODIFY_SC_X1_SPD_OVRR0_SPDr BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR0_SPDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_SPDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR0_0
 * BLOCKS:   SC_X1_SPEED_OVERRIDE0
 * REGADDR:  0x9272
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ENCODEMODE       000 All functions disabled for lane001 cl48 8b10b010 cl48 8b10b rxaui011 cl36 8b10b100 cl82 64b66b101 cl49 64b66b110 brcm 64b66b
 *     FEC_ENABLE       
 *     CL72_ENABLE      
 *     SCR_MODE         00 bypass scrambler01 64b66b scrambler (all 66 bits)10 8b10b scrambler (all 80 bits)11 64b66b scrambler (sync bits not scrambled)
 *     OS_MODE          0: OS MODE 1 - divide by 11: OS MODE 2 - divide by 22: OS MODE 3 - divide by 33: OS MODE 3.3 - divide by 3.3.Bit repeating pattern is 3,3,3,4,3,3,4,3,3,44: OS MODE 4 - divide by 45: OS MODE 5 - divide by 56: OS MODE 7.5 - divide by 7.57: OS MODE 8 - divide by 88: OS MODE 8.25 - divide by 8.25.Bit repeating pattern is 8,8,8,99: OS MODE 10 - divide by 10
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r (0x00109272 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR0_0.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr0_0[1];
	uint32_t _sc_x1_spd_ovrr0_0;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r_CLR(r) (r).sc_x1_spd_ovrr0_0[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r_SET(r,d) (r).sc_x1_spd_ovrr0_0[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r_GET(r) (r).sc_x1_spd_ovrr0_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r_OS_MODEf_GET(r) ((((r).sc_x1_spd_ovrr0_0[0]) >> 12) & 0xf)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r_OS_MODEf_SET(r,f) (r).sc_x1_spd_ovrr0_0[0]=(((r).sc_x1_spd_ovrr0_0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r_SCR_MODEf_GET(r) ((((r).sc_x1_spd_ovrr0_0[0]) >> 10) & 0x3)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r_SCR_MODEf_SET(r,f) (r).sc_x1_spd_ovrr0_0[0]=(((r).sc_x1_spd_ovrr0_0[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r_CL72_ENABLEf_GET(r) ((((r).sc_x1_spd_ovrr0_0[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r_CL72_ENABLEf_SET(r,f) (r).sc_x1_spd_ovrr0_0[0]=(((r).sc_x1_spd_ovrr0_0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r_FEC_ENABLEf_GET(r) ((((r).sc_x1_spd_ovrr0_0[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r_FEC_ENABLEf_SET(r,f) (r).sc_x1_spd_ovrr0_0[0]=(((r).sc_x1_spd_ovrr0_0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r_ENCODEMODEf_GET(r) (((r).sc_x1_spd_ovrr0_0[0]) & 0x7)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r_ENCODEMODEf_SET(r,f) (r).sc_x1_spd_ovrr0_0[0]=(((r).sc_x1_spd_ovrr0_0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR0_0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR0_0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r,(_r._sc_x1_spd_ovrr0_0))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR0_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r,(_r._sc_x1_spd_ovrr0_0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR0_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r,(_r._sc_x1_spd_ovrr0_0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR0_0r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r
#define SC_X1_SPD_OVRR0_0r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r_t SC_X1_SPD_OVRR0_0r_t;
#define SC_X1_SPD_OVRR0_0r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r_CLR
#define SC_X1_SPD_OVRR0_0r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r_SET
#define SC_X1_SPD_OVRR0_0r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r_GET
#define SC_X1_SPD_OVRR0_0r_OS_MODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r_OS_MODEf_GET
#define SC_X1_SPD_OVRR0_0r_OS_MODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r_OS_MODEf_SET
#define SC_X1_SPD_OVRR0_0r_SCR_MODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r_SCR_MODEf_GET
#define SC_X1_SPD_OVRR0_0r_SCR_MODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r_SCR_MODEf_SET
#define SC_X1_SPD_OVRR0_0r_CL72_ENABLEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r_CL72_ENABLEf_GET
#define SC_X1_SPD_OVRR0_0r_CL72_ENABLEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r_CL72_ENABLEf_SET
#define SC_X1_SPD_OVRR0_0r_FEC_ENABLEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r_FEC_ENABLEf_GET
#define SC_X1_SPD_OVRR0_0r_FEC_ENABLEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r_FEC_ENABLEf_SET
#define SC_X1_SPD_OVRR0_0r_ENCODEMODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r_ENCODEMODEf_GET
#define SC_X1_SPD_OVRR0_0r_ENCODEMODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r_ENCODEMODEf_SET
#define READ_SC_X1_SPD_OVRR0_0r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR0_0r
#define WRITE_SC_X1_SPD_OVRR0_0r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR0_0r
#define MODIFY_SC_X1_SPD_OVRR0_0r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR0_0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR0_1
 * BLOCKS:   SC_X1_SPEED_OVERRIDE0
 * REGADDR:  0x9273
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BRCM64B66_DESCRAMBLER_ENABLE If set, the data sent to the the brcm64b66 decoder is scrambled.Sync headers are not scrambled
 *     CL36BYTEDELETEMODE 2'b00 - 100M mode (Delete 9 out of every 10 bytes)2'b01 - 10M mode (Delete 99 out of every 100 bytes)2'b10 - Passthrough (No deletion)
 *     DESC2_MODE       r_desc2 mode3'b000 - NONE3'b001 - CL493'b010 - BRCM3'b011 - 3'b100 - CL483'b101 - CL363'b110 - CL823'b111 - NONE
 *     DESKEWMODE       3'b000 - None3'b001 - byte based deskew for 8b10b mode3'b010 - block based deskew for BRCM 64b66b mode3'b011 - block based deskew for IEEE CL82 mode3'b100 - cl36 mode enable
 *     DECODERMODE      r_dec1 mode3'b000 - None3'b001 - cl49 64b66b mode3'b010 - BRCM 64b66b mode3'b011 -  - cl49/BRCM 64b66b mode3'b100 - 8b10b mode - cl48 mode3'b101 - 8b10b mode - cl36 mode
 *     DESCRAMBLERMODE  r_descr1 modeUsed only in CL48 based speeds, set to bypass for all other speeds2'b00 - bypass descrambler2'b01 - 64b66b descrambler2'b10 - 8b10b descrambler2'b11 - reserved
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r (0x00109273 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR0_1.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr0_1[1];
	uint32_t _sc_x1_spd_ovrr0_1;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r_CLR(r) (r).sc_x1_spd_ovrr0_1[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r_SET(r,d) (r).sc_x1_spd_ovrr0_1[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r_GET(r) (r).sc_x1_spd_ovrr0_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r_DESCRAMBLERMODEf_GET(r) ((((r).sc_x1_spd_ovrr0_1[0]) >> 14) & 0x3)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r_DESCRAMBLERMODEf_SET(r,f) (r).sc_x1_spd_ovrr0_1[0]=(((r).sc_x1_spd_ovrr0_1[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r_DECODERMODEf_GET(r) ((((r).sc_x1_spd_ovrr0_1[0]) >> 11) & 0x7)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r_DECODERMODEf_SET(r,f) (r).sc_x1_spd_ovrr0_1[0]=(((r).sc_x1_spd_ovrr0_1[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r_DESKEWMODEf_GET(r) ((((r).sc_x1_spd_ovrr0_1[0]) >> 8) & 0x7)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r_DESKEWMODEf_SET(r,f) (r).sc_x1_spd_ovrr0_1[0]=(((r).sc_x1_spd_ovrr0_1[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r_DESC2_MODEf_GET(r) ((((r).sc_x1_spd_ovrr0_1[0]) >> 5) & 0x7)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r_DESC2_MODEf_SET(r,f) (r).sc_x1_spd_ovrr0_1[0]=(((r).sc_x1_spd_ovrr0_1[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5)) | (7 << (16 + 5))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r_CL36BYTEDELETEMODEf_GET(r) ((((r).sc_x1_spd_ovrr0_1[0]) >> 3) & 0x3)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r_CL36BYTEDELETEMODEf_SET(r,f) (r).sc_x1_spd_ovrr0_1[0]=(((r).sc_x1_spd_ovrr0_1[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3)) | (3 << (16 + 3))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r_BRCM64B66_DESCRAMBLER_ENABLEf_GET(r) ((((r).sc_x1_spd_ovrr0_1[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r_BRCM64B66_DESCRAMBLER_ENABLEf_SET(r,f) (r).sc_x1_spd_ovrr0_1[0]=(((r).sc_x1_spd_ovrr0_1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access SC_X1_SPD_OVRR0_1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR0_1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r,(_r._sc_x1_spd_ovrr0_1))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR0_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r,(_r._sc_x1_spd_ovrr0_1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR0_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r,(_r._sc_x1_spd_ovrr0_1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR0_1r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r
#define SC_X1_SPD_OVRR0_1r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r_t SC_X1_SPD_OVRR0_1r_t;
#define SC_X1_SPD_OVRR0_1r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r_CLR
#define SC_X1_SPD_OVRR0_1r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r_SET
#define SC_X1_SPD_OVRR0_1r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r_GET
#define SC_X1_SPD_OVRR0_1r_DESCRAMBLERMODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r_DESCRAMBLERMODEf_GET
#define SC_X1_SPD_OVRR0_1r_DESCRAMBLERMODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r_DESCRAMBLERMODEf_SET
#define SC_X1_SPD_OVRR0_1r_DECODERMODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r_DECODERMODEf_GET
#define SC_X1_SPD_OVRR0_1r_DECODERMODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r_DECODERMODEf_SET
#define SC_X1_SPD_OVRR0_1r_DESKEWMODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r_DESKEWMODEf_GET
#define SC_X1_SPD_OVRR0_1r_DESKEWMODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r_DESKEWMODEf_SET
#define SC_X1_SPD_OVRR0_1r_DESC2_MODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r_DESC2_MODEf_GET
#define SC_X1_SPD_OVRR0_1r_DESC2_MODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r_DESC2_MODEf_SET
#define SC_X1_SPD_OVRR0_1r_CL36BYTEDELETEMODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r_CL36BYTEDELETEMODEf_GET
#define SC_X1_SPD_OVRR0_1r_CL36BYTEDELETEMODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r_CL36BYTEDELETEMODEf_SET
#define SC_X1_SPD_OVRR0_1r_BRCM64B66_DESCRAMBLER_ENABLEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r_BRCM64B66_DESCRAMBLER_ENABLEf_GET
#define SC_X1_SPD_OVRR0_1r_BRCM64B66_DESCRAMBLER_ENABLEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r_BRCM64B66_DESCRAMBLER_ENABLEf_SET
#define READ_SC_X1_SPD_OVRR0_1r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR0_1r
#define WRITE_SC_X1_SPD_OVRR0_1r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR0_1r
#define MODIFY_SC_X1_SPD_OVRR0_1r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR0_1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR0_2
 * BLOCKS:   SC_X1_SPEED_OVERRIDE0
 * REGADDR:  0x9274
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x400 (1024)
 * ACCESS:   R/W
 * FIELDS:
 *     CL36_EN          
 *     REORDER_EN       1'b0: cl48 reorder is disabled1'b1: cl48 reorder is enabled
 *     BLOCK_SYNC_MODE  000 none001 cl49 mode - enables func_cl49cl82_sync block010 cl82 mode - enables func_cl49cl82_sync block011 8b10b mode - enables the func_8b10b_sync block100 fec mode - enables the func_fec_sync block101 brcm 64b66b mode
 *     CHK_END_EN       this bit enables cl48 check_end function as defined in section 48.2.6.1.4
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_2r (0x00109274 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_2r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR0_2.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_2r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr0_2[1];
	uint32_t _sc_x1_spd_ovrr0_2;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_2r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_2r_CLR(r) (r).sc_x1_spd_ovrr0_2[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_2r_SET(r,d) (r).sc_x1_spd_ovrr0_2[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_2r_GET(r) (r).sc_x1_spd_ovrr0_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_2r_CHK_END_ENf_GET(r) ((((r).sc_x1_spd_ovrr0_2[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_2r_CHK_END_ENf_SET(r,f) (r).sc_x1_spd_ovrr0_2[0]=(((r).sc_x1_spd_ovrr0_2[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_2r_BLOCK_SYNC_MODEf_GET(r) ((((r).sc_x1_spd_ovrr0_2[0]) >> 4) & 0x7)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_2r_BLOCK_SYNC_MODEf_SET(r,f) (r).sc_x1_spd_ovrr0_2[0]=(((r).sc_x1_spd_ovrr0_2[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_2r_REORDER_ENf_GET(r) ((((r).sc_x1_spd_ovrr0_2[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_2r_REORDER_ENf_SET(r,f) (r).sc_x1_spd_ovrr0_2[0]=(((r).sc_x1_spd_ovrr0_2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_2r_CL36_ENf_GET(r) (((r).sc_x1_spd_ovrr0_2[0]) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_2r_CL36_ENf_SET(r,f) (r).sc_x1_spd_ovrr0_2[0]=(((r).sc_x1_spd_ovrr0_2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR0_2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR0_2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_2r,(_r._sc_x1_spd_ovrr0_2))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR0_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_2r,(_r._sc_x1_spd_ovrr0_2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR0_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_2r,(_r._sc_x1_spd_ovrr0_2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR0_2r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_2r
#define SC_X1_SPD_OVRR0_2r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_2r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_2r_t SC_X1_SPD_OVRR0_2r_t;
#define SC_X1_SPD_OVRR0_2r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_2r_CLR
#define SC_X1_SPD_OVRR0_2r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_2r_SET
#define SC_X1_SPD_OVRR0_2r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_2r_GET
#define SC_X1_SPD_OVRR0_2r_CHK_END_ENf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_2r_CHK_END_ENf_GET
#define SC_X1_SPD_OVRR0_2r_CHK_END_ENf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_2r_CHK_END_ENf_SET
#define SC_X1_SPD_OVRR0_2r_BLOCK_SYNC_MODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_2r_BLOCK_SYNC_MODEf_GET
#define SC_X1_SPD_OVRR0_2r_BLOCK_SYNC_MODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_2r_BLOCK_SYNC_MODEf_SET
#define SC_X1_SPD_OVRR0_2r_REORDER_ENf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_2r_REORDER_ENf_GET
#define SC_X1_SPD_OVRR0_2r_REORDER_ENf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_2r_REORDER_ENf_SET
#define SC_X1_SPD_OVRR0_2r_CL36_ENf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_2r_CL36_ENf_GET
#define SC_X1_SPD_OVRR0_2r_CL36_ENf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_2r_CL36_ENf_SET
#define READ_SC_X1_SPD_OVRR0_2r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR0_2r
#define WRITE_SC_X1_SPD_OVRR0_2r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR0_2r
#define MODIFY_SC_X1_SPD_OVRR0_2r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR0_2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR0_3
 * BLOCKS:   SC_X1_SPEED_OVERRIDE0
 * REGADDR:  0x9275
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CLOCKCNT0        clock count 0 for credit programming, range 5 to 4125
 *     SGMII_SPD_SWITCH Indicates to switch credits so that 10M/100M credits can go to the MAC and 1G credits can go to the PCS
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_3r (0x00109275 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_3r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR0_3.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_3r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr0_3[1];
	uint32_t _sc_x1_spd_ovrr0_3;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_3r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_3r_CLR(r) (r).sc_x1_spd_ovrr0_3[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_3r_SET(r,d) (r).sc_x1_spd_ovrr0_3[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_3r_GET(r) (r).sc_x1_spd_ovrr0_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_3r_SGMII_SPD_SWITCHf_GET(r) ((((r).sc_x1_spd_ovrr0_3[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_3r_SGMII_SPD_SWITCHf_SET(r,f) (r).sc_x1_spd_ovrr0_3[0]=(((r).sc_x1_spd_ovrr0_3[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_3r_CLOCKCNT0f_GET(r) (((r).sc_x1_spd_ovrr0_3[0]) & 0x3fff)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_3r_CLOCKCNT0f_SET(r,f) (r).sc_x1_spd_ovrr0_3[0]=(((r).sc_x1_spd_ovrr0_3[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR0_3.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR0_3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_3r,(_r._sc_x1_spd_ovrr0_3))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR0_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_3r,(_r._sc_x1_spd_ovrr0_3)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR0_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_3r,(_r._sc_x1_spd_ovrr0_3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR0_3r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_3r
#define SC_X1_SPD_OVRR0_3r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_3r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_3r_t SC_X1_SPD_OVRR0_3r_t;
#define SC_X1_SPD_OVRR0_3r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_3r_CLR
#define SC_X1_SPD_OVRR0_3r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_3r_SET
#define SC_X1_SPD_OVRR0_3r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_3r_GET
#define SC_X1_SPD_OVRR0_3r_SGMII_SPD_SWITCHf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_3r_SGMII_SPD_SWITCHf_GET
#define SC_X1_SPD_OVRR0_3r_SGMII_SPD_SWITCHf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_3r_SGMII_SPD_SWITCHf_SET
#define SC_X1_SPD_OVRR0_3r_CLOCKCNT0f_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_3r_CLOCKCNT0f_GET
#define SC_X1_SPD_OVRR0_3r_CLOCKCNT0f_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_3r_CLOCKCNT0f_SET
#define READ_SC_X1_SPD_OVRR0_3r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR0_3r
#define WRITE_SC_X1_SPD_OVRR0_3r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR0_3r
#define MODIFY_SC_X1_SPD_OVRR0_3r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR0_3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR0_4
 * BLOCKS:   SC_X1_SPEED_OVERRIDE0
 * REGADDR:  0x9276
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CLOCKCNT1        clock count 1 for credit programming, range 4 to 12
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_4r (0x00109276 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_4r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR0_4.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_4r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr0_4[1];
	uint32_t _sc_x1_spd_ovrr0_4;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_4r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_4r_CLR(r) (r).sc_x1_spd_ovrr0_4[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_4r_SET(r,d) (r).sc_x1_spd_ovrr0_4[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_4r_GET(r) (r).sc_x1_spd_ovrr0_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_4r_CLOCKCNT1f_GET(r) (((r).sc_x1_spd_ovrr0_4[0]) & 0xff)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_4r_CLOCKCNT1f_SET(r,f) (r).sc_x1_spd_ovrr0_4[0]=(((r).sc_x1_spd_ovrr0_4[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR0_4.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR0_4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_4r,(_r._sc_x1_spd_ovrr0_4))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR0_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_4r,(_r._sc_x1_spd_ovrr0_4)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR0_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_4r,(_r._sc_x1_spd_ovrr0_4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR0_4r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_4r
#define SC_X1_SPD_OVRR0_4r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_4r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_4r_t SC_X1_SPD_OVRR0_4r_t;
#define SC_X1_SPD_OVRR0_4r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_4r_CLR
#define SC_X1_SPD_OVRR0_4r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_4r_SET
#define SC_X1_SPD_OVRR0_4r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_4r_GET
#define SC_X1_SPD_OVRR0_4r_CLOCKCNT1f_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_4r_CLOCKCNT1f_GET
#define SC_X1_SPD_OVRR0_4r_CLOCKCNT1f_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_4r_CLOCKCNT1f_SET
#define READ_SC_X1_SPD_OVRR0_4r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR0_4r
#define WRITE_SC_X1_SPD_OVRR0_4r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR0_4r
#define MODIFY_SC_X1_SPD_OVRR0_4r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR0_4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR0_5
 * BLOCKS:   SC_X1_SPEED_OVERRIDE0
 * REGADDR:  0x9277
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LOOPCNT1         loop count 1 for credit programming, range 2 to 18
 *     LOOPCNT0         loop count 0 for credit programming, range 1 to 1
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_5r (0x00109277 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_5r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR0_5.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_5r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr0_5[1];
	uint32_t _sc_x1_spd_ovrr0_5;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_5r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_5r_CLR(r) (r).sc_x1_spd_ovrr0_5[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_5r_SET(r,d) (r).sc_x1_spd_ovrr0_5[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_5r_GET(r) (r).sc_x1_spd_ovrr0_5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_5r_LOOPCNT0f_GET(r) ((((r).sc_x1_spd_ovrr0_5[0]) >> 6) & 0xff)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_5r_LOOPCNT0f_SET(r,f) (r).sc_x1_spd_ovrr0_5[0]=(((r).sc_x1_spd_ovrr0_5[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6)) | (255 << (16 + 6))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_5r_LOOPCNT1f_GET(r) (((r).sc_x1_spd_ovrr0_5[0]) & 0x3f)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_5r_LOOPCNT1f_SET(r,f) (r).sc_x1_spd_ovrr0_5[0]=(((r).sc_x1_spd_ovrr0_5[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR0_5.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR0_5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_5r,(_r._sc_x1_spd_ovrr0_5))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR0_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_5r,(_r._sc_x1_spd_ovrr0_5)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR0_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_5r,(_r._sc_x1_spd_ovrr0_5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR0_5r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_5r
#define SC_X1_SPD_OVRR0_5r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_5r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_5r_t SC_X1_SPD_OVRR0_5r_t;
#define SC_X1_SPD_OVRR0_5r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_5r_CLR
#define SC_X1_SPD_OVRR0_5r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_5r_SET
#define SC_X1_SPD_OVRR0_5r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_5r_GET
#define SC_X1_SPD_OVRR0_5r_LOOPCNT0f_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_5r_LOOPCNT0f_GET
#define SC_X1_SPD_OVRR0_5r_LOOPCNT0f_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_5r_LOOPCNT0f_SET
#define SC_X1_SPD_OVRR0_5r_LOOPCNT1f_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_5r_LOOPCNT1f_GET
#define SC_X1_SPD_OVRR0_5r_LOOPCNT1f_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_5r_LOOPCNT1f_SET
#define READ_SC_X1_SPD_OVRR0_5r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR0_5r
#define WRITE_SC_X1_SPD_OVRR0_5r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR0_5r
#define MODIFY_SC_X1_SPD_OVRR0_5r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR0_5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR0_6
 * BLOCKS:   SC_X1_SPEED_OVERRIDE0
 * REGADDR:  0x9278
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MAC_CREDITGENCNT CGC for mac credit generation, range 1 to 2063
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_6r (0x00109278 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_6r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR0_6.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_6r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr0_6[1];
	uint32_t _sc_x1_spd_ovrr0_6;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_6r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_6r_CLR(r) (r).sc_x1_spd_ovrr0_6[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_6r_SET(r,d) (r).sc_x1_spd_ovrr0_6[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_6r_GET(r) (r).sc_x1_spd_ovrr0_6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_6r_MAC_CREDITGENCNTf_GET(r) (((r).sc_x1_spd_ovrr0_6[0]) & 0x1fff)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_6r_MAC_CREDITGENCNTf_SET(r,f) (r).sc_x1_spd_ovrr0_6[0]=(((r).sc_x1_spd_ovrr0_6[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR0_6.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR0_6r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_6r,(_r._sc_x1_spd_ovrr0_6))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR0_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_6r,(_r._sc_x1_spd_ovrr0_6)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR0_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_6r,(_r._sc_x1_spd_ovrr0_6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR0_6r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_6r
#define SC_X1_SPD_OVRR0_6r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_6r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_6r_t SC_X1_SPD_OVRR0_6r_t;
#define SC_X1_SPD_OVRR0_6r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_6r_CLR
#define SC_X1_SPD_OVRR0_6r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_6r_SET
#define SC_X1_SPD_OVRR0_6r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_6r_GET
#define SC_X1_SPD_OVRR0_6r_MAC_CREDITGENCNTf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_6r_MAC_CREDITGENCNTf_GET
#define SC_X1_SPD_OVRR0_6r_MAC_CREDITGENCNTf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_6r_MAC_CREDITGENCNTf_SET
#define READ_SC_X1_SPD_OVRR0_6r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR0_6r
#define WRITE_SC_X1_SPD_OVRR0_6r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR0_6r
#define MODIFY_SC_X1_SPD_OVRR0_6r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR0_6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR0_7
 * BLOCKS:   SC_X1_SPEED_OVERRIDE0
 * REGADDR:  0x9279
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_CLOCKCNT0    pcs clock count 0 for credit programming, range 5 to 4125
 *     PCS_CREDITENABLE Enables credits to be generated for the PCS.  Only used in 10M or 100M modes.
 *     REPLICATION_CNT  Set to one (1) for 10M and zero (0) for 100M
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_7r (0x00109279 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_7r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR0_7.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_7r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr0_7[1];
	uint32_t _sc_x1_spd_ovrr0_7;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_7r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_7r_CLR(r) (r).sc_x1_spd_ovrr0_7[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_7r_SET(r,d) (r).sc_x1_spd_ovrr0_7[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_7r_GET(r) (r).sc_x1_spd_ovrr0_7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_7r_REPLICATION_CNTf_GET(r) ((((r).sc_x1_spd_ovrr0_7[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_7r_REPLICATION_CNTf_SET(r,f) (r).sc_x1_spd_ovrr0_7[0]=(((r).sc_x1_spd_ovrr0_7[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_7r_PCS_CREDITENABLEf_GET(r) ((((r).sc_x1_spd_ovrr0_7[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_7r_PCS_CREDITENABLEf_SET(r,f) (r).sc_x1_spd_ovrr0_7[0]=(((r).sc_x1_spd_ovrr0_7[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_7r_PCS_CLOCKCNT0f_GET(r) (((r).sc_x1_spd_ovrr0_7[0]) & 0x3fff)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_7r_PCS_CLOCKCNT0f_SET(r,f) (r).sc_x1_spd_ovrr0_7[0]=(((r).sc_x1_spd_ovrr0_7[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR0_7.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR0_7r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_7r,(_r._sc_x1_spd_ovrr0_7))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR0_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_7r,(_r._sc_x1_spd_ovrr0_7)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR0_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_7r,(_r._sc_x1_spd_ovrr0_7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR0_7r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_7r
#define SC_X1_SPD_OVRR0_7r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_7r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_7r_t SC_X1_SPD_OVRR0_7r_t;
#define SC_X1_SPD_OVRR0_7r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_7r_CLR
#define SC_X1_SPD_OVRR0_7r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_7r_SET
#define SC_X1_SPD_OVRR0_7r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_7r_GET
#define SC_X1_SPD_OVRR0_7r_REPLICATION_CNTf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_7r_REPLICATION_CNTf_GET
#define SC_X1_SPD_OVRR0_7r_REPLICATION_CNTf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_7r_REPLICATION_CNTf_SET
#define SC_X1_SPD_OVRR0_7r_PCS_CREDITENABLEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_7r_PCS_CREDITENABLEf_GET
#define SC_X1_SPD_OVRR0_7r_PCS_CREDITENABLEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_7r_PCS_CREDITENABLEf_SET
#define SC_X1_SPD_OVRR0_7r_PCS_CLOCKCNT0f_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_7r_PCS_CLOCKCNT0f_GET
#define SC_X1_SPD_OVRR0_7r_PCS_CLOCKCNT0f_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_7r_PCS_CLOCKCNT0f_SET
#define READ_SC_X1_SPD_OVRR0_7r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR0_7r
#define WRITE_SC_X1_SPD_OVRR0_7r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR0_7r
#define MODIFY_SC_X1_SPD_OVRR0_7r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR0_7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR0_8
 * BLOCKS:   SC_X1_SPEED_OVERRIDE0
 * REGADDR:  0x927a
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_CREDITGENCNT CGC for pcs credit generation, range 1 to 2063
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_8r (0x0010927a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_8r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR0_8.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_8r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr0_8[1];
	uint32_t _sc_x1_spd_ovrr0_8;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_8r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_8r_CLR(r) (r).sc_x1_spd_ovrr0_8[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_8r_SET(r,d) (r).sc_x1_spd_ovrr0_8[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_8r_GET(r) (r).sc_x1_spd_ovrr0_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_8r_PCS_CREDITGENCNTf_GET(r) (((r).sc_x1_spd_ovrr0_8[0]) & 0x1fff)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_8r_PCS_CREDITGENCNTf_SET(r,f) (r).sc_x1_spd_ovrr0_8[0]=(((r).sc_x1_spd_ovrr0_8[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR0_8.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR0_8r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_8r,(_r._sc_x1_spd_ovrr0_8))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR0_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_8r,(_r._sc_x1_spd_ovrr0_8)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR0_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_8r,(_r._sc_x1_spd_ovrr0_8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR0_8r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_8r
#define SC_X1_SPD_OVRR0_8r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_8r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_8r_t SC_X1_SPD_OVRR0_8r_t;
#define SC_X1_SPD_OVRR0_8r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_8r_CLR
#define SC_X1_SPD_OVRR0_8r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_8r_SET
#define SC_X1_SPD_OVRR0_8r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_8r_GET
#define SC_X1_SPD_OVRR0_8r_PCS_CREDITGENCNTf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_8r_PCS_CREDITGENCNTf_GET
#define SC_X1_SPD_OVRR0_8r_PCS_CREDITGENCNTf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_8r_PCS_CREDITGENCNTf_SET
#define READ_SC_X1_SPD_OVRR0_8r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR0_8r
#define WRITE_SC_X1_SPD_OVRR0_8r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR0_8r
#define MODIFY_SC_X1_SPD_OVRR0_8r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR0_8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR0_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR1_SPD
 * BLOCKS:   SC_X1_SPEED_OVERRIDE1
 * REGADDR:  0x9280
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     NUM_LANES        Number of lanes0   : NUM_LANES_01 - use 1 lane1   : NUM_LANES_02 - use 2 lanes2   : NUM_LANES_04 - use 4 lanes3   : NUM_LANES_10 - use 10 lanes4   : NUM_LANES_12 - use 12 lanes
 *     SPEED            Speed ID to use for this configuration
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_SPDr (0x00109280 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_SPDr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR1_SPD.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_SPDr_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr1_spd[1];
	uint32_t _sc_x1_spd_ovrr1_spd;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_SPDr_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_SPDr_CLR(r) (r).sc_x1_spd_ovrr1_spd[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_SPDr_SET(r,d) (r).sc_x1_spd_ovrr1_spd[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_SPDr_GET(r) (r).sc_x1_spd_ovrr1_spd[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_SPDr_SPEEDf_GET(r) ((((r).sc_x1_spd_ovrr1_spd[0]) >> 8) & 0xff)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_SPDr_SPEEDf_SET(r,f) (r).sc_x1_spd_ovrr1_spd[0]=(((r).sc_x1_spd_ovrr1_spd[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_SPDr_NUM_LANESf_GET(r) (((r).sc_x1_spd_ovrr1_spd[0]) & 0x7)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_SPDr_NUM_LANESf_SET(r,f) (r).sc_x1_spd_ovrr1_spd[0]=(((r).sc_x1_spd_ovrr1_spd[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR1_SPD.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR1_SPDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_SPDr,(_r._sc_x1_spd_ovrr1_spd))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR1_SPDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_SPDr,(_r._sc_x1_spd_ovrr1_spd)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR1_SPDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_SPDr,(_r._sc_x1_spd_ovrr1_spd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR1_SPDr BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_SPDr
#define SC_X1_SPD_OVRR1_SPDr_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_SPDr_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_SPDr_t SC_X1_SPD_OVRR1_SPDr_t;
#define SC_X1_SPD_OVRR1_SPDr_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_SPDr_CLR
#define SC_X1_SPD_OVRR1_SPDr_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_SPDr_SET
#define SC_X1_SPD_OVRR1_SPDr_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_SPDr_GET
#define SC_X1_SPD_OVRR1_SPDr_SPEEDf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_SPDr_SPEEDf_GET
#define SC_X1_SPD_OVRR1_SPDr_SPEEDf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_SPDr_SPEEDf_SET
#define SC_X1_SPD_OVRR1_SPDr_NUM_LANESf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_SPDr_NUM_LANESf_GET
#define SC_X1_SPD_OVRR1_SPDr_NUM_LANESf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_SPDr_NUM_LANESf_SET
#define READ_SC_X1_SPD_OVRR1_SPDr BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR1_SPDr
#define WRITE_SC_X1_SPD_OVRR1_SPDr BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR1_SPDr
#define MODIFY_SC_X1_SPD_OVRR1_SPDr BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR1_SPDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_SPDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR1_0
 * BLOCKS:   SC_X1_SPEED_OVERRIDE1
 * REGADDR:  0x9282
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ENCODEMODE       000 All functions disabled for lane001 cl48 8b10b010 cl48 8b10b rxaui011 cl36 8b10b100 cl82 64b66b101 cl49 64b66b110 brcm 64b66b
 *     FEC_ENABLE       
 *     CL72_ENABLE      
 *     SCR_MODE         00 bypass scrambler01 64b66b scrambler (all 66 bits)10 8b10b scrambler (all 80 bits)11 64b66b scrambler (sync bits not scrambled)
 *     OS_MODE          0: OS MODE 1 - divide by 11: OS MODE 2 - divide by 22: OS MODE 3 - divide by 33: OS MODE 3.3 - divide by 3.3.Bit repeating pattern is 3,3,3,4,3,3,4,3,3,44: OS MODE 4 - divide by 45: OS MODE 5 - divide by 56: OS MODE 7.5 - divide by 7.57: OS MODE 8 - divide by 88: OS MODE 8.25 - divide by 8.25.Bit repeating pattern is 8,8,8,99: OS MODE 10 - divide by 10
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r (0x00109282 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR1_0.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr1_0[1];
	uint32_t _sc_x1_spd_ovrr1_0;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r_CLR(r) (r).sc_x1_spd_ovrr1_0[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r_SET(r,d) (r).sc_x1_spd_ovrr1_0[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r_GET(r) (r).sc_x1_spd_ovrr1_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r_OS_MODEf_GET(r) ((((r).sc_x1_spd_ovrr1_0[0]) >> 12) & 0xf)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r_OS_MODEf_SET(r,f) (r).sc_x1_spd_ovrr1_0[0]=(((r).sc_x1_spd_ovrr1_0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r_SCR_MODEf_GET(r) ((((r).sc_x1_spd_ovrr1_0[0]) >> 10) & 0x3)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r_SCR_MODEf_SET(r,f) (r).sc_x1_spd_ovrr1_0[0]=(((r).sc_x1_spd_ovrr1_0[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r_CL72_ENABLEf_GET(r) ((((r).sc_x1_spd_ovrr1_0[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r_CL72_ENABLEf_SET(r,f) (r).sc_x1_spd_ovrr1_0[0]=(((r).sc_x1_spd_ovrr1_0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r_FEC_ENABLEf_GET(r) ((((r).sc_x1_spd_ovrr1_0[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r_FEC_ENABLEf_SET(r,f) (r).sc_x1_spd_ovrr1_0[0]=(((r).sc_x1_spd_ovrr1_0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r_ENCODEMODEf_GET(r) (((r).sc_x1_spd_ovrr1_0[0]) & 0x7)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r_ENCODEMODEf_SET(r,f) (r).sc_x1_spd_ovrr1_0[0]=(((r).sc_x1_spd_ovrr1_0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR1_0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR1_0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r,(_r._sc_x1_spd_ovrr1_0))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR1_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r,(_r._sc_x1_spd_ovrr1_0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR1_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r,(_r._sc_x1_spd_ovrr1_0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR1_0r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r
#define SC_X1_SPD_OVRR1_0r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r_t SC_X1_SPD_OVRR1_0r_t;
#define SC_X1_SPD_OVRR1_0r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r_CLR
#define SC_X1_SPD_OVRR1_0r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r_SET
#define SC_X1_SPD_OVRR1_0r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r_GET
#define SC_X1_SPD_OVRR1_0r_OS_MODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r_OS_MODEf_GET
#define SC_X1_SPD_OVRR1_0r_OS_MODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r_OS_MODEf_SET
#define SC_X1_SPD_OVRR1_0r_SCR_MODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r_SCR_MODEf_GET
#define SC_X1_SPD_OVRR1_0r_SCR_MODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r_SCR_MODEf_SET
#define SC_X1_SPD_OVRR1_0r_CL72_ENABLEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r_CL72_ENABLEf_GET
#define SC_X1_SPD_OVRR1_0r_CL72_ENABLEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r_CL72_ENABLEf_SET
#define SC_X1_SPD_OVRR1_0r_FEC_ENABLEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r_FEC_ENABLEf_GET
#define SC_X1_SPD_OVRR1_0r_FEC_ENABLEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r_FEC_ENABLEf_SET
#define SC_X1_SPD_OVRR1_0r_ENCODEMODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r_ENCODEMODEf_GET
#define SC_X1_SPD_OVRR1_0r_ENCODEMODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r_ENCODEMODEf_SET
#define READ_SC_X1_SPD_OVRR1_0r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR1_0r
#define WRITE_SC_X1_SPD_OVRR1_0r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR1_0r
#define MODIFY_SC_X1_SPD_OVRR1_0r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR1_0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR1_1
 * BLOCKS:   SC_X1_SPEED_OVERRIDE1
 * REGADDR:  0x9283
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BRCM64B66_DESCRAMBLER_ENABLE If set, the data sent to the the brcm64b66 decoder is scrambled.Sync headers are not scrambled
 *     CL36BYTEDELETEMODE 2'b00 - 100M mode (Delete 9 out of every 10 bytes)2'b01 - 10M mode (Delete 99 out of every 100 bytes)2'b10 - Passthrough (No deletion)
 *     DESC2_MODE       r_desc2 mode3'b000 - NONE3'b001 - CL493'b010 - BRCM3'b011 - 3'b100 - CL483'b101 - CL363'b110 - CL823'b111 - NONE
 *     DESKEWMODE       3'b000 - None3'b001 - byte based deskew for 8b10b mode3'b010 - block based deskew for BRCM 64b66b mode3'b011 - block based deskew for IEEE CL82 mode3'b100 - cl36 mode enable
 *     DECODERMODE      r_dec1 mode3'b000 - None3'b001 - cl49 64b66b mode3'b010 - BRCM 64b66b mode3'b011 -  - cl49/BRCM 64b66b mode3'b100 - 8b10b mode - cl48 mode3'b101 - 8b10b mode - cl36 mode
 *     DESCRAMBLERMODE  r_descr1 modeUsed only in CL48 based speeds, set to bypass for all other speeds2'b00 - bypass descrambler2'b01 - 64b66b descrambler2'b10 - 8b10b descrambler2'b11 - reserved
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r (0x00109283 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR1_1.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr1_1[1];
	uint32_t _sc_x1_spd_ovrr1_1;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r_CLR(r) (r).sc_x1_spd_ovrr1_1[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r_SET(r,d) (r).sc_x1_spd_ovrr1_1[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r_GET(r) (r).sc_x1_spd_ovrr1_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r_DESCRAMBLERMODEf_GET(r) ((((r).sc_x1_spd_ovrr1_1[0]) >> 14) & 0x3)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r_DESCRAMBLERMODEf_SET(r,f) (r).sc_x1_spd_ovrr1_1[0]=(((r).sc_x1_spd_ovrr1_1[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r_DECODERMODEf_GET(r) ((((r).sc_x1_spd_ovrr1_1[0]) >> 11) & 0x7)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r_DECODERMODEf_SET(r,f) (r).sc_x1_spd_ovrr1_1[0]=(((r).sc_x1_spd_ovrr1_1[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r_DESKEWMODEf_GET(r) ((((r).sc_x1_spd_ovrr1_1[0]) >> 8) & 0x7)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r_DESKEWMODEf_SET(r,f) (r).sc_x1_spd_ovrr1_1[0]=(((r).sc_x1_spd_ovrr1_1[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r_DESC2_MODEf_GET(r) ((((r).sc_x1_spd_ovrr1_1[0]) >> 5) & 0x7)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r_DESC2_MODEf_SET(r,f) (r).sc_x1_spd_ovrr1_1[0]=(((r).sc_x1_spd_ovrr1_1[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5)) | (7 << (16 + 5))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r_CL36BYTEDELETEMODEf_GET(r) ((((r).sc_x1_spd_ovrr1_1[0]) >> 3) & 0x3)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r_CL36BYTEDELETEMODEf_SET(r,f) (r).sc_x1_spd_ovrr1_1[0]=(((r).sc_x1_spd_ovrr1_1[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3)) | (3 << (16 + 3))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r_BRCM64B66_DESCRAMBLER_ENABLEf_GET(r) ((((r).sc_x1_spd_ovrr1_1[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r_BRCM64B66_DESCRAMBLER_ENABLEf_SET(r,f) (r).sc_x1_spd_ovrr1_1[0]=(((r).sc_x1_spd_ovrr1_1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access SC_X1_SPD_OVRR1_1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR1_1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r,(_r._sc_x1_spd_ovrr1_1))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR1_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r,(_r._sc_x1_spd_ovrr1_1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR1_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r,(_r._sc_x1_spd_ovrr1_1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR1_1r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r
#define SC_X1_SPD_OVRR1_1r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r_t SC_X1_SPD_OVRR1_1r_t;
#define SC_X1_SPD_OVRR1_1r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r_CLR
#define SC_X1_SPD_OVRR1_1r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r_SET
#define SC_X1_SPD_OVRR1_1r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r_GET
#define SC_X1_SPD_OVRR1_1r_DESCRAMBLERMODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r_DESCRAMBLERMODEf_GET
#define SC_X1_SPD_OVRR1_1r_DESCRAMBLERMODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r_DESCRAMBLERMODEf_SET
#define SC_X1_SPD_OVRR1_1r_DECODERMODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r_DECODERMODEf_GET
#define SC_X1_SPD_OVRR1_1r_DECODERMODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r_DECODERMODEf_SET
#define SC_X1_SPD_OVRR1_1r_DESKEWMODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r_DESKEWMODEf_GET
#define SC_X1_SPD_OVRR1_1r_DESKEWMODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r_DESKEWMODEf_SET
#define SC_X1_SPD_OVRR1_1r_DESC2_MODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r_DESC2_MODEf_GET
#define SC_X1_SPD_OVRR1_1r_DESC2_MODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r_DESC2_MODEf_SET
#define SC_X1_SPD_OVRR1_1r_CL36BYTEDELETEMODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r_CL36BYTEDELETEMODEf_GET
#define SC_X1_SPD_OVRR1_1r_CL36BYTEDELETEMODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r_CL36BYTEDELETEMODEf_SET
#define SC_X1_SPD_OVRR1_1r_BRCM64B66_DESCRAMBLER_ENABLEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r_BRCM64B66_DESCRAMBLER_ENABLEf_GET
#define SC_X1_SPD_OVRR1_1r_BRCM64B66_DESCRAMBLER_ENABLEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r_BRCM64B66_DESCRAMBLER_ENABLEf_SET
#define READ_SC_X1_SPD_OVRR1_1r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR1_1r
#define WRITE_SC_X1_SPD_OVRR1_1r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR1_1r
#define MODIFY_SC_X1_SPD_OVRR1_1r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR1_1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR1_2
 * BLOCKS:   SC_X1_SPEED_OVERRIDE1
 * REGADDR:  0x9284
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x400 (1024)
 * ACCESS:   R/W
 * FIELDS:
 *     CL36_EN          
 *     REORDER_EN       1'b0: cl48 reorder is disabled1'b1: cl48 reorder is enabled
 *     BLOCK_SYNC_MODE  000 none001 cl49 mode - enables func_cl49cl82_sync block010 cl82 mode - enables func_cl49cl82_sync block011 8b10b mode - enables the func_8b10b_sync block100 fec mode - enables the func_fec_sync block101 brcm 64b66b mode
 *     CHK_END_EN       this bit enables cl48 check_end function as defined in section 48.2.6.1.4
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_2r (0x00109284 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_2r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR1_2.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_2r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr1_2[1];
	uint32_t _sc_x1_spd_ovrr1_2;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_2r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_2r_CLR(r) (r).sc_x1_spd_ovrr1_2[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_2r_SET(r,d) (r).sc_x1_spd_ovrr1_2[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_2r_GET(r) (r).sc_x1_spd_ovrr1_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_2r_CHK_END_ENf_GET(r) ((((r).sc_x1_spd_ovrr1_2[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_2r_CHK_END_ENf_SET(r,f) (r).sc_x1_spd_ovrr1_2[0]=(((r).sc_x1_spd_ovrr1_2[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_2r_BLOCK_SYNC_MODEf_GET(r) ((((r).sc_x1_spd_ovrr1_2[0]) >> 4) & 0x7)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_2r_BLOCK_SYNC_MODEf_SET(r,f) (r).sc_x1_spd_ovrr1_2[0]=(((r).sc_x1_spd_ovrr1_2[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_2r_REORDER_ENf_GET(r) ((((r).sc_x1_spd_ovrr1_2[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_2r_REORDER_ENf_SET(r,f) (r).sc_x1_spd_ovrr1_2[0]=(((r).sc_x1_spd_ovrr1_2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_2r_CL36_ENf_GET(r) (((r).sc_x1_spd_ovrr1_2[0]) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_2r_CL36_ENf_SET(r,f) (r).sc_x1_spd_ovrr1_2[0]=(((r).sc_x1_spd_ovrr1_2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR1_2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR1_2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_2r,(_r._sc_x1_spd_ovrr1_2))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR1_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_2r,(_r._sc_x1_spd_ovrr1_2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR1_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_2r,(_r._sc_x1_spd_ovrr1_2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR1_2r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_2r
#define SC_X1_SPD_OVRR1_2r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_2r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_2r_t SC_X1_SPD_OVRR1_2r_t;
#define SC_X1_SPD_OVRR1_2r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_2r_CLR
#define SC_X1_SPD_OVRR1_2r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_2r_SET
#define SC_X1_SPD_OVRR1_2r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_2r_GET
#define SC_X1_SPD_OVRR1_2r_CHK_END_ENf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_2r_CHK_END_ENf_GET
#define SC_X1_SPD_OVRR1_2r_CHK_END_ENf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_2r_CHK_END_ENf_SET
#define SC_X1_SPD_OVRR1_2r_BLOCK_SYNC_MODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_2r_BLOCK_SYNC_MODEf_GET
#define SC_X1_SPD_OVRR1_2r_BLOCK_SYNC_MODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_2r_BLOCK_SYNC_MODEf_SET
#define SC_X1_SPD_OVRR1_2r_REORDER_ENf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_2r_REORDER_ENf_GET
#define SC_X1_SPD_OVRR1_2r_REORDER_ENf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_2r_REORDER_ENf_SET
#define SC_X1_SPD_OVRR1_2r_CL36_ENf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_2r_CL36_ENf_GET
#define SC_X1_SPD_OVRR1_2r_CL36_ENf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_2r_CL36_ENf_SET
#define READ_SC_X1_SPD_OVRR1_2r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR1_2r
#define WRITE_SC_X1_SPD_OVRR1_2r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR1_2r
#define MODIFY_SC_X1_SPD_OVRR1_2r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR1_2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR1_3
 * BLOCKS:   SC_X1_SPEED_OVERRIDE1
 * REGADDR:  0x9285
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CLOCKCNT0        clock count 0 for credit programming, range 5 to 4125
 *     SGMII_SPD_SWITCH Indicates to switch credits so that 10M/100M credits can go to the MAC and 1G credits can go to the PCS
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_3r (0x00109285 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_3r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR1_3.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_3r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr1_3[1];
	uint32_t _sc_x1_spd_ovrr1_3;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_3r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_3r_CLR(r) (r).sc_x1_spd_ovrr1_3[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_3r_SET(r,d) (r).sc_x1_spd_ovrr1_3[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_3r_GET(r) (r).sc_x1_spd_ovrr1_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_3r_SGMII_SPD_SWITCHf_GET(r) ((((r).sc_x1_spd_ovrr1_3[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_3r_SGMII_SPD_SWITCHf_SET(r,f) (r).sc_x1_spd_ovrr1_3[0]=(((r).sc_x1_spd_ovrr1_3[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_3r_CLOCKCNT0f_GET(r) (((r).sc_x1_spd_ovrr1_3[0]) & 0x3fff)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_3r_CLOCKCNT0f_SET(r,f) (r).sc_x1_spd_ovrr1_3[0]=(((r).sc_x1_spd_ovrr1_3[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR1_3.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR1_3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_3r,(_r._sc_x1_spd_ovrr1_3))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR1_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_3r,(_r._sc_x1_spd_ovrr1_3)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR1_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_3r,(_r._sc_x1_spd_ovrr1_3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR1_3r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_3r
#define SC_X1_SPD_OVRR1_3r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_3r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_3r_t SC_X1_SPD_OVRR1_3r_t;
#define SC_X1_SPD_OVRR1_3r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_3r_CLR
#define SC_X1_SPD_OVRR1_3r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_3r_SET
#define SC_X1_SPD_OVRR1_3r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_3r_GET
#define SC_X1_SPD_OVRR1_3r_SGMII_SPD_SWITCHf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_3r_SGMII_SPD_SWITCHf_GET
#define SC_X1_SPD_OVRR1_3r_SGMII_SPD_SWITCHf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_3r_SGMII_SPD_SWITCHf_SET
#define SC_X1_SPD_OVRR1_3r_CLOCKCNT0f_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_3r_CLOCKCNT0f_GET
#define SC_X1_SPD_OVRR1_3r_CLOCKCNT0f_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_3r_CLOCKCNT0f_SET
#define READ_SC_X1_SPD_OVRR1_3r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR1_3r
#define WRITE_SC_X1_SPD_OVRR1_3r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR1_3r
#define MODIFY_SC_X1_SPD_OVRR1_3r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR1_3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR1_4
 * BLOCKS:   SC_X1_SPEED_OVERRIDE1
 * REGADDR:  0x9286
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CLOCKCNT1        clock count 1 for credit programming, range 4 to 12
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_4r (0x00109286 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_4r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR1_4.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_4r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr1_4[1];
	uint32_t _sc_x1_spd_ovrr1_4;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_4r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_4r_CLR(r) (r).sc_x1_spd_ovrr1_4[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_4r_SET(r,d) (r).sc_x1_spd_ovrr1_4[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_4r_GET(r) (r).sc_x1_spd_ovrr1_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_4r_CLOCKCNT1f_GET(r) (((r).sc_x1_spd_ovrr1_4[0]) & 0xff)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_4r_CLOCKCNT1f_SET(r,f) (r).sc_x1_spd_ovrr1_4[0]=(((r).sc_x1_spd_ovrr1_4[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR1_4.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR1_4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_4r,(_r._sc_x1_spd_ovrr1_4))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR1_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_4r,(_r._sc_x1_spd_ovrr1_4)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR1_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_4r,(_r._sc_x1_spd_ovrr1_4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR1_4r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_4r
#define SC_X1_SPD_OVRR1_4r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_4r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_4r_t SC_X1_SPD_OVRR1_4r_t;
#define SC_X1_SPD_OVRR1_4r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_4r_CLR
#define SC_X1_SPD_OVRR1_4r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_4r_SET
#define SC_X1_SPD_OVRR1_4r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_4r_GET
#define SC_X1_SPD_OVRR1_4r_CLOCKCNT1f_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_4r_CLOCKCNT1f_GET
#define SC_X1_SPD_OVRR1_4r_CLOCKCNT1f_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_4r_CLOCKCNT1f_SET
#define READ_SC_X1_SPD_OVRR1_4r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR1_4r
#define WRITE_SC_X1_SPD_OVRR1_4r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR1_4r
#define MODIFY_SC_X1_SPD_OVRR1_4r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR1_4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR1_5
 * BLOCKS:   SC_X1_SPEED_OVERRIDE1
 * REGADDR:  0x9287
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LOOPCNT1         loop count 1 for credit programming, range 2 to 18
 *     LOOPCNT0         loop count 0 for credit programming, range 1 to 1
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_5r (0x00109287 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_5r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR1_5.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_5r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr1_5[1];
	uint32_t _sc_x1_spd_ovrr1_5;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_5r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_5r_CLR(r) (r).sc_x1_spd_ovrr1_5[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_5r_SET(r,d) (r).sc_x1_spd_ovrr1_5[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_5r_GET(r) (r).sc_x1_spd_ovrr1_5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_5r_LOOPCNT0f_GET(r) ((((r).sc_x1_spd_ovrr1_5[0]) >> 6) & 0xff)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_5r_LOOPCNT0f_SET(r,f) (r).sc_x1_spd_ovrr1_5[0]=(((r).sc_x1_spd_ovrr1_5[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6)) | (255 << (16 + 6))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_5r_LOOPCNT1f_GET(r) (((r).sc_x1_spd_ovrr1_5[0]) & 0x3f)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_5r_LOOPCNT1f_SET(r,f) (r).sc_x1_spd_ovrr1_5[0]=(((r).sc_x1_spd_ovrr1_5[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR1_5.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR1_5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_5r,(_r._sc_x1_spd_ovrr1_5))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR1_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_5r,(_r._sc_x1_spd_ovrr1_5)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR1_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_5r,(_r._sc_x1_spd_ovrr1_5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR1_5r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_5r
#define SC_X1_SPD_OVRR1_5r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_5r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_5r_t SC_X1_SPD_OVRR1_5r_t;
#define SC_X1_SPD_OVRR1_5r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_5r_CLR
#define SC_X1_SPD_OVRR1_5r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_5r_SET
#define SC_X1_SPD_OVRR1_5r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_5r_GET
#define SC_X1_SPD_OVRR1_5r_LOOPCNT0f_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_5r_LOOPCNT0f_GET
#define SC_X1_SPD_OVRR1_5r_LOOPCNT0f_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_5r_LOOPCNT0f_SET
#define SC_X1_SPD_OVRR1_5r_LOOPCNT1f_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_5r_LOOPCNT1f_GET
#define SC_X1_SPD_OVRR1_5r_LOOPCNT1f_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_5r_LOOPCNT1f_SET
#define READ_SC_X1_SPD_OVRR1_5r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR1_5r
#define WRITE_SC_X1_SPD_OVRR1_5r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR1_5r
#define MODIFY_SC_X1_SPD_OVRR1_5r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR1_5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR1_6
 * BLOCKS:   SC_X1_SPEED_OVERRIDE1
 * REGADDR:  0x9288
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MAC_CREDITGENCNT CGC for mac credit generation, range 1 to 2063
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_6r (0x00109288 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_6r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR1_6.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_6r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr1_6[1];
	uint32_t _sc_x1_spd_ovrr1_6;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_6r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_6r_CLR(r) (r).sc_x1_spd_ovrr1_6[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_6r_SET(r,d) (r).sc_x1_spd_ovrr1_6[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_6r_GET(r) (r).sc_x1_spd_ovrr1_6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_6r_MAC_CREDITGENCNTf_GET(r) (((r).sc_x1_spd_ovrr1_6[0]) & 0x1fff)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_6r_MAC_CREDITGENCNTf_SET(r,f) (r).sc_x1_spd_ovrr1_6[0]=(((r).sc_x1_spd_ovrr1_6[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR1_6.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR1_6r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_6r,(_r._sc_x1_spd_ovrr1_6))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR1_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_6r,(_r._sc_x1_spd_ovrr1_6)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR1_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_6r,(_r._sc_x1_spd_ovrr1_6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR1_6r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_6r
#define SC_X1_SPD_OVRR1_6r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_6r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_6r_t SC_X1_SPD_OVRR1_6r_t;
#define SC_X1_SPD_OVRR1_6r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_6r_CLR
#define SC_X1_SPD_OVRR1_6r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_6r_SET
#define SC_X1_SPD_OVRR1_6r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_6r_GET
#define SC_X1_SPD_OVRR1_6r_MAC_CREDITGENCNTf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_6r_MAC_CREDITGENCNTf_GET
#define SC_X1_SPD_OVRR1_6r_MAC_CREDITGENCNTf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_6r_MAC_CREDITGENCNTf_SET
#define READ_SC_X1_SPD_OVRR1_6r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR1_6r
#define WRITE_SC_X1_SPD_OVRR1_6r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR1_6r
#define MODIFY_SC_X1_SPD_OVRR1_6r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR1_6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR1_7
 * BLOCKS:   SC_X1_SPEED_OVERRIDE1
 * REGADDR:  0x9289
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_CLOCKCNT0    pcs clock count 0 for credit programming, range 5 to 4125
 *     PCS_CREDITENABLE Enables credits to be generated for the PCS.  Only used in 10M or 100M modes.
 *     REPLICATION_CNT  Set to one (1) for 10M and zero (0) for 100M
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_7r (0x00109289 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_7r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR1_7.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_7r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr1_7[1];
	uint32_t _sc_x1_spd_ovrr1_7;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_7r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_7r_CLR(r) (r).sc_x1_spd_ovrr1_7[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_7r_SET(r,d) (r).sc_x1_spd_ovrr1_7[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_7r_GET(r) (r).sc_x1_spd_ovrr1_7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_7r_REPLICATION_CNTf_GET(r) ((((r).sc_x1_spd_ovrr1_7[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_7r_REPLICATION_CNTf_SET(r,f) (r).sc_x1_spd_ovrr1_7[0]=(((r).sc_x1_spd_ovrr1_7[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_7r_PCS_CREDITENABLEf_GET(r) ((((r).sc_x1_spd_ovrr1_7[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_7r_PCS_CREDITENABLEf_SET(r,f) (r).sc_x1_spd_ovrr1_7[0]=(((r).sc_x1_spd_ovrr1_7[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_7r_PCS_CLOCKCNT0f_GET(r) (((r).sc_x1_spd_ovrr1_7[0]) & 0x3fff)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_7r_PCS_CLOCKCNT0f_SET(r,f) (r).sc_x1_spd_ovrr1_7[0]=(((r).sc_x1_spd_ovrr1_7[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR1_7.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR1_7r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_7r,(_r._sc_x1_spd_ovrr1_7))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR1_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_7r,(_r._sc_x1_spd_ovrr1_7)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR1_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_7r,(_r._sc_x1_spd_ovrr1_7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR1_7r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_7r
#define SC_X1_SPD_OVRR1_7r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_7r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_7r_t SC_X1_SPD_OVRR1_7r_t;
#define SC_X1_SPD_OVRR1_7r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_7r_CLR
#define SC_X1_SPD_OVRR1_7r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_7r_SET
#define SC_X1_SPD_OVRR1_7r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_7r_GET
#define SC_X1_SPD_OVRR1_7r_REPLICATION_CNTf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_7r_REPLICATION_CNTf_GET
#define SC_X1_SPD_OVRR1_7r_REPLICATION_CNTf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_7r_REPLICATION_CNTf_SET
#define SC_X1_SPD_OVRR1_7r_PCS_CREDITENABLEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_7r_PCS_CREDITENABLEf_GET
#define SC_X1_SPD_OVRR1_7r_PCS_CREDITENABLEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_7r_PCS_CREDITENABLEf_SET
#define SC_X1_SPD_OVRR1_7r_PCS_CLOCKCNT0f_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_7r_PCS_CLOCKCNT0f_GET
#define SC_X1_SPD_OVRR1_7r_PCS_CLOCKCNT0f_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_7r_PCS_CLOCKCNT0f_SET
#define READ_SC_X1_SPD_OVRR1_7r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR1_7r
#define WRITE_SC_X1_SPD_OVRR1_7r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR1_7r
#define MODIFY_SC_X1_SPD_OVRR1_7r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR1_7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR1_8
 * BLOCKS:   SC_X1_SPEED_OVERRIDE1
 * REGADDR:  0x928a
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_CREDITGENCNT CGC for pcs credit generation, range 1 to 2063
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_8r (0x0010928a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_8r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR1_8.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_8r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr1_8[1];
	uint32_t _sc_x1_spd_ovrr1_8;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_8r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_8r_CLR(r) (r).sc_x1_spd_ovrr1_8[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_8r_SET(r,d) (r).sc_x1_spd_ovrr1_8[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_8r_GET(r) (r).sc_x1_spd_ovrr1_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_8r_PCS_CREDITGENCNTf_GET(r) (((r).sc_x1_spd_ovrr1_8[0]) & 0x1fff)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_8r_PCS_CREDITGENCNTf_SET(r,f) (r).sc_x1_spd_ovrr1_8[0]=(((r).sc_x1_spd_ovrr1_8[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR1_8.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR1_8r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_8r,(_r._sc_x1_spd_ovrr1_8))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR1_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_8r,(_r._sc_x1_spd_ovrr1_8)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR1_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_8r,(_r._sc_x1_spd_ovrr1_8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR1_8r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_8r
#define SC_X1_SPD_OVRR1_8r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_8r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_8r_t SC_X1_SPD_OVRR1_8r_t;
#define SC_X1_SPD_OVRR1_8r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_8r_CLR
#define SC_X1_SPD_OVRR1_8r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_8r_SET
#define SC_X1_SPD_OVRR1_8r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_8r_GET
#define SC_X1_SPD_OVRR1_8r_PCS_CREDITGENCNTf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_8r_PCS_CREDITGENCNTf_GET
#define SC_X1_SPD_OVRR1_8r_PCS_CREDITGENCNTf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_8r_PCS_CREDITGENCNTf_SET
#define READ_SC_X1_SPD_OVRR1_8r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR1_8r
#define WRITE_SC_X1_SPD_OVRR1_8r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR1_8r
#define MODIFY_SC_X1_SPD_OVRR1_8r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR1_8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR1_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR2_SPD
 * BLOCKS:   SC_X1_SPEED_OVERRIDE2
 * REGADDR:  0x9290
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     NUM_LANES        Number of lanes0   : NUM_LANES_01 - use 1 lane1   : NUM_LANES_02 - use 2 lanes2   : NUM_LANES_04 - use 4 lanes3   : NUM_LANES_10 - use 10 lanes4   : NUM_LANES_12 - use 12 lanes
 *     SPEED            Speed ID to use for this configuration
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_SPDr (0x00109290 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_SPDr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR2_SPD.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_SPDr_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr2_spd[1];
	uint32_t _sc_x1_spd_ovrr2_spd;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_SPDr_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_SPDr_CLR(r) (r).sc_x1_spd_ovrr2_spd[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_SPDr_SET(r,d) (r).sc_x1_spd_ovrr2_spd[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_SPDr_GET(r) (r).sc_x1_spd_ovrr2_spd[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_SPDr_SPEEDf_GET(r) ((((r).sc_x1_spd_ovrr2_spd[0]) >> 8) & 0xff)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_SPDr_SPEEDf_SET(r,f) (r).sc_x1_spd_ovrr2_spd[0]=(((r).sc_x1_spd_ovrr2_spd[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_SPDr_NUM_LANESf_GET(r) (((r).sc_x1_spd_ovrr2_spd[0]) & 0x7)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_SPDr_NUM_LANESf_SET(r,f) (r).sc_x1_spd_ovrr2_spd[0]=(((r).sc_x1_spd_ovrr2_spd[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR2_SPD.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR2_SPDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_SPDr,(_r._sc_x1_spd_ovrr2_spd))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR2_SPDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_SPDr,(_r._sc_x1_spd_ovrr2_spd)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR2_SPDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_SPDr,(_r._sc_x1_spd_ovrr2_spd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR2_SPDr BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_SPDr
#define SC_X1_SPD_OVRR2_SPDr_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_SPDr_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_SPDr_t SC_X1_SPD_OVRR2_SPDr_t;
#define SC_X1_SPD_OVRR2_SPDr_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_SPDr_CLR
#define SC_X1_SPD_OVRR2_SPDr_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_SPDr_SET
#define SC_X1_SPD_OVRR2_SPDr_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_SPDr_GET
#define SC_X1_SPD_OVRR2_SPDr_SPEEDf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_SPDr_SPEEDf_GET
#define SC_X1_SPD_OVRR2_SPDr_SPEEDf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_SPDr_SPEEDf_SET
#define SC_X1_SPD_OVRR2_SPDr_NUM_LANESf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_SPDr_NUM_LANESf_GET
#define SC_X1_SPD_OVRR2_SPDr_NUM_LANESf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_SPDr_NUM_LANESf_SET
#define READ_SC_X1_SPD_OVRR2_SPDr BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR2_SPDr
#define WRITE_SC_X1_SPD_OVRR2_SPDr BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR2_SPDr
#define MODIFY_SC_X1_SPD_OVRR2_SPDr BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR2_SPDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_SPDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR2_0
 * BLOCKS:   SC_X1_SPEED_OVERRIDE2
 * REGADDR:  0x9292
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ENCODEMODE       000 All functions disabled for lane001 cl48 8b10b010 cl48 8b10b rxaui011 cl36 8b10b100 cl82 64b66b101 cl49 64b66b110 brcm 64b66b
 *     FEC_ENABLE       
 *     CL72_ENABLE      
 *     SCR_MODE         00 bypass scrambler01 64b66b scrambler (all 66 bits)10 8b10b scrambler (all 80 bits)11 64b66b scrambler (sync bits not scrambled)
 *     OS_MODE          0: OS MODE 1 - divide by 11: OS MODE 2 - divide by 22: OS MODE 3 - divide by 33: OS MODE 3.3 - divide by 3.3.Bit repeating pattern is 3,3,3,4,3,3,4,3,3,44: OS MODE 4 - divide by 45: OS MODE 5 - divide by 56: OS MODE 7.5 - divide by 7.57: OS MODE 8 - divide by 88: OS MODE 8.25 - divide by 8.25.Bit repeating pattern is 8,8,8,99: OS MODE 10 - divide by 10
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r (0x00109292 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR2_0.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr2_0[1];
	uint32_t _sc_x1_spd_ovrr2_0;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r_CLR(r) (r).sc_x1_spd_ovrr2_0[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r_SET(r,d) (r).sc_x1_spd_ovrr2_0[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r_GET(r) (r).sc_x1_spd_ovrr2_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r_OS_MODEf_GET(r) ((((r).sc_x1_spd_ovrr2_0[0]) >> 12) & 0xf)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r_OS_MODEf_SET(r,f) (r).sc_x1_spd_ovrr2_0[0]=(((r).sc_x1_spd_ovrr2_0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r_SCR_MODEf_GET(r) ((((r).sc_x1_spd_ovrr2_0[0]) >> 10) & 0x3)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r_SCR_MODEf_SET(r,f) (r).sc_x1_spd_ovrr2_0[0]=(((r).sc_x1_spd_ovrr2_0[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r_CL72_ENABLEf_GET(r) ((((r).sc_x1_spd_ovrr2_0[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r_CL72_ENABLEf_SET(r,f) (r).sc_x1_spd_ovrr2_0[0]=(((r).sc_x1_spd_ovrr2_0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r_FEC_ENABLEf_GET(r) ((((r).sc_x1_spd_ovrr2_0[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r_FEC_ENABLEf_SET(r,f) (r).sc_x1_spd_ovrr2_0[0]=(((r).sc_x1_spd_ovrr2_0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r_ENCODEMODEf_GET(r) (((r).sc_x1_spd_ovrr2_0[0]) & 0x7)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r_ENCODEMODEf_SET(r,f) (r).sc_x1_spd_ovrr2_0[0]=(((r).sc_x1_spd_ovrr2_0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR2_0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR2_0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r,(_r._sc_x1_spd_ovrr2_0))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR2_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r,(_r._sc_x1_spd_ovrr2_0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR2_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r,(_r._sc_x1_spd_ovrr2_0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR2_0r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r
#define SC_X1_SPD_OVRR2_0r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r_t SC_X1_SPD_OVRR2_0r_t;
#define SC_X1_SPD_OVRR2_0r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r_CLR
#define SC_X1_SPD_OVRR2_0r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r_SET
#define SC_X1_SPD_OVRR2_0r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r_GET
#define SC_X1_SPD_OVRR2_0r_OS_MODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r_OS_MODEf_GET
#define SC_X1_SPD_OVRR2_0r_OS_MODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r_OS_MODEf_SET
#define SC_X1_SPD_OVRR2_0r_SCR_MODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r_SCR_MODEf_GET
#define SC_X1_SPD_OVRR2_0r_SCR_MODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r_SCR_MODEf_SET
#define SC_X1_SPD_OVRR2_0r_CL72_ENABLEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r_CL72_ENABLEf_GET
#define SC_X1_SPD_OVRR2_0r_CL72_ENABLEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r_CL72_ENABLEf_SET
#define SC_X1_SPD_OVRR2_0r_FEC_ENABLEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r_FEC_ENABLEf_GET
#define SC_X1_SPD_OVRR2_0r_FEC_ENABLEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r_FEC_ENABLEf_SET
#define SC_X1_SPD_OVRR2_0r_ENCODEMODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r_ENCODEMODEf_GET
#define SC_X1_SPD_OVRR2_0r_ENCODEMODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r_ENCODEMODEf_SET
#define READ_SC_X1_SPD_OVRR2_0r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR2_0r
#define WRITE_SC_X1_SPD_OVRR2_0r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR2_0r
#define MODIFY_SC_X1_SPD_OVRR2_0r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR2_0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR2_1
 * BLOCKS:   SC_X1_SPEED_OVERRIDE2
 * REGADDR:  0x9293
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BRCM64B66_DESCRAMBLER_ENABLE If set, the data sent to the the brcm64b66 decoder is scrambled.Sync headers are not scrambled
 *     CL36BYTEDELETEMODE 2'b00 - 100M mode (Delete 9 out of every 10 bytes)2'b01 - 10M mode (Delete 99 out of every 100 bytes)2'b10 - Passthrough (No deletion)
 *     DESC2_MODE       r_desc2 mode3'b000 - NONE3'b001 - CL493'b010 - BRCM3'b011 - 3'b100 - CL483'b101 - CL363'b110 - CL823'b111 - NONE
 *     DESKEWMODE       3'b000 - None3'b001 - byte based deskew for 8b10b mode3'b010 - block based deskew for BRCM 64b66b mode3'b011 - block based deskew for IEEE CL82 mode3'b100 - cl36 mode enable
 *     DECODERMODE      r_dec1 mode3'b000 - None3'b001 - cl49 64b66b mode3'b010 - BRCM 64b66b mode3'b011 -  - cl49/BRCM 64b66b mode3'b100 - 8b10b mode - cl48 mode3'b101 - 8b10b mode - cl36 mode
 *     DESCRAMBLERMODE  r_descr1 modeUsed only in CL48 based speeds, set to bypass for all other speeds2'b00 - bypass descrambler2'b01 - 64b66b descrambler2'b10 - 8b10b descrambler2'b11 - reserved
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r (0x00109293 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR2_1.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr2_1[1];
	uint32_t _sc_x1_spd_ovrr2_1;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r_CLR(r) (r).sc_x1_spd_ovrr2_1[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r_SET(r,d) (r).sc_x1_spd_ovrr2_1[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r_GET(r) (r).sc_x1_spd_ovrr2_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r_DESCRAMBLERMODEf_GET(r) ((((r).sc_x1_spd_ovrr2_1[0]) >> 14) & 0x3)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r_DESCRAMBLERMODEf_SET(r,f) (r).sc_x1_spd_ovrr2_1[0]=(((r).sc_x1_spd_ovrr2_1[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r_DECODERMODEf_GET(r) ((((r).sc_x1_spd_ovrr2_1[0]) >> 11) & 0x7)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r_DECODERMODEf_SET(r,f) (r).sc_x1_spd_ovrr2_1[0]=(((r).sc_x1_spd_ovrr2_1[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r_DESKEWMODEf_GET(r) ((((r).sc_x1_spd_ovrr2_1[0]) >> 8) & 0x7)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r_DESKEWMODEf_SET(r,f) (r).sc_x1_spd_ovrr2_1[0]=(((r).sc_x1_spd_ovrr2_1[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r_DESC2_MODEf_GET(r) ((((r).sc_x1_spd_ovrr2_1[0]) >> 5) & 0x7)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r_DESC2_MODEf_SET(r,f) (r).sc_x1_spd_ovrr2_1[0]=(((r).sc_x1_spd_ovrr2_1[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5)) | (7 << (16 + 5))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r_CL36BYTEDELETEMODEf_GET(r) ((((r).sc_x1_spd_ovrr2_1[0]) >> 3) & 0x3)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r_CL36BYTEDELETEMODEf_SET(r,f) (r).sc_x1_spd_ovrr2_1[0]=(((r).sc_x1_spd_ovrr2_1[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3)) | (3 << (16 + 3))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r_BRCM64B66_DESCRAMBLER_ENABLEf_GET(r) ((((r).sc_x1_spd_ovrr2_1[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r_BRCM64B66_DESCRAMBLER_ENABLEf_SET(r,f) (r).sc_x1_spd_ovrr2_1[0]=(((r).sc_x1_spd_ovrr2_1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access SC_X1_SPD_OVRR2_1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR2_1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r,(_r._sc_x1_spd_ovrr2_1))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR2_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r,(_r._sc_x1_spd_ovrr2_1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR2_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r,(_r._sc_x1_spd_ovrr2_1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR2_1r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r
#define SC_X1_SPD_OVRR2_1r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r_t SC_X1_SPD_OVRR2_1r_t;
#define SC_X1_SPD_OVRR2_1r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r_CLR
#define SC_X1_SPD_OVRR2_1r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r_SET
#define SC_X1_SPD_OVRR2_1r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r_GET
#define SC_X1_SPD_OVRR2_1r_DESCRAMBLERMODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r_DESCRAMBLERMODEf_GET
#define SC_X1_SPD_OVRR2_1r_DESCRAMBLERMODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r_DESCRAMBLERMODEf_SET
#define SC_X1_SPD_OVRR2_1r_DECODERMODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r_DECODERMODEf_GET
#define SC_X1_SPD_OVRR2_1r_DECODERMODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r_DECODERMODEf_SET
#define SC_X1_SPD_OVRR2_1r_DESKEWMODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r_DESKEWMODEf_GET
#define SC_X1_SPD_OVRR2_1r_DESKEWMODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r_DESKEWMODEf_SET
#define SC_X1_SPD_OVRR2_1r_DESC2_MODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r_DESC2_MODEf_GET
#define SC_X1_SPD_OVRR2_1r_DESC2_MODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r_DESC2_MODEf_SET
#define SC_X1_SPD_OVRR2_1r_CL36BYTEDELETEMODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r_CL36BYTEDELETEMODEf_GET
#define SC_X1_SPD_OVRR2_1r_CL36BYTEDELETEMODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r_CL36BYTEDELETEMODEf_SET
#define SC_X1_SPD_OVRR2_1r_BRCM64B66_DESCRAMBLER_ENABLEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r_BRCM64B66_DESCRAMBLER_ENABLEf_GET
#define SC_X1_SPD_OVRR2_1r_BRCM64B66_DESCRAMBLER_ENABLEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r_BRCM64B66_DESCRAMBLER_ENABLEf_SET
#define READ_SC_X1_SPD_OVRR2_1r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR2_1r
#define WRITE_SC_X1_SPD_OVRR2_1r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR2_1r
#define MODIFY_SC_X1_SPD_OVRR2_1r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR2_1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR2_2
 * BLOCKS:   SC_X1_SPEED_OVERRIDE2
 * REGADDR:  0x9294
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x400 (1024)
 * ACCESS:   R/W
 * FIELDS:
 *     CL36_EN          
 *     REORDER_EN       1'b0: cl48 reorder is disabled1'b1: cl48 reorder is enabled
 *     BLOCK_SYNC_MODE  000 none001 cl49 mode - enables func_cl49cl82_sync block010 cl82 mode - enables func_cl49cl82_sync block011 8b10b mode - enables the func_8b10b_sync block100 fec mode - enables the func_fec_sync block101 brcm 64b66b mode
 *     CHK_END_EN       this bit enables cl48 check_end function as defined in section 48.2.6.1.4
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_2r (0x00109294 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_2r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR2_2.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_2r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr2_2[1];
	uint32_t _sc_x1_spd_ovrr2_2;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_2r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_2r_CLR(r) (r).sc_x1_spd_ovrr2_2[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_2r_SET(r,d) (r).sc_x1_spd_ovrr2_2[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_2r_GET(r) (r).sc_x1_spd_ovrr2_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_2r_CHK_END_ENf_GET(r) ((((r).sc_x1_spd_ovrr2_2[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_2r_CHK_END_ENf_SET(r,f) (r).sc_x1_spd_ovrr2_2[0]=(((r).sc_x1_spd_ovrr2_2[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_2r_BLOCK_SYNC_MODEf_GET(r) ((((r).sc_x1_spd_ovrr2_2[0]) >> 4) & 0x7)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_2r_BLOCK_SYNC_MODEf_SET(r,f) (r).sc_x1_spd_ovrr2_2[0]=(((r).sc_x1_spd_ovrr2_2[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_2r_REORDER_ENf_GET(r) ((((r).sc_x1_spd_ovrr2_2[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_2r_REORDER_ENf_SET(r,f) (r).sc_x1_spd_ovrr2_2[0]=(((r).sc_x1_spd_ovrr2_2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_2r_CL36_ENf_GET(r) (((r).sc_x1_spd_ovrr2_2[0]) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_2r_CL36_ENf_SET(r,f) (r).sc_x1_spd_ovrr2_2[0]=(((r).sc_x1_spd_ovrr2_2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR2_2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR2_2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_2r,(_r._sc_x1_spd_ovrr2_2))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR2_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_2r,(_r._sc_x1_spd_ovrr2_2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR2_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_2r,(_r._sc_x1_spd_ovrr2_2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR2_2r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_2r
#define SC_X1_SPD_OVRR2_2r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_2r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_2r_t SC_X1_SPD_OVRR2_2r_t;
#define SC_X1_SPD_OVRR2_2r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_2r_CLR
#define SC_X1_SPD_OVRR2_2r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_2r_SET
#define SC_X1_SPD_OVRR2_2r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_2r_GET
#define SC_X1_SPD_OVRR2_2r_CHK_END_ENf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_2r_CHK_END_ENf_GET
#define SC_X1_SPD_OVRR2_2r_CHK_END_ENf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_2r_CHK_END_ENf_SET
#define SC_X1_SPD_OVRR2_2r_BLOCK_SYNC_MODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_2r_BLOCK_SYNC_MODEf_GET
#define SC_X1_SPD_OVRR2_2r_BLOCK_SYNC_MODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_2r_BLOCK_SYNC_MODEf_SET
#define SC_X1_SPD_OVRR2_2r_REORDER_ENf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_2r_REORDER_ENf_GET
#define SC_X1_SPD_OVRR2_2r_REORDER_ENf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_2r_REORDER_ENf_SET
#define SC_X1_SPD_OVRR2_2r_CL36_ENf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_2r_CL36_ENf_GET
#define SC_X1_SPD_OVRR2_2r_CL36_ENf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_2r_CL36_ENf_SET
#define READ_SC_X1_SPD_OVRR2_2r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR2_2r
#define WRITE_SC_X1_SPD_OVRR2_2r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR2_2r
#define MODIFY_SC_X1_SPD_OVRR2_2r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR2_2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR2_3
 * BLOCKS:   SC_X1_SPEED_OVERRIDE2
 * REGADDR:  0x9295
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CLOCKCNT0        clock count 0 for credit programming, range 5 to 4125
 *     SGMII_SPD_SWITCH Indicates to switch credits so that 10M/100M credits can go to the MAC and 1G credits can go to the PCS
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_3r (0x00109295 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_3r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR2_3.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_3r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr2_3[1];
	uint32_t _sc_x1_spd_ovrr2_3;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_3r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_3r_CLR(r) (r).sc_x1_spd_ovrr2_3[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_3r_SET(r,d) (r).sc_x1_spd_ovrr2_3[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_3r_GET(r) (r).sc_x1_spd_ovrr2_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_3r_SGMII_SPD_SWITCHf_GET(r) ((((r).sc_x1_spd_ovrr2_3[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_3r_SGMII_SPD_SWITCHf_SET(r,f) (r).sc_x1_spd_ovrr2_3[0]=(((r).sc_x1_spd_ovrr2_3[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_3r_CLOCKCNT0f_GET(r) (((r).sc_x1_spd_ovrr2_3[0]) & 0x3fff)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_3r_CLOCKCNT0f_SET(r,f) (r).sc_x1_spd_ovrr2_3[0]=(((r).sc_x1_spd_ovrr2_3[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR2_3.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR2_3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_3r,(_r._sc_x1_spd_ovrr2_3))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR2_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_3r,(_r._sc_x1_spd_ovrr2_3)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR2_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_3r,(_r._sc_x1_spd_ovrr2_3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR2_3r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_3r
#define SC_X1_SPD_OVRR2_3r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_3r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_3r_t SC_X1_SPD_OVRR2_3r_t;
#define SC_X1_SPD_OVRR2_3r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_3r_CLR
#define SC_X1_SPD_OVRR2_3r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_3r_SET
#define SC_X1_SPD_OVRR2_3r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_3r_GET
#define SC_X1_SPD_OVRR2_3r_SGMII_SPD_SWITCHf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_3r_SGMII_SPD_SWITCHf_GET
#define SC_X1_SPD_OVRR2_3r_SGMII_SPD_SWITCHf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_3r_SGMII_SPD_SWITCHf_SET
#define SC_X1_SPD_OVRR2_3r_CLOCKCNT0f_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_3r_CLOCKCNT0f_GET
#define SC_X1_SPD_OVRR2_3r_CLOCKCNT0f_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_3r_CLOCKCNT0f_SET
#define READ_SC_X1_SPD_OVRR2_3r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR2_3r
#define WRITE_SC_X1_SPD_OVRR2_3r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR2_3r
#define MODIFY_SC_X1_SPD_OVRR2_3r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR2_3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR2_4
 * BLOCKS:   SC_X1_SPEED_OVERRIDE2
 * REGADDR:  0x9296
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CLOCKCNT1        clock count 1 for credit programming, range 4 to 12
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_4r (0x00109296 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_4r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR2_4.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_4r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr2_4[1];
	uint32_t _sc_x1_spd_ovrr2_4;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_4r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_4r_CLR(r) (r).sc_x1_spd_ovrr2_4[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_4r_SET(r,d) (r).sc_x1_spd_ovrr2_4[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_4r_GET(r) (r).sc_x1_spd_ovrr2_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_4r_CLOCKCNT1f_GET(r) (((r).sc_x1_spd_ovrr2_4[0]) & 0xff)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_4r_CLOCKCNT1f_SET(r,f) (r).sc_x1_spd_ovrr2_4[0]=(((r).sc_x1_spd_ovrr2_4[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR2_4.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR2_4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_4r,(_r._sc_x1_spd_ovrr2_4))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR2_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_4r,(_r._sc_x1_spd_ovrr2_4)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR2_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_4r,(_r._sc_x1_spd_ovrr2_4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR2_4r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_4r
#define SC_X1_SPD_OVRR2_4r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_4r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_4r_t SC_X1_SPD_OVRR2_4r_t;
#define SC_X1_SPD_OVRR2_4r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_4r_CLR
#define SC_X1_SPD_OVRR2_4r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_4r_SET
#define SC_X1_SPD_OVRR2_4r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_4r_GET
#define SC_X1_SPD_OVRR2_4r_CLOCKCNT1f_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_4r_CLOCKCNT1f_GET
#define SC_X1_SPD_OVRR2_4r_CLOCKCNT1f_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_4r_CLOCKCNT1f_SET
#define READ_SC_X1_SPD_OVRR2_4r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR2_4r
#define WRITE_SC_X1_SPD_OVRR2_4r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR2_4r
#define MODIFY_SC_X1_SPD_OVRR2_4r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR2_4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR2_5
 * BLOCKS:   SC_X1_SPEED_OVERRIDE2
 * REGADDR:  0x9297
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LOOPCNT1         loop count 1 for credit programming, range 2 to 18
 *     LOOPCNT0         loop count 0 for credit programming, range 1 to 1
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_5r (0x00109297 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_5r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR2_5.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_5r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr2_5[1];
	uint32_t _sc_x1_spd_ovrr2_5;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_5r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_5r_CLR(r) (r).sc_x1_spd_ovrr2_5[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_5r_SET(r,d) (r).sc_x1_spd_ovrr2_5[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_5r_GET(r) (r).sc_x1_spd_ovrr2_5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_5r_LOOPCNT0f_GET(r) ((((r).sc_x1_spd_ovrr2_5[0]) >> 6) & 0xff)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_5r_LOOPCNT0f_SET(r,f) (r).sc_x1_spd_ovrr2_5[0]=(((r).sc_x1_spd_ovrr2_5[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6)) | (255 << (16 + 6))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_5r_LOOPCNT1f_GET(r) (((r).sc_x1_spd_ovrr2_5[0]) & 0x3f)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_5r_LOOPCNT1f_SET(r,f) (r).sc_x1_spd_ovrr2_5[0]=(((r).sc_x1_spd_ovrr2_5[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR2_5.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR2_5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_5r,(_r._sc_x1_spd_ovrr2_5))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR2_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_5r,(_r._sc_x1_spd_ovrr2_5)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR2_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_5r,(_r._sc_x1_spd_ovrr2_5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR2_5r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_5r
#define SC_X1_SPD_OVRR2_5r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_5r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_5r_t SC_X1_SPD_OVRR2_5r_t;
#define SC_X1_SPD_OVRR2_5r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_5r_CLR
#define SC_X1_SPD_OVRR2_5r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_5r_SET
#define SC_X1_SPD_OVRR2_5r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_5r_GET
#define SC_X1_SPD_OVRR2_5r_LOOPCNT0f_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_5r_LOOPCNT0f_GET
#define SC_X1_SPD_OVRR2_5r_LOOPCNT0f_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_5r_LOOPCNT0f_SET
#define SC_X1_SPD_OVRR2_5r_LOOPCNT1f_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_5r_LOOPCNT1f_GET
#define SC_X1_SPD_OVRR2_5r_LOOPCNT1f_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_5r_LOOPCNT1f_SET
#define READ_SC_X1_SPD_OVRR2_5r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR2_5r
#define WRITE_SC_X1_SPD_OVRR2_5r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR2_5r
#define MODIFY_SC_X1_SPD_OVRR2_5r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR2_5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR2_6
 * BLOCKS:   SC_X1_SPEED_OVERRIDE2
 * REGADDR:  0x9298
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MAC_CREDITGENCNT CGC for mac credit generation, range 1 to 2063
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_6r (0x00109298 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_6r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR2_6.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_6r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr2_6[1];
	uint32_t _sc_x1_spd_ovrr2_6;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_6r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_6r_CLR(r) (r).sc_x1_spd_ovrr2_6[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_6r_SET(r,d) (r).sc_x1_spd_ovrr2_6[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_6r_GET(r) (r).sc_x1_spd_ovrr2_6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_6r_MAC_CREDITGENCNTf_GET(r) (((r).sc_x1_spd_ovrr2_6[0]) & 0x1fff)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_6r_MAC_CREDITGENCNTf_SET(r,f) (r).sc_x1_spd_ovrr2_6[0]=(((r).sc_x1_spd_ovrr2_6[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR2_6.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR2_6r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_6r,(_r._sc_x1_spd_ovrr2_6))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR2_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_6r,(_r._sc_x1_spd_ovrr2_6)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR2_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_6r,(_r._sc_x1_spd_ovrr2_6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR2_6r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_6r
#define SC_X1_SPD_OVRR2_6r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_6r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_6r_t SC_X1_SPD_OVRR2_6r_t;
#define SC_X1_SPD_OVRR2_6r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_6r_CLR
#define SC_X1_SPD_OVRR2_6r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_6r_SET
#define SC_X1_SPD_OVRR2_6r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_6r_GET
#define SC_X1_SPD_OVRR2_6r_MAC_CREDITGENCNTf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_6r_MAC_CREDITGENCNTf_GET
#define SC_X1_SPD_OVRR2_6r_MAC_CREDITGENCNTf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_6r_MAC_CREDITGENCNTf_SET
#define READ_SC_X1_SPD_OVRR2_6r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR2_6r
#define WRITE_SC_X1_SPD_OVRR2_6r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR2_6r
#define MODIFY_SC_X1_SPD_OVRR2_6r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR2_6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR2_7
 * BLOCKS:   SC_X1_SPEED_OVERRIDE2
 * REGADDR:  0x9299
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_CLOCKCNT0    pcs clock count 0 for credit programming, range 5 to 4125
 *     PCS_CREDITENABLE Enables credits to be generated for the PCS.  Only used in 10M or 100M modes.
 *     REPLICATION_CNT  Set to one (1) for 10M and zero (0) for 100M
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_7r (0x00109299 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_7r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR2_7.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_7r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr2_7[1];
	uint32_t _sc_x1_spd_ovrr2_7;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_7r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_7r_CLR(r) (r).sc_x1_spd_ovrr2_7[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_7r_SET(r,d) (r).sc_x1_spd_ovrr2_7[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_7r_GET(r) (r).sc_x1_spd_ovrr2_7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_7r_REPLICATION_CNTf_GET(r) ((((r).sc_x1_spd_ovrr2_7[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_7r_REPLICATION_CNTf_SET(r,f) (r).sc_x1_spd_ovrr2_7[0]=(((r).sc_x1_spd_ovrr2_7[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_7r_PCS_CREDITENABLEf_GET(r) ((((r).sc_x1_spd_ovrr2_7[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_7r_PCS_CREDITENABLEf_SET(r,f) (r).sc_x1_spd_ovrr2_7[0]=(((r).sc_x1_spd_ovrr2_7[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_7r_PCS_CLOCKCNT0f_GET(r) (((r).sc_x1_spd_ovrr2_7[0]) & 0x3fff)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_7r_PCS_CLOCKCNT0f_SET(r,f) (r).sc_x1_spd_ovrr2_7[0]=(((r).sc_x1_spd_ovrr2_7[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR2_7.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR2_7r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_7r,(_r._sc_x1_spd_ovrr2_7))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR2_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_7r,(_r._sc_x1_spd_ovrr2_7)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR2_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_7r,(_r._sc_x1_spd_ovrr2_7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR2_7r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_7r
#define SC_X1_SPD_OVRR2_7r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_7r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_7r_t SC_X1_SPD_OVRR2_7r_t;
#define SC_X1_SPD_OVRR2_7r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_7r_CLR
#define SC_X1_SPD_OVRR2_7r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_7r_SET
#define SC_X1_SPD_OVRR2_7r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_7r_GET
#define SC_X1_SPD_OVRR2_7r_REPLICATION_CNTf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_7r_REPLICATION_CNTf_GET
#define SC_X1_SPD_OVRR2_7r_REPLICATION_CNTf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_7r_REPLICATION_CNTf_SET
#define SC_X1_SPD_OVRR2_7r_PCS_CREDITENABLEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_7r_PCS_CREDITENABLEf_GET
#define SC_X1_SPD_OVRR2_7r_PCS_CREDITENABLEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_7r_PCS_CREDITENABLEf_SET
#define SC_X1_SPD_OVRR2_7r_PCS_CLOCKCNT0f_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_7r_PCS_CLOCKCNT0f_GET
#define SC_X1_SPD_OVRR2_7r_PCS_CLOCKCNT0f_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_7r_PCS_CLOCKCNT0f_SET
#define READ_SC_X1_SPD_OVRR2_7r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR2_7r
#define WRITE_SC_X1_SPD_OVRR2_7r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR2_7r
#define MODIFY_SC_X1_SPD_OVRR2_7r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR2_7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR2_8
 * BLOCKS:   SC_X1_SPEED_OVERRIDE2
 * REGADDR:  0x929a
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_CREDITGENCNT CGC for pcs credit generation, range 1 to 2063
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_8r (0x0010929a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_8r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR2_8.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_8r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr2_8[1];
	uint32_t _sc_x1_spd_ovrr2_8;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_8r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_8r_CLR(r) (r).sc_x1_spd_ovrr2_8[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_8r_SET(r,d) (r).sc_x1_spd_ovrr2_8[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_8r_GET(r) (r).sc_x1_spd_ovrr2_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_8r_PCS_CREDITGENCNTf_GET(r) (((r).sc_x1_spd_ovrr2_8[0]) & 0x1fff)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_8r_PCS_CREDITGENCNTf_SET(r,f) (r).sc_x1_spd_ovrr2_8[0]=(((r).sc_x1_spd_ovrr2_8[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR2_8.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR2_8r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_8r,(_r._sc_x1_spd_ovrr2_8))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR2_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_8r,(_r._sc_x1_spd_ovrr2_8)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR2_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_8r,(_r._sc_x1_spd_ovrr2_8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR2_8r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_8r
#define SC_X1_SPD_OVRR2_8r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_8r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_8r_t SC_X1_SPD_OVRR2_8r_t;
#define SC_X1_SPD_OVRR2_8r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_8r_CLR
#define SC_X1_SPD_OVRR2_8r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_8r_SET
#define SC_X1_SPD_OVRR2_8r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_8r_GET
#define SC_X1_SPD_OVRR2_8r_PCS_CREDITGENCNTf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_8r_PCS_CREDITGENCNTf_GET
#define SC_X1_SPD_OVRR2_8r_PCS_CREDITGENCNTf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_8r_PCS_CREDITGENCNTf_SET
#define READ_SC_X1_SPD_OVRR2_8r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR2_8r
#define WRITE_SC_X1_SPD_OVRR2_8r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR2_8r
#define MODIFY_SC_X1_SPD_OVRR2_8r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR2_8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR2_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR3_SPD
 * BLOCKS:   SC_X1_SPEED_OVERRIDE3
 * REGADDR:  0x92a0
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     NUM_LANES        Number of lanes0   : NUM_LANES_01 - use 1 lane1   : NUM_LANES_02 - use 2 lanes2   : NUM_LANES_04 - use 4 lanes3   : NUM_LANES_10 - use 10 lanes4   : NUM_LANES_12 - use 12 lanes
 *     SPEED            Speed ID to use for this configuration
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_SPDr (0x001092a0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_SPDr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR3_SPD.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_SPDr_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr3_spd[1];
	uint32_t _sc_x1_spd_ovrr3_spd;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_SPDr_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_SPDr_CLR(r) (r).sc_x1_spd_ovrr3_spd[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_SPDr_SET(r,d) (r).sc_x1_spd_ovrr3_spd[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_SPDr_GET(r) (r).sc_x1_spd_ovrr3_spd[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_SPDr_SPEEDf_GET(r) ((((r).sc_x1_spd_ovrr3_spd[0]) >> 8) & 0xff)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_SPDr_SPEEDf_SET(r,f) (r).sc_x1_spd_ovrr3_spd[0]=(((r).sc_x1_spd_ovrr3_spd[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_SPDr_NUM_LANESf_GET(r) (((r).sc_x1_spd_ovrr3_spd[0]) & 0x7)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_SPDr_NUM_LANESf_SET(r,f) (r).sc_x1_spd_ovrr3_spd[0]=(((r).sc_x1_spd_ovrr3_spd[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR3_SPD.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR3_SPDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_SPDr,(_r._sc_x1_spd_ovrr3_spd))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR3_SPDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_SPDr,(_r._sc_x1_spd_ovrr3_spd)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR3_SPDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_SPDr,(_r._sc_x1_spd_ovrr3_spd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR3_SPDr BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_SPDr
#define SC_X1_SPD_OVRR3_SPDr_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_SPDr_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_SPDr_t SC_X1_SPD_OVRR3_SPDr_t;
#define SC_X1_SPD_OVRR3_SPDr_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_SPDr_CLR
#define SC_X1_SPD_OVRR3_SPDr_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_SPDr_SET
#define SC_X1_SPD_OVRR3_SPDr_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_SPDr_GET
#define SC_X1_SPD_OVRR3_SPDr_SPEEDf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_SPDr_SPEEDf_GET
#define SC_X1_SPD_OVRR3_SPDr_SPEEDf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_SPDr_SPEEDf_SET
#define SC_X1_SPD_OVRR3_SPDr_NUM_LANESf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_SPDr_NUM_LANESf_GET
#define SC_X1_SPD_OVRR3_SPDr_NUM_LANESf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_SPDr_NUM_LANESf_SET
#define READ_SC_X1_SPD_OVRR3_SPDr BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR3_SPDr
#define WRITE_SC_X1_SPD_OVRR3_SPDr BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR3_SPDr
#define MODIFY_SC_X1_SPD_OVRR3_SPDr BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR3_SPDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_SPDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR3_0
 * BLOCKS:   SC_X1_SPEED_OVERRIDE3
 * REGADDR:  0x92a2
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ENCODEMODE       000 All functions disabled for lane001 cl48 8b10b010 cl48 8b10b rxaui011 cl36 8b10b100 cl82 64b66b101 cl49 64b66b110 brcm 64b66b
 *     FEC_ENABLE       
 *     CL72_ENABLE      
 *     SCR_MODE         00 bypass scrambler01 64b66b scrambler (all 66 bits)10 8b10b scrambler (all 80 bits)11 64b66b scrambler (sync bits not scrambled)
 *     OS_MODE          0: OS MODE 1 - divide by 11: OS MODE 2 - divide by 22: OS MODE 3 - divide by 33: OS MODE 3.3 - divide by 3.3.Bit repeating pattern is 3,3,3,4,3,3,4,3,3,44: OS MODE 4 - divide by 45: OS MODE 5 - divide by 56: OS MODE 7.5 - divide by 7.57: OS MODE 8 - divide by 88: OS MODE 8.25 - divide by 8.25.Bit repeating pattern is 8,8,8,99: OS MODE 10 - divide by 10
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r (0x001092a2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR3_0.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr3_0[1];
	uint32_t _sc_x1_spd_ovrr3_0;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r_CLR(r) (r).sc_x1_spd_ovrr3_0[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r_SET(r,d) (r).sc_x1_spd_ovrr3_0[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r_GET(r) (r).sc_x1_spd_ovrr3_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r_OS_MODEf_GET(r) ((((r).sc_x1_spd_ovrr3_0[0]) >> 12) & 0xf)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r_OS_MODEf_SET(r,f) (r).sc_x1_spd_ovrr3_0[0]=(((r).sc_x1_spd_ovrr3_0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r_SCR_MODEf_GET(r) ((((r).sc_x1_spd_ovrr3_0[0]) >> 10) & 0x3)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r_SCR_MODEf_SET(r,f) (r).sc_x1_spd_ovrr3_0[0]=(((r).sc_x1_spd_ovrr3_0[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r_CL72_ENABLEf_GET(r) ((((r).sc_x1_spd_ovrr3_0[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r_CL72_ENABLEf_SET(r,f) (r).sc_x1_spd_ovrr3_0[0]=(((r).sc_x1_spd_ovrr3_0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r_FEC_ENABLEf_GET(r) ((((r).sc_x1_spd_ovrr3_0[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r_FEC_ENABLEf_SET(r,f) (r).sc_x1_spd_ovrr3_0[0]=(((r).sc_x1_spd_ovrr3_0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r_ENCODEMODEf_GET(r) (((r).sc_x1_spd_ovrr3_0[0]) & 0x7)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r_ENCODEMODEf_SET(r,f) (r).sc_x1_spd_ovrr3_0[0]=(((r).sc_x1_spd_ovrr3_0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR3_0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR3_0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r,(_r._sc_x1_spd_ovrr3_0))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR3_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r,(_r._sc_x1_spd_ovrr3_0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR3_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r,(_r._sc_x1_spd_ovrr3_0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR3_0r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r
#define SC_X1_SPD_OVRR3_0r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r_t SC_X1_SPD_OVRR3_0r_t;
#define SC_X1_SPD_OVRR3_0r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r_CLR
#define SC_X1_SPD_OVRR3_0r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r_SET
#define SC_X1_SPD_OVRR3_0r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r_GET
#define SC_X1_SPD_OVRR3_0r_OS_MODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r_OS_MODEf_GET
#define SC_X1_SPD_OVRR3_0r_OS_MODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r_OS_MODEf_SET
#define SC_X1_SPD_OVRR3_0r_SCR_MODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r_SCR_MODEf_GET
#define SC_X1_SPD_OVRR3_0r_SCR_MODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r_SCR_MODEf_SET
#define SC_X1_SPD_OVRR3_0r_CL72_ENABLEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r_CL72_ENABLEf_GET
#define SC_X1_SPD_OVRR3_0r_CL72_ENABLEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r_CL72_ENABLEf_SET
#define SC_X1_SPD_OVRR3_0r_FEC_ENABLEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r_FEC_ENABLEf_GET
#define SC_X1_SPD_OVRR3_0r_FEC_ENABLEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r_FEC_ENABLEf_SET
#define SC_X1_SPD_OVRR3_0r_ENCODEMODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r_ENCODEMODEf_GET
#define SC_X1_SPD_OVRR3_0r_ENCODEMODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r_ENCODEMODEf_SET
#define READ_SC_X1_SPD_OVRR3_0r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR3_0r
#define WRITE_SC_X1_SPD_OVRR3_0r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR3_0r
#define MODIFY_SC_X1_SPD_OVRR3_0r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR3_0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR3_1
 * BLOCKS:   SC_X1_SPEED_OVERRIDE3
 * REGADDR:  0x92a3
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BRCM64B66_DESCRAMBLER_ENABLE If set, the data sent to the the brcm64b66 decoder is scrambled.Sync headers are not scrambled
 *     CL36BYTEDELETEMODE 2'b00 - 100M mode (Delete 9 out of every 10 bytes)2'b01 - 10M mode (Delete 99 out of every 100 bytes)2'b10 - Passthrough (No deletion)
 *     DESC2_MODE       r_desc2 mode3'b000 - NONE3'b001 - CL493'b010 - BRCM3'b011 - 3'b100 - CL483'b101 - CL363'b110 - CL823'b111 - NONE
 *     DESKEWMODE       3'b000 - None3'b001 - byte based deskew for 8b10b mode3'b010 - block based deskew for BRCM 64b66b mode3'b011 - block based deskew for IEEE CL82 mode3'b100 - cl36 mode enable
 *     DECODERMODE      r_dec1 mode3'b000 - None3'b001 - cl49 64b66b mode3'b010 - BRCM 64b66b mode3'b011 -  - cl49/BRCM 64b66b mode3'b100 - 8b10b mode - cl48 mode3'b101 - 8b10b mode - cl36 mode
 *     DESCRAMBLERMODE  r_descr1 modeUsed only in CL48 based speeds, set to bypass for all other speeds2'b00 - bypass descrambler2'b01 - 64b66b descrambler2'b10 - 8b10b descrambler2'b11 - reserved
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r (0x001092a3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR3_1.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr3_1[1];
	uint32_t _sc_x1_spd_ovrr3_1;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r_CLR(r) (r).sc_x1_spd_ovrr3_1[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r_SET(r,d) (r).sc_x1_spd_ovrr3_1[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r_GET(r) (r).sc_x1_spd_ovrr3_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r_DESCRAMBLERMODEf_GET(r) ((((r).sc_x1_spd_ovrr3_1[0]) >> 14) & 0x3)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r_DESCRAMBLERMODEf_SET(r,f) (r).sc_x1_spd_ovrr3_1[0]=(((r).sc_x1_spd_ovrr3_1[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r_DECODERMODEf_GET(r) ((((r).sc_x1_spd_ovrr3_1[0]) >> 11) & 0x7)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r_DECODERMODEf_SET(r,f) (r).sc_x1_spd_ovrr3_1[0]=(((r).sc_x1_spd_ovrr3_1[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r_DESKEWMODEf_GET(r) ((((r).sc_x1_spd_ovrr3_1[0]) >> 8) & 0x7)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r_DESKEWMODEf_SET(r,f) (r).sc_x1_spd_ovrr3_1[0]=(((r).sc_x1_spd_ovrr3_1[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r_DESC2_MODEf_GET(r) ((((r).sc_x1_spd_ovrr3_1[0]) >> 5) & 0x7)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r_DESC2_MODEf_SET(r,f) (r).sc_x1_spd_ovrr3_1[0]=(((r).sc_x1_spd_ovrr3_1[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5)) | (7 << (16 + 5))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r_CL36BYTEDELETEMODEf_GET(r) ((((r).sc_x1_spd_ovrr3_1[0]) >> 3) & 0x3)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r_CL36BYTEDELETEMODEf_SET(r,f) (r).sc_x1_spd_ovrr3_1[0]=(((r).sc_x1_spd_ovrr3_1[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3)) | (3 << (16 + 3))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r_BRCM64B66_DESCRAMBLER_ENABLEf_GET(r) ((((r).sc_x1_spd_ovrr3_1[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r_BRCM64B66_DESCRAMBLER_ENABLEf_SET(r,f) (r).sc_x1_spd_ovrr3_1[0]=(((r).sc_x1_spd_ovrr3_1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access SC_X1_SPD_OVRR3_1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR3_1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r,(_r._sc_x1_spd_ovrr3_1))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR3_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r,(_r._sc_x1_spd_ovrr3_1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR3_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r,(_r._sc_x1_spd_ovrr3_1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR3_1r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r
#define SC_X1_SPD_OVRR3_1r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r_t SC_X1_SPD_OVRR3_1r_t;
#define SC_X1_SPD_OVRR3_1r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r_CLR
#define SC_X1_SPD_OVRR3_1r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r_SET
#define SC_X1_SPD_OVRR3_1r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r_GET
#define SC_X1_SPD_OVRR3_1r_DESCRAMBLERMODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r_DESCRAMBLERMODEf_GET
#define SC_X1_SPD_OVRR3_1r_DESCRAMBLERMODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r_DESCRAMBLERMODEf_SET
#define SC_X1_SPD_OVRR3_1r_DECODERMODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r_DECODERMODEf_GET
#define SC_X1_SPD_OVRR3_1r_DECODERMODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r_DECODERMODEf_SET
#define SC_X1_SPD_OVRR3_1r_DESKEWMODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r_DESKEWMODEf_GET
#define SC_X1_SPD_OVRR3_1r_DESKEWMODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r_DESKEWMODEf_SET
#define SC_X1_SPD_OVRR3_1r_DESC2_MODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r_DESC2_MODEf_GET
#define SC_X1_SPD_OVRR3_1r_DESC2_MODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r_DESC2_MODEf_SET
#define SC_X1_SPD_OVRR3_1r_CL36BYTEDELETEMODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r_CL36BYTEDELETEMODEf_GET
#define SC_X1_SPD_OVRR3_1r_CL36BYTEDELETEMODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r_CL36BYTEDELETEMODEf_SET
#define SC_X1_SPD_OVRR3_1r_BRCM64B66_DESCRAMBLER_ENABLEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r_BRCM64B66_DESCRAMBLER_ENABLEf_GET
#define SC_X1_SPD_OVRR3_1r_BRCM64B66_DESCRAMBLER_ENABLEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r_BRCM64B66_DESCRAMBLER_ENABLEf_SET
#define READ_SC_X1_SPD_OVRR3_1r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR3_1r
#define WRITE_SC_X1_SPD_OVRR3_1r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR3_1r
#define MODIFY_SC_X1_SPD_OVRR3_1r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR3_1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR3_2
 * BLOCKS:   SC_X1_SPEED_OVERRIDE3
 * REGADDR:  0x92a4
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x400 (1024)
 * ACCESS:   R/W
 * FIELDS:
 *     CL36_EN          
 *     REORDER_EN       1'b0: cl48 reorder is disabled1'b1: cl48 reorder is enabled
 *     BLOCK_SYNC_MODE  000 none001 cl49 mode - enables func_cl49cl82_sync block010 cl82 mode - enables func_cl49cl82_sync block011 8b10b mode - enables the func_8b10b_sync block100 fec mode - enables the func_fec_sync block101 brcm 64b66b mode
 *     CHK_END_EN       this bit enables cl48 check_end function as defined in section 48.2.6.1.4
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_2r (0x001092a4 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_2r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR3_2.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_2r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr3_2[1];
	uint32_t _sc_x1_spd_ovrr3_2;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_2r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_2r_CLR(r) (r).sc_x1_spd_ovrr3_2[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_2r_SET(r,d) (r).sc_x1_spd_ovrr3_2[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_2r_GET(r) (r).sc_x1_spd_ovrr3_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_2r_CHK_END_ENf_GET(r) ((((r).sc_x1_spd_ovrr3_2[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_2r_CHK_END_ENf_SET(r,f) (r).sc_x1_spd_ovrr3_2[0]=(((r).sc_x1_spd_ovrr3_2[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_2r_BLOCK_SYNC_MODEf_GET(r) ((((r).sc_x1_spd_ovrr3_2[0]) >> 4) & 0x7)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_2r_BLOCK_SYNC_MODEf_SET(r,f) (r).sc_x1_spd_ovrr3_2[0]=(((r).sc_x1_spd_ovrr3_2[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_2r_REORDER_ENf_GET(r) ((((r).sc_x1_spd_ovrr3_2[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_2r_REORDER_ENf_SET(r,f) (r).sc_x1_spd_ovrr3_2[0]=(((r).sc_x1_spd_ovrr3_2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_2r_CL36_ENf_GET(r) (((r).sc_x1_spd_ovrr3_2[0]) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_2r_CL36_ENf_SET(r,f) (r).sc_x1_spd_ovrr3_2[0]=(((r).sc_x1_spd_ovrr3_2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR3_2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR3_2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_2r,(_r._sc_x1_spd_ovrr3_2))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR3_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_2r,(_r._sc_x1_spd_ovrr3_2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR3_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_2r,(_r._sc_x1_spd_ovrr3_2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR3_2r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_2r
#define SC_X1_SPD_OVRR3_2r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_2r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_2r_t SC_X1_SPD_OVRR3_2r_t;
#define SC_X1_SPD_OVRR3_2r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_2r_CLR
#define SC_X1_SPD_OVRR3_2r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_2r_SET
#define SC_X1_SPD_OVRR3_2r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_2r_GET
#define SC_X1_SPD_OVRR3_2r_CHK_END_ENf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_2r_CHK_END_ENf_GET
#define SC_X1_SPD_OVRR3_2r_CHK_END_ENf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_2r_CHK_END_ENf_SET
#define SC_X1_SPD_OVRR3_2r_BLOCK_SYNC_MODEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_2r_BLOCK_SYNC_MODEf_GET
#define SC_X1_SPD_OVRR3_2r_BLOCK_SYNC_MODEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_2r_BLOCK_SYNC_MODEf_SET
#define SC_X1_SPD_OVRR3_2r_REORDER_ENf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_2r_REORDER_ENf_GET
#define SC_X1_SPD_OVRR3_2r_REORDER_ENf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_2r_REORDER_ENf_SET
#define SC_X1_SPD_OVRR3_2r_CL36_ENf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_2r_CL36_ENf_GET
#define SC_X1_SPD_OVRR3_2r_CL36_ENf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_2r_CL36_ENf_SET
#define READ_SC_X1_SPD_OVRR3_2r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR3_2r
#define WRITE_SC_X1_SPD_OVRR3_2r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR3_2r
#define MODIFY_SC_X1_SPD_OVRR3_2r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR3_2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR3_3
 * BLOCKS:   SC_X1_SPEED_OVERRIDE3
 * REGADDR:  0x92a5
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CLOCKCNT0        clock count 0 for credit programming, range 5 to 4125
 *     SGMII_SPD_SWITCH Indicates to switch credits so that 10M/100M credits can go to the MAC and 1G credits can go to the PCS
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_3r (0x001092a5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_3r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR3_3.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_3r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr3_3[1];
	uint32_t _sc_x1_spd_ovrr3_3;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_3r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_3r_CLR(r) (r).sc_x1_spd_ovrr3_3[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_3r_SET(r,d) (r).sc_x1_spd_ovrr3_3[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_3r_GET(r) (r).sc_x1_spd_ovrr3_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_3r_SGMII_SPD_SWITCHf_GET(r) ((((r).sc_x1_spd_ovrr3_3[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_3r_SGMII_SPD_SWITCHf_SET(r,f) (r).sc_x1_spd_ovrr3_3[0]=(((r).sc_x1_spd_ovrr3_3[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_3r_CLOCKCNT0f_GET(r) (((r).sc_x1_spd_ovrr3_3[0]) & 0x3fff)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_3r_CLOCKCNT0f_SET(r,f) (r).sc_x1_spd_ovrr3_3[0]=(((r).sc_x1_spd_ovrr3_3[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR3_3.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR3_3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_3r,(_r._sc_x1_spd_ovrr3_3))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR3_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_3r,(_r._sc_x1_spd_ovrr3_3)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR3_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_3r,(_r._sc_x1_spd_ovrr3_3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR3_3r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_3r
#define SC_X1_SPD_OVRR3_3r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_3r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_3r_t SC_X1_SPD_OVRR3_3r_t;
#define SC_X1_SPD_OVRR3_3r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_3r_CLR
#define SC_X1_SPD_OVRR3_3r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_3r_SET
#define SC_X1_SPD_OVRR3_3r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_3r_GET
#define SC_X1_SPD_OVRR3_3r_SGMII_SPD_SWITCHf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_3r_SGMII_SPD_SWITCHf_GET
#define SC_X1_SPD_OVRR3_3r_SGMII_SPD_SWITCHf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_3r_SGMII_SPD_SWITCHf_SET
#define SC_X1_SPD_OVRR3_3r_CLOCKCNT0f_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_3r_CLOCKCNT0f_GET
#define SC_X1_SPD_OVRR3_3r_CLOCKCNT0f_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_3r_CLOCKCNT0f_SET
#define READ_SC_X1_SPD_OVRR3_3r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR3_3r
#define WRITE_SC_X1_SPD_OVRR3_3r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR3_3r
#define MODIFY_SC_X1_SPD_OVRR3_3r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR3_3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR3_4
 * BLOCKS:   SC_X1_SPEED_OVERRIDE3
 * REGADDR:  0x92a6
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CLOCKCNT1        clock count 1 for credit programming, range 4 to 12
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_4r (0x001092a6 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_4r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR3_4.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_4r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr3_4[1];
	uint32_t _sc_x1_spd_ovrr3_4;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_4r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_4r_CLR(r) (r).sc_x1_spd_ovrr3_4[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_4r_SET(r,d) (r).sc_x1_spd_ovrr3_4[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_4r_GET(r) (r).sc_x1_spd_ovrr3_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_4r_CLOCKCNT1f_GET(r) (((r).sc_x1_spd_ovrr3_4[0]) & 0xff)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_4r_CLOCKCNT1f_SET(r,f) (r).sc_x1_spd_ovrr3_4[0]=(((r).sc_x1_spd_ovrr3_4[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR3_4.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR3_4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_4r,(_r._sc_x1_spd_ovrr3_4))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR3_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_4r,(_r._sc_x1_spd_ovrr3_4)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR3_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_4r,(_r._sc_x1_spd_ovrr3_4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR3_4r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_4r
#define SC_X1_SPD_OVRR3_4r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_4r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_4r_t SC_X1_SPD_OVRR3_4r_t;
#define SC_X1_SPD_OVRR3_4r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_4r_CLR
#define SC_X1_SPD_OVRR3_4r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_4r_SET
#define SC_X1_SPD_OVRR3_4r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_4r_GET
#define SC_X1_SPD_OVRR3_4r_CLOCKCNT1f_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_4r_CLOCKCNT1f_GET
#define SC_X1_SPD_OVRR3_4r_CLOCKCNT1f_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_4r_CLOCKCNT1f_SET
#define READ_SC_X1_SPD_OVRR3_4r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR3_4r
#define WRITE_SC_X1_SPD_OVRR3_4r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR3_4r
#define MODIFY_SC_X1_SPD_OVRR3_4r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR3_4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR3_5
 * BLOCKS:   SC_X1_SPEED_OVERRIDE3
 * REGADDR:  0x92a7
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LOOPCNT1         loop count 1 for credit programming, range 2 to 18
 *     LOOPCNT0         loop count 0 for credit programming, range 1 to 1
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_5r (0x001092a7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_5r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR3_5.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_5r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr3_5[1];
	uint32_t _sc_x1_spd_ovrr3_5;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_5r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_5r_CLR(r) (r).sc_x1_spd_ovrr3_5[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_5r_SET(r,d) (r).sc_x1_spd_ovrr3_5[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_5r_GET(r) (r).sc_x1_spd_ovrr3_5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_5r_LOOPCNT0f_GET(r) ((((r).sc_x1_spd_ovrr3_5[0]) >> 6) & 0xff)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_5r_LOOPCNT0f_SET(r,f) (r).sc_x1_spd_ovrr3_5[0]=(((r).sc_x1_spd_ovrr3_5[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6)) | (255 << (16 + 6))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_5r_LOOPCNT1f_GET(r) (((r).sc_x1_spd_ovrr3_5[0]) & 0x3f)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_5r_LOOPCNT1f_SET(r,f) (r).sc_x1_spd_ovrr3_5[0]=(((r).sc_x1_spd_ovrr3_5[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR3_5.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR3_5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_5r,(_r._sc_x1_spd_ovrr3_5))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR3_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_5r,(_r._sc_x1_spd_ovrr3_5)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR3_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_5r,(_r._sc_x1_spd_ovrr3_5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR3_5r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_5r
#define SC_X1_SPD_OVRR3_5r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_5r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_5r_t SC_X1_SPD_OVRR3_5r_t;
#define SC_X1_SPD_OVRR3_5r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_5r_CLR
#define SC_X1_SPD_OVRR3_5r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_5r_SET
#define SC_X1_SPD_OVRR3_5r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_5r_GET
#define SC_X1_SPD_OVRR3_5r_LOOPCNT0f_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_5r_LOOPCNT0f_GET
#define SC_X1_SPD_OVRR3_5r_LOOPCNT0f_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_5r_LOOPCNT0f_SET
#define SC_X1_SPD_OVRR3_5r_LOOPCNT1f_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_5r_LOOPCNT1f_GET
#define SC_X1_SPD_OVRR3_5r_LOOPCNT1f_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_5r_LOOPCNT1f_SET
#define READ_SC_X1_SPD_OVRR3_5r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR3_5r
#define WRITE_SC_X1_SPD_OVRR3_5r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR3_5r
#define MODIFY_SC_X1_SPD_OVRR3_5r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR3_5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR3_6
 * BLOCKS:   SC_X1_SPEED_OVERRIDE3
 * REGADDR:  0x92a8
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MAC_CREDITGENCNT CGC for mac credit generation, range 1 to 2063
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_6r (0x001092a8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_6r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR3_6.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_6r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr3_6[1];
	uint32_t _sc_x1_spd_ovrr3_6;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_6r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_6r_CLR(r) (r).sc_x1_spd_ovrr3_6[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_6r_SET(r,d) (r).sc_x1_spd_ovrr3_6[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_6r_GET(r) (r).sc_x1_spd_ovrr3_6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_6r_MAC_CREDITGENCNTf_GET(r) (((r).sc_x1_spd_ovrr3_6[0]) & 0x1fff)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_6r_MAC_CREDITGENCNTf_SET(r,f) (r).sc_x1_spd_ovrr3_6[0]=(((r).sc_x1_spd_ovrr3_6[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR3_6.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR3_6r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_6r,(_r._sc_x1_spd_ovrr3_6))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR3_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_6r,(_r._sc_x1_spd_ovrr3_6)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR3_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_6r,(_r._sc_x1_spd_ovrr3_6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR3_6r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_6r
#define SC_X1_SPD_OVRR3_6r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_6r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_6r_t SC_X1_SPD_OVRR3_6r_t;
#define SC_X1_SPD_OVRR3_6r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_6r_CLR
#define SC_X1_SPD_OVRR3_6r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_6r_SET
#define SC_X1_SPD_OVRR3_6r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_6r_GET
#define SC_X1_SPD_OVRR3_6r_MAC_CREDITGENCNTf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_6r_MAC_CREDITGENCNTf_GET
#define SC_X1_SPD_OVRR3_6r_MAC_CREDITGENCNTf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_6r_MAC_CREDITGENCNTf_SET
#define READ_SC_X1_SPD_OVRR3_6r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR3_6r
#define WRITE_SC_X1_SPD_OVRR3_6r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR3_6r
#define MODIFY_SC_X1_SPD_OVRR3_6r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR3_6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR3_7
 * BLOCKS:   SC_X1_SPEED_OVERRIDE3
 * REGADDR:  0x92a9
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_CLOCKCNT0    pcs clock count 0 for credit programming, range 5 to 4125
 *     PCS_CREDITENABLE Enables credits to be generated for the PCS.  Only used in 10M or 100M modes.
 *     REPLICATION_CNT  Set to one (1) for 10M and zero (0) for 100M
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_7r (0x001092a9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_7r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR3_7.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_7r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr3_7[1];
	uint32_t _sc_x1_spd_ovrr3_7;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_7r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_7r_CLR(r) (r).sc_x1_spd_ovrr3_7[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_7r_SET(r,d) (r).sc_x1_spd_ovrr3_7[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_7r_GET(r) (r).sc_x1_spd_ovrr3_7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_7r_REPLICATION_CNTf_GET(r) ((((r).sc_x1_spd_ovrr3_7[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_7r_REPLICATION_CNTf_SET(r,f) (r).sc_x1_spd_ovrr3_7[0]=(((r).sc_x1_spd_ovrr3_7[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_7r_PCS_CREDITENABLEf_GET(r) ((((r).sc_x1_spd_ovrr3_7[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_7r_PCS_CREDITENABLEf_SET(r,f) (r).sc_x1_spd_ovrr3_7[0]=(((r).sc_x1_spd_ovrr3_7[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_7r_PCS_CLOCKCNT0f_GET(r) (((r).sc_x1_spd_ovrr3_7[0]) & 0x3fff)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_7r_PCS_CLOCKCNT0f_SET(r,f) (r).sc_x1_spd_ovrr3_7[0]=(((r).sc_x1_spd_ovrr3_7[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR3_7.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR3_7r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_7r,(_r._sc_x1_spd_ovrr3_7))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR3_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_7r,(_r._sc_x1_spd_ovrr3_7)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR3_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_7r,(_r._sc_x1_spd_ovrr3_7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR3_7r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_7r
#define SC_X1_SPD_OVRR3_7r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_7r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_7r_t SC_X1_SPD_OVRR3_7r_t;
#define SC_X1_SPD_OVRR3_7r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_7r_CLR
#define SC_X1_SPD_OVRR3_7r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_7r_SET
#define SC_X1_SPD_OVRR3_7r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_7r_GET
#define SC_X1_SPD_OVRR3_7r_REPLICATION_CNTf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_7r_REPLICATION_CNTf_GET
#define SC_X1_SPD_OVRR3_7r_REPLICATION_CNTf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_7r_REPLICATION_CNTf_SET
#define SC_X1_SPD_OVRR3_7r_PCS_CREDITENABLEf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_7r_PCS_CREDITENABLEf_GET
#define SC_X1_SPD_OVRR3_7r_PCS_CREDITENABLEf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_7r_PCS_CREDITENABLEf_SET
#define SC_X1_SPD_OVRR3_7r_PCS_CLOCKCNT0f_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_7r_PCS_CLOCKCNT0f_GET
#define SC_X1_SPD_OVRR3_7r_PCS_CLOCKCNT0f_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_7r_PCS_CLOCKCNT0f_SET
#define READ_SC_X1_SPD_OVRR3_7r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR3_7r
#define WRITE_SC_X1_SPD_OVRR3_7r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR3_7r
#define MODIFY_SC_X1_SPD_OVRR3_7r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR3_7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X1_SPD_OVRR3_8
 * BLOCKS:   SC_X1_SPEED_OVERRIDE3
 * REGADDR:  0x92aa
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_CREDITGENCNT CGC for pcs credit generation, range 1 to 2063
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_8r (0x001092aa | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_8r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR3_8.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_8r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr3_8[1];
	uint32_t _sc_x1_spd_ovrr3_8;
} BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_8r_t;

#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_8r_CLR(r) (r).sc_x1_spd_ovrr3_8[0] = 0
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_8r_SET(r,d) (r).sc_x1_spd_ovrr3_8[0] = d
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_8r_GET(r) (r).sc_x1_spd_ovrr3_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_8r_PCS_CREDITGENCNTf_GET(r) (((r).sc_x1_spd_ovrr3_8[0]) & 0x1fff)
#define BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_8r_PCS_CREDITGENCNTf_SET(r,f) (r).sc_x1_spd_ovrr3_8[0]=(((r).sc_x1_spd_ovrr3_8[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR3_8.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR3_8r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_8r,(_r._sc_x1_spd_ovrr3_8))
#define BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR3_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_8r,(_r._sc_x1_spd_ovrr3_8)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR3_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_8r,(_r._sc_x1_spd_ovrr3_8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR3_8r BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_8r
#define SC_X1_SPD_OVRR3_8r_SIZE BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_8r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_8r_t SC_X1_SPD_OVRR3_8r_t;
#define SC_X1_SPD_OVRR3_8r_CLR BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_8r_CLR
#define SC_X1_SPD_OVRR3_8r_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_8r_SET
#define SC_X1_SPD_OVRR3_8r_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_8r_GET
#define SC_X1_SPD_OVRR3_8r_PCS_CREDITGENCNTf_GET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_8r_PCS_CREDITGENCNTf_GET
#define SC_X1_SPD_OVRR3_8r_PCS_CREDITGENCNTf_SET BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_8r_PCS_CREDITGENCNTf_SET
#define READ_SC_X1_SPD_OVRR3_8r BCMI_TSCE16_XGXS_READ_SC_X1_SPD_OVRR3_8r
#define WRITE_SC_X1_SPD_OVRR3_8r BCMI_TSCE16_XGXS_WRITE_SC_X1_SPD_OVRR3_8r
#define MODIFY_SC_X1_SPD_OVRR3_8r BCMI_TSCE16_XGXS_MODIFY_SC_X1_SPD_OVRR3_8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X1_SPD_OVRR3_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_X2_MLD_SWP_CNT
 * BLOCKS:   TX_X2_CONTROL0
 * REGADDR:  0xa000
 * DESC:     Swap Count register
 * RESETVAL: 0xfffc (65532)
 * ACCESS:   R/W
 * FIELDS:
 *     MLD_SWAP_COUNT   Number of blocks between insertion of ||A|| per PORTProgram the register assuming 40G speed.Hardware adjusts the value for 20G, 100G and 120G speeds.For 20G the programmed value is devided by 2, for 100G the value is multiplied by 5 and for 120G the value is multiplied by 6.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_X2_MLD_SWP_CNTr (0x0020a000 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_X2_MLD_SWP_CNTr_SIZE 4

/*
 * This structure should be used to declare and program TX_X2_MLD_SWP_CNT.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_X2_MLD_SWP_CNTr_s {
	uint32_t v[1];
	uint32_t tx_x2_mld_swp_cnt[1];
	uint32_t _tx_x2_mld_swp_cnt;
} BCMI_TSCE16_XGXS_TX_X2_MLD_SWP_CNTr_t;

#define BCMI_TSCE16_XGXS_TX_X2_MLD_SWP_CNTr_CLR(r) (r).tx_x2_mld_swp_cnt[0] = 0
#define BCMI_TSCE16_XGXS_TX_X2_MLD_SWP_CNTr_SET(r,d) (r).tx_x2_mld_swp_cnt[0] = d
#define BCMI_TSCE16_XGXS_TX_X2_MLD_SWP_CNTr_GET(r) (r).tx_x2_mld_swp_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_X2_MLD_SWP_CNTr_MLD_SWAP_COUNTf_GET(r) (((r).tx_x2_mld_swp_cnt[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_TX_X2_MLD_SWP_CNTr_MLD_SWAP_COUNTf_SET(r,f) (r).tx_x2_mld_swp_cnt[0]=(((r).tx_x2_mld_swp_cnt[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TX_X2_MLD_SWP_CNT.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_X2_MLD_SWP_CNTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_X2_MLD_SWP_CNTr,(_r._tx_x2_mld_swp_cnt))
#define BCMI_TSCE16_XGXS_WRITE_TX_X2_MLD_SWP_CNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X2_MLD_SWP_CNTr,(_r._tx_x2_mld_swp_cnt)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_X2_MLD_SWP_CNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X2_MLD_SWP_CNTr,(_r._tx_x2_mld_swp_cnt))
#define BCMI_TSCE16_XGXS_READLN_TX_X2_MLD_SWP_CNTr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_X2_MLD_SWP_CNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x2_mld_swp_cnt))
#define BCMI_TSCE16_XGXS_WRITELN_TX_X2_MLD_SWP_CNTr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X2_MLD_SWP_CNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x2_mld_swp_cnt))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_X2_MLD_SWP_CNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X2_MLD_SWP_CNTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x2_mld_swp_cnt))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X2_MLD_SWP_CNTr BCMI_TSCE16_XGXS_TX_X2_MLD_SWP_CNTr
#define TX_X2_MLD_SWP_CNTr_SIZE BCMI_TSCE16_XGXS_TX_X2_MLD_SWP_CNTr_SIZE
typedef BCMI_TSCE16_XGXS_TX_X2_MLD_SWP_CNTr_t TX_X2_MLD_SWP_CNTr_t;
#define TX_X2_MLD_SWP_CNTr_CLR BCMI_TSCE16_XGXS_TX_X2_MLD_SWP_CNTr_CLR
#define TX_X2_MLD_SWP_CNTr_SET BCMI_TSCE16_XGXS_TX_X2_MLD_SWP_CNTr_SET
#define TX_X2_MLD_SWP_CNTr_GET BCMI_TSCE16_XGXS_TX_X2_MLD_SWP_CNTr_GET
#define TX_X2_MLD_SWP_CNTr_MLD_SWAP_COUNTf_GET BCMI_TSCE16_XGXS_TX_X2_MLD_SWP_CNTr_MLD_SWAP_COUNTf_GET
#define TX_X2_MLD_SWP_CNTr_MLD_SWAP_COUNTf_SET BCMI_TSCE16_XGXS_TX_X2_MLD_SWP_CNTr_MLD_SWAP_COUNTf_SET
#define READ_TX_X2_MLD_SWP_CNTr BCMI_TSCE16_XGXS_READ_TX_X2_MLD_SWP_CNTr
#define WRITE_TX_X2_MLD_SWP_CNTr BCMI_TSCE16_XGXS_WRITE_TX_X2_MLD_SWP_CNTr
#define MODIFY_TX_X2_MLD_SWP_CNTr BCMI_TSCE16_XGXS_MODIFY_TX_X2_MLD_SWP_CNTr
#define READLN_TX_X2_MLD_SWP_CNTr BCMI_TSCE16_XGXS_READLN_TX_X2_MLD_SWP_CNTr
#define WRITELN_TX_X2_MLD_SWP_CNTr BCMI_TSCE16_XGXS_WRITELN_TX_X2_MLD_SWP_CNTr
#define WRITEALL_TX_X2_MLD_SWP_CNTr BCMI_TSCE16_XGXS_WRITEALL_TX_X2_MLD_SWP_CNTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_X2_MLD_SWP_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_X2_CL48_0
 * BLOCKS:   TX_X2_CONTROL0
 * REGADDR:  0xa001
 * DESC:     CL48 register
 * RESETVAL: 0x8030 (32816)
 * ACCESS:   R/W
 * FIELDS:
 *     CL48_TX_QRSVDCTRL For each bit set in this control swap the ordered set byte withthe RX_X2_Control0_qrsvd_0.QrsvdSwap byte, for the TX PCS.For CL48 only
 *     CL48_TX_RF_ENABLE If this bit is a one, RFs are passed from the RS LAYER to the PCS.If this bit is a zero, RFs are replaced by IDLEs which are then passedfrom the RS LAYER to the PCS.For CL48 only.
 *     CL48_TX_LF_ENABLE If this bit is a one, LFs are passed from the RS LAYER to the PCS.If this bit is a zero, LFs are replaced by IDLEs which are then passedfrom the RS LAYER to the PCS.For CL48 only.
 *     CL48_TX_LI_ENABLE If this bit is a one, LIs (Link Interrupt) are passed from the RS LAYER to the encoder.If this bit is a zero, LIs are replaced by IDLEs which are then passedfrom the RS LAYER to the encoder.For CL48 only.
 *     BRCM_MODE_USE_K20PT5 Enable inserting /K20.5/ instead of /D20.5/ when LPI are encoded/decoded
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_X2_CL48_0r (0x0020a001 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_X2_CL48_0r_SIZE 4

/*
 * This structure should be used to declare and program TX_X2_CL48_0.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_X2_CL48_0r_s {
	uint32_t v[1];
	uint32_t tx_x2_cl48_0[1];
	uint32_t _tx_x2_cl48_0;
} BCMI_TSCE16_XGXS_TX_X2_CL48_0r_t;

#define BCMI_TSCE16_XGXS_TX_X2_CL48_0r_CLR(r) (r).tx_x2_cl48_0[0] = 0
#define BCMI_TSCE16_XGXS_TX_X2_CL48_0r_SET(r,d) (r).tx_x2_cl48_0[0] = d
#define BCMI_TSCE16_XGXS_TX_X2_CL48_0r_GET(r) (r).tx_x2_cl48_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_X2_CL48_0r_BRCM_MODE_USE_K20PT5f_GET(r) ((((r).tx_x2_cl48_0[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X2_CL48_0r_BRCM_MODE_USE_K20PT5f_SET(r,f) (r).tx_x2_cl48_0[0]=(((r).tx_x2_cl48_0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_TX_X2_CL48_0r_CL48_TX_LI_ENABLEf_GET(r) ((((r).tx_x2_cl48_0[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X2_CL48_0r_CL48_TX_LI_ENABLEf_SET(r,f) (r).tx_x2_cl48_0[0]=(((r).tx_x2_cl48_0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_TX_X2_CL48_0r_CL48_TX_LF_ENABLEf_GET(r) ((((r).tx_x2_cl48_0[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X2_CL48_0r_CL48_TX_LF_ENABLEf_SET(r,f) (r).tx_x2_cl48_0[0]=(((r).tx_x2_cl48_0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_TX_X2_CL48_0r_CL48_TX_RF_ENABLEf_GET(r) ((((r).tx_x2_cl48_0[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X2_CL48_0r_CL48_TX_RF_ENABLEf_SET(r,f) (r).tx_x2_cl48_0[0]=(((r).tx_x2_cl48_0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_TX_X2_CL48_0r_CL48_TX_QRSVDCTRLf_GET(r) (((r).tx_x2_cl48_0[0]) & 0xf)
#define BCMI_TSCE16_XGXS_TX_X2_CL48_0r_CL48_TX_QRSVDCTRLf_SET(r,f) (r).tx_x2_cl48_0[0]=(((r).tx_x2_cl48_0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access TX_X2_CL48_0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_X2_CL48_0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_X2_CL48_0r,(_r._tx_x2_cl48_0))
#define BCMI_TSCE16_XGXS_WRITE_TX_X2_CL48_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X2_CL48_0r,(_r._tx_x2_cl48_0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_X2_CL48_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X2_CL48_0r,(_r._tx_x2_cl48_0))
#define BCMI_TSCE16_XGXS_READLN_TX_X2_CL48_0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_X2_CL48_0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x2_cl48_0))
#define BCMI_TSCE16_XGXS_WRITELN_TX_X2_CL48_0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X2_CL48_0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x2_cl48_0))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_X2_CL48_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X2_CL48_0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x2_cl48_0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X2_CL48_0r BCMI_TSCE16_XGXS_TX_X2_CL48_0r
#define TX_X2_CL48_0r_SIZE BCMI_TSCE16_XGXS_TX_X2_CL48_0r_SIZE
typedef BCMI_TSCE16_XGXS_TX_X2_CL48_0r_t TX_X2_CL48_0r_t;
#define TX_X2_CL48_0r_CLR BCMI_TSCE16_XGXS_TX_X2_CL48_0r_CLR
#define TX_X2_CL48_0r_SET BCMI_TSCE16_XGXS_TX_X2_CL48_0r_SET
#define TX_X2_CL48_0r_GET BCMI_TSCE16_XGXS_TX_X2_CL48_0r_GET
#define TX_X2_CL48_0r_BRCM_MODE_USE_K20PT5f_GET BCMI_TSCE16_XGXS_TX_X2_CL48_0r_BRCM_MODE_USE_K20PT5f_GET
#define TX_X2_CL48_0r_BRCM_MODE_USE_K20PT5f_SET BCMI_TSCE16_XGXS_TX_X2_CL48_0r_BRCM_MODE_USE_K20PT5f_SET
#define TX_X2_CL48_0r_CL48_TX_LI_ENABLEf_GET BCMI_TSCE16_XGXS_TX_X2_CL48_0r_CL48_TX_LI_ENABLEf_GET
#define TX_X2_CL48_0r_CL48_TX_LI_ENABLEf_SET BCMI_TSCE16_XGXS_TX_X2_CL48_0r_CL48_TX_LI_ENABLEf_SET
#define TX_X2_CL48_0r_CL48_TX_LF_ENABLEf_GET BCMI_TSCE16_XGXS_TX_X2_CL48_0r_CL48_TX_LF_ENABLEf_GET
#define TX_X2_CL48_0r_CL48_TX_LF_ENABLEf_SET BCMI_TSCE16_XGXS_TX_X2_CL48_0r_CL48_TX_LF_ENABLEf_SET
#define TX_X2_CL48_0r_CL48_TX_RF_ENABLEf_GET BCMI_TSCE16_XGXS_TX_X2_CL48_0r_CL48_TX_RF_ENABLEf_GET
#define TX_X2_CL48_0r_CL48_TX_RF_ENABLEf_SET BCMI_TSCE16_XGXS_TX_X2_CL48_0r_CL48_TX_RF_ENABLEf_SET
#define TX_X2_CL48_0r_CL48_TX_QRSVDCTRLf_GET BCMI_TSCE16_XGXS_TX_X2_CL48_0r_CL48_TX_QRSVDCTRLf_GET
#define TX_X2_CL48_0r_CL48_TX_QRSVDCTRLf_SET BCMI_TSCE16_XGXS_TX_X2_CL48_0r_CL48_TX_QRSVDCTRLf_SET
#define READ_TX_X2_CL48_0r BCMI_TSCE16_XGXS_READ_TX_X2_CL48_0r
#define WRITE_TX_X2_CL48_0r BCMI_TSCE16_XGXS_WRITE_TX_X2_CL48_0r
#define MODIFY_TX_X2_CL48_0r BCMI_TSCE16_XGXS_MODIFY_TX_X2_CL48_0r
#define READLN_TX_X2_CL48_0r BCMI_TSCE16_XGXS_READLN_TX_X2_CL48_0r
#define WRITELN_TX_X2_CL48_0r BCMI_TSCE16_XGXS_WRITELN_TX_X2_CL48_0r
#define WRITEALL_TX_X2_CL48_0r BCMI_TSCE16_XGXS_WRITEALL_TX_X2_CL48_0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_X2_CL48_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_X2_CL82_0
 * BLOCKS:   TX_X2_CONTROL0
 * REGADDR:  0xa002
 * DESC:     CL82 register
 * RESETVAL: 0x70 (112)
 * ACCESS:   R/W
 * FIELDS:
 *     CL82_TX_RF_ENABLE If this bit is a one, RFs are passed from the RS LAYER to the PCS.If this bit is a zero, RFs are replaced by IDLEs which are then passedto the PCS.For CL82 only.
 *     CL82_TX_LF_ENABLE If this bit is a one, LFs are passed from the RS LAYER to the PCS.If this bit is a zero, LFs are replaced by IDLEs which are then passedto the PCS.For CL82 only.
 *     CL82_TX_LI_ENABLE If this bit is a one, LIs (Link Interrupt) are passed thru to the RS LAYER.If this bit is a zero, LIs (Link Interrupt) are replaced by IDLEs which are then passedto the RS LAYER.For CL82 only.
 *     CL82_BYPASS_TXSM Bypass cl82 transmit state machine1 = Bypass cl82 txsm :- force TX_INIT state- pass the data from the table look-up decoder to the output0 = normal mode
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_X2_CL82_0r (0x0020a002 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_X2_CL82_0r_SIZE 4

/*
 * This structure should be used to declare and program TX_X2_CL82_0.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_X2_CL82_0r_s {
	uint32_t v[1];
	uint32_t tx_x2_cl82_0[1];
	uint32_t _tx_x2_cl82_0;
} BCMI_TSCE16_XGXS_TX_X2_CL82_0r_t;

#define BCMI_TSCE16_XGXS_TX_X2_CL82_0r_CLR(r) (r).tx_x2_cl82_0[0] = 0
#define BCMI_TSCE16_XGXS_TX_X2_CL82_0r_SET(r,d) (r).tx_x2_cl82_0[0] = d
#define BCMI_TSCE16_XGXS_TX_X2_CL82_0r_GET(r) (r).tx_x2_cl82_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_X2_CL82_0r_CL82_BYPASS_TXSMf_GET(r) ((((r).tx_x2_cl82_0[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X2_CL82_0r_CL82_BYPASS_TXSMf_SET(r,f) (r).tx_x2_cl82_0[0]=(((r).tx_x2_cl82_0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_TX_X2_CL82_0r_CL82_TX_LI_ENABLEf_GET(r) ((((r).tx_x2_cl82_0[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X2_CL82_0r_CL82_TX_LI_ENABLEf_SET(r,f) (r).tx_x2_cl82_0[0]=(((r).tx_x2_cl82_0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_TX_X2_CL82_0r_CL82_TX_LF_ENABLEf_GET(r) ((((r).tx_x2_cl82_0[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X2_CL82_0r_CL82_TX_LF_ENABLEf_SET(r,f) (r).tx_x2_cl82_0[0]=(((r).tx_x2_cl82_0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_TX_X2_CL82_0r_CL82_TX_RF_ENABLEf_GET(r) ((((r).tx_x2_cl82_0[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X2_CL82_0r_CL82_TX_RF_ENABLEf_SET(r,f) (r).tx_x2_cl82_0[0]=(((r).tx_x2_cl82_0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))

/*
 * These macros can be used to access TX_X2_CL82_0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_X2_CL82_0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_X2_CL82_0r,(_r._tx_x2_cl82_0))
#define BCMI_TSCE16_XGXS_WRITE_TX_X2_CL82_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X2_CL82_0r,(_r._tx_x2_cl82_0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_X2_CL82_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X2_CL82_0r,(_r._tx_x2_cl82_0))
#define BCMI_TSCE16_XGXS_READLN_TX_X2_CL82_0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_X2_CL82_0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x2_cl82_0))
#define BCMI_TSCE16_XGXS_WRITELN_TX_X2_CL82_0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X2_CL82_0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x2_cl82_0))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_X2_CL82_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X2_CL82_0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x2_cl82_0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X2_CL82_0r BCMI_TSCE16_XGXS_TX_X2_CL82_0r
#define TX_X2_CL82_0r_SIZE BCMI_TSCE16_XGXS_TX_X2_CL82_0r_SIZE
typedef BCMI_TSCE16_XGXS_TX_X2_CL82_0r_t TX_X2_CL82_0r_t;
#define TX_X2_CL82_0r_CLR BCMI_TSCE16_XGXS_TX_X2_CL82_0r_CLR
#define TX_X2_CL82_0r_SET BCMI_TSCE16_XGXS_TX_X2_CL82_0r_SET
#define TX_X2_CL82_0r_GET BCMI_TSCE16_XGXS_TX_X2_CL82_0r_GET
#define TX_X2_CL82_0r_CL82_BYPASS_TXSMf_GET BCMI_TSCE16_XGXS_TX_X2_CL82_0r_CL82_BYPASS_TXSMf_GET
#define TX_X2_CL82_0r_CL82_BYPASS_TXSMf_SET BCMI_TSCE16_XGXS_TX_X2_CL82_0r_CL82_BYPASS_TXSMf_SET
#define TX_X2_CL82_0r_CL82_TX_LI_ENABLEf_GET BCMI_TSCE16_XGXS_TX_X2_CL82_0r_CL82_TX_LI_ENABLEf_GET
#define TX_X2_CL82_0r_CL82_TX_LI_ENABLEf_SET BCMI_TSCE16_XGXS_TX_X2_CL82_0r_CL82_TX_LI_ENABLEf_SET
#define TX_X2_CL82_0r_CL82_TX_LF_ENABLEf_GET BCMI_TSCE16_XGXS_TX_X2_CL82_0r_CL82_TX_LF_ENABLEf_GET
#define TX_X2_CL82_0r_CL82_TX_LF_ENABLEf_SET BCMI_TSCE16_XGXS_TX_X2_CL82_0r_CL82_TX_LF_ENABLEf_SET
#define TX_X2_CL82_0r_CL82_TX_RF_ENABLEf_GET BCMI_TSCE16_XGXS_TX_X2_CL82_0r_CL82_TX_RF_ENABLEf_GET
#define TX_X2_CL82_0r_CL82_TX_RF_ENABLEf_SET BCMI_TSCE16_XGXS_TX_X2_CL82_0r_CL82_TX_RF_ENABLEf_SET
#define READ_TX_X2_CL82_0r BCMI_TSCE16_XGXS_READ_TX_X2_CL82_0r
#define WRITE_TX_X2_CL82_0r BCMI_TSCE16_XGXS_WRITE_TX_X2_CL82_0r
#define MODIFY_TX_X2_CL82_0r BCMI_TSCE16_XGXS_MODIFY_TX_X2_CL82_0r
#define READLN_TX_X2_CL82_0r BCMI_TSCE16_XGXS_READLN_TX_X2_CL82_0r
#define WRITELN_TX_X2_CL82_0r BCMI_TSCE16_XGXS_WRITELN_TX_X2_CL82_0r
#define WRITEALL_TX_X2_CL82_0r BCMI_TSCE16_XGXS_WRITEALL_TX_X2_CL82_0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_X2_CL82_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_X2_BRCM_MODE
 * BLOCKS:   TX_X2_CONTROL0
 * REGADDR:  0xa003
 * DESC:     BROADCOM 64/66 ACOL INSERTION COUNT
 * RESETVAL: 0x64 (100)
 * ACCESS:   R/W
 * FIELDS:
 *     ACOL_SWAP_COUNT64B66B It is used to add extra |A| column spacing (add to pseudo random of 16 to 31 spacing)For normal cl48 mode, the count is 0.For BRCM mode, the count is 8'h64.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_X2_BRCM_MODEr (0x0020a003 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_X2_BRCM_MODEr_SIZE 4

/*
 * This structure should be used to declare and program TX_X2_BRCM_MODE.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_X2_BRCM_MODEr_s {
	uint32_t v[1];
	uint32_t tx_x2_brcm_mode[1];
	uint32_t _tx_x2_brcm_mode;
} BCMI_TSCE16_XGXS_TX_X2_BRCM_MODEr_t;

#define BCMI_TSCE16_XGXS_TX_X2_BRCM_MODEr_CLR(r) (r).tx_x2_brcm_mode[0] = 0
#define BCMI_TSCE16_XGXS_TX_X2_BRCM_MODEr_SET(r,d) (r).tx_x2_brcm_mode[0] = d
#define BCMI_TSCE16_XGXS_TX_X2_BRCM_MODEr_GET(r) (r).tx_x2_brcm_mode[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_X2_BRCM_MODEr_ACOL_SWAP_COUNT64B66Bf_GET(r) (((r).tx_x2_brcm_mode[0]) & 0xff)
#define BCMI_TSCE16_XGXS_TX_X2_BRCM_MODEr_ACOL_SWAP_COUNT64B66Bf_SET(r,f) (r).tx_x2_brcm_mode[0]=(((r).tx_x2_brcm_mode[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access TX_X2_BRCM_MODE.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_X2_BRCM_MODEr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_X2_BRCM_MODEr,(_r._tx_x2_brcm_mode))
#define BCMI_TSCE16_XGXS_WRITE_TX_X2_BRCM_MODEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X2_BRCM_MODEr,(_r._tx_x2_brcm_mode)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_X2_BRCM_MODEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X2_BRCM_MODEr,(_r._tx_x2_brcm_mode))
#define BCMI_TSCE16_XGXS_READLN_TX_X2_BRCM_MODEr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_X2_BRCM_MODEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x2_brcm_mode))
#define BCMI_TSCE16_XGXS_WRITELN_TX_X2_BRCM_MODEr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X2_BRCM_MODEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x2_brcm_mode))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_X2_BRCM_MODEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X2_BRCM_MODEr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x2_brcm_mode))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X2_BRCM_MODEr BCMI_TSCE16_XGXS_TX_X2_BRCM_MODEr
#define TX_X2_BRCM_MODEr_SIZE BCMI_TSCE16_XGXS_TX_X2_BRCM_MODEr_SIZE
typedef BCMI_TSCE16_XGXS_TX_X2_BRCM_MODEr_t TX_X2_BRCM_MODEr_t;
#define TX_X2_BRCM_MODEr_CLR BCMI_TSCE16_XGXS_TX_X2_BRCM_MODEr_CLR
#define TX_X2_BRCM_MODEr_SET BCMI_TSCE16_XGXS_TX_X2_BRCM_MODEr_SET
#define TX_X2_BRCM_MODEr_GET BCMI_TSCE16_XGXS_TX_X2_BRCM_MODEr_GET
#define TX_X2_BRCM_MODEr_ACOL_SWAP_COUNT64B66Bf_GET BCMI_TSCE16_XGXS_TX_X2_BRCM_MODEr_ACOL_SWAP_COUNT64B66Bf_GET
#define TX_X2_BRCM_MODEr_ACOL_SWAP_COUNT64B66Bf_SET BCMI_TSCE16_XGXS_TX_X2_BRCM_MODEr_ACOL_SWAP_COUNT64B66Bf_SET
#define READ_TX_X2_BRCM_MODEr BCMI_TSCE16_XGXS_READ_TX_X2_BRCM_MODEr
#define WRITE_TX_X2_BRCM_MODEr BCMI_TSCE16_XGXS_WRITE_TX_X2_BRCM_MODEr
#define MODIFY_TX_X2_BRCM_MODEr BCMI_TSCE16_XGXS_MODIFY_TX_X2_BRCM_MODEr
#define READLN_TX_X2_BRCM_MODEr BCMI_TSCE16_XGXS_READLN_TX_X2_BRCM_MODEr
#define WRITELN_TX_X2_BRCM_MODEr BCMI_TSCE16_XGXS_WRITELN_TX_X2_BRCM_MODEr
#define WRITEALL_TX_X2_BRCM_MODEr BCMI_TSCE16_XGXS_WRITEALL_TX_X2_BRCM_MODEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_X2_BRCM_MODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_X2_CL82_TX_STS0
 * BLOCKS:   TX_X2_STATUS0
 * REGADDR:  0xa011
 * DESC:     CL82 Status 0 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TXSM_STATE       Transmit SM - current state3'b110 - TX_HIG_END3'b101 - TX_HIG_START3'b100 - TX_E3'b011 - TX_T3'b010 - TX_D3'b001 - TX_C3'b000 - TX_INIT
 *     LTXSM_STATE      Transmit SM - latched states - latched on entrybit 9 - TX_HIG_ENDbit 8 - TX_HIG_STARTbit 7 - TX_Ebit 6 - TX_Tbit 5 - TX_Dbit 4 - TX_Cbit 3 - TX_INITNOTE: THIS FIELD IS CLEAR ON READ
 *     T_TYPE_CODED     Transmit SM - current t_type3'b101 - T_TYPE_B13'b100 - T_TYPE_C3'b011 - T_TYPE_S3'b010 - T_TYPE_T3'b001 - T_TYPE_D3'b000 - T_TYPE_E
 *     CL82_IDLE_DELETION_UNDERFLOW Not enough IPG between ||A|| in MLD mode.Clear on read.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r (0x0020a011 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r_SIZE 4

/*
 * This structure should be used to declare and program TX_X2_CL82_TX_STS0.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r_s {
	uint32_t v[1];
	uint32_t tx_x2_cl82_tx_sts0[1];
	uint32_t _tx_x2_cl82_tx_sts0;
} BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r_t;

#define BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r_CLR(r) (r).tx_x2_cl82_tx_sts0[0] = 0
#define BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r_SET(r,d) (r).tx_x2_cl82_tx_sts0[0] = d
#define BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r_GET(r) (r).tx_x2_cl82_tx_sts0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r_CL82_IDLE_DELETION_UNDERFLOWf_GET(r) ((((r).tx_x2_cl82_tx_sts0[0]) >> 13) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r_CL82_IDLE_DELETION_UNDERFLOWf_SET(r,f) (r).tx_x2_cl82_tx_sts0[0]=(((r).tx_x2_cl82_tx_sts0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r_T_TYPE_CODEDf_GET(r) ((((r).tx_x2_cl82_tx_sts0[0]) >> 10) & 0x7)
#define BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r_T_TYPE_CODEDf_SET(r,f) (r).tx_x2_cl82_tx_sts0[0]=(((r).tx_x2_cl82_tx_sts0[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10)) | (7 << (16 + 10))
#define BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r_LTXSM_STATEf_GET(r) ((((r).tx_x2_cl82_tx_sts0[0]) >> 3) & 0x7f)
#define BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r_LTXSM_STATEf_SET(r,f) (r).tx_x2_cl82_tx_sts0[0]=(((r).tx_x2_cl82_tx_sts0[0] & ~((uint32_t)0x7f << 3)) | ((((uint32_t)f) & 0x7f) << 3)) | (127 << (16 + 3))
#define BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r_TXSM_STATEf_GET(r) (((r).tx_x2_cl82_tx_sts0[0]) & 0x7)
#define BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r_TXSM_STATEf_SET(r,f) (r).tx_x2_cl82_tx_sts0[0]=(((r).tx_x2_cl82_tx_sts0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access TX_X2_CL82_TX_STS0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_X2_CL82_TX_STS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r,(_r._tx_x2_cl82_tx_sts0))
#define BCMI_TSCE16_XGXS_WRITE_TX_X2_CL82_TX_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r,(_r._tx_x2_cl82_tx_sts0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_X2_CL82_TX_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r,(_r._tx_x2_cl82_tx_sts0))
#define BCMI_TSCE16_XGXS_READLN_TX_X2_CL82_TX_STS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x2_cl82_tx_sts0))
#define BCMI_TSCE16_XGXS_WRITELN_TX_X2_CL82_TX_STS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x2_cl82_tx_sts0))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_X2_CL82_TX_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x2_cl82_tx_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X2_CL82_TX_STS0r BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r
#define TX_X2_CL82_TX_STS0r_SIZE BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r_SIZE
typedef BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r_t TX_X2_CL82_TX_STS0r_t;
#define TX_X2_CL82_TX_STS0r_CLR BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r_CLR
#define TX_X2_CL82_TX_STS0r_SET BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r_SET
#define TX_X2_CL82_TX_STS0r_GET BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r_GET
#define TX_X2_CL82_TX_STS0r_CL82_IDLE_DELETION_UNDERFLOWf_GET BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r_CL82_IDLE_DELETION_UNDERFLOWf_GET
#define TX_X2_CL82_TX_STS0r_CL82_IDLE_DELETION_UNDERFLOWf_SET BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r_CL82_IDLE_DELETION_UNDERFLOWf_SET
#define TX_X2_CL82_TX_STS0r_T_TYPE_CODEDf_GET BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r_T_TYPE_CODEDf_GET
#define TX_X2_CL82_TX_STS0r_T_TYPE_CODEDf_SET BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r_T_TYPE_CODEDf_SET
#define TX_X2_CL82_TX_STS0r_LTXSM_STATEf_GET BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r_LTXSM_STATEf_GET
#define TX_X2_CL82_TX_STS0r_LTXSM_STATEf_SET BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r_LTXSM_STATEf_SET
#define TX_X2_CL82_TX_STS0r_TXSM_STATEf_GET BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r_TXSM_STATEf_GET
#define TX_X2_CL82_TX_STS0r_TXSM_STATEf_SET BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r_TXSM_STATEf_SET
#define READ_TX_X2_CL82_TX_STS0r BCMI_TSCE16_XGXS_READ_TX_X2_CL82_TX_STS0r
#define WRITE_TX_X2_CL82_TX_STS0r BCMI_TSCE16_XGXS_WRITE_TX_X2_CL82_TX_STS0r
#define MODIFY_TX_X2_CL82_TX_STS0r BCMI_TSCE16_XGXS_MODIFY_TX_X2_CL82_TX_STS0r
#define READLN_TX_X2_CL82_TX_STS0r BCMI_TSCE16_XGXS_READLN_TX_X2_CL82_TX_STS0r
#define WRITELN_TX_X2_CL82_TX_STS0r BCMI_TSCE16_XGXS_WRITELN_TX_X2_CL82_TX_STS0r
#define WRITEALL_TX_X2_CL82_TX_STS0r BCMI_TSCE16_XGXS_WRITEALL_TX_X2_CL82_TX_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_X2_CL82_TX_STS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X2_QRSVD0
 * BLOCKS:   RX_X2_CONTROL0
 * REGADDR:  0xa020
 * DESC:     qrsvd 0 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL48_RX_QRSVDCTRL For each bit set in this control swap the ordered set byte withthe RX_X2_Control0_qrsvd_0.QrsvdSwap byte, for the RX PCS.For CL48 only
 *     QRSVDSWAP        QrsvdSwap contains the byte which may be used to replace any of the bytes within a reserved ordered set
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X2_QRSVD0r (0x0020a020 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X2_QRSVD0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X2_QRSVD0.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X2_QRSVD0r_s {
	uint32_t v[1];
	uint32_t rx_x2_qrsvd0[1];
	uint32_t _rx_x2_qrsvd0;
} BCMI_TSCE16_XGXS_RX_X2_QRSVD0r_t;

#define BCMI_TSCE16_XGXS_RX_X2_QRSVD0r_CLR(r) (r).rx_x2_qrsvd0[0] = 0
#define BCMI_TSCE16_XGXS_RX_X2_QRSVD0r_SET(r,d) (r).rx_x2_qrsvd0[0] = d
#define BCMI_TSCE16_XGXS_RX_X2_QRSVD0r_GET(r) (r).rx_x2_qrsvd0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X2_QRSVD0r_QRSVDSWAPf_GET(r) ((((r).rx_x2_qrsvd0[0]) >> 5) & 0x3ff)
#define BCMI_TSCE16_XGXS_RX_X2_QRSVD0r_QRSVDSWAPf_SET(r,f) (r).rx_x2_qrsvd0[0]=(((r).rx_x2_qrsvd0[0] & ~((uint32_t)0x3ff << 5)) | ((((uint32_t)f) & 0x3ff) << 5)) | (1023 << (16 + 5))
#define BCMI_TSCE16_XGXS_RX_X2_QRSVD0r_CL48_RX_QRSVDCTRLf_GET(r) ((((r).rx_x2_qrsvd0[0]) >> 1) & 0xf)
#define BCMI_TSCE16_XGXS_RX_X2_QRSVD0r_CL48_RX_QRSVDCTRLf_SET(r,f) (r).rx_x2_qrsvd0[0]=(((r).rx_x2_qrsvd0[0] & ~((uint32_t)0xf << 1)) | ((((uint32_t)f) & 0xf) << 1)) | (15 << (16 + 1))

/*
 * These macros can be used to access RX_X2_QRSVD0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X2_QRSVD0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X2_QRSVD0r,(_r._rx_x2_qrsvd0))
#define BCMI_TSCE16_XGXS_WRITE_RX_X2_QRSVD0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X2_QRSVD0r,(_r._rx_x2_qrsvd0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X2_QRSVD0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X2_QRSVD0r,(_r._rx_x2_qrsvd0))
#define BCMI_TSCE16_XGXS_READLN_RX_X2_QRSVD0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X2_QRSVD0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x2_qrsvd0))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X2_QRSVD0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X2_QRSVD0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x2_qrsvd0))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X2_QRSVD0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X2_QRSVD0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x2_qrsvd0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X2_QRSVD0r BCMI_TSCE16_XGXS_RX_X2_QRSVD0r
#define RX_X2_QRSVD0r_SIZE BCMI_TSCE16_XGXS_RX_X2_QRSVD0r_SIZE
typedef BCMI_TSCE16_XGXS_RX_X2_QRSVD0r_t RX_X2_QRSVD0r_t;
#define RX_X2_QRSVD0r_CLR BCMI_TSCE16_XGXS_RX_X2_QRSVD0r_CLR
#define RX_X2_QRSVD0r_SET BCMI_TSCE16_XGXS_RX_X2_QRSVD0r_SET
#define RX_X2_QRSVD0r_GET BCMI_TSCE16_XGXS_RX_X2_QRSVD0r_GET
#define RX_X2_QRSVD0r_QRSVDSWAPf_GET BCMI_TSCE16_XGXS_RX_X2_QRSVD0r_QRSVDSWAPf_GET
#define RX_X2_QRSVD0r_QRSVDSWAPf_SET BCMI_TSCE16_XGXS_RX_X2_QRSVD0r_QRSVDSWAPf_SET
#define RX_X2_QRSVD0r_CL48_RX_QRSVDCTRLf_GET BCMI_TSCE16_XGXS_RX_X2_QRSVD0r_CL48_RX_QRSVDCTRLf_GET
#define RX_X2_QRSVD0r_CL48_RX_QRSVDCTRLf_SET BCMI_TSCE16_XGXS_RX_X2_QRSVD0r_CL48_RX_QRSVDCTRLf_SET
#define READ_RX_X2_QRSVD0r BCMI_TSCE16_XGXS_READ_RX_X2_QRSVD0r
#define WRITE_RX_X2_QRSVD0r BCMI_TSCE16_XGXS_WRITE_RX_X2_QRSVD0r
#define MODIFY_RX_X2_QRSVD0r BCMI_TSCE16_XGXS_MODIFY_RX_X2_QRSVD0r
#define READLN_RX_X2_QRSVD0r BCMI_TSCE16_XGXS_READLN_RX_X2_QRSVD0r
#define WRITELN_RX_X2_QRSVD0r BCMI_TSCE16_XGXS_WRITELN_RX_X2_QRSVD0r
#define WRITEALL_RX_X2_QRSVD0r BCMI_TSCE16_XGXS_WRITEALL_RX_X2_QRSVD0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X2_QRSVD0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X2_QRSVD1
 * BLOCKS:   RX_X2_CONTROL0
 * REGADDR:  0xa021
 * DESC:     qrsvd 1 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     QRSVD2_8_2       Qrsvd2 is used to identify sequence ordered sets for which the bytes might be replaced.
 *     QRSVD1           Qrsvd1 is used to identify sequence ordered sets for which the bytes might be replaced.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X2_QRSVD1r (0x0020a021 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X2_QRSVD1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X2_QRSVD1.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X2_QRSVD1r_s {
	uint32_t v[1];
	uint32_t rx_x2_qrsvd1[1];
	uint32_t _rx_x2_qrsvd1;
} BCMI_TSCE16_XGXS_RX_X2_QRSVD1r_t;

#define BCMI_TSCE16_XGXS_RX_X2_QRSVD1r_CLR(r) (r).rx_x2_qrsvd1[0] = 0
#define BCMI_TSCE16_XGXS_RX_X2_QRSVD1r_SET(r,d) (r).rx_x2_qrsvd1[0] = d
#define BCMI_TSCE16_XGXS_RX_X2_QRSVD1r_GET(r) (r).rx_x2_qrsvd1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X2_QRSVD1r_QRSVD1f_GET(r) ((((r).rx_x2_qrsvd1[0]) >> 7) & 0x1ff)
#define BCMI_TSCE16_XGXS_RX_X2_QRSVD1r_QRSVD1f_SET(r,f) (r).rx_x2_qrsvd1[0]=(((r).rx_x2_qrsvd1[0] & ~((uint32_t)0x1ff << 7)) | ((((uint32_t)f) & 0x1ff) << 7)) | (511 << (16 + 7))
#define BCMI_TSCE16_XGXS_RX_X2_QRSVD1r_QRSVD2_8_2f_GET(r) (((r).rx_x2_qrsvd1[0]) & 0x7f)
#define BCMI_TSCE16_XGXS_RX_X2_QRSVD1r_QRSVD2_8_2f_SET(r,f) (r).rx_x2_qrsvd1[0]=(((r).rx_x2_qrsvd1[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access RX_X2_QRSVD1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X2_QRSVD1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X2_QRSVD1r,(_r._rx_x2_qrsvd1))
#define BCMI_TSCE16_XGXS_WRITE_RX_X2_QRSVD1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X2_QRSVD1r,(_r._rx_x2_qrsvd1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X2_QRSVD1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X2_QRSVD1r,(_r._rx_x2_qrsvd1))
#define BCMI_TSCE16_XGXS_READLN_RX_X2_QRSVD1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X2_QRSVD1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x2_qrsvd1))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X2_QRSVD1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X2_QRSVD1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x2_qrsvd1))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X2_QRSVD1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X2_QRSVD1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x2_qrsvd1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X2_QRSVD1r BCMI_TSCE16_XGXS_RX_X2_QRSVD1r
#define RX_X2_QRSVD1r_SIZE BCMI_TSCE16_XGXS_RX_X2_QRSVD1r_SIZE
typedef BCMI_TSCE16_XGXS_RX_X2_QRSVD1r_t RX_X2_QRSVD1r_t;
#define RX_X2_QRSVD1r_CLR BCMI_TSCE16_XGXS_RX_X2_QRSVD1r_CLR
#define RX_X2_QRSVD1r_SET BCMI_TSCE16_XGXS_RX_X2_QRSVD1r_SET
#define RX_X2_QRSVD1r_GET BCMI_TSCE16_XGXS_RX_X2_QRSVD1r_GET
#define RX_X2_QRSVD1r_QRSVD1f_GET BCMI_TSCE16_XGXS_RX_X2_QRSVD1r_QRSVD1f_GET
#define RX_X2_QRSVD1r_QRSVD1f_SET BCMI_TSCE16_XGXS_RX_X2_QRSVD1r_QRSVD1f_SET
#define RX_X2_QRSVD1r_QRSVD2_8_2f_GET BCMI_TSCE16_XGXS_RX_X2_QRSVD1r_QRSVD2_8_2f_GET
#define RX_X2_QRSVD1r_QRSVD2_8_2f_SET BCMI_TSCE16_XGXS_RX_X2_QRSVD1r_QRSVD2_8_2f_SET
#define READ_RX_X2_QRSVD1r BCMI_TSCE16_XGXS_READ_RX_X2_QRSVD1r
#define WRITE_RX_X2_QRSVD1r BCMI_TSCE16_XGXS_WRITE_RX_X2_QRSVD1r
#define MODIFY_RX_X2_QRSVD1r BCMI_TSCE16_XGXS_MODIFY_RX_X2_QRSVD1r
#define READLN_RX_X2_QRSVD1r BCMI_TSCE16_XGXS_READLN_RX_X2_QRSVD1r
#define WRITELN_RX_X2_QRSVD1r BCMI_TSCE16_XGXS_WRITELN_RX_X2_QRSVD1r
#define WRITEALL_RX_X2_QRSVD1r BCMI_TSCE16_XGXS_WRITEALL_RX_X2_QRSVD1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X2_QRSVD1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X2_QRSVD2
 * BLOCKS:   RX_X2_CONTROL0
 * REGADDR:  0xa022
 * DESC:     qrsvd 2 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     QRSVD3           Qrsvd3 is used to identify sequence ordered sets for which the bytes might be replaced.
 *     QRSVD2_1_0       Qrsvd2 is used to identify sequence ordered sets for which the bytes might be replaced.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X2_QRSVD2r (0x0020a022 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X2_QRSVD2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X2_QRSVD2.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X2_QRSVD2r_s {
	uint32_t v[1];
	uint32_t rx_x2_qrsvd2[1];
	uint32_t _rx_x2_qrsvd2;
} BCMI_TSCE16_XGXS_RX_X2_QRSVD2r_t;

#define BCMI_TSCE16_XGXS_RX_X2_QRSVD2r_CLR(r) (r).rx_x2_qrsvd2[0] = 0
#define BCMI_TSCE16_XGXS_RX_X2_QRSVD2r_SET(r,d) (r).rx_x2_qrsvd2[0] = d
#define BCMI_TSCE16_XGXS_RX_X2_QRSVD2r_GET(r) (r).rx_x2_qrsvd2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X2_QRSVD2r_QRSVD2_1_0f_GET(r) ((((r).rx_x2_qrsvd2[0]) >> 14) & 0x3)
#define BCMI_TSCE16_XGXS_RX_X2_QRSVD2r_QRSVD2_1_0f_SET(r,f) (r).rx_x2_qrsvd2[0]=(((r).rx_x2_qrsvd2[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCE16_XGXS_RX_X2_QRSVD2r_QRSVD3f_GET(r) ((((r).rx_x2_qrsvd2[0]) >> 5) & 0x1ff)
#define BCMI_TSCE16_XGXS_RX_X2_QRSVD2r_QRSVD3f_SET(r,f) (r).rx_x2_qrsvd2[0]=(((r).rx_x2_qrsvd2[0] & ~((uint32_t)0x1ff << 5)) | ((((uint32_t)f) & 0x1ff) << 5)) | (511 << (16 + 5))

/*
 * These macros can be used to access RX_X2_QRSVD2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X2_QRSVD2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X2_QRSVD2r,(_r._rx_x2_qrsvd2))
#define BCMI_TSCE16_XGXS_WRITE_RX_X2_QRSVD2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X2_QRSVD2r,(_r._rx_x2_qrsvd2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X2_QRSVD2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X2_QRSVD2r,(_r._rx_x2_qrsvd2))
#define BCMI_TSCE16_XGXS_READLN_RX_X2_QRSVD2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X2_QRSVD2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x2_qrsvd2))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X2_QRSVD2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X2_QRSVD2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x2_qrsvd2))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X2_QRSVD2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X2_QRSVD2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x2_qrsvd2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X2_QRSVD2r BCMI_TSCE16_XGXS_RX_X2_QRSVD2r
#define RX_X2_QRSVD2r_SIZE BCMI_TSCE16_XGXS_RX_X2_QRSVD2r_SIZE
typedef BCMI_TSCE16_XGXS_RX_X2_QRSVD2r_t RX_X2_QRSVD2r_t;
#define RX_X2_QRSVD2r_CLR BCMI_TSCE16_XGXS_RX_X2_QRSVD2r_CLR
#define RX_X2_QRSVD2r_SET BCMI_TSCE16_XGXS_RX_X2_QRSVD2r_SET
#define RX_X2_QRSVD2r_GET BCMI_TSCE16_XGXS_RX_X2_QRSVD2r_GET
#define RX_X2_QRSVD2r_QRSVD2_1_0f_GET BCMI_TSCE16_XGXS_RX_X2_QRSVD2r_QRSVD2_1_0f_GET
#define RX_X2_QRSVD2r_QRSVD2_1_0f_SET BCMI_TSCE16_XGXS_RX_X2_QRSVD2r_QRSVD2_1_0f_SET
#define RX_X2_QRSVD2r_QRSVD3f_GET BCMI_TSCE16_XGXS_RX_X2_QRSVD2r_QRSVD3f_GET
#define RX_X2_QRSVD2r_QRSVD3f_SET BCMI_TSCE16_XGXS_RX_X2_QRSVD2r_QRSVD3f_SET
#define READ_RX_X2_QRSVD2r BCMI_TSCE16_XGXS_READ_RX_X2_QRSVD2r
#define WRITE_RX_X2_QRSVD2r BCMI_TSCE16_XGXS_WRITE_RX_X2_QRSVD2r
#define MODIFY_RX_X2_QRSVD2r BCMI_TSCE16_XGXS_MODIFY_RX_X2_QRSVD2r
#define READLN_RX_X2_QRSVD2r BCMI_TSCE16_XGXS_READLN_RX_X2_QRSVD2r
#define WRITELN_RX_X2_QRSVD2r BCMI_TSCE16_XGXS_WRITELN_RX_X2_QRSVD2r
#define WRITEALL_RX_X2_QRSVD2r BCMI_TSCE16_XGXS_WRITEALL_RX_X2_QRSVD2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X2_QRSVD2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X2_MISC0
 * BLOCKS:   RX_X2_CONTROL0
 * REGADDR:  0xa023
 * DESC:     misc 0 register
 * RESETVAL: 0x1400 (5120)
 * ACCESS:   R/W
 * FIELDS:
 *     BYPASS_CL82RXSM  Bypass cl82 receive state machine1 = Bypass cl82 rxsm :- force RX_INIT state- pass the data from the table look-up decoder to the output0 = normal mode
 *     DIS_CL82_BERMON  Disable cl82 BER monitor state machine1 = Disable bermon fsm, force BER_MT_INIT state0 = Enable (default)
 *     BRCM_MODE_USE_K20PT5 
 *     CHK_END_EN       this bit enables cl48 check_end function as defined in section 48.2.6.1.4
 *     LINK_EN          Enables CL49 link up
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X2_MISC0r (0x0020a023 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X2_MISC0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X2_MISC0.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X2_MISC0r_s {
	uint32_t v[1];
	uint32_t rx_x2_misc0[1];
	uint32_t _rx_x2_misc0;
} BCMI_TSCE16_XGXS_RX_X2_MISC0r_t;

#define BCMI_TSCE16_XGXS_RX_X2_MISC0r_CLR(r) (r).rx_x2_misc0[0] = 0
#define BCMI_TSCE16_XGXS_RX_X2_MISC0r_SET(r,d) (r).rx_x2_misc0[0] = d
#define BCMI_TSCE16_XGXS_RX_X2_MISC0r_GET(r) (r).rx_x2_misc0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X2_MISC0r_LINK_ENf_GET(r) ((((r).rx_x2_misc0[0]) >> 12) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X2_MISC0r_LINK_ENf_SET(r,f) (r).rx_x2_misc0[0]=(((r).rx_x2_misc0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCE16_XGXS_RX_X2_MISC0r_CHK_END_ENf_GET(r) ((((r).rx_x2_misc0[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X2_MISC0r_CHK_END_ENf_SET(r,f) (r).rx_x2_misc0[0]=(((r).rx_x2_misc0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_RX_X2_MISC0r_BRCM_MODE_USE_K20PT5f_GET(r) ((((r).rx_x2_misc0[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X2_MISC0r_BRCM_MODE_USE_K20PT5f_SET(r,f) (r).rx_x2_misc0[0]=(((r).rx_x2_misc0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_RX_X2_MISC0r_DIS_CL82_BERMONf_GET(r) ((((r).rx_x2_misc0[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X2_MISC0r_DIS_CL82_BERMONf_SET(r,f) (r).rx_x2_misc0[0]=(((r).rx_x2_misc0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_RX_X2_MISC0r_BYPASS_CL82RXSMf_GET(r) (((r).rx_x2_misc0[0]) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X2_MISC0r_BYPASS_CL82RXSMf_SET(r,f) (r).rx_x2_misc0[0]=(((r).rx_x2_misc0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X2_MISC0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X2_MISC0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X2_MISC0r,(_r._rx_x2_misc0))
#define BCMI_TSCE16_XGXS_WRITE_RX_X2_MISC0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X2_MISC0r,(_r._rx_x2_misc0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X2_MISC0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X2_MISC0r,(_r._rx_x2_misc0))
#define BCMI_TSCE16_XGXS_READLN_RX_X2_MISC0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X2_MISC0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x2_misc0))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X2_MISC0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X2_MISC0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x2_misc0))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X2_MISC0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X2_MISC0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x2_misc0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X2_MISC0r BCMI_TSCE16_XGXS_RX_X2_MISC0r
#define RX_X2_MISC0r_SIZE BCMI_TSCE16_XGXS_RX_X2_MISC0r_SIZE
typedef BCMI_TSCE16_XGXS_RX_X2_MISC0r_t RX_X2_MISC0r_t;
#define RX_X2_MISC0r_CLR BCMI_TSCE16_XGXS_RX_X2_MISC0r_CLR
#define RX_X2_MISC0r_SET BCMI_TSCE16_XGXS_RX_X2_MISC0r_SET
#define RX_X2_MISC0r_GET BCMI_TSCE16_XGXS_RX_X2_MISC0r_GET
#define RX_X2_MISC0r_LINK_ENf_GET BCMI_TSCE16_XGXS_RX_X2_MISC0r_LINK_ENf_GET
#define RX_X2_MISC0r_LINK_ENf_SET BCMI_TSCE16_XGXS_RX_X2_MISC0r_LINK_ENf_SET
#define RX_X2_MISC0r_CHK_END_ENf_GET BCMI_TSCE16_XGXS_RX_X2_MISC0r_CHK_END_ENf_GET
#define RX_X2_MISC0r_CHK_END_ENf_SET BCMI_TSCE16_XGXS_RX_X2_MISC0r_CHK_END_ENf_SET
#define RX_X2_MISC0r_BRCM_MODE_USE_K20PT5f_GET BCMI_TSCE16_XGXS_RX_X2_MISC0r_BRCM_MODE_USE_K20PT5f_GET
#define RX_X2_MISC0r_BRCM_MODE_USE_K20PT5f_SET BCMI_TSCE16_XGXS_RX_X2_MISC0r_BRCM_MODE_USE_K20PT5f_SET
#define RX_X2_MISC0r_DIS_CL82_BERMONf_GET BCMI_TSCE16_XGXS_RX_X2_MISC0r_DIS_CL82_BERMONf_GET
#define RX_X2_MISC0r_DIS_CL82_BERMONf_SET BCMI_TSCE16_XGXS_RX_X2_MISC0r_DIS_CL82_BERMONf_SET
#define RX_X2_MISC0r_BYPASS_CL82RXSMf_GET BCMI_TSCE16_XGXS_RX_X2_MISC0r_BYPASS_CL82RXSMf_GET
#define RX_X2_MISC0r_BYPASS_CL82RXSMf_SET BCMI_TSCE16_XGXS_RX_X2_MISC0r_BYPASS_CL82RXSMf_SET
#define READ_RX_X2_MISC0r BCMI_TSCE16_XGXS_READ_RX_X2_MISC0r
#define WRITE_RX_X2_MISC0r BCMI_TSCE16_XGXS_WRITE_RX_X2_MISC0r
#define MODIFY_RX_X2_MISC0r BCMI_TSCE16_XGXS_MODIFY_RX_X2_MISC0r
#define READLN_RX_X2_MISC0r BCMI_TSCE16_XGXS_READLN_RX_X2_MISC0r
#define WRITELN_RX_X2_MISC0r BCMI_TSCE16_XGXS_WRITELN_RX_X2_MISC0r
#define WRITEALL_RX_X2_MISC0r BCMI_TSCE16_XGXS_WRITEALL_RX_X2_MISC0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X2_MISC0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X2_MISC1
 * BLOCKS:   RX_X2_CONTROL0
 * REGADDR:  0xa024
 * DESC:     misc 1 register
 * RESETVAL: 0x30f (783)
 * ACCESS:   R/W
 * FIELDS:
 *     CL82_RX_RF_ENABLE If this bit is a one, RFs are passed to the RS layer from the PCS.If this bit is a zero, RFs are replaced by IDLEs which are then passedto the RS layer.For CL82 only.
 *     CL82_RX_LF_ENABLE If this bit is a one, LFs are passed to the RS layer from the PCS.If this bit is a zero, LFs are replaced by IDLEs which are then passedto the RS layer.For CL82 only.
 *     CL48_RX_RF_ENABLE If this bit is a one, RFs are passed to the RS layer from the PCS.If this bit is a zero, RFs are replaced by IDLEs which are then passedto the RS layer.For CL48 only.
 *     CL48_RX_LF_ENABLE If this bit is a one, LFs are passed to the RS layer from the PCS.If this bit is a zero, LFs are replaced by IDLEs which are then passedto the RS layer.For CL48 only.
 *     CL48_RX_LI_ENABLE If this bit is a one, LI (Link Interrupt) codes are passed thru to the PCS.If this bit is a zero, LI are replaced by IDLEs which are then passedto the PCS.For CL48 only.
 *     CL82_RX_LI_ENABLE If this bit is a one, LI (Link Interrupt) codes are passed thru to the PCS.If this bit is a zero, LI are replaced by IDLEs which are then passedto the PCS.For CL82 only.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X2_MISC1r (0x0020a024 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X2_MISC1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X2_MISC1.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X2_MISC1r_s {
	uint32_t v[1];
	uint32_t rx_x2_misc1[1];
	uint32_t _rx_x2_misc1;
} BCMI_TSCE16_XGXS_RX_X2_MISC1r_t;

#define BCMI_TSCE16_XGXS_RX_X2_MISC1r_CLR(r) (r).rx_x2_misc1[0] = 0
#define BCMI_TSCE16_XGXS_RX_X2_MISC1r_SET(r,d) (r).rx_x2_misc1[0] = d
#define BCMI_TSCE16_XGXS_RX_X2_MISC1r_GET(r) (r).rx_x2_misc1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X2_MISC1r_CL82_RX_LI_ENABLEf_GET(r) ((((r).rx_x2_misc1[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X2_MISC1r_CL82_RX_LI_ENABLEf_SET(r,f) (r).rx_x2_misc1[0]=(((r).rx_x2_misc1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_RX_X2_MISC1r_CL48_RX_LI_ENABLEf_GET(r) ((((r).rx_x2_misc1[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X2_MISC1r_CL48_RX_LI_ENABLEf_SET(r,f) (r).rx_x2_misc1[0]=(((r).rx_x2_misc1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_RX_X2_MISC1r_CL48_RX_LF_ENABLEf_GET(r) ((((r).rx_x2_misc1[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X2_MISC1r_CL48_RX_LF_ENABLEf_SET(r,f) (r).rx_x2_misc1[0]=(((r).rx_x2_misc1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_RX_X2_MISC1r_CL48_RX_RF_ENABLEf_GET(r) ((((r).rx_x2_misc1[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X2_MISC1r_CL48_RX_RF_ENABLEf_SET(r,f) (r).rx_x2_misc1[0]=(((r).rx_x2_misc1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_RX_X2_MISC1r_CL82_RX_LF_ENABLEf_GET(r) ((((r).rx_x2_misc1[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X2_MISC1r_CL82_RX_LF_ENABLEf_SET(r,f) (r).rx_x2_misc1[0]=(((r).rx_x2_misc1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_RX_X2_MISC1r_CL82_RX_RF_ENABLEf_GET(r) (((r).rx_x2_misc1[0]) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X2_MISC1r_CL82_RX_RF_ENABLEf_SET(r,f) (r).rx_x2_misc1[0]=(((r).rx_x2_misc1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X2_MISC1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X2_MISC1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X2_MISC1r,(_r._rx_x2_misc1))
#define BCMI_TSCE16_XGXS_WRITE_RX_X2_MISC1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X2_MISC1r,(_r._rx_x2_misc1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X2_MISC1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X2_MISC1r,(_r._rx_x2_misc1))
#define BCMI_TSCE16_XGXS_READLN_RX_X2_MISC1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X2_MISC1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x2_misc1))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X2_MISC1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X2_MISC1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x2_misc1))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X2_MISC1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X2_MISC1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x2_misc1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X2_MISC1r BCMI_TSCE16_XGXS_RX_X2_MISC1r
#define RX_X2_MISC1r_SIZE BCMI_TSCE16_XGXS_RX_X2_MISC1r_SIZE
typedef BCMI_TSCE16_XGXS_RX_X2_MISC1r_t RX_X2_MISC1r_t;
#define RX_X2_MISC1r_CLR BCMI_TSCE16_XGXS_RX_X2_MISC1r_CLR
#define RX_X2_MISC1r_SET BCMI_TSCE16_XGXS_RX_X2_MISC1r_SET
#define RX_X2_MISC1r_GET BCMI_TSCE16_XGXS_RX_X2_MISC1r_GET
#define RX_X2_MISC1r_CL82_RX_LI_ENABLEf_GET BCMI_TSCE16_XGXS_RX_X2_MISC1r_CL82_RX_LI_ENABLEf_GET
#define RX_X2_MISC1r_CL82_RX_LI_ENABLEf_SET BCMI_TSCE16_XGXS_RX_X2_MISC1r_CL82_RX_LI_ENABLEf_SET
#define RX_X2_MISC1r_CL48_RX_LI_ENABLEf_GET BCMI_TSCE16_XGXS_RX_X2_MISC1r_CL48_RX_LI_ENABLEf_GET
#define RX_X2_MISC1r_CL48_RX_LI_ENABLEf_SET BCMI_TSCE16_XGXS_RX_X2_MISC1r_CL48_RX_LI_ENABLEf_SET
#define RX_X2_MISC1r_CL48_RX_LF_ENABLEf_GET BCMI_TSCE16_XGXS_RX_X2_MISC1r_CL48_RX_LF_ENABLEf_GET
#define RX_X2_MISC1r_CL48_RX_LF_ENABLEf_SET BCMI_TSCE16_XGXS_RX_X2_MISC1r_CL48_RX_LF_ENABLEf_SET
#define RX_X2_MISC1r_CL48_RX_RF_ENABLEf_GET BCMI_TSCE16_XGXS_RX_X2_MISC1r_CL48_RX_RF_ENABLEf_GET
#define RX_X2_MISC1r_CL48_RX_RF_ENABLEf_SET BCMI_TSCE16_XGXS_RX_X2_MISC1r_CL48_RX_RF_ENABLEf_SET
#define RX_X2_MISC1r_CL82_RX_LF_ENABLEf_GET BCMI_TSCE16_XGXS_RX_X2_MISC1r_CL82_RX_LF_ENABLEf_GET
#define RX_X2_MISC1r_CL82_RX_LF_ENABLEf_SET BCMI_TSCE16_XGXS_RX_X2_MISC1r_CL82_RX_LF_ENABLEf_SET
#define RX_X2_MISC1r_CL82_RX_RF_ENABLEf_GET BCMI_TSCE16_XGXS_RX_X2_MISC1r_CL82_RX_RF_ENABLEf_GET
#define RX_X2_MISC1r_CL82_RX_RF_ENABLEf_SET BCMI_TSCE16_XGXS_RX_X2_MISC1r_CL82_RX_RF_ENABLEf_SET
#define READ_RX_X2_MISC1r BCMI_TSCE16_XGXS_READ_RX_X2_MISC1r
#define WRITE_RX_X2_MISC1r BCMI_TSCE16_XGXS_WRITE_RX_X2_MISC1r
#define MODIFY_RX_X2_MISC1r BCMI_TSCE16_XGXS_MODIFY_RX_X2_MISC1r
#define READLN_RX_X2_MISC1r BCMI_TSCE16_XGXS_READLN_RX_X2_MISC1r
#define WRITELN_RX_X2_MISC1r BCMI_TSCE16_XGXS_WRITELN_RX_X2_MISC1r
#define WRITEALL_RX_X2_MISC1r BCMI_TSCE16_XGXS_WRITEALL_RX_X2_MISC1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X2_MISC1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X2_SKEW_STS0
 * BLOCKS:   RX_X2_STATUS0
 * REGADDR:  0xa031
 * DESC:     skew_status_0 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL48_SKEWACQ_STATE_D_3 CL48 deskew fsm3 current state: This is after processing column6, column7CL48 deskew fsm processes 8columns at a time3'b000 - LOSS_OF_ALIGN_BIT3'b001 - ALIGN_DET_1_BIT3'b010 - ALIGN_DET_2_BIT3'b011 - ALIGN_DET_3_BIT3'b100 - ALIGN_ACQ_1_BIT3'b101 - ALIGN_ACQ_2_BIT3'b110 - ALIGN_ACQ_3_BIT3'b111 - ALIGN_ACQ_4_BIT
 *     CL48_SKEWACQ_STATE_D_2 CL48 deskew fsm2 current state: This is after processing column4, column5CL48 deskew fsm processes 8columns at a time3'b000 - LOSS_OF_ALIGN_BIT3'b001 - ALIGN_DET_1_BIT3'b010 - ALIGN_DET_2_BIT3'b011 - ALIGN_DET_3_BIT3'b100 - ALIGN_ACQ_1_BIT3'b101 - ALIGN_ACQ_2_BIT3'b110 - ALIGN_ACQ_3_BIT3'b111 - ALIGN_ACQ_4_BIT
 *     CL48_SKEWACQ_STATE_D_1 CL48 deskew fsm1 current state: This is after processing column2, column3CL48 deskew fsm processes 8columns at a time3'b000 - LOSS_OF_ALIGN_BIT3'b001 - ALIGN_DET_1_BIT3'b010 - ALIGN_DET_2_BIT3'b011 - ALIGN_DET_3_BIT3'b100 - ALIGN_ACQ_1_BIT3'b101 - ALIGN_ACQ_2_BIT3'b110 - ALIGN_ACQ_3_BIT3'b111 - ALIGN_ACQ_4_BIT
 *     CL48_SKEWACQ_STATE_D_0 CL48 deskew fsm0 current state: This is after processing column0, column1CL48 deskew fsm processes 8columns at a time3'b000 - LOSS_OF_ALIGN_BIT3'b001 - ALIGN_DET_1_BIT3'b010 - ALIGN_DET_2_BIT3'b011 - ALIGN_DET_3_BIT3'b100 - ALIGN_ACQ_1_BIT3'b101 - ALIGN_ACQ_2_BIT3'b110 - ALIGN_ACQ_3_BIT3'b111 - ALIGN_ACQ_4_BIT
 *     CL48_SKEW_STATUS CL48 skew lock status
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r (0x0020a031 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X2_SKEW_STS0.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r_s {
	uint32_t v[1];
	uint32_t rx_x2_skew_sts0[1];
	uint32_t _rx_x2_skew_sts0;
} BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r_t;

#define BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r_CLR(r) (r).rx_x2_skew_sts0[0] = 0
#define BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r_SET(r,d) (r).rx_x2_skew_sts0[0] = d
#define BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r_GET(r) (r).rx_x2_skew_sts0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r_CL48_SKEW_STATUSf_GET(r) ((((r).rx_x2_skew_sts0[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r_CL48_SKEW_STATUSf_SET(r,f) (r).rx_x2_skew_sts0[0]=(((r).rx_x2_skew_sts0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r_CL48_SKEWACQ_STATE_D_0f_GET(r) ((((r).rx_x2_skew_sts0[0]) >> 12) & 0x7)
#define BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r_CL48_SKEWACQ_STATE_D_0f_SET(r,f) (r).rx_x2_skew_sts0[0]=(((r).rx_x2_skew_sts0[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12)) | (7 << (16 + 12))
#define BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r_CL48_SKEWACQ_STATE_D_1f_GET(r) ((((r).rx_x2_skew_sts0[0]) >> 9) & 0x7)
#define BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r_CL48_SKEWACQ_STATE_D_1f_SET(r,f) (r).rx_x2_skew_sts0[0]=(((r).rx_x2_skew_sts0[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9)) | (7 << (16 + 9))
#define BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r_CL48_SKEWACQ_STATE_D_2f_GET(r) ((((r).rx_x2_skew_sts0[0]) >> 6) & 0x7)
#define BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r_CL48_SKEWACQ_STATE_D_2f_SET(r,f) (r).rx_x2_skew_sts0[0]=(((r).rx_x2_skew_sts0[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r_CL48_SKEWACQ_STATE_D_3f_GET(r) ((((r).rx_x2_skew_sts0[0]) >> 3) & 0x7)
#define BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r_CL48_SKEWACQ_STATE_D_3f_SET(r,f) (r).rx_x2_skew_sts0[0]=(((r).rx_x2_skew_sts0[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3)) | (7 << (16 + 3))

/*
 * These macros can be used to access RX_X2_SKEW_STS0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X2_SKEW_STS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r,(_r._rx_x2_skew_sts0))
#define BCMI_TSCE16_XGXS_WRITE_RX_X2_SKEW_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r,(_r._rx_x2_skew_sts0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X2_SKEW_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r,(_r._rx_x2_skew_sts0))
#define BCMI_TSCE16_XGXS_READLN_RX_X2_SKEW_STS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x2_skew_sts0))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X2_SKEW_STS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x2_skew_sts0))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X2_SKEW_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x2_skew_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X2_SKEW_STS0r BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r
#define RX_X2_SKEW_STS0r_SIZE BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r_SIZE
typedef BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r_t RX_X2_SKEW_STS0r_t;
#define RX_X2_SKEW_STS0r_CLR BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r_CLR
#define RX_X2_SKEW_STS0r_SET BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r_SET
#define RX_X2_SKEW_STS0r_GET BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r_GET
#define RX_X2_SKEW_STS0r_CL48_SKEW_STATUSf_GET BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r_CL48_SKEW_STATUSf_GET
#define RX_X2_SKEW_STS0r_CL48_SKEW_STATUSf_SET BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r_CL48_SKEW_STATUSf_SET
#define RX_X2_SKEW_STS0r_CL48_SKEWACQ_STATE_D_0f_GET BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r_CL48_SKEWACQ_STATE_D_0f_GET
#define RX_X2_SKEW_STS0r_CL48_SKEWACQ_STATE_D_0f_SET BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r_CL48_SKEWACQ_STATE_D_0f_SET
#define RX_X2_SKEW_STS0r_CL48_SKEWACQ_STATE_D_1f_GET BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r_CL48_SKEWACQ_STATE_D_1f_GET
#define RX_X2_SKEW_STS0r_CL48_SKEWACQ_STATE_D_1f_SET BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r_CL48_SKEWACQ_STATE_D_1f_SET
#define RX_X2_SKEW_STS0r_CL48_SKEWACQ_STATE_D_2f_GET BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r_CL48_SKEWACQ_STATE_D_2f_GET
#define RX_X2_SKEW_STS0r_CL48_SKEWACQ_STATE_D_2f_SET BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r_CL48_SKEWACQ_STATE_D_2f_SET
#define RX_X2_SKEW_STS0r_CL48_SKEWACQ_STATE_D_3f_GET BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r_CL48_SKEWACQ_STATE_D_3f_GET
#define RX_X2_SKEW_STS0r_CL48_SKEWACQ_STATE_D_3f_SET BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r_CL48_SKEWACQ_STATE_D_3f_SET
#define READ_RX_X2_SKEW_STS0r BCMI_TSCE16_XGXS_READ_RX_X2_SKEW_STS0r
#define WRITE_RX_X2_SKEW_STS0r BCMI_TSCE16_XGXS_WRITE_RX_X2_SKEW_STS0r
#define MODIFY_RX_X2_SKEW_STS0r BCMI_TSCE16_XGXS_MODIFY_RX_X2_SKEW_STS0r
#define READLN_RX_X2_SKEW_STS0r BCMI_TSCE16_XGXS_READLN_RX_X2_SKEW_STS0r
#define WRITELN_RX_X2_SKEW_STS0r BCMI_TSCE16_XGXS_WRITELN_RX_X2_SKEW_STS0r
#define WRITEALL_RX_X2_SKEW_STS0r BCMI_TSCE16_XGXS_WRITEALL_RX_X2_SKEW_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X2_SKEW_STS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X2_SKEW_STS1
 * BLOCKS:   RX_X2_STATUS0
 * REGADDR:  0xa032
 * DESC:     skew_status_1 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL48_SKEWACQ_STATE_L bit 0 - LOSS_OF_ALIGN_BITbit 1 - ALIGN_DET_1_BITbit 2 - ALIGN_DET_2_BITbit 3 - ALIGN_DET_3_BITbit 4 - ALIGN_ACQ_1_BITbit 5 - ALIGN_ACQ_2_BITbit 6 - ALIGN_ACQ_3_BITbit 7 - ALIGN_ACQ_4_BIT
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X2_SKEW_STS1r (0x0020a032 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X2_SKEW_STS1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X2_SKEW_STS1.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X2_SKEW_STS1r_s {
	uint32_t v[1];
	uint32_t rx_x2_skew_sts1[1];
	uint32_t _rx_x2_skew_sts1;
} BCMI_TSCE16_XGXS_RX_X2_SKEW_STS1r_t;

#define BCMI_TSCE16_XGXS_RX_X2_SKEW_STS1r_CLR(r) (r).rx_x2_skew_sts1[0] = 0
#define BCMI_TSCE16_XGXS_RX_X2_SKEW_STS1r_SET(r,d) (r).rx_x2_skew_sts1[0] = d
#define BCMI_TSCE16_XGXS_RX_X2_SKEW_STS1r_GET(r) (r).rx_x2_skew_sts1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X2_SKEW_STS1r_CL48_SKEWACQ_STATE_Lf_GET(r) (((r).rx_x2_skew_sts1[0]) & 0xff)
#define BCMI_TSCE16_XGXS_RX_X2_SKEW_STS1r_CL48_SKEWACQ_STATE_Lf_SET(r,f) (r).rx_x2_skew_sts1[0]=(((r).rx_x2_skew_sts1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access RX_X2_SKEW_STS1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X2_SKEW_STS1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X2_SKEW_STS1r,(_r._rx_x2_skew_sts1))
#define BCMI_TSCE16_XGXS_WRITE_RX_X2_SKEW_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X2_SKEW_STS1r,(_r._rx_x2_skew_sts1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X2_SKEW_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X2_SKEW_STS1r,(_r._rx_x2_skew_sts1))
#define BCMI_TSCE16_XGXS_READLN_RX_X2_SKEW_STS1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X2_SKEW_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x2_skew_sts1))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X2_SKEW_STS1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X2_SKEW_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x2_skew_sts1))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X2_SKEW_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X2_SKEW_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x2_skew_sts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X2_SKEW_STS1r BCMI_TSCE16_XGXS_RX_X2_SKEW_STS1r
#define RX_X2_SKEW_STS1r_SIZE BCMI_TSCE16_XGXS_RX_X2_SKEW_STS1r_SIZE
typedef BCMI_TSCE16_XGXS_RX_X2_SKEW_STS1r_t RX_X2_SKEW_STS1r_t;
#define RX_X2_SKEW_STS1r_CLR BCMI_TSCE16_XGXS_RX_X2_SKEW_STS1r_CLR
#define RX_X2_SKEW_STS1r_SET BCMI_TSCE16_XGXS_RX_X2_SKEW_STS1r_SET
#define RX_X2_SKEW_STS1r_GET BCMI_TSCE16_XGXS_RX_X2_SKEW_STS1r_GET
#define RX_X2_SKEW_STS1r_CL48_SKEWACQ_STATE_Lf_GET BCMI_TSCE16_XGXS_RX_X2_SKEW_STS1r_CL48_SKEWACQ_STATE_Lf_GET
#define RX_X2_SKEW_STS1r_CL48_SKEWACQ_STATE_Lf_SET BCMI_TSCE16_XGXS_RX_X2_SKEW_STS1r_CL48_SKEWACQ_STATE_Lf_SET
#define READ_RX_X2_SKEW_STS1r BCMI_TSCE16_XGXS_READ_RX_X2_SKEW_STS1r
#define WRITE_RX_X2_SKEW_STS1r BCMI_TSCE16_XGXS_WRITE_RX_X2_SKEW_STS1r
#define MODIFY_RX_X2_SKEW_STS1r BCMI_TSCE16_XGXS_MODIFY_RX_X2_SKEW_STS1r
#define READLN_RX_X2_SKEW_STS1r BCMI_TSCE16_XGXS_READLN_RX_X2_SKEW_STS1r
#define WRITELN_RX_X2_SKEW_STS1r BCMI_TSCE16_XGXS_WRITELN_RX_X2_SKEW_STS1r
#define WRITEALL_RX_X2_SKEW_STS1r BCMI_TSCE16_XGXS_WRITEALL_RX_X2_SKEW_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X2_SKEW_STS1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X2_CL82_RX_SCR_IDLE_ERR_CNT
 * BLOCKS:   RX_X2_STATUS0
 * REGADDR:  0xa033
 * DESC:     CL82 ScrambledIdle Error Counter
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL82_RX_SCR_IDLE_ERROR_CNT CL82 ScrambledIdle Error Counter. 16 bits, Saturate at 16'hFFFF, Clear on read.NOTE: This counter is applicable to all cl82 modes, including cl49_codec(HG2_ENABLE && HG2_CODEC).
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr (0x0020a033 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr_SIZE 4

/*
 * This structure should be used to declare and program RX_X2_CL82_RX_SCR_IDLE_ERR_CNT.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr_s {
	uint32_t v[1];
	uint32_t rx_x2_cl82_rx_scr_idle_err_cnt[1];
	uint32_t _rx_x2_cl82_rx_scr_idle_err_cnt;
} BCMI_TSCE16_XGXS_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr_t;

#define BCMI_TSCE16_XGXS_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr_CLR(r) (r).rx_x2_cl82_rx_scr_idle_err_cnt[0] = 0
#define BCMI_TSCE16_XGXS_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr_SET(r,d) (r).rx_x2_cl82_rx_scr_idle_err_cnt[0] = d
#define BCMI_TSCE16_XGXS_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr_GET(r) (r).rx_x2_cl82_rx_scr_idle_err_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr_CL82_RX_SCR_IDLE_ERROR_CNTf_GET(r) (((r).rx_x2_cl82_rx_scr_idle_err_cnt[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr_CL82_RX_SCR_IDLE_ERROR_CNTf_SET(r,f) (r).rx_x2_cl82_rx_scr_idle_err_cnt[0]=(((r).rx_x2_cl82_rx_scr_idle_err_cnt[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X2_CL82_RX_SCR_IDLE_ERR_CNT.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr,(_r._rx_x2_cl82_rx_scr_idle_err_cnt))
#define BCMI_TSCE16_XGXS_WRITE_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr,(_r._rx_x2_cl82_rx_scr_idle_err_cnt)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr,(_r._rx_x2_cl82_rx_scr_idle_err_cnt))
#define BCMI_TSCE16_XGXS_READLN_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x2_cl82_rx_scr_idle_err_cnt))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x2_cl82_rx_scr_idle_err_cnt))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x2_cl82_rx_scr_idle_err_cnt))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr BCMI_TSCE16_XGXS_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr
#define RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr_SIZE BCMI_TSCE16_XGXS_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr_SIZE
typedef BCMI_TSCE16_XGXS_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr_t RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr_t;
#define RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr_CLR BCMI_TSCE16_XGXS_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr_CLR
#define RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr_SET BCMI_TSCE16_XGXS_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr_SET
#define RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr_GET BCMI_TSCE16_XGXS_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr_GET
#define RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr_CL82_RX_SCR_IDLE_ERROR_CNTf_GET BCMI_TSCE16_XGXS_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr_CL82_RX_SCR_IDLE_ERROR_CNTf_GET
#define RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr_CL82_RX_SCR_IDLE_ERROR_CNTf_SET BCMI_TSCE16_XGXS_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr_CL82_RX_SCR_IDLE_ERROR_CNTf_SET
#define READ_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr BCMI_TSCE16_XGXS_READ_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr
#define WRITE_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr BCMI_TSCE16_XGXS_WRITE_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr
#define MODIFY_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr BCMI_TSCE16_XGXS_MODIFY_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr
#define READLN_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr BCMI_TSCE16_XGXS_READLN_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr
#define WRITELN_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr BCMI_TSCE16_XGXS_WRITELN_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr
#define WRITEALL_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr BCMI_TSCE16_XGXS_WRITEALL_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X2_CL82_RX_SCR_IDLE_ERR_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  CL82_RX_DECR_STS
 * BLOCKS:   CL82
 * REGADDR:  0xa080
 * DESC:     cl82 rx decoder status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RXSM_STATE       Recieve fsm - current statebit 6 - RX_HIG_ENDbit 5 - RX_HIG_STARTbit 4 - RX_Ebit 3 - RX_Tbit 2 - RX_Dbit 1 - RX_Cbit 0 - RX_INIT
 *     R_TYPE_CODED     Receive SM - current r_typebit 5 - R_TYPE_B1bit 4 - R_TYPE_Cbit 3 - R_TYPE_Sbit 2 - R_TYPE_Tbit 1 - R_TYPE_Dbit 0 - R_TYPE_E
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_CL82_RX_DECR_STSr (0x0020a080 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_CL82_RX_DECR_STSr_SIZE 4

/*
 * This structure should be used to declare and program CL82_RX_DECR_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_CL82_RX_DECR_STSr_s {
	uint32_t v[1];
	uint32_t cl82_rx_decr_sts[1];
	uint32_t _cl82_rx_decr_sts;
} BCMI_TSCE16_XGXS_CL82_RX_DECR_STSr_t;

#define BCMI_TSCE16_XGXS_CL82_RX_DECR_STSr_CLR(r) (r).cl82_rx_decr_sts[0] = 0
#define BCMI_TSCE16_XGXS_CL82_RX_DECR_STSr_SET(r,d) (r).cl82_rx_decr_sts[0] = d
#define BCMI_TSCE16_XGXS_CL82_RX_DECR_STSr_GET(r) (r).cl82_rx_decr_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_CL82_RX_DECR_STSr_R_TYPE_CODEDf_GET(r) ((((r).cl82_rx_decr_sts[0]) >> 7) & 0x3f)
#define BCMI_TSCE16_XGXS_CL82_RX_DECR_STSr_R_TYPE_CODEDf_SET(r,f) (r).cl82_rx_decr_sts[0]=(((r).cl82_rx_decr_sts[0] & ~((uint32_t)0x3f << 7)) | ((((uint32_t)f) & 0x3f) << 7)) | (63 << (16 + 7))
#define BCMI_TSCE16_XGXS_CL82_RX_DECR_STSr_RXSM_STATEf_GET(r) (((r).cl82_rx_decr_sts[0]) & 0x7f)
#define BCMI_TSCE16_XGXS_CL82_RX_DECR_STSr_RXSM_STATEf_SET(r,f) (r).cl82_rx_decr_sts[0]=(((r).cl82_rx_decr_sts[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access CL82_RX_DECR_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_CL82_RX_DECR_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL82_RX_DECR_STSr,(_r._cl82_rx_decr_sts))
#define BCMI_TSCE16_XGXS_WRITE_CL82_RX_DECR_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL82_RX_DECR_STSr,(_r._cl82_rx_decr_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_CL82_RX_DECR_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL82_RX_DECR_STSr,(_r._cl82_rx_decr_sts))
#define BCMI_TSCE16_XGXS_READLN_CL82_RX_DECR_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL82_RX_DECR_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl82_rx_decr_sts))
#define BCMI_TSCE16_XGXS_WRITELN_CL82_RX_DECR_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL82_RX_DECR_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl82_rx_decr_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_CL82_RX_DECR_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL82_RX_DECR_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl82_rx_decr_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL82_RX_DECR_STSr BCMI_TSCE16_XGXS_CL82_RX_DECR_STSr
#define CL82_RX_DECR_STSr_SIZE BCMI_TSCE16_XGXS_CL82_RX_DECR_STSr_SIZE
typedef BCMI_TSCE16_XGXS_CL82_RX_DECR_STSr_t CL82_RX_DECR_STSr_t;
#define CL82_RX_DECR_STSr_CLR BCMI_TSCE16_XGXS_CL82_RX_DECR_STSr_CLR
#define CL82_RX_DECR_STSr_SET BCMI_TSCE16_XGXS_CL82_RX_DECR_STSr_SET
#define CL82_RX_DECR_STSr_GET BCMI_TSCE16_XGXS_CL82_RX_DECR_STSr_GET
#define CL82_RX_DECR_STSr_R_TYPE_CODEDf_GET BCMI_TSCE16_XGXS_CL82_RX_DECR_STSr_R_TYPE_CODEDf_GET
#define CL82_RX_DECR_STSr_R_TYPE_CODEDf_SET BCMI_TSCE16_XGXS_CL82_RX_DECR_STSr_R_TYPE_CODEDf_SET
#define CL82_RX_DECR_STSr_RXSM_STATEf_GET BCMI_TSCE16_XGXS_CL82_RX_DECR_STSr_RXSM_STATEf_GET
#define CL82_RX_DECR_STSr_RXSM_STATEf_SET BCMI_TSCE16_XGXS_CL82_RX_DECR_STSr_RXSM_STATEf_SET
#define READ_CL82_RX_DECR_STSr BCMI_TSCE16_XGXS_READ_CL82_RX_DECR_STSr
#define WRITE_CL82_RX_DECR_STSr BCMI_TSCE16_XGXS_WRITE_CL82_RX_DECR_STSr
#define MODIFY_CL82_RX_DECR_STSr BCMI_TSCE16_XGXS_MODIFY_CL82_RX_DECR_STSr
#define READLN_CL82_RX_DECR_STSr BCMI_TSCE16_XGXS_READLN_CL82_RX_DECR_STSr
#define WRITELN_CL82_RX_DECR_STSr BCMI_TSCE16_XGXS_WRITELN_CL82_RX_DECR_STSr
#define WRITEALL_CL82_RX_DECR_STSr BCMI_TSCE16_XGXS_WRITEALL_CL82_RX_DECR_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_CL82_RX_DECR_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  CL82_RX_DESKEW_BER_STS
 * BLOCKS:   CL82
 * REGADDR:  0xa081
 * DESC:     cl82 rx deskew status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     BERMON_STATE     BER Monitor fsm - current statebit 4 - HI_BERbit 3 - GOOD_BERbit 2 - BER_TEST_SHbit 1 - START_TIMERbit 0 - BER_MT_INIT
 *     LBERMON_STATE    BER Monitor fsm - history states - latched on entryclear on readbit 4  - HI_BERbit 3  - GOOD_BERbit 2  - BER_TEST_SHbit 1  - START_TIMERbit 0  - BER_MT_INIT
 *     DESKEW_HIS_STATE Deskew history statesclear on readbit 1  - ALIGN_ACQUIREDbit 0  - LOSS_OF_ALIGNMENT
 *     DESKEW_STATE     Deskew current statesbit 1  - ALIGN_ACQUIREDbit 0  - LOSS_OF_ALIGNMENT
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr (0x0020a081 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr_SIZE 4

/*
 * This structure should be used to declare and program CL82_RX_DESKEW_BER_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr_s {
	uint32_t v[1];
	uint32_t cl82_rx_deskew_ber_sts[1];
	uint32_t _cl82_rx_deskew_ber_sts;
} BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr_t;

#define BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr_CLR(r) (r).cl82_rx_deskew_ber_sts[0] = 0
#define BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr_SET(r,d) (r).cl82_rx_deskew_ber_sts[0] = d
#define BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr_GET(r) (r).cl82_rx_deskew_ber_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr_DESKEW_STATEf_GET(r) ((((r).cl82_rx_deskew_ber_sts[0]) >> 14) & 0x3)
#define BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr_DESKEW_STATEf_SET(r,f) (r).cl82_rx_deskew_ber_sts[0]=(((r).cl82_rx_deskew_ber_sts[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr_DESKEW_HIS_STATEf_GET(r) ((((r).cl82_rx_deskew_ber_sts[0]) >> 12) & 0x3)
#define BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr_DESKEW_HIS_STATEf_SET(r,f) (r).cl82_rx_deskew_ber_sts[0]=(((r).cl82_rx_deskew_ber_sts[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr_LBERMON_STATEf_GET(r) ((((r).cl82_rx_deskew_ber_sts[0]) >> 6) & 0x1f)
#define BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr_LBERMON_STATEf_SET(r,f) (r).cl82_rx_deskew_ber_sts[0]=(((r).cl82_rx_deskew_ber_sts[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr_BERMON_STATEf_GET(r) (((r).cl82_rx_deskew_ber_sts[0]) & 0x1f)
#define BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr_BERMON_STATEf_SET(r,f) (r).cl82_rx_deskew_ber_sts[0]=(((r).cl82_rx_deskew_ber_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access CL82_RX_DESKEW_BER_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_CL82_RX_DESKEW_BER_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr,(_r._cl82_rx_deskew_ber_sts))
#define BCMI_TSCE16_XGXS_WRITE_CL82_RX_DESKEW_BER_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr,(_r._cl82_rx_deskew_ber_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_CL82_RX_DESKEW_BER_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr,(_r._cl82_rx_deskew_ber_sts))
#define BCMI_TSCE16_XGXS_READLN_CL82_RX_DESKEW_BER_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl82_rx_deskew_ber_sts))
#define BCMI_TSCE16_XGXS_WRITELN_CL82_RX_DESKEW_BER_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl82_rx_deskew_ber_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_CL82_RX_DESKEW_BER_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl82_rx_deskew_ber_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL82_RX_DESKEW_BER_STSr BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr
#define CL82_RX_DESKEW_BER_STSr_SIZE BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr_SIZE
typedef BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr_t CL82_RX_DESKEW_BER_STSr_t;
#define CL82_RX_DESKEW_BER_STSr_CLR BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr_CLR
#define CL82_RX_DESKEW_BER_STSr_SET BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr_SET
#define CL82_RX_DESKEW_BER_STSr_GET BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr_GET
#define CL82_RX_DESKEW_BER_STSr_DESKEW_STATEf_GET BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr_DESKEW_STATEf_GET
#define CL82_RX_DESKEW_BER_STSr_DESKEW_STATEf_SET BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr_DESKEW_STATEf_SET
#define CL82_RX_DESKEW_BER_STSr_DESKEW_HIS_STATEf_GET BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr_DESKEW_HIS_STATEf_GET
#define CL82_RX_DESKEW_BER_STSr_DESKEW_HIS_STATEf_SET BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr_DESKEW_HIS_STATEf_SET
#define CL82_RX_DESKEW_BER_STSr_LBERMON_STATEf_GET BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr_LBERMON_STATEf_GET
#define CL82_RX_DESKEW_BER_STSr_LBERMON_STATEf_SET BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr_LBERMON_STATEf_SET
#define CL82_RX_DESKEW_BER_STSr_BERMON_STATEf_GET BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr_BERMON_STATEf_GET
#define CL82_RX_DESKEW_BER_STSr_BERMON_STATEf_SET BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr_BERMON_STATEf_SET
#define READ_CL82_RX_DESKEW_BER_STSr BCMI_TSCE16_XGXS_READ_CL82_RX_DESKEW_BER_STSr
#define WRITE_CL82_RX_DESKEW_BER_STSr BCMI_TSCE16_XGXS_WRITE_CL82_RX_DESKEW_BER_STSr
#define MODIFY_CL82_RX_DESKEW_BER_STSr BCMI_TSCE16_XGXS_MODIFY_CL82_RX_DESKEW_BER_STSr
#define READLN_CL82_RX_DESKEW_BER_STSr BCMI_TSCE16_XGXS_READLN_CL82_RX_DESKEW_BER_STSr
#define WRITELN_CL82_RX_DESKEW_BER_STSr BCMI_TSCE16_XGXS_WRITELN_CL82_RX_DESKEW_BER_STSr
#define WRITEALL_CL82_RX_DESKEW_BER_STSr BCMI_TSCE16_XGXS_WRITEALL_CL82_RX_DESKEW_BER_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_CL82_RX_DESKEW_BER_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  CL82_BER_HO_STS
 * BLOCKS:   CL82
 * REGADDR:  0xa085
 * DESC:     CL82 BER HIGH ORDER bits register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     BER_HO           Upper 16 bits of CL82 BER count
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_CL82_BER_HO_STSr (0x0020a085 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_CL82_BER_HO_STSr_SIZE 4

/*
 * This structure should be used to declare and program CL82_BER_HO_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_CL82_BER_HO_STSr_s {
	uint32_t v[1];
	uint32_t cl82_ber_ho_sts[1];
	uint32_t _cl82_ber_ho_sts;
} BCMI_TSCE16_XGXS_CL82_BER_HO_STSr_t;

#define BCMI_TSCE16_XGXS_CL82_BER_HO_STSr_CLR(r) (r).cl82_ber_ho_sts[0] = 0
#define BCMI_TSCE16_XGXS_CL82_BER_HO_STSr_SET(r,d) (r).cl82_ber_ho_sts[0] = d
#define BCMI_TSCE16_XGXS_CL82_BER_HO_STSr_GET(r) (r).cl82_ber_ho_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_CL82_BER_HO_STSr_BER_HOf_GET(r) (((r).cl82_ber_ho_sts[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_CL82_BER_HO_STSr_BER_HOf_SET(r,f) (r).cl82_ber_ho_sts[0]=(((r).cl82_ber_ho_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CL82_BER_HO_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_CL82_BER_HO_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL82_BER_HO_STSr,(_r._cl82_ber_ho_sts))
#define BCMI_TSCE16_XGXS_WRITE_CL82_BER_HO_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL82_BER_HO_STSr,(_r._cl82_ber_ho_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_CL82_BER_HO_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL82_BER_HO_STSr,(_r._cl82_ber_ho_sts))
#define BCMI_TSCE16_XGXS_READLN_CL82_BER_HO_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL82_BER_HO_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl82_ber_ho_sts))
#define BCMI_TSCE16_XGXS_WRITELN_CL82_BER_HO_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL82_BER_HO_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl82_ber_ho_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_CL82_BER_HO_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL82_BER_HO_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl82_ber_ho_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL82_BER_HO_STSr BCMI_TSCE16_XGXS_CL82_BER_HO_STSr
#define CL82_BER_HO_STSr_SIZE BCMI_TSCE16_XGXS_CL82_BER_HO_STSr_SIZE
typedef BCMI_TSCE16_XGXS_CL82_BER_HO_STSr_t CL82_BER_HO_STSr_t;
#define CL82_BER_HO_STSr_CLR BCMI_TSCE16_XGXS_CL82_BER_HO_STSr_CLR
#define CL82_BER_HO_STSr_SET BCMI_TSCE16_XGXS_CL82_BER_HO_STSr_SET
#define CL82_BER_HO_STSr_GET BCMI_TSCE16_XGXS_CL82_BER_HO_STSr_GET
#define CL82_BER_HO_STSr_BER_HOf_GET BCMI_TSCE16_XGXS_CL82_BER_HO_STSr_BER_HOf_GET
#define CL82_BER_HO_STSr_BER_HOf_SET BCMI_TSCE16_XGXS_CL82_BER_HO_STSr_BER_HOf_SET
#define READ_CL82_BER_HO_STSr BCMI_TSCE16_XGXS_READ_CL82_BER_HO_STSr
#define WRITE_CL82_BER_HO_STSr BCMI_TSCE16_XGXS_WRITE_CL82_BER_HO_STSr
#define MODIFY_CL82_BER_HO_STSr BCMI_TSCE16_XGXS_MODIFY_CL82_BER_HO_STSr
#define READLN_CL82_BER_HO_STSr BCMI_TSCE16_XGXS_READLN_CL82_BER_HO_STSr
#define WRITELN_CL82_BER_HO_STSr BCMI_TSCE16_XGXS_WRITELN_CL82_BER_HO_STSr
#define WRITEALL_CL82_BER_HO_STSr BCMI_TSCE16_XGXS_WRITEALL_CL82_BER_HO_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_CL82_BER_HO_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  CL82_PCS_ERRED_BLKS_HO
 * BLOCKS:   CL82
 * REGADDR:  0xa086
 * DESC:     40G/100GBASE-R Errored blocks high order counter
 * RESETVAL: 0x8000 (32768)
 * ACCESS:   R/O
 * FIELDS:
 *     ERRORED_BLOCKS_HO Error blocks counter high order bits   - CR/NRBits 21:8 of the Error blocks  counter
 *     ERRORED_BLOCKS_HO_PRESENT Error blocks counter high order bits present - ROAlways reads as 1 if this registers is implemented
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_CL82_PCS_ERRED_BLKS_HOr (0x0020a086 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_CL82_PCS_ERRED_BLKS_HOr_SIZE 4

/*
 * This structure should be used to declare and program CL82_PCS_ERRED_BLKS_HO.
 *
 */
typedef union BCMI_TSCE16_XGXS_CL82_PCS_ERRED_BLKS_HOr_s {
	uint32_t v[1];
	uint32_t cl82_pcs_erred_blks_ho[1];
	uint32_t _cl82_pcs_erred_blks_ho;
} BCMI_TSCE16_XGXS_CL82_PCS_ERRED_BLKS_HOr_t;

#define BCMI_TSCE16_XGXS_CL82_PCS_ERRED_BLKS_HOr_CLR(r) (r).cl82_pcs_erred_blks_ho[0] = 0
#define BCMI_TSCE16_XGXS_CL82_PCS_ERRED_BLKS_HOr_SET(r,d) (r).cl82_pcs_erred_blks_ho[0] = d
#define BCMI_TSCE16_XGXS_CL82_PCS_ERRED_BLKS_HOr_GET(r) (r).cl82_pcs_erred_blks_ho[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_CL82_PCS_ERRED_BLKS_HOr_ERRORED_BLOCKS_HO_PRESENTf_GET(r) ((((r).cl82_pcs_erred_blks_ho[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_CL82_PCS_ERRED_BLKS_HOr_ERRORED_BLOCKS_HO_PRESENTf_SET(r,f) (r).cl82_pcs_erred_blks_ho[0]=(((r).cl82_pcs_erred_blks_ho[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_CL82_PCS_ERRED_BLKS_HOr_ERRORED_BLOCKS_HOf_GET(r) (((r).cl82_pcs_erred_blks_ho[0]) & 0x3fff)
#define BCMI_TSCE16_XGXS_CL82_PCS_ERRED_BLKS_HOr_ERRORED_BLOCKS_HOf_SET(r,f) (r).cl82_pcs_erred_blks_ho[0]=(((r).cl82_pcs_erred_blks_ho[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access CL82_PCS_ERRED_BLKS_HO.
 *
 */
#define BCMI_TSCE16_XGXS_READ_CL82_PCS_ERRED_BLKS_HOr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL82_PCS_ERRED_BLKS_HOr,(_r._cl82_pcs_erred_blks_ho))
#define BCMI_TSCE16_XGXS_WRITE_CL82_PCS_ERRED_BLKS_HOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL82_PCS_ERRED_BLKS_HOr,(_r._cl82_pcs_erred_blks_ho)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_CL82_PCS_ERRED_BLKS_HOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL82_PCS_ERRED_BLKS_HOr,(_r._cl82_pcs_erred_blks_ho))
#define BCMI_TSCE16_XGXS_READLN_CL82_PCS_ERRED_BLKS_HOr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL82_PCS_ERRED_BLKS_HOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl82_pcs_erred_blks_ho))
#define BCMI_TSCE16_XGXS_WRITELN_CL82_PCS_ERRED_BLKS_HOr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL82_PCS_ERRED_BLKS_HOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl82_pcs_erred_blks_ho))
#define BCMI_TSCE16_XGXS_WRITEALL_CL82_PCS_ERRED_BLKS_HOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL82_PCS_ERRED_BLKS_HOr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl82_pcs_erred_blks_ho))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL82_PCS_ERRED_BLKS_HOr BCMI_TSCE16_XGXS_CL82_PCS_ERRED_BLKS_HOr
#define CL82_PCS_ERRED_BLKS_HOr_SIZE BCMI_TSCE16_XGXS_CL82_PCS_ERRED_BLKS_HOr_SIZE
typedef BCMI_TSCE16_XGXS_CL82_PCS_ERRED_BLKS_HOr_t CL82_PCS_ERRED_BLKS_HOr_t;
#define CL82_PCS_ERRED_BLKS_HOr_CLR BCMI_TSCE16_XGXS_CL82_PCS_ERRED_BLKS_HOr_CLR
#define CL82_PCS_ERRED_BLKS_HOr_SET BCMI_TSCE16_XGXS_CL82_PCS_ERRED_BLKS_HOr_SET
#define CL82_PCS_ERRED_BLKS_HOr_GET BCMI_TSCE16_XGXS_CL82_PCS_ERRED_BLKS_HOr_GET
#define CL82_PCS_ERRED_BLKS_HOr_ERRORED_BLOCKS_HO_PRESENTf_GET BCMI_TSCE16_XGXS_CL82_PCS_ERRED_BLKS_HOr_ERRORED_BLOCKS_HO_PRESENTf_GET
#define CL82_PCS_ERRED_BLKS_HOr_ERRORED_BLOCKS_HO_PRESENTf_SET BCMI_TSCE16_XGXS_CL82_PCS_ERRED_BLKS_HOr_ERRORED_BLOCKS_HO_PRESENTf_SET
#define CL82_PCS_ERRED_BLKS_HOr_ERRORED_BLOCKS_HOf_GET BCMI_TSCE16_XGXS_CL82_PCS_ERRED_BLKS_HOr_ERRORED_BLOCKS_HOf_GET
#define CL82_PCS_ERRED_BLKS_HOr_ERRORED_BLOCKS_HOf_SET BCMI_TSCE16_XGXS_CL82_PCS_ERRED_BLKS_HOr_ERRORED_BLOCKS_HOf_SET
#define READ_CL82_PCS_ERRED_BLKS_HOr BCMI_TSCE16_XGXS_READ_CL82_PCS_ERRED_BLKS_HOr
#define WRITE_CL82_PCS_ERRED_BLKS_HOr BCMI_TSCE16_XGXS_WRITE_CL82_PCS_ERRED_BLKS_HOr
#define MODIFY_CL82_PCS_ERRED_BLKS_HOr BCMI_TSCE16_XGXS_MODIFY_CL82_PCS_ERRED_BLKS_HOr
#define READLN_CL82_PCS_ERRED_BLKS_HOr BCMI_TSCE16_XGXS_READLN_CL82_PCS_ERRED_BLKS_HOr
#define WRITELN_CL82_PCS_ERRED_BLKS_HOr BCMI_TSCE16_XGXS_WRITELN_CL82_PCS_ERRED_BLKS_HOr
#define WRITEALL_CL82_PCS_ERRED_BLKS_HOr BCMI_TSCE16_XGXS_WRITEALL_CL82_PCS_ERRED_BLKS_HOr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_CL82_PCS_ERRED_BLKS_HOr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PMD_X4_CTL
 * BLOCKS:   PMD_X4
 * REGADDR:  0xc010
 * DESC:     PMD lane reset controls
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_RX_DP_H_RSTB  RX PMD lane datapath reset override valueOnly used for Speed Control bypass operation
 *     LN_RX_H_RSTB     RX Reset all lane logic: data path and registers
 *     LN_TX_H_PWRDN    Lane power down, TX direction
 *     LN_RX_H_PWRDN    Lane power down, RX direction
 *     TX_OSR_MODE      TX OSR mode. In current implementation only OSR mode 1 is usedOnly used for Speed Control bypass operation
 *     TX_DISABLE       Set to squelch the transmit signal for laneOnly used for Speed Control bypass operation
 *     RX_OSR_MODE      RX OSR mode. In current implementation only OSR mode 1 is usedOnly used for Speed Control bypass operation
 *     RX_DME_EN        DME is enabled, for CL73 faster sample modeOnly used for Speed Control bypass operation
 *     LN_TX_DP_H_RSTB  TX PMD lane datapath reset override valueOnly used for Speed Control bypass operation
 *     LN_TX_H_RSTB     TX Reset all lane logic: data path and registers
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PMD_X4_CTLr (0x0000c010 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PMD_X4_CTLr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X4_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_PMD_X4_CTLr_s {
	uint32_t v[1];
	uint32_t pmd_x4_ctl[1];
	uint32_t _pmd_x4_ctl;
} BCMI_TSCE16_XGXS_PMD_X4_CTLr_t;

#define BCMI_TSCE16_XGXS_PMD_X4_CTLr_CLR(r) (r).pmd_x4_ctl[0] = 0
#define BCMI_TSCE16_XGXS_PMD_X4_CTLr_SET(r,d) (r).pmd_x4_ctl[0] = d
#define BCMI_TSCE16_XGXS_PMD_X4_CTLr_GET(r) (r).pmd_x4_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PMD_X4_CTLr_LN_TX_H_RSTBf_GET(r) ((((r).pmd_x4_ctl[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X4_CTLr_LN_TX_H_RSTBf_SET(r,f) (r).pmd_x4_ctl[0]=(((r).pmd_x4_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_PMD_X4_CTLr_LN_TX_DP_H_RSTBf_GET(r) ((((r).pmd_x4_ctl[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X4_CTLr_LN_TX_DP_H_RSTBf_SET(r,f) (r).pmd_x4_ctl[0]=(((r).pmd_x4_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_PMD_X4_CTLr_RX_DME_ENf_GET(r) ((((r).pmd_x4_ctl[0]) >> 13) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X4_CTLr_RX_DME_ENf_SET(r,f) (r).pmd_x4_ctl[0]=(((r).pmd_x4_ctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCE16_XGXS_PMD_X4_CTLr_RX_OSR_MODEf_GET(r) ((((r).pmd_x4_ctl[0]) >> 9) & 0xf)
#define BCMI_TSCE16_XGXS_PMD_X4_CTLr_RX_OSR_MODEf_SET(r,f) (r).pmd_x4_ctl[0]=(((r).pmd_x4_ctl[0] & ~((uint32_t)0xf << 9)) | ((((uint32_t)f) & 0xf) << 9)) | (15 << (16 + 9))
#define BCMI_TSCE16_XGXS_PMD_X4_CTLr_TX_DISABLEf_GET(r) ((((r).pmd_x4_ctl[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X4_CTLr_TX_DISABLEf_SET(r,f) (r).pmd_x4_ctl[0]=(((r).pmd_x4_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_PMD_X4_CTLr_TX_OSR_MODEf_GET(r) ((((r).pmd_x4_ctl[0]) >> 4) & 0xf)
#define BCMI_TSCE16_XGXS_PMD_X4_CTLr_TX_OSR_MODEf_SET(r,f) (r).pmd_x4_ctl[0]=(((r).pmd_x4_ctl[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_TSCE16_XGXS_PMD_X4_CTLr_LN_RX_H_PWRDNf_GET(r) ((((r).pmd_x4_ctl[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X4_CTLr_LN_RX_H_PWRDNf_SET(r,f) (r).pmd_x4_ctl[0]=(((r).pmd_x4_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_PMD_X4_CTLr_LN_TX_H_PWRDNf_GET(r) ((((r).pmd_x4_ctl[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X4_CTLr_LN_TX_H_PWRDNf_SET(r,f) (r).pmd_x4_ctl[0]=(((r).pmd_x4_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_PMD_X4_CTLr_LN_RX_H_RSTBf_GET(r) ((((r).pmd_x4_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X4_CTLr_LN_RX_H_RSTBf_SET(r,f) (r).pmd_x4_ctl[0]=(((r).pmd_x4_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_PMD_X4_CTLr_LN_RX_DP_H_RSTBf_GET(r) (((r).pmd_x4_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X4_CTLr_LN_RX_DP_H_RSTBf_SET(r,f) (r).pmd_x4_ctl[0]=(((r).pmd_x4_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PMD_X4_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PMD_X4_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PMD_X4_CTLr,(_r._pmd_x4_ctl))
#define BCMI_TSCE16_XGXS_WRITE_PMD_X4_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X4_CTLr,(_r._pmd_x4_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PMD_X4_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X4_CTLr,(_r._pmd_x4_ctl))
#define BCMI_TSCE16_XGXS_READLN_PMD_X4_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PMD_X4_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_PMD_X4_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X4_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_PMD_X4_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X4_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pmd_x4_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X4_CTLr BCMI_TSCE16_XGXS_PMD_X4_CTLr
#define PMD_X4_CTLr_SIZE BCMI_TSCE16_XGXS_PMD_X4_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_PMD_X4_CTLr_t PMD_X4_CTLr_t;
#define PMD_X4_CTLr_CLR BCMI_TSCE16_XGXS_PMD_X4_CTLr_CLR
#define PMD_X4_CTLr_SET BCMI_TSCE16_XGXS_PMD_X4_CTLr_SET
#define PMD_X4_CTLr_GET BCMI_TSCE16_XGXS_PMD_X4_CTLr_GET
#define PMD_X4_CTLr_LN_TX_H_RSTBf_GET BCMI_TSCE16_XGXS_PMD_X4_CTLr_LN_TX_H_RSTBf_GET
#define PMD_X4_CTLr_LN_TX_H_RSTBf_SET BCMI_TSCE16_XGXS_PMD_X4_CTLr_LN_TX_H_RSTBf_SET
#define PMD_X4_CTLr_LN_TX_DP_H_RSTBf_GET BCMI_TSCE16_XGXS_PMD_X4_CTLr_LN_TX_DP_H_RSTBf_GET
#define PMD_X4_CTLr_LN_TX_DP_H_RSTBf_SET BCMI_TSCE16_XGXS_PMD_X4_CTLr_LN_TX_DP_H_RSTBf_SET
#define PMD_X4_CTLr_RX_DME_ENf_GET BCMI_TSCE16_XGXS_PMD_X4_CTLr_RX_DME_ENf_GET
#define PMD_X4_CTLr_RX_DME_ENf_SET BCMI_TSCE16_XGXS_PMD_X4_CTLr_RX_DME_ENf_SET
#define PMD_X4_CTLr_RX_OSR_MODEf_GET BCMI_TSCE16_XGXS_PMD_X4_CTLr_RX_OSR_MODEf_GET
#define PMD_X4_CTLr_RX_OSR_MODEf_SET BCMI_TSCE16_XGXS_PMD_X4_CTLr_RX_OSR_MODEf_SET
#define PMD_X4_CTLr_TX_DISABLEf_GET BCMI_TSCE16_XGXS_PMD_X4_CTLr_TX_DISABLEf_GET
#define PMD_X4_CTLr_TX_DISABLEf_SET BCMI_TSCE16_XGXS_PMD_X4_CTLr_TX_DISABLEf_SET
#define PMD_X4_CTLr_TX_OSR_MODEf_GET BCMI_TSCE16_XGXS_PMD_X4_CTLr_TX_OSR_MODEf_GET
#define PMD_X4_CTLr_TX_OSR_MODEf_SET BCMI_TSCE16_XGXS_PMD_X4_CTLr_TX_OSR_MODEf_SET
#define PMD_X4_CTLr_LN_RX_H_PWRDNf_GET BCMI_TSCE16_XGXS_PMD_X4_CTLr_LN_RX_H_PWRDNf_GET
#define PMD_X4_CTLr_LN_RX_H_PWRDNf_SET BCMI_TSCE16_XGXS_PMD_X4_CTLr_LN_RX_H_PWRDNf_SET
#define PMD_X4_CTLr_LN_TX_H_PWRDNf_GET BCMI_TSCE16_XGXS_PMD_X4_CTLr_LN_TX_H_PWRDNf_GET
#define PMD_X4_CTLr_LN_TX_H_PWRDNf_SET BCMI_TSCE16_XGXS_PMD_X4_CTLr_LN_TX_H_PWRDNf_SET
#define PMD_X4_CTLr_LN_RX_H_RSTBf_GET BCMI_TSCE16_XGXS_PMD_X4_CTLr_LN_RX_H_RSTBf_GET
#define PMD_X4_CTLr_LN_RX_H_RSTBf_SET BCMI_TSCE16_XGXS_PMD_X4_CTLr_LN_RX_H_RSTBf_SET
#define PMD_X4_CTLr_LN_RX_DP_H_RSTBf_GET BCMI_TSCE16_XGXS_PMD_X4_CTLr_LN_RX_DP_H_RSTBf_GET
#define PMD_X4_CTLr_LN_RX_DP_H_RSTBf_SET BCMI_TSCE16_XGXS_PMD_X4_CTLr_LN_RX_DP_H_RSTBf_SET
#define READ_PMD_X4_CTLr BCMI_TSCE16_XGXS_READ_PMD_X4_CTLr
#define WRITE_PMD_X4_CTLr BCMI_TSCE16_XGXS_WRITE_PMD_X4_CTLr
#define MODIFY_PMD_X4_CTLr BCMI_TSCE16_XGXS_MODIFY_PMD_X4_CTLr
#define READLN_PMD_X4_CTLr BCMI_TSCE16_XGXS_READLN_PMD_X4_CTLr
#define WRITELN_PMD_X4_CTLr BCMI_TSCE16_XGXS_WRITELN_PMD_X4_CTLr
#define WRITEALL_PMD_X4_CTLr BCMI_TSCE16_XGXS_WRITEALL_PMD_X4_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PMD_X4_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PMD_X4_MODE
 * BLOCKS:   PMD_X4
 * REGADDR:  0xc011
 * DESC:     PMD lane mode configuration
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LANE_MODE        Lane modeUse the following format: {reserved[4:0], cl72_en, scrambler_dis, eee_mode_en, speed_id[7:0]}Only used for Speed Control bypass operation
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PMD_X4_MODEr (0x0000c011 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PMD_X4_MODEr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X4_MODE.
 *
 */
typedef union BCMI_TSCE16_XGXS_PMD_X4_MODEr_s {
	uint32_t v[1];
	uint32_t pmd_x4_mode[1];
	uint32_t _pmd_x4_mode;
} BCMI_TSCE16_XGXS_PMD_X4_MODEr_t;

#define BCMI_TSCE16_XGXS_PMD_X4_MODEr_CLR(r) (r).pmd_x4_mode[0] = 0
#define BCMI_TSCE16_XGXS_PMD_X4_MODEr_SET(r,d) (r).pmd_x4_mode[0] = d
#define BCMI_TSCE16_XGXS_PMD_X4_MODEr_GET(r) (r).pmd_x4_mode[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PMD_X4_MODEr_LANE_MODEf_GET(r) (((r).pmd_x4_mode[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PMD_X4_MODEr_LANE_MODEf_SET(r,f) (r).pmd_x4_mode[0]=(((r).pmd_x4_mode[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PMD_X4_MODE.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PMD_X4_MODEr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PMD_X4_MODEr,(_r._pmd_x4_mode))
#define BCMI_TSCE16_XGXS_WRITE_PMD_X4_MODEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X4_MODEr,(_r._pmd_x4_mode)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PMD_X4_MODEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X4_MODEr,(_r._pmd_x4_mode))
#define BCMI_TSCE16_XGXS_READLN_PMD_X4_MODEr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PMD_X4_MODEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_mode))
#define BCMI_TSCE16_XGXS_WRITELN_PMD_X4_MODEr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X4_MODEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_mode))
#define BCMI_TSCE16_XGXS_WRITEALL_PMD_X4_MODEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X4_MODEr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pmd_x4_mode))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X4_MODEr BCMI_TSCE16_XGXS_PMD_X4_MODEr
#define PMD_X4_MODEr_SIZE BCMI_TSCE16_XGXS_PMD_X4_MODEr_SIZE
typedef BCMI_TSCE16_XGXS_PMD_X4_MODEr_t PMD_X4_MODEr_t;
#define PMD_X4_MODEr_CLR BCMI_TSCE16_XGXS_PMD_X4_MODEr_CLR
#define PMD_X4_MODEr_SET BCMI_TSCE16_XGXS_PMD_X4_MODEr_SET
#define PMD_X4_MODEr_GET BCMI_TSCE16_XGXS_PMD_X4_MODEr_GET
#define PMD_X4_MODEr_LANE_MODEf_GET BCMI_TSCE16_XGXS_PMD_X4_MODEr_LANE_MODEf_GET
#define PMD_X4_MODEr_LANE_MODEf_SET BCMI_TSCE16_XGXS_PMD_X4_MODEr_LANE_MODEf_SET
#define READ_PMD_X4_MODEr BCMI_TSCE16_XGXS_READ_PMD_X4_MODEr
#define WRITE_PMD_X4_MODEr BCMI_TSCE16_XGXS_WRITE_PMD_X4_MODEr
#define MODIFY_PMD_X4_MODEr BCMI_TSCE16_XGXS_MODIFY_PMD_X4_MODEr
#define READLN_PMD_X4_MODEr BCMI_TSCE16_XGXS_READLN_PMD_X4_MODEr
#define WRITELN_PMD_X4_MODEr BCMI_TSCE16_XGXS_WRITELN_PMD_X4_MODEr
#define WRITEALL_PMD_X4_MODEr BCMI_TSCE16_XGXS_WRITEALL_PMD_X4_MODEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PMD_X4_MODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PMD_X4_STS
 * BLOCKS:   PMD_X4
 * REGADDR:  0xc012
 * DESC:     PMD lane live status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_LOCK_STS      DSC RX lock indication from PMD
 *     SIGNAL_DETECT_STS Signal Detect indication from PMD
 *     RX_CLK_VLD_STS   rx_clk_vld indication from PMD
 *     TX_CLK_VLD_STS   tx_clk_vld indication from PMD
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PMD_X4_STSr (0x0000c012 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PMD_X4_STSr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X4_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_PMD_X4_STSr_s {
	uint32_t v[1];
	uint32_t pmd_x4_sts[1];
	uint32_t _pmd_x4_sts;
} BCMI_TSCE16_XGXS_PMD_X4_STSr_t;

#define BCMI_TSCE16_XGXS_PMD_X4_STSr_CLR(r) (r).pmd_x4_sts[0] = 0
#define BCMI_TSCE16_XGXS_PMD_X4_STSr_SET(r,d) (r).pmd_x4_sts[0] = d
#define BCMI_TSCE16_XGXS_PMD_X4_STSr_GET(r) (r).pmd_x4_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PMD_X4_STSr_TX_CLK_VLD_STSf_GET(r) ((((r).pmd_x4_sts[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X4_STSr_TX_CLK_VLD_STSf_SET(r,f) (r).pmd_x4_sts[0]=(((r).pmd_x4_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_PMD_X4_STSr_RX_CLK_VLD_STSf_GET(r) ((((r).pmd_x4_sts[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X4_STSr_RX_CLK_VLD_STSf_SET(r,f) (r).pmd_x4_sts[0]=(((r).pmd_x4_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_PMD_X4_STSr_SIGNAL_DETECT_STSf_GET(r) ((((r).pmd_x4_sts[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X4_STSr_SIGNAL_DETECT_STSf_SET(r,f) (r).pmd_x4_sts[0]=(((r).pmd_x4_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_PMD_X4_STSr_RX_LOCK_STSf_GET(r) (((r).pmd_x4_sts[0]) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X4_STSr_RX_LOCK_STSf_SET(r,f) (r).pmd_x4_sts[0]=(((r).pmd_x4_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PMD_X4_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PMD_X4_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PMD_X4_STSr,(_r._pmd_x4_sts))
#define BCMI_TSCE16_XGXS_WRITE_PMD_X4_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X4_STSr,(_r._pmd_x4_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PMD_X4_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X4_STSr,(_r._pmd_x4_sts))
#define BCMI_TSCE16_XGXS_READLN_PMD_X4_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PMD_X4_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_sts))
#define BCMI_TSCE16_XGXS_WRITELN_PMD_X4_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X4_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_PMD_X4_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X4_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pmd_x4_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X4_STSr BCMI_TSCE16_XGXS_PMD_X4_STSr
#define PMD_X4_STSr_SIZE BCMI_TSCE16_XGXS_PMD_X4_STSr_SIZE
typedef BCMI_TSCE16_XGXS_PMD_X4_STSr_t PMD_X4_STSr_t;
#define PMD_X4_STSr_CLR BCMI_TSCE16_XGXS_PMD_X4_STSr_CLR
#define PMD_X4_STSr_SET BCMI_TSCE16_XGXS_PMD_X4_STSr_SET
#define PMD_X4_STSr_GET BCMI_TSCE16_XGXS_PMD_X4_STSr_GET
#define PMD_X4_STSr_TX_CLK_VLD_STSf_GET BCMI_TSCE16_XGXS_PMD_X4_STSr_TX_CLK_VLD_STSf_GET
#define PMD_X4_STSr_TX_CLK_VLD_STSf_SET BCMI_TSCE16_XGXS_PMD_X4_STSr_TX_CLK_VLD_STSf_SET
#define PMD_X4_STSr_RX_CLK_VLD_STSf_GET BCMI_TSCE16_XGXS_PMD_X4_STSr_RX_CLK_VLD_STSf_GET
#define PMD_X4_STSr_RX_CLK_VLD_STSf_SET BCMI_TSCE16_XGXS_PMD_X4_STSr_RX_CLK_VLD_STSf_SET
#define PMD_X4_STSr_SIGNAL_DETECT_STSf_GET BCMI_TSCE16_XGXS_PMD_X4_STSr_SIGNAL_DETECT_STSf_GET
#define PMD_X4_STSr_SIGNAL_DETECT_STSf_SET BCMI_TSCE16_XGXS_PMD_X4_STSr_SIGNAL_DETECT_STSf_SET
#define PMD_X4_STSr_RX_LOCK_STSf_GET BCMI_TSCE16_XGXS_PMD_X4_STSr_RX_LOCK_STSf_GET
#define PMD_X4_STSr_RX_LOCK_STSf_SET BCMI_TSCE16_XGXS_PMD_X4_STSr_RX_LOCK_STSf_SET
#define READ_PMD_X4_STSr BCMI_TSCE16_XGXS_READ_PMD_X4_STSr
#define WRITE_PMD_X4_STSr BCMI_TSCE16_XGXS_WRITE_PMD_X4_STSr
#define MODIFY_PMD_X4_STSr BCMI_TSCE16_XGXS_MODIFY_PMD_X4_STSr
#define READLN_PMD_X4_STSr BCMI_TSCE16_XGXS_READLN_PMD_X4_STSr
#define WRITELN_PMD_X4_STSr BCMI_TSCE16_XGXS_WRITELN_PMD_X4_STSr
#define WRITEALL_PMD_X4_STSr BCMI_TSCE16_XGXS_WRITEALL_PMD_X4_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PMD_X4_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PMD_X4_LATCH_STS
 * BLOCKS:   PMD_X4
 * REGADDR:  0xc013
 * DESC:     PMD lane latched status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LOCK_LL       DSC RX lock indication from PMD negedge detected
 *     RX_LOCK_LH       DSC RX lock indication from PMD posedge detected
 *     SIGNAL_DETECT_LL Signal Detect indication from PMD negedge detected
 *     SIGNAL_DETECT_LH Signal Detect indication from PMD posedge detected
 *     RX_CLK_VLD_LL    rx_clk_vld indication from PMD negedge detected
 *     RX_CLK_VLD_LH    rx_clk_vld indication from PMD posedge detected
 *     TX_CLK_VLD_LL    tx_clk_vld indication from PMD negedge detected
 *     TX_CLK_VLD_LH    tx_clk_vld indication from PMD posedge detected
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr (0x0000c013 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X4_LATCH_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_s {
	uint32_t v[1];
	uint32_t pmd_x4_latch_sts[1];
	uint32_t _pmd_x4_latch_sts;
} BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_t;

#define BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_CLR(r) (r).pmd_x4_latch_sts[0] = 0
#define BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_SET(r,d) (r).pmd_x4_latch_sts[0] = d
#define BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_GET(r) (r).pmd_x4_latch_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_TX_CLK_VLD_LHf_GET(r) ((((r).pmd_x4_latch_sts[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_TX_CLK_VLD_LHf_SET(r,f) (r).pmd_x4_latch_sts[0]=(((r).pmd_x4_latch_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_TX_CLK_VLD_LLf_GET(r) ((((r).pmd_x4_latch_sts[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_TX_CLK_VLD_LLf_SET(r,f) (r).pmd_x4_latch_sts[0]=(((r).pmd_x4_latch_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LHf_GET(r) ((((r).pmd_x4_latch_sts[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LHf_SET(r,f) (r).pmd_x4_latch_sts[0]=(((r).pmd_x4_latch_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LLf_GET(r) ((((r).pmd_x4_latch_sts[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LLf_SET(r,f) (r).pmd_x4_latch_sts[0]=(((r).pmd_x4_latch_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LHf_GET(r) ((((r).pmd_x4_latch_sts[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LHf_SET(r,f) (r).pmd_x4_latch_sts[0]=(((r).pmd_x4_latch_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LLf_GET(r) ((((r).pmd_x4_latch_sts[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LLf_SET(r,f) (r).pmd_x4_latch_sts[0]=(((r).pmd_x4_latch_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LHf_GET(r) ((((r).pmd_x4_latch_sts[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LHf_SET(r,f) (r).pmd_x4_latch_sts[0]=(((r).pmd_x4_latch_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LLf_GET(r) (((r).pmd_x4_latch_sts[0]) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LLf_SET(r,f) (r).pmd_x4_latch_sts[0]=(((r).pmd_x4_latch_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PMD_X4_LATCH_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PMD_X4_LATCH_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr,(_r._pmd_x4_latch_sts))
#define BCMI_TSCE16_XGXS_WRITE_PMD_X4_LATCH_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr,(_r._pmd_x4_latch_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PMD_X4_LATCH_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr,(_r._pmd_x4_latch_sts))
#define BCMI_TSCE16_XGXS_READLN_PMD_X4_LATCH_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_latch_sts))
#define BCMI_TSCE16_XGXS_WRITELN_PMD_X4_LATCH_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_latch_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_PMD_X4_LATCH_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pmd_x4_latch_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X4_LATCH_STSr BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr
#define PMD_X4_LATCH_STSr_SIZE BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_SIZE
typedef BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_t PMD_X4_LATCH_STSr_t;
#define PMD_X4_LATCH_STSr_CLR BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_CLR
#define PMD_X4_LATCH_STSr_SET BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_SET
#define PMD_X4_LATCH_STSr_GET BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_GET
#define PMD_X4_LATCH_STSr_TX_CLK_VLD_LHf_GET BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_TX_CLK_VLD_LHf_GET
#define PMD_X4_LATCH_STSr_TX_CLK_VLD_LHf_SET BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_TX_CLK_VLD_LHf_SET
#define PMD_X4_LATCH_STSr_TX_CLK_VLD_LLf_GET BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_TX_CLK_VLD_LLf_GET
#define PMD_X4_LATCH_STSr_TX_CLK_VLD_LLf_SET BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_TX_CLK_VLD_LLf_SET
#define PMD_X4_LATCH_STSr_RX_CLK_VLD_LHf_GET BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LHf_GET
#define PMD_X4_LATCH_STSr_RX_CLK_VLD_LHf_SET BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LHf_SET
#define PMD_X4_LATCH_STSr_RX_CLK_VLD_LLf_GET BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LLf_GET
#define PMD_X4_LATCH_STSr_RX_CLK_VLD_LLf_SET BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LLf_SET
#define PMD_X4_LATCH_STSr_SIGNAL_DETECT_LHf_GET BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LHf_GET
#define PMD_X4_LATCH_STSr_SIGNAL_DETECT_LHf_SET BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LHf_SET
#define PMD_X4_LATCH_STSr_SIGNAL_DETECT_LLf_GET BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LLf_GET
#define PMD_X4_LATCH_STSr_SIGNAL_DETECT_LLf_SET BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LLf_SET
#define PMD_X4_LATCH_STSr_RX_LOCK_LHf_GET BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LHf_GET
#define PMD_X4_LATCH_STSr_RX_LOCK_LHf_SET BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LHf_SET
#define PMD_X4_LATCH_STSr_RX_LOCK_LLf_GET BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LLf_GET
#define PMD_X4_LATCH_STSr_RX_LOCK_LLf_SET BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LLf_SET
#define READ_PMD_X4_LATCH_STSr BCMI_TSCE16_XGXS_READ_PMD_X4_LATCH_STSr
#define WRITE_PMD_X4_LATCH_STSr BCMI_TSCE16_XGXS_WRITE_PMD_X4_LATCH_STSr
#define MODIFY_PMD_X4_LATCH_STSr BCMI_TSCE16_XGXS_MODIFY_PMD_X4_LATCH_STSr
#define READLN_PMD_X4_LATCH_STSr BCMI_TSCE16_XGXS_READLN_PMD_X4_LATCH_STSr
#define WRITELN_PMD_X4_LATCH_STSr BCMI_TSCE16_XGXS_WRITELN_PMD_X4_LATCH_STSr
#define WRITEALL_PMD_X4_LATCH_STSr BCMI_TSCE16_XGXS_WRITEALL_PMD_X4_LATCH_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PMD_X4_LATCH_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PMD_X4_OVRR
 * BLOCKS:   PMD_X4
 * REGADDR:  0xc014
 * DESC:     PMD lane override
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LOCK_OVRD     Override for DSC RX lock indication from PMD
 *     SIGNAL_DETECT_OVRD Override for Signal Detect indication from PMD
 *     RX_CLK_VLD_OVRD  Override rx_clk_vld indication from PMD
 *     LANE_MODE_OEN    Lane mode override enable
 *     RX_OSR_MODE_OEN  OSR mode, overrideOnly used for Speed Control bypass operation
 *     RX_DME_EN_OEN    DME is enabled, overrideOnly used for Speed Control bypass operation
 *     TX_DISABLE_OEN   tx_disable override enableOnly used for Speed Control bypass operation
 *     LN_RX_DP_H_RSTB_OEN PMD Lane Data path reset override enableOnly used for Speed Control bypass operation
 *     TX_CLK_VLD_OVRD  Override tx_clk_vld indication from PMDOnly used for Speed Control bypass operation
 *     TX_OSR_MODE_OEN  OSR mode, overrideOnly used for Speed Control bypass operation
 *     LN_TX_DP_H_RSTB_OEN PMD Lane Data path reset override enableOnly used for Speed Control bypass operation
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PMD_X4_OVRRr (0x0000c014 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PMD_X4_OVRRr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X4_OVRR.
 *
 */
typedef union BCMI_TSCE16_XGXS_PMD_X4_OVRRr_s {
	uint32_t v[1];
	uint32_t pmd_x4_ovrr[1];
	uint32_t _pmd_x4_ovrr;
} BCMI_TSCE16_XGXS_PMD_X4_OVRRr_t;

#define BCMI_TSCE16_XGXS_PMD_X4_OVRRr_CLR(r) (r).pmd_x4_ovrr[0] = 0
#define BCMI_TSCE16_XGXS_PMD_X4_OVRRr_SET(r,d) (r).pmd_x4_ovrr[0] = d
#define BCMI_TSCE16_XGXS_PMD_X4_OVRRr_GET(r) (r).pmd_x4_ovrr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PMD_X4_OVRRr_LN_TX_DP_H_RSTB_OENf_GET(r) ((((r).pmd_x4_ovrr[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X4_OVRRr_LN_TX_DP_H_RSTB_OENf_SET(r,f) (r).pmd_x4_ovrr[0]=(((r).pmd_x4_ovrr[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_PMD_X4_OVRRr_TX_OSR_MODE_OENf_GET(r) ((((r).pmd_x4_ovrr[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X4_OVRRr_TX_OSR_MODE_OENf_SET(r,f) (r).pmd_x4_ovrr[0]=(((r).pmd_x4_ovrr[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_PMD_X4_OVRRr_TX_CLK_VLD_OVRDf_GET(r) ((((r).pmd_x4_ovrr[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X4_OVRRr_TX_CLK_VLD_OVRDf_SET(r,f) (r).pmd_x4_ovrr[0]=(((r).pmd_x4_ovrr[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_PMD_X4_OVRRr_LN_RX_DP_H_RSTB_OENf_GET(r) ((((r).pmd_x4_ovrr[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X4_OVRRr_LN_RX_DP_H_RSTB_OENf_SET(r,f) (r).pmd_x4_ovrr[0]=(((r).pmd_x4_ovrr[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_PMD_X4_OVRRr_TX_DISABLE_OENf_GET(r) ((((r).pmd_x4_ovrr[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X4_OVRRr_TX_DISABLE_OENf_SET(r,f) (r).pmd_x4_ovrr[0]=(((r).pmd_x4_ovrr[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_PMD_X4_OVRRr_RX_DME_EN_OENf_GET(r) ((((r).pmd_x4_ovrr[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X4_OVRRr_RX_DME_EN_OENf_SET(r,f) (r).pmd_x4_ovrr[0]=(((r).pmd_x4_ovrr[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_PMD_X4_OVRRr_RX_OSR_MODE_OENf_GET(r) ((((r).pmd_x4_ovrr[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X4_OVRRr_RX_OSR_MODE_OENf_SET(r,f) (r).pmd_x4_ovrr[0]=(((r).pmd_x4_ovrr[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_PMD_X4_OVRRr_LANE_MODE_OENf_GET(r) ((((r).pmd_x4_ovrr[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X4_OVRRr_LANE_MODE_OENf_SET(r,f) (r).pmd_x4_ovrr[0]=(((r).pmd_x4_ovrr[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_PMD_X4_OVRRr_RX_CLK_VLD_OVRDf_GET(r) ((((r).pmd_x4_ovrr[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X4_OVRRr_RX_CLK_VLD_OVRDf_SET(r,f) (r).pmd_x4_ovrr[0]=(((r).pmd_x4_ovrr[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_PMD_X4_OVRRr_SIGNAL_DETECT_OVRDf_GET(r) ((((r).pmd_x4_ovrr[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X4_OVRRr_SIGNAL_DETECT_OVRDf_SET(r,f) (r).pmd_x4_ovrr[0]=(((r).pmd_x4_ovrr[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_PMD_X4_OVRRr_RX_LOCK_OVRDf_GET(r) (((r).pmd_x4_ovrr[0]) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X4_OVRRr_RX_LOCK_OVRDf_SET(r,f) (r).pmd_x4_ovrr[0]=(((r).pmd_x4_ovrr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PMD_X4_OVRR.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PMD_X4_OVRRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PMD_X4_OVRRr,(_r._pmd_x4_ovrr))
#define BCMI_TSCE16_XGXS_WRITE_PMD_X4_OVRRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X4_OVRRr,(_r._pmd_x4_ovrr)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PMD_X4_OVRRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X4_OVRRr,(_r._pmd_x4_ovrr))
#define BCMI_TSCE16_XGXS_READLN_PMD_X4_OVRRr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PMD_X4_OVRRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_ovrr))
#define BCMI_TSCE16_XGXS_WRITELN_PMD_X4_OVRRr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X4_OVRRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_ovrr))
#define BCMI_TSCE16_XGXS_WRITEALL_PMD_X4_OVRRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X4_OVRRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pmd_x4_ovrr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X4_OVRRr BCMI_TSCE16_XGXS_PMD_X4_OVRRr
#define PMD_X4_OVRRr_SIZE BCMI_TSCE16_XGXS_PMD_X4_OVRRr_SIZE
typedef BCMI_TSCE16_XGXS_PMD_X4_OVRRr_t PMD_X4_OVRRr_t;
#define PMD_X4_OVRRr_CLR BCMI_TSCE16_XGXS_PMD_X4_OVRRr_CLR
#define PMD_X4_OVRRr_SET BCMI_TSCE16_XGXS_PMD_X4_OVRRr_SET
#define PMD_X4_OVRRr_GET BCMI_TSCE16_XGXS_PMD_X4_OVRRr_GET
#define PMD_X4_OVRRr_LN_TX_DP_H_RSTB_OENf_GET BCMI_TSCE16_XGXS_PMD_X4_OVRRr_LN_TX_DP_H_RSTB_OENf_GET
#define PMD_X4_OVRRr_LN_TX_DP_H_RSTB_OENf_SET BCMI_TSCE16_XGXS_PMD_X4_OVRRr_LN_TX_DP_H_RSTB_OENf_SET
#define PMD_X4_OVRRr_TX_OSR_MODE_OENf_GET BCMI_TSCE16_XGXS_PMD_X4_OVRRr_TX_OSR_MODE_OENf_GET
#define PMD_X4_OVRRr_TX_OSR_MODE_OENf_SET BCMI_TSCE16_XGXS_PMD_X4_OVRRr_TX_OSR_MODE_OENf_SET
#define PMD_X4_OVRRr_TX_CLK_VLD_OVRDf_GET BCMI_TSCE16_XGXS_PMD_X4_OVRRr_TX_CLK_VLD_OVRDf_GET
#define PMD_X4_OVRRr_TX_CLK_VLD_OVRDf_SET BCMI_TSCE16_XGXS_PMD_X4_OVRRr_TX_CLK_VLD_OVRDf_SET
#define PMD_X4_OVRRr_LN_RX_DP_H_RSTB_OENf_GET BCMI_TSCE16_XGXS_PMD_X4_OVRRr_LN_RX_DP_H_RSTB_OENf_GET
#define PMD_X4_OVRRr_LN_RX_DP_H_RSTB_OENf_SET BCMI_TSCE16_XGXS_PMD_X4_OVRRr_LN_RX_DP_H_RSTB_OENf_SET
#define PMD_X4_OVRRr_TX_DISABLE_OENf_GET BCMI_TSCE16_XGXS_PMD_X4_OVRRr_TX_DISABLE_OENf_GET
#define PMD_X4_OVRRr_TX_DISABLE_OENf_SET BCMI_TSCE16_XGXS_PMD_X4_OVRRr_TX_DISABLE_OENf_SET
#define PMD_X4_OVRRr_RX_DME_EN_OENf_GET BCMI_TSCE16_XGXS_PMD_X4_OVRRr_RX_DME_EN_OENf_GET
#define PMD_X4_OVRRr_RX_DME_EN_OENf_SET BCMI_TSCE16_XGXS_PMD_X4_OVRRr_RX_DME_EN_OENf_SET
#define PMD_X4_OVRRr_RX_OSR_MODE_OENf_GET BCMI_TSCE16_XGXS_PMD_X4_OVRRr_RX_OSR_MODE_OENf_GET
#define PMD_X4_OVRRr_RX_OSR_MODE_OENf_SET BCMI_TSCE16_XGXS_PMD_X4_OVRRr_RX_OSR_MODE_OENf_SET
#define PMD_X4_OVRRr_LANE_MODE_OENf_GET BCMI_TSCE16_XGXS_PMD_X4_OVRRr_LANE_MODE_OENf_GET
#define PMD_X4_OVRRr_LANE_MODE_OENf_SET BCMI_TSCE16_XGXS_PMD_X4_OVRRr_LANE_MODE_OENf_SET
#define PMD_X4_OVRRr_RX_CLK_VLD_OVRDf_GET BCMI_TSCE16_XGXS_PMD_X4_OVRRr_RX_CLK_VLD_OVRDf_GET
#define PMD_X4_OVRRr_RX_CLK_VLD_OVRDf_SET BCMI_TSCE16_XGXS_PMD_X4_OVRRr_RX_CLK_VLD_OVRDf_SET
#define PMD_X4_OVRRr_SIGNAL_DETECT_OVRDf_GET BCMI_TSCE16_XGXS_PMD_X4_OVRRr_SIGNAL_DETECT_OVRDf_GET
#define PMD_X4_OVRRr_SIGNAL_DETECT_OVRDf_SET BCMI_TSCE16_XGXS_PMD_X4_OVRRr_SIGNAL_DETECT_OVRDf_SET
#define PMD_X4_OVRRr_RX_LOCK_OVRDf_GET BCMI_TSCE16_XGXS_PMD_X4_OVRRr_RX_LOCK_OVRDf_GET
#define PMD_X4_OVRRr_RX_LOCK_OVRDf_SET BCMI_TSCE16_XGXS_PMD_X4_OVRRr_RX_LOCK_OVRDf_SET
#define READ_PMD_X4_OVRRr BCMI_TSCE16_XGXS_READ_PMD_X4_OVRRr
#define WRITE_PMD_X4_OVRRr BCMI_TSCE16_XGXS_WRITE_PMD_X4_OVRRr
#define MODIFY_PMD_X4_OVRRr BCMI_TSCE16_XGXS_MODIFY_PMD_X4_OVRRr
#define READLN_PMD_X4_OVRRr BCMI_TSCE16_XGXS_READLN_PMD_X4_OVRRr
#define WRITELN_PMD_X4_OVRRr BCMI_TSCE16_XGXS_WRITELN_PMD_X4_OVRRr
#define WRITEALL_PMD_X4_OVRRr BCMI_TSCE16_XGXS_WRITEALL_PMD_X4_OVRRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PMD_X4_OVRRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PMD_X4_EEE_CTL
 * BLOCKS:   PMD_X4
 * REGADDR:  0xc018
 * DESC:     PMD lane eee controls
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_MODE          EEE tx low power modeEEE low power operation is not supported by TSC
 *     RX_MODE          EEE rx low power modeEEE low power operation is not supported by TSC
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PMD_X4_EEE_CTLr (0x0000c018 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PMD_X4_EEE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X4_EEE_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_PMD_X4_EEE_CTLr_s {
	uint32_t v[1];
	uint32_t pmd_x4_eee_ctl[1];
	uint32_t _pmd_x4_eee_ctl;
} BCMI_TSCE16_XGXS_PMD_X4_EEE_CTLr_t;

#define BCMI_TSCE16_XGXS_PMD_X4_EEE_CTLr_CLR(r) (r).pmd_x4_eee_ctl[0] = 0
#define BCMI_TSCE16_XGXS_PMD_X4_EEE_CTLr_SET(r,d) (r).pmd_x4_eee_ctl[0] = d
#define BCMI_TSCE16_XGXS_PMD_X4_EEE_CTLr_GET(r) (r).pmd_x4_eee_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PMD_X4_EEE_CTLr_RX_MODEf_GET(r) ((((r).pmd_x4_eee_ctl[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X4_EEE_CTLr_RX_MODEf_SET(r,f) (r).pmd_x4_eee_ctl[0]=(((r).pmd_x4_eee_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_PMD_X4_EEE_CTLr_TX_MODEf_GET(r) (((r).pmd_x4_eee_ctl[0]) & 0x3)
#define BCMI_TSCE16_XGXS_PMD_X4_EEE_CTLr_TX_MODEf_SET(r,f) (r).pmd_x4_eee_ctl[0]=(((r).pmd_x4_eee_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access PMD_X4_EEE_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PMD_X4_EEE_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PMD_X4_EEE_CTLr,(_r._pmd_x4_eee_ctl))
#define BCMI_TSCE16_XGXS_WRITE_PMD_X4_EEE_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X4_EEE_CTLr,(_r._pmd_x4_eee_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PMD_X4_EEE_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X4_EEE_CTLr,(_r._pmd_x4_eee_ctl))
#define BCMI_TSCE16_XGXS_READLN_PMD_X4_EEE_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PMD_X4_EEE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_eee_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_PMD_X4_EEE_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X4_EEE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_eee_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_PMD_X4_EEE_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X4_EEE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pmd_x4_eee_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X4_EEE_CTLr BCMI_TSCE16_XGXS_PMD_X4_EEE_CTLr
#define PMD_X4_EEE_CTLr_SIZE BCMI_TSCE16_XGXS_PMD_X4_EEE_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_PMD_X4_EEE_CTLr_t PMD_X4_EEE_CTLr_t;
#define PMD_X4_EEE_CTLr_CLR BCMI_TSCE16_XGXS_PMD_X4_EEE_CTLr_CLR
#define PMD_X4_EEE_CTLr_SET BCMI_TSCE16_XGXS_PMD_X4_EEE_CTLr_SET
#define PMD_X4_EEE_CTLr_GET BCMI_TSCE16_XGXS_PMD_X4_EEE_CTLr_GET
#define PMD_X4_EEE_CTLr_RX_MODEf_GET BCMI_TSCE16_XGXS_PMD_X4_EEE_CTLr_RX_MODEf_GET
#define PMD_X4_EEE_CTLr_RX_MODEf_SET BCMI_TSCE16_XGXS_PMD_X4_EEE_CTLr_RX_MODEf_SET
#define PMD_X4_EEE_CTLr_TX_MODEf_GET BCMI_TSCE16_XGXS_PMD_X4_EEE_CTLr_TX_MODEf_GET
#define PMD_X4_EEE_CTLr_TX_MODEf_SET BCMI_TSCE16_XGXS_PMD_X4_EEE_CTLr_TX_MODEf_SET
#define READ_PMD_X4_EEE_CTLr BCMI_TSCE16_XGXS_READ_PMD_X4_EEE_CTLr
#define WRITE_PMD_X4_EEE_CTLr BCMI_TSCE16_XGXS_WRITE_PMD_X4_EEE_CTLr
#define MODIFY_PMD_X4_EEE_CTLr BCMI_TSCE16_XGXS_MODIFY_PMD_X4_EEE_CTLr
#define READLN_PMD_X4_EEE_CTLr BCMI_TSCE16_XGXS_READLN_PMD_X4_EEE_CTLr
#define WRITELN_PMD_X4_EEE_CTLr BCMI_TSCE16_XGXS_WRITELN_PMD_X4_EEE_CTLr
#define WRITEALL_PMD_X4_EEE_CTLr BCMI_TSCE16_XGXS_WRITEALL_PMD_X4_EEE_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PMD_X4_EEE_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PMD_X4_EEE_STS
 * BLOCKS:   PMD_X4
 * REGADDR:  0xc019
 * DESC:     PMD lane eee status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     ENERGY_DETECT    EEE Energy detection indication from PMDEEE low power operation is not supported by TSC
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PMD_X4_EEE_STSr (0x0000c019 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PMD_X4_EEE_STSr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X4_EEE_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_PMD_X4_EEE_STSr_s {
	uint32_t v[1];
	uint32_t pmd_x4_eee_sts[1];
	uint32_t _pmd_x4_eee_sts;
} BCMI_TSCE16_XGXS_PMD_X4_EEE_STSr_t;

#define BCMI_TSCE16_XGXS_PMD_X4_EEE_STSr_CLR(r) (r).pmd_x4_eee_sts[0] = 0
#define BCMI_TSCE16_XGXS_PMD_X4_EEE_STSr_SET(r,d) (r).pmd_x4_eee_sts[0] = d
#define BCMI_TSCE16_XGXS_PMD_X4_EEE_STSr_GET(r) (r).pmd_x4_eee_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PMD_X4_EEE_STSr_ENERGY_DETECTf_GET(r) (((r).pmd_x4_eee_sts[0]) & 0x1)
#define BCMI_TSCE16_XGXS_PMD_X4_EEE_STSr_ENERGY_DETECTf_SET(r,f) (r).pmd_x4_eee_sts[0]=(((r).pmd_x4_eee_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PMD_X4_EEE_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PMD_X4_EEE_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PMD_X4_EEE_STSr,(_r._pmd_x4_eee_sts))
#define BCMI_TSCE16_XGXS_WRITE_PMD_X4_EEE_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X4_EEE_STSr,(_r._pmd_x4_eee_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PMD_X4_EEE_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X4_EEE_STSr,(_r._pmd_x4_eee_sts))
#define BCMI_TSCE16_XGXS_READLN_PMD_X4_EEE_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PMD_X4_EEE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_eee_sts))
#define BCMI_TSCE16_XGXS_WRITELN_PMD_X4_EEE_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X4_EEE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_eee_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_PMD_X4_EEE_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_X4_EEE_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pmd_x4_eee_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X4_EEE_STSr BCMI_TSCE16_XGXS_PMD_X4_EEE_STSr
#define PMD_X4_EEE_STSr_SIZE BCMI_TSCE16_XGXS_PMD_X4_EEE_STSr_SIZE
typedef BCMI_TSCE16_XGXS_PMD_X4_EEE_STSr_t PMD_X4_EEE_STSr_t;
#define PMD_X4_EEE_STSr_CLR BCMI_TSCE16_XGXS_PMD_X4_EEE_STSr_CLR
#define PMD_X4_EEE_STSr_SET BCMI_TSCE16_XGXS_PMD_X4_EEE_STSr_SET
#define PMD_X4_EEE_STSr_GET BCMI_TSCE16_XGXS_PMD_X4_EEE_STSr_GET
#define PMD_X4_EEE_STSr_ENERGY_DETECTf_GET BCMI_TSCE16_XGXS_PMD_X4_EEE_STSr_ENERGY_DETECTf_GET
#define PMD_X4_EEE_STSr_ENERGY_DETECTf_SET BCMI_TSCE16_XGXS_PMD_X4_EEE_STSr_ENERGY_DETECTf_SET
#define READ_PMD_X4_EEE_STSr BCMI_TSCE16_XGXS_READ_PMD_X4_EEE_STSr
#define WRITE_PMD_X4_EEE_STSr BCMI_TSCE16_XGXS_WRITE_PMD_X4_EEE_STSr
#define MODIFY_PMD_X4_EEE_STSr BCMI_TSCE16_XGXS_MODIFY_PMD_X4_EEE_STSr
#define READLN_PMD_X4_EEE_STSr BCMI_TSCE16_XGXS_READLN_PMD_X4_EEE_STSr
#define WRITELN_PMD_X4_EEE_STSr BCMI_TSCE16_XGXS_WRITELN_PMD_X4_EEE_STSr
#define WRITEALL_PMD_X4_EEE_STSr BCMI_TSCE16_XGXS_WRITEALL_PMD_X4_EEE_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PMD_X4_EEE_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TXPKTCNT_U
 * BLOCKS:   PATGEN1
 * REGADDR:  0xc040
 * DESC:     TX Packet Count Upper Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TXPKTCNT_U       Read from this register will sample instanteneous value of the internal 32 bit number of transmited packets counter.16 upper bits are represented in this register, Lower 16 bits are represented in txpktcnt_L register.This register has to be read first for values in the txpktcnt_L to be updated.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TXPKTCNT_Ur (0x0000c040 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TXPKTCNT_Ur_SIZE 4

/*
 * This structure should be used to declare and program TXPKTCNT_U.
 *
 */
typedef union BCMI_TSCE16_XGXS_TXPKTCNT_Ur_s {
	uint32_t v[1];
	uint32_t txpktcnt_u[1];
	uint32_t _txpktcnt_u;
} BCMI_TSCE16_XGXS_TXPKTCNT_Ur_t;

#define BCMI_TSCE16_XGXS_TXPKTCNT_Ur_CLR(r) (r).txpktcnt_u[0] = 0
#define BCMI_TSCE16_XGXS_TXPKTCNT_Ur_SET(r,d) (r).txpktcnt_u[0] = d
#define BCMI_TSCE16_XGXS_TXPKTCNT_Ur_GET(r) (r).txpktcnt_u[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TXPKTCNT_Ur_TXPKTCNT_Uf_GET(r) (((r).txpktcnt_u[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_TXPKTCNT_Ur_TXPKTCNT_Uf_SET(r,f) (r).txpktcnt_u[0]=(((r).txpktcnt_u[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TXPKTCNT_U.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TXPKTCNT_Ur(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TXPKTCNT_Ur,(_r._txpktcnt_u))
#define BCMI_TSCE16_XGXS_WRITE_TXPKTCNT_Ur(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXPKTCNT_Ur,(_r._txpktcnt_u)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TXPKTCNT_Ur(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXPKTCNT_Ur,(_r._txpktcnt_u))
#define BCMI_TSCE16_XGXS_READLN_TXPKTCNT_Ur(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TXPKTCNT_Ur|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txpktcnt_u))
#define BCMI_TSCE16_XGXS_WRITELN_TXPKTCNT_Ur(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXPKTCNT_Ur|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txpktcnt_u))
#define BCMI_TSCE16_XGXS_WRITEALL_TXPKTCNT_Ur(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXPKTCNT_Ur|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txpktcnt_u))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXPKTCNT_Ur BCMI_TSCE16_XGXS_TXPKTCNT_Ur
#define TXPKTCNT_Ur_SIZE BCMI_TSCE16_XGXS_TXPKTCNT_Ur_SIZE
typedef BCMI_TSCE16_XGXS_TXPKTCNT_Ur_t TXPKTCNT_Ur_t;
#define TXPKTCNT_Ur_CLR BCMI_TSCE16_XGXS_TXPKTCNT_Ur_CLR
#define TXPKTCNT_Ur_SET BCMI_TSCE16_XGXS_TXPKTCNT_Ur_SET
#define TXPKTCNT_Ur_GET BCMI_TSCE16_XGXS_TXPKTCNT_Ur_GET
#define TXPKTCNT_Ur_TXPKTCNT_Uf_GET BCMI_TSCE16_XGXS_TXPKTCNT_Ur_TXPKTCNT_Uf_GET
#define TXPKTCNT_Ur_TXPKTCNT_Uf_SET BCMI_TSCE16_XGXS_TXPKTCNT_Ur_TXPKTCNT_Uf_SET
#define READ_TXPKTCNT_Ur BCMI_TSCE16_XGXS_READ_TXPKTCNT_Ur
#define WRITE_TXPKTCNT_Ur BCMI_TSCE16_XGXS_WRITE_TXPKTCNT_Ur
#define MODIFY_TXPKTCNT_Ur BCMI_TSCE16_XGXS_MODIFY_TXPKTCNT_Ur
#define READLN_TXPKTCNT_Ur BCMI_TSCE16_XGXS_READLN_TXPKTCNT_Ur
#define WRITELN_TXPKTCNT_Ur BCMI_TSCE16_XGXS_WRITELN_TXPKTCNT_Ur
#define WRITEALL_TXPKTCNT_Ur BCMI_TSCE16_XGXS_WRITEALL_TXPKTCNT_Ur

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TXPKTCNT_Ur'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TXPKTCNT_L
 * BLOCKS:   PATGEN1
 * REGADDR:  0xc041
 * DESC:     TX Packet Count Lower Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TXPKTCNT_L       Lower 16 bits of instanteneous value of the internal 32 bit number of transmited packets counter.The value is sampled on read from txpktcnt_U.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TXPKTCNT_Lr (0x0000c041 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TXPKTCNT_Lr_SIZE 4

/*
 * This structure should be used to declare and program TXPKTCNT_L.
 *
 */
typedef union BCMI_TSCE16_XGXS_TXPKTCNT_Lr_s {
	uint32_t v[1];
	uint32_t txpktcnt_l[1];
	uint32_t _txpktcnt_l;
} BCMI_TSCE16_XGXS_TXPKTCNT_Lr_t;

#define BCMI_TSCE16_XGXS_TXPKTCNT_Lr_CLR(r) (r).txpktcnt_l[0] = 0
#define BCMI_TSCE16_XGXS_TXPKTCNT_Lr_SET(r,d) (r).txpktcnt_l[0] = d
#define BCMI_TSCE16_XGXS_TXPKTCNT_Lr_GET(r) (r).txpktcnt_l[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TXPKTCNT_Lr_TXPKTCNT_Lf_GET(r) (((r).txpktcnt_l[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_TXPKTCNT_Lr_TXPKTCNT_Lf_SET(r,f) (r).txpktcnt_l[0]=(((r).txpktcnt_l[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TXPKTCNT_L.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TXPKTCNT_Lr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TXPKTCNT_Lr,(_r._txpktcnt_l))
#define BCMI_TSCE16_XGXS_WRITE_TXPKTCNT_Lr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXPKTCNT_Lr,(_r._txpktcnt_l)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TXPKTCNT_Lr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXPKTCNT_Lr,(_r._txpktcnt_l))
#define BCMI_TSCE16_XGXS_READLN_TXPKTCNT_Lr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TXPKTCNT_Lr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txpktcnt_l))
#define BCMI_TSCE16_XGXS_WRITELN_TXPKTCNT_Lr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXPKTCNT_Lr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txpktcnt_l))
#define BCMI_TSCE16_XGXS_WRITEALL_TXPKTCNT_Lr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXPKTCNT_Lr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txpktcnt_l))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXPKTCNT_Lr BCMI_TSCE16_XGXS_TXPKTCNT_Lr
#define TXPKTCNT_Lr_SIZE BCMI_TSCE16_XGXS_TXPKTCNT_Lr_SIZE
typedef BCMI_TSCE16_XGXS_TXPKTCNT_Lr_t TXPKTCNT_Lr_t;
#define TXPKTCNT_Lr_CLR BCMI_TSCE16_XGXS_TXPKTCNT_Lr_CLR
#define TXPKTCNT_Lr_SET BCMI_TSCE16_XGXS_TXPKTCNT_Lr_SET
#define TXPKTCNT_Lr_GET BCMI_TSCE16_XGXS_TXPKTCNT_Lr_GET
#define TXPKTCNT_Lr_TXPKTCNT_Lf_GET BCMI_TSCE16_XGXS_TXPKTCNT_Lr_TXPKTCNT_Lf_GET
#define TXPKTCNT_Lr_TXPKTCNT_Lf_SET BCMI_TSCE16_XGXS_TXPKTCNT_Lr_TXPKTCNT_Lf_SET
#define READ_TXPKTCNT_Lr BCMI_TSCE16_XGXS_READ_TXPKTCNT_Lr
#define WRITE_TXPKTCNT_Lr BCMI_TSCE16_XGXS_WRITE_TXPKTCNT_Lr
#define MODIFY_TXPKTCNT_Lr BCMI_TSCE16_XGXS_MODIFY_TXPKTCNT_Lr
#define READLN_TXPKTCNT_Lr BCMI_TSCE16_XGXS_READLN_TXPKTCNT_Lr
#define WRITELN_TXPKTCNT_Lr BCMI_TSCE16_XGXS_WRITELN_TXPKTCNT_Lr
#define WRITEALL_TXPKTCNT_Lr BCMI_TSCE16_XGXS_WRITEALL_TXPKTCNT_Lr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TXPKTCNT_Lr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RXPKTCNT_U
 * BLOCKS:   PATGEN1
 * REGADDR:  0xc042
 * DESC:     RX Packet Count Upper Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXPKTCNT_U       Read from this register will sample instanteneous value of the internal 32 bit number of received packets counter.16 upper bits are represented in this register, Lower 16 bits are represented in rxpktcnt_L register.This register has to be read first for values in the rxpktcnt_L to be updated.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RXPKTCNT_Ur (0x0000c042 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RXPKTCNT_Ur_SIZE 4

/*
 * This structure should be used to declare and program RXPKTCNT_U.
 *
 */
typedef union BCMI_TSCE16_XGXS_RXPKTCNT_Ur_s {
	uint32_t v[1];
	uint32_t rxpktcnt_u[1];
	uint32_t _rxpktcnt_u;
} BCMI_TSCE16_XGXS_RXPKTCNT_Ur_t;

#define BCMI_TSCE16_XGXS_RXPKTCNT_Ur_CLR(r) (r).rxpktcnt_u[0] = 0
#define BCMI_TSCE16_XGXS_RXPKTCNT_Ur_SET(r,d) (r).rxpktcnt_u[0] = d
#define BCMI_TSCE16_XGXS_RXPKTCNT_Ur_GET(r) (r).rxpktcnt_u[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RXPKTCNT_Ur_RXPKTCNT_Uf_GET(r) (((r).rxpktcnt_u[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_RXPKTCNT_Ur_RXPKTCNT_Uf_SET(r,f) (r).rxpktcnt_u[0]=(((r).rxpktcnt_u[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RXPKTCNT_U.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RXPKTCNT_Ur(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXPKTCNT_Ur,(_r._rxpktcnt_u))
#define BCMI_TSCE16_XGXS_WRITE_RXPKTCNT_Ur(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXPKTCNT_Ur,(_r._rxpktcnt_u)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RXPKTCNT_Ur(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXPKTCNT_Ur,(_r._rxpktcnt_u))
#define BCMI_TSCE16_XGXS_READLN_RXPKTCNT_Ur(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXPKTCNT_Ur|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxpktcnt_u))
#define BCMI_TSCE16_XGXS_WRITELN_RXPKTCNT_Ur(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXPKTCNT_Ur|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxpktcnt_u))
#define BCMI_TSCE16_XGXS_WRITEALL_RXPKTCNT_Ur(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXPKTCNT_Ur|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxpktcnt_u))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXPKTCNT_Ur BCMI_TSCE16_XGXS_RXPKTCNT_Ur
#define RXPKTCNT_Ur_SIZE BCMI_TSCE16_XGXS_RXPKTCNT_Ur_SIZE
typedef BCMI_TSCE16_XGXS_RXPKTCNT_Ur_t RXPKTCNT_Ur_t;
#define RXPKTCNT_Ur_CLR BCMI_TSCE16_XGXS_RXPKTCNT_Ur_CLR
#define RXPKTCNT_Ur_SET BCMI_TSCE16_XGXS_RXPKTCNT_Ur_SET
#define RXPKTCNT_Ur_GET BCMI_TSCE16_XGXS_RXPKTCNT_Ur_GET
#define RXPKTCNT_Ur_RXPKTCNT_Uf_GET BCMI_TSCE16_XGXS_RXPKTCNT_Ur_RXPKTCNT_Uf_GET
#define RXPKTCNT_Ur_RXPKTCNT_Uf_SET BCMI_TSCE16_XGXS_RXPKTCNT_Ur_RXPKTCNT_Uf_SET
#define READ_RXPKTCNT_Ur BCMI_TSCE16_XGXS_READ_RXPKTCNT_Ur
#define WRITE_RXPKTCNT_Ur BCMI_TSCE16_XGXS_WRITE_RXPKTCNT_Ur
#define MODIFY_RXPKTCNT_Ur BCMI_TSCE16_XGXS_MODIFY_RXPKTCNT_Ur
#define READLN_RXPKTCNT_Ur BCMI_TSCE16_XGXS_READLN_RXPKTCNT_Ur
#define WRITELN_RXPKTCNT_Ur BCMI_TSCE16_XGXS_WRITELN_RXPKTCNT_Ur
#define WRITEALL_RXPKTCNT_Ur BCMI_TSCE16_XGXS_WRITEALL_RXPKTCNT_Ur

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RXPKTCNT_Ur'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RXPKTCNT_L
 * BLOCKS:   PATGEN1
 * REGADDR:  0xc043
 * DESC:     RX Packet Count Lower Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXPKTCNT_L       Lower 16 bits of instanteneous value of the internal 32 bit number of received packets counter.The value is sampled on read from rxpktcnt_U.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RXPKTCNT_Lr (0x0000c043 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RXPKTCNT_Lr_SIZE 4

/*
 * This structure should be used to declare and program RXPKTCNT_L.
 *
 */
typedef union BCMI_TSCE16_XGXS_RXPKTCNT_Lr_s {
	uint32_t v[1];
	uint32_t rxpktcnt_l[1];
	uint32_t _rxpktcnt_l;
} BCMI_TSCE16_XGXS_RXPKTCNT_Lr_t;

#define BCMI_TSCE16_XGXS_RXPKTCNT_Lr_CLR(r) (r).rxpktcnt_l[0] = 0
#define BCMI_TSCE16_XGXS_RXPKTCNT_Lr_SET(r,d) (r).rxpktcnt_l[0] = d
#define BCMI_TSCE16_XGXS_RXPKTCNT_Lr_GET(r) (r).rxpktcnt_l[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RXPKTCNT_Lr_RXPKTCNT_Lf_GET(r) (((r).rxpktcnt_l[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_RXPKTCNT_Lr_RXPKTCNT_Lf_SET(r,f) (r).rxpktcnt_l[0]=(((r).rxpktcnt_l[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RXPKTCNT_L.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RXPKTCNT_Lr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXPKTCNT_Lr,(_r._rxpktcnt_l))
#define BCMI_TSCE16_XGXS_WRITE_RXPKTCNT_Lr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXPKTCNT_Lr,(_r._rxpktcnt_l)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RXPKTCNT_Lr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXPKTCNT_Lr,(_r._rxpktcnt_l))
#define BCMI_TSCE16_XGXS_READLN_RXPKTCNT_Lr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXPKTCNT_Lr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxpktcnt_l))
#define BCMI_TSCE16_XGXS_WRITELN_RXPKTCNT_Lr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXPKTCNT_Lr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxpktcnt_l))
#define BCMI_TSCE16_XGXS_WRITEALL_RXPKTCNT_Lr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXPKTCNT_Lr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxpktcnt_l))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXPKTCNT_Lr BCMI_TSCE16_XGXS_RXPKTCNT_Lr
#define RXPKTCNT_Lr_SIZE BCMI_TSCE16_XGXS_RXPKTCNT_Lr_SIZE
typedef BCMI_TSCE16_XGXS_RXPKTCNT_Lr_t RXPKTCNT_Lr_t;
#define RXPKTCNT_Lr_CLR BCMI_TSCE16_XGXS_RXPKTCNT_Lr_CLR
#define RXPKTCNT_Lr_SET BCMI_TSCE16_XGXS_RXPKTCNT_Lr_SET
#define RXPKTCNT_Lr_GET BCMI_TSCE16_XGXS_RXPKTCNT_Lr_GET
#define RXPKTCNT_Lr_RXPKTCNT_Lf_GET BCMI_TSCE16_XGXS_RXPKTCNT_Lr_RXPKTCNT_Lf_GET
#define RXPKTCNT_Lr_RXPKTCNT_Lf_SET BCMI_TSCE16_XGXS_RXPKTCNT_Lr_RXPKTCNT_Lf_SET
#define READ_RXPKTCNT_Lr BCMI_TSCE16_XGXS_READ_RXPKTCNT_Lr
#define WRITE_RXPKTCNT_Lr BCMI_TSCE16_XGXS_WRITE_RXPKTCNT_Lr
#define MODIFY_RXPKTCNT_Lr BCMI_TSCE16_XGXS_MODIFY_RXPKTCNT_Lr
#define READLN_RXPKTCNT_Lr BCMI_TSCE16_XGXS_READLN_RXPKTCNT_Lr
#define WRITELN_RXPKTCNT_Lr BCMI_TSCE16_XGXS_WRITELN_RXPKTCNT_Lr
#define WRITEALL_RXPKTCNT_Lr BCMI_TSCE16_XGXS_WRITEALL_RXPKTCNT_Lr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RXPKTCNT_Lr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X4_CTL
 * BLOCKS:   SC_X4_CONTROL
 * REGADDR:  0xc050
 * DESC:     SW speed change control
 * RESETVAL: 0xff (255)
 * ACCESS:   R/W
 * FIELDS:
 *     SW_SPEED         Speed to be set
 *     SW_SPEED_CHANGE  Start SW speed change.HW will detect possedge of this field and start or restart the speed change logic.To restart speed change logic SW must write 0 to this bit and then write 1.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X4_CTLr (0x0000c050 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X4_CTLr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X4_CTLr_s {
	uint32_t v[1];
	uint32_t sc_x4_ctl[1];
	uint32_t _sc_x4_ctl;
} BCMI_TSCE16_XGXS_SC_X4_CTLr_t;

#define BCMI_TSCE16_XGXS_SC_X4_CTLr_CLR(r) (r).sc_x4_ctl[0] = 0
#define BCMI_TSCE16_XGXS_SC_X4_CTLr_SET(r,d) (r).sc_x4_ctl[0] = d
#define BCMI_TSCE16_XGXS_SC_X4_CTLr_GET(r) (r).sc_x4_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X4_CTLr_SW_SPEED_CHANGEf_GET(r) ((((r).sc_x4_ctl[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_CTLr_SW_SPEED_CHANGEf_SET(r,f) (r).sc_x4_ctl[0]=(((r).sc_x4_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_SC_X4_CTLr_SW_SPEEDf_GET(r) (((r).sc_x4_ctl[0]) & 0xff)
#define BCMI_TSCE16_XGXS_SC_X4_CTLr_SW_SPEEDf_SET(r,f) (r).sc_x4_ctl[0]=(((r).sc_x4_ctl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access SC_X4_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X4_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_CTLr,(_r._sc_x4_ctl))
#define BCMI_TSCE16_XGXS_WRITE_SC_X4_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_CTLr,(_r._sc_x4_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X4_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_CTLr,(_r._sc_x4_ctl))
#define BCMI_TSCE16_XGXS_READLN_SC_X4_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_SC_X4_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_SC_X4_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_CTLr BCMI_TSCE16_XGXS_SC_X4_CTLr
#define SC_X4_CTLr_SIZE BCMI_TSCE16_XGXS_SC_X4_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_SC_X4_CTLr_t SC_X4_CTLr_t;
#define SC_X4_CTLr_CLR BCMI_TSCE16_XGXS_SC_X4_CTLr_CLR
#define SC_X4_CTLr_SET BCMI_TSCE16_XGXS_SC_X4_CTLr_SET
#define SC_X4_CTLr_GET BCMI_TSCE16_XGXS_SC_X4_CTLr_GET
#define SC_X4_CTLr_SW_SPEED_CHANGEf_GET BCMI_TSCE16_XGXS_SC_X4_CTLr_SW_SPEED_CHANGEf_GET
#define SC_X4_CTLr_SW_SPEED_CHANGEf_SET BCMI_TSCE16_XGXS_SC_X4_CTLr_SW_SPEED_CHANGEf_SET
#define SC_X4_CTLr_SW_SPEEDf_GET BCMI_TSCE16_XGXS_SC_X4_CTLr_SW_SPEEDf_GET
#define SC_X4_CTLr_SW_SPEEDf_SET BCMI_TSCE16_XGXS_SC_X4_CTLr_SW_SPEEDf_SET
#define READ_SC_X4_CTLr BCMI_TSCE16_XGXS_READ_SC_X4_CTLr
#define WRITE_SC_X4_CTLr BCMI_TSCE16_XGXS_WRITE_SC_X4_CTLr
#define MODIFY_SC_X4_CTLr BCMI_TSCE16_XGXS_MODIFY_SC_X4_CTLr
#define READLN_SC_X4_CTLr BCMI_TSCE16_XGXS_READLN_SC_X4_CTLr
#define WRITELN_SC_X4_CTLr BCMI_TSCE16_XGXS_WRITELN_SC_X4_CTLr
#define WRITEALL_SC_X4_CTLr BCMI_TSCE16_XGXS_WRITEALL_SC_X4_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X4_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X4_STS
 * BLOCKS:   SC_X4_CONTROL
 * REGADDR:  0xc051
 * DESC:     SW speed change status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SW_SPEED_CHANGE_DONE Read clear bit indicating that SW initiated speed change completed
 *     SW_SPEED_CONFIG_VLD Read clear bit indicating that resolved speed configuration in stutus registers can be read
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X4_STSr (0x0000c051 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X4_STSr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X4_STSr_s {
	uint32_t v[1];
	uint32_t sc_x4_sts[1];
	uint32_t _sc_x4_sts;
} BCMI_TSCE16_XGXS_SC_X4_STSr_t;

#define BCMI_TSCE16_XGXS_SC_X4_STSr_CLR(r) (r).sc_x4_sts[0] = 0
#define BCMI_TSCE16_XGXS_SC_X4_STSr_SET(r,d) (r).sc_x4_sts[0] = d
#define BCMI_TSCE16_XGXS_SC_X4_STSr_GET(r) (r).sc_x4_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X4_STSr_SW_SPEED_CONFIG_VLDf_GET(r) ((((r).sc_x4_sts[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_STSr_SW_SPEED_CONFIG_VLDf_SET(r,f) (r).sc_x4_sts[0]=(((r).sc_x4_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_SC_X4_STSr_SW_SPEED_CHANGE_DONEf_GET(r) (((r).sc_x4_sts[0]) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_STSr_SW_SPEED_CHANGE_DONEf_SET(r,f) (r).sc_x4_sts[0]=(((r).sc_x4_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X4_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X4_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_STSr,(_r._sc_x4_sts))
#define BCMI_TSCE16_XGXS_WRITE_SC_X4_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_STSr,(_r._sc_x4_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X4_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_STSr,(_r._sc_x4_sts))
#define BCMI_TSCE16_XGXS_READLN_SC_X4_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_sts))
#define BCMI_TSCE16_XGXS_WRITELN_SC_X4_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_SC_X4_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_STSr BCMI_TSCE16_XGXS_SC_X4_STSr
#define SC_X4_STSr_SIZE BCMI_TSCE16_XGXS_SC_X4_STSr_SIZE
typedef BCMI_TSCE16_XGXS_SC_X4_STSr_t SC_X4_STSr_t;
#define SC_X4_STSr_CLR BCMI_TSCE16_XGXS_SC_X4_STSr_CLR
#define SC_X4_STSr_SET BCMI_TSCE16_XGXS_SC_X4_STSr_SET
#define SC_X4_STSr_GET BCMI_TSCE16_XGXS_SC_X4_STSr_GET
#define SC_X4_STSr_SW_SPEED_CONFIG_VLDf_GET BCMI_TSCE16_XGXS_SC_X4_STSr_SW_SPEED_CONFIG_VLDf_GET
#define SC_X4_STSr_SW_SPEED_CONFIG_VLDf_SET BCMI_TSCE16_XGXS_SC_X4_STSr_SW_SPEED_CONFIG_VLDf_SET
#define SC_X4_STSr_SW_SPEED_CHANGE_DONEf_GET BCMI_TSCE16_XGXS_SC_X4_STSr_SW_SPEED_CHANGE_DONEf_GET
#define SC_X4_STSr_SW_SPEED_CHANGE_DONEf_SET BCMI_TSCE16_XGXS_SC_X4_STSr_SW_SPEED_CHANGE_DONEf_SET
#define READ_SC_X4_STSr BCMI_TSCE16_XGXS_READ_SC_X4_STSr
#define WRITE_SC_X4_STSr BCMI_TSCE16_XGXS_WRITE_SC_X4_STSr
#define MODIFY_SC_X4_STSr BCMI_TSCE16_XGXS_MODIFY_SC_X4_STSr
#define READLN_SC_X4_STSr BCMI_TSCE16_XGXS_READLN_SC_X4_STSr
#define WRITELN_SC_X4_STSr BCMI_TSCE16_XGXS_WRITELN_SC_X4_STSr
#define WRITEALL_SC_X4_STSr BCMI_TSCE16_XGXS_WRITEALL_SC_X4_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X4_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X4_ERR
 * BLOCKS:   SC_X4_CONTROL
 * REGADDR:  0xc052
 * DESC:     Speed control error indication
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PLL_LOCK_TIMED_OUT Indication of timeout during PLL lock
 *     PMD_LOCK_TIMED_OUT Indication of timeout during PMD RX lock
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X4_ERRr (0x0000c052 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X4_ERRr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_ERR.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X4_ERRr_s {
	uint32_t v[1];
	uint32_t sc_x4_err[1];
	uint32_t _sc_x4_err;
} BCMI_TSCE16_XGXS_SC_X4_ERRr_t;

#define BCMI_TSCE16_XGXS_SC_X4_ERRr_CLR(r) (r).sc_x4_err[0] = 0
#define BCMI_TSCE16_XGXS_SC_X4_ERRr_SET(r,d) (r).sc_x4_err[0] = d
#define BCMI_TSCE16_XGXS_SC_X4_ERRr_GET(r) (r).sc_x4_err[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X4_ERRr_PMD_LOCK_TIMED_OUTf_GET(r) ((((r).sc_x4_err[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_ERRr_PMD_LOCK_TIMED_OUTf_SET(r,f) (r).sc_x4_err[0]=(((r).sc_x4_err[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_SC_X4_ERRr_PLL_LOCK_TIMED_OUTf_GET(r) (((r).sc_x4_err[0]) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_ERRr_PLL_LOCK_TIMED_OUTf_SET(r,f) (r).sc_x4_err[0]=(((r).sc_x4_err[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X4_ERR.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X4_ERRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_ERRr,(_r._sc_x4_err))
#define BCMI_TSCE16_XGXS_WRITE_SC_X4_ERRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_ERRr,(_r._sc_x4_err)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X4_ERRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_ERRr,(_r._sc_x4_err))
#define BCMI_TSCE16_XGXS_READLN_SC_X4_ERRr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_ERRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_err))
#define BCMI_TSCE16_XGXS_WRITELN_SC_X4_ERRr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_ERRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_err))
#define BCMI_TSCE16_XGXS_WRITEALL_SC_X4_ERRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_ERRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_err))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_ERRr BCMI_TSCE16_XGXS_SC_X4_ERRr
#define SC_X4_ERRr_SIZE BCMI_TSCE16_XGXS_SC_X4_ERRr_SIZE
typedef BCMI_TSCE16_XGXS_SC_X4_ERRr_t SC_X4_ERRr_t;
#define SC_X4_ERRr_CLR BCMI_TSCE16_XGXS_SC_X4_ERRr_CLR
#define SC_X4_ERRr_SET BCMI_TSCE16_XGXS_SC_X4_ERRr_SET
#define SC_X4_ERRr_GET BCMI_TSCE16_XGXS_SC_X4_ERRr_GET
#define SC_X4_ERRr_PMD_LOCK_TIMED_OUTf_GET BCMI_TSCE16_XGXS_SC_X4_ERRr_PMD_LOCK_TIMED_OUTf_GET
#define SC_X4_ERRr_PMD_LOCK_TIMED_OUTf_SET BCMI_TSCE16_XGXS_SC_X4_ERRr_PMD_LOCK_TIMED_OUTf_SET
#define SC_X4_ERRr_PLL_LOCK_TIMED_OUTf_GET BCMI_TSCE16_XGXS_SC_X4_ERRr_PLL_LOCK_TIMED_OUTf_GET
#define SC_X4_ERRr_PLL_LOCK_TIMED_OUTf_SET BCMI_TSCE16_XGXS_SC_X4_ERRr_PLL_LOCK_TIMED_OUTf_SET
#define READ_SC_X4_ERRr BCMI_TSCE16_XGXS_READ_SC_X4_ERRr
#define WRITE_SC_X4_ERRr BCMI_TSCE16_XGXS_WRITE_SC_X4_ERRr
#define MODIFY_SC_X4_ERRr BCMI_TSCE16_XGXS_MODIFY_SC_X4_ERRr
#define READLN_SC_X4_ERRr BCMI_TSCE16_XGXS_READLN_SC_X4_ERRr
#define WRITELN_SC_X4_ERRr BCMI_TSCE16_XGXS_WRITELN_SC_X4_ERRr
#define WRITEALL_SC_X4_ERRr BCMI_TSCE16_XGXS_WRITEALL_SC_X4_ERRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X4_ERRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X4_DBG
 * BLOCKS:   SC_X4_CONTROL
 * REGADDR:  0xc054
 * DESC:     Speed control debug information
 * RESETVAL: 0x8000 (32768)
 * ACCESS:   R/W
 * FIELDS:
 *     SC_FSM_STATUS    Speed Control logic FSM debug information
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X4_DBGr (0x0000c054 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X4_DBGr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_DBG.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X4_DBGr_s {
	uint32_t v[1];
	uint32_t sc_x4_dbg[1];
	uint32_t _sc_x4_dbg;
} BCMI_TSCE16_XGXS_SC_X4_DBGr_t;

#define BCMI_TSCE16_XGXS_SC_X4_DBGr_CLR(r) (r).sc_x4_dbg[0] = 0
#define BCMI_TSCE16_XGXS_SC_X4_DBGr_SET(r,d) (r).sc_x4_dbg[0] = d
#define BCMI_TSCE16_XGXS_SC_X4_DBGr_GET(r) (r).sc_x4_dbg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X4_DBGr_SC_FSM_STATUSf_GET(r) (((r).sc_x4_dbg[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_SC_X4_DBGr_SC_FSM_STATUSf_SET(r,f) (r).sc_x4_dbg[0]=(((r).sc_x4_dbg[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SC_X4_DBG.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X4_DBGr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_DBGr,(_r._sc_x4_dbg))
#define BCMI_TSCE16_XGXS_WRITE_SC_X4_DBGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_DBGr,(_r._sc_x4_dbg)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X4_DBGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_DBGr,(_r._sc_x4_dbg))
#define BCMI_TSCE16_XGXS_READLN_SC_X4_DBGr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_DBGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_dbg))
#define BCMI_TSCE16_XGXS_WRITELN_SC_X4_DBGr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_DBGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_dbg))
#define BCMI_TSCE16_XGXS_WRITEALL_SC_X4_DBGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_DBGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_dbg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_DBGr BCMI_TSCE16_XGXS_SC_X4_DBGr
#define SC_X4_DBGr_SIZE BCMI_TSCE16_XGXS_SC_X4_DBGr_SIZE
typedef BCMI_TSCE16_XGXS_SC_X4_DBGr_t SC_X4_DBGr_t;
#define SC_X4_DBGr_CLR BCMI_TSCE16_XGXS_SC_X4_DBGr_CLR
#define SC_X4_DBGr_SET BCMI_TSCE16_XGXS_SC_X4_DBGr_SET
#define SC_X4_DBGr_GET BCMI_TSCE16_XGXS_SC_X4_DBGr_GET
#define SC_X4_DBGr_SC_FSM_STATUSf_GET BCMI_TSCE16_XGXS_SC_X4_DBGr_SC_FSM_STATUSf_GET
#define SC_X4_DBGr_SC_FSM_STATUSf_SET BCMI_TSCE16_XGXS_SC_X4_DBGr_SC_FSM_STATUSf_SET
#define READ_SC_X4_DBGr BCMI_TSCE16_XGXS_READ_SC_X4_DBGr
#define WRITE_SC_X4_DBGr BCMI_TSCE16_XGXS_WRITE_SC_X4_DBGr
#define MODIFY_SC_X4_DBGr BCMI_TSCE16_XGXS_MODIFY_SC_X4_DBGr
#define READLN_SC_X4_DBGr BCMI_TSCE16_XGXS_READLN_SC_X4_DBGr
#define WRITELN_SC_X4_DBGr BCMI_TSCE16_XGXS_WRITELN_SC_X4_DBGr
#define WRITEALL_SC_X4_DBGr BCMI_TSCE16_XGXS_WRITEALL_SC_X4_DBGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X4_DBGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X4_LN_NUM_OVRR
 * BLOCKS:   SC_X4_CONTROL
 * REGADDR:  0xc055
 * DESC:     Number of lanes for override configuration
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NUM_LANES_OVERRIDE_VALUE Number of lanes for override configuration0   : NUM_LANES_01 - use 1 lane1   : NUM_LANES_02 - use 2 lanes2   : NUM_LANES_04 - use 4 lanes3   : NUM_LANES_10 - use 10 lanes4   : NUM_LANES_12 - use 12 lanes
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X4_LN_NUM_OVRRr (0x0000c055 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X4_LN_NUM_OVRRr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_LN_NUM_OVRR.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X4_LN_NUM_OVRRr_s {
	uint32_t v[1];
	uint32_t sc_x4_ln_num_ovrr[1];
	uint32_t _sc_x4_ln_num_ovrr;
} BCMI_TSCE16_XGXS_SC_X4_LN_NUM_OVRRr_t;

#define BCMI_TSCE16_XGXS_SC_X4_LN_NUM_OVRRr_CLR(r) (r).sc_x4_ln_num_ovrr[0] = 0
#define BCMI_TSCE16_XGXS_SC_X4_LN_NUM_OVRRr_SET(r,d) (r).sc_x4_ln_num_ovrr[0] = d
#define BCMI_TSCE16_XGXS_SC_X4_LN_NUM_OVRRr_GET(r) (r).sc_x4_ln_num_ovrr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X4_LN_NUM_OVRRr_NUM_LANES_OVERRIDE_VALUEf_GET(r) (((r).sc_x4_ln_num_ovrr[0]) & 0x7)
#define BCMI_TSCE16_XGXS_SC_X4_LN_NUM_OVRRr_NUM_LANES_OVERRIDE_VALUEf_SET(r,f) (r).sc_x4_ln_num_ovrr[0]=(((r).sc_x4_ln_num_ovrr[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SC_X4_LN_NUM_OVRR.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X4_LN_NUM_OVRRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_LN_NUM_OVRRr,(_r._sc_x4_ln_num_ovrr))
#define BCMI_TSCE16_XGXS_WRITE_SC_X4_LN_NUM_OVRRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_LN_NUM_OVRRr,(_r._sc_x4_ln_num_ovrr)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X4_LN_NUM_OVRRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_LN_NUM_OVRRr,(_r._sc_x4_ln_num_ovrr))
#define BCMI_TSCE16_XGXS_READLN_SC_X4_LN_NUM_OVRRr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_LN_NUM_OVRRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_ln_num_ovrr))
#define BCMI_TSCE16_XGXS_WRITELN_SC_X4_LN_NUM_OVRRr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_LN_NUM_OVRRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_ln_num_ovrr))
#define BCMI_TSCE16_XGXS_WRITEALL_SC_X4_LN_NUM_OVRRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_LN_NUM_OVRRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_ln_num_ovrr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_LN_NUM_OVRRr BCMI_TSCE16_XGXS_SC_X4_LN_NUM_OVRRr
#define SC_X4_LN_NUM_OVRRr_SIZE BCMI_TSCE16_XGXS_SC_X4_LN_NUM_OVRRr_SIZE
typedef BCMI_TSCE16_XGXS_SC_X4_LN_NUM_OVRRr_t SC_X4_LN_NUM_OVRRr_t;
#define SC_X4_LN_NUM_OVRRr_CLR BCMI_TSCE16_XGXS_SC_X4_LN_NUM_OVRRr_CLR
#define SC_X4_LN_NUM_OVRRr_SET BCMI_TSCE16_XGXS_SC_X4_LN_NUM_OVRRr_SET
#define SC_X4_LN_NUM_OVRRr_GET BCMI_TSCE16_XGXS_SC_X4_LN_NUM_OVRRr_GET
#define SC_X4_LN_NUM_OVRRr_NUM_LANES_OVERRIDE_VALUEf_GET BCMI_TSCE16_XGXS_SC_X4_LN_NUM_OVRRr_NUM_LANES_OVERRIDE_VALUEf_GET
#define SC_X4_LN_NUM_OVRRr_NUM_LANES_OVERRIDE_VALUEf_SET BCMI_TSCE16_XGXS_SC_X4_LN_NUM_OVRRr_NUM_LANES_OVERRIDE_VALUEf_SET
#define READ_SC_X4_LN_NUM_OVRRr BCMI_TSCE16_XGXS_READ_SC_X4_LN_NUM_OVRRr
#define WRITE_SC_X4_LN_NUM_OVRRr BCMI_TSCE16_XGXS_WRITE_SC_X4_LN_NUM_OVRRr
#define MODIFY_SC_X4_LN_NUM_OVRRr BCMI_TSCE16_XGXS_MODIFY_SC_X4_LN_NUM_OVRRr
#define READLN_SC_X4_LN_NUM_OVRRr BCMI_TSCE16_XGXS_READLN_SC_X4_LN_NUM_OVRRr
#define WRITELN_SC_X4_LN_NUM_OVRRr BCMI_TSCE16_XGXS_WRITELN_SC_X4_LN_NUM_OVRRr
#define WRITEALL_SC_X4_LN_NUM_OVRRr BCMI_TSCE16_XGXS_WRITEALL_SC_X4_LN_NUM_OVRRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X4_LN_NUM_OVRRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X4_BYPASS
 * BLOCKS:   SC_X4_CONTROL
 * REGADDR:  0xc058
 * DESC:     Speed control bypass enable
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SC_BYPASS        Disable speed control logic
 *     SC_IGNORE_TX_DATA_VLD Do not wait for tx_data_vld indication from PMD before taking TX pipe out of reset
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X4_BYPASSr (0x0000c058 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X4_BYPASSr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_BYPASS.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X4_BYPASSr_s {
	uint32_t v[1];
	uint32_t sc_x4_bypass[1];
	uint32_t _sc_x4_bypass;
} BCMI_TSCE16_XGXS_SC_X4_BYPASSr_t;

#define BCMI_TSCE16_XGXS_SC_X4_BYPASSr_CLR(r) (r).sc_x4_bypass[0] = 0
#define BCMI_TSCE16_XGXS_SC_X4_BYPASSr_SET(r,d) (r).sc_x4_bypass[0] = d
#define BCMI_TSCE16_XGXS_SC_X4_BYPASSr_GET(r) (r).sc_x4_bypass[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X4_BYPASSr_SC_IGNORE_TX_DATA_VLDf_GET(r) ((((r).sc_x4_bypass[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_BYPASSr_SC_IGNORE_TX_DATA_VLDf_SET(r,f) (r).sc_x4_bypass[0]=(((r).sc_x4_bypass[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_SC_X4_BYPASSr_SC_BYPASSf_GET(r) (((r).sc_x4_bypass[0]) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_BYPASSr_SC_BYPASSf_SET(r,f) (r).sc_x4_bypass[0]=(((r).sc_x4_bypass[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X4_BYPASS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X4_BYPASSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_BYPASSr,(_r._sc_x4_bypass))
#define BCMI_TSCE16_XGXS_WRITE_SC_X4_BYPASSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_BYPASSr,(_r._sc_x4_bypass)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X4_BYPASSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_BYPASSr,(_r._sc_x4_bypass))
#define BCMI_TSCE16_XGXS_READLN_SC_X4_BYPASSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_BYPASSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_bypass))
#define BCMI_TSCE16_XGXS_WRITELN_SC_X4_BYPASSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_BYPASSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_bypass))
#define BCMI_TSCE16_XGXS_WRITEALL_SC_X4_BYPASSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_BYPASSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_bypass))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_BYPASSr BCMI_TSCE16_XGXS_SC_X4_BYPASSr
#define SC_X4_BYPASSr_SIZE BCMI_TSCE16_XGXS_SC_X4_BYPASSr_SIZE
typedef BCMI_TSCE16_XGXS_SC_X4_BYPASSr_t SC_X4_BYPASSr_t;
#define SC_X4_BYPASSr_CLR BCMI_TSCE16_XGXS_SC_X4_BYPASSr_CLR
#define SC_X4_BYPASSr_SET BCMI_TSCE16_XGXS_SC_X4_BYPASSr_SET
#define SC_X4_BYPASSr_GET BCMI_TSCE16_XGXS_SC_X4_BYPASSr_GET
#define SC_X4_BYPASSr_SC_IGNORE_TX_DATA_VLDf_GET BCMI_TSCE16_XGXS_SC_X4_BYPASSr_SC_IGNORE_TX_DATA_VLDf_GET
#define SC_X4_BYPASSr_SC_IGNORE_TX_DATA_VLDf_SET BCMI_TSCE16_XGXS_SC_X4_BYPASSr_SC_IGNORE_TX_DATA_VLDf_SET
#define SC_X4_BYPASSr_SC_BYPASSf_GET BCMI_TSCE16_XGXS_SC_X4_BYPASSr_SC_BYPASSf_GET
#define SC_X4_BYPASSr_SC_BYPASSf_SET BCMI_TSCE16_XGXS_SC_X4_BYPASSr_SC_BYPASSf_SET
#define READ_SC_X4_BYPASSr BCMI_TSCE16_XGXS_READ_SC_X4_BYPASSr
#define WRITE_SC_X4_BYPASSr BCMI_TSCE16_XGXS_WRITE_SC_X4_BYPASSr
#define MODIFY_SC_X4_BYPASSr BCMI_TSCE16_XGXS_MODIFY_SC_X4_BYPASSr
#define READLN_SC_X4_BYPASSr BCMI_TSCE16_XGXS_READLN_SC_X4_BYPASSr
#define WRITELN_SC_X4_BYPASSr BCMI_TSCE16_XGXS_WRITELN_SC_X4_BYPASSr
#define WRITEALL_SC_X4_BYPASSr BCMI_TSCE16_XGXS_WRITEALL_SC_X4_BYPASSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X4_BYPASSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X4_FLD_OVRR_EN0_TYPE
 * BLOCKS:   SC_X4_FIELD_OVERRIDE_ENABLE
 * REGADDR:  0xc060
 * DESC:     Enable override of individual fields
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BLOCK_SYNC_MODE_OEN 
 *     CHK_END_EN_OEN   
 *     BRCM64B66_DESCRAMBLER_ENABLE_OEN 
 *     CL36BYTEDELETEMODE_OEN 
 *     DESC2_MODE_OEN   
 *     DESKEWMODE_OEN   
 *     DECODERMODE_OEN  
 *     DESCRAMBLERMODE_OEN 
 *     ENCODEMODE_OEN   
 *     FEC_ENABLE_OEN   
 *     SCR_MODE_OEN     
 *     OS_MODE_OEN      
 *     NUM_LANES_OEN    
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr (0x0000c060 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FLD_OVRR_EN0_TYPE.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_s {
	uint32_t v[1];
	uint32_t sc_x4_fld_ovrr_en0_type[1];
	uint32_t _sc_x4_fld_ovrr_en0_type;
} BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_t;

#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CLR(r) (r).sc_x4_fld_ovrr_en0_type[0] = 0
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_SET(r,d) (r).sc_x4_fld_ovrr_en0_type[0] = d
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_GET(r) (r).sc_x4_fld_ovrr_en0_type[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_NUM_LANES_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_NUM_LANES_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_OS_MODE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 12) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_OS_MODE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_SCR_MODE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 11) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_SCR_MODE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_FEC_ENABLE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_FEC_ENABLE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_ENCODEMODE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_ENCODEMODE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_DESCRAMBLERMODE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_DESCRAMBLERMODE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_DECODERMODE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_DECODERMODE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_DESKEWMODE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_DESKEWMODE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_DESC2_MODE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_DESC2_MODE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CL36BYTEDELETEMODE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CL36BYTEDELETEMODE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_BRCM64B66_DESCRAMBLER_ENABLE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_BRCM64B66_DESCRAMBLER_ENABLE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CHK_END_EN_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CHK_END_EN_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_BLOCK_SYNC_MODE_OENf_GET(r) (((r).sc_x4_fld_ovrr_en0_type[0]) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_BLOCK_SYNC_MODE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X4_FLD_OVRR_EN0_TYPE.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X4_FLD_OVRR_EN0_TYPEr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr,(_r._sc_x4_fld_ovrr_en0_type))
#define BCMI_TSCE16_XGXS_WRITE_SC_X4_FLD_OVRR_EN0_TYPEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr,(_r._sc_x4_fld_ovrr_en0_type)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X4_FLD_OVRR_EN0_TYPEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr,(_r._sc_x4_fld_ovrr_en0_type))
#define BCMI_TSCE16_XGXS_READLN_SC_X4_FLD_OVRR_EN0_TYPEr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fld_ovrr_en0_type))
#define BCMI_TSCE16_XGXS_WRITELN_SC_X4_FLD_OVRR_EN0_TYPEr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fld_ovrr_en0_type))
#define BCMI_TSCE16_XGXS_WRITEALL_SC_X4_FLD_OVRR_EN0_TYPEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fld_ovrr_en0_type))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FLD_OVRR_EN0_TYPEr BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr
#define SC_X4_FLD_OVRR_EN0_TYPEr_SIZE BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_SIZE
typedef BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_t SC_X4_FLD_OVRR_EN0_TYPEr_t;
#define SC_X4_FLD_OVRR_EN0_TYPEr_CLR BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CLR
#define SC_X4_FLD_OVRR_EN0_TYPEr_SET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_GET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_NUM_LANES_OENf_GET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_NUM_LANES_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_NUM_LANES_OENf_SET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_NUM_LANES_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_OS_MODE_OENf_GET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_OS_MODE_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_OS_MODE_OENf_SET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_OS_MODE_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_SCR_MODE_OENf_GET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_SCR_MODE_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_SCR_MODE_OENf_SET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_SCR_MODE_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_FEC_ENABLE_OENf_GET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_FEC_ENABLE_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_FEC_ENABLE_OENf_SET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_FEC_ENABLE_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_ENCODEMODE_OENf_GET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_ENCODEMODE_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_ENCODEMODE_OENf_SET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_ENCODEMODE_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_DESCRAMBLERMODE_OENf_GET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_DESCRAMBLERMODE_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_DESCRAMBLERMODE_OENf_SET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_DESCRAMBLERMODE_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_DECODERMODE_OENf_GET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_DECODERMODE_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_DECODERMODE_OENf_SET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_DECODERMODE_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_DESKEWMODE_OENf_GET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_DESKEWMODE_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_DESKEWMODE_OENf_SET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_DESKEWMODE_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_DESC2_MODE_OENf_GET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_DESC2_MODE_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_DESC2_MODE_OENf_SET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_DESC2_MODE_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_CL36BYTEDELETEMODE_OENf_GET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CL36BYTEDELETEMODE_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_CL36BYTEDELETEMODE_OENf_SET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CL36BYTEDELETEMODE_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_BRCM64B66_DESCRAMBLER_ENABLE_OENf_GET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_BRCM64B66_DESCRAMBLER_ENABLE_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_BRCM64B66_DESCRAMBLER_ENABLE_OENf_SET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_BRCM64B66_DESCRAMBLER_ENABLE_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_CHK_END_EN_OENf_GET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CHK_END_EN_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_CHK_END_EN_OENf_SET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CHK_END_EN_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_BLOCK_SYNC_MODE_OENf_GET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_BLOCK_SYNC_MODE_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_BLOCK_SYNC_MODE_OENf_SET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_BLOCK_SYNC_MODE_OENf_SET
#define READ_SC_X4_FLD_OVRR_EN0_TYPEr BCMI_TSCE16_XGXS_READ_SC_X4_FLD_OVRR_EN0_TYPEr
#define WRITE_SC_X4_FLD_OVRR_EN0_TYPEr BCMI_TSCE16_XGXS_WRITE_SC_X4_FLD_OVRR_EN0_TYPEr
#define MODIFY_SC_X4_FLD_OVRR_EN0_TYPEr BCMI_TSCE16_XGXS_MODIFY_SC_X4_FLD_OVRR_EN0_TYPEr
#define READLN_SC_X4_FLD_OVRR_EN0_TYPEr BCMI_TSCE16_XGXS_READLN_SC_X4_FLD_OVRR_EN0_TYPEr
#define WRITELN_SC_X4_FLD_OVRR_EN0_TYPEr BCMI_TSCE16_XGXS_WRITELN_SC_X4_FLD_OVRR_EN0_TYPEr
#define WRITEALL_SC_X4_FLD_OVRR_EN0_TYPEr BCMI_TSCE16_XGXS_WRITEALL_SC_X4_FLD_OVRR_EN0_TYPEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X4_FLD_OVRR_EN1_TYPE
 * BLOCKS:   SC_X4_FIELD_OVERRIDE_ENABLE
 * REGADDR:  0xc061
 * DESC:     Enable override of individual fields
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_CREDITGENCNT_OEN 
 *     PCS_CLOCKCNT0_OEN 
 *     PCS_CREDITENABLE_OEN 
 *     REPLICATION_CNT_OEN 
 *     MAC_CREDITGENCNT_OEN 
 *     LOOPCNT1_OEN     
 *     LOOPCNT0_OEN     
 *     CLOCKCNT1_OEN    
 *     CLOCKCNT0_OEN    
 *     CREDITENABLE_OEN 
 *     SGMII_SPD_SWITCH_OEN 
 *     CL36_EN_OEN      
 *     REORDER_EN_OEN   
 *     CL72_EN_OEN      
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr (0x0000c061 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FLD_OVRR_EN1_TYPE.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_s {
	uint32_t v[1];
	uint32_t sc_x4_fld_ovrr_en1_type[1];
	uint32_t _sc_x4_fld_ovrr_en1_type;
} BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_t;

#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CLR(r) (r).sc_x4_fld_ovrr_en1_type[0] = 0
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_SET(r,d) (r).sc_x4_fld_ovrr_en1_type[0] = d
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_GET(r) (r).sc_x4_fld_ovrr_en1_type[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CL72_EN_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en1_type[0]) >> 13) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CL72_EN_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en1_type[0]=(((r).sc_x4_fld_ovrr_en1_type[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_REORDER_EN_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en1_type[0]) >> 12) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_REORDER_EN_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en1_type[0]=(((r).sc_x4_fld_ovrr_en1_type[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CL36_EN_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en1_type[0]) >> 11) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CL36_EN_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en1_type[0]=(((r).sc_x4_fld_ovrr_en1_type[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_SGMII_SPD_SWITCH_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en1_type[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_SGMII_SPD_SWITCH_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en1_type[0]=(((r).sc_x4_fld_ovrr_en1_type[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CREDITENABLE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en1_type[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CREDITENABLE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en1_type[0]=(((r).sc_x4_fld_ovrr_en1_type[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CLOCKCNT0_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en1_type[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CLOCKCNT0_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en1_type[0]=(((r).sc_x4_fld_ovrr_en1_type[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CLOCKCNT1_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en1_type[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CLOCKCNT1_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en1_type[0]=(((r).sc_x4_fld_ovrr_en1_type[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_LOOPCNT0_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en1_type[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_LOOPCNT0_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en1_type[0]=(((r).sc_x4_fld_ovrr_en1_type[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_LOOPCNT1_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en1_type[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_LOOPCNT1_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en1_type[0]=(((r).sc_x4_fld_ovrr_en1_type[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_MAC_CREDITGENCNT_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en1_type[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_MAC_CREDITGENCNT_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en1_type[0]=(((r).sc_x4_fld_ovrr_en1_type[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_REPLICATION_CNT_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en1_type[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_REPLICATION_CNT_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en1_type[0]=(((r).sc_x4_fld_ovrr_en1_type[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_PCS_CREDITENABLE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en1_type[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_PCS_CREDITENABLE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en1_type[0]=(((r).sc_x4_fld_ovrr_en1_type[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_PCS_CLOCKCNT0_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en1_type[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_PCS_CLOCKCNT0_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en1_type[0]=(((r).sc_x4_fld_ovrr_en1_type[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_PCS_CREDITGENCNT_OENf_GET(r) (((r).sc_x4_fld_ovrr_en1_type[0]) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_PCS_CREDITGENCNT_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en1_type[0]=(((r).sc_x4_fld_ovrr_en1_type[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X4_FLD_OVRR_EN1_TYPE.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X4_FLD_OVRR_EN1_TYPEr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr,(_r._sc_x4_fld_ovrr_en1_type))
#define BCMI_TSCE16_XGXS_WRITE_SC_X4_FLD_OVRR_EN1_TYPEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr,(_r._sc_x4_fld_ovrr_en1_type)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X4_FLD_OVRR_EN1_TYPEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr,(_r._sc_x4_fld_ovrr_en1_type))
#define BCMI_TSCE16_XGXS_READLN_SC_X4_FLD_OVRR_EN1_TYPEr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fld_ovrr_en1_type))
#define BCMI_TSCE16_XGXS_WRITELN_SC_X4_FLD_OVRR_EN1_TYPEr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fld_ovrr_en1_type))
#define BCMI_TSCE16_XGXS_WRITEALL_SC_X4_FLD_OVRR_EN1_TYPEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fld_ovrr_en1_type))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FLD_OVRR_EN1_TYPEr BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr
#define SC_X4_FLD_OVRR_EN1_TYPEr_SIZE BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_SIZE
typedef BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_t SC_X4_FLD_OVRR_EN1_TYPEr_t;
#define SC_X4_FLD_OVRR_EN1_TYPEr_CLR BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CLR
#define SC_X4_FLD_OVRR_EN1_TYPEr_SET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_SET
#define SC_X4_FLD_OVRR_EN1_TYPEr_GET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_GET
#define SC_X4_FLD_OVRR_EN1_TYPEr_CL72_EN_OENf_GET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CL72_EN_OENf_GET
#define SC_X4_FLD_OVRR_EN1_TYPEr_CL72_EN_OENf_SET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CL72_EN_OENf_SET
#define SC_X4_FLD_OVRR_EN1_TYPEr_REORDER_EN_OENf_GET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_REORDER_EN_OENf_GET
#define SC_X4_FLD_OVRR_EN1_TYPEr_REORDER_EN_OENf_SET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_REORDER_EN_OENf_SET
#define SC_X4_FLD_OVRR_EN1_TYPEr_CL36_EN_OENf_GET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CL36_EN_OENf_GET
#define SC_X4_FLD_OVRR_EN1_TYPEr_CL36_EN_OENf_SET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CL36_EN_OENf_SET
#define SC_X4_FLD_OVRR_EN1_TYPEr_SGMII_SPD_SWITCH_OENf_GET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_SGMII_SPD_SWITCH_OENf_GET
#define SC_X4_FLD_OVRR_EN1_TYPEr_SGMII_SPD_SWITCH_OENf_SET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_SGMII_SPD_SWITCH_OENf_SET
#define SC_X4_FLD_OVRR_EN1_TYPEr_CREDITENABLE_OENf_GET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CREDITENABLE_OENf_GET
#define SC_X4_FLD_OVRR_EN1_TYPEr_CREDITENABLE_OENf_SET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CREDITENABLE_OENf_SET
#define SC_X4_FLD_OVRR_EN1_TYPEr_CLOCKCNT0_OENf_GET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CLOCKCNT0_OENf_GET
#define SC_X4_FLD_OVRR_EN1_TYPEr_CLOCKCNT0_OENf_SET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CLOCKCNT0_OENf_SET
#define SC_X4_FLD_OVRR_EN1_TYPEr_CLOCKCNT1_OENf_GET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CLOCKCNT1_OENf_GET
#define SC_X4_FLD_OVRR_EN1_TYPEr_CLOCKCNT1_OENf_SET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CLOCKCNT1_OENf_SET
#define SC_X4_FLD_OVRR_EN1_TYPEr_LOOPCNT0_OENf_GET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_LOOPCNT0_OENf_GET
#define SC_X4_FLD_OVRR_EN1_TYPEr_LOOPCNT0_OENf_SET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_LOOPCNT0_OENf_SET
#define SC_X4_FLD_OVRR_EN1_TYPEr_LOOPCNT1_OENf_GET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_LOOPCNT1_OENf_GET
#define SC_X4_FLD_OVRR_EN1_TYPEr_LOOPCNT1_OENf_SET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_LOOPCNT1_OENf_SET
#define SC_X4_FLD_OVRR_EN1_TYPEr_MAC_CREDITGENCNT_OENf_GET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_MAC_CREDITGENCNT_OENf_GET
#define SC_X4_FLD_OVRR_EN1_TYPEr_MAC_CREDITGENCNT_OENf_SET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_MAC_CREDITGENCNT_OENf_SET
#define SC_X4_FLD_OVRR_EN1_TYPEr_REPLICATION_CNT_OENf_GET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_REPLICATION_CNT_OENf_GET
#define SC_X4_FLD_OVRR_EN1_TYPEr_REPLICATION_CNT_OENf_SET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_REPLICATION_CNT_OENf_SET
#define SC_X4_FLD_OVRR_EN1_TYPEr_PCS_CREDITENABLE_OENf_GET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_PCS_CREDITENABLE_OENf_GET
#define SC_X4_FLD_OVRR_EN1_TYPEr_PCS_CREDITENABLE_OENf_SET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_PCS_CREDITENABLE_OENf_SET
#define SC_X4_FLD_OVRR_EN1_TYPEr_PCS_CLOCKCNT0_OENf_GET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_PCS_CLOCKCNT0_OENf_GET
#define SC_X4_FLD_OVRR_EN1_TYPEr_PCS_CLOCKCNT0_OENf_SET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_PCS_CLOCKCNT0_OENf_SET
#define SC_X4_FLD_OVRR_EN1_TYPEr_PCS_CREDITGENCNT_OENf_GET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_PCS_CREDITGENCNT_OENf_GET
#define SC_X4_FLD_OVRR_EN1_TYPEr_PCS_CREDITGENCNT_OENf_SET BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_PCS_CREDITGENCNT_OENf_SET
#define READ_SC_X4_FLD_OVRR_EN1_TYPEr BCMI_TSCE16_XGXS_READ_SC_X4_FLD_OVRR_EN1_TYPEr
#define WRITE_SC_X4_FLD_OVRR_EN1_TYPEr BCMI_TSCE16_XGXS_WRITE_SC_X4_FLD_OVRR_EN1_TYPEr
#define MODIFY_SC_X4_FLD_OVRR_EN1_TYPEr BCMI_TSCE16_XGXS_MODIFY_SC_X4_FLD_OVRR_EN1_TYPEr
#define READLN_SC_X4_FLD_OVRR_EN1_TYPEr BCMI_TSCE16_XGXS_READLN_SC_X4_FLD_OVRR_EN1_TYPEr
#define WRITELN_SC_X4_FLD_OVRR_EN1_TYPEr BCMI_TSCE16_XGXS_WRITELN_SC_X4_FLD_OVRR_EN1_TYPEr
#define WRITEALL_SC_X4_FLD_OVRR_EN1_TYPEr BCMI_TSCE16_XGXS_WRITEALL_SC_X4_FLD_OVRR_EN1_TYPEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X4_RSLVD_SPD
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS
 * REGADDR:  0xc070
 * DESC:     Final speed configuration for PCS
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/O
 * FIELDS:
 *     NUM_LANES        Number of lanes0   : NUM_LANES_01 - use 1 lane1   : NUM_LANES_02 - use 2 lanes2   : NUM_LANES_04 - use 4 lanes3   : NUM_LANES_10 - use 10 lanes4   : NUM_LANES_12 - use 12 lanes
 *     SPEED            Speed ID to use for this configuration
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD_SPDr (0x0000c070 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X4_RSLVD_SPDr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_RSLVD_SPD.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X4_RSLVD_SPDr_s {
	uint32_t v[1];
	uint32_t sc_x4_rslvd_spd[1];
	uint32_t _sc_x4_rslvd_spd;
} BCMI_TSCE16_XGXS_SC_X4_RSLVD_SPDr_t;

#define BCMI_TSCE16_XGXS_SC_X4_RSLVD_SPDr_CLR(r) (r).sc_x4_rslvd_spd[0] = 0
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD_SPDr_SET(r,d) (r).sc_x4_rslvd_spd[0] = d
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD_SPDr_GET(r) (r).sc_x4_rslvd_spd[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD_SPDr_SPEEDf_GET(r) ((((r).sc_x4_rslvd_spd[0]) >> 8) & 0xff)
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD_SPDr_SPEEDf_SET(r,f) (r).sc_x4_rslvd_spd[0]=(((r).sc_x4_rslvd_spd[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD_SPDr_NUM_LANESf_GET(r) (((r).sc_x4_rslvd_spd[0]) & 0x7)
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD_SPDr_NUM_LANESf_SET(r,f) (r).sc_x4_rslvd_spd[0]=(((r).sc_x4_rslvd_spd[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SC_X4_RSLVD_SPD.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X4_RSLVD_SPDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD_SPDr,(_r._sc_x4_rslvd_spd))
#define BCMI_TSCE16_XGXS_WRITE_SC_X4_RSLVD_SPDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD_SPDr,(_r._sc_x4_rslvd_spd)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X4_RSLVD_SPDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD_SPDr,(_r._sc_x4_rslvd_spd))
#define BCMI_TSCE16_XGXS_READLN_SC_X4_RSLVD_SPDr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD_SPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd_spd))
#define BCMI_TSCE16_XGXS_WRITELN_SC_X4_RSLVD_SPDr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD_SPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd_spd))
#define BCMI_TSCE16_XGXS_WRITEALL_SC_X4_RSLVD_SPDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD_SPDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_rslvd_spd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_RSLVD_SPDr BCMI_TSCE16_XGXS_SC_X4_RSLVD_SPDr
#define SC_X4_RSLVD_SPDr_SIZE BCMI_TSCE16_XGXS_SC_X4_RSLVD_SPDr_SIZE
typedef BCMI_TSCE16_XGXS_SC_X4_RSLVD_SPDr_t SC_X4_RSLVD_SPDr_t;
#define SC_X4_RSLVD_SPDr_CLR BCMI_TSCE16_XGXS_SC_X4_RSLVD_SPDr_CLR
#define SC_X4_RSLVD_SPDr_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD_SPDr_SET
#define SC_X4_RSLVD_SPDr_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD_SPDr_GET
#define SC_X4_RSLVD_SPDr_SPEEDf_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD_SPDr_SPEEDf_GET
#define SC_X4_RSLVD_SPDr_SPEEDf_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD_SPDr_SPEEDf_SET
#define SC_X4_RSLVD_SPDr_NUM_LANESf_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD_SPDr_NUM_LANESf_GET
#define SC_X4_RSLVD_SPDr_NUM_LANESf_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD_SPDr_NUM_LANESf_SET
#define READ_SC_X4_RSLVD_SPDr BCMI_TSCE16_XGXS_READ_SC_X4_RSLVD_SPDr
#define WRITE_SC_X4_RSLVD_SPDr BCMI_TSCE16_XGXS_WRITE_SC_X4_RSLVD_SPDr
#define MODIFY_SC_X4_RSLVD_SPDr BCMI_TSCE16_XGXS_MODIFY_SC_X4_RSLVD_SPDr
#define READLN_SC_X4_RSLVD_SPDr BCMI_TSCE16_XGXS_READLN_SC_X4_RSLVD_SPDr
#define WRITELN_SC_X4_RSLVD_SPDr BCMI_TSCE16_XGXS_WRITELN_SC_X4_RSLVD_SPDr
#define WRITEALL_SC_X4_RSLVD_SPDr BCMI_TSCE16_XGXS_WRITEALL_SC_X4_RSLVD_SPDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X4_RSLVD_SPDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X4_RSLVD0
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS
 * REGADDR:  0xc072
 * DESC:     Final speed configuration for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     ENCODEMODE       000 All functions disabled for lane001 cl48 8b10b010 cl48 8b10b rxaui011 cl36 8b10b100 cl82 64b66b101 cl49 64b66b110 brcm 64b66b
 *     FEC_ENABLE       
 *     CL72_ENABLE      
 *     SCR_MODE         00 bypass scrambler01 64b66b scrambler (all 66 bits)10 8b10b scrambler (all 80 bits)11 64b66b scrambler (sync bits not scrambled)
 *     OS_MODE          0: OS MODE 1 - divide by 11: OS MODE 2 - divide by 22: OS MODE 3 - divide by 33: OS MODE 3.3 - divide by 3.3.Bit repeating pattern is 3,3,3,4,3,3,4,3,3,44: OS MODE 4 - divide by 45: OS MODE 5 - divide by 56: OS MODE 7.5 - divide by 7.57: OS MODE 8 - divide by 88: OS MODE 8.25 - divide by 8.25.Bit repeating pattern is 8,8,8,99: OS MODE 10 - divide by 10
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD0r (0x0000c072 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X4_RSLVD0r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_RSLVD0.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X4_RSLVD0r_s {
	uint32_t v[1];
	uint32_t sc_x4_rslvd0[1];
	uint32_t _sc_x4_rslvd0;
} BCMI_TSCE16_XGXS_SC_X4_RSLVD0r_t;

#define BCMI_TSCE16_XGXS_SC_X4_RSLVD0r_CLR(r) (r).sc_x4_rslvd0[0] = 0
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD0r_SET(r,d) (r).sc_x4_rslvd0[0] = d
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD0r_GET(r) (r).sc_x4_rslvd0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD0r_OS_MODEf_GET(r) ((((r).sc_x4_rslvd0[0]) >> 12) & 0xf)
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD0r_OS_MODEf_SET(r,f) (r).sc_x4_rslvd0[0]=(((r).sc_x4_rslvd0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD0r_SCR_MODEf_GET(r) ((((r).sc_x4_rslvd0[0]) >> 10) & 0x3)
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD0r_SCR_MODEf_SET(r,f) (r).sc_x4_rslvd0[0]=(((r).sc_x4_rslvd0[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD0r_CL72_ENABLEf_GET(r) ((((r).sc_x4_rslvd0[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD0r_CL72_ENABLEf_SET(r,f) (r).sc_x4_rslvd0[0]=(((r).sc_x4_rslvd0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD0r_FEC_ENABLEf_GET(r) ((((r).sc_x4_rslvd0[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD0r_FEC_ENABLEf_SET(r,f) (r).sc_x4_rslvd0[0]=(((r).sc_x4_rslvd0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD0r_ENCODEMODEf_GET(r) (((r).sc_x4_rslvd0[0]) & 0x7)
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD0r_ENCODEMODEf_SET(r,f) (r).sc_x4_rslvd0[0]=(((r).sc_x4_rslvd0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SC_X4_RSLVD0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X4_RSLVD0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD0r,(_r._sc_x4_rslvd0))
#define BCMI_TSCE16_XGXS_WRITE_SC_X4_RSLVD0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD0r,(_r._sc_x4_rslvd0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X4_RSLVD0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD0r,(_r._sc_x4_rslvd0))
#define BCMI_TSCE16_XGXS_READLN_SC_X4_RSLVD0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd0))
#define BCMI_TSCE16_XGXS_WRITELN_SC_X4_RSLVD0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd0))
#define BCMI_TSCE16_XGXS_WRITEALL_SC_X4_RSLVD0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_rslvd0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_RSLVD0r BCMI_TSCE16_XGXS_SC_X4_RSLVD0r
#define SC_X4_RSLVD0r_SIZE BCMI_TSCE16_XGXS_SC_X4_RSLVD0r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X4_RSLVD0r_t SC_X4_RSLVD0r_t;
#define SC_X4_RSLVD0r_CLR BCMI_TSCE16_XGXS_SC_X4_RSLVD0r_CLR
#define SC_X4_RSLVD0r_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD0r_SET
#define SC_X4_RSLVD0r_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD0r_GET
#define SC_X4_RSLVD0r_OS_MODEf_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD0r_OS_MODEf_GET
#define SC_X4_RSLVD0r_OS_MODEf_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD0r_OS_MODEf_SET
#define SC_X4_RSLVD0r_SCR_MODEf_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD0r_SCR_MODEf_GET
#define SC_X4_RSLVD0r_SCR_MODEf_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD0r_SCR_MODEf_SET
#define SC_X4_RSLVD0r_CL72_ENABLEf_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD0r_CL72_ENABLEf_GET
#define SC_X4_RSLVD0r_CL72_ENABLEf_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD0r_CL72_ENABLEf_SET
#define SC_X4_RSLVD0r_FEC_ENABLEf_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD0r_FEC_ENABLEf_GET
#define SC_X4_RSLVD0r_FEC_ENABLEf_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD0r_FEC_ENABLEf_SET
#define SC_X4_RSLVD0r_ENCODEMODEf_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD0r_ENCODEMODEf_GET
#define SC_X4_RSLVD0r_ENCODEMODEf_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD0r_ENCODEMODEf_SET
#define READ_SC_X4_RSLVD0r BCMI_TSCE16_XGXS_READ_SC_X4_RSLVD0r
#define WRITE_SC_X4_RSLVD0r BCMI_TSCE16_XGXS_WRITE_SC_X4_RSLVD0r
#define MODIFY_SC_X4_RSLVD0r BCMI_TSCE16_XGXS_MODIFY_SC_X4_RSLVD0r
#define READLN_SC_X4_RSLVD0r BCMI_TSCE16_XGXS_READLN_SC_X4_RSLVD0r
#define WRITELN_SC_X4_RSLVD0r BCMI_TSCE16_XGXS_WRITELN_SC_X4_RSLVD0r
#define WRITEALL_SC_X4_RSLVD0r BCMI_TSCE16_XGXS_WRITEALL_SC_X4_RSLVD0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X4_RSLVD0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X4_RSLVD1
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS
 * REGADDR:  0xc073
 * DESC:     Final speed configuration for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     BRCM64B66_DESCRAMBLER_ENABLE If set, the data sent to the the brcm64b66 decoder is scrambled.Sync headers are not scrambled
 *     CL36BYTEDELETEMODE 2'b00 - 100M mode (Delete 9 out of every 10 bytes)2'b01 - 10M mode (Delete 99 out of every 100 bytes)2'b10 - Passthrough (No deletion)
 *     DESC2_MODE       r_desc2 mode3'b000 - NONE3'b001 - CL493'b010 - BRCM3'b011 - 3'b100 - CL483'b101 - CL363'b110 - CL823'b111 - NONE
 *     DESKEWMODE       3'b000 - None3'b001 - byte based deskew for 8b10b mode3'b010 - block based deskew for BRCM 64b66b mode3'b011 - block based deskew for IEEE CL82 mode3'b100 - cl36 mode enable
 *     DECODERMODE      r_dec1 mode3'b000 - None3'b001 - cl49 64b66b mode3'b010 - BRCM 64b66b mode3'b011 -  - cl49/BRCM 64b66b mode3'b100 - 8b10b mode - cl48 mode3'b101 - 8b10b mode - cl36 mode
 *     DESCRAMBLERMODE  r_descr1 modeUsed only in CL48 based speeds, set to bypass for all other speeds2'b00 - bypass descrambler2'b01 - 64b66b descrambler2'b10 - 8b10b descrambler2'b11 - reserved
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD1r (0x0000c073 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X4_RSLVD1r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_RSLVD1.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X4_RSLVD1r_s {
	uint32_t v[1];
	uint32_t sc_x4_rslvd1[1];
	uint32_t _sc_x4_rslvd1;
} BCMI_TSCE16_XGXS_SC_X4_RSLVD1r_t;

#define BCMI_TSCE16_XGXS_SC_X4_RSLVD1r_CLR(r) (r).sc_x4_rslvd1[0] = 0
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD1r_SET(r,d) (r).sc_x4_rslvd1[0] = d
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD1r_GET(r) (r).sc_x4_rslvd1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD1r_DESCRAMBLERMODEf_GET(r) ((((r).sc_x4_rslvd1[0]) >> 14) & 0x3)
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD1r_DESCRAMBLERMODEf_SET(r,f) (r).sc_x4_rslvd1[0]=(((r).sc_x4_rslvd1[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD1r_DECODERMODEf_GET(r) ((((r).sc_x4_rslvd1[0]) >> 11) & 0x7)
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD1r_DECODERMODEf_SET(r,f) (r).sc_x4_rslvd1[0]=(((r).sc_x4_rslvd1[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD1r_DESKEWMODEf_GET(r) ((((r).sc_x4_rslvd1[0]) >> 8) & 0x7)
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD1r_DESKEWMODEf_SET(r,f) (r).sc_x4_rslvd1[0]=(((r).sc_x4_rslvd1[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD1r_DESC2_MODEf_GET(r) ((((r).sc_x4_rslvd1[0]) >> 5) & 0x7)
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD1r_DESC2_MODEf_SET(r,f) (r).sc_x4_rslvd1[0]=(((r).sc_x4_rslvd1[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5)) | (7 << (16 + 5))
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD1r_CL36BYTEDELETEMODEf_GET(r) ((((r).sc_x4_rslvd1[0]) >> 3) & 0x3)
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD1r_CL36BYTEDELETEMODEf_SET(r,f) (r).sc_x4_rslvd1[0]=(((r).sc_x4_rslvd1[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3)) | (3 << (16 + 3))
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD1r_BRCM64B66_DESCRAMBLER_ENABLEf_GET(r) ((((r).sc_x4_rslvd1[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD1r_BRCM64B66_DESCRAMBLER_ENABLEf_SET(r,f) (r).sc_x4_rslvd1[0]=(((r).sc_x4_rslvd1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access SC_X4_RSLVD1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X4_RSLVD1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD1r,(_r._sc_x4_rslvd1))
#define BCMI_TSCE16_XGXS_WRITE_SC_X4_RSLVD1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD1r,(_r._sc_x4_rslvd1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X4_RSLVD1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD1r,(_r._sc_x4_rslvd1))
#define BCMI_TSCE16_XGXS_READLN_SC_X4_RSLVD1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd1))
#define BCMI_TSCE16_XGXS_WRITELN_SC_X4_RSLVD1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd1))
#define BCMI_TSCE16_XGXS_WRITEALL_SC_X4_RSLVD1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_rslvd1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_RSLVD1r BCMI_TSCE16_XGXS_SC_X4_RSLVD1r
#define SC_X4_RSLVD1r_SIZE BCMI_TSCE16_XGXS_SC_X4_RSLVD1r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X4_RSLVD1r_t SC_X4_RSLVD1r_t;
#define SC_X4_RSLVD1r_CLR BCMI_TSCE16_XGXS_SC_X4_RSLVD1r_CLR
#define SC_X4_RSLVD1r_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD1r_SET
#define SC_X4_RSLVD1r_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD1r_GET
#define SC_X4_RSLVD1r_DESCRAMBLERMODEf_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD1r_DESCRAMBLERMODEf_GET
#define SC_X4_RSLVD1r_DESCRAMBLERMODEf_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD1r_DESCRAMBLERMODEf_SET
#define SC_X4_RSLVD1r_DECODERMODEf_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD1r_DECODERMODEf_GET
#define SC_X4_RSLVD1r_DECODERMODEf_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD1r_DECODERMODEf_SET
#define SC_X4_RSLVD1r_DESKEWMODEf_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD1r_DESKEWMODEf_GET
#define SC_X4_RSLVD1r_DESKEWMODEf_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD1r_DESKEWMODEf_SET
#define SC_X4_RSLVD1r_DESC2_MODEf_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD1r_DESC2_MODEf_GET
#define SC_X4_RSLVD1r_DESC2_MODEf_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD1r_DESC2_MODEf_SET
#define SC_X4_RSLVD1r_CL36BYTEDELETEMODEf_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD1r_CL36BYTEDELETEMODEf_GET
#define SC_X4_RSLVD1r_CL36BYTEDELETEMODEf_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD1r_CL36BYTEDELETEMODEf_SET
#define SC_X4_RSLVD1r_BRCM64B66_DESCRAMBLER_ENABLEf_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD1r_BRCM64B66_DESCRAMBLER_ENABLEf_GET
#define SC_X4_RSLVD1r_BRCM64B66_DESCRAMBLER_ENABLEf_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD1r_BRCM64B66_DESCRAMBLER_ENABLEf_SET
#define READ_SC_X4_RSLVD1r BCMI_TSCE16_XGXS_READ_SC_X4_RSLVD1r
#define WRITE_SC_X4_RSLVD1r BCMI_TSCE16_XGXS_WRITE_SC_X4_RSLVD1r
#define MODIFY_SC_X4_RSLVD1r BCMI_TSCE16_XGXS_MODIFY_SC_X4_RSLVD1r
#define READLN_SC_X4_RSLVD1r BCMI_TSCE16_XGXS_READLN_SC_X4_RSLVD1r
#define WRITELN_SC_X4_RSLVD1r BCMI_TSCE16_XGXS_WRITELN_SC_X4_RSLVD1r
#define WRITEALL_SC_X4_RSLVD1r BCMI_TSCE16_XGXS_WRITEALL_SC_X4_RSLVD1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X4_RSLVD1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X4_RSLVD2
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS
 * REGADDR:  0xc074
 * DESC:     Final speed configuration for PCS
 * RESETVAL: 0x400 (1024)
 * ACCESS:   R/O
 * FIELDS:
 *     CL36_EN          
 *     REORDER_EN       1'b0: cl48 reorder is disabled1'b1: cl48 reorder is enabled
 *     BLOCK_SYNC_MODE  000 none001 cl49 mode - enables func_cl49cl82_sync block010 cl82 mode - enables func_cl49cl82_sync block011 8b10b mode - enables the func_8b10b_sync block100 fec mode - enables the func_fec_sync block101 brcm 64b66b mode
 *     CHK_END_EN       this bit enables cl48 check_end function as defined in section 48.2.6.1.4
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD2r (0x0000c074 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X4_RSLVD2r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_RSLVD2.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X4_RSLVD2r_s {
	uint32_t v[1];
	uint32_t sc_x4_rslvd2[1];
	uint32_t _sc_x4_rslvd2;
} BCMI_TSCE16_XGXS_SC_X4_RSLVD2r_t;

#define BCMI_TSCE16_XGXS_SC_X4_RSLVD2r_CLR(r) (r).sc_x4_rslvd2[0] = 0
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD2r_SET(r,d) (r).sc_x4_rslvd2[0] = d
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD2r_GET(r) (r).sc_x4_rslvd2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD2r_CHK_END_ENf_GET(r) ((((r).sc_x4_rslvd2[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD2r_CHK_END_ENf_SET(r,f) (r).sc_x4_rslvd2[0]=(((r).sc_x4_rslvd2[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD2r_BLOCK_SYNC_MODEf_GET(r) ((((r).sc_x4_rslvd2[0]) >> 4) & 0x7)
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD2r_BLOCK_SYNC_MODEf_SET(r,f) (r).sc_x4_rslvd2[0]=(((r).sc_x4_rslvd2[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD2r_REORDER_ENf_GET(r) ((((r).sc_x4_rslvd2[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD2r_REORDER_ENf_SET(r,f) (r).sc_x4_rslvd2[0]=(((r).sc_x4_rslvd2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD2r_CL36_ENf_GET(r) (((r).sc_x4_rslvd2[0]) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD2r_CL36_ENf_SET(r,f) (r).sc_x4_rslvd2[0]=(((r).sc_x4_rslvd2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X4_RSLVD2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X4_RSLVD2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD2r,(_r._sc_x4_rslvd2))
#define BCMI_TSCE16_XGXS_WRITE_SC_X4_RSLVD2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD2r,(_r._sc_x4_rslvd2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X4_RSLVD2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD2r,(_r._sc_x4_rslvd2))
#define BCMI_TSCE16_XGXS_READLN_SC_X4_RSLVD2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd2))
#define BCMI_TSCE16_XGXS_WRITELN_SC_X4_RSLVD2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd2))
#define BCMI_TSCE16_XGXS_WRITEALL_SC_X4_RSLVD2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_rslvd2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_RSLVD2r BCMI_TSCE16_XGXS_SC_X4_RSLVD2r
#define SC_X4_RSLVD2r_SIZE BCMI_TSCE16_XGXS_SC_X4_RSLVD2r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X4_RSLVD2r_t SC_X4_RSLVD2r_t;
#define SC_X4_RSLVD2r_CLR BCMI_TSCE16_XGXS_SC_X4_RSLVD2r_CLR
#define SC_X4_RSLVD2r_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD2r_SET
#define SC_X4_RSLVD2r_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD2r_GET
#define SC_X4_RSLVD2r_CHK_END_ENf_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD2r_CHK_END_ENf_GET
#define SC_X4_RSLVD2r_CHK_END_ENf_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD2r_CHK_END_ENf_SET
#define SC_X4_RSLVD2r_BLOCK_SYNC_MODEf_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD2r_BLOCK_SYNC_MODEf_GET
#define SC_X4_RSLVD2r_BLOCK_SYNC_MODEf_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD2r_BLOCK_SYNC_MODEf_SET
#define SC_X4_RSLVD2r_REORDER_ENf_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD2r_REORDER_ENf_GET
#define SC_X4_RSLVD2r_REORDER_ENf_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD2r_REORDER_ENf_SET
#define SC_X4_RSLVD2r_CL36_ENf_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD2r_CL36_ENf_GET
#define SC_X4_RSLVD2r_CL36_ENf_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD2r_CL36_ENf_SET
#define READ_SC_X4_RSLVD2r BCMI_TSCE16_XGXS_READ_SC_X4_RSLVD2r
#define WRITE_SC_X4_RSLVD2r BCMI_TSCE16_XGXS_WRITE_SC_X4_RSLVD2r
#define MODIFY_SC_X4_RSLVD2r BCMI_TSCE16_XGXS_MODIFY_SC_X4_RSLVD2r
#define READLN_SC_X4_RSLVD2r BCMI_TSCE16_XGXS_READLN_SC_X4_RSLVD2r
#define WRITELN_SC_X4_RSLVD2r BCMI_TSCE16_XGXS_WRITELN_SC_X4_RSLVD2r
#define WRITEALL_SC_X4_RSLVD2r BCMI_TSCE16_XGXS_WRITEALL_SC_X4_RSLVD2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X4_RSLVD2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X4_RSLVD3
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS
 * REGADDR:  0xc075
 * DESC:     Final speed configuration for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CLOCKCNT0        clock count 0 for credit programming, range 5 to 4125
 *     SGMII_SPD_SWITCH Indicates to switch credits so that 10M/100M credits can go to the MAC and 1G credits can go to the PCS
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD3r (0x0000c075 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X4_RSLVD3r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_RSLVD3.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X4_RSLVD3r_s {
	uint32_t v[1];
	uint32_t sc_x4_rslvd3[1];
	uint32_t _sc_x4_rslvd3;
} BCMI_TSCE16_XGXS_SC_X4_RSLVD3r_t;

#define BCMI_TSCE16_XGXS_SC_X4_RSLVD3r_CLR(r) (r).sc_x4_rslvd3[0] = 0
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD3r_SET(r,d) (r).sc_x4_rslvd3[0] = d
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD3r_GET(r) (r).sc_x4_rslvd3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD3r_SGMII_SPD_SWITCHf_GET(r) ((((r).sc_x4_rslvd3[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD3r_SGMII_SPD_SWITCHf_SET(r,f) (r).sc_x4_rslvd3[0]=(((r).sc_x4_rslvd3[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD3r_CLOCKCNT0f_GET(r) (((r).sc_x4_rslvd3[0]) & 0x3fff)
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD3r_CLOCKCNT0f_SET(r,f) (r).sc_x4_rslvd3[0]=(((r).sc_x4_rslvd3[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access SC_X4_RSLVD3.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X4_RSLVD3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD3r,(_r._sc_x4_rslvd3))
#define BCMI_TSCE16_XGXS_WRITE_SC_X4_RSLVD3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD3r,(_r._sc_x4_rslvd3)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X4_RSLVD3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD3r,(_r._sc_x4_rslvd3))
#define BCMI_TSCE16_XGXS_READLN_SC_X4_RSLVD3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd3))
#define BCMI_TSCE16_XGXS_WRITELN_SC_X4_RSLVD3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd3))
#define BCMI_TSCE16_XGXS_WRITEALL_SC_X4_RSLVD3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_rslvd3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_RSLVD3r BCMI_TSCE16_XGXS_SC_X4_RSLVD3r
#define SC_X4_RSLVD3r_SIZE BCMI_TSCE16_XGXS_SC_X4_RSLVD3r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X4_RSLVD3r_t SC_X4_RSLVD3r_t;
#define SC_X4_RSLVD3r_CLR BCMI_TSCE16_XGXS_SC_X4_RSLVD3r_CLR
#define SC_X4_RSLVD3r_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD3r_SET
#define SC_X4_RSLVD3r_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD3r_GET
#define SC_X4_RSLVD3r_SGMII_SPD_SWITCHf_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD3r_SGMII_SPD_SWITCHf_GET
#define SC_X4_RSLVD3r_SGMII_SPD_SWITCHf_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD3r_SGMII_SPD_SWITCHf_SET
#define SC_X4_RSLVD3r_CLOCKCNT0f_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD3r_CLOCKCNT0f_GET
#define SC_X4_RSLVD3r_CLOCKCNT0f_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD3r_CLOCKCNT0f_SET
#define READ_SC_X4_RSLVD3r BCMI_TSCE16_XGXS_READ_SC_X4_RSLVD3r
#define WRITE_SC_X4_RSLVD3r BCMI_TSCE16_XGXS_WRITE_SC_X4_RSLVD3r
#define MODIFY_SC_X4_RSLVD3r BCMI_TSCE16_XGXS_MODIFY_SC_X4_RSLVD3r
#define READLN_SC_X4_RSLVD3r BCMI_TSCE16_XGXS_READLN_SC_X4_RSLVD3r
#define WRITELN_SC_X4_RSLVD3r BCMI_TSCE16_XGXS_WRITELN_SC_X4_RSLVD3r
#define WRITEALL_SC_X4_RSLVD3r BCMI_TSCE16_XGXS_WRITEALL_SC_X4_RSLVD3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X4_RSLVD3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X4_RSLVD4
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS
 * REGADDR:  0xc076
 * DESC:     Final speed configuration for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CLOCKCNT1        clock count 1 for credit programming, range 4 to 12
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD4r (0x0000c076 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X4_RSLVD4r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_RSLVD4.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X4_RSLVD4r_s {
	uint32_t v[1];
	uint32_t sc_x4_rslvd4[1];
	uint32_t _sc_x4_rslvd4;
} BCMI_TSCE16_XGXS_SC_X4_RSLVD4r_t;

#define BCMI_TSCE16_XGXS_SC_X4_RSLVD4r_CLR(r) (r).sc_x4_rslvd4[0] = 0
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD4r_SET(r,d) (r).sc_x4_rslvd4[0] = d
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD4r_GET(r) (r).sc_x4_rslvd4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD4r_CLOCKCNT1f_GET(r) (((r).sc_x4_rslvd4[0]) & 0xff)
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD4r_CLOCKCNT1f_SET(r,f) (r).sc_x4_rslvd4[0]=(((r).sc_x4_rslvd4[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access SC_X4_RSLVD4.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X4_RSLVD4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD4r,(_r._sc_x4_rslvd4))
#define BCMI_TSCE16_XGXS_WRITE_SC_X4_RSLVD4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD4r,(_r._sc_x4_rslvd4)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X4_RSLVD4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD4r,(_r._sc_x4_rslvd4))
#define BCMI_TSCE16_XGXS_READLN_SC_X4_RSLVD4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd4))
#define BCMI_TSCE16_XGXS_WRITELN_SC_X4_RSLVD4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd4))
#define BCMI_TSCE16_XGXS_WRITEALL_SC_X4_RSLVD4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_rslvd4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_RSLVD4r BCMI_TSCE16_XGXS_SC_X4_RSLVD4r
#define SC_X4_RSLVD4r_SIZE BCMI_TSCE16_XGXS_SC_X4_RSLVD4r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X4_RSLVD4r_t SC_X4_RSLVD4r_t;
#define SC_X4_RSLVD4r_CLR BCMI_TSCE16_XGXS_SC_X4_RSLVD4r_CLR
#define SC_X4_RSLVD4r_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD4r_SET
#define SC_X4_RSLVD4r_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD4r_GET
#define SC_X4_RSLVD4r_CLOCKCNT1f_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD4r_CLOCKCNT1f_GET
#define SC_X4_RSLVD4r_CLOCKCNT1f_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD4r_CLOCKCNT1f_SET
#define READ_SC_X4_RSLVD4r BCMI_TSCE16_XGXS_READ_SC_X4_RSLVD4r
#define WRITE_SC_X4_RSLVD4r BCMI_TSCE16_XGXS_WRITE_SC_X4_RSLVD4r
#define MODIFY_SC_X4_RSLVD4r BCMI_TSCE16_XGXS_MODIFY_SC_X4_RSLVD4r
#define READLN_SC_X4_RSLVD4r BCMI_TSCE16_XGXS_READLN_SC_X4_RSLVD4r
#define WRITELN_SC_X4_RSLVD4r BCMI_TSCE16_XGXS_WRITELN_SC_X4_RSLVD4r
#define WRITEALL_SC_X4_RSLVD4r BCMI_TSCE16_XGXS_WRITEALL_SC_X4_RSLVD4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X4_RSLVD4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X4_RSLVD5
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS
 * REGADDR:  0xc077
 * DESC:     Final speed configuration for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LOOPCNT1         loop count 1 for credit programming, range 2 to 18
 *     LOOPCNT0         loop count 0 for credit programming, range 1 to 1
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD5r (0x0000c077 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X4_RSLVD5r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_RSLVD5.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X4_RSLVD5r_s {
	uint32_t v[1];
	uint32_t sc_x4_rslvd5[1];
	uint32_t _sc_x4_rslvd5;
} BCMI_TSCE16_XGXS_SC_X4_RSLVD5r_t;

#define BCMI_TSCE16_XGXS_SC_X4_RSLVD5r_CLR(r) (r).sc_x4_rslvd5[0] = 0
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD5r_SET(r,d) (r).sc_x4_rslvd5[0] = d
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD5r_GET(r) (r).sc_x4_rslvd5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD5r_LOOPCNT0f_GET(r) ((((r).sc_x4_rslvd5[0]) >> 6) & 0xff)
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD5r_LOOPCNT0f_SET(r,f) (r).sc_x4_rslvd5[0]=(((r).sc_x4_rslvd5[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6)) | (255 << (16 + 6))
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD5r_LOOPCNT1f_GET(r) (((r).sc_x4_rslvd5[0]) & 0x3f)
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD5r_LOOPCNT1f_SET(r,f) (r).sc_x4_rslvd5[0]=(((r).sc_x4_rslvd5[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access SC_X4_RSLVD5.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X4_RSLVD5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD5r,(_r._sc_x4_rslvd5))
#define BCMI_TSCE16_XGXS_WRITE_SC_X4_RSLVD5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD5r,(_r._sc_x4_rslvd5)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X4_RSLVD5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD5r,(_r._sc_x4_rslvd5))
#define BCMI_TSCE16_XGXS_READLN_SC_X4_RSLVD5r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd5))
#define BCMI_TSCE16_XGXS_WRITELN_SC_X4_RSLVD5r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd5))
#define BCMI_TSCE16_XGXS_WRITEALL_SC_X4_RSLVD5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_rslvd5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_RSLVD5r BCMI_TSCE16_XGXS_SC_X4_RSLVD5r
#define SC_X4_RSLVD5r_SIZE BCMI_TSCE16_XGXS_SC_X4_RSLVD5r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X4_RSLVD5r_t SC_X4_RSLVD5r_t;
#define SC_X4_RSLVD5r_CLR BCMI_TSCE16_XGXS_SC_X4_RSLVD5r_CLR
#define SC_X4_RSLVD5r_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD5r_SET
#define SC_X4_RSLVD5r_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD5r_GET
#define SC_X4_RSLVD5r_LOOPCNT0f_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD5r_LOOPCNT0f_GET
#define SC_X4_RSLVD5r_LOOPCNT0f_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD5r_LOOPCNT0f_SET
#define SC_X4_RSLVD5r_LOOPCNT1f_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD5r_LOOPCNT1f_GET
#define SC_X4_RSLVD5r_LOOPCNT1f_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD5r_LOOPCNT1f_SET
#define READ_SC_X4_RSLVD5r BCMI_TSCE16_XGXS_READ_SC_X4_RSLVD5r
#define WRITE_SC_X4_RSLVD5r BCMI_TSCE16_XGXS_WRITE_SC_X4_RSLVD5r
#define MODIFY_SC_X4_RSLVD5r BCMI_TSCE16_XGXS_MODIFY_SC_X4_RSLVD5r
#define READLN_SC_X4_RSLVD5r BCMI_TSCE16_XGXS_READLN_SC_X4_RSLVD5r
#define WRITELN_SC_X4_RSLVD5r BCMI_TSCE16_XGXS_WRITELN_SC_X4_RSLVD5r
#define WRITEALL_SC_X4_RSLVD5r BCMI_TSCE16_XGXS_WRITEALL_SC_X4_RSLVD5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X4_RSLVD5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X4_RSLVD6
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS
 * REGADDR:  0xc078
 * DESC:     Final speed configuration for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MAC_CREDITGENCNT CGC for mac credit generation, range 1 to 2063
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD6r (0x0000c078 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X4_RSLVD6r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_RSLVD6.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X4_RSLVD6r_s {
	uint32_t v[1];
	uint32_t sc_x4_rslvd6[1];
	uint32_t _sc_x4_rslvd6;
} BCMI_TSCE16_XGXS_SC_X4_RSLVD6r_t;

#define BCMI_TSCE16_XGXS_SC_X4_RSLVD6r_CLR(r) (r).sc_x4_rslvd6[0] = 0
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD6r_SET(r,d) (r).sc_x4_rslvd6[0] = d
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD6r_GET(r) (r).sc_x4_rslvd6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD6r_MAC_CREDITGENCNTf_GET(r) (((r).sc_x4_rslvd6[0]) & 0x1fff)
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD6r_MAC_CREDITGENCNTf_SET(r,f) (r).sc_x4_rslvd6[0]=(((r).sc_x4_rslvd6[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access SC_X4_RSLVD6.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X4_RSLVD6r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD6r,(_r._sc_x4_rslvd6))
#define BCMI_TSCE16_XGXS_WRITE_SC_X4_RSLVD6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD6r,(_r._sc_x4_rslvd6)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X4_RSLVD6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD6r,(_r._sc_x4_rslvd6))
#define BCMI_TSCE16_XGXS_READLN_SC_X4_RSLVD6r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd6))
#define BCMI_TSCE16_XGXS_WRITELN_SC_X4_RSLVD6r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd6))
#define BCMI_TSCE16_XGXS_WRITEALL_SC_X4_RSLVD6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_rslvd6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_RSLVD6r BCMI_TSCE16_XGXS_SC_X4_RSLVD6r
#define SC_X4_RSLVD6r_SIZE BCMI_TSCE16_XGXS_SC_X4_RSLVD6r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X4_RSLVD6r_t SC_X4_RSLVD6r_t;
#define SC_X4_RSLVD6r_CLR BCMI_TSCE16_XGXS_SC_X4_RSLVD6r_CLR
#define SC_X4_RSLVD6r_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD6r_SET
#define SC_X4_RSLVD6r_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD6r_GET
#define SC_X4_RSLVD6r_MAC_CREDITGENCNTf_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD6r_MAC_CREDITGENCNTf_GET
#define SC_X4_RSLVD6r_MAC_CREDITGENCNTf_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD6r_MAC_CREDITGENCNTf_SET
#define READ_SC_X4_RSLVD6r BCMI_TSCE16_XGXS_READ_SC_X4_RSLVD6r
#define WRITE_SC_X4_RSLVD6r BCMI_TSCE16_XGXS_WRITE_SC_X4_RSLVD6r
#define MODIFY_SC_X4_RSLVD6r BCMI_TSCE16_XGXS_MODIFY_SC_X4_RSLVD6r
#define READLN_SC_X4_RSLVD6r BCMI_TSCE16_XGXS_READLN_SC_X4_RSLVD6r
#define WRITELN_SC_X4_RSLVD6r BCMI_TSCE16_XGXS_WRITELN_SC_X4_RSLVD6r
#define WRITEALL_SC_X4_RSLVD6r BCMI_TSCE16_XGXS_WRITEALL_SC_X4_RSLVD6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X4_RSLVD6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X4_RSLVD7
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS
 * REGADDR:  0xc079
 * DESC:     Final speed configuration for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PCS_CLOCKCNT0    pcs clock count 0 for credit programming, range 5 to 4125
 *     PCS_CREDITENABLE Enables credits to be generated for the PCS.  Only used in 10M or 100M modes.
 *     REPLICATION_CNT  Set to one (1) for 10M and zero (0) for 100M
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD7r (0x0000c079 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X4_RSLVD7r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_RSLVD7.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X4_RSLVD7r_s {
	uint32_t v[1];
	uint32_t sc_x4_rslvd7[1];
	uint32_t _sc_x4_rslvd7;
} BCMI_TSCE16_XGXS_SC_X4_RSLVD7r_t;

#define BCMI_TSCE16_XGXS_SC_X4_RSLVD7r_CLR(r) (r).sc_x4_rslvd7[0] = 0
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD7r_SET(r,d) (r).sc_x4_rslvd7[0] = d
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD7r_GET(r) (r).sc_x4_rslvd7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD7r_REPLICATION_CNTf_GET(r) ((((r).sc_x4_rslvd7[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD7r_REPLICATION_CNTf_SET(r,f) (r).sc_x4_rslvd7[0]=(((r).sc_x4_rslvd7[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD7r_PCS_CREDITENABLEf_GET(r) ((((r).sc_x4_rslvd7[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD7r_PCS_CREDITENABLEf_SET(r,f) (r).sc_x4_rslvd7[0]=(((r).sc_x4_rslvd7[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD7r_PCS_CLOCKCNT0f_GET(r) (((r).sc_x4_rslvd7[0]) & 0x3fff)
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD7r_PCS_CLOCKCNT0f_SET(r,f) (r).sc_x4_rslvd7[0]=(((r).sc_x4_rslvd7[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access SC_X4_RSLVD7.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X4_RSLVD7r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD7r,(_r._sc_x4_rslvd7))
#define BCMI_TSCE16_XGXS_WRITE_SC_X4_RSLVD7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD7r,(_r._sc_x4_rslvd7)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X4_RSLVD7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD7r,(_r._sc_x4_rslvd7))
#define BCMI_TSCE16_XGXS_READLN_SC_X4_RSLVD7r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd7))
#define BCMI_TSCE16_XGXS_WRITELN_SC_X4_RSLVD7r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd7))
#define BCMI_TSCE16_XGXS_WRITEALL_SC_X4_RSLVD7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD7r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_rslvd7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_RSLVD7r BCMI_TSCE16_XGXS_SC_X4_RSLVD7r
#define SC_X4_RSLVD7r_SIZE BCMI_TSCE16_XGXS_SC_X4_RSLVD7r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X4_RSLVD7r_t SC_X4_RSLVD7r_t;
#define SC_X4_RSLVD7r_CLR BCMI_TSCE16_XGXS_SC_X4_RSLVD7r_CLR
#define SC_X4_RSLVD7r_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD7r_SET
#define SC_X4_RSLVD7r_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD7r_GET
#define SC_X4_RSLVD7r_REPLICATION_CNTf_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD7r_REPLICATION_CNTf_GET
#define SC_X4_RSLVD7r_REPLICATION_CNTf_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD7r_REPLICATION_CNTf_SET
#define SC_X4_RSLVD7r_PCS_CREDITENABLEf_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD7r_PCS_CREDITENABLEf_GET
#define SC_X4_RSLVD7r_PCS_CREDITENABLEf_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD7r_PCS_CREDITENABLEf_SET
#define SC_X4_RSLVD7r_PCS_CLOCKCNT0f_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD7r_PCS_CLOCKCNT0f_GET
#define SC_X4_RSLVD7r_PCS_CLOCKCNT0f_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD7r_PCS_CLOCKCNT0f_SET
#define READ_SC_X4_RSLVD7r BCMI_TSCE16_XGXS_READ_SC_X4_RSLVD7r
#define WRITE_SC_X4_RSLVD7r BCMI_TSCE16_XGXS_WRITE_SC_X4_RSLVD7r
#define MODIFY_SC_X4_RSLVD7r BCMI_TSCE16_XGXS_MODIFY_SC_X4_RSLVD7r
#define READLN_SC_X4_RSLVD7r BCMI_TSCE16_XGXS_READLN_SC_X4_RSLVD7r
#define WRITELN_SC_X4_RSLVD7r BCMI_TSCE16_XGXS_WRITELN_SC_X4_RSLVD7r
#define WRITEALL_SC_X4_RSLVD7r BCMI_TSCE16_XGXS_WRITEALL_SC_X4_RSLVD7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X4_RSLVD7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SC_X4_RSLVD8
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS
 * REGADDR:  0xc07a
 * DESC:     Final speed configuration for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PCS_CREDITGENCNT CGC for pcs credit generation, range 1 to 2063
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD8r (0x0000c07a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SC_X4_RSLVD8r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_RSLVD8.
 *
 */
typedef union BCMI_TSCE16_XGXS_SC_X4_RSLVD8r_s {
	uint32_t v[1];
	uint32_t sc_x4_rslvd8[1];
	uint32_t _sc_x4_rslvd8;
} BCMI_TSCE16_XGXS_SC_X4_RSLVD8r_t;

#define BCMI_TSCE16_XGXS_SC_X4_RSLVD8r_CLR(r) (r).sc_x4_rslvd8[0] = 0
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD8r_SET(r,d) (r).sc_x4_rslvd8[0] = d
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD8r_GET(r) (r).sc_x4_rslvd8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD8r_PCS_CREDITGENCNTf_GET(r) (((r).sc_x4_rslvd8[0]) & 0x1fff)
#define BCMI_TSCE16_XGXS_SC_X4_RSLVD8r_PCS_CREDITGENCNTf_SET(r,f) (r).sc_x4_rslvd8[0]=(((r).sc_x4_rslvd8[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access SC_X4_RSLVD8.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SC_X4_RSLVD8r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD8r,(_r._sc_x4_rslvd8))
#define BCMI_TSCE16_XGXS_WRITE_SC_X4_RSLVD8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD8r,(_r._sc_x4_rslvd8)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SC_X4_RSLVD8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD8r,(_r._sc_x4_rslvd8))
#define BCMI_TSCE16_XGXS_READLN_SC_X4_RSLVD8r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd8))
#define BCMI_TSCE16_XGXS_WRITELN_SC_X4_RSLVD8r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd8))
#define BCMI_TSCE16_XGXS_WRITEALL_SC_X4_RSLVD8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SC_X4_RSLVD8r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_rslvd8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_RSLVD8r BCMI_TSCE16_XGXS_SC_X4_RSLVD8r
#define SC_X4_RSLVD8r_SIZE BCMI_TSCE16_XGXS_SC_X4_RSLVD8r_SIZE
typedef BCMI_TSCE16_XGXS_SC_X4_RSLVD8r_t SC_X4_RSLVD8r_t;
#define SC_X4_RSLVD8r_CLR BCMI_TSCE16_XGXS_SC_X4_RSLVD8r_CLR
#define SC_X4_RSLVD8r_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD8r_SET
#define SC_X4_RSLVD8r_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD8r_GET
#define SC_X4_RSLVD8r_PCS_CREDITGENCNTf_GET BCMI_TSCE16_XGXS_SC_X4_RSLVD8r_PCS_CREDITGENCNTf_GET
#define SC_X4_RSLVD8r_PCS_CREDITGENCNTf_SET BCMI_TSCE16_XGXS_SC_X4_RSLVD8r_PCS_CREDITGENCNTf_SET
#define READ_SC_X4_RSLVD8r BCMI_TSCE16_XGXS_READ_SC_X4_RSLVD8r
#define WRITE_SC_X4_RSLVD8r BCMI_TSCE16_XGXS_WRITE_SC_X4_RSLVD8r
#define MODIFY_SC_X4_RSLVD8r BCMI_TSCE16_XGXS_MODIFY_SC_X4_RSLVD8r
#define READLN_SC_X4_RSLVD8r BCMI_TSCE16_XGXS_READLN_SC_X4_RSLVD8r
#define WRITELN_SC_X4_RSLVD8r BCMI_TSCE16_XGXS_WRITELN_SC_X4_RSLVD8r
#define WRITEALL_SC_X4_RSLVD8r BCMI_TSCE16_XGXS_WRITEALL_SC_X4_RSLVD8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SC_X4_RSLVD8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_X4_CRED0
 * BLOCKS:   TX_X4_CREDIT0
 * REGADDR:  0xc100
 * DESC:     clock count 0 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CLOCKCNT0        clock count 0 for credit programming, range 5 to 4125
 *     CREDITENABLE     Enables credits to be generated for the MAC.
 *     SGMII_SPD_SWITCH Indicates to switch credits so that 10M/100M credits can go to the MAC and 1G credits can go to the PCS
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_X4_CRED0r (0x0000c100 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_X4_CRED0r_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_CRED0.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_X4_CRED0r_s {
	uint32_t v[1];
	uint32_t tx_x4_cred0[1];
	uint32_t _tx_x4_cred0;
} BCMI_TSCE16_XGXS_TX_X4_CRED0r_t;

#define BCMI_TSCE16_XGXS_TX_X4_CRED0r_CLR(r) (r).tx_x4_cred0[0] = 0
#define BCMI_TSCE16_XGXS_TX_X4_CRED0r_SET(r,d) (r).tx_x4_cred0[0] = d
#define BCMI_TSCE16_XGXS_TX_X4_CRED0r_GET(r) (r).tx_x4_cred0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_X4_CRED0r_SGMII_SPD_SWITCHf_GET(r) ((((r).tx_x4_cred0[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X4_CRED0r_SGMII_SPD_SWITCHf_SET(r,f) (r).tx_x4_cred0[0]=(((r).tx_x4_cred0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_TX_X4_CRED0r_CREDITENABLEf_GET(r) ((((r).tx_x4_cred0[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X4_CRED0r_CREDITENABLEf_SET(r,f) (r).tx_x4_cred0[0]=(((r).tx_x4_cred0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_TX_X4_CRED0r_CLOCKCNT0f_GET(r) (((r).tx_x4_cred0[0]) & 0x3fff)
#define BCMI_TSCE16_XGXS_TX_X4_CRED0r_CLOCKCNT0f_SET(r,f) (r).tx_x4_cred0[0]=(((r).tx_x4_cred0[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access TX_X4_CRED0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_X4_CRED0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_X4_CRED0r,(_r._tx_x4_cred0))
#define BCMI_TSCE16_XGXS_WRITE_TX_X4_CRED0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_CRED0r,(_r._tx_x4_cred0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_X4_CRED0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_CRED0r,(_r._tx_x4_cred0))
#define BCMI_TSCE16_XGXS_READLN_TX_X4_CRED0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_X4_CRED0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_cred0))
#define BCMI_TSCE16_XGXS_WRITELN_TX_X4_CRED0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_CRED0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_cred0))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_X4_CRED0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_CRED0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_cred0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_CRED0r BCMI_TSCE16_XGXS_TX_X4_CRED0r
#define TX_X4_CRED0r_SIZE BCMI_TSCE16_XGXS_TX_X4_CRED0r_SIZE
typedef BCMI_TSCE16_XGXS_TX_X4_CRED0r_t TX_X4_CRED0r_t;
#define TX_X4_CRED0r_CLR BCMI_TSCE16_XGXS_TX_X4_CRED0r_CLR
#define TX_X4_CRED0r_SET BCMI_TSCE16_XGXS_TX_X4_CRED0r_SET
#define TX_X4_CRED0r_GET BCMI_TSCE16_XGXS_TX_X4_CRED0r_GET
#define TX_X4_CRED0r_SGMII_SPD_SWITCHf_GET BCMI_TSCE16_XGXS_TX_X4_CRED0r_SGMII_SPD_SWITCHf_GET
#define TX_X4_CRED0r_SGMII_SPD_SWITCHf_SET BCMI_TSCE16_XGXS_TX_X4_CRED0r_SGMII_SPD_SWITCHf_SET
#define TX_X4_CRED0r_CREDITENABLEf_GET BCMI_TSCE16_XGXS_TX_X4_CRED0r_CREDITENABLEf_GET
#define TX_X4_CRED0r_CREDITENABLEf_SET BCMI_TSCE16_XGXS_TX_X4_CRED0r_CREDITENABLEf_SET
#define TX_X4_CRED0r_CLOCKCNT0f_GET BCMI_TSCE16_XGXS_TX_X4_CRED0r_CLOCKCNT0f_GET
#define TX_X4_CRED0r_CLOCKCNT0f_SET BCMI_TSCE16_XGXS_TX_X4_CRED0r_CLOCKCNT0f_SET
#define READ_TX_X4_CRED0r BCMI_TSCE16_XGXS_READ_TX_X4_CRED0r
#define WRITE_TX_X4_CRED0r BCMI_TSCE16_XGXS_WRITE_TX_X4_CRED0r
#define MODIFY_TX_X4_CRED0r BCMI_TSCE16_XGXS_MODIFY_TX_X4_CRED0r
#define READLN_TX_X4_CRED0r BCMI_TSCE16_XGXS_READLN_TX_X4_CRED0r
#define WRITELN_TX_X4_CRED0r BCMI_TSCE16_XGXS_WRITELN_TX_X4_CRED0r
#define WRITEALL_TX_X4_CRED0r BCMI_TSCE16_XGXS_WRITEALL_TX_X4_CRED0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_X4_CRED0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_X4_CRED1
 * BLOCKS:   TX_X4_CREDIT0
 * REGADDR:  0xc101
 * DESC:     clock count 1 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CLOCKCNT1        clock count 1 for credit programming, range 4 to 12
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_X4_CRED1r (0x0000c101 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_X4_CRED1r_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_CRED1.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_X4_CRED1r_s {
	uint32_t v[1];
	uint32_t tx_x4_cred1[1];
	uint32_t _tx_x4_cred1;
} BCMI_TSCE16_XGXS_TX_X4_CRED1r_t;

#define BCMI_TSCE16_XGXS_TX_X4_CRED1r_CLR(r) (r).tx_x4_cred1[0] = 0
#define BCMI_TSCE16_XGXS_TX_X4_CRED1r_SET(r,d) (r).tx_x4_cred1[0] = d
#define BCMI_TSCE16_XGXS_TX_X4_CRED1r_GET(r) (r).tx_x4_cred1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_X4_CRED1r_CLOCKCNT1f_GET(r) (((r).tx_x4_cred1[0]) & 0xff)
#define BCMI_TSCE16_XGXS_TX_X4_CRED1r_CLOCKCNT1f_SET(r,f) (r).tx_x4_cred1[0]=(((r).tx_x4_cred1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access TX_X4_CRED1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_X4_CRED1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_X4_CRED1r,(_r._tx_x4_cred1))
#define BCMI_TSCE16_XGXS_WRITE_TX_X4_CRED1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_CRED1r,(_r._tx_x4_cred1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_X4_CRED1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_CRED1r,(_r._tx_x4_cred1))
#define BCMI_TSCE16_XGXS_READLN_TX_X4_CRED1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_X4_CRED1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_cred1))
#define BCMI_TSCE16_XGXS_WRITELN_TX_X4_CRED1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_CRED1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_cred1))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_X4_CRED1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_CRED1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_cred1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_CRED1r BCMI_TSCE16_XGXS_TX_X4_CRED1r
#define TX_X4_CRED1r_SIZE BCMI_TSCE16_XGXS_TX_X4_CRED1r_SIZE
typedef BCMI_TSCE16_XGXS_TX_X4_CRED1r_t TX_X4_CRED1r_t;
#define TX_X4_CRED1r_CLR BCMI_TSCE16_XGXS_TX_X4_CRED1r_CLR
#define TX_X4_CRED1r_SET BCMI_TSCE16_XGXS_TX_X4_CRED1r_SET
#define TX_X4_CRED1r_GET BCMI_TSCE16_XGXS_TX_X4_CRED1r_GET
#define TX_X4_CRED1r_CLOCKCNT1f_GET BCMI_TSCE16_XGXS_TX_X4_CRED1r_CLOCKCNT1f_GET
#define TX_X4_CRED1r_CLOCKCNT1f_SET BCMI_TSCE16_XGXS_TX_X4_CRED1r_CLOCKCNT1f_SET
#define READ_TX_X4_CRED1r BCMI_TSCE16_XGXS_READ_TX_X4_CRED1r
#define WRITE_TX_X4_CRED1r BCMI_TSCE16_XGXS_WRITE_TX_X4_CRED1r
#define MODIFY_TX_X4_CRED1r BCMI_TSCE16_XGXS_MODIFY_TX_X4_CRED1r
#define READLN_TX_X4_CRED1r BCMI_TSCE16_XGXS_READLN_TX_X4_CRED1r
#define WRITELN_TX_X4_CRED1r BCMI_TSCE16_XGXS_WRITELN_TX_X4_CRED1r
#define WRITEALL_TX_X4_CRED1r BCMI_TSCE16_XGXS_WRITEALL_TX_X4_CRED1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_X4_CRED1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_X4_LOOPCNT
 * BLOCKS:   TX_X4_CREDIT0
 * REGADDR:  0xc102
 * DESC:     loop count 1_0 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LOOPCNT1         loop count 1 for credit programming, range 2 to 18
 *     LOOPCNT0         loop count 0 for credit programming, range 1 to 1
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_X4_LOOPCNTr (0x0000c102 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_X4_LOOPCNTr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_LOOPCNT.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_X4_LOOPCNTr_s {
	uint32_t v[1];
	uint32_t tx_x4_loopcnt[1];
	uint32_t _tx_x4_loopcnt;
} BCMI_TSCE16_XGXS_TX_X4_LOOPCNTr_t;

#define BCMI_TSCE16_XGXS_TX_X4_LOOPCNTr_CLR(r) (r).tx_x4_loopcnt[0] = 0
#define BCMI_TSCE16_XGXS_TX_X4_LOOPCNTr_SET(r,d) (r).tx_x4_loopcnt[0] = d
#define BCMI_TSCE16_XGXS_TX_X4_LOOPCNTr_GET(r) (r).tx_x4_loopcnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_X4_LOOPCNTr_LOOPCNT0f_GET(r) ((((r).tx_x4_loopcnt[0]) >> 6) & 0xff)
#define BCMI_TSCE16_XGXS_TX_X4_LOOPCNTr_LOOPCNT0f_SET(r,f) (r).tx_x4_loopcnt[0]=(((r).tx_x4_loopcnt[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6)) | (255 << (16 + 6))
#define BCMI_TSCE16_XGXS_TX_X4_LOOPCNTr_LOOPCNT1f_GET(r) (((r).tx_x4_loopcnt[0]) & 0x3f)
#define BCMI_TSCE16_XGXS_TX_X4_LOOPCNTr_LOOPCNT1f_SET(r,f) (r).tx_x4_loopcnt[0]=(((r).tx_x4_loopcnt[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access TX_X4_LOOPCNT.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_X4_LOOPCNTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_X4_LOOPCNTr,(_r._tx_x4_loopcnt))
#define BCMI_TSCE16_XGXS_WRITE_TX_X4_LOOPCNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_LOOPCNTr,(_r._tx_x4_loopcnt)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_X4_LOOPCNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_LOOPCNTr,(_r._tx_x4_loopcnt))
#define BCMI_TSCE16_XGXS_READLN_TX_X4_LOOPCNTr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_X4_LOOPCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_loopcnt))
#define BCMI_TSCE16_XGXS_WRITELN_TX_X4_LOOPCNTr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_LOOPCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_loopcnt))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_X4_LOOPCNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_LOOPCNTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_loopcnt))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_LOOPCNTr BCMI_TSCE16_XGXS_TX_X4_LOOPCNTr
#define TX_X4_LOOPCNTr_SIZE BCMI_TSCE16_XGXS_TX_X4_LOOPCNTr_SIZE
typedef BCMI_TSCE16_XGXS_TX_X4_LOOPCNTr_t TX_X4_LOOPCNTr_t;
#define TX_X4_LOOPCNTr_CLR BCMI_TSCE16_XGXS_TX_X4_LOOPCNTr_CLR
#define TX_X4_LOOPCNTr_SET BCMI_TSCE16_XGXS_TX_X4_LOOPCNTr_SET
#define TX_X4_LOOPCNTr_GET BCMI_TSCE16_XGXS_TX_X4_LOOPCNTr_GET
#define TX_X4_LOOPCNTr_LOOPCNT0f_GET BCMI_TSCE16_XGXS_TX_X4_LOOPCNTr_LOOPCNT0f_GET
#define TX_X4_LOOPCNTr_LOOPCNT0f_SET BCMI_TSCE16_XGXS_TX_X4_LOOPCNTr_LOOPCNT0f_SET
#define TX_X4_LOOPCNTr_LOOPCNT1f_GET BCMI_TSCE16_XGXS_TX_X4_LOOPCNTr_LOOPCNT1f_GET
#define TX_X4_LOOPCNTr_LOOPCNT1f_SET BCMI_TSCE16_XGXS_TX_X4_LOOPCNTr_LOOPCNT1f_SET
#define READ_TX_X4_LOOPCNTr BCMI_TSCE16_XGXS_READ_TX_X4_LOOPCNTr
#define WRITE_TX_X4_LOOPCNTr BCMI_TSCE16_XGXS_WRITE_TX_X4_LOOPCNTr
#define MODIFY_TX_X4_LOOPCNTr BCMI_TSCE16_XGXS_MODIFY_TX_X4_LOOPCNTr
#define READLN_TX_X4_LOOPCNTr BCMI_TSCE16_XGXS_READLN_TX_X4_LOOPCNTr
#define WRITELN_TX_X4_LOOPCNTr BCMI_TSCE16_XGXS_WRITELN_TX_X4_LOOPCNTr
#define WRITEALL_TX_X4_LOOPCNTr BCMI_TSCE16_XGXS_WRITEALL_TX_X4_LOOPCNTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_X4_LOOPCNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_X4_MAC_CREDGENCNT
 * BLOCKS:   TX_X4_CREDIT0
 * REGADDR:  0xc103
 * DESC:     credit gen count register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MAC_CREDITGENCNT clock count 0 for credit programming, range 1 to 2063
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_X4_MAC_CREDGENCNTr (0x0000c103 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_X4_MAC_CREDGENCNTr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_MAC_CREDGENCNT.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_X4_MAC_CREDGENCNTr_s {
	uint32_t v[1];
	uint32_t tx_x4_mac_credgencnt[1];
	uint32_t _tx_x4_mac_credgencnt;
} BCMI_TSCE16_XGXS_TX_X4_MAC_CREDGENCNTr_t;

#define BCMI_TSCE16_XGXS_TX_X4_MAC_CREDGENCNTr_CLR(r) (r).tx_x4_mac_credgencnt[0] = 0
#define BCMI_TSCE16_XGXS_TX_X4_MAC_CREDGENCNTr_SET(r,d) (r).tx_x4_mac_credgencnt[0] = d
#define BCMI_TSCE16_XGXS_TX_X4_MAC_CREDGENCNTr_GET(r) (r).tx_x4_mac_credgencnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_X4_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_GET(r) (((r).tx_x4_mac_credgencnt[0]) & 0x1fff)
#define BCMI_TSCE16_XGXS_TX_X4_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_SET(r,f) (r).tx_x4_mac_credgencnt[0]=(((r).tx_x4_mac_credgencnt[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access TX_X4_MAC_CREDGENCNT.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_X4_MAC_CREDGENCNTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_X4_MAC_CREDGENCNTr,(_r._tx_x4_mac_credgencnt))
#define BCMI_TSCE16_XGXS_WRITE_TX_X4_MAC_CREDGENCNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_MAC_CREDGENCNTr,(_r._tx_x4_mac_credgencnt)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_X4_MAC_CREDGENCNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_MAC_CREDGENCNTr,(_r._tx_x4_mac_credgencnt))
#define BCMI_TSCE16_XGXS_READLN_TX_X4_MAC_CREDGENCNTr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_X4_MAC_CREDGENCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_mac_credgencnt))
#define BCMI_TSCE16_XGXS_WRITELN_TX_X4_MAC_CREDGENCNTr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_MAC_CREDGENCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_mac_credgencnt))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_X4_MAC_CREDGENCNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_MAC_CREDGENCNTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_mac_credgencnt))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_MAC_CREDGENCNTr BCMI_TSCE16_XGXS_TX_X4_MAC_CREDGENCNTr
#define TX_X4_MAC_CREDGENCNTr_SIZE BCMI_TSCE16_XGXS_TX_X4_MAC_CREDGENCNTr_SIZE
typedef BCMI_TSCE16_XGXS_TX_X4_MAC_CREDGENCNTr_t TX_X4_MAC_CREDGENCNTr_t;
#define TX_X4_MAC_CREDGENCNTr_CLR BCMI_TSCE16_XGXS_TX_X4_MAC_CREDGENCNTr_CLR
#define TX_X4_MAC_CREDGENCNTr_SET BCMI_TSCE16_XGXS_TX_X4_MAC_CREDGENCNTr_SET
#define TX_X4_MAC_CREDGENCNTr_GET BCMI_TSCE16_XGXS_TX_X4_MAC_CREDGENCNTr_GET
#define TX_X4_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_GET BCMI_TSCE16_XGXS_TX_X4_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_GET
#define TX_X4_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_SET BCMI_TSCE16_XGXS_TX_X4_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_SET
#define READ_TX_X4_MAC_CREDGENCNTr BCMI_TSCE16_XGXS_READ_TX_X4_MAC_CREDGENCNTr
#define WRITE_TX_X4_MAC_CREDGENCNTr BCMI_TSCE16_XGXS_WRITE_TX_X4_MAC_CREDGENCNTr
#define MODIFY_TX_X4_MAC_CREDGENCNTr BCMI_TSCE16_XGXS_MODIFY_TX_X4_MAC_CREDGENCNTr
#define READLN_TX_X4_MAC_CREDGENCNTr BCMI_TSCE16_XGXS_READLN_TX_X4_MAC_CREDGENCNTr
#define WRITELN_TX_X4_MAC_CREDGENCNTr BCMI_TSCE16_XGXS_WRITELN_TX_X4_MAC_CREDGENCNTr
#define WRITEALL_TX_X4_MAC_CREDGENCNTr BCMI_TSCE16_XGXS_WRITEALL_TX_X4_MAC_CREDGENCNTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_X4_MAC_CREDGENCNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_X4_PCS_CLKCNT0
 * BLOCKS:   TX_X4_CREDIT0
 * REGADDR:  0xc104
 * DESC:     pcs clock count 0 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_CLOCKCNT0    pcs clock count 0 for credit programming, range 5 to 4125
 *     PCS_CREDITENABLE Enables credits to be generated for the PCS.  Only used in 10M or 100M modes.
 *     REPLICATION_CNT  Set to one (1) for 10M and zero (0) for 100M
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_X4_PCS_CLKCNT0r (0x0000c104 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_X4_PCS_CLKCNT0r_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_PCS_CLKCNT0.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_X4_PCS_CLKCNT0r_s {
	uint32_t v[1];
	uint32_t tx_x4_pcs_clkcnt0[1];
	uint32_t _tx_x4_pcs_clkcnt0;
} BCMI_TSCE16_XGXS_TX_X4_PCS_CLKCNT0r_t;

#define BCMI_TSCE16_XGXS_TX_X4_PCS_CLKCNT0r_CLR(r) (r).tx_x4_pcs_clkcnt0[0] = 0
#define BCMI_TSCE16_XGXS_TX_X4_PCS_CLKCNT0r_SET(r,d) (r).tx_x4_pcs_clkcnt0[0] = d
#define BCMI_TSCE16_XGXS_TX_X4_PCS_CLKCNT0r_GET(r) (r).tx_x4_pcs_clkcnt0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_X4_PCS_CLKCNT0r_REPLICATION_CNTf_GET(r) ((((r).tx_x4_pcs_clkcnt0[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X4_PCS_CLKCNT0r_REPLICATION_CNTf_SET(r,f) (r).tx_x4_pcs_clkcnt0[0]=(((r).tx_x4_pcs_clkcnt0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_TX_X4_PCS_CLKCNT0r_PCS_CREDITENABLEf_GET(r) ((((r).tx_x4_pcs_clkcnt0[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X4_PCS_CLKCNT0r_PCS_CREDITENABLEf_SET(r,f) (r).tx_x4_pcs_clkcnt0[0]=(((r).tx_x4_pcs_clkcnt0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_TX_X4_PCS_CLKCNT0r_PCS_CLOCKCNT0f_GET(r) (((r).tx_x4_pcs_clkcnt0[0]) & 0x3fff)
#define BCMI_TSCE16_XGXS_TX_X4_PCS_CLKCNT0r_PCS_CLOCKCNT0f_SET(r,f) (r).tx_x4_pcs_clkcnt0[0]=(((r).tx_x4_pcs_clkcnt0[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access TX_X4_PCS_CLKCNT0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_X4_PCS_CLKCNT0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_X4_PCS_CLKCNT0r,(_r._tx_x4_pcs_clkcnt0))
#define BCMI_TSCE16_XGXS_WRITE_TX_X4_PCS_CLKCNT0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_PCS_CLKCNT0r,(_r._tx_x4_pcs_clkcnt0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_X4_PCS_CLKCNT0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_PCS_CLKCNT0r,(_r._tx_x4_pcs_clkcnt0))
#define BCMI_TSCE16_XGXS_READLN_TX_X4_PCS_CLKCNT0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_X4_PCS_CLKCNT0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_pcs_clkcnt0))
#define BCMI_TSCE16_XGXS_WRITELN_TX_X4_PCS_CLKCNT0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_PCS_CLKCNT0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_pcs_clkcnt0))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_X4_PCS_CLKCNT0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_PCS_CLKCNT0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_pcs_clkcnt0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_PCS_CLKCNT0r BCMI_TSCE16_XGXS_TX_X4_PCS_CLKCNT0r
#define TX_X4_PCS_CLKCNT0r_SIZE BCMI_TSCE16_XGXS_TX_X4_PCS_CLKCNT0r_SIZE
typedef BCMI_TSCE16_XGXS_TX_X4_PCS_CLKCNT0r_t TX_X4_PCS_CLKCNT0r_t;
#define TX_X4_PCS_CLKCNT0r_CLR BCMI_TSCE16_XGXS_TX_X4_PCS_CLKCNT0r_CLR
#define TX_X4_PCS_CLKCNT0r_SET BCMI_TSCE16_XGXS_TX_X4_PCS_CLKCNT0r_SET
#define TX_X4_PCS_CLKCNT0r_GET BCMI_TSCE16_XGXS_TX_X4_PCS_CLKCNT0r_GET
#define TX_X4_PCS_CLKCNT0r_REPLICATION_CNTf_GET BCMI_TSCE16_XGXS_TX_X4_PCS_CLKCNT0r_REPLICATION_CNTf_GET
#define TX_X4_PCS_CLKCNT0r_REPLICATION_CNTf_SET BCMI_TSCE16_XGXS_TX_X4_PCS_CLKCNT0r_REPLICATION_CNTf_SET
#define TX_X4_PCS_CLKCNT0r_PCS_CREDITENABLEf_GET BCMI_TSCE16_XGXS_TX_X4_PCS_CLKCNT0r_PCS_CREDITENABLEf_GET
#define TX_X4_PCS_CLKCNT0r_PCS_CREDITENABLEf_SET BCMI_TSCE16_XGXS_TX_X4_PCS_CLKCNT0r_PCS_CREDITENABLEf_SET
#define TX_X4_PCS_CLKCNT0r_PCS_CLOCKCNT0f_GET BCMI_TSCE16_XGXS_TX_X4_PCS_CLKCNT0r_PCS_CLOCKCNT0f_GET
#define TX_X4_PCS_CLKCNT0r_PCS_CLOCKCNT0f_SET BCMI_TSCE16_XGXS_TX_X4_PCS_CLKCNT0r_PCS_CLOCKCNT0f_SET
#define READ_TX_X4_PCS_CLKCNT0r BCMI_TSCE16_XGXS_READ_TX_X4_PCS_CLKCNT0r
#define WRITE_TX_X4_PCS_CLKCNT0r BCMI_TSCE16_XGXS_WRITE_TX_X4_PCS_CLKCNT0r
#define MODIFY_TX_X4_PCS_CLKCNT0r BCMI_TSCE16_XGXS_MODIFY_TX_X4_PCS_CLKCNT0r
#define READLN_TX_X4_PCS_CLKCNT0r BCMI_TSCE16_XGXS_READLN_TX_X4_PCS_CLKCNT0r
#define WRITELN_TX_X4_PCS_CLKCNT0r BCMI_TSCE16_XGXS_WRITELN_TX_X4_PCS_CLKCNT0r
#define WRITEALL_TX_X4_PCS_CLKCNT0r BCMI_TSCE16_XGXS_WRITEALL_TX_X4_PCS_CLKCNT0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_X4_PCS_CLKCNT0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_X4_PCS_CREDGENCNT
 * BLOCKS:   TX_X4_CREDIT0
 * REGADDR:  0xc105
 * DESC:     pcs credit gen count register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_CREDITGENCNT pcs clock count 0 for credit programming, range 1 to 2063
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_X4_PCS_CREDGENCNTr (0x0000c105 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_X4_PCS_CREDGENCNTr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_PCS_CREDGENCNT.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_X4_PCS_CREDGENCNTr_s {
	uint32_t v[1];
	uint32_t tx_x4_pcs_credgencnt[1];
	uint32_t _tx_x4_pcs_credgencnt;
} BCMI_TSCE16_XGXS_TX_X4_PCS_CREDGENCNTr_t;

#define BCMI_TSCE16_XGXS_TX_X4_PCS_CREDGENCNTr_CLR(r) (r).tx_x4_pcs_credgencnt[0] = 0
#define BCMI_TSCE16_XGXS_TX_X4_PCS_CREDGENCNTr_SET(r,d) (r).tx_x4_pcs_credgencnt[0] = d
#define BCMI_TSCE16_XGXS_TX_X4_PCS_CREDGENCNTr_GET(r) (r).tx_x4_pcs_credgencnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_X4_PCS_CREDGENCNTr_PCS_CREDITGENCNTf_GET(r) (((r).tx_x4_pcs_credgencnt[0]) & 0x1fff)
#define BCMI_TSCE16_XGXS_TX_X4_PCS_CREDGENCNTr_PCS_CREDITGENCNTf_SET(r,f) (r).tx_x4_pcs_credgencnt[0]=(((r).tx_x4_pcs_credgencnt[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access TX_X4_PCS_CREDGENCNT.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_X4_PCS_CREDGENCNTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_X4_PCS_CREDGENCNTr,(_r._tx_x4_pcs_credgencnt))
#define BCMI_TSCE16_XGXS_WRITE_TX_X4_PCS_CREDGENCNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_PCS_CREDGENCNTr,(_r._tx_x4_pcs_credgencnt)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_X4_PCS_CREDGENCNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_PCS_CREDGENCNTr,(_r._tx_x4_pcs_credgencnt))
#define BCMI_TSCE16_XGXS_READLN_TX_X4_PCS_CREDGENCNTr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_X4_PCS_CREDGENCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_pcs_credgencnt))
#define BCMI_TSCE16_XGXS_WRITELN_TX_X4_PCS_CREDGENCNTr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_PCS_CREDGENCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_pcs_credgencnt))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_X4_PCS_CREDGENCNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_PCS_CREDGENCNTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_pcs_credgencnt))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_PCS_CREDGENCNTr BCMI_TSCE16_XGXS_TX_X4_PCS_CREDGENCNTr
#define TX_X4_PCS_CREDGENCNTr_SIZE BCMI_TSCE16_XGXS_TX_X4_PCS_CREDGENCNTr_SIZE
typedef BCMI_TSCE16_XGXS_TX_X4_PCS_CREDGENCNTr_t TX_X4_PCS_CREDGENCNTr_t;
#define TX_X4_PCS_CREDGENCNTr_CLR BCMI_TSCE16_XGXS_TX_X4_PCS_CREDGENCNTr_CLR
#define TX_X4_PCS_CREDGENCNTr_SET BCMI_TSCE16_XGXS_TX_X4_PCS_CREDGENCNTr_SET
#define TX_X4_PCS_CREDGENCNTr_GET BCMI_TSCE16_XGXS_TX_X4_PCS_CREDGENCNTr_GET
#define TX_X4_PCS_CREDGENCNTr_PCS_CREDITGENCNTf_GET BCMI_TSCE16_XGXS_TX_X4_PCS_CREDGENCNTr_PCS_CREDITGENCNTf_GET
#define TX_X4_PCS_CREDGENCNTr_PCS_CREDITGENCNTf_SET BCMI_TSCE16_XGXS_TX_X4_PCS_CREDGENCNTr_PCS_CREDITGENCNTf_SET
#define READ_TX_X4_PCS_CREDGENCNTr BCMI_TSCE16_XGXS_READ_TX_X4_PCS_CREDGENCNTr
#define WRITE_TX_X4_PCS_CREDGENCNTr BCMI_TSCE16_XGXS_WRITE_TX_X4_PCS_CREDGENCNTr
#define MODIFY_TX_X4_PCS_CREDGENCNTr BCMI_TSCE16_XGXS_MODIFY_TX_X4_PCS_CREDGENCNTr
#define READLN_TX_X4_PCS_CREDGENCNTr BCMI_TSCE16_XGXS_READLN_TX_X4_PCS_CREDGENCNTr
#define WRITELN_TX_X4_PCS_CREDGENCNTr BCMI_TSCE16_XGXS_WRITELN_TX_X4_PCS_CREDGENCNTr
#define WRITEALL_TX_X4_PCS_CREDGENCNTr BCMI_TSCE16_XGXS_WRITEALL_TX_X4_PCS_CREDGENCNTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_X4_PCS_CREDGENCNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_X4_ENC0
 * BLOCKS:   TX_X4_CONTROL0
 * REGADDR:  0xc111
 * DESC:     Encode 0 register
 * RESETVAL: 0x800 (2048)
 * ACCESS:   R/W
 * FIELDS:
 *     ENCODEMODE       000 All functions disabled for lane001 cl48 8b10b010 cl48 8b10b rxaui011 cl36 8b10b100 cl82 64b66b101 cl49 64b66b110 brcm 64b66b
 *     CL49_TX_TL_MODE  Enables alternate table lookup entry for cl49
 *     T_TEST_MODE_CFG  Enables the CL49/CL82 encoder to send IDLE control block forscrambled IDLE test pattern generation
 *     CL49_BYPASS_TXSM Bypass cl49 transmit state machine1 = Bypass cl49 txsm :- force TX_INIT state- pass the data from the table look-up decoder to the output0 = normal mode
 *     HG2_ENABLE       Enables HG2 support for PCS
 *     HG2_MESSAGE_INVALID_CODE_ENABLE Enables HG2 invalid message code support.
 *     HG2_CODEC        Enables HG2 extensions support for PCSSet this bit to enable HG2 messaging
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_X4_ENC0r (0x0000c111 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_X4_ENC0r_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_ENC0.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_X4_ENC0r_s {
	uint32_t v[1];
	uint32_t tx_x4_enc0[1];
	uint32_t _tx_x4_enc0;
} BCMI_TSCE16_XGXS_TX_X4_ENC0r_t;

#define BCMI_TSCE16_XGXS_TX_X4_ENC0r_CLR(r) (r).tx_x4_enc0[0] = 0
#define BCMI_TSCE16_XGXS_TX_X4_ENC0r_SET(r,d) (r).tx_x4_enc0[0] = d
#define BCMI_TSCE16_XGXS_TX_X4_ENC0r_GET(r) (r).tx_x4_enc0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_X4_ENC0r_HG2_CODECf_GET(r) ((((r).tx_x4_enc0[0]) >> 12) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X4_ENC0r_HG2_CODECf_SET(r,f) (r).tx_x4_enc0[0]=(((r).tx_x4_enc0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCE16_XGXS_TX_X4_ENC0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_GET(r) ((((r).tx_x4_enc0[0]) >> 11) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X4_ENC0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_SET(r,f) (r).tx_x4_enc0[0]=(((r).tx_x4_enc0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCE16_XGXS_TX_X4_ENC0r_HG2_ENABLEf_GET(r) ((((r).tx_x4_enc0[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X4_ENC0r_HG2_ENABLEf_SET(r,f) (r).tx_x4_enc0[0]=(((r).tx_x4_enc0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_TX_X4_ENC0r_CL49_BYPASS_TXSMf_GET(r) ((((r).tx_x4_enc0[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X4_ENC0r_CL49_BYPASS_TXSMf_SET(r,f) (r).tx_x4_enc0[0]=(((r).tx_x4_enc0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_TX_X4_ENC0r_T_TEST_MODE_CFGf_GET(r) ((((r).tx_x4_enc0[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X4_ENC0r_T_TEST_MODE_CFGf_SET(r,f) (r).tx_x4_enc0[0]=(((r).tx_x4_enc0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_TX_X4_ENC0r_CL49_TX_TL_MODEf_GET(r) ((((r).tx_x4_enc0[0]) >> 5) & 0x3)
#define BCMI_TSCE16_XGXS_TX_X4_ENC0r_CL49_TX_TL_MODEf_SET(r,f) (r).tx_x4_enc0[0]=(((r).tx_x4_enc0[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5)) | (3 << (16 + 5))
#define BCMI_TSCE16_XGXS_TX_X4_ENC0r_ENCODEMODEf_GET(r) ((((r).tx_x4_enc0[0]) >> 2) & 0x7)
#define BCMI_TSCE16_XGXS_TX_X4_ENC0r_ENCODEMODEf_SET(r,f) (r).tx_x4_enc0[0]=(((r).tx_x4_enc0[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2)) | (7 << (16 + 2))

/*
 * These macros can be used to access TX_X4_ENC0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_X4_ENC0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_X4_ENC0r,(_r._tx_x4_enc0))
#define BCMI_TSCE16_XGXS_WRITE_TX_X4_ENC0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_ENC0r,(_r._tx_x4_enc0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_X4_ENC0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_ENC0r,(_r._tx_x4_enc0))
#define BCMI_TSCE16_XGXS_READLN_TX_X4_ENC0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_X4_ENC0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_enc0))
#define BCMI_TSCE16_XGXS_WRITELN_TX_X4_ENC0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_ENC0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_enc0))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_X4_ENC0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_ENC0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_enc0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_ENC0r BCMI_TSCE16_XGXS_TX_X4_ENC0r
#define TX_X4_ENC0r_SIZE BCMI_TSCE16_XGXS_TX_X4_ENC0r_SIZE
typedef BCMI_TSCE16_XGXS_TX_X4_ENC0r_t TX_X4_ENC0r_t;
#define TX_X4_ENC0r_CLR BCMI_TSCE16_XGXS_TX_X4_ENC0r_CLR
#define TX_X4_ENC0r_SET BCMI_TSCE16_XGXS_TX_X4_ENC0r_SET
#define TX_X4_ENC0r_GET BCMI_TSCE16_XGXS_TX_X4_ENC0r_GET
#define TX_X4_ENC0r_HG2_CODECf_GET BCMI_TSCE16_XGXS_TX_X4_ENC0r_HG2_CODECf_GET
#define TX_X4_ENC0r_HG2_CODECf_SET BCMI_TSCE16_XGXS_TX_X4_ENC0r_HG2_CODECf_SET
#define TX_X4_ENC0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_GET BCMI_TSCE16_XGXS_TX_X4_ENC0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_GET
#define TX_X4_ENC0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_SET BCMI_TSCE16_XGXS_TX_X4_ENC0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_SET
#define TX_X4_ENC0r_HG2_ENABLEf_GET BCMI_TSCE16_XGXS_TX_X4_ENC0r_HG2_ENABLEf_GET
#define TX_X4_ENC0r_HG2_ENABLEf_SET BCMI_TSCE16_XGXS_TX_X4_ENC0r_HG2_ENABLEf_SET
#define TX_X4_ENC0r_CL49_BYPASS_TXSMf_GET BCMI_TSCE16_XGXS_TX_X4_ENC0r_CL49_BYPASS_TXSMf_GET
#define TX_X4_ENC0r_CL49_BYPASS_TXSMf_SET BCMI_TSCE16_XGXS_TX_X4_ENC0r_CL49_BYPASS_TXSMf_SET
#define TX_X4_ENC0r_T_TEST_MODE_CFGf_GET BCMI_TSCE16_XGXS_TX_X4_ENC0r_T_TEST_MODE_CFGf_GET
#define TX_X4_ENC0r_T_TEST_MODE_CFGf_SET BCMI_TSCE16_XGXS_TX_X4_ENC0r_T_TEST_MODE_CFGf_SET
#define TX_X4_ENC0r_CL49_TX_TL_MODEf_GET BCMI_TSCE16_XGXS_TX_X4_ENC0r_CL49_TX_TL_MODEf_GET
#define TX_X4_ENC0r_CL49_TX_TL_MODEf_SET BCMI_TSCE16_XGXS_TX_X4_ENC0r_CL49_TX_TL_MODEf_SET
#define TX_X4_ENC0r_ENCODEMODEf_GET BCMI_TSCE16_XGXS_TX_X4_ENC0r_ENCODEMODEf_GET
#define TX_X4_ENC0r_ENCODEMODEf_SET BCMI_TSCE16_XGXS_TX_X4_ENC0r_ENCODEMODEf_SET
#define READ_TX_X4_ENC0r BCMI_TSCE16_XGXS_READ_TX_X4_ENC0r
#define WRITE_TX_X4_ENC0r BCMI_TSCE16_XGXS_WRITE_TX_X4_ENC0r
#define MODIFY_TX_X4_ENC0r BCMI_TSCE16_XGXS_MODIFY_TX_X4_ENC0r
#define READLN_TX_X4_ENC0r BCMI_TSCE16_XGXS_READLN_TX_X4_ENC0r
#define WRITELN_TX_X4_ENC0r BCMI_TSCE16_XGXS_WRITELN_TX_X4_ENC0r
#define WRITEALL_TX_X4_ENC0r BCMI_TSCE16_XGXS_WRITEALL_TX_X4_ENC0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_X4_ENC0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_X4_ENC1
 * BLOCKS:   TX_X4_CONTROL0
 * REGADDR:  0xc112
 * DESC:     Encode 1 register 64/66 Encoder Programmable Table Lookup Control Character
 * RESETVAL: 0x1b4 (436)
 * ACCESS:   R/W
 * FIELDS:
 *     PROG_TL_CHAR     A programmable control character for table lookup.
 *     PROG_TL_EN       Enable lookup of programmable control character
 *     CATCH_ALL_8B10B_DIS The following logic implements the catch-all special code-group case indicatedin the IEEE Std 802.3-2005, Table 48-2. Basically, it states that any invalidcode-group NOT defined in either Table 36-2 Valid special code-groups, orTable 48-2 XGMII character to PCS code-group mapping, shall be mapped tospecial code-group K30.7 (i.e. 10'h1FE). An input mux muxes out the actualinput data[7:0] or the 10'h1FE onto the internal bus, data_int, which drivesthe orginal 8b10b logic. A control, named catch_all_8b10b_dis, is used to turn offthe catch-all; default is catch-all is ON.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_X4_ENC1r (0x0000c112 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_X4_ENC1r_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_ENC1.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_X4_ENC1r_s {
	uint32_t v[1];
	uint32_t tx_x4_enc1[1];
	uint32_t _tx_x4_enc1;
} BCMI_TSCE16_XGXS_TX_X4_ENC1r_t;

#define BCMI_TSCE16_XGXS_TX_X4_ENC1r_CLR(r) (r).tx_x4_enc1[0] = 0
#define BCMI_TSCE16_XGXS_TX_X4_ENC1r_SET(r,d) (r).tx_x4_enc1[0] = d
#define BCMI_TSCE16_XGXS_TX_X4_ENC1r_GET(r) (r).tx_x4_enc1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_X4_ENC1r_CATCH_ALL_8B10B_DISf_GET(r) ((((r).tx_x4_enc1[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X4_ENC1r_CATCH_ALL_8B10B_DISf_SET(r,f) (r).tx_x4_enc1[0]=(((r).tx_x4_enc1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_TX_X4_ENC1r_PROG_TL_ENf_GET(r) ((((r).tx_x4_enc1[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X4_ENC1r_PROG_TL_ENf_SET(r,f) (r).tx_x4_enc1[0]=(((r).tx_x4_enc1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_TX_X4_ENC1r_PROG_TL_CHARf_GET(r) (((r).tx_x4_enc1[0]) & 0xff)
#define BCMI_TSCE16_XGXS_TX_X4_ENC1r_PROG_TL_CHARf_SET(r,f) (r).tx_x4_enc1[0]=(((r).tx_x4_enc1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access TX_X4_ENC1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_X4_ENC1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_X4_ENC1r,(_r._tx_x4_enc1))
#define BCMI_TSCE16_XGXS_WRITE_TX_X4_ENC1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_ENC1r,(_r._tx_x4_enc1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_X4_ENC1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_ENC1r,(_r._tx_x4_enc1))
#define BCMI_TSCE16_XGXS_READLN_TX_X4_ENC1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_X4_ENC1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_enc1))
#define BCMI_TSCE16_XGXS_WRITELN_TX_X4_ENC1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_ENC1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_enc1))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_X4_ENC1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_ENC1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_enc1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_ENC1r BCMI_TSCE16_XGXS_TX_X4_ENC1r
#define TX_X4_ENC1r_SIZE BCMI_TSCE16_XGXS_TX_X4_ENC1r_SIZE
typedef BCMI_TSCE16_XGXS_TX_X4_ENC1r_t TX_X4_ENC1r_t;
#define TX_X4_ENC1r_CLR BCMI_TSCE16_XGXS_TX_X4_ENC1r_CLR
#define TX_X4_ENC1r_SET BCMI_TSCE16_XGXS_TX_X4_ENC1r_SET
#define TX_X4_ENC1r_GET BCMI_TSCE16_XGXS_TX_X4_ENC1r_GET
#define TX_X4_ENC1r_CATCH_ALL_8B10B_DISf_GET BCMI_TSCE16_XGXS_TX_X4_ENC1r_CATCH_ALL_8B10B_DISf_GET
#define TX_X4_ENC1r_CATCH_ALL_8B10B_DISf_SET BCMI_TSCE16_XGXS_TX_X4_ENC1r_CATCH_ALL_8B10B_DISf_SET
#define TX_X4_ENC1r_PROG_TL_ENf_GET BCMI_TSCE16_XGXS_TX_X4_ENC1r_PROG_TL_ENf_GET
#define TX_X4_ENC1r_PROG_TL_ENf_SET BCMI_TSCE16_XGXS_TX_X4_ENC1r_PROG_TL_ENf_SET
#define TX_X4_ENC1r_PROG_TL_CHARf_GET BCMI_TSCE16_XGXS_TX_X4_ENC1r_PROG_TL_CHARf_GET
#define TX_X4_ENC1r_PROG_TL_CHARf_SET BCMI_TSCE16_XGXS_TX_X4_ENC1r_PROG_TL_CHARf_SET
#define READ_TX_X4_ENC1r BCMI_TSCE16_XGXS_READ_TX_X4_ENC1r
#define WRITE_TX_X4_ENC1r BCMI_TSCE16_XGXS_WRITE_TX_X4_ENC1r
#define MODIFY_TX_X4_ENC1r BCMI_TSCE16_XGXS_MODIFY_TX_X4_ENC1r
#define READLN_TX_X4_ENC1r BCMI_TSCE16_XGXS_READLN_TX_X4_ENC1r
#define WRITELN_TX_X4_ENC1r BCMI_TSCE16_XGXS_WRITELN_TX_X4_ENC1r
#define WRITEALL_TX_X4_ENC1r BCMI_TSCE16_XGXS_WRITEALL_TX_X4_ENC1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_X4_ENC1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_X4_MISC
 * BLOCKS:   TX_X4_CONTROL0
 * REGADDR:  0xc113
 * DESC:     Misc register
 * RESETVAL: 0x1c8 (456)
 * ACCESS:   R/W
 * FIELDS:
 *     ENABLE_TX_LANE   Per lane enable to allow DVs from MAC to enter TXP
 *     RSTB_TX_LANE     Low active reset for txp lanes
 *     TX_FIFO_WATERMARK Per logical lane tx fifo watermark0: N/A1: Depth of 12: Depth of 23: Depth of 3
 *     CL49_TX_RF_ENABLE If this bit is a one, RFs are passed from the RS LAYER to the PCS.If this bit is a zero, RFs are replaced by IDLEs which are then passedto the PCS.For CL49 only.
 *     CL49_TX_LF_ENABLE If this bit is a one, LFs are passed from the RS LAYER to the PCS.If this bit is a zero, LFs are replaced by IDLEs which are then passedto the PCS.For CL49 only.
 *     CL49_TX_LI_ENABLE If this bit is a one, LIs (Link Interrupt) are passed thru to the RS LAYER.If this bit is a zero, LIs (Link Interrupt) are replaced by IDLEs which are then passedto the RS LAYER.For CL49 only.
 *     FEC_ENABLE       
 *     SCR_MODE         00 bypass scrambler01 64b66b scrambler (all 66 bits)10 8b10b scrambler (all 80 bits)11 64b66b scrambler (sync bits not scrambled)
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_X4_MISCr (0x0000c113 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_X4_MISCr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_MISC.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_X4_MISCr_s {
	uint32_t v[1];
	uint32_t tx_x4_misc[1];
	uint32_t _tx_x4_misc;
} BCMI_TSCE16_XGXS_TX_X4_MISCr_t;

#define BCMI_TSCE16_XGXS_TX_X4_MISCr_CLR(r) (r).tx_x4_misc[0] = 0
#define BCMI_TSCE16_XGXS_TX_X4_MISCr_SET(r,d) (r).tx_x4_misc[0] = d
#define BCMI_TSCE16_XGXS_TX_X4_MISCr_GET(r) (r).tx_x4_misc[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_X4_MISCr_SCR_MODEf_GET(r) ((((r).tx_x4_misc[0]) >> 14) & 0x3)
#define BCMI_TSCE16_XGXS_TX_X4_MISCr_SCR_MODEf_SET(r,f) (r).tx_x4_misc[0]=(((r).tx_x4_misc[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCE16_XGXS_TX_X4_MISCr_FEC_ENABLEf_GET(r) ((((r).tx_x4_misc[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X4_MISCr_FEC_ENABLEf_SET(r,f) (r).tx_x4_misc[0]=(((r).tx_x4_misc[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_TX_X4_MISCr_CL49_TX_LI_ENABLEf_GET(r) ((((r).tx_x4_misc[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X4_MISCr_CL49_TX_LI_ENABLEf_SET(r,f) (r).tx_x4_misc[0]=(((r).tx_x4_misc[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_TX_X4_MISCr_CL49_TX_LF_ENABLEf_GET(r) ((((r).tx_x4_misc[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X4_MISCr_CL49_TX_LF_ENABLEf_SET(r,f) (r).tx_x4_misc[0]=(((r).tx_x4_misc[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_TX_X4_MISCr_CL49_TX_RF_ENABLEf_GET(r) ((((r).tx_x4_misc[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X4_MISCr_CL49_TX_RF_ENABLEf_SET(r,f) (r).tx_x4_misc[0]=(((r).tx_x4_misc[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_TX_X4_MISCr_TX_FIFO_WATERMARKf_GET(r) ((((r).tx_x4_misc[0]) >> 2) & 0x3)
#define BCMI_TSCE16_XGXS_TX_X4_MISCr_TX_FIFO_WATERMARKf_SET(r,f) (r).tx_x4_misc[0]=(((r).tx_x4_misc[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCE16_XGXS_TX_X4_MISCr_RSTB_TX_LANEf_GET(r) ((((r).tx_x4_misc[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X4_MISCr_RSTB_TX_LANEf_SET(r,f) (r).tx_x4_misc[0]=(((r).tx_x4_misc[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_TX_X4_MISCr_ENABLE_TX_LANEf_GET(r) (((r).tx_x4_misc[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X4_MISCr_ENABLE_TX_LANEf_SET(r,f) (r).tx_x4_misc[0]=(((r).tx_x4_misc[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_X4_MISC.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_X4_MISCr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_X4_MISCr,(_r._tx_x4_misc))
#define BCMI_TSCE16_XGXS_WRITE_TX_X4_MISCr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_MISCr,(_r._tx_x4_misc)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_X4_MISCr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_MISCr,(_r._tx_x4_misc))
#define BCMI_TSCE16_XGXS_READLN_TX_X4_MISCr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_X4_MISCr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_misc))
#define BCMI_TSCE16_XGXS_WRITELN_TX_X4_MISCr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_MISCr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_misc))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_X4_MISCr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_MISCr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_misc))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_MISCr BCMI_TSCE16_XGXS_TX_X4_MISCr
#define TX_X4_MISCr_SIZE BCMI_TSCE16_XGXS_TX_X4_MISCr_SIZE
typedef BCMI_TSCE16_XGXS_TX_X4_MISCr_t TX_X4_MISCr_t;
#define TX_X4_MISCr_CLR BCMI_TSCE16_XGXS_TX_X4_MISCr_CLR
#define TX_X4_MISCr_SET BCMI_TSCE16_XGXS_TX_X4_MISCr_SET
#define TX_X4_MISCr_GET BCMI_TSCE16_XGXS_TX_X4_MISCr_GET
#define TX_X4_MISCr_SCR_MODEf_GET BCMI_TSCE16_XGXS_TX_X4_MISCr_SCR_MODEf_GET
#define TX_X4_MISCr_SCR_MODEf_SET BCMI_TSCE16_XGXS_TX_X4_MISCr_SCR_MODEf_SET
#define TX_X4_MISCr_FEC_ENABLEf_GET BCMI_TSCE16_XGXS_TX_X4_MISCr_FEC_ENABLEf_GET
#define TX_X4_MISCr_FEC_ENABLEf_SET BCMI_TSCE16_XGXS_TX_X4_MISCr_FEC_ENABLEf_SET
#define TX_X4_MISCr_CL49_TX_LI_ENABLEf_GET BCMI_TSCE16_XGXS_TX_X4_MISCr_CL49_TX_LI_ENABLEf_GET
#define TX_X4_MISCr_CL49_TX_LI_ENABLEf_SET BCMI_TSCE16_XGXS_TX_X4_MISCr_CL49_TX_LI_ENABLEf_SET
#define TX_X4_MISCr_CL49_TX_LF_ENABLEf_GET BCMI_TSCE16_XGXS_TX_X4_MISCr_CL49_TX_LF_ENABLEf_GET
#define TX_X4_MISCr_CL49_TX_LF_ENABLEf_SET BCMI_TSCE16_XGXS_TX_X4_MISCr_CL49_TX_LF_ENABLEf_SET
#define TX_X4_MISCr_CL49_TX_RF_ENABLEf_GET BCMI_TSCE16_XGXS_TX_X4_MISCr_CL49_TX_RF_ENABLEf_GET
#define TX_X4_MISCr_CL49_TX_RF_ENABLEf_SET BCMI_TSCE16_XGXS_TX_X4_MISCr_CL49_TX_RF_ENABLEf_SET
#define TX_X4_MISCr_TX_FIFO_WATERMARKf_GET BCMI_TSCE16_XGXS_TX_X4_MISCr_TX_FIFO_WATERMARKf_GET
#define TX_X4_MISCr_TX_FIFO_WATERMARKf_SET BCMI_TSCE16_XGXS_TX_X4_MISCr_TX_FIFO_WATERMARKf_SET
#define TX_X4_MISCr_RSTB_TX_LANEf_GET BCMI_TSCE16_XGXS_TX_X4_MISCr_RSTB_TX_LANEf_GET
#define TX_X4_MISCr_RSTB_TX_LANEf_SET BCMI_TSCE16_XGXS_TX_X4_MISCr_RSTB_TX_LANEf_SET
#define TX_X4_MISCr_ENABLE_TX_LANEf_GET BCMI_TSCE16_XGXS_TX_X4_MISCr_ENABLE_TX_LANEf_GET
#define TX_X4_MISCr_ENABLE_TX_LANEf_SET BCMI_TSCE16_XGXS_TX_X4_MISCr_ENABLE_TX_LANEf_SET
#define READ_TX_X4_MISCr BCMI_TSCE16_XGXS_READ_TX_X4_MISCr
#define WRITE_TX_X4_MISCr BCMI_TSCE16_XGXS_WRITE_TX_X4_MISCr
#define MODIFY_TX_X4_MISCr BCMI_TSCE16_XGXS_MODIFY_TX_X4_MISCr
#define READLN_TX_X4_MISCr BCMI_TSCE16_XGXS_READLN_TX_X4_MISCr
#define WRITELN_TX_X4_MISCr BCMI_TSCE16_XGXS_WRITELN_TX_X4_MISCr
#define WRITEALL_TX_X4_MISCr BCMI_TSCE16_XGXS_WRITEALL_TX_X4_MISCr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_X4_MISCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_X4_PER_PHY_LN_CRED_CTL
 * BLOCKS:   TX_X4_CONTROL0
 * REGADDR:  0xc114
 * DESC:     phy per lane credit enable register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CREDIT_FROM_PER_PHY_LN_EN Enabling credit generation from each lane (tclk20 domain)
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_X4_PER_PHY_LN_CRED_CTLr (0x0000c114 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_X4_PER_PHY_LN_CRED_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_PER_PHY_LN_CRED_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_X4_PER_PHY_LN_CRED_CTLr_s {
	uint32_t v[1];
	uint32_t tx_x4_per_phy_ln_cred_ctl[1];
	uint32_t _tx_x4_per_phy_ln_cred_ctl;
} BCMI_TSCE16_XGXS_TX_X4_PER_PHY_LN_CRED_CTLr_t;

#define BCMI_TSCE16_XGXS_TX_X4_PER_PHY_LN_CRED_CTLr_CLR(r) (r).tx_x4_per_phy_ln_cred_ctl[0] = 0
#define BCMI_TSCE16_XGXS_TX_X4_PER_PHY_LN_CRED_CTLr_SET(r,d) (r).tx_x4_per_phy_ln_cred_ctl[0] = d
#define BCMI_TSCE16_XGXS_TX_X4_PER_PHY_LN_CRED_CTLr_GET(r) (r).tx_x4_per_phy_ln_cred_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_X4_PER_PHY_LN_CRED_CTLr_CREDIT_FROM_PER_PHY_LN_ENf_GET(r) (((r).tx_x4_per_phy_ln_cred_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X4_PER_PHY_LN_CRED_CTLr_CREDIT_FROM_PER_PHY_LN_ENf_SET(r,f) (r).tx_x4_per_phy_ln_cred_ctl[0]=(((r).tx_x4_per_phy_ln_cred_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_X4_PER_PHY_LN_CRED_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_X4_PER_PHY_LN_CRED_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_X4_PER_PHY_LN_CRED_CTLr,(_r._tx_x4_per_phy_ln_cred_ctl))
#define BCMI_TSCE16_XGXS_WRITE_TX_X4_PER_PHY_LN_CRED_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_PER_PHY_LN_CRED_CTLr,(_r._tx_x4_per_phy_ln_cred_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_X4_PER_PHY_LN_CRED_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_PER_PHY_LN_CRED_CTLr,(_r._tx_x4_per_phy_ln_cred_ctl))
#define BCMI_TSCE16_XGXS_READLN_TX_X4_PER_PHY_LN_CRED_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_X4_PER_PHY_LN_CRED_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_per_phy_ln_cred_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_TX_X4_PER_PHY_LN_CRED_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_PER_PHY_LN_CRED_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_per_phy_ln_cred_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_X4_PER_PHY_LN_CRED_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_PER_PHY_LN_CRED_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_per_phy_ln_cred_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_PER_PHY_LN_CRED_CTLr BCMI_TSCE16_XGXS_TX_X4_PER_PHY_LN_CRED_CTLr
#define TX_X4_PER_PHY_LN_CRED_CTLr_SIZE BCMI_TSCE16_XGXS_TX_X4_PER_PHY_LN_CRED_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_TX_X4_PER_PHY_LN_CRED_CTLr_t TX_X4_PER_PHY_LN_CRED_CTLr_t;
#define TX_X4_PER_PHY_LN_CRED_CTLr_CLR BCMI_TSCE16_XGXS_TX_X4_PER_PHY_LN_CRED_CTLr_CLR
#define TX_X4_PER_PHY_LN_CRED_CTLr_SET BCMI_TSCE16_XGXS_TX_X4_PER_PHY_LN_CRED_CTLr_SET
#define TX_X4_PER_PHY_LN_CRED_CTLr_GET BCMI_TSCE16_XGXS_TX_X4_PER_PHY_LN_CRED_CTLr_GET
#define TX_X4_PER_PHY_LN_CRED_CTLr_CREDIT_FROM_PER_PHY_LN_ENf_GET BCMI_TSCE16_XGXS_TX_X4_PER_PHY_LN_CRED_CTLr_CREDIT_FROM_PER_PHY_LN_ENf_GET
#define TX_X4_PER_PHY_LN_CRED_CTLr_CREDIT_FROM_PER_PHY_LN_ENf_SET BCMI_TSCE16_XGXS_TX_X4_PER_PHY_LN_CRED_CTLr_CREDIT_FROM_PER_PHY_LN_ENf_SET
#define READ_TX_X4_PER_PHY_LN_CRED_CTLr BCMI_TSCE16_XGXS_READ_TX_X4_PER_PHY_LN_CRED_CTLr
#define WRITE_TX_X4_PER_PHY_LN_CRED_CTLr BCMI_TSCE16_XGXS_WRITE_TX_X4_PER_PHY_LN_CRED_CTLr
#define MODIFY_TX_X4_PER_PHY_LN_CRED_CTLr BCMI_TSCE16_XGXS_MODIFY_TX_X4_PER_PHY_LN_CRED_CTLr
#define READLN_TX_X4_PER_PHY_LN_CRED_CTLr BCMI_TSCE16_XGXS_READLN_TX_X4_PER_PHY_LN_CRED_CTLr
#define WRITELN_TX_X4_PER_PHY_LN_CRED_CTLr BCMI_TSCE16_XGXS_WRITELN_TX_X4_PER_PHY_LN_CRED_CTLr
#define WRITEALL_TX_X4_PER_PHY_LN_CRED_CTLr BCMI_TSCE16_XGXS_WRITEALL_TX_X4_PER_PHY_LN_CRED_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_X4_PER_PHY_LN_CRED_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_X4_ENC_STS0
 * BLOCKS:   TX_X4_STATUS0
 * REGADDR:  0xc120
 * DESC:     Encode Status 0 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL49_TXSM_STATE  Transmit SM - current stateBits 2 1 0111 - RX_HIG_END110 - RX_HIG_START101 - TX_LI100 - TX_E011 - TX_T010 - TX_D001 - TX_C000 - TX_INIT
 *     CL49_LTXSM_STATE Transmit SM - latched states - latched on entrybit 10 - TX_HIG_ENDbit 9 - TX_HIG_STARTbit 8 - TX_LIbit 7 - TX_Ebit 6 - TX_Tbit 5 - TX_Dbit 4 - TX_Cbit 3 - TX_INIT
 *     CL49_TX_FAULT_DET A live status bit indicating that the cl49 encoder has just encountered a local or remote fault block.
 *     CL49_T_TYPE_CODED Transmit SM - current t_typeBits 15:124'hF - BAD T_TYPE4'hB - T_TYPE_B04'hA - T_TYPE_OB4'h9 - T_TYPE_B14'h8 - T_TYPE_DB4'h7 - T_TYPE_FC4'h6 - T_TYPE_TB4'h5 - T_TYPE_LI4'h4 - T_TYPE_C4'h3 - T_TYPE_S4'h2 - T_TYPE_T4'h1 - T_TYPE_D4'h0 - T_TYPE_E
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r (0x0000c120 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_ENC_STS0.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r_s {
	uint32_t v[1];
	uint32_t tx_x4_enc_sts0[1];
	uint32_t _tx_x4_enc_sts0;
} BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r_t;

#define BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r_CLR(r) (r).tx_x4_enc_sts0[0] = 0
#define BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r_SET(r,d) (r).tx_x4_enc_sts0[0] = d
#define BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r_GET(r) (r).tx_x4_enc_sts0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r_CL49_T_TYPE_CODEDf_GET(r) ((((r).tx_x4_enc_sts0[0]) >> 12) & 0xf)
#define BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r_CL49_T_TYPE_CODEDf_SET(r,f) (r).tx_x4_enc_sts0[0]=(((r).tx_x4_enc_sts0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r_CL49_TX_FAULT_DETf_GET(r) ((((r).tx_x4_enc_sts0[0]) >> 11) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r_CL49_TX_FAULT_DETf_SET(r,f) (r).tx_x4_enc_sts0[0]=(((r).tx_x4_enc_sts0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r_CL49_LTXSM_STATEf_GET(r) ((((r).tx_x4_enc_sts0[0]) >> 3) & 0xff)
#define BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r_CL49_LTXSM_STATEf_SET(r,f) (r).tx_x4_enc_sts0[0]=(((r).tx_x4_enc_sts0[0] & ~((uint32_t)0xff << 3)) | ((((uint32_t)f) & 0xff) << 3)) | (255 << (16 + 3))
#define BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r_CL49_TXSM_STATEf_GET(r) (((r).tx_x4_enc_sts0[0]) & 0x7)
#define BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r_CL49_TXSM_STATEf_SET(r,f) (r).tx_x4_enc_sts0[0]=(((r).tx_x4_enc_sts0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access TX_X4_ENC_STS0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_X4_ENC_STS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r,(_r._tx_x4_enc_sts0))
#define BCMI_TSCE16_XGXS_WRITE_TX_X4_ENC_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r,(_r._tx_x4_enc_sts0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_X4_ENC_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r,(_r._tx_x4_enc_sts0))
#define BCMI_TSCE16_XGXS_READLN_TX_X4_ENC_STS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_enc_sts0))
#define BCMI_TSCE16_XGXS_WRITELN_TX_X4_ENC_STS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_enc_sts0))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_X4_ENC_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_enc_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_ENC_STS0r BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r
#define TX_X4_ENC_STS0r_SIZE BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r_SIZE
typedef BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r_t TX_X4_ENC_STS0r_t;
#define TX_X4_ENC_STS0r_CLR BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r_CLR
#define TX_X4_ENC_STS0r_SET BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r_SET
#define TX_X4_ENC_STS0r_GET BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r_GET
#define TX_X4_ENC_STS0r_CL49_T_TYPE_CODEDf_GET BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r_CL49_T_TYPE_CODEDf_GET
#define TX_X4_ENC_STS0r_CL49_T_TYPE_CODEDf_SET BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r_CL49_T_TYPE_CODEDf_SET
#define TX_X4_ENC_STS0r_CL49_TX_FAULT_DETf_GET BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r_CL49_TX_FAULT_DETf_GET
#define TX_X4_ENC_STS0r_CL49_TX_FAULT_DETf_SET BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r_CL49_TX_FAULT_DETf_SET
#define TX_X4_ENC_STS0r_CL49_LTXSM_STATEf_GET BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r_CL49_LTXSM_STATEf_GET
#define TX_X4_ENC_STS0r_CL49_LTXSM_STATEf_SET BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r_CL49_LTXSM_STATEf_SET
#define TX_X4_ENC_STS0r_CL49_TXSM_STATEf_GET BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r_CL49_TXSM_STATEf_GET
#define TX_X4_ENC_STS0r_CL49_TXSM_STATEf_SET BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r_CL49_TXSM_STATEf_SET
#define READ_TX_X4_ENC_STS0r BCMI_TSCE16_XGXS_READ_TX_X4_ENC_STS0r
#define WRITE_TX_X4_ENC_STS0r BCMI_TSCE16_XGXS_WRITE_TX_X4_ENC_STS0r
#define MODIFY_TX_X4_ENC_STS0r BCMI_TSCE16_XGXS_MODIFY_TX_X4_ENC_STS0r
#define READLN_TX_X4_ENC_STS0r BCMI_TSCE16_XGXS_READLN_TX_X4_ENC_STS0r
#define WRITELN_TX_X4_ENC_STS0r BCMI_TSCE16_XGXS_WRITELN_TX_X4_ENC_STS0r
#define WRITEALL_TX_X4_ENC_STS0r BCMI_TSCE16_XGXS_WRITEALL_TX_X4_ENC_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_X4_ENC_STS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_X4_PCS_STS
 * BLOCKS:   TX_X4_STATUS0
 * REGADDR:  0xc121
 * DESC:     Status of PCS Information
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LPI_RECEIVED_LH  PER PORT: Low Power Indicator (LPI) has transitioned high since last read.Clear on read
 *     RESERVED_ORDERED_SET_LH PER PORT: Reserved Ordered Set indicator has transitioned high since last readReserved Ordered Set is defined as a Sequence Ordered Set that is not LF and is not RFClear on read
 *     REMOTE_FAULT_LH  PER PORT: Remote Fault (RF)  has transitioned high since last read.Clear on read
 *     LOCAL_FAULT_LH   PER PORT: Local Fault (LF) indicator has transitioned high since last read.Clear on read
 *     LINK_INTERRUPT_LH PER PORT: LI (LINK INTERRUPT) indicator has transitioned high since last read.Clear on read
 *     TX_LPI_RECEIVED  PER PORT: Live LPI (LOW POWER IDLE ) indicator
 *     TX_LINK_INTERRUPT PER PORT: Live LI (LINK INTERRUPT) indicator
 *     TX_REMOTE_FAULT  PER PORT: Live RF (REMOTE FAULT ) indicator
 *     TX_LOCAL_FAULT   PER PORT: Live LF (LOCAL FAULT ) indicator
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_X4_PCS_STSr (0x0000c121 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_PCS_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_s {
	uint32_t v[1];
	uint32_t tx_x4_pcs_sts[1];
	uint32_t _tx_x4_pcs_sts;
} BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_t;

#define BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_CLR(r) (r).tx_x4_pcs_sts[0] = 0
#define BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_SET(r,d) (r).tx_x4_pcs_sts[0] = d
#define BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_GET(r) (r).tx_x4_pcs_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_TX_LOCAL_FAULTf_GET(r) ((((r).tx_x4_pcs_sts[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_TX_LOCAL_FAULTf_SET(r,f) (r).tx_x4_pcs_sts[0]=(((r).tx_x4_pcs_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_TX_REMOTE_FAULTf_GET(r) ((((r).tx_x4_pcs_sts[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_TX_REMOTE_FAULTf_SET(r,f) (r).tx_x4_pcs_sts[0]=(((r).tx_x4_pcs_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_TX_LINK_INTERRUPTf_GET(r) ((((r).tx_x4_pcs_sts[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_TX_LINK_INTERRUPTf_SET(r,f) (r).tx_x4_pcs_sts[0]=(((r).tx_x4_pcs_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_TX_LPI_RECEIVEDf_GET(r) ((((r).tx_x4_pcs_sts[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_TX_LPI_RECEIVEDf_SET(r,f) (r).tx_x4_pcs_sts[0]=(((r).tx_x4_pcs_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_LINK_INTERRUPT_LHf_GET(r) ((((r).tx_x4_pcs_sts[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_LINK_INTERRUPT_LHf_SET(r,f) (r).tx_x4_pcs_sts[0]=(((r).tx_x4_pcs_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_LOCAL_FAULT_LHf_GET(r) ((((r).tx_x4_pcs_sts[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_LOCAL_FAULT_LHf_SET(r,f) (r).tx_x4_pcs_sts[0]=(((r).tx_x4_pcs_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_REMOTE_FAULT_LHf_GET(r) ((((r).tx_x4_pcs_sts[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_REMOTE_FAULT_LHf_SET(r,f) (r).tx_x4_pcs_sts[0]=(((r).tx_x4_pcs_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_RESERVED_ORDERED_SET_LHf_GET(r) ((((r).tx_x4_pcs_sts[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_RESERVED_ORDERED_SET_LHf_SET(r,f) (r).tx_x4_pcs_sts[0]=(((r).tx_x4_pcs_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_LPI_RECEIVED_LHf_GET(r) (((r).tx_x4_pcs_sts[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_LPI_RECEIVED_LHf_SET(r,f) (r).tx_x4_pcs_sts[0]=(((r).tx_x4_pcs_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_X4_PCS_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_X4_PCS_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_X4_PCS_STSr,(_r._tx_x4_pcs_sts))
#define BCMI_TSCE16_XGXS_WRITE_TX_X4_PCS_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_PCS_STSr,(_r._tx_x4_pcs_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_X4_PCS_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_PCS_STSr,(_r._tx_x4_pcs_sts))
#define BCMI_TSCE16_XGXS_READLN_TX_X4_PCS_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_X4_PCS_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_pcs_sts))
#define BCMI_TSCE16_XGXS_WRITELN_TX_X4_PCS_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_PCS_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_pcs_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_X4_PCS_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_X4_PCS_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_pcs_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_PCS_STSr BCMI_TSCE16_XGXS_TX_X4_PCS_STSr
#define TX_X4_PCS_STSr_SIZE BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_SIZE
typedef BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_t TX_X4_PCS_STSr_t;
#define TX_X4_PCS_STSr_CLR BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_CLR
#define TX_X4_PCS_STSr_SET BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_SET
#define TX_X4_PCS_STSr_GET BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_GET
#define TX_X4_PCS_STSr_TX_LOCAL_FAULTf_GET BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_TX_LOCAL_FAULTf_GET
#define TX_X4_PCS_STSr_TX_LOCAL_FAULTf_SET BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_TX_LOCAL_FAULTf_SET
#define TX_X4_PCS_STSr_TX_REMOTE_FAULTf_GET BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_TX_REMOTE_FAULTf_GET
#define TX_X4_PCS_STSr_TX_REMOTE_FAULTf_SET BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_TX_REMOTE_FAULTf_SET
#define TX_X4_PCS_STSr_TX_LINK_INTERRUPTf_GET BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_TX_LINK_INTERRUPTf_GET
#define TX_X4_PCS_STSr_TX_LINK_INTERRUPTf_SET BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_TX_LINK_INTERRUPTf_SET
#define TX_X4_PCS_STSr_TX_LPI_RECEIVEDf_GET BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_TX_LPI_RECEIVEDf_GET
#define TX_X4_PCS_STSr_TX_LPI_RECEIVEDf_SET BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_TX_LPI_RECEIVEDf_SET
#define TX_X4_PCS_STSr_LINK_INTERRUPT_LHf_GET BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_LINK_INTERRUPT_LHf_GET
#define TX_X4_PCS_STSr_LINK_INTERRUPT_LHf_SET BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_LINK_INTERRUPT_LHf_SET
#define TX_X4_PCS_STSr_LOCAL_FAULT_LHf_GET BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_LOCAL_FAULT_LHf_GET
#define TX_X4_PCS_STSr_LOCAL_FAULT_LHf_SET BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_LOCAL_FAULT_LHf_SET
#define TX_X4_PCS_STSr_REMOTE_FAULT_LHf_GET BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_REMOTE_FAULT_LHf_GET
#define TX_X4_PCS_STSr_REMOTE_FAULT_LHf_SET BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_REMOTE_FAULT_LHf_SET
#define TX_X4_PCS_STSr_RESERVED_ORDERED_SET_LHf_GET BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_RESERVED_ORDERED_SET_LHf_GET
#define TX_X4_PCS_STSr_RESERVED_ORDERED_SET_LHf_SET BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_RESERVED_ORDERED_SET_LHf_SET
#define TX_X4_PCS_STSr_LPI_RECEIVED_LHf_GET BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_LPI_RECEIVED_LHf_GET
#define TX_X4_PCS_STSr_LPI_RECEIVED_LHf_SET BCMI_TSCE16_XGXS_TX_X4_PCS_STSr_LPI_RECEIVED_LHf_SET
#define READ_TX_X4_PCS_STSr BCMI_TSCE16_XGXS_READ_TX_X4_PCS_STSr
#define WRITE_TX_X4_PCS_STSr BCMI_TSCE16_XGXS_WRITE_TX_X4_PCS_STSr
#define MODIFY_TX_X4_PCS_STSr BCMI_TSCE16_XGXS_MODIFY_TX_X4_PCS_STSr
#define READLN_TX_X4_PCS_STSr BCMI_TSCE16_XGXS_READLN_TX_X4_PCS_STSr
#define WRITELN_TX_X4_PCS_STSr BCMI_TSCE16_XGXS_WRITELN_TX_X4_PCS_STSr
#define WRITEALL_TX_X4_PCS_STSr BCMI_TSCE16_XGXS_WRITEALL_TX_X4_PCS_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_X4_PCS_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_PCS_CTL0
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc130
 * DESC:     pcs control 0 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BRCM64B66_DESCRAMBLER_ENABLE If asserted, the data sent to the the brcm64b66 decoder is scrambledSync headers are not scrambled
 *     LPI_ENABLE       If off (0), LPIs are converted to IDLEsNOTE: LPI_ENABLE APPLIES TO BOTH TX AND RX pipelines
 *     CL36BYTEDELETEMODE 2'b00 - 100M mode (Delete 9 out of every 10 bytes)2'b01 - 10M mode (Delete 99 out of every 100 bytes)2'b10 - Passthrough (No deletion)
 *     DESC2_MODE       r_desc2 mode# {000:NONE}, {001:CL49}, {010:BRCM}, {011:}, {100:CL48}, {101:CL36}, {110:CL82}, {111:NONE}
 *     DESKEWMODE       3'b000 - None3'b001 - byte based deskew for 8b10b mode3'b010 - block based deskew for BRCM 64b66b mode3'b011 - block based deskew for IEEE CL82 mode3'b100 - cl36 mode enable
 *     DECODERMODE      r_dec1 mode3'b000 - None3'b001 - cl49 64b66b mode3'b010 - BRCM 64b66b mode3'b011 -  - cl49/BRCM 64b66b mode3'b100 - 8b10b mode - cl48 mode3'b101 - 8b10b mode - cl36 mode
 *     DESCRAMBLERMODE  r_descr1 mode00 bypass descrambler01 64b66b descrambler10 8b10b descrambler11 reserved
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r (0x0000c130 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_PCS_CTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_s {
	uint32_t v[1];
	uint32_t rx_x4_pcs_ctl0[1];
	uint32_t _rx_x4_pcs_ctl0;
} BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_t;

#define BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_CLR(r) (r).rx_x4_pcs_ctl0[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_SET(r,d) (r).rx_x4_pcs_ctl0[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_GET(r) (r).rx_x4_pcs_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_DESCRAMBLERMODEf_GET(r) ((((r).rx_x4_pcs_ctl0[0]) >> 14) & 0x3)
#define BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_DESCRAMBLERMODEf_SET(r,f) (r).rx_x4_pcs_ctl0[0]=(((r).rx_x4_pcs_ctl0[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_DECODERMODEf_GET(r) ((((r).rx_x4_pcs_ctl0[0]) >> 11) & 0x7)
#define BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_DECODERMODEf_SET(r,f) (r).rx_x4_pcs_ctl0[0]=(((r).rx_x4_pcs_ctl0[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_DESKEWMODEf_GET(r) ((((r).rx_x4_pcs_ctl0[0]) >> 8) & 0x7)
#define BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_DESKEWMODEf_SET(r,f) (r).rx_x4_pcs_ctl0[0]=(((r).rx_x4_pcs_ctl0[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_DESC2_MODEf_GET(r) ((((r).rx_x4_pcs_ctl0[0]) >> 5) & 0x7)
#define BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_DESC2_MODEf_SET(r,f) (r).rx_x4_pcs_ctl0[0]=(((r).rx_x4_pcs_ctl0[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5)) | (7 << (16 + 5))
#define BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_CL36BYTEDELETEMODEf_GET(r) ((((r).rx_x4_pcs_ctl0[0]) >> 3) & 0x3)
#define BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_CL36BYTEDELETEMODEf_SET(r,f) (r).rx_x4_pcs_ctl0[0]=(((r).rx_x4_pcs_ctl0[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3)) | (3 << (16 + 3))
#define BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_LPI_ENABLEf_GET(r) ((((r).rx_x4_pcs_ctl0[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_LPI_ENABLEf_SET(r,f) (r).rx_x4_pcs_ctl0[0]=(((r).rx_x4_pcs_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_BRCM64B66_DESCRAMBLER_ENABLEf_GET(r) ((((r).rx_x4_pcs_ctl0[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_BRCM64B66_DESCRAMBLER_ENABLEf_SET(r,f) (r).rx_x4_pcs_ctl0[0]=(((r).rx_x4_pcs_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access RX_X4_PCS_CTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_PCS_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r,(_r._rx_x4_pcs_ctl0))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_PCS_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r,(_r._rx_x4_pcs_ctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_PCS_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r,(_r._rx_x4_pcs_ctl0))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_PCS_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_pcs_ctl0))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_PCS_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_pcs_ctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_PCS_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_pcs_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_PCS_CTL0r BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r
#define RX_X4_PCS_CTL0r_SIZE BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_t RX_X4_PCS_CTL0r_t;
#define RX_X4_PCS_CTL0r_CLR BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_CLR
#define RX_X4_PCS_CTL0r_SET BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_SET
#define RX_X4_PCS_CTL0r_GET BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_GET
#define RX_X4_PCS_CTL0r_DESCRAMBLERMODEf_GET BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_DESCRAMBLERMODEf_GET
#define RX_X4_PCS_CTL0r_DESCRAMBLERMODEf_SET BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_DESCRAMBLERMODEf_SET
#define RX_X4_PCS_CTL0r_DECODERMODEf_GET BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_DECODERMODEf_GET
#define RX_X4_PCS_CTL0r_DECODERMODEf_SET BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_DECODERMODEf_SET
#define RX_X4_PCS_CTL0r_DESKEWMODEf_GET BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_DESKEWMODEf_GET
#define RX_X4_PCS_CTL0r_DESKEWMODEf_SET BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_DESKEWMODEf_SET
#define RX_X4_PCS_CTL0r_DESC2_MODEf_GET BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_DESC2_MODEf_GET
#define RX_X4_PCS_CTL0r_DESC2_MODEf_SET BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_DESC2_MODEf_SET
#define RX_X4_PCS_CTL0r_CL36BYTEDELETEMODEf_GET BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_CL36BYTEDELETEMODEf_GET
#define RX_X4_PCS_CTL0r_CL36BYTEDELETEMODEf_SET BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_CL36BYTEDELETEMODEf_SET
#define RX_X4_PCS_CTL0r_LPI_ENABLEf_GET BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_LPI_ENABLEf_GET
#define RX_X4_PCS_CTL0r_LPI_ENABLEf_SET BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_LPI_ENABLEf_SET
#define RX_X4_PCS_CTL0r_BRCM64B66_DESCRAMBLER_ENABLEf_GET BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_BRCM64B66_DESCRAMBLER_ENABLEf_GET
#define RX_X4_PCS_CTL0r_BRCM64B66_DESCRAMBLER_ENABLEf_SET BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r_BRCM64B66_DESCRAMBLER_ENABLEf_SET
#define READ_RX_X4_PCS_CTL0r BCMI_TSCE16_XGXS_READ_RX_X4_PCS_CTL0r
#define WRITE_RX_X4_PCS_CTL0r BCMI_TSCE16_XGXS_WRITE_RX_X4_PCS_CTL0r
#define MODIFY_RX_X4_PCS_CTL0r BCMI_TSCE16_XGXS_MODIFY_RX_X4_PCS_CTL0r
#define READLN_RX_X4_PCS_CTL0r BCMI_TSCE16_XGXS_READLN_RX_X4_PCS_CTL0r
#define WRITELN_RX_X4_PCS_CTL0r BCMI_TSCE16_XGXS_WRITELN_RX_X4_PCS_CTL0r
#define WRITEALL_RX_X4_PCS_CTL0r BCMI_TSCE16_XGXS_WRITEALL_RX_X4_PCS_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_PCS_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_FEC0
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc131
 * DESC:     User FEC Control 0 register
 * RESETVAL: 0x2000 (8192)
 * ACCESS:   R/W
 * FIELDS:
 *     FAST_LOCK_EN     
 *     DBG_ENABLE       FEC debug enable
 *     ERROR_EN_OVR_VAL FEC error enable override control value
 *     ERROR_EN_OVR     FEC error enable override control
 *     FEC_ERR_ENABLE   
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_FEC0r (0x0000c131 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_FEC0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC0.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_FEC0r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec0[1];
	uint32_t _rx_x4_fec0;
} BCMI_TSCE16_XGXS_RX_X4_FEC0r_t;

#define BCMI_TSCE16_XGXS_RX_X4_FEC0r_CLR(r) (r).rx_x4_fec0[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_FEC0r_SET(r,d) (r).rx_x4_fec0[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_FEC0r_GET(r) (r).rx_x4_fec0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_FEC0r_FEC_ERR_ENABLEf_GET(r) ((((r).rx_x4_fec0[0]) >> 13) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_FEC0r_FEC_ERR_ENABLEf_SET(r,f) (r).rx_x4_fec0[0]=(((r).rx_x4_fec0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCE16_XGXS_RX_X4_FEC0r_ERROR_EN_OVRf_GET(r) ((((r).rx_x4_fec0[0]) >> 12) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_FEC0r_ERROR_EN_OVRf_SET(r,f) (r).rx_x4_fec0[0]=(((r).rx_x4_fec0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCE16_XGXS_RX_X4_FEC0r_ERROR_EN_OVR_VALf_GET(r) ((((r).rx_x4_fec0[0]) >> 11) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_FEC0r_ERROR_EN_OVR_VALf_SET(r,f) (r).rx_x4_fec0[0]=(((r).rx_x4_fec0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCE16_XGXS_RX_X4_FEC0r_DBG_ENABLEf_GET(r) ((((r).rx_x4_fec0[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_FEC0r_DBG_ENABLEf_SET(r,f) (r).rx_x4_fec0[0]=(((r).rx_x4_fec0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_RX_X4_FEC0r_FAST_LOCK_ENf_GET(r) ((((r).rx_x4_fec0[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_FEC0r_FAST_LOCK_ENf_SET(r,f) (r).rx_x4_fec0[0]=(((r).rx_x4_fec0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))

/*
 * These macros can be used to access RX_X4_FEC0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_FEC0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC0r,(_r._rx_x4_fec0))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_FEC0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC0r,(_r._rx_x4_fec0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_FEC0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC0r,(_r._rx_x4_fec0))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_FEC0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec0))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_FEC0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec0))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_FEC0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC0r BCMI_TSCE16_XGXS_RX_X4_FEC0r
#define RX_X4_FEC0r_SIZE BCMI_TSCE16_XGXS_RX_X4_FEC0r_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_FEC0r_t RX_X4_FEC0r_t;
#define RX_X4_FEC0r_CLR BCMI_TSCE16_XGXS_RX_X4_FEC0r_CLR
#define RX_X4_FEC0r_SET BCMI_TSCE16_XGXS_RX_X4_FEC0r_SET
#define RX_X4_FEC0r_GET BCMI_TSCE16_XGXS_RX_X4_FEC0r_GET
#define RX_X4_FEC0r_FEC_ERR_ENABLEf_GET BCMI_TSCE16_XGXS_RX_X4_FEC0r_FEC_ERR_ENABLEf_GET
#define RX_X4_FEC0r_FEC_ERR_ENABLEf_SET BCMI_TSCE16_XGXS_RX_X4_FEC0r_FEC_ERR_ENABLEf_SET
#define RX_X4_FEC0r_ERROR_EN_OVRf_GET BCMI_TSCE16_XGXS_RX_X4_FEC0r_ERROR_EN_OVRf_GET
#define RX_X4_FEC0r_ERROR_EN_OVRf_SET BCMI_TSCE16_XGXS_RX_X4_FEC0r_ERROR_EN_OVRf_SET
#define RX_X4_FEC0r_ERROR_EN_OVR_VALf_GET BCMI_TSCE16_XGXS_RX_X4_FEC0r_ERROR_EN_OVR_VALf_GET
#define RX_X4_FEC0r_ERROR_EN_OVR_VALf_SET BCMI_TSCE16_XGXS_RX_X4_FEC0r_ERROR_EN_OVR_VALf_SET
#define RX_X4_FEC0r_DBG_ENABLEf_GET BCMI_TSCE16_XGXS_RX_X4_FEC0r_DBG_ENABLEf_GET
#define RX_X4_FEC0r_DBG_ENABLEf_SET BCMI_TSCE16_XGXS_RX_X4_FEC0r_DBG_ENABLEf_SET
#define RX_X4_FEC0r_FAST_LOCK_ENf_GET BCMI_TSCE16_XGXS_RX_X4_FEC0r_FAST_LOCK_ENf_GET
#define RX_X4_FEC0r_FAST_LOCK_ENf_SET BCMI_TSCE16_XGXS_RX_X4_FEC0r_FAST_LOCK_ENf_SET
#define READ_RX_X4_FEC0r BCMI_TSCE16_XGXS_READ_RX_X4_FEC0r
#define WRITE_RX_X4_FEC0r BCMI_TSCE16_XGXS_WRITE_RX_X4_FEC0r
#define MODIFY_RX_X4_FEC0r BCMI_TSCE16_XGXS_MODIFY_RX_X4_FEC0r
#define READLN_RX_X4_FEC0r BCMI_TSCE16_XGXS_READLN_RX_X4_FEC0r
#define WRITELN_RX_X4_FEC0r BCMI_TSCE16_XGXS_WRITELN_RX_X4_FEC0r
#define WRITEALL_RX_X4_FEC0r BCMI_TSCE16_XGXS_WRITEALL_RX_X4_FEC0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_FEC0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_FEC1
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc132
 * DESC:     User FEC Control 1 register
 * RESETVAL: 0x442c (17452)
 * ACCESS:   R/W
 * FIELDS:
 *     DBG_ERR_MODE     debug readout only for uncorrectable errors
 *     BURST_ERR_STATUS_MODE collect error info only for uncorrectable errors0 - update on correctable and uncorrectable events1 - update on uncorrectable events only
 *     DEC_MAX_PM       maximum correctable burst pattern size
 *     INVALID_PARITY_CNT number of bad locks before unlocking
 *     GOOD_PARITY_CNT  number of good blocks before locking
 *     FEC_ERROR_CODE_ALL report errors thru all sync headers
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_FEC1r (0x0000c132 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_FEC1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC1.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_FEC1r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec1[1];
	uint32_t _rx_x4_fec1;
} BCMI_TSCE16_XGXS_RX_X4_FEC1r_t;

#define BCMI_TSCE16_XGXS_RX_X4_FEC1r_CLR(r) (r).rx_x4_fec1[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_FEC1r_SET(r,d) (r).rx_x4_fec1[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_FEC1r_GET(r) (r).rx_x4_fec1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_FEC1r_FEC_ERROR_CODE_ALLf_GET(r) ((((r).rx_x4_fec1[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_FEC1r_FEC_ERROR_CODE_ALLf_SET(r,f) (r).rx_x4_fec1[0]=(((r).rx_x4_fec1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_RX_X4_FEC1r_GOOD_PARITY_CNTf_GET(r) ((((r).rx_x4_fec1[0]) >> 12) & 0x7)
#define BCMI_TSCE16_XGXS_RX_X4_FEC1r_GOOD_PARITY_CNTf_SET(r,f) (r).rx_x4_fec1[0]=(((r).rx_x4_fec1[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12)) | (7 << (16 + 12))
#define BCMI_TSCE16_XGXS_RX_X4_FEC1r_INVALID_PARITY_CNTf_GET(r) ((((r).rx_x4_fec1[0]) >> 8) & 0xf)
#define BCMI_TSCE16_XGXS_RX_X4_FEC1r_INVALID_PARITY_CNTf_SET(r,f) (r).rx_x4_fec1[0]=(((r).rx_x4_fec1[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_TSCE16_XGXS_RX_X4_FEC1r_DEC_MAX_PMf_GET(r) ((((r).rx_x4_fec1[0]) >> 2) & 0x3f)
#define BCMI_TSCE16_XGXS_RX_X4_FEC1r_DEC_MAX_PMf_SET(r,f) (r).rx_x4_fec1[0]=(((r).rx_x4_fec1[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2)) | (63 << (16 + 2))
#define BCMI_TSCE16_XGXS_RX_X4_FEC1r_BURST_ERR_STATUS_MODEf_GET(r) ((((r).rx_x4_fec1[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_FEC1r_BURST_ERR_STATUS_MODEf_SET(r,f) (r).rx_x4_fec1[0]=(((r).rx_x4_fec1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_RX_X4_FEC1r_DBG_ERR_MODEf_GET(r) (((r).rx_x4_fec1[0]) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_FEC1r_DBG_ERR_MODEf_SET(r,f) (r).rx_x4_fec1[0]=(((r).rx_x4_fec1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_FEC1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_FEC1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC1r,(_r._rx_x4_fec1))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_FEC1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC1r,(_r._rx_x4_fec1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_FEC1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC1r,(_r._rx_x4_fec1))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_FEC1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec1))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_FEC1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec1))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_FEC1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC1r BCMI_TSCE16_XGXS_RX_X4_FEC1r
#define RX_X4_FEC1r_SIZE BCMI_TSCE16_XGXS_RX_X4_FEC1r_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_FEC1r_t RX_X4_FEC1r_t;
#define RX_X4_FEC1r_CLR BCMI_TSCE16_XGXS_RX_X4_FEC1r_CLR
#define RX_X4_FEC1r_SET BCMI_TSCE16_XGXS_RX_X4_FEC1r_SET
#define RX_X4_FEC1r_GET BCMI_TSCE16_XGXS_RX_X4_FEC1r_GET
#define RX_X4_FEC1r_FEC_ERROR_CODE_ALLf_GET BCMI_TSCE16_XGXS_RX_X4_FEC1r_FEC_ERROR_CODE_ALLf_GET
#define RX_X4_FEC1r_FEC_ERROR_CODE_ALLf_SET BCMI_TSCE16_XGXS_RX_X4_FEC1r_FEC_ERROR_CODE_ALLf_SET
#define RX_X4_FEC1r_GOOD_PARITY_CNTf_GET BCMI_TSCE16_XGXS_RX_X4_FEC1r_GOOD_PARITY_CNTf_GET
#define RX_X4_FEC1r_GOOD_PARITY_CNTf_SET BCMI_TSCE16_XGXS_RX_X4_FEC1r_GOOD_PARITY_CNTf_SET
#define RX_X4_FEC1r_INVALID_PARITY_CNTf_GET BCMI_TSCE16_XGXS_RX_X4_FEC1r_INVALID_PARITY_CNTf_GET
#define RX_X4_FEC1r_INVALID_PARITY_CNTf_SET BCMI_TSCE16_XGXS_RX_X4_FEC1r_INVALID_PARITY_CNTf_SET
#define RX_X4_FEC1r_DEC_MAX_PMf_GET BCMI_TSCE16_XGXS_RX_X4_FEC1r_DEC_MAX_PMf_GET
#define RX_X4_FEC1r_DEC_MAX_PMf_SET BCMI_TSCE16_XGXS_RX_X4_FEC1r_DEC_MAX_PMf_SET
#define RX_X4_FEC1r_BURST_ERR_STATUS_MODEf_GET BCMI_TSCE16_XGXS_RX_X4_FEC1r_BURST_ERR_STATUS_MODEf_GET
#define RX_X4_FEC1r_BURST_ERR_STATUS_MODEf_SET BCMI_TSCE16_XGXS_RX_X4_FEC1r_BURST_ERR_STATUS_MODEf_SET
#define RX_X4_FEC1r_DBG_ERR_MODEf_GET BCMI_TSCE16_XGXS_RX_X4_FEC1r_DBG_ERR_MODEf_GET
#define RX_X4_FEC1r_DBG_ERR_MODEf_SET BCMI_TSCE16_XGXS_RX_X4_FEC1r_DBG_ERR_MODEf_SET
#define READ_RX_X4_FEC1r BCMI_TSCE16_XGXS_READ_RX_X4_FEC1r
#define WRITE_RX_X4_FEC1r BCMI_TSCE16_XGXS_WRITE_RX_X4_FEC1r
#define MODIFY_RX_X4_FEC1r BCMI_TSCE16_XGXS_MODIFY_RX_X4_FEC1r
#define READLN_RX_X4_FEC1r BCMI_TSCE16_XGXS_READLN_RX_X4_FEC1r
#define WRITELN_RX_X4_FEC1r BCMI_TSCE16_XGXS_WRITELN_RX_X4_FEC1r
#define WRITEALL_RX_X4_FEC1r BCMI_TSCE16_XGXS_WRITEALL_RX_X4_FEC1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_FEC1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_FEC2
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc133
 * DESC:     User FEC Control 2 register
 * RESETVAL: 0x28 (40)
 * ACCESS:   R/W
 * FIELDS:
 *     DEC_GAP_COUNT_MODE Gap counting mode0 = Counting zero method1 = Counting gap method
 *     DEC_17B_BURST_GAP_COUNT Gaps allowed in 17-bit bursts000 No gaps001 Single gap010-111 Multi gaps
 *     DEC_18B_BURST_GAP_COUNT Gaps allowed in 18-bit bursts000 No gaps001 Single gap010-111 Multi gaps
 *     DEC_19B_BURST_GAP_COUNT Gaps allowed in 19-bit bursts000 No gaps001 Single gap010-111 Multi gaps
 *     DEC_PM_MODE      Pattern Match ModeBurst error     Mode11 bits         0000016 bits         0000117 bits         0001018 bits         0001119 bits         0010020 bits         0010121 bits         0011022 bits         0011123 bits         0100024 bits         0100125 bits         0101026 bits         0101127 bits         0110028 bits         0110129 bits         0111030 bits         0111131 bits         1000032 bits         1000133 bits         1001034 bits         1001135 bits         1010036 bits         1010137 bits         1011038 bits         1011139 bits         1100040 bits         1100141 bits         11010
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_FEC2r (0x0000c133 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_FEC2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC2.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_FEC2r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec2[1];
	uint32_t _rx_x4_fec2;
} BCMI_TSCE16_XGXS_RX_X4_FEC2r_t;

#define BCMI_TSCE16_XGXS_RX_X4_FEC2r_CLR(r) (r).rx_x4_fec2[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_FEC2r_SET(r,d) (r).rx_x4_fec2[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_FEC2r_GET(r) (r).rx_x4_fec2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_FEC2r_DEC_PM_MODEf_GET(r) ((((r).rx_x4_fec2[0]) >> 11) & 0x1f)
#define BCMI_TSCE16_XGXS_RX_X4_FEC2r_DEC_PM_MODEf_SET(r,f) (r).rx_x4_fec2[0]=(((r).rx_x4_fec2[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_TSCE16_XGXS_RX_X4_FEC2r_DEC_19B_BURST_GAP_COUNTf_GET(r) ((((r).rx_x4_fec2[0]) >> 8) & 0x7)
#define BCMI_TSCE16_XGXS_RX_X4_FEC2r_DEC_19B_BURST_GAP_COUNTf_SET(r,f) (r).rx_x4_fec2[0]=(((r).rx_x4_fec2[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_TSCE16_XGXS_RX_X4_FEC2r_DEC_18B_BURST_GAP_COUNTf_GET(r) ((((r).rx_x4_fec2[0]) >> 5) & 0x7)
#define BCMI_TSCE16_XGXS_RX_X4_FEC2r_DEC_18B_BURST_GAP_COUNTf_SET(r,f) (r).rx_x4_fec2[0]=(((r).rx_x4_fec2[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5)) | (7 << (16 + 5))
#define BCMI_TSCE16_XGXS_RX_X4_FEC2r_DEC_17B_BURST_GAP_COUNTf_GET(r) ((((r).rx_x4_fec2[0]) >> 2) & 0x7)
#define BCMI_TSCE16_XGXS_RX_X4_FEC2r_DEC_17B_BURST_GAP_COUNTf_SET(r,f) (r).rx_x4_fec2[0]=(((r).rx_x4_fec2[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2)) | (7 << (16 + 2))
#define BCMI_TSCE16_XGXS_RX_X4_FEC2r_DEC_GAP_COUNT_MODEf_GET(r) ((((r).rx_x4_fec2[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_FEC2r_DEC_GAP_COUNT_MODEf_SET(r,f) (r).rx_x4_fec2[0]=(((r).rx_x4_fec2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access RX_X4_FEC2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_FEC2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC2r,(_r._rx_x4_fec2))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_FEC2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC2r,(_r._rx_x4_fec2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_FEC2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC2r,(_r._rx_x4_fec2))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_FEC2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec2))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_FEC2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec2))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_FEC2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC2r BCMI_TSCE16_XGXS_RX_X4_FEC2r
#define RX_X4_FEC2r_SIZE BCMI_TSCE16_XGXS_RX_X4_FEC2r_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_FEC2r_t RX_X4_FEC2r_t;
#define RX_X4_FEC2r_CLR BCMI_TSCE16_XGXS_RX_X4_FEC2r_CLR
#define RX_X4_FEC2r_SET BCMI_TSCE16_XGXS_RX_X4_FEC2r_SET
#define RX_X4_FEC2r_GET BCMI_TSCE16_XGXS_RX_X4_FEC2r_GET
#define RX_X4_FEC2r_DEC_PM_MODEf_GET BCMI_TSCE16_XGXS_RX_X4_FEC2r_DEC_PM_MODEf_GET
#define RX_X4_FEC2r_DEC_PM_MODEf_SET BCMI_TSCE16_XGXS_RX_X4_FEC2r_DEC_PM_MODEf_SET
#define RX_X4_FEC2r_DEC_19B_BURST_GAP_COUNTf_GET BCMI_TSCE16_XGXS_RX_X4_FEC2r_DEC_19B_BURST_GAP_COUNTf_GET
#define RX_X4_FEC2r_DEC_19B_BURST_GAP_COUNTf_SET BCMI_TSCE16_XGXS_RX_X4_FEC2r_DEC_19B_BURST_GAP_COUNTf_SET
#define RX_X4_FEC2r_DEC_18B_BURST_GAP_COUNTf_GET BCMI_TSCE16_XGXS_RX_X4_FEC2r_DEC_18B_BURST_GAP_COUNTf_GET
#define RX_X4_FEC2r_DEC_18B_BURST_GAP_COUNTf_SET BCMI_TSCE16_XGXS_RX_X4_FEC2r_DEC_18B_BURST_GAP_COUNTf_SET
#define RX_X4_FEC2r_DEC_17B_BURST_GAP_COUNTf_GET BCMI_TSCE16_XGXS_RX_X4_FEC2r_DEC_17B_BURST_GAP_COUNTf_GET
#define RX_X4_FEC2r_DEC_17B_BURST_GAP_COUNTf_SET BCMI_TSCE16_XGXS_RX_X4_FEC2r_DEC_17B_BURST_GAP_COUNTf_SET
#define RX_X4_FEC2r_DEC_GAP_COUNT_MODEf_GET BCMI_TSCE16_XGXS_RX_X4_FEC2r_DEC_GAP_COUNT_MODEf_GET
#define RX_X4_FEC2r_DEC_GAP_COUNT_MODEf_SET BCMI_TSCE16_XGXS_RX_X4_FEC2r_DEC_GAP_COUNT_MODEf_SET
#define READ_RX_X4_FEC2r BCMI_TSCE16_XGXS_READ_RX_X4_FEC2r
#define WRITE_RX_X4_FEC2r BCMI_TSCE16_XGXS_WRITE_RX_X4_FEC2r
#define MODIFY_RX_X4_FEC2r BCMI_TSCE16_XGXS_MODIFY_RX_X4_FEC2r
#define READLN_RX_X4_FEC2r BCMI_TSCE16_XGXS_READLN_RX_X4_FEC2r
#define WRITELN_RX_X4_FEC2r BCMI_TSCE16_XGXS_WRITELN_RX_X4_FEC2r
#define WRITEALL_RX_X4_FEC2r BCMI_TSCE16_XGXS_WRITEALL_RX_X4_FEC2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_FEC2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_DEC_CTL0
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc134
 * DESC:     Decoder control 0 register
 * RESETVAL: 0x2870 (10352)
 * ACCESS:   R/W
 * FIELDS:
 *     BLOCK_SYNC_MODE  000 none001 cl49 mode - enables func_cl49cl82_sync block010 cl82 mode - enables func_cl49cl82_sync block011 8b10b mode - enables the func_8b10b_sync block100 fec mode - enables the func_fec_sync block101 brcm 64b66b mode
 *     CL49_RX_RF_ENABLE If this bit is a one, RFs are passed to the RS layer from the PCS.If this bit is a zero, RFs are replaced by IDLEs which are then passedto the RS layer.For CL49 only.
 *     CL49_RX_LF_ENABLE If this bit is a one, LFs are passed to the RS layer from the PCS.If this bit is a zero, LFs are replaced by IDLEs which are then passedto the RS layer.For CL49 only.
 *     CL49_RX_LI_ENABLE If this bit is a one, LIs (Link Interrupt) are passed thru to the PCS.If this bit is a zero, LIs (Link Interrupt) are replaced by IDLEs which are then passedto the PCS.For CL49 only.
 *     DISABLE_CL49_BERMON Disable cl49 BER monitor state machine1 = Disable bermon fsm, force BER_MT_INIT state0 = Enable (default)
 *     HG2_CODEC        Enables HG2 extensions support for PCSSet this bit to enable HG2 messaging
 *     CL48_CGBAD_EN    
 *     CL48_SYNCACQ_EN  This is mainly a debug control.  this control should be set (1) under normal operating conditions
 *     HG2_ENABLE       Enables HG2 support for PCS
 *     HG2_MESSAGE_INVALID_CODE_ENABLE Enables HG2 invalid message code support.
 *     R_TEST_MODE_CFG  Test Mode enable for both CL49 and CL82
 *     BYPASS_CL49RXSM  Bypass cl49 receive state machine1 = Bypass cl49 rxsm :- force RX_INIT state- pass the data from the table look-up decoder to the output0 = normal mode
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r (0x0000c134 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_DEC_CTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_s {
	uint32_t v[1];
	uint32_t rx_x4_dec_ctl0[1];
	uint32_t _rx_x4_dec_ctl0;
} BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_t;

#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_CLR(r) (r).rx_x4_dec_ctl0[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_SET(r,d) (r).rx_x4_dec_ctl0[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_GET(r) (r).rx_x4_dec_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_BYPASS_CL49RXSMf_GET(r) ((((r).rx_x4_dec_ctl0[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_BYPASS_CL49RXSMf_SET(r,f) (r).rx_x4_dec_ctl0[0]=(((r).rx_x4_dec_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_R_TEST_MODE_CFGf_GET(r) ((((r).rx_x4_dec_ctl0[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_R_TEST_MODE_CFGf_SET(r,f) (r).rx_x4_dec_ctl0[0]=(((r).rx_x4_dec_ctl0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_GET(r) ((((r).rx_x4_dec_ctl0[0]) >> 13) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_SET(r,f) (r).rx_x4_dec_ctl0[0]=(((r).rx_x4_dec_ctl0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_HG2_ENABLEf_GET(r) ((((r).rx_x4_dec_ctl0[0]) >> 12) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_HG2_ENABLEf_SET(r,f) (r).rx_x4_dec_ctl0[0]=(((r).rx_x4_dec_ctl0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_CL48_SYNCACQ_ENf_GET(r) ((((r).rx_x4_dec_ctl0[0]) >> 11) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_CL48_SYNCACQ_ENf_SET(r,f) (r).rx_x4_dec_ctl0[0]=(((r).rx_x4_dec_ctl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_CL48_CGBAD_ENf_GET(r) ((((r).rx_x4_dec_ctl0[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_CL48_CGBAD_ENf_SET(r,f) (r).rx_x4_dec_ctl0[0]=(((r).rx_x4_dec_ctl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_HG2_CODECf_GET(r) ((((r).rx_x4_dec_ctl0[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_HG2_CODECf_SET(r,f) (r).rx_x4_dec_ctl0[0]=(((r).rx_x4_dec_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_DISABLE_CL49_BERMONf_GET(r) ((((r).rx_x4_dec_ctl0[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_DISABLE_CL49_BERMONf_SET(r,f) (r).rx_x4_dec_ctl0[0]=(((r).rx_x4_dec_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_CL49_RX_LI_ENABLEf_GET(r) ((((r).rx_x4_dec_ctl0[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_CL49_RX_LI_ENABLEf_SET(r,f) (r).rx_x4_dec_ctl0[0]=(((r).rx_x4_dec_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_CL49_RX_LF_ENABLEf_GET(r) ((((r).rx_x4_dec_ctl0[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_CL49_RX_LF_ENABLEf_SET(r,f) (r).rx_x4_dec_ctl0[0]=(((r).rx_x4_dec_ctl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_CL49_RX_RF_ENABLEf_GET(r) ((((r).rx_x4_dec_ctl0[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_CL49_RX_RF_ENABLEf_SET(r,f) (r).rx_x4_dec_ctl0[0]=(((r).rx_x4_dec_ctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_BLOCK_SYNC_MODEf_GET(r) (((r).rx_x4_dec_ctl0[0]) & 0x7)
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_BLOCK_SYNC_MODEf_SET(r,f) (r).rx_x4_dec_ctl0[0]=(((r).rx_x4_dec_ctl0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access RX_X4_DEC_CTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_DEC_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r,(_r._rx_x4_dec_ctl0))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_DEC_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r,(_r._rx_x4_dec_ctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_DEC_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r,(_r._rx_x4_dec_ctl0))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_DEC_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_dec_ctl0))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_DEC_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_dec_ctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_DEC_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_dec_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_DEC_CTL0r BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r
#define RX_X4_DEC_CTL0r_SIZE BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_t RX_X4_DEC_CTL0r_t;
#define RX_X4_DEC_CTL0r_CLR BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_CLR
#define RX_X4_DEC_CTL0r_SET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_SET
#define RX_X4_DEC_CTL0r_GET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_GET
#define RX_X4_DEC_CTL0r_BYPASS_CL49RXSMf_GET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_BYPASS_CL49RXSMf_GET
#define RX_X4_DEC_CTL0r_BYPASS_CL49RXSMf_SET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_BYPASS_CL49RXSMf_SET
#define RX_X4_DEC_CTL0r_R_TEST_MODE_CFGf_GET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_R_TEST_MODE_CFGf_GET
#define RX_X4_DEC_CTL0r_R_TEST_MODE_CFGf_SET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_R_TEST_MODE_CFGf_SET
#define RX_X4_DEC_CTL0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_GET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_GET
#define RX_X4_DEC_CTL0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_SET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_SET
#define RX_X4_DEC_CTL0r_HG2_ENABLEf_GET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_HG2_ENABLEf_GET
#define RX_X4_DEC_CTL0r_HG2_ENABLEf_SET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_HG2_ENABLEf_SET
#define RX_X4_DEC_CTL0r_CL48_SYNCACQ_ENf_GET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_CL48_SYNCACQ_ENf_GET
#define RX_X4_DEC_CTL0r_CL48_SYNCACQ_ENf_SET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_CL48_SYNCACQ_ENf_SET
#define RX_X4_DEC_CTL0r_CL48_CGBAD_ENf_GET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_CL48_CGBAD_ENf_GET
#define RX_X4_DEC_CTL0r_CL48_CGBAD_ENf_SET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_CL48_CGBAD_ENf_SET
#define RX_X4_DEC_CTL0r_HG2_CODECf_GET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_HG2_CODECf_GET
#define RX_X4_DEC_CTL0r_HG2_CODECf_SET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_HG2_CODECf_SET
#define RX_X4_DEC_CTL0r_DISABLE_CL49_BERMONf_GET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_DISABLE_CL49_BERMONf_GET
#define RX_X4_DEC_CTL0r_DISABLE_CL49_BERMONf_SET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_DISABLE_CL49_BERMONf_SET
#define RX_X4_DEC_CTL0r_CL49_RX_LI_ENABLEf_GET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_CL49_RX_LI_ENABLEf_GET
#define RX_X4_DEC_CTL0r_CL49_RX_LI_ENABLEf_SET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_CL49_RX_LI_ENABLEf_SET
#define RX_X4_DEC_CTL0r_CL49_RX_LF_ENABLEf_GET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_CL49_RX_LF_ENABLEf_GET
#define RX_X4_DEC_CTL0r_CL49_RX_LF_ENABLEf_SET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_CL49_RX_LF_ENABLEf_SET
#define RX_X4_DEC_CTL0r_CL49_RX_RF_ENABLEf_GET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_CL49_RX_RF_ENABLEf_GET
#define RX_X4_DEC_CTL0r_CL49_RX_RF_ENABLEf_SET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_CL49_RX_RF_ENABLEf_SET
#define RX_X4_DEC_CTL0r_BLOCK_SYNC_MODEf_GET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_BLOCK_SYNC_MODEf_GET
#define RX_X4_DEC_CTL0r_BLOCK_SYNC_MODEf_SET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r_BLOCK_SYNC_MODEf_SET
#define READ_RX_X4_DEC_CTL0r BCMI_TSCE16_XGXS_READ_RX_X4_DEC_CTL0r
#define WRITE_RX_X4_DEC_CTL0r BCMI_TSCE16_XGXS_WRITE_RX_X4_DEC_CTL0r
#define MODIFY_RX_X4_DEC_CTL0r BCMI_TSCE16_XGXS_MODIFY_RX_X4_DEC_CTL0r
#define READLN_RX_X4_DEC_CTL0r BCMI_TSCE16_XGXS_READLN_RX_X4_DEC_CTL0r
#define WRITELN_RX_X4_DEC_CTL0r BCMI_TSCE16_XGXS_WRITELN_RX_X4_DEC_CTL0r
#define WRITEALL_RX_X4_DEC_CTL0r BCMI_TSCE16_XGXS_WRITEALL_RX_X4_DEC_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_DEC_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_DEC_CTL1
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc135
 * DESC:     Decoder control 1 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     B66DEC_CGBAD_EN  Set bit 9 of symbol when bad symbol is detectedShould be set to 1
 *     B66DEC_SYNCERRCOUNT_EN 64/66 decode sync error counter enable.
 *     B66DEC_KCODE66ERRCOUNT_EN 64/66 decode k code group error counter enable.
 *     B66DEC_FAULT_DET_EN In brcm/cl49 mode detect local and remote faults on the rx side0  - disabled1  - enabled
 *     B66DEC_PROG_TL_CHAR A programmable control character for table lookup.This should be set to 0xb4.
 *     B66DEC_PROG_TL_EN Enable lookup of programmable control character.This should be set to 1.
 *     B66DEC_NOBLOCKLOCK_DOUT_SEL In brcm/cl49 mode data output control when the link is down or the test mode is enabledi.e. reset + r_test_mode + hi_ber + !block_lock in Fig49-15 in the IEEE spec2'b00  - local faults (same as cl49)2'b01  - idles2'b10  - zeroes2'b11  - error codes
 *     B66DEC_DOUT_ERRORS_IF_BAD_SYNC In brcm/cl49 mode send error codes when bad sync is detected.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r (0x0000c135 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_DEC_CTL1.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_s {
	uint32_t v[1];
	uint32_t rx_x4_dec_ctl1[1];
	uint32_t _rx_x4_dec_ctl1;
} BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_t;

#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_CLR(r) (r).rx_x4_dec_ctl1[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_SET(r,d) (r).rx_x4_dec_ctl1[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_GET(r) (r).rx_x4_dec_ctl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_B66DEC_DOUT_ERRORS_IF_BAD_SYNCf_GET(r) ((((r).rx_x4_dec_ctl1[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_B66DEC_DOUT_ERRORS_IF_BAD_SYNCf_SET(r,f) (r).rx_x4_dec_ctl1[0]=(((r).rx_x4_dec_ctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_B66DEC_NOBLOCKLOCK_DOUT_SELf_GET(r) ((((r).rx_x4_dec_ctl1[0]) >> 13) & 0x3)
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_B66DEC_NOBLOCKLOCK_DOUT_SELf_SET(r,f) (r).rx_x4_dec_ctl1[0]=(((r).rx_x4_dec_ctl1[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13)) | (3 << (16 + 13))
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_B66DEC_PROG_TL_ENf_GET(r) ((((r).rx_x4_dec_ctl1[0]) >> 12) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_B66DEC_PROG_TL_ENf_SET(r,f) (r).rx_x4_dec_ctl1[0]=(((r).rx_x4_dec_ctl1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_B66DEC_PROG_TL_CHARf_GET(r) ((((r).rx_x4_dec_ctl1[0]) >> 4) & 0xff)
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_B66DEC_PROG_TL_CHARf_SET(r,f) (r).rx_x4_dec_ctl1[0]=(((r).rx_x4_dec_ctl1[0] & ~((uint32_t)0xff << 4)) | ((((uint32_t)f) & 0xff) << 4)) | (255 << (16 + 4))
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_B66DEC_FAULT_DET_ENf_GET(r) ((((r).rx_x4_dec_ctl1[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_B66DEC_FAULT_DET_ENf_SET(r,f) (r).rx_x4_dec_ctl1[0]=(((r).rx_x4_dec_ctl1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_B66DEC_KCODE66ERRCOUNT_ENf_GET(r) ((((r).rx_x4_dec_ctl1[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_B66DEC_KCODE66ERRCOUNT_ENf_SET(r,f) (r).rx_x4_dec_ctl1[0]=(((r).rx_x4_dec_ctl1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_B66DEC_SYNCERRCOUNT_ENf_GET(r) ((((r).rx_x4_dec_ctl1[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_B66DEC_SYNCERRCOUNT_ENf_SET(r,f) (r).rx_x4_dec_ctl1[0]=(((r).rx_x4_dec_ctl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_B66DEC_CGBAD_ENf_GET(r) (((r).rx_x4_dec_ctl1[0]) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_B66DEC_CGBAD_ENf_SET(r,f) (r).rx_x4_dec_ctl1[0]=(((r).rx_x4_dec_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_DEC_CTL1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_DEC_CTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r,(_r._rx_x4_dec_ctl1))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_DEC_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r,(_r._rx_x4_dec_ctl1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_DEC_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r,(_r._rx_x4_dec_ctl1))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_DEC_CTL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_dec_ctl1))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_DEC_CTL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_dec_ctl1))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_DEC_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_dec_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_DEC_CTL1r BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r
#define RX_X4_DEC_CTL1r_SIZE BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_t RX_X4_DEC_CTL1r_t;
#define RX_X4_DEC_CTL1r_CLR BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_CLR
#define RX_X4_DEC_CTL1r_SET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_SET
#define RX_X4_DEC_CTL1r_GET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_GET
#define RX_X4_DEC_CTL1r_B66DEC_DOUT_ERRORS_IF_BAD_SYNCf_GET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_B66DEC_DOUT_ERRORS_IF_BAD_SYNCf_GET
#define RX_X4_DEC_CTL1r_B66DEC_DOUT_ERRORS_IF_BAD_SYNCf_SET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_B66DEC_DOUT_ERRORS_IF_BAD_SYNCf_SET
#define RX_X4_DEC_CTL1r_B66DEC_NOBLOCKLOCK_DOUT_SELf_GET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_B66DEC_NOBLOCKLOCK_DOUT_SELf_GET
#define RX_X4_DEC_CTL1r_B66DEC_NOBLOCKLOCK_DOUT_SELf_SET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_B66DEC_NOBLOCKLOCK_DOUT_SELf_SET
#define RX_X4_DEC_CTL1r_B66DEC_PROG_TL_ENf_GET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_B66DEC_PROG_TL_ENf_GET
#define RX_X4_DEC_CTL1r_B66DEC_PROG_TL_ENf_SET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_B66DEC_PROG_TL_ENf_SET
#define RX_X4_DEC_CTL1r_B66DEC_PROG_TL_CHARf_GET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_B66DEC_PROG_TL_CHARf_GET
#define RX_X4_DEC_CTL1r_B66DEC_PROG_TL_CHARf_SET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_B66DEC_PROG_TL_CHARf_SET
#define RX_X4_DEC_CTL1r_B66DEC_FAULT_DET_ENf_GET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_B66DEC_FAULT_DET_ENf_GET
#define RX_X4_DEC_CTL1r_B66DEC_FAULT_DET_ENf_SET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_B66DEC_FAULT_DET_ENf_SET
#define RX_X4_DEC_CTL1r_B66DEC_KCODE66ERRCOUNT_ENf_GET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_B66DEC_KCODE66ERRCOUNT_ENf_GET
#define RX_X4_DEC_CTL1r_B66DEC_KCODE66ERRCOUNT_ENf_SET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_B66DEC_KCODE66ERRCOUNT_ENf_SET
#define RX_X4_DEC_CTL1r_B66DEC_SYNCERRCOUNT_ENf_GET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_B66DEC_SYNCERRCOUNT_ENf_GET
#define RX_X4_DEC_CTL1r_B66DEC_SYNCERRCOUNT_ENf_SET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_B66DEC_SYNCERRCOUNT_ENf_SET
#define RX_X4_DEC_CTL1r_B66DEC_CGBAD_ENf_GET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_B66DEC_CGBAD_ENf_GET
#define RX_X4_DEC_CTL1r_B66DEC_CGBAD_ENf_SET BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r_B66DEC_CGBAD_ENf_SET
#define READ_RX_X4_DEC_CTL1r BCMI_TSCE16_XGXS_READ_RX_X4_DEC_CTL1r
#define WRITE_RX_X4_DEC_CTL1r BCMI_TSCE16_XGXS_WRITE_RX_X4_DEC_CTL1r
#define MODIFY_RX_X4_DEC_CTL1r BCMI_TSCE16_XGXS_MODIFY_RX_X4_DEC_CTL1r
#define READLN_RX_X4_DEC_CTL1r BCMI_TSCE16_XGXS_READLN_RX_X4_DEC_CTL1r
#define WRITELN_RX_X4_DEC_CTL1r BCMI_TSCE16_XGXS_WRITELN_RX_X4_DEC_CTL1r
#define WRITEALL_RX_X4_DEC_CTL1r BCMI_TSCE16_XGXS_WRITEALL_RX_X4_DEC_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_DEC_CTL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_CL36_RX0
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc136
 * DESC:     cl36_rx_0 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL36_EN          
 *     REORDER_EN       1'b0: cl48 reorder is disabled1'b1: cl48 reorder is enabled
 *     DISABLE_CARRIER_EXTEND 
 *     CL36_FORCE_COMMA_ALIGN_ENABLE 
 *     CL36_BER_EN      
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r (0x0000c136 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL36_RX0.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r_s {
	uint32_t v[1];
	uint32_t rx_x4_cl36_rx0[1];
	uint32_t _rx_x4_cl36_rx0;
} BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r_t;

#define BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r_CLR(r) (r).rx_x4_cl36_rx0[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r_SET(r,d) (r).rx_x4_cl36_rx0[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r_GET(r) (r).rx_x4_cl36_rx0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r_CL36_BER_ENf_GET(r) ((((r).rx_x4_cl36_rx0[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r_CL36_BER_ENf_SET(r,f) (r).rx_x4_cl36_rx0[0]=(((r).rx_x4_cl36_rx0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r_CL36_FORCE_COMMA_ALIGN_ENABLEf_GET(r) ((((r).rx_x4_cl36_rx0[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r_CL36_FORCE_COMMA_ALIGN_ENABLEf_SET(r,f) (r).rx_x4_cl36_rx0[0]=(((r).rx_x4_cl36_rx0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r_DISABLE_CARRIER_EXTENDf_GET(r) ((((r).rx_x4_cl36_rx0[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r_DISABLE_CARRIER_EXTENDf_SET(r,f) (r).rx_x4_cl36_rx0[0]=(((r).rx_x4_cl36_rx0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r_REORDER_ENf_GET(r) ((((r).rx_x4_cl36_rx0[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r_REORDER_ENf_SET(r,f) (r).rx_x4_cl36_rx0[0]=(((r).rx_x4_cl36_rx0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r_CL36_ENf_GET(r) (((r).rx_x4_cl36_rx0[0]) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r_CL36_ENf_SET(r,f) (r).rx_x4_cl36_rx0[0]=(((r).rx_x4_cl36_rx0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_CL36_RX0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_CL36_RX0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r,(_r._rx_x4_cl36_rx0))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_CL36_RX0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r,(_r._rx_x4_cl36_rx0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_CL36_RX0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r,(_r._rx_x4_cl36_rx0))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_CL36_RX0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl36_rx0))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_CL36_RX0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl36_rx0))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_CL36_RX0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl36_rx0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL36_RX0r BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r
#define RX_X4_CL36_RX0r_SIZE BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r_t RX_X4_CL36_RX0r_t;
#define RX_X4_CL36_RX0r_CLR BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r_CLR
#define RX_X4_CL36_RX0r_SET BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r_SET
#define RX_X4_CL36_RX0r_GET BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r_GET
#define RX_X4_CL36_RX0r_CL36_BER_ENf_GET BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r_CL36_BER_ENf_GET
#define RX_X4_CL36_RX0r_CL36_BER_ENf_SET BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r_CL36_BER_ENf_SET
#define RX_X4_CL36_RX0r_CL36_FORCE_COMMA_ALIGN_ENABLEf_GET BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r_CL36_FORCE_COMMA_ALIGN_ENABLEf_GET
#define RX_X4_CL36_RX0r_CL36_FORCE_COMMA_ALIGN_ENABLEf_SET BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r_CL36_FORCE_COMMA_ALIGN_ENABLEf_SET
#define RX_X4_CL36_RX0r_DISABLE_CARRIER_EXTENDf_GET BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r_DISABLE_CARRIER_EXTENDf_GET
#define RX_X4_CL36_RX0r_DISABLE_CARRIER_EXTENDf_SET BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r_DISABLE_CARRIER_EXTENDf_SET
#define RX_X4_CL36_RX0r_REORDER_ENf_GET BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r_REORDER_ENf_GET
#define RX_X4_CL36_RX0r_REORDER_ENf_SET BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r_REORDER_ENf_SET
#define RX_X4_CL36_RX0r_CL36_ENf_GET BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r_CL36_ENf_GET
#define RX_X4_CL36_RX0r_CL36_ENf_SET BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r_CL36_ENf_SET
#define READ_RX_X4_CL36_RX0r BCMI_TSCE16_XGXS_READ_RX_X4_CL36_RX0r
#define WRITE_RX_X4_CL36_RX0r BCMI_TSCE16_XGXS_WRITE_RX_X4_CL36_RX0r
#define MODIFY_RX_X4_CL36_RX0r BCMI_TSCE16_XGXS_MODIFY_RX_X4_CL36_RX0r
#define READLN_RX_X4_CL36_RX0r BCMI_TSCE16_XGXS_READLN_RX_X4_CL36_RX0r
#define WRITELN_RX_X4_CL36_RX0r BCMI_TSCE16_XGXS_WRITELN_RX_X4_CL36_RX0r
#define WRITEALL_RX_X4_CL36_RX0r BCMI_TSCE16_XGXS_WRITEALL_RX_X4_CL36_RX0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_CL36_RX0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_PMA_CTL0
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc137
 * DESC:     pma_control_0 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RSTB_LANE        Low activer per lane reset for RXP
 *     RX_GBOX_AFRST_EN 
 *     OS_MODE          0: OS MODE 1 - divide by 11: OS MODE 2 - divide by 22: OS MODE 3 - divide by 33: OS MODE 3.3 - divide by 3.3.Bit repeating pattern is 3,3,3,4,3,3,4,3,3,44: OS MODE 4 - divide by 45: OS MODE 5 - divide by 56: OS MODE 8 - divide by 87: OS MODE 8.25 - divide by 8.25.Bit repeating pattern is 8,8,8,98: OS MODE 10 - divide by 10
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_PMA_CTL0r (0x0000c137 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_PMA_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_PMA_CTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_PMA_CTL0r_s {
	uint32_t v[1];
	uint32_t rx_x4_pma_ctl0[1];
	uint32_t _rx_x4_pma_ctl0;
} BCMI_TSCE16_XGXS_RX_X4_PMA_CTL0r_t;

#define BCMI_TSCE16_XGXS_RX_X4_PMA_CTL0r_CLR(r) (r).rx_x4_pma_ctl0[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_PMA_CTL0r_SET(r,d) (r).rx_x4_pma_ctl0[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_PMA_CTL0r_GET(r) (r).rx_x4_pma_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_PMA_CTL0r_OS_MODEf_GET(r) ((((r).rx_x4_pma_ctl0[0]) >> 3) & 0xf)
#define BCMI_TSCE16_XGXS_RX_X4_PMA_CTL0r_OS_MODEf_SET(r,f) (r).rx_x4_pma_ctl0[0]=(((r).rx_x4_pma_ctl0[0] & ~((uint32_t)0xf << 3)) | ((((uint32_t)f) & 0xf) << 3)) | (15 << (16 + 3))
#define BCMI_TSCE16_XGXS_RX_X4_PMA_CTL0r_RX_GBOX_AFRST_ENf_GET(r) ((((r).rx_x4_pma_ctl0[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_PMA_CTL0r_RX_GBOX_AFRST_ENf_SET(r,f) (r).rx_x4_pma_ctl0[0]=(((r).rx_x4_pma_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_RX_X4_PMA_CTL0r_RSTB_LANEf_GET(r) (((r).rx_x4_pma_ctl0[0]) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_PMA_CTL0r_RSTB_LANEf_SET(r,f) (r).rx_x4_pma_ctl0[0]=(((r).rx_x4_pma_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_PMA_CTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_PMA_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_PMA_CTL0r,(_r._rx_x4_pma_ctl0))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_PMA_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_PMA_CTL0r,(_r._rx_x4_pma_ctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_PMA_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_PMA_CTL0r,(_r._rx_x4_pma_ctl0))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_PMA_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_PMA_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_pma_ctl0))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_PMA_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_PMA_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_pma_ctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_PMA_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_PMA_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_pma_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_PMA_CTL0r BCMI_TSCE16_XGXS_RX_X4_PMA_CTL0r
#define RX_X4_PMA_CTL0r_SIZE BCMI_TSCE16_XGXS_RX_X4_PMA_CTL0r_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_PMA_CTL0r_t RX_X4_PMA_CTL0r_t;
#define RX_X4_PMA_CTL0r_CLR BCMI_TSCE16_XGXS_RX_X4_PMA_CTL0r_CLR
#define RX_X4_PMA_CTL0r_SET BCMI_TSCE16_XGXS_RX_X4_PMA_CTL0r_SET
#define RX_X4_PMA_CTL0r_GET BCMI_TSCE16_XGXS_RX_X4_PMA_CTL0r_GET
#define RX_X4_PMA_CTL0r_OS_MODEf_GET BCMI_TSCE16_XGXS_RX_X4_PMA_CTL0r_OS_MODEf_GET
#define RX_X4_PMA_CTL0r_OS_MODEf_SET BCMI_TSCE16_XGXS_RX_X4_PMA_CTL0r_OS_MODEf_SET
#define RX_X4_PMA_CTL0r_RX_GBOX_AFRST_ENf_GET BCMI_TSCE16_XGXS_RX_X4_PMA_CTL0r_RX_GBOX_AFRST_ENf_GET
#define RX_X4_PMA_CTL0r_RX_GBOX_AFRST_ENf_SET BCMI_TSCE16_XGXS_RX_X4_PMA_CTL0r_RX_GBOX_AFRST_ENf_SET
#define RX_X4_PMA_CTL0r_RSTB_LANEf_GET BCMI_TSCE16_XGXS_RX_X4_PMA_CTL0r_RSTB_LANEf_GET
#define RX_X4_PMA_CTL0r_RSTB_LANEf_SET BCMI_TSCE16_XGXS_RX_X4_PMA_CTL0r_RSTB_LANEf_SET
#define READ_RX_X4_PMA_CTL0r BCMI_TSCE16_XGXS_READ_RX_X4_PMA_CTL0r
#define WRITE_RX_X4_PMA_CTL0r BCMI_TSCE16_XGXS_WRITE_RX_X4_PMA_CTL0r
#define MODIFY_RX_X4_PMA_CTL0r BCMI_TSCE16_XGXS_MODIFY_RX_X4_PMA_CTL0r
#define READLN_RX_X4_PMA_CTL0r BCMI_TSCE16_XGXS_READLN_RX_X4_PMA_CTL0r
#define WRITELN_RX_X4_PMA_CTL0r BCMI_TSCE16_XGXS_WRITELN_RX_X4_PMA_CTL0r
#define WRITEALL_RX_X4_PMA_CTL0r BCMI_TSCE16_XGXS_WRITEALL_RX_X4_PMA_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_PMA_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_LNK_CTL
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc139
 * DESC:     Link status control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LATCH_LINKDOWN_ENABLE Per port signal1'b1 - If the link status transitions from UP (1) to DOWN (0), this bit maintains the DOWN (0) value of the link status until the SW clears this bit.1'b0 - The link status information is passed directly from the PCS to the MAC and status registers without modification
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_LNK_CTLr (0x0000c139 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_LNK_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_LNK_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_LNK_CTLr_s {
	uint32_t v[1];
	uint32_t rx_x4_lnk_ctl[1];
	uint32_t _rx_x4_lnk_ctl;
} BCMI_TSCE16_XGXS_RX_X4_LNK_CTLr_t;

#define BCMI_TSCE16_XGXS_RX_X4_LNK_CTLr_CLR(r) (r).rx_x4_lnk_ctl[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_LNK_CTLr_SET(r,d) (r).rx_x4_lnk_ctl[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_LNK_CTLr_GET(r) (r).rx_x4_lnk_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_LNK_CTLr_LATCH_LINKDOWN_ENABLEf_GET(r) (((r).rx_x4_lnk_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_LNK_CTLr_LATCH_LINKDOWN_ENABLEf_SET(r,f) (r).rx_x4_lnk_ctl[0]=(((r).rx_x4_lnk_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_LNK_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_LNK_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_LNK_CTLr,(_r._rx_x4_lnk_ctl))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_LNK_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_LNK_CTLr,(_r._rx_x4_lnk_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_LNK_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_LNK_CTLr,(_r._rx_x4_lnk_ctl))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_LNK_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_LNK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_lnk_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_LNK_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_LNK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_lnk_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_LNK_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_LNK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_lnk_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_LNK_CTLr BCMI_TSCE16_XGXS_RX_X4_LNK_CTLr
#define RX_X4_LNK_CTLr_SIZE BCMI_TSCE16_XGXS_RX_X4_LNK_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_LNK_CTLr_t RX_X4_LNK_CTLr_t;
#define RX_X4_LNK_CTLr_CLR BCMI_TSCE16_XGXS_RX_X4_LNK_CTLr_CLR
#define RX_X4_LNK_CTLr_SET BCMI_TSCE16_XGXS_RX_X4_LNK_CTLr_SET
#define RX_X4_LNK_CTLr_GET BCMI_TSCE16_XGXS_RX_X4_LNK_CTLr_GET
#define RX_X4_LNK_CTLr_LATCH_LINKDOWN_ENABLEf_GET BCMI_TSCE16_XGXS_RX_X4_LNK_CTLr_LATCH_LINKDOWN_ENABLEf_GET
#define RX_X4_LNK_CTLr_LATCH_LINKDOWN_ENABLEf_SET BCMI_TSCE16_XGXS_RX_X4_LNK_CTLr_LATCH_LINKDOWN_ENABLEf_SET
#define READ_RX_X4_LNK_CTLr BCMI_TSCE16_XGXS_READ_RX_X4_LNK_CTLr
#define WRITE_RX_X4_LNK_CTLr BCMI_TSCE16_XGXS_WRITE_RX_X4_LNK_CTLr
#define MODIFY_RX_X4_LNK_CTLr BCMI_TSCE16_XGXS_MODIFY_RX_X4_LNK_CTLr
#define READLN_RX_X4_LNK_CTLr BCMI_TSCE16_XGXS_READLN_RX_X4_LNK_CTLr
#define WRITELN_RX_X4_LNK_CTLr BCMI_TSCE16_XGXS_WRITELN_RX_X4_LNK_CTLr
#define WRITEALL_RX_X4_LNK_CTLr BCMI_TSCE16_XGXS_WRITEALL_RX_X4_LNK_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_LNK_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_SYNCE_CTL
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc13d
 * DESC:     SyncE SDM Divisor
 * RESETVAL: 0x14a0 (5280)
 * ACCESS:   R/W
 * FIELDS:
 *     SYNCE_STAGE0_SDM_DIV_PHY_LN Per physical lane:Program this register for different divider as the following table:f_cdr(Hz)      config divisor[15:0]  resulted fractional divider :Eagle         515,625,000     5280                  20.625546,875,000     5600                  21.875Falcon        644,531,250     6600                  25.78125683,593,750     7000                  27.34375515,625,000     5280                  20.625257,812,500     2640                  10.3125156,250,000     1600                  6.25515,625,000     5280                  20.625resulted fractional divider  =       config division[15:0]/256
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_SYNCE_CTLr (0x0000c13d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_SYNCE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_SYNCE_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_SYNCE_CTLr_s {
	uint32_t v[1];
	uint32_t rx_x4_synce_ctl[1];
	uint32_t _rx_x4_synce_ctl;
} BCMI_TSCE16_XGXS_RX_X4_SYNCE_CTLr_t;

#define BCMI_TSCE16_XGXS_RX_X4_SYNCE_CTLr_CLR(r) (r).rx_x4_synce_ctl[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_SYNCE_CTLr_SET(r,d) (r).rx_x4_synce_ctl[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_SYNCE_CTLr_GET(r) (r).rx_x4_synce_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_SYNCE_CTLr_SYNCE_STAGE0_SDM_DIV_PHY_LNf_GET(r) (((r).rx_x4_synce_ctl[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_RX_X4_SYNCE_CTLr_SYNCE_STAGE0_SDM_DIV_PHY_LNf_SET(r,f) (r).rx_x4_synce_ctl[0]=(((r).rx_x4_synce_ctl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_SYNCE_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_SYNCE_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_SYNCE_CTLr,(_r._rx_x4_synce_ctl))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_SYNCE_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_SYNCE_CTLr,(_r._rx_x4_synce_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_SYNCE_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_SYNCE_CTLr,(_r._rx_x4_synce_ctl))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_SYNCE_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_SYNCE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_synce_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_SYNCE_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_SYNCE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_synce_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_SYNCE_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_SYNCE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_synce_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_SYNCE_CTLr BCMI_TSCE16_XGXS_RX_X4_SYNCE_CTLr
#define RX_X4_SYNCE_CTLr_SIZE BCMI_TSCE16_XGXS_RX_X4_SYNCE_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_SYNCE_CTLr_t RX_X4_SYNCE_CTLr_t;
#define RX_X4_SYNCE_CTLr_CLR BCMI_TSCE16_XGXS_RX_X4_SYNCE_CTLr_CLR
#define RX_X4_SYNCE_CTLr_SET BCMI_TSCE16_XGXS_RX_X4_SYNCE_CTLr_SET
#define RX_X4_SYNCE_CTLr_GET BCMI_TSCE16_XGXS_RX_X4_SYNCE_CTLr_GET
#define RX_X4_SYNCE_CTLr_SYNCE_STAGE0_SDM_DIV_PHY_LNf_GET BCMI_TSCE16_XGXS_RX_X4_SYNCE_CTLr_SYNCE_STAGE0_SDM_DIV_PHY_LNf_GET
#define RX_X4_SYNCE_CTLr_SYNCE_STAGE0_SDM_DIV_PHY_LNf_SET BCMI_TSCE16_XGXS_RX_X4_SYNCE_CTLr_SYNCE_STAGE0_SDM_DIV_PHY_LNf_SET
#define READ_RX_X4_SYNCE_CTLr BCMI_TSCE16_XGXS_READ_RX_X4_SYNCE_CTLr
#define WRITE_RX_X4_SYNCE_CTLr BCMI_TSCE16_XGXS_WRITE_RX_X4_SYNCE_CTLr
#define MODIFY_RX_X4_SYNCE_CTLr BCMI_TSCE16_XGXS_MODIFY_RX_X4_SYNCE_CTLr
#define READLN_RX_X4_SYNCE_CTLr BCMI_TSCE16_XGXS_READLN_RX_X4_SYNCE_CTLr
#define WRITELN_RX_X4_SYNCE_CTLr BCMI_TSCE16_XGXS_WRITELN_RX_X4_SYNCE_CTLr
#define WRITEALL_RX_X4_SYNCE_CTLr BCMI_TSCE16_XGXS_WRITEALL_RX_X4_SYNCE_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_SYNCE_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_FEC_DBG_ERRL
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc140
 * DESC:     User FEC debug read data [15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DBG_ERRL         16 LSB of the FEC debug data, clear on read
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRLr (0x0000c140 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRLr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_DBG_ERRL.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRLr_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_dbg_errl[1];
	uint32_t _rx_x4_fec_dbg_errl;
} BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRLr_t;

#define BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRLr_CLR(r) (r).rx_x4_fec_dbg_errl[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRLr_SET(r,d) (r).rx_x4_fec_dbg_errl[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRLr_GET(r) (r).rx_x4_fec_dbg_errl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRLr_DBG_ERRLf_GET(r) (((r).rx_x4_fec_dbg_errl[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRLr_DBG_ERRLf_SET(r,f) (r).rx_x4_fec_dbg_errl[0]=(((r).rx_x4_fec_dbg_errl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_DBG_ERRL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_FEC_DBG_ERRLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRLr,(_r._rx_x4_fec_dbg_errl))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_FEC_DBG_ERRLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRLr,(_r._rx_x4_fec_dbg_errl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_FEC_DBG_ERRLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRLr,(_r._rx_x4_fec_dbg_errl))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_FEC_DBG_ERRLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_dbg_errl))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_FEC_DBG_ERRLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_dbg_errl))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_FEC_DBG_ERRLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_dbg_errl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_DBG_ERRLr BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRLr
#define RX_X4_FEC_DBG_ERRLr_SIZE BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRLr_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRLr_t RX_X4_FEC_DBG_ERRLr_t;
#define RX_X4_FEC_DBG_ERRLr_CLR BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRLr_CLR
#define RX_X4_FEC_DBG_ERRLr_SET BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRLr_SET
#define RX_X4_FEC_DBG_ERRLr_GET BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRLr_GET
#define RX_X4_FEC_DBG_ERRLr_DBG_ERRLf_GET BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRLr_DBG_ERRLf_GET
#define RX_X4_FEC_DBG_ERRLr_DBG_ERRLf_SET BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRLr_DBG_ERRLf_SET
#define READ_RX_X4_FEC_DBG_ERRLr BCMI_TSCE16_XGXS_READ_RX_X4_FEC_DBG_ERRLr
#define WRITE_RX_X4_FEC_DBG_ERRLr BCMI_TSCE16_XGXS_WRITE_RX_X4_FEC_DBG_ERRLr
#define MODIFY_RX_X4_FEC_DBG_ERRLr BCMI_TSCE16_XGXS_MODIFY_RX_X4_FEC_DBG_ERRLr
#define READLN_RX_X4_FEC_DBG_ERRLr BCMI_TSCE16_XGXS_READLN_RX_X4_FEC_DBG_ERRLr
#define WRITELN_RX_X4_FEC_DBG_ERRLr BCMI_TSCE16_XGXS_WRITELN_RX_X4_FEC_DBG_ERRLr
#define WRITEALL_RX_X4_FEC_DBG_ERRLr BCMI_TSCE16_XGXS_WRITEALL_RX_X4_FEC_DBG_ERRLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_FEC_DBG_ERRAH
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc141
 * DESC:     User FEC debug read data [31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DBG_ERRH         16 MSB of the FEC debug data, clear on readContents are latched upon read of Fecdbg_edataL
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRAHr (0x0000c141 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRAHr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_DBG_ERRAH.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRAHr_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_dbg_errah[1];
	uint32_t _rx_x4_fec_dbg_errah;
} BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRAHr_t;

#define BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRAHr_CLR(r) (r).rx_x4_fec_dbg_errah[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRAHr_SET(r,d) (r).rx_x4_fec_dbg_errah[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRAHr_GET(r) (r).rx_x4_fec_dbg_errah[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRAHr_DBG_ERRHf_GET(r) (((r).rx_x4_fec_dbg_errah[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRAHr_DBG_ERRHf_SET(r,f) (r).rx_x4_fec_dbg_errah[0]=(((r).rx_x4_fec_dbg_errah[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_DBG_ERRAH.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_FEC_DBG_ERRAHr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRAHr,(_r._rx_x4_fec_dbg_errah))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_FEC_DBG_ERRAHr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRAHr,(_r._rx_x4_fec_dbg_errah)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_FEC_DBG_ERRAHr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRAHr,(_r._rx_x4_fec_dbg_errah))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_FEC_DBG_ERRAHr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRAHr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_dbg_errah))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_FEC_DBG_ERRAHr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRAHr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_dbg_errah))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_FEC_DBG_ERRAHr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRAHr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_dbg_errah))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_DBG_ERRAHr BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRAHr
#define RX_X4_FEC_DBG_ERRAHr_SIZE BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRAHr_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRAHr_t RX_X4_FEC_DBG_ERRAHr_t;
#define RX_X4_FEC_DBG_ERRAHr_CLR BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRAHr_CLR
#define RX_X4_FEC_DBG_ERRAHr_SET BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRAHr_SET
#define RX_X4_FEC_DBG_ERRAHr_GET BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRAHr_GET
#define RX_X4_FEC_DBG_ERRAHr_DBG_ERRHf_GET BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRAHr_DBG_ERRHf_GET
#define RX_X4_FEC_DBG_ERRAHr_DBG_ERRHf_SET BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRAHr_DBG_ERRHf_SET
#define READ_RX_X4_FEC_DBG_ERRAHr BCMI_TSCE16_XGXS_READ_RX_X4_FEC_DBG_ERRAHr
#define WRITE_RX_X4_FEC_DBG_ERRAHr BCMI_TSCE16_XGXS_WRITE_RX_X4_FEC_DBG_ERRAHr
#define MODIFY_RX_X4_FEC_DBG_ERRAHr BCMI_TSCE16_XGXS_MODIFY_RX_X4_FEC_DBG_ERRAHr
#define READLN_RX_X4_FEC_DBG_ERRAHr BCMI_TSCE16_XGXS_READLN_RX_X4_FEC_DBG_ERRAHr
#define WRITELN_RX_X4_FEC_DBG_ERRAHr BCMI_TSCE16_XGXS_WRITELN_RX_X4_FEC_DBG_ERRAHr
#define WRITEALL_RX_X4_FEC_DBG_ERRAHr BCMI_TSCE16_XGXS_WRITEALL_RX_X4_FEC_DBG_ERRAHr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_FEC_DBG_ERRAHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_FEC_BURST_ERR_STSL
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc142
 * DESC:     fec burst error status lower 16 bits
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BURST_ERR_STATUSL 16 LSB of the fec_burst_err_statusbits mapping :Bit [15:0] : b21[15:0]Note: Bit 15 of Fec_burst_err_statusH register clears upon reading this register
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSLr (0x0000c142 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSLr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_BURST_ERR_STSL.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSLr_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_burst_err_stsl[1];
	uint32_t _rx_x4_fec_burst_err_stsl;
} BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSLr_t;

#define BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSLr_CLR(r) (r).rx_x4_fec_burst_err_stsl[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSLr_SET(r,d) (r).rx_x4_fec_burst_err_stsl[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSLr_GET(r) (r).rx_x4_fec_burst_err_stsl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSLr_BURST_ERR_STATUSLf_GET(r) (((r).rx_x4_fec_burst_err_stsl[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSLr_BURST_ERR_STATUSLf_SET(r,f) (r).rx_x4_fec_burst_err_stsl[0]=(((r).rx_x4_fec_burst_err_stsl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_BURST_ERR_STSL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_FEC_BURST_ERR_STSLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSLr,(_r._rx_x4_fec_burst_err_stsl))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_FEC_BURST_ERR_STSLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSLr,(_r._rx_x4_fec_burst_err_stsl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_FEC_BURST_ERR_STSLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSLr,(_r._rx_x4_fec_burst_err_stsl))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_FEC_BURST_ERR_STSLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_burst_err_stsl))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_FEC_BURST_ERR_STSLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_burst_err_stsl))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_FEC_BURST_ERR_STSLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_burst_err_stsl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_BURST_ERR_STSLr BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSLr
#define RX_X4_FEC_BURST_ERR_STSLr_SIZE BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSLr_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSLr_t RX_X4_FEC_BURST_ERR_STSLr_t;
#define RX_X4_FEC_BURST_ERR_STSLr_CLR BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSLr_CLR
#define RX_X4_FEC_BURST_ERR_STSLr_SET BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSLr_SET
#define RX_X4_FEC_BURST_ERR_STSLr_GET BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSLr_GET
#define RX_X4_FEC_BURST_ERR_STSLr_BURST_ERR_STATUSLf_GET BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSLr_BURST_ERR_STATUSLf_GET
#define RX_X4_FEC_BURST_ERR_STSLr_BURST_ERR_STATUSLf_SET BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSLr_BURST_ERR_STATUSLf_SET
#define READ_RX_X4_FEC_BURST_ERR_STSLr BCMI_TSCE16_XGXS_READ_RX_X4_FEC_BURST_ERR_STSLr
#define WRITE_RX_X4_FEC_BURST_ERR_STSLr BCMI_TSCE16_XGXS_WRITE_RX_X4_FEC_BURST_ERR_STSLr
#define MODIFY_RX_X4_FEC_BURST_ERR_STSLr BCMI_TSCE16_XGXS_MODIFY_RX_X4_FEC_BURST_ERR_STSLr
#define READLN_RX_X4_FEC_BURST_ERR_STSLr BCMI_TSCE16_XGXS_READLN_RX_X4_FEC_BURST_ERR_STSLr
#define WRITELN_RX_X4_FEC_BURST_ERR_STSLr BCMI_TSCE16_XGXS_WRITELN_RX_X4_FEC_BURST_ERR_STSLr
#define WRITEALL_RX_X4_FEC_BURST_ERR_STSLr BCMI_TSCE16_XGXS_WRITEALL_RX_X4_FEC_BURST_ERR_STSLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_FEC_BURST_ERR_STSH
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc143
 * DESC:     fec burst error status lower 16 bits
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BURST_ERR_STATUSH 16 MSB of the fec_burst_err_statusbits mapping :Bit 15: status updatedBit 8: 21-bit burst detected, but location failed pattern searchBit 7: pattern match passedBit 6: Corrected alternate errorBit 5: Corrected errorBit [4:0] : b21[20:16]Note: Bit 15 clears upon reading Fec_burst_err_statusL register
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSHr (0x0000c143 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSHr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_BURST_ERR_STSH.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSHr_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_burst_err_stsh[1];
	uint32_t _rx_x4_fec_burst_err_stsh;
} BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSHr_t;

#define BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSHr_CLR(r) (r).rx_x4_fec_burst_err_stsh[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSHr_SET(r,d) (r).rx_x4_fec_burst_err_stsh[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSHr_GET(r) (r).rx_x4_fec_burst_err_stsh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSHr_BURST_ERR_STATUSHf_GET(r) (((r).rx_x4_fec_burst_err_stsh[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSHr_BURST_ERR_STATUSHf_SET(r,f) (r).rx_x4_fec_burst_err_stsh[0]=(((r).rx_x4_fec_burst_err_stsh[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_BURST_ERR_STSH.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_FEC_BURST_ERR_STSHr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSHr,(_r._rx_x4_fec_burst_err_stsh))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_FEC_BURST_ERR_STSHr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSHr,(_r._rx_x4_fec_burst_err_stsh)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_FEC_BURST_ERR_STSHr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSHr,(_r._rx_x4_fec_burst_err_stsh))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_FEC_BURST_ERR_STSHr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSHr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_burst_err_stsh))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_FEC_BURST_ERR_STSHr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSHr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_burst_err_stsh))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_FEC_BURST_ERR_STSHr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSHr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_burst_err_stsh))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_BURST_ERR_STSHr BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSHr
#define RX_X4_FEC_BURST_ERR_STSHr_SIZE BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSHr_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSHr_t RX_X4_FEC_BURST_ERR_STSHr_t;
#define RX_X4_FEC_BURST_ERR_STSHr_CLR BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSHr_CLR
#define RX_X4_FEC_BURST_ERR_STSHr_SET BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSHr_SET
#define RX_X4_FEC_BURST_ERR_STSHr_GET BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSHr_GET
#define RX_X4_FEC_BURST_ERR_STSHr_BURST_ERR_STATUSHf_GET BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSHr_BURST_ERR_STATUSHf_GET
#define RX_X4_FEC_BURST_ERR_STSHr_BURST_ERR_STATUSHf_SET BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSHr_BURST_ERR_STATUSHf_SET
#define READ_RX_X4_FEC_BURST_ERR_STSHr BCMI_TSCE16_XGXS_READ_RX_X4_FEC_BURST_ERR_STSHr
#define WRITE_RX_X4_FEC_BURST_ERR_STSHr BCMI_TSCE16_XGXS_WRITE_RX_X4_FEC_BURST_ERR_STSHr
#define MODIFY_RX_X4_FEC_BURST_ERR_STSHr BCMI_TSCE16_XGXS_MODIFY_RX_X4_FEC_BURST_ERR_STSHr
#define READLN_RX_X4_FEC_BURST_ERR_STSHr BCMI_TSCE16_XGXS_READLN_RX_X4_FEC_BURST_ERR_STSHr
#define WRITELN_RX_X4_FEC_BURST_ERR_STSHr BCMI_TSCE16_XGXS_WRITELN_RX_X4_FEC_BURST_ERR_STSHr
#define WRITEALL_RX_X4_FEC_BURST_ERR_STSHr BCMI_TSCE16_XGXS_WRITEALL_RX_X4_FEC_BURST_ERR_STSHr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_FEC_BURST_ERR_STSHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_BARREL_SHIFTER_ST
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc144
 * DESC:     Barrel Shifter State
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     SHIFT_AMMOUNT    
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_BARREL_SHIFTER_STr (0x0000c144 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_BARREL_SHIFTER_STr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_BARREL_SHIFTER_ST.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_BARREL_SHIFTER_STr_s {
	uint32_t v[1];
	uint32_t rx_x4_barrel_shifter_st[1];
	uint32_t _rx_x4_barrel_shifter_st;
} BCMI_TSCE16_XGXS_RX_X4_BARREL_SHIFTER_STr_t;

#define BCMI_TSCE16_XGXS_RX_X4_BARREL_SHIFTER_STr_CLR(r) (r).rx_x4_barrel_shifter_st[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_BARREL_SHIFTER_STr_SET(r,d) (r).rx_x4_barrel_shifter_st[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_BARREL_SHIFTER_STr_GET(r) (r).rx_x4_barrel_shifter_st[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_BARREL_SHIFTER_STr_SHIFT_AMMOUNTf_GET(r) (((r).rx_x4_barrel_shifter_st[0]) & 0xff)
#define BCMI_TSCE16_XGXS_RX_X4_BARREL_SHIFTER_STr_SHIFT_AMMOUNTf_SET(r,f) (r).rx_x4_barrel_shifter_st[0]=(((r).rx_x4_barrel_shifter_st[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access RX_X4_BARREL_SHIFTER_ST.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_BARREL_SHIFTER_STr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_BARREL_SHIFTER_STr,(_r._rx_x4_barrel_shifter_st))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_BARREL_SHIFTER_STr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_BARREL_SHIFTER_STr,(_r._rx_x4_barrel_shifter_st)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_BARREL_SHIFTER_STr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_BARREL_SHIFTER_STr,(_r._rx_x4_barrel_shifter_st))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_BARREL_SHIFTER_STr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_BARREL_SHIFTER_STr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_barrel_shifter_st))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_BARREL_SHIFTER_STr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_BARREL_SHIFTER_STr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_barrel_shifter_st))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_BARREL_SHIFTER_STr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_BARREL_SHIFTER_STr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_barrel_shifter_st))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_BARREL_SHIFTER_STr BCMI_TSCE16_XGXS_RX_X4_BARREL_SHIFTER_STr
#define RX_X4_BARREL_SHIFTER_STr_SIZE BCMI_TSCE16_XGXS_RX_X4_BARREL_SHIFTER_STr_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_BARREL_SHIFTER_STr_t RX_X4_BARREL_SHIFTER_STr_t;
#define RX_X4_BARREL_SHIFTER_STr_CLR BCMI_TSCE16_XGXS_RX_X4_BARREL_SHIFTER_STr_CLR
#define RX_X4_BARREL_SHIFTER_STr_SET BCMI_TSCE16_XGXS_RX_X4_BARREL_SHIFTER_STr_SET
#define RX_X4_BARREL_SHIFTER_STr_GET BCMI_TSCE16_XGXS_RX_X4_BARREL_SHIFTER_STr_GET
#define RX_X4_BARREL_SHIFTER_STr_SHIFT_AMMOUNTf_GET BCMI_TSCE16_XGXS_RX_X4_BARREL_SHIFTER_STr_SHIFT_AMMOUNTf_GET
#define RX_X4_BARREL_SHIFTER_STr_SHIFT_AMMOUNTf_SET BCMI_TSCE16_XGXS_RX_X4_BARREL_SHIFTER_STr_SHIFT_AMMOUNTf_SET
#define READ_RX_X4_BARREL_SHIFTER_STr BCMI_TSCE16_XGXS_READ_RX_X4_BARREL_SHIFTER_STr
#define WRITE_RX_X4_BARREL_SHIFTER_STr BCMI_TSCE16_XGXS_WRITE_RX_X4_BARREL_SHIFTER_STr
#define MODIFY_RX_X4_BARREL_SHIFTER_STr BCMI_TSCE16_XGXS_MODIFY_RX_X4_BARREL_SHIFTER_STr
#define READLN_RX_X4_BARREL_SHIFTER_STr BCMI_TSCE16_XGXS_READLN_RX_X4_BARREL_SHIFTER_STr
#define WRITELN_RX_X4_BARREL_SHIFTER_STr BCMI_TSCE16_XGXS_WRITELN_RX_X4_BARREL_SHIFTER_STr
#define WRITEALL_RX_X4_BARREL_SHIFTER_STr BCMI_TSCE16_XGXS_WRITEALL_RX_X4_BARREL_SHIFTER_STr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_BARREL_SHIFTER_STr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_CL49_LOCK_FSM_STS
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc145
 * DESC:     cl49_lock_fsm_status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LSM_CURR_STATE   Lock FSM - current stateLOCK_INIT:  lsm_state_coded_ = 2'b00;TEST_SH:    lsm_state_coded_ = 2'b01;TEST_SH2:   lsm_state_coded_ = 2'b10;default:    lsm_state_coded_ = 2'b11;
 *     LSM_HIS_STATE    Lock SM - latched states - latched on entryLOCK_INIT	3'b001 - Lock IntializationTEST_SH 	3'b010 - Test Sync Header - VALID_SH and INVALID_SH merged to this state.TEST_SH2	3'b100 - Test Sync Header 2 - for cl82
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_CL49_LOCK_FSM_STSr (0x0000c145 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_CL49_LOCK_FSM_STSr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL49_LOCK_FSM_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_CL49_LOCK_FSM_STSr_s {
	uint32_t v[1];
	uint32_t rx_x4_cl49_lock_fsm_sts[1];
	uint32_t _rx_x4_cl49_lock_fsm_sts;
} BCMI_TSCE16_XGXS_RX_X4_CL49_LOCK_FSM_STSr_t;

#define BCMI_TSCE16_XGXS_RX_X4_CL49_LOCK_FSM_STSr_CLR(r) (r).rx_x4_cl49_lock_fsm_sts[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_CL49_LOCK_FSM_STSr_SET(r,d) (r).rx_x4_cl49_lock_fsm_sts[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_CL49_LOCK_FSM_STSr_GET(r) (r).rx_x4_cl49_lock_fsm_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_CL49_LOCK_FSM_STSr_LSM_HIS_STATEf_GET(r) ((((r).rx_x4_cl49_lock_fsm_sts[0]) >> 2) & 0x7)
#define BCMI_TSCE16_XGXS_RX_X4_CL49_LOCK_FSM_STSr_LSM_HIS_STATEf_SET(r,f) (r).rx_x4_cl49_lock_fsm_sts[0]=(((r).rx_x4_cl49_lock_fsm_sts[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2)) | (7 << (16 + 2))
#define BCMI_TSCE16_XGXS_RX_X4_CL49_LOCK_FSM_STSr_LSM_CURR_STATEf_GET(r) (((r).rx_x4_cl49_lock_fsm_sts[0]) & 0x3)
#define BCMI_TSCE16_XGXS_RX_X4_CL49_LOCK_FSM_STSr_LSM_CURR_STATEf_SET(r,f) (r).rx_x4_cl49_lock_fsm_sts[0]=(((r).rx_x4_cl49_lock_fsm_sts[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access RX_X4_CL49_LOCK_FSM_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_CL49_LOCK_FSM_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_CL49_LOCK_FSM_STSr,(_r._rx_x4_cl49_lock_fsm_sts))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_CL49_LOCK_FSM_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_CL49_LOCK_FSM_STSr,(_r._rx_x4_cl49_lock_fsm_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_CL49_LOCK_FSM_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_CL49_LOCK_FSM_STSr,(_r._rx_x4_cl49_lock_fsm_sts))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_CL49_LOCK_FSM_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_CL49_LOCK_FSM_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl49_lock_fsm_sts))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_CL49_LOCK_FSM_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_CL49_LOCK_FSM_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl49_lock_fsm_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_CL49_LOCK_FSM_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_CL49_LOCK_FSM_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl49_lock_fsm_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL49_LOCK_FSM_STSr BCMI_TSCE16_XGXS_RX_X4_CL49_LOCK_FSM_STSr
#define RX_X4_CL49_LOCK_FSM_STSr_SIZE BCMI_TSCE16_XGXS_RX_X4_CL49_LOCK_FSM_STSr_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_CL49_LOCK_FSM_STSr_t RX_X4_CL49_LOCK_FSM_STSr_t;
#define RX_X4_CL49_LOCK_FSM_STSr_CLR BCMI_TSCE16_XGXS_RX_X4_CL49_LOCK_FSM_STSr_CLR
#define RX_X4_CL49_LOCK_FSM_STSr_SET BCMI_TSCE16_XGXS_RX_X4_CL49_LOCK_FSM_STSr_SET
#define RX_X4_CL49_LOCK_FSM_STSr_GET BCMI_TSCE16_XGXS_RX_X4_CL49_LOCK_FSM_STSr_GET
#define RX_X4_CL49_LOCK_FSM_STSr_LSM_HIS_STATEf_GET BCMI_TSCE16_XGXS_RX_X4_CL49_LOCK_FSM_STSr_LSM_HIS_STATEf_GET
#define RX_X4_CL49_LOCK_FSM_STSr_LSM_HIS_STATEf_SET BCMI_TSCE16_XGXS_RX_X4_CL49_LOCK_FSM_STSr_LSM_HIS_STATEf_SET
#define RX_X4_CL49_LOCK_FSM_STSr_LSM_CURR_STATEf_GET BCMI_TSCE16_XGXS_RX_X4_CL49_LOCK_FSM_STSr_LSM_CURR_STATEf_GET
#define RX_X4_CL49_LOCK_FSM_STSr_LSM_CURR_STATEf_SET BCMI_TSCE16_XGXS_RX_X4_CL49_LOCK_FSM_STSr_LSM_CURR_STATEf_SET
#define READ_RX_X4_CL49_LOCK_FSM_STSr BCMI_TSCE16_XGXS_READ_RX_X4_CL49_LOCK_FSM_STSr
#define WRITE_RX_X4_CL49_LOCK_FSM_STSr BCMI_TSCE16_XGXS_WRITE_RX_X4_CL49_LOCK_FSM_STSr
#define MODIFY_RX_X4_CL49_LOCK_FSM_STSr BCMI_TSCE16_XGXS_MODIFY_RX_X4_CL49_LOCK_FSM_STSr
#define READLN_RX_X4_CL49_LOCK_FSM_STSr BCMI_TSCE16_XGXS_READLN_RX_X4_CL49_LOCK_FSM_STSr
#define WRITELN_RX_X4_CL49_LOCK_FSM_STSr BCMI_TSCE16_XGXS_WRITELN_RX_X4_CL49_LOCK_FSM_STSr
#define WRITEALL_RX_X4_CL49_LOCK_FSM_STSr BCMI_TSCE16_XGXS_WRITEALL_RX_X4_CL49_LOCK_FSM_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_CL49_LOCK_FSM_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_DEC_STS0
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc146
 * DESC:     decode status 0 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL49_RXSM_CURRENT_STATE Recieve SM - current stateBits 2 1 0110 - RX_HIG_START101 - RX_LI100 - RX_E011 - RX_T010 - RX_D001 - RX_C000 - RX_INIT
 *     CL49_RXSM_HISTORY_STATE Receive SM - latched states - latched on entrybit 10 - RX_HIG_ENDbit 9 - RX_HIG_STARTbit 8 - RX_LIbit 7 - RX_Ebit 6 - RX_Tbit 5 - RX_Dbit 4 - RX_Cbit 3 - RX_INIT
 *     CL49_R_TYPE_CODED Receive SM - current r_typeBits 15:124'hF - BAD R_TYPE4'hB - R_TYPE_B04'hA - R_TYPE_OB4'h9 - R_TYPE_B14'h8 - R_TYPE_DB4'h7 - R_TYPE_FC4'h6 - R_TYPE_TB4'h5 - R_TYPE_LI4'h4 - R_TYPE_C4'h3 - R_TYPE_S4'h2 - R_TYPE_T4'h1 - R_TYPE_D4'h0 - R_TYPE_E
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS0r (0x0000c146 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_DEC_STS0.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_DEC_STS0r_s {
	uint32_t v[1];
	uint32_t rx_x4_dec_sts0[1];
	uint32_t _rx_x4_dec_sts0;
} BCMI_TSCE16_XGXS_RX_X4_DEC_STS0r_t;

#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS0r_CLR(r) (r).rx_x4_dec_sts0[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS0r_SET(r,d) (r).rx_x4_dec_sts0[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS0r_GET(r) (r).rx_x4_dec_sts0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS0r_CL49_R_TYPE_CODEDf_GET(r) ((((r).rx_x4_dec_sts0[0]) >> 12) & 0xf)
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS0r_CL49_R_TYPE_CODEDf_SET(r,f) (r).rx_x4_dec_sts0[0]=(((r).rx_x4_dec_sts0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS0r_CL49_RXSM_HISTORY_STATEf_GET(r) ((((r).rx_x4_dec_sts0[0]) >> 3) & 0xff)
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS0r_CL49_RXSM_HISTORY_STATEf_SET(r,f) (r).rx_x4_dec_sts0[0]=(((r).rx_x4_dec_sts0[0] & ~((uint32_t)0xff << 3)) | ((((uint32_t)f) & 0xff) << 3)) | (255 << (16 + 3))
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS0r_CL49_RXSM_CURRENT_STATEf_GET(r) (((r).rx_x4_dec_sts0[0]) & 0x7)
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS0r_CL49_RXSM_CURRENT_STATEf_SET(r,f) (r).rx_x4_dec_sts0[0]=(((r).rx_x4_dec_sts0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access RX_X4_DEC_STS0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_DEC_STS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS0r,(_r._rx_x4_dec_sts0))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_DEC_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS0r,(_r._rx_x4_dec_sts0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_DEC_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS0r,(_r._rx_x4_dec_sts0))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_DEC_STS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_dec_sts0))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_DEC_STS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_dec_sts0))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_DEC_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_dec_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_DEC_STS0r BCMI_TSCE16_XGXS_RX_X4_DEC_STS0r
#define RX_X4_DEC_STS0r_SIZE BCMI_TSCE16_XGXS_RX_X4_DEC_STS0r_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_DEC_STS0r_t RX_X4_DEC_STS0r_t;
#define RX_X4_DEC_STS0r_CLR BCMI_TSCE16_XGXS_RX_X4_DEC_STS0r_CLR
#define RX_X4_DEC_STS0r_SET BCMI_TSCE16_XGXS_RX_X4_DEC_STS0r_SET
#define RX_X4_DEC_STS0r_GET BCMI_TSCE16_XGXS_RX_X4_DEC_STS0r_GET
#define RX_X4_DEC_STS0r_CL49_R_TYPE_CODEDf_GET BCMI_TSCE16_XGXS_RX_X4_DEC_STS0r_CL49_R_TYPE_CODEDf_GET
#define RX_X4_DEC_STS0r_CL49_R_TYPE_CODEDf_SET BCMI_TSCE16_XGXS_RX_X4_DEC_STS0r_CL49_R_TYPE_CODEDf_SET
#define RX_X4_DEC_STS0r_CL49_RXSM_HISTORY_STATEf_GET BCMI_TSCE16_XGXS_RX_X4_DEC_STS0r_CL49_RXSM_HISTORY_STATEf_GET
#define RX_X4_DEC_STS0r_CL49_RXSM_HISTORY_STATEf_SET BCMI_TSCE16_XGXS_RX_X4_DEC_STS0r_CL49_RXSM_HISTORY_STATEf_SET
#define RX_X4_DEC_STS0r_CL49_RXSM_CURRENT_STATEf_GET BCMI_TSCE16_XGXS_RX_X4_DEC_STS0r_CL49_RXSM_CURRENT_STATEf_GET
#define RX_X4_DEC_STS0r_CL49_RXSM_CURRENT_STATEf_SET BCMI_TSCE16_XGXS_RX_X4_DEC_STS0r_CL49_RXSM_CURRENT_STATEf_SET
#define READ_RX_X4_DEC_STS0r BCMI_TSCE16_XGXS_READ_RX_X4_DEC_STS0r
#define WRITE_RX_X4_DEC_STS0r BCMI_TSCE16_XGXS_WRITE_RX_X4_DEC_STS0r
#define MODIFY_RX_X4_DEC_STS0r BCMI_TSCE16_XGXS_MODIFY_RX_X4_DEC_STS0r
#define READLN_RX_X4_DEC_STS0r BCMI_TSCE16_XGXS_READLN_RX_X4_DEC_STS0r
#define WRITELN_RX_X4_DEC_STS0r BCMI_TSCE16_XGXS_WRITELN_RX_X4_DEC_STS0r
#define WRITEALL_RX_X4_DEC_STS0r BCMI_TSCE16_XGXS_WRITEALL_RX_X4_DEC_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_DEC_STS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_DEC_STS1
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc147
 * DESC:     decode status 1 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL49_BERMON_CURRENT_STATE BER Monitor fsm - current statebit 4 - HI_BERbit 3 - GOOD_BERbit 2 - BER_TEST_SHbit 1 - START_TIMERbit 0 - BER_MT_INIT
 *     CL49_BERMON_HISTORY_STATE BER Monitor fsm - latched states - latched on entry5'b10000 - HI_BER5'b01000 - GOOD_BER5'b00100 - BER_TEST_SH5'b00010 - START_TIMER5'b00001 - BER_MT_INIT
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS1r (0x0000c147 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_DEC_STS1.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_DEC_STS1r_s {
	uint32_t v[1];
	uint32_t rx_x4_dec_sts1[1];
	uint32_t _rx_x4_dec_sts1;
} BCMI_TSCE16_XGXS_RX_X4_DEC_STS1r_t;

#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS1r_CLR(r) (r).rx_x4_dec_sts1[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS1r_SET(r,d) (r).rx_x4_dec_sts1[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS1r_GET(r) (r).rx_x4_dec_sts1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS1r_CL49_BERMON_HISTORY_STATEf_GET(r) ((((r).rx_x4_dec_sts1[0]) >> 5) & 0x1f)
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS1r_CL49_BERMON_HISTORY_STATEf_SET(r,f) (r).rx_x4_dec_sts1[0]=(((r).rx_x4_dec_sts1[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS1r_CL49_BERMON_CURRENT_STATEf_GET(r) (((r).rx_x4_dec_sts1[0]) & 0x1f)
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS1r_CL49_BERMON_CURRENT_STATEf_SET(r,f) (r).rx_x4_dec_sts1[0]=(((r).rx_x4_dec_sts1[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access RX_X4_DEC_STS1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_DEC_STS1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS1r,(_r._rx_x4_dec_sts1))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_DEC_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS1r,(_r._rx_x4_dec_sts1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_DEC_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS1r,(_r._rx_x4_dec_sts1))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_DEC_STS1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_dec_sts1))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_DEC_STS1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_dec_sts1))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_DEC_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_dec_sts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_DEC_STS1r BCMI_TSCE16_XGXS_RX_X4_DEC_STS1r
#define RX_X4_DEC_STS1r_SIZE BCMI_TSCE16_XGXS_RX_X4_DEC_STS1r_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_DEC_STS1r_t RX_X4_DEC_STS1r_t;
#define RX_X4_DEC_STS1r_CLR BCMI_TSCE16_XGXS_RX_X4_DEC_STS1r_CLR
#define RX_X4_DEC_STS1r_SET BCMI_TSCE16_XGXS_RX_X4_DEC_STS1r_SET
#define RX_X4_DEC_STS1r_GET BCMI_TSCE16_XGXS_RX_X4_DEC_STS1r_GET
#define RX_X4_DEC_STS1r_CL49_BERMON_HISTORY_STATEf_GET BCMI_TSCE16_XGXS_RX_X4_DEC_STS1r_CL49_BERMON_HISTORY_STATEf_GET
#define RX_X4_DEC_STS1r_CL49_BERMON_HISTORY_STATEf_SET BCMI_TSCE16_XGXS_RX_X4_DEC_STS1r_CL49_BERMON_HISTORY_STATEf_SET
#define RX_X4_DEC_STS1r_CL49_BERMON_CURRENT_STATEf_GET BCMI_TSCE16_XGXS_RX_X4_DEC_STS1r_CL49_BERMON_CURRENT_STATEf_GET
#define RX_X4_DEC_STS1r_CL49_BERMON_CURRENT_STATEf_SET BCMI_TSCE16_XGXS_RX_X4_DEC_STS1r_CL49_BERMON_CURRENT_STATEf_SET
#define READ_RX_X4_DEC_STS1r BCMI_TSCE16_XGXS_READ_RX_X4_DEC_STS1r
#define WRITE_RX_X4_DEC_STS1r BCMI_TSCE16_XGXS_WRITE_RX_X4_DEC_STS1r
#define MODIFY_RX_X4_DEC_STS1r BCMI_TSCE16_XGXS_MODIFY_RX_X4_DEC_STS1r
#define READLN_RX_X4_DEC_STS1r BCMI_TSCE16_XGXS_READLN_RX_X4_DEC_STS1r
#define WRITELN_RX_X4_DEC_STS1r BCMI_TSCE16_XGXS_WRITELN_RX_X4_DEC_STS1r
#define WRITEALL_RX_X4_DEC_STS1r BCMI_TSCE16_XGXS_WRITEALL_RX_X4_DEC_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_DEC_STS1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_DEC_STS2
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc148
 * DESC:     scw & K-code group error counters
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     KCODE66ERRCOUNT  64/66 decode k code group error countclear-on-read
 *     SYNC66ERRCOUNT   64/66 decode sync error countclear-on-read
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS2r (0x0000c148 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_DEC_STS2.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_DEC_STS2r_s {
	uint32_t v[1];
	uint32_t rx_x4_dec_sts2[1];
	uint32_t _rx_x4_dec_sts2;
} BCMI_TSCE16_XGXS_RX_X4_DEC_STS2r_t;

#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS2r_CLR(r) (r).rx_x4_dec_sts2[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS2r_SET(r,d) (r).rx_x4_dec_sts2[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS2r_GET(r) (r).rx_x4_dec_sts2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS2r_SYNC66ERRCOUNTf_GET(r) ((((r).rx_x4_dec_sts2[0]) >> 8) & 0xff)
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS2r_SYNC66ERRCOUNTf_SET(r,f) (r).rx_x4_dec_sts2[0]=(((r).rx_x4_dec_sts2[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS2r_KCODE66ERRCOUNTf_GET(r) (((r).rx_x4_dec_sts2[0]) & 0xff)
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS2r_KCODE66ERRCOUNTf_SET(r,f) (r).rx_x4_dec_sts2[0]=(((r).rx_x4_dec_sts2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access RX_X4_DEC_STS2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_DEC_STS2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS2r,(_r._rx_x4_dec_sts2))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_DEC_STS2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS2r,(_r._rx_x4_dec_sts2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_DEC_STS2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS2r,(_r._rx_x4_dec_sts2))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_DEC_STS2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_dec_sts2))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_DEC_STS2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_dec_sts2))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_DEC_STS2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_dec_sts2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_DEC_STS2r BCMI_TSCE16_XGXS_RX_X4_DEC_STS2r
#define RX_X4_DEC_STS2r_SIZE BCMI_TSCE16_XGXS_RX_X4_DEC_STS2r_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_DEC_STS2r_t RX_X4_DEC_STS2r_t;
#define RX_X4_DEC_STS2r_CLR BCMI_TSCE16_XGXS_RX_X4_DEC_STS2r_CLR
#define RX_X4_DEC_STS2r_SET BCMI_TSCE16_XGXS_RX_X4_DEC_STS2r_SET
#define RX_X4_DEC_STS2r_GET BCMI_TSCE16_XGXS_RX_X4_DEC_STS2r_GET
#define RX_X4_DEC_STS2r_SYNC66ERRCOUNTf_GET BCMI_TSCE16_XGXS_RX_X4_DEC_STS2r_SYNC66ERRCOUNTf_GET
#define RX_X4_DEC_STS2r_SYNC66ERRCOUNTf_SET BCMI_TSCE16_XGXS_RX_X4_DEC_STS2r_SYNC66ERRCOUNTf_SET
#define RX_X4_DEC_STS2r_KCODE66ERRCOUNTf_GET BCMI_TSCE16_XGXS_RX_X4_DEC_STS2r_KCODE66ERRCOUNTf_GET
#define RX_X4_DEC_STS2r_KCODE66ERRCOUNTf_SET BCMI_TSCE16_XGXS_RX_X4_DEC_STS2r_KCODE66ERRCOUNTf_SET
#define READ_RX_X4_DEC_STS2r BCMI_TSCE16_XGXS_READ_RX_X4_DEC_STS2r
#define WRITE_RX_X4_DEC_STS2r BCMI_TSCE16_XGXS_WRITE_RX_X4_DEC_STS2r
#define MODIFY_RX_X4_DEC_STS2r BCMI_TSCE16_XGXS_MODIFY_RX_X4_DEC_STS2r
#define READLN_RX_X4_DEC_STS2r BCMI_TSCE16_XGXS_READLN_RX_X4_DEC_STS2r
#define WRITELN_RX_X4_DEC_STS2r BCMI_TSCE16_XGXS_WRITELN_RX_X4_DEC_STS2r
#define WRITEALL_RX_X4_DEC_STS2r BCMI_TSCE16_XGXS_WRITEALL_RX_X4_DEC_STS2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_DEC_STS2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_DEC_STS3
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc149
 * DESC:     decode status 3 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL49IEEE_ERRORED_BLOCKS Contains the count of the errored blocks decoded by the cl49/cl82 decoders.For cl82, it contains the lower 8 bits of the 22 bit value. The upper 14 bits are present in the ieee pcs2 register.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS3r (0x0000c149 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS3r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_DEC_STS3.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_DEC_STS3r_s {
	uint32_t v[1];
	uint32_t rx_x4_dec_sts3[1];
	uint32_t _rx_x4_dec_sts3;
} BCMI_TSCE16_XGXS_RX_X4_DEC_STS3r_t;

#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS3r_CLR(r) (r).rx_x4_dec_sts3[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS3r_SET(r,d) (r).rx_x4_dec_sts3[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS3r_GET(r) (r).rx_x4_dec_sts3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS3r_CL49IEEE_ERRORED_BLOCKSf_GET(r) ((((r).rx_x4_dec_sts3[0]) >> 2) & 0xff)
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS3r_CL49IEEE_ERRORED_BLOCKSf_SET(r,f) (r).rx_x4_dec_sts3[0]=(((r).rx_x4_dec_sts3[0] & ~((uint32_t)0xff << 2)) | ((((uint32_t)f) & 0xff) << 2)) | (255 << (16 + 2))

/*
 * These macros can be used to access RX_X4_DEC_STS3.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_DEC_STS3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS3r,(_r._rx_x4_dec_sts3))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_DEC_STS3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS3r,(_r._rx_x4_dec_sts3)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_DEC_STS3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS3r,(_r._rx_x4_dec_sts3))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_DEC_STS3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_dec_sts3))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_DEC_STS3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_dec_sts3))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_DEC_STS3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_dec_sts3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_DEC_STS3r BCMI_TSCE16_XGXS_RX_X4_DEC_STS3r
#define RX_X4_DEC_STS3r_SIZE BCMI_TSCE16_XGXS_RX_X4_DEC_STS3r_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_DEC_STS3r_t RX_X4_DEC_STS3r_t;
#define RX_X4_DEC_STS3r_CLR BCMI_TSCE16_XGXS_RX_X4_DEC_STS3r_CLR
#define RX_X4_DEC_STS3r_SET BCMI_TSCE16_XGXS_RX_X4_DEC_STS3r_SET
#define RX_X4_DEC_STS3r_GET BCMI_TSCE16_XGXS_RX_X4_DEC_STS3r_GET
#define RX_X4_DEC_STS3r_CL49IEEE_ERRORED_BLOCKSf_GET BCMI_TSCE16_XGXS_RX_X4_DEC_STS3r_CL49IEEE_ERRORED_BLOCKSf_GET
#define RX_X4_DEC_STS3r_CL49IEEE_ERRORED_BLOCKSf_SET BCMI_TSCE16_XGXS_RX_X4_DEC_STS3r_CL49IEEE_ERRORED_BLOCKSf_SET
#define READ_RX_X4_DEC_STS3r BCMI_TSCE16_XGXS_READ_RX_X4_DEC_STS3r
#define WRITE_RX_X4_DEC_STS3r BCMI_TSCE16_XGXS_WRITE_RX_X4_DEC_STS3r
#define MODIFY_RX_X4_DEC_STS3r BCMI_TSCE16_XGXS_MODIFY_RX_X4_DEC_STS3r
#define READLN_RX_X4_DEC_STS3r BCMI_TSCE16_XGXS_READLN_RX_X4_DEC_STS3r
#define WRITELN_RX_X4_DEC_STS3r BCMI_TSCE16_XGXS_WRITELN_RX_X4_DEC_STS3r
#define WRITEALL_RX_X4_DEC_STS3r BCMI_TSCE16_XGXS_WRITEALL_RX_X4_DEC_STS3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_DEC_STS3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_DEC_STS4
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc14a
 * DESC:     decode status 4 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL48_SYNCACQ_STATE_L Latched version of the state of the cl48 sync acquisition state machinebit 0  - LOSS_OF_SYNC_BITbit 1  - COMMA_DET_1_BITbit 2  - COMMA_DET_2_BITbit 3  - COMMA_DET_3_BITbit 4  - SYNC_ACQ_1_BITbit 5  - SYNC_ACQ_2_BITbit 6  - SYNC_ACQ_3_BITbit 7  - SYNC_ACQ_4_BITbit 8  - SYNC_ACQ_2A_BITbit 9  - SYNC_ACQ_3A_BITbit 10 - SYNC_ACQ_4A_BIT
 *     B66DEC_FAULT_DET It is the latched version of a local/remote fault detect bit
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS4r (0x0000c14a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS4r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_DEC_STS4.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_DEC_STS4r_s {
	uint32_t v[1];
	uint32_t rx_x4_dec_sts4[1];
	uint32_t _rx_x4_dec_sts4;
} BCMI_TSCE16_XGXS_RX_X4_DEC_STS4r_t;

#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS4r_CLR(r) (r).rx_x4_dec_sts4[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS4r_SET(r,d) (r).rx_x4_dec_sts4[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS4r_GET(r) (r).rx_x4_dec_sts4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS4r_B66DEC_FAULT_DETf_GET(r) ((((r).rx_x4_dec_sts4[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS4r_B66DEC_FAULT_DETf_SET(r,f) (r).rx_x4_dec_sts4[0]=(((r).rx_x4_dec_sts4[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS4r_CL48_SYNCACQ_STATE_Lf_GET(r) ((((r).rx_x4_dec_sts4[0]) >> 4) & 0x7ff)
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS4r_CL48_SYNCACQ_STATE_Lf_SET(r,f) (r).rx_x4_dec_sts4[0]=(((r).rx_x4_dec_sts4[0] & ~((uint32_t)0x7ff << 4)) | ((((uint32_t)f) & 0x7ff) << 4)) | (2047 << (16 + 4))

/*
 * These macros can be used to access RX_X4_DEC_STS4.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_DEC_STS4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS4r,(_r._rx_x4_dec_sts4))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_DEC_STS4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS4r,(_r._rx_x4_dec_sts4)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_DEC_STS4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS4r,(_r._rx_x4_dec_sts4))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_DEC_STS4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_dec_sts4))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_DEC_STS4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_dec_sts4))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_DEC_STS4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_dec_sts4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_DEC_STS4r BCMI_TSCE16_XGXS_RX_X4_DEC_STS4r
#define RX_X4_DEC_STS4r_SIZE BCMI_TSCE16_XGXS_RX_X4_DEC_STS4r_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_DEC_STS4r_t RX_X4_DEC_STS4r_t;
#define RX_X4_DEC_STS4r_CLR BCMI_TSCE16_XGXS_RX_X4_DEC_STS4r_CLR
#define RX_X4_DEC_STS4r_SET BCMI_TSCE16_XGXS_RX_X4_DEC_STS4r_SET
#define RX_X4_DEC_STS4r_GET BCMI_TSCE16_XGXS_RX_X4_DEC_STS4r_GET
#define RX_X4_DEC_STS4r_B66DEC_FAULT_DETf_GET BCMI_TSCE16_XGXS_RX_X4_DEC_STS4r_B66DEC_FAULT_DETf_GET
#define RX_X4_DEC_STS4r_B66DEC_FAULT_DETf_SET BCMI_TSCE16_XGXS_RX_X4_DEC_STS4r_B66DEC_FAULT_DETf_SET
#define RX_X4_DEC_STS4r_CL48_SYNCACQ_STATE_Lf_GET BCMI_TSCE16_XGXS_RX_X4_DEC_STS4r_CL48_SYNCACQ_STATE_Lf_GET
#define RX_X4_DEC_STS4r_CL48_SYNCACQ_STATE_Lf_SET BCMI_TSCE16_XGXS_RX_X4_DEC_STS4r_CL48_SYNCACQ_STATE_Lf_SET
#define READ_RX_X4_DEC_STS4r BCMI_TSCE16_XGXS_READ_RX_X4_DEC_STS4r
#define WRITE_RX_X4_DEC_STS4r BCMI_TSCE16_XGXS_WRITE_RX_X4_DEC_STS4r
#define MODIFY_RX_X4_DEC_STS4r BCMI_TSCE16_XGXS_MODIFY_RX_X4_DEC_STS4r
#define READLN_RX_X4_DEC_STS4r BCMI_TSCE16_XGXS_READLN_RX_X4_DEC_STS4r
#define WRITELN_RX_X4_DEC_STS4r BCMI_TSCE16_XGXS_WRITELN_RX_X4_DEC_STS4r
#define WRITEALL_RX_X4_DEC_STS4r BCMI_TSCE16_XGXS_WRITEALL_RX_X4_DEC_STS4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_DEC_STS4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_DEC_STS5
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc14b
 * DESC:     decode status 5 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL48_SYNCACQ_STATE_D_3 Live version of the state of the cl48 sync acquisition state machine for bytes 6 and 74'd0  - LOSS_OF_SYNC_BIT4'd1  - COMMA_DET_1_BIT4'd2  - COMMA_DET_2_BIT4'd3  - COMMA_DET_3_BIT4'd4  - SYNC_ACQ_1_BIT4'd5  - SYNC_ACQ_2_BIT4'd6  - SYNC_ACQ_3_BIT4'd7  - SYNC_ACQ_4_BIT4'd8  - SYNC_ACQ_2A_BIT4'd9  - SYNC_ACQ_3A_BIT4'd10 - SYNC_ACQ_4A_BIT
 *     CL48_SYNCACQ_STATE_D_2 Live version of the state of the cl48 sync acquisition state machine for bytes 4 and 54'd0  - LOSS_OF_SYNC_BIT4'd1  - COMMA_DET_1_BIT4'd2  - COMMA_DET_2_BIT4'd3  - COMMA_DET_3_BIT4'd4  - SYNC_ACQ_1_BIT4'd5  - SYNC_ACQ_2_BIT4'd6  - SYNC_ACQ_3_BIT4'd7  - SYNC_ACQ_4_BIT4'd8  - SYNC_ACQ_2A_BIT4'd9  - SYNC_ACQ_3A_BIT4'd10 - SYNC_ACQ_4A_BIT
 *     CL48_SYNCACQ_STATE_D_1 Live version of the state of the cl48 sync acquisition state machine for bytes 2 and 34'd0  - LOSS_OF_SYNC_BIT4'd1  - COMMA_DET_1_BIT4'd2  - COMMA_DET_2_BIT4'd3  - COMMA_DET_3_BIT4'd4  - SYNC_ACQ_1_BIT4'd5  - SYNC_ACQ_2_BIT4'd6  - SYNC_ACQ_3_BIT4'd7  - SYNC_ACQ_4_BIT4'd8  - SYNC_ACQ_2A_BIT4'd9  - SYNC_ACQ_3A_BIT4'd10 - SYNC_ACQ_4A_BIT
 *     CL48_SYNCACQ_STATE_D_0 Live version of the state of the cl48 sync acquisition state machine for bytes 0 and 14'd0  - LOSS_OF_SYNC_BIT4'd1  - COMMA_DET_1_BIT4'd2  - COMMA_DET_2_BIT4'd3  - COMMA_DET_3_BIT4'd4  - SYNC_ACQ_1_BIT4'd5  - SYNC_ACQ_2_BIT4'd6  - SYNC_ACQ_3_BIT4'd7  - SYNC_ACQ_4_BIT4'd8  - SYNC_ACQ_2A_BIT4'd9  - SYNC_ACQ_3A_BIT4'd10 - SYNC_ACQ_4A_BIT
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r (0x0000c14b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_DEC_STS5.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r_s {
	uint32_t v[1];
	uint32_t rx_x4_dec_sts5[1];
	uint32_t _rx_x4_dec_sts5;
} BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r_t;

#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r_CLR(r) (r).rx_x4_dec_sts5[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r_SET(r,d) (r).rx_x4_dec_sts5[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r_GET(r) (r).rx_x4_dec_sts5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r_CL48_SYNCACQ_STATE_D_0f_GET(r) ((((r).rx_x4_dec_sts5[0]) >> 12) & 0xf)
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r_CL48_SYNCACQ_STATE_D_0f_SET(r,f) (r).rx_x4_dec_sts5[0]=(((r).rx_x4_dec_sts5[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r_CL48_SYNCACQ_STATE_D_1f_GET(r) ((((r).rx_x4_dec_sts5[0]) >> 8) & 0xf)
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r_CL48_SYNCACQ_STATE_D_1f_SET(r,f) (r).rx_x4_dec_sts5[0]=(((r).rx_x4_dec_sts5[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r_CL48_SYNCACQ_STATE_D_2f_GET(r) ((((r).rx_x4_dec_sts5[0]) >> 4) & 0xf)
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r_CL48_SYNCACQ_STATE_D_2f_SET(r,f) (r).rx_x4_dec_sts5[0]=(((r).rx_x4_dec_sts5[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r_CL48_SYNCACQ_STATE_D_3f_GET(r) (((r).rx_x4_dec_sts5[0]) & 0xf)
#define BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r_CL48_SYNCACQ_STATE_D_3f_SET(r,f) (r).rx_x4_dec_sts5[0]=(((r).rx_x4_dec_sts5[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access RX_X4_DEC_STS5.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_DEC_STS5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r,(_r._rx_x4_dec_sts5))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_DEC_STS5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r,(_r._rx_x4_dec_sts5)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_DEC_STS5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r,(_r._rx_x4_dec_sts5))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_DEC_STS5r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_dec_sts5))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_DEC_STS5r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_dec_sts5))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_DEC_STS5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_dec_sts5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_DEC_STS5r BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r
#define RX_X4_DEC_STS5r_SIZE BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r_t RX_X4_DEC_STS5r_t;
#define RX_X4_DEC_STS5r_CLR BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r_CLR
#define RX_X4_DEC_STS5r_SET BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r_SET
#define RX_X4_DEC_STS5r_GET BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r_GET
#define RX_X4_DEC_STS5r_CL48_SYNCACQ_STATE_D_0f_GET BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r_CL48_SYNCACQ_STATE_D_0f_GET
#define RX_X4_DEC_STS5r_CL48_SYNCACQ_STATE_D_0f_SET BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r_CL48_SYNCACQ_STATE_D_0f_SET
#define RX_X4_DEC_STS5r_CL48_SYNCACQ_STATE_D_1f_GET BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r_CL48_SYNCACQ_STATE_D_1f_GET
#define RX_X4_DEC_STS5r_CL48_SYNCACQ_STATE_D_1f_SET BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r_CL48_SYNCACQ_STATE_D_1f_SET
#define RX_X4_DEC_STS5r_CL48_SYNCACQ_STATE_D_2f_GET BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r_CL48_SYNCACQ_STATE_D_2f_GET
#define RX_X4_DEC_STS5r_CL48_SYNCACQ_STATE_D_2f_SET BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r_CL48_SYNCACQ_STATE_D_2f_SET
#define RX_X4_DEC_STS5r_CL48_SYNCACQ_STATE_D_3f_GET BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r_CL48_SYNCACQ_STATE_D_3f_GET
#define RX_X4_DEC_STS5r_CL48_SYNCACQ_STATE_D_3f_SET BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r_CL48_SYNCACQ_STATE_D_3f_SET
#define READ_RX_X4_DEC_STS5r BCMI_TSCE16_XGXS_READ_RX_X4_DEC_STS5r
#define WRITE_RX_X4_DEC_STS5r BCMI_TSCE16_XGXS_WRITE_RX_X4_DEC_STS5r
#define MODIFY_RX_X4_DEC_STS5r BCMI_TSCE16_XGXS_MODIFY_RX_X4_DEC_STS5r
#define READLN_RX_X4_DEC_STS5r BCMI_TSCE16_XGXS_READLN_RX_X4_DEC_STS5r
#define WRITELN_RX_X4_DEC_STS5r BCMI_TSCE16_XGXS_WRITELN_RX_X4_DEC_STS5r
#define WRITEALL_RX_X4_DEC_STS5r BCMI_TSCE16_XGXS_WRITEALL_RX_X4_DEC_STS5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_DEC_STS5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_SYNCACQ_STS0
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc14c
 * DESC:     syncacq_status_0 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL36_SYNCACQ_STATE_CODED_PER_LN cl36 sync acquisition fsm - next state4'd0 - LOSS_OF_SYNC4'd1 - COMMA_DET_14'd2 - ACQ_SYNC_14'd3 - COMMA_DET_24'd4 - ACQ_SYNC_24'd5 - COMMA_DET_34'd6 - SYNC_ACQ_14'd7 - SYNC_ACQ_24'd8 - SYNC_ACQ_34'd9 - SYNC_ACQ_44'd10 - SYNC_ACQ_2A4'd11 - SYNC_ACQ_3A4'd12 - SYNC_ACQ_4A
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS0r (0x0000c14c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_SYNCACQ_STS0.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS0r_s {
	uint32_t v[1];
	uint32_t rx_x4_syncacq_sts0[1];
	uint32_t _rx_x4_syncacq_sts0;
} BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS0r_t;

#define BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS0r_CLR(r) (r).rx_x4_syncacq_sts0[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS0r_SET(r,d) (r).rx_x4_syncacq_sts0[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS0r_GET(r) (r).rx_x4_syncacq_sts0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS0r_CL36_SYNCACQ_STATE_CODED_PER_LNf_GET(r) (((r).rx_x4_syncacq_sts0[0]) & 0xf)
#define BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS0r_CL36_SYNCACQ_STATE_CODED_PER_LNf_SET(r,f) (r).rx_x4_syncacq_sts0[0]=(((r).rx_x4_syncacq_sts0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access RX_X4_SYNCACQ_STS0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_SYNCACQ_STS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS0r,(_r._rx_x4_syncacq_sts0))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_SYNCACQ_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS0r,(_r._rx_x4_syncacq_sts0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_SYNCACQ_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS0r,(_r._rx_x4_syncacq_sts0))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_SYNCACQ_STS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_syncacq_sts0))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_SYNCACQ_STS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_syncacq_sts0))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_SYNCACQ_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_syncacq_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_SYNCACQ_STS0r BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS0r
#define RX_X4_SYNCACQ_STS0r_SIZE BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS0r_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS0r_t RX_X4_SYNCACQ_STS0r_t;
#define RX_X4_SYNCACQ_STS0r_CLR BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS0r_CLR
#define RX_X4_SYNCACQ_STS0r_SET BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS0r_SET
#define RX_X4_SYNCACQ_STS0r_GET BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS0r_GET
#define RX_X4_SYNCACQ_STS0r_CL36_SYNCACQ_STATE_CODED_PER_LNf_GET BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS0r_CL36_SYNCACQ_STATE_CODED_PER_LNf_GET
#define RX_X4_SYNCACQ_STS0r_CL36_SYNCACQ_STATE_CODED_PER_LNf_SET BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS0r_CL36_SYNCACQ_STATE_CODED_PER_LNf_SET
#define READ_RX_X4_SYNCACQ_STS0r BCMI_TSCE16_XGXS_READ_RX_X4_SYNCACQ_STS0r
#define WRITE_RX_X4_SYNCACQ_STS0r BCMI_TSCE16_XGXS_WRITE_RX_X4_SYNCACQ_STS0r
#define MODIFY_RX_X4_SYNCACQ_STS0r BCMI_TSCE16_XGXS_MODIFY_RX_X4_SYNCACQ_STS0r
#define READLN_RX_X4_SYNCACQ_STS0r BCMI_TSCE16_XGXS_READLN_RX_X4_SYNCACQ_STS0r
#define WRITELN_RX_X4_SYNCACQ_STS0r BCMI_TSCE16_XGXS_WRITELN_RX_X4_SYNCACQ_STS0r
#define WRITEALL_RX_X4_SYNCACQ_STS0r BCMI_TSCE16_XGXS_WRITEALL_RX_X4_SYNCACQ_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_SYNCACQ_STS1
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc14d
 * DESC:     syncacq_status_1 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL36_SYNCACQ_HIS_STATE_PER_LN bit 0 - LOSS_OF_SYNCbit 1 - COMMA_DET_1bit 2 - ACQ_SYNC_1bit 3 - COMMA_DET_2bit 4 - ACQ_SYNC_2bit 5 - COMMA_DET_3bit 6 - SYNC_ACQ_1bit 7 - SYNC_ACQ_2bit 8 - SYNC_ACQ_3bit 9 - SYNC_ACQ_4bit 10 - SYNC_ACQ_2Abit 11 - SYNC_ACQ_3Abit 12 - SYNC_ACQ_4A
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS1r (0x0000c14d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_SYNCACQ_STS1.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS1r_s {
	uint32_t v[1];
	uint32_t rx_x4_syncacq_sts1[1];
	uint32_t _rx_x4_syncacq_sts1;
} BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS1r_t;

#define BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS1r_CLR(r) (r).rx_x4_syncacq_sts1[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS1r_SET(r,d) (r).rx_x4_syncacq_sts1[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS1r_GET(r) (r).rx_x4_syncacq_sts1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS1r_CL36_SYNCACQ_HIS_STATE_PER_LNf_GET(r) (((r).rx_x4_syncacq_sts1[0]) & 0x1fff)
#define BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS1r_CL36_SYNCACQ_HIS_STATE_PER_LNf_SET(r,f) (r).rx_x4_syncacq_sts1[0]=(((r).rx_x4_syncacq_sts1[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access RX_X4_SYNCACQ_STS1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_SYNCACQ_STS1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS1r,(_r._rx_x4_syncacq_sts1))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_SYNCACQ_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS1r,(_r._rx_x4_syncacq_sts1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_SYNCACQ_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS1r,(_r._rx_x4_syncacq_sts1))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_SYNCACQ_STS1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_syncacq_sts1))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_SYNCACQ_STS1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_syncacq_sts1))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_SYNCACQ_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_syncacq_sts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_SYNCACQ_STS1r BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS1r
#define RX_X4_SYNCACQ_STS1r_SIZE BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS1r_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS1r_t RX_X4_SYNCACQ_STS1r_t;
#define RX_X4_SYNCACQ_STS1r_CLR BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS1r_CLR
#define RX_X4_SYNCACQ_STS1r_SET BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS1r_SET
#define RX_X4_SYNCACQ_STS1r_GET BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS1r_GET
#define RX_X4_SYNCACQ_STS1r_CL36_SYNCACQ_HIS_STATE_PER_LNf_GET BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS1r_CL36_SYNCACQ_HIS_STATE_PER_LNf_GET
#define RX_X4_SYNCACQ_STS1r_CL36_SYNCACQ_HIS_STATE_PER_LNf_SET BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS1r_CL36_SYNCACQ_HIS_STATE_PER_LNf_SET
#define READ_RX_X4_SYNCACQ_STS1r BCMI_TSCE16_XGXS_READ_RX_X4_SYNCACQ_STS1r
#define WRITE_RX_X4_SYNCACQ_STS1r BCMI_TSCE16_XGXS_WRITE_RX_X4_SYNCACQ_STS1r
#define MODIFY_RX_X4_SYNCACQ_STS1r BCMI_TSCE16_XGXS_MODIFY_RX_X4_SYNCACQ_STS1r
#define READLN_RX_X4_SYNCACQ_STS1r BCMI_TSCE16_XGXS_READLN_RX_X4_SYNCACQ_STS1r
#define WRITELN_RX_X4_SYNCACQ_STS1r BCMI_TSCE16_XGXS_WRITELN_RX_X4_SYNCACQ_STS1r
#define WRITEALL_RX_X4_SYNCACQ_STS1r BCMI_TSCE16_XGXS_WRITEALL_RX_X4_SYNCACQ_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_SYNCACQ_STS1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_BERCNT
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc14e
 * DESC:     bercount register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BER_COUNT_PER_LN For cl82 - This field is the lower 8 bit of the 22 bit BER count.For cl49 - This field is the 8 bit BER count.For cl36 - This field is the 8b/10b symbol error counter that increments1. upon detecting symbol error (due to invalid symbol or disparity error)2. when comma aligns on the wrong boundaryThe error conditions are detected only when cl36 sync_status is asserted.The counter saturates at 8'hFF and clears on read.
 *     BIP_ERROR_COUNT_PER_LANE CL82 BIP error count.Saturates at 8'hFF. Clear on read.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_BERCNTr (0x0000c14e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_BERCNTr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_BERCNT.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_BERCNTr_s {
	uint32_t v[1];
	uint32_t rx_x4_bercnt[1];
	uint32_t _rx_x4_bercnt;
} BCMI_TSCE16_XGXS_RX_X4_BERCNTr_t;

#define BCMI_TSCE16_XGXS_RX_X4_BERCNTr_CLR(r) (r).rx_x4_bercnt[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_BERCNTr_SET(r,d) (r).rx_x4_bercnt[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_BERCNTr_GET(r) (r).rx_x4_bercnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_BERCNTr_BIP_ERROR_COUNT_PER_LANEf_GET(r) ((((r).rx_x4_bercnt[0]) >> 8) & 0xff)
#define BCMI_TSCE16_XGXS_RX_X4_BERCNTr_BIP_ERROR_COUNT_PER_LANEf_SET(r,f) (r).rx_x4_bercnt[0]=(((r).rx_x4_bercnt[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCE16_XGXS_RX_X4_BERCNTr_BER_COUNT_PER_LNf_GET(r) (((r).rx_x4_bercnt[0]) & 0xff)
#define BCMI_TSCE16_XGXS_RX_X4_BERCNTr_BER_COUNT_PER_LNf_SET(r,f) (r).rx_x4_bercnt[0]=(((r).rx_x4_bercnt[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access RX_X4_BERCNT.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_BERCNTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_BERCNTr,(_r._rx_x4_bercnt))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_BERCNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_BERCNTr,(_r._rx_x4_bercnt)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_BERCNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_BERCNTr,(_r._rx_x4_bercnt))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_BERCNTr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_BERCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_bercnt))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_BERCNTr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_BERCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_bercnt))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_BERCNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_BERCNTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_bercnt))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_BERCNTr BCMI_TSCE16_XGXS_RX_X4_BERCNTr
#define RX_X4_BERCNTr_SIZE BCMI_TSCE16_XGXS_RX_X4_BERCNTr_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_BERCNTr_t RX_X4_BERCNTr_t;
#define RX_X4_BERCNTr_CLR BCMI_TSCE16_XGXS_RX_X4_BERCNTr_CLR
#define RX_X4_BERCNTr_SET BCMI_TSCE16_XGXS_RX_X4_BERCNTr_SET
#define RX_X4_BERCNTr_GET BCMI_TSCE16_XGXS_RX_X4_BERCNTr_GET
#define RX_X4_BERCNTr_BIP_ERROR_COUNT_PER_LANEf_GET BCMI_TSCE16_XGXS_RX_X4_BERCNTr_BIP_ERROR_COUNT_PER_LANEf_GET
#define RX_X4_BERCNTr_BIP_ERROR_COUNT_PER_LANEf_SET BCMI_TSCE16_XGXS_RX_X4_BERCNTr_BIP_ERROR_COUNT_PER_LANEf_SET
#define RX_X4_BERCNTr_BER_COUNT_PER_LNf_GET BCMI_TSCE16_XGXS_RX_X4_BERCNTr_BER_COUNT_PER_LNf_GET
#define RX_X4_BERCNTr_BER_COUNT_PER_LNf_SET BCMI_TSCE16_XGXS_RX_X4_BERCNTr_BER_COUNT_PER_LNf_SET
#define READ_RX_X4_BERCNTr BCMI_TSCE16_XGXS_READ_RX_X4_BERCNTr
#define WRITE_RX_X4_BERCNTr BCMI_TSCE16_XGXS_WRITE_RX_X4_BERCNTr
#define MODIFY_RX_X4_BERCNTr BCMI_TSCE16_XGXS_MODIFY_RX_X4_BERCNTr
#define READLN_RX_X4_BERCNTr BCMI_TSCE16_XGXS_READLN_RX_X4_BERCNTr
#define WRITELN_RX_X4_BERCNTr BCMI_TSCE16_XGXS_WRITELN_RX_X4_BERCNTr
#define WRITEALL_RX_X4_BERCNTr BCMI_TSCE16_XGXS_WRITEALL_RX_X4_BERCNTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_BERCNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_PCS_LATCH_STS1
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc152
 * DESC:     Latched status of PCS Information
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LPI_RECEIVED_LH  PER PORT: Low Power Indicator (LPI) has transitioned high since last read.Clear on read
 *     RESERVED_ORDERED_BYTE_3 PER PORT: Latched Reserved Ordered Set Byte 3 value.This field contains a recording of the third byte (starting with the byte after the 10'h19C) received when a reserved ordered set is detectedThis field is set when RESERVED_ORDERED_SET_LH is setClear on read
 *     RESERVED_ORDERED_SET_LH PER PORT: Reserved Ordered Set indicator has transitioned high since last readReserved Ordered Set is defined as a Sequence Ordered Set that is not LF and is not RFClear on read
 *     LINK_INTERRUPT_LH PER PORT: Link Interrupt (LI)  has transitioned high since last read.Clear on read
 *     REMOTE_FAULT_LH  PER PORT: Remote Fault (RF)  has transitioned high since last read.Clear on read
 *     LOCAL_FAULT_LH   PER PORT: Local Fault (LF) indicator has transitioned high since last read.Clear on read
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r (0x0000c152 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_PCS_LATCH_STS1.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r_s {
	uint32_t v[1];
	uint32_t rx_x4_pcs_latch_sts1[1];
	uint32_t _rx_x4_pcs_latch_sts1;
} BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r_t;

#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r_CLR(r) (r).rx_x4_pcs_latch_sts1[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r_SET(r,d) (r).rx_x4_pcs_latch_sts1[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r_GET(r) (r).rx_x4_pcs_latch_sts1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r_LOCAL_FAULT_LHf_GET(r) ((((r).rx_x4_pcs_latch_sts1[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r_LOCAL_FAULT_LHf_SET(r,f) (r).rx_x4_pcs_latch_sts1[0]=(((r).rx_x4_pcs_latch_sts1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r_REMOTE_FAULT_LHf_GET(r) ((((r).rx_x4_pcs_latch_sts1[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r_REMOTE_FAULT_LHf_SET(r,f) (r).rx_x4_pcs_latch_sts1[0]=(((r).rx_x4_pcs_latch_sts1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r_LINK_INTERRUPT_LHf_GET(r) ((((r).rx_x4_pcs_latch_sts1[0]) >> 13) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r_LINK_INTERRUPT_LHf_SET(r,f) (r).rx_x4_pcs_latch_sts1[0]=(((r).rx_x4_pcs_latch_sts1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r_RESERVED_ORDERED_SET_LHf_GET(r) ((((r).rx_x4_pcs_latch_sts1[0]) >> 12) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r_RESERVED_ORDERED_SET_LHf_SET(r,f) (r).rx_x4_pcs_latch_sts1[0]=(((r).rx_x4_pcs_latch_sts1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r_RESERVED_ORDERED_BYTE_3f_GET(r) ((((r).rx_x4_pcs_latch_sts1[0]) >> 4) & 0xff)
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r_RESERVED_ORDERED_BYTE_3f_SET(r,f) (r).rx_x4_pcs_latch_sts1[0]=(((r).rx_x4_pcs_latch_sts1[0] & ~((uint32_t)0xff << 4)) | ((((uint32_t)f) & 0xff) << 4)) | (255 << (16 + 4))
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r_LPI_RECEIVED_LHf_GET(r) ((((r).rx_x4_pcs_latch_sts1[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r_LPI_RECEIVED_LHf_SET(r,f) (r).rx_x4_pcs_latch_sts1[0]=(((r).rx_x4_pcs_latch_sts1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))

/*
 * These macros can be used to access RX_X4_PCS_LATCH_STS1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_PCS_LATCH_STS1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r,(_r._rx_x4_pcs_latch_sts1))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_PCS_LATCH_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r,(_r._rx_x4_pcs_latch_sts1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_PCS_LATCH_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r,(_r._rx_x4_pcs_latch_sts1))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_PCS_LATCH_STS1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_pcs_latch_sts1))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_PCS_LATCH_STS1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_pcs_latch_sts1))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_PCS_LATCH_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_pcs_latch_sts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_PCS_LATCH_STS1r BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r
#define RX_X4_PCS_LATCH_STS1r_SIZE BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r_t RX_X4_PCS_LATCH_STS1r_t;
#define RX_X4_PCS_LATCH_STS1r_CLR BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r_CLR
#define RX_X4_PCS_LATCH_STS1r_SET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r_SET
#define RX_X4_PCS_LATCH_STS1r_GET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r_GET
#define RX_X4_PCS_LATCH_STS1r_LOCAL_FAULT_LHf_GET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r_LOCAL_FAULT_LHf_GET
#define RX_X4_PCS_LATCH_STS1r_LOCAL_FAULT_LHf_SET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r_LOCAL_FAULT_LHf_SET
#define RX_X4_PCS_LATCH_STS1r_REMOTE_FAULT_LHf_GET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r_REMOTE_FAULT_LHf_GET
#define RX_X4_PCS_LATCH_STS1r_REMOTE_FAULT_LHf_SET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r_REMOTE_FAULT_LHf_SET
#define RX_X4_PCS_LATCH_STS1r_LINK_INTERRUPT_LHf_GET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r_LINK_INTERRUPT_LHf_GET
#define RX_X4_PCS_LATCH_STS1r_LINK_INTERRUPT_LHf_SET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r_LINK_INTERRUPT_LHf_SET
#define RX_X4_PCS_LATCH_STS1r_RESERVED_ORDERED_SET_LHf_GET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r_RESERVED_ORDERED_SET_LHf_GET
#define RX_X4_PCS_LATCH_STS1r_RESERVED_ORDERED_SET_LHf_SET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r_RESERVED_ORDERED_SET_LHf_SET
#define RX_X4_PCS_LATCH_STS1r_RESERVED_ORDERED_BYTE_3f_GET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r_RESERVED_ORDERED_BYTE_3f_GET
#define RX_X4_PCS_LATCH_STS1r_RESERVED_ORDERED_BYTE_3f_SET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r_RESERVED_ORDERED_BYTE_3f_SET
#define RX_X4_PCS_LATCH_STS1r_LPI_RECEIVED_LHf_GET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r_LPI_RECEIVED_LHf_GET
#define RX_X4_PCS_LATCH_STS1r_LPI_RECEIVED_LHf_SET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r_LPI_RECEIVED_LHf_SET
#define READ_RX_X4_PCS_LATCH_STS1r BCMI_TSCE16_XGXS_READ_RX_X4_PCS_LATCH_STS1r
#define WRITE_RX_X4_PCS_LATCH_STS1r BCMI_TSCE16_XGXS_WRITE_RX_X4_PCS_LATCH_STS1r
#define MODIFY_RX_X4_PCS_LATCH_STS1r BCMI_TSCE16_XGXS_MODIFY_RX_X4_PCS_LATCH_STS1r
#define READLN_RX_X4_PCS_LATCH_STS1r BCMI_TSCE16_XGXS_READLN_RX_X4_PCS_LATCH_STS1r
#define WRITELN_RX_X4_PCS_LATCH_STS1r BCMI_TSCE16_XGXS_WRITELN_RX_X4_PCS_LATCH_STS1r
#define WRITEALL_RX_X4_PCS_LATCH_STS1r BCMI_TSCE16_XGXS_WRITEALL_RX_X4_PCS_LATCH_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_PCS_LATCH_STS0
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc153
 * DESC:     Latched status of PCS Information
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SYNC_STATUS_LL   PER PORT: Sync Status indicator has transitioned low since last read.(Same as Block lock status) Block alignment for 64/66, sync_status FSM status for 8b10b = comma_align with no ErrorsClear on read
 *     SYNC_STATUS_LH   PER PORT: Sync Status indicator has transitioned high since last read.(Same as Block lock status) Block alignment for 64/66, sync_status FSM status for 8b10b = comma_align with no ErrorsClear on read
 *     LINK_STATUS_LL   PER PORT: Link Status indicator has transitioned low since last readClear on read
 *     LINK_STATUS_LH   PER PORT: Link Status indicator has transitioned high since last readClear on read
 *     HI_BER_LL        HI_BER has transitioned low since last read.Clear on read
 *     HI_BER_LH        HI_BER has transitioned high since last read.Clear on read
 *     DESKEW_STATUS_LL Deskew status has transitioned low since last read.Deskew achieved (1), Deskew not achieved (0)Clear on read
 *     DESKEW_STATUS_LH Deskew status has transitioned high since last read.Deskew achieved (1), Deskew not achieved (0)Clear on read
 *     AM_LOCK_LL       AM Lock has transitioned low since last read.Clear on read
 *     AM_LOCK_LH       AM Lock has transitioned high since last read.Clear on read
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r (0x0000c153 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_PCS_LATCH_STS0.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_s {
	uint32_t v[1];
	uint32_t rx_x4_pcs_latch_sts0[1];
	uint32_t _rx_x4_pcs_latch_sts0;
} BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_t;

#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_CLR(r) (r).rx_x4_pcs_latch_sts0[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_SET(r,d) (r).rx_x4_pcs_latch_sts0[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_GET(r) (r).rx_x4_pcs_latch_sts0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_AM_LOCK_LHf_GET(r) ((((r).rx_x4_pcs_latch_sts0[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_AM_LOCK_LHf_SET(r,f) (r).rx_x4_pcs_latch_sts0[0]=(((r).rx_x4_pcs_latch_sts0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_AM_LOCK_LLf_GET(r) ((((r).rx_x4_pcs_latch_sts0[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_AM_LOCK_LLf_SET(r,f) (r).rx_x4_pcs_latch_sts0[0]=(((r).rx_x4_pcs_latch_sts0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_DESKEW_STATUS_LHf_GET(r) ((((r).rx_x4_pcs_latch_sts0[0]) >> 13) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_DESKEW_STATUS_LHf_SET(r,f) (r).rx_x4_pcs_latch_sts0[0]=(((r).rx_x4_pcs_latch_sts0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_DESKEW_STATUS_LLf_GET(r) ((((r).rx_x4_pcs_latch_sts0[0]) >> 12) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_DESKEW_STATUS_LLf_SET(r,f) (r).rx_x4_pcs_latch_sts0[0]=(((r).rx_x4_pcs_latch_sts0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_HI_BER_LHf_GET(r) ((((r).rx_x4_pcs_latch_sts0[0]) >> 11) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_HI_BER_LHf_SET(r,f) (r).rx_x4_pcs_latch_sts0[0]=(((r).rx_x4_pcs_latch_sts0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_HI_BER_LLf_GET(r) ((((r).rx_x4_pcs_latch_sts0[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_HI_BER_LLf_SET(r,f) (r).rx_x4_pcs_latch_sts0[0]=(((r).rx_x4_pcs_latch_sts0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_LINK_STATUS_LHf_GET(r) ((((r).rx_x4_pcs_latch_sts0[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_LINK_STATUS_LHf_SET(r,f) (r).rx_x4_pcs_latch_sts0[0]=(((r).rx_x4_pcs_latch_sts0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_LINK_STATUS_LLf_GET(r) ((((r).rx_x4_pcs_latch_sts0[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_LINK_STATUS_LLf_SET(r,f) (r).rx_x4_pcs_latch_sts0[0]=(((r).rx_x4_pcs_latch_sts0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_SYNC_STATUS_LHf_GET(r) ((((r).rx_x4_pcs_latch_sts0[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_SYNC_STATUS_LHf_SET(r,f) (r).rx_x4_pcs_latch_sts0[0]=(((r).rx_x4_pcs_latch_sts0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_SYNC_STATUS_LLf_GET(r) ((((r).rx_x4_pcs_latch_sts0[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_SYNC_STATUS_LLf_SET(r,f) (r).rx_x4_pcs_latch_sts0[0]=(((r).rx_x4_pcs_latch_sts0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))

/*
 * These macros can be used to access RX_X4_PCS_LATCH_STS0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_PCS_LATCH_STS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r,(_r._rx_x4_pcs_latch_sts0))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_PCS_LATCH_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r,(_r._rx_x4_pcs_latch_sts0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_PCS_LATCH_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r,(_r._rx_x4_pcs_latch_sts0))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_PCS_LATCH_STS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_pcs_latch_sts0))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_PCS_LATCH_STS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_pcs_latch_sts0))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_PCS_LATCH_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_pcs_latch_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_PCS_LATCH_STS0r BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r
#define RX_X4_PCS_LATCH_STS0r_SIZE BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_t RX_X4_PCS_LATCH_STS0r_t;
#define RX_X4_PCS_LATCH_STS0r_CLR BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_CLR
#define RX_X4_PCS_LATCH_STS0r_SET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_SET
#define RX_X4_PCS_LATCH_STS0r_GET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_GET
#define RX_X4_PCS_LATCH_STS0r_AM_LOCK_LHf_GET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_AM_LOCK_LHf_GET
#define RX_X4_PCS_LATCH_STS0r_AM_LOCK_LHf_SET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_AM_LOCK_LHf_SET
#define RX_X4_PCS_LATCH_STS0r_AM_LOCK_LLf_GET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_AM_LOCK_LLf_GET
#define RX_X4_PCS_LATCH_STS0r_AM_LOCK_LLf_SET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_AM_LOCK_LLf_SET
#define RX_X4_PCS_LATCH_STS0r_DESKEW_STATUS_LHf_GET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_DESKEW_STATUS_LHf_GET
#define RX_X4_PCS_LATCH_STS0r_DESKEW_STATUS_LHf_SET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_DESKEW_STATUS_LHf_SET
#define RX_X4_PCS_LATCH_STS0r_DESKEW_STATUS_LLf_GET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_DESKEW_STATUS_LLf_GET
#define RX_X4_PCS_LATCH_STS0r_DESKEW_STATUS_LLf_SET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_DESKEW_STATUS_LLf_SET
#define RX_X4_PCS_LATCH_STS0r_HI_BER_LHf_GET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_HI_BER_LHf_GET
#define RX_X4_PCS_LATCH_STS0r_HI_BER_LHf_SET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_HI_BER_LHf_SET
#define RX_X4_PCS_LATCH_STS0r_HI_BER_LLf_GET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_HI_BER_LLf_GET
#define RX_X4_PCS_LATCH_STS0r_HI_BER_LLf_SET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_HI_BER_LLf_SET
#define RX_X4_PCS_LATCH_STS0r_LINK_STATUS_LHf_GET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_LINK_STATUS_LHf_GET
#define RX_X4_PCS_LATCH_STS0r_LINK_STATUS_LHf_SET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_LINK_STATUS_LHf_SET
#define RX_X4_PCS_LATCH_STS0r_LINK_STATUS_LLf_GET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_LINK_STATUS_LLf_GET
#define RX_X4_PCS_LATCH_STS0r_LINK_STATUS_LLf_SET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_LINK_STATUS_LLf_SET
#define RX_X4_PCS_LATCH_STS0r_SYNC_STATUS_LHf_GET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_SYNC_STATUS_LHf_GET
#define RX_X4_PCS_LATCH_STS0r_SYNC_STATUS_LHf_SET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_SYNC_STATUS_LHf_SET
#define RX_X4_PCS_LATCH_STS0r_SYNC_STATUS_LLf_GET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_SYNC_STATUS_LLf_GET
#define RX_X4_PCS_LATCH_STS0r_SYNC_STATUS_LLf_SET BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r_SYNC_STATUS_LLf_SET
#define READ_RX_X4_PCS_LATCH_STS0r BCMI_TSCE16_XGXS_READ_RX_X4_PCS_LATCH_STS0r
#define WRITE_RX_X4_PCS_LATCH_STS0r BCMI_TSCE16_XGXS_WRITE_RX_X4_PCS_LATCH_STS0r
#define MODIFY_RX_X4_PCS_LATCH_STS0r BCMI_TSCE16_XGXS_MODIFY_RX_X4_PCS_LATCH_STS0r
#define READLN_RX_X4_PCS_LATCH_STS0r BCMI_TSCE16_XGXS_READLN_RX_X4_PCS_LATCH_STS0r
#define WRITELN_RX_X4_PCS_LATCH_STS0r BCMI_TSCE16_XGXS_WRITELN_RX_X4_PCS_LATCH_STS0r
#define WRITEALL_RX_X4_PCS_LATCH_STS0r BCMI_TSCE16_XGXS_WRITEALL_RX_X4_PCS_LATCH_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_PCS_LATCH_STS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_PCS_LIVE_STS
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc154
 * DESC:     LiveLatched status of PCS Information
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     SYNC_STATUS      PER PORT: Live Sync Status indicator for cl36, cl48, brcm modePER LANE: Live Block Lock Status indicator for cl49, cl82.
 *     LINK_STATUS      PER PORT: Live Link Status indicator
 *     HI_BER           HI_BER indicator
 *     DESKEW_STATUS    Deskew achieved (1), Deskew not achieved (0)
 *     AM_LOCK          AM Lock status
 *     LPI_RECEIVED     Live LPI indicator
 *     LINK_INTERRUPT   Live link interrupt indicator
 *     REMOTE_FAULT     Live remote fault indicator
 *     LOCAL_FAULT      Live local fault indicator
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr (0x0000c154 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_PCS_LIVE_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_s {
	uint32_t v[1];
	uint32_t rx_x4_pcs_live_sts[1];
	uint32_t _rx_x4_pcs_live_sts;
} BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_t;

#define BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_CLR(r) (r).rx_x4_pcs_live_sts[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_SET(r,d) (r).rx_x4_pcs_live_sts[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_GET(r) (r).rx_x4_pcs_live_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_LOCAL_FAULTf_GET(r) ((((r).rx_x4_pcs_live_sts[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_LOCAL_FAULTf_SET(r,f) (r).rx_x4_pcs_live_sts[0]=(((r).rx_x4_pcs_live_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_REMOTE_FAULTf_GET(r) ((((r).rx_x4_pcs_live_sts[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_REMOTE_FAULTf_SET(r,f) (r).rx_x4_pcs_live_sts[0]=(((r).rx_x4_pcs_live_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_LINK_INTERRUPTf_GET(r) ((((r).rx_x4_pcs_live_sts[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_LINK_INTERRUPTf_SET(r,f) (r).rx_x4_pcs_live_sts[0]=(((r).rx_x4_pcs_live_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_LPI_RECEIVEDf_GET(r) ((((r).rx_x4_pcs_live_sts[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_LPI_RECEIVEDf_SET(r,f) (r).rx_x4_pcs_live_sts[0]=(((r).rx_x4_pcs_live_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_AM_LOCKf_GET(r) ((((r).rx_x4_pcs_live_sts[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_AM_LOCKf_SET(r,f) (r).rx_x4_pcs_live_sts[0]=(((r).rx_x4_pcs_live_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_DESKEW_STATUSf_GET(r) ((((r).rx_x4_pcs_live_sts[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_DESKEW_STATUSf_SET(r,f) (r).rx_x4_pcs_live_sts[0]=(((r).rx_x4_pcs_live_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_HI_BERf_GET(r) ((((r).rx_x4_pcs_live_sts[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_HI_BERf_SET(r,f) (r).rx_x4_pcs_live_sts[0]=(((r).rx_x4_pcs_live_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_LINK_STATUSf_GET(r) ((((r).rx_x4_pcs_live_sts[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_LINK_STATUSf_SET(r,f) (r).rx_x4_pcs_live_sts[0]=(((r).rx_x4_pcs_live_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_SYNC_STATUSf_GET(r) (((r).rx_x4_pcs_live_sts[0]) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_SYNC_STATUSf_SET(r,f) (r).rx_x4_pcs_live_sts[0]=(((r).rx_x4_pcs_live_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_PCS_LIVE_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_PCS_LIVE_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr,(_r._rx_x4_pcs_live_sts))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_PCS_LIVE_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr,(_r._rx_x4_pcs_live_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_PCS_LIVE_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr,(_r._rx_x4_pcs_live_sts))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_PCS_LIVE_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_pcs_live_sts))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_PCS_LIVE_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_pcs_live_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_PCS_LIVE_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_pcs_live_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_PCS_LIVE_STSr BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr
#define RX_X4_PCS_LIVE_STSr_SIZE BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_t RX_X4_PCS_LIVE_STSr_t;
#define RX_X4_PCS_LIVE_STSr_CLR BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_CLR
#define RX_X4_PCS_LIVE_STSr_SET BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_SET
#define RX_X4_PCS_LIVE_STSr_GET BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_GET
#define RX_X4_PCS_LIVE_STSr_LOCAL_FAULTf_GET BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_LOCAL_FAULTf_GET
#define RX_X4_PCS_LIVE_STSr_LOCAL_FAULTf_SET BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_LOCAL_FAULTf_SET
#define RX_X4_PCS_LIVE_STSr_REMOTE_FAULTf_GET BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_REMOTE_FAULTf_GET
#define RX_X4_PCS_LIVE_STSr_REMOTE_FAULTf_SET BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_REMOTE_FAULTf_SET
#define RX_X4_PCS_LIVE_STSr_LINK_INTERRUPTf_GET BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_LINK_INTERRUPTf_GET
#define RX_X4_PCS_LIVE_STSr_LINK_INTERRUPTf_SET BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_LINK_INTERRUPTf_SET
#define RX_X4_PCS_LIVE_STSr_LPI_RECEIVEDf_GET BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_LPI_RECEIVEDf_GET
#define RX_X4_PCS_LIVE_STSr_LPI_RECEIVEDf_SET BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_LPI_RECEIVEDf_SET
#define RX_X4_PCS_LIVE_STSr_AM_LOCKf_GET BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_AM_LOCKf_GET
#define RX_X4_PCS_LIVE_STSr_AM_LOCKf_SET BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_AM_LOCKf_SET
#define RX_X4_PCS_LIVE_STSr_DESKEW_STATUSf_GET BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_DESKEW_STATUSf_GET
#define RX_X4_PCS_LIVE_STSr_DESKEW_STATUSf_SET BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_DESKEW_STATUSf_SET
#define RX_X4_PCS_LIVE_STSr_HI_BERf_GET BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_HI_BERf_GET
#define RX_X4_PCS_LIVE_STSr_HI_BERf_SET BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_HI_BERf_SET
#define RX_X4_PCS_LIVE_STSr_LINK_STATUSf_GET BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_LINK_STATUSf_GET
#define RX_X4_PCS_LIVE_STSr_LINK_STATUSf_SET BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_LINK_STATUSf_SET
#define RX_X4_PCS_LIVE_STSr_SYNC_STATUSf_GET BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_SYNC_STATUSf_GET
#define RX_X4_PCS_LIVE_STSr_SYNC_STATUSf_SET BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr_SYNC_STATUSf_SET
#define READ_RX_X4_PCS_LIVE_STSr BCMI_TSCE16_XGXS_READ_RX_X4_PCS_LIVE_STSr
#define WRITE_RX_X4_PCS_LIVE_STSr BCMI_TSCE16_XGXS_WRITE_RX_X4_PCS_LIVE_STSr
#define MODIFY_RX_X4_PCS_LIVE_STSr BCMI_TSCE16_XGXS_MODIFY_RX_X4_PCS_LIVE_STSr
#define READLN_RX_X4_PCS_LIVE_STSr BCMI_TSCE16_XGXS_READLN_RX_X4_PCS_LIVE_STSr
#define WRITELN_RX_X4_PCS_LIVE_STSr BCMI_TSCE16_XGXS_WRITELN_RX_X4_PCS_LIVE_STSr
#define WRITEALL_RX_X4_PCS_LIVE_STSr BCMI_TSCE16_XGXS_WRITEALL_RX_X4_PCS_LIVE_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_PCS_LIVE_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_CL82_AM_LATCH_STS
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc155
 * DESC:     cl82 AM lock state machine latched status per lane
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AM_LOCK_HIS_STATE Alignment marker history states - per laneclear on readbit 9 - INVALID_AMbit 8 - GOOD_AMbit 7 - COMP_AMbit 6 - TIMER_2bit 5 - AM_2_GOODbit 4 - COMP_2NDbit 3 - TIMER_1bit 2 - FIND_1STbit 1 - AM_RESET_CNTbit 0 - AM_LOCK_INIT
 *     AMRKR_SPACING_ERR_LATCH_MUX align marker spacing error detected - per laneclear on read
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LATCH_STSr (0x0000c155 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LATCH_STSr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL82_AM_LATCH_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LATCH_STSr_s {
	uint32_t v[1];
	uint32_t rx_x4_cl82_am_latch_sts[1];
	uint32_t _rx_x4_cl82_am_latch_sts;
} BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LATCH_STSr_t;

#define BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LATCH_STSr_CLR(r) (r).rx_x4_cl82_am_latch_sts[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LATCH_STSr_SET(r,d) (r).rx_x4_cl82_am_latch_sts[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LATCH_STSr_GET(r) (r).rx_x4_cl82_am_latch_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LATCH_STSr_AMRKR_SPACING_ERR_LATCH_MUXf_GET(r) ((((r).rx_x4_cl82_am_latch_sts[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LATCH_STSr_AMRKR_SPACING_ERR_LATCH_MUXf_SET(r,f) (r).rx_x4_cl82_am_latch_sts[0]=(((r).rx_x4_cl82_am_latch_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LATCH_STSr_AM_LOCK_HIS_STATEf_GET(r) (((r).rx_x4_cl82_am_latch_sts[0]) & 0x3ff)
#define BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LATCH_STSr_AM_LOCK_HIS_STATEf_SET(r,f) (r).rx_x4_cl82_am_latch_sts[0]=(((r).rx_x4_cl82_am_latch_sts[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access RX_X4_CL82_AM_LATCH_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_CL82_AM_LATCH_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LATCH_STSr,(_r._rx_x4_cl82_am_latch_sts))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_CL82_AM_LATCH_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LATCH_STSr,(_r._rx_x4_cl82_am_latch_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_CL82_AM_LATCH_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LATCH_STSr,(_r._rx_x4_cl82_am_latch_sts))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_CL82_AM_LATCH_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl82_am_latch_sts))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_CL82_AM_LATCH_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl82_am_latch_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_CL82_AM_LATCH_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl82_am_latch_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL82_AM_LATCH_STSr BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LATCH_STSr
#define RX_X4_CL82_AM_LATCH_STSr_SIZE BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LATCH_STSr_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LATCH_STSr_t RX_X4_CL82_AM_LATCH_STSr_t;
#define RX_X4_CL82_AM_LATCH_STSr_CLR BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LATCH_STSr_CLR
#define RX_X4_CL82_AM_LATCH_STSr_SET BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LATCH_STSr_SET
#define RX_X4_CL82_AM_LATCH_STSr_GET BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LATCH_STSr_GET
#define RX_X4_CL82_AM_LATCH_STSr_AMRKR_SPACING_ERR_LATCH_MUXf_GET BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LATCH_STSr_AMRKR_SPACING_ERR_LATCH_MUXf_GET
#define RX_X4_CL82_AM_LATCH_STSr_AMRKR_SPACING_ERR_LATCH_MUXf_SET BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LATCH_STSr_AMRKR_SPACING_ERR_LATCH_MUXf_SET
#define RX_X4_CL82_AM_LATCH_STSr_AM_LOCK_HIS_STATEf_GET BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LATCH_STSr_AM_LOCK_HIS_STATEf_GET
#define RX_X4_CL82_AM_LATCH_STSr_AM_LOCK_HIS_STATEf_SET BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LATCH_STSr_AM_LOCK_HIS_STATEf_SET
#define READ_RX_X4_CL82_AM_LATCH_STSr BCMI_TSCE16_XGXS_READ_RX_X4_CL82_AM_LATCH_STSr
#define WRITE_RX_X4_CL82_AM_LATCH_STSr BCMI_TSCE16_XGXS_WRITE_RX_X4_CL82_AM_LATCH_STSr
#define MODIFY_RX_X4_CL82_AM_LATCH_STSr BCMI_TSCE16_XGXS_MODIFY_RX_X4_CL82_AM_LATCH_STSr
#define READLN_RX_X4_CL82_AM_LATCH_STSr BCMI_TSCE16_XGXS_READLN_RX_X4_CL82_AM_LATCH_STSr
#define WRITELN_RX_X4_CL82_AM_LATCH_STSr BCMI_TSCE16_XGXS_WRITELN_RX_X4_CL82_AM_LATCH_STSr
#define WRITEALL_RX_X4_CL82_AM_LATCH_STSr BCMI_TSCE16_XGXS_WRITEALL_RX_X4_CL82_AM_LATCH_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LATCH_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_CL82_AM_LIVE_STS
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc156
 * DESC:     cl82 AM lock state machine live status per lane
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     AM_LOCK_STATE    Alignment marker current states - per lanebit 9 - INVALID_AMbit 8 - GOOD_AMbit 7 - COMP_AMbit 6 - TIMER_2bit 5 - AM_2_GOODbit 4 - COMP_2NDbit 3 - TIMER_1bit 2 - FIND_1STbit 1 - AM_RESET_CNTbit 0 - AM_LOCK_INIT
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LIVE_STSr (0x0000c156 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LIVE_STSr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL82_AM_LIVE_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LIVE_STSr_s {
	uint32_t v[1];
	uint32_t rx_x4_cl82_am_live_sts[1];
	uint32_t _rx_x4_cl82_am_live_sts;
} BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LIVE_STSr_t;

#define BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LIVE_STSr_CLR(r) (r).rx_x4_cl82_am_live_sts[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LIVE_STSr_SET(r,d) (r).rx_x4_cl82_am_live_sts[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LIVE_STSr_GET(r) (r).rx_x4_cl82_am_live_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LIVE_STSr_AM_LOCK_STATEf_GET(r) (((r).rx_x4_cl82_am_live_sts[0]) & 0x3ff)
#define BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LIVE_STSr_AM_LOCK_STATEf_SET(r,f) (r).rx_x4_cl82_am_live_sts[0]=(((r).rx_x4_cl82_am_live_sts[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access RX_X4_CL82_AM_LIVE_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_CL82_AM_LIVE_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LIVE_STSr,(_r._rx_x4_cl82_am_live_sts))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_CL82_AM_LIVE_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LIVE_STSr,(_r._rx_x4_cl82_am_live_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_CL82_AM_LIVE_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LIVE_STSr,(_r._rx_x4_cl82_am_live_sts))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_CL82_AM_LIVE_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LIVE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl82_am_live_sts))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_CL82_AM_LIVE_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LIVE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl82_am_live_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_CL82_AM_LIVE_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LIVE_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl82_am_live_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL82_AM_LIVE_STSr BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LIVE_STSr
#define RX_X4_CL82_AM_LIVE_STSr_SIZE BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LIVE_STSr_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LIVE_STSr_t RX_X4_CL82_AM_LIVE_STSr_t;
#define RX_X4_CL82_AM_LIVE_STSr_CLR BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LIVE_STSr_CLR
#define RX_X4_CL82_AM_LIVE_STSr_SET BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LIVE_STSr_SET
#define RX_X4_CL82_AM_LIVE_STSr_GET BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LIVE_STSr_GET
#define RX_X4_CL82_AM_LIVE_STSr_AM_LOCK_STATEf_GET BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LIVE_STSr_AM_LOCK_STATEf_GET
#define RX_X4_CL82_AM_LIVE_STSr_AM_LOCK_STATEf_SET BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LIVE_STSr_AM_LOCK_STATEf_SET
#define READ_RX_X4_CL82_AM_LIVE_STSr BCMI_TSCE16_XGXS_READ_RX_X4_CL82_AM_LIVE_STSr
#define WRITE_RX_X4_CL82_AM_LIVE_STSr BCMI_TSCE16_XGXS_WRITE_RX_X4_CL82_AM_LIVE_STSr
#define MODIFY_RX_X4_CL82_AM_LIVE_STSr BCMI_TSCE16_XGXS_MODIFY_RX_X4_CL82_AM_LIVE_STSr
#define READLN_RX_X4_CL82_AM_LIVE_STSr BCMI_TSCE16_XGXS_READLN_RX_X4_CL82_AM_LIVE_STSr
#define WRITELN_RX_X4_CL82_AM_LIVE_STSr BCMI_TSCE16_XGXS_WRITELN_RX_X4_CL82_AM_LIVE_STSr
#define WRITEALL_RX_X4_CL82_AM_LIVE_STSr BCMI_TSCE16_XGXS_WRITEALL_RX_X4_CL82_AM_LIVE_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_CL82_AM_LIVE_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_FEC_CORRBLKSL
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc157
 * DESC:     FEC corrected blocks counter [15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CORCOUNTL        16 LSB of the corrected blocks count, clear on read
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSLr (0x0000c157 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSLr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_CORRBLKSL.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSLr_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_corrblksl[1];
	uint32_t _rx_x4_fec_corrblksl;
} BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSLr_t;

#define BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSLr_CLR(r) (r).rx_x4_fec_corrblksl[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSLr_SET(r,d) (r).rx_x4_fec_corrblksl[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSLr_GET(r) (r).rx_x4_fec_corrblksl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSLr_CORCOUNTLf_GET(r) (((r).rx_x4_fec_corrblksl[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSLr_CORCOUNTLf_SET(r,f) (r).rx_x4_fec_corrblksl[0]=(((r).rx_x4_fec_corrblksl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_CORRBLKSL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_FEC_CORRBLKSLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSLr,(_r._rx_x4_fec_corrblksl))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_FEC_CORRBLKSLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSLr,(_r._rx_x4_fec_corrblksl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_FEC_CORRBLKSLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSLr,(_r._rx_x4_fec_corrblksl))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_FEC_CORRBLKSLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corrblksl))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_FEC_CORRBLKSLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corrblksl))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_FEC_CORRBLKSLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_corrblksl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_CORRBLKSLr BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSLr
#define RX_X4_FEC_CORRBLKSLr_SIZE BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSLr_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSLr_t RX_X4_FEC_CORRBLKSLr_t;
#define RX_X4_FEC_CORRBLKSLr_CLR BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSLr_CLR
#define RX_X4_FEC_CORRBLKSLr_SET BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSLr_SET
#define RX_X4_FEC_CORRBLKSLr_GET BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSLr_GET
#define RX_X4_FEC_CORRBLKSLr_CORCOUNTLf_GET BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSLr_CORCOUNTLf_GET
#define RX_X4_FEC_CORRBLKSLr_CORCOUNTLf_SET BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSLr_CORCOUNTLf_SET
#define READ_RX_X4_FEC_CORRBLKSLr BCMI_TSCE16_XGXS_READ_RX_X4_FEC_CORRBLKSLr
#define WRITE_RX_X4_FEC_CORRBLKSLr BCMI_TSCE16_XGXS_WRITE_RX_X4_FEC_CORRBLKSLr
#define MODIFY_RX_X4_FEC_CORRBLKSLr BCMI_TSCE16_XGXS_MODIFY_RX_X4_FEC_CORRBLKSLr
#define READLN_RX_X4_FEC_CORRBLKSLr BCMI_TSCE16_XGXS_READLN_RX_X4_FEC_CORRBLKSLr
#define WRITELN_RX_X4_FEC_CORRBLKSLr BCMI_TSCE16_XGXS_WRITELN_RX_X4_FEC_CORRBLKSLr
#define WRITEALL_RX_X4_FEC_CORRBLKSLr BCMI_TSCE16_XGXS_WRITEALL_RX_X4_FEC_CORRBLKSLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_FEC_CORRBLKSH
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc158
 * DESC:     FEC corrected blocks counter [31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CORCOUNTH        16 MSB of the corrected blocks count, clear on readContents are latched upon read of corCountL
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSHr (0x0000c158 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSHr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_CORRBLKSH.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSHr_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_corrblksh[1];
	uint32_t _rx_x4_fec_corrblksh;
} BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSHr_t;

#define BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSHr_CLR(r) (r).rx_x4_fec_corrblksh[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSHr_SET(r,d) (r).rx_x4_fec_corrblksh[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSHr_GET(r) (r).rx_x4_fec_corrblksh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSHr_CORCOUNTHf_GET(r) (((r).rx_x4_fec_corrblksh[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSHr_CORCOUNTHf_SET(r,f) (r).rx_x4_fec_corrblksh[0]=(((r).rx_x4_fec_corrblksh[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_CORRBLKSH.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_FEC_CORRBLKSHr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSHr,(_r._rx_x4_fec_corrblksh))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_FEC_CORRBLKSHr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSHr,(_r._rx_x4_fec_corrblksh)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_FEC_CORRBLKSHr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSHr,(_r._rx_x4_fec_corrblksh))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_FEC_CORRBLKSHr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSHr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corrblksh))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_FEC_CORRBLKSHr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSHr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corrblksh))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_FEC_CORRBLKSHr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSHr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_corrblksh))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_CORRBLKSHr BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSHr
#define RX_X4_FEC_CORRBLKSHr_SIZE BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSHr_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSHr_t RX_X4_FEC_CORRBLKSHr_t;
#define RX_X4_FEC_CORRBLKSHr_CLR BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSHr_CLR
#define RX_X4_FEC_CORRBLKSHr_SET BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSHr_SET
#define RX_X4_FEC_CORRBLKSHr_GET BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSHr_GET
#define RX_X4_FEC_CORRBLKSHr_CORCOUNTHf_GET BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSHr_CORCOUNTHf_GET
#define RX_X4_FEC_CORRBLKSHr_CORCOUNTHf_SET BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSHr_CORCOUNTHf_SET
#define READ_RX_X4_FEC_CORRBLKSHr BCMI_TSCE16_XGXS_READ_RX_X4_FEC_CORRBLKSHr
#define WRITE_RX_X4_FEC_CORRBLKSHr BCMI_TSCE16_XGXS_WRITE_RX_X4_FEC_CORRBLKSHr
#define MODIFY_RX_X4_FEC_CORRBLKSHr BCMI_TSCE16_XGXS_MODIFY_RX_X4_FEC_CORRBLKSHr
#define READLN_RX_X4_FEC_CORRBLKSHr BCMI_TSCE16_XGXS_READLN_RX_X4_FEC_CORRBLKSHr
#define WRITELN_RX_X4_FEC_CORRBLKSHr BCMI_TSCE16_XGXS_WRITELN_RX_X4_FEC_CORRBLKSHr
#define WRITEALL_RX_X4_FEC_CORRBLKSHr BCMI_TSCE16_XGXS_WRITEALL_RX_X4_FEC_CORRBLKSHr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_FEC_CORRBLKSHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_FEC_UNCORRBLKSL
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc159
 * DESC:     FEC uncorrected blocks counter [15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UNCORCOUNTL      16 LSB of the uncorrected blocks count, clear on read
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSLr (0x0000c159 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSLr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_UNCORRBLKSL.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSLr_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_uncorrblksl[1];
	uint32_t _rx_x4_fec_uncorrblksl;
} BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSLr_t;

#define BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSLr_CLR(r) (r).rx_x4_fec_uncorrblksl[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSLr_SET(r,d) (r).rx_x4_fec_uncorrblksl[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSLr_GET(r) (r).rx_x4_fec_uncorrblksl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSLr_UNCORCOUNTLf_GET(r) (((r).rx_x4_fec_uncorrblksl[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSLr_UNCORCOUNTLf_SET(r,f) (r).rx_x4_fec_uncorrblksl[0]=(((r).rx_x4_fec_uncorrblksl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_UNCORRBLKSL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_FEC_UNCORRBLKSLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSLr,(_r._rx_x4_fec_uncorrblksl))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_FEC_UNCORRBLKSLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSLr,(_r._rx_x4_fec_uncorrblksl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_FEC_UNCORRBLKSLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSLr,(_r._rx_x4_fec_uncorrblksl))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_FEC_UNCORRBLKSLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorrblksl))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_FEC_UNCORRBLKSLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorrblksl))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_FEC_UNCORRBLKSLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_uncorrblksl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_UNCORRBLKSLr BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSLr
#define RX_X4_FEC_UNCORRBLKSLr_SIZE BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSLr_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSLr_t RX_X4_FEC_UNCORRBLKSLr_t;
#define RX_X4_FEC_UNCORRBLKSLr_CLR BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSLr_CLR
#define RX_X4_FEC_UNCORRBLKSLr_SET BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSLr_SET
#define RX_X4_FEC_UNCORRBLKSLr_GET BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSLr_GET
#define RX_X4_FEC_UNCORRBLKSLr_UNCORCOUNTLf_GET BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSLr_UNCORCOUNTLf_GET
#define RX_X4_FEC_UNCORRBLKSLr_UNCORCOUNTLf_SET BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSLr_UNCORCOUNTLf_SET
#define READ_RX_X4_FEC_UNCORRBLKSLr BCMI_TSCE16_XGXS_READ_RX_X4_FEC_UNCORRBLKSLr
#define WRITE_RX_X4_FEC_UNCORRBLKSLr BCMI_TSCE16_XGXS_WRITE_RX_X4_FEC_UNCORRBLKSLr
#define MODIFY_RX_X4_FEC_UNCORRBLKSLr BCMI_TSCE16_XGXS_MODIFY_RX_X4_FEC_UNCORRBLKSLr
#define READLN_RX_X4_FEC_UNCORRBLKSLr BCMI_TSCE16_XGXS_READLN_RX_X4_FEC_UNCORRBLKSLr
#define WRITELN_RX_X4_FEC_UNCORRBLKSLr BCMI_TSCE16_XGXS_WRITELN_RX_X4_FEC_UNCORRBLKSLr
#define WRITEALL_RX_X4_FEC_UNCORRBLKSLr BCMI_TSCE16_XGXS_WRITEALL_RX_X4_FEC_UNCORRBLKSLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_FEC_UNCORRBLKSH
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc15a
 * DESC:     FEC uncorrected blocks counter [31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UNCORCOUNTH      16 MSB of the uncorrected blocks count, clear on readContents are latched upon read of uncorCountL
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSHr (0x0000c15a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSHr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_UNCORRBLKSH.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSHr_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_uncorrblksh[1];
	uint32_t _rx_x4_fec_uncorrblksh;
} BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSHr_t;

#define BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSHr_CLR(r) (r).rx_x4_fec_uncorrblksh[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSHr_SET(r,d) (r).rx_x4_fec_uncorrblksh[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSHr_GET(r) (r).rx_x4_fec_uncorrblksh[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSHr_UNCORCOUNTHf_GET(r) (((r).rx_x4_fec_uncorrblksh[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSHr_UNCORCOUNTHf_SET(r,f) (r).rx_x4_fec_uncorrblksh[0]=(((r).rx_x4_fec_uncorrblksh[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_UNCORRBLKSH.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_FEC_UNCORRBLKSHr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSHr,(_r._rx_x4_fec_uncorrblksh))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_FEC_UNCORRBLKSHr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSHr,(_r._rx_x4_fec_uncorrblksh)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_FEC_UNCORRBLKSHr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSHr,(_r._rx_x4_fec_uncorrblksh))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_FEC_UNCORRBLKSHr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSHr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorrblksh))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_FEC_UNCORRBLKSHr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSHr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorrblksh))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_FEC_UNCORRBLKSHr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSHr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_uncorrblksh))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_UNCORRBLKSHr BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSHr
#define RX_X4_FEC_UNCORRBLKSHr_SIZE BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSHr_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSHr_t RX_X4_FEC_UNCORRBLKSHr_t;
#define RX_X4_FEC_UNCORRBLKSHr_CLR BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSHr_CLR
#define RX_X4_FEC_UNCORRBLKSHr_SET BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSHr_SET
#define RX_X4_FEC_UNCORRBLKSHr_GET BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSHr_GET
#define RX_X4_FEC_UNCORRBLKSHr_UNCORCOUNTHf_GET BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSHr_UNCORCOUNTHf_GET
#define RX_X4_FEC_UNCORRBLKSHr_UNCORCOUNTHf_SET BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSHr_UNCORCOUNTHf_SET
#define READ_RX_X4_FEC_UNCORRBLKSHr BCMI_TSCE16_XGXS_READ_RX_X4_FEC_UNCORRBLKSHr
#define WRITE_RX_X4_FEC_UNCORRBLKSHr BCMI_TSCE16_XGXS_WRITE_RX_X4_FEC_UNCORRBLKSHr
#define MODIFY_RX_X4_FEC_UNCORRBLKSHr BCMI_TSCE16_XGXS_MODIFY_RX_X4_FEC_UNCORRBLKSHr
#define READLN_RX_X4_FEC_UNCORRBLKSHr BCMI_TSCE16_XGXS_READLN_RX_X4_FEC_UNCORRBLKSHr
#define WRITELN_RX_X4_FEC_UNCORRBLKSHr BCMI_TSCE16_XGXS_WRITELN_RX_X4_FEC_UNCORRBLKSHr
#define WRITEALL_RX_X4_FEC_UNCORRBLKSHr BCMI_TSCE16_XGXS_WRITEALL_RX_X4_FEC_UNCORRBLKSHr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_FEC_UNCORRBLKSHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_GBOX_STS
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc15b
 * DESC:     rx_gbox error status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     GBOX_UNDERFLOW_ERR Underflow error was detected in rx_gbox
 *     GBOX_OVERFLOW_ERR Overflow error was detected in rx_gbox
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_GBOX_STSr (0x0000c15b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_GBOX_STSr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_GBOX_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_GBOX_STSr_s {
	uint32_t v[1];
	uint32_t rx_x4_gbox_sts[1];
	uint32_t _rx_x4_gbox_sts;
} BCMI_TSCE16_XGXS_RX_X4_GBOX_STSr_t;

#define BCMI_TSCE16_XGXS_RX_X4_GBOX_STSr_CLR(r) (r).rx_x4_gbox_sts[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_GBOX_STSr_SET(r,d) (r).rx_x4_gbox_sts[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_GBOX_STSr_GET(r) (r).rx_x4_gbox_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_GBOX_STSr_GBOX_OVERFLOW_ERRf_GET(r) ((((r).rx_x4_gbox_sts[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_GBOX_STSr_GBOX_OVERFLOW_ERRf_SET(r,f) (r).rx_x4_gbox_sts[0]=(((r).rx_x4_gbox_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_RX_X4_GBOX_STSr_GBOX_UNDERFLOW_ERRf_GET(r) (((r).rx_x4_gbox_sts[0]) & 0x1)
#define BCMI_TSCE16_XGXS_RX_X4_GBOX_STSr_GBOX_UNDERFLOW_ERRf_SET(r,f) (r).rx_x4_gbox_sts[0]=(((r).rx_x4_gbox_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_GBOX_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_GBOX_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_GBOX_STSr,(_r._rx_x4_gbox_sts))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_GBOX_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_GBOX_STSr,(_r._rx_x4_gbox_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_GBOX_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_GBOX_STSr,(_r._rx_x4_gbox_sts))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_GBOX_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_GBOX_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_gbox_sts))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_GBOX_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_GBOX_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_gbox_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_GBOX_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_GBOX_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_gbox_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_GBOX_STSr BCMI_TSCE16_XGXS_RX_X4_GBOX_STSr
#define RX_X4_GBOX_STSr_SIZE BCMI_TSCE16_XGXS_RX_X4_GBOX_STSr_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_GBOX_STSr_t RX_X4_GBOX_STSr_t;
#define RX_X4_GBOX_STSr_CLR BCMI_TSCE16_XGXS_RX_X4_GBOX_STSr_CLR
#define RX_X4_GBOX_STSr_SET BCMI_TSCE16_XGXS_RX_X4_GBOX_STSr_SET
#define RX_X4_GBOX_STSr_GET BCMI_TSCE16_XGXS_RX_X4_GBOX_STSr_GET
#define RX_X4_GBOX_STSr_GBOX_OVERFLOW_ERRf_GET BCMI_TSCE16_XGXS_RX_X4_GBOX_STSr_GBOX_OVERFLOW_ERRf_GET
#define RX_X4_GBOX_STSr_GBOX_OVERFLOW_ERRf_SET BCMI_TSCE16_XGXS_RX_X4_GBOX_STSr_GBOX_OVERFLOW_ERRf_SET
#define RX_X4_GBOX_STSr_GBOX_UNDERFLOW_ERRf_GET BCMI_TSCE16_XGXS_RX_X4_GBOX_STSr_GBOX_UNDERFLOW_ERRf_GET
#define RX_X4_GBOX_STSr_GBOX_UNDERFLOW_ERRf_SET BCMI_TSCE16_XGXS_RX_X4_GBOX_STSr_GBOX_UNDERFLOW_ERRf_SET
#define READ_RX_X4_GBOX_STSr BCMI_TSCE16_XGXS_READ_RX_X4_GBOX_STSr
#define WRITE_RX_X4_GBOX_STSr BCMI_TSCE16_XGXS_WRITE_RX_X4_GBOX_STSr
#define MODIFY_RX_X4_GBOX_STSr BCMI_TSCE16_XGXS_MODIFY_RX_X4_GBOX_STSr
#define READLN_RX_X4_GBOX_STSr BCMI_TSCE16_XGXS_READLN_RX_X4_GBOX_STSr
#define WRITELN_RX_X4_GBOX_STSr BCMI_TSCE16_XGXS_WRITELN_RX_X4_GBOX_STSr
#define WRITEALL_RX_X4_GBOX_STSr BCMI_TSCE16_XGXS_WRITEALL_RX_X4_GBOX_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_GBOX_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_X4_CL49_RX_SCR_IDLE_ERR_CNT
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc15c
 * DESC:     CL49 ScrambledIdle Error Counter
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL49_RX_SCR_IDLE_ERROR_CNT CL49 ScrambledIdle Error Counter. 16 bits, Saturate at 16'hFFFF, Clear on read.NOTE: This counter is NOT applicable to cl82 ports with cl49_codec enabled(HG2_ENABLE && HG2_CODEC).
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr (0x0000c15c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL49_RX_SCR_IDLE_ERR_CNT.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr_s {
	uint32_t v[1];
	uint32_t rx_x4_cl49_rx_scr_idle_err_cnt[1];
	uint32_t _rx_x4_cl49_rx_scr_idle_err_cnt;
} BCMI_TSCE16_XGXS_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr_t;

#define BCMI_TSCE16_XGXS_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr_CLR(r) (r).rx_x4_cl49_rx_scr_idle_err_cnt[0] = 0
#define BCMI_TSCE16_XGXS_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr_SET(r,d) (r).rx_x4_cl49_rx_scr_idle_err_cnt[0] = d
#define BCMI_TSCE16_XGXS_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr_GET(r) (r).rx_x4_cl49_rx_scr_idle_err_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr_CL49_RX_SCR_IDLE_ERROR_CNTf_GET(r) (((r).rx_x4_cl49_rx_scr_idle_err_cnt[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr_CL49_RX_SCR_IDLE_ERROR_CNTf_SET(r,f) (r).rx_x4_cl49_rx_scr_idle_err_cnt[0]=(((r).rx_x4_cl49_rx_scr_idle_err_cnt[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_CL49_RX_SCR_IDLE_ERR_CNT.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr,(_r._rx_x4_cl49_rx_scr_idle_err_cnt))
#define BCMI_TSCE16_XGXS_WRITE_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr,(_r._rx_x4_cl49_rx_scr_idle_err_cnt)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr,(_r._rx_x4_cl49_rx_scr_idle_err_cnt))
#define BCMI_TSCE16_XGXS_READLN_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl49_rx_scr_idle_err_cnt))
#define BCMI_TSCE16_XGXS_WRITELN_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl49_rx_scr_idle_err_cnt))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl49_rx_scr_idle_err_cnt))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr BCMI_TSCE16_XGXS_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr
#define RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr_SIZE BCMI_TSCE16_XGXS_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr_SIZE
typedef BCMI_TSCE16_XGXS_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr_t RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr_t;
#define RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr_CLR BCMI_TSCE16_XGXS_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr_CLR
#define RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr_SET BCMI_TSCE16_XGXS_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr_SET
#define RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr_GET BCMI_TSCE16_XGXS_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr_GET
#define RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr_CL49_RX_SCR_IDLE_ERROR_CNTf_GET BCMI_TSCE16_XGXS_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr_CL49_RX_SCR_IDLE_ERROR_CNTf_GET
#define RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr_CL49_RX_SCR_IDLE_ERROR_CNTf_SET BCMI_TSCE16_XGXS_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr_CL49_RX_SCR_IDLE_ERROR_CNTf_SET
#define READ_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr BCMI_TSCE16_XGXS_READ_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr
#define WRITE_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr BCMI_TSCE16_XGXS_WRITE_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr
#define MODIFY_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr BCMI_TSCE16_XGXS_MODIFY_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr
#define READLN_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr BCMI_TSCE16_XGXS_READLN_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr
#define WRITELN_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr BCMI_TSCE16_XGXS_WRITELN_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr
#define WRITEALL_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr BCMI_TSCE16_XGXS_WRITEALL_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_X4_CL49_RX_SCR_IDLE_ERR_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  FEC_0TSC_12
 * BLOCKS:   RX_X4_CONTROL0_TSC_12
 * REGADDR:  0xc161
 * DESC:     User FEC Control 0 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FAST_LOCK_EN     
 *     DBG_ENABLE       FEC debug enable
 *     ERROR_EN_OVR_VAL FEC error enable override control value
 *     ERROR_EN_OVR     FEC error enable override control
 *     FEC_ERR_ENABLE   
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_FEC_0TSC_12r (0x0000c161 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_FEC_0TSC_12r_SIZE 4

/*
 * This structure should be used to declare and program FEC_0TSC_12.
 *
 */
typedef union BCMI_TSCE16_XGXS_FEC_0TSC_12r_s {
	uint32_t v[1];
	uint32_t fec_0tsc_12[1];
	uint32_t _fec_0tsc_12;
} BCMI_TSCE16_XGXS_FEC_0TSC_12r_t;

#define BCMI_TSCE16_XGXS_FEC_0TSC_12r_CLR(r) (r).fec_0tsc_12[0] = 0
#define BCMI_TSCE16_XGXS_FEC_0TSC_12r_SET(r,d) (r).fec_0tsc_12[0] = d
#define BCMI_TSCE16_XGXS_FEC_0TSC_12r_GET(r) (r).fec_0tsc_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_FEC_0TSC_12r_FEC_ERR_ENABLEf_GET(r) ((((r).fec_0tsc_12[0]) >> 13) & 0x1)
#define BCMI_TSCE16_XGXS_FEC_0TSC_12r_FEC_ERR_ENABLEf_SET(r,f) (r).fec_0tsc_12[0]=(((r).fec_0tsc_12[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCE16_XGXS_FEC_0TSC_12r_ERROR_EN_OVRf_GET(r) ((((r).fec_0tsc_12[0]) >> 12) & 0x1)
#define BCMI_TSCE16_XGXS_FEC_0TSC_12r_ERROR_EN_OVRf_SET(r,f) (r).fec_0tsc_12[0]=(((r).fec_0tsc_12[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCE16_XGXS_FEC_0TSC_12r_ERROR_EN_OVR_VALf_GET(r) ((((r).fec_0tsc_12[0]) >> 11) & 0x1)
#define BCMI_TSCE16_XGXS_FEC_0TSC_12r_ERROR_EN_OVR_VALf_SET(r,f) (r).fec_0tsc_12[0]=(((r).fec_0tsc_12[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCE16_XGXS_FEC_0TSC_12r_DBG_ENABLEf_GET(r) ((((r).fec_0tsc_12[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_FEC_0TSC_12r_DBG_ENABLEf_SET(r,f) (r).fec_0tsc_12[0]=(((r).fec_0tsc_12[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_FEC_0TSC_12r_FAST_LOCK_ENf_GET(r) ((((r).fec_0tsc_12[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_FEC_0TSC_12r_FAST_LOCK_ENf_SET(r,f) (r).fec_0tsc_12[0]=(((r).fec_0tsc_12[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))

/*
 * These macros can be used to access FEC_0TSC_12.
 *
 */
#define BCMI_TSCE16_XGXS_READ_FEC_0TSC_12r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_FEC_0TSC_12r,(_r._fec_0tsc_12))
#define BCMI_TSCE16_XGXS_WRITE_FEC_0TSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_0TSC_12r,(_r._fec_0tsc_12)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_FEC_0TSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_0TSC_12r,(_r._fec_0tsc_12))
#define BCMI_TSCE16_XGXS_READLN_FEC_0TSC_12r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_FEC_0TSC_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._fec_0tsc_12))
#define BCMI_TSCE16_XGXS_WRITELN_FEC_0TSC_12r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_0TSC_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._fec_0tsc_12))
#define BCMI_TSCE16_XGXS_WRITEALL_FEC_0TSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_0TSC_12r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._fec_0tsc_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FEC_0TSC_12r BCMI_TSCE16_XGXS_FEC_0TSC_12r
#define FEC_0TSC_12r_SIZE BCMI_TSCE16_XGXS_FEC_0TSC_12r_SIZE
typedef BCMI_TSCE16_XGXS_FEC_0TSC_12r_t FEC_0TSC_12r_t;
#define FEC_0TSC_12r_CLR BCMI_TSCE16_XGXS_FEC_0TSC_12r_CLR
#define FEC_0TSC_12r_SET BCMI_TSCE16_XGXS_FEC_0TSC_12r_SET
#define FEC_0TSC_12r_GET BCMI_TSCE16_XGXS_FEC_0TSC_12r_GET
#define FEC_0TSC_12r_FEC_ERR_ENABLEf_GET BCMI_TSCE16_XGXS_FEC_0TSC_12r_FEC_ERR_ENABLEf_GET
#define FEC_0TSC_12r_FEC_ERR_ENABLEf_SET BCMI_TSCE16_XGXS_FEC_0TSC_12r_FEC_ERR_ENABLEf_SET
#define FEC_0TSC_12r_ERROR_EN_OVRf_GET BCMI_TSCE16_XGXS_FEC_0TSC_12r_ERROR_EN_OVRf_GET
#define FEC_0TSC_12r_ERROR_EN_OVRf_SET BCMI_TSCE16_XGXS_FEC_0TSC_12r_ERROR_EN_OVRf_SET
#define FEC_0TSC_12r_ERROR_EN_OVR_VALf_GET BCMI_TSCE16_XGXS_FEC_0TSC_12r_ERROR_EN_OVR_VALf_GET
#define FEC_0TSC_12r_ERROR_EN_OVR_VALf_SET BCMI_TSCE16_XGXS_FEC_0TSC_12r_ERROR_EN_OVR_VALf_SET
#define FEC_0TSC_12r_DBG_ENABLEf_GET BCMI_TSCE16_XGXS_FEC_0TSC_12r_DBG_ENABLEf_GET
#define FEC_0TSC_12r_DBG_ENABLEf_SET BCMI_TSCE16_XGXS_FEC_0TSC_12r_DBG_ENABLEf_SET
#define FEC_0TSC_12r_FAST_LOCK_ENf_GET BCMI_TSCE16_XGXS_FEC_0TSC_12r_FAST_LOCK_ENf_GET
#define FEC_0TSC_12r_FAST_LOCK_ENf_SET BCMI_TSCE16_XGXS_FEC_0TSC_12r_FAST_LOCK_ENf_SET
#define READ_FEC_0TSC_12r BCMI_TSCE16_XGXS_READ_FEC_0TSC_12r
#define WRITE_FEC_0TSC_12r BCMI_TSCE16_XGXS_WRITE_FEC_0TSC_12r
#define MODIFY_FEC_0TSC_12r BCMI_TSCE16_XGXS_MODIFY_FEC_0TSC_12r
#define READLN_FEC_0TSC_12r BCMI_TSCE16_XGXS_READLN_FEC_0TSC_12r
#define WRITELN_FEC_0TSC_12r BCMI_TSCE16_XGXS_WRITELN_FEC_0TSC_12r
#define WRITEALL_FEC_0TSC_12r BCMI_TSCE16_XGXS_WRITEALL_FEC_0TSC_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_FEC_0TSC_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  FEC_1TSC_12
 * BLOCKS:   RX_X4_CONTROL0_TSC_12
 * REGADDR:  0xc162
 * DESC:     User FEC Control 1 register
 * RESETVAL: 0x4478 (17528)
 * ACCESS:   R/W
 * FIELDS:
 *     DBG_ERR_MODE     debug readout only for uncorrectable errors
 *     BURST_ERR_STATUS_MODE collect error info only for uncorrectable errors0 - update on correctable and uncorrectable events1 - update on uncorrectable events only
 *     DEC_MAX_PM       maximum correctable burst pattern size
 *     INVALID_PARITY_CNT number of bad locks before unlocking
 *     GOOD_PARITY_CNT  number of good blocks before locking
 *     FEC_ERROR_CODE_ALL report errors thru all sync headers
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_FEC_1TSC_12r (0x0000c162 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_FEC_1TSC_12r_SIZE 4

/*
 * This structure should be used to declare and program FEC_1TSC_12.
 *
 */
typedef union BCMI_TSCE16_XGXS_FEC_1TSC_12r_s {
	uint32_t v[1];
	uint32_t fec_1tsc_12[1];
	uint32_t _fec_1tsc_12;
} BCMI_TSCE16_XGXS_FEC_1TSC_12r_t;

#define BCMI_TSCE16_XGXS_FEC_1TSC_12r_CLR(r) (r).fec_1tsc_12[0] = 0
#define BCMI_TSCE16_XGXS_FEC_1TSC_12r_SET(r,d) (r).fec_1tsc_12[0] = d
#define BCMI_TSCE16_XGXS_FEC_1TSC_12r_GET(r) (r).fec_1tsc_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_FEC_1TSC_12r_FEC_ERROR_CODE_ALLf_GET(r) ((((r).fec_1tsc_12[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_FEC_1TSC_12r_FEC_ERROR_CODE_ALLf_SET(r,f) (r).fec_1tsc_12[0]=(((r).fec_1tsc_12[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_FEC_1TSC_12r_GOOD_PARITY_CNTf_GET(r) ((((r).fec_1tsc_12[0]) >> 12) & 0x7)
#define BCMI_TSCE16_XGXS_FEC_1TSC_12r_GOOD_PARITY_CNTf_SET(r,f) (r).fec_1tsc_12[0]=(((r).fec_1tsc_12[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12)) | (7 << (16 + 12))
#define BCMI_TSCE16_XGXS_FEC_1TSC_12r_INVALID_PARITY_CNTf_GET(r) ((((r).fec_1tsc_12[0]) >> 8) & 0xf)
#define BCMI_TSCE16_XGXS_FEC_1TSC_12r_INVALID_PARITY_CNTf_SET(r,f) (r).fec_1tsc_12[0]=(((r).fec_1tsc_12[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_TSCE16_XGXS_FEC_1TSC_12r_DEC_MAX_PMf_GET(r) ((((r).fec_1tsc_12[0]) >> 2) & 0x3f)
#define BCMI_TSCE16_XGXS_FEC_1TSC_12r_DEC_MAX_PMf_SET(r,f) (r).fec_1tsc_12[0]=(((r).fec_1tsc_12[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2)) | (63 << (16 + 2))
#define BCMI_TSCE16_XGXS_FEC_1TSC_12r_BURST_ERR_STATUS_MODEf_GET(r) ((((r).fec_1tsc_12[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_FEC_1TSC_12r_BURST_ERR_STATUS_MODEf_SET(r,f) (r).fec_1tsc_12[0]=(((r).fec_1tsc_12[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_FEC_1TSC_12r_DBG_ERR_MODEf_GET(r) (((r).fec_1tsc_12[0]) & 0x1)
#define BCMI_TSCE16_XGXS_FEC_1TSC_12r_DBG_ERR_MODEf_SET(r,f) (r).fec_1tsc_12[0]=(((r).fec_1tsc_12[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access FEC_1TSC_12.
 *
 */
#define BCMI_TSCE16_XGXS_READ_FEC_1TSC_12r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_FEC_1TSC_12r,(_r._fec_1tsc_12))
#define BCMI_TSCE16_XGXS_WRITE_FEC_1TSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_1TSC_12r,(_r._fec_1tsc_12)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_FEC_1TSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_1TSC_12r,(_r._fec_1tsc_12))
#define BCMI_TSCE16_XGXS_READLN_FEC_1TSC_12r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_FEC_1TSC_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._fec_1tsc_12))
#define BCMI_TSCE16_XGXS_WRITELN_FEC_1TSC_12r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_1TSC_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._fec_1tsc_12))
#define BCMI_TSCE16_XGXS_WRITEALL_FEC_1TSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_1TSC_12r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._fec_1tsc_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FEC_1TSC_12r BCMI_TSCE16_XGXS_FEC_1TSC_12r
#define FEC_1TSC_12r_SIZE BCMI_TSCE16_XGXS_FEC_1TSC_12r_SIZE
typedef BCMI_TSCE16_XGXS_FEC_1TSC_12r_t FEC_1TSC_12r_t;
#define FEC_1TSC_12r_CLR BCMI_TSCE16_XGXS_FEC_1TSC_12r_CLR
#define FEC_1TSC_12r_SET BCMI_TSCE16_XGXS_FEC_1TSC_12r_SET
#define FEC_1TSC_12r_GET BCMI_TSCE16_XGXS_FEC_1TSC_12r_GET
#define FEC_1TSC_12r_FEC_ERROR_CODE_ALLf_GET BCMI_TSCE16_XGXS_FEC_1TSC_12r_FEC_ERROR_CODE_ALLf_GET
#define FEC_1TSC_12r_FEC_ERROR_CODE_ALLf_SET BCMI_TSCE16_XGXS_FEC_1TSC_12r_FEC_ERROR_CODE_ALLf_SET
#define FEC_1TSC_12r_GOOD_PARITY_CNTf_GET BCMI_TSCE16_XGXS_FEC_1TSC_12r_GOOD_PARITY_CNTf_GET
#define FEC_1TSC_12r_GOOD_PARITY_CNTf_SET BCMI_TSCE16_XGXS_FEC_1TSC_12r_GOOD_PARITY_CNTf_SET
#define FEC_1TSC_12r_INVALID_PARITY_CNTf_GET BCMI_TSCE16_XGXS_FEC_1TSC_12r_INVALID_PARITY_CNTf_GET
#define FEC_1TSC_12r_INVALID_PARITY_CNTf_SET BCMI_TSCE16_XGXS_FEC_1TSC_12r_INVALID_PARITY_CNTf_SET
#define FEC_1TSC_12r_DEC_MAX_PMf_GET BCMI_TSCE16_XGXS_FEC_1TSC_12r_DEC_MAX_PMf_GET
#define FEC_1TSC_12r_DEC_MAX_PMf_SET BCMI_TSCE16_XGXS_FEC_1TSC_12r_DEC_MAX_PMf_SET
#define FEC_1TSC_12r_BURST_ERR_STATUS_MODEf_GET BCMI_TSCE16_XGXS_FEC_1TSC_12r_BURST_ERR_STATUS_MODEf_GET
#define FEC_1TSC_12r_BURST_ERR_STATUS_MODEf_SET BCMI_TSCE16_XGXS_FEC_1TSC_12r_BURST_ERR_STATUS_MODEf_SET
#define FEC_1TSC_12r_DBG_ERR_MODEf_GET BCMI_TSCE16_XGXS_FEC_1TSC_12r_DBG_ERR_MODEf_GET
#define FEC_1TSC_12r_DBG_ERR_MODEf_SET BCMI_TSCE16_XGXS_FEC_1TSC_12r_DBG_ERR_MODEf_SET
#define READ_FEC_1TSC_12r BCMI_TSCE16_XGXS_READ_FEC_1TSC_12r
#define WRITE_FEC_1TSC_12r BCMI_TSCE16_XGXS_WRITE_FEC_1TSC_12r
#define MODIFY_FEC_1TSC_12r BCMI_TSCE16_XGXS_MODIFY_FEC_1TSC_12r
#define READLN_FEC_1TSC_12r BCMI_TSCE16_XGXS_READLN_FEC_1TSC_12r
#define WRITELN_FEC_1TSC_12r BCMI_TSCE16_XGXS_WRITELN_FEC_1TSC_12r
#define WRITEALL_FEC_1TSC_12r BCMI_TSCE16_XGXS_WRITEALL_FEC_1TSC_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_FEC_1TSC_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  FEC_2TSC_12
 * BLOCKS:   RX_X4_CONTROL0_TSC_12
 * REGADDR:  0xc163
 * DESC:     User FEC Control 2 register
 * RESETVAL: 0x7828 (30760)
 * ACCESS:   R/W
 * FIELDS:
 *     DEC_GAP_COUNT_MODE Gap counting mode0 = Counting zero method1 = Counting gap method
 *     DEC_17B_BURST_GAP_COUNT Gaps allowed in 17-bit bursts000 No gaps001 Single gap010-111 Multi gaps
 *     DEC_18B_BURST_GAP_COUNT Gaps allowed in 18-bit bursts000 No gaps001 Single gap010-111 Multi gaps
 *     DEC_19B_BURST_GAP_COUNT Gaps allowed in 19-bit bursts000 No gaps001 Single gap010-111 Multi gaps
 *     DEC_PM_MODE      Pattern Match ModeBurst error     Mode11 bits         0000016 bits         0000117 bits         0001018 bits         0001119 bits         0010020 bits         0010121 bits         0011022 bits         0011123 bits         0100024 bits         0100125 bits         0101026 bits         0101127 bits         0110028 bits         0110129 bits         0111030 bits         0111131 bits         1000032 bits         1000133 bits         1001034 bits         1001135 bits         1010036 bits         1010137 bits         1011038 bits         1011139 bits         1100040 bits         1100141 bits         11010
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_FEC_2TSC_12r (0x0000c163 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_FEC_2TSC_12r_SIZE 4

/*
 * This structure should be used to declare and program FEC_2TSC_12.
 *
 */
typedef union BCMI_TSCE16_XGXS_FEC_2TSC_12r_s {
	uint32_t v[1];
	uint32_t fec_2tsc_12[1];
	uint32_t _fec_2tsc_12;
} BCMI_TSCE16_XGXS_FEC_2TSC_12r_t;

#define BCMI_TSCE16_XGXS_FEC_2TSC_12r_CLR(r) (r).fec_2tsc_12[0] = 0
#define BCMI_TSCE16_XGXS_FEC_2TSC_12r_SET(r,d) (r).fec_2tsc_12[0] = d
#define BCMI_TSCE16_XGXS_FEC_2TSC_12r_GET(r) (r).fec_2tsc_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_FEC_2TSC_12r_DEC_PM_MODEf_GET(r) ((((r).fec_2tsc_12[0]) >> 11) & 0x1f)
#define BCMI_TSCE16_XGXS_FEC_2TSC_12r_DEC_PM_MODEf_SET(r,f) (r).fec_2tsc_12[0]=(((r).fec_2tsc_12[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_TSCE16_XGXS_FEC_2TSC_12r_DEC_19B_BURST_GAP_COUNTf_GET(r) ((((r).fec_2tsc_12[0]) >> 8) & 0x7)
#define BCMI_TSCE16_XGXS_FEC_2TSC_12r_DEC_19B_BURST_GAP_COUNTf_SET(r,f) (r).fec_2tsc_12[0]=(((r).fec_2tsc_12[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_TSCE16_XGXS_FEC_2TSC_12r_DEC_18B_BURST_GAP_COUNTf_GET(r) ((((r).fec_2tsc_12[0]) >> 5) & 0x7)
#define BCMI_TSCE16_XGXS_FEC_2TSC_12r_DEC_18B_BURST_GAP_COUNTf_SET(r,f) (r).fec_2tsc_12[0]=(((r).fec_2tsc_12[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5)) | (7 << (16 + 5))
#define BCMI_TSCE16_XGXS_FEC_2TSC_12r_DEC_17B_BURST_GAP_COUNTf_GET(r) ((((r).fec_2tsc_12[0]) >> 2) & 0x7)
#define BCMI_TSCE16_XGXS_FEC_2TSC_12r_DEC_17B_BURST_GAP_COUNTf_SET(r,f) (r).fec_2tsc_12[0]=(((r).fec_2tsc_12[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2)) | (7 << (16 + 2))
#define BCMI_TSCE16_XGXS_FEC_2TSC_12r_DEC_GAP_COUNT_MODEf_GET(r) ((((r).fec_2tsc_12[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_FEC_2TSC_12r_DEC_GAP_COUNT_MODEf_SET(r,f) (r).fec_2tsc_12[0]=(((r).fec_2tsc_12[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access FEC_2TSC_12.
 *
 */
#define BCMI_TSCE16_XGXS_READ_FEC_2TSC_12r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_FEC_2TSC_12r,(_r._fec_2tsc_12))
#define BCMI_TSCE16_XGXS_WRITE_FEC_2TSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_2TSC_12r,(_r._fec_2tsc_12)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_FEC_2TSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_2TSC_12r,(_r._fec_2tsc_12))
#define BCMI_TSCE16_XGXS_READLN_FEC_2TSC_12r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_FEC_2TSC_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._fec_2tsc_12))
#define BCMI_TSCE16_XGXS_WRITELN_FEC_2TSC_12r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_2TSC_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._fec_2tsc_12))
#define BCMI_TSCE16_XGXS_WRITEALL_FEC_2TSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_2TSC_12r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._fec_2tsc_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FEC_2TSC_12r BCMI_TSCE16_XGXS_FEC_2TSC_12r
#define FEC_2TSC_12r_SIZE BCMI_TSCE16_XGXS_FEC_2TSC_12r_SIZE
typedef BCMI_TSCE16_XGXS_FEC_2TSC_12r_t FEC_2TSC_12r_t;
#define FEC_2TSC_12r_CLR BCMI_TSCE16_XGXS_FEC_2TSC_12r_CLR
#define FEC_2TSC_12r_SET BCMI_TSCE16_XGXS_FEC_2TSC_12r_SET
#define FEC_2TSC_12r_GET BCMI_TSCE16_XGXS_FEC_2TSC_12r_GET
#define FEC_2TSC_12r_DEC_PM_MODEf_GET BCMI_TSCE16_XGXS_FEC_2TSC_12r_DEC_PM_MODEf_GET
#define FEC_2TSC_12r_DEC_PM_MODEf_SET BCMI_TSCE16_XGXS_FEC_2TSC_12r_DEC_PM_MODEf_SET
#define FEC_2TSC_12r_DEC_19B_BURST_GAP_COUNTf_GET BCMI_TSCE16_XGXS_FEC_2TSC_12r_DEC_19B_BURST_GAP_COUNTf_GET
#define FEC_2TSC_12r_DEC_19B_BURST_GAP_COUNTf_SET BCMI_TSCE16_XGXS_FEC_2TSC_12r_DEC_19B_BURST_GAP_COUNTf_SET
#define FEC_2TSC_12r_DEC_18B_BURST_GAP_COUNTf_GET BCMI_TSCE16_XGXS_FEC_2TSC_12r_DEC_18B_BURST_GAP_COUNTf_GET
#define FEC_2TSC_12r_DEC_18B_BURST_GAP_COUNTf_SET BCMI_TSCE16_XGXS_FEC_2TSC_12r_DEC_18B_BURST_GAP_COUNTf_SET
#define FEC_2TSC_12r_DEC_17B_BURST_GAP_COUNTf_GET BCMI_TSCE16_XGXS_FEC_2TSC_12r_DEC_17B_BURST_GAP_COUNTf_GET
#define FEC_2TSC_12r_DEC_17B_BURST_GAP_COUNTf_SET BCMI_TSCE16_XGXS_FEC_2TSC_12r_DEC_17B_BURST_GAP_COUNTf_SET
#define FEC_2TSC_12r_DEC_GAP_COUNT_MODEf_GET BCMI_TSCE16_XGXS_FEC_2TSC_12r_DEC_GAP_COUNT_MODEf_GET
#define FEC_2TSC_12r_DEC_GAP_COUNT_MODEf_SET BCMI_TSCE16_XGXS_FEC_2TSC_12r_DEC_GAP_COUNT_MODEf_SET
#define READ_FEC_2TSC_12r BCMI_TSCE16_XGXS_READ_FEC_2TSC_12r
#define WRITE_FEC_2TSC_12r BCMI_TSCE16_XGXS_WRITE_FEC_2TSC_12r
#define MODIFY_FEC_2TSC_12r BCMI_TSCE16_XGXS_MODIFY_FEC_2TSC_12r
#define READLN_FEC_2TSC_12r BCMI_TSCE16_XGXS_READLN_FEC_2TSC_12r
#define WRITELN_FEC_2TSC_12r BCMI_TSCE16_XGXS_WRITELN_FEC_2TSC_12r
#define WRITEALL_FEC_2TSC_12r BCMI_TSCE16_XGXS_WRITEALL_FEC_2TSC_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_FEC_2TSC_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  FEC_DBG_ERRLTSC_12
 * BLOCKS:   RX_X4_STATUS0_TSC_12
 * REGADDR:  0xc170
 * DESC:     User FEC debug read data [15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DBG_ERRL         16 LSB of the FEC debug data, clear on read
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_FEC_DBG_ERRLTSC_12r (0x0000c170 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_FEC_DBG_ERRLTSC_12r_SIZE 4

/*
 * This structure should be used to declare and program FEC_DBG_ERRLTSC_12.
 *
 */
typedef union BCMI_TSCE16_XGXS_FEC_DBG_ERRLTSC_12r_s {
	uint32_t v[1];
	uint32_t fec_dbg_errltsc_12[1];
	uint32_t _fec_dbg_errltsc_12;
} BCMI_TSCE16_XGXS_FEC_DBG_ERRLTSC_12r_t;

#define BCMI_TSCE16_XGXS_FEC_DBG_ERRLTSC_12r_CLR(r) (r).fec_dbg_errltsc_12[0] = 0
#define BCMI_TSCE16_XGXS_FEC_DBG_ERRLTSC_12r_SET(r,d) (r).fec_dbg_errltsc_12[0] = d
#define BCMI_TSCE16_XGXS_FEC_DBG_ERRLTSC_12r_GET(r) (r).fec_dbg_errltsc_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_FEC_DBG_ERRLTSC_12r_DBG_ERRLf_GET(r) (((r).fec_dbg_errltsc_12[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_FEC_DBG_ERRLTSC_12r_DBG_ERRLf_SET(r,f) (r).fec_dbg_errltsc_12[0]=(((r).fec_dbg_errltsc_12[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access FEC_DBG_ERRLTSC_12.
 *
 */
#define BCMI_TSCE16_XGXS_READ_FEC_DBG_ERRLTSC_12r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_FEC_DBG_ERRLTSC_12r,(_r._fec_dbg_errltsc_12))
#define BCMI_TSCE16_XGXS_WRITE_FEC_DBG_ERRLTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_DBG_ERRLTSC_12r,(_r._fec_dbg_errltsc_12)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_FEC_DBG_ERRLTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_DBG_ERRLTSC_12r,(_r._fec_dbg_errltsc_12))
#define BCMI_TSCE16_XGXS_READLN_FEC_DBG_ERRLTSC_12r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_FEC_DBG_ERRLTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._fec_dbg_errltsc_12))
#define BCMI_TSCE16_XGXS_WRITELN_FEC_DBG_ERRLTSC_12r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_DBG_ERRLTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._fec_dbg_errltsc_12))
#define BCMI_TSCE16_XGXS_WRITEALL_FEC_DBG_ERRLTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_DBG_ERRLTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._fec_dbg_errltsc_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FEC_DBG_ERRLTSC_12r BCMI_TSCE16_XGXS_FEC_DBG_ERRLTSC_12r
#define FEC_DBG_ERRLTSC_12r_SIZE BCMI_TSCE16_XGXS_FEC_DBG_ERRLTSC_12r_SIZE
typedef BCMI_TSCE16_XGXS_FEC_DBG_ERRLTSC_12r_t FEC_DBG_ERRLTSC_12r_t;
#define FEC_DBG_ERRLTSC_12r_CLR BCMI_TSCE16_XGXS_FEC_DBG_ERRLTSC_12r_CLR
#define FEC_DBG_ERRLTSC_12r_SET BCMI_TSCE16_XGXS_FEC_DBG_ERRLTSC_12r_SET
#define FEC_DBG_ERRLTSC_12r_GET BCMI_TSCE16_XGXS_FEC_DBG_ERRLTSC_12r_GET
#define FEC_DBG_ERRLTSC_12r_DBG_ERRLf_GET BCMI_TSCE16_XGXS_FEC_DBG_ERRLTSC_12r_DBG_ERRLf_GET
#define FEC_DBG_ERRLTSC_12r_DBG_ERRLf_SET BCMI_TSCE16_XGXS_FEC_DBG_ERRLTSC_12r_DBG_ERRLf_SET
#define READ_FEC_DBG_ERRLTSC_12r BCMI_TSCE16_XGXS_READ_FEC_DBG_ERRLTSC_12r
#define WRITE_FEC_DBG_ERRLTSC_12r BCMI_TSCE16_XGXS_WRITE_FEC_DBG_ERRLTSC_12r
#define MODIFY_FEC_DBG_ERRLTSC_12r BCMI_TSCE16_XGXS_MODIFY_FEC_DBG_ERRLTSC_12r
#define READLN_FEC_DBG_ERRLTSC_12r BCMI_TSCE16_XGXS_READLN_FEC_DBG_ERRLTSC_12r
#define WRITELN_FEC_DBG_ERRLTSC_12r BCMI_TSCE16_XGXS_WRITELN_FEC_DBG_ERRLTSC_12r
#define WRITEALL_FEC_DBG_ERRLTSC_12r BCMI_TSCE16_XGXS_WRITEALL_FEC_DBG_ERRLTSC_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_FEC_DBG_ERRLTSC_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  FEC_DBG_ERRAHTSC_12
 * BLOCKS:   RX_X4_STATUS0_TSC_12
 * REGADDR:  0xc171
 * DESC:     User FEC debug read data [31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DBG_ERRH         16 MSB of the FEC debug data, clear on readContents are latched upon read of Fecdbg_edataL
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_FEC_DBG_ERRAHTSC_12r (0x0000c171 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_FEC_DBG_ERRAHTSC_12r_SIZE 4

/*
 * This structure should be used to declare and program FEC_DBG_ERRAHTSC_12.
 *
 */
typedef union BCMI_TSCE16_XGXS_FEC_DBG_ERRAHTSC_12r_s {
	uint32_t v[1];
	uint32_t fec_dbg_errahtsc_12[1];
	uint32_t _fec_dbg_errahtsc_12;
} BCMI_TSCE16_XGXS_FEC_DBG_ERRAHTSC_12r_t;

#define BCMI_TSCE16_XGXS_FEC_DBG_ERRAHTSC_12r_CLR(r) (r).fec_dbg_errahtsc_12[0] = 0
#define BCMI_TSCE16_XGXS_FEC_DBG_ERRAHTSC_12r_SET(r,d) (r).fec_dbg_errahtsc_12[0] = d
#define BCMI_TSCE16_XGXS_FEC_DBG_ERRAHTSC_12r_GET(r) (r).fec_dbg_errahtsc_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_FEC_DBG_ERRAHTSC_12r_DBG_ERRHf_GET(r) (((r).fec_dbg_errahtsc_12[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_FEC_DBG_ERRAHTSC_12r_DBG_ERRHf_SET(r,f) (r).fec_dbg_errahtsc_12[0]=(((r).fec_dbg_errahtsc_12[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access FEC_DBG_ERRAHTSC_12.
 *
 */
#define BCMI_TSCE16_XGXS_READ_FEC_DBG_ERRAHTSC_12r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_FEC_DBG_ERRAHTSC_12r,(_r._fec_dbg_errahtsc_12))
#define BCMI_TSCE16_XGXS_WRITE_FEC_DBG_ERRAHTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_DBG_ERRAHTSC_12r,(_r._fec_dbg_errahtsc_12)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_FEC_DBG_ERRAHTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_DBG_ERRAHTSC_12r,(_r._fec_dbg_errahtsc_12))
#define BCMI_TSCE16_XGXS_READLN_FEC_DBG_ERRAHTSC_12r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_FEC_DBG_ERRAHTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._fec_dbg_errahtsc_12))
#define BCMI_TSCE16_XGXS_WRITELN_FEC_DBG_ERRAHTSC_12r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_DBG_ERRAHTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._fec_dbg_errahtsc_12))
#define BCMI_TSCE16_XGXS_WRITEALL_FEC_DBG_ERRAHTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_DBG_ERRAHTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._fec_dbg_errahtsc_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FEC_DBG_ERRAHTSC_12r BCMI_TSCE16_XGXS_FEC_DBG_ERRAHTSC_12r
#define FEC_DBG_ERRAHTSC_12r_SIZE BCMI_TSCE16_XGXS_FEC_DBG_ERRAHTSC_12r_SIZE
typedef BCMI_TSCE16_XGXS_FEC_DBG_ERRAHTSC_12r_t FEC_DBG_ERRAHTSC_12r_t;
#define FEC_DBG_ERRAHTSC_12r_CLR BCMI_TSCE16_XGXS_FEC_DBG_ERRAHTSC_12r_CLR
#define FEC_DBG_ERRAHTSC_12r_SET BCMI_TSCE16_XGXS_FEC_DBG_ERRAHTSC_12r_SET
#define FEC_DBG_ERRAHTSC_12r_GET BCMI_TSCE16_XGXS_FEC_DBG_ERRAHTSC_12r_GET
#define FEC_DBG_ERRAHTSC_12r_DBG_ERRHf_GET BCMI_TSCE16_XGXS_FEC_DBG_ERRAHTSC_12r_DBG_ERRHf_GET
#define FEC_DBG_ERRAHTSC_12r_DBG_ERRHf_SET BCMI_TSCE16_XGXS_FEC_DBG_ERRAHTSC_12r_DBG_ERRHf_SET
#define READ_FEC_DBG_ERRAHTSC_12r BCMI_TSCE16_XGXS_READ_FEC_DBG_ERRAHTSC_12r
#define WRITE_FEC_DBG_ERRAHTSC_12r BCMI_TSCE16_XGXS_WRITE_FEC_DBG_ERRAHTSC_12r
#define MODIFY_FEC_DBG_ERRAHTSC_12r BCMI_TSCE16_XGXS_MODIFY_FEC_DBG_ERRAHTSC_12r
#define READLN_FEC_DBG_ERRAHTSC_12r BCMI_TSCE16_XGXS_READLN_FEC_DBG_ERRAHTSC_12r
#define WRITELN_FEC_DBG_ERRAHTSC_12r BCMI_TSCE16_XGXS_WRITELN_FEC_DBG_ERRAHTSC_12r
#define WRITEALL_FEC_DBG_ERRAHTSC_12r BCMI_TSCE16_XGXS_WRITEALL_FEC_DBG_ERRAHTSC_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_FEC_DBG_ERRAHTSC_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  FEC_BURST_ERR_STSLTSC_12
 * BLOCKS:   RX_X4_STATUS0_TSC_12
 * REGADDR:  0xc172
 * DESC:     fec burst error status lower 16 bits
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BURST_ERR_STATUSL 16 LSB of the fec_burst_err_statusbits mapping :Bit [15:0] : b21[15:0]Note: Bit 15 of Fec_burst_err_statusH register clears upon reading this register
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSLTSC_12r (0x0000c172 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSLTSC_12r_SIZE 4

/*
 * This structure should be used to declare and program FEC_BURST_ERR_STSLTSC_12.
 *
 */
typedef union BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSLTSC_12r_s {
	uint32_t v[1];
	uint32_t fec_burst_err_stsltsc_12[1];
	uint32_t _fec_burst_err_stsltsc_12;
} BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSLTSC_12r_t;

#define BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSLTSC_12r_CLR(r) (r).fec_burst_err_stsltsc_12[0] = 0
#define BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSLTSC_12r_SET(r,d) (r).fec_burst_err_stsltsc_12[0] = d
#define BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSLTSC_12r_GET(r) (r).fec_burst_err_stsltsc_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSLTSC_12r_BURST_ERR_STATUSLf_GET(r) (((r).fec_burst_err_stsltsc_12[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSLTSC_12r_BURST_ERR_STATUSLf_SET(r,f) (r).fec_burst_err_stsltsc_12[0]=(((r).fec_burst_err_stsltsc_12[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access FEC_BURST_ERR_STSLTSC_12.
 *
 */
#define BCMI_TSCE16_XGXS_READ_FEC_BURST_ERR_STSLTSC_12r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSLTSC_12r,(_r._fec_burst_err_stsltsc_12))
#define BCMI_TSCE16_XGXS_WRITE_FEC_BURST_ERR_STSLTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSLTSC_12r,(_r._fec_burst_err_stsltsc_12)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_FEC_BURST_ERR_STSLTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSLTSC_12r,(_r._fec_burst_err_stsltsc_12))
#define BCMI_TSCE16_XGXS_READLN_FEC_BURST_ERR_STSLTSC_12r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSLTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._fec_burst_err_stsltsc_12))
#define BCMI_TSCE16_XGXS_WRITELN_FEC_BURST_ERR_STSLTSC_12r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSLTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._fec_burst_err_stsltsc_12))
#define BCMI_TSCE16_XGXS_WRITEALL_FEC_BURST_ERR_STSLTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSLTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._fec_burst_err_stsltsc_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FEC_BURST_ERR_STSLTSC_12r BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSLTSC_12r
#define FEC_BURST_ERR_STSLTSC_12r_SIZE BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSLTSC_12r_SIZE
typedef BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSLTSC_12r_t FEC_BURST_ERR_STSLTSC_12r_t;
#define FEC_BURST_ERR_STSLTSC_12r_CLR BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSLTSC_12r_CLR
#define FEC_BURST_ERR_STSLTSC_12r_SET BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSLTSC_12r_SET
#define FEC_BURST_ERR_STSLTSC_12r_GET BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSLTSC_12r_GET
#define FEC_BURST_ERR_STSLTSC_12r_BURST_ERR_STATUSLf_GET BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSLTSC_12r_BURST_ERR_STATUSLf_GET
#define FEC_BURST_ERR_STSLTSC_12r_BURST_ERR_STATUSLf_SET BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSLTSC_12r_BURST_ERR_STATUSLf_SET
#define READ_FEC_BURST_ERR_STSLTSC_12r BCMI_TSCE16_XGXS_READ_FEC_BURST_ERR_STSLTSC_12r
#define WRITE_FEC_BURST_ERR_STSLTSC_12r BCMI_TSCE16_XGXS_WRITE_FEC_BURST_ERR_STSLTSC_12r
#define MODIFY_FEC_BURST_ERR_STSLTSC_12r BCMI_TSCE16_XGXS_MODIFY_FEC_BURST_ERR_STSLTSC_12r
#define READLN_FEC_BURST_ERR_STSLTSC_12r BCMI_TSCE16_XGXS_READLN_FEC_BURST_ERR_STSLTSC_12r
#define WRITELN_FEC_BURST_ERR_STSLTSC_12r BCMI_TSCE16_XGXS_WRITELN_FEC_BURST_ERR_STSLTSC_12r
#define WRITEALL_FEC_BURST_ERR_STSLTSC_12r BCMI_TSCE16_XGXS_WRITEALL_FEC_BURST_ERR_STSLTSC_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSLTSC_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  FEC_BURST_ERR_STSHTSC_12
 * BLOCKS:   RX_X4_STATUS0_TSC_12
 * REGADDR:  0xc173
 * DESC:     fec burst error status lower 16 bits
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BURST_ERR_STATUSH 16 MSB of the fec_burst_err_statusbits mapping :Bit 15: status updatedBit 8: 21-bit burst detected, but location failed pattern searchBit 7: pattern match passedBit 6: Corrected alternate errorBit 5: Corrected errorBit [4:0] : b21[20:16]Note: Bit 15 clears upon reading Fec_burst_err_statusL register
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSHTSC_12r (0x0000c173 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSHTSC_12r_SIZE 4

/*
 * This structure should be used to declare and program FEC_BURST_ERR_STSHTSC_12.
 *
 */
typedef union BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSHTSC_12r_s {
	uint32_t v[1];
	uint32_t fec_burst_err_stshtsc_12[1];
	uint32_t _fec_burst_err_stshtsc_12;
} BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSHTSC_12r_t;

#define BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSHTSC_12r_CLR(r) (r).fec_burst_err_stshtsc_12[0] = 0
#define BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSHTSC_12r_SET(r,d) (r).fec_burst_err_stshtsc_12[0] = d
#define BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSHTSC_12r_GET(r) (r).fec_burst_err_stshtsc_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSHTSC_12r_BURST_ERR_STATUSHf_GET(r) (((r).fec_burst_err_stshtsc_12[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSHTSC_12r_BURST_ERR_STATUSHf_SET(r,f) (r).fec_burst_err_stshtsc_12[0]=(((r).fec_burst_err_stshtsc_12[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access FEC_BURST_ERR_STSHTSC_12.
 *
 */
#define BCMI_TSCE16_XGXS_READ_FEC_BURST_ERR_STSHTSC_12r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSHTSC_12r,(_r._fec_burst_err_stshtsc_12))
#define BCMI_TSCE16_XGXS_WRITE_FEC_BURST_ERR_STSHTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSHTSC_12r,(_r._fec_burst_err_stshtsc_12)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_FEC_BURST_ERR_STSHTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSHTSC_12r,(_r._fec_burst_err_stshtsc_12))
#define BCMI_TSCE16_XGXS_READLN_FEC_BURST_ERR_STSHTSC_12r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSHTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._fec_burst_err_stshtsc_12))
#define BCMI_TSCE16_XGXS_WRITELN_FEC_BURST_ERR_STSHTSC_12r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSHTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._fec_burst_err_stshtsc_12))
#define BCMI_TSCE16_XGXS_WRITEALL_FEC_BURST_ERR_STSHTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSHTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._fec_burst_err_stshtsc_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FEC_BURST_ERR_STSHTSC_12r BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSHTSC_12r
#define FEC_BURST_ERR_STSHTSC_12r_SIZE BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSHTSC_12r_SIZE
typedef BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSHTSC_12r_t FEC_BURST_ERR_STSHTSC_12r_t;
#define FEC_BURST_ERR_STSHTSC_12r_CLR BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSHTSC_12r_CLR
#define FEC_BURST_ERR_STSHTSC_12r_SET BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSHTSC_12r_SET
#define FEC_BURST_ERR_STSHTSC_12r_GET BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSHTSC_12r_GET
#define FEC_BURST_ERR_STSHTSC_12r_BURST_ERR_STATUSHf_GET BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSHTSC_12r_BURST_ERR_STATUSHf_GET
#define FEC_BURST_ERR_STSHTSC_12r_BURST_ERR_STATUSHf_SET BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSHTSC_12r_BURST_ERR_STATUSHf_SET
#define READ_FEC_BURST_ERR_STSHTSC_12r BCMI_TSCE16_XGXS_READ_FEC_BURST_ERR_STSHTSC_12r
#define WRITE_FEC_BURST_ERR_STSHTSC_12r BCMI_TSCE16_XGXS_WRITE_FEC_BURST_ERR_STSHTSC_12r
#define MODIFY_FEC_BURST_ERR_STSHTSC_12r BCMI_TSCE16_XGXS_MODIFY_FEC_BURST_ERR_STSHTSC_12r
#define READLN_FEC_BURST_ERR_STSHTSC_12r BCMI_TSCE16_XGXS_READLN_FEC_BURST_ERR_STSHTSC_12r
#define WRITELN_FEC_BURST_ERR_STSHTSC_12r BCMI_TSCE16_XGXS_WRITELN_FEC_BURST_ERR_STSHTSC_12r
#define WRITEALL_FEC_BURST_ERR_STSHTSC_12r BCMI_TSCE16_XGXS_WRITEALL_FEC_BURST_ERR_STSHTSC_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_FEC_BURST_ERR_STSHTSC_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  BERCNTTSC_12
 * BLOCKS:   RX_X4_STATUS0_TSC_12
 * REGADDR:  0xc174
 * DESC:     bercount register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BIP_ERROR_COUNT_PER_LANE 
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_BERCNTTSC_12r (0x0000c174 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_BERCNTTSC_12r_SIZE 4

/*
 * This structure should be used to declare and program BERCNTTSC_12.
 *
 */
typedef union BCMI_TSCE16_XGXS_BERCNTTSC_12r_s {
	uint32_t v[1];
	uint32_t bercnttsc_12[1];
	uint32_t _bercnttsc_12;
} BCMI_TSCE16_XGXS_BERCNTTSC_12r_t;

#define BCMI_TSCE16_XGXS_BERCNTTSC_12r_CLR(r) (r).bercnttsc_12[0] = 0
#define BCMI_TSCE16_XGXS_BERCNTTSC_12r_SET(r,d) (r).bercnttsc_12[0] = d
#define BCMI_TSCE16_XGXS_BERCNTTSC_12r_GET(r) (r).bercnttsc_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_BERCNTTSC_12r_BIP_ERROR_COUNT_PER_LANEf_GET(r) (((r).bercnttsc_12[0]) & 0xff)
#define BCMI_TSCE16_XGXS_BERCNTTSC_12r_BIP_ERROR_COUNT_PER_LANEf_SET(r,f) (r).bercnttsc_12[0]=(((r).bercnttsc_12[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access BERCNTTSC_12.
 *
 */
#define BCMI_TSCE16_XGXS_READ_BERCNTTSC_12r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_BERCNTTSC_12r,(_r._bercnttsc_12))
#define BCMI_TSCE16_XGXS_WRITE_BERCNTTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_BERCNTTSC_12r,(_r._bercnttsc_12)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_BERCNTTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_BERCNTTSC_12r,(_r._bercnttsc_12))
#define BCMI_TSCE16_XGXS_READLN_BERCNTTSC_12r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_BERCNTTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._bercnttsc_12))
#define BCMI_TSCE16_XGXS_WRITELN_BERCNTTSC_12r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_BERCNTTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._bercnttsc_12))
#define BCMI_TSCE16_XGXS_WRITEALL_BERCNTTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_BERCNTTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._bercnttsc_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define BERCNTTSC_12r BCMI_TSCE16_XGXS_BERCNTTSC_12r
#define BERCNTTSC_12r_SIZE BCMI_TSCE16_XGXS_BERCNTTSC_12r_SIZE
typedef BCMI_TSCE16_XGXS_BERCNTTSC_12r_t BERCNTTSC_12r_t;
#define BERCNTTSC_12r_CLR BCMI_TSCE16_XGXS_BERCNTTSC_12r_CLR
#define BERCNTTSC_12r_SET BCMI_TSCE16_XGXS_BERCNTTSC_12r_SET
#define BERCNTTSC_12r_GET BCMI_TSCE16_XGXS_BERCNTTSC_12r_GET
#define BERCNTTSC_12r_BIP_ERROR_COUNT_PER_LANEf_GET BCMI_TSCE16_XGXS_BERCNTTSC_12r_BIP_ERROR_COUNT_PER_LANEf_GET
#define BERCNTTSC_12r_BIP_ERROR_COUNT_PER_LANEf_SET BCMI_TSCE16_XGXS_BERCNTTSC_12r_BIP_ERROR_COUNT_PER_LANEf_SET
#define READ_BERCNTTSC_12r BCMI_TSCE16_XGXS_READ_BERCNTTSC_12r
#define WRITE_BERCNTTSC_12r BCMI_TSCE16_XGXS_WRITE_BERCNTTSC_12r
#define MODIFY_BERCNTTSC_12r BCMI_TSCE16_XGXS_MODIFY_BERCNTTSC_12r
#define READLN_BERCNTTSC_12r BCMI_TSCE16_XGXS_READLN_BERCNTTSC_12r
#define WRITELN_BERCNTTSC_12r BCMI_TSCE16_XGXS_WRITELN_BERCNTTSC_12r
#define WRITEALL_BERCNTTSC_12r BCMI_TSCE16_XGXS_WRITEALL_BERCNTTSC_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_BERCNTTSC_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  CL49_LOCK_FSM_STSTSC_12
 * BLOCKS:   RX_X4_STATUS0_TSC_12
 * REGADDR:  0xc175
 * DESC:     TSC_12 EXTENSION of CL49 Lock Status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LSM_CURR_STATE   Lock FSM - current stateLOCK_INIT:  lsm_state_coded_ = 2'b00;TEST_SH:    lsm_state_coded_ = 2'b01;TEST_SH2:   lsm_state_coded_ = 2'b10;default:    lsm_state_coded_ = 2'b11;Per lane status - For pseduo logical lanes 4-7
 *     LSM_HIS_STATE    Lock SM - latched states - latched on entryLOCK_INIT	3'b001TEST_SH 	3'b010TEST_SH2	3'b100Per lane status - For pseduo logical lanes 4-7
 *     ALIGN_STATUS_CL82 
 *     RMLD_STATUS      
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r (0x0000c175 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r_SIZE 4

/*
 * This structure should be used to declare and program CL49_LOCK_FSM_STSTSC_12.
 *
 */
typedef union BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r_s {
	uint32_t v[1];
	uint32_t cl49_lock_fsm_ststsc_12[1];
	uint32_t _cl49_lock_fsm_ststsc_12;
} BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r_t;

#define BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r_CLR(r) (r).cl49_lock_fsm_ststsc_12[0] = 0
#define BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r_SET(r,d) (r).cl49_lock_fsm_ststsc_12[0] = d
#define BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r_GET(r) (r).cl49_lock_fsm_ststsc_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r_RMLD_STATUSf_GET(r) ((((r).cl49_lock_fsm_ststsc_12[0]) >> 8) & 0xff)
#define BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r_RMLD_STATUSf_SET(r,f) (r).cl49_lock_fsm_ststsc_12[0]=(((r).cl49_lock_fsm_ststsc_12[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r_ALIGN_STATUS_CL82f_GET(r) ((((r).cl49_lock_fsm_ststsc_12[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r_ALIGN_STATUS_CL82f_SET(r,f) (r).cl49_lock_fsm_ststsc_12[0]=(((r).cl49_lock_fsm_ststsc_12[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r_LSM_HIS_STATEf_GET(r) ((((r).cl49_lock_fsm_ststsc_12[0]) >> 2) & 0x7)
#define BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r_LSM_HIS_STATEf_SET(r,f) (r).cl49_lock_fsm_ststsc_12[0]=(((r).cl49_lock_fsm_ststsc_12[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2)) | (7 << (16 + 2))
#define BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r_LSM_CURR_STATEf_GET(r) (((r).cl49_lock_fsm_ststsc_12[0]) & 0x3)
#define BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r_LSM_CURR_STATEf_SET(r,f) (r).cl49_lock_fsm_ststsc_12[0]=(((r).cl49_lock_fsm_ststsc_12[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access CL49_LOCK_FSM_STSTSC_12.
 *
 */
#define BCMI_TSCE16_XGXS_READ_CL49_LOCK_FSM_STSTSC_12r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r,(_r._cl49_lock_fsm_ststsc_12))
#define BCMI_TSCE16_XGXS_WRITE_CL49_LOCK_FSM_STSTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r,(_r._cl49_lock_fsm_ststsc_12)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_CL49_LOCK_FSM_STSTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r,(_r._cl49_lock_fsm_ststsc_12))
#define BCMI_TSCE16_XGXS_READLN_CL49_LOCK_FSM_STSTSC_12r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl49_lock_fsm_ststsc_12))
#define BCMI_TSCE16_XGXS_WRITELN_CL49_LOCK_FSM_STSTSC_12r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl49_lock_fsm_ststsc_12))
#define BCMI_TSCE16_XGXS_WRITEALL_CL49_LOCK_FSM_STSTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl49_lock_fsm_ststsc_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL49_LOCK_FSM_STSTSC_12r BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r
#define CL49_LOCK_FSM_STSTSC_12r_SIZE BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r_SIZE
typedef BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r_t CL49_LOCK_FSM_STSTSC_12r_t;
#define CL49_LOCK_FSM_STSTSC_12r_CLR BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r_CLR
#define CL49_LOCK_FSM_STSTSC_12r_SET BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r_SET
#define CL49_LOCK_FSM_STSTSC_12r_GET BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r_GET
#define CL49_LOCK_FSM_STSTSC_12r_RMLD_STATUSf_GET BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r_RMLD_STATUSf_GET
#define CL49_LOCK_FSM_STSTSC_12r_RMLD_STATUSf_SET BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r_RMLD_STATUSf_SET
#define CL49_LOCK_FSM_STSTSC_12r_ALIGN_STATUS_CL82f_GET BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r_ALIGN_STATUS_CL82f_GET
#define CL49_LOCK_FSM_STSTSC_12r_ALIGN_STATUS_CL82f_SET BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r_ALIGN_STATUS_CL82f_SET
#define CL49_LOCK_FSM_STSTSC_12r_LSM_HIS_STATEf_GET BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r_LSM_HIS_STATEf_GET
#define CL49_LOCK_FSM_STSTSC_12r_LSM_HIS_STATEf_SET BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r_LSM_HIS_STATEf_SET
#define CL49_LOCK_FSM_STSTSC_12r_LSM_CURR_STATEf_GET BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r_LSM_CURR_STATEf_GET
#define CL49_LOCK_FSM_STSTSC_12r_LSM_CURR_STATEf_SET BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r_LSM_CURR_STATEf_SET
#define READ_CL49_LOCK_FSM_STSTSC_12r BCMI_TSCE16_XGXS_READ_CL49_LOCK_FSM_STSTSC_12r
#define WRITE_CL49_LOCK_FSM_STSTSC_12r BCMI_TSCE16_XGXS_WRITE_CL49_LOCK_FSM_STSTSC_12r
#define MODIFY_CL49_LOCK_FSM_STSTSC_12r BCMI_TSCE16_XGXS_MODIFY_CL49_LOCK_FSM_STSTSC_12r
#define READLN_CL49_LOCK_FSM_STSTSC_12r BCMI_TSCE16_XGXS_READLN_CL49_LOCK_FSM_STSTSC_12r
#define WRITELN_CL49_LOCK_FSM_STSTSC_12r BCMI_TSCE16_XGXS_WRITELN_CL49_LOCK_FSM_STSTSC_12r
#define WRITEALL_CL49_LOCK_FSM_STSTSC_12r BCMI_TSCE16_XGXS_WRITEALL_CL49_LOCK_FSM_STSTSC_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_CL49_LOCK_FSM_STSTSC_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  MLD_VL_INFO_0TSC_12
 * BLOCKS:   RX_X4_STATUS0_TSC_12
 * REGADDR:  0xc176
 * DESC:     TSC_12 VIRTUAL LANE MAPPING
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     VL_ON_LL_0       Indicates which Virtual Lane blocks are arriving on this Lane
 *     VL_ON_LL_1       Indicates which Virtual Lane blocks are arriving on this Lane
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_MLD_VL_INFO_0TSC_12r (0x0000c176 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_MLD_VL_INFO_0TSC_12r_SIZE 4

/*
 * This structure should be used to declare and program MLD_VL_INFO_0TSC_12.
 *
 */
typedef union BCMI_TSCE16_XGXS_MLD_VL_INFO_0TSC_12r_s {
	uint32_t v[1];
	uint32_t mld_vl_info_0tsc_12[1];
	uint32_t _mld_vl_info_0tsc_12;
} BCMI_TSCE16_XGXS_MLD_VL_INFO_0TSC_12r_t;

#define BCMI_TSCE16_XGXS_MLD_VL_INFO_0TSC_12r_CLR(r) (r).mld_vl_info_0tsc_12[0] = 0
#define BCMI_TSCE16_XGXS_MLD_VL_INFO_0TSC_12r_SET(r,d) (r).mld_vl_info_0tsc_12[0] = d
#define BCMI_TSCE16_XGXS_MLD_VL_INFO_0TSC_12r_GET(r) (r).mld_vl_info_0tsc_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_MLD_VL_INFO_0TSC_12r_VL_ON_LL_1f_GET(r) ((((r).mld_vl_info_0tsc_12[0]) >> 5) & 0x1f)
#define BCMI_TSCE16_XGXS_MLD_VL_INFO_0TSC_12r_VL_ON_LL_1f_SET(r,f) (r).mld_vl_info_0tsc_12[0]=(((r).mld_vl_info_0tsc_12[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_TSCE16_XGXS_MLD_VL_INFO_0TSC_12r_VL_ON_LL_0f_GET(r) (((r).mld_vl_info_0tsc_12[0]) & 0x1f)
#define BCMI_TSCE16_XGXS_MLD_VL_INFO_0TSC_12r_VL_ON_LL_0f_SET(r,f) (r).mld_vl_info_0tsc_12[0]=(((r).mld_vl_info_0tsc_12[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access MLD_VL_INFO_0TSC_12.
 *
 */
#define BCMI_TSCE16_XGXS_READ_MLD_VL_INFO_0TSC_12r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MLD_VL_INFO_0TSC_12r,(_r._mld_vl_info_0tsc_12))
#define BCMI_TSCE16_XGXS_WRITE_MLD_VL_INFO_0TSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MLD_VL_INFO_0TSC_12r,(_r._mld_vl_info_0tsc_12)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_MLD_VL_INFO_0TSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MLD_VL_INFO_0TSC_12r,(_r._mld_vl_info_0tsc_12))
#define BCMI_TSCE16_XGXS_READLN_MLD_VL_INFO_0TSC_12r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MLD_VL_INFO_0TSC_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mld_vl_info_0tsc_12))
#define BCMI_TSCE16_XGXS_WRITELN_MLD_VL_INFO_0TSC_12r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MLD_VL_INFO_0TSC_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mld_vl_info_0tsc_12))
#define BCMI_TSCE16_XGXS_WRITEALL_MLD_VL_INFO_0TSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MLD_VL_INFO_0TSC_12r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._mld_vl_info_0tsc_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MLD_VL_INFO_0TSC_12r BCMI_TSCE16_XGXS_MLD_VL_INFO_0TSC_12r
#define MLD_VL_INFO_0TSC_12r_SIZE BCMI_TSCE16_XGXS_MLD_VL_INFO_0TSC_12r_SIZE
typedef BCMI_TSCE16_XGXS_MLD_VL_INFO_0TSC_12r_t MLD_VL_INFO_0TSC_12r_t;
#define MLD_VL_INFO_0TSC_12r_CLR BCMI_TSCE16_XGXS_MLD_VL_INFO_0TSC_12r_CLR
#define MLD_VL_INFO_0TSC_12r_SET BCMI_TSCE16_XGXS_MLD_VL_INFO_0TSC_12r_SET
#define MLD_VL_INFO_0TSC_12r_GET BCMI_TSCE16_XGXS_MLD_VL_INFO_0TSC_12r_GET
#define MLD_VL_INFO_0TSC_12r_VL_ON_LL_1f_GET BCMI_TSCE16_XGXS_MLD_VL_INFO_0TSC_12r_VL_ON_LL_1f_GET
#define MLD_VL_INFO_0TSC_12r_VL_ON_LL_1f_SET BCMI_TSCE16_XGXS_MLD_VL_INFO_0TSC_12r_VL_ON_LL_1f_SET
#define MLD_VL_INFO_0TSC_12r_VL_ON_LL_0f_GET BCMI_TSCE16_XGXS_MLD_VL_INFO_0TSC_12r_VL_ON_LL_0f_GET
#define MLD_VL_INFO_0TSC_12r_VL_ON_LL_0f_SET BCMI_TSCE16_XGXS_MLD_VL_INFO_0TSC_12r_VL_ON_LL_0f_SET
#define READ_MLD_VL_INFO_0TSC_12r BCMI_TSCE16_XGXS_READ_MLD_VL_INFO_0TSC_12r
#define WRITE_MLD_VL_INFO_0TSC_12r BCMI_TSCE16_XGXS_WRITE_MLD_VL_INFO_0TSC_12r
#define MODIFY_MLD_VL_INFO_0TSC_12r BCMI_TSCE16_XGXS_MODIFY_MLD_VL_INFO_0TSC_12r
#define READLN_MLD_VL_INFO_0TSC_12r BCMI_TSCE16_XGXS_READLN_MLD_VL_INFO_0TSC_12r
#define WRITELN_MLD_VL_INFO_0TSC_12r BCMI_TSCE16_XGXS_WRITELN_MLD_VL_INFO_0TSC_12r
#define WRITEALL_MLD_VL_INFO_0TSC_12r BCMI_TSCE16_XGXS_WRITEALL_MLD_VL_INFO_0TSC_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_MLD_VL_INFO_0TSC_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  BARREL_SHIFTER_STTSC_12
 * BLOCKS:   RX_X4_STATUS0_TSC_12
 * REGADDR:  0xc177
 * DESC:     Barrel Shifter State
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SHIFT_AMMOUNT    
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_BARREL_SHIFTER_STTSC_12r (0x0000c177 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_BARREL_SHIFTER_STTSC_12r_SIZE 4

/*
 * This structure should be used to declare and program BARREL_SHIFTER_STTSC_12.
 *
 */
typedef union BCMI_TSCE16_XGXS_BARREL_SHIFTER_STTSC_12r_s {
	uint32_t v[1];
	uint32_t barrel_shifter_sttsc_12[1];
	uint32_t _barrel_shifter_sttsc_12;
} BCMI_TSCE16_XGXS_BARREL_SHIFTER_STTSC_12r_t;

#define BCMI_TSCE16_XGXS_BARREL_SHIFTER_STTSC_12r_CLR(r) (r).barrel_shifter_sttsc_12[0] = 0
#define BCMI_TSCE16_XGXS_BARREL_SHIFTER_STTSC_12r_SET(r,d) (r).barrel_shifter_sttsc_12[0] = d
#define BCMI_TSCE16_XGXS_BARREL_SHIFTER_STTSC_12r_GET(r) (r).barrel_shifter_sttsc_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_BARREL_SHIFTER_STTSC_12r_SHIFT_AMMOUNTf_GET(r) (((r).barrel_shifter_sttsc_12[0]) & 0xff)
#define BCMI_TSCE16_XGXS_BARREL_SHIFTER_STTSC_12r_SHIFT_AMMOUNTf_SET(r,f) (r).barrel_shifter_sttsc_12[0]=(((r).barrel_shifter_sttsc_12[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access BARREL_SHIFTER_STTSC_12.
 *
 */
#define BCMI_TSCE16_XGXS_READ_BARREL_SHIFTER_STTSC_12r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_BARREL_SHIFTER_STTSC_12r,(_r._barrel_shifter_sttsc_12))
#define BCMI_TSCE16_XGXS_WRITE_BARREL_SHIFTER_STTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_BARREL_SHIFTER_STTSC_12r,(_r._barrel_shifter_sttsc_12)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_BARREL_SHIFTER_STTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_BARREL_SHIFTER_STTSC_12r,(_r._barrel_shifter_sttsc_12))
#define BCMI_TSCE16_XGXS_READLN_BARREL_SHIFTER_STTSC_12r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_BARREL_SHIFTER_STTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._barrel_shifter_sttsc_12))
#define BCMI_TSCE16_XGXS_WRITELN_BARREL_SHIFTER_STTSC_12r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_BARREL_SHIFTER_STTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._barrel_shifter_sttsc_12))
#define BCMI_TSCE16_XGXS_WRITEALL_BARREL_SHIFTER_STTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_BARREL_SHIFTER_STTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._barrel_shifter_sttsc_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define BARREL_SHIFTER_STTSC_12r BCMI_TSCE16_XGXS_BARREL_SHIFTER_STTSC_12r
#define BARREL_SHIFTER_STTSC_12r_SIZE BCMI_TSCE16_XGXS_BARREL_SHIFTER_STTSC_12r_SIZE
typedef BCMI_TSCE16_XGXS_BARREL_SHIFTER_STTSC_12r_t BARREL_SHIFTER_STTSC_12r_t;
#define BARREL_SHIFTER_STTSC_12r_CLR BCMI_TSCE16_XGXS_BARREL_SHIFTER_STTSC_12r_CLR
#define BARREL_SHIFTER_STTSC_12r_SET BCMI_TSCE16_XGXS_BARREL_SHIFTER_STTSC_12r_SET
#define BARREL_SHIFTER_STTSC_12r_GET BCMI_TSCE16_XGXS_BARREL_SHIFTER_STTSC_12r_GET
#define BARREL_SHIFTER_STTSC_12r_SHIFT_AMMOUNTf_GET BCMI_TSCE16_XGXS_BARREL_SHIFTER_STTSC_12r_SHIFT_AMMOUNTf_GET
#define BARREL_SHIFTER_STTSC_12r_SHIFT_AMMOUNTf_SET BCMI_TSCE16_XGXS_BARREL_SHIFTER_STTSC_12r_SHIFT_AMMOUNTf_SET
#define READ_BARREL_SHIFTER_STTSC_12r BCMI_TSCE16_XGXS_READ_BARREL_SHIFTER_STTSC_12r
#define WRITE_BARREL_SHIFTER_STTSC_12r BCMI_TSCE16_XGXS_WRITE_BARREL_SHIFTER_STTSC_12r
#define MODIFY_BARREL_SHIFTER_STTSC_12r BCMI_TSCE16_XGXS_MODIFY_BARREL_SHIFTER_STTSC_12r
#define READLN_BARREL_SHIFTER_STTSC_12r BCMI_TSCE16_XGXS_READLN_BARREL_SHIFTER_STTSC_12r
#define WRITELN_BARREL_SHIFTER_STTSC_12r BCMI_TSCE16_XGXS_WRITELN_BARREL_SHIFTER_STTSC_12r
#define WRITEALL_BARREL_SHIFTER_STTSC_12r BCMI_TSCE16_XGXS_WRITEALL_BARREL_SHIFTER_STTSC_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_BARREL_SHIFTER_STTSC_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  FEC_CORRBLKSLTSC_12
 * BLOCKS:   RX_X4_STATUS0_TSC_12
 * REGADDR:  0xc178
 * DESC:     FEC corrected blocks counter [15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CORCOUNTL        16 LSB of the corrected blocks count, clear on read
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_FEC_CORRBLKSLTSC_12r (0x0000c178 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_FEC_CORRBLKSLTSC_12r_SIZE 4

/*
 * This structure should be used to declare and program FEC_CORRBLKSLTSC_12.
 *
 */
typedef union BCMI_TSCE16_XGXS_FEC_CORRBLKSLTSC_12r_s {
	uint32_t v[1];
	uint32_t fec_corrblksltsc_12[1];
	uint32_t _fec_corrblksltsc_12;
} BCMI_TSCE16_XGXS_FEC_CORRBLKSLTSC_12r_t;

#define BCMI_TSCE16_XGXS_FEC_CORRBLKSLTSC_12r_CLR(r) (r).fec_corrblksltsc_12[0] = 0
#define BCMI_TSCE16_XGXS_FEC_CORRBLKSLTSC_12r_SET(r,d) (r).fec_corrblksltsc_12[0] = d
#define BCMI_TSCE16_XGXS_FEC_CORRBLKSLTSC_12r_GET(r) (r).fec_corrblksltsc_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_FEC_CORRBLKSLTSC_12r_CORCOUNTLf_GET(r) (((r).fec_corrblksltsc_12[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_FEC_CORRBLKSLTSC_12r_CORCOUNTLf_SET(r,f) (r).fec_corrblksltsc_12[0]=(((r).fec_corrblksltsc_12[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access FEC_CORRBLKSLTSC_12.
 *
 */
#define BCMI_TSCE16_XGXS_READ_FEC_CORRBLKSLTSC_12r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_FEC_CORRBLKSLTSC_12r,(_r._fec_corrblksltsc_12))
#define BCMI_TSCE16_XGXS_WRITE_FEC_CORRBLKSLTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_CORRBLKSLTSC_12r,(_r._fec_corrblksltsc_12)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_FEC_CORRBLKSLTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_CORRBLKSLTSC_12r,(_r._fec_corrblksltsc_12))
#define BCMI_TSCE16_XGXS_READLN_FEC_CORRBLKSLTSC_12r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_FEC_CORRBLKSLTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._fec_corrblksltsc_12))
#define BCMI_TSCE16_XGXS_WRITELN_FEC_CORRBLKSLTSC_12r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_CORRBLKSLTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._fec_corrblksltsc_12))
#define BCMI_TSCE16_XGXS_WRITEALL_FEC_CORRBLKSLTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_CORRBLKSLTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._fec_corrblksltsc_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FEC_CORRBLKSLTSC_12r BCMI_TSCE16_XGXS_FEC_CORRBLKSLTSC_12r
#define FEC_CORRBLKSLTSC_12r_SIZE BCMI_TSCE16_XGXS_FEC_CORRBLKSLTSC_12r_SIZE
typedef BCMI_TSCE16_XGXS_FEC_CORRBLKSLTSC_12r_t FEC_CORRBLKSLTSC_12r_t;
#define FEC_CORRBLKSLTSC_12r_CLR BCMI_TSCE16_XGXS_FEC_CORRBLKSLTSC_12r_CLR
#define FEC_CORRBLKSLTSC_12r_SET BCMI_TSCE16_XGXS_FEC_CORRBLKSLTSC_12r_SET
#define FEC_CORRBLKSLTSC_12r_GET BCMI_TSCE16_XGXS_FEC_CORRBLKSLTSC_12r_GET
#define FEC_CORRBLKSLTSC_12r_CORCOUNTLf_GET BCMI_TSCE16_XGXS_FEC_CORRBLKSLTSC_12r_CORCOUNTLf_GET
#define FEC_CORRBLKSLTSC_12r_CORCOUNTLf_SET BCMI_TSCE16_XGXS_FEC_CORRBLKSLTSC_12r_CORCOUNTLf_SET
#define READ_FEC_CORRBLKSLTSC_12r BCMI_TSCE16_XGXS_READ_FEC_CORRBLKSLTSC_12r
#define WRITE_FEC_CORRBLKSLTSC_12r BCMI_TSCE16_XGXS_WRITE_FEC_CORRBLKSLTSC_12r
#define MODIFY_FEC_CORRBLKSLTSC_12r BCMI_TSCE16_XGXS_MODIFY_FEC_CORRBLKSLTSC_12r
#define READLN_FEC_CORRBLKSLTSC_12r BCMI_TSCE16_XGXS_READLN_FEC_CORRBLKSLTSC_12r
#define WRITELN_FEC_CORRBLKSLTSC_12r BCMI_TSCE16_XGXS_WRITELN_FEC_CORRBLKSLTSC_12r
#define WRITEALL_FEC_CORRBLKSLTSC_12r BCMI_TSCE16_XGXS_WRITEALL_FEC_CORRBLKSLTSC_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_FEC_CORRBLKSLTSC_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  FEC_CORRBLKSHTSC_12
 * BLOCKS:   RX_X4_STATUS0_TSC_12
 * REGADDR:  0xc179
 * DESC:     FEC corrected blocks counter [31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CORCOUNTH        16 MSB of the corrected blocks count, clear on readContents are latched upon read of corCountL
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_FEC_CORRBLKSHTSC_12r (0x0000c179 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_FEC_CORRBLKSHTSC_12r_SIZE 4

/*
 * This structure should be used to declare and program FEC_CORRBLKSHTSC_12.
 *
 */
typedef union BCMI_TSCE16_XGXS_FEC_CORRBLKSHTSC_12r_s {
	uint32_t v[1];
	uint32_t fec_corrblkshtsc_12[1];
	uint32_t _fec_corrblkshtsc_12;
} BCMI_TSCE16_XGXS_FEC_CORRBLKSHTSC_12r_t;

#define BCMI_TSCE16_XGXS_FEC_CORRBLKSHTSC_12r_CLR(r) (r).fec_corrblkshtsc_12[0] = 0
#define BCMI_TSCE16_XGXS_FEC_CORRBLKSHTSC_12r_SET(r,d) (r).fec_corrblkshtsc_12[0] = d
#define BCMI_TSCE16_XGXS_FEC_CORRBLKSHTSC_12r_GET(r) (r).fec_corrblkshtsc_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_FEC_CORRBLKSHTSC_12r_CORCOUNTHf_GET(r) (((r).fec_corrblkshtsc_12[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_FEC_CORRBLKSHTSC_12r_CORCOUNTHf_SET(r,f) (r).fec_corrblkshtsc_12[0]=(((r).fec_corrblkshtsc_12[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access FEC_CORRBLKSHTSC_12.
 *
 */
#define BCMI_TSCE16_XGXS_READ_FEC_CORRBLKSHTSC_12r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_FEC_CORRBLKSHTSC_12r,(_r._fec_corrblkshtsc_12))
#define BCMI_TSCE16_XGXS_WRITE_FEC_CORRBLKSHTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_CORRBLKSHTSC_12r,(_r._fec_corrblkshtsc_12)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_FEC_CORRBLKSHTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_CORRBLKSHTSC_12r,(_r._fec_corrblkshtsc_12))
#define BCMI_TSCE16_XGXS_READLN_FEC_CORRBLKSHTSC_12r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_FEC_CORRBLKSHTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._fec_corrblkshtsc_12))
#define BCMI_TSCE16_XGXS_WRITELN_FEC_CORRBLKSHTSC_12r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_CORRBLKSHTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._fec_corrblkshtsc_12))
#define BCMI_TSCE16_XGXS_WRITEALL_FEC_CORRBLKSHTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_CORRBLKSHTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._fec_corrblkshtsc_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FEC_CORRBLKSHTSC_12r BCMI_TSCE16_XGXS_FEC_CORRBLKSHTSC_12r
#define FEC_CORRBLKSHTSC_12r_SIZE BCMI_TSCE16_XGXS_FEC_CORRBLKSHTSC_12r_SIZE
typedef BCMI_TSCE16_XGXS_FEC_CORRBLKSHTSC_12r_t FEC_CORRBLKSHTSC_12r_t;
#define FEC_CORRBLKSHTSC_12r_CLR BCMI_TSCE16_XGXS_FEC_CORRBLKSHTSC_12r_CLR
#define FEC_CORRBLKSHTSC_12r_SET BCMI_TSCE16_XGXS_FEC_CORRBLKSHTSC_12r_SET
#define FEC_CORRBLKSHTSC_12r_GET BCMI_TSCE16_XGXS_FEC_CORRBLKSHTSC_12r_GET
#define FEC_CORRBLKSHTSC_12r_CORCOUNTHf_GET BCMI_TSCE16_XGXS_FEC_CORRBLKSHTSC_12r_CORCOUNTHf_GET
#define FEC_CORRBLKSHTSC_12r_CORCOUNTHf_SET BCMI_TSCE16_XGXS_FEC_CORRBLKSHTSC_12r_CORCOUNTHf_SET
#define READ_FEC_CORRBLKSHTSC_12r BCMI_TSCE16_XGXS_READ_FEC_CORRBLKSHTSC_12r
#define WRITE_FEC_CORRBLKSHTSC_12r BCMI_TSCE16_XGXS_WRITE_FEC_CORRBLKSHTSC_12r
#define MODIFY_FEC_CORRBLKSHTSC_12r BCMI_TSCE16_XGXS_MODIFY_FEC_CORRBLKSHTSC_12r
#define READLN_FEC_CORRBLKSHTSC_12r BCMI_TSCE16_XGXS_READLN_FEC_CORRBLKSHTSC_12r
#define WRITELN_FEC_CORRBLKSHTSC_12r BCMI_TSCE16_XGXS_WRITELN_FEC_CORRBLKSHTSC_12r
#define WRITEALL_FEC_CORRBLKSHTSC_12r BCMI_TSCE16_XGXS_WRITEALL_FEC_CORRBLKSHTSC_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_FEC_CORRBLKSHTSC_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  FEC_UNCORRBLKSLTSC_12
 * BLOCKS:   RX_X4_STATUS0_TSC_12
 * REGADDR:  0xc17a
 * DESC:     FEC uncorrected blocks counter [15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UNCORCOUNTL      16 LSB of the uncorrected blocks count, clear on read
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_FEC_UNCORRBLKSLTSC_12r (0x0000c17a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_FEC_UNCORRBLKSLTSC_12r_SIZE 4

/*
 * This structure should be used to declare and program FEC_UNCORRBLKSLTSC_12.
 *
 */
typedef union BCMI_TSCE16_XGXS_FEC_UNCORRBLKSLTSC_12r_s {
	uint32_t v[1];
	uint32_t fec_uncorrblksltsc_12[1];
	uint32_t _fec_uncorrblksltsc_12;
} BCMI_TSCE16_XGXS_FEC_UNCORRBLKSLTSC_12r_t;

#define BCMI_TSCE16_XGXS_FEC_UNCORRBLKSLTSC_12r_CLR(r) (r).fec_uncorrblksltsc_12[0] = 0
#define BCMI_TSCE16_XGXS_FEC_UNCORRBLKSLTSC_12r_SET(r,d) (r).fec_uncorrblksltsc_12[0] = d
#define BCMI_TSCE16_XGXS_FEC_UNCORRBLKSLTSC_12r_GET(r) (r).fec_uncorrblksltsc_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_FEC_UNCORRBLKSLTSC_12r_UNCORCOUNTLf_GET(r) (((r).fec_uncorrblksltsc_12[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_FEC_UNCORRBLKSLTSC_12r_UNCORCOUNTLf_SET(r,f) (r).fec_uncorrblksltsc_12[0]=(((r).fec_uncorrblksltsc_12[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access FEC_UNCORRBLKSLTSC_12.
 *
 */
#define BCMI_TSCE16_XGXS_READ_FEC_UNCORRBLKSLTSC_12r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_FEC_UNCORRBLKSLTSC_12r,(_r._fec_uncorrblksltsc_12))
#define BCMI_TSCE16_XGXS_WRITE_FEC_UNCORRBLKSLTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_UNCORRBLKSLTSC_12r,(_r._fec_uncorrblksltsc_12)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_FEC_UNCORRBLKSLTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_UNCORRBLKSLTSC_12r,(_r._fec_uncorrblksltsc_12))
#define BCMI_TSCE16_XGXS_READLN_FEC_UNCORRBLKSLTSC_12r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_FEC_UNCORRBLKSLTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._fec_uncorrblksltsc_12))
#define BCMI_TSCE16_XGXS_WRITELN_FEC_UNCORRBLKSLTSC_12r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_UNCORRBLKSLTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._fec_uncorrblksltsc_12))
#define BCMI_TSCE16_XGXS_WRITEALL_FEC_UNCORRBLKSLTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_UNCORRBLKSLTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._fec_uncorrblksltsc_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FEC_UNCORRBLKSLTSC_12r BCMI_TSCE16_XGXS_FEC_UNCORRBLKSLTSC_12r
#define FEC_UNCORRBLKSLTSC_12r_SIZE BCMI_TSCE16_XGXS_FEC_UNCORRBLKSLTSC_12r_SIZE
typedef BCMI_TSCE16_XGXS_FEC_UNCORRBLKSLTSC_12r_t FEC_UNCORRBLKSLTSC_12r_t;
#define FEC_UNCORRBLKSLTSC_12r_CLR BCMI_TSCE16_XGXS_FEC_UNCORRBLKSLTSC_12r_CLR
#define FEC_UNCORRBLKSLTSC_12r_SET BCMI_TSCE16_XGXS_FEC_UNCORRBLKSLTSC_12r_SET
#define FEC_UNCORRBLKSLTSC_12r_GET BCMI_TSCE16_XGXS_FEC_UNCORRBLKSLTSC_12r_GET
#define FEC_UNCORRBLKSLTSC_12r_UNCORCOUNTLf_GET BCMI_TSCE16_XGXS_FEC_UNCORRBLKSLTSC_12r_UNCORCOUNTLf_GET
#define FEC_UNCORRBLKSLTSC_12r_UNCORCOUNTLf_SET BCMI_TSCE16_XGXS_FEC_UNCORRBLKSLTSC_12r_UNCORCOUNTLf_SET
#define READ_FEC_UNCORRBLKSLTSC_12r BCMI_TSCE16_XGXS_READ_FEC_UNCORRBLKSLTSC_12r
#define WRITE_FEC_UNCORRBLKSLTSC_12r BCMI_TSCE16_XGXS_WRITE_FEC_UNCORRBLKSLTSC_12r
#define MODIFY_FEC_UNCORRBLKSLTSC_12r BCMI_TSCE16_XGXS_MODIFY_FEC_UNCORRBLKSLTSC_12r
#define READLN_FEC_UNCORRBLKSLTSC_12r BCMI_TSCE16_XGXS_READLN_FEC_UNCORRBLKSLTSC_12r
#define WRITELN_FEC_UNCORRBLKSLTSC_12r BCMI_TSCE16_XGXS_WRITELN_FEC_UNCORRBLKSLTSC_12r
#define WRITEALL_FEC_UNCORRBLKSLTSC_12r BCMI_TSCE16_XGXS_WRITEALL_FEC_UNCORRBLKSLTSC_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_FEC_UNCORRBLKSLTSC_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  FEC_UNCORRBLKSHTSC_12
 * BLOCKS:   RX_X4_STATUS0_TSC_12
 * REGADDR:  0xc17b
 * DESC:     FEC uncorrected blocks counter [31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UNCORCOUNTH      16 MSB of the uncorrected blocks count, clear on readContents are latched upon read of uncorCountL
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_FEC_UNCORRBLKSHTSC_12r (0x0000c17b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_FEC_UNCORRBLKSHTSC_12r_SIZE 4

/*
 * This structure should be used to declare and program FEC_UNCORRBLKSHTSC_12.
 *
 */
typedef union BCMI_TSCE16_XGXS_FEC_UNCORRBLKSHTSC_12r_s {
	uint32_t v[1];
	uint32_t fec_uncorrblkshtsc_12[1];
	uint32_t _fec_uncorrblkshtsc_12;
} BCMI_TSCE16_XGXS_FEC_UNCORRBLKSHTSC_12r_t;

#define BCMI_TSCE16_XGXS_FEC_UNCORRBLKSHTSC_12r_CLR(r) (r).fec_uncorrblkshtsc_12[0] = 0
#define BCMI_TSCE16_XGXS_FEC_UNCORRBLKSHTSC_12r_SET(r,d) (r).fec_uncorrblkshtsc_12[0] = d
#define BCMI_TSCE16_XGXS_FEC_UNCORRBLKSHTSC_12r_GET(r) (r).fec_uncorrblkshtsc_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_FEC_UNCORRBLKSHTSC_12r_UNCORCOUNTHf_GET(r) (((r).fec_uncorrblkshtsc_12[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_FEC_UNCORRBLKSHTSC_12r_UNCORCOUNTHf_SET(r,f) (r).fec_uncorrblkshtsc_12[0]=(((r).fec_uncorrblkshtsc_12[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access FEC_UNCORRBLKSHTSC_12.
 *
 */
#define BCMI_TSCE16_XGXS_READ_FEC_UNCORRBLKSHTSC_12r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_FEC_UNCORRBLKSHTSC_12r,(_r._fec_uncorrblkshtsc_12))
#define BCMI_TSCE16_XGXS_WRITE_FEC_UNCORRBLKSHTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_UNCORRBLKSHTSC_12r,(_r._fec_uncorrblkshtsc_12)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_FEC_UNCORRBLKSHTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_UNCORRBLKSHTSC_12r,(_r._fec_uncorrblkshtsc_12))
#define BCMI_TSCE16_XGXS_READLN_FEC_UNCORRBLKSHTSC_12r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_FEC_UNCORRBLKSHTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._fec_uncorrblkshtsc_12))
#define BCMI_TSCE16_XGXS_WRITELN_FEC_UNCORRBLKSHTSC_12r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_UNCORRBLKSHTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._fec_uncorrblkshtsc_12))
#define BCMI_TSCE16_XGXS_WRITEALL_FEC_UNCORRBLKSHTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_FEC_UNCORRBLKSHTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._fec_uncorrblkshtsc_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FEC_UNCORRBLKSHTSC_12r BCMI_TSCE16_XGXS_FEC_UNCORRBLKSHTSC_12r
#define FEC_UNCORRBLKSHTSC_12r_SIZE BCMI_TSCE16_XGXS_FEC_UNCORRBLKSHTSC_12r_SIZE
typedef BCMI_TSCE16_XGXS_FEC_UNCORRBLKSHTSC_12r_t FEC_UNCORRBLKSHTSC_12r_t;
#define FEC_UNCORRBLKSHTSC_12r_CLR BCMI_TSCE16_XGXS_FEC_UNCORRBLKSHTSC_12r_CLR
#define FEC_UNCORRBLKSHTSC_12r_SET BCMI_TSCE16_XGXS_FEC_UNCORRBLKSHTSC_12r_SET
#define FEC_UNCORRBLKSHTSC_12r_GET BCMI_TSCE16_XGXS_FEC_UNCORRBLKSHTSC_12r_GET
#define FEC_UNCORRBLKSHTSC_12r_UNCORCOUNTHf_GET BCMI_TSCE16_XGXS_FEC_UNCORRBLKSHTSC_12r_UNCORCOUNTHf_GET
#define FEC_UNCORRBLKSHTSC_12r_UNCORCOUNTHf_SET BCMI_TSCE16_XGXS_FEC_UNCORRBLKSHTSC_12r_UNCORCOUNTHf_SET
#define READ_FEC_UNCORRBLKSHTSC_12r BCMI_TSCE16_XGXS_READ_FEC_UNCORRBLKSHTSC_12r
#define WRITE_FEC_UNCORRBLKSHTSC_12r BCMI_TSCE16_XGXS_WRITE_FEC_UNCORRBLKSHTSC_12r
#define MODIFY_FEC_UNCORRBLKSHTSC_12r BCMI_TSCE16_XGXS_MODIFY_FEC_UNCORRBLKSHTSC_12r
#define READLN_FEC_UNCORRBLKSHTSC_12r BCMI_TSCE16_XGXS_READLN_FEC_UNCORRBLKSHTSC_12r
#define WRITELN_FEC_UNCORRBLKSHTSC_12r BCMI_TSCE16_XGXS_WRITELN_FEC_UNCORRBLKSHTSC_12r
#define WRITEALL_FEC_UNCORRBLKSHTSC_12r BCMI_TSCE16_XGXS_WRITEALL_FEC_UNCORRBLKSHTSC_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_FEC_UNCORRBLKSHTSC_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  CL82_PCS_LATCH_STSTSC_12
 * BLOCKS:   RX_X4_STATUS0_TSC_12
 * REGADDR:  0xc17c
 * DESC:     CL82 latched_status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AM_LOCK_HIS_STATE Alignment marker history states - per pseudo virtual lanestatus for 4 higher pseudo virtual lanes: 4 to 7. instance 0 of this register is psl lane 4.clear on readbit 9 - INVALID_AMbit 8 - GOOD_AMbit 7 - COMP_AMbit 6 - TIMER_2bit 5 - AM_2_GOODbit 4 - COMP_2NDbit 3 - TIMER_1bit 2 - FIND_1STbit 1 - AM_RESET_CNTbit 0 - AM_LOCK_INIT
 *     AMRKR_SPACING_ERR_LATCH_MUX align marker spacing error detected - per pseudo virtual lanestatus for 4 higher pseudo virtual lanes: 4 to 7. instance 0 of this register is psl lane 4.clear on read
 *     SYNC_STATUS_LL   Per pseudo logical lane: Sync Status indicator has transitioned low since last read.status for 4 higher pseudo virtual lanes: 4 to 7. instance 0 of this register is psl lane 4.(Same as Block lock status) Block alignment for 64/66Clear on read
 *     SYNC_STATUS_LH   Per pseudo logical lane: Sync Status indicator has transitioned high since last read.status for 4 higher pseudo virtual lanes: 4 to 7. instance 0 of this register is psl lane 4.(Same as Block lock status) Block alignment for 64/66Clear on read
 *     AM_LOCK_LL       AM Lock has transitioned low since last read - per pseudo virtual lanestatus for 4 higher pseudo virtual lanes: 4 to 7. instance 0 of this register is psl lane 4.Clear on read
 *     AM_LOCK_LH       AM Lock has transitioned high since last read - per pseudo virtual lanestatus for 4 higher pseudo virtual lanes: 4 to 7. instance 0 of this register is psl lane 4.Clear on read
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r (0x0000c17c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r_SIZE 4

/*
 * This structure should be used to declare and program CL82_PCS_LATCH_STSTSC_12.
 *
 */
typedef union BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r_s {
	uint32_t v[1];
	uint32_t cl82_pcs_latch_ststsc_12[1];
	uint32_t _cl82_pcs_latch_ststsc_12;
} BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r_t;

#define BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r_CLR(r) (r).cl82_pcs_latch_ststsc_12[0] = 0
#define BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r_SET(r,d) (r).cl82_pcs_latch_ststsc_12[0] = d
#define BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r_GET(r) (r).cl82_pcs_latch_ststsc_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r_AM_LOCK_LHf_GET(r) ((((r).cl82_pcs_latch_ststsc_12[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r_AM_LOCK_LHf_SET(r,f) (r).cl82_pcs_latch_ststsc_12[0]=(((r).cl82_pcs_latch_ststsc_12[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r_AM_LOCK_LLf_GET(r) ((((r).cl82_pcs_latch_ststsc_12[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r_AM_LOCK_LLf_SET(r,f) (r).cl82_pcs_latch_ststsc_12[0]=(((r).cl82_pcs_latch_ststsc_12[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r_SYNC_STATUS_LHf_GET(r) ((((r).cl82_pcs_latch_ststsc_12[0]) >> 13) & 0x1)
#define BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r_SYNC_STATUS_LHf_SET(r,f) (r).cl82_pcs_latch_ststsc_12[0]=(((r).cl82_pcs_latch_ststsc_12[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r_SYNC_STATUS_LLf_GET(r) ((((r).cl82_pcs_latch_ststsc_12[0]) >> 12) & 0x1)
#define BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r_SYNC_STATUS_LLf_SET(r,f) (r).cl82_pcs_latch_ststsc_12[0]=(((r).cl82_pcs_latch_ststsc_12[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r_AMRKR_SPACING_ERR_LATCH_MUXf_GET(r) ((((r).cl82_pcs_latch_ststsc_12[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r_AMRKR_SPACING_ERR_LATCH_MUXf_SET(r,f) (r).cl82_pcs_latch_ststsc_12[0]=(((r).cl82_pcs_latch_ststsc_12[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r_AM_LOCK_HIS_STATEf_GET(r) (((r).cl82_pcs_latch_ststsc_12[0]) & 0x3ff)
#define BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r_AM_LOCK_HIS_STATEf_SET(r,f) (r).cl82_pcs_latch_ststsc_12[0]=(((r).cl82_pcs_latch_ststsc_12[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access CL82_PCS_LATCH_STSTSC_12.
 *
 */
#define BCMI_TSCE16_XGXS_READ_CL82_PCS_LATCH_STSTSC_12r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r,(_r._cl82_pcs_latch_ststsc_12))
#define BCMI_TSCE16_XGXS_WRITE_CL82_PCS_LATCH_STSTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r,(_r._cl82_pcs_latch_ststsc_12)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_CL82_PCS_LATCH_STSTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r,(_r._cl82_pcs_latch_ststsc_12))
#define BCMI_TSCE16_XGXS_READLN_CL82_PCS_LATCH_STSTSC_12r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl82_pcs_latch_ststsc_12))
#define BCMI_TSCE16_XGXS_WRITELN_CL82_PCS_LATCH_STSTSC_12r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl82_pcs_latch_ststsc_12))
#define BCMI_TSCE16_XGXS_WRITEALL_CL82_PCS_LATCH_STSTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl82_pcs_latch_ststsc_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL82_PCS_LATCH_STSTSC_12r BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r
#define CL82_PCS_LATCH_STSTSC_12r_SIZE BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r_SIZE
typedef BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r_t CL82_PCS_LATCH_STSTSC_12r_t;
#define CL82_PCS_LATCH_STSTSC_12r_CLR BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r_CLR
#define CL82_PCS_LATCH_STSTSC_12r_SET BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r_SET
#define CL82_PCS_LATCH_STSTSC_12r_GET BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r_GET
#define CL82_PCS_LATCH_STSTSC_12r_AM_LOCK_LHf_GET BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r_AM_LOCK_LHf_GET
#define CL82_PCS_LATCH_STSTSC_12r_AM_LOCK_LHf_SET BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r_AM_LOCK_LHf_SET
#define CL82_PCS_LATCH_STSTSC_12r_AM_LOCK_LLf_GET BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r_AM_LOCK_LLf_GET
#define CL82_PCS_LATCH_STSTSC_12r_AM_LOCK_LLf_SET BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r_AM_LOCK_LLf_SET
#define CL82_PCS_LATCH_STSTSC_12r_SYNC_STATUS_LHf_GET BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r_SYNC_STATUS_LHf_GET
#define CL82_PCS_LATCH_STSTSC_12r_SYNC_STATUS_LHf_SET BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r_SYNC_STATUS_LHf_SET
#define CL82_PCS_LATCH_STSTSC_12r_SYNC_STATUS_LLf_GET BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r_SYNC_STATUS_LLf_GET
#define CL82_PCS_LATCH_STSTSC_12r_SYNC_STATUS_LLf_SET BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r_SYNC_STATUS_LLf_SET
#define CL82_PCS_LATCH_STSTSC_12r_AMRKR_SPACING_ERR_LATCH_MUXf_GET BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r_AMRKR_SPACING_ERR_LATCH_MUXf_GET
#define CL82_PCS_LATCH_STSTSC_12r_AMRKR_SPACING_ERR_LATCH_MUXf_SET BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r_AMRKR_SPACING_ERR_LATCH_MUXf_SET
#define CL82_PCS_LATCH_STSTSC_12r_AM_LOCK_HIS_STATEf_GET BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r_AM_LOCK_HIS_STATEf_GET
#define CL82_PCS_LATCH_STSTSC_12r_AM_LOCK_HIS_STATEf_SET BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r_AM_LOCK_HIS_STATEf_SET
#define READ_CL82_PCS_LATCH_STSTSC_12r BCMI_TSCE16_XGXS_READ_CL82_PCS_LATCH_STSTSC_12r
#define WRITE_CL82_PCS_LATCH_STSTSC_12r BCMI_TSCE16_XGXS_WRITE_CL82_PCS_LATCH_STSTSC_12r
#define MODIFY_CL82_PCS_LATCH_STSTSC_12r BCMI_TSCE16_XGXS_MODIFY_CL82_PCS_LATCH_STSTSC_12r
#define READLN_CL82_PCS_LATCH_STSTSC_12r BCMI_TSCE16_XGXS_READLN_CL82_PCS_LATCH_STSTSC_12r
#define WRITELN_CL82_PCS_LATCH_STSTSC_12r BCMI_TSCE16_XGXS_WRITELN_CL82_PCS_LATCH_STSTSC_12r
#define WRITEALL_CL82_PCS_LATCH_STSTSC_12r BCMI_TSCE16_XGXS_WRITEALL_CL82_PCS_LATCH_STSTSC_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_CL82_PCS_LATCH_STSTSC_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  CL82_PCS_LIVE_STSTSC_12
 * BLOCKS:   RX_X4_STATUS0_TSC_12
 * REGADDR:  0xc17d
 * DESC:     CL82 live status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AM_LOCK_STATE    Alignment marker current states - per pseudo virtual lanestatus for 4 higher pseudo virtual lanes: 4 to 7. instance 0 of this register is psl lane 4.bit 9 - INVALID_AMbit 8 - GOOD_AMbit 7 - COMP_AMbit 6 - TIMER_2bit 5 - AM_2_GOODbit 4 - COMP_2NDbit 3 - TIMER_1bit 2 - FIND_1STbit 1 - AM_RESET_CNTbit 0 - AM_LOCK_INIT
 *     SYNC_STATUS      status for 4 higher pseudo virtual lanes: 4 to 7. instance 0 of this register is psl lane 4.Per pseudo logical lane: Live Block Lock Status indicator for cl82.
 *     AM_LOCK          status for 4 higher pseudo virtual lanes: 4 to 7. instance 0 of this register is psl lane 4.Per pseudo logical lane: AM Lock status
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_CL82_PCS_LIVE_STSTSC_12r (0x0000c17d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_CL82_PCS_LIVE_STSTSC_12r_SIZE 4

/*
 * This structure should be used to declare and program CL82_PCS_LIVE_STSTSC_12.
 *
 */
typedef union BCMI_TSCE16_XGXS_CL82_PCS_LIVE_STSTSC_12r_s {
	uint32_t v[1];
	uint32_t cl82_pcs_live_ststsc_12[1];
	uint32_t _cl82_pcs_live_ststsc_12;
} BCMI_TSCE16_XGXS_CL82_PCS_LIVE_STSTSC_12r_t;

#define BCMI_TSCE16_XGXS_CL82_PCS_LIVE_STSTSC_12r_CLR(r) (r).cl82_pcs_live_ststsc_12[0] = 0
#define BCMI_TSCE16_XGXS_CL82_PCS_LIVE_STSTSC_12r_SET(r,d) (r).cl82_pcs_live_ststsc_12[0] = d
#define BCMI_TSCE16_XGXS_CL82_PCS_LIVE_STSTSC_12r_GET(r) (r).cl82_pcs_live_ststsc_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_CL82_PCS_LIVE_STSTSC_12r_AM_LOCKf_GET(r) ((((r).cl82_pcs_live_ststsc_12[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_CL82_PCS_LIVE_STSTSC_12r_AM_LOCKf_SET(r,f) (r).cl82_pcs_live_ststsc_12[0]=(((r).cl82_pcs_live_ststsc_12[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_CL82_PCS_LIVE_STSTSC_12r_SYNC_STATUSf_GET(r) ((((r).cl82_pcs_live_ststsc_12[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_CL82_PCS_LIVE_STSTSC_12r_SYNC_STATUSf_SET(r,f) (r).cl82_pcs_live_ststsc_12[0]=(((r).cl82_pcs_live_ststsc_12[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_CL82_PCS_LIVE_STSTSC_12r_AM_LOCK_STATEf_GET(r) (((r).cl82_pcs_live_ststsc_12[0]) & 0x3ff)
#define BCMI_TSCE16_XGXS_CL82_PCS_LIVE_STSTSC_12r_AM_LOCK_STATEf_SET(r,f) (r).cl82_pcs_live_ststsc_12[0]=(((r).cl82_pcs_live_ststsc_12[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access CL82_PCS_LIVE_STSTSC_12.
 *
 */
#define BCMI_TSCE16_XGXS_READ_CL82_PCS_LIVE_STSTSC_12r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL82_PCS_LIVE_STSTSC_12r,(_r._cl82_pcs_live_ststsc_12))
#define BCMI_TSCE16_XGXS_WRITE_CL82_PCS_LIVE_STSTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL82_PCS_LIVE_STSTSC_12r,(_r._cl82_pcs_live_ststsc_12)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_CL82_PCS_LIVE_STSTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL82_PCS_LIVE_STSTSC_12r,(_r._cl82_pcs_live_ststsc_12))
#define BCMI_TSCE16_XGXS_READLN_CL82_PCS_LIVE_STSTSC_12r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL82_PCS_LIVE_STSTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl82_pcs_live_ststsc_12))
#define BCMI_TSCE16_XGXS_WRITELN_CL82_PCS_LIVE_STSTSC_12r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL82_PCS_LIVE_STSTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl82_pcs_live_ststsc_12))
#define BCMI_TSCE16_XGXS_WRITEALL_CL82_PCS_LIVE_STSTSC_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL82_PCS_LIVE_STSTSC_12r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl82_pcs_live_ststsc_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL82_PCS_LIVE_STSTSC_12r BCMI_TSCE16_XGXS_CL82_PCS_LIVE_STSTSC_12r
#define CL82_PCS_LIVE_STSTSC_12r_SIZE BCMI_TSCE16_XGXS_CL82_PCS_LIVE_STSTSC_12r_SIZE
typedef BCMI_TSCE16_XGXS_CL82_PCS_LIVE_STSTSC_12r_t CL82_PCS_LIVE_STSTSC_12r_t;
#define CL82_PCS_LIVE_STSTSC_12r_CLR BCMI_TSCE16_XGXS_CL82_PCS_LIVE_STSTSC_12r_CLR
#define CL82_PCS_LIVE_STSTSC_12r_SET BCMI_TSCE16_XGXS_CL82_PCS_LIVE_STSTSC_12r_SET
#define CL82_PCS_LIVE_STSTSC_12r_GET BCMI_TSCE16_XGXS_CL82_PCS_LIVE_STSTSC_12r_GET
#define CL82_PCS_LIVE_STSTSC_12r_AM_LOCKf_GET BCMI_TSCE16_XGXS_CL82_PCS_LIVE_STSTSC_12r_AM_LOCKf_GET
#define CL82_PCS_LIVE_STSTSC_12r_AM_LOCKf_SET BCMI_TSCE16_XGXS_CL82_PCS_LIVE_STSTSC_12r_AM_LOCKf_SET
#define CL82_PCS_LIVE_STSTSC_12r_SYNC_STATUSf_GET BCMI_TSCE16_XGXS_CL82_PCS_LIVE_STSTSC_12r_SYNC_STATUSf_GET
#define CL82_PCS_LIVE_STSTSC_12r_SYNC_STATUSf_SET BCMI_TSCE16_XGXS_CL82_PCS_LIVE_STSTSC_12r_SYNC_STATUSf_SET
#define CL82_PCS_LIVE_STSTSC_12r_AM_LOCK_STATEf_GET BCMI_TSCE16_XGXS_CL82_PCS_LIVE_STSTSC_12r_AM_LOCK_STATEf_GET
#define CL82_PCS_LIVE_STSTSC_12r_AM_LOCK_STATEf_SET BCMI_TSCE16_XGXS_CL82_PCS_LIVE_STSTSC_12r_AM_LOCK_STATEf_SET
#define READ_CL82_PCS_LIVE_STSTSC_12r BCMI_TSCE16_XGXS_READ_CL82_PCS_LIVE_STSTSC_12r
#define WRITE_CL82_PCS_LIVE_STSTSC_12r BCMI_TSCE16_XGXS_WRITE_CL82_PCS_LIVE_STSTSC_12r
#define MODIFY_CL82_PCS_LIVE_STSTSC_12r BCMI_TSCE16_XGXS_MODIFY_CL82_PCS_LIVE_STSTSC_12r
#define READLN_CL82_PCS_LIVE_STSTSC_12r BCMI_TSCE16_XGXS_READLN_CL82_PCS_LIVE_STSTSC_12r
#define WRITELN_CL82_PCS_LIVE_STSTSC_12r BCMI_TSCE16_XGXS_WRITELN_CL82_PCS_LIVE_STSTSC_12r
#define WRITEALL_CL82_PCS_LIVE_STSTSC_12r BCMI_TSCE16_XGXS_WRITEALL_CL82_PCS_LIVE_STSTSC_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_CL82_PCS_LIVE_STSTSC_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X4_ENS
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc180
 * DESC:     AN ENABLES
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL73_AN_RESTART  CL73 Auto-Negotiation RestartA transition from zero to one on this bit will restart CL73 AN
 *     CL37_AN_RESTART  CL37 Auto-Negotiation RestartA transition from zero to one on this bit will restart CL37 AN
 *     HPAM_TO_CL73_AUTO_ENABLE Hewlett-Packard to CL73 Auto-Detect EnableWhen doing Hewlett-Packard auto-negotiation, if the other device is doingIEEE CL73 auto-negotiation, then restart auto-negotiation in IEEE CL73 mode.
 *     CL73_BAM_TO_HPAM_AUTO_ENABLE Broadcom to Hewlett-Packard Auto-Detect EnableWhen doing Broadcom CL73 auto-negotioation, if the other device is doingHewlett-Packard auto-negotiation, then restart auto-negotiation in.Hewlett-Packard mode.
 *     CL37_ENABLE      IEEE CL37 Auto-Negotiation Mode Enable
 *     CL73_ENABLE      IEEE CL73 Auto-Negotiation Mode Enable
 *     CL73_HPAM_ENABLE Hewlett-Packard Auto-Negotiation Mode EnableIf both Broadcom CL73 and Hewlett Packard modes are enabled, then the local device will start in Broadcom CL73 mode.
 *     CL73_BAM_ENABLE  Broadcom CL73 Auto-Negotiation Mode Enable
 *     CL37_BAM_ENABLE  Broadcom CL37 Auto-Negotiation Mode Enable
 *     NUM_ADVERTISED_LANES Defines the number of lanes that are available via the advertised pagesSW must set this field before enabling AN0: one lane1: two lanes2: four lanes3: 10 lanes
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X4_ENSr (0x0000c180 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X4_ENSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_ENS.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X4_ENSr_s {
	uint32_t v[1];
	uint32_t an_x4_ens[1];
	uint32_t _an_x4_ens;
} BCMI_TSCE16_XGXS_AN_X4_ENSr_t;

#define BCMI_TSCE16_XGXS_AN_X4_ENSr_CLR(r) (r).an_x4_ens[0] = 0
#define BCMI_TSCE16_XGXS_AN_X4_ENSr_SET(r,d) (r).an_x4_ens[0] = d
#define BCMI_TSCE16_XGXS_AN_X4_ENSr_GET(r) (r).an_x4_ens[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X4_ENSr_NUM_ADVERTISED_LANESf_GET(r) ((((r).an_x4_ens[0]) >> 12) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X4_ENSr_NUM_ADVERTISED_LANESf_SET(r,f) (r).an_x4_ens[0]=(((r).an_x4_ens[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_TSCE16_XGXS_AN_X4_ENSr_CL37_BAM_ENABLEf_GET(r) ((((r).an_x4_ens[0]) >> 11) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_ENSr_CL37_BAM_ENABLEf_SET(r,f) (r).an_x4_ens[0]=(((r).an_x4_ens[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCE16_XGXS_AN_X4_ENSr_CL73_BAM_ENABLEf_GET(r) ((((r).an_x4_ens[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_ENSr_CL73_BAM_ENABLEf_SET(r,f) (r).an_x4_ens[0]=(((r).an_x4_ens[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_AN_X4_ENSr_CL73_HPAM_ENABLEf_GET(r) ((((r).an_x4_ens[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_ENSr_CL73_HPAM_ENABLEf_SET(r,f) (r).an_x4_ens[0]=(((r).an_x4_ens[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_AN_X4_ENSr_CL73_ENABLEf_GET(r) ((((r).an_x4_ens[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_ENSr_CL73_ENABLEf_SET(r,f) (r).an_x4_ens[0]=(((r).an_x4_ens[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_AN_X4_ENSr_CL37_SGMII_ENABLEf_GET(r) ((((r).an_x4_ens[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_ENSr_CL37_SGMII_ENABLEf_SET(r,f) (r).an_x4_ens[0]=(((r).an_x4_ens[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_AN_X4_ENSr_CL37_ENABLEf_GET(r) ((((r).an_x4_ens[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_ENSr_CL37_ENABLEf_SET(r,f) (r).an_x4_ens[0]=(((r).an_x4_ens[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_AN_X4_ENSr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_GET(r) ((((r).an_x4_ens[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_ENSr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_SET(r,f) (r).an_x4_ens[0]=(((r).an_x4_ens[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_AN_X4_ENSr_SGMII_TO_CL37_AUTO_ENABLEf_GET(r) ((((r).an_x4_ens[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_ENSr_SGMII_TO_CL37_AUTO_ENABLEf_SET(r,f) (r).an_x4_ens[0]=(((r).an_x4_ens[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_AN_X4_ENSr_CL73_BAM_TO_HPAM_AUTO_ENABLEf_GET(r) ((((r).an_x4_ens[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_ENSr_CL73_BAM_TO_HPAM_AUTO_ENABLEf_SET(r,f) (r).an_x4_ens[0]=(((r).an_x4_ens[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_AN_X4_ENSr_HPAM_TO_CL73_AUTO_ENABLEf_GET(r) ((((r).an_x4_ens[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_ENSr_HPAM_TO_CL73_AUTO_ENABLEf_SET(r,f) (r).an_x4_ens[0]=(((r).an_x4_ens[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_AN_X4_ENSr_CL37_AN_RESTARTf_GET(r) ((((r).an_x4_ens[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_ENSr_CL37_AN_RESTARTf_SET(r,f) (r).an_x4_ens[0]=(((r).an_x4_ens[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_AN_X4_ENSr_CL73_AN_RESTARTf_GET(r) (((r).an_x4_ens[0]) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_ENSr_CL73_AN_RESTARTf_SET(r,f) (r).an_x4_ens[0]=(((r).an_x4_ens[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_ENS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X4_ENSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_ENSr,(_r._an_x4_ens))
#define BCMI_TSCE16_XGXS_WRITE_AN_X4_ENSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_ENSr,(_r._an_x4_ens)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X4_ENSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_ENSr,(_r._an_x4_ens))
#define BCMI_TSCE16_XGXS_READLN_AN_X4_ENSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_ENSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ens))
#define BCMI_TSCE16_XGXS_WRITELN_AN_X4_ENSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_ENSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ens))
#define BCMI_TSCE16_XGXS_WRITEALL_AN_X4_ENSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_ENSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_ens))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_ENSr BCMI_TSCE16_XGXS_AN_X4_ENSr
#define AN_X4_ENSr_SIZE BCMI_TSCE16_XGXS_AN_X4_ENSr_SIZE
typedef BCMI_TSCE16_XGXS_AN_X4_ENSr_t AN_X4_ENSr_t;
#define AN_X4_ENSr_CLR BCMI_TSCE16_XGXS_AN_X4_ENSr_CLR
#define AN_X4_ENSr_SET BCMI_TSCE16_XGXS_AN_X4_ENSr_SET
#define AN_X4_ENSr_GET BCMI_TSCE16_XGXS_AN_X4_ENSr_GET
#define AN_X4_ENSr_NUM_ADVERTISED_LANESf_GET BCMI_TSCE16_XGXS_AN_X4_ENSr_NUM_ADVERTISED_LANESf_GET
#define AN_X4_ENSr_NUM_ADVERTISED_LANESf_SET BCMI_TSCE16_XGXS_AN_X4_ENSr_NUM_ADVERTISED_LANESf_SET
#define AN_X4_ENSr_CL37_BAM_ENABLEf_GET BCMI_TSCE16_XGXS_AN_X4_ENSr_CL37_BAM_ENABLEf_GET
#define AN_X4_ENSr_CL37_BAM_ENABLEf_SET BCMI_TSCE16_XGXS_AN_X4_ENSr_CL37_BAM_ENABLEf_SET
#define AN_X4_ENSr_CL73_BAM_ENABLEf_GET BCMI_TSCE16_XGXS_AN_X4_ENSr_CL73_BAM_ENABLEf_GET
#define AN_X4_ENSr_CL73_BAM_ENABLEf_SET BCMI_TSCE16_XGXS_AN_X4_ENSr_CL73_BAM_ENABLEf_SET
#define AN_X4_ENSr_CL73_HPAM_ENABLEf_GET BCMI_TSCE16_XGXS_AN_X4_ENSr_CL73_HPAM_ENABLEf_GET
#define AN_X4_ENSr_CL73_HPAM_ENABLEf_SET BCMI_TSCE16_XGXS_AN_X4_ENSr_CL73_HPAM_ENABLEf_SET
#define AN_X4_ENSr_CL73_ENABLEf_GET BCMI_TSCE16_XGXS_AN_X4_ENSr_CL73_ENABLEf_GET
#define AN_X4_ENSr_CL73_ENABLEf_SET BCMI_TSCE16_XGXS_AN_X4_ENSr_CL73_ENABLEf_SET
#define AN_X4_ENSr_CL37_SGMII_ENABLEf_GET BCMI_TSCE16_XGXS_AN_X4_ENSr_CL37_SGMII_ENABLEf_GET
#define AN_X4_ENSr_CL37_SGMII_ENABLEf_SET BCMI_TSCE16_XGXS_AN_X4_ENSr_CL37_SGMII_ENABLEf_SET
#define AN_X4_ENSr_CL37_ENABLEf_GET BCMI_TSCE16_XGXS_AN_X4_ENSr_CL37_ENABLEf_GET
#define AN_X4_ENSr_CL37_ENABLEf_SET BCMI_TSCE16_XGXS_AN_X4_ENSr_CL37_ENABLEf_SET
#define AN_X4_ENSr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_GET BCMI_TSCE16_XGXS_AN_X4_ENSr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_GET
#define AN_X4_ENSr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_SET BCMI_TSCE16_XGXS_AN_X4_ENSr_CL37_BAM_TO_SGMII_AUTO_ENABLEf_SET
#define AN_X4_ENSr_SGMII_TO_CL37_AUTO_ENABLEf_GET BCMI_TSCE16_XGXS_AN_X4_ENSr_SGMII_TO_CL37_AUTO_ENABLEf_GET
#define AN_X4_ENSr_SGMII_TO_CL37_AUTO_ENABLEf_SET BCMI_TSCE16_XGXS_AN_X4_ENSr_SGMII_TO_CL37_AUTO_ENABLEf_SET
#define AN_X4_ENSr_CL73_BAM_TO_HPAM_AUTO_ENABLEf_GET BCMI_TSCE16_XGXS_AN_X4_ENSr_CL73_BAM_TO_HPAM_AUTO_ENABLEf_GET
#define AN_X4_ENSr_CL73_BAM_TO_HPAM_AUTO_ENABLEf_SET BCMI_TSCE16_XGXS_AN_X4_ENSr_CL73_BAM_TO_HPAM_AUTO_ENABLEf_SET
#define AN_X4_ENSr_HPAM_TO_CL73_AUTO_ENABLEf_GET BCMI_TSCE16_XGXS_AN_X4_ENSr_HPAM_TO_CL73_AUTO_ENABLEf_GET
#define AN_X4_ENSr_HPAM_TO_CL73_AUTO_ENABLEf_SET BCMI_TSCE16_XGXS_AN_X4_ENSr_HPAM_TO_CL73_AUTO_ENABLEf_SET
#define AN_X4_ENSr_CL37_AN_RESTARTf_GET BCMI_TSCE16_XGXS_AN_X4_ENSr_CL37_AN_RESTARTf_GET
#define AN_X4_ENSr_CL37_AN_RESTARTf_SET BCMI_TSCE16_XGXS_AN_X4_ENSr_CL37_AN_RESTARTf_SET
#define AN_X4_ENSr_CL73_AN_RESTARTf_GET BCMI_TSCE16_XGXS_AN_X4_ENSr_CL73_AN_RESTARTf_GET
#define AN_X4_ENSr_CL73_AN_RESTARTf_SET BCMI_TSCE16_XGXS_AN_X4_ENSr_CL73_AN_RESTARTf_SET
#define READ_AN_X4_ENSr BCMI_TSCE16_XGXS_READ_AN_X4_ENSr
#define WRITE_AN_X4_ENSr BCMI_TSCE16_XGXS_WRITE_AN_X4_ENSr
#define MODIFY_AN_X4_ENSr BCMI_TSCE16_XGXS_MODIFY_AN_X4_ENSr
#define READLN_AN_X4_ENSr BCMI_TSCE16_XGXS_READLN_AN_X4_ENSr
#define WRITELN_AN_X4_ENSr BCMI_TSCE16_XGXS_WRITELN_AN_X4_ENSr
#define WRITEALL_AN_X4_ENSr BCMI_TSCE16_XGXS_WRITEALL_AN_X4_ENSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X4_ENSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X4_LOC_DEV_CL37_BASE_ABIL
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc181
 * DESC:     CL37 BASE PAGE ABILITIES
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SGMII_SPEED      11 = Reserved 10 = SGMII 1000 Mb/s 01 = SGMII 100 Mb/s 00 = SGMII 10 Mb/s
 *     SGMII_FULL_DUPLEX 
 *     CL37_FULL_DUPLEX 
 *     CL37_HALF_DUPLEX 
 *     CL37_PAUSE       Pause Ability[7:6]00 - No PAUSE ability10 - Asymmetric-toward-link-partner PAUSE ability01 - Symmetric PAUSE ability11 - Both symmetric and asymmetric-toward-local-device PAUSE ability
 *     CL37_NEXT_PAGE   
 *     SGMII_MASTER_MODE 
 *     AN_PD_TO_CL37_ENABLE Enable CL37 in parallel detect
 *     CL37_AN_RESTART_RESET_DISABLE Disable full pipeline reset when CL37 AN is restarted by remote partner.Do not set this bit for BAM modes.
 *     CL37_SW_RESTART_RESET_DISABLE Disable full pipeline reset when CL37 AN is restarted by SW.Do not set this bit when enabling AN for the first time. Only set it before restarting AN.Do not set this bit for BAM modes.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr (0x0000c181 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LOC_DEV_CL37_BASE_ABIL.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_s {
	uint32_t v[1];
	uint32_t an_x4_loc_dev_cl37_base_abil[1];
	uint32_t _an_x4_loc_dev_cl37_base_abil;
} BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_t;

#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_CLR(r) (r).an_x4_loc_dev_cl37_base_abil[0] = 0
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_SET(r,d) (r).an_x4_loc_dev_cl37_base_abil[0] = d
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_GET(r) (r).an_x4_loc_dev_cl37_base_abil[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_SW_RESTART_RESET_DISABLEf_GET(r) ((((r).an_x4_loc_dev_cl37_base_abil[0]) >> 12) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_SW_RESTART_RESET_DISABLEf_SET(r,f) (r).an_x4_loc_dev_cl37_base_abil[0]=(((r).an_x4_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_AN_RESTART_RESET_DISABLEf_GET(r) ((((r).an_x4_loc_dev_cl37_base_abil[0]) >> 11) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_AN_RESTART_RESET_DISABLEf_SET(r,f) (r).an_x4_loc_dev_cl37_base_abil[0]=(((r).an_x4_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_AN_PD_TO_CL37_ENABLEf_GET(r) ((((r).an_x4_loc_dev_cl37_base_abil[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_AN_PD_TO_CL37_ENABLEf_SET(r,f) (r).an_x4_loc_dev_cl37_base_abil[0]=(((r).an_x4_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_SGMII_MASTER_MODEf_GET(r) ((((r).an_x4_loc_dev_cl37_base_abil[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_SGMII_MASTER_MODEf_SET(r,f) (r).an_x4_loc_dev_cl37_base_abil[0]=(((r).an_x4_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_NEXT_PAGEf_GET(r) ((((r).an_x4_loc_dev_cl37_base_abil[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_NEXT_PAGEf_SET(r,f) (r).an_x4_loc_dev_cl37_base_abil[0]=(((r).an_x4_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_PAUSEf_GET(r) ((((r).an_x4_loc_dev_cl37_base_abil[0]) >> 6) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_PAUSEf_SET(r,f) (r).an_x4_loc_dev_cl37_base_abil[0]=(((r).an_x4_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_HALF_DUPLEXf_GET(r) ((((r).an_x4_loc_dev_cl37_base_abil[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_HALF_DUPLEXf_SET(r,f) (r).an_x4_loc_dev_cl37_base_abil[0]=(((r).an_x4_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_FULL_DUPLEXf_GET(r) ((((r).an_x4_loc_dev_cl37_base_abil[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_FULL_DUPLEXf_SET(r,f) (r).an_x4_loc_dev_cl37_base_abil[0]=(((r).an_x4_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_GET(r) ((((r).an_x4_loc_dev_cl37_base_abil[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_SET(r,f) (r).an_x4_loc_dev_cl37_base_abil[0]=(((r).an_x4_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_SGMII_SPEEDf_GET(r) (((r).an_x4_loc_dev_cl37_base_abil[0]) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_SGMII_SPEEDf_SET(r,f) (r).an_x4_loc_dev_cl37_base_abil[0]=(((r).an_x4_loc_dev_cl37_base_abil[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access AN_X4_LOC_DEV_CL37_BASE_ABIL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X4_LOC_DEV_CL37_BASE_ABILr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr,(_r._an_x4_loc_dev_cl37_base_abil))
#define BCMI_TSCE16_XGXS_WRITE_AN_X4_LOC_DEV_CL37_BASE_ABILr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr,(_r._an_x4_loc_dev_cl37_base_abil)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X4_LOC_DEV_CL37_BASE_ABILr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr,(_r._an_x4_loc_dev_cl37_base_abil))
#define BCMI_TSCE16_XGXS_READLN_AN_X4_LOC_DEV_CL37_BASE_ABILr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_loc_dev_cl37_base_abil))
#define BCMI_TSCE16_XGXS_WRITELN_AN_X4_LOC_DEV_CL37_BASE_ABILr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_loc_dev_cl37_base_abil))
#define BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LOC_DEV_CL37_BASE_ABILr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_loc_dev_cl37_base_abil))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LOC_DEV_CL37_BASE_ABILr BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr
#define AN_X4_LOC_DEV_CL37_BASE_ABILr_SIZE BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_SIZE
typedef BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_t AN_X4_LOC_DEV_CL37_BASE_ABILr_t;
#define AN_X4_LOC_DEV_CL37_BASE_ABILr_CLR BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_CLR
#define AN_X4_LOC_DEV_CL37_BASE_ABILr_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_SET
#define AN_X4_LOC_DEV_CL37_BASE_ABILr_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_GET
#define AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_SW_RESTART_RESET_DISABLEf_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_SW_RESTART_RESET_DISABLEf_GET
#define AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_SW_RESTART_RESET_DISABLEf_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_SW_RESTART_RESET_DISABLEf_SET
#define AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_AN_RESTART_RESET_DISABLEf_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_AN_RESTART_RESET_DISABLEf_GET
#define AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_AN_RESTART_RESET_DISABLEf_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_AN_RESTART_RESET_DISABLEf_SET
#define AN_X4_LOC_DEV_CL37_BASE_ABILr_AN_PD_TO_CL37_ENABLEf_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_AN_PD_TO_CL37_ENABLEf_GET
#define AN_X4_LOC_DEV_CL37_BASE_ABILr_AN_PD_TO_CL37_ENABLEf_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_AN_PD_TO_CL37_ENABLEf_SET
#define AN_X4_LOC_DEV_CL37_BASE_ABILr_SGMII_MASTER_MODEf_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_SGMII_MASTER_MODEf_GET
#define AN_X4_LOC_DEV_CL37_BASE_ABILr_SGMII_MASTER_MODEf_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_SGMII_MASTER_MODEf_SET
#define AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_NEXT_PAGEf_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_NEXT_PAGEf_GET
#define AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_NEXT_PAGEf_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_NEXT_PAGEf_SET
#define AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_PAUSEf_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_PAUSEf_GET
#define AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_PAUSEf_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_PAUSEf_SET
#define AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_HALF_DUPLEXf_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_HALF_DUPLEXf_GET
#define AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_HALF_DUPLEXf_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_HALF_DUPLEXf_SET
#define AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_FULL_DUPLEXf_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_FULL_DUPLEXf_GET
#define AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_FULL_DUPLEXf_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_CL37_FULL_DUPLEXf_SET
#define AN_X4_LOC_DEV_CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_GET
#define AN_X4_LOC_DEV_CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_SGMII_FULL_DUPLEXf_SET
#define AN_X4_LOC_DEV_CL37_BASE_ABILr_SGMII_SPEEDf_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_SGMII_SPEEDf_GET
#define AN_X4_LOC_DEV_CL37_BASE_ABILr_SGMII_SPEEDf_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr_SGMII_SPEEDf_SET
#define READ_AN_X4_LOC_DEV_CL37_BASE_ABILr BCMI_TSCE16_XGXS_READ_AN_X4_LOC_DEV_CL37_BASE_ABILr
#define WRITE_AN_X4_LOC_DEV_CL37_BASE_ABILr BCMI_TSCE16_XGXS_WRITE_AN_X4_LOC_DEV_CL37_BASE_ABILr
#define MODIFY_AN_X4_LOC_DEV_CL37_BASE_ABILr BCMI_TSCE16_XGXS_MODIFY_AN_X4_LOC_DEV_CL37_BASE_ABILr
#define READLN_AN_X4_LOC_DEV_CL37_BASE_ABILr BCMI_TSCE16_XGXS_READLN_AN_X4_LOC_DEV_CL37_BASE_ABILr
#define WRITELN_AN_X4_LOC_DEV_CL37_BASE_ABILr BCMI_TSCE16_XGXS_WRITELN_AN_X4_LOC_DEV_CL37_BASE_ABILr
#define WRITEALL_AN_X4_LOC_DEV_CL37_BASE_ABILr BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LOC_DEV_CL37_BASE_ABILr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BASE_ABILr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X4_LOC_DEV_CL37_BAM_ABIL
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc182
 * DESC:     CL37 BAM ABILITIES
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     OVER1G_PAGE_COUNT 
 *     OVER1G_ABILITY   
 *     CL37_BAM_CODE    
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BAM_ABILr (0x0000c182 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BAM_ABILr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LOC_DEV_CL37_BAM_ABIL.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BAM_ABILr_s {
	uint32_t v[1];
	uint32_t an_x4_loc_dev_cl37_bam_abil[1];
	uint32_t _an_x4_loc_dev_cl37_bam_abil;
} BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BAM_ABILr_t;

#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BAM_ABILr_CLR(r) (r).an_x4_loc_dev_cl37_bam_abil[0] = 0
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BAM_ABILr_SET(r,d) (r).an_x4_loc_dev_cl37_bam_abil[0] = d
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BAM_ABILr_GET(r) (r).an_x4_loc_dev_cl37_bam_abil[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BAM_ABILr_CL37_BAM_CODEf_GET(r) ((((r).an_x4_loc_dev_cl37_bam_abil[0]) >> 3) & 0x1ff)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BAM_ABILr_CL37_BAM_CODEf_SET(r,f) (r).an_x4_loc_dev_cl37_bam_abil[0]=(((r).an_x4_loc_dev_cl37_bam_abil[0] & ~((uint32_t)0x1ff << 3)) | ((((uint32_t)f) & 0x1ff) << 3)) | (511 << (16 + 3))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BAM_ABILr_OVER1G_ABILITYf_GET(r) ((((r).an_x4_loc_dev_cl37_bam_abil[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BAM_ABILr_OVER1G_ABILITYf_SET(r,f) (r).an_x4_loc_dev_cl37_bam_abil[0]=(((r).an_x4_loc_dev_cl37_bam_abil[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_GET(r) (((r).an_x4_loc_dev_cl37_bam_abil[0]) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_SET(r,f) (r).an_x4_loc_dev_cl37_bam_abil[0]=(((r).an_x4_loc_dev_cl37_bam_abil[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access AN_X4_LOC_DEV_CL37_BAM_ABIL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X4_LOC_DEV_CL37_BAM_ABILr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BAM_ABILr,(_r._an_x4_loc_dev_cl37_bam_abil))
#define BCMI_TSCE16_XGXS_WRITE_AN_X4_LOC_DEV_CL37_BAM_ABILr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BAM_ABILr,(_r._an_x4_loc_dev_cl37_bam_abil)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X4_LOC_DEV_CL37_BAM_ABILr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BAM_ABILr,(_r._an_x4_loc_dev_cl37_bam_abil))
#define BCMI_TSCE16_XGXS_READLN_AN_X4_LOC_DEV_CL37_BAM_ABILr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BAM_ABILr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_loc_dev_cl37_bam_abil))
#define BCMI_TSCE16_XGXS_WRITELN_AN_X4_LOC_DEV_CL37_BAM_ABILr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BAM_ABILr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_loc_dev_cl37_bam_abil))
#define BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LOC_DEV_CL37_BAM_ABILr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BAM_ABILr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_loc_dev_cl37_bam_abil))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LOC_DEV_CL37_BAM_ABILr BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BAM_ABILr
#define AN_X4_LOC_DEV_CL37_BAM_ABILr_SIZE BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BAM_ABILr_SIZE
typedef BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BAM_ABILr_t AN_X4_LOC_DEV_CL37_BAM_ABILr_t;
#define AN_X4_LOC_DEV_CL37_BAM_ABILr_CLR BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BAM_ABILr_CLR
#define AN_X4_LOC_DEV_CL37_BAM_ABILr_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BAM_ABILr_SET
#define AN_X4_LOC_DEV_CL37_BAM_ABILr_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BAM_ABILr_GET
#define AN_X4_LOC_DEV_CL37_BAM_ABILr_CL37_BAM_CODEf_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BAM_ABILr_CL37_BAM_CODEf_GET
#define AN_X4_LOC_DEV_CL37_BAM_ABILr_CL37_BAM_CODEf_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BAM_ABILr_CL37_BAM_CODEf_SET
#define AN_X4_LOC_DEV_CL37_BAM_ABILr_OVER1G_ABILITYf_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BAM_ABILr_OVER1G_ABILITYf_GET
#define AN_X4_LOC_DEV_CL37_BAM_ABILr_OVER1G_ABILITYf_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BAM_ABILr_OVER1G_ABILITYf_SET
#define AN_X4_LOC_DEV_CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_GET
#define AN_X4_LOC_DEV_CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BAM_ABILr_OVER1G_PAGE_COUNTf_SET
#define READ_AN_X4_LOC_DEV_CL37_BAM_ABILr BCMI_TSCE16_XGXS_READ_AN_X4_LOC_DEV_CL37_BAM_ABILr
#define WRITE_AN_X4_LOC_DEV_CL37_BAM_ABILr BCMI_TSCE16_XGXS_WRITE_AN_X4_LOC_DEV_CL37_BAM_ABILr
#define MODIFY_AN_X4_LOC_DEV_CL37_BAM_ABILr BCMI_TSCE16_XGXS_MODIFY_AN_X4_LOC_DEV_CL37_BAM_ABILr
#define READLN_AN_X4_LOC_DEV_CL37_BAM_ABILr BCMI_TSCE16_XGXS_READLN_AN_X4_LOC_DEV_CL37_BAM_ABILr
#define WRITELN_AN_X4_LOC_DEV_CL37_BAM_ABILr BCMI_TSCE16_XGXS_WRITELN_AN_X4_LOC_DEV_CL37_BAM_ABILr
#define WRITEALL_AN_X4_LOC_DEV_CL37_BAM_ABILr BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LOC_DEV_CL37_BAM_ABILr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL37_BAM_ABILr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X4_LOC_DEV_OVER1G_ABIL1
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc183
 * DESC:     Cl37 OVER1G ABILITIES REG 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BAM_13GBASE_X4   MP1024 UP1.7
 *     BAM_15GBASE_X4   MP1024 UP1.8
 *     BAM_15P75GBASE_X2 MP1024 UP4.7
 *     BAM_16GBASE_X4   MP1024 UP1.9
 *     BAM_20GBASE_X4_CX4 MP1024 UP1.10
 *     BAM_20GBASE_X4   MP1024 UP4.0
 *     BAM_20GBASE_X2   MP1024 UP4.5
 *     BAM_20GBASE_X2_CX4 MP1024 UP4.6
 *     BAM_21GBASE_X4   MP1024 UP3.9
 *     BAM_25P455GBASE_X4 MP1024 UP3.8
 *     BAM_31P5GBASE_X4 MP1024 UP3.7
 *     BAM_32P7GBASE_X4 Not supported in TSCEMP1024 UP3.6
 *     BAM_40GBASE_X4   MP1024 UP3.5
 *     CL72             MP1024 UP3.2
 *     FEC              MP1024 UP3.1
 *     HG2              MP1024 UP3.0
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r (0x0000c183 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LOC_DEV_OVER1G_ABIL1.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_s {
	uint32_t v[1];
	uint32_t an_x4_loc_dev_over1g_abil1[1];
	uint32_t _an_x4_loc_dev_over1g_abil1;
} BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_t;

#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_CLR(r) (r).an_x4_loc_dev_over1g_abil1[0] = 0
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_SET(r,d) (r).an_x4_loc_dev_over1g_abil1[0] = d
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_GET(r) (r).an_x4_loc_dev_over1g_abil1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_HG2f_GET(r) ((((r).an_x4_loc_dev_over1g_abil1[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_HG2f_SET(r,f) (r).an_x4_loc_dev_over1g_abil1[0]=(((r).an_x4_loc_dev_over1g_abil1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_FECf_GET(r) ((((r).an_x4_loc_dev_over1g_abil1[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_FECf_SET(r,f) (r).an_x4_loc_dev_over1g_abil1[0]=(((r).an_x4_loc_dev_over1g_abil1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_CL72f_GET(r) ((((r).an_x4_loc_dev_over1g_abil1[0]) >> 13) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_CL72f_SET(r,f) (r).an_x4_loc_dev_over1g_abil1[0]=(((r).an_x4_loc_dev_over1g_abil1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_40GBASE_X4f_GET(r) ((((r).an_x4_loc_dev_over1g_abil1[0]) >> 12) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_40GBASE_X4f_SET(r,f) (r).an_x4_loc_dev_over1g_abil1[0]=(((r).an_x4_loc_dev_over1g_abil1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_32P7GBASE_X4f_GET(r) ((((r).an_x4_loc_dev_over1g_abil1[0]) >> 11) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_32P7GBASE_X4f_SET(r,f) (r).an_x4_loc_dev_over1g_abil1[0]=(((r).an_x4_loc_dev_over1g_abil1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_31P5GBASE_X4f_GET(r) ((((r).an_x4_loc_dev_over1g_abil1[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_31P5GBASE_X4f_SET(r,f) (r).an_x4_loc_dev_over1g_abil1[0]=(((r).an_x4_loc_dev_over1g_abil1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_25P455GBASE_X4f_GET(r) ((((r).an_x4_loc_dev_over1g_abil1[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_25P455GBASE_X4f_SET(r,f) (r).an_x4_loc_dev_over1g_abil1[0]=(((r).an_x4_loc_dev_over1g_abil1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_21GBASE_X4f_GET(r) ((((r).an_x4_loc_dev_over1g_abil1[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_21GBASE_X4f_SET(r,f) (r).an_x4_loc_dev_over1g_abil1[0]=(((r).an_x4_loc_dev_over1g_abil1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_20GBASE_X2_CX4f_GET(r) ((((r).an_x4_loc_dev_over1g_abil1[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_20GBASE_X2_CX4f_SET(r,f) (r).an_x4_loc_dev_over1g_abil1[0]=(((r).an_x4_loc_dev_over1g_abil1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_20GBASE_X2f_GET(r) ((((r).an_x4_loc_dev_over1g_abil1[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_20GBASE_X2f_SET(r,f) (r).an_x4_loc_dev_over1g_abil1[0]=(((r).an_x4_loc_dev_over1g_abil1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_20GBASE_X4f_GET(r) ((((r).an_x4_loc_dev_over1g_abil1[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_20GBASE_X4f_SET(r,f) (r).an_x4_loc_dev_over1g_abil1[0]=(((r).an_x4_loc_dev_over1g_abil1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_20GBASE_X4_CX4f_GET(r) ((((r).an_x4_loc_dev_over1g_abil1[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_20GBASE_X4_CX4f_SET(r,f) (r).an_x4_loc_dev_over1g_abil1[0]=(((r).an_x4_loc_dev_over1g_abil1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_16GBASE_X4f_GET(r) ((((r).an_x4_loc_dev_over1g_abil1[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_16GBASE_X4f_SET(r,f) (r).an_x4_loc_dev_over1g_abil1[0]=(((r).an_x4_loc_dev_over1g_abil1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_15P75GBASE_X2f_GET(r) ((((r).an_x4_loc_dev_over1g_abil1[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_15P75GBASE_X2f_SET(r,f) (r).an_x4_loc_dev_over1g_abil1[0]=(((r).an_x4_loc_dev_over1g_abil1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_15GBASE_X4f_GET(r) ((((r).an_x4_loc_dev_over1g_abil1[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_15GBASE_X4f_SET(r,f) (r).an_x4_loc_dev_over1g_abil1[0]=(((r).an_x4_loc_dev_over1g_abil1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_13GBASE_X4f_GET(r) (((r).an_x4_loc_dev_over1g_abil1[0]) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_13GBASE_X4f_SET(r,f) (r).an_x4_loc_dev_over1g_abil1[0]=(((r).an_x4_loc_dev_over1g_abil1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_LOC_DEV_OVER1G_ABIL1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X4_LOC_DEV_OVER1G_ABIL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r,(_r._an_x4_loc_dev_over1g_abil1))
#define BCMI_TSCE16_XGXS_WRITE_AN_X4_LOC_DEV_OVER1G_ABIL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r,(_r._an_x4_loc_dev_over1g_abil1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X4_LOC_DEV_OVER1G_ABIL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r,(_r._an_x4_loc_dev_over1g_abil1))
#define BCMI_TSCE16_XGXS_READLN_AN_X4_LOC_DEV_OVER1G_ABIL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_loc_dev_over1g_abil1))
#define BCMI_TSCE16_XGXS_WRITELN_AN_X4_LOC_DEV_OVER1G_ABIL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_loc_dev_over1g_abil1))
#define BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LOC_DEV_OVER1G_ABIL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_loc_dev_over1g_abil1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LOC_DEV_OVER1G_ABIL1r BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_SIZE BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_SIZE
typedef BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_t AN_X4_LOC_DEV_OVER1G_ABIL1r_t;
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_CLR BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_CLR
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_SET
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_GET
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_HG2f_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_HG2f_GET
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_HG2f_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_HG2f_SET
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_FECf_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_FECf_GET
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_FECf_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_FECf_SET
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_CL72f_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_CL72f_GET
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_CL72f_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_CL72f_SET
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_40GBASE_X4f_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_40GBASE_X4f_GET
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_40GBASE_X4f_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_40GBASE_X4f_SET
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_32P7GBASE_X4f_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_32P7GBASE_X4f_GET
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_32P7GBASE_X4f_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_32P7GBASE_X4f_SET
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_31P5GBASE_X4f_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_31P5GBASE_X4f_GET
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_31P5GBASE_X4f_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_31P5GBASE_X4f_SET
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_25P455GBASE_X4f_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_25P455GBASE_X4f_GET
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_25P455GBASE_X4f_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_25P455GBASE_X4f_SET
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_21GBASE_X4f_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_21GBASE_X4f_GET
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_21GBASE_X4f_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_21GBASE_X4f_SET
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_20GBASE_X2_CX4f_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_20GBASE_X2_CX4f_GET
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_20GBASE_X2_CX4f_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_20GBASE_X2_CX4f_SET
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_20GBASE_X2f_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_20GBASE_X2f_GET
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_20GBASE_X2f_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_20GBASE_X2f_SET
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_20GBASE_X4f_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_20GBASE_X4f_GET
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_20GBASE_X4f_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_20GBASE_X4f_SET
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_20GBASE_X4_CX4f_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_20GBASE_X4_CX4f_GET
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_20GBASE_X4_CX4f_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_20GBASE_X4_CX4f_SET
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_16GBASE_X4f_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_16GBASE_X4f_GET
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_16GBASE_X4f_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_16GBASE_X4f_SET
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_15P75GBASE_X2f_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_15P75GBASE_X2f_GET
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_15P75GBASE_X2f_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_15P75GBASE_X2f_SET
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_15GBASE_X4f_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_15GBASE_X4f_GET
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_15GBASE_X4f_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_15GBASE_X4f_SET
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_13GBASE_X4f_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_13GBASE_X4f_GET
#define AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_13GBASE_X4f_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r_BAM_13GBASE_X4f_SET
#define READ_AN_X4_LOC_DEV_OVER1G_ABIL1r BCMI_TSCE16_XGXS_READ_AN_X4_LOC_DEV_OVER1G_ABIL1r
#define WRITE_AN_X4_LOC_DEV_OVER1G_ABIL1r BCMI_TSCE16_XGXS_WRITE_AN_X4_LOC_DEV_OVER1G_ABIL1r
#define MODIFY_AN_X4_LOC_DEV_OVER1G_ABIL1r BCMI_TSCE16_XGXS_MODIFY_AN_X4_LOC_DEV_OVER1G_ABIL1r
#define READLN_AN_X4_LOC_DEV_OVER1G_ABIL1r BCMI_TSCE16_XGXS_READLN_AN_X4_LOC_DEV_OVER1G_ABIL1r
#define WRITELN_AN_X4_LOC_DEV_OVER1G_ABIL1r BCMI_TSCE16_XGXS_WRITELN_AN_X4_LOC_DEV_OVER1G_ABIL1r
#define WRITEALL_AN_X4_LOC_DEV_OVER1G_ABIL1r BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LOC_DEV_OVER1G_ABIL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X4_LOC_DEV_OVER1G_ABIL0
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc184
 * DESC:     Cl37 OVER1G ABILITIES REG 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BAM_2P5GBASE_X   MP1024 UP1.0
 *     BAM_5GBASE_X4    Not supported in TSCEMP1024 UP1.1
 *     BAM_6GBASE_X4    Not supported in TSCEMP1024 UP1.2
 *     BAM_10GBASE_X4   MP1024 UP1.3
 *     BAM_10GBASE_X4_CX4 MP1024 UP1.4
 *     BAM_10GBASE_X2   MP1024 UP4.1
 *     BAM_10GBASE_X2_CX4 MP1024 UP4.2
 *     BAM_10P5GBASE_X2 MP1024 UP4.3
 *     BAM_12GBASE_X4   Not supported in TSCEMP1024 UP1.5
 *     BAM_12P5GBASE_X4 Not supported in TSCEMP1024 UP1.6
 *     BAM_12P7GBASE_X2 MP1024 UP4.4
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r (0x0000c184 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LOC_DEV_OVER1G_ABIL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_s {
	uint32_t v[1];
	uint32_t an_x4_loc_dev_over1g_abil0[1];
	uint32_t _an_x4_loc_dev_over1g_abil0;
} BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_t;

#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_CLR(r) (r).an_x4_loc_dev_over1g_abil0[0] = 0
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_SET(r,d) (r).an_x4_loc_dev_over1g_abil0[0] = d
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_GET(r) (r).an_x4_loc_dev_over1g_abil0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_12P7GBASE_X2f_GET(r) ((((r).an_x4_loc_dev_over1g_abil0[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_12P7GBASE_X2f_SET(r,f) (r).an_x4_loc_dev_over1g_abil0[0]=(((r).an_x4_loc_dev_over1g_abil0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_12P5GBASE_X4f_GET(r) ((((r).an_x4_loc_dev_over1g_abil0[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_12P5GBASE_X4f_SET(r,f) (r).an_x4_loc_dev_over1g_abil0[0]=(((r).an_x4_loc_dev_over1g_abil0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_12GBASE_X4f_GET(r) ((((r).an_x4_loc_dev_over1g_abil0[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_12GBASE_X4f_SET(r,f) (r).an_x4_loc_dev_over1g_abil0[0]=(((r).an_x4_loc_dev_over1g_abil0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_10P5GBASE_X2f_GET(r) ((((r).an_x4_loc_dev_over1g_abil0[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_10P5GBASE_X2f_SET(r,f) (r).an_x4_loc_dev_over1g_abil0[0]=(((r).an_x4_loc_dev_over1g_abil0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_10GBASE_X2_CX4f_GET(r) ((((r).an_x4_loc_dev_over1g_abil0[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_10GBASE_X2_CX4f_SET(r,f) (r).an_x4_loc_dev_over1g_abil0[0]=(((r).an_x4_loc_dev_over1g_abil0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_10GBASE_X2f_GET(r) ((((r).an_x4_loc_dev_over1g_abil0[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_10GBASE_X2f_SET(r,f) (r).an_x4_loc_dev_over1g_abil0[0]=(((r).an_x4_loc_dev_over1g_abil0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_10GBASE_X4_CX4f_GET(r) ((((r).an_x4_loc_dev_over1g_abil0[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_10GBASE_X4_CX4f_SET(r,f) (r).an_x4_loc_dev_over1g_abil0[0]=(((r).an_x4_loc_dev_over1g_abil0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_10GBASE_X4f_GET(r) ((((r).an_x4_loc_dev_over1g_abil0[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_10GBASE_X4f_SET(r,f) (r).an_x4_loc_dev_over1g_abil0[0]=(((r).an_x4_loc_dev_over1g_abil0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_6GBASE_X4f_GET(r) ((((r).an_x4_loc_dev_over1g_abil0[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_6GBASE_X4f_SET(r,f) (r).an_x4_loc_dev_over1g_abil0[0]=(((r).an_x4_loc_dev_over1g_abil0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_5GBASE_X4f_GET(r) ((((r).an_x4_loc_dev_over1g_abil0[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_5GBASE_X4f_SET(r,f) (r).an_x4_loc_dev_over1g_abil0[0]=(((r).an_x4_loc_dev_over1g_abil0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_2P5GBASE_Xf_GET(r) (((r).an_x4_loc_dev_over1g_abil0[0]) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_2P5GBASE_Xf_SET(r,f) (r).an_x4_loc_dev_over1g_abil0[0]=(((r).an_x4_loc_dev_over1g_abil0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_LOC_DEV_OVER1G_ABIL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X4_LOC_DEV_OVER1G_ABIL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r,(_r._an_x4_loc_dev_over1g_abil0))
#define BCMI_TSCE16_XGXS_WRITE_AN_X4_LOC_DEV_OVER1G_ABIL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r,(_r._an_x4_loc_dev_over1g_abil0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X4_LOC_DEV_OVER1G_ABIL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r,(_r._an_x4_loc_dev_over1g_abil0))
#define BCMI_TSCE16_XGXS_READLN_AN_X4_LOC_DEV_OVER1G_ABIL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_loc_dev_over1g_abil0))
#define BCMI_TSCE16_XGXS_WRITELN_AN_X4_LOC_DEV_OVER1G_ABIL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_loc_dev_over1g_abil0))
#define BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LOC_DEV_OVER1G_ABIL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_loc_dev_over1g_abil0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LOC_DEV_OVER1G_ABIL0r BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r
#define AN_X4_LOC_DEV_OVER1G_ABIL0r_SIZE BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_SIZE
typedef BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_t AN_X4_LOC_DEV_OVER1G_ABIL0r_t;
#define AN_X4_LOC_DEV_OVER1G_ABIL0r_CLR BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_CLR
#define AN_X4_LOC_DEV_OVER1G_ABIL0r_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_SET
#define AN_X4_LOC_DEV_OVER1G_ABIL0r_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_GET
#define AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_12P7GBASE_X2f_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_12P7GBASE_X2f_GET
#define AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_12P7GBASE_X2f_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_12P7GBASE_X2f_SET
#define AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_12P5GBASE_X4f_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_12P5GBASE_X4f_GET
#define AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_12P5GBASE_X4f_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_12P5GBASE_X4f_SET
#define AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_12GBASE_X4f_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_12GBASE_X4f_GET
#define AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_12GBASE_X4f_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_12GBASE_X4f_SET
#define AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_10P5GBASE_X2f_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_10P5GBASE_X2f_GET
#define AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_10P5GBASE_X2f_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_10P5GBASE_X2f_SET
#define AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_10GBASE_X2_CX4f_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_10GBASE_X2_CX4f_GET
#define AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_10GBASE_X2_CX4f_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_10GBASE_X2_CX4f_SET
#define AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_10GBASE_X2f_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_10GBASE_X2f_GET
#define AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_10GBASE_X2f_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_10GBASE_X2f_SET
#define AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_10GBASE_X4_CX4f_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_10GBASE_X4_CX4f_GET
#define AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_10GBASE_X4_CX4f_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_10GBASE_X4_CX4f_SET
#define AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_10GBASE_X4f_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_10GBASE_X4f_GET
#define AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_10GBASE_X4f_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_10GBASE_X4f_SET
#define AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_6GBASE_X4f_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_6GBASE_X4f_GET
#define AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_6GBASE_X4f_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_6GBASE_X4f_SET
#define AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_5GBASE_X4f_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_5GBASE_X4f_GET
#define AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_5GBASE_X4f_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_5GBASE_X4f_SET
#define AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_2P5GBASE_Xf_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_2P5GBASE_Xf_GET
#define AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_2P5GBASE_Xf_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r_BAM_2P5GBASE_Xf_SET
#define READ_AN_X4_LOC_DEV_OVER1G_ABIL0r BCMI_TSCE16_XGXS_READ_AN_X4_LOC_DEV_OVER1G_ABIL0r
#define WRITE_AN_X4_LOC_DEV_OVER1G_ABIL0r BCMI_TSCE16_XGXS_WRITE_AN_X4_LOC_DEV_OVER1G_ABIL0r
#define MODIFY_AN_X4_LOC_DEV_OVER1G_ABIL0r BCMI_TSCE16_XGXS_MODIFY_AN_X4_LOC_DEV_OVER1G_ABIL0r
#define READLN_AN_X4_LOC_DEV_OVER1G_ABIL0r BCMI_TSCE16_XGXS_READLN_AN_X4_LOC_DEV_OVER1G_ABIL0r
#define WRITELN_AN_X4_LOC_DEV_OVER1G_ABIL0r BCMI_TSCE16_XGXS_WRITELN_AN_X4_LOC_DEV_OVER1G_ABIL0r
#define WRITEALL_AN_X4_LOC_DEV_OVER1G_ABIL0r BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LOC_DEV_OVER1G_ABIL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_OVER1G_ABIL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X4_LOC_DEV_CL73_BASE_ABIL1
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc185
 * DESC:     CL73 BASE PAGE ABILITIES REG 1
 * RESETVAL: 0x2a0 (672)
 * ACCESS:   R/W
 * FIELDS:
 *     BASE_SELECTOR    IEEE Annex 28A Message Selector0 - reserved1 - 802.32 - 802.93 - 802.54 - 1394Sent in CL73 base page.
 *     TRANSMIT_NONCE   First CL73 nonce to be transmitted.
 *     CL73_NONCE_MATCH_VAL Clause 73 nonce match value
 *     CL73_NONCE_MATCH_OVER Clause 73 nonce match over-ride
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r (0x0000c185 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LOC_DEV_CL73_BASE_ABIL1.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r_s {
	uint32_t v[1];
	uint32_t an_x4_loc_dev_cl73_base_abil1[1];
	uint32_t _an_x4_loc_dev_cl73_base_abil1;
} BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r_t;

#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r_CLR(r) (r).an_x4_loc_dev_cl73_base_abil1[0] = 0
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r_SET(r,d) (r).an_x4_loc_dev_cl73_base_abil1[0] = d
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r_GET(r) (r).an_x4_loc_dev_cl73_base_abil1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r_CL73_NONCE_MATCH_OVERf_GET(r) ((((r).an_x4_loc_dev_cl73_base_abil1[0]) >> 11) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r_CL73_NONCE_MATCH_OVERf_SET(r,f) (r).an_x4_loc_dev_cl73_base_abil1[0]=(((r).an_x4_loc_dev_cl73_base_abil1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r_CL73_NONCE_MATCH_VALf_GET(r) ((((r).an_x4_loc_dev_cl73_base_abil1[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r_CL73_NONCE_MATCH_VALf_SET(r,f) (r).an_x4_loc_dev_cl73_base_abil1[0]=(((r).an_x4_loc_dev_cl73_base_abil1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r_TRANSMIT_NONCEf_GET(r) ((((r).an_x4_loc_dev_cl73_base_abil1[0]) >> 5) & 0x1f)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r_TRANSMIT_NONCEf_SET(r,f) (r).an_x4_loc_dev_cl73_base_abil1[0]=(((r).an_x4_loc_dev_cl73_base_abil1[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r_BASE_SELECTORf_GET(r) (((r).an_x4_loc_dev_cl73_base_abil1[0]) & 0x1f)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r_BASE_SELECTORf_SET(r,f) (r).an_x4_loc_dev_cl73_base_abil1[0]=(((r).an_x4_loc_dev_cl73_base_abil1[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access AN_X4_LOC_DEV_CL73_BASE_ABIL1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X4_LOC_DEV_CL73_BASE_ABIL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r,(_r._an_x4_loc_dev_cl73_base_abil1))
#define BCMI_TSCE16_XGXS_WRITE_AN_X4_LOC_DEV_CL73_BASE_ABIL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r,(_r._an_x4_loc_dev_cl73_base_abil1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X4_LOC_DEV_CL73_BASE_ABIL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r,(_r._an_x4_loc_dev_cl73_base_abil1))
#define BCMI_TSCE16_XGXS_READLN_AN_X4_LOC_DEV_CL73_BASE_ABIL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_loc_dev_cl73_base_abil1))
#define BCMI_TSCE16_XGXS_WRITELN_AN_X4_LOC_DEV_CL73_BASE_ABIL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_loc_dev_cl73_base_abil1))
#define BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LOC_DEV_CL73_BASE_ABIL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_loc_dev_cl73_base_abil1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LOC_DEV_CL73_BASE_ABIL1r BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r
#define AN_X4_LOC_DEV_CL73_BASE_ABIL1r_SIZE BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r_SIZE
typedef BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r_t AN_X4_LOC_DEV_CL73_BASE_ABIL1r_t;
#define AN_X4_LOC_DEV_CL73_BASE_ABIL1r_CLR BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r_CLR
#define AN_X4_LOC_DEV_CL73_BASE_ABIL1r_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r_SET
#define AN_X4_LOC_DEV_CL73_BASE_ABIL1r_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r_GET
#define AN_X4_LOC_DEV_CL73_BASE_ABIL1r_CL73_NONCE_MATCH_OVERf_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r_CL73_NONCE_MATCH_OVERf_GET
#define AN_X4_LOC_DEV_CL73_BASE_ABIL1r_CL73_NONCE_MATCH_OVERf_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r_CL73_NONCE_MATCH_OVERf_SET
#define AN_X4_LOC_DEV_CL73_BASE_ABIL1r_CL73_NONCE_MATCH_VALf_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r_CL73_NONCE_MATCH_VALf_GET
#define AN_X4_LOC_DEV_CL73_BASE_ABIL1r_CL73_NONCE_MATCH_VALf_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r_CL73_NONCE_MATCH_VALf_SET
#define AN_X4_LOC_DEV_CL73_BASE_ABIL1r_TRANSMIT_NONCEf_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r_TRANSMIT_NONCEf_GET
#define AN_X4_LOC_DEV_CL73_BASE_ABIL1r_TRANSMIT_NONCEf_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r_TRANSMIT_NONCEf_SET
#define AN_X4_LOC_DEV_CL73_BASE_ABIL1r_BASE_SELECTORf_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r_BASE_SELECTORf_GET
#define AN_X4_LOC_DEV_CL73_BASE_ABIL1r_BASE_SELECTORf_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r_BASE_SELECTORf_SET
#define READ_AN_X4_LOC_DEV_CL73_BASE_ABIL1r BCMI_TSCE16_XGXS_READ_AN_X4_LOC_DEV_CL73_BASE_ABIL1r
#define WRITE_AN_X4_LOC_DEV_CL73_BASE_ABIL1r BCMI_TSCE16_XGXS_WRITE_AN_X4_LOC_DEV_CL73_BASE_ABIL1r
#define MODIFY_AN_X4_LOC_DEV_CL73_BASE_ABIL1r BCMI_TSCE16_XGXS_MODIFY_AN_X4_LOC_DEV_CL73_BASE_ABIL1r
#define READLN_AN_X4_LOC_DEV_CL73_BASE_ABIL1r BCMI_TSCE16_XGXS_READLN_AN_X4_LOC_DEV_CL73_BASE_ABIL1r
#define WRITELN_AN_X4_LOC_DEV_CL73_BASE_ABIL1r BCMI_TSCE16_XGXS_WRITELN_AN_X4_LOC_DEV_CL73_BASE_ABIL1r
#define WRITEALL_AN_X4_LOC_DEV_CL73_BASE_ABIL1r BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LOC_DEV_CL73_BASE_ABIL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X4_LOC_DEV_CL73_BASE_ABIL0
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc186
 * DESC:     CL73 BASE PAGE ABILITIES REG 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BASE_100GBASE_CR10 MP5 ability bit 5
 *     BASE_40GBASE_CR4 MP5 ability bit 4
 *     BASE_40GBASE_KR4 MP5 ability bit 3
 *     BASE_10GBASE_KR  MP5 ability bit 2
 *     BASE_10GBASE_KX4 MP5 ability bit 1
 *     BASE_1000BASE_KX MP5 ability bit 0
 *     CL73_PAUSE       Pause Ability[7:6]00 - No PAUSE ability10 - Asymmetric-toward-link-partner PAUSE ability01 - Symmetric PAUSE ability11 - Both symmetric and asymmetric-toward-local-device PAUSE ability
 *     FEC              Forward Error Correction00 - FEC not supported01 - FEC supported but not requested10 - invalid setting11 - FEC supported and requestedIf neither device requests FEC, then FEC is not done.
 *     NEXT_PAGE        
 *     CL73_REMOTE_FAULT CL73 AN Advertisement Register (7.16.13) Remote Fault field.Specifies whether the Remote Fault field should be set in the CL73 base pages that are transmitted.0 = no fault1 = fault
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r (0x0000c186 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LOC_DEV_CL73_BASE_ABIL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_s {
	uint32_t v[1];
	uint32_t an_x4_loc_dev_cl73_base_abil0[1];
	uint32_t _an_x4_loc_dev_cl73_base_abil0;
} BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_t;

#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_CLR(r) (r).an_x4_loc_dev_cl73_base_abil0[0] = 0
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_SET(r,d) (r).an_x4_loc_dev_cl73_base_abil0[0] = d
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_GET(r) (r).an_x4_loc_dev_cl73_base_abil0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_CL73_REMOTE_FAULTf_GET(r) ((((r).an_x4_loc_dev_cl73_base_abil0[0]) >> 11) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_CL73_REMOTE_FAULTf_SET(r,f) (r).an_x4_loc_dev_cl73_base_abil0[0]=(((r).an_x4_loc_dev_cl73_base_abil0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_NEXT_PAGEf_GET(r) ((((r).an_x4_loc_dev_cl73_base_abil0[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_NEXT_PAGEf_SET(r,f) (r).an_x4_loc_dev_cl73_base_abil0[0]=(((r).an_x4_loc_dev_cl73_base_abil0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_FECf_GET(r) ((((r).an_x4_loc_dev_cl73_base_abil0[0]) >> 8) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_FECf_SET(r,f) (r).an_x4_loc_dev_cl73_base_abil0[0]=(((r).an_x4_loc_dev_cl73_base_abil0[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_CL73_PAUSEf_GET(r) ((((r).an_x4_loc_dev_cl73_base_abil0[0]) >> 6) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_CL73_PAUSEf_SET(r,f) (r).an_x4_loc_dev_cl73_base_abil0[0]=(((r).an_x4_loc_dev_cl73_base_abil0[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_1000BASE_KXf_GET(r) ((((r).an_x4_loc_dev_cl73_base_abil0[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_1000BASE_KXf_SET(r,f) (r).an_x4_loc_dev_cl73_base_abil0[0]=(((r).an_x4_loc_dev_cl73_base_abil0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_10GBASE_KX4f_GET(r) ((((r).an_x4_loc_dev_cl73_base_abil0[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_10GBASE_KX4f_SET(r,f) (r).an_x4_loc_dev_cl73_base_abil0[0]=(((r).an_x4_loc_dev_cl73_base_abil0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_10GBASE_KRf_GET(r) ((((r).an_x4_loc_dev_cl73_base_abil0[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_10GBASE_KRf_SET(r,f) (r).an_x4_loc_dev_cl73_base_abil0[0]=(((r).an_x4_loc_dev_cl73_base_abil0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_40GBASE_KR4f_GET(r) ((((r).an_x4_loc_dev_cl73_base_abil0[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_40GBASE_KR4f_SET(r,f) (r).an_x4_loc_dev_cl73_base_abil0[0]=(((r).an_x4_loc_dev_cl73_base_abil0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_40GBASE_CR4f_GET(r) ((((r).an_x4_loc_dev_cl73_base_abil0[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_40GBASE_CR4f_SET(r,f) (r).an_x4_loc_dev_cl73_base_abil0[0]=(((r).an_x4_loc_dev_cl73_base_abil0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_100GBASE_CR10f_GET(r) (((r).an_x4_loc_dev_cl73_base_abil0[0]) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_100GBASE_CR10f_SET(r,f) (r).an_x4_loc_dev_cl73_base_abil0[0]=(((r).an_x4_loc_dev_cl73_base_abil0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_LOC_DEV_CL73_BASE_ABIL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X4_LOC_DEV_CL73_BASE_ABIL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r,(_r._an_x4_loc_dev_cl73_base_abil0))
#define BCMI_TSCE16_XGXS_WRITE_AN_X4_LOC_DEV_CL73_BASE_ABIL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r,(_r._an_x4_loc_dev_cl73_base_abil0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X4_LOC_DEV_CL73_BASE_ABIL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r,(_r._an_x4_loc_dev_cl73_base_abil0))
#define BCMI_TSCE16_XGXS_READLN_AN_X4_LOC_DEV_CL73_BASE_ABIL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_loc_dev_cl73_base_abil0))
#define BCMI_TSCE16_XGXS_WRITELN_AN_X4_LOC_DEV_CL73_BASE_ABIL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_loc_dev_cl73_base_abil0))
#define BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LOC_DEV_CL73_BASE_ABIL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_loc_dev_cl73_base_abil0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LOC_DEV_CL73_BASE_ABIL0r BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r
#define AN_X4_LOC_DEV_CL73_BASE_ABIL0r_SIZE BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_SIZE
typedef BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_t AN_X4_LOC_DEV_CL73_BASE_ABIL0r_t;
#define AN_X4_LOC_DEV_CL73_BASE_ABIL0r_CLR BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_CLR
#define AN_X4_LOC_DEV_CL73_BASE_ABIL0r_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_SET
#define AN_X4_LOC_DEV_CL73_BASE_ABIL0r_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_GET
#define AN_X4_LOC_DEV_CL73_BASE_ABIL0r_CL73_REMOTE_FAULTf_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_CL73_REMOTE_FAULTf_GET
#define AN_X4_LOC_DEV_CL73_BASE_ABIL0r_CL73_REMOTE_FAULTf_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_CL73_REMOTE_FAULTf_SET
#define AN_X4_LOC_DEV_CL73_BASE_ABIL0r_NEXT_PAGEf_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_NEXT_PAGEf_GET
#define AN_X4_LOC_DEV_CL73_BASE_ABIL0r_NEXT_PAGEf_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_NEXT_PAGEf_SET
#define AN_X4_LOC_DEV_CL73_BASE_ABIL0r_FECf_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_FECf_GET
#define AN_X4_LOC_DEV_CL73_BASE_ABIL0r_FECf_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_FECf_SET
#define AN_X4_LOC_DEV_CL73_BASE_ABIL0r_CL73_PAUSEf_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_CL73_PAUSEf_GET
#define AN_X4_LOC_DEV_CL73_BASE_ABIL0r_CL73_PAUSEf_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_CL73_PAUSEf_SET
#define AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_1000BASE_KXf_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_1000BASE_KXf_GET
#define AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_1000BASE_KXf_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_1000BASE_KXf_SET
#define AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_10GBASE_KX4f_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_10GBASE_KX4f_GET
#define AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_10GBASE_KX4f_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_10GBASE_KX4f_SET
#define AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_10GBASE_KRf_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_10GBASE_KRf_GET
#define AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_10GBASE_KRf_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_10GBASE_KRf_SET
#define AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_40GBASE_KR4f_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_40GBASE_KR4f_GET
#define AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_40GBASE_KR4f_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_40GBASE_KR4f_SET
#define AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_40GBASE_CR4f_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_40GBASE_CR4f_GET
#define AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_40GBASE_CR4f_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_40GBASE_CR4f_SET
#define AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_100GBASE_CR10f_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_100GBASE_CR10f_GET
#define AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_100GBASE_CR10f_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r_BASE_100GBASE_CR10f_SET
#define READ_AN_X4_LOC_DEV_CL73_BASE_ABIL0r BCMI_TSCE16_XGXS_READ_AN_X4_LOC_DEV_CL73_BASE_ABIL0r
#define WRITE_AN_X4_LOC_DEV_CL73_BASE_ABIL0r BCMI_TSCE16_XGXS_WRITE_AN_X4_LOC_DEV_CL73_BASE_ABIL0r
#define MODIFY_AN_X4_LOC_DEV_CL73_BASE_ABIL0r BCMI_TSCE16_XGXS_MODIFY_AN_X4_LOC_DEV_CL73_BASE_ABIL0r
#define READLN_AN_X4_LOC_DEV_CL73_BASE_ABIL0r BCMI_TSCE16_XGXS_READLN_AN_X4_LOC_DEV_CL73_BASE_ABIL0r
#define WRITELN_AN_X4_LOC_DEV_CL73_BASE_ABIL0r BCMI_TSCE16_XGXS_WRITELN_AN_X4_LOC_DEV_CL73_BASE_ABIL0r
#define WRITEALL_AN_X4_LOC_DEV_CL73_BASE_ABIL0r BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LOC_DEV_CL73_BASE_ABIL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BASE_ABIL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X4_LOC_DEV_CL73_BAM_ABIL
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc187
 * DESC:     CL73 BAM ABILITIES
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BAM_20GBASE_KR2  MP5 ability bit 16
 *     BAM_20GBASE_CR2  MP5 ability bit 15
 *     CL73_BAM_CODE    
 *     HPAM_20GKR2      
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr (0x0000c187 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LOC_DEV_CL73_BAM_ABIL.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr_s {
	uint32_t v[1];
	uint32_t an_x4_loc_dev_cl73_bam_abil[1];
	uint32_t _an_x4_loc_dev_cl73_bam_abil;
} BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr_t;

#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr_CLR(r) (r).an_x4_loc_dev_cl73_bam_abil[0] = 0
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr_SET(r,d) (r).an_x4_loc_dev_cl73_bam_abil[0] = d
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr_GET(r) (r).an_x4_loc_dev_cl73_bam_abil[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr_HPAM_20GKR2f_GET(r) ((((r).an_x4_loc_dev_cl73_bam_abil[0]) >> 11) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr_HPAM_20GKR2f_SET(r,f) (r).an_x4_loc_dev_cl73_bam_abil[0]=(((r).an_x4_loc_dev_cl73_bam_abil[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr_CL73_BAM_CODEf_GET(r) ((((r).an_x4_loc_dev_cl73_bam_abil[0]) >> 2) & 0x1ff)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr_CL73_BAM_CODEf_SET(r,f) (r).an_x4_loc_dev_cl73_bam_abil[0]=(((r).an_x4_loc_dev_cl73_bam_abil[0] & ~((uint32_t)0x1ff << 2)) | ((((uint32_t)f) & 0x1ff) << 2)) | (511 << (16 + 2))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr_BAM_20GBASE_CR2f_GET(r) ((((r).an_x4_loc_dev_cl73_bam_abil[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr_BAM_20GBASE_CR2f_SET(r,f) (r).an_x4_loc_dev_cl73_bam_abil[0]=(((r).an_x4_loc_dev_cl73_bam_abil[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr_BAM_20GBASE_KR2f_GET(r) (((r).an_x4_loc_dev_cl73_bam_abil[0]) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr_BAM_20GBASE_KR2f_SET(r,f) (r).an_x4_loc_dev_cl73_bam_abil[0]=(((r).an_x4_loc_dev_cl73_bam_abil[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_LOC_DEV_CL73_BAM_ABIL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X4_LOC_DEV_CL73_BAM_ABILr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr,(_r._an_x4_loc_dev_cl73_bam_abil))
#define BCMI_TSCE16_XGXS_WRITE_AN_X4_LOC_DEV_CL73_BAM_ABILr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr,(_r._an_x4_loc_dev_cl73_bam_abil)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X4_LOC_DEV_CL73_BAM_ABILr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr,(_r._an_x4_loc_dev_cl73_bam_abil))
#define BCMI_TSCE16_XGXS_READLN_AN_X4_LOC_DEV_CL73_BAM_ABILr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_loc_dev_cl73_bam_abil))
#define BCMI_TSCE16_XGXS_WRITELN_AN_X4_LOC_DEV_CL73_BAM_ABILr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_loc_dev_cl73_bam_abil))
#define BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LOC_DEV_CL73_BAM_ABILr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_loc_dev_cl73_bam_abil))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LOC_DEV_CL73_BAM_ABILr BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr
#define AN_X4_LOC_DEV_CL73_BAM_ABILr_SIZE BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr_SIZE
typedef BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr_t AN_X4_LOC_DEV_CL73_BAM_ABILr_t;
#define AN_X4_LOC_DEV_CL73_BAM_ABILr_CLR BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr_CLR
#define AN_X4_LOC_DEV_CL73_BAM_ABILr_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr_SET
#define AN_X4_LOC_DEV_CL73_BAM_ABILr_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr_GET
#define AN_X4_LOC_DEV_CL73_BAM_ABILr_HPAM_20GKR2f_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr_HPAM_20GKR2f_GET
#define AN_X4_LOC_DEV_CL73_BAM_ABILr_HPAM_20GKR2f_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr_HPAM_20GKR2f_SET
#define AN_X4_LOC_DEV_CL73_BAM_ABILr_CL73_BAM_CODEf_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr_CL73_BAM_CODEf_GET
#define AN_X4_LOC_DEV_CL73_BAM_ABILr_CL73_BAM_CODEf_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr_CL73_BAM_CODEf_SET
#define AN_X4_LOC_DEV_CL73_BAM_ABILr_BAM_20GBASE_CR2f_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr_BAM_20GBASE_CR2f_GET
#define AN_X4_LOC_DEV_CL73_BAM_ABILr_BAM_20GBASE_CR2f_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr_BAM_20GBASE_CR2f_SET
#define AN_X4_LOC_DEV_CL73_BAM_ABILr_BAM_20GBASE_KR2f_GET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr_BAM_20GBASE_KR2f_GET
#define AN_X4_LOC_DEV_CL73_BAM_ABILr_BAM_20GBASE_KR2f_SET BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr_BAM_20GBASE_KR2f_SET
#define READ_AN_X4_LOC_DEV_CL73_BAM_ABILr BCMI_TSCE16_XGXS_READ_AN_X4_LOC_DEV_CL73_BAM_ABILr
#define WRITE_AN_X4_LOC_DEV_CL73_BAM_ABILr BCMI_TSCE16_XGXS_WRITE_AN_X4_LOC_DEV_CL73_BAM_ABILr
#define MODIFY_AN_X4_LOC_DEV_CL73_BAM_ABILr BCMI_TSCE16_XGXS_MODIFY_AN_X4_LOC_DEV_CL73_BAM_ABILr
#define READLN_AN_X4_LOC_DEV_CL73_BAM_ABILr BCMI_TSCE16_XGXS_READLN_AN_X4_LOC_DEV_CL73_BAM_ABILr
#define WRITELN_AN_X4_LOC_DEV_CL73_BAM_ABILr BCMI_TSCE16_XGXS_WRITELN_AN_X4_LOC_DEV_CL73_BAM_ABILr
#define WRITEALL_AN_X4_LOC_DEV_CL73_BAM_ABILr BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LOC_DEV_CL73_BAM_ABILr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X4_LOC_DEV_CL73_BAM_ABILr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X4_CTLS
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc188
 * DESC:     AN MISC CONTROLS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PD_KX4_EN        
 *     PD_KX_EN         
 *     AN_GOOD_TRAP     
 *     AN_GOOD_CHECK_TRAP 
 *     LINKFAILTIMER_DIS 
 *     LINKFAILTIMERQUAL_EN 
 *     AN_FAIL_COUNT_LIMIT Number of times AN may retry after AN failureIt indicates the max value of an_fail_count register
 *     OUI_CONTROL      bit 5: require programmable OUI to detect CL73 HP modebit 4: advertise programmable OUI for CL73 HP modebit 3: require programmable OUI to detect CL73 BAMbit 2: advertise programmable OUI in CL73 BAMbit 1: require programmable OUI to detect CL37 BAMbit 0: advertise programmable OUI in CL37 BAM\
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X4_CTLSr (0x0000c188 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X4_CTLSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_CTLS.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X4_CTLSr_s {
	uint32_t v[1];
	uint32_t an_x4_ctls[1];
	uint32_t _an_x4_ctls;
} BCMI_TSCE16_XGXS_AN_X4_CTLSr_t;

#define BCMI_TSCE16_XGXS_AN_X4_CTLSr_CLR(r) (r).an_x4_ctls[0] = 0
#define BCMI_TSCE16_XGXS_AN_X4_CTLSr_SET(r,d) (r).an_x4_ctls[0] = d
#define BCMI_TSCE16_XGXS_AN_X4_CTLSr_GET(r) (r).an_x4_ctls[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X4_CTLSr_OUI_CONTROLf_GET(r) ((((r).an_x4_ctls[0]) >> 10) & 0x3f)
#define BCMI_TSCE16_XGXS_AN_X4_CTLSr_OUI_CONTROLf_SET(r,f) (r).an_x4_ctls[0]=(((r).an_x4_ctls[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10)) | (63 << (16 + 10))
#define BCMI_TSCE16_XGXS_AN_X4_CTLSr_AN_FAIL_COUNT_LIMITf_GET(r) ((((r).an_x4_ctls[0]) >> 6) & 0xf)
#define BCMI_TSCE16_XGXS_AN_X4_CTLSr_AN_FAIL_COUNT_LIMITf_SET(r,f) (r).an_x4_ctls[0]=(((r).an_x4_ctls[0] & ~((uint32_t)0xf << 6)) | ((((uint32_t)f) & 0xf) << 6)) | (15 << (16 + 6))
#define BCMI_TSCE16_XGXS_AN_X4_CTLSr_LINKFAILTIMERQUAL_ENf_GET(r) ((((r).an_x4_ctls[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_CTLSr_LINKFAILTIMERQUAL_ENf_SET(r,f) (r).an_x4_ctls[0]=(((r).an_x4_ctls[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_AN_X4_CTLSr_LINKFAILTIMER_DISf_GET(r) ((((r).an_x4_ctls[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_CTLSr_LINKFAILTIMER_DISf_SET(r,f) (r).an_x4_ctls[0]=(((r).an_x4_ctls[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_AN_X4_CTLSr_AN_GOOD_CHECK_TRAPf_GET(r) ((((r).an_x4_ctls[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_CTLSr_AN_GOOD_CHECK_TRAPf_SET(r,f) (r).an_x4_ctls[0]=(((r).an_x4_ctls[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_AN_X4_CTLSr_AN_GOOD_TRAPf_GET(r) ((((r).an_x4_ctls[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_CTLSr_AN_GOOD_TRAPf_SET(r,f) (r).an_x4_ctls[0]=(((r).an_x4_ctls[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_AN_X4_CTLSr_PD_KX_ENf_GET(r) ((((r).an_x4_ctls[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_CTLSr_PD_KX_ENf_SET(r,f) (r).an_x4_ctls[0]=(((r).an_x4_ctls[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_AN_X4_CTLSr_PD_KX4_ENf_GET(r) (((r).an_x4_ctls[0]) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_CTLSr_PD_KX4_ENf_SET(r,f) (r).an_x4_ctls[0]=(((r).an_x4_ctls[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_CTLS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X4_CTLSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_CTLSr,(_r._an_x4_ctls))
#define BCMI_TSCE16_XGXS_WRITE_AN_X4_CTLSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_CTLSr,(_r._an_x4_ctls)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X4_CTLSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_CTLSr,(_r._an_x4_ctls))
#define BCMI_TSCE16_XGXS_READLN_AN_X4_CTLSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_CTLSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ctls))
#define BCMI_TSCE16_XGXS_WRITELN_AN_X4_CTLSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_CTLSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ctls))
#define BCMI_TSCE16_XGXS_WRITEALL_AN_X4_CTLSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_CTLSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_ctls))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_CTLSr BCMI_TSCE16_XGXS_AN_X4_CTLSr
#define AN_X4_CTLSr_SIZE BCMI_TSCE16_XGXS_AN_X4_CTLSr_SIZE
typedef BCMI_TSCE16_XGXS_AN_X4_CTLSr_t AN_X4_CTLSr_t;
#define AN_X4_CTLSr_CLR BCMI_TSCE16_XGXS_AN_X4_CTLSr_CLR
#define AN_X4_CTLSr_SET BCMI_TSCE16_XGXS_AN_X4_CTLSr_SET
#define AN_X4_CTLSr_GET BCMI_TSCE16_XGXS_AN_X4_CTLSr_GET
#define AN_X4_CTLSr_OUI_CONTROLf_GET BCMI_TSCE16_XGXS_AN_X4_CTLSr_OUI_CONTROLf_GET
#define AN_X4_CTLSr_OUI_CONTROLf_SET BCMI_TSCE16_XGXS_AN_X4_CTLSr_OUI_CONTROLf_SET
#define AN_X4_CTLSr_AN_FAIL_COUNT_LIMITf_GET BCMI_TSCE16_XGXS_AN_X4_CTLSr_AN_FAIL_COUNT_LIMITf_GET
#define AN_X4_CTLSr_AN_FAIL_COUNT_LIMITf_SET BCMI_TSCE16_XGXS_AN_X4_CTLSr_AN_FAIL_COUNT_LIMITf_SET
#define AN_X4_CTLSr_LINKFAILTIMERQUAL_ENf_GET BCMI_TSCE16_XGXS_AN_X4_CTLSr_LINKFAILTIMERQUAL_ENf_GET
#define AN_X4_CTLSr_LINKFAILTIMERQUAL_ENf_SET BCMI_TSCE16_XGXS_AN_X4_CTLSr_LINKFAILTIMERQUAL_ENf_SET
#define AN_X4_CTLSr_LINKFAILTIMER_DISf_GET BCMI_TSCE16_XGXS_AN_X4_CTLSr_LINKFAILTIMER_DISf_GET
#define AN_X4_CTLSr_LINKFAILTIMER_DISf_SET BCMI_TSCE16_XGXS_AN_X4_CTLSr_LINKFAILTIMER_DISf_SET
#define AN_X4_CTLSr_AN_GOOD_CHECK_TRAPf_GET BCMI_TSCE16_XGXS_AN_X4_CTLSr_AN_GOOD_CHECK_TRAPf_GET
#define AN_X4_CTLSr_AN_GOOD_CHECK_TRAPf_SET BCMI_TSCE16_XGXS_AN_X4_CTLSr_AN_GOOD_CHECK_TRAPf_SET
#define AN_X4_CTLSr_AN_GOOD_TRAPf_GET BCMI_TSCE16_XGXS_AN_X4_CTLSr_AN_GOOD_TRAPf_GET
#define AN_X4_CTLSr_AN_GOOD_TRAPf_SET BCMI_TSCE16_XGXS_AN_X4_CTLSr_AN_GOOD_TRAPf_SET
#define AN_X4_CTLSr_PD_KX_ENf_GET BCMI_TSCE16_XGXS_AN_X4_CTLSr_PD_KX_ENf_GET
#define AN_X4_CTLSr_PD_KX_ENf_SET BCMI_TSCE16_XGXS_AN_X4_CTLSr_PD_KX_ENf_SET
#define AN_X4_CTLSr_PD_KX4_ENf_GET BCMI_TSCE16_XGXS_AN_X4_CTLSr_PD_KX4_ENf_GET
#define AN_X4_CTLSr_PD_KX4_ENf_SET BCMI_TSCE16_XGXS_AN_X4_CTLSr_PD_KX4_ENf_SET
#define READ_AN_X4_CTLSr BCMI_TSCE16_XGXS_READ_AN_X4_CTLSr
#define WRITE_AN_X4_CTLSr BCMI_TSCE16_XGXS_WRITE_AN_X4_CTLSr
#define MODIFY_AN_X4_CTLSr BCMI_TSCE16_XGXS_MODIFY_AN_X4_CTLSr
#define READLN_AN_X4_CTLSr BCMI_TSCE16_XGXS_READLN_AN_X4_CTLSr
#define WRITELN_AN_X4_CTLSr BCMI_TSCE16_XGXS_WRITELN_AN_X4_CTLSr
#define WRITEALL_AN_X4_CTLSr BCMI_TSCE16_XGXS_WRITEALL_AN_X4_CTLSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X4_CTLSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X4_LP_MP5_UP1
 * BLOCKS:   AN_X4_HW_LP_PAGES
 * REGADDR:  0xc190
 * DESC:     LINK PARTNER MESSAGE_PAGE 5 USER PAGE 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LP_MP5_UP1_PAGE_DATA AUTO-NEG LINK PARTNER OUI USER PAGE 115        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10:0      - OUI[23:13]
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP1r (0x0000c190 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_MP5_UP1.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP1r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_mp5_up1[1];
	uint32_t _an_x4_lp_mp5_up1;
} BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP1r_t;

#define BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP1r_CLR(r) (r).an_x4_lp_mp5_up1[0] = 0
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP1r_SET(r,d) (r).an_x4_lp_mp5_up1[0] = d
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP1r_GET(r) (r).an_x4_lp_mp5_up1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_GET(r) (((r).an_x4_lp_mp5_up1[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_SET(r,f) (r).an_x4_lp_mp5_up1[0]=(((r).an_x4_lp_mp5_up1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_MP5_UP1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X4_LP_MP5_UP1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP1r,(_r._an_x4_lp_mp5_up1))
#define BCMI_TSCE16_XGXS_WRITE_AN_X4_LP_MP5_UP1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP1r,(_r._an_x4_lp_mp5_up1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X4_LP_MP5_UP1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP1r,(_r._an_x4_lp_mp5_up1))
#define BCMI_TSCE16_XGXS_READLN_AN_X4_LP_MP5_UP1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_mp5_up1))
#define BCMI_TSCE16_XGXS_WRITELN_AN_X4_LP_MP5_UP1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_mp5_up1))
#define BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LP_MP5_UP1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_mp5_up1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_MP5_UP1r BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP1r
#define AN_X4_LP_MP5_UP1r_SIZE BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP1r_SIZE
typedef BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP1r_t AN_X4_LP_MP5_UP1r_t;
#define AN_X4_LP_MP5_UP1r_CLR BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP1r_CLR
#define AN_X4_LP_MP5_UP1r_SET BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP1r_SET
#define AN_X4_LP_MP5_UP1r_GET BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP1r_GET
#define AN_X4_LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_GET BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_GET
#define AN_X4_LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_SET BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP1r_LP_MP5_UP1_PAGE_DATAf_SET
#define READ_AN_X4_LP_MP5_UP1r BCMI_TSCE16_XGXS_READ_AN_X4_LP_MP5_UP1r
#define WRITE_AN_X4_LP_MP5_UP1r BCMI_TSCE16_XGXS_WRITE_AN_X4_LP_MP5_UP1r
#define MODIFY_AN_X4_LP_MP5_UP1r BCMI_TSCE16_XGXS_MODIFY_AN_X4_LP_MP5_UP1r
#define READLN_AN_X4_LP_MP5_UP1r BCMI_TSCE16_XGXS_READLN_AN_X4_LP_MP5_UP1r
#define WRITELN_AN_X4_LP_MP5_UP1r BCMI_TSCE16_XGXS_WRITELN_AN_X4_LP_MP5_UP1r
#define WRITEALL_AN_X4_LP_MP5_UP1r BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LP_MP5_UP1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X4_LP_MP5_UP2
 * BLOCKS:   AN_X4_HW_LP_PAGES
 * REGADDR:  0xc191
 * DESC:     LINK PARTNER MESSAGE_PAGE 5 USER PAGE 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LP_MP5_UP2_PAGE_DATA AUTO-NEG LINK PARTNER OUI USER PAGE 215        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10:0      - OUI[12:2]
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP2r (0x0000c191 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_MP5_UP2.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP2r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_mp5_up2[1];
	uint32_t _an_x4_lp_mp5_up2;
} BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP2r_t;

#define BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP2r_CLR(r) (r).an_x4_lp_mp5_up2[0] = 0
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP2r_SET(r,d) (r).an_x4_lp_mp5_up2[0] = d
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP2r_GET(r) (r).an_x4_lp_mp5_up2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_GET(r) (((r).an_x4_lp_mp5_up2[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_SET(r,f) (r).an_x4_lp_mp5_up2[0]=(((r).an_x4_lp_mp5_up2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_MP5_UP2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X4_LP_MP5_UP2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP2r,(_r._an_x4_lp_mp5_up2))
#define BCMI_TSCE16_XGXS_WRITE_AN_X4_LP_MP5_UP2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP2r,(_r._an_x4_lp_mp5_up2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X4_LP_MP5_UP2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP2r,(_r._an_x4_lp_mp5_up2))
#define BCMI_TSCE16_XGXS_READLN_AN_X4_LP_MP5_UP2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_mp5_up2))
#define BCMI_TSCE16_XGXS_WRITELN_AN_X4_LP_MP5_UP2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_mp5_up2))
#define BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LP_MP5_UP2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_mp5_up2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_MP5_UP2r BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP2r
#define AN_X4_LP_MP5_UP2r_SIZE BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP2r_SIZE
typedef BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP2r_t AN_X4_LP_MP5_UP2r_t;
#define AN_X4_LP_MP5_UP2r_CLR BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP2r_CLR
#define AN_X4_LP_MP5_UP2r_SET BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP2r_SET
#define AN_X4_LP_MP5_UP2r_GET BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP2r_GET
#define AN_X4_LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_GET BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_GET
#define AN_X4_LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_SET BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP2r_LP_MP5_UP2_PAGE_DATAf_SET
#define READ_AN_X4_LP_MP5_UP2r BCMI_TSCE16_XGXS_READ_AN_X4_LP_MP5_UP2r
#define WRITE_AN_X4_LP_MP5_UP2r BCMI_TSCE16_XGXS_WRITE_AN_X4_LP_MP5_UP2r
#define MODIFY_AN_X4_LP_MP5_UP2r BCMI_TSCE16_XGXS_MODIFY_AN_X4_LP_MP5_UP2r
#define READLN_AN_X4_LP_MP5_UP2r BCMI_TSCE16_XGXS_READLN_AN_X4_LP_MP5_UP2r
#define WRITELN_AN_X4_LP_MP5_UP2r BCMI_TSCE16_XGXS_WRITELN_AN_X4_LP_MP5_UP2r
#define WRITEALL_AN_X4_LP_MP5_UP2r BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LP_MP5_UP2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X4_LP_MP5_UP3
 * BLOCKS:   AN_X4_HW_LP_PAGES
 * REGADDR:  0xc192
 * DESC:     LINK PARTNER MESSAGE_PAGE 5 USER PAGE 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LP_MP5_UP3_PAGE_DATA AUTO-NEG LINK PARTNER OUI USER PAGE 315        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10:9      - OUI[1:0]8:0       - User-Defined Code[19:11]
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP3r (0x0000c192 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP3r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_MP5_UP3.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP3r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_mp5_up3[1];
	uint32_t _an_x4_lp_mp5_up3;
} BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP3r_t;

#define BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP3r_CLR(r) (r).an_x4_lp_mp5_up3[0] = 0
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP3r_SET(r,d) (r).an_x4_lp_mp5_up3[0] = d
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP3r_GET(r) (r).an_x4_lp_mp5_up3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_GET(r) (((r).an_x4_lp_mp5_up3[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_SET(r,f) (r).an_x4_lp_mp5_up3[0]=(((r).an_x4_lp_mp5_up3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_MP5_UP3.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X4_LP_MP5_UP3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP3r,(_r._an_x4_lp_mp5_up3))
#define BCMI_TSCE16_XGXS_WRITE_AN_X4_LP_MP5_UP3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP3r,(_r._an_x4_lp_mp5_up3)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X4_LP_MP5_UP3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP3r,(_r._an_x4_lp_mp5_up3))
#define BCMI_TSCE16_XGXS_READLN_AN_X4_LP_MP5_UP3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_mp5_up3))
#define BCMI_TSCE16_XGXS_WRITELN_AN_X4_LP_MP5_UP3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_mp5_up3))
#define BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LP_MP5_UP3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_mp5_up3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_MP5_UP3r BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP3r
#define AN_X4_LP_MP5_UP3r_SIZE BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP3r_SIZE
typedef BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP3r_t AN_X4_LP_MP5_UP3r_t;
#define AN_X4_LP_MP5_UP3r_CLR BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP3r_CLR
#define AN_X4_LP_MP5_UP3r_SET BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP3r_SET
#define AN_X4_LP_MP5_UP3r_GET BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP3r_GET
#define AN_X4_LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_GET BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_GET
#define AN_X4_LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_SET BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP3r_LP_MP5_UP3_PAGE_DATAf_SET
#define READ_AN_X4_LP_MP5_UP3r BCMI_TSCE16_XGXS_READ_AN_X4_LP_MP5_UP3r
#define WRITE_AN_X4_LP_MP5_UP3r BCMI_TSCE16_XGXS_WRITE_AN_X4_LP_MP5_UP3r
#define MODIFY_AN_X4_LP_MP5_UP3r BCMI_TSCE16_XGXS_MODIFY_AN_X4_LP_MP5_UP3r
#define READLN_AN_X4_LP_MP5_UP3r BCMI_TSCE16_XGXS_READLN_AN_X4_LP_MP5_UP3r
#define WRITELN_AN_X4_LP_MP5_UP3r BCMI_TSCE16_XGXS_WRITELN_AN_X4_LP_MP5_UP3r
#define WRITEALL_AN_X4_LP_MP5_UP3r BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LP_MP5_UP3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X4_LP_MP5_UP4
 * BLOCKS:   AN_X4_HW_LP_PAGES
 * REGADDR:  0xc193
 * DESC:     LINK PARTNER MESSAGE_PAGE 5 USER PAGE 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LP_MP5_UP4_PAGE_DATA AUTO-NEG LINK PARTNER OUI USER PAGE 415        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10:0      - User-Defined Code[10:0]In Hewlett-Packard auto-neg mode, an OUI[23:0] of 0x643150, andan User-Defined Code[19:0] of 0xABE20 indicate that the device is capable of 20G-KR2.In Broadcom auto-neg mode, User-Defined Code[19:11] contain a BAM code, andUser-Defined Code[10:0] contain BAM abilities.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP4r (0x0000c193 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP4r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_MP5_UP4.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP4r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_mp5_up4[1];
	uint32_t _an_x4_lp_mp5_up4;
} BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP4r_t;

#define BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP4r_CLR(r) (r).an_x4_lp_mp5_up4[0] = 0
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP4r_SET(r,d) (r).an_x4_lp_mp5_up4[0] = d
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP4r_GET(r) (r).an_x4_lp_mp5_up4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_GET(r) (((r).an_x4_lp_mp5_up4[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_SET(r,f) (r).an_x4_lp_mp5_up4[0]=(((r).an_x4_lp_mp5_up4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_MP5_UP4.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X4_LP_MP5_UP4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP4r,(_r._an_x4_lp_mp5_up4))
#define BCMI_TSCE16_XGXS_WRITE_AN_X4_LP_MP5_UP4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP4r,(_r._an_x4_lp_mp5_up4)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X4_LP_MP5_UP4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP4r,(_r._an_x4_lp_mp5_up4))
#define BCMI_TSCE16_XGXS_READLN_AN_X4_LP_MP5_UP4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_mp5_up4))
#define BCMI_TSCE16_XGXS_WRITELN_AN_X4_LP_MP5_UP4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_mp5_up4))
#define BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LP_MP5_UP4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_mp5_up4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_MP5_UP4r BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP4r
#define AN_X4_LP_MP5_UP4r_SIZE BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP4r_SIZE
typedef BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP4r_t AN_X4_LP_MP5_UP4r_t;
#define AN_X4_LP_MP5_UP4r_CLR BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP4r_CLR
#define AN_X4_LP_MP5_UP4r_SET BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP4r_SET
#define AN_X4_LP_MP5_UP4r_GET BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP4r_GET
#define AN_X4_LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_GET BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_GET
#define AN_X4_LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_SET BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP4r_LP_MP5_UP4_PAGE_DATAf_SET
#define READ_AN_X4_LP_MP5_UP4r BCMI_TSCE16_XGXS_READ_AN_X4_LP_MP5_UP4r
#define WRITE_AN_X4_LP_MP5_UP4r BCMI_TSCE16_XGXS_WRITE_AN_X4_LP_MP5_UP4r
#define MODIFY_AN_X4_LP_MP5_UP4r BCMI_TSCE16_XGXS_MODIFY_AN_X4_LP_MP5_UP4r
#define READLN_AN_X4_LP_MP5_UP4r BCMI_TSCE16_XGXS_READLN_AN_X4_LP_MP5_UP4r
#define WRITELN_AN_X4_LP_MP5_UP4r BCMI_TSCE16_XGXS_WRITELN_AN_X4_LP_MP5_UP4r
#define WRITEALL_AN_X4_LP_MP5_UP4r BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LP_MP5_UP4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X4_LP_MP5_UP4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X4_LP_MP1024_UP1
 * BLOCKS:   AN_X4_HW_LP_PAGES
 * REGADDR:  0xc194
 * DESC:     LINK PARTNER MESSAGE_PAGE 1024 USER PAGE 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LP_MP1024_UP1_PAGE_DATA AUTO-NEG LINK PARTNER OVER1G USER PAGE 115        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10        - Speed Ability 20G-CX49         - Speed Ability 16G-X48         - Speed Ability 15G-X47         - Speed Ability 13G-X46         - Speed Ability 12.5G-X45         - Speed Ability 12G-X44         - Speed Ability 10G-CX43         - Speed Ability 10G-X42         - Speed Ability 6G-X41         - Speed Ability 5G-X40         - Speed Ability 2.5G-X1
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP1r (0x0000c194 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_MP1024_UP1.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP1r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_mp1024_up1[1];
	uint32_t _an_x4_lp_mp1024_up1;
} BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP1r_t;

#define BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP1r_CLR(r) (r).an_x4_lp_mp1024_up1[0] = 0
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP1r_SET(r,d) (r).an_x4_lp_mp1024_up1[0] = d
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP1r_GET(r) (r).an_x4_lp_mp1024_up1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_GET(r) (((r).an_x4_lp_mp1024_up1[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_SET(r,f) (r).an_x4_lp_mp1024_up1[0]=(((r).an_x4_lp_mp1024_up1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_MP1024_UP1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X4_LP_MP1024_UP1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP1r,(_r._an_x4_lp_mp1024_up1))
#define BCMI_TSCE16_XGXS_WRITE_AN_X4_LP_MP1024_UP1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP1r,(_r._an_x4_lp_mp1024_up1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X4_LP_MP1024_UP1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP1r,(_r._an_x4_lp_mp1024_up1))
#define BCMI_TSCE16_XGXS_READLN_AN_X4_LP_MP1024_UP1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_mp1024_up1))
#define BCMI_TSCE16_XGXS_WRITELN_AN_X4_LP_MP1024_UP1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_mp1024_up1))
#define BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LP_MP1024_UP1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_mp1024_up1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_MP1024_UP1r BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP1r
#define AN_X4_LP_MP1024_UP1r_SIZE BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP1r_SIZE
typedef BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP1r_t AN_X4_LP_MP1024_UP1r_t;
#define AN_X4_LP_MP1024_UP1r_CLR BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP1r_CLR
#define AN_X4_LP_MP1024_UP1r_SET BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP1r_SET
#define AN_X4_LP_MP1024_UP1r_GET BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP1r_GET
#define AN_X4_LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_GET BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_GET
#define AN_X4_LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_SET BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP1r_LP_MP1024_UP1_PAGE_DATAf_SET
#define READ_AN_X4_LP_MP1024_UP1r BCMI_TSCE16_XGXS_READ_AN_X4_LP_MP1024_UP1r
#define WRITE_AN_X4_LP_MP1024_UP1r BCMI_TSCE16_XGXS_WRITE_AN_X4_LP_MP1024_UP1r
#define MODIFY_AN_X4_LP_MP1024_UP1r BCMI_TSCE16_XGXS_MODIFY_AN_X4_LP_MP1024_UP1r
#define READLN_AN_X4_LP_MP1024_UP1r BCMI_TSCE16_XGXS_READLN_AN_X4_LP_MP1024_UP1r
#define WRITELN_AN_X4_LP_MP1024_UP1r BCMI_TSCE16_XGXS_WRITELN_AN_X4_LP_MP1024_UP1r
#define WRITEALL_AN_X4_LP_MP1024_UP1r BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LP_MP1024_UP1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X4_LP_MP1024_UP2
 * BLOCKS:   AN_X4_HW_LP_PAGES
 * REGADDR:  0xc195
 * DESC:     LINK PARTNER MESSAGE_PAGE 1024 USER PAGE 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LP_MP1024_UP2_PAGE_DATA AUTO-NEG LINK PARTNER OVER1G USER PAGE 215        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10        - Transmitter-Equalization values are valid9:6       - Transmitter-Equalization preemphasis5:3       - Transmitter-Equalization idriver2:0       - Transmitter-Equalization ipredriver
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP2r (0x0000c195 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_MP1024_UP2.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP2r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_mp1024_up2[1];
	uint32_t _an_x4_lp_mp1024_up2;
} BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP2r_t;

#define BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP2r_CLR(r) (r).an_x4_lp_mp1024_up2[0] = 0
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP2r_SET(r,d) (r).an_x4_lp_mp1024_up2[0] = d
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP2r_GET(r) (r).an_x4_lp_mp1024_up2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_GET(r) (((r).an_x4_lp_mp1024_up2[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_SET(r,f) (r).an_x4_lp_mp1024_up2[0]=(((r).an_x4_lp_mp1024_up2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_MP1024_UP2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X4_LP_MP1024_UP2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP2r,(_r._an_x4_lp_mp1024_up2))
#define BCMI_TSCE16_XGXS_WRITE_AN_X4_LP_MP1024_UP2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP2r,(_r._an_x4_lp_mp1024_up2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X4_LP_MP1024_UP2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP2r,(_r._an_x4_lp_mp1024_up2))
#define BCMI_TSCE16_XGXS_READLN_AN_X4_LP_MP1024_UP2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_mp1024_up2))
#define BCMI_TSCE16_XGXS_WRITELN_AN_X4_LP_MP1024_UP2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_mp1024_up2))
#define BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LP_MP1024_UP2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_mp1024_up2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_MP1024_UP2r BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP2r
#define AN_X4_LP_MP1024_UP2r_SIZE BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP2r_SIZE
typedef BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP2r_t AN_X4_LP_MP1024_UP2r_t;
#define AN_X4_LP_MP1024_UP2r_CLR BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP2r_CLR
#define AN_X4_LP_MP1024_UP2r_SET BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP2r_SET
#define AN_X4_LP_MP1024_UP2r_GET BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP2r_GET
#define AN_X4_LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_GET BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_GET
#define AN_X4_LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_SET BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP2r_LP_MP1024_UP2_PAGE_DATAf_SET
#define READ_AN_X4_LP_MP1024_UP2r BCMI_TSCE16_XGXS_READ_AN_X4_LP_MP1024_UP2r
#define WRITE_AN_X4_LP_MP1024_UP2r BCMI_TSCE16_XGXS_WRITE_AN_X4_LP_MP1024_UP2r
#define MODIFY_AN_X4_LP_MP1024_UP2r BCMI_TSCE16_XGXS_MODIFY_AN_X4_LP_MP1024_UP2r
#define READLN_AN_X4_LP_MP1024_UP2r BCMI_TSCE16_XGXS_READLN_AN_X4_LP_MP1024_UP2r
#define WRITELN_AN_X4_LP_MP1024_UP2r BCMI_TSCE16_XGXS_WRITELN_AN_X4_LP_MP1024_UP2r
#define WRITEALL_AN_X4_LP_MP1024_UP2r BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LP_MP1024_UP2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X4_LP_MP1024_UP3
 * BLOCKS:   AN_X4_HW_LP_PAGES
 * REGADDR:  0xc196
 * DESC:     LINK PARTNER MESSAGE_PAGE 1024 USER PAGE 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LP_MP1024_UP3_PAGE_DATA AUTO-NEG LINK PARTNER OVER1G USER PAGE 315        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10        - Last User Page Indication9         - Speed Ability 21G-X48         - Speed Ability 25.45G-X47         - Speed Ability 31.5G-X46         - Speed Ability 32.7G5         - Speed Ability 40G-X44:3       - reserved2         - CL72 Training Ability1         - cl74 Forward-Error Correction Ability0         - High-Gig II Ability
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP3r (0x0000c196 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP3r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_MP1024_UP3.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP3r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_mp1024_up3[1];
	uint32_t _an_x4_lp_mp1024_up3;
} BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP3r_t;

#define BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP3r_CLR(r) (r).an_x4_lp_mp1024_up3[0] = 0
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP3r_SET(r,d) (r).an_x4_lp_mp1024_up3[0] = d
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP3r_GET(r) (r).an_x4_lp_mp1024_up3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_GET(r) (((r).an_x4_lp_mp1024_up3[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_SET(r,f) (r).an_x4_lp_mp1024_up3[0]=(((r).an_x4_lp_mp1024_up3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_MP1024_UP3.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X4_LP_MP1024_UP3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP3r,(_r._an_x4_lp_mp1024_up3))
#define BCMI_TSCE16_XGXS_WRITE_AN_X4_LP_MP1024_UP3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP3r,(_r._an_x4_lp_mp1024_up3)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X4_LP_MP1024_UP3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP3r,(_r._an_x4_lp_mp1024_up3))
#define BCMI_TSCE16_XGXS_READLN_AN_X4_LP_MP1024_UP3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_mp1024_up3))
#define BCMI_TSCE16_XGXS_WRITELN_AN_X4_LP_MP1024_UP3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_mp1024_up3))
#define BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LP_MP1024_UP3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_mp1024_up3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_MP1024_UP3r BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP3r
#define AN_X4_LP_MP1024_UP3r_SIZE BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP3r_SIZE
typedef BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP3r_t AN_X4_LP_MP1024_UP3r_t;
#define AN_X4_LP_MP1024_UP3r_CLR BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP3r_CLR
#define AN_X4_LP_MP1024_UP3r_SET BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP3r_SET
#define AN_X4_LP_MP1024_UP3r_GET BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP3r_GET
#define AN_X4_LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_GET BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_GET
#define AN_X4_LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_SET BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP3r_LP_MP1024_UP3_PAGE_DATAf_SET
#define READ_AN_X4_LP_MP1024_UP3r BCMI_TSCE16_XGXS_READ_AN_X4_LP_MP1024_UP3r
#define WRITE_AN_X4_LP_MP1024_UP3r BCMI_TSCE16_XGXS_WRITE_AN_X4_LP_MP1024_UP3r
#define MODIFY_AN_X4_LP_MP1024_UP3r BCMI_TSCE16_XGXS_MODIFY_AN_X4_LP_MP1024_UP3r
#define READLN_AN_X4_LP_MP1024_UP3r BCMI_TSCE16_XGXS_READLN_AN_X4_LP_MP1024_UP3r
#define WRITELN_AN_X4_LP_MP1024_UP3r BCMI_TSCE16_XGXS_WRITELN_AN_X4_LP_MP1024_UP3r
#define WRITEALL_AN_X4_LP_MP1024_UP3r BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LP_MP1024_UP3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X4_LP_MP1024_UP4
 * BLOCKS:   AN_X4_HW_LP_PAGES
 * REGADDR:  0xc197
 * DESC:     LINK PARTNER MESSAGE_PAGE 1024 USER PAGE 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LP_MP1024_UP4_PAGE_DATA AUTO-NEG LINK PARTNER OVER1G USER PAGE 415        - Next Page Indication14        - Receive Acknowledge13        - Message Page Indication12        - Comply Acknowledge11        - Toggle10        - Last User Page Indication9         - Speed Ability 1G-CX18         - Speed Ability 10G-CX17         - Speed Ability 15.75G-X26         - Speed Ability 20G-CX25         - Speed Ability 20G-X24         - Speed Ability 12.7G-X23         - Speed Ability 10.5G-X22         - Speed Ability 10G-CX21         - Speed Ability 10G-X20         - Speed Ability 20G-X4
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP4r (0x0000c197 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP4r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_MP1024_UP4.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP4r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_mp1024_up4[1];
	uint32_t _an_x4_lp_mp1024_up4;
} BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP4r_t;

#define BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP4r_CLR(r) (r).an_x4_lp_mp1024_up4[0] = 0
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP4r_SET(r,d) (r).an_x4_lp_mp1024_up4[0] = d
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP4r_GET(r) (r).an_x4_lp_mp1024_up4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_GET(r) (((r).an_x4_lp_mp1024_up4[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_SET(r,f) (r).an_x4_lp_mp1024_up4[0]=(((r).an_x4_lp_mp1024_up4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_MP1024_UP4.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X4_LP_MP1024_UP4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP4r,(_r._an_x4_lp_mp1024_up4))
#define BCMI_TSCE16_XGXS_WRITE_AN_X4_LP_MP1024_UP4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP4r,(_r._an_x4_lp_mp1024_up4)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X4_LP_MP1024_UP4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP4r,(_r._an_x4_lp_mp1024_up4))
#define BCMI_TSCE16_XGXS_READLN_AN_X4_LP_MP1024_UP4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_mp1024_up4))
#define BCMI_TSCE16_XGXS_WRITELN_AN_X4_LP_MP1024_UP4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_mp1024_up4))
#define BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LP_MP1024_UP4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_mp1024_up4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_MP1024_UP4r BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP4r
#define AN_X4_LP_MP1024_UP4r_SIZE BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP4r_SIZE
typedef BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP4r_t AN_X4_LP_MP1024_UP4r_t;
#define AN_X4_LP_MP1024_UP4r_CLR BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP4r_CLR
#define AN_X4_LP_MP1024_UP4r_SET BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP4r_SET
#define AN_X4_LP_MP1024_UP4r_GET BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP4r_GET
#define AN_X4_LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_GET BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_GET
#define AN_X4_LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_SET BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP4r_LP_MP1024_UP4_PAGE_DATAf_SET
#define READ_AN_X4_LP_MP1024_UP4r BCMI_TSCE16_XGXS_READ_AN_X4_LP_MP1024_UP4r
#define WRITE_AN_X4_LP_MP1024_UP4r BCMI_TSCE16_XGXS_WRITE_AN_X4_LP_MP1024_UP4r
#define MODIFY_AN_X4_LP_MP1024_UP4r BCMI_TSCE16_XGXS_MODIFY_AN_X4_LP_MP1024_UP4r
#define READLN_AN_X4_LP_MP1024_UP4r BCMI_TSCE16_XGXS_READLN_AN_X4_LP_MP1024_UP4r
#define WRITELN_AN_X4_LP_MP1024_UP4r BCMI_TSCE16_XGXS_WRITELN_AN_X4_LP_MP1024_UP4r
#define WRITEALL_AN_X4_LP_MP1024_UP4r BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LP_MP1024_UP4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X4_LP_MP1024_UP4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X4_LP_BASE_PAGE1
 * BLOCKS:   AN_X4_HW_LP_PAGES
 * REGADDR:  0xc198
 * DESC:     LINK PARTNER BASE PAGE 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LP_BASE_PAGE1_PAGE_DATA AUTO-NEG LINK PARTNER BASE PAGE 1CL3715        - Next Page Indication14        - Receive Acknowledge13:12     - Remote Fault Status11:9      - reserved8:7       - Pause Ability6:5       - Duplex Ability4:0       - ReservedSGMII15        - Link Up14        - Receive Acknowledge13        - reserved12        - Duplex Ability11:10     - Speed Ability9:1       - reserved0         - SGMII IndicatorCL7315        - Next Page Indication14        - Receive Acknowledge13        - Remote Fault Status12        - reserved11:10     - Pause Ability9:5       - Echo of Received Nonce4:0       - Selector
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE1r (0x0000c198 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_BASE_PAGE1.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE1r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_base_page1[1];
	uint32_t _an_x4_lp_base_page1;
} BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE1r_t;

#define BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE1r_CLR(r) (r).an_x4_lp_base_page1[0] = 0
#define BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE1r_SET(r,d) (r).an_x4_lp_base_page1[0] = d
#define BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE1r_GET(r) (r).an_x4_lp_base_page1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_GET(r) (((r).an_x4_lp_base_page1[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_SET(r,f) (r).an_x4_lp_base_page1[0]=(((r).an_x4_lp_base_page1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_BASE_PAGE1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X4_LP_BASE_PAGE1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE1r,(_r._an_x4_lp_base_page1))
#define BCMI_TSCE16_XGXS_WRITE_AN_X4_LP_BASE_PAGE1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE1r,(_r._an_x4_lp_base_page1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X4_LP_BASE_PAGE1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE1r,(_r._an_x4_lp_base_page1))
#define BCMI_TSCE16_XGXS_READLN_AN_X4_LP_BASE_PAGE1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_base_page1))
#define BCMI_TSCE16_XGXS_WRITELN_AN_X4_LP_BASE_PAGE1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_base_page1))
#define BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LP_BASE_PAGE1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_base_page1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_BASE_PAGE1r BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE1r
#define AN_X4_LP_BASE_PAGE1r_SIZE BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE1r_SIZE
typedef BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE1r_t AN_X4_LP_BASE_PAGE1r_t;
#define AN_X4_LP_BASE_PAGE1r_CLR BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE1r_CLR
#define AN_X4_LP_BASE_PAGE1r_SET BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE1r_SET
#define AN_X4_LP_BASE_PAGE1r_GET BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE1r_GET
#define AN_X4_LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_GET BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_GET
#define AN_X4_LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_SET BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE1r_LP_BASE_PAGE1_PAGE_DATAf_SET
#define READ_AN_X4_LP_BASE_PAGE1r BCMI_TSCE16_XGXS_READ_AN_X4_LP_BASE_PAGE1r
#define WRITE_AN_X4_LP_BASE_PAGE1r BCMI_TSCE16_XGXS_WRITE_AN_X4_LP_BASE_PAGE1r
#define MODIFY_AN_X4_LP_BASE_PAGE1r BCMI_TSCE16_XGXS_MODIFY_AN_X4_LP_BASE_PAGE1r
#define READLN_AN_X4_LP_BASE_PAGE1r BCMI_TSCE16_XGXS_READLN_AN_X4_LP_BASE_PAGE1r
#define WRITELN_AN_X4_LP_BASE_PAGE1r BCMI_TSCE16_XGXS_WRITELN_AN_X4_LP_BASE_PAGE1r
#define WRITEALL_AN_X4_LP_BASE_PAGE1r BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LP_BASE_PAGE1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X4_LP_BASE_PAGE2
 * BLOCKS:   AN_X4_HW_LP_PAGES
 * REGADDR:  0xc199
 * DESC:     LINK PARTNER BASE PAGE 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LP_BASE_PAGE2_PAGE_DATA AUTO-NEG LINK PARTNER BASE PAGE 2CL7315:11      - reserved10         - 100G-CR109         - 40G-CR48         - 40G-KR47         - 10G-KR Ability6         - 10G-KX4 Ability5         - 1G-KX Ability4:0       - Transmit Nonce
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE2r (0x0000c199 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_BASE_PAGE2.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE2r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_base_page2[1];
	uint32_t _an_x4_lp_base_page2;
} BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE2r_t;

#define BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE2r_CLR(r) (r).an_x4_lp_base_page2[0] = 0
#define BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE2r_SET(r,d) (r).an_x4_lp_base_page2[0] = d
#define BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE2r_GET(r) (r).an_x4_lp_base_page2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_GET(r) (((r).an_x4_lp_base_page2[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_SET(r,f) (r).an_x4_lp_base_page2[0]=(((r).an_x4_lp_base_page2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_BASE_PAGE2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X4_LP_BASE_PAGE2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE2r,(_r._an_x4_lp_base_page2))
#define BCMI_TSCE16_XGXS_WRITE_AN_X4_LP_BASE_PAGE2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE2r,(_r._an_x4_lp_base_page2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X4_LP_BASE_PAGE2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE2r,(_r._an_x4_lp_base_page2))
#define BCMI_TSCE16_XGXS_READLN_AN_X4_LP_BASE_PAGE2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_base_page2))
#define BCMI_TSCE16_XGXS_WRITELN_AN_X4_LP_BASE_PAGE2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_base_page2))
#define BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LP_BASE_PAGE2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_base_page2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_BASE_PAGE2r BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE2r
#define AN_X4_LP_BASE_PAGE2r_SIZE BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE2r_SIZE
typedef BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE2r_t AN_X4_LP_BASE_PAGE2r_t;
#define AN_X4_LP_BASE_PAGE2r_CLR BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE2r_CLR
#define AN_X4_LP_BASE_PAGE2r_SET BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE2r_SET
#define AN_X4_LP_BASE_PAGE2r_GET BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE2r_GET
#define AN_X4_LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_GET BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_GET
#define AN_X4_LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_SET BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE2r_LP_BASE_PAGE2_PAGE_DATAf_SET
#define READ_AN_X4_LP_BASE_PAGE2r BCMI_TSCE16_XGXS_READ_AN_X4_LP_BASE_PAGE2r
#define WRITE_AN_X4_LP_BASE_PAGE2r BCMI_TSCE16_XGXS_WRITE_AN_X4_LP_BASE_PAGE2r
#define MODIFY_AN_X4_LP_BASE_PAGE2r BCMI_TSCE16_XGXS_MODIFY_AN_X4_LP_BASE_PAGE2r
#define READLN_AN_X4_LP_BASE_PAGE2r BCMI_TSCE16_XGXS_READLN_AN_X4_LP_BASE_PAGE2r
#define WRITELN_AN_X4_LP_BASE_PAGE2r BCMI_TSCE16_XGXS_WRITELN_AN_X4_LP_BASE_PAGE2r
#define WRITEALL_AN_X4_LP_BASE_PAGE2r BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LP_BASE_PAGE2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X4_LP_BASE_PAGE3
 * BLOCKS:   AN_X4_HW_LP_PAGES
 * REGADDR:  0xc19a
 * DESC:     LINK PARTNER BASE PAGE 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LP_BASE_PAGE3_PAGE_DATA AUTO-NEG LINK PARTNER BASE PAGE 3CL7315:14     - FEC13:0      - reserved
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE3r (0x0000c19a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE3r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_BASE_PAGE3.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE3r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_base_page3[1];
	uint32_t _an_x4_lp_base_page3;
} BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE3r_t;

#define BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE3r_CLR(r) (r).an_x4_lp_base_page3[0] = 0
#define BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE3r_SET(r,d) (r).an_x4_lp_base_page3[0] = d
#define BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE3r_GET(r) (r).an_x4_lp_base_page3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_GET(r) (((r).an_x4_lp_base_page3[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_SET(r,f) (r).an_x4_lp_base_page3[0]=(((r).an_x4_lp_base_page3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_BASE_PAGE3.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X4_LP_BASE_PAGE3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE3r,(_r._an_x4_lp_base_page3))
#define BCMI_TSCE16_XGXS_WRITE_AN_X4_LP_BASE_PAGE3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE3r,(_r._an_x4_lp_base_page3)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X4_LP_BASE_PAGE3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE3r,(_r._an_x4_lp_base_page3))
#define BCMI_TSCE16_XGXS_READLN_AN_X4_LP_BASE_PAGE3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_base_page3))
#define BCMI_TSCE16_XGXS_WRITELN_AN_X4_LP_BASE_PAGE3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_base_page3))
#define BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LP_BASE_PAGE3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_base_page3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_BASE_PAGE3r BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE3r
#define AN_X4_LP_BASE_PAGE3r_SIZE BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE3r_SIZE
typedef BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE3r_t AN_X4_LP_BASE_PAGE3r_t;
#define AN_X4_LP_BASE_PAGE3r_CLR BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE3r_CLR
#define AN_X4_LP_BASE_PAGE3r_SET BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE3r_SET
#define AN_X4_LP_BASE_PAGE3r_GET BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE3r_GET
#define AN_X4_LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_GET BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_GET
#define AN_X4_LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_SET BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE3r_LP_BASE_PAGE3_PAGE_DATAf_SET
#define READ_AN_X4_LP_BASE_PAGE3r BCMI_TSCE16_XGXS_READ_AN_X4_LP_BASE_PAGE3r
#define WRITE_AN_X4_LP_BASE_PAGE3r BCMI_TSCE16_XGXS_WRITE_AN_X4_LP_BASE_PAGE3r
#define MODIFY_AN_X4_LP_BASE_PAGE3r BCMI_TSCE16_XGXS_MODIFY_AN_X4_LP_BASE_PAGE3r
#define READLN_AN_X4_LP_BASE_PAGE3r BCMI_TSCE16_XGXS_READLN_AN_X4_LP_BASE_PAGE3r
#define WRITELN_AN_X4_LP_BASE_PAGE3r BCMI_TSCE16_XGXS_WRITELN_AN_X4_LP_BASE_PAGE3r
#define WRITEALL_AN_X4_LP_BASE_PAGE3r BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LP_BASE_PAGE3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X4_LP_BASE_PAGE3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X4_LD_PAGE2
 * BLOCKS:   AN_X4_SW_MANAGEMENT
 * REGADDR:  0xc1a0
 * DESC:     LOCAL DEVICE SW CONTROL PAGE 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LD_PAGE_2_PAGE_DATA LOCAL DEVICE PAGE 2 FIELD
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X4_LD_PAGE2r (0x0000c1a0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X4_LD_PAGE2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LD_PAGE2.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X4_LD_PAGE2r_s {
	uint32_t v[1];
	uint32_t an_x4_ld_page2[1];
	uint32_t _an_x4_ld_page2;
} BCMI_TSCE16_XGXS_AN_X4_LD_PAGE2r_t;

#define BCMI_TSCE16_XGXS_AN_X4_LD_PAGE2r_CLR(r) (r).an_x4_ld_page2[0] = 0
#define BCMI_TSCE16_XGXS_AN_X4_LD_PAGE2r_SET(r,d) (r).an_x4_ld_page2[0] = d
#define BCMI_TSCE16_XGXS_AN_X4_LD_PAGE2r_GET(r) (r).an_x4_ld_page2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X4_LD_PAGE2r_LD_PAGE_2_PAGE_DATAf_GET(r) (((r).an_x4_ld_page2[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_AN_X4_LD_PAGE2r_LD_PAGE_2_PAGE_DATAf_SET(r,f) (r).an_x4_ld_page2[0]=(((r).an_x4_ld_page2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LD_PAGE2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X4_LD_PAGE2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LD_PAGE2r,(_r._an_x4_ld_page2))
#define BCMI_TSCE16_XGXS_WRITE_AN_X4_LD_PAGE2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LD_PAGE2r,(_r._an_x4_ld_page2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X4_LD_PAGE2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LD_PAGE2r,(_r._an_x4_ld_page2))
#define BCMI_TSCE16_XGXS_READLN_AN_X4_LD_PAGE2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LD_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_page2))
#define BCMI_TSCE16_XGXS_WRITELN_AN_X4_LD_PAGE2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LD_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_page2))
#define BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LD_PAGE2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LD_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_ld_page2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LD_PAGE2r BCMI_TSCE16_XGXS_AN_X4_LD_PAGE2r
#define AN_X4_LD_PAGE2r_SIZE BCMI_TSCE16_XGXS_AN_X4_LD_PAGE2r_SIZE
typedef BCMI_TSCE16_XGXS_AN_X4_LD_PAGE2r_t AN_X4_LD_PAGE2r_t;
#define AN_X4_LD_PAGE2r_CLR BCMI_TSCE16_XGXS_AN_X4_LD_PAGE2r_CLR
#define AN_X4_LD_PAGE2r_SET BCMI_TSCE16_XGXS_AN_X4_LD_PAGE2r_SET
#define AN_X4_LD_PAGE2r_GET BCMI_TSCE16_XGXS_AN_X4_LD_PAGE2r_GET
#define AN_X4_LD_PAGE2r_LD_PAGE_2_PAGE_DATAf_GET BCMI_TSCE16_XGXS_AN_X4_LD_PAGE2r_LD_PAGE_2_PAGE_DATAf_GET
#define AN_X4_LD_PAGE2r_LD_PAGE_2_PAGE_DATAf_SET BCMI_TSCE16_XGXS_AN_X4_LD_PAGE2r_LD_PAGE_2_PAGE_DATAf_SET
#define READ_AN_X4_LD_PAGE2r BCMI_TSCE16_XGXS_READ_AN_X4_LD_PAGE2r
#define WRITE_AN_X4_LD_PAGE2r BCMI_TSCE16_XGXS_WRITE_AN_X4_LD_PAGE2r
#define MODIFY_AN_X4_LD_PAGE2r BCMI_TSCE16_XGXS_MODIFY_AN_X4_LD_PAGE2r
#define READLN_AN_X4_LD_PAGE2r BCMI_TSCE16_XGXS_READLN_AN_X4_LD_PAGE2r
#define WRITELN_AN_X4_LD_PAGE2r BCMI_TSCE16_XGXS_WRITELN_AN_X4_LD_PAGE2r
#define WRITEALL_AN_X4_LD_PAGE2r BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LD_PAGE2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X4_LD_PAGE2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X4_LD_PAGE1
 * BLOCKS:   AN_X4_SW_MANAGEMENT
 * REGADDR:  0xc1a1
 * DESC:     LOCAL DEVICE SW CONTROL PAGE 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LD_PAGE_1_PAGE_DATA LOCAL DEVICE PAGE 1 FIELD
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X4_LD_PAGE1r (0x0000c1a1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X4_LD_PAGE1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LD_PAGE1.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X4_LD_PAGE1r_s {
	uint32_t v[1];
	uint32_t an_x4_ld_page1[1];
	uint32_t _an_x4_ld_page1;
} BCMI_TSCE16_XGXS_AN_X4_LD_PAGE1r_t;

#define BCMI_TSCE16_XGXS_AN_X4_LD_PAGE1r_CLR(r) (r).an_x4_ld_page1[0] = 0
#define BCMI_TSCE16_XGXS_AN_X4_LD_PAGE1r_SET(r,d) (r).an_x4_ld_page1[0] = d
#define BCMI_TSCE16_XGXS_AN_X4_LD_PAGE1r_GET(r) (r).an_x4_ld_page1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X4_LD_PAGE1r_LD_PAGE_1_PAGE_DATAf_GET(r) (((r).an_x4_ld_page1[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_AN_X4_LD_PAGE1r_LD_PAGE_1_PAGE_DATAf_SET(r,f) (r).an_x4_ld_page1[0]=(((r).an_x4_ld_page1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LD_PAGE1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X4_LD_PAGE1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LD_PAGE1r,(_r._an_x4_ld_page1))
#define BCMI_TSCE16_XGXS_WRITE_AN_X4_LD_PAGE1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LD_PAGE1r,(_r._an_x4_ld_page1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X4_LD_PAGE1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LD_PAGE1r,(_r._an_x4_ld_page1))
#define BCMI_TSCE16_XGXS_READLN_AN_X4_LD_PAGE1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LD_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_page1))
#define BCMI_TSCE16_XGXS_WRITELN_AN_X4_LD_PAGE1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LD_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_page1))
#define BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LD_PAGE1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LD_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_ld_page1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LD_PAGE1r BCMI_TSCE16_XGXS_AN_X4_LD_PAGE1r
#define AN_X4_LD_PAGE1r_SIZE BCMI_TSCE16_XGXS_AN_X4_LD_PAGE1r_SIZE
typedef BCMI_TSCE16_XGXS_AN_X4_LD_PAGE1r_t AN_X4_LD_PAGE1r_t;
#define AN_X4_LD_PAGE1r_CLR BCMI_TSCE16_XGXS_AN_X4_LD_PAGE1r_CLR
#define AN_X4_LD_PAGE1r_SET BCMI_TSCE16_XGXS_AN_X4_LD_PAGE1r_SET
#define AN_X4_LD_PAGE1r_GET BCMI_TSCE16_XGXS_AN_X4_LD_PAGE1r_GET
#define AN_X4_LD_PAGE1r_LD_PAGE_1_PAGE_DATAf_GET BCMI_TSCE16_XGXS_AN_X4_LD_PAGE1r_LD_PAGE_1_PAGE_DATAf_GET
#define AN_X4_LD_PAGE1r_LD_PAGE_1_PAGE_DATAf_SET BCMI_TSCE16_XGXS_AN_X4_LD_PAGE1r_LD_PAGE_1_PAGE_DATAf_SET
#define READ_AN_X4_LD_PAGE1r BCMI_TSCE16_XGXS_READ_AN_X4_LD_PAGE1r
#define WRITE_AN_X4_LD_PAGE1r BCMI_TSCE16_XGXS_WRITE_AN_X4_LD_PAGE1r
#define MODIFY_AN_X4_LD_PAGE1r BCMI_TSCE16_XGXS_MODIFY_AN_X4_LD_PAGE1r
#define READLN_AN_X4_LD_PAGE1r BCMI_TSCE16_XGXS_READLN_AN_X4_LD_PAGE1r
#define WRITELN_AN_X4_LD_PAGE1r BCMI_TSCE16_XGXS_WRITELN_AN_X4_LD_PAGE1r
#define WRITEALL_AN_X4_LD_PAGE1r BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LD_PAGE1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X4_LD_PAGE1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X4_LD_PAGE0
 * BLOCKS:   AN_X4_SW_MANAGEMENT
 * REGADDR:  0xc1a2
 * DESC:     LOCAL DEVICE SW CONTROL PAGE 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LD_PAGE_0_PAGE_DATA LOCAL DEVICE PAGE 0 FIELD
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X4_LD_PAGE0r (0x0000c1a2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X4_LD_PAGE0r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LD_PAGE0.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X4_LD_PAGE0r_s {
	uint32_t v[1];
	uint32_t an_x4_ld_page0[1];
	uint32_t _an_x4_ld_page0;
} BCMI_TSCE16_XGXS_AN_X4_LD_PAGE0r_t;

#define BCMI_TSCE16_XGXS_AN_X4_LD_PAGE0r_CLR(r) (r).an_x4_ld_page0[0] = 0
#define BCMI_TSCE16_XGXS_AN_X4_LD_PAGE0r_SET(r,d) (r).an_x4_ld_page0[0] = d
#define BCMI_TSCE16_XGXS_AN_X4_LD_PAGE0r_GET(r) (r).an_x4_ld_page0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X4_LD_PAGE0r_LD_PAGE_0_PAGE_DATAf_GET(r) (((r).an_x4_ld_page0[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_AN_X4_LD_PAGE0r_LD_PAGE_0_PAGE_DATAf_SET(r,f) (r).an_x4_ld_page0[0]=(((r).an_x4_ld_page0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LD_PAGE0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X4_LD_PAGE0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LD_PAGE0r,(_r._an_x4_ld_page0))
#define BCMI_TSCE16_XGXS_WRITE_AN_X4_LD_PAGE0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LD_PAGE0r,(_r._an_x4_ld_page0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X4_LD_PAGE0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LD_PAGE0r,(_r._an_x4_ld_page0))
#define BCMI_TSCE16_XGXS_READLN_AN_X4_LD_PAGE0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LD_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_page0))
#define BCMI_TSCE16_XGXS_WRITELN_AN_X4_LD_PAGE0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LD_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_page0))
#define BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LD_PAGE0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LD_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_ld_page0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LD_PAGE0r BCMI_TSCE16_XGXS_AN_X4_LD_PAGE0r
#define AN_X4_LD_PAGE0r_SIZE BCMI_TSCE16_XGXS_AN_X4_LD_PAGE0r_SIZE
typedef BCMI_TSCE16_XGXS_AN_X4_LD_PAGE0r_t AN_X4_LD_PAGE0r_t;
#define AN_X4_LD_PAGE0r_CLR BCMI_TSCE16_XGXS_AN_X4_LD_PAGE0r_CLR
#define AN_X4_LD_PAGE0r_SET BCMI_TSCE16_XGXS_AN_X4_LD_PAGE0r_SET
#define AN_X4_LD_PAGE0r_GET BCMI_TSCE16_XGXS_AN_X4_LD_PAGE0r_GET
#define AN_X4_LD_PAGE0r_LD_PAGE_0_PAGE_DATAf_GET BCMI_TSCE16_XGXS_AN_X4_LD_PAGE0r_LD_PAGE_0_PAGE_DATAf_GET
#define AN_X4_LD_PAGE0r_LD_PAGE_0_PAGE_DATAf_SET BCMI_TSCE16_XGXS_AN_X4_LD_PAGE0r_LD_PAGE_0_PAGE_DATAf_SET
#define READ_AN_X4_LD_PAGE0r BCMI_TSCE16_XGXS_READ_AN_X4_LD_PAGE0r
#define WRITE_AN_X4_LD_PAGE0r BCMI_TSCE16_XGXS_WRITE_AN_X4_LD_PAGE0r
#define MODIFY_AN_X4_LD_PAGE0r BCMI_TSCE16_XGXS_MODIFY_AN_X4_LD_PAGE0r
#define READLN_AN_X4_LD_PAGE0r BCMI_TSCE16_XGXS_READLN_AN_X4_LD_PAGE0r
#define WRITELN_AN_X4_LD_PAGE0r BCMI_TSCE16_XGXS_WRITELN_AN_X4_LD_PAGE0r
#define WRITEALL_AN_X4_LD_PAGE0r BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LD_PAGE0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X4_LD_PAGE0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X4_LP_PAGE2
 * BLOCKS:   AN_X4_SW_MANAGEMENT
 * REGADDR:  0xc1a3
 * DESC:     LINK PARNTER SW CONTROL PAGE 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LP_PAGE_2_PAGE_DATA LINK PARTNER PAGE 2 FIELD
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X4_LP_PAGE2r (0x0000c1a3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X4_LP_PAGE2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_PAGE2.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X4_LP_PAGE2r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_page2[1];
	uint32_t _an_x4_lp_page2;
} BCMI_TSCE16_XGXS_AN_X4_LP_PAGE2r_t;

#define BCMI_TSCE16_XGXS_AN_X4_LP_PAGE2r_CLR(r) (r).an_x4_lp_page2[0] = 0
#define BCMI_TSCE16_XGXS_AN_X4_LP_PAGE2r_SET(r,d) (r).an_x4_lp_page2[0] = d
#define BCMI_TSCE16_XGXS_AN_X4_LP_PAGE2r_GET(r) (r).an_x4_lp_page2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X4_LP_PAGE2r_LP_PAGE_2_PAGE_DATAf_GET(r) (((r).an_x4_lp_page2[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_AN_X4_LP_PAGE2r_LP_PAGE_2_PAGE_DATAf_SET(r,f) (r).an_x4_lp_page2[0]=(((r).an_x4_lp_page2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_PAGE2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X4_LP_PAGE2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_PAGE2r,(_r._an_x4_lp_page2))
#define BCMI_TSCE16_XGXS_WRITE_AN_X4_LP_PAGE2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_PAGE2r,(_r._an_x4_lp_page2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X4_LP_PAGE2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_PAGE2r,(_r._an_x4_lp_page2))
#define BCMI_TSCE16_XGXS_READLN_AN_X4_LP_PAGE2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_page2))
#define BCMI_TSCE16_XGXS_WRITELN_AN_X4_LP_PAGE2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_page2))
#define BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LP_PAGE2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_page2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_PAGE2r BCMI_TSCE16_XGXS_AN_X4_LP_PAGE2r
#define AN_X4_LP_PAGE2r_SIZE BCMI_TSCE16_XGXS_AN_X4_LP_PAGE2r_SIZE
typedef BCMI_TSCE16_XGXS_AN_X4_LP_PAGE2r_t AN_X4_LP_PAGE2r_t;
#define AN_X4_LP_PAGE2r_CLR BCMI_TSCE16_XGXS_AN_X4_LP_PAGE2r_CLR
#define AN_X4_LP_PAGE2r_SET BCMI_TSCE16_XGXS_AN_X4_LP_PAGE2r_SET
#define AN_X4_LP_PAGE2r_GET BCMI_TSCE16_XGXS_AN_X4_LP_PAGE2r_GET
#define AN_X4_LP_PAGE2r_LP_PAGE_2_PAGE_DATAf_GET BCMI_TSCE16_XGXS_AN_X4_LP_PAGE2r_LP_PAGE_2_PAGE_DATAf_GET
#define AN_X4_LP_PAGE2r_LP_PAGE_2_PAGE_DATAf_SET BCMI_TSCE16_XGXS_AN_X4_LP_PAGE2r_LP_PAGE_2_PAGE_DATAf_SET
#define READ_AN_X4_LP_PAGE2r BCMI_TSCE16_XGXS_READ_AN_X4_LP_PAGE2r
#define WRITE_AN_X4_LP_PAGE2r BCMI_TSCE16_XGXS_WRITE_AN_X4_LP_PAGE2r
#define MODIFY_AN_X4_LP_PAGE2r BCMI_TSCE16_XGXS_MODIFY_AN_X4_LP_PAGE2r
#define READLN_AN_X4_LP_PAGE2r BCMI_TSCE16_XGXS_READLN_AN_X4_LP_PAGE2r
#define WRITELN_AN_X4_LP_PAGE2r BCMI_TSCE16_XGXS_WRITELN_AN_X4_LP_PAGE2r
#define WRITEALL_AN_X4_LP_PAGE2r BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LP_PAGE2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X4_LP_PAGE2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X4_LP_PAGE1
 * BLOCKS:   AN_X4_SW_MANAGEMENT
 * REGADDR:  0xc1a4
 * DESC:     LINK PARNTER SW CONTROL PAGE 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LP_PAGE_1_PAGE_DATA LINK PARTNER PAGE 1 FIELD
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X4_LP_PAGE1r (0x0000c1a4 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X4_LP_PAGE1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_PAGE1.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X4_LP_PAGE1r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_page1[1];
	uint32_t _an_x4_lp_page1;
} BCMI_TSCE16_XGXS_AN_X4_LP_PAGE1r_t;

#define BCMI_TSCE16_XGXS_AN_X4_LP_PAGE1r_CLR(r) (r).an_x4_lp_page1[0] = 0
#define BCMI_TSCE16_XGXS_AN_X4_LP_PAGE1r_SET(r,d) (r).an_x4_lp_page1[0] = d
#define BCMI_TSCE16_XGXS_AN_X4_LP_PAGE1r_GET(r) (r).an_x4_lp_page1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X4_LP_PAGE1r_LP_PAGE_1_PAGE_DATAf_GET(r) (((r).an_x4_lp_page1[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_AN_X4_LP_PAGE1r_LP_PAGE_1_PAGE_DATAf_SET(r,f) (r).an_x4_lp_page1[0]=(((r).an_x4_lp_page1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_PAGE1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X4_LP_PAGE1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_PAGE1r,(_r._an_x4_lp_page1))
#define BCMI_TSCE16_XGXS_WRITE_AN_X4_LP_PAGE1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_PAGE1r,(_r._an_x4_lp_page1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X4_LP_PAGE1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_PAGE1r,(_r._an_x4_lp_page1))
#define BCMI_TSCE16_XGXS_READLN_AN_X4_LP_PAGE1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_page1))
#define BCMI_TSCE16_XGXS_WRITELN_AN_X4_LP_PAGE1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_page1))
#define BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LP_PAGE1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_page1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_PAGE1r BCMI_TSCE16_XGXS_AN_X4_LP_PAGE1r
#define AN_X4_LP_PAGE1r_SIZE BCMI_TSCE16_XGXS_AN_X4_LP_PAGE1r_SIZE
typedef BCMI_TSCE16_XGXS_AN_X4_LP_PAGE1r_t AN_X4_LP_PAGE1r_t;
#define AN_X4_LP_PAGE1r_CLR BCMI_TSCE16_XGXS_AN_X4_LP_PAGE1r_CLR
#define AN_X4_LP_PAGE1r_SET BCMI_TSCE16_XGXS_AN_X4_LP_PAGE1r_SET
#define AN_X4_LP_PAGE1r_GET BCMI_TSCE16_XGXS_AN_X4_LP_PAGE1r_GET
#define AN_X4_LP_PAGE1r_LP_PAGE_1_PAGE_DATAf_GET BCMI_TSCE16_XGXS_AN_X4_LP_PAGE1r_LP_PAGE_1_PAGE_DATAf_GET
#define AN_X4_LP_PAGE1r_LP_PAGE_1_PAGE_DATAf_SET BCMI_TSCE16_XGXS_AN_X4_LP_PAGE1r_LP_PAGE_1_PAGE_DATAf_SET
#define READ_AN_X4_LP_PAGE1r BCMI_TSCE16_XGXS_READ_AN_X4_LP_PAGE1r
#define WRITE_AN_X4_LP_PAGE1r BCMI_TSCE16_XGXS_WRITE_AN_X4_LP_PAGE1r
#define MODIFY_AN_X4_LP_PAGE1r BCMI_TSCE16_XGXS_MODIFY_AN_X4_LP_PAGE1r
#define READLN_AN_X4_LP_PAGE1r BCMI_TSCE16_XGXS_READLN_AN_X4_LP_PAGE1r
#define WRITELN_AN_X4_LP_PAGE1r BCMI_TSCE16_XGXS_WRITELN_AN_X4_LP_PAGE1r
#define WRITEALL_AN_X4_LP_PAGE1r BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LP_PAGE1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X4_LP_PAGE1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X4_LP_PAGE0
 * BLOCKS:   AN_X4_SW_MANAGEMENT
 * REGADDR:  0xc1a5
 * DESC:     LINK PARNTER SW CONTROL PAGE 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LP_PAGE_0_PAGE_DATA LINK PARTNER PAGE 0 FIELD
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X4_LP_PAGE0r (0x0000c1a5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X4_LP_PAGE0r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_PAGE0.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X4_LP_PAGE0r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_page0[1];
	uint32_t _an_x4_lp_page0;
} BCMI_TSCE16_XGXS_AN_X4_LP_PAGE0r_t;

#define BCMI_TSCE16_XGXS_AN_X4_LP_PAGE0r_CLR(r) (r).an_x4_lp_page0[0] = 0
#define BCMI_TSCE16_XGXS_AN_X4_LP_PAGE0r_SET(r,d) (r).an_x4_lp_page0[0] = d
#define BCMI_TSCE16_XGXS_AN_X4_LP_PAGE0r_GET(r) (r).an_x4_lp_page0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X4_LP_PAGE0r_LP_PAGE_0_PAGE_DATAf_GET(r) (((r).an_x4_lp_page0[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_AN_X4_LP_PAGE0r_LP_PAGE_0_PAGE_DATAf_SET(r,f) (r).an_x4_lp_page0[0]=(((r).an_x4_lp_page0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_PAGE0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X4_LP_PAGE0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_PAGE0r,(_r._an_x4_lp_page0))
#define BCMI_TSCE16_XGXS_WRITE_AN_X4_LP_PAGE0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_PAGE0r,(_r._an_x4_lp_page0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X4_LP_PAGE0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_PAGE0r,(_r._an_x4_lp_page0))
#define BCMI_TSCE16_XGXS_READLN_AN_X4_LP_PAGE0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_page0))
#define BCMI_TSCE16_XGXS_WRITELN_AN_X4_LP_PAGE0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_page0))
#define BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LP_PAGE0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LP_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_page0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_PAGE0r BCMI_TSCE16_XGXS_AN_X4_LP_PAGE0r
#define AN_X4_LP_PAGE0r_SIZE BCMI_TSCE16_XGXS_AN_X4_LP_PAGE0r_SIZE
typedef BCMI_TSCE16_XGXS_AN_X4_LP_PAGE0r_t AN_X4_LP_PAGE0r_t;
#define AN_X4_LP_PAGE0r_CLR BCMI_TSCE16_XGXS_AN_X4_LP_PAGE0r_CLR
#define AN_X4_LP_PAGE0r_SET BCMI_TSCE16_XGXS_AN_X4_LP_PAGE0r_SET
#define AN_X4_LP_PAGE0r_GET BCMI_TSCE16_XGXS_AN_X4_LP_PAGE0r_GET
#define AN_X4_LP_PAGE0r_LP_PAGE_0_PAGE_DATAf_GET BCMI_TSCE16_XGXS_AN_X4_LP_PAGE0r_LP_PAGE_0_PAGE_DATAf_GET
#define AN_X4_LP_PAGE0r_LP_PAGE_0_PAGE_DATAf_SET BCMI_TSCE16_XGXS_AN_X4_LP_PAGE0r_LP_PAGE_0_PAGE_DATAf_SET
#define READ_AN_X4_LP_PAGE0r BCMI_TSCE16_XGXS_READ_AN_X4_LP_PAGE0r
#define WRITE_AN_X4_LP_PAGE0r BCMI_TSCE16_XGXS_WRITE_AN_X4_LP_PAGE0r
#define MODIFY_AN_X4_LP_PAGE0r BCMI_TSCE16_XGXS_MODIFY_AN_X4_LP_PAGE0r
#define READLN_AN_X4_LP_PAGE0r BCMI_TSCE16_XGXS_READLN_AN_X4_LP_PAGE0r
#define WRITELN_AN_X4_LP_PAGE0r BCMI_TSCE16_XGXS_WRITELN_AN_X4_LP_PAGE0r
#define WRITEALL_AN_X4_LP_PAGE0r BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LP_PAGE0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X4_LP_PAGE0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X4_SW_CTL_STS
 * BLOCKS:   AN_X4_SW_MANAGEMENT
 * REGADDR:  0xc1a6
 * DESC:     SW CONTROL STATUS INFORMATION
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLA_LN_SEQUENCER_FSM_STATUS1 TLA Lane sequencer fsm latched status cont.Clear on read of tla_ln_seq_status register
 *     PD_CL37_COMPLETED Parallel detect process has selected cl37 and it was completed.
 *     LP_STATUS_VALID  Set by HW, Clear on Read of lp_page_0
 *     LD_CONTROL_VALID Set by SW write to ld_page_0, Cleared when HW transfers the ld_page's
 *     AN_COMPLETED_SW  Software control page sequence. All page exchanges have completed
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr (0x0000c1a6 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_CTL_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_ctl_sts[1];
	uint32_t _an_x4_sw_ctl_sts;
} BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr_t;

#define BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr_CLR(r) (r).an_x4_sw_ctl_sts[0] = 0
#define BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr_SET(r,d) (r).an_x4_sw_ctl_sts[0] = d
#define BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr_GET(r) (r).an_x4_sw_ctl_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr_AN_COMPLETED_SWf_GET(r) ((((r).an_x4_sw_ctl_sts[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr_AN_COMPLETED_SWf_SET(r,f) (r).an_x4_sw_ctl_sts[0]=(((r).an_x4_sw_ctl_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr_LD_CONTROL_VALIDf_GET(r) ((((r).an_x4_sw_ctl_sts[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr_LD_CONTROL_VALIDf_SET(r,f) (r).an_x4_sw_ctl_sts[0]=(((r).an_x4_sw_ctl_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr_LP_STATUS_VALIDf_GET(r) ((((r).an_x4_sw_ctl_sts[0]) >> 13) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr_LP_STATUS_VALIDf_SET(r,f) (r).an_x4_sw_ctl_sts[0]=(((r).an_x4_sw_ctl_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr_PD_CL37_COMPLETEDf_GET(r) ((((r).an_x4_sw_ctl_sts[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr_PD_CL37_COMPLETEDf_SET(r,f) (r).an_x4_sw_ctl_sts[0]=(((r).an_x4_sw_ctl_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_GET(r) (((r).an_x4_sw_ctl_sts[0]) & 0xff)
#define BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_SET(r,f) (r).an_x4_sw_ctl_sts[0]=(((r).an_x4_sw_ctl_sts[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access AN_X4_SW_CTL_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X4_SW_CTL_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr,(_r._an_x4_sw_ctl_sts))
#define BCMI_TSCE16_XGXS_WRITE_AN_X4_SW_CTL_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr,(_r._an_x4_sw_ctl_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X4_SW_CTL_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr,(_r._an_x4_sw_ctl_sts))
#define BCMI_TSCE16_XGXS_READLN_AN_X4_SW_CTL_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_ctl_sts))
#define BCMI_TSCE16_XGXS_WRITELN_AN_X4_SW_CTL_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_ctl_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_AN_X4_SW_CTL_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_ctl_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_CTL_STSr BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr
#define AN_X4_SW_CTL_STSr_SIZE BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr_SIZE
typedef BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr_t AN_X4_SW_CTL_STSr_t;
#define AN_X4_SW_CTL_STSr_CLR BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr_CLR
#define AN_X4_SW_CTL_STSr_SET BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr_SET
#define AN_X4_SW_CTL_STSr_GET BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr_GET
#define AN_X4_SW_CTL_STSr_AN_COMPLETED_SWf_GET BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr_AN_COMPLETED_SWf_GET
#define AN_X4_SW_CTL_STSr_AN_COMPLETED_SWf_SET BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr_AN_COMPLETED_SWf_SET
#define AN_X4_SW_CTL_STSr_LD_CONTROL_VALIDf_GET BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr_LD_CONTROL_VALIDf_GET
#define AN_X4_SW_CTL_STSr_LD_CONTROL_VALIDf_SET BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr_LD_CONTROL_VALIDf_SET
#define AN_X4_SW_CTL_STSr_LP_STATUS_VALIDf_GET BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr_LP_STATUS_VALIDf_GET
#define AN_X4_SW_CTL_STSr_LP_STATUS_VALIDf_SET BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr_LP_STATUS_VALIDf_SET
#define AN_X4_SW_CTL_STSr_PD_CL37_COMPLETEDf_GET BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr_PD_CL37_COMPLETEDf_GET
#define AN_X4_SW_CTL_STSr_PD_CL37_COMPLETEDf_SET BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr_PD_CL37_COMPLETEDf_SET
#define AN_X4_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_GET BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_GET
#define AN_X4_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_SET BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_SET
#define READ_AN_X4_SW_CTL_STSr BCMI_TSCE16_XGXS_READ_AN_X4_SW_CTL_STSr
#define WRITE_AN_X4_SW_CTL_STSr BCMI_TSCE16_XGXS_WRITE_AN_X4_SW_CTL_STSr
#define MODIFY_AN_X4_SW_CTL_STSr BCMI_TSCE16_XGXS_MODIFY_AN_X4_SW_CTL_STSr
#define READLN_AN_X4_SW_CTL_STSr BCMI_TSCE16_XGXS_READLN_AN_X4_SW_CTL_STSr
#define WRITELN_AN_X4_SW_CTL_STSr BCMI_TSCE16_XGXS_WRITELN_AN_X4_SW_CTL_STSr
#define WRITEALL_AN_X4_SW_CTL_STSr BCMI_TSCE16_XGXS_WRITEALL_AN_X4_SW_CTL_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X4_SW_CTL_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X4_LD_CTL
 * BLOCKS:   AN_X4_SW_MANAGEMENT
 * REGADDR:  0xc1a7
 * DESC:     LOCAL DEVICE CONTROLS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SW_HCD           Indicates HW does not perform HCD
 *     SW_AN            Indicates SW managed AN
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X4_LD_CTLr (0x0000c1a7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X4_LD_CTLr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LD_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X4_LD_CTLr_s {
	uint32_t v[1];
	uint32_t an_x4_ld_ctl[1];
	uint32_t _an_x4_ld_ctl;
} BCMI_TSCE16_XGXS_AN_X4_LD_CTLr_t;

#define BCMI_TSCE16_XGXS_AN_X4_LD_CTLr_CLR(r) (r).an_x4_ld_ctl[0] = 0
#define BCMI_TSCE16_XGXS_AN_X4_LD_CTLr_SET(r,d) (r).an_x4_ld_ctl[0] = d
#define BCMI_TSCE16_XGXS_AN_X4_LD_CTLr_GET(r) (r).an_x4_ld_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X4_LD_CTLr_SW_ANf_GET(r) ((((r).an_x4_ld_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LD_CTLr_SW_ANf_SET(r,f) (r).an_x4_ld_ctl[0]=(((r).an_x4_ld_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_AN_X4_LD_CTLr_SW_HCDf_GET(r) (((r).an_x4_ld_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_LD_CTLr_SW_HCDf_SET(r,f) (r).an_x4_ld_ctl[0]=(((r).an_x4_ld_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_LD_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X4_LD_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LD_CTLr,(_r._an_x4_ld_ctl))
#define BCMI_TSCE16_XGXS_WRITE_AN_X4_LD_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LD_CTLr,(_r._an_x4_ld_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X4_LD_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LD_CTLr,(_r._an_x4_ld_ctl))
#define BCMI_TSCE16_XGXS_READLN_AN_X4_LD_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_LD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_AN_X4_LD_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LD_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_LD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_ld_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LD_CTLr BCMI_TSCE16_XGXS_AN_X4_LD_CTLr
#define AN_X4_LD_CTLr_SIZE BCMI_TSCE16_XGXS_AN_X4_LD_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_AN_X4_LD_CTLr_t AN_X4_LD_CTLr_t;
#define AN_X4_LD_CTLr_CLR BCMI_TSCE16_XGXS_AN_X4_LD_CTLr_CLR
#define AN_X4_LD_CTLr_SET BCMI_TSCE16_XGXS_AN_X4_LD_CTLr_SET
#define AN_X4_LD_CTLr_GET BCMI_TSCE16_XGXS_AN_X4_LD_CTLr_GET
#define AN_X4_LD_CTLr_SW_ANf_GET BCMI_TSCE16_XGXS_AN_X4_LD_CTLr_SW_ANf_GET
#define AN_X4_LD_CTLr_SW_ANf_SET BCMI_TSCE16_XGXS_AN_X4_LD_CTLr_SW_ANf_SET
#define AN_X4_LD_CTLr_SW_HCDf_GET BCMI_TSCE16_XGXS_AN_X4_LD_CTLr_SW_HCDf_GET
#define AN_X4_LD_CTLr_SW_HCDf_SET BCMI_TSCE16_XGXS_AN_X4_LD_CTLr_SW_HCDf_SET
#define READ_AN_X4_LD_CTLr BCMI_TSCE16_XGXS_READ_AN_X4_LD_CTLr
#define WRITE_AN_X4_LD_CTLr BCMI_TSCE16_XGXS_WRITE_AN_X4_LD_CTLr
#define MODIFY_AN_X4_LD_CTLr BCMI_TSCE16_XGXS_MODIFY_AN_X4_LD_CTLr
#define READLN_AN_X4_LD_CTLr BCMI_TSCE16_XGXS_READLN_AN_X4_LD_CTLr
#define WRITELN_AN_X4_LD_CTLr BCMI_TSCE16_XGXS_WRITELN_AN_X4_LD_CTLr
#define WRITEALL_AN_X4_LD_CTLr BCMI_TSCE16_XGXS_WRITEALL_AN_X4_LD_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X4_LD_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X4_AN_PAGE_SEQUENCER_STS
 * BLOCKS:   AN_X4_SW_MANAGEMENT
 * REGADDR:  0xc1a8
 * DESC:     AN PAGE SEQUENCER STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AN_ST_CL73_COMPLETE CL73 auto-neg is complete
 *     AN_ST_CL37_COMPLETE CL37 auto-neg is completeClear on read
 *     AN_ST_RX_NP_TOGGLE_ERR Received auto-neg next page without T togglingClear on read
 *     AN_ST_RX_INVALID_SEQ Received invalid auto-neg page sequenceClear on read
 *     AN_ST_RX_UP_OUI_MATCH Received auto-neg MPS-5 OUI matchClear on read
 *     AN_ST_RX_UP_OUI_MISMATCH Received auto-neg MPS-5 OUI mismatchClear on read
 *     AN_ST_RX_UP_3    Received auto-neg unformatted page 3Clear on read
 *     AN_ST_RX_MP_MISMATCH Received mismatching auto-neg message pageClear on read
 *     AN_ST_RX_MP_OVER1G Received auto-neg message page 1024 (Over1G Message)Clear on read
 *     AN_ST_RX_MP_OUI  Received auto-neg message page 5 (Organizationally Unique Identifier Message)Clear on read
 *     AN_ST_RX_MP_NULL Received auto-neg message page 1 (Null Message)Clear on read
 *     AN_ST_RX_NP      Received auto-neg next pageClear on read
 *     AN_ST_RX_BP      Received auto-neg base pageClear on read
 *     AN_ST_RX_SGMII_MISMATCH Received non-SGMII page when in SGMII auto-neg modeClear on read
 *     AN_ST_HP_MODE    In Hewlett-Packard auto-neg modeClear on read
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr (0x0000c1a8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_AN_PAGE_SEQUENCER_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_an_page_sequencer_sts[1];
	uint32_t _an_x4_an_page_sequencer_sts;
} BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_t;

#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_CLR(r) (r).an_x4_an_page_sequencer_sts[0] = 0
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_SET(r,d) (r).an_x4_an_page_sequencer_sts[0] = d
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_GET(r) (r).an_x4_an_page_sequencer_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_SGMII_MODEf_GET(r) ((((r).an_x4_an_page_sequencer_sts[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_SGMII_MODEf_SET(r,f) (r).an_x4_an_page_sequencer_sts[0]=(((r).an_x4_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_HP_MODEf_GET(r) ((((r).an_x4_an_page_sequencer_sts[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_HP_MODEf_SET(r,f) (r).an_x4_an_page_sequencer_sts[0]=(((r).an_x4_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_SGMII_MISMATCHf_GET(r) ((((r).an_x4_an_page_sequencer_sts[0]) >> 13) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_SGMII_MISMATCHf_SET(r,f) (r).an_x4_an_page_sequencer_sts[0]=(((r).an_x4_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_BPf_GET(r) ((((r).an_x4_an_page_sequencer_sts[0]) >> 12) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_BPf_SET(r,f) (r).an_x4_an_page_sequencer_sts[0]=(((r).an_x4_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NPf_GET(r) ((((r).an_x4_an_page_sequencer_sts[0]) >> 11) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NPf_SET(r,f) (r).an_x4_an_page_sequencer_sts[0]=(((r).an_x4_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_NULLf_GET(r) ((((r).an_x4_an_page_sequencer_sts[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_NULLf_SET(r,f) (r).an_x4_an_page_sequencer_sts[0]=(((r).an_x4_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OUIf_GET(r) ((((r).an_x4_an_page_sequencer_sts[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OUIf_SET(r,f) (r).an_x4_an_page_sequencer_sts[0]=(((r).an_x4_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OVER1Gf_GET(r) ((((r).an_x4_an_page_sequencer_sts[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OVER1Gf_SET(r,f) (r).an_x4_an_page_sequencer_sts[0]=(((r).an_x4_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_MISMATCHf_GET(r) ((((r).an_x4_an_page_sequencer_sts[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_MISMATCHf_SET(r,f) (r).an_x4_an_page_sequencer_sts[0]=(((r).an_x4_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_3f_GET(r) ((((r).an_x4_an_page_sequencer_sts[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_3f_SET(r,f) (r).an_x4_an_page_sequencer_sts[0]=(((r).an_x4_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MISMATCHf_GET(r) ((((r).an_x4_an_page_sequencer_sts[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MISMATCHf_SET(r,f) (r).an_x4_an_page_sequencer_sts[0]=(((r).an_x4_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MATCHf_GET(r) ((((r).an_x4_an_page_sequencer_sts[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MATCHf_SET(r,f) (r).an_x4_an_page_sequencer_sts[0]=(((r).an_x4_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_INVALID_SEQf_GET(r) ((((r).an_x4_an_page_sequencer_sts[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_INVALID_SEQf_SET(r,f) (r).an_x4_an_page_sequencer_sts[0]=(((r).an_x4_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NP_TOGGLE_ERRf_GET(r) ((((r).an_x4_an_page_sequencer_sts[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NP_TOGGLE_ERRf_SET(r,f) (r).an_x4_an_page_sequencer_sts[0]=(((r).an_x4_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_CL37_COMPLETEf_GET(r) ((((r).an_x4_an_page_sequencer_sts[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_CL37_COMPLETEf_SET(r,f) (r).an_x4_an_page_sequencer_sts[0]=(((r).an_x4_an_page_sequencer_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_CL73_COMPLETEf_GET(r) (((r).an_x4_an_page_sequencer_sts[0]) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_CL73_COMPLETEf_SET(r,f) (r).an_x4_an_page_sequencer_sts[0]=(((r).an_x4_an_page_sequencer_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_AN_PAGE_SEQUENCER_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X4_AN_PAGE_SEQUENCER_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr,(_r._an_x4_an_page_sequencer_sts))
#define BCMI_TSCE16_XGXS_WRITE_AN_X4_AN_PAGE_SEQUENCER_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr,(_r._an_x4_an_page_sequencer_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X4_AN_PAGE_SEQUENCER_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr,(_r._an_x4_an_page_sequencer_sts))
#define BCMI_TSCE16_XGXS_READLN_AN_X4_AN_PAGE_SEQUENCER_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_an_page_sequencer_sts))
#define BCMI_TSCE16_XGXS_WRITELN_AN_X4_AN_PAGE_SEQUENCER_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_an_page_sequencer_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_AN_X4_AN_PAGE_SEQUENCER_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_an_page_sequencer_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_AN_PAGE_SEQUENCER_STSr BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr
#define AN_X4_AN_PAGE_SEQUENCER_STSr_SIZE BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_SIZE
typedef BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_t AN_X4_AN_PAGE_SEQUENCER_STSr_t;
#define AN_X4_AN_PAGE_SEQUENCER_STSr_CLR BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_CLR
#define AN_X4_AN_PAGE_SEQUENCER_STSr_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_SET
#define AN_X4_AN_PAGE_SEQUENCER_STSr_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_GET
#define AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_SGMII_MODEf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_SGMII_MODEf_GET
#define AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_SGMII_MODEf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_SGMII_MODEf_SET
#define AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_HP_MODEf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_HP_MODEf_GET
#define AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_HP_MODEf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_HP_MODEf_SET
#define AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_SGMII_MISMATCHf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_SGMII_MISMATCHf_GET
#define AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_SGMII_MISMATCHf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_SGMII_MISMATCHf_SET
#define AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_BPf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_BPf_GET
#define AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_BPf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_BPf_SET
#define AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NPf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NPf_GET
#define AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NPf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NPf_SET
#define AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_NULLf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_NULLf_GET
#define AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_NULLf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_NULLf_SET
#define AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OUIf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OUIf_GET
#define AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OUIf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OUIf_SET
#define AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OVER1Gf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OVER1Gf_GET
#define AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OVER1Gf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_OVER1Gf_SET
#define AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_MISMATCHf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_MISMATCHf_GET
#define AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_MISMATCHf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_MP_MISMATCHf_SET
#define AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_3f_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_3f_GET
#define AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_3f_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_3f_SET
#define AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MISMATCHf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MISMATCHf_GET
#define AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MISMATCHf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MISMATCHf_SET
#define AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MATCHf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MATCHf_GET
#define AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MATCHf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_UP_OUI_MATCHf_SET
#define AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_INVALID_SEQf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_INVALID_SEQf_GET
#define AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_INVALID_SEQf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_INVALID_SEQf_SET
#define AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NP_TOGGLE_ERRf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NP_TOGGLE_ERRf_GET
#define AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NP_TOGGLE_ERRf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_RX_NP_TOGGLE_ERRf_SET
#define AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_CL37_COMPLETEf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_CL37_COMPLETEf_GET
#define AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_CL37_COMPLETEf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_CL37_COMPLETEf_SET
#define AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_CL73_COMPLETEf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_CL73_COMPLETEf_GET
#define AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_CL73_COMPLETEf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr_AN_ST_CL73_COMPLETEf_SET
#define READ_AN_X4_AN_PAGE_SEQUENCER_STSr BCMI_TSCE16_XGXS_READ_AN_X4_AN_PAGE_SEQUENCER_STSr
#define WRITE_AN_X4_AN_PAGE_SEQUENCER_STSr BCMI_TSCE16_XGXS_WRITE_AN_X4_AN_PAGE_SEQUENCER_STSr
#define MODIFY_AN_X4_AN_PAGE_SEQUENCER_STSr BCMI_TSCE16_XGXS_MODIFY_AN_X4_AN_PAGE_SEQUENCER_STSr
#define READLN_AN_X4_AN_PAGE_SEQUENCER_STSr BCMI_TSCE16_XGXS_READLN_AN_X4_AN_PAGE_SEQUENCER_STSr
#define WRITELN_AN_X4_AN_PAGE_SEQUENCER_STSr BCMI_TSCE16_XGXS_WRITELN_AN_X4_AN_PAGE_SEQUENCER_STSr
#define WRITEALL_AN_X4_AN_PAGE_SEQUENCER_STSr BCMI_TSCE16_XGXS_WRITEALL_AN_X4_AN_PAGE_SEQUENCER_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_SEQUENCER_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X4_AN_PAGE_EXCHANGEER_STS
 * BLOCKS:   AN_X4_SW_MANAGEMENT
 * REGADDR:  0xc1a9
 * DESC:     AN PAGE EXCHANGER STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AN_ST_CONFIG_RESTART Received auto-neg restart (0) page
 *     AN_ST_IDLE_DETECT Entered auto-neg IDLE_DETECT stateClear on read
 *     AN_ST_DISABLE_LINK Entered auto-neg DISABLE_LINK stateClear on read
 *     AN_ST_ERROR_STATE Entered auto-neg ERROR stateClear on read
 *     AN_ST_AN_ENABLE  Entered auto-neg AN_ENABLE stateClear on read
 *     AN_ST_ABILITY_DETECT Entered auto-neg ABILITY_DETECT stateClear on read
 *     AN_ST_ACK_DETECT Entered auto-neg ACKNOWLEDGE_DETECT stateClear on read
 *     AN_ST_COMPLETE_ACK Entered auto-neg COMPLETE_ACKNOWLEDGE stateClear on read
 *     AN_ST_CONSISTENCY_MISMATCH Auto-neg consistency mismatch detectedClear on read
 *     AN_ST_CONFIG_NONZERO Page Exchanger Received non-zero configuration ordered setClear on read
 *     AN_ST_RESTART    Page Exchanger entered AN_RESTART stateClear on read
 *     AN_ST_AN_GOOD_CHECK Page Exchanger entered AN_GOOD_CHECK stateClear on read
 *     AN_ST_LINK_OK    Page Exchanger entered LINK_OK stateClear on read
 *     AN_ST_NEXT_PAGE_WAIT Page Exchanger entered NEXT_PAGE_WAIT stateClear on read
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr (0x0000c1a9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_AN_PAGE_EXCHANGEER_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_an_page_exchangeer_sts[1];
	uint32_t _an_x4_an_page_exchangeer_sts;
} BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_t;

#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_CLR(r) (r).an_x4_an_page_exchangeer_sts[0] = 0
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_SET(r,d) (r).an_x4_an_page_exchangeer_sts[0] = d
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_GET(r) (r).an_x4_an_page_exchangeer_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_NEXT_PAGE_WAITf_GET(r) ((((r).an_x4_an_page_exchangeer_sts[0]) >> 13) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_NEXT_PAGE_WAITf_SET(r,f) (r).an_x4_an_page_exchangeer_sts[0]=(((r).an_x4_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_LINK_OKf_GET(r) ((((r).an_x4_an_page_exchangeer_sts[0]) >> 12) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_LINK_OKf_SET(r,f) (r).an_x4_an_page_exchangeer_sts[0]=(((r).an_x4_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_GOOD_CHECKf_GET(r) ((((r).an_x4_an_page_exchangeer_sts[0]) >> 11) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_GOOD_CHECKf_SET(r,f) (r).an_x4_an_page_exchangeer_sts[0]=(((r).an_x4_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_RESTARTf_GET(r) ((((r).an_x4_an_page_exchangeer_sts[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_RESTARTf_SET(r,f) (r).an_x4_an_page_exchangeer_sts[0]=(((r).an_x4_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_NONZEROf_GET(r) ((((r).an_x4_an_page_exchangeer_sts[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_NONZEROf_SET(r,f) (r).an_x4_an_page_exchangeer_sts[0]=(((r).an_x4_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONSISTENCY_MISMATCHf_GET(r) ((((r).an_x4_an_page_exchangeer_sts[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONSISTENCY_MISMATCHf_SET(r,f) (r).an_x4_an_page_exchangeer_sts[0]=(((r).an_x4_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_COMPLETE_ACKf_GET(r) ((((r).an_x4_an_page_exchangeer_sts[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_COMPLETE_ACKf_SET(r,f) (r).an_x4_an_page_exchangeer_sts[0]=(((r).an_x4_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_ACK_DETECTf_GET(r) ((((r).an_x4_an_page_exchangeer_sts[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_ACK_DETECTf_SET(r,f) (r).an_x4_an_page_exchangeer_sts[0]=(((r).an_x4_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_ABILITY_DETECTf_GET(r) ((((r).an_x4_an_page_exchangeer_sts[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_ABILITY_DETECTf_SET(r,f) (r).an_x4_an_page_exchangeer_sts[0]=(((r).an_x4_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_ENABLEf_GET(r) ((((r).an_x4_an_page_exchangeer_sts[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_ENABLEf_SET(r,f) (r).an_x4_an_page_exchangeer_sts[0]=(((r).an_x4_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_ERROR_STATEf_GET(r) ((((r).an_x4_an_page_exchangeer_sts[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_ERROR_STATEf_SET(r,f) (r).an_x4_an_page_exchangeer_sts[0]=(((r).an_x4_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_DISABLE_LINKf_GET(r) ((((r).an_x4_an_page_exchangeer_sts[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_DISABLE_LINKf_SET(r,f) (r).an_x4_an_page_exchangeer_sts[0]=(((r).an_x4_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_IDLE_DETECTf_GET(r) ((((r).an_x4_an_page_exchangeer_sts[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_IDLE_DETECTf_SET(r,f) (r).an_x4_an_page_exchangeer_sts[0]=(((r).an_x4_an_page_exchangeer_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_RESTARTf_GET(r) (((r).an_x4_an_page_exchangeer_sts[0]) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_RESTARTf_SET(r,f) (r).an_x4_an_page_exchangeer_sts[0]=(((r).an_x4_an_page_exchangeer_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_AN_PAGE_EXCHANGEER_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X4_AN_PAGE_EXCHANGEER_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr,(_r._an_x4_an_page_exchangeer_sts))
#define BCMI_TSCE16_XGXS_WRITE_AN_X4_AN_PAGE_EXCHANGEER_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr,(_r._an_x4_an_page_exchangeer_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X4_AN_PAGE_EXCHANGEER_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr,(_r._an_x4_an_page_exchangeer_sts))
#define BCMI_TSCE16_XGXS_READLN_AN_X4_AN_PAGE_EXCHANGEER_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_an_page_exchangeer_sts))
#define BCMI_TSCE16_XGXS_WRITELN_AN_X4_AN_PAGE_EXCHANGEER_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_an_page_exchangeer_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_AN_X4_AN_PAGE_EXCHANGEER_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_an_page_exchangeer_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_AN_PAGE_EXCHANGEER_STSr BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr
#define AN_X4_AN_PAGE_EXCHANGEER_STSr_SIZE BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_SIZE
typedef BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_t AN_X4_AN_PAGE_EXCHANGEER_STSr_t;
#define AN_X4_AN_PAGE_EXCHANGEER_STSr_CLR BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_CLR
#define AN_X4_AN_PAGE_EXCHANGEER_STSr_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_SET
#define AN_X4_AN_PAGE_EXCHANGEER_STSr_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_GET
#define AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_NEXT_PAGE_WAITf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_NEXT_PAGE_WAITf_GET
#define AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_NEXT_PAGE_WAITf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_NEXT_PAGE_WAITf_SET
#define AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_LINK_OKf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_LINK_OKf_GET
#define AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_LINK_OKf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_LINK_OKf_SET
#define AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_GOOD_CHECKf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_GOOD_CHECKf_GET
#define AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_GOOD_CHECKf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_GOOD_CHECKf_SET
#define AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_RESTARTf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_RESTARTf_GET
#define AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_RESTARTf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_RESTARTf_SET
#define AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_NONZEROf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_NONZEROf_GET
#define AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_NONZEROf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_NONZEROf_SET
#define AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONSISTENCY_MISMATCHf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONSISTENCY_MISMATCHf_GET
#define AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONSISTENCY_MISMATCHf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONSISTENCY_MISMATCHf_SET
#define AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_COMPLETE_ACKf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_COMPLETE_ACKf_GET
#define AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_COMPLETE_ACKf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_COMPLETE_ACKf_SET
#define AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_ACK_DETECTf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_ACK_DETECTf_GET
#define AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_ACK_DETECTf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_ACK_DETECTf_SET
#define AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_ABILITY_DETECTf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_ABILITY_DETECTf_GET
#define AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_ABILITY_DETECTf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_ABILITY_DETECTf_SET
#define AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_ENABLEf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_ENABLEf_GET
#define AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_ENABLEf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_AN_ENABLEf_SET
#define AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_ERROR_STATEf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_ERROR_STATEf_GET
#define AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_ERROR_STATEf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_ERROR_STATEf_SET
#define AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_DISABLE_LINKf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_DISABLE_LINKf_GET
#define AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_DISABLE_LINKf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_DISABLE_LINKf_SET
#define AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_IDLE_DETECTf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_IDLE_DETECTf_GET
#define AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_IDLE_DETECTf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_IDLE_DETECTf_SET
#define AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_RESTARTf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_RESTARTf_GET
#define AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_RESTARTf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr_AN_ST_CONFIG_RESTARTf_SET
#define READ_AN_X4_AN_PAGE_EXCHANGEER_STSr BCMI_TSCE16_XGXS_READ_AN_X4_AN_PAGE_EXCHANGEER_STSr
#define WRITE_AN_X4_AN_PAGE_EXCHANGEER_STSr BCMI_TSCE16_XGXS_WRITE_AN_X4_AN_PAGE_EXCHANGEER_STSr
#define MODIFY_AN_X4_AN_PAGE_EXCHANGEER_STSr BCMI_TSCE16_XGXS_MODIFY_AN_X4_AN_PAGE_EXCHANGEER_STSr
#define READLN_AN_X4_AN_PAGE_EXCHANGEER_STSr BCMI_TSCE16_XGXS_READLN_AN_X4_AN_PAGE_EXCHANGEER_STSr
#define WRITELN_AN_X4_AN_PAGE_EXCHANGEER_STSr BCMI_TSCE16_XGXS_WRITELN_AN_X4_AN_PAGE_EXCHANGEER_STSr
#define WRITEALL_AN_X4_AN_PAGE_EXCHANGEER_STSr BCMI_TSCE16_XGXS_WRITEALL_AN_X4_AN_PAGE_EXCHANGEER_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_EXCHANGEER_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X4_AN_PAGE_DECR_STS
 * BLOCKS:   AN_X4_SW_MANAGEMENT
 * REGADDR:  0xc1aa
 * DESC:     AN PAGE DECODER STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AN_RX_ST_STATE   DME Receive State
 *     AN_RX_ST_RUDI_INVALID Received invalid ordered setClear on read
 *     AN_RX_ST_RUDI_CONFIG Received configuration ordered setClear on read
 *     AN_RX_ST_RUDI_IDLE Received idle ordered setClear on read
 *     AN_RX_ST_PAGE    Valid DME page receivedClear on read
 *     AN_RX_ST_MV_PAIR DME Delimiter detectedClear on read
 *     AN_RX_ST_CLK_TRANS_MISS Missing DME clock transition detectedClear on read
 *     AN_RX_ST_PAGE_TOO_LONG A CL73 DME page longer than the maximum specified by cl73_page_test_max_timer was detectedClear on read
 *     AN_RX_ST_PAGE_TOO_SHORT A CL73 DME page shorter than the  minimum specified by cl73_page_test_min_timer was detectedClear on read
 *     AN_RX_ST_PULSE_TOO_LONG Too long DME pulse detectedDuration - minimum 35 samples. Each sample 0.4nsClear on read
 *     AN_RX_ST_PULSE_TOO_SHORT Too short DME pulse detectedDuration - 2 to 4 samples. Each sample 0.4nsClear on read
 *     AN_RX_ST_PULSE_TOO_MODERATE Too moderate DME pulse detectedDuration - 19 to 29 samples. Each sample 0.4nsClear on read
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr (0x0000c1aa | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_AN_PAGE_DECR_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_an_page_decr_sts[1];
	uint32_t _an_x4_an_page_decr_sts;
} BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_t;

#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_CLR(r) (r).an_x4_an_page_decr_sts[0] = 0
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_SET(r,d) (r).an_x4_an_page_decr_sts[0] = d
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_GET(r) (r).an_x4_an_page_decr_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_MODERATEf_GET(r) ((((r).an_x4_an_page_decr_sts[0]) >> 12) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_MODERATEf_SET(r,f) (r).an_x4_an_page_decr_sts[0]=(((r).an_x4_an_page_decr_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_SHORTf_GET(r) ((((r).an_x4_an_page_decr_sts[0]) >> 11) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_SHORTf_SET(r,f) (r).an_x4_an_page_decr_sts[0]=(((r).an_x4_an_page_decr_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_LONGf_GET(r) ((((r).an_x4_an_page_decr_sts[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_LONGf_SET(r,f) (r).an_x4_an_page_decr_sts[0]=(((r).an_x4_an_page_decr_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_SHORTf_GET(r) ((((r).an_x4_an_page_decr_sts[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_SHORTf_SET(r,f) (r).an_x4_an_page_decr_sts[0]=(((r).an_x4_an_page_decr_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_LONGf_GET(r) ((((r).an_x4_an_page_decr_sts[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_LONGf_SET(r,f) (r).an_x4_an_page_decr_sts[0]=(((r).an_x4_an_page_decr_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_CLK_TRANS_MISSf_GET(r) ((((r).an_x4_an_page_decr_sts[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_CLK_TRANS_MISSf_SET(r,f) (r).an_x4_an_page_decr_sts[0]=(((r).an_x4_an_page_decr_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_MV_PAIRf_GET(r) ((((r).an_x4_an_page_decr_sts[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_MV_PAIRf_SET(r,f) (r).an_x4_an_page_decr_sts[0]=(((r).an_x4_an_page_decr_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PAGEf_GET(r) ((((r).an_x4_an_page_decr_sts[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PAGEf_SET(r,f) (r).an_x4_an_page_decr_sts[0]=(((r).an_x4_an_page_decr_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_IDLEf_GET(r) ((((r).an_x4_an_page_decr_sts[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_IDLEf_SET(r,f) (r).an_x4_an_page_decr_sts[0]=(((r).an_x4_an_page_decr_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_CONFIGf_GET(r) ((((r).an_x4_an_page_decr_sts[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_CONFIGf_SET(r,f) (r).an_x4_an_page_decr_sts[0]=(((r).an_x4_an_page_decr_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_INVALIDf_GET(r) ((((r).an_x4_an_page_decr_sts[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_INVALIDf_SET(r,f) (r).an_x4_an_page_decr_sts[0]=(((r).an_x4_an_page_decr_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_STATEf_GET(r) (((r).an_x4_an_page_decr_sts[0]) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_STATEf_SET(r,f) (r).an_x4_an_page_decr_sts[0]=(((r).an_x4_an_page_decr_sts[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access AN_X4_AN_PAGE_DECR_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X4_AN_PAGE_DECR_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr,(_r._an_x4_an_page_decr_sts))
#define BCMI_TSCE16_XGXS_WRITE_AN_X4_AN_PAGE_DECR_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr,(_r._an_x4_an_page_decr_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X4_AN_PAGE_DECR_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr,(_r._an_x4_an_page_decr_sts))
#define BCMI_TSCE16_XGXS_READLN_AN_X4_AN_PAGE_DECR_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_an_page_decr_sts))
#define BCMI_TSCE16_XGXS_WRITELN_AN_X4_AN_PAGE_DECR_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_an_page_decr_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_AN_X4_AN_PAGE_DECR_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_an_page_decr_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_AN_PAGE_DECR_STSr BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr
#define AN_X4_AN_PAGE_DECR_STSr_SIZE BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_SIZE
typedef BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_t AN_X4_AN_PAGE_DECR_STSr_t;
#define AN_X4_AN_PAGE_DECR_STSr_CLR BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_CLR
#define AN_X4_AN_PAGE_DECR_STSr_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_SET
#define AN_X4_AN_PAGE_DECR_STSr_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_GET
#define AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_MODERATEf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_MODERATEf_GET
#define AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_MODERATEf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_MODERATEf_SET
#define AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_SHORTf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_SHORTf_GET
#define AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_SHORTf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_SHORTf_SET
#define AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_LONGf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_LONGf_GET
#define AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_LONGf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PULSE_TOO_LONGf_SET
#define AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_SHORTf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_SHORTf_GET
#define AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_SHORTf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_SHORTf_SET
#define AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_LONGf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_LONGf_GET
#define AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_LONGf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PAGE_TOO_LONGf_SET
#define AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_CLK_TRANS_MISSf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_CLK_TRANS_MISSf_GET
#define AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_CLK_TRANS_MISSf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_CLK_TRANS_MISSf_SET
#define AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_MV_PAIRf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_MV_PAIRf_GET
#define AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_MV_PAIRf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_MV_PAIRf_SET
#define AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PAGEf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PAGEf_GET
#define AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PAGEf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_PAGEf_SET
#define AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_IDLEf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_IDLEf_GET
#define AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_IDLEf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_IDLEf_SET
#define AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_CONFIGf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_CONFIGf_GET
#define AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_CONFIGf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_CONFIGf_SET
#define AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_INVALIDf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_INVALIDf_GET
#define AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_INVALIDf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_RUDI_INVALIDf_SET
#define AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_STATEf_GET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_STATEf_GET
#define AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_STATEf_SET BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr_AN_RX_ST_STATEf_SET
#define READ_AN_X4_AN_PAGE_DECR_STSr BCMI_TSCE16_XGXS_READ_AN_X4_AN_PAGE_DECR_STSr
#define WRITE_AN_X4_AN_PAGE_DECR_STSr BCMI_TSCE16_XGXS_WRITE_AN_X4_AN_PAGE_DECR_STSr
#define MODIFY_AN_X4_AN_PAGE_DECR_STSr BCMI_TSCE16_XGXS_MODIFY_AN_X4_AN_PAGE_DECR_STSr
#define READLN_AN_X4_AN_PAGE_DECR_STSr BCMI_TSCE16_XGXS_READLN_AN_X4_AN_PAGE_DECR_STSr
#define WRITELN_AN_X4_AN_PAGE_DECR_STSr BCMI_TSCE16_XGXS_WRITELN_AN_X4_AN_PAGE_DECR_STSr
#define WRITEALL_AN_X4_AN_PAGE_DECR_STSr BCMI_TSCE16_XGXS_WRITEALL_AN_X4_AN_PAGE_DECR_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X4_AN_PAGE_DECR_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X4_AN_ABIL_RESOLUTION_STS
 * BLOCKS:   AN_X4_SW_MANAGEMENT
 * REGADDR:  0xc1ab
 * DESC:     AN ABILITY RESOLUTION INFORMATION
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     AN_HCD_SWITCH_TO_CL37 HCD an_hcd_switch_to_cl37
 *     AN_HCD_HIGIG2    HCD Hi-Gig II ability
 *     AN_HCD_CL72      HCD training ability
 *     AN_HCD_FEC       HCD forward-error correction ability
 *     AN_HCD_SPEED     HCD speed
 *     AN_HCD_PAUSE     HCD Pause Ability[11:10]00 - None01 - TX (from LD to LP)10 - RX (from LP to LD)11 - TX/RX (symmetrical)
 *     AN_HCD_DUPLEX    HCD full-duplex ability
 *     AN_ST_RESOLUTION_ERR No common speed
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr (0x0000c1ab | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_AN_ABIL_RESOLUTION_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_an_abil_resolution_sts[1];
	uint32_t _an_x4_an_abil_resolution_sts;
} BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_t;

#define BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_CLR(r) (r).an_x4_an_abil_resolution_sts[0] = 0
#define BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_SET(r,d) (r).an_x4_an_abil_resolution_sts[0] = d
#define BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_GET(r) (r).an_x4_an_abil_resolution_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_ST_RESOLUTION_ERRf_GET(r) ((((r).an_x4_an_abil_resolution_sts[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_ST_RESOLUTION_ERRf_SET(r,f) (r).an_x4_an_abil_resolution_sts[0]=(((r).an_x4_an_abil_resolution_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_GET(r) ((((r).an_x4_an_abil_resolution_sts[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_SET(r,f) (r).an_x4_an_abil_resolution_sts[0]=(((r).an_x4_an_abil_resolution_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_GET(r) ((((r).an_x4_an_abil_resolution_sts[0]) >> 12) & 0x3)
#define BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_SET(r,f) (r).an_x4_an_abil_resolution_sts[0]=(((r).an_x4_an_abil_resolution_sts[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_GET(r) ((((r).an_x4_an_abil_resolution_sts[0]) >> 4) & 0xff)
#define BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_SET(r,f) (r).an_x4_an_abil_resolution_sts[0]=(((r).an_x4_an_abil_resolution_sts[0] & ~((uint32_t)0xff << 4)) | ((((uint32_t)f) & 0xff) << 4)) | (255 << (16 + 4))
#define BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_GET(r) ((((r).an_x4_an_abil_resolution_sts[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_SET(r,f) (r).an_x4_an_abil_resolution_sts[0]=(((r).an_x4_an_abil_resolution_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_GET(r) ((((r).an_x4_an_abil_resolution_sts[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_SET(r,f) (r).an_x4_an_abil_resolution_sts[0]=(((r).an_x4_an_abil_resolution_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_HIGIG2f_GET(r) ((((r).an_x4_an_abil_resolution_sts[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_HIGIG2f_SET(r,f) (r).an_x4_an_abil_resolution_sts[0]=(((r).an_x4_an_abil_resolution_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_SWITCH_TO_CL37f_GET(r) (((r).an_x4_an_abil_resolution_sts[0]) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_SWITCH_TO_CL37f_SET(r,f) (r).an_x4_an_abil_resolution_sts[0]=(((r).an_x4_an_abil_resolution_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_AN_ABIL_RESOLUTION_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X4_AN_ABIL_RESOLUTION_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr,(_r._an_x4_an_abil_resolution_sts))
#define BCMI_TSCE16_XGXS_WRITE_AN_X4_AN_ABIL_RESOLUTION_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr,(_r._an_x4_an_abil_resolution_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X4_AN_ABIL_RESOLUTION_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr,(_r._an_x4_an_abil_resolution_sts))
#define BCMI_TSCE16_XGXS_READLN_AN_X4_AN_ABIL_RESOLUTION_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_an_abil_resolution_sts))
#define BCMI_TSCE16_XGXS_WRITELN_AN_X4_AN_ABIL_RESOLUTION_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_an_abil_resolution_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_AN_X4_AN_ABIL_RESOLUTION_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_an_abil_resolution_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_AN_ABIL_RESOLUTION_STSr BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr
#define AN_X4_AN_ABIL_RESOLUTION_STSr_SIZE BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_SIZE
typedef BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_t AN_X4_AN_ABIL_RESOLUTION_STSr_t;
#define AN_X4_AN_ABIL_RESOLUTION_STSr_CLR BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_CLR
#define AN_X4_AN_ABIL_RESOLUTION_STSr_SET BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_SET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_GET BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_GET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_ST_RESOLUTION_ERRf_GET BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_ST_RESOLUTION_ERRf_GET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_ST_RESOLUTION_ERRf_SET BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_ST_RESOLUTION_ERRf_SET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_GET BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_GET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_SET BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_SET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_GET BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_GET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_SET BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_SET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_GET BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_GET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_SET BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_SET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_GET BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_GET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_SET BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_SET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_GET BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_GET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_SET BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_SET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_HIGIG2f_GET BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_HIGIG2f_GET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_HIGIG2f_SET BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_HIGIG2f_SET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_SWITCH_TO_CL37f_GET BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_SWITCH_TO_CL37f_GET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_SWITCH_TO_CL37f_SET BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_SWITCH_TO_CL37f_SET
#define READ_AN_X4_AN_ABIL_RESOLUTION_STSr BCMI_TSCE16_XGXS_READ_AN_X4_AN_ABIL_RESOLUTION_STSr
#define WRITE_AN_X4_AN_ABIL_RESOLUTION_STSr BCMI_TSCE16_XGXS_WRITE_AN_X4_AN_ABIL_RESOLUTION_STSr
#define MODIFY_AN_X4_AN_ABIL_RESOLUTION_STSr BCMI_TSCE16_XGXS_MODIFY_AN_X4_AN_ABIL_RESOLUTION_STSr
#define READLN_AN_X4_AN_ABIL_RESOLUTION_STSr BCMI_TSCE16_XGXS_READLN_AN_X4_AN_ABIL_RESOLUTION_STSr
#define WRITELN_AN_X4_AN_ABIL_RESOLUTION_STSr BCMI_TSCE16_XGXS_WRITELN_AN_X4_AN_ABIL_RESOLUTION_STSr
#define WRITEALL_AN_X4_AN_ABIL_RESOLUTION_STSr BCMI_TSCE16_XGXS_WRITEALL_AN_X4_AN_ABIL_RESOLUTION_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X4_AN_MISC_STS
 * BLOCKS:   AN_X4_SW_MANAGEMENT
 * REGADDR:  0xc1ac
 * DESC:     MISCILLANEOUS AN STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PD_HCD_KX4_OR_KX Speed status for PD attempt0: KX4, 1: KX
 *     PD_IN_PROGRESS   Currently Parallel detect is active
 *     AN_FAIL_COUNT    Number of AN retries due to AN failureSaturate, Clear on Read
 *     AN_ACTIVE        Auto-neg in progress
 *     PD_COMPLETED     Parallel detect process is
 *     REMOTE_FAULT_IN_BASE_PAGE Remote fault indicated in AN base page
 *     AN_RETRY_COUNT   Number of AN retried for any reasonSaturate, Clear on Read
 *     AN_COMPLETE      
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr (0x0000c1ac | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_AN_MISC_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_an_misc_sts[1];
	uint32_t _an_x4_an_misc_sts;
} BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_t;

#define BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_CLR(r) (r).an_x4_an_misc_sts[0] = 0
#define BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_SET(r,d) (r).an_x4_an_misc_sts[0] = d
#define BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_GET(r) (r).an_x4_an_misc_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_AN_COMPLETEf_GET(r) ((((r).an_x4_an_misc_sts[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_AN_COMPLETEf_SET(r,f) (r).an_x4_an_misc_sts[0]=(((r).an_x4_an_misc_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_AN_RETRY_COUNTf_GET(r) ((((r).an_x4_an_misc_sts[0]) >> 9) & 0x3f)
#define BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_AN_RETRY_COUNTf_SET(r,f) (r).an_x4_an_misc_sts[0]=(((r).an_x4_an_misc_sts[0] & ~((uint32_t)0x3f << 9)) | ((((uint32_t)f) & 0x3f) << 9)) | (63 << (16 + 9))
#define BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_REMOTE_FAULT_IN_BASE_PAGEf_GET(r) ((((r).an_x4_an_misc_sts[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_REMOTE_FAULT_IN_BASE_PAGEf_SET(r,f) (r).an_x4_an_misc_sts[0]=(((r).an_x4_an_misc_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_PD_COMPLETEDf_GET(r) ((((r).an_x4_an_misc_sts[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_PD_COMPLETEDf_SET(r,f) (r).an_x4_an_misc_sts[0]=(((r).an_x4_an_misc_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_AN_ACTIVEf_GET(r) ((((r).an_x4_an_misc_sts[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_AN_ACTIVEf_SET(r,f) (r).an_x4_an_misc_sts[0]=(((r).an_x4_an_misc_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_AN_FAIL_COUNTf_GET(r) ((((r).an_x4_an_misc_sts[0]) >> 2) & 0xf)
#define BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_AN_FAIL_COUNTf_SET(r,f) (r).an_x4_an_misc_sts[0]=(((r).an_x4_an_misc_sts[0] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2)) | (15 << (16 + 2))
#define BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_PD_IN_PROGRESSf_GET(r) ((((r).an_x4_an_misc_sts[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_PD_IN_PROGRESSf_SET(r,f) (r).an_x4_an_misc_sts[0]=(((r).an_x4_an_misc_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_PD_HCD_KX4_OR_KXf_GET(r) (((r).an_x4_an_misc_sts[0]) & 0x1)
#define BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_PD_HCD_KX4_OR_KXf_SET(r,f) (r).an_x4_an_misc_sts[0]=(((r).an_x4_an_misc_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_AN_MISC_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X4_AN_MISC_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr,(_r._an_x4_an_misc_sts))
#define BCMI_TSCE16_XGXS_WRITE_AN_X4_AN_MISC_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr,(_r._an_x4_an_misc_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X4_AN_MISC_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr,(_r._an_x4_an_misc_sts))
#define BCMI_TSCE16_XGXS_READLN_AN_X4_AN_MISC_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_an_misc_sts))
#define BCMI_TSCE16_XGXS_WRITELN_AN_X4_AN_MISC_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_an_misc_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_AN_X4_AN_MISC_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_an_misc_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_AN_MISC_STSr BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr
#define AN_X4_AN_MISC_STSr_SIZE BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_SIZE
typedef BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_t AN_X4_AN_MISC_STSr_t;
#define AN_X4_AN_MISC_STSr_CLR BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_CLR
#define AN_X4_AN_MISC_STSr_SET BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_SET
#define AN_X4_AN_MISC_STSr_GET BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_GET
#define AN_X4_AN_MISC_STSr_AN_COMPLETEf_GET BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_AN_COMPLETEf_GET
#define AN_X4_AN_MISC_STSr_AN_COMPLETEf_SET BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_AN_COMPLETEf_SET
#define AN_X4_AN_MISC_STSr_AN_RETRY_COUNTf_GET BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_AN_RETRY_COUNTf_GET
#define AN_X4_AN_MISC_STSr_AN_RETRY_COUNTf_SET BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_AN_RETRY_COUNTf_SET
#define AN_X4_AN_MISC_STSr_REMOTE_FAULT_IN_BASE_PAGEf_GET BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_REMOTE_FAULT_IN_BASE_PAGEf_GET
#define AN_X4_AN_MISC_STSr_REMOTE_FAULT_IN_BASE_PAGEf_SET BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_REMOTE_FAULT_IN_BASE_PAGEf_SET
#define AN_X4_AN_MISC_STSr_PD_COMPLETEDf_GET BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_PD_COMPLETEDf_GET
#define AN_X4_AN_MISC_STSr_PD_COMPLETEDf_SET BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_PD_COMPLETEDf_SET
#define AN_X4_AN_MISC_STSr_AN_ACTIVEf_GET BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_AN_ACTIVEf_GET
#define AN_X4_AN_MISC_STSr_AN_ACTIVEf_SET BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_AN_ACTIVEf_SET
#define AN_X4_AN_MISC_STSr_AN_FAIL_COUNTf_GET BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_AN_FAIL_COUNTf_GET
#define AN_X4_AN_MISC_STSr_AN_FAIL_COUNTf_SET BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_AN_FAIL_COUNTf_SET
#define AN_X4_AN_MISC_STSr_PD_IN_PROGRESSf_GET BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_PD_IN_PROGRESSf_GET
#define AN_X4_AN_MISC_STSr_PD_IN_PROGRESSf_SET BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_PD_IN_PROGRESSf_SET
#define AN_X4_AN_MISC_STSr_PD_HCD_KX4_OR_KXf_GET BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_PD_HCD_KX4_OR_KXf_GET
#define AN_X4_AN_MISC_STSr_PD_HCD_KX4_OR_KXf_SET BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr_PD_HCD_KX4_OR_KXf_SET
#define READ_AN_X4_AN_MISC_STSr BCMI_TSCE16_XGXS_READ_AN_X4_AN_MISC_STSr
#define WRITE_AN_X4_AN_MISC_STSr BCMI_TSCE16_XGXS_WRITE_AN_X4_AN_MISC_STSr
#define MODIFY_AN_X4_AN_MISC_STSr BCMI_TSCE16_XGXS_MODIFY_AN_X4_AN_MISC_STSr
#define READLN_AN_X4_AN_MISC_STSr BCMI_TSCE16_XGXS_READLN_AN_X4_AN_MISC_STSr
#define WRITELN_AN_X4_AN_MISC_STSr BCMI_TSCE16_XGXS_WRITELN_AN_X4_AN_MISC_STSr
#define WRITEALL_AN_X4_AN_MISC_STSr BCMI_TSCE16_XGXS_WRITEALL_AN_X4_AN_MISC_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X4_AN_MISC_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X4_TLA_SEQUENCER_STS
 * BLOCKS:   AN_X4_SW_MANAGEMENT
 * REGADDR:  0xc1ad
 * DESC:     TLA SEQUENCER STATUS
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     TLA_LN_SEQUENCER_FSM_STATUS TLA Lane sequencer fsm latched statusClear on read
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X4_TLA_SEQUENCER_STSr (0x0000c1ad | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X4_TLA_SEQUENCER_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_TLA_SEQUENCER_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X4_TLA_SEQUENCER_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_tla_sequencer_sts[1];
	uint32_t _an_x4_tla_sequencer_sts;
} BCMI_TSCE16_XGXS_AN_X4_TLA_SEQUENCER_STSr_t;

#define BCMI_TSCE16_XGXS_AN_X4_TLA_SEQUENCER_STSr_CLR(r) (r).an_x4_tla_sequencer_sts[0] = 0
#define BCMI_TSCE16_XGXS_AN_X4_TLA_SEQUENCER_STSr_SET(r,d) (r).an_x4_tla_sequencer_sts[0] = d
#define BCMI_TSCE16_XGXS_AN_X4_TLA_SEQUENCER_STSr_GET(r) (r).an_x4_tla_sequencer_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X4_TLA_SEQUENCER_STSr_TLA_LN_SEQUENCER_FSM_STATUSf_GET(r) (((r).an_x4_tla_sequencer_sts[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_AN_X4_TLA_SEQUENCER_STSr_TLA_LN_SEQUENCER_FSM_STATUSf_SET(r,f) (r).an_x4_tla_sequencer_sts[0]=(((r).an_x4_tla_sequencer_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_TLA_SEQUENCER_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X4_TLA_SEQUENCER_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_TLA_SEQUENCER_STSr,(_r._an_x4_tla_sequencer_sts))
#define BCMI_TSCE16_XGXS_WRITE_AN_X4_TLA_SEQUENCER_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_TLA_SEQUENCER_STSr,(_r._an_x4_tla_sequencer_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X4_TLA_SEQUENCER_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_TLA_SEQUENCER_STSr,(_r._an_x4_tla_sequencer_sts))
#define BCMI_TSCE16_XGXS_READLN_AN_X4_TLA_SEQUENCER_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_TLA_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_tla_sequencer_sts))
#define BCMI_TSCE16_XGXS_WRITELN_AN_X4_TLA_SEQUENCER_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_TLA_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_tla_sequencer_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_AN_X4_TLA_SEQUENCER_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_TLA_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_tla_sequencer_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_TLA_SEQUENCER_STSr BCMI_TSCE16_XGXS_AN_X4_TLA_SEQUENCER_STSr
#define AN_X4_TLA_SEQUENCER_STSr_SIZE BCMI_TSCE16_XGXS_AN_X4_TLA_SEQUENCER_STSr_SIZE
typedef BCMI_TSCE16_XGXS_AN_X4_TLA_SEQUENCER_STSr_t AN_X4_TLA_SEQUENCER_STSr_t;
#define AN_X4_TLA_SEQUENCER_STSr_CLR BCMI_TSCE16_XGXS_AN_X4_TLA_SEQUENCER_STSr_CLR
#define AN_X4_TLA_SEQUENCER_STSr_SET BCMI_TSCE16_XGXS_AN_X4_TLA_SEQUENCER_STSr_SET
#define AN_X4_TLA_SEQUENCER_STSr_GET BCMI_TSCE16_XGXS_AN_X4_TLA_SEQUENCER_STSr_GET
#define AN_X4_TLA_SEQUENCER_STSr_TLA_LN_SEQUENCER_FSM_STATUSf_GET BCMI_TSCE16_XGXS_AN_X4_TLA_SEQUENCER_STSr_TLA_LN_SEQUENCER_FSM_STATUSf_GET
#define AN_X4_TLA_SEQUENCER_STSr_TLA_LN_SEQUENCER_FSM_STATUSf_SET BCMI_TSCE16_XGXS_AN_X4_TLA_SEQUENCER_STSr_TLA_LN_SEQUENCER_FSM_STATUSf_SET
#define READ_AN_X4_TLA_SEQUENCER_STSr BCMI_TSCE16_XGXS_READ_AN_X4_TLA_SEQUENCER_STSr
#define WRITE_AN_X4_TLA_SEQUENCER_STSr BCMI_TSCE16_XGXS_WRITE_AN_X4_TLA_SEQUENCER_STSr
#define MODIFY_AN_X4_TLA_SEQUENCER_STSr BCMI_TSCE16_XGXS_MODIFY_AN_X4_TLA_SEQUENCER_STSr
#define READLN_AN_X4_TLA_SEQUENCER_STSr BCMI_TSCE16_XGXS_READLN_AN_X4_TLA_SEQUENCER_STSr
#define WRITELN_AN_X4_TLA_SEQUENCER_STSr BCMI_TSCE16_XGXS_WRITELN_AN_X4_TLA_SEQUENCER_STSr
#define WRITEALL_AN_X4_TLA_SEQUENCER_STSr BCMI_TSCE16_XGXS_WRITEALL_AN_X4_TLA_SEQUENCER_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X4_TLA_SEQUENCER_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  AN_X4_AN_SEQ_UNEXPECTED_PAGE
 * BLOCKS:   AN_X4_SW_MANAGEMENT
 * REGADDR:  0xc1ae
 * DESC:     AN SEQUENCER UNEXPECTED PAGE
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     SEQ_UNEXPECTED_PAGE First unexpected page received
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_AN_X4_AN_SEQ_UNEXPECTED_PAGEr (0x0000c1ae | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_AN_X4_AN_SEQ_UNEXPECTED_PAGEr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_AN_SEQ_UNEXPECTED_PAGE.
 *
 */
typedef union BCMI_TSCE16_XGXS_AN_X4_AN_SEQ_UNEXPECTED_PAGEr_s {
	uint32_t v[1];
	uint32_t an_x4_an_seq_unexpected_page[1];
	uint32_t _an_x4_an_seq_unexpected_page;
} BCMI_TSCE16_XGXS_AN_X4_AN_SEQ_UNEXPECTED_PAGEr_t;

#define BCMI_TSCE16_XGXS_AN_X4_AN_SEQ_UNEXPECTED_PAGEr_CLR(r) (r).an_x4_an_seq_unexpected_page[0] = 0
#define BCMI_TSCE16_XGXS_AN_X4_AN_SEQ_UNEXPECTED_PAGEr_SET(r,d) (r).an_x4_an_seq_unexpected_page[0] = d
#define BCMI_TSCE16_XGXS_AN_X4_AN_SEQ_UNEXPECTED_PAGEr_GET(r) (r).an_x4_an_seq_unexpected_page[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_AN_X4_AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_GET(r) (((r).an_x4_an_seq_unexpected_page[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_AN_X4_AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_SET(r,f) (r).an_x4_an_seq_unexpected_page[0]=(((r).an_x4_an_seq_unexpected_page[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_AN_SEQ_UNEXPECTED_PAGE.
 *
 */
#define BCMI_TSCE16_XGXS_READ_AN_X4_AN_SEQ_UNEXPECTED_PAGEr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_SEQ_UNEXPECTED_PAGEr,(_r._an_x4_an_seq_unexpected_page))
#define BCMI_TSCE16_XGXS_WRITE_AN_X4_AN_SEQ_UNEXPECTED_PAGEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_SEQ_UNEXPECTED_PAGEr,(_r._an_x4_an_seq_unexpected_page)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_AN_X4_AN_SEQ_UNEXPECTED_PAGEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_SEQ_UNEXPECTED_PAGEr,(_r._an_x4_an_seq_unexpected_page))
#define BCMI_TSCE16_XGXS_READLN_AN_X4_AN_SEQ_UNEXPECTED_PAGEr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_SEQ_UNEXPECTED_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_an_seq_unexpected_page))
#define BCMI_TSCE16_XGXS_WRITELN_AN_X4_AN_SEQ_UNEXPECTED_PAGEr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_SEQ_UNEXPECTED_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_an_seq_unexpected_page))
#define BCMI_TSCE16_XGXS_WRITEALL_AN_X4_AN_SEQ_UNEXPECTED_PAGEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_AN_X4_AN_SEQ_UNEXPECTED_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_an_seq_unexpected_page))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_AN_SEQ_UNEXPECTED_PAGEr BCMI_TSCE16_XGXS_AN_X4_AN_SEQ_UNEXPECTED_PAGEr
#define AN_X4_AN_SEQ_UNEXPECTED_PAGEr_SIZE BCMI_TSCE16_XGXS_AN_X4_AN_SEQ_UNEXPECTED_PAGEr_SIZE
typedef BCMI_TSCE16_XGXS_AN_X4_AN_SEQ_UNEXPECTED_PAGEr_t AN_X4_AN_SEQ_UNEXPECTED_PAGEr_t;
#define AN_X4_AN_SEQ_UNEXPECTED_PAGEr_CLR BCMI_TSCE16_XGXS_AN_X4_AN_SEQ_UNEXPECTED_PAGEr_CLR
#define AN_X4_AN_SEQ_UNEXPECTED_PAGEr_SET BCMI_TSCE16_XGXS_AN_X4_AN_SEQ_UNEXPECTED_PAGEr_SET
#define AN_X4_AN_SEQ_UNEXPECTED_PAGEr_GET BCMI_TSCE16_XGXS_AN_X4_AN_SEQ_UNEXPECTED_PAGEr_GET
#define AN_X4_AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_GET BCMI_TSCE16_XGXS_AN_X4_AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_GET
#define AN_X4_AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_SET BCMI_TSCE16_XGXS_AN_X4_AN_SEQ_UNEXPECTED_PAGEr_SEQ_UNEXPECTED_PAGEf_SET
#define READ_AN_X4_AN_SEQ_UNEXPECTED_PAGEr BCMI_TSCE16_XGXS_READ_AN_X4_AN_SEQ_UNEXPECTED_PAGEr
#define WRITE_AN_X4_AN_SEQ_UNEXPECTED_PAGEr BCMI_TSCE16_XGXS_WRITE_AN_X4_AN_SEQ_UNEXPECTED_PAGEr
#define MODIFY_AN_X4_AN_SEQ_UNEXPECTED_PAGEr BCMI_TSCE16_XGXS_MODIFY_AN_X4_AN_SEQ_UNEXPECTED_PAGEr
#define READLN_AN_X4_AN_SEQ_UNEXPECTED_PAGEr BCMI_TSCE16_XGXS_READLN_AN_X4_AN_SEQ_UNEXPECTED_PAGEr
#define WRITELN_AN_X4_AN_SEQ_UNEXPECTED_PAGEr BCMI_TSCE16_XGXS_WRITELN_AN_X4_AN_SEQ_UNEXPECTED_PAGEr
#define WRITEALL_AN_X4_AN_SEQ_UNEXPECTED_PAGEr BCMI_TSCE16_XGXS_WRITEALL_AN_X4_AN_SEQ_UNEXPECTED_PAGEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_AN_X4_AN_SEQ_UNEXPECTED_PAGEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  LNK_CTL
 * BLOCKS:   CL72
 * REGADDR:  0xc253
 * DESC:     CL72 Link Control Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LINK_CONTROL_FORCEVAL Override value for auto-neg CL72 training enable.If cl72_link_control_force is set when the auto-neg CL72 training enable is being determined, then the auto-neg CL73 training enable will be forced to the value in this register.If cl72_link_control_force is clear when the auto-neg CL72 training enable is being determined, this register has no effect.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_LNK_CTLr (0x0000c253 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_LNK_CTLr_SIZE 4

/*
 * This structure should be used to declare and program LNK_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_LNK_CTLr_s {
	uint32_t v[1];
	uint32_t lnk_ctl[1];
	uint32_t _lnk_ctl;
} BCMI_TSCE16_XGXS_LNK_CTLr_t;

#define BCMI_TSCE16_XGXS_LNK_CTLr_CLR(r) (r).lnk_ctl[0] = 0
#define BCMI_TSCE16_XGXS_LNK_CTLr_SET(r,d) (r).lnk_ctl[0] = d
#define BCMI_TSCE16_XGXS_LNK_CTLr_GET(r) (r).lnk_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_LNK_CTLr_LINK_CONTROL_FORCEVALf_GET(r) ((((r).lnk_ctl[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_LNK_CTLr_LINK_CONTROL_FORCEVALf_SET(r,f) (r).lnk_ctl[0]=(((r).lnk_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))

/*
 * These macros can be used to access LNK_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_LNK_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_LNK_CTLr,(_r._lnk_ctl))
#define BCMI_TSCE16_XGXS_WRITE_LNK_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_LNK_CTLr,(_r._lnk_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_LNK_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_LNK_CTLr,(_r._lnk_ctl))
#define BCMI_TSCE16_XGXS_READLN_LNK_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_LNK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnk_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_LNK_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_LNK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnk_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_LNK_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_LNK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnk_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LNK_CTLr BCMI_TSCE16_XGXS_LNK_CTLr
#define LNK_CTLr_SIZE BCMI_TSCE16_XGXS_LNK_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_LNK_CTLr_t LNK_CTLr_t;
#define LNK_CTLr_CLR BCMI_TSCE16_XGXS_LNK_CTLr_CLR
#define LNK_CTLr_SET BCMI_TSCE16_XGXS_LNK_CTLr_SET
#define LNK_CTLr_GET BCMI_TSCE16_XGXS_LNK_CTLr_GET
#define LNK_CTLr_LINK_CONTROL_FORCEVALf_GET BCMI_TSCE16_XGXS_LNK_CTLr_LINK_CONTROL_FORCEVALf_GET
#define LNK_CTLr_LINK_CONTROL_FORCEVALf_SET BCMI_TSCE16_XGXS_LNK_CTLr_LINK_CONTROL_FORCEVALf_SET
#define READ_LNK_CTLr BCMI_TSCE16_XGXS_READ_LNK_CTLr
#define WRITE_LNK_CTLr BCMI_TSCE16_XGXS_WRITE_LNK_CTLr
#define MODIFY_LNK_CTLr BCMI_TSCE16_XGXS_MODIFY_LNK_CTLr
#define READLN_LNK_CTLr BCMI_TSCE16_XGXS_READLN_LNK_CTLr
#define WRITELN_LNK_CTLr BCMI_TSCE16_XGXS_WRITELN_LNK_CTLr
#define WRITEALL_LNK_CTLr BCMI_TSCE16_XGXS_WRITEALL_LNK_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_LNK_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DIGITAL_CTL1000X2
 * BLOCKS:   DIGITAL
 * REGADDR:  0xc301
 * DESC:     1000X control 2 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DISABLE_REMOTE_FAULT_REPORTING 1 = disable automatic reporting of remote faults, such as auto-negotiation error0 = report remote fault status to link partner via auto-negotiation when fiber mode is selected. (SGMII does not support remote faults)
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DIGITAL_CTL1000X2r (0x0000c301 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DIGITAL_CTL1000X2r_SIZE 4

/*
 * This structure should be used to declare and program DIGITAL_CTL1000X2.
 *
 */
typedef union BCMI_TSCE16_XGXS_DIGITAL_CTL1000X2r_s {
	uint32_t v[1];
	uint32_t digital_ctl1000x2[1];
	uint32_t _digital_ctl1000x2;
} BCMI_TSCE16_XGXS_DIGITAL_CTL1000X2r_t;

#define BCMI_TSCE16_XGXS_DIGITAL_CTL1000X2r_CLR(r) (r).digital_ctl1000x2[0] = 0
#define BCMI_TSCE16_XGXS_DIGITAL_CTL1000X2r_SET(r,d) (r).digital_ctl1000x2[0] = d
#define BCMI_TSCE16_XGXS_DIGITAL_CTL1000X2r_GET(r) (r).digital_ctl1000x2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DIGITAL_CTL1000X2r_DISABLE_REMOTE_FAULT_REPORTINGf_GET(r) ((((r).digital_ctl1000x2[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_DIGITAL_CTL1000X2r_DISABLE_REMOTE_FAULT_REPORTINGf_SET(r,f) (r).digital_ctl1000x2[0]=(((r).digital_ctl1000x2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))

/*
 * These macros can be used to access DIGITAL_CTL1000X2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DIGITAL_CTL1000X2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DIGITAL_CTL1000X2r,(_r._digital_ctl1000x2))
#define BCMI_TSCE16_XGXS_WRITE_DIGITAL_CTL1000X2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DIGITAL_CTL1000X2r,(_r._digital_ctl1000x2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DIGITAL_CTL1000X2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DIGITAL_CTL1000X2r,(_r._digital_ctl1000x2))
#define BCMI_TSCE16_XGXS_READLN_DIGITAL_CTL1000X2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DIGITAL_CTL1000X2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._digital_ctl1000x2))
#define BCMI_TSCE16_XGXS_WRITELN_DIGITAL_CTL1000X2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DIGITAL_CTL1000X2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._digital_ctl1000x2))
#define BCMI_TSCE16_XGXS_WRITEALL_DIGITAL_CTL1000X2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DIGITAL_CTL1000X2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._digital_ctl1000x2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIGITAL_CTL1000X2r BCMI_TSCE16_XGXS_DIGITAL_CTL1000X2r
#define DIGITAL_CTL1000X2r_SIZE BCMI_TSCE16_XGXS_DIGITAL_CTL1000X2r_SIZE
typedef BCMI_TSCE16_XGXS_DIGITAL_CTL1000X2r_t DIGITAL_CTL1000X2r_t;
#define DIGITAL_CTL1000X2r_CLR BCMI_TSCE16_XGXS_DIGITAL_CTL1000X2r_CLR
#define DIGITAL_CTL1000X2r_SET BCMI_TSCE16_XGXS_DIGITAL_CTL1000X2r_SET
#define DIGITAL_CTL1000X2r_GET BCMI_TSCE16_XGXS_DIGITAL_CTL1000X2r_GET
#define DIGITAL_CTL1000X2r_DISABLE_REMOTE_FAULT_REPORTINGf_GET BCMI_TSCE16_XGXS_DIGITAL_CTL1000X2r_DISABLE_REMOTE_FAULT_REPORTINGf_GET
#define DIGITAL_CTL1000X2r_DISABLE_REMOTE_FAULT_REPORTINGf_SET BCMI_TSCE16_XGXS_DIGITAL_CTL1000X2r_DISABLE_REMOTE_FAULT_REPORTINGf_SET
#define READ_DIGITAL_CTL1000X2r BCMI_TSCE16_XGXS_READ_DIGITAL_CTL1000X2r
#define WRITE_DIGITAL_CTL1000X2r BCMI_TSCE16_XGXS_WRITE_DIGITAL_CTL1000X2r
#define MODIFY_DIGITAL_CTL1000X2r BCMI_TSCE16_XGXS_MODIFY_DIGITAL_CTL1000X2r
#define READLN_DIGITAL_CTL1000X2r BCMI_TSCE16_XGXS_READLN_DIGITAL_CTL1000X2r
#define WRITELN_DIGITAL_CTL1000X2r BCMI_TSCE16_XGXS_WRITELN_DIGITAL_CTL1000X2r
#define WRITEALL_DIGITAL_CTL1000X2r BCMI_TSCE16_XGXS_WRITEALL_DIGITAL_CTL1000X2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DIGITAL_CTL1000X2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SPARE0
 * BLOCKS:   DIGITAL
 * REGADDR:  0xc30a
 * DESC:     spare 0 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPARE0           
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SPARE0r (0x0000c30a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SPARE0r_SIZE 4

/*
 * This structure should be used to declare and program SPARE0.
 *
 */
typedef union BCMI_TSCE16_XGXS_SPARE0r_s {
	uint32_t v[1];
	uint32_t spare0[1];
	uint32_t _spare0;
} BCMI_TSCE16_XGXS_SPARE0r_t;

#define BCMI_TSCE16_XGXS_SPARE0r_CLR(r) (r).spare0[0] = 0
#define BCMI_TSCE16_XGXS_SPARE0r_SET(r,d) (r).spare0[0] = d
#define BCMI_TSCE16_XGXS_SPARE0r_GET(r) (r).spare0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SPARE0r_SPARE0f_GET(r) (((r).spare0[0]) & 0xff)
#define BCMI_TSCE16_XGXS_SPARE0r_SPARE0f_SET(r,f) (r).spare0[0]=(((r).spare0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access SPARE0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SPARE0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SPARE0r,(_r._spare0))
#define BCMI_TSCE16_XGXS_WRITE_SPARE0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SPARE0r,(_r._spare0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SPARE0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SPARE0r,(_r._spare0))
#define BCMI_TSCE16_XGXS_READLN_SPARE0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SPARE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._spare0))
#define BCMI_TSCE16_XGXS_WRITELN_SPARE0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SPARE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._spare0))
#define BCMI_TSCE16_XGXS_WRITEALL_SPARE0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SPARE0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._spare0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SPARE0r BCMI_TSCE16_XGXS_SPARE0r
#define SPARE0r_SIZE BCMI_TSCE16_XGXS_SPARE0r_SIZE
typedef BCMI_TSCE16_XGXS_SPARE0r_t SPARE0r_t;
#define SPARE0r_CLR BCMI_TSCE16_XGXS_SPARE0r_CLR
#define SPARE0r_SET BCMI_TSCE16_XGXS_SPARE0r_SET
#define SPARE0r_GET BCMI_TSCE16_XGXS_SPARE0r_GET
#define SPARE0r_SPARE0f_GET BCMI_TSCE16_XGXS_SPARE0r_SPARE0f_GET
#define SPARE0r_SPARE0f_SET BCMI_TSCE16_XGXS_SPARE0r_SPARE0f_SET
#define READ_SPARE0r BCMI_TSCE16_XGXS_READ_SPARE0r
#define WRITE_SPARE0r BCMI_TSCE16_XGXS_WRITE_SPARE0r
#define MODIFY_SPARE0r BCMI_TSCE16_XGXS_MODIFY_SPARE0r
#define READLN_SPARE0r BCMI_TSCE16_XGXS_READLN_SPARE0r
#define WRITELN_SPARE0r BCMI_TSCE16_XGXS_WRITELN_SPARE0r
#define WRITEALL_SPARE0r BCMI_TSCE16_XGXS_WRITEALL_SPARE0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SPARE0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SPARE1
 * BLOCKS:   DIGITAL
 * REGADDR:  0xc30b
 * DESC:     spare 1 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPARE1           
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SPARE1r (0x0000c30b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SPARE1r_SIZE 4

/*
 * This structure should be used to declare and program SPARE1.
 *
 */
typedef union BCMI_TSCE16_XGXS_SPARE1r_s {
	uint32_t v[1];
	uint32_t spare1[1];
	uint32_t _spare1;
} BCMI_TSCE16_XGXS_SPARE1r_t;

#define BCMI_TSCE16_XGXS_SPARE1r_CLR(r) (r).spare1[0] = 0
#define BCMI_TSCE16_XGXS_SPARE1r_SET(r,d) (r).spare1[0] = d
#define BCMI_TSCE16_XGXS_SPARE1r_GET(r) (r).spare1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SPARE1r_SPARE1f_GET(r) (((r).spare1[0]) & 0xff)
#define BCMI_TSCE16_XGXS_SPARE1r_SPARE1f_SET(r,f) (r).spare1[0]=(((r).spare1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access SPARE1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SPARE1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SPARE1r,(_r._spare1))
#define BCMI_TSCE16_XGXS_WRITE_SPARE1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SPARE1r,(_r._spare1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SPARE1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SPARE1r,(_r._spare1))
#define BCMI_TSCE16_XGXS_READLN_SPARE1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SPARE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._spare1))
#define BCMI_TSCE16_XGXS_WRITELN_SPARE1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SPARE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._spare1))
#define BCMI_TSCE16_XGXS_WRITEALL_SPARE1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SPARE1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._spare1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SPARE1r BCMI_TSCE16_XGXS_SPARE1r
#define SPARE1r_SIZE BCMI_TSCE16_XGXS_SPARE1r_SIZE
typedef BCMI_TSCE16_XGXS_SPARE1r_t SPARE1r_t;
#define SPARE1r_CLR BCMI_TSCE16_XGXS_SPARE1r_CLR
#define SPARE1r_SET BCMI_TSCE16_XGXS_SPARE1r_SET
#define SPARE1r_GET BCMI_TSCE16_XGXS_SPARE1r_GET
#define SPARE1r_SPARE1f_GET BCMI_TSCE16_XGXS_SPARE1r_SPARE1f_GET
#define SPARE1r_SPARE1f_SET BCMI_TSCE16_XGXS_SPARE1r_SPARE1f_SET
#define READ_SPARE1r BCMI_TSCE16_XGXS_READ_SPARE1r
#define WRITE_SPARE1r BCMI_TSCE16_XGXS_WRITE_SPARE1r
#define MODIFY_SPARE1r BCMI_TSCE16_XGXS_MODIFY_SPARE1r
#define READLN_SPARE1r BCMI_TSCE16_XGXS_READLN_SPARE1r
#define WRITELN_SPARE1r BCMI_TSCE16_XGXS_WRITELN_SPARE1r
#define WRITEALL_SPARE1r BCMI_TSCE16_XGXS_WRITEALL_SPARE1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SPARE1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  ILKN_CTL0
 * BLOCKS:   ILKN_CONTROL0
 * REGADDR:  0xc330
 * DESC:     ilkn control 0 register
 * RESETVAL: 0x2 (2)
 * ACCESS:   R/W
 * FIELDS:
 *     WM               Watermark to reach before data from bypass interface is sent on egress data pathWatermark applies to the egress path onlyThe optimal setting of the watermark is between 1 and 4Watermark level of 1 is set for any configuration value of less than 1Watermark level of 4 is set for any configuration value of greater than 4
 *     ILKN_SEL         1 = enable ingress and egress data paths through ilkn bypass logicWhen 0, data paths are connected to the PCS interface
 *     INV_TX_ORDER     1 = when tx20_sel is 1, bit[39:20] from bypass interface is first sent on the egress data path0 = when tx20_sel is 1, bit[19:0] from bypass interface is first sent on the egress data path
 *     INV_RX_ORDER     1 = when rx20_sel is 1, ingress data from serdes is first packed into bit[39:20] of the bypass interface0 = when rx20_sel is 1, ingress data from serdes is first packed into bit[19:0] of the bypass interface
 *     SOFT_RST_TX      1 = reset tx path logic, other register setting is not changed; set bit to 0 for normal operation
 *     SOFT_RST_RX      1 = reset rx path logic, other register setting is not changed; set bit to 0 for normal operation
 *     CREDIT_EN        1 = enable credit generation to bypass interface on the egress pathWhen 0, no credit is issued for the egress path of the bypass interface
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_ILKN_CTL0r (0x0000c330 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_ILKN_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program ILKN_CTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_ILKN_CTL0r_s {
	uint32_t v[1];
	uint32_t ilkn_ctl0[1];
	uint32_t _ilkn_ctl0;
} BCMI_TSCE16_XGXS_ILKN_CTL0r_t;

#define BCMI_TSCE16_XGXS_ILKN_CTL0r_CLR(r) (r).ilkn_ctl0[0] = 0
#define BCMI_TSCE16_XGXS_ILKN_CTL0r_SET(r,d) (r).ilkn_ctl0[0] = d
#define BCMI_TSCE16_XGXS_ILKN_CTL0r_GET(r) (r).ilkn_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_ILKN_CTL0r_CREDIT_ENf_GET(r) ((((r).ilkn_ctl0[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_ILKN_CTL0r_CREDIT_ENf_SET(r,f) (r).ilkn_ctl0[0]=(((r).ilkn_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_ILKN_CTL0r_SOFT_RST_RXf_GET(r) ((((r).ilkn_ctl0[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_ILKN_CTL0r_SOFT_RST_RXf_SET(r,f) (r).ilkn_ctl0[0]=(((r).ilkn_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_ILKN_CTL0r_SOFT_RST_TXf_GET(r) ((((r).ilkn_ctl0[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_ILKN_CTL0r_SOFT_RST_TXf_SET(r,f) (r).ilkn_ctl0[0]=(((r).ilkn_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_ILKN_CTL0r_INV_RX_ORDERf_GET(r) ((((r).ilkn_ctl0[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_ILKN_CTL0r_INV_RX_ORDERf_SET(r,f) (r).ilkn_ctl0[0]=(((r).ilkn_ctl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_ILKN_CTL0r_INV_TX_ORDERf_GET(r) ((((r).ilkn_ctl0[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_ILKN_CTL0r_INV_TX_ORDERf_SET(r,f) (r).ilkn_ctl0[0]=(((r).ilkn_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_ILKN_CTL0r_ILKN_SELf_GET(r) ((((r).ilkn_ctl0[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_ILKN_CTL0r_ILKN_SELf_SET(r,f) (r).ilkn_ctl0[0]=(((r).ilkn_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_ILKN_CTL0r_WMf_GET(r) (((r).ilkn_ctl0[0]) & 0x7)
#define BCMI_TSCE16_XGXS_ILKN_CTL0r_WMf_SET(r,f) (r).ilkn_ctl0[0]=(((r).ilkn_ctl0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access ILKN_CTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_ILKN_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_ILKN_CTL0r,(_r._ilkn_ctl0))
#define BCMI_TSCE16_XGXS_WRITE_ILKN_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_ILKN_CTL0r,(_r._ilkn_ctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_ILKN_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_ILKN_CTL0r,(_r._ilkn_ctl0))
#define BCMI_TSCE16_XGXS_READLN_ILKN_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_ILKN_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ilkn_ctl0))
#define BCMI_TSCE16_XGXS_WRITELN_ILKN_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_ILKN_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ilkn_ctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_ILKN_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_ILKN_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ilkn_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ILKN_CTL0r BCMI_TSCE16_XGXS_ILKN_CTL0r
#define ILKN_CTL0r_SIZE BCMI_TSCE16_XGXS_ILKN_CTL0r_SIZE
typedef BCMI_TSCE16_XGXS_ILKN_CTL0r_t ILKN_CTL0r_t;
#define ILKN_CTL0r_CLR BCMI_TSCE16_XGXS_ILKN_CTL0r_CLR
#define ILKN_CTL0r_SET BCMI_TSCE16_XGXS_ILKN_CTL0r_SET
#define ILKN_CTL0r_GET BCMI_TSCE16_XGXS_ILKN_CTL0r_GET
#define ILKN_CTL0r_CREDIT_ENf_GET BCMI_TSCE16_XGXS_ILKN_CTL0r_CREDIT_ENf_GET
#define ILKN_CTL0r_CREDIT_ENf_SET BCMI_TSCE16_XGXS_ILKN_CTL0r_CREDIT_ENf_SET
#define ILKN_CTL0r_SOFT_RST_RXf_GET BCMI_TSCE16_XGXS_ILKN_CTL0r_SOFT_RST_RXf_GET
#define ILKN_CTL0r_SOFT_RST_RXf_SET BCMI_TSCE16_XGXS_ILKN_CTL0r_SOFT_RST_RXf_SET
#define ILKN_CTL0r_SOFT_RST_TXf_GET BCMI_TSCE16_XGXS_ILKN_CTL0r_SOFT_RST_TXf_GET
#define ILKN_CTL0r_SOFT_RST_TXf_SET BCMI_TSCE16_XGXS_ILKN_CTL0r_SOFT_RST_TXf_SET
#define ILKN_CTL0r_INV_RX_ORDERf_GET BCMI_TSCE16_XGXS_ILKN_CTL0r_INV_RX_ORDERf_GET
#define ILKN_CTL0r_INV_RX_ORDERf_SET BCMI_TSCE16_XGXS_ILKN_CTL0r_INV_RX_ORDERf_SET
#define ILKN_CTL0r_INV_TX_ORDERf_GET BCMI_TSCE16_XGXS_ILKN_CTL0r_INV_TX_ORDERf_GET
#define ILKN_CTL0r_INV_TX_ORDERf_SET BCMI_TSCE16_XGXS_ILKN_CTL0r_INV_TX_ORDERf_SET
#define ILKN_CTL0r_ILKN_SELf_GET BCMI_TSCE16_XGXS_ILKN_CTL0r_ILKN_SELf_GET
#define ILKN_CTL0r_ILKN_SELf_SET BCMI_TSCE16_XGXS_ILKN_CTL0r_ILKN_SELf_SET
#define ILKN_CTL0r_WMf_GET BCMI_TSCE16_XGXS_ILKN_CTL0r_WMf_GET
#define ILKN_CTL0r_WMf_SET BCMI_TSCE16_XGXS_ILKN_CTL0r_WMf_SET
#define READ_ILKN_CTL0r BCMI_TSCE16_XGXS_READ_ILKN_CTL0r
#define WRITE_ILKN_CTL0r BCMI_TSCE16_XGXS_WRITE_ILKN_CTL0r
#define MODIFY_ILKN_CTL0r BCMI_TSCE16_XGXS_MODIFY_ILKN_CTL0r
#define READLN_ILKN_CTL0r BCMI_TSCE16_XGXS_READLN_ILKN_CTL0r
#define WRITELN_ILKN_CTL0r BCMI_TSCE16_XGXS_WRITELN_ILKN_CTL0r
#define WRITEALL_ILKN_CTL0r BCMI_TSCE16_XGXS_WRITEALL_ILKN_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_ILKN_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  ILKN_STS0
 * BLOCKS:   ILKN_STATUS0
 * REGADDR:  0xc340
 * DESC:     ilkn status 0 register
 * RESETVAL: 0x11 (17)
 * ACCESS:   R/W
 * FIELDS:
 *     RXFIFO_EMPTY     rxfifo status  - mainly for simulatin and debug purposesreal time rxfifo status in bypass rxclk domain; rxfifo is empty
 *     RXFIFO_FULL      rxfifo status  - mainly for simulatin and debug purposesreal time rxfifo status in serdes rxclk domain; rxfifo is full
 *     RXFIFO_OVERRUN   rxfifo status  - mainly for simulatin and debug purposesreal time rxfifo status in bypass rxclk domain; rxfifo is being written when full
 *     RXFIFO_UNDERRUN  rxfifo status  - mainly for simulatin and debug purposesreal time rxfifo status in bypass rxclk domain; rxfifo is being read when empty
 *     TXFIFO_EMPTY     txfifo status  - mainly for simulatin and debug purposesreal time txfifo status in serdes txwclk domain; txfifo is empty
 *     TXFIFO_FULL      txfifo status  - mainly for simulatin and debug purposesreal time txfifo status in bypass txclk domain; txfifo is full
 *     TXFIFO_OVERRUN   txfifo status  - mainly for simulatin and debug purposesreal time txfifo status in serdes txwclk domain; txfifo is being written when full
 *     TXFIFO_UNDERRUN  txfifo status  - mainly for simulatin and debug purposesreal time txfifo status in serdes txwclk domain; txfifo is being read when empty
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_ILKN_STS0r (0x0000c340 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_ILKN_STS0r_SIZE 4

/*
 * This structure should be used to declare and program ILKN_STS0.
 *
 */
typedef union BCMI_TSCE16_XGXS_ILKN_STS0r_s {
	uint32_t v[1];
	uint32_t ilkn_sts0[1];
	uint32_t _ilkn_sts0;
} BCMI_TSCE16_XGXS_ILKN_STS0r_t;

#define BCMI_TSCE16_XGXS_ILKN_STS0r_CLR(r) (r).ilkn_sts0[0] = 0
#define BCMI_TSCE16_XGXS_ILKN_STS0r_SET(r,d) (r).ilkn_sts0[0] = d
#define BCMI_TSCE16_XGXS_ILKN_STS0r_GET(r) (r).ilkn_sts0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_ILKN_STS0r_TXFIFO_UNDERRUNf_GET(r) ((((r).ilkn_sts0[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_ILKN_STS0r_TXFIFO_UNDERRUNf_SET(r,f) (r).ilkn_sts0[0]=(((r).ilkn_sts0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_ILKN_STS0r_TXFIFO_OVERRUNf_GET(r) ((((r).ilkn_sts0[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_ILKN_STS0r_TXFIFO_OVERRUNf_SET(r,f) (r).ilkn_sts0[0]=(((r).ilkn_sts0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_ILKN_STS0r_TXFIFO_FULLf_GET(r) ((((r).ilkn_sts0[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_ILKN_STS0r_TXFIFO_FULLf_SET(r,f) (r).ilkn_sts0[0]=(((r).ilkn_sts0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_ILKN_STS0r_TXFIFO_EMPTYf_GET(r) ((((r).ilkn_sts0[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_ILKN_STS0r_TXFIFO_EMPTYf_SET(r,f) (r).ilkn_sts0[0]=(((r).ilkn_sts0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_ILKN_STS0r_RXFIFO_UNDERRUNf_GET(r) ((((r).ilkn_sts0[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_ILKN_STS0r_RXFIFO_UNDERRUNf_SET(r,f) (r).ilkn_sts0[0]=(((r).ilkn_sts0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_ILKN_STS0r_RXFIFO_OVERRUNf_GET(r) ((((r).ilkn_sts0[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_ILKN_STS0r_RXFIFO_OVERRUNf_SET(r,f) (r).ilkn_sts0[0]=(((r).ilkn_sts0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_ILKN_STS0r_RXFIFO_FULLf_GET(r) ((((r).ilkn_sts0[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_ILKN_STS0r_RXFIFO_FULLf_SET(r,f) (r).ilkn_sts0[0]=(((r).ilkn_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_ILKN_STS0r_RXFIFO_EMPTYf_GET(r) (((r).ilkn_sts0[0]) & 0x1)
#define BCMI_TSCE16_XGXS_ILKN_STS0r_RXFIFO_EMPTYf_SET(r,f) (r).ilkn_sts0[0]=(((r).ilkn_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access ILKN_STS0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_ILKN_STS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_ILKN_STS0r,(_r._ilkn_sts0))
#define BCMI_TSCE16_XGXS_WRITE_ILKN_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_ILKN_STS0r,(_r._ilkn_sts0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_ILKN_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_ILKN_STS0r,(_r._ilkn_sts0))
#define BCMI_TSCE16_XGXS_READLN_ILKN_STS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_ILKN_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ilkn_sts0))
#define BCMI_TSCE16_XGXS_WRITELN_ILKN_STS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_ILKN_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ilkn_sts0))
#define BCMI_TSCE16_XGXS_WRITEALL_ILKN_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_ILKN_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ilkn_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ILKN_STS0r BCMI_TSCE16_XGXS_ILKN_STS0r
#define ILKN_STS0r_SIZE BCMI_TSCE16_XGXS_ILKN_STS0r_SIZE
typedef BCMI_TSCE16_XGXS_ILKN_STS0r_t ILKN_STS0r_t;
#define ILKN_STS0r_CLR BCMI_TSCE16_XGXS_ILKN_STS0r_CLR
#define ILKN_STS0r_SET BCMI_TSCE16_XGXS_ILKN_STS0r_SET
#define ILKN_STS0r_GET BCMI_TSCE16_XGXS_ILKN_STS0r_GET
#define ILKN_STS0r_TXFIFO_UNDERRUNf_GET BCMI_TSCE16_XGXS_ILKN_STS0r_TXFIFO_UNDERRUNf_GET
#define ILKN_STS0r_TXFIFO_UNDERRUNf_SET BCMI_TSCE16_XGXS_ILKN_STS0r_TXFIFO_UNDERRUNf_SET
#define ILKN_STS0r_TXFIFO_OVERRUNf_GET BCMI_TSCE16_XGXS_ILKN_STS0r_TXFIFO_OVERRUNf_GET
#define ILKN_STS0r_TXFIFO_OVERRUNf_SET BCMI_TSCE16_XGXS_ILKN_STS0r_TXFIFO_OVERRUNf_SET
#define ILKN_STS0r_TXFIFO_FULLf_GET BCMI_TSCE16_XGXS_ILKN_STS0r_TXFIFO_FULLf_GET
#define ILKN_STS0r_TXFIFO_FULLf_SET BCMI_TSCE16_XGXS_ILKN_STS0r_TXFIFO_FULLf_SET
#define ILKN_STS0r_TXFIFO_EMPTYf_GET BCMI_TSCE16_XGXS_ILKN_STS0r_TXFIFO_EMPTYf_GET
#define ILKN_STS0r_TXFIFO_EMPTYf_SET BCMI_TSCE16_XGXS_ILKN_STS0r_TXFIFO_EMPTYf_SET
#define ILKN_STS0r_RXFIFO_UNDERRUNf_GET BCMI_TSCE16_XGXS_ILKN_STS0r_RXFIFO_UNDERRUNf_GET
#define ILKN_STS0r_RXFIFO_UNDERRUNf_SET BCMI_TSCE16_XGXS_ILKN_STS0r_RXFIFO_UNDERRUNf_SET
#define ILKN_STS0r_RXFIFO_OVERRUNf_GET BCMI_TSCE16_XGXS_ILKN_STS0r_RXFIFO_OVERRUNf_GET
#define ILKN_STS0r_RXFIFO_OVERRUNf_SET BCMI_TSCE16_XGXS_ILKN_STS0r_RXFIFO_OVERRUNf_SET
#define ILKN_STS0r_RXFIFO_FULLf_GET BCMI_TSCE16_XGXS_ILKN_STS0r_RXFIFO_FULLf_GET
#define ILKN_STS0r_RXFIFO_FULLf_SET BCMI_TSCE16_XGXS_ILKN_STS0r_RXFIFO_FULLf_SET
#define ILKN_STS0r_RXFIFO_EMPTYf_GET BCMI_TSCE16_XGXS_ILKN_STS0r_RXFIFO_EMPTYf_GET
#define ILKN_STS0r_RXFIFO_EMPTYf_SET BCMI_TSCE16_XGXS_ILKN_STS0r_RXFIFO_EMPTYf_SET
#define READ_ILKN_STS0r BCMI_TSCE16_XGXS_READ_ILKN_STS0r
#define WRITE_ILKN_STS0r BCMI_TSCE16_XGXS_WRITE_ILKN_STS0r
#define MODIFY_ILKN_STS0r BCMI_TSCE16_XGXS_MODIFY_ILKN_STS0r
#define READLN_ILKN_STS0r BCMI_TSCE16_XGXS_READLN_ILKN_STS0r
#define WRITELN_ILKN_STS0r BCMI_TSCE16_XGXS_WRITELN_ILKN_STS0r
#define WRITEALL_ILKN_STS0r BCMI_TSCE16_XGXS_WRITEALL_ILKN_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_ILKN_STS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_CDR_CTL0
 * BLOCKS:   DSC_A
 * REGADDR:  0xd001
 * DESC:     CDR Control 0
 * RESETVAL: 0x4 (4)
 * ACCESS:   R/W
 * FIELDS:
 *     CDR_PHASE_SAT_CTRL 0:(+-12), 1:(+-10)
 *     BR_PD_EN         Enables BR phase detector
 *     CDR_FREQ_EN      1: 2nd order loop output to contribute
 *     CDR_INTEG_REG_CLR clear integ register
 *     CDR_PHASE_ERR_FRZ 1: override phase error to be 0
 *     CDR_INTEG_SAT_SEL 0:(-24576, 24575), 1:(-16384, 16383)
 *     CDR_FREQ_OVERRIDE_EN 1:override integ register with cdr_freq_override_val
 *     CDR_LM_THR_SEL   cdr lock monitor looks for integ reg[15:6] to be within sat - (cdr_lm_thr_sel +1)*512 in magnitude
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL0r (0x0000d001 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program DSC_CDR_CTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_s {
	uint32_t v[1];
	uint32_t dsc_cdr_ctl0[1];
	uint32_t _dsc_cdr_ctl0;
} BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_t;

#define BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_CLR(r) (r).dsc_cdr_ctl0[0] = 0
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_SET(r,d) (r).dsc_cdr_ctl0[0] = d
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_GET(r) (r).dsc_cdr_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_CDR_LM_THR_SELf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 8) & 0x7)
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_CDR_LM_THR_SELf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_CDR_FREQ_OVERRIDE_ENf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_CDR_FREQ_OVERRIDE_ENf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_CDR_INTEG_SAT_SELf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_CDR_INTEG_SAT_SELf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_CDR_PHASE_ERR_FRZf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_CDR_PHASE_ERR_FRZf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_CDR_INTEG_REG_CLRf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_CDR_INTEG_REG_CLRf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_CDR_FREQ_ENf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_CDR_FREQ_ENf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_BR_PD_ENf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_BR_PD_ENf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_CDR_PHASE_SAT_CTRLf_GET(r) (((r).dsc_cdr_ctl0[0]) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_CDR_PHASE_SAT_CTRLf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_CDR_CTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_CDR_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_CDR_CTL0r,(_r._dsc_cdr_ctl0))
#define BCMI_TSCE16_XGXS_WRITE_DSC_CDR_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_CDR_CTL0r,(_r._dsc_cdr_ctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_CDR_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_CDR_CTL0r,(_r._dsc_cdr_ctl0))
#define BCMI_TSCE16_XGXS_READLN_DSC_CDR_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_CDR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_ctl0))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_CDR_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_CDR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_ctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_CDR_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_CDR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_cdr_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_CDR_CTL0r BCMI_TSCE16_XGXS_DSC_CDR_CTL0r
#define DSC_CDR_CTL0r_SIZE BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_SIZE
typedef BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_t DSC_CDR_CTL0r_t;
#define DSC_CDR_CTL0r_CLR BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_CLR
#define DSC_CDR_CTL0r_SET BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_SET
#define DSC_CDR_CTL0r_GET BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_GET
#define DSC_CDR_CTL0r_CDR_LM_THR_SELf_GET BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_CDR_LM_THR_SELf_GET
#define DSC_CDR_CTL0r_CDR_LM_THR_SELf_SET BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_CDR_LM_THR_SELf_SET
#define DSC_CDR_CTL0r_CDR_FREQ_OVERRIDE_ENf_GET BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_CDR_FREQ_OVERRIDE_ENf_GET
#define DSC_CDR_CTL0r_CDR_FREQ_OVERRIDE_ENf_SET BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_CDR_FREQ_OVERRIDE_ENf_SET
#define DSC_CDR_CTL0r_CDR_INTEG_SAT_SELf_GET BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_CDR_INTEG_SAT_SELf_GET
#define DSC_CDR_CTL0r_CDR_INTEG_SAT_SELf_SET BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_CDR_INTEG_SAT_SELf_SET
#define DSC_CDR_CTL0r_CDR_PHASE_ERR_FRZf_GET BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_CDR_PHASE_ERR_FRZf_GET
#define DSC_CDR_CTL0r_CDR_PHASE_ERR_FRZf_SET BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_CDR_PHASE_ERR_FRZf_SET
#define DSC_CDR_CTL0r_CDR_INTEG_REG_CLRf_GET BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_CDR_INTEG_REG_CLRf_GET
#define DSC_CDR_CTL0r_CDR_INTEG_REG_CLRf_SET BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_CDR_INTEG_REG_CLRf_SET
#define DSC_CDR_CTL0r_CDR_FREQ_ENf_GET BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_CDR_FREQ_ENf_GET
#define DSC_CDR_CTL0r_CDR_FREQ_ENf_SET BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_CDR_FREQ_ENf_SET
#define DSC_CDR_CTL0r_BR_PD_ENf_GET BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_BR_PD_ENf_GET
#define DSC_CDR_CTL0r_BR_PD_ENf_SET BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_BR_PD_ENf_SET
#define DSC_CDR_CTL0r_CDR_PHASE_SAT_CTRLf_GET BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_CDR_PHASE_SAT_CTRLf_GET
#define DSC_CDR_CTL0r_CDR_PHASE_SAT_CTRLf_SET BCMI_TSCE16_XGXS_DSC_CDR_CTL0r_CDR_PHASE_SAT_CTRLf_SET
#define READ_DSC_CDR_CTL0r BCMI_TSCE16_XGXS_READ_DSC_CDR_CTL0r
#define WRITE_DSC_CDR_CTL0r BCMI_TSCE16_XGXS_WRITE_DSC_CDR_CTL0r
#define MODIFY_DSC_CDR_CTL0r BCMI_TSCE16_XGXS_MODIFY_DSC_CDR_CTL0r
#define READLN_DSC_CDR_CTL0r BCMI_TSCE16_XGXS_READLN_DSC_CDR_CTL0r
#define WRITELN_DSC_CDR_CTL0r BCMI_TSCE16_XGXS_WRITELN_DSC_CDR_CTL0r
#define WRITEALL_DSC_CDR_CTL0r BCMI_TSCE16_XGXS_WRITEALL_DSC_CDR_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_CDR_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_CDR_CTL1
 * BLOCKS:   DSC_A
 * REGADDR:  0xd002
 * DESC:     CDR Control 1
 * RESETVAL: 0x690 (1680)
 * ACCESS:   R/W
 * FIELDS:
 *     DFE_VGA_UNFREEZE When 1, the dfe and vga adaptive loops are unfrozen.
 *     CDR_FREQ_OVERRIDE_VAL Override value for the second order integrator. Initial value is +20ppm which gets loaded on resetThis value gets loaded into [15:1] indexes of the integ reg in the CDRs second order loop on reset. Value/42 is the approximate ppm forced.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL1r (0x0000d002 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_CDR_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program DSC_CDR_CTL1.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_CDR_CTL1r_s {
	uint32_t v[1];
	uint32_t dsc_cdr_ctl1[1];
	uint32_t _dsc_cdr_ctl1;
} BCMI_TSCE16_XGXS_DSC_CDR_CTL1r_t;

#define BCMI_TSCE16_XGXS_DSC_CDR_CTL1r_CLR(r) (r).dsc_cdr_ctl1[0] = 0
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL1r_SET(r,d) (r).dsc_cdr_ctl1[0] = d
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL1r_GET(r) (r).dsc_cdr_ctl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL1r_CDR_FREQ_OVERRIDE_VALf_GET(r) ((((r).dsc_cdr_ctl1[0]) >> 1) & 0x7fff)
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL1r_CDR_FREQ_OVERRIDE_VALf_SET(r,f) (r).dsc_cdr_ctl1[0]=(((r).dsc_cdr_ctl1[0] & ~((uint32_t)0x7fff << 1)) | ((((uint32_t)f) & 0x7fff) << 1)) | (32767 << (16 + 1))
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL1r_DFE_VGA_UNFREEZEf_GET(r) (((r).dsc_cdr_ctl1[0]) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL1r_DFE_VGA_UNFREEZEf_SET(r,f) (r).dsc_cdr_ctl1[0]=(((r).dsc_cdr_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_CDR_CTL1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_CDR_CTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_CDR_CTL1r,(_r._dsc_cdr_ctl1))
#define BCMI_TSCE16_XGXS_WRITE_DSC_CDR_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_CDR_CTL1r,(_r._dsc_cdr_ctl1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_CDR_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_CDR_CTL1r,(_r._dsc_cdr_ctl1))
#define BCMI_TSCE16_XGXS_READLN_DSC_CDR_CTL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_CDR_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_ctl1))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_CDR_CTL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_CDR_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_ctl1))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_CDR_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_CDR_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_cdr_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_CDR_CTL1r BCMI_TSCE16_XGXS_DSC_CDR_CTL1r
#define DSC_CDR_CTL1r_SIZE BCMI_TSCE16_XGXS_DSC_CDR_CTL1r_SIZE
typedef BCMI_TSCE16_XGXS_DSC_CDR_CTL1r_t DSC_CDR_CTL1r_t;
#define DSC_CDR_CTL1r_CLR BCMI_TSCE16_XGXS_DSC_CDR_CTL1r_CLR
#define DSC_CDR_CTL1r_SET BCMI_TSCE16_XGXS_DSC_CDR_CTL1r_SET
#define DSC_CDR_CTL1r_GET BCMI_TSCE16_XGXS_DSC_CDR_CTL1r_GET
#define DSC_CDR_CTL1r_CDR_FREQ_OVERRIDE_VALf_GET BCMI_TSCE16_XGXS_DSC_CDR_CTL1r_CDR_FREQ_OVERRIDE_VALf_GET
#define DSC_CDR_CTL1r_CDR_FREQ_OVERRIDE_VALf_SET BCMI_TSCE16_XGXS_DSC_CDR_CTL1r_CDR_FREQ_OVERRIDE_VALf_SET
#define DSC_CDR_CTL1r_DFE_VGA_UNFREEZEf_GET BCMI_TSCE16_XGXS_DSC_CDR_CTL1r_DFE_VGA_UNFREEZEf_GET
#define DSC_CDR_CTL1r_DFE_VGA_UNFREEZEf_SET BCMI_TSCE16_XGXS_DSC_CDR_CTL1r_DFE_VGA_UNFREEZEf_SET
#define READ_DSC_CDR_CTL1r BCMI_TSCE16_XGXS_READ_DSC_CDR_CTL1r
#define WRITE_DSC_CDR_CTL1r BCMI_TSCE16_XGXS_WRITE_DSC_CDR_CTL1r
#define MODIFY_DSC_CDR_CTL1r BCMI_TSCE16_XGXS_MODIFY_DSC_CDR_CTL1r
#define READLN_DSC_CDR_CTL1r BCMI_TSCE16_XGXS_READLN_DSC_CDR_CTL1r
#define WRITELN_DSC_CDR_CTL1r BCMI_TSCE16_XGXS_WRITELN_DSC_CDR_CTL1r
#define WRITEALL_DSC_CDR_CTL1r BCMI_TSCE16_XGXS_WRITEALL_DSC_CDR_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_CDR_CTL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_CDR_CTL2
 * BLOCKS:   DSC_A
 * REGADDR:  0xd003
 * DESC:     CDR Control 2
 * RESETVAL: 0xf0 (240)
 * ACCESS:   R/W
 * FIELDS:
 *     CDR_ZERO_POLARITY inverts the edge sample (zero) information before the phase detector
 *     PHASE_ERR_OFFSET_MULT_2 Multiplies the phase error offset by 2
 *     PATTERN_SEL      CDR can be conditioned to operate on selected 3-bit data patterns.Each bit of this register field enables a specified pattern.In OS phase detector mode, pattern is specified by {2nd previous, previous, current bit}.In  BR phase detector mode, pattern is specified by {previous, current, future bit}Bit 0: 001Bit 1: 110Bit 2: 010 for OS modes, 011 for BR modeBit 3: 101 for OS modes, 100 for BR modeFor OSx3 and higher oversampling ratios, this feature is not supported, please leave it at reset value of 0xF.
 *     OSX2P_PHERR_GAIN in > osx2 modes, the phase error is multiplied by 2^{0,1,2,3}
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL2r (0x0000d003 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_CDR_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program DSC_CDR_CTL2.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_CDR_CTL2r_s {
	uint32_t v[1];
	uint32_t dsc_cdr_ctl2[1];
	uint32_t _dsc_cdr_ctl2;
} BCMI_TSCE16_XGXS_DSC_CDR_CTL2r_t;

#define BCMI_TSCE16_XGXS_DSC_CDR_CTL2r_CLR(r) (r).dsc_cdr_ctl2[0] = 0
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL2r_SET(r,d) (r).dsc_cdr_ctl2[0] = d
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL2r_GET(r) (r).dsc_cdr_ctl2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL2r_OSX2P_PHERR_GAINf_GET(r) ((((r).dsc_cdr_ctl2[0]) >> 8) & 0x3)
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL2r_OSX2P_PHERR_GAINf_SET(r,f) (r).dsc_cdr_ctl2[0]=(((r).dsc_cdr_ctl2[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL2r_PATTERN_SELf_GET(r) ((((r).dsc_cdr_ctl2[0]) >> 4) & 0xf)
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL2r_PATTERN_SELf_SET(r,f) (r).dsc_cdr_ctl2[0]=(((r).dsc_cdr_ctl2[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL2r_PHASE_ERR_OFFSET_MULT_2f_GET(r) ((((r).dsc_cdr_ctl2[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL2r_PHASE_ERR_OFFSET_MULT_2f_SET(r,f) (r).dsc_cdr_ctl2[0]=(((r).dsc_cdr_ctl2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL2r_CDR_ZERO_POLARITYf_GET(r) (((r).dsc_cdr_ctl2[0]) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_CDR_CTL2r_CDR_ZERO_POLARITYf_SET(r,f) (r).dsc_cdr_ctl2[0]=(((r).dsc_cdr_ctl2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_CDR_CTL2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_CDR_CTL2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_CDR_CTL2r,(_r._dsc_cdr_ctl2))
#define BCMI_TSCE16_XGXS_WRITE_DSC_CDR_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_CDR_CTL2r,(_r._dsc_cdr_ctl2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_CDR_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_CDR_CTL2r,(_r._dsc_cdr_ctl2))
#define BCMI_TSCE16_XGXS_READLN_DSC_CDR_CTL2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_CDR_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_ctl2))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_CDR_CTL2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_CDR_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_ctl2))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_CDR_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_CDR_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_cdr_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_CDR_CTL2r BCMI_TSCE16_XGXS_DSC_CDR_CTL2r
#define DSC_CDR_CTL2r_SIZE BCMI_TSCE16_XGXS_DSC_CDR_CTL2r_SIZE
typedef BCMI_TSCE16_XGXS_DSC_CDR_CTL2r_t DSC_CDR_CTL2r_t;
#define DSC_CDR_CTL2r_CLR BCMI_TSCE16_XGXS_DSC_CDR_CTL2r_CLR
#define DSC_CDR_CTL2r_SET BCMI_TSCE16_XGXS_DSC_CDR_CTL2r_SET
#define DSC_CDR_CTL2r_GET BCMI_TSCE16_XGXS_DSC_CDR_CTL2r_GET
#define DSC_CDR_CTL2r_OSX2P_PHERR_GAINf_GET BCMI_TSCE16_XGXS_DSC_CDR_CTL2r_OSX2P_PHERR_GAINf_GET
#define DSC_CDR_CTL2r_OSX2P_PHERR_GAINf_SET BCMI_TSCE16_XGXS_DSC_CDR_CTL2r_OSX2P_PHERR_GAINf_SET
#define DSC_CDR_CTL2r_PATTERN_SELf_GET BCMI_TSCE16_XGXS_DSC_CDR_CTL2r_PATTERN_SELf_GET
#define DSC_CDR_CTL2r_PATTERN_SELf_SET BCMI_TSCE16_XGXS_DSC_CDR_CTL2r_PATTERN_SELf_SET
#define DSC_CDR_CTL2r_PHASE_ERR_OFFSET_MULT_2f_GET BCMI_TSCE16_XGXS_DSC_CDR_CTL2r_PHASE_ERR_OFFSET_MULT_2f_GET
#define DSC_CDR_CTL2r_PHASE_ERR_OFFSET_MULT_2f_SET BCMI_TSCE16_XGXS_DSC_CDR_CTL2r_PHASE_ERR_OFFSET_MULT_2f_SET
#define DSC_CDR_CTL2r_CDR_ZERO_POLARITYf_GET BCMI_TSCE16_XGXS_DSC_CDR_CTL2r_CDR_ZERO_POLARITYf_GET
#define DSC_CDR_CTL2r_CDR_ZERO_POLARITYf_SET BCMI_TSCE16_XGXS_DSC_CDR_CTL2r_CDR_ZERO_POLARITYf_SET
#define READ_DSC_CDR_CTL2r BCMI_TSCE16_XGXS_READ_DSC_CDR_CTL2r
#define WRITE_DSC_CDR_CTL2r BCMI_TSCE16_XGXS_WRITE_DSC_CDR_CTL2r
#define MODIFY_DSC_CDR_CTL2r BCMI_TSCE16_XGXS_MODIFY_DSC_CDR_CTL2r
#define READLN_DSC_CDR_CTL2r BCMI_TSCE16_XGXS_READLN_DSC_CDR_CTL2r
#define WRITELN_DSC_CDR_CTL2r BCMI_TSCE16_XGXS_WRITELN_DSC_CDR_CTL2r
#define WRITEALL_DSC_CDR_CTL2r BCMI_TSCE16_XGXS_WRITEALL_DSC_CDR_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_CDR_CTL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_RX_PI_CTL
 * BLOCKS:   DSC_A
 * REGADDR:  0xd004
 * DESC:     RX PI control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_PI_PHASE_STEP_CNT # of steps to adjust
 *     RX_PI_MANUAL_STROBE strobe performs a manual override for a specified # of cycles (self clearing)
 *     RX_PI_PHASE_STEP_DIR 0: left shift, 1: right shift
 *     RX_PI_MANUAL_MODE 0: normal, 1:disconnect all PI's from CDR when enabled
 *     RX_PI_SLICERS_EN bit-vector representing which PI's to adjust: [0] d, [1] p1, [2] m1,where [0][1][2] are index locations.Eg: if data and m1 slicers need to be moved set pi_slicers_en[2:0] to 3'b101Encoding: each index is an independent enable for the corresponding slicer.
 *     RX_PI_MANUAL_RESET active high reset signal which initializes the pi
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr (0x0000d004 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_ctl[1];
	uint32_t _dsc_rx_pi_ctl;
} BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr_t;

#define BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr_CLR(r) (r).dsc_rx_pi_ctl[0] = 0
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr_SET(r,d) (r).dsc_rx_pi_ctl[0] = d
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr_GET(r) (r).dsc_rx_pi_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_RESETf_GET(r) ((((r).dsc_rx_pi_ctl[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_RESETf_SET(r,f) (r).dsc_rx_pi_ctl[0]=(((r).dsc_rx_pi_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr_RX_PI_SLICERS_ENf_GET(r) ((((r).dsc_rx_pi_ctl[0]) >> 12) & 0x7)
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr_RX_PI_SLICERS_ENf_SET(r,f) (r).dsc_rx_pi_ctl[0]=(((r).dsc_rx_pi_ctl[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12)) | (7 << (16 + 12))
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_MODEf_GET(r) ((((r).dsc_rx_pi_ctl[0]) >> 11) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_MODEf_SET(r,f) (r).dsc_rx_pi_ctl[0]=(((r).dsc_rx_pi_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_DIRf_GET(r) ((((r).dsc_rx_pi_ctl[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_DIRf_SET(r,f) (r).dsc_rx_pi_ctl[0]=(((r).dsc_rx_pi_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_STROBEf_GET(r) ((((r).dsc_rx_pi_ctl[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_STROBEf_SET(r,f) (r).dsc_rx_pi_ctl[0]=(((r).dsc_rx_pi_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_CNTf_GET(r) (((r).dsc_rx_pi_ctl[0]) & 0x7f)
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_CNTf_SET(r,f) (r).dsc_rx_pi_ctl[0]=(((r).dsc_rx_pi_ctl[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access DSC_RX_PI_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_RX_PI_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr,(_r._dsc_rx_pi_ctl))
#define BCMI_TSCE16_XGXS_WRITE_DSC_RX_PI_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr,(_r._dsc_rx_pi_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_RX_PI_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr,(_r._dsc_rx_pi_ctl))
#define BCMI_TSCE16_XGXS_READLN_DSC_RX_PI_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_RX_PI_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_RX_PI_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_CTLr BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr
#define DSC_RX_PI_CTLr_SIZE BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr_t DSC_RX_PI_CTLr_t;
#define DSC_RX_PI_CTLr_CLR BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr_CLR
#define DSC_RX_PI_CTLr_SET BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr_SET
#define DSC_RX_PI_CTLr_GET BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr_GET
#define DSC_RX_PI_CTLr_RX_PI_MANUAL_RESETf_GET BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_RESETf_GET
#define DSC_RX_PI_CTLr_RX_PI_MANUAL_RESETf_SET BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_RESETf_SET
#define DSC_RX_PI_CTLr_RX_PI_SLICERS_ENf_GET BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr_RX_PI_SLICERS_ENf_GET
#define DSC_RX_PI_CTLr_RX_PI_SLICERS_ENf_SET BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr_RX_PI_SLICERS_ENf_SET
#define DSC_RX_PI_CTLr_RX_PI_MANUAL_MODEf_GET BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_MODEf_GET
#define DSC_RX_PI_CTLr_RX_PI_MANUAL_MODEf_SET BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_MODEf_SET
#define DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_DIRf_GET BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_DIRf_GET
#define DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_DIRf_SET BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_DIRf_SET
#define DSC_RX_PI_CTLr_RX_PI_MANUAL_STROBEf_GET BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_STROBEf_GET
#define DSC_RX_PI_CTLr_RX_PI_MANUAL_STROBEf_SET BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_STROBEf_SET
#define DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_CNTf_GET BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_CNTf_GET
#define DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_CNTf_SET BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_CNTf_SET
#define READ_DSC_RX_PI_CTLr BCMI_TSCE16_XGXS_READ_DSC_RX_PI_CTLr
#define WRITE_DSC_RX_PI_CTLr BCMI_TSCE16_XGXS_WRITE_DSC_RX_PI_CTLr
#define MODIFY_DSC_RX_PI_CTLr BCMI_TSCE16_XGXS_MODIFY_DSC_RX_PI_CTLr
#define READLN_DSC_RX_PI_CTLr BCMI_TSCE16_XGXS_READLN_DSC_RX_PI_CTLr
#define WRITELN_DSC_RX_PI_CTLr BCMI_TSCE16_XGXS_WRITELN_DSC_RX_PI_CTLr
#define WRITEALL_DSC_RX_PI_CTLr BCMI_TSCE16_XGXS_WRITEALL_DSC_RX_PI_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_RX_PI_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_CDR_STS_INTEG
 * BLOCKS:   DSC_A
 * REGADDR:  0xd005
 * DESC:     CDR Status Integ Reg
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CDR_INTEG_REG    CDR Integ register value.The frequency offset in ppm can be derived from the cdr_integ_reg as follows:cdr_integ_reg /83.886 in ppm
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_CDR_STS_INTEGr (0x0000d005 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_CDR_STS_INTEGr_SIZE 4

/*
 * This structure should be used to declare and program DSC_CDR_STS_INTEG.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_CDR_STS_INTEGr_s {
	uint32_t v[1];
	uint32_t dsc_cdr_sts_integ[1];
	uint32_t _dsc_cdr_sts_integ;
} BCMI_TSCE16_XGXS_DSC_CDR_STS_INTEGr_t;

#define BCMI_TSCE16_XGXS_DSC_CDR_STS_INTEGr_CLR(r) (r).dsc_cdr_sts_integ[0] = 0
#define BCMI_TSCE16_XGXS_DSC_CDR_STS_INTEGr_SET(r,d) (r).dsc_cdr_sts_integ[0] = d
#define BCMI_TSCE16_XGXS_DSC_CDR_STS_INTEGr_GET(r) (r).dsc_cdr_sts_integ[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_GET(r) (((r).dsc_cdr_sts_integ[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_SET(r,f) (r).dsc_cdr_sts_integ[0]=(((r).dsc_cdr_sts_integ[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_CDR_STS_INTEG.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_CDR_STS_INTEGr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_CDR_STS_INTEGr,(_r._dsc_cdr_sts_integ))
#define BCMI_TSCE16_XGXS_WRITE_DSC_CDR_STS_INTEGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_CDR_STS_INTEGr,(_r._dsc_cdr_sts_integ)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_CDR_STS_INTEGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_CDR_STS_INTEGr,(_r._dsc_cdr_sts_integ))
#define BCMI_TSCE16_XGXS_READLN_DSC_CDR_STS_INTEGr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_CDR_STS_INTEGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_sts_integ))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_CDR_STS_INTEGr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_CDR_STS_INTEGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_sts_integ))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_CDR_STS_INTEGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_CDR_STS_INTEGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_cdr_sts_integ))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_CDR_STS_INTEGr BCMI_TSCE16_XGXS_DSC_CDR_STS_INTEGr
#define DSC_CDR_STS_INTEGr_SIZE BCMI_TSCE16_XGXS_DSC_CDR_STS_INTEGr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_CDR_STS_INTEGr_t DSC_CDR_STS_INTEGr_t;
#define DSC_CDR_STS_INTEGr_CLR BCMI_TSCE16_XGXS_DSC_CDR_STS_INTEGr_CLR
#define DSC_CDR_STS_INTEGr_SET BCMI_TSCE16_XGXS_DSC_CDR_STS_INTEGr_SET
#define DSC_CDR_STS_INTEGr_GET BCMI_TSCE16_XGXS_DSC_CDR_STS_INTEGr_GET
#define DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_GET BCMI_TSCE16_XGXS_DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_GET
#define DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_SET BCMI_TSCE16_XGXS_DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_SET
#define READ_DSC_CDR_STS_INTEGr BCMI_TSCE16_XGXS_READ_DSC_CDR_STS_INTEGr
#define WRITE_DSC_CDR_STS_INTEGr BCMI_TSCE16_XGXS_WRITE_DSC_CDR_STS_INTEGr
#define MODIFY_DSC_CDR_STS_INTEGr BCMI_TSCE16_XGXS_MODIFY_DSC_CDR_STS_INTEGr
#define READLN_DSC_CDR_STS_INTEGr BCMI_TSCE16_XGXS_READLN_DSC_CDR_STS_INTEGr
#define WRITELN_DSC_CDR_STS_INTEGr BCMI_TSCE16_XGXS_WRITELN_DSC_CDR_STS_INTEGr
#define WRITEALL_DSC_CDR_STS_INTEGr BCMI_TSCE16_XGXS_WRITEALL_DSC_CDR_STS_INTEGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_CDR_STS_INTEGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_CDR_STS_PHASE_ERR
 * BLOCKS:   DSC_A
 * REGADDR:  0xd006
 * DESC:     CDR Status phase err
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CDR_PHASE_ERR    CDR Phase Error value (post gain, saturation , freeze logic)
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_CDR_STS_PHASE_ERRr (0x0000d006 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_CDR_STS_PHASE_ERRr_SIZE 4

/*
 * This structure should be used to declare and program DSC_CDR_STS_PHASE_ERR.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_CDR_STS_PHASE_ERRr_s {
	uint32_t v[1];
	uint32_t dsc_cdr_sts_phase_err[1];
	uint32_t _dsc_cdr_sts_phase_err;
} BCMI_TSCE16_XGXS_DSC_CDR_STS_PHASE_ERRr_t;

#define BCMI_TSCE16_XGXS_DSC_CDR_STS_PHASE_ERRr_CLR(r) (r).dsc_cdr_sts_phase_err[0] = 0
#define BCMI_TSCE16_XGXS_DSC_CDR_STS_PHASE_ERRr_SET(r,d) (r).dsc_cdr_sts_phase_err[0] = d
#define BCMI_TSCE16_XGXS_DSC_CDR_STS_PHASE_ERRr_GET(r) (r).dsc_cdr_sts_phase_err[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_CDR_STS_PHASE_ERRr_CDR_PHASE_ERRf_GET(r) (((r).dsc_cdr_sts_phase_err[0]) & 0x1f)
#define BCMI_TSCE16_XGXS_DSC_CDR_STS_PHASE_ERRr_CDR_PHASE_ERRf_SET(r,f) (r).dsc_cdr_sts_phase_err[0]=(((r).dsc_cdr_sts_phase_err[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_CDR_STS_PHASE_ERR.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_CDR_STS_PHASE_ERRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_CDR_STS_PHASE_ERRr,(_r._dsc_cdr_sts_phase_err))
#define BCMI_TSCE16_XGXS_WRITE_DSC_CDR_STS_PHASE_ERRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_CDR_STS_PHASE_ERRr,(_r._dsc_cdr_sts_phase_err)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_CDR_STS_PHASE_ERRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_CDR_STS_PHASE_ERRr,(_r._dsc_cdr_sts_phase_err))
#define BCMI_TSCE16_XGXS_READLN_DSC_CDR_STS_PHASE_ERRr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_CDR_STS_PHASE_ERRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_sts_phase_err))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_CDR_STS_PHASE_ERRr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_CDR_STS_PHASE_ERRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_sts_phase_err))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_CDR_STS_PHASE_ERRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_CDR_STS_PHASE_ERRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_cdr_sts_phase_err))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_CDR_STS_PHASE_ERRr BCMI_TSCE16_XGXS_DSC_CDR_STS_PHASE_ERRr
#define DSC_CDR_STS_PHASE_ERRr_SIZE BCMI_TSCE16_XGXS_DSC_CDR_STS_PHASE_ERRr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_CDR_STS_PHASE_ERRr_t DSC_CDR_STS_PHASE_ERRr_t;
#define DSC_CDR_STS_PHASE_ERRr_CLR BCMI_TSCE16_XGXS_DSC_CDR_STS_PHASE_ERRr_CLR
#define DSC_CDR_STS_PHASE_ERRr_SET BCMI_TSCE16_XGXS_DSC_CDR_STS_PHASE_ERRr_SET
#define DSC_CDR_STS_PHASE_ERRr_GET BCMI_TSCE16_XGXS_DSC_CDR_STS_PHASE_ERRr_GET
#define DSC_CDR_STS_PHASE_ERRr_CDR_PHASE_ERRf_GET BCMI_TSCE16_XGXS_DSC_CDR_STS_PHASE_ERRr_CDR_PHASE_ERRf_GET
#define DSC_CDR_STS_PHASE_ERRr_CDR_PHASE_ERRf_SET BCMI_TSCE16_XGXS_DSC_CDR_STS_PHASE_ERRr_CDR_PHASE_ERRf_SET
#define READ_DSC_CDR_STS_PHASE_ERRr BCMI_TSCE16_XGXS_READ_DSC_CDR_STS_PHASE_ERRr
#define WRITE_DSC_CDR_STS_PHASE_ERRr BCMI_TSCE16_XGXS_WRITE_DSC_CDR_STS_PHASE_ERRr
#define MODIFY_DSC_CDR_STS_PHASE_ERRr BCMI_TSCE16_XGXS_MODIFY_DSC_CDR_STS_PHASE_ERRr
#define READLN_DSC_CDR_STS_PHASE_ERRr BCMI_TSCE16_XGXS_READLN_DSC_CDR_STS_PHASE_ERRr
#define WRITELN_DSC_CDR_STS_PHASE_ERRr BCMI_TSCE16_XGXS_WRITELN_DSC_CDR_STS_PHASE_ERRr
#define WRITEALL_DSC_CDR_STS_PHASE_ERRr BCMI_TSCE16_XGXS_WRITEALL_DSC_CDR_STS_PHASE_ERRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_CDR_STS_PHASE_ERRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_RX_PI_CNT_BIN_D
 * BLOCKS:   DSC_A
 * REGADDR:  0xd007
 * DESC:     Rx PI {P1, D}
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CNT_BIN_D_DREG   Slicer D location
 *     CNT_BIN_P1_DREG  Slicer P1 locationThis read is duplicated here, so that the entire 15 bits if read at a time,the difference between d and p1 can be calculated, which is not possible with single reads without freezing the CDR
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Dr (0x0000d007 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Dr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_CNT_BIN_D.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Dr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_cnt_bin_d[1];
	uint32_t _dsc_rx_pi_cnt_bin_d;
} BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Dr_t;

#define BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Dr_CLR(r) (r).dsc_rx_pi_cnt_bin_d[0] = 0
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Dr_SET(r,d) (r).dsc_rx_pi_cnt_bin_d[0] = d
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Dr_GET(r) (r).dsc_rx_pi_cnt_bin_d[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_P1_DREGf_GET(r) ((((r).dsc_rx_pi_cnt_bin_d[0]) >> 8) & 0x7f)
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_P1_DREGf_SET(r,f) (r).dsc_rx_pi_cnt_bin_d[0]=(((r).dsc_rx_pi_cnt_bin_d[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8)) | (127 << (16 + 8))
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_D_DREGf_GET(r) (((r).dsc_rx_pi_cnt_bin_d[0]) & 0x7f)
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_D_DREGf_SET(r,f) (r).dsc_rx_pi_cnt_bin_d[0]=(((r).dsc_rx_pi_cnt_bin_d[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access DSC_RX_PI_CNT_BIN_D.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_RX_PI_CNT_BIN_Dr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Dr,(_r._dsc_rx_pi_cnt_bin_d))
#define BCMI_TSCE16_XGXS_WRITE_DSC_RX_PI_CNT_BIN_Dr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Dr,(_r._dsc_rx_pi_cnt_bin_d)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_Dr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Dr,(_r._dsc_rx_pi_cnt_bin_d))
#define BCMI_TSCE16_XGXS_READLN_DSC_RX_PI_CNT_BIN_Dr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Dr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_d))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_Dr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Dr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_d))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_Dr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Dr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_cnt_bin_d))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_CNT_BIN_Dr BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Dr
#define DSC_RX_PI_CNT_BIN_Dr_SIZE BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Dr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Dr_t DSC_RX_PI_CNT_BIN_Dr_t;
#define DSC_RX_PI_CNT_BIN_Dr_CLR BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Dr_CLR
#define DSC_RX_PI_CNT_BIN_Dr_SET BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Dr_SET
#define DSC_RX_PI_CNT_BIN_Dr_GET BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Dr_GET
#define DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_P1_DREGf_GET BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_P1_DREGf_GET
#define DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_P1_DREGf_SET BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_P1_DREGf_SET
#define DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_D_DREGf_GET BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_D_DREGf_GET
#define DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_D_DREGf_SET BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_D_DREGf_SET
#define READ_DSC_RX_PI_CNT_BIN_Dr BCMI_TSCE16_XGXS_READ_DSC_RX_PI_CNT_BIN_Dr
#define WRITE_DSC_RX_PI_CNT_BIN_Dr BCMI_TSCE16_XGXS_WRITE_DSC_RX_PI_CNT_BIN_Dr
#define MODIFY_DSC_RX_PI_CNT_BIN_Dr BCMI_TSCE16_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_Dr
#define READLN_DSC_RX_PI_CNT_BIN_Dr BCMI_TSCE16_XGXS_READLN_DSC_RX_PI_CNT_BIN_Dr
#define WRITELN_DSC_RX_PI_CNT_BIN_Dr BCMI_TSCE16_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_Dr
#define WRITEALL_DSC_RX_PI_CNT_BIN_Dr BCMI_TSCE16_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_Dr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Dr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_RX_PI_CNT_BIN_P
 * BLOCKS:   DSC_A
 * REGADDR:  0xd008
 * DESC:     Rx PI {M1, P1}
 * RESETVAL: 0x2000 (8192)
 * ACCESS:   R/O
 * FIELDS:
 *     CNT_BIN_P1_PREG  Slicer P1 location
 *     CNT_BIN_M1_PREG  Slicer M1 locationSee note for cnt_bin_p1_dreg in rx_pi_cnt_bin_d
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Pr (0x0000d008 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Pr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_CNT_BIN_P.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Pr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_cnt_bin_p[1];
	uint32_t _dsc_rx_pi_cnt_bin_p;
} BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Pr_t;

#define BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Pr_CLR(r) (r).dsc_rx_pi_cnt_bin_p[0] = 0
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Pr_SET(r,d) (r).dsc_rx_pi_cnt_bin_p[0] = d
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Pr_GET(r) (r).dsc_rx_pi_cnt_bin_p[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_M1_PREGf_GET(r) ((((r).dsc_rx_pi_cnt_bin_p[0]) >> 8) & 0x7f)
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_M1_PREGf_SET(r,f) (r).dsc_rx_pi_cnt_bin_p[0]=(((r).dsc_rx_pi_cnt_bin_p[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8)) | (127 << (16 + 8))
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_P1_PREGf_GET(r) (((r).dsc_rx_pi_cnt_bin_p[0]) & 0x7f)
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_P1_PREGf_SET(r,f) (r).dsc_rx_pi_cnt_bin_p[0]=(((r).dsc_rx_pi_cnt_bin_p[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access DSC_RX_PI_CNT_BIN_P.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_RX_PI_CNT_BIN_Pr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Pr,(_r._dsc_rx_pi_cnt_bin_p))
#define BCMI_TSCE16_XGXS_WRITE_DSC_RX_PI_CNT_BIN_Pr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Pr,(_r._dsc_rx_pi_cnt_bin_p)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_Pr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Pr,(_r._dsc_rx_pi_cnt_bin_p))
#define BCMI_TSCE16_XGXS_READLN_DSC_RX_PI_CNT_BIN_Pr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Pr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_p))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_Pr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Pr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_p))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_Pr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Pr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_cnt_bin_p))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_CNT_BIN_Pr BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Pr
#define DSC_RX_PI_CNT_BIN_Pr_SIZE BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Pr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Pr_t DSC_RX_PI_CNT_BIN_Pr_t;
#define DSC_RX_PI_CNT_BIN_Pr_CLR BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Pr_CLR
#define DSC_RX_PI_CNT_BIN_Pr_SET BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Pr_SET
#define DSC_RX_PI_CNT_BIN_Pr_GET BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Pr_GET
#define DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_M1_PREGf_GET BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_M1_PREGf_GET
#define DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_M1_PREGf_SET BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_M1_PREGf_SET
#define DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_P1_PREGf_GET BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_P1_PREGf_GET
#define DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_P1_PREGf_SET BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_P1_PREGf_SET
#define READ_DSC_RX_PI_CNT_BIN_Pr BCMI_TSCE16_XGXS_READ_DSC_RX_PI_CNT_BIN_Pr
#define WRITE_DSC_RX_PI_CNT_BIN_Pr BCMI_TSCE16_XGXS_WRITE_DSC_RX_PI_CNT_BIN_Pr
#define MODIFY_DSC_RX_PI_CNT_BIN_Pr BCMI_TSCE16_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_Pr
#define READLN_DSC_RX_PI_CNT_BIN_Pr BCMI_TSCE16_XGXS_READLN_DSC_RX_PI_CNT_BIN_Pr
#define WRITELN_DSC_RX_PI_CNT_BIN_Pr BCMI_TSCE16_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_Pr
#define WRITEALL_DSC_RX_PI_CNT_BIN_Pr BCMI_TSCE16_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_Pr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Pr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_RX_PI_CNT_BIN_M
 * BLOCKS:   DSC_A
 * REGADDR:  0xd009
 * DESC:     Rx PI {D, M1}
 * RESETVAL: 0x20 (32)
 * ACCESS:   R/O
 * FIELDS:
 *     CNT_BIN_M1_MREG  Slicer M1 location
 *     CNT_BIN_D_MREG   Slicer D locationSee note for cnt_bin_p1_dreg in rx_pi_cnt_bin_d
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Mr (0x0000d009 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Mr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_CNT_BIN_M.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Mr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_cnt_bin_m[1];
	uint32_t _dsc_rx_pi_cnt_bin_m;
} BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Mr_t;

#define BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Mr_CLR(r) (r).dsc_rx_pi_cnt_bin_m[0] = 0
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Mr_SET(r,d) (r).dsc_rx_pi_cnt_bin_m[0] = d
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Mr_GET(r) (r).dsc_rx_pi_cnt_bin_m[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Mr_CNT_BIN_D_MREGf_GET(r) ((((r).dsc_rx_pi_cnt_bin_m[0]) >> 8) & 0x7f)
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Mr_CNT_BIN_D_MREGf_SET(r,f) (r).dsc_rx_pi_cnt_bin_m[0]=(((r).dsc_rx_pi_cnt_bin_m[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8)) | (127 << (16 + 8))
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Mr_CNT_BIN_M1_MREGf_GET(r) (((r).dsc_rx_pi_cnt_bin_m[0]) & 0x7f)
#define BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Mr_CNT_BIN_M1_MREGf_SET(r,f) (r).dsc_rx_pi_cnt_bin_m[0]=(((r).dsc_rx_pi_cnt_bin_m[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access DSC_RX_PI_CNT_BIN_M.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_RX_PI_CNT_BIN_Mr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Mr,(_r._dsc_rx_pi_cnt_bin_m))
#define BCMI_TSCE16_XGXS_WRITE_DSC_RX_PI_CNT_BIN_Mr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Mr,(_r._dsc_rx_pi_cnt_bin_m)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_Mr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Mr,(_r._dsc_rx_pi_cnt_bin_m))
#define BCMI_TSCE16_XGXS_READLN_DSC_RX_PI_CNT_BIN_Mr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Mr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_m))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_Mr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Mr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_m))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_Mr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Mr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_cnt_bin_m))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_CNT_BIN_Mr BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Mr
#define DSC_RX_PI_CNT_BIN_Mr_SIZE BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Mr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Mr_t DSC_RX_PI_CNT_BIN_Mr_t;
#define DSC_RX_PI_CNT_BIN_Mr_CLR BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Mr_CLR
#define DSC_RX_PI_CNT_BIN_Mr_SET BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Mr_SET
#define DSC_RX_PI_CNT_BIN_Mr_GET BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Mr_GET
#define DSC_RX_PI_CNT_BIN_Mr_CNT_BIN_D_MREGf_GET BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Mr_CNT_BIN_D_MREGf_GET
#define DSC_RX_PI_CNT_BIN_Mr_CNT_BIN_D_MREGf_SET BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Mr_CNT_BIN_D_MREGf_SET
#define DSC_RX_PI_CNT_BIN_Mr_CNT_BIN_M1_MREGf_GET BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Mr_CNT_BIN_M1_MREGf_GET
#define DSC_RX_PI_CNT_BIN_Mr_CNT_BIN_M1_MREGf_SET BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Mr_CNT_BIN_M1_MREGf_SET
#define READ_DSC_RX_PI_CNT_BIN_Mr BCMI_TSCE16_XGXS_READ_DSC_RX_PI_CNT_BIN_Mr
#define WRITE_DSC_RX_PI_CNT_BIN_Mr BCMI_TSCE16_XGXS_WRITE_DSC_RX_PI_CNT_BIN_Mr
#define MODIFY_DSC_RX_PI_CNT_BIN_Mr BCMI_TSCE16_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_Mr
#define READLN_DSC_RX_PI_CNT_BIN_Mr BCMI_TSCE16_XGXS_READLN_DSC_RX_PI_CNT_BIN_Mr
#define WRITELN_DSC_RX_PI_CNT_BIN_Mr BCMI_TSCE16_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_Mr
#define WRITEALL_DSC_RX_PI_CNT_BIN_Mr BCMI_TSCE16_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_Mr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_RX_PI_CNT_BIN_Mr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_RX_PI_DIFF_BIN
 * BLOCKS:   DSC_A
 * REGADDR:  0xd00a
 * DESC:     Rx PI {D-P1, D-M1}
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CNT_D_MINUS_M1   Slicer D minus M1
 *     CNT_D_MINUS_P1   Slicer D minus P1
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_RX_PI_DIFF_BINr (0x0000d00a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_RX_PI_DIFF_BINr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_DIFF_BIN.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_RX_PI_DIFF_BINr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_diff_bin[1];
	uint32_t _dsc_rx_pi_diff_bin;
} BCMI_TSCE16_XGXS_DSC_RX_PI_DIFF_BINr_t;

#define BCMI_TSCE16_XGXS_DSC_RX_PI_DIFF_BINr_CLR(r) (r).dsc_rx_pi_diff_bin[0] = 0
#define BCMI_TSCE16_XGXS_DSC_RX_PI_DIFF_BINr_SET(r,d) (r).dsc_rx_pi_diff_bin[0] = d
#define BCMI_TSCE16_XGXS_DSC_RX_PI_DIFF_BINr_GET(r) (r).dsc_rx_pi_diff_bin[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_RX_PI_DIFF_BINr_CNT_D_MINUS_P1f_GET(r) ((((r).dsc_rx_pi_diff_bin[0]) >> 8) & 0xff)
#define BCMI_TSCE16_XGXS_DSC_RX_PI_DIFF_BINr_CNT_D_MINUS_P1f_SET(r,f) (r).dsc_rx_pi_diff_bin[0]=(((r).dsc_rx_pi_diff_bin[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCE16_XGXS_DSC_RX_PI_DIFF_BINr_CNT_D_MINUS_M1f_GET(r) (((r).dsc_rx_pi_diff_bin[0]) & 0xff)
#define BCMI_TSCE16_XGXS_DSC_RX_PI_DIFF_BINr_CNT_D_MINUS_M1f_SET(r,f) (r).dsc_rx_pi_diff_bin[0]=(((r).dsc_rx_pi_diff_bin[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_RX_PI_DIFF_BIN.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_RX_PI_DIFF_BINr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_RX_PI_DIFF_BINr,(_r._dsc_rx_pi_diff_bin))
#define BCMI_TSCE16_XGXS_WRITE_DSC_RX_PI_DIFF_BINr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_RX_PI_DIFF_BINr,(_r._dsc_rx_pi_diff_bin)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_RX_PI_DIFF_BINr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_RX_PI_DIFF_BINr,(_r._dsc_rx_pi_diff_bin))
#define BCMI_TSCE16_XGXS_READLN_DSC_RX_PI_DIFF_BINr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_RX_PI_DIFF_BINr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_diff_bin))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_RX_PI_DIFF_BINr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_RX_PI_DIFF_BINr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_diff_bin))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_RX_PI_DIFF_BINr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_RX_PI_DIFF_BINr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_diff_bin))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_DIFF_BINr BCMI_TSCE16_XGXS_DSC_RX_PI_DIFF_BINr
#define DSC_RX_PI_DIFF_BINr_SIZE BCMI_TSCE16_XGXS_DSC_RX_PI_DIFF_BINr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_RX_PI_DIFF_BINr_t DSC_RX_PI_DIFF_BINr_t;
#define DSC_RX_PI_DIFF_BINr_CLR BCMI_TSCE16_XGXS_DSC_RX_PI_DIFF_BINr_CLR
#define DSC_RX_PI_DIFF_BINr_SET BCMI_TSCE16_XGXS_DSC_RX_PI_DIFF_BINr_SET
#define DSC_RX_PI_DIFF_BINr_GET BCMI_TSCE16_XGXS_DSC_RX_PI_DIFF_BINr_GET
#define DSC_RX_PI_DIFF_BINr_CNT_D_MINUS_P1f_GET BCMI_TSCE16_XGXS_DSC_RX_PI_DIFF_BINr_CNT_D_MINUS_P1f_GET
#define DSC_RX_PI_DIFF_BINr_CNT_D_MINUS_P1f_SET BCMI_TSCE16_XGXS_DSC_RX_PI_DIFF_BINr_CNT_D_MINUS_P1f_SET
#define DSC_RX_PI_DIFF_BINr_CNT_D_MINUS_M1f_GET BCMI_TSCE16_XGXS_DSC_RX_PI_DIFF_BINr_CNT_D_MINUS_M1f_GET
#define DSC_RX_PI_DIFF_BINr_CNT_D_MINUS_M1f_SET BCMI_TSCE16_XGXS_DSC_RX_PI_DIFF_BINr_CNT_D_MINUS_M1f_SET
#define READ_DSC_RX_PI_DIFF_BINr BCMI_TSCE16_XGXS_READ_DSC_RX_PI_DIFF_BINr
#define WRITE_DSC_RX_PI_DIFF_BINr BCMI_TSCE16_XGXS_WRITE_DSC_RX_PI_DIFF_BINr
#define MODIFY_DSC_RX_PI_DIFF_BINr BCMI_TSCE16_XGXS_MODIFY_DSC_RX_PI_DIFF_BINr
#define READLN_DSC_RX_PI_DIFF_BINr BCMI_TSCE16_XGXS_READLN_DSC_RX_PI_DIFF_BINr
#define WRITELN_DSC_RX_PI_DIFF_BINr BCMI_TSCE16_XGXS_WRITELN_DSC_RX_PI_DIFF_BINr
#define WRITEALL_DSC_RX_PI_DIFF_BINr BCMI_TSCE16_XGXS_WRITEALL_DSC_RX_PI_DIFF_BINr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_RX_PI_DIFF_BINr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_TRNSUM_CTL5
 * BLOCKS:   DSC_A
 * REGADDR:  0xd00b
 * DESC:     training sum control 5
 * RESETVAL: 0x60 (96)
 * ACCESS:   R/W
 * FIELDS:
 *     TRNSUM_CLR_SC    Self Clearing bitWhen asserted, the trnsum accumulator clears.
 *     TRNSUM_DISABLE_SM_CLEAR When asserted,a pulse on uc_trnsum_en no longer clears the accumulator.
 *     TRNSUM_PATTERN_MATCH_SEL 0, 3: pattern matching on rx_data1: pattern matching on m1err2: pattern matching on expected prbs data
 *     TRNSUM_EYE_CLOSE_PREV_EN When 1, the first eye close event after previous 6 non-eye closure events is picked. The eye close condition settings need to be turned on for this setting to work.
 *     TRNSUM_PRBS_SEL  0: 2'b00, 0 is sent to the prbs accumulator1: 2'b01, odd trnsum is sent to the prbs acc2: 2'b10, even trnsum is sent to the prbs acc3: 2'b11, both are summed and sent to the prbs acc
 *     SWAP_LMS_M1      When set the m1 and p1 slicers from the AFE, get swapped for all down-stream logic. Lower priority than swap_lms_data.
 *     SWAP_LMS_DATA    When set the d and p1 slicers from the AFE, get swapped for all down-stream logic.
 *     TRNSUM_EYE_CLOSURE_ERR_SEL When trnsum_eye_closure_en is set, this field determines what is compared against d slicer. d!=error_selected , where error_selected is:2'b00: emux2'b01: m12'b10: p12'b11: expected prbs. The expected prbs needs the CDR to slip by pipeline_diff-2 bits. The pipeline_diff is the difference in the data coming to the trnsum vs the expected prbs bits coming from the prbs checker logic. The (-2) comes from the fact that the trnsum operates on a 2 bit shifted data per cycle to be able to 'look into the future'.
 *     EDGE_COUNT_REFLESS_EN When 1 this enables the edge counter. The edge counter assumes that the slicers are spaced 1/3rd UI apart. The trnsum accumulators accumulate the edge information. The even tap accumulates edges counted by 30 samples and odd accumulates the other 30. Math: 60 samples from 3 slicers in a rclk20 cycle. Max possible edges in 30 samples is <=11
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r (0x0000d00b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_CTL5.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_ctl5[1];
	uint32_t _dsc_trnsum_ctl5;
} BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_t;

#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_CLR(r) (r).dsc_trnsum_ctl5[0] = 0
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_SET(r,d) (r).dsc_trnsum_ctl5[0] = d
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_GET(r) (r).dsc_trnsum_ctl5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_EDGE_COUNT_REFLESS_ENf_GET(r) ((((r).dsc_trnsum_ctl5[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_EDGE_COUNT_REFLESS_ENf_SET(r,f) (r).dsc_trnsum_ctl5[0]=(((r).dsc_trnsum_ctl5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_TRNSUM_EYE_CLOSURE_ERR_SELf_GET(r) ((((r).dsc_trnsum_ctl5[0]) >> 12) & 0x3)
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_TRNSUM_EYE_CLOSURE_ERR_SELf_SET(r,f) (r).dsc_trnsum_ctl5[0]=(((r).dsc_trnsum_ctl5[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_SWAP_LMS_DATAf_GET(r) ((((r).dsc_trnsum_ctl5[0]) >> 11) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_SWAP_LMS_DATAf_SET(r,f) (r).dsc_trnsum_ctl5[0]=(((r).dsc_trnsum_ctl5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_SWAP_LMS_M1f_GET(r) ((((r).dsc_trnsum_ctl5[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_SWAP_LMS_M1f_SET(r,f) (r).dsc_trnsum_ctl5[0]=(((r).dsc_trnsum_ctl5[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_TRNSUM_PRBS_SELf_GET(r) ((((r).dsc_trnsum_ctl5[0]) >> 5) & 0x3)
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_TRNSUM_PRBS_SELf_SET(r,f) (r).dsc_trnsum_ctl5[0]=(((r).dsc_trnsum_ctl5[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5)) | (3 << (16 + 5))
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_TRNSUM_EYE_CLOSE_PREV_ENf_GET(r) ((((r).dsc_trnsum_ctl5[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_TRNSUM_EYE_CLOSE_PREV_ENf_SET(r,f) (r).dsc_trnsum_ctl5[0]=(((r).dsc_trnsum_ctl5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_TRNSUM_PATTERN_MATCH_SELf_GET(r) ((((r).dsc_trnsum_ctl5[0]) >> 2) & 0x3)
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_TRNSUM_PATTERN_MATCH_SELf_SET(r,f) (r).dsc_trnsum_ctl5[0]=(((r).dsc_trnsum_ctl5[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_TRNSUM_DISABLE_SM_CLEARf_GET(r) ((((r).dsc_trnsum_ctl5[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_TRNSUM_DISABLE_SM_CLEARf_SET(r,f) (r).dsc_trnsum_ctl5[0]=(((r).dsc_trnsum_ctl5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_TRNSUM_CLR_SCf_GET(r) (((r).dsc_trnsum_ctl5[0]) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_TRNSUM_CLR_SCf_SET(r,f) (r).dsc_trnsum_ctl5[0]=(((r).dsc_trnsum_ctl5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_TRNSUM_CTL5.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_TRNSUM_CTL5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r,(_r._dsc_trnsum_ctl5))
#define BCMI_TSCE16_XGXS_WRITE_DSC_TRNSUM_CTL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r,(_r._dsc_trnsum_ctl5)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_TRNSUM_CTL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r,(_r._dsc_trnsum_ctl5))
#define BCMI_TSCE16_XGXS_READLN_DSC_TRNSUM_CTL5r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_ctl5))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_TRNSUM_CTL5r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_ctl5))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_TRNSUM_CTL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_ctl5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_CTL5r BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r
#define DSC_TRNSUM_CTL5r_SIZE BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_SIZE
typedef BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_t DSC_TRNSUM_CTL5r_t;
#define DSC_TRNSUM_CTL5r_CLR BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_CLR
#define DSC_TRNSUM_CTL5r_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_SET
#define DSC_TRNSUM_CTL5r_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_GET
#define DSC_TRNSUM_CTL5r_EDGE_COUNT_REFLESS_ENf_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_EDGE_COUNT_REFLESS_ENf_GET
#define DSC_TRNSUM_CTL5r_EDGE_COUNT_REFLESS_ENf_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_EDGE_COUNT_REFLESS_ENf_SET
#define DSC_TRNSUM_CTL5r_TRNSUM_EYE_CLOSURE_ERR_SELf_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_TRNSUM_EYE_CLOSURE_ERR_SELf_GET
#define DSC_TRNSUM_CTL5r_TRNSUM_EYE_CLOSURE_ERR_SELf_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_TRNSUM_EYE_CLOSURE_ERR_SELf_SET
#define DSC_TRNSUM_CTL5r_SWAP_LMS_DATAf_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_SWAP_LMS_DATAf_GET
#define DSC_TRNSUM_CTL5r_SWAP_LMS_DATAf_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_SWAP_LMS_DATAf_SET
#define DSC_TRNSUM_CTL5r_SWAP_LMS_M1f_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_SWAP_LMS_M1f_GET
#define DSC_TRNSUM_CTL5r_SWAP_LMS_M1f_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_SWAP_LMS_M1f_SET
#define DSC_TRNSUM_CTL5r_TRNSUM_PRBS_SELf_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_TRNSUM_PRBS_SELf_GET
#define DSC_TRNSUM_CTL5r_TRNSUM_PRBS_SELf_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_TRNSUM_PRBS_SELf_SET
#define DSC_TRNSUM_CTL5r_TRNSUM_EYE_CLOSE_PREV_ENf_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_TRNSUM_EYE_CLOSE_PREV_ENf_GET
#define DSC_TRNSUM_CTL5r_TRNSUM_EYE_CLOSE_PREV_ENf_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_TRNSUM_EYE_CLOSE_PREV_ENf_SET
#define DSC_TRNSUM_CTL5r_TRNSUM_PATTERN_MATCH_SELf_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_TRNSUM_PATTERN_MATCH_SELf_GET
#define DSC_TRNSUM_CTL5r_TRNSUM_PATTERN_MATCH_SELf_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_TRNSUM_PATTERN_MATCH_SELf_SET
#define DSC_TRNSUM_CTL5r_TRNSUM_DISABLE_SM_CLEARf_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_TRNSUM_DISABLE_SM_CLEARf_GET
#define DSC_TRNSUM_CTL5r_TRNSUM_DISABLE_SM_CLEARf_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_TRNSUM_DISABLE_SM_CLEARf_SET
#define DSC_TRNSUM_CTL5r_TRNSUM_CLR_SCf_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_TRNSUM_CLR_SCf_GET
#define DSC_TRNSUM_CTL5r_TRNSUM_CLR_SCf_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r_TRNSUM_CLR_SCf_SET
#define READ_DSC_TRNSUM_CTL5r BCMI_TSCE16_XGXS_READ_DSC_TRNSUM_CTL5r
#define WRITE_DSC_TRNSUM_CTL5r BCMI_TSCE16_XGXS_WRITE_DSC_TRNSUM_CTL5r
#define MODIFY_DSC_TRNSUM_CTL5r BCMI_TSCE16_XGXS_MODIFY_DSC_TRNSUM_CTL5r
#define READLN_DSC_TRNSUM_CTL5r BCMI_TSCE16_XGXS_READLN_DSC_TRNSUM_CTL5r
#define WRITELN_DSC_TRNSUM_CTL5r BCMI_TSCE16_XGXS_WRITELN_DSC_TRNSUM_CTL5r
#define WRITEALL_DSC_TRNSUM_CTL5r BCMI_TSCE16_XGXS_WRITEALL_DSC_TRNSUM_CTL5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_UC_CTL
 * BLOCKS:   DSC_A
 * REGADDR:  0xd00d
 * DESC:     DSC uC Control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UC_DSC_GP_UC_REQ gp_uc request
 *     UC_DSC_ERROR_FOUND Error Found.
 *     UC_DSC_READY_FOR_CMD Ready for command.
 *     UC_DSC_SUPP_INFO Supplemental information.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_UC_CTLr (0x0000d00d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_UC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_UC_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_UC_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_uc_ctl[1];
	uint32_t _dsc_uc_ctl;
} BCMI_TSCE16_XGXS_DSC_UC_CTLr_t;

#define BCMI_TSCE16_XGXS_DSC_UC_CTLr_CLR(r) (r).dsc_uc_ctl[0] = 0
#define BCMI_TSCE16_XGXS_DSC_UC_CTLr_SET(r,d) (r).dsc_uc_ctl[0] = d
#define BCMI_TSCE16_XGXS_DSC_UC_CTLr_GET(r) (r).dsc_uc_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_UC_CTLr_UC_DSC_SUPP_INFOf_GET(r) ((((r).dsc_uc_ctl[0]) >> 8) & 0xff)
#define BCMI_TSCE16_XGXS_DSC_UC_CTLr_UC_DSC_SUPP_INFOf_SET(r,f) (r).dsc_uc_ctl[0]=(((r).dsc_uc_ctl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCE16_XGXS_DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_GET(r) ((((r).dsc_uc_ctl[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_SET(r,f) (r).dsc_uc_ctl[0]=(((r).dsc_uc_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_GET(r) ((((r).dsc_uc_ctl[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_SET(r,f) (r).dsc_uc_ctl[0]=(((r).dsc_uc_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_DSC_UC_CTLr_UC_DSC_GP_UC_REQf_GET(r) (((r).dsc_uc_ctl[0]) & 0x3f)
#define BCMI_TSCE16_XGXS_DSC_UC_CTLr_UC_DSC_GP_UC_REQf_SET(r,f) (r).dsc_uc_ctl[0]=(((r).dsc_uc_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_UC_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_UC_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_UC_CTLr,(_r._dsc_uc_ctl))
#define BCMI_TSCE16_XGXS_WRITE_DSC_UC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_UC_CTLr,(_r._dsc_uc_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_UC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_UC_CTLr,(_r._dsc_uc_ctl))
#define BCMI_TSCE16_XGXS_READLN_DSC_UC_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_UC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_uc_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_UC_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_UC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_uc_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_UC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_UC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_uc_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_UC_CTLr BCMI_TSCE16_XGXS_DSC_UC_CTLr
#define DSC_UC_CTLr_SIZE BCMI_TSCE16_XGXS_DSC_UC_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_UC_CTLr_t DSC_UC_CTLr_t;
#define DSC_UC_CTLr_CLR BCMI_TSCE16_XGXS_DSC_UC_CTLr_CLR
#define DSC_UC_CTLr_SET BCMI_TSCE16_XGXS_DSC_UC_CTLr_SET
#define DSC_UC_CTLr_GET BCMI_TSCE16_XGXS_DSC_UC_CTLr_GET
#define DSC_UC_CTLr_UC_DSC_SUPP_INFOf_GET BCMI_TSCE16_XGXS_DSC_UC_CTLr_UC_DSC_SUPP_INFOf_GET
#define DSC_UC_CTLr_UC_DSC_SUPP_INFOf_SET BCMI_TSCE16_XGXS_DSC_UC_CTLr_UC_DSC_SUPP_INFOf_SET
#define DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_GET BCMI_TSCE16_XGXS_DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_GET
#define DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_SET BCMI_TSCE16_XGXS_DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_SET
#define DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_GET BCMI_TSCE16_XGXS_DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_GET
#define DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_SET BCMI_TSCE16_XGXS_DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_SET
#define DSC_UC_CTLr_UC_DSC_GP_UC_REQf_GET BCMI_TSCE16_XGXS_DSC_UC_CTLr_UC_DSC_GP_UC_REQf_GET
#define DSC_UC_CTLr_UC_DSC_GP_UC_REQf_SET BCMI_TSCE16_XGXS_DSC_UC_CTLr_UC_DSC_GP_UC_REQf_SET
#define READ_DSC_UC_CTLr BCMI_TSCE16_XGXS_READ_DSC_UC_CTLr
#define WRITE_DSC_UC_CTLr BCMI_TSCE16_XGXS_WRITE_DSC_UC_CTLr
#define MODIFY_DSC_UC_CTLr BCMI_TSCE16_XGXS_MODIFY_DSC_UC_CTLr
#define READLN_DSC_UC_CTLr BCMI_TSCE16_XGXS_READLN_DSC_UC_CTLr
#define WRITELN_DSC_UC_CTLr BCMI_TSCE16_XGXS_WRITELN_DSC_UC_CTLr
#define WRITEALL_DSC_UC_CTLr BCMI_TSCE16_XGXS_WRITEALL_DSC_UC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_UC_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_SCRATCH
 * BLOCKS:   DSC_A
 * REGADDR:  0xd00e
 * DESC:     DSC uC Control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UC_DSC_SCRATCH   DSC scratch register.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_SCRATCHr (0x0000d00e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_SCRATCHr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SCRATCH.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_SCRATCHr_s {
	uint32_t v[1];
	uint32_t dsc_scratch[1];
	uint32_t _dsc_scratch;
} BCMI_TSCE16_XGXS_DSC_SCRATCHr_t;

#define BCMI_TSCE16_XGXS_DSC_SCRATCHr_CLR(r) (r).dsc_scratch[0] = 0
#define BCMI_TSCE16_XGXS_DSC_SCRATCHr_SET(r,d) (r).dsc_scratch[0] = d
#define BCMI_TSCE16_XGXS_DSC_SCRATCHr_GET(r) (r).dsc_scratch[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_SCRATCHr_UC_DSC_SCRATCHf_GET(r) (((r).dsc_scratch[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_DSC_SCRATCHr_UC_DSC_SCRATCHf_SET(r,f) (r).dsc_scratch[0]=(((r).dsc_scratch[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_SCRATCH.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_SCRATCHr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_SCRATCHr,(_r._dsc_scratch))
#define BCMI_TSCE16_XGXS_WRITE_DSC_SCRATCHr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SCRATCHr,(_r._dsc_scratch)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_SCRATCHr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SCRATCHr,(_r._dsc_scratch))
#define BCMI_TSCE16_XGXS_READLN_DSC_SCRATCHr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_SCRATCHr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_scratch))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_SCRATCHr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SCRATCHr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_scratch))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_SCRATCHr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SCRATCHr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_scratch))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SCRATCHr BCMI_TSCE16_XGXS_DSC_SCRATCHr
#define DSC_SCRATCHr_SIZE BCMI_TSCE16_XGXS_DSC_SCRATCHr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_SCRATCHr_t DSC_SCRATCHr_t;
#define DSC_SCRATCHr_CLR BCMI_TSCE16_XGXS_DSC_SCRATCHr_CLR
#define DSC_SCRATCHr_SET BCMI_TSCE16_XGXS_DSC_SCRATCHr_SET
#define DSC_SCRATCHr_GET BCMI_TSCE16_XGXS_DSC_SCRATCHr_GET
#define DSC_SCRATCHr_UC_DSC_SCRATCHf_GET BCMI_TSCE16_XGXS_DSC_SCRATCHr_UC_DSC_SCRATCHf_GET
#define DSC_SCRATCHr_UC_DSC_SCRATCHf_SET BCMI_TSCE16_XGXS_DSC_SCRATCHr_UC_DSC_SCRATCHf_SET
#define READ_DSC_SCRATCHr BCMI_TSCE16_XGXS_READ_DSC_SCRATCHr
#define WRITE_DSC_SCRATCHr BCMI_TSCE16_XGXS_WRITE_DSC_SCRATCHr
#define MODIFY_DSC_SCRATCHr BCMI_TSCE16_XGXS_MODIFY_DSC_SCRATCHr
#define READLN_DSC_SCRATCHr BCMI_TSCE16_XGXS_READLN_DSC_SCRATCHr
#define WRITELN_DSC_SCRATCHr BCMI_TSCE16_XGXS_WRITELN_DSC_SCRATCHr
#define WRITEALL_DSC_SCRATCHr BCMI_TSCE16_XGXS_WRITEALL_DSC_SCRATCHr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_SCRATCHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_SM_CTL0
 * BLOCKS:   DSC_B
 * REGADDR:  0xd010
 * DESC:     DSC STATE MACHINE CONTROL 0
 * RESETVAL: 0x8 (8)
 * ACCESS:   R/W
 * FIELDS:
 *     EEE_MODE_EN      1'b1 will enable the EEE mode.
 *     EEE_QUIET_RX_AFE_PWRDWN_VAL 1'b1 will enable the RX AFE powerdown in EEE_QUIET mode.
 *     IGNORE_RX_MODE   If set to 1'b1 then pmd_rx_mode input will be ignored in DSC SM.
 *     CL72_TIMER_EN    If enabled to 1'b1 then LFSR is loaded with 0x01CD else it is loaded with 0x1C1E for all non-EEE and non-MEASURE states.
 *     UC_TUNE_EN       uc_tune_en is used to move in and out of UC_TUNE state. Look for DSC SM state diagram for more details.
 *     HW_TUNE_EN       Should be 1'b1 along with uc_tune_en==1'b1 to move from UC_TUNE to HW_TUNE state.  This is a self-clear register bit.
 *     UC_TRNSUM_EN     1'b1 will move the state from UC_TUNE to MEASURE. This is a self-clear register bit.
 *     EEE_MEASURE_EN   1'b1 Enables the measurement during EEE_MEASURE.
 *     SLICER_CAL_DONE_CLEAR 1'b1 will clear the slicer_cal_done status register to 1'b0. This is a self-clear bit.
 *     SLICER_CAL_BYPASS 1'b1 will bypass the SLICER_CAL state.
 *     UC_ACK_DSC_EEE_DONE 1'b1 will enable the EEE_DONE to DONE transition. This is a self-clear bit.
 *     UC_ACK_DSC_RESTART 1'b1 will enable the RESTART to CONFIG transition. This is a self-clear bit.
 *     UC_ACK_DSC_CONFIG 1'b1 will enable the CONFIG to WAIT_FOR_SIG transition. This is a self-clear bit.
 *     SET_MEAS_INCOMPLETE 1'b1 will force meas_incomplete to be 1'b1 to start a new measurement in EEE mode. This is a self-clear bit.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_SM_CTL0r (0x0000d010 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_SM_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_SM_CTL0r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl0[1];
	uint32_t _dsc_sm_ctl0;
} BCMI_TSCE16_XGXS_DSC_SM_CTL0r_t;

#define BCMI_TSCE16_XGXS_DSC_SM_CTL0r_CLR(r) (r).dsc_sm_ctl0[0] = 0
#define BCMI_TSCE16_XGXS_DSC_SM_CTL0r_SET(r,d) (r).dsc_sm_ctl0[0] = d
#define BCMI_TSCE16_XGXS_DSC_SM_CTL0r_GET(r) (r).dsc_sm_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_SM_CTL0r_SET_MEAS_INCOMPLETEf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL0r_SET_MEAS_INCOMPLETEf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_CONFIGf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_CONFIGf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_RESTARTf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 13) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_RESTARTf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_EEE_DONEf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 11) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_EEE_DONEf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL0r_SLICER_CAL_BYPASSf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL0r_SLICER_CAL_BYPASSf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL0r_SLICER_CAL_DONE_CLEARf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL0r_SLICER_CAL_DONE_CLEARf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL0r_EEE_MEASURE_ENf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL0r_EEE_MEASURE_ENf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL0r_UC_TRNSUM_ENf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL0r_UC_TRNSUM_ENf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL0r_HW_TUNE_ENf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL0r_HW_TUNE_ENf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL0r_UC_TUNE_ENf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL0r_UC_TUNE_ENf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL0r_CL72_TIMER_ENf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL0r_CL72_TIMER_ENf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL0r_IGNORE_RX_MODEf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL0r_IGNORE_RX_MODEf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL0r_EEE_QUIET_RX_AFE_PWRDWN_VALf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL0r_EEE_QUIET_RX_AFE_PWRDWN_VALf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL0r_EEE_MODE_ENf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL0r_EEE_MODE_ENf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access DSC_SM_CTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_SM_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL0r,(_r._dsc_sm_ctl0))
#define BCMI_TSCE16_XGXS_WRITE_DSC_SM_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL0r,(_r._dsc_sm_ctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_SM_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL0r,(_r._dsc_sm_ctl0))
#define BCMI_TSCE16_XGXS_READLN_DSC_SM_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl0))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_SM_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_SM_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL0r BCMI_TSCE16_XGXS_DSC_SM_CTL0r
#define DSC_SM_CTL0r_SIZE BCMI_TSCE16_XGXS_DSC_SM_CTL0r_SIZE
typedef BCMI_TSCE16_XGXS_DSC_SM_CTL0r_t DSC_SM_CTL0r_t;
#define DSC_SM_CTL0r_CLR BCMI_TSCE16_XGXS_DSC_SM_CTL0r_CLR
#define DSC_SM_CTL0r_SET BCMI_TSCE16_XGXS_DSC_SM_CTL0r_SET
#define DSC_SM_CTL0r_GET BCMI_TSCE16_XGXS_DSC_SM_CTL0r_GET
#define DSC_SM_CTL0r_SET_MEAS_INCOMPLETEf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL0r_SET_MEAS_INCOMPLETEf_GET
#define DSC_SM_CTL0r_SET_MEAS_INCOMPLETEf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL0r_SET_MEAS_INCOMPLETEf_SET
#define DSC_SM_CTL0r_UC_ACK_DSC_CONFIGf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_CONFIGf_GET
#define DSC_SM_CTL0r_UC_ACK_DSC_CONFIGf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_CONFIGf_SET
#define DSC_SM_CTL0r_UC_ACK_DSC_RESTARTf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_RESTARTf_GET
#define DSC_SM_CTL0r_UC_ACK_DSC_RESTARTf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_RESTARTf_SET
#define DSC_SM_CTL0r_UC_ACK_DSC_EEE_DONEf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_EEE_DONEf_GET
#define DSC_SM_CTL0r_UC_ACK_DSC_EEE_DONEf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_EEE_DONEf_SET
#define DSC_SM_CTL0r_SLICER_CAL_BYPASSf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL0r_SLICER_CAL_BYPASSf_GET
#define DSC_SM_CTL0r_SLICER_CAL_BYPASSf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL0r_SLICER_CAL_BYPASSf_SET
#define DSC_SM_CTL0r_SLICER_CAL_DONE_CLEARf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL0r_SLICER_CAL_DONE_CLEARf_GET
#define DSC_SM_CTL0r_SLICER_CAL_DONE_CLEARf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL0r_SLICER_CAL_DONE_CLEARf_SET
#define DSC_SM_CTL0r_EEE_MEASURE_ENf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL0r_EEE_MEASURE_ENf_GET
#define DSC_SM_CTL0r_EEE_MEASURE_ENf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL0r_EEE_MEASURE_ENf_SET
#define DSC_SM_CTL0r_UC_TRNSUM_ENf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL0r_UC_TRNSUM_ENf_GET
#define DSC_SM_CTL0r_UC_TRNSUM_ENf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL0r_UC_TRNSUM_ENf_SET
#define DSC_SM_CTL0r_HW_TUNE_ENf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL0r_HW_TUNE_ENf_GET
#define DSC_SM_CTL0r_HW_TUNE_ENf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL0r_HW_TUNE_ENf_SET
#define DSC_SM_CTL0r_UC_TUNE_ENf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL0r_UC_TUNE_ENf_GET
#define DSC_SM_CTL0r_UC_TUNE_ENf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL0r_UC_TUNE_ENf_SET
#define DSC_SM_CTL0r_CL72_TIMER_ENf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL0r_CL72_TIMER_ENf_GET
#define DSC_SM_CTL0r_CL72_TIMER_ENf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL0r_CL72_TIMER_ENf_SET
#define DSC_SM_CTL0r_IGNORE_RX_MODEf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL0r_IGNORE_RX_MODEf_GET
#define DSC_SM_CTL0r_IGNORE_RX_MODEf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL0r_IGNORE_RX_MODEf_SET
#define DSC_SM_CTL0r_EEE_QUIET_RX_AFE_PWRDWN_VALf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL0r_EEE_QUIET_RX_AFE_PWRDWN_VALf_GET
#define DSC_SM_CTL0r_EEE_QUIET_RX_AFE_PWRDWN_VALf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL0r_EEE_QUIET_RX_AFE_PWRDWN_VALf_SET
#define DSC_SM_CTL0r_EEE_MODE_ENf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL0r_EEE_MODE_ENf_GET
#define DSC_SM_CTL0r_EEE_MODE_ENf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL0r_EEE_MODE_ENf_SET
#define READ_DSC_SM_CTL0r BCMI_TSCE16_XGXS_READ_DSC_SM_CTL0r
#define WRITE_DSC_SM_CTL0r BCMI_TSCE16_XGXS_WRITE_DSC_SM_CTL0r
#define MODIFY_DSC_SM_CTL0r BCMI_TSCE16_XGXS_MODIFY_DSC_SM_CTL0r
#define READLN_DSC_SM_CTL0r BCMI_TSCE16_XGXS_READLN_DSC_SM_CTL0r
#define WRITELN_DSC_SM_CTL0r BCMI_TSCE16_XGXS_WRITELN_DSC_SM_CTL0r
#define WRITEALL_DSC_SM_CTL0r BCMI_TSCE16_XGXS_WRITEALL_DSC_SM_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_SM_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_SM_CTL1
 * BLOCKS:   DSC_B
 * REGADDR:  0xd011
 * DESC:     DSC STATE MACHINE CONTROL 1
 * RESETVAL: 0x200 (512)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_DSC_LOCK_FRC  rx_dsc_lock force.
 *     RX_DSC_LOCK_FRC_VAL rx_dsc_lock force value.
 *     DSC_CLR_FRC      DSC clear force.
 *     DSC_CLR_FRC_VAL  DSC clear force value.
 *     TRNSUM_FRZ_FRC   Training Sum freeze force.
 *     TRNSUM_FRZ_FRC_VAL Training Sum freeze force value.
 *     TIMER_DONE_FRC   Can be forced to 1'b1 which will disable the H/W timer in HW_TUNE and MEASURE states.
 *     TIMER_DONE_FRC_VAL If timer_done_frc is set to 1'b1 and DSC SM is in HW_TUNE or MEASURE states then setting this bit to 1 will move the state to next state.
 *     FREQ_UPD_EN_FRC  Frequency update force.
 *     FREQ_UPD_EN_FRC_VAL Frequency update force value.
 *     CDR_FRZ_FRC      CDR Freeze force.
 *     CDR_FRZ_FRC_VAL  CDR Freeze force value.
 *     TRNSUM_CLR_FRC   Training Sum freeze force.
 *     TRNSUM_CLR_FRC_VAL raining Sum freeze force value.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_SM_CTL1r (0x0000d011 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_SM_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL1.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_SM_CTL1r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl1[1];
	uint32_t _dsc_sm_ctl1;
} BCMI_TSCE16_XGXS_DSC_SM_CTL1r_t;

#define BCMI_TSCE16_XGXS_DSC_SM_CTL1r_CLR(r) (r).dsc_sm_ctl1[0] = 0
#define BCMI_TSCE16_XGXS_DSC_SM_CTL1r_SET(r,d) (r).dsc_sm_ctl1[0] = d
#define BCMI_TSCE16_XGXS_DSC_SM_CTL1r_GET(r) (r).dsc_sm_ctl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_SM_CTL1r_TRNSUM_CLR_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 13) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL1r_TRNSUM_CLR_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL1r_TRNSUM_CLR_FRCf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 12) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL1r_TRNSUM_CLR_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL1r_CDR_FRZ_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 11) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL1r_CDR_FRZ_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL1r_CDR_FRZ_FRCf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL1r_CDR_FRZ_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL1r_FREQ_UPD_EN_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL1r_FREQ_UPD_EN_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL1r_FREQ_UPD_EN_FRCf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL1r_FREQ_UPD_EN_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL1r_TIMER_DONE_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL1r_TIMER_DONE_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL1r_TIMER_DONE_FRCf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL1r_TIMER_DONE_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL1r_TRNSUM_FRZ_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL1r_TRNSUM_FRZ_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL1r_TRNSUM_FRZ_FRCf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL1r_TRNSUM_FRZ_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL1r_DSC_CLR_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL1r_DSC_CLR_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL1r_DSC_CLR_FRCf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL1r_DSC_CLR_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_GET(r) (((r).dsc_sm_ctl1[0]) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_SM_CTL1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_SM_CTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL1r,(_r._dsc_sm_ctl1))
#define BCMI_TSCE16_XGXS_WRITE_DSC_SM_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL1r,(_r._dsc_sm_ctl1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_SM_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL1r,(_r._dsc_sm_ctl1))
#define BCMI_TSCE16_XGXS_READLN_DSC_SM_CTL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl1))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_SM_CTL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl1))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_SM_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL1r BCMI_TSCE16_XGXS_DSC_SM_CTL1r
#define DSC_SM_CTL1r_SIZE BCMI_TSCE16_XGXS_DSC_SM_CTL1r_SIZE
typedef BCMI_TSCE16_XGXS_DSC_SM_CTL1r_t DSC_SM_CTL1r_t;
#define DSC_SM_CTL1r_CLR BCMI_TSCE16_XGXS_DSC_SM_CTL1r_CLR
#define DSC_SM_CTL1r_SET BCMI_TSCE16_XGXS_DSC_SM_CTL1r_SET
#define DSC_SM_CTL1r_GET BCMI_TSCE16_XGXS_DSC_SM_CTL1r_GET
#define DSC_SM_CTL1r_TRNSUM_CLR_FRC_VALf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL1r_TRNSUM_CLR_FRC_VALf_GET
#define DSC_SM_CTL1r_TRNSUM_CLR_FRC_VALf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL1r_TRNSUM_CLR_FRC_VALf_SET
#define DSC_SM_CTL1r_TRNSUM_CLR_FRCf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL1r_TRNSUM_CLR_FRCf_GET
#define DSC_SM_CTL1r_TRNSUM_CLR_FRCf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL1r_TRNSUM_CLR_FRCf_SET
#define DSC_SM_CTL1r_CDR_FRZ_FRC_VALf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL1r_CDR_FRZ_FRC_VALf_GET
#define DSC_SM_CTL1r_CDR_FRZ_FRC_VALf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL1r_CDR_FRZ_FRC_VALf_SET
#define DSC_SM_CTL1r_CDR_FRZ_FRCf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL1r_CDR_FRZ_FRCf_GET
#define DSC_SM_CTL1r_CDR_FRZ_FRCf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL1r_CDR_FRZ_FRCf_SET
#define DSC_SM_CTL1r_FREQ_UPD_EN_FRC_VALf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL1r_FREQ_UPD_EN_FRC_VALf_GET
#define DSC_SM_CTL1r_FREQ_UPD_EN_FRC_VALf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL1r_FREQ_UPD_EN_FRC_VALf_SET
#define DSC_SM_CTL1r_FREQ_UPD_EN_FRCf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL1r_FREQ_UPD_EN_FRCf_GET
#define DSC_SM_CTL1r_FREQ_UPD_EN_FRCf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL1r_FREQ_UPD_EN_FRCf_SET
#define DSC_SM_CTL1r_TIMER_DONE_FRC_VALf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL1r_TIMER_DONE_FRC_VALf_GET
#define DSC_SM_CTL1r_TIMER_DONE_FRC_VALf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL1r_TIMER_DONE_FRC_VALf_SET
#define DSC_SM_CTL1r_TIMER_DONE_FRCf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL1r_TIMER_DONE_FRCf_GET
#define DSC_SM_CTL1r_TIMER_DONE_FRCf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL1r_TIMER_DONE_FRCf_SET
#define DSC_SM_CTL1r_TRNSUM_FRZ_FRC_VALf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL1r_TRNSUM_FRZ_FRC_VALf_GET
#define DSC_SM_CTL1r_TRNSUM_FRZ_FRC_VALf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL1r_TRNSUM_FRZ_FRC_VALf_SET
#define DSC_SM_CTL1r_TRNSUM_FRZ_FRCf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL1r_TRNSUM_FRZ_FRCf_GET
#define DSC_SM_CTL1r_TRNSUM_FRZ_FRCf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL1r_TRNSUM_FRZ_FRCf_SET
#define DSC_SM_CTL1r_DSC_CLR_FRC_VALf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL1r_DSC_CLR_FRC_VALf_GET
#define DSC_SM_CTL1r_DSC_CLR_FRC_VALf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL1r_DSC_CLR_FRC_VALf_SET
#define DSC_SM_CTL1r_DSC_CLR_FRCf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL1r_DSC_CLR_FRCf_GET
#define DSC_SM_CTL1r_DSC_CLR_FRCf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL1r_DSC_CLR_FRCf_SET
#define DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_GET
#define DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_SET
#define DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_GET
#define DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_SET
#define READ_DSC_SM_CTL1r BCMI_TSCE16_XGXS_READ_DSC_SM_CTL1r
#define WRITE_DSC_SM_CTL1r BCMI_TSCE16_XGXS_WRITE_DSC_SM_CTL1r
#define MODIFY_DSC_SM_CTL1r BCMI_TSCE16_XGXS_MODIFY_DSC_SM_CTL1r
#define READLN_DSC_SM_CTL1r BCMI_TSCE16_XGXS_READLN_DSC_SM_CTL1r
#define WRITELN_DSC_SM_CTL1r BCMI_TSCE16_XGXS_WRITELN_DSC_SM_CTL1r
#define WRITEALL_DSC_SM_CTL1r BCMI_TSCE16_XGXS_WRITEALL_DSC_SM_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_SM_CTL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_SM_CTL2
 * BLOCKS:   DSC_B
 * REGADDR:  0xd012
 * DESC:     DSC STATE MACHINE CONTROL 2
 * RESETVAL: 0x87 (135)
 * ACCESS:   R/W
 * FIELDS:
 *     EEE_LFSR_CNT     LFSR timer start value for all EEE timers except EEE_MEASURE. LFSR wraps after every 42 rclk20 clock cycles with this default value.For all non-EEE and non-MEASURE states, LFSR is loaded with 13'h1c1e when cl72_timer_en = 0 resulting into 2048 rclk20 clock cycles for LFSR wrap interval.For all non-EEE and non-MEASURE states, LFSR is loaded with 13'h01cd when cl72_timer_en = 1 resulting into 2192 rclk20 clock cycles for LFSR wrap interval.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_SM_CTL2r (0x0000d012 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_SM_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL2.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_SM_CTL2r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl2[1];
	uint32_t _dsc_sm_ctl2;
} BCMI_TSCE16_XGXS_DSC_SM_CTL2r_t;

#define BCMI_TSCE16_XGXS_DSC_SM_CTL2r_CLR(r) (r).dsc_sm_ctl2[0] = 0
#define BCMI_TSCE16_XGXS_DSC_SM_CTL2r_SET(r,d) (r).dsc_sm_ctl2[0] = d
#define BCMI_TSCE16_XGXS_DSC_SM_CTL2r_GET(r) (r).dsc_sm_ctl2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_SM_CTL2r_EEE_LFSR_CNTf_GET(r) (((r).dsc_sm_ctl2[0]) & 0x1fff)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL2r_EEE_LFSR_CNTf_SET(r,f) (r).dsc_sm_ctl2[0]=(((r).dsc_sm_ctl2[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access DSC_SM_CTL2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_SM_CTL2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL2r,(_r._dsc_sm_ctl2))
#define BCMI_TSCE16_XGXS_WRITE_DSC_SM_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL2r,(_r._dsc_sm_ctl2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_SM_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL2r,(_r._dsc_sm_ctl2))
#define BCMI_TSCE16_XGXS_READLN_DSC_SM_CTL2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl2))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_SM_CTL2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl2))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_SM_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL2r BCMI_TSCE16_XGXS_DSC_SM_CTL2r
#define DSC_SM_CTL2r_SIZE BCMI_TSCE16_XGXS_DSC_SM_CTL2r_SIZE
typedef BCMI_TSCE16_XGXS_DSC_SM_CTL2r_t DSC_SM_CTL2r_t;
#define DSC_SM_CTL2r_CLR BCMI_TSCE16_XGXS_DSC_SM_CTL2r_CLR
#define DSC_SM_CTL2r_SET BCMI_TSCE16_XGXS_DSC_SM_CTL2r_SET
#define DSC_SM_CTL2r_GET BCMI_TSCE16_XGXS_DSC_SM_CTL2r_GET
#define DSC_SM_CTL2r_EEE_LFSR_CNTf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL2r_EEE_LFSR_CNTf_GET
#define DSC_SM_CTL2r_EEE_LFSR_CNTf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL2r_EEE_LFSR_CNTf_SET
#define READ_DSC_SM_CTL2r BCMI_TSCE16_XGXS_READ_DSC_SM_CTL2r
#define WRITE_DSC_SM_CTL2r BCMI_TSCE16_XGXS_WRITE_DSC_SM_CTL2r
#define MODIFY_DSC_SM_CTL2r BCMI_TSCE16_XGXS_MODIFY_DSC_SM_CTL2r
#define READLN_DSC_SM_CTL2r BCMI_TSCE16_XGXS_READLN_DSC_SM_CTL2r
#define WRITELN_DSC_SM_CTL2r BCMI_TSCE16_XGXS_WRITELN_DSC_SM_CTL2r
#define WRITEALL_DSC_SM_CTL2r BCMI_TSCE16_XGXS_WRITEALL_DSC_SM_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_SM_CTL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_SM_CTL3
 * BLOCKS:   DSC_B
 * REGADDR:  0xd013
 * DESC:     DSC STATE MACHINE CONTROL 3
 * RESETVAL: 0x1c1e (7198)
 * ACCESS:   R/W
 * FIELDS:
 *     MEASURE_LFSR_CNT LFSR timer start value for MEASURE and EEE_MEASURE state timers. LFSR wraps after every 2048 rclk20 clock cycles with this default value.For all non-EEE and non-MEASURE states, LFSR is loaded with 13'h1c1e when cl72_timer_en = 0 resulting into 2048 rclk20 clock cycles for LFSR wrap interval.For all non-EEE and non-MEASURE states, LFSR is loaded with 13'h01cd when cl72_timer_en = 1 resulting into 2192 rclk20 clock cycles for LFSR wrap interval.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_SM_CTL3r (0x0000d013 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_SM_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL3.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_SM_CTL3r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl3[1];
	uint32_t _dsc_sm_ctl3;
} BCMI_TSCE16_XGXS_DSC_SM_CTL3r_t;

#define BCMI_TSCE16_XGXS_DSC_SM_CTL3r_CLR(r) (r).dsc_sm_ctl3[0] = 0
#define BCMI_TSCE16_XGXS_DSC_SM_CTL3r_SET(r,d) (r).dsc_sm_ctl3[0] = d
#define BCMI_TSCE16_XGXS_DSC_SM_CTL3r_GET(r) (r).dsc_sm_ctl3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_SM_CTL3r_MEASURE_LFSR_CNTf_GET(r) (((r).dsc_sm_ctl3[0]) & 0x1fff)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL3r_MEASURE_LFSR_CNTf_SET(r,f) (r).dsc_sm_ctl3[0]=(((r).dsc_sm_ctl3[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access DSC_SM_CTL3.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_SM_CTL3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL3r,(_r._dsc_sm_ctl3))
#define BCMI_TSCE16_XGXS_WRITE_DSC_SM_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL3r,(_r._dsc_sm_ctl3)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_SM_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL3r,(_r._dsc_sm_ctl3))
#define BCMI_TSCE16_XGXS_READLN_DSC_SM_CTL3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl3))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_SM_CTL3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl3))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_SM_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL3r BCMI_TSCE16_XGXS_DSC_SM_CTL3r
#define DSC_SM_CTL3r_SIZE BCMI_TSCE16_XGXS_DSC_SM_CTL3r_SIZE
typedef BCMI_TSCE16_XGXS_DSC_SM_CTL3r_t DSC_SM_CTL3r_t;
#define DSC_SM_CTL3r_CLR BCMI_TSCE16_XGXS_DSC_SM_CTL3r_CLR
#define DSC_SM_CTL3r_SET BCMI_TSCE16_XGXS_DSC_SM_CTL3r_SET
#define DSC_SM_CTL3r_GET BCMI_TSCE16_XGXS_DSC_SM_CTL3r_GET
#define DSC_SM_CTL3r_MEASURE_LFSR_CNTf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL3r_MEASURE_LFSR_CNTf_GET
#define DSC_SM_CTL3r_MEASURE_LFSR_CNTf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL3r_MEASURE_LFSR_CNTf_SET
#define READ_DSC_SM_CTL3r BCMI_TSCE16_XGXS_READ_DSC_SM_CTL3r
#define WRITE_DSC_SM_CTL3r BCMI_TSCE16_XGXS_WRITE_DSC_SM_CTL3r
#define MODIFY_DSC_SM_CTL3r BCMI_TSCE16_XGXS_MODIFY_DSC_SM_CTL3r
#define READLN_DSC_SM_CTL3r BCMI_TSCE16_XGXS_READLN_DSC_SM_CTL3r
#define WRITELN_DSC_SM_CTL3r BCMI_TSCE16_XGXS_WRITELN_DSC_SM_CTL3r
#define WRITEALL_DSC_SM_CTL3r BCMI_TSCE16_XGXS_WRITEALL_DSC_SM_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_SM_CTL3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_SM_CTL4
 * BLOCKS:   DSC_B
 * REGADDR:  0xd014
 * DESC:     DSC STATE MACHINE CONTROL 4
 * RESETVAL: 0x35ad (13741)
 * ACCESS:   R/W
 * FIELDS:
 *     ACQ_CDR_TIMEOUT  Defines timeout value for the ACQ_CDR state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.Following is the mapping table for the 5 bit timeout register values to 0-448 count. This mapping is applicable to all the DSC_SM timeout registers.0      =>           01      =>           12      =>           23      =>           34      =>           45      =>           56      =>           67      =>           78      =>           89      =>          1010      =>          1211      =>          1412      =>          1613      =>          2014      =>          2415      =>          2816      =>          3217      =>          4018      =>          4819      =>          5620      =>          6421      =>          8022      =>          9623      =>         11224      =>         12825      =>         16026      =>         19227      =>         22428      =>         25629      =>         32030      =>         38431      =>         448
 *     CDR_SETTLE_TIMEOUT Defines timeout value for the CDR_SETTLE state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 *     HW_TUNE_TIMEOUT  Defines timeout value for the HW_TUNE state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_SM_CTL4r (0x0000d014 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_SM_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL4.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_SM_CTL4r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl4[1];
	uint32_t _dsc_sm_ctl4;
} BCMI_TSCE16_XGXS_DSC_SM_CTL4r_t;

#define BCMI_TSCE16_XGXS_DSC_SM_CTL4r_CLR(r) (r).dsc_sm_ctl4[0] = 0
#define BCMI_TSCE16_XGXS_DSC_SM_CTL4r_SET(r,d) (r).dsc_sm_ctl4[0] = d
#define BCMI_TSCE16_XGXS_DSC_SM_CTL4r_GET(r) (r).dsc_sm_ctl4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_SM_CTL4r_HW_TUNE_TIMEOUTf_GET(r) ((((r).dsc_sm_ctl4[0]) >> 10) & 0x1f)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL4r_HW_TUNE_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl4[0]=(((r).dsc_sm_ctl4[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL4r_CDR_SETTLE_TIMEOUTf_GET(r) ((((r).dsc_sm_ctl4[0]) >> 5) & 0x1f)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL4r_CDR_SETTLE_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl4[0]=(((r).dsc_sm_ctl4[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL4r_ACQ_CDR_TIMEOUTf_GET(r) (((r).dsc_sm_ctl4[0]) & 0x1f)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL4r_ACQ_CDR_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl4[0]=(((r).dsc_sm_ctl4[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_SM_CTL4.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_SM_CTL4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL4r,(_r._dsc_sm_ctl4))
#define BCMI_TSCE16_XGXS_WRITE_DSC_SM_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL4r,(_r._dsc_sm_ctl4)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_SM_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL4r,(_r._dsc_sm_ctl4))
#define BCMI_TSCE16_XGXS_READLN_DSC_SM_CTL4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl4))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_SM_CTL4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl4))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_SM_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL4r BCMI_TSCE16_XGXS_DSC_SM_CTL4r
#define DSC_SM_CTL4r_SIZE BCMI_TSCE16_XGXS_DSC_SM_CTL4r_SIZE
typedef BCMI_TSCE16_XGXS_DSC_SM_CTL4r_t DSC_SM_CTL4r_t;
#define DSC_SM_CTL4r_CLR BCMI_TSCE16_XGXS_DSC_SM_CTL4r_CLR
#define DSC_SM_CTL4r_SET BCMI_TSCE16_XGXS_DSC_SM_CTL4r_SET
#define DSC_SM_CTL4r_GET BCMI_TSCE16_XGXS_DSC_SM_CTL4r_GET
#define DSC_SM_CTL4r_HW_TUNE_TIMEOUTf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL4r_HW_TUNE_TIMEOUTf_GET
#define DSC_SM_CTL4r_HW_TUNE_TIMEOUTf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL4r_HW_TUNE_TIMEOUTf_SET
#define DSC_SM_CTL4r_CDR_SETTLE_TIMEOUTf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL4r_CDR_SETTLE_TIMEOUTf_GET
#define DSC_SM_CTL4r_CDR_SETTLE_TIMEOUTf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL4r_CDR_SETTLE_TIMEOUTf_SET
#define DSC_SM_CTL4r_ACQ_CDR_TIMEOUTf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL4r_ACQ_CDR_TIMEOUTf_GET
#define DSC_SM_CTL4r_ACQ_CDR_TIMEOUTf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL4r_ACQ_CDR_TIMEOUTf_SET
#define READ_DSC_SM_CTL4r BCMI_TSCE16_XGXS_READ_DSC_SM_CTL4r
#define WRITE_DSC_SM_CTL4r BCMI_TSCE16_XGXS_WRITE_DSC_SM_CTL4r
#define MODIFY_DSC_SM_CTL4r BCMI_TSCE16_XGXS_MODIFY_DSC_SM_CTL4r
#define READLN_DSC_SM_CTL4r BCMI_TSCE16_XGXS_READLN_DSC_SM_CTL4r
#define WRITELN_DSC_SM_CTL4r BCMI_TSCE16_XGXS_WRITELN_DSC_SM_CTL4r
#define WRITEALL_DSC_SM_CTL4r BCMI_TSCE16_XGXS_WRITEALL_DSC_SM_CTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_SM_CTL4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_SM_CTL5
 * BLOCKS:   DSC_B
 * REGADDR:  0xd015
 * DESC:     DSC STATE MACHINE CONTROL 5
 * RESETVAL: 0x35ad (13741)
 * ACCESS:   R/W
 * FIELDS:
 *     MEASURE_TIMEOUT  Defines timeout value for the MEASURE state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 *     EEE_ACQ_CDR_TIMEOUT Defines timeout value for the EEE_ACQ_CDR state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 *     EEE_CDR_SETTLE_TIMEOUT Defines timeout value for the EEE_CDR_SETTLE state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_SM_CTL5r (0x0000d015 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_SM_CTL5r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL5.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_SM_CTL5r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl5[1];
	uint32_t _dsc_sm_ctl5;
} BCMI_TSCE16_XGXS_DSC_SM_CTL5r_t;

#define BCMI_TSCE16_XGXS_DSC_SM_CTL5r_CLR(r) (r).dsc_sm_ctl5[0] = 0
#define BCMI_TSCE16_XGXS_DSC_SM_CTL5r_SET(r,d) (r).dsc_sm_ctl5[0] = d
#define BCMI_TSCE16_XGXS_DSC_SM_CTL5r_GET(r) (r).dsc_sm_ctl5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_SM_CTL5r_EEE_CDR_SETTLE_TIMEOUTf_GET(r) ((((r).dsc_sm_ctl5[0]) >> 10) & 0x1f)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL5r_EEE_CDR_SETTLE_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl5[0]=(((r).dsc_sm_ctl5[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL5r_EEE_ACQ_CDR_TIMEOUTf_GET(r) ((((r).dsc_sm_ctl5[0]) >> 5) & 0x1f)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL5r_EEE_ACQ_CDR_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl5[0]=(((r).dsc_sm_ctl5[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL5r_MEASURE_TIMEOUTf_GET(r) (((r).dsc_sm_ctl5[0]) & 0x1f)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL5r_MEASURE_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl5[0]=(((r).dsc_sm_ctl5[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_SM_CTL5.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_SM_CTL5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL5r,(_r._dsc_sm_ctl5))
#define BCMI_TSCE16_XGXS_WRITE_DSC_SM_CTL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL5r,(_r._dsc_sm_ctl5)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_SM_CTL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL5r,(_r._dsc_sm_ctl5))
#define BCMI_TSCE16_XGXS_READLN_DSC_SM_CTL5r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl5))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_SM_CTL5r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl5))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_SM_CTL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL5r BCMI_TSCE16_XGXS_DSC_SM_CTL5r
#define DSC_SM_CTL5r_SIZE BCMI_TSCE16_XGXS_DSC_SM_CTL5r_SIZE
typedef BCMI_TSCE16_XGXS_DSC_SM_CTL5r_t DSC_SM_CTL5r_t;
#define DSC_SM_CTL5r_CLR BCMI_TSCE16_XGXS_DSC_SM_CTL5r_CLR
#define DSC_SM_CTL5r_SET BCMI_TSCE16_XGXS_DSC_SM_CTL5r_SET
#define DSC_SM_CTL5r_GET BCMI_TSCE16_XGXS_DSC_SM_CTL5r_GET
#define DSC_SM_CTL5r_EEE_CDR_SETTLE_TIMEOUTf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL5r_EEE_CDR_SETTLE_TIMEOUTf_GET
#define DSC_SM_CTL5r_EEE_CDR_SETTLE_TIMEOUTf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL5r_EEE_CDR_SETTLE_TIMEOUTf_SET
#define DSC_SM_CTL5r_EEE_ACQ_CDR_TIMEOUTf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL5r_EEE_ACQ_CDR_TIMEOUTf_GET
#define DSC_SM_CTL5r_EEE_ACQ_CDR_TIMEOUTf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL5r_EEE_ACQ_CDR_TIMEOUTf_SET
#define DSC_SM_CTL5r_MEASURE_TIMEOUTf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL5r_MEASURE_TIMEOUTf_GET
#define DSC_SM_CTL5r_MEASURE_TIMEOUTf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL5r_MEASURE_TIMEOUTf_SET
#define READ_DSC_SM_CTL5r BCMI_TSCE16_XGXS_READ_DSC_SM_CTL5r
#define WRITE_DSC_SM_CTL5r BCMI_TSCE16_XGXS_WRITE_DSC_SM_CTL5r
#define MODIFY_DSC_SM_CTL5r BCMI_TSCE16_XGXS_MODIFY_DSC_SM_CTL5r
#define READLN_DSC_SM_CTL5r BCMI_TSCE16_XGXS_READLN_DSC_SM_CTL5r
#define WRITELN_DSC_SM_CTL5r BCMI_TSCE16_XGXS_WRITELN_DSC_SM_CTL5r
#define WRITEALL_DSC_SM_CTL5r BCMI_TSCE16_XGXS_WRITEALL_DSC_SM_CTL5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_SM_CTL5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_SM_CTL6
 * BLOCKS:   DSC_B
 * REGADDR:  0xd016
 * DESC:     DSC STATE MACHINE CONTROL 6
 * RESETVAL: 0x340d (13325)
 * ACCESS:   R/W
 * FIELDS:
 *     EEE_HW_TUNE_TIMEOUT Defines timeout value for the EEE_HW_TUNE state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 *     SLICER_CAL_TIMEOUT Defines timeout value for the SLICER_CAL state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps. Total time spent in SLICER_CAL is 8*(slicer_cal_timeout timer) .
 *     EEE_ANA_PWR_TIMEOUT Defines timeout value for the EEE_ANA_PWR state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_SM_CTL6r (0x0000d016 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_SM_CTL6r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL6.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_SM_CTL6r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl6[1];
	uint32_t _dsc_sm_ctl6;
} BCMI_TSCE16_XGXS_DSC_SM_CTL6r_t;

#define BCMI_TSCE16_XGXS_DSC_SM_CTL6r_CLR(r) (r).dsc_sm_ctl6[0] = 0
#define BCMI_TSCE16_XGXS_DSC_SM_CTL6r_SET(r,d) (r).dsc_sm_ctl6[0] = d
#define BCMI_TSCE16_XGXS_DSC_SM_CTL6r_GET(r) (r).dsc_sm_ctl6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_SM_CTL6r_EEE_ANA_PWR_TIMEOUTf_GET(r) ((((r).dsc_sm_ctl6[0]) >> 10) & 0x1f)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL6r_EEE_ANA_PWR_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl6[0]=(((r).dsc_sm_ctl6[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL6r_SLICER_CAL_TIMEOUTf_GET(r) ((((r).dsc_sm_ctl6[0]) >> 5) & 0x1f)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL6r_SLICER_CAL_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl6[0]=(((r).dsc_sm_ctl6[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL6r_EEE_HW_TUNE_TIMEOUTf_GET(r) (((r).dsc_sm_ctl6[0]) & 0x1f)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL6r_EEE_HW_TUNE_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl6[0]=(((r).dsc_sm_ctl6[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_SM_CTL6.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_SM_CTL6r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL6r,(_r._dsc_sm_ctl6))
#define BCMI_TSCE16_XGXS_WRITE_DSC_SM_CTL6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL6r,(_r._dsc_sm_ctl6)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_SM_CTL6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL6r,(_r._dsc_sm_ctl6))
#define BCMI_TSCE16_XGXS_READLN_DSC_SM_CTL6r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl6))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_SM_CTL6r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl6))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_SM_CTL6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL6r BCMI_TSCE16_XGXS_DSC_SM_CTL6r
#define DSC_SM_CTL6r_SIZE BCMI_TSCE16_XGXS_DSC_SM_CTL6r_SIZE
typedef BCMI_TSCE16_XGXS_DSC_SM_CTL6r_t DSC_SM_CTL6r_t;
#define DSC_SM_CTL6r_CLR BCMI_TSCE16_XGXS_DSC_SM_CTL6r_CLR
#define DSC_SM_CTL6r_SET BCMI_TSCE16_XGXS_DSC_SM_CTL6r_SET
#define DSC_SM_CTL6r_GET BCMI_TSCE16_XGXS_DSC_SM_CTL6r_GET
#define DSC_SM_CTL6r_EEE_ANA_PWR_TIMEOUTf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL6r_EEE_ANA_PWR_TIMEOUTf_GET
#define DSC_SM_CTL6r_EEE_ANA_PWR_TIMEOUTf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL6r_EEE_ANA_PWR_TIMEOUTf_SET
#define DSC_SM_CTL6r_SLICER_CAL_TIMEOUTf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL6r_SLICER_CAL_TIMEOUTf_GET
#define DSC_SM_CTL6r_SLICER_CAL_TIMEOUTf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL6r_SLICER_CAL_TIMEOUTf_SET
#define DSC_SM_CTL6r_EEE_HW_TUNE_TIMEOUTf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL6r_EEE_HW_TUNE_TIMEOUTf_GET
#define DSC_SM_CTL6r_EEE_HW_TUNE_TIMEOUTf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL6r_EEE_HW_TUNE_TIMEOUTf_SET
#define READ_DSC_SM_CTL6r BCMI_TSCE16_XGXS_READ_DSC_SM_CTL6r
#define WRITE_DSC_SM_CTL6r BCMI_TSCE16_XGXS_WRITE_DSC_SM_CTL6r
#define MODIFY_DSC_SM_CTL6r BCMI_TSCE16_XGXS_MODIFY_DSC_SM_CTL6r
#define READLN_DSC_SM_CTL6r BCMI_TSCE16_XGXS_READLN_DSC_SM_CTL6r
#define WRITELN_DSC_SM_CTL6r BCMI_TSCE16_XGXS_WRITELN_DSC_SM_CTL6r
#define WRITEALL_DSC_SM_CTL6r BCMI_TSCE16_XGXS_WRITEALL_DSC_SM_CTL6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_SM_CTL6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_SM_CTL7
 * BLOCKS:   DSC_B
 * REGADDR:  0xd017
 * DESC:     DSC STATE MACHINE CONTROL 7
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CDR_BWSEL_INTEG_ACQCDR CDR Integ Bandwidth select for ACQ_CDR state.{0->4} <=> 2^{0->4}. {13,14,15} <=> {2^{-3,-2,-1}}.
 *     CDR_BWSEL_INTEG_EEE_ACQCDR CDR Integ Bandwidth select for EEE_ACQ_CDR state.{0->4} <=> 2^{0->4}. {13,14,15} <=> {2^{-3,-2,-1}}.
 *     CDR_BWSEL_INTEG_NORM CDR Integ Bandwidth select for non ACQ_CDR and EEE_ACQ_CDR states.{0->4} <=> 2^{0->4}. {13,14,15} <=> {2^{-3,-2,-1}}.
 *     CDR_BWSEL_PROP_ACQCDR CDR Proportional Bandwidth select for ACQ_CDR state.{0, 1, 2} map to {2^1, 2^2, 2^0}2^2 has a user beware attached to it. Use is when max number of edges per rclk20 * osx2p_pherr_gain are guaranteed to be < 15
 *     CDR_BWSEL_PROP_NORM CDR Proportional Bandwidth select for non ACQ_CDR and EEE_ACQ_CDR states.{0, 1, 2} map to {2^1, 2^2, 2^0}2^2 has a user beware attached to it. Use is when max number of edges per rclk20 * osx2p_pherr_gain are guaranteed to be < 15
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_SM_CTL7r (0x0000d017 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_SM_CTL7r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL7.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_SM_CTL7r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl7[1];
	uint32_t _dsc_sm_ctl7;
} BCMI_TSCE16_XGXS_DSC_SM_CTL7r_t;

#define BCMI_TSCE16_XGXS_DSC_SM_CTL7r_CLR(r) (r).dsc_sm_ctl7[0] = 0
#define BCMI_TSCE16_XGXS_DSC_SM_CTL7r_SET(r,d) (r).dsc_sm_ctl7[0] = d
#define BCMI_TSCE16_XGXS_DSC_SM_CTL7r_GET(r) (r).dsc_sm_ctl7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_SM_CTL7r_CDR_BWSEL_PROP_NORMf_GET(r) ((((r).dsc_sm_ctl7[0]) >> 14) & 0x3)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL7r_CDR_BWSEL_PROP_NORMf_SET(r,f) (r).dsc_sm_ctl7[0]=(((r).dsc_sm_ctl7[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL7r_CDR_BWSEL_PROP_ACQCDRf_GET(r) ((((r).dsc_sm_ctl7[0]) >> 12) & 0x3)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL7r_CDR_BWSEL_PROP_ACQCDRf_SET(r,f) (r).dsc_sm_ctl7[0]=(((r).dsc_sm_ctl7[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_NORMf_GET(r) ((((r).dsc_sm_ctl7[0]) >> 8) & 0xf)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_NORMf_SET(r,f) (r).dsc_sm_ctl7[0]=(((r).dsc_sm_ctl7[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_EEE_ACQCDRf_GET(r) ((((r).dsc_sm_ctl7[0]) >> 4) & 0xf)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_EEE_ACQCDRf_SET(r,f) (r).dsc_sm_ctl7[0]=(((r).dsc_sm_ctl7[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_ACQCDRf_GET(r) (((r).dsc_sm_ctl7[0]) & 0xf)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_ACQCDRf_SET(r,f) (r).dsc_sm_ctl7[0]=(((r).dsc_sm_ctl7[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_SM_CTL7.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_SM_CTL7r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL7r,(_r._dsc_sm_ctl7))
#define BCMI_TSCE16_XGXS_WRITE_DSC_SM_CTL7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL7r,(_r._dsc_sm_ctl7)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_SM_CTL7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL7r,(_r._dsc_sm_ctl7))
#define BCMI_TSCE16_XGXS_READLN_DSC_SM_CTL7r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl7))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_SM_CTL7r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl7))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_SM_CTL7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL7r BCMI_TSCE16_XGXS_DSC_SM_CTL7r
#define DSC_SM_CTL7r_SIZE BCMI_TSCE16_XGXS_DSC_SM_CTL7r_SIZE
typedef BCMI_TSCE16_XGXS_DSC_SM_CTL7r_t DSC_SM_CTL7r_t;
#define DSC_SM_CTL7r_CLR BCMI_TSCE16_XGXS_DSC_SM_CTL7r_CLR
#define DSC_SM_CTL7r_SET BCMI_TSCE16_XGXS_DSC_SM_CTL7r_SET
#define DSC_SM_CTL7r_GET BCMI_TSCE16_XGXS_DSC_SM_CTL7r_GET
#define DSC_SM_CTL7r_CDR_BWSEL_PROP_NORMf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL7r_CDR_BWSEL_PROP_NORMf_GET
#define DSC_SM_CTL7r_CDR_BWSEL_PROP_NORMf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL7r_CDR_BWSEL_PROP_NORMf_SET
#define DSC_SM_CTL7r_CDR_BWSEL_PROP_ACQCDRf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL7r_CDR_BWSEL_PROP_ACQCDRf_GET
#define DSC_SM_CTL7r_CDR_BWSEL_PROP_ACQCDRf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL7r_CDR_BWSEL_PROP_ACQCDRf_SET
#define DSC_SM_CTL7r_CDR_BWSEL_INTEG_NORMf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_NORMf_GET
#define DSC_SM_CTL7r_CDR_BWSEL_INTEG_NORMf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_NORMf_SET
#define DSC_SM_CTL7r_CDR_BWSEL_INTEG_EEE_ACQCDRf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_EEE_ACQCDRf_GET
#define DSC_SM_CTL7r_CDR_BWSEL_INTEG_EEE_ACQCDRf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_EEE_ACQCDRf_SET
#define DSC_SM_CTL7r_CDR_BWSEL_INTEG_ACQCDRf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_ACQCDRf_GET
#define DSC_SM_CTL7r_CDR_BWSEL_INTEG_ACQCDRf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_ACQCDRf_SET
#define READ_DSC_SM_CTL7r BCMI_TSCE16_XGXS_READ_DSC_SM_CTL7r
#define WRITE_DSC_SM_CTL7r BCMI_TSCE16_XGXS_WRITE_DSC_SM_CTL7r
#define MODIFY_DSC_SM_CTL7r BCMI_TSCE16_XGXS_MODIFY_DSC_SM_CTL7r
#define READLN_DSC_SM_CTL7r BCMI_TSCE16_XGXS_READLN_DSC_SM_CTL7r
#define WRITELN_DSC_SM_CTL7r BCMI_TSCE16_XGXS_WRITELN_DSC_SM_CTL7r
#define WRITEALL_DSC_SM_CTL7r BCMI_TSCE16_XGXS_WRITEALL_DSC_SM_CTL7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_SM_CTL7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_SM_CTL8
 * BLOCKS:   DSC_B
 * REGADDR:  0xd018
 * DESC:     DSC STATE MACHINE CONTROL 8
 * RESETVAL: 0x11 (17)
 * ACCESS:   R/W
 * FIELDS:
 *     PHASE_ERR_OFFSET Phase Error Offset for non-EEE_ACQ_CDR states. Signed value. Valid range is -8 to 7. This translates to either -8/2 to 7/2 or -8/4 to 7/4, depending on how rg_phase_err_offset_mult_2 is set. By default is is -8/4 to 7/4 adding into VCO reg.
 *     EEE_PHASE_ERR_OFFSET Phase Error Offset for EEE_ACQ_CDR state. Signed value. Valid range is -8 to 7.
 *     PHASE_ERR_OFFSET_EN Phase Error Offset Enable for non-EEE_ACQ_CDR states.
 *     EEE_PHASE_ERR_OFFSET_EN Phase Error Offset Enable for EEE_ACQ_CDR state.
 *     CDR_BWSEL_PROP_EEE_ACQCDR CDR Proportional Bandwidth select for EEE_ACQ_CDR state.{0, 1, 2} map to {2^1, 2^2, 2^0}2^2 has a user beware attached to it. Use is when max number of edges per rclk20 * osx2p_pherr_gain are guaranteed to be < 15
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_SM_CTL8r (0x0000d018 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_SM_CTL8r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL8.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_SM_CTL8r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl8[1];
	uint32_t _dsc_sm_ctl8;
} BCMI_TSCE16_XGXS_DSC_SM_CTL8r_t;

#define BCMI_TSCE16_XGXS_DSC_SM_CTL8r_CLR(r) (r).dsc_sm_ctl8[0] = 0
#define BCMI_TSCE16_XGXS_DSC_SM_CTL8r_SET(r,d) (r).dsc_sm_ctl8[0] = d
#define BCMI_TSCE16_XGXS_DSC_SM_CTL8r_GET(r) (r).dsc_sm_ctl8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_SM_CTL8r_CDR_BWSEL_PROP_EEE_ACQCDRf_GET(r) ((((r).dsc_sm_ctl8[0]) >> 14) & 0x3)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL8r_CDR_BWSEL_PROP_EEE_ACQCDRf_SET(r,f) (r).dsc_sm_ctl8[0]=(((r).dsc_sm_ctl8[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSET_ENf_GET(r) ((((r).dsc_sm_ctl8[0]) >> 10) & 0x3)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSET_ENf_SET(r,f) (r).dsc_sm_ctl8[0]=(((r).dsc_sm_ctl8[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL8r_PHASE_ERR_OFFSET_ENf_GET(r) ((((r).dsc_sm_ctl8[0]) >> 8) & 0x3)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL8r_PHASE_ERR_OFFSET_ENf_SET(r,f) (r).dsc_sm_ctl8[0]=(((r).dsc_sm_ctl8[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSETf_GET(r) ((((r).dsc_sm_ctl8[0]) >> 4) & 0xf)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSETf_SET(r,f) (r).dsc_sm_ctl8[0]=(((r).dsc_sm_ctl8[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL8r_PHASE_ERR_OFFSETf_GET(r) (((r).dsc_sm_ctl8[0]) & 0xf)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL8r_PHASE_ERR_OFFSETf_SET(r,f) (r).dsc_sm_ctl8[0]=(((r).dsc_sm_ctl8[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_SM_CTL8.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_SM_CTL8r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL8r,(_r._dsc_sm_ctl8))
#define BCMI_TSCE16_XGXS_WRITE_DSC_SM_CTL8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL8r,(_r._dsc_sm_ctl8)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_SM_CTL8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL8r,(_r._dsc_sm_ctl8))
#define BCMI_TSCE16_XGXS_READLN_DSC_SM_CTL8r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl8))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_SM_CTL8r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl8))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_SM_CTL8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL8r BCMI_TSCE16_XGXS_DSC_SM_CTL8r
#define DSC_SM_CTL8r_SIZE BCMI_TSCE16_XGXS_DSC_SM_CTL8r_SIZE
typedef BCMI_TSCE16_XGXS_DSC_SM_CTL8r_t DSC_SM_CTL8r_t;
#define DSC_SM_CTL8r_CLR BCMI_TSCE16_XGXS_DSC_SM_CTL8r_CLR
#define DSC_SM_CTL8r_SET BCMI_TSCE16_XGXS_DSC_SM_CTL8r_SET
#define DSC_SM_CTL8r_GET BCMI_TSCE16_XGXS_DSC_SM_CTL8r_GET
#define DSC_SM_CTL8r_CDR_BWSEL_PROP_EEE_ACQCDRf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL8r_CDR_BWSEL_PROP_EEE_ACQCDRf_GET
#define DSC_SM_CTL8r_CDR_BWSEL_PROP_EEE_ACQCDRf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL8r_CDR_BWSEL_PROP_EEE_ACQCDRf_SET
#define DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSET_ENf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSET_ENf_GET
#define DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSET_ENf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSET_ENf_SET
#define DSC_SM_CTL8r_PHASE_ERR_OFFSET_ENf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL8r_PHASE_ERR_OFFSET_ENf_GET
#define DSC_SM_CTL8r_PHASE_ERR_OFFSET_ENf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL8r_PHASE_ERR_OFFSET_ENf_SET
#define DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSETf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSETf_GET
#define DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSETf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSETf_SET
#define DSC_SM_CTL8r_PHASE_ERR_OFFSETf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL8r_PHASE_ERR_OFFSETf_GET
#define DSC_SM_CTL8r_PHASE_ERR_OFFSETf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL8r_PHASE_ERR_OFFSETf_SET
#define READ_DSC_SM_CTL8r BCMI_TSCE16_XGXS_READ_DSC_SM_CTL8r
#define WRITE_DSC_SM_CTL8r BCMI_TSCE16_XGXS_WRITE_DSC_SM_CTL8r
#define MODIFY_DSC_SM_CTL8r BCMI_TSCE16_XGXS_MODIFY_DSC_SM_CTL8r
#define READLN_DSC_SM_CTL8r BCMI_TSCE16_XGXS_READLN_DSC_SM_CTL8r
#define WRITELN_DSC_SM_CTL8r BCMI_TSCE16_XGXS_WRITELN_DSC_SM_CTL8r
#define WRITEALL_DSC_SM_CTL8r BCMI_TSCE16_XGXS_WRITEALL_DSC_SM_CTL8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_SM_CTL8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_SM_CTL9
 * BLOCKS:   DSC_B
 * REGADDR:  0xd019
 * DESC:     DSC STATE MACHINE CONTROL 9
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_RESTART_PMD   1'b1 will reset the DSC SM into RESTART state. This is a self-clear register bit.
 *     RX_RESTART_PMD_HOLD 1'b1 will reset the DSC SM into RESTART state and HOLD it there until set to 1'b0.
 *     DCOFF_CAL_TIMEOUT Defines timeout value for the DCOFF_CAL state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_SM_CTL9r (0x0000d019 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_SM_CTL9r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL9.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_SM_CTL9r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl9[1];
	uint32_t _dsc_sm_ctl9;
} BCMI_TSCE16_XGXS_DSC_SM_CTL9r_t;

#define BCMI_TSCE16_XGXS_DSC_SM_CTL9r_CLR(r) (r).dsc_sm_ctl9[0] = 0
#define BCMI_TSCE16_XGXS_DSC_SM_CTL9r_SET(r,d) (r).dsc_sm_ctl9[0] = d
#define BCMI_TSCE16_XGXS_DSC_SM_CTL9r_GET(r) (r).dsc_sm_ctl9[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_SM_CTL9r_DCOFF_CAL_TIMEOUTf_GET(r) ((((r).dsc_sm_ctl9[0]) >> 10) & 0x1f)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL9r_DCOFF_CAL_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl9[0]=(((r).dsc_sm_ctl9[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_GET(r) ((((r).dsc_sm_ctl9[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_SET(r,f) (r).dsc_sm_ctl9[0]=(((r).dsc_sm_ctl9[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_DSC_SM_CTL9r_RX_RESTART_PMDf_GET(r) (((r).dsc_sm_ctl9[0]) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_CTL9r_RX_RESTART_PMDf_SET(r,f) (r).dsc_sm_ctl9[0]=(((r).dsc_sm_ctl9[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_SM_CTL9.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_SM_CTL9r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL9r,(_r._dsc_sm_ctl9))
#define BCMI_TSCE16_XGXS_WRITE_DSC_SM_CTL9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL9r,(_r._dsc_sm_ctl9)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_SM_CTL9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL9r,(_r._dsc_sm_ctl9))
#define BCMI_TSCE16_XGXS_READLN_DSC_SM_CTL9r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl9))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_SM_CTL9r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl9))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_SM_CTL9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl9))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL9r BCMI_TSCE16_XGXS_DSC_SM_CTL9r
#define DSC_SM_CTL9r_SIZE BCMI_TSCE16_XGXS_DSC_SM_CTL9r_SIZE
typedef BCMI_TSCE16_XGXS_DSC_SM_CTL9r_t DSC_SM_CTL9r_t;
#define DSC_SM_CTL9r_CLR BCMI_TSCE16_XGXS_DSC_SM_CTL9r_CLR
#define DSC_SM_CTL9r_SET BCMI_TSCE16_XGXS_DSC_SM_CTL9r_SET
#define DSC_SM_CTL9r_GET BCMI_TSCE16_XGXS_DSC_SM_CTL9r_GET
#define DSC_SM_CTL9r_DCOFF_CAL_TIMEOUTf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL9r_DCOFF_CAL_TIMEOUTf_GET
#define DSC_SM_CTL9r_DCOFF_CAL_TIMEOUTf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL9r_DCOFF_CAL_TIMEOUTf_SET
#define DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_GET
#define DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_SET
#define DSC_SM_CTL9r_RX_RESTART_PMDf_GET BCMI_TSCE16_XGXS_DSC_SM_CTL9r_RX_RESTART_PMDf_GET
#define DSC_SM_CTL9r_RX_RESTART_PMDf_SET BCMI_TSCE16_XGXS_DSC_SM_CTL9r_RX_RESTART_PMDf_SET
#define READ_DSC_SM_CTL9r BCMI_TSCE16_XGXS_READ_DSC_SM_CTL9r
#define WRITE_DSC_SM_CTL9r BCMI_TSCE16_XGXS_WRITE_DSC_SM_CTL9r
#define MODIFY_DSC_SM_CTL9r BCMI_TSCE16_XGXS_MODIFY_DSC_SM_CTL9r
#define READLN_DSC_SM_CTL9r BCMI_TSCE16_XGXS_READLN_DSC_SM_CTL9r
#define WRITELN_DSC_SM_CTL9r BCMI_TSCE16_XGXS_WRITELN_DSC_SM_CTL9r
#define WRITEALL_DSC_SM_CTL9r BCMI_TSCE16_XGXS_WRITEALL_DSC_SM_CTL9r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_SM_CTL9r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_SM_STS_DSC_LOCK
 * BLOCKS:   DSC_B
 * REGADDR:  0xd01a
 * DESC:     DSC STATE MACHINE DSC_LOCK STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_DSC_LOCK      1 indicates that DSC is locked.
 *     MEAS_INCOMPLETE  1 indicates that measurement is incomplete. 0 indicates that measurement is complete.
 *     SLICER_CAL_DONE  Status register which is set to 1'b1 upon successful completion of SLICER_CAL state and transition from SLICER_CAL state to WAIT_FOR_SIG state.This also gets cleared upon DSC_SM block reset (i.e. datapath reset).
 *     EEE_MEASURE_CNT  Indicates the eee_measure_cnt status. This is a debug register.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr (0x0000d01a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_STS_DSC_LOCK.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr_s {
	uint32_t v[1];
	uint32_t dsc_sm_sts_dsc_lock[1];
	uint32_t _dsc_sm_sts_dsc_lock;
} BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr_t;

#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr_CLR(r) (r).dsc_sm_sts_dsc_lock[0] = 0
#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr_SET(r,d) (r).dsc_sm_sts_dsc_lock[0] = d
#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr_GET(r) (r).dsc_sm_sts_dsc_lock[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr_EEE_MEASURE_CNTf_GET(r) ((((r).dsc_sm_sts_dsc_lock[0]) >> 7) & 0x1ff)
#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr_EEE_MEASURE_CNTf_SET(r,f) (r).dsc_sm_sts_dsc_lock[0]=(((r).dsc_sm_sts_dsc_lock[0] & ~((uint32_t)0x1ff << 7)) | ((((uint32_t)f) & 0x1ff) << 7)) | (511 << (16 + 7))
#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr_SLICER_CAL_DONEf_GET(r) ((((r).dsc_sm_sts_dsc_lock[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr_SLICER_CAL_DONEf_SET(r,f) (r).dsc_sm_sts_dsc_lock[0]=(((r).dsc_sm_sts_dsc_lock[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr_MEAS_INCOMPLETEf_GET(r) ((((r).dsc_sm_sts_dsc_lock[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr_MEAS_INCOMPLETEf_SET(r,f) (r).dsc_sm_sts_dsc_lock[0]=(((r).dsc_sm_sts_dsc_lock[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr_RX_DSC_LOCKf_GET(r) (((r).dsc_sm_sts_dsc_lock[0]) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr_RX_DSC_LOCKf_SET(r,f) (r).dsc_sm_sts_dsc_lock[0]=(((r).dsc_sm_sts_dsc_lock[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_SM_STS_DSC_LOCK.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_SM_STS_DSC_LOCKr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr,(_r._dsc_sm_sts_dsc_lock))
#define BCMI_TSCE16_XGXS_WRITE_DSC_SM_STS_DSC_LOCKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr,(_r._dsc_sm_sts_dsc_lock)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_SM_STS_DSC_LOCKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr,(_r._dsc_sm_sts_dsc_lock))
#define BCMI_TSCE16_XGXS_READLN_DSC_SM_STS_DSC_LOCKr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_lock))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_SM_STS_DSC_LOCKr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_lock))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_SM_STS_DSC_LOCKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_sts_dsc_lock))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_STS_DSC_LOCKr BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr
#define DSC_SM_STS_DSC_LOCKr_SIZE BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr_t DSC_SM_STS_DSC_LOCKr_t;
#define DSC_SM_STS_DSC_LOCKr_CLR BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr_CLR
#define DSC_SM_STS_DSC_LOCKr_SET BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr_SET
#define DSC_SM_STS_DSC_LOCKr_GET BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr_GET
#define DSC_SM_STS_DSC_LOCKr_EEE_MEASURE_CNTf_GET BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr_EEE_MEASURE_CNTf_GET
#define DSC_SM_STS_DSC_LOCKr_EEE_MEASURE_CNTf_SET BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr_EEE_MEASURE_CNTf_SET
#define DSC_SM_STS_DSC_LOCKr_SLICER_CAL_DONEf_GET BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr_SLICER_CAL_DONEf_GET
#define DSC_SM_STS_DSC_LOCKr_SLICER_CAL_DONEf_SET BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr_SLICER_CAL_DONEf_SET
#define DSC_SM_STS_DSC_LOCKr_MEAS_INCOMPLETEf_GET BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr_MEAS_INCOMPLETEf_GET
#define DSC_SM_STS_DSC_LOCKr_MEAS_INCOMPLETEf_SET BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr_MEAS_INCOMPLETEf_SET
#define DSC_SM_STS_DSC_LOCKr_RX_DSC_LOCKf_GET BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr_RX_DSC_LOCKf_GET
#define DSC_SM_STS_DSC_LOCKr_RX_DSC_LOCKf_SET BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr_RX_DSC_LOCKf_SET
#define READ_DSC_SM_STS_DSC_LOCKr BCMI_TSCE16_XGXS_READ_DSC_SM_STS_DSC_LOCKr
#define WRITE_DSC_SM_STS_DSC_LOCKr BCMI_TSCE16_XGXS_WRITE_DSC_SM_STS_DSC_LOCKr
#define MODIFY_DSC_SM_STS_DSC_LOCKr BCMI_TSCE16_XGXS_MODIFY_DSC_SM_STS_DSC_LOCKr
#define READLN_DSC_SM_STS_DSC_LOCKr BCMI_TSCE16_XGXS_READLN_DSC_SM_STS_DSC_LOCKr
#define WRITELN_DSC_SM_STS_DSC_LOCKr BCMI_TSCE16_XGXS_WRITELN_DSC_SM_STS_DSC_LOCKr
#define WRITEALL_DSC_SM_STS_DSC_LOCKr BCMI_TSCE16_XGXS_WRITEALL_DSC_SM_STS_DSC_LOCKr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_LOCKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_SM_STS_DSC_ST_ONE_HOT
 * BLOCKS:   DSC_B
 * REGADDR:  0xd01b
 * DESC:     DSC STATE MACHINE STATUS ONE HOT
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DSC_STATE_ONE_HOT Sticky one-hot coded states. These registers are cleared on read.RESET           =  0RESTART         =  1CONFIG          =  2WAIT_FOR_SIG    =  3ACQ_CDR         =  4CDR_SETTLE      =  5HW_TUNE         =  6UC_TUNE         =  7MEASURE         =  8DONE            =  9SLICER_CAL      =  10DCOFF_CAL       =  11
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr (0x0000d01b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_STS_DSC_ST_ONE_HOT.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_s {
	uint32_t v[1];
	uint32_t dsc_sm_sts_dsc_st_one_hot[1];
	uint32_t _dsc_sm_sts_dsc_st_one_hot;
} BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_t;

#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_CLR(r) (r).dsc_sm_sts_dsc_st_one_hot[0] = 0
#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_SET(r,d) (r).dsc_sm_sts_dsc_st_one_hot[0] = d
#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_GET(r) (r).dsc_sm_sts_dsc_st_one_hot[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_GET(r) (((r).dsc_sm_sts_dsc_st_one_hot[0]) & 0xfff)
#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_SET(r,f) (r).dsc_sm_sts_dsc_st_one_hot[0]=(((r).dsc_sm_sts_dsc_st_one_hot[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff)) | (0xfff << 16)

/*
 * These macros can be used to access DSC_SM_STS_DSC_ST_ONE_HOT.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_SM_STS_DSC_ST_ONE_HOTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr,(_r._dsc_sm_sts_dsc_st_one_hot))
#define BCMI_TSCE16_XGXS_WRITE_DSC_SM_STS_DSC_ST_ONE_HOTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr,(_r._dsc_sm_sts_dsc_st_one_hot)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_SM_STS_DSC_ST_ONE_HOTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr,(_r._dsc_sm_sts_dsc_st_one_hot))
#define BCMI_TSCE16_XGXS_READLN_DSC_SM_STS_DSC_ST_ONE_HOTr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_st_one_hot))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_SM_STS_DSC_ST_ONE_HOTr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_st_one_hot))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_SM_STS_DSC_ST_ONE_HOTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_sts_dsc_st_one_hot))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr
#define DSC_SM_STS_DSC_ST_ONE_HOTr_SIZE BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_t DSC_SM_STS_DSC_ST_ONE_HOTr_t;
#define DSC_SM_STS_DSC_ST_ONE_HOTr_CLR BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_CLR
#define DSC_SM_STS_DSC_ST_ONE_HOTr_SET BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_SET
#define DSC_SM_STS_DSC_ST_ONE_HOTr_GET BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_GET
#define DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_GET BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_GET
#define DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_SET BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_SET
#define READ_DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_TSCE16_XGXS_READ_DSC_SM_STS_DSC_ST_ONE_HOTr
#define WRITE_DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_TSCE16_XGXS_WRITE_DSC_SM_STS_DSC_ST_ONE_HOTr
#define MODIFY_DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_TSCE16_XGXS_MODIFY_DSC_SM_STS_DSC_ST_ONE_HOTr
#define READLN_DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_TSCE16_XGXS_READLN_DSC_SM_STS_DSC_ST_ONE_HOTr
#define WRITELN_DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_TSCE16_XGXS_WRITELN_DSC_SM_STS_DSC_ST_ONE_HOTr
#define WRITEALL_DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_TSCE16_XGXS_WRITEALL_DSC_SM_STS_DSC_ST_ONE_HOTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_SM_STS_DSC_ST_EEE_ONE_HOT
 * BLOCKS:   DSC_B
 * REGADDR:  0xd01c
 * DESC:     DSC STATE MACHINE STATUS EEE ONE HOT
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DSC_STATE_EEE_ONE_HOT Sticky one-hot coded EEE state . These registers are cleared on read.EEE_QUIET       =  0EEE_ANA_PWR     =  1EEE_ACQ_CDR     =  2EEE_CDR_SETTLE  =  3EEE_HW_TUNE     =  4EEE_MEASURE     =  5EEE_DONE        =  6
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr (0x0000d01c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_STS_DSC_ST_EEE_ONE_HOT.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_s {
	uint32_t v[1];
	uint32_t dsc_sm_sts_dsc_st_eee_one_hot[1];
	uint32_t _dsc_sm_sts_dsc_st_eee_one_hot;
} BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_t;

#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_CLR(r) (r).dsc_sm_sts_dsc_st_eee_one_hot[0] = 0
#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_SET(r,d) (r).dsc_sm_sts_dsc_st_eee_one_hot[0] = d
#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_GET(r) (r).dsc_sm_sts_dsc_st_eee_one_hot[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_DSC_STATE_EEE_ONE_HOTf_GET(r) (((r).dsc_sm_sts_dsc_st_eee_one_hot[0]) & 0x7f)
#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_DSC_STATE_EEE_ONE_HOTf_SET(r,f) (r).dsc_sm_sts_dsc_st_eee_one_hot[0]=(((r).dsc_sm_sts_dsc_st_eee_one_hot[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access DSC_SM_STS_DSC_ST_EEE_ONE_HOT.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr,(_r._dsc_sm_sts_dsc_st_eee_one_hot))
#define BCMI_TSCE16_XGXS_WRITE_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr,(_r._dsc_sm_sts_dsc_st_eee_one_hot)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr,(_r._dsc_sm_sts_dsc_st_eee_one_hot))
#define BCMI_TSCE16_XGXS_READLN_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_st_eee_one_hot))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_st_eee_one_hot))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_sts_dsc_st_eee_one_hot))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_STS_DSC_ST_EEE_ONE_HOTr BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr
#define DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_SIZE BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_t DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_t;
#define DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_CLR BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_CLR
#define DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_SET BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_SET
#define DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_GET BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_GET
#define DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_DSC_STATE_EEE_ONE_HOTf_GET BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_DSC_STATE_EEE_ONE_HOTf_GET
#define DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_DSC_STATE_EEE_ONE_HOTf_SET BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_DSC_STATE_EEE_ONE_HOTf_SET
#define READ_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr BCMI_TSCE16_XGXS_READ_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr
#define WRITE_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr BCMI_TSCE16_XGXS_WRITE_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr
#define MODIFY_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr BCMI_TSCE16_XGXS_MODIFY_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr
#define READLN_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr BCMI_TSCE16_XGXS_READLN_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr
#define WRITELN_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr BCMI_TSCE16_XGXS_WRITELN_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr
#define WRITEALL_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr BCMI_TSCE16_XGXS_WRITEALL_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_SM_STS_RESTART
 * BLOCKS:   DSC_B
 * REGADDR:  0xd01d
 * DESC:     DSC STATE MACHINE STATUS RESTART
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RESTART_PI_EXT_MODE Indicates when SM moves to RESTART state due to enabling of RX_PI external control (i.e. digital loopback enable). This is clear on read.
 *     RESTART_SIGDET   Indicates when SM moves to RESTART state due to sigdet==0 and eee_mode_en register is 1'b0. This is clear on read.
 *     RESTART_PMD_RESTART Indicates when SM moves to RESTART state due to assertion of pmd_restart to 1'b1. This is clear on read.
 *     EEE_QUIET_FROM_EEE_STATES Indicates when SM moves from any EEE states to EEE_QUIET state. This is clear on read.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr (0x0000d01d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_STS_RESTART.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr_s {
	uint32_t v[1];
	uint32_t dsc_sm_sts_restart[1];
	uint32_t _dsc_sm_sts_restart;
} BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr_t;

#define BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr_CLR(r) (r).dsc_sm_sts_restart[0] = 0
#define BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr_SET(r,d) (r).dsc_sm_sts_restart[0] = d
#define BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr_GET(r) (r).dsc_sm_sts_restart[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr_EEE_QUIET_FROM_EEE_STATESf_GET(r) ((((r).dsc_sm_sts_restart[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr_EEE_QUIET_FROM_EEE_STATESf_SET(r,f) (r).dsc_sm_sts_restart[0]=(((r).dsc_sm_sts_restart[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr_RESTART_PMD_RESTARTf_GET(r) ((((r).dsc_sm_sts_restart[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr_RESTART_PMD_RESTARTf_SET(r,f) (r).dsc_sm_sts_restart[0]=(((r).dsc_sm_sts_restart[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr_RESTART_SIGDETf_GET(r) ((((r).dsc_sm_sts_restart[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr_RESTART_SIGDETf_SET(r,f) (r).dsc_sm_sts_restart[0]=(((r).dsc_sm_sts_restart[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr_RESTART_PI_EXT_MODEf_GET(r) (((r).dsc_sm_sts_restart[0]) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr_RESTART_PI_EXT_MODEf_SET(r,f) (r).dsc_sm_sts_restart[0]=(((r).dsc_sm_sts_restart[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_SM_STS_RESTART.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_SM_STS_RESTARTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr,(_r._dsc_sm_sts_restart))
#define BCMI_TSCE16_XGXS_WRITE_DSC_SM_STS_RESTARTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr,(_r._dsc_sm_sts_restart)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_SM_STS_RESTARTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr,(_r._dsc_sm_sts_restart))
#define BCMI_TSCE16_XGXS_READLN_DSC_SM_STS_RESTARTr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_restart))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_SM_STS_RESTARTr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_restart))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_SM_STS_RESTARTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_sts_restart))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_STS_RESTARTr BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr
#define DSC_SM_STS_RESTARTr_SIZE BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr_t DSC_SM_STS_RESTARTr_t;
#define DSC_SM_STS_RESTARTr_CLR BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr_CLR
#define DSC_SM_STS_RESTARTr_SET BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr_SET
#define DSC_SM_STS_RESTARTr_GET BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr_GET
#define DSC_SM_STS_RESTARTr_EEE_QUIET_FROM_EEE_STATESf_GET BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr_EEE_QUIET_FROM_EEE_STATESf_GET
#define DSC_SM_STS_RESTARTr_EEE_QUIET_FROM_EEE_STATESf_SET BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr_EEE_QUIET_FROM_EEE_STATESf_SET
#define DSC_SM_STS_RESTARTr_RESTART_PMD_RESTARTf_GET BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr_RESTART_PMD_RESTARTf_GET
#define DSC_SM_STS_RESTARTr_RESTART_PMD_RESTARTf_SET BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr_RESTART_PMD_RESTARTf_SET
#define DSC_SM_STS_RESTARTr_RESTART_SIGDETf_GET BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr_RESTART_SIGDETf_GET
#define DSC_SM_STS_RESTARTr_RESTART_SIGDETf_SET BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr_RESTART_SIGDETf_SET
#define DSC_SM_STS_RESTARTr_RESTART_PI_EXT_MODEf_GET BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr_RESTART_PI_EXT_MODEf_GET
#define DSC_SM_STS_RESTARTr_RESTART_PI_EXT_MODEf_SET BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr_RESTART_PI_EXT_MODEf_SET
#define READ_DSC_SM_STS_RESTARTr BCMI_TSCE16_XGXS_READ_DSC_SM_STS_RESTARTr
#define WRITE_DSC_SM_STS_RESTARTr BCMI_TSCE16_XGXS_WRITE_DSC_SM_STS_RESTARTr
#define MODIFY_DSC_SM_STS_RESTARTr BCMI_TSCE16_XGXS_MODIFY_DSC_SM_STS_RESTARTr
#define READLN_DSC_SM_STS_RESTARTr BCMI_TSCE16_XGXS_READLN_DSC_SM_STS_RESTARTr
#define WRITELN_DSC_SM_STS_RESTARTr BCMI_TSCE16_XGXS_WRITELN_DSC_SM_STS_RESTARTr
#define WRITEALL_DSC_SM_STS_RESTARTr BCMI_TSCE16_XGXS_WRITEALL_DSC_SM_STS_RESTARTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_SM_STS_RESTARTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_SM_STS_DSC_ST
 * BLOCKS:   DSC_B
 * REGADDR:  0xd01e
 * DESC:     DSC STATE MACHINE STATUS
 * RESETVAL: 0x40 (64)
 * ACCESS:   R/O
 * FIELDS:
 *     DSC_SM_GP_UC_REQ gp_uc_req.
 *     CDR_LM_OUTOFLOCK CDR Lock Monitor loss of lock (1 implies a potential loss of lock). This bit sets itself on register read.And if the cdr_integ_reg is within bounds it clears itself in the next cycle from which it detects within bounds. Note: Set on readThe valid bounds on the cdr_integ_reg are programmed using cdr_lm_thr_selHas more meaning after rx_dsc_lock is asserted.
 *     DSC_SM_READY_FOR_CMD Ready for Command.
 *     DSC_SM_SCRATCH   3 LSB bits of dsc_scratch
 *     DSC_STATE        Live DSC SM state. Following are the state encodings.RESET           =  0RESTART         =  1CONFIG          =  2WAIT_FOR_SIG    =  3ACQ_CDR         =  4CDR_SETTLE      =  5HW_TUNE         =  6UC_TUNE         =  7MEASURE         =  8DONE            =  9EEE_QUIET       =  10EEE_ANA_PWR     =  11EEE_ACQ_CDR     =  12EEE_CDR_SETTLE  =  13EEE_HW_TUNE     =  14EEE_MEASURE     =  15EEE_DONE        =  16SLICER_CAL      =  17DCOFF_CAL       =  18
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr (0x0000d01e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_STS_DSC_ST.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr_s {
	uint32_t v[1];
	uint32_t dsc_sm_sts_dsc_st[1];
	uint32_t _dsc_sm_sts_dsc_st;
} BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr_t;

#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr_CLR(r) (r).dsc_sm_sts_dsc_st[0] = 0
#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr_SET(r,d) (r).dsc_sm_sts_dsc_st[0] = d
#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr_GET(r) (r).dsc_sm_sts_dsc_st[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr_DSC_STATEf_GET(r) ((((r).dsc_sm_sts_dsc_st[0]) >> 11) & 0x1f)
#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr_DSC_STATEf_SET(r,f) (r).dsc_sm_sts_dsc_st[0]=(((r).dsc_sm_sts_dsc_st[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_GET(r) ((((r).dsc_sm_sts_dsc_st[0]) >> 8) & 0x7)
#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_SET(r,f) (r).dsc_sm_sts_dsc_st[0]=(((r).dsc_sm_sts_dsc_st[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_GET(r) ((((r).dsc_sm_sts_dsc_st[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_SET(r,f) (r).dsc_sm_sts_dsc_st[0]=(((r).dsc_sm_sts_dsc_st[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr_CDR_LM_OUTOFLOCKf_GET(r) ((((r).dsc_sm_sts_dsc_st[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr_CDR_LM_OUTOFLOCKf_SET(r,f) (r).dsc_sm_sts_dsc_st[0]=(((r).dsc_sm_sts_dsc_st[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_GET(r) (((r).dsc_sm_sts_dsc_st[0]) & 0x3f)
#define BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_SET(r,f) (r).dsc_sm_sts_dsc_st[0]=(((r).dsc_sm_sts_dsc_st[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_SM_STS_DSC_ST.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_SM_STS_DSC_STr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr,(_r._dsc_sm_sts_dsc_st))
#define BCMI_TSCE16_XGXS_WRITE_DSC_SM_STS_DSC_STr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr,(_r._dsc_sm_sts_dsc_st)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_SM_STS_DSC_STr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr,(_r._dsc_sm_sts_dsc_st))
#define BCMI_TSCE16_XGXS_READLN_DSC_SM_STS_DSC_STr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_st))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_SM_STS_DSC_STr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_st))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_SM_STS_DSC_STr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_sts_dsc_st))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_STS_DSC_STr BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr
#define DSC_SM_STS_DSC_STr_SIZE BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr_t DSC_SM_STS_DSC_STr_t;
#define DSC_SM_STS_DSC_STr_CLR BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr_CLR
#define DSC_SM_STS_DSC_STr_SET BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr_SET
#define DSC_SM_STS_DSC_STr_GET BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr_GET
#define DSC_SM_STS_DSC_STr_DSC_STATEf_GET BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr_DSC_STATEf_GET
#define DSC_SM_STS_DSC_STr_DSC_STATEf_SET BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr_DSC_STATEf_SET
#define DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_GET BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_GET
#define DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_SET BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_SET
#define DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_GET BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_GET
#define DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_SET BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_SET
#define DSC_SM_STS_DSC_STr_CDR_LM_OUTOFLOCKf_GET BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr_CDR_LM_OUTOFLOCKf_GET
#define DSC_SM_STS_DSC_STr_CDR_LM_OUTOFLOCKf_SET BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr_CDR_LM_OUTOFLOCKf_SET
#define DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_GET BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_GET
#define DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_SET BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_SET
#define READ_DSC_SM_STS_DSC_STr BCMI_TSCE16_XGXS_READ_DSC_SM_STS_DSC_STr
#define WRITE_DSC_SM_STS_DSC_STr BCMI_TSCE16_XGXS_WRITE_DSC_SM_STS_DSC_STr
#define MODIFY_DSC_SM_STS_DSC_STr BCMI_TSCE16_XGXS_MODIFY_DSC_SM_STS_DSC_STr
#define READLN_DSC_SM_STS_DSC_STr BCMI_TSCE16_XGXS_READLN_DSC_SM_STS_DSC_STr
#define WRITELN_DSC_SM_STS_DSC_STr BCMI_TSCE16_XGXS_WRITELN_DSC_SM_STS_DSC_STr
#define WRITEALL_DSC_SM_STS_DSC_STr BCMI_TSCE16_XGXS_WRITEALL_DSC_SM_STS_DSC_STr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_SM_STS_DSC_STr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_DFE_COMMON_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd020
 * DESC:     DFE Common Control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DFE_LEAKY_LMS_EN When 1, the leaky lms feature is enabled in the DFE adaptive loops.The rate of leakiness = amount/time is adjustable by changing the time intervalThe amount of leakiness is fixed to +2 or -2. The interval between leaks is programmable.+2 when sign of the tap is negative and -2 when sign of the tap is positive.
 *     DFE_LEAKY_LMS_UPD_DUR 0: dfe accumulator leaks every cycle1-7: dfe accumulator leaks every 2^{1-7} cycles
 *     DFE_HW_EYE_CLOSURE_EN When 1, this enables the DFE adaptive loop to only react to eye closure conditions.An eye closure condition is defined as d!={emux or p1 or m1}This selectability is provided by the dfe_eye_closure_err_sel[1:0]emux is defined as d?p1:m1
 *     DFE_EYE_CLOSURE_ERR_SEL When dfe_eye_closure_en is set, this field determines what is compared against d slicer. d!=error_selected , where error_selected is:2'b00: emux ; emux = d? p1:m12'b01: m12'b10: p12'b11: not supported
 *     DFE_UPDATE_GAIN  *1 or *2 on the updates to the tap
 *     DFE_ALLOW_SIMULT Allow simulatenous change for the cmn tap as well as either odd/even tap controls
 *     DFE_ACC_HYS_EN   Enables hysteresis behavior in the accumulator
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr (0x0000d020 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DFE_COMMON_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_dfe_common_ctl[1];
	uint32_t _dsc_dfe_common_ctl;
} BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_t;

#define BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_CLR(r) (r).dsc_dfe_common_ctl[0] = 0
#define BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_SET(r,d) (r).dsc_dfe_common_ctl[0] = d
#define BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_GET(r) (r).dsc_dfe_common_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_DFE_ACC_HYS_ENf_GET(r) ((((r).dsc_dfe_common_ctl[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_DFE_ACC_HYS_ENf_SET(r,f) (r).dsc_dfe_common_ctl[0]=(((r).dsc_dfe_common_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_DFE_ALLOW_SIMULTf_GET(r) ((((r).dsc_dfe_common_ctl[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_DFE_ALLOW_SIMULTf_SET(r,f) (r).dsc_dfe_common_ctl[0]=(((r).dsc_dfe_common_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_DFE_UPDATE_GAINf_GET(r) ((((r).dsc_dfe_common_ctl[0]) >> 13) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_DFE_UPDATE_GAINf_SET(r,f) (r).dsc_dfe_common_ctl[0]=(((r).dsc_dfe_common_ctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_DFE_EYE_CLOSURE_ERR_SELf_GET(r) ((((r).dsc_dfe_common_ctl[0]) >> 6) & 0x3)
#define BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_DFE_EYE_CLOSURE_ERR_SELf_SET(r,f) (r).dsc_dfe_common_ctl[0]=(((r).dsc_dfe_common_ctl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_DFE_HW_EYE_CLOSURE_ENf_GET(r) ((((r).dsc_dfe_common_ctl[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_DFE_HW_EYE_CLOSURE_ENf_SET(r,f) (r).dsc_dfe_common_ctl[0]=(((r).dsc_dfe_common_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_DFE_LEAKY_LMS_UPD_DURf_GET(r) ((((r).dsc_dfe_common_ctl[0]) >> 1) & 0xf)
#define BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_DFE_LEAKY_LMS_UPD_DURf_SET(r,f) (r).dsc_dfe_common_ctl[0]=(((r).dsc_dfe_common_ctl[0] & ~((uint32_t)0xf << 1)) | ((((uint32_t)f) & 0xf) << 1)) | (15 << (16 + 1))
#define BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_DFE_LEAKY_LMS_ENf_GET(r) (((r).dsc_dfe_common_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_DFE_LEAKY_LMS_ENf_SET(r,f) (r).dsc_dfe_common_ctl[0]=(((r).dsc_dfe_common_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_DFE_COMMON_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_DFE_COMMON_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr,(_r._dsc_dfe_common_ctl))
#define BCMI_TSCE16_XGXS_WRITE_DSC_DFE_COMMON_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr,(_r._dsc_dfe_common_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_DFE_COMMON_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr,(_r._dsc_dfe_common_ctl))
#define BCMI_TSCE16_XGXS_READLN_DSC_DFE_COMMON_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_common_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_DFE_COMMON_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_common_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_DFE_COMMON_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_dfe_common_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_DFE_COMMON_CTLr BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr
#define DSC_DFE_COMMON_CTLr_SIZE BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_t DSC_DFE_COMMON_CTLr_t;
#define DSC_DFE_COMMON_CTLr_CLR BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_CLR
#define DSC_DFE_COMMON_CTLr_SET BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_SET
#define DSC_DFE_COMMON_CTLr_GET BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_GET
#define DSC_DFE_COMMON_CTLr_DFE_ACC_HYS_ENf_GET BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_DFE_ACC_HYS_ENf_GET
#define DSC_DFE_COMMON_CTLr_DFE_ACC_HYS_ENf_SET BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_DFE_ACC_HYS_ENf_SET
#define DSC_DFE_COMMON_CTLr_DFE_ALLOW_SIMULTf_GET BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_DFE_ALLOW_SIMULTf_GET
#define DSC_DFE_COMMON_CTLr_DFE_ALLOW_SIMULTf_SET BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_DFE_ALLOW_SIMULTf_SET
#define DSC_DFE_COMMON_CTLr_DFE_UPDATE_GAINf_GET BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_DFE_UPDATE_GAINf_GET
#define DSC_DFE_COMMON_CTLr_DFE_UPDATE_GAINf_SET BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_DFE_UPDATE_GAINf_SET
#define DSC_DFE_COMMON_CTLr_DFE_EYE_CLOSURE_ERR_SELf_GET BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_DFE_EYE_CLOSURE_ERR_SELf_GET
#define DSC_DFE_COMMON_CTLr_DFE_EYE_CLOSURE_ERR_SELf_SET BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_DFE_EYE_CLOSURE_ERR_SELf_SET
#define DSC_DFE_COMMON_CTLr_DFE_HW_EYE_CLOSURE_ENf_GET BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_DFE_HW_EYE_CLOSURE_ENf_GET
#define DSC_DFE_COMMON_CTLr_DFE_HW_EYE_CLOSURE_ENf_SET BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_DFE_HW_EYE_CLOSURE_ENf_SET
#define DSC_DFE_COMMON_CTLr_DFE_LEAKY_LMS_UPD_DURf_GET BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_DFE_LEAKY_LMS_UPD_DURf_GET
#define DSC_DFE_COMMON_CTLr_DFE_LEAKY_LMS_UPD_DURf_SET BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_DFE_LEAKY_LMS_UPD_DURf_SET
#define DSC_DFE_COMMON_CTLr_DFE_LEAKY_LMS_ENf_GET BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_DFE_LEAKY_LMS_ENf_GET
#define DSC_DFE_COMMON_CTLr_DFE_LEAKY_LMS_ENf_SET BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr_DFE_LEAKY_LMS_ENf_SET
#define READ_DSC_DFE_COMMON_CTLr BCMI_TSCE16_XGXS_READ_DSC_DFE_COMMON_CTLr
#define WRITE_DSC_DFE_COMMON_CTLr BCMI_TSCE16_XGXS_WRITE_DSC_DFE_COMMON_CTLr
#define MODIFY_DSC_DFE_COMMON_CTLr BCMI_TSCE16_XGXS_MODIFY_DSC_DFE_COMMON_CTLr
#define READLN_DSC_DFE_COMMON_CTLr BCMI_TSCE16_XGXS_READLN_DSC_DFE_COMMON_CTLr
#define WRITELN_DSC_DFE_COMMON_CTLr BCMI_TSCE16_XGXS_WRITELN_DSC_DFE_COMMON_CTLr
#define WRITEALL_DSC_DFE_COMMON_CTLr BCMI_TSCE16_XGXS_WRITEALL_DSC_DFE_COMMON_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_DFE_COMMON_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_DFE_1_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd021
 * DESC:     DFE 1 Control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DFE_1_ACC_CLR    clears the dfe_1_tap related accumulator, and intermediate pipeline stages, but not the taps which interface to the analog.
 *     DFE_1_CMN_ONLY   both even and odd errors are summed and apply only to cmn tap - not to the evn and odd taps
 *     DFE_1_INV_P1     invert p1
 *     DFE_1_INV_M1     invert m1
 *     DFE_1_ERR_GAIN   error scaled by 2^dfe_1_err_gain
 *     DFE_1_GRADIENT_INVERT invert the gradient
 *     DFE_1_ERR_SEL    00: emux, 01: p1, 02: m1, 03: nemuxemux = d? p1:m1; nemux = ~d? p1: m1
 *     DFE_1_EN         Enables the tap for adaptive eq
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr (0x0000d021 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DFE_1_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_dfe_1_ctl[1];
	uint32_t _dsc_dfe_1_ctl;
} BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_t;

#define BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_CLR(r) (r).dsc_dfe_1_ctl[0] = 0
#define BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_SET(r,d) (r).dsc_dfe_1_ctl[0] = d
#define BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_GET(r) (r).dsc_dfe_1_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_DFE_1_ENf_GET(r) ((((r).dsc_dfe_1_ctl[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_DFE_1_ENf_SET(r,f) (r).dsc_dfe_1_ctl[0]=(((r).dsc_dfe_1_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_DFE_1_ERR_SELf_GET(r) ((((r).dsc_dfe_1_ctl[0]) >> 13) & 0x3)
#define BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_DFE_1_ERR_SELf_SET(r,f) (r).dsc_dfe_1_ctl[0]=(((r).dsc_dfe_1_ctl[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13)) | (3 << (16 + 13))
#define BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_DFE_1_GRADIENT_INVERTf_GET(r) ((((r).dsc_dfe_1_ctl[0]) >> 12) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_DFE_1_GRADIENT_INVERTf_SET(r,f) (r).dsc_dfe_1_ctl[0]=(((r).dsc_dfe_1_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_DFE_1_ERR_GAINf_GET(r) ((((r).dsc_dfe_1_ctl[0]) >> 10) & 0x3)
#define BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_DFE_1_ERR_GAINf_SET(r,f) (r).dsc_dfe_1_ctl[0]=(((r).dsc_dfe_1_ctl[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_DFE_1_INV_M1f_GET(r) ((((r).dsc_dfe_1_ctl[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_DFE_1_INV_M1f_SET(r,f) (r).dsc_dfe_1_ctl[0]=(((r).dsc_dfe_1_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_DFE_1_INV_P1f_GET(r) ((((r).dsc_dfe_1_ctl[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_DFE_1_INV_P1f_SET(r,f) (r).dsc_dfe_1_ctl[0]=(((r).dsc_dfe_1_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_DFE_1_CMN_ONLYf_GET(r) ((((r).dsc_dfe_1_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_DFE_1_CMN_ONLYf_SET(r,f) (r).dsc_dfe_1_ctl[0]=(((r).dsc_dfe_1_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_DFE_1_ACC_CLRf_GET(r) (((r).dsc_dfe_1_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_DFE_1_ACC_CLRf_SET(r,f) (r).dsc_dfe_1_ctl[0]=(((r).dsc_dfe_1_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_DFE_1_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_DFE_1_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr,(_r._dsc_dfe_1_ctl))
#define BCMI_TSCE16_XGXS_WRITE_DSC_DFE_1_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr,(_r._dsc_dfe_1_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_DFE_1_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr,(_r._dsc_dfe_1_ctl))
#define BCMI_TSCE16_XGXS_READLN_DSC_DFE_1_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_1_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_DFE_1_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_1_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_DFE_1_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_dfe_1_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_DFE_1_CTLr BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr
#define DSC_DFE_1_CTLr_SIZE BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_t DSC_DFE_1_CTLr_t;
#define DSC_DFE_1_CTLr_CLR BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_CLR
#define DSC_DFE_1_CTLr_SET BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_SET
#define DSC_DFE_1_CTLr_GET BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_GET
#define DSC_DFE_1_CTLr_DFE_1_ENf_GET BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_DFE_1_ENf_GET
#define DSC_DFE_1_CTLr_DFE_1_ENf_SET BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_DFE_1_ENf_SET
#define DSC_DFE_1_CTLr_DFE_1_ERR_SELf_GET BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_DFE_1_ERR_SELf_GET
#define DSC_DFE_1_CTLr_DFE_1_ERR_SELf_SET BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_DFE_1_ERR_SELf_SET
#define DSC_DFE_1_CTLr_DFE_1_GRADIENT_INVERTf_GET BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_DFE_1_GRADIENT_INVERTf_GET
#define DSC_DFE_1_CTLr_DFE_1_GRADIENT_INVERTf_SET BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_DFE_1_GRADIENT_INVERTf_SET
#define DSC_DFE_1_CTLr_DFE_1_ERR_GAINf_GET BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_DFE_1_ERR_GAINf_GET
#define DSC_DFE_1_CTLr_DFE_1_ERR_GAINf_SET BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_DFE_1_ERR_GAINf_SET
#define DSC_DFE_1_CTLr_DFE_1_INV_M1f_GET BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_DFE_1_INV_M1f_GET
#define DSC_DFE_1_CTLr_DFE_1_INV_M1f_SET BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_DFE_1_INV_M1f_SET
#define DSC_DFE_1_CTLr_DFE_1_INV_P1f_GET BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_DFE_1_INV_P1f_GET
#define DSC_DFE_1_CTLr_DFE_1_INV_P1f_SET BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_DFE_1_INV_P1f_SET
#define DSC_DFE_1_CTLr_DFE_1_CMN_ONLYf_GET BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_DFE_1_CMN_ONLYf_GET
#define DSC_DFE_1_CTLr_DFE_1_CMN_ONLYf_SET BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_DFE_1_CMN_ONLYf_SET
#define DSC_DFE_1_CTLr_DFE_1_ACC_CLRf_GET BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_DFE_1_ACC_CLRf_GET
#define DSC_DFE_1_CTLr_DFE_1_ACC_CLRf_SET BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr_DFE_1_ACC_CLRf_SET
#define READ_DSC_DFE_1_CTLr BCMI_TSCE16_XGXS_READ_DSC_DFE_1_CTLr
#define WRITE_DSC_DFE_1_CTLr BCMI_TSCE16_XGXS_WRITE_DSC_DFE_1_CTLr
#define MODIFY_DSC_DFE_1_CTLr BCMI_TSCE16_XGXS_MODIFY_DSC_DFE_1_CTLr
#define READLN_DSC_DFE_1_CTLr BCMI_TSCE16_XGXS_READLN_DSC_DFE_1_CTLr
#define WRITELN_DSC_DFE_1_CTLr BCMI_TSCE16_XGXS_WRITELN_DSC_DFE_1_CTLr
#define WRITEALL_DSC_DFE_1_CTLr BCMI_TSCE16_XGXS_WRITEALL_DSC_DFE_1_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_DFE_1_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_DFE_2_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd022
 * DESC:     DFE 2 Control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DFE_2_ACC_CLR    clears the dfe_2_tap related accumulator, and intermediate pipeline stages, but not the taps which interface to the analog.
 *     DFE_2_CMN_ONLY   both even and odd errors are summed and apply only to cmn tap - not to the evn and odd taps
 *     DFE_2_INV_P1     invert p1
 *     DFE_2_INV_M1     invert m1
 *     DFE_2_ERR_GAIN   error scaled by 2^dfe_2_err_gain
 *     DFE_2_GRADIENT_INVERT invert the gradient
 *     DFE_2_ERR_SEL    00: emux, 01: p1, 02: m1, 03: nemuxemux = d? p1:m1; nemux = ~d? p1: m1
 *     DFE_2_EN         Enables the tap for adaptive eq
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr (0x0000d022 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DFE_2_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_dfe_2_ctl[1];
	uint32_t _dsc_dfe_2_ctl;
} BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_t;

#define BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_CLR(r) (r).dsc_dfe_2_ctl[0] = 0
#define BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_SET(r,d) (r).dsc_dfe_2_ctl[0] = d
#define BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_GET(r) (r).dsc_dfe_2_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_DFE_2_ENf_GET(r) ((((r).dsc_dfe_2_ctl[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_DFE_2_ENf_SET(r,f) (r).dsc_dfe_2_ctl[0]=(((r).dsc_dfe_2_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_DFE_2_ERR_SELf_GET(r) ((((r).dsc_dfe_2_ctl[0]) >> 13) & 0x3)
#define BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_DFE_2_ERR_SELf_SET(r,f) (r).dsc_dfe_2_ctl[0]=(((r).dsc_dfe_2_ctl[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13)) | (3 << (16 + 13))
#define BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_DFE_2_GRADIENT_INVERTf_GET(r) ((((r).dsc_dfe_2_ctl[0]) >> 12) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_DFE_2_GRADIENT_INVERTf_SET(r,f) (r).dsc_dfe_2_ctl[0]=(((r).dsc_dfe_2_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_DFE_2_ERR_GAINf_GET(r) ((((r).dsc_dfe_2_ctl[0]) >> 10) & 0x3)
#define BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_DFE_2_ERR_GAINf_SET(r,f) (r).dsc_dfe_2_ctl[0]=(((r).dsc_dfe_2_ctl[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_DFE_2_INV_M1f_GET(r) ((((r).dsc_dfe_2_ctl[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_DFE_2_INV_M1f_SET(r,f) (r).dsc_dfe_2_ctl[0]=(((r).dsc_dfe_2_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_DFE_2_INV_P1f_GET(r) ((((r).dsc_dfe_2_ctl[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_DFE_2_INV_P1f_SET(r,f) (r).dsc_dfe_2_ctl[0]=(((r).dsc_dfe_2_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_DFE_2_CMN_ONLYf_GET(r) ((((r).dsc_dfe_2_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_DFE_2_CMN_ONLYf_SET(r,f) (r).dsc_dfe_2_ctl[0]=(((r).dsc_dfe_2_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_DFE_2_ACC_CLRf_GET(r) (((r).dsc_dfe_2_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_DFE_2_ACC_CLRf_SET(r,f) (r).dsc_dfe_2_ctl[0]=(((r).dsc_dfe_2_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_DFE_2_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_DFE_2_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr,(_r._dsc_dfe_2_ctl))
#define BCMI_TSCE16_XGXS_WRITE_DSC_DFE_2_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr,(_r._dsc_dfe_2_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_DFE_2_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr,(_r._dsc_dfe_2_ctl))
#define BCMI_TSCE16_XGXS_READLN_DSC_DFE_2_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_2_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_DFE_2_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_2_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_DFE_2_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_dfe_2_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_DFE_2_CTLr BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr
#define DSC_DFE_2_CTLr_SIZE BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_t DSC_DFE_2_CTLr_t;
#define DSC_DFE_2_CTLr_CLR BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_CLR
#define DSC_DFE_2_CTLr_SET BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_SET
#define DSC_DFE_2_CTLr_GET BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_GET
#define DSC_DFE_2_CTLr_DFE_2_ENf_GET BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_DFE_2_ENf_GET
#define DSC_DFE_2_CTLr_DFE_2_ENf_SET BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_DFE_2_ENf_SET
#define DSC_DFE_2_CTLr_DFE_2_ERR_SELf_GET BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_DFE_2_ERR_SELf_GET
#define DSC_DFE_2_CTLr_DFE_2_ERR_SELf_SET BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_DFE_2_ERR_SELf_SET
#define DSC_DFE_2_CTLr_DFE_2_GRADIENT_INVERTf_GET BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_DFE_2_GRADIENT_INVERTf_GET
#define DSC_DFE_2_CTLr_DFE_2_GRADIENT_INVERTf_SET BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_DFE_2_GRADIENT_INVERTf_SET
#define DSC_DFE_2_CTLr_DFE_2_ERR_GAINf_GET BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_DFE_2_ERR_GAINf_GET
#define DSC_DFE_2_CTLr_DFE_2_ERR_GAINf_SET BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_DFE_2_ERR_GAINf_SET
#define DSC_DFE_2_CTLr_DFE_2_INV_M1f_GET BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_DFE_2_INV_M1f_GET
#define DSC_DFE_2_CTLr_DFE_2_INV_M1f_SET BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_DFE_2_INV_M1f_SET
#define DSC_DFE_2_CTLr_DFE_2_INV_P1f_GET BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_DFE_2_INV_P1f_GET
#define DSC_DFE_2_CTLr_DFE_2_INV_P1f_SET BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_DFE_2_INV_P1f_SET
#define DSC_DFE_2_CTLr_DFE_2_CMN_ONLYf_GET BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_DFE_2_CMN_ONLYf_GET
#define DSC_DFE_2_CTLr_DFE_2_CMN_ONLYf_SET BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_DFE_2_CMN_ONLYf_SET
#define DSC_DFE_2_CTLr_DFE_2_ACC_CLRf_GET BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_DFE_2_ACC_CLRf_GET
#define DSC_DFE_2_CTLr_DFE_2_ACC_CLRf_SET BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr_DFE_2_ACC_CLRf_SET
#define READ_DSC_DFE_2_CTLr BCMI_TSCE16_XGXS_READ_DSC_DFE_2_CTLr
#define WRITE_DSC_DFE_2_CTLr BCMI_TSCE16_XGXS_WRITE_DSC_DFE_2_CTLr
#define MODIFY_DSC_DFE_2_CTLr BCMI_TSCE16_XGXS_MODIFY_DSC_DFE_2_CTLr
#define READLN_DSC_DFE_2_CTLr BCMI_TSCE16_XGXS_READLN_DSC_DFE_2_CTLr
#define WRITELN_DSC_DFE_2_CTLr BCMI_TSCE16_XGXS_WRITELN_DSC_DFE_2_CTLr
#define WRITEALL_DSC_DFE_2_CTLr BCMI_TSCE16_XGXS_WRITEALL_DSC_DFE_2_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_DFE_2_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_DFE_3_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd023
 * DESC:     DFE 3 Control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DFE_3_ACC_CLR    clears the dfe_3_tap related accumulator, and intermediate pipeline stages, but not the taps which interface to the analog.
 *     DFE_3_INV_P1     invert p1
 *     DFE_3_INV_M1     invert m1
 *     DFE_3_ERR_GAIN   error scaled by 2^dfe_3_err_gain
 *     DFE_3_GRADIENT_INVERT invert the gradient
 *     DFE_3_ERR_SEL    00: emux, 01: p1, 02: m1, 03: nemuxemux = d? p1:m1; nemux = ~d? p1: m1
 *     DFE_3_EN         Enables the tap for adaptive eq
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr (0x0000d023 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DFE_3_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_dfe_3_ctl[1];
	uint32_t _dsc_dfe_3_ctl;
} BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_t;

#define BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_CLR(r) (r).dsc_dfe_3_ctl[0] = 0
#define BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_SET(r,d) (r).dsc_dfe_3_ctl[0] = d
#define BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_GET(r) (r).dsc_dfe_3_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_DFE_3_ENf_GET(r) ((((r).dsc_dfe_3_ctl[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_DFE_3_ENf_SET(r,f) (r).dsc_dfe_3_ctl[0]=(((r).dsc_dfe_3_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_DFE_3_ERR_SELf_GET(r) ((((r).dsc_dfe_3_ctl[0]) >> 13) & 0x3)
#define BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_DFE_3_ERR_SELf_SET(r,f) (r).dsc_dfe_3_ctl[0]=(((r).dsc_dfe_3_ctl[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13)) | (3 << (16 + 13))
#define BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_DFE_3_GRADIENT_INVERTf_GET(r) ((((r).dsc_dfe_3_ctl[0]) >> 12) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_DFE_3_GRADIENT_INVERTf_SET(r,f) (r).dsc_dfe_3_ctl[0]=(((r).dsc_dfe_3_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_DFE_3_ERR_GAINf_GET(r) ((((r).dsc_dfe_3_ctl[0]) >> 10) & 0x3)
#define BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_DFE_3_ERR_GAINf_SET(r,f) (r).dsc_dfe_3_ctl[0]=(((r).dsc_dfe_3_ctl[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_DFE_3_INV_M1f_GET(r) ((((r).dsc_dfe_3_ctl[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_DFE_3_INV_M1f_SET(r,f) (r).dsc_dfe_3_ctl[0]=(((r).dsc_dfe_3_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_DFE_3_INV_P1f_GET(r) ((((r).dsc_dfe_3_ctl[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_DFE_3_INV_P1f_SET(r,f) (r).dsc_dfe_3_ctl[0]=(((r).dsc_dfe_3_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_DFE_3_ACC_CLRf_GET(r) (((r).dsc_dfe_3_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_DFE_3_ACC_CLRf_SET(r,f) (r).dsc_dfe_3_ctl[0]=(((r).dsc_dfe_3_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_DFE_3_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_DFE_3_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr,(_r._dsc_dfe_3_ctl))
#define BCMI_TSCE16_XGXS_WRITE_DSC_DFE_3_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr,(_r._dsc_dfe_3_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_DFE_3_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr,(_r._dsc_dfe_3_ctl))
#define BCMI_TSCE16_XGXS_READLN_DSC_DFE_3_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_3_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_DFE_3_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_3_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_DFE_3_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_dfe_3_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_DFE_3_CTLr BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr
#define DSC_DFE_3_CTLr_SIZE BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_t DSC_DFE_3_CTLr_t;
#define DSC_DFE_3_CTLr_CLR BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_CLR
#define DSC_DFE_3_CTLr_SET BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_SET
#define DSC_DFE_3_CTLr_GET BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_GET
#define DSC_DFE_3_CTLr_DFE_3_ENf_GET BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_DFE_3_ENf_GET
#define DSC_DFE_3_CTLr_DFE_3_ENf_SET BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_DFE_3_ENf_SET
#define DSC_DFE_3_CTLr_DFE_3_ERR_SELf_GET BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_DFE_3_ERR_SELf_GET
#define DSC_DFE_3_CTLr_DFE_3_ERR_SELf_SET BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_DFE_3_ERR_SELf_SET
#define DSC_DFE_3_CTLr_DFE_3_GRADIENT_INVERTf_GET BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_DFE_3_GRADIENT_INVERTf_GET
#define DSC_DFE_3_CTLr_DFE_3_GRADIENT_INVERTf_SET BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_DFE_3_GRADIENT_INVERTf_SET
#define DSC_DFE_3_CTLr_DFE_3_ERR_GAINf_GET BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_DFE_3_ERR_GAINf_GET
#define DSC_DFE_3_CTLr_DFE_3_ERR_GAINf_SET BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_DFE_3_ERR_GAINf_SET
#define DSC_DFE_3_CTLr_DFE_3_INV_M1f_GET BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_DFE_3_INV_M1f_GET
#define DSC_DFE_3_CTLr_DFE_3_INV_M1f_SET BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_DFE_3_INV_M1f_SET
#define DSC_DFE_3_CTLr_DFE_3_INV_P1f_GET BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_DFE_3_INV_P1f_GET
#define DSC_DFE_3_CTLr_DFE_3_INV_P1f_SET BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_DFE_3_INV_P1f_SET
#define DSC_DFE_3_CTLr_DFE_3_ACC_CLRf_GET BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_DFE_3_ACC_CLRf_GET
#define DSC_DFE_3_CTLr_DFE_3_ACC_CLRf_SET BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr_DFE_3_ACC_CLRf_SET
#define READ_DSC_DFE_3_CTLr BCMI_TSCE16_XGXS_READ_DSC_DFE_3_CTLr
#define WRITE_DSC_DFE_3_CTLr BCMI_TSCE16_XGXS_WRITE_DSC_DFE_3_CTLr
#define MODIFY_DSC_DFE_3_CTLr BCMI_TSCE16_XGXS_MODIFY_DSC_DFE_3_CTLr
#define READLN_DSC_DFE_3_CTLr BCMI_TSCE16_XGXS_READLN_DSC_DFE_3_CTLr
#define WRITELN_DSC_DFE_3_CTLr BCMI_TSCE16_XGXS_WRITELN_DSC_DFE_3_CTLr
#define WRITEALL_DSC_DFE_3_CTLr BCMI_TSCE16_XGXS_WRITEALL_DSC_DFE_3_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_DFE_3_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_DFE_4_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd024
 * DESC:     DFE 4 Control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DFE_4_ACC_CLR    clears the dfe_4_tap related accumulator, and intermediate pipeline stages, but not the taps which interface to the analog.
 *     DFE_4_INV_P1     invert p1
 *     DFE_4_INV_M1     invert m1
 *     DFE_4_ERR_GAIN   error scaled by 2^dfe_4_err_gain
 *     DFE_4_GRADIENT_INVERT invert the gradient
 *     DFE_4_ERR_SEL    00: emux, 01: p1, 02: m1, 03: nemuxemux = d? p1:m1; nemux = ~d? p1: m1
 *     DFE_4_EN         Enables the tap for adaptive eq
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr (0x0000d024 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DFE_4_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_dfe_4_ctl[1];
	uint32_t _dsc_dfe_4_ctl;
} BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_t;

#define BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_CLR(r) (r).dsc_dfe_4_ctl[0] = 0
#define BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_SET(r,d) (r).dsc_dfe_4_ctl[0] = d
#define BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_GET(r) (r).dsc_dfe_4_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_DFE_4_ENf_GET(r) ((((r).dsc_dfe_4_ctl[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_DFE_4_ENf_SET(r,f) (r).dsc_dfe_4_ctl[0]=(((r).dsc_dfe_4_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_DFE_4_ERR_SELf_GET(r) ((((r).dsc_dfe_4_ctl[0]) >> 13) & 0x3)
#define BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_DFE_4_ERR_SELf_SET(r,f) (r).dsc_dfe_4_ctl[0]=(((r).dsc_dfe_4_ctl[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13)) | (3 << (16 + 13))
#define BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_DFE_4_GRADIENT_INVERTf_GET(r) ((((r).dsc_dfe_4_ctl[0]) >> 12) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_DFE_4_GRADIENT_INVERTf_SET(r,f) (r).dsc_dfe_4_ctl[0]=(((r).dsc_dfe_4_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_DFE_4_ERR_GAINf_GET(r) ((((r).dsc_dfe_4_ctl[0]) >> 10) & 0x3)
#define BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_DFE_4_ERR_GAINf_SET(r,f) (r).dsc_dfe_4_ctl[0]=(((r).dsc_dfe_4_ctl[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_DFE_4_INV_M1f_GET(r) ((((r).dsc_dfe_4_ctl[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_DFE_4_INV_M1f_SET(r,f) (r).dsc_dfe_4_ctl[0]=(((r).dsc_dfe_4_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_DFE_4_INV_P1f_GET(r) ((((r).dsc_dfe_4_ctl[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_DFE_4_INV_P1f_SET(r,f) (r).dsc_dfe_4_ctl[0]=(((r).dsc_dfe_4_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_DFE_4_ACC_CLRf_GET(r) (((r).dsc_dfe_4_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_DFE_4_ACC_CLRf_SET(r,f) (r).dsc_dfe_4_ctl[0]=(((r).dsc_dfe_4_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_DFE_4_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_DFE_4_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr,(_r._dsc_dfe_4_ctl))
#define BCMI_TSCE16_XGXS_WRITE_DSC_DFE_4_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr,(_r._dsc_dfe_4_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_DFE_4_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr,(_r._dsc_dfe_4_ctl))
#define BCMI_TSCE16_XGXS_READLN_DSC_DFE_4_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_4_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_DFE_4_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_4_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_DFE_4_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_dfe_4_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_DFE_4_CTLr BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr
#define DSC_DFE_4_CTLr_SIZE BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_t DSC_DFE_4_CTLr_t;
#define DSC_DFE_4_CTLr_CLR BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_CLR
#define DSC_DFE_4_CTLr_SET BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_SET
#define DSC_DFE_4_CTLr_GET BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_GET
#define DSC_DFE_4_CTLr_DFE_4_ENf_GET BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_DFE_4_ENf_GET
#define DSC_DFE_4_CTLr_DFE_4_ENf_SET BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_DFE_4_ENf_SET
#define DSC_DFE_4_CTLr_DFE_4_ERR_SELf_GET BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_DFE_4_ERR_SELf_GET
#define DSC_DFE_4_CTLr_DFE_4_ERR_SELf_SET BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_DFE_4_ERR_SELf_SET
#define DSC_DFE_4_CTLr_DFE_4_GRADIENT_INVERTf_GET BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_DFE_4_GRADIENT_INVERTf_GET
#define DSC_DFE_4_CTLr_DFE_4_GRADIENT_INVERTf_SET BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_DFE_4_GRADIENT_INVERTf_SET
#define DSC_DFE_4_CTLr_DFE_4_ERR_GAINf_GET BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_DFE_4_ERR_GAINf_GET
#define DSC_DFE_4_CTLr_DFE_4_ERR_GAINf_SET BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_DFE_4_ERR_GAINf_SET
#define DSC_DFE_4_CTLr_DFE_4_INV_M1f_GET BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_DFE_4_INV_M1f_GET
#define DSC_DFE_4_CTLr_DFE_4_INV_M1f_SET BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_DFE_4_INV_M1f_SET
#define DSC_DFE_4_CTLr_DFE_4_INV_P1f_GET BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_DFE_4_INV_P1f_GET
#define DSC_DFE_4_CTLr_DFE_4_INV_P1f_SET BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_DFE_4_INV_P1f_SET
#define DSC_DFE_4_CTLr_DFE_4_ACC_CLRf_GET BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_DFE_4_ACC_CLRf_GET
#define DSC_DFE_4_CTLr_DFE_4_ACC_CLRf_SET BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr_DFE_4_ACC_CLRf_SET
#define READ_DSC_DFE_4_CTLr BCMI_TSCE16_XGXS_READ_DSC_DFE_4_CTLr
#define WRITE_DSC_DFE_4_CTLr BCMI_TSCE16_XGXS_WRITE_DSC_DFE_4_CTLr
#define MODIFY_DSC_DFE_4_CTLr BCMI_TSCE16_XGXS_MODIFY_DSC_DFE_4_CTLr
#define READLN_DSC_DFE_4_CTLr BCMI_TSCE16_XGXS_READLN_DSC_DFE_4_CTLr
#define WRITELN_DSC_DFE_4_CTLr BCMI_TSCE16_XGXS_WRITELN_DSC_DFE_4_CTLr
#define WRITEALL_DSC_DFE_4_CTLr BCMI_TSCE16_XGXS_WRITEALL_DSC_DFE_4_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_DFE_4_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_DFE_5_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd025
 * DESC:     DFE 5 Control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DFE_5_ACC_CLR    clears the dfe_5_tap related accumulator, and intermediate pipeline stages, but not the taps which interface to the analog.
 *     DFE_5_INV_P1     invert p1
 *     DFE_5_INV_M1     invert m1
 *     DFE_5_ERR_GAIN   error scaled by 2^dfe_5_err_gain
 *     DFE_5_GRADIENT_INVERT invert the gradient
 *     DFE_5_ERR_SEL    00: emux, 01: p1, 02: m1, 03: nemuxemux = d? p1:m1; nemux = ~d? p1: m1
 *     DFE_5_EN         Enables the tap for adaptive eq
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr (0x0000d025 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DFE_5_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_dfe_5_ctl[1];
	uint32_t _dsc_dfe_5_ctl;
} BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_t;

#define BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_CLR(r) (r).dsc_dfe_5_ctl[0] = 0
#define BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_SET(r,d) (r).dsc_dfe_5_ctl[0] = d
#define BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_GET(r) (r).dsc_dfe_5_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_DFE_5_ENf_GET(r) ((((r).dsc_dfe_5_ctl[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_DFE_5_ENf_SET(r,f) (r).dsc_dfe_5_ctl[0]=(((r).dsc_dfe_5_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_DFE_5_ERR_SELf_GET(r) ((((r).dsc_dfe_5_ctl[0]) >> 13) & 0x3)
#define BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_DFE_5_ERR_SELf_SET(r,f) (r).dsc_dfe_5_ctl[0]=(((r).dsc_dfe_5_ctl[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13)) | (3 << (16 + 13))
#define BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_DFE_5_GRADIENT_INVERTf_GET(r) ((((r).dsc_dfe_5_ctl[0]) >> 12) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_DFE_5_GRADIENT_INVERTf_SET(r,f) (r).dsc_dfe_5_ctl[0]=(((r).dsc_dfe_5_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_DFE_5_ERR_GAINf_GET(r) ((((r).dsc_dfe_5_ctl[0]) >> 10) & 0x3)
#define BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_DFE_5_ERR_GAINf_SET(r,f) (r).dsc_dfe_5_ctl[0]=(((r).dsc_dfe_5_ctl[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_DFE_5_INV_M1f_GET(r) ((((r).dsc_dfe_5_ctl[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_DFE_5_INV_M1f_SET(r,f) (r).dsc_dfe_5_ctl[0]=(((r).dsc_dfe_5_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_DFE_5_INV_P1f_GET(r) ((((r).dsc_dfe_5_ctl[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_DFE_5_INV_P1f_SET(r,f) (r).dsc_dfe_5_ctl[0]=(((r).dsc_dfe_5_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_DFE_5_ACC_CLRf_GET(r) (((r).dsc_dfe_5_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_DFE_5_ACC_CLRf_SET(r,f) (r).dsc_dfe_5_ctl[0]=(((r).dsc_dfe_5_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_DFE_5_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_DFE_5_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr,(_r._dsc_dfe_5_ctl))
#define BCMI_TSCE16_XGXS_WRITE_DSC_DFE_5_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr,(_r._dsc_dfe_5_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_DFE_5_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr,(_r._dsc_dfe_5_ctl))
#define BCMI_TSCE16_XGXS_READLN_DSC_DFE_5_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_5_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_DFE_5_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_5_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_DFE_5_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_dfe_5_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_DFE_5_CTLr BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr
#define DSC_DFE_5_CTLr_SIZE BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_t DSC_DFE_5_CTLr_t;
#define DSC_DFE_5_CTLr_CLR BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_CLR
#define DSC_DFE_5_CTLr_SET BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_SET
#define DSC_DFE_5_CTLr_GET BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_GET
#define DSC_DFE_5_CTLr_DFE_5_ENf_GET BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_DFE_5_ENf_GET
#define DSC_DFE_5_CTLr_DFE_5_ENf_SET BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_DFE_5_ENf_SET
#define DSC_DFE_5_CTLr_DFE_5_ERR_SELf_GET BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_DFE_5_ERR_SELf_GET
#define DSC_DFE_5_CTLr_DFE_5_ERR_SELf_SET BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_DFE_5_ERR_SELf_SET
#define DSC_DFE_5_CTLr_DFE_5_GRADIENT_INVERTf_GET BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_DFE_5_GRADIENT_INVERTf_GET
#define DSC_DFE_5_CTLr_DFE_5_GRADIENT_INVERTf_SET BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_DFE_5_GRADIENT_INVERTf_SET
#define DSC_DFE_5_CTLr_DFE_5_ERR_GAINf_GET BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_DFE_5_ERR_GAINf_GET
#define DSC_DFE_5_CTLr_DFE_5_ERR_GAINf_SET BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_DFE_5_ERR_GAINf_SET
#define DSC_DFE_5_CTLr_DFE_5_INV_M1f_GET BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_DFE_5_INV_M1f_GET
#define DSC_DFE_5_CTLr_DFE_5_INV_M1f_SET BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_DFE_5_INV_M1f_SET
#define DSC_DFE_5_CTLr_DFE_5_INV_P1f_GET BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_DFE_5_INV_P1f_GET
#define DSC_DFE_5_CTLr_DFE_5_INV_P1f_SET BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_DFE_5_INV_P1f_SET
#define DSC_DFE_5_CTLr_DFE_5_ACC_CLRf_GET BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_DFE_5_ACC_CLRf_GET
#define DSC_DFE_5_CTLr_DFE_5_ACC_CLRf_SET BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr_DFE_5_ACC_CLRf_SET
#define READ_DSC_DFE_5_CTLr BCMI_TSCE16_XGXS_READ_DSC_DFE_5_CTLr
#define WRITE_DSC_DFE_5_CTLr BCMI_TSCE16_XGXS_WRITE_DSC_DFE_5_CTLr
#define MODIFY_DSC_DFE_5_CTLr BCMI_TSCE16_XGXS_MODIFY_DSC_DFE_5_CTLr
#define READLN_DSC_DFE_5_CTLr BCMI_TSCE16_XGXS_READLN_DSC_DFE_5_CTLr
#define WRITELN_DSC_DFE_5_CTLr BCMI_TSCE16_XGXS_WRITELN_DSC_DFE_5_CTLr
#define WRITEALL_DSC_DFE_5_CTLr BCMI_TSCE16_XGXS_WRITEALL_DSC_DFE_5_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_DFE_5_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_DFE_PAT_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd026
 * DESC:     DFE Pattern Control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DFE_PATTERN      pattern based conditioning of error accumulation (accumulate if pattern matches)pattern bits [5:0] msb to lsb <=> locations 0 to -5 (current bit to 5 bits in past)
 *     DFE_PATTERN_BIT_EN pattern bit maskpattern bits [5:0] msb to lsb <=> locations 0 to -5 (current bit to 5 bits in past)pattern_bit_en[5:0] serves as a bitwise mask which enables the corresponding bits in the pattern[5:0] to be enabled for matching
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_DFE_PAT_CTLr (0x0000d026 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_DFE_PAT_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DFE_PAT_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_DFE_PAT_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_dfe_pat_ctl[1];
	uint32_t _dsc_dfe_pat_ctl;
} BCMI_TSCE16_XGXS_DSC_DFE_PAT_CTLr_t;

#define BCMI_TSCE16_XGXS_DSC_DFE_PAT_CTLr_CLR(r) (r).dsc_dfe_pat_ctl[0] = 0
#define BCMI_TSCE16_XGXS_DSC_DFE_PAT_CTLr_SET(r,d) (r).dsc_dfe_pat_ctl[0] = d
#define BCMI_TSCE16_XGXS_DSC_DFE_PAT_CTLr_GET(r) (r).dsc_dfe_pat_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_DFE_PAT_CTLr_DFE_PATTERN_BIT_ENf_GET(r) ((((r).dsc_dfe_pat_ctl[0]) >> 8) & 0x3f)
#define BCMI_TSCE16_XGXS_DSC_DFE_PAT_CTLr_DFE_PATTERN_BIT_ENf_SET(r,f) (r).dsc_dfe_pat_ctl[0]=(((r).dsc_dfe_pat_ctl[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_TSCE16_XGXS_DSC_DFE_PAT_CTLr_DFE_PATTERNf_GET(r) (((r).dsc_dfe_pat_ctl[0]) & 0x3f)
#define BCMI_TSCE16_XGXS_DSC_DFE_PAT_CTLr_DFE_PATTERNf_SET(r,f) (r).dsc_dfe_pat_ctl[0]=(((r).dsc_dfe_pat_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_DFE_PAT_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_DFE_PAT_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_DFE_PAT_CTLr,(_r._dsc_dfe_pat_ctl))
#define BCMI_TSCE16_XGXS_WRITE_DSC_DFE_PAT_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_PAT_CTLr,(_r._dsc_dfe_pat_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_DFE_PAT_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_PAT_CTLr,(_r._dsc_dfe_pat_ctl))
#define BCMI_TSCE16_XGXS_READLN_DSC_DFE_PAT_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_DFE_PAT_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_pat_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_DFE_PAT_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_PAT_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_pat_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_DFE_PAT_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_PAT_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_dfe_pat_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_DFE_PAT_CTLr BCMI_TSCE16_XGXS_DSC_DFE_PAT_CTLr
#define DSC_DFE_PAT_CTLr_SIZE BCMI_TSCE16_XGXS_DSC_DFE_PAT_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_DFE_PAT_CTLr_t DSC_DFE_PAT_CTLr_t;
#define DSC_DFE_PAT_CTLr_CLR BCMI_TSCE16_XGXS_DSC_DFE_PAT_CTLr_CLR
#define DSC_DFE_PAT_CTLr_SET BCMI_TSCE16_XGXS_DSC_DFE_PAT_CTLr_SET
#define DSC_DFE_PAT_CTLr_GET BCMI_TSCE16_XGXS_DSC_DFE_PAT_CTLr_GET
#define DSC_DFE_PAT_CTLr_DFE_PATTERN_BIT_ENf_GET BCMI_TSCE16_XGXS_DSC_DFE_PAT_CTLr_DFE_PATTERN_BIT_ENf_GET
#define DSC_DFE_PAT_CTLr_DFE_PATTERN_BIT_ENf_SET BCMI_TSCE16_XGXS_DSC_DFE_PAT_CTLr_DFE_PATTERN_BIT_ENf_SET
#define DSC_DFE_PAT_CTLr_DFE_PATTERNf_GET BCMI_TSCE16_XGXS_DSC_DFE_PAT_CTLr_DFE_PATTERNf_GET
#define DSC_DFE_PAT_CTLr_DFE_PATTERNf_SET BCMI_TSCE16_XGXS_DSC_DFE_PAT_CTLr_DFE_PATTERNf_SET
#define READ_DSC_DFE_PAT_CTLr BCMI_TSCE16_XGXS_READ_DSC_DFE_PAT_CTLr
#define WRITE_DSC_DFE_PAT_CTLr BCMI_TSCE16_XGXS_WRITE_DSC_DFE_PAT_CTLr
#define MODIFY_DSC_DFE_PAT_CTLr BCMI_TSCE16_XGXS_MODIFY_DSC_DFE_PAT_CTLr
#define READLN_DSC_DFE_PAT_CTLr BCMI_TSCE16_XGXS_READLN_DSC_DFE_PAT_CTLr
#define WRITELN_DSC_DFE_PAT_CTLr BCMI_TSCE16_XGXS_WRITELN_DSC_DFE_PAT_CTLr
#define WRITEALL_DSC_DFE_PAT_CTLr BCMI_TSCE16_XGXS_WRITEALL_DSC_DFE_PAT_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_DFE_PAT_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_VGA_P1_MISC_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd027
 * DESC:     VGA P1 Misc Control
 * RESETVAL: 0x8440 (33856)
 * ACCESS:   R/W
 * FIELDS:
 *     VGA_HWTUNE_MIN   This minimum limit is respected by the VGA harware adaptive loop.Also used by the status logic for vga_wants_to_go_low.
 *     VGA_OP_SHORT_OFFCAL This is the control for the AFE VGA output short function in a specific situation.This control bit is used only when the DSC_SM is in slicer offset cal states.In order to force the 'vga output idle' control, i.e. rx_ctrl[16], write the same value to bothvga_op_short_norm and vga_op_short_offcal
 *     VGA_OP_SHORT_NORM This is the normal mode control for the AFE VGA output short function.This control bit is used in all situations except when DSC_SM is in slicer offset cal states.In order to force the 'vga output idle' control, i.e. rx_ctrl[16], write the same value to bothvga_op_short_norm and vga_op_short_offcal
 *     P1_HWTUNE_MIN    A signed minimum limit which the hardware loop respects during adaptation.Must be lesser than the p1_hwtune_max.Default is 21h, which is -31.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr (0x0000d027 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_VGA_P1_MISC_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_vga_p1_misc_ctl[1];
	uint32_t _dsc_vga_p1_misc_ctl;
} BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr_t;

#define BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr_CLR(r) (r).dsc_vga_p1_misc_ctl[0] = 0
#define BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr_SET(r,d) (r).dsc_vga_p1_misc_ctl[0] = d
#define BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr_GET(r) (r).dsc_vga_p1_misc_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr_P1_HWTUNE_MINf_GET(r) ((((r).dsc_vga_p1_misc_ctl[0]) >> 10) & 0x3f)
#define BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr_P1_HWTUNE_MINf_SET(r,f) (r).dsc_vga_p1_misc_ctl[0]=(((r).dsc_vga_p1_misc_ctl[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10)) | (63 << (16 + 10))
#define BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr_VGA_OP_SHORT_NORMf_GET(r) ((((r).dsc_vga_p1_misc_ctl[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr_VGA_OP_SHORT_NORMf_SET(r,f) (r).dsc_vga_p1_misc_ctl[0]=(((r).dsc_vga_p1_misc_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr_VGA_OP_SHORT_OFFCALf_GET(r) ((((r).dsc_vga_p1_misc_ctl[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr_VGA_OP_SHORT_OFFCALf_SET(r,f) (r).dsc_vga_p1_misc_ctl[0]=(((r).dsc_vga_p1_misc_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr_VGA_HWTUNE_MINf_GET(r) (((r).dsc_vga_p1_misc_ctl[0]) & 0x3f)
#define BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr_VGA_HWTUNE_MINf_SET(r,f) (r).dsc_vga_p1_misc_ctl[0]=(((r).dsc_vga_p1_misc_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_VGA_P1_MISC_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_VGA_P1_MISC_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr,(_r._dsc_vga_p1_misc_ctl))
#define BCMI_TSCE16_XGXS_WRITE_DSC_VGA_P1_MISC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr,(_r._dsc_vga_p1_misc_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_VGA_P1_MISC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr,(_r._dsc_vga_p1_misc_ctl))
#define BCMI_TSCE16_XGXS_READLN_DSC_VGA_P1_MISC_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_vga_p1_misc_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_VGA_P1_MISC_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_vga_p1_misc_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_VGA_P1_MISC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_vga_p1_misc_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_VGA_P1_MISC_CTLr BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr
#define DSC_VGA_P1_MISC_CTLr_SIZE BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr_t DSC_VGA_P1_MISC_CTLr_t;
#define DSC_VGA_P1_MISC_CTLr_CLR BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr_CLR
#define DSC_VGA_P1_MISC_CTLr_SET BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr_SET
#define DSC_VGA_P1_MISC_CTLr_GET BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr_GET
#define DSC_VGA_P1_MISC_CTLr_P1_HWTUNE_MINf_GET BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr_P1_HWTUNE_MINf_GET
#define DSC_VGA_P1_MISC_CTLr_P1_HWTUNE_MINf_SET BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr_P1_HWTUNE_MINf_SET
#define DSC_VGA_P1_MISC_CTLr_VGA_OP_SHORT_NORMf_GET BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr_VGA_OP_SHORT_NORMf_GET
#define DSC_VGA_P1_MISC_CTLr_VGA_OP_SHORT_NORMf_SET BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr_VGA_OP_SHORT_NORMf_SET
#define DSC_VGA_P1_MISC_CTLr_VGA_OP_SHORT_OFFCALf_GET BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr_VGA_OP_SHORT_OFFCALf_GET
#define DSC_VGA_P1_MISC_CTLr_VGA_OP_SHORT_OFFCALf_SET BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr_VGA_OP_SHORT_OFFCALf_SET
#define DSC_VGA_P1_MISC_CTLr_VGA_HWTUNE_MINf_GET BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr_VGA_HWTUNE_MINf_GET
#define DSC_VGA_P1_MISC_CTLr_VGA_HWTUNE_MINf_SET BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr_VGA_HWTUNE_MINf_SET
#define READ_DSC_VGA_P1_MISC_CTLr BCMI_TSCE16_XGXS_READ_DSC_VGA_P1_MISC_CTLr
#define WRITE_DSC_VGA_P1_MISC_CTLr BCMI_TSCE16_XGXS_WRITE_DSC_VGA_P1_MISC_CTLr
#define MODIFY_DSC_VGA_P1_MISC_CTLr BCMI_TSCE16_XGXS_MODIFY_DSC_VGA_P1_MISC_CTLr
#define READLN_DSC_VGA_P1_MISC_CTLr BCMI_TSCE16_XGXS_READLN_DSC_VGA_P1_MISC_CTLr
#define WRITELN_DSC_VGA_P1_MISC_CTLr BCMI_TSCE16_XGXS_WRITELN_DSC_VGA_P1_MISC_CTLr
#define WRITEALL_DSC_VGA_P1_MISC_CTLr BCMI_TSCE16_XGXS_WRITEALL_DSC_VGA_P1_MISC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_VGA_P1_MISC_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_DC_SLCR_OFFS_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd029
 * DESC:     DC & Slicer Offset Hw-tune CTL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DC_OFFSET_EN     Enable the DC Offset Hardware.
 *     HW_DC_OFFSET_HYS_EN When 1, hysteresis is enabled on the error accumulator. An underflow/overflow resets the accumulator to 0.
 *     HW_DC_OFFSET_ERR_GAIN multiplies the error by 2^{0,1,2,3}
 *     DC_OFFSET_INV    When 1, the m1 slicer is inverted.
 *     DC_OFFSET_PATTERN_INV_EN When 1, the pattern is matched or the inverse of the pattern is matched. {1,0,X} <=> {0,1,X}
 *     HW_DC_OFFSET_GRAD_INV inverts the gradient of the adaptation when 1.
 *     DC_OFFSET_PATTERN pattern,  range [2:0] corresponds to indexes [2:-1] , where lower indexes are earlier in time samples
 *     DC_OFFSET_PATTERN_BIT_EN pattern bit mask,   range [2:0] corresponds to indexes [2:-1] , where lower indexes are earlier in time samples
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr (0x0000d029 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DC_SLCR_OFFS_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_dc_slcr_offs_ctl[1];
	uint32_t _dsc_dc_slcr_offs_ctl;
} BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_t;

#define BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_CLR(r) (r).dsc_dc_slcr_offs_ctl[0] = 0
#define BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_SET(r,d) (r).dsc_dc_slcr_offs_ctl[0] = d
#define BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_GET(r) (r).dsc_dc_slcr_offs_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_DC_OFFSET_PATTERN_BIT_ENf_GET(r) ((((r).dsc_dc_slcr_offs_ctl[0]) >> 12) & 0xf)
#define BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_DC_OFFSET_PATTERN_BIT_ENf_SET(r,f) (r).dsc_dc_slcr_offs_ctl[0]=(((r).dsc_dc_slcr_offs_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_DC_OFFSET_PATTERNf_GET(r) ((((r).dsc_dc_slcr_offs_ctl[0]) >> 8) & 0xf)
#define BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_DC_OFFSET_PATTERNf_SET(r,f) (r).dsc_dc_slcr_offs_ctl[0]=(((r).dsc_dc_slcr_offs_ctl[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_HW_DC_OFFSET_GRAD_INVf_GET(r) ((((r).dsc_dc_slcr_offs_ctl[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_HW_DC_OFFSET_GRAD_INVf_SET(r,f) (r).dsc_dc_slcr_offs_ctl[0]=(((r).dsc_dc_slcr_offs_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_DC_OFFSET_PATTERN_INV_ENf_GET(r) ((((r).dsc_dc_slcr_offs_ctl[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_DC_OFFSET_PATTERN_INV_ENf_SET(r,f) (r).dsc_dc_slcr_offs_ctl[0]=(((r).dsc_dc_slcr_offs_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_DC_OFFSET_INVf_GET(r) ((((r).dsc_dc_slcr_offs_ctl[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_DC_OFFSET_INVf_SET(r,f) (r).dsc_dc_slcr_offs_ctl[0]=(((r).dsc_dc_slcr_offs_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_HW_DC_OFFSET_ERR_GAINf_GET(r) ((((r).dsc_dc_slcr_offs_ctl[0]) >> 2) & 0x3)
#define BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_HW_DC_OFFSET_ERR_GAINf_SET(r,f) (r).dsc_dc_slcr_offs_ctl[0]=(((r).dsc_dc_slcr_offs_ctl[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_HW_DC_OFFSET_HYS_ENf_GET(r) ((((r).dsc_dc_slcr_offs_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_HW_DC_OFFSET_HYS_ENf_SET(r,f) (r).dsc_dc_slcr_offs_ctl[0]=(((r).dsc_dc_slcr_offs_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_DC_OFFSET_ENf_GET(r) (((r).dsc_dc_slcr_offs_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_DC_OFFSET_ENf_SET(r,f) (r).dsc_dc_slcr_offs_ctl[0]=(((r).dsc_dc_slcr_offs_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_DC_SLCR_OFFS_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_DC_SLCR_OFFS_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr,(_r._dsc_dc_slcr_offs_ctl))
#define BCMI_TSCE16_XGXS_WRITE_DSC_DC_SLCR_OFFS_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr,(_r._dsc_dc_slcr_offs_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_DC_SLCR_OFFS_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr,(_r._dsc_dc_slcr_offs_ctl))
#define BCMI_TSCE16_XGXS_READLN_DSC_DC_SLCR_OFFS_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dc_slcr_offs_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_DC_SLCR_OFFS_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dc_slcr_offs_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_DC_SLCR_OFFS_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_dc_slcr_offs_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_DC_SLCR_OFFS_CTLr BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr
#define DSC_DC_SLCR_OFFS_CTLr_SIZE BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_t DSC_DC_SLCR_OFFS_CTLr_t;
#define DSC_DC_SLCR_OFFS_CTLr_CLR BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_CLR
#define DSC_DC_SLCR_OFFS_CTLr_SET BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_SET
#define DSC_DC_SLCR_OFFS_CTLr_GET BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_GET
#define DSC_DC_SLCR_OFFS_CTLr_DC_OFFSET_PATTERN_BIT_ENf_GET BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_DC_OFFSET_PATTERN_BIT_ENf_GET
#define DSC_DC_SLCR_OFFS_CTLr_DC_OFFSET_PATTERN_BIT_ENf_SET BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_DC_OFFSET_PATTERN_BIT_ENf_SET
#define DSC_DC_SLCR_OFFS_CTLr_DC_OFFSET_PATTERNf_GET BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_DC_OFFSET_PATTERNf_GET
#define DSC_DC_SLCR_OFFS_CTLr_DC_OFFSET_PATTERNf_SET BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_DC_OFFSET_PATTERNf_SET
#define DSC_DC_SLCR_OFFS_CTLr_HW_DC_OFFSET_GRAD_INVf_GET BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_HW_DC_OFFSET_GRAD_INVf_GET
#define DSC_DC_SLCR_OFFS_CTLr_HW_DC_OFFSET_GRAD_INVf_SET BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_HW_DC_OFFSET_GRAD_INVf_SET
#define DSC_DC_SLCR_OFFS_CTLr_DC_OFFSET_PATTERN_INV_ENf_GET BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_DC_OFFSET_PATTERN_INV_ENf_GET
#define DSC_DC_SLCR_OFFS_CTLr_DC_OFFSET_PATTERN_INV_ENf_SET BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_DC_OFFSET_PATTERN_INV_ENf_SET
#define DSC_DC_SLCR_OFFS_CTLr_DC_OFFSET_INVf_GET BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_DC_OFFSET_INVf_GET
#define DSC_DC_SLCR_OFFS_CTLr_DC_OFFSET_INVf_SET BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_DC_OFFSET_INVf_SET
#define DSC_DC_SLCR_OFFS_CTLr_HW_DC_OFFSET_ERR_GAINf_GET BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_HW_DC_OFFSET_ERR_GAINf_GET
#define DSC_DC_SLCR_OFFS_CTLr_HW_DC_OFFSET_ERR_GAINf_SET BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_HW_DC_OFFSET_ERR_GAINf_SET
#define DSC_DC_SLCR_OFFS_CTLr_HW_DC_OFFSET_HYS_ENf_GET BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_HW_DC_OFFSET_HYS_ENf_GET
#define DSC_DC_SLCR_OFFS_CTLr_HW_DC_OFFSET_HYS_ENf_SET BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_HW_DC_OFFSET_HYS_ENf_SET
#define DSC_DC_SLCR_OFFS_CTLr_DC_OFFSET_ENf_GET BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_DC_OFFSET_ENf_GET
#define DSC_DC_SLCR_OFFS_CTLr_DC_OFFSET_ENf_SET BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr_DC_OFFSET_ENf_SET
#define READ_DSC_DC_SLCR_OFFS_CTLr BCMI_TSCE16_XGXS_READ_DSC_DC_SLCR_OFFS_CTLr
#define WRITE_DSC_DC_SLCR_OFFS_CTLr BCMI_TSCE16_XGXS_WRITE_DSC_DC_SLCR_OFFS_CTLr
#define MODIFY_DSC_DC_SLCR_OFFS_CTLr BCMI_TSCE16_XGXS_MODIFY_DSC_DC_SLCR_OFFS_CTLr
#define READLN_DSC_DC_SLCR_OFFS_CTLr BCMI_TSCE16_XGXS_READLN_DSC_DC_SLCR_OFFS_CTLr
#define WRITELN_DSC_DC_SLCR_OFFS_CTLr BCMI_TSCE16_XGXS_WRITELN_DSC_DC_SLCR_OFFS_CTLr
#define WRITEALL_DSC_DC_SLCR_OFFS_CTLr BCMI_TSCE16_XGXS_WRITEALL_DSC_DC_SLCR_OFFS_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_DC_SLCR_OFFS_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_SLCR_OFFS_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd02a
 * DESC:     Slicer Offset Hw-tune CTL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     HW_SLICER_OFFSET_EN When 1, the slicer_offset hardware is enabled.
 *     HW_SLICER_OFFSET_HYS_EN When 1, hysteresis is enabledWhenever the penultimate error accumulator over/under flows, it returns to 0.
 *     HW_SLICER_OFFSET_ERR_GAIN Multiplies the error calculated by 2^{gain = 0,1,2,3}
 *     HW_SLICER_OFFSET_INV_DATA When 1, this inverts the data being used by the slicer offset hardware
 *     HW_SLICER_OFFSET_INV_M1 When 1, this inverts the m1 being used by the slicer offset hardware
 *     HW_SLICER_OFFSET_INV_P1 When 1, this inverts the p1 being used by the slicer offset hardware
 *     HW_SLICER_OFFSET_GRAD_INV When 1, this inverts the gradient of the adaptation
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr (0x0000d02a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SLCR_OFFS_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_slcr_offs_ctl[1];
	uint32_t _dsc_slcr_offs_ctl;
} BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_t;

#define BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_CLR(r) (r).dsc_slcr_offs_ctl[0] = 0
#define BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_SET(r,d) (r).dsc_slcr_offs_ctl[0] = d
#define BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_GET(r) (r).dsc_slcr_offs_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_GRAD_INVf_GET(r) ((((r).dsc_slcr_offs_ctl[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_GRAD_INVf_SET(r,f) (r).dsc_slcr_offs_ctl[0]=(((r).dsc_slcr_offs_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_INV_P1f_GET(r) ((((r).dsc_slcr_offs_ctl[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_INV_P1f_SET(r,f) (r).dsc_slcr_offs_ctl[0]=(((r).dsc_slcr_offs_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_INV_M1f_GET(r) ((((r).dsc_slcr_offs_ctl[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_INV_M1f_SET(r,f) (r).dsc_slcr_offs_ctl[0]=(((r).dsc_slcr_offs_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_INV_DATAf_GET(r) ((((r).dsc_slcr_offs_ctl[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_INV_DATAf_SET(r,f) (r).dsc_slcr_offs_ctl[0]=(((r).dsc_slcr_offs_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_ERR_GAINf_GET(r) ((((r).dsc_slcr_offs_ctl[0]) >> 2) & 0x3)
#define BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_ERR_GAINf_SET(r,f) (r).dsc_slcr_offs_ctl[0]=(((r).dsc_slcr_offs_ctl[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_HYS_ENf_GET(r) ((((r).dsc_slcr_offs_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_HYS_ENf_SET(r,f) (r).dsc_slcr_offs_ctl[0]=(((r).dsc_slcr_offs_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_ENf_GET(r) (((r).dsc_slcr_offs_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_ENf_SET(r,f) (r).dsc_slcr_offs_ctl[0]=(((r).dsc_slcr_offs_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_SLCR_OFFS_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_SLCR_OFFS_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr,(_r._dsc_slcr_offs_ctl))
#define BCMI_TSCE16_XGXS_WRITE_DSC_SLCR_OFFS_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr,(_r._dsc_slcr_offs_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_SLCR_OFFS_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr,(_r._dsc_slcr_offs_ctl))
#define BCMI_TSCE16_XGXS_READLN_DSC_SLCR_OFFS_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_slcr_offs_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_SLCR_OFFS_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_slcr_offs_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_SLCR_OFFS_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_slcr_offs_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SLCR_OFFS_CTLr BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr
#define DSC_SLCR_OFFS_CTLr_SIZE BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_t DSC_SLCR_OFFS_CTLr_t;
#define DSC_SLCR_OFFS_CTLr_CLR BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_CLR
#define DSC_SLCR_OFFS_CTLr_SET BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_SET
#define DSC_SLCR_OFFS_CTLr_GET BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_GET
#define DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_GRAD_INVf_GET BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_GRAD_INVf_GET
#define DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_GRAD_INVf_SET BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_GRAD_INVf_SET
#define DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_INV_P1f_GET BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_INV_P1f_GET
#define DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_INV_P1f_SET BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_INV_P1f_SET
#define DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_INV_M1f_GET BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_INV_M1f_GET
#define DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_INV_M1f_SET BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_INV_M1f_SET
#define DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_INV_DATAf_GET BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_INV_DATAf_GET
#define DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_INV_DATAf_SET BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_INV_DATAf_SET
#define DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_ERR_GAINf_GET BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_ERR_GAINf_GET
#define DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_ERR_GAINf_SET BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_ERR_GAINf_SET
#define DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_HYS_ENf_GET BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_HYS_ENf_GET
#define DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_HYS_ENf_SET BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_HYS_ENf_SET
#define DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_ENf_GET BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_ENf_GET
#define DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_ENf_SET BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr_HW_SLICER_OFFSET_ENf_SET
#define READ_DSC_SLCR_OFFS_CTLr BCMI_TSCE16_XGXS_READ_DSC_SLCR_OFFS_CTLr
#define WRITE_DSC_SLCR_OFFS_CTLr BCMI_TSCE16_XGXS_WRITE_DSC_SLCR_OFFS_CTLr
#define MODIFY_DSC_SLCR_OFFS_CTLr BCMI_TSCE16_XGXS_MODIFY_DSC_SLCR_OFFS_CTLr
#define READLN_DSC_SLCR_OFFS_CTLr BCMI_TSCE16_XGXS_READLN_DSC_SLCR_OFFS_CTLr
#define WRITELN_DSC_SLCR_OFFS_CTLr BCMI_TSCE16_XGXS_WRITELN_DSC_SLCR_OFFS_CTLr
#define WRITEALL_DSC_SLCR_OFFS_CTLr BCMI_TSCE16_XGXS_WRITEALL_DSC_SLCR_OFFS_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_SLCR_OFFS_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_HWTUNE_OVR_OVRR
 * BLOCKS:   DSC_C
 * REGADDR:  0xd02b
 * DESC:     DFE Overrude
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     HWTUNE_OVR_WRITE_VAL override valuePlease refer to AMS document for working ranges of the signals.Please note that AMS document describes special encoded formats at the Analog IP boundary.However, the register interface uses standard 2's complement binary notation matching the interpretation and listed below.Select: Analog Control    Bits Used           Format and ranges==================================================================0: VGA                         [8:3]          (0..45)  (see vga_update_style for translation)1: Dfe1 cmn                    [5:0]          (0..63)2: Dfe1 odd                    [2:0]          (0..7)3: Dfe1 even                   [2:0]          (0..7)4: Dfe2 cmn                    [4:0]          (0..31)5: Dfe2 odd                    [2:0]          (0..4)6: Dfe2 even                   [2:0]          (0..4)7: Dfe3                        [5:0]          (-31..31) signed 2s complement8: Dfe4                        [4:0]          (-15..15) signed 2s complement9: Dfe5                        [4:0]          (-15..15) signed 2s complementA: Dfe2 sign evn               [0:0]          0: positive; 1: negativeB: Dfe2 sign odd               [0:0]          0: positive; 1: negativeD: rx_p1_eyediag               [8:3]          (-31..31) since analog treat sign = 1 as positive for this parameter; *-1 before writing.E: VGA1                        [3:0]          (0..15) unsignedF: VGA2                        [3:0]          (0..15) unsigned10:VGA3                        [3:0]          (0..31) unsigned11:Data Odd  Offset Control    [5:0]          (-31..31) signed12:Data Even Offset Control    [5:0]          (-31..31) signed13:P1 Odd  Offset Control      [5:0]          (-31..31) signed14:P1 Even Offset Control      [5:0]          (-31..31) signed15:M1 Odd  Offset Control      [5:0]          (-31..31) signed16:M1 Even Offset Control      [5:0]          (-31..31) signed17:DC Offset Control           [6:0]          (-63..63) signed
 *     HWTUNE_OVR_WRITE_SEL 'h0 = vga(see vga_update_style for translation information"'h{1,2,3} = {tap 1 cmn, odd, evn}; {4,5,6,a,b} = {tap 2 cmn, odd, evn, sign even, sign odd}'h{7,8,9} = dfe tap 3 ,4, 5'hd = p1_eyediag'he = vga1 ctrl, write vga_update_style to 3'hf = vga2 ctrl, write vga_update_style to 3'h10 = vga3 ctrl, write vga_update_style to 3'h11 = Data Odd  ctrl'h12 = Data Even ctrl'h13 = P1 Odd ctrl'h14 = P1 Even ctrl'h15 = M1 Odd ctrl'h16 = M1 Even ctrl'h17 = DC Offset ctrl
 *     HWTUNE_OVR_WRITE_EN a 1 on this enables the firmware to write the tap valuesFirst set valid values on hwtune_ovr_write_tapsel and hwtune_ovr_write_val and then set this self clear bit to 1Self Clearing
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_HWTUNE_OVR_OVRRr (0x0000d02b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_HWTUNE_OVR_OVRRr_SIZE 4

/*
 * This structure should be used to declare and program DSC_HWTUNE_OVR_OVRR.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_HWTUNE_OVR_OVRRr_s {
	uint32_t v[1];
	uint32_t dsc_hwtune_ovr_ovrr[1];
	uint32_t _dsc_hwtune_ovr_ovrr;
} BCMI_TSCE16_XGXS_DSC_HWTUNE_OVR_OVRRr_t;

#define BCMI_TSCE16_XGXS_DSC_HWTUNE_OVR_OVRRr_CLR(r) (r).dsc_hwtune_ovr_ovrr[0] = 0
#define BCMI_TSCE16_XGXS_DSC_HWTUNE_OVR_OVRRr_SET(r,d) (r).dsc_hwtune_ovr_ovrr[0] = d
#define BCMI_TSCE16_XGXS_DSC_HWTUNE_OVR_OVRRr_GET(r) (r).dsc_hwtune_ovr_ovrr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_HWTUNE_OVR_OVRRr_HWTUNE_OVR_WRITE_ENf_GET(r) ((((r).dsc_hwtune_ovr_ovrr[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_HWTUNE_OVR_OVRRr_HWTUNE_OVR_WRITE_ENf_SET(r,f) (r).dsc_hwtune_ovr_ovrr[0]=(((r).dsc_hwtune_ovr_ovrr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_DSC_HWTUNE_OVR_OVRRr_HWTUNE_OVR_WRITE_SELf_GET(r) ((((r).dsc_hwtune_ovr_ovrr[0]) >> 9) & 0x1f)
#define BCMI_TSCE16_XGXS_DSC_HWTUNE_OVR_OVRRr_HWTUNE_OVR_WRITE_SELf_SET(r,f) (r).dsc_hwtune_ovr_ovrr[0]=(((r).dsc_hwtune_ovr_ovrr[0] & ~((uint32_t)0x1f << 9)) | ((((uint32_t)f) & 0x1f) << 9)) | (31 << (16 + 9))
#define BCMI_TSCE16_XGXS_DSC_HWTUNE_OVR_OVRRr_HWTUNE_OVR_WRITE_VALf_GET(r) (((r).dsc_hwtune_ovr_ovrr[0]) & 0x1ff)
#define BCMI_TSCE16_XGXS_DSC_HWTUNE_OVR_OVRRr_HWTUNE_OVR_WRITE_VALf_SET(r,f) (r).dsc_hwtune_ovr_ovrr[0]=(((r).dsc_hwtune_ovr_ovrr[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff)) | (0x1ff << 16)

/*
 * These macros can be used to access DSC_HWTUNE_OVR_OVRR.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_HWTUNE_OVR_OVRRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_HWTUNE_OVR_OVRRr,(_r._dsc_hwtune_ovr_ovrr))
#define BCMI_TSCE16_XGXS_WRITE_DSC_HWTUNE_OVR_OVRRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_HWTUNE_OVR_OVRRr,(_r._dsc_hwtune_ovr_ovrr)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_HWTUNE_OVR_OVRRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_HWTUNE_OVR_OVRRr,(_r._dsc_hwtune_ovr_ovrr))
#define BCMI_TSCE16_XGXS_READLN_DSC_HWTUNE_OVR_OVRRr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_HWTUNE_OVR_OVRRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_hwtune_ovr_ovrr))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_HWTUNE_OVR_OVRRr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_HWTUNE_OVR_OVRRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_hwtune_ovr_ovrr))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_HWTUNE_OVR_OVRRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_HWTUNE_OVR_OVRRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_hwtune_ovr_ovrr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_HWTUNE_OVR_OVRRr BCMI_TSCE16_XGXS_DSC_HWTUNE_OVR_OVRRr
#define DSC_HWTUNE_OVR_OVRRr_SIZE BCMI_TSCE16_XGXS_DSC_HWTUNE_OVR_OVRRr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_HWTUNE_OVR_OVRRr_t DSC_HWTUNE_OVR_OVRRr_t;
#define DSC_HWTUNE_OVR_OVRRr_CLR BCMI_TSCE16_XGXS_DSC_HWTUNE_OVR_OVRRr_CLR
#define DSC_HWTUNE_OVR_OVRRr_SET BCMI_TSCE16_XGXS_DSC_HWTUNE_OVR_OVRRr_SET
#define DSC_HWTUNE_OVR_OVRRr_GET BCMI_TSCE16_XGXS_DSC_HWTUNE_OVR_OVRRr_GET
#define DSC_HWTUNE_OVR_OVRRr_HWTUNE_OVR_WRITE_ENf_GET BCMI_TSCE16_XGXS_DSC_HWTUNE_OVR_OVRRr_HWTUNE_OVR_WRITE_ENf_GET
#define DSC_HWTUNE_OVR_OVRRr_HWTUNE_OVR_WRITE_ENf_SET BCMI_TSCE16_XGXS_DSC_HWTUNE_OVR_OVRRr_HWTUNE_OVR_WRITE_ENf_SET
#define DSC_HWTUNE_OVR_OVRRr_HWTUNE_OVR_WRITE_SELf_GET BCMI_TSCE16_XGXS_DSC_HWTUNE_OVR_OVRRr_HWTUNE_OVR_WRITE_SELf_GET
#define DSC_HWTUNE_OVR_OVRRr_HWTUNE_OVR_WRITE_SELf_SET BCMI_TSCE16_XGXS_DSC_HWTUNE_OVR_OVRRr_HWTUNE_OVR_WRITE_SELf_SET
#define DSC_HWTUNE_OVR_OVRRr_HWTUNE_OVR_WRITE_VALf_GET BCMI_TSCE16_XGXS_DSC_HWTUNE_OVR_OVRRr_HWTUNE_OVR_WRITE_VALf_GET
#define DSC_HWTUNE_OVR_OVRRr_HWTUNE_OVR_WRITE_VALf_SET BCMI_TSCE16_XGXS_DSC_HWTUNE_OVR_OVRRr_HWTUNE_OVR_WRITE_VALf_SET
#define READ_DSC_HWTUNE_OVR_OVRRr BCMI_TSCE16_XGXS_READ_DSC_HWTUNE_OVR_OVRRr
#define WRITE_DSC_HWTUNE_OVR_OVRRr BCMI_TSCE16_XGXS_WRITE_DSC_HWTUNE_OVR_OVRRr
#define MODIFY_DSC_HWTUNE_OVR_OVRRr BCMI_TSCE16_XGXS_MODIFY_DSC_HWTUNE_OVR_OVRRr
#define READLN_DSC_HWTUNE_OVR_OVRRr BCMI_TSCE16_XGXS_READLN_DSC_HWTUNE_OVR_OVRRr
#define WRITELN_DSC_HWTUNE_OVR_OVRRr BCMI_TSCE16_XGXS_WRITELN_DSC_HWTUNE_OVR_OVRRr
#define WRITEALL_DSC_HWTUNE_OVR_OVRRr BCMI_TSCE16_XGXS_WRITEALL_DSC_HWTUNE_OVR_OVRRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_HWTUNE_OVR_OVRRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_VGA_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd02c
 * DESC:     VGA Control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     VGA_P1_ACC_CLR   clears the vga and p1 related accumulators and intermediate stagesbut not the final tap values which interface to the analog.
 *     VGA_ACC_HYS_EN   enables hysteresis on vga accumulators
 *     VGA_UPDATE_STYLE 0: populate vga1 first till it is at max and then vga2 and then vga31: populate vga3 first till it is at max and then vga2 and then vga12: populate vga1 first by 1 and then vga2 and then vga3 (so all the vgas are balanced)3: write to 3 when manually overriding to vga1, 2, or 3 independently - this disables the vga_sum from being translated into vga1,2,3
 *     VGA_AFFECTED_BY_DFE1 0: DFE 1 tap values cannot affect VGA adaptation1: VGA lowering is not allowed if DFE tap1 wants to go negative
 *     VGA_UPDATE_GAIN  vga update gain *1,2,4,8
 *     VGA_INV_P1       invert p1
 *     VGA_INV_M1       invert m1
 *     VGA_ERR_GAIN     error scaled by 2^vga_err_gain
 *     VGA_P1_GRADIENT_INVERT invert the gradient of the inc/dec going into the vga accumulators
 *     VGA_ERR_SEL      00: emux, 01: p1, 02: m1, 03: nemuxemux = d? p1:m1; nemux = ~d? p1: m1
 *     VGA_EN           Enables the tap for adaptive eq
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_VGA_CTLr (0x0000d02c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_VGA_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_VGA_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_VGA_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_vga_ctl[1];
	uint32_t _dsc_vga_ctl;
} BCMI_TSCE16_XGXS_DSC_VGA_CTLr_t;

#define BCMI_TSCE16_XGXS_DSC_VGA_CTLr_CLR(r) (r).dsc_vga_ctl[0] = 0
#define BCMI_TSCE16_XGXS_DSC_VGA_CTLr_SET(r,d) (r).dsc_vga_ctl[0] = d
#define BCMI_TSCE16_XGXS_DSC_VGA_CTLr_GET(r) (r).dsc_vga_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_ENf_GET(r) ((((r).dsc_vga_ctl[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_ENf_SET(r,f) (r).dsc_vga_ctl[0]=(((r).dsc_vga_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_ERR_SELf_GET(r) ((((r).dsc_vga_ctl[0]) >> 13) & 0x3)
#define BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_ERR_SELf_SET(r,f) (r).dsc_vga_ctl[0]=(((r).dsc_vga_ctl[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13)) | (3 << (16 + 13))
#define BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_P1_GRADIENT_INVERTf_GET(r) ((((r).dsc_vga_ctl[0]) >> 12) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_P1_GRADIENT_INVERTf_SET(r,f) (r).dsc_vga_ctl[0]=(((r).dsc_vga_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_ERR_GAINf_GET(r) ((((r).dsc_vga_ctl[0]) >> 10) & 0x3)
#define BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_ERR_GAINf_SET(r,f) (r).dsc_vga_ctl[0]=(((r).dsc_vga_ctl[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_INV_M1f_GET(r) ((((r).dsc_vga_ctl[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_INV_M1f_SET(r,f) (r).dsc_vga_ctl[0]=(((r).dsc_vga_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_INV_P1f_GET(r) ((((r).dsc_vga_ctl[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_INV_P1f_SET(r,f) (r).dsc_vga_ctl[0]=(((r).dsc_vga_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_UPDATE_GAINf_GET(r) ((((r).dsc_vga_ctl[0]) >> 6) & 0x3)
#define BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_UPDATE_GAINf_SET(r,f) (r).dsc_vga_ctl[0]=(((r).dsc_vga_ctl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_AFFECTED_BY_DFE1f_GET(r) ((((r).dsc_vga_ctl[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_AFFECTED_BY_DFE1f_SET(r,f) (r).dsc_vga_ctl[0]=(((r).dsc_vga_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_UPDATE_STYLEf_GET(r) ((((r).dsc_vga_ctl[0]) >> 2) & 0x3)
#define BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_UPDATE_STYLEf_SET(r,f) (r).dsc_vga_ctl[0]=(((r).dsc_vga_ctl[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_ACC_HYS_ENf_GET(r) ((((r).dsc_vga_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_ACC_HYS_ENf_SET(r,f) (r).dsc_vga_ctl[0]=(((r).dsc_vga_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_P1_ACC_CLRf_GET(r) (((r).dsc_vga_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_P1_ACC_CLRf_SET(r,f) (r).dsc_vga_ctl[0]=(((r).dsc_vga_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_VGA_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_VGA_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_VGA_CTLr,(_r._dsc_vga_ctl))
#define BCMI_TSCE16_XGXS_WRITE_DSC_VGA_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_VGA_CTLr,(_r._dsc_vga_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_VGA_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_VGA_CTLr,(_r._dsc_vga_ctl))
#define BCMI_TSCE16_XGXS_READLN_DSC_VGA_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_VGA_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_vga_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_VGA_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_VGA_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_vga_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_VGA_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_VGA_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_vga_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_VGA_CTLr BCMI_TSCE16_XGXS_DSC_VGA_CTLr
#define DSC_VGA_CTLr_SIZE BCMI_TSCE16_XGXS_DSC_VGA_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_VGA_CTLr_t DSC_VGA_CTLr_t;
#define DSC_VGA_CTLr_CLR BCMI_TSCE16_XGXS_DSC_VGA_CTLr_CLR
#define DSC_VGA_CTLr_SET BCMI_TSCE16_XGXS_DSC_VGA_CTLr_SET
#define DSC_VGA_CTLr_GET BCMI_TSCE16_XGXS_DSC_VGA_CTLr_GET
#define DSC_VGA_CTLr_VGA_ENf_GET BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_ENf_GET
#define DSC_VGA_CTLr_VGA_ENf_SET BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_ENf_SET
#define DSC_VGA_CTLr_VGA_ERR_SELf_GET BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_ERR_SELf_GET
#define DSC_VGA_CTLr_VGA_ERR_SELf_SET BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_ERR_SELf_SET
#define DSC_VGA_CTLr_VGA_P1_GRADIENT_INVERTf_GET BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_P1_GRADIENT_INVERTf_GET
#define DSC_VGA_CTLr_VGA_P1_GRADIENT_INVERTf_SET BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_P1_GRADIENT_INVERTf_SET
#define DSC_VGA_CTLr_VGA_ERR_GAINf_GET BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_ERR_GAINf_GET
#define DSC_VGA_CTLr_VGA_ERR_GAINf_SET BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_ERR_GAINf_SET
#define DSC_VGA_CTLr_VGA_INV_M1f_GET BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_INV_M1f_GET
#define DSC_VGA_CTLr_VGA_INV_M1f_SET BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_INV_M1f_SET
#define DSC_VGA_CTLr_VGA_INV_P1f_GET BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_INV_P1f_GET
#define DSC_VGA_CTLr_VGA_INV_P1f_SET BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_INV_P1f_SET
#define DSC_VGA_CTLr_VGA_UPDATE_GAINf_GET BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_UPDATE_GAINf_GET
#define DSC_VGA_CTLr_VGA_UPDATE_GAINf_SET BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_UPDATE_GAINf_SET
#define DSC_VGA_CTLr_VGA_AFFECTED_BY_DFE1f_GET BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_AFFECTED_BY_DFE1f_GET
#define DSC_VGA_CTLr_VGA_AFFECTED_BY_DFE1f_SET BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_AFFECTED_BY_DFE1f_SET
#define DSC_VGA_CTLr_VGA_UPDATE_STYLEf_GET BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_UPDATE_STYLEf_GET
#define DSC_VGA_CTLr_VGA_UPDATE_STYLEf_SET BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_UPDATE_STYLEf_SET
#define DSC_VGA_CTLr_VGA_ACC_HYS_ENf_GET BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_ACC_HYS_ENf_GET
#define DSC_VGA_CTLr_VGA_ACC_HYS_ENf_SET BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_ACC_HYS_ENf_SET
#define DSC_VGA_CTLr_VGA_P1_ACC_CLRf_GET BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_P1_ACC_CLRf_GET
#define DSC_VGA_CTLr_VGA_P1_ACC_CLRf_SET BCMI_TSCE16_XGXS_DSC_VGA_CTLr_VGA_P1_ACC_CLRf_SET
#define READ_DSC_VGA_CTLr BCMI_TSCE16_XGXS_READ_DSC_VGA_CTLr
#define WRITE_DSC_VGA_CTLr BCMI_TSCE16_XGXS_WRITE_DSC_VGA_CTLr
#define MODIFY_DSC_VGA_CTLr BCMI_TSCE16_XGXS_MODIFY_DSC_VGA_CTLr
#define READLN_DSC_VGA_CTLr BCMI_TSCE16_XGXS_READLN_DSC_VGA_CTLr
#define WRITELN_DSC_VGA_CTLr BCMI_TSCE16_XGXS_WRITELN_DSC_VGA_CTLr
#define WRITEALL_DSC_VGA_CTLr BCMI_TSCE16_XGXS_WRITEALL_DSC_VGA_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_VGA_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_VGA_PAT_EYEDIAG_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd02d
 * DESC:     VGA Pat and P1 Eye Diag Control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     VGA_PATTERN      pattern, range [2:0] corresponds to indexes [2:-1] , where lower indexes are earlier in time samples
 *     VGA_PATTERN_BIT_EN pattern bit mask; range [2:0] corresponds to indexes [2:-1] , where lower indexes are earlier in time samples
 *     P1_EYEDIAG_EN    enable p1 eye diag
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr (0x0000d02d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_VGA_PAT_EYEDIAG_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_vga_pat_eyediag_ctl[1];
	uint32_t _dsc_vga_pat_eyediag_ctl;
} BCMI_TSCE16_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_t;

#define BCMI_TSCE16_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_CLR(r) (r).dsc_vga_pat_eyediag_ctl[0] = 0
#define BCMI_TSCE16_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_SET(r,d) (r).dsc_vga_pat_eyediag_ctl[0] = d
#define BCMI_TSCE16_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_GET(r) (r).dsc_vga_pat_eyediag_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_P1_EYEDIAG_ENf_GET(r) ((((r).dsc_vga_pat_eyediag_ctl[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_P1_EYEDIAG_ENf_SET(r,f) (r).dsc_vga_pat_eyediag_ctl[0]=(((r).dsc_vga_pat_eyediag_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_VGA_PATTERN_BIT_ENf_GET(r) ((((r).dsc_vga_pat_eyediag_ctl[0]) >> 4) & 0xf)
#define BCMI_TSCE16_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_VGA_PATTERN_BIT_ENf_SET(r,f) (r).dsc_vga_pat_eyediag_ctl[0]=(((r).dsc_vga_pat_eyediag_ctl[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_TSCE16_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_VGA_PATTERNf_GET(r) (((r).dsc_vga_pat_eyediag_ctl[0]) & 0xf)
#define BCMI_TSCE16_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_VGA_PATTERNf_SET(r,f) (r).dsc_vga_pat_eyediag_ctl[0]=(((r).dsc_vga_pat_eyediag_ctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_VGA_PAT_EYEDIAG_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_VGA_PAT_EYEDIAG_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr,(_r._dsc_vga_pat_eyediag_ctl))
#define BCMI_TSCE16_XGXS_WRITE_DSC_VGA_PAT_EYEDIAG_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr,(_r._dsc_vga_pat_eyediag_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_VGA_PAT_EYEDIAG_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr,(_r._dsc_vga_pat_eyediag_ctl))
#define BCMI_TSCE16_XGXS_READLN_DSC_VGA_PAT_EYEDIAG_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_vga_pat_eyediag_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_VGA_PAT_EYEDIAG_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_vga_pat_eyediag_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_VGA_PAT_EYEDIAG_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_vga_pat_eyediag_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_VGA_PAT_EYEDIAG_CTLr BCMI_TSCE16_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr
#define DSC_VGA_PAT_EYEDIAG_CTLr_SIZE BCMI_TSCE16_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_t DSC_VGA_PAT_EYEDIAG_CTLr_t;
#define DSC_VGA_PAT_EYEDIAG_CTLr_CLR BCMI_TSCE16_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_CLR
#define DSC_VGA_PAT_EYEDIAG_CTLr_SET BCMI_TSCE16_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_SET
#define DSC_VGA_PAT_EYEDIAG_CTLr_GET BCMI_TSCE16_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_GET
#define DSC_VGA_PAT_EYEDIAG_CTLr_P1_EYEDIAG_ENf_GET BCMI_TSCE16_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_P1_EYEDIAG_ENf_GET
#define DSC_VGA_PAT_EYEDIAG_CTLr_P1_EYEDIAG_ENf_SET BCMI_TSCE16_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_P1_EYEDIAG_ENf_SET
#define DSC_VGA_PAT_EYEDIAG_CTLr_VGA_PATTERN_BIT_ENf_GET BCMI_TSCE16_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_VGA_PATTERN_BIT_ENf_GET
#define DSC_VGA_PAT_EYEDIAG_CTLr_VGA_PATTERN_BIT_ENf_SET BCMI_TSCE16_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_VGA_PATTERN_BIT_ENf_SET
#define DSC_VGA_PAT_EYEDIAG_CTLr_VGA_PATTERNf_GET BCMI_TSCE16_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_VGA_PATTERNf_GET
#define DSC_VGA_PAT_EYEDIAG_CTLr_VGA_PATTERNf_SET BCMI_TSCE16_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr_VGA_PATTERNf_SET
#define READ_DSC_VGA_PAT_EYEDIAG_CTLr BCMI_TSCE16_XGXS_READ_DSC_VGA_PAT_EYEDIAG_CTLr
#define WRITE_DSC_VGA_PAT_EYEDIAG_CTLr BCMI_TSCE16_XGXS_WRITE_DSC_VGA_PAT_EYEDIAG_CTLr
#define MODIFY_DSC_VGA_PAT_EYEDIAG_CTLr BCMI_TSCE16_XGXS_MODIFY_DSC_VGA_PAT_EYEDIAG_CTLr
#define READLN_DSC_VGA_PAT_EYEDIAG_CTLr BCMI_TSCE16_XGXS_READLN_DSC_VGA_PAT_EYEDIAG_CTLr
#define WRITELN_DSC_VGA_PAT_EYEDIAG_CTLr BCMI_TSCE16_XGXS_WRITELN_DSC_VGA_PAT_EYEDIAG_CTLr
#define WRITEALL_DSC_VGA_PAT_EYEDIAG_CTLr BCMI_TSCE16_XGXS_WRITEALL_DSC_VGA_PAT_EYEDIAG_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_VGA_PAT_EYEDIAG_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_P1_FRAC_OFFS_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd02e
 * DESC:     P1 Fractional Offset Control
 * RESETVAL: 0xc400 (50176)
 * ACCESS:   R/W
 * FIELDS:
 *     P1_OFFSET        range is from -64 to +63. It is mapped to -64/64 to 63/64 error which gets added into the accumulator path. This adds into the +20 to -20 range error signal.
 *     P1_OFFSET_EN     Enables the Delta Sigma Fractional Offset hardware
 *     P1_OFF_3LEVELQ_EN This enables the 3 level quantizer when set +1/-1/0. Else the quantizer is 2 level +1/-1
 *     P1_HWTUNE_MAX    A signed maximum limit which the hardware loop respects during adaptation.Must be greater than the p1_hwtune_min.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr (0x0000d02e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_P1_FRAC_OFFS_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_p1_frac_offs_ctl[1];
	uint32_t _dsc_p1_frac_offs_ctl;
} BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr_t;

#define BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr_CLR(r) (r).dsc_p1_frac_offs_ctl[0] = 0
#define BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr_SET(r,d) (r).dsc_p1_frac_offs_ctl[0] = d
#define BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr_GET(r) (r).dsc_p1_frac_offs_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr_P1_HWTUNE_MAXf_GET(r) ((((r).dsc_p1_frac_offs_ctl[0]) >> 10) & 0x3f)
#define BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr_P1_HWTUNE_MAXf_SET(r,f) (r).dsc_p1_frac_offs_ctl[0]=(((r).dsc_p1_frac_offs_ctl[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10)) | (63 << (16 + 10))
#define BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr_P1_OFF_3LEVELQ_ENf_GET(r) ((((r).dsc_p1_frac_offs_ctl[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr_P1_OFF_3LEVELQ_ENf_SET(r,f) (r).dsc_p1_frac_offs_ctl[0]=(((r).dsc_p1_frac_offs_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr_P1_OFFSET_ENf_GET(r) ((((r).dsc_p1_frac_offs_ctl[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr_P1_OFFSET_ENf_SET(r,f) (r).dsc_p1_frac_offs_ctl[0]=(((r).dsc_p1_frac_offs_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr_P1_OFFSETf_GET(r) (((r).dsc_p1_frac_offs_ctl[0]) & 0x7f)
#define BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr_P1_OFFSETf_SET(r,f) (r).dsc_p1_frac_offs_ctl[0]=(((r).dsc_p1_frac_offs_ctl[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access DSC_P1_FRAC_OFFS_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_P1_FRAC_OFFS_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr,(_r._dsc_p1_frac_offs_ctl))
#define BCMI_TSCE16_XGXS_WRITE_DSC_P1_FRAC_OFFS_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr,(_r._dsc_p1_frac_offs_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_P1_FRAC_OFFS_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr,(_r._dsc_p1_frac_offs_ctl))
#define BCMI_TSCE16_XGXS_READLN_DSC_P1_FRAC_OFFS_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_p1_frac_offs_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_P1_FRAC_OFFS_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_p1_frac_offs_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_P1_FRAC_OFFS_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_p1_frac_offs_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_P1_FRAC_OFFS_CTLr BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr
#define DSC_P1_FRAC_OFFS_CTLr_SIZE BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr_t DSC_P1_FRAC_OFFS_CTLr_t;
#define DSC_P1_FRAC_OFFS_CTLr_CLR BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr_CLR
#define DSC_P1_FRAC_OFFS_CTLr_SET BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr_SET
#define DSC_P1_FRAC_OFFS_CTLr_GET BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr_GET
#define DSC_P1_FRAC_OFFS_CTLr_P1_HWTUNE_MAXf_GET BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr_P1_HWTUNE_MAXf_GET
#define DSC_P1_FRAC_OFFS_CTLr_P1_HWTUNE_MAXf_SET BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr_P1_HWTUNE_MAXf_SET
#define DSC_P1_FRAC_OFFS_CTLr_P1_OFF_3LEVELQ_ENf_GET BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr_P1_OFF_3LEVELQ_ENf_GET
#define DSC_P1_FRAC_OFFS_CTLr_P1_OFF_3LEVELQ_ENf_SET BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr_P1_OFF_3LEVELQ_ENf_SET
#define DSC_P1_FRAC_OFFS_CTLr_P1_OFFSET_ENf_GET BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr_P1_OFFSET_ENf_GET
#define DSC_P1_FRAC_OFFS_CTLr_P1_OFFSET_ENf_SET BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr_P1_OFFSET_ENf_SET
#define DSC_P1_FRAC_OFFS_CTLr_P1_OFFSETf_GET BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr_P1_OFFSETf_GET
#define DSC_P1_FRAC_OFFS_CTLr_P1_OFFSETf_SET BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr_P1_OFFSETf_SET
#define READ_DSC_P1_FRAC_OFFS_CTLr BCMI_TSCE16_XGXS_READ_DSC_P1_FRAC_OFFS_CTLr
#define WRITE_DSC_P1_FRAC_OFFS_CTLr BCMI_TSCE16_XGXS_WRITE_DSC_P1_FRAC_OFFS_CTLr
#define MODIFY_DSC_P1_FRAC_OFFS_CTLr BCMI_TSCE16_XGXS_MODIFY_DSC_P1_FRAC_OFFS_CTLr
#define READLN_DSC_P1_FRAC_OFFS_CTLr BCMI_TSCE16_XGXS_READLN_DSC_P1_FRAC_OFFS_CTLr
#define WRITELN_DSC_P1_FRAC_OFFS_CTLr BCMI_TSCE16_XGXS_WRITELN_DSC_P1_FRAC_OFFS_CTLr
#define WRITEALL_DSC_P1_FRAC_OFFS_CTLr BCMI_TSCE16_XGXS_WRITEALL_DSC_P1_FRAC_OFFS_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_P1_FRAC_OFFS_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_TRNSUM_CTL1
 * BLOCKS:   DSC_D
 * REGADDR:  0xd030
 * DESC:     Trnsum Ctl 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TRNSUM_TAP_RANGE_SEL 0: -2 to 5; 1: 6 to 13; 2: 14 to 21; 3: all 1s are selected as data
 *     CDR_QPHASE_MULT_EN enables qphase weighting
 *     TRNSUM_EYE_CLOSURE_EN when 1'b1, condition is anded with data!=emuxTrnsum sums {err*data} over certain {conditions}. This is part of the {conditions} .
 *     TRNSUM_GAIN      training sum error values get *1,2,4,8 or 2^{trnsum_gain}
 *     TRNSUM_EDGE_PATTERN_EN enables pattern matching on edges {-6,-5,-4,-3,-2,-1,data,0,1,2} where a number (eg: -4) represents an edge between d[-4] and d[-3]
 *     TRNSUM_PATTERN_FULL_CHECK_OFF training only enabled for bits 2 and 13
 *     TRNSUM_INV_PATTERN_EN when 1'b1, the pattern is randomly inverted for pattern match
 *     TRNSUM_RANDOM_TAPSEL_DISABLE disables random data tap selection
 *     TRNSUM_ERR_SEL   0: emux = d?p1:m1, 1: 1'b1, 2:m1, 3:p1, 4: d1=d?p1:~m1Trnsum sums {err*data} over certain {conditions}. This is the {err} part.
 *     TRNSUM_EN        enable training sum.A rising edge on this signal will clear the trnsum accumulator (status) registers.A probable use case would be to set it at the beginning of all measurements and clear it at the end. Clearing it should still retain the status register values.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r (0x0000d030 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_CTL1.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_ctl1[1];
	uint32_t _dsc_trnsum_ctl1;
} BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_t;

#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_CLR(r) (r).dsc_trnsum_ctl1[0] = 0
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_SET(r,d) (r).dsc_trnsum_ctl1[0] = d
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_GET(r) (r).dsc_trnsum_ctl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_ENf_GET(r) ((((r).dsc_trnsum_ctl1[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_ENf_SET(r,f) (r).dsc_trnsum_ctl1[0]=(((r).dsc_trnsum_ctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_ERR_SELf_GET(r) ((((r).dsc_trnsum_ctl1[0]) >> 12) & 0x7)
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_ERR_SELf_SET(r,f) (r).dsc_trnsum_ctl1[0]=(((r).dsc_trnsum_ctl1[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12)) | (7 << (16 + 12))
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_RANDOM_TAPSEL_DISABLEf_GET(r) ((((r).dsc_trnsum_ctl1[0]) >> 11) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_RANDOM_TAPSEL_DISABLEf_SET(r,f) (r).dsc_trnsum_ctl1[0]=(((r).dsc_trnsum_ctl1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_INV_PATTERN_ENf_GET(r) ((((r).dsc_trnsum_ctl1[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_INV_PATTERN_ENf_SET(r,f) (r).dsc_trnsum_ctl1[0]=(((r).dsc_trnsum_ctl1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_PATTERN_FULL_CHECK_OFFf_GET(r) ((((r).dsc_trnsum_ctl1[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_PATTERN_FULL_CHECK_OFFf_SET(r,f) (r).dsc_trnsum_ctl1[0]=(((r).dsc_trnsum_ctl1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_EDGE_PATTERN_ENf_GET(r) ((((r).dsc_trnsum_ctl1[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_EDGE_PATTERN_ENf_SET(r,f) (r).dsc_trnsum_ctl1[0]=(((r).dsc_trnsum_ctl1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_GAINf_GET(r) ((((r).dsc_trnsum_ctl1[0]) >> 6) & 0x3)
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_GAINf_SET(r,f) (r).dsc_trnsum_ctl1[0]=(((r).dsc_trnsum_ctl1[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_EYE_CLOSURE_ENf_GET(r) ((((r).dsc_trnsum_ctl1[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_EYE_CLOSURE_ENf_SET(r,f) (r).dsc_trnsum_ctl1[0]=(((r).dsc_trnsum_ctl1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_CDR_QPHASE_MULT_ENf_GET(r) ((((r).dsc_trnsum_ctl1[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_CDR_QPHASE_MULT_ENf_SET(r,f) (r).dsc_trnsum_ctl1[0]=(((r).dsc_trnsum_ctl1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_TAP_RANGE_SELf_GET(r) ((((r).dsc_trnsum_ctl1[0]) >> 2) & 0x3)
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_TAP_RANGE_SELf_SET(r,f) (r).dsc_trnsum_ctl1[0]=(((r).dsc_trnsum_ctl1[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))

/*
 * These macros can be used to access DSC_TRNSUM_CTL1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_TRNSUM_CTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r,(_r._dsc_trnsum_ctl1))
#define BCMI_TSCE16_XGXS_WRITE_DSC_TRNSUM_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r,(_r._dsc_trnsum_ctl1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_TRNSUM_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r,(_r._dsc_trnsum_ctl1))
#define BCMI_TSCE16_XGXS_READLN_DSC_TRNSUM_CTL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_ctl1))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_TRNSUM_CTL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_ctl1))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_TRNSUM_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_CTL1r BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r
#define DSC_TRNSUM_CTL1r_SIZE BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_SIZE
typedef BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_t DSC_TRNSUM_CTL1r_t;
#define DSC_TRNSUM_CTL1r_CLR BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_CLR
#define DSC_TRNSUM_CTL1r_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_SET
#define DSC_TRNSUM_CTL1r_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_GET
#define DSC_TRNSUM_CTL1r_TRNSUM_ENf_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_ENf_GET
#define DSC_TRNSUM_CTL1r_TRNSUM_ENf_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_ENf_SET
#define DSC_TRNSUM_CTL1r_TRNSUM_ERR_SELf_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_ERR_SELf_GET
#define DSC_TRNSUM_CTL1r_TRNSUM_ERR_SELf_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_ERR_SELf_SET
#define DSC_TRNSUM_CTL1r_TRNSUM_RANDOM_TAPSEL_DISABLEf_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_RANDOM_TAPSEL_DISABLEf_GET
#define DSC_TRNSUM_CTL1r_TRNSUM_RANDOM_TAPSEL_DISABLEf_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_RANDOM_TAPSEL_DISABLEf_SET
#define DSC_TRNSUM_CTL1r_TRNSUM_INV_PATTERN_ENf_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_INV_PATTERN_ENf_GET
#define DSC_TRNSUM_CTL1r_TRNSUM_INV_PATTERN_ENf_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_INV_PATTERN_ENf_SET
#define DSC_TRNSUM_CTL1r_TRNSUM_PATTERN_FULL_CHECK_OFFf_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_PATTERN_FULL_CHECK_OFFf_GET
#define DSC_TRNSUM_CTL1r_TRNSUM_PATTERN_FULL_CHECK_OFFf_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_PATTERN_FULL_CHECK_OFFf_SET
#define DSC_TRNSUM_CTL1r_TRNSUM_EDGE_PATTERN_ENf_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_EDGE_PATTERN_ENf_GET
#define DSC_TRNSUM_CTL1r_TRNSUM_EDGE_PATTERN_ENf_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_EDGE_PATTERN_ENf_SET
#define DSC_TRNSUM_CTL1r_TRNSUM_GAINf_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_GAINf_GET
#define DSC_TRNSUM_CTL1r_TRNSUM_GAINf_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_GAINf_SET
#define DSC_TRNSUM_CTL1r_TRNSUM_EYE_CLOSURE_ENf_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_EYE_CLOSURE_ENf_GET
#define DSC_TRNSUM_CTL1r_TRNSUM_EYE_CLOSURE_ENf_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_EYE_CLOSURE_ENf_SET
#define DSC_TRNSUM_CTL1r_CDR_QPHASE_MULT_ENf_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_CDR_QPHASE_MULT_ENf_GET
#define DSC_TRNSUM_CTL1r_CDR_QPHASE_MULT_ENf_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_CDR_QPHASE_MULT_ENf_SET
#define DSC_TRNSUM_CTL1r_TRNSUM_TAP_RANGE_SELf_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_TAP_RANGE_SELf_GET
#define DSC_TRNSUM_CTL1r_TRNSUM_TAP_RANGE_SELf_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r_TRNSUM_TAP_RANGE_SELf_SET
#define READ_DSC_TRNSUM_CTL1r BCMI_TSCE16_XGXS_READ_DSC_TRNSUM_CTL1r
#define WRITE_DSC_TRNSUM_CTL1r BCMI_TSCE16_XGXS_WRITE_DSC_TRNSUM_CTL1r
#define MODIFY_DSC_TRNSUM_CTL1r BCMI_TSCE16_XGXS_MODIFY_DSC_TRNSUM_CTL1r
#define READLN_DSC_TRNSUM_CTL1r BCMI_TSCE16_XGXS_READLN_DSC_TRNSUM_CTL1r
#define WRITELN_DSC_TRNSUM_CTL1r BCMI_TSCE16_XGXS_WRITELN_DSC_TRNSUM_CTL1r
#define WRITEALL_DSC_TRNSUM_CTL1r BCMI_TSCE16_XGXS_WRITEALL_DSC_TRNSUM_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_TRNSUM_CTL2
 * BLOCKS:   DSC_D
 * REGADDR:  0xd031
 * DESC:     Trnsum Ctl 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TRNSUM_PATTERN_BIT_EN trnsum pattern maskWhen a particular location is 0; it is ignored for pattern match.The bit association is the same as trnsum_pattern.
 *     TRNSUM_PATTERN   trnsum pattern.Trnsum sums {err*data} over certain {conditions}. This is part of the {conditions} .The data around the current bit is compared to this pattern, and if it matches, condition is 1; else 0.{MSB->LSB} corresponds to {newer -> older} bits in time.{7:0] correspond to {2:-5} wrt current data bit.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL2r (0x0000d031 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_CTL2.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL2r_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_ctl2[1];
	uint32_t _dsc_trnsum_ctl2;
} BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL2r_t;

#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL2r_CLR(r) (r).dsc_trnsum_ctl2[0] = 0
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL2r_SET(r,d) (r).dsc_trnsum_ctl2[0] = d
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL2r_GET(r) (r).dsc_trnsum_ctl2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_PATTERNf_GET(r) ((((r).dsc_trnsum_ctl2[0]) >> 8) & 0xff)
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_PATTERNf_SET(r,f) (r).dsc_trnsum_ctl2[0]=(((r).dsc_trnsum_ctl2[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_PATTERN_BIT_ENf_GET(r) (((r).dsc_trnsum_ctl2[0]) & 0xff)
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_PATTERN_BIT_ENf_SET(r,f) (r).dsc_trnsum_ctl2[0]=(((r).dsc_trnsum_ctl2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_TRNSUM_CTL2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_TRNSUM_CTL2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL2r,(_r._dsc_trnsum_ctl2))
#define BCMI_TSCE16_XGXS_WRITE_DSC_TRNSUM_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL2r,(_r._dsc_trnsum_ctl2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_TRNSUM_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL2r,(_r._dsc_trnsum_ctl2))
#define BCMI_TSCE16_XGXS_READLN_DSC_TRNSUM_CTL2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_ctl2))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_TRNSUM_CTL2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_ctl2))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_TRNSUM_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_CTL2r BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL2r
#define DSC_TRNSUM_CTL2r_SIZE BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL2r_SIZE
typedef BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL2r_t DSC_TRNSUM_CTL2r_t;
#define DSC_TRNSUM_CTL2r_CLR BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL2r_CLR
#define DSC_TRNSUM_CTL2r_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL2r_SET
#define DSC_TRNSUM_CTL2r_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL2r_GET
#define DSC_TRNSUM_CTL2r_TRNSUM_PATTERNf_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_PATTERNf_GET
#define DSC_TRNSUM_CTL2r_TRNSUM_PATTERNf_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_PATTERNf_SET
#define DSC_TRNSUM_CTL2r_TRNSUM_PATTERN_BIT_ENf_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_PATTERN_BIT_ENf_GET
#define DSC_TRNSUM_CTL2r_TRNSUM_PATTERN_BIT_ENf_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL2r_TRNSUM_PATTERN_BIT_ENf_SET
#define READ_DSC_TRNSUM_CTL2r BCMI_TSCE16_XGXS_READ_DSC_TRNSUM_CTL2r
#define WRITE_DSC_TRNSUM_CTL2r BCMI_TSCE16_XGXS_WRITE_DSC_TRNSUM_CTL2r
#define MODIFY_DSC_TRNSUM_CTL2r BCMI_TSCE16_XGXS_MODIFY_DSC_TRNSUM_CTL2r
#define READLN_DSC_TRNSUM_CTL2r BCMI_TSCE16_XGXS_READLN_DSC_TRNSUM_CTL2r
#define WRITELN_DSC_TRNSUM_CTL2r BCMI_TSCE16_XGXS_WRITELN_DSC_TRNSUM_CTL2r
#define WRITEALL_DSC_TRNSUM_CTL2r BCMI_TSCE16_XGXS_WRITEALL_DSC_TRNSUM_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_TRNSUM_CTL3
 * BLOCKS:   DSC_D
 * REGADDR:  0xd032
 * DESC:     Trnsum Ctl 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TRNSUM_TAP_SIGN  trnsum tap signA 1'b1 at any location, indicates that the trnsum error for that tap will be negated (*-1) before accumulation.This one hot signal has similar associations as trnsum_tap_en.
 *     TRNSUM_TAP_EN    trnsum tap enableFor trnsum_tap_range_sel ==0; {15:8} correspond to {tap5, tap4, tap3, tap2, tap1, tap0, tapn1, tapn2}.Multiple taps can be enabled - this means that the training will randomly switch between different paths. (the random movement across enabled taps can be disabled)
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL3r (0x0000d032 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_CTL3.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL3r_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_ctl3[1];
	uint32_t _dsc_trnsum_ctl3;
} BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL3r_t;

#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL3r_CLR(r) (r).dsc_trnsum_ctl3[0] = 0
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL3r_SET(r,d) (r).dsc_trnsum_ctl3[0] = d
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL3r_GET(r) (r).dsc_trnsum_ctl3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL3r_TRNSUM_TAP_ENf_GET(r) ((((r).dsc_trnsum_ctl3[0]) >> 8) & 0xff)
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL3r_TRNSUM_TAP_ENf_SET(r,f) (r).dsc_trnsum_ctl3[0]=(((r).dsc_trnsum_ctl3[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL3r_TRNSUM_TAP_SIGNf_GET(r) (((r).dsc_trnsum_ctl3[0]) & 0xff)
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL3r_TRNSUM_TAP_SIGNf_SET(r,f) (r).dsc_trnsum_ctl3[0]=(((r).dsc_trnsum_ctl3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_TRNSUM_CTL3.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_TRNSUM_CTL3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL3r,(_r._dsc_trnsum_ctl3))
#define BCMI_TSCE16_XGXS_WRITE_DSC_TRNSUM_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL3r,(_r._dsc_trnsum_ctl3)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_TRNSUM_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL3r,(_r._dsc_trnsum_ctl3))
#define BCMI_TSCE16_XGXS_READLN_DSC_TRNSUM_CTL3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_ctl3))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_TRNSUM_CTL3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_ctl3))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_TRNSUM_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_ctl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_CTL3r BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL3r
#define DSC_TRNSUM_CTL3r_SIZE BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL3r_SIZE
typedef BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL3r_t DSC_TRNSUM_CTL3r_t;
#define DSC_TRNSUM_CTL3r_CLR BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL3r_CLR
#define DSC_TRNSUM_CTL3r_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL3r_SET
#define DSC_TRNSUM_CTL3r_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL3r_GET
#define DSC_TRNSUM_CTL3r_TRNSUM_TAP_ENf_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL3r_TRNSUM_TAP_ENf_GET
#define DSC_TRNSUM_CTL3r_TRNSUM_TAP_ENf_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL3r_TRNSUM_TAP_ENf_SET
#define DSC_TRNSUM_CTL3r_TRNSUM_TAP_SIGNf_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL3r_TRNSUM_TAP_SIGNf_GET
#define DSC_TRNSUM_CTL3r_TRNSUM_TAP_SIGNf_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL3r_TRNSUM_TAP_SIGNf_SET
#define READ_DSC_TRNSUM_CTL3r BCMI_TSCE16_XGXS_READ_DSC_TRNSUM_CTL3r
#define WRITE_DSC_TRNSUM_CTL3r BCMI_TSCE16_XGXS_WRITE_DSC_TRNSUM_CTL3r
#define MODIFY_DSC_TRNSUM_CTL3r BCMI_TSCE16_XGXS_MODIFY_DSC_TRNSUM_CTL3r
#define READLN_DSC_TRNSUM_CTL3r BCMI_TSCE16_XGXS_READLN_DSC_TRNSUM_CTL3r
#define WRITELN_DSC_TRNSUM_CTL3r BCMI_TSCE16_XGXS_WRITELN_DSC_TRNSUM_CTL3r
#define WRITEALL_DSC_TRNSUM_CTL3r BCMI_TSCE16_XGXS_WRITEALL_DSC_TRNSUM_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_TRNSUM_CTL4
 * BLOCKS:   DSC_D
 * REGADDR:  0xd033
 * DESC:     Trnsum Ctl 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TRNSUM_UNSIGNED_CORR when 1; and !trnsum_unsigned_flip, correlated error after XOR {0,1} becomes signed {2'b00,2'b01}
 *     TRNSUM_UNSIGNED_FLIP when 1 along with trnsum_unsigned_corr, {0,1} - {2'b01, 2'b00}
 *     TDR_BIT_SEL      tdr bit select: range is 0 to 19
 *     TDR_TRNSUM_EN    enables the tdr feature
 *     TDR_CYCLE_SEL    the cycle counter wraps at this number
 *     TDR_CYCLE_BIN    valid range: from 0 to tdr_cycle_sel; this cycle the tdr is enabled on bit indicated by tdr_bit_sel
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r (0x0000d033 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_CTL4.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_ctl4[1];
	uint32_t _dsc_trnsum_ctl4;
} BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r_t;

#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r_CLR(r) (r).dsc_trnsum_ctl4[0] = 0
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r_SET(r,d) (r).dsc_trnsum_ctl4[0] = d
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r_GET(r) (r).dsc_trnsum_ctl4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r_TDR_CYCLE_BINf_GET(r) ((((r).dsc_trnsum_ctl4[0]) >> 12) & 0xf)
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r_TDR_CYCLE_BINf_SET(r,f) (r).dsc_trnsum_ctl4[0]=(((r).dsc_trnsum_ctl4[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r_TDR_CYCLE_SELf_GET(r) ((((r).dsc_trnsum_ctl4[0]) >> 8) & 0xf)
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r_TDR_CYCLE_SELf_SET(r,f) (r).dsc_trnsum_ctl4[0]=(((r).dsc_trnsum_ctl4[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r_TDR_TRNSUM_ENf_GET(r) ((((r).dsc_trnsum_ctl4[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r_TDR_TRNSUM_ENf_SET(r,f) (r).dsc_trnsum_ctl4[0]=(((r).dsc_trnsum_ctl4[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r_TDR_BIT_SELf_GET(r) ((((r).dsc_trnsum_ctl4[0]) >> 2) & 0x1f)
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r_TDR_BIT_SELf_SET(r,f) (r).dsc_trnsum_ctl4[0]=(((r).dsc_trnsum_ctl4[0] & ~((uint32_t)0x1f << 2)) | ((((uint32_t)f) & 0x1f) << 2)) | (31 << (16 + 2))
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r_TRNSUM_UNSIGNED_FLIPf_GET(r) ((((r).dsc_trnsum_ctl4[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r_TRNSUM_UNSIGNED_FLIPf_SET(r,f) (r).dsc_trnsum_ctl4[0]=(((r).dsc_trnsum_ctl4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r_TRNSUM_UNSIGNED_CORRf_GET(r) (((r).dsc_trnsum_ctl4[0]) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r_TRNSUM_UNSIGNED_CORRf_SET(r,f) (r).dsc_trnsum_ctl4[0]=(((r).dsc_trnsum_ctl4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_TRNSUM_CTL4.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_TRNSUM_CTL4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r,(_r._dsc_trnsum_ctl4))
#define BCMI_TSCE16_XGXS_WRITE_DSC_TRNSUM_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r,(_r._dsc_trnsum_ctl4)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_TRNSUM_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r,(_r._dsc_trnsum_ctl4))
#define BCMI_TSCE16_XGXS_READLN_DSC_TRNSUM_CTL4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_ctl4))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_TRNSUM_CTL4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_ctl4))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_TRNSUM_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_ctl4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_CTL4r BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r
#define DSC_TRNSUM_CTL4r_SIZE BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r_SIZE
typedef BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r_t DSC_TRNSUM_CTL4r_t;
#define DSC_TRNSUM_CTL4r_CLR BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r_CLR
#define DSC_TRNSUM_CTL4r_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r_SET
#define DSC_TRNSUM_CTL4r_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r_GET
#define DSC_TRNSUM_CTL4r_TDR_CYCLE_BINf_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r_TDR_CYCLE_BINf_GET
#define DSC_TRNSUM_CTL4r_TDR_CYCLE_BINf_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r_TDR_CYCLE_BINf_SET
#define DSC_TRNSUM_CTL4r_TDR_CYCLE_SELf_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r_TDR_CYCLE_SELf_GET
#define DSC_TRNSUM_CTL4r_TDR_CYCLE_SELf_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r_TDR_CYCLE_SELf_SET
#define DSC_TRNSUM_CTL4r_TDR_TRNSUM_ENf_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r_TDR_TRNSUM_ENf_GET
#define DSC_TRNSUM_CTL4r_TDR_TRNSUM_ENf_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r_TDR_TRNSUM_ENf_SET
#define DSC_TRNSUM_CTL4r_TDR_BIT_SELf_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r_TDR_BIT_SELf_GET
#define DSC_TRNSUM_CTL4r_TDR_BIT_SELf_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r_TDR_BIT_SELf_SET
#define DSC_TRNSUM_CTL4r_TRNSUM_UNSIGNED_FLIPf_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r_TRNSUM_UNSIGNED_FLIPf_GET
#define DSC_TRNSUM_CTL4r_TRNSUM_UNSIGNED_FLIPf_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r_TRNSUM_UNSIGNED_FLIPf_SET
#define DSC_TRNSUM_CTL4r_TRNSUM_UNSIGNED_CORRf_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r_TRNSUM_UNSIGNED_CORRf_GET
#define DSC_TRNSUM_CTL4r_TRNSUM_UNSIGNED_CORRf_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r_TRNSUM_UNSIGNED_CORRf_SET
#define READ_DSC_TRNSUM_CTL4r BCMI_TSCE16_XGXS_READ_DSC_TRNSUM_CTL4r
#define WRITE_DSC_TRNSUM_CTL4r BCMI_TSCE16_XGXS_WRITE_DSC_TRNSUM_CTL4r
#define MODIFY_DSC_TRNSUM_CTL4r BCMI_TSCE16_XGXS_MODIFY_DSC_TRNSUM_CTL4r
#define READLN_DSC_TRNSUM_CTL4r BCMI_TSCE16_XGXS_READLN_DSC_TRNSUM_CTL4r
#define WRITELN_DSC_TRNSUM_CTL4r BCMI_TSCE16_XGXS_WRITELN_DSC_TRNSUM_CTL4r
#define WRITEALL_DSC_TRNSUM_CTL4r BCMI_TSCE16_XGXS_WRITEALL_DSC_TRNSUM_CTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_TRNSUM_CTL4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_TRNSUM_STS1
 * BLOCKS:   DSC_D
 * REGADDR:  0xd034
 * DESC:     Trnsum Status 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM_E_HIGH    trnsum accumulator for even bit locations; bits [23:8]
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS1r (0x0000d034 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS1r_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_STS1.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_TRNSUM_STS1r_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_sts1[1];
	uint32_t _dsc_trnsum_sts1;
} BCMI_TSCE16_XGXS_DSC_TRNSUM_STS1r_t;

#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS1r_CLR(r) (r).dsc_trnsum_sts1[0] = 0
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS1r_SET(r,d) (r).dsc_trnsum_sts1[0] = d
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS1r_GET(r) (r).dsc_trnsum_sts1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS1r_TRNSUM_E_HIGHf_GET(r) (((r).dsc_trnsum_sts1[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS1r_TRNSUM_E_HIGHf_SET(r,f) (r).dsc_trnsum_sts1[0]=(((r).dsc_trnsum_sts1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_TRNSUM_STS1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_TRNSUM_STS1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS1r,(_r._dsc_trnsum_sts1))
#define BCMI_TSCE16_XGXS_WRITE_DSC_TRNSUM_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS1r,(_r._dsc_trnsum_sts1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_TRNSUM_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS1r,(_r._dsc_trnsum_sts1))
#define BCMI_TSCE16_XGXS_READLN_DSC_TRNSUM_STS1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_sts1))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_TRNSUM_STS1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_sts1))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_TRNSUM_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_sts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_STS1r BCMI_TSCE16_XGXS_DSC_TRNSUM_STS1r
#define DSC_TRNSUM_STS1r_SIZE BCMI_TSCE16_XGXS_DSC_TRNSUM_STS1r_SIZE
typedef BCMI_TSCE16_XGXS_DSC_TRNSUM_STS1r_t DSC_TRNSUM_STS1r_t;
#define DSC_TRNSUM_STS1r_CLR BCMI_TSCE16_XGXS_DSC_TRNSUM_STS1r_CLR
#define DSC_TRNSUM_STS1r_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_STS1r_SET
#define DSC_TRNSUM_STS1r_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_STS1r_GET
#define DSC_TRNSUM_STS1r_TRNSUM_E_HIGHf_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_STS1r_TRNSUM_E_HIGHf_GET
#define DSC_TRNSUM_STS1r_TRNSUM_E_HIGHf_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_STS1r_TRNSUM_E_HIGHf_SET
#define READ_DSC_TRNSUM_STS1r BCMI_TSCE16_XGXS_READ_DSC_TRNSUM_STS1r
#define WRITE_DSC_TRNSUM_STS1r BCMI_TSCE16_XGXS_WRITE_DSC_TRNSUM_STS1r
#define MODIFY_DSC_TRNSUM_STS1r BCMI_TSCE16_XGXS_MODIFY_DSC_TRNSUM_STS1r
#define READLN_DSC_TRNSUM_STS1r BCMI_TSCE16_XGXS_READLN_DSC_TRNSUM_STS1r
#define WRITELN_DSC_TRNSUM_STS1r BCMI_TSCE16_XGXS_WRITELN_DSC_TRNSUM_STS1r
#define WRITEALL_DSC_TRNSUM_STS1r BCMI_TSCE16_XGXS_WRITEALL_DSC_TRNSUM_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_TRNSUM_STS1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_TRNSUM_STS2
 * BLOCKS:   DSC_D
 * REGADDR:  0xd035
 * DESC:     Trnsum Status 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM_E_LOW     trnsum accumulator for even bit locations; bits [7:0]
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS2r (0x0000d035 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS2r_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_STS2.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_TRNSUM_STS2r_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_sts2[1];
	uint32_t _dsc_trnsum_sts2;
} BCMI_TSCE16_XGXS_DSC_TRNSUM_STS2r_t;

#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS2r_CLR(r) (r).dsc_trnsum_sts2[0] = 0
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS2r_SET(r,d) (r).dsc_trnsum_sts2[0] = d
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS2r_GET(r) (r).dsc_trnsum_sts2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS2r_TRNSUM_E_LOWf_GET(r) (((r).dsc_trnsum_sts2[0]) & 0xff)
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS2r_TRNSUM_E_LOWf_SET(r,f) (r).dsc_trnsum_sts2[0]=(((r).dsc_trnsum_sts2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_TRNSUM_STS2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_TRNSUM_STS2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS2r,(_r._dsc_trnsum_sts2))
#define BCMI_TSCE16_XGXS_WRITE_DSC_TRNSUM_STS2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS2r,(_r._dsc_trnsum_sts2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_TRNSUM_STS2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS2r,(_r._dsc_trnsum_sts2))
#define BCMI_TSCE16_XGXS_READLN_DSC_TRNSUM_STS2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_sts2))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_TRNSUM_STS2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_sts2))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_TRNSUM_STS2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_sts2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_STS2r BCMI_TSCE16_XGXS_DSC_TRNSUM_STS2r
#define DSC_TRNSUM_STS2r_SIZE BCMI_TSCE16_XGXS_DSC_TRNSUM_STS2r_SIZE
typedef BCMI_TSCE16_XGXS_DSC_TRNSUM_STS2r_t DSC_TRNSUM_STS2r_t;
#define DSC_TRNSUM_STS2r_CLR BCMI_TSCE16_XGXS_DSC_TRNSUM_STS2r_CLR
#define DSC_TRNSUM_STS2r_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_STS2r_SET
#define DSC_TRNSUM_STS2r_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_STS2r_GET
#define DSC_TRNSUM_STS2r_TRNSUM_E_LOWf_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_STS2r_TRNSUM_E_LOWf_GET
#define DSC_TRNSUM_STS2r_TRNSUM_E_LOWf_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_STS2r_TRNSUM_E_LOWf_SET
#define READ_DSC_TRNSUM_STS2r BCMI_TSCE16_XGXS_READ_DSC_TRNSUM_STS2r
#define WRITE_DSC_TRNSUM_STS2r BCMI_TSCE16_XGXS_WRITE_DSC_TRNSUM_STS2r
#define MODIFY_DSC_TRNSUM_STS2r BCMI_TSCE16_XGXS_MODIFY_DSC_TRNSUM_STS2r
#define READLN_DSC_TRNSUM_STS2r BCMI_TSCE16_XGXS_READLN_DSC_TRNSUM_STS2r
#define WRITELN_DSC_TRNSUM_STS2r BCMI_TSCE16_XGXS_WRITELN_DSC_TRNSUM_STS2r
#define WRITEALL_DSC_TRNSUM_STS2r BCMI_TSCE16_XGXS_WRITEALL_DSC_TRNSUM_STS2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_TRNSUM_STS2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_TRNSUM_STS3
 * BLOCKS:   DSC_D
 * REGADDR:  0xd036
 * DESC:     Trnsum Status 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM_O_HIGH    trnsum accumulator for odd bit locations; bits [23:8]
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS3r (0x0000d036 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS3r_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_STS3.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_TRNSUM_STS3r_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_sts3[1];
	uint32_t _dsc_trnsum_sts3;
} BCMI_TSCE16_XGXS_DSC_TRNSUM_STS3r_t;

#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS3r_CLR(r) (r).dsc_trnsum_sts3[0] = 0
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS3r_SET(r,d) (r).dsc_trnsum_sts3[0] = d
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS3r_GET(r) (r).dsc_trnsum_sts3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS3r_TRNSUM_O_HIGHf_GET(r) (((r).dsc_trnsum_sts3[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS3r_TRNSUM_O_HIGHf_SET(r,f) (r).dsc_trnsum_sts3[0]=(((r).dsc_trnsum_sts3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_TRNSUM_STS3.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_TRNSUM_STS3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS3r,(_r._dsc_trnsum_sts3))
#define BCMI_TSCE16_XGXS_WRITE_DSC_TRNSUM_STS3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS3r,(_r._dsc_trnsum_sts3)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_TRNSUM_STS3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS3r,(_r._dsc_trnsum_sts3))
#define BCMI_TSCE16_XGXS_READLN_DSC_TRNSUM_STS3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_sts3))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_TRNSUM_STS3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_sts3))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_TRNSUM_STS3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_sts3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_STS3r BCMI_TSCE16_XGXS_DSC_TRNSUM_STS3r
#define DSC_TRNSUM_STS3r_SIZE BCMI_TSCE16_XGXS_DSC_TRNSUM_STS3r_SIZE
typedef BCMI_TSCE16_XGXS_DSC_TRNSUM_STS3r_t DSC_TRNSUM_STS3r_t;
#define DSC_TRNSUM_STS3r_CLR BCMI_TSCE16_XGXS_DSC_TRNSUM_STS3r_CLR
#define DSC_TRNSUM_STS3r_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_STS3r_SET
#define DSC_TRNSUM_STS3r_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_STS3r_GET
#define DSC_TRNSUM_STS3r_TRNSUM_O_HIGHf_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_STS3r_TRNSUM_O_HIGHf_GET
#define DSC_TRNSUM_STS3r_TRNSUM_O_HIGHf_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_STS3r_TRNSUM_O_HIGHf_SET
#define READ_DSC_TRNSUM_STS3r BCMI_TSCE16_XGXS_READ_DSC_TRNSUM_STS3r
#define WRITE_DSC_TRNSUM_STS3r BCMI_TSCE16_XGXS_WRITE_DSC_TRNSUM_STS3r
#define MODIFY_DSC_TRNSUM_STS3r BCMI_TSCE16_XGXS_MODIFY_DSC_TRNSUM_STS3r
#define READLN_DSC_TRNSUM_STS3r BCMI_TSCE16_XGXS_READLN_DSC_TRNSUM_STS3r
#define WRITELN_DSC_TRNSUM_STS3r BCMI_TSCE16_XGXS_WRITELN_DSC_TRNSUM_STS3r
#define WRITEALL_DSC_TRNSUM_STS3r BCMI_TSCE16_XGXS_WRITEALL_DSC_TRNSUM_STS3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_TRNSUM_STS3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_TRNSUM_STS4
 * BLOCKS:   DSC_D
 * REGADDR:  0xd037
 * DESC:     Trnsum Status 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM_O_LOW     trnsum accumulator for odd bit locations; bits [7:0]
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS4r (0x0000d037 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS4r_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_STS4.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_TRNSUM_STS4r_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_sts4[1];
	uint32_t _dsc_trnsum_sts4;
} BCMI_TSCE16_XGXS_DSC_TRNSUM_STS4r_t;

#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS4r_CLR(r) (r).dsc_trnsum_sts4[0] = 0
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS4r_SET(r,d) (r).dsc_trnsum_sts4[0] = d
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS4r_GET(r) (r).dsc_trnsum_sts4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS4r_TRNSUM_O_LOWf_GET(r) (((r).dsc_trnsum_sts4[0]) & 0xff)
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS4r_TRNSUM_O_LOWf_SET(r,f) (r).dsc_trnsum_sts4[0]=(((r).dsc_trnsum_sts4[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_TRNSUM_STS4.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_TRNSUM_STS4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS4r,(_r._dsc_trnsum_sts4))
#define BCMI_TSCE16_XGXS_WRITE_DSC_TRNSUM_STS4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS4r,(_r._dsc_trnsum_sts4)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_TRNSUM_STS4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS4r,(_r._dsc_trnsum_sts4))
#define BCMI_TSCE16_XGXS_READLN_DSC_TRNSUM_STS4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_sts4))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_TRNSUM_STS4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_sts4))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_TRNSUM_STS4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_sts4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_STS4r BCMI_TSCE16_XGXS_DSC_TRNSUM_STS4r
#define DSC_TRNSUM_STS4r_SIZE BCMI_TSCE16_XGXS_DSC_TRNSUM_STS4r_SIZE
typedef BCMI_TSCE16_XGXS_DSC_TRNSUM_STS4r_t DSC_TRNSUM_STS4r_t;
#define DSC_TRNSUM_STS4r_CLR BCMI_TSCE16_XGXS_DSC_TRNSUM_STS4r_CLR
#define DSC_TRNSUM_STS4r_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_STS4r_SET
#define DSC_TRNSUM_STS4r_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_STS4r_GET
#define DSC_TRNSUM_STS4r_TRNSUM_O_LOWf_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_STS4r_TRNSUM_O_LOWf_GET
#define DSC_TRNSUM_STS4r_TRNSUM_O_LOWf_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_STS4r_TRNSUM_O_LOWf_SET
#define READ_DSC_TRNSUM_STS4r BCMI_TSCE16_XGXS_READ_DSC_TRNSUM_STS4r
#define WRITE_DSC_TRNSUM_STS4r BCMI_TSCE16_XGXS_WRITE_DSC_TRNSUM_STS4r
#define MODIFY_DSC_TRNSUM_STS4r BCMI_TSCE16_XGXS_MODIFY_DSC_TRNSUM_STS4r
#define READLN_DSC_TRNSUM_STS4r BCMI_TSCE16_XGXS_READLN_DSC_TRNSUM_STS4r
#define WRITELN_DSC_TRNSUM_STS4r BCMI_TSCE16_XGXS_WRITELN_DSC_TRNSUM_STS4r
#define WRITEALL_DSC_TRNSUM_STS4r BCMI_TSCE16_XGXS_WRITEALL_DSC_TRNSUM_STS4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_TRNSUM_STS4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_TRNSUM_STS5
 * BLOCKS:   DSC_D
 * REGADDR:  0xd038
 * DESC:     Trnsum Status 5
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM_HIGH      trnsum accumulator (even + odd); bits [25:10]
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS5r (0x0000d038 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS5r_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_STS5.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_TRNSUM_STS5r_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_sts5[1];
	uint32_t _dsc_trnsum_sts5;
} BCMI_TSCE16_XGXS_DSC_TRNSUM_STS5r_t;

#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS5r_CLR(r) (r).dsc_trnsum_sts5[0] = 0
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS5r_SET(r,d) (r).dsc_trnsum_sts5[0] = d
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS5r_GET(r) (r).dsc_trnsum_sts5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS5r_TRNSUM_HIGHf_GET(r) (((r).dsc_trnsum_sts5[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS5r_TRNSUM_HIGHf_SET(r,f) (r).dsc_trnsum_sts5[0]=(((r).dsc_trnsum_sts5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_TRNSUM_STS5.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_TRNSUM_STS5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS5r,(_r._dsc_trnsum_sts5))
#define BCMI_TSCE16_XGXS_WRITE_DSC_TRNSUM_STS5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS5r,(_r._dsc_trnsum_sts5)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_TRNSUM_STS5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS5r,(_r._dsc_trnsum_sts5))
#define BCMI_TSCE16_XGXS_READLN_DSC_TRNSUM_STS5r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_sts5))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_TRNSUM_STS5r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_sts5))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_TRNSUM_STS5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_sts5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_STS5r BCMI_TSCE16_XGXS_DSC_TRNSUM_STS5r
#define DSC_TRNSUM_STS5r_SIZE BCMI_TSCE16_XGXS_DSC_TRNSUM_STS5r_SIZE
typedef BCMI_TSCE16_XGXS_DSC_TRNSUM_STS5r_t DSC_TRNSUM_STS5r_t;
#define DSC_TRNSUM_STS5r_CLR BCMI_TSCE16_XGXS_DSC_TRNSUM_STS5r_CLR
#define DSC_TRNSUM_STS5r_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_STS5r_SET
#define DSC_TRNSUM_STS5r_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_STS5r_GET
#define DSC_TRNSUM_STS5r_TRNSUM_HIGHf_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_STS5r_TRNSUM_HIGHf_GET
#define DSC_TRNSUM_STS5r_TRNSUM_HIGHf_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_STS5r_TRNSUM_HIGHf_SET
#define READ_DSC_TRNSUM_STS5r BCMI_TSCE16_XGXS_READ_DSC_TRNSUM_STS5r
#define WRITE_DSC_TRNSUM_STS5r BCMI_TSCE16_XGXS_WRITE_DSC_TRNSUM_STS5r
#define MODIFY_DSC_TRNSUM_STS5r BCMI_TSCE16_XGXS_MODIFY_DSC_TRNSUM_STS5r
#define READLN_DSC_TRNSUM_STS5r BCMI_TSCE16_XGXS_READLN_DSC_TRNSUM_STS5r
#define WRITELN_DSC_TRNSUM_STS5r BCMI_TSCE16_XGXS_WRITELN_DSC_TRNSUM_STS5r
#define WRITEALL_DSC_TRNSUM_STS5r BCMI_TSCE16_XGXS_WRITEALL_DSC_TRNSUM_STS5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_TRNSUM_STS5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_TRNSUM_STS6
 * BLOCKS:   DSC_D
 * REGADDR:  0xd039
 * DESC:     Trnsum Status 6
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM_LOW       trnsum accumulator (even + odd); bits [9:0]
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS6r (0x0000d039 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS6r_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_STS6.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_TRNSUM_STS6r_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_sts6[1];
	uint32_t _dsc_trnsum_sts6;
} BCMI_TSCE16_XGXS_DSC_TRNSUM_STS6r_t;

#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS6r_CLR(r) (r).dsc_trnsum_sts6[0] = 0
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS6r_SET(r,d) (r).dsc_trnsum_sts6[0] = d
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS6r_GET(r) (r).dsc_trnsum_sts6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS6r_TRNSUM_LOWf_GET(r) (((r).dsc_trnsum_sts6[0]) & 0x3ff)
#define BCMI_TSCE16_XGXS_DSC_TRNSUM_STS6r_TRNSUM_LOWf_SET(r,f) (r).dsc_trnsum_sts6[0]=(((r).dsc_trnsum_sts6[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access DSC_TRNSUM_STS6.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_TRNSUM_STS6r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS6r,(_r._dsc_trnsum_sts6))
#define BCMI_TSCE16_XGXS_WRITE_DSC_TRNSUM_STS6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS6r,(_r._dsc_trnsum_sts6)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_TRNSUM_STS6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS6r,(_r._dsc_trnsum_sts6))
#define BCMI_TSCE16_XGXS_READLN_DSC_TRNSUM_STS6r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_sts6))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_TRNSUM_STS6r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_sts6))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_TRNSUM_STS6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_TRNSUM_STS6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_sts6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_STS6r BCMI_TSCE16_XGXS_DSC_TRNSUM_STS6r
#define DSC_TRNSUM_STS6r_SIZE BCMI_TSCE16_XGXS_DSC_TRNSUM_STS6r_SIZE
typedef BCMI_TSCE16_XGXS_DSC_TRNSUM_STS6r_t DSC_TRNSUM_STS6r_t;
#define DSC_TRNSUM_STS6r_CLR BCMI_TSCE16_XGXS_DSC_TRNSUM_STS6r_CLR
#define DSC_TRNSUM_STS6r_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_STS6r_SET
#define DSC_TRNSUM_STS6r_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_STS6r_GET
#define DSC_TRNSUM_STS6r_TRNSUM_LOWf_GET BCMI_TSCE16_XGXS_DSC_TRNSUM_STS6r_TRNSUM_LOWf_GET
#define DSC_TRNSUM_STS6r_TRNSUM_LOWf_SET BCMI_TSCE16_XGXS_DSC_TRNSUM_STS6r_TRNSUM_LOWf_SET
#define READ_DSC_TRNSUM_STS6r BCMI_TSCE16_XGXS_READ_DSC_TRNSUM_STS6r
#define WRITE_DSC_TRNSUM_STS6r BCMI_TSCE16_XGXS_WRITE_DSC_TRNSUM_STS6r
#define MODIFY_DSC_TRNSUM_STS6r BCMI_TSCE16_XGXS_MODIFY_DSC_TRNSUM_STS6r
#define READLN_DSC_TRNSUM_STS6r BCMI_TSCE16_XGXS_READLN_DSC_TRNSUM_STS6r
#define WRITELN_DSC_TRNSUM_STS6r BCMI_TSCE16_XGXS_WRITELN_DSC_TRNSUM_STS6r
#define WRITEALL_DSC_TRNSUM_STS6r BCMI_TSCE16_XGXS_WRITEALL_DSC_TRNSUM_STS6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_TRNSUM_STS6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_VGA_P1EYEDIAG_STS
 * BLOCKS:   DSC_D
 * REGADDR:  0xd03a
 * DESC:     VGA status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     VGA_BIN          vga status
 *     VGA_WANTS_TO_GO_LOW vga wants to go lower than the lower limit.
 *     P1_EYEDIAG_BIN   p1 eyediag status
 *     P1_WANTS_TO_GO_LOW p1 wants to go lower than the lower limit.
 *     P1_WANTS_TO_GO_HIGH p1 wants to go higher than the upper limit.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr (0x0000d03a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_VGA_P1EYEDIAG_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr_s {
	uint32_t v[1];
	uint32_t dsc_vga_p1eyediag_sts[1];
	uint32_t _dsc_vga_p1eyediag_sts;
} BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr_t;

#define BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr_CLR(r) (r).dsc_vga_p1eyediag_sts[0] = 0
#define BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr_SET(r,d) (r).dsc_vga_p1eyediag_sts[0] = d
#define BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr_GET(r) (r).dsc_vga_p1eyediag_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr_P1_WANTS_TO_GO_HIGHf_GET(r) ((((r).dsc_vga_p1eyediag_sts[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr_P1_WANTS_TO_GO_HIGHf_SET(r,f) (r).dsc_vga_p1eyediag_sts[0]=(((r).dsc_vga_p1eyediag_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr_P1_WANTS_TO_GO_LOWf_GET(r) ((((r).dsc_vga_p1eyediag_sts[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr_P1_WANTS_TO_GO_LOWf_SET(r,f) (r).dsc_vga_p1eyediag_sts[0]=(((r).dsc_vga_p1eyediag_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr_P1_EYEDIAG_BINf_GET(r) ((((r).dsc_vga_p1eyediag_sts[0]) >> 8) & 0x3f)
#define BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr_P1_EYEDIAG_BINf_SET(r,f) (r).dsc_vga_p1eyediag_sts[0]=(((r).dsc_vga_p1eyediag_sts[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr_VGA_WANTS_TO_GO_LOWf_GET(r) ((((r).dsc_vga_p1eyediag_sts[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr_VGA_WANTS_TO_GO_LOWf_SET(r,f) (r).dsc_vga_p1eyediag_sts[0]=(((r).dsc_vga_p1eyediag_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr_VGA_BINf_GET(r) (((r).dsc_vga_p1eyediag_sts[0]) & 0x3f)
#define BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr_VGA_BINf_SET(r,f) (r).dsc_vga_p1eyediag_sts[0]=(((r).dsc_vga_p1eyediag_sts[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_VGA_P1EYEDIAG_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_VGA_P1EYEDIAG_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr,(_r._dsc_vga_p1eyediag_sts))
#define BCMI_TSCE16_XGXS_WRITE_DSC_VGA_P1EYEDIAG_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr,(_r._dsc_vga_p1eyediag_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_VGA_P1EYEDIAG_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr,(_r._dsc_vga_p1eyediag_sts))
#define BCMI_TSCE16_XGXS_READLN_DSC_VGA_P1EYEDIAG_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_vga_p1eyediag_sts))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_VGA_P1EYEDIAG_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_vga_p1eyediag_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_VGA_P1EYEDIAG_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_vga_p1eyediag_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_VGA_P1EYEDIAG_STSr BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr
#define DSC_VGA_P1EYEDIAG_STSr_SIZE BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr_t DSC_VGA_P1EYEDIAG_STSr_t;
#define DSC_VGA_P1EYEDIAG_STSr_CLR BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr_CLR
#define DSC_VGA_P1EYEDIAG_STSr_SET BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr_SET
#define DSC_VGA_P1EYEDIAG_STSr_GET BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr_GET
#define DSC_VGA_P1EYEDIAG_STSr_P1_WANTS_TO_GO_HIGHf_GET BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr_P1_WANTS_TO_GO_HIGHf_GET
#define DSC_VGA_P1EYEDIAG_STSr_P1_WANTS_TO_GO_HIGHf_SET BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr_P1_WANTS_TO_GO_HIGHf_SET
#define DSC_VGA_P1EYEDIAG_STSr_P1_WANTS_TO_GO_LOWf_GET BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr_P1_WANTS_TO_GO_LOWf_GET
#define DSC_VGA_P1EYEDIAG_STSr_P1_WANTS_TO_GO_LOWf_SET BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr_P1_WANTS_TO_GO_LOWf_SET
#define DSC_VGA_P1EYEDIAG_STSr_P1_EYEDIAG_BINf_GET BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr_P1_EYEDIAG_BINf_GET
#define DSC_VGA_P1EYEDIAG_STSr_P1_EYEDIAG_BINf_SET BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr_P1_EYEDIAG_BINf_SET
#define DSC_VGA_P1EYEDIAG_STSr_VGA_WANTS_TO_GO_LOWf_GET BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr_VGA_WANTS_TO_GO_LOWf_GET
#define DSC_VGA_P1EYEDIAG_STSr_VGA_WANTS_TO_GO_LOWf_SET BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr_VGA_WANTS_TO_GO_LOWf_SET
#define DSC_VGA_P1EYEDIAG_STSr_VGA_BINf_GET BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr_VGA_BINf_GET
#define DSC_VGA_P1EYEDIAG_STSr_VGA_BINf_SET BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr_VGA_BINf_SET
#define READ_DSC_VGA_P1EYEDIAG_STSr BCMI_TSCE16_XGXS_READ_DSC_VGA_P1EYEDIAG_STSr
#define WRITE_DSC_VGA_P1EYEDIAG_STSr BCMI_TSCE16_XGXS_WRITE_DSC_VGA_P1EYEDIAG_STSr
#define MODIFY_DSC_VGA_P1EYEDIAG_STSr BCMI_TSCE16_XGXS_MODIFY_DSC_VGA_P1EYEDIAG_STSr
#define READLN_DSC_VGA_P1EYEDIAG_STSr BCMI_TSCE16_XGXS_READLN_DSC_VGA_P1EYEDIAG_STSr
#define WRITELN_DSC_VGA_P1EYEDIAG_STSr BCMI_TSCE16_XGXS_WRITELN_DSC_VGA_P1EYEDIAG_STSr
#define WRITEALL_DSC_VGA_P1EYEDIAG_STSr BCMI_TSCE16_XGXS_WRITEALL_DSC_VGA_P1EYEDIAG_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_VGA_P1EYEDIAG_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_DFE_1_STS
 * BLOCKS:   DSC_D
 * REGADDR:  0xd03b
 * DESC:     DFE 1 status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DFE_1_CMN        dfe 1 cmn tap
 *     DFE_1_O          dfe1 odd tap
 *     DFE_1_E          dfe1 even tap
 *     DFE_1_WANTS_NEGATIVE dfe1 wants negative
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_DFE_1_STSr (0x0000d03b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_DFE_1_STSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DFE_1_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_DFE_1_STSr_s {
	uint32_t v[1];
	uint32_t dsc_dfe_1_sts[1];
	uint32_t _dsc_dfe_1_sts;
} BCMI_TSCE16_XGXS_DSC_DFE_1_STSr_t;

#define BCMI_TSCE16_XGXS_DSC_DFE_1_STSr_CLR(r) (r).dsc_dfe_1_sts[0] = 0
#define BCMI_TSCE16_XGXS_DSC_DFE_1_STSr_SET(r,d) (r).dsc_dfe_1_sts[0] = d
#define BCMI_TSCE16_XGXS_DSC_DFE_1_STSr_GET(r) (r).dsc_dfe_1_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_DFE_1_STSr_DFE_1_WANTS_NEGATIVEf_GET(r) ((((r).dsc_dfe_1_sts[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DFE_1_STSr_DFE_1_WANTS_NEGATIVEf_SET(r,f) (r).dsc_dfe_1_sts[0]=(((r).dsc_dfe_1_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_DSC_DFE_1_STSr_DFE_1_Ef_GET(r) ((((r).dsc_dfe_1_sts[0]) >> 11) & 0x7)
#define BCMI_TSCE16_XGXS_DSC_DFE_1_STSr_DFE_1_Ef_SET(r,f) (r).dsc_dfe_1_sts[0]=(((r).dsc_dfe_1_sts[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_TSCE16_XGXS_DSC_DFE_1_STSr_DFE_1_Of_GET(r) ((((r).dsc_dfe_1_sts[0]) >> 8) & 0x7)
#define BCMI_TSCE16_XGXS_DSC_DFE_1_STSr_DFE_1_Of_SET(r,f) (r).dsc_dfe_1_sts[0]=(((r).dsc_dfe_1_sts[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_TSCE16_XGXS_DSC_DFE_1_STSr_DFE_1_CMNf_GET(r) (((r).dsc_dfe_1_sts[0]) & 0x3f)
#define BCMI_TSCE16_XGXS_DSC_DFE_1_STSr_DFE_1_CMNf_SET(r,f) (r).dsc_dfe_1_sts[0]=(((r).dsc_dfe_1_sts[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_DFE_1_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_DFE_1_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_DFE_1_STSr,(_r._dsc_dfe_1_sts))
#define BCMI_TSCE16_XGXS_WRITE_DSC_DFE_1_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_1_STSr,(_r._dsc_dfe_1_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_DFE_1_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_1_STSr,(_r._dsc_dfe_1_sts))
#define BCMI_TSCE16_XGXS_READLN_DSC_DFE_1_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_DFE_1_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_1_sts))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_DFE_1_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_1_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_1_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_DFE_1_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_1_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_dfe_1_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_DFE_1_STSr BCMI_TSCE16_XGXS_DSC_DFE_1_STSr
#define DSC_DFE_1_STSr_SIZE BCMI_TSCE16_XGXS_DSC_DFE_1_STSr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_DFE_1_STSr_t DSC_DFE_1_STSr_t;
#define DSC_DFE_1_STSr_CLR BCMI_TSCE16_XGXS_DSC_DFE_1_STSr_CLR
#define DSC_DFE_1_STSr_SET BCMI_TSCE16_XGXS_DSC_DFE_1_STSr_SET
#define DSC_DFE_1_STSr_GET BCMI_TSCE16_XGXS_DSC_DFE_1_STSr_GET
#define DSC_DFE_1_STSr_DFE_1_WANTS_NEGATIVEf_GET BCMI_TSCE16_XGXS_DSC_DFE_1_STSr_DFE_1_WANTS_NEGATIVEf_GET
#define DSC_DFE_1_STSr_DFE_1_WANTS_NEGATIVEf_SET BCMI_TSCE16_XGXS_DSC_DFE_1_STSr_DFE_1_WANTS_NEGATIVEf_SET
#define DSC_DFE_1_STSr_DFE_1_Ef_GET BCMI_TSCE16_XGXS_DSC_DFE_1_STSr_DFE_1_Ef_GET
#define DSC_DFE_1_STSr_DFE_1_Ef_SET BCMI_TSCE16_XGXS_DSC_DFE_1_STSr_DFE_1_Ef_SET
#define DSC_DFE_1_STSr_DFE_1_Of_GET BCMI_TSCE16_XGXS_DSC_DFE_1_STSr_DFE_1_Of_GET
#define DSC_DFE_1_STSr_DFE_1_Of_SET BCMI_TSCE16_XGXS_DSC_DFE_1_STSr_DFE_1_Of_SET
#define DSC_DFE_1_STSr_DFE_1_CMNf_GET BCMI_TSCE16_XGXS_DSC_DFE_1_STSr_DFE_1_CMNf_GET
#define DSC_DFE_1_STSr_DFE_1_CMNf_SET BCMI_TSCE16_XGXS_DSC_DFE_1_STSr_DFE_1_CMNf_SET
#define READ_DSC_DFE_1_STSr BCMI_TSCE16_XGXS_READ_DSC_DFE_1_STSr
#define WRITE_DSC_DFE_1_STSr BCMI_TSCE16_XGXS_WRITE_DSC_DFE_1_STSr
#define MODIFY_DSC_DFE_1_STSr BCMI_TSCE16_XGXS_MODIFY_DSC_DFE_1_STSr
#define READLN_DSC_DFE_1_STSr BCMI_TSCE16_XGXS_READLN_DSC_DFE_1_STSr
#define WRITELN_DSC_DFE_1_STSr BCMI_TSCE16_XGXS_WRITELN_DSC_DFE_1_STSr
#define WRITEALL_DSC_DFE_1_STSr BCMI_TSCE16_XGXS_WRITEALL_DSC_DFE_1_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_DFE_1_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_DFE_2_STS
 * BLOCKS:   DSC_D
 * REGADDR:  0xd03c
 * DESC:     DFE 2 status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DFE_2_CMN        dfe2 cmn tap
 *     DFE_2_SO         dfe 2 tap sign odd
 *     DFE_2_SE         dfe 2 tap sign even
 *     DFE_2_O          dfe2 odd tap
 *     DFE_2_E          dfe2 even tap
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_DFE_2_STSr (0x0000d03c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_DFE_2_STSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DFE_2_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_DFE_2_STSr_s {
	uint32_t v[1];
	uint32_t dsc_dfe_2_sts[1];
	uint32_t _dsc_dfe_2_sts;
} BCMI_TSCE16_XGXS_DSC_DFE_2_STSr_t;

#define BCMI_TSCE16_XGXS_DSC_DFE_2_STSr_CLR(r) (r).dsc_dfe_2_sts[0] = 0
#define BCMI_TSCE16_XGXS_DSC_DFE_2_STSr_SET(r,d) (r).dsc_dfe_2_sts[0] = d
#define BCMI_TSCE16_XGXS_DSC_DFE_2_STSr_GET(r) (r).dsc_dfe_2_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_DFE_2_STSr_DFE_2_Ef_GET(r) ((((r).dsc_dfe_2_sts[0]) >> 11) & 0x7)
#define BCMI_TSCE16_XGXS_DSC_DFE_2_STSr_DFE_2_Ef_SET(r,f) (r).dsc_dfe_2_sts[0]=(((r).dsc_dfe_2_sts[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_TSCE16_XGXS_DSC_DFE_2_STSr_DFE_2_Of_GET(r) ((((r).dsc_dfe_2_sts[0]) >> 8) & 0x7)
#define BCMI_TSCE16_XGXS_DSC_DFE_2_STSr_DFE_2_Of_SET(r,f) (r).dsc_dfe_2_sts[0]=(((r).dsc_dfe_2_sts[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_TSCE16_XGXS_DSC_DFE_2_STSr_DFE_2_SEf_GET(r) ((((r).dsc_dfe_2_sts[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DFE_2_STSr_DFE_2_SEf_SET(r,f) (r).dsc_dfe_2_sts[0]=(((r).dsc_dfe_2_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_DSC_DFE_2_STSr_DFE_2_SOf_GET(r) ((((r).dsc_dfe_2_sts[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_DFE_2_STSr_DFE_2_SOf_SET(r,f) (r).dsc_dfe_2_sts[0]=(((r).dsc_dfe_2_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_DSC_DFE_2_STSr_DFE_2_CMNf_GET(r) (((r).dsc_dfe_2_sts[0]) & 0x1f)
#define BCMI_TSCE16_XGXS_DSC_DFE_2_STSr_DFE_2_CMNf_SET(r,f) (r).dsc_dfe_2_sts[0]=(((r).dsc_dfe_2_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_DFE_2_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_DFE_2_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_DFE_2_STSr,(_r._dsc_dfe_2_sts))
#define BCMI_TSCE16_XGXS_WRITE_DSC_DFE_2_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_2_STSr,(_r._dsc_dfe_2_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_DFE_2_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_2_STSr,(_r._dsc_dfe_2_sts))
#define BCMI_TSCE16_XGXS_READLN_DSC_DFE_2_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_DFE_2_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_2_sts))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_DFE_2_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_2_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_2_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_DFE_2_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_2_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_dfe_2_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_DFE_2_STSr BCMI_TSCE16_XGXS_DSC_DFE_2_STSr
#define DSC_DFE_2_STSr_SIZE BCMI_TSCE16_XGXS_DSC_DFE_2_STSr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_DFE_2_STSr_t DSC_DFE_2_STSr_t;
#define DSC_DFE_2_STSr_CLR BCMI_TSCE16_XGXS_DSC_DFE_2_STSr_CLR
#define DSC_DFE_2_STSr_SET BCMI_TSCE16_XGXS_DSC_DFE_2_STSr_SET
#define DSC_DFE_2_STSr_GET BCMI_TSCE16_XGXS_DSC_DFE_2_STSr_GET
#define DSC_DFE_2_STSr_DFE_2_Ef_GET BCMI_TSCE16_XGXS_DSC_DFE_2_STSr_DFE_2_Ef_GET
#define DSC_DFE_2_STSr_DFE_2_Ef_SET BCMI_TSCE16_XGXS_DSC_DFE_2_STSr_DFE_2_Ef_SET
#define DSC_DFE_2_STSr_DFE_2_Of_GET BCMI_TSCE16_XGXS_DSC_DFE_2_STSr_DFE_2_Of_GET
#define DSC_DFE_2_STSr_DFE_2_Of_SET BCMI_TSCE16_XGXS_DSC_DFE_2_STSr_DFE_2_Of_SET
#define DSC_DFE_2_STSr_DFE_2_SEf_GET BCMI_TSCE16_XGXS_DSC_DFE_2_STSr_DFE_2_SEf_GET
#define DSC_DFE_2_STSr_DFE_2_SEf_SET BCMI_TSCE16_XGXS_DSC_DFE_2_STSr_DFE_2_SEf_SET
#define DSC_DFE_2_STSr_DFE_2_SOf_GET BCMI_TSCE16_XGXS_DSC_DFE_2_STSr_DFE_2_SOf_GET
#define DSC_DFE_2_STSr_DFE_2_SOf_SET BCMI_TSCE16_XGXS_DSC_DFE_2_STSr_DFE_2_SOf_SET
#define DSC_DFE_2_STSr_DFE_2_CMNf_GET BCMI_TSCE16_XGXS_DSC_DFE_2_STSr_DFE_2_CMNf_GET
#define DSC_DFE_2_STSr_DFE_2_CMNf_SET BCMI_TSCE16_XGXS_DSC_DFE_2_STSr_DFE_2_CMNf_SET
#define READ_DSC_DFE_2_STSr BCMI_TSCE16_XGXS_READ_DSC_DFE_2_STSr
#define WRITE_DSC_DFE_2_STSr BCMI_TSCE16_XGXS_WRITE_DSC_DFE_2_STSr
#define MODIFY_DSC_DFE_2_STSr BCMI_TSCE16_XGXS_MODIFY_DSC_DFE_2_STSr
#define READLN_DSC_DFE_2_STSr BCMI_TSCE16_XGXS_READLN_DSC_DFE_2_STSr
#define WRITELN_DSC_DFE_2_STSr BCMI_TSCE16_XGXS_WRITELN_DSC_DFE_2_STSr
#define WRITEALL_DSC_DFE_2_STSr BCMI_TSCE16_XGXS_WRITEALL_DSC_DFE_2_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_DFE_2_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_DFE_3_4_5_STS
 * BLOCKS:   DSC_D
 * REGADDR:  0xd03d
 * DESC:     DFE 3,4,5 status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DFE_3_CMN        dfe 3 tap value
 *     DFE_4_CMN        dfe 4 tap value
 *     DFE_5_CMN        dfe 5 tap value
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_DFE_3_4_5_STSr (0x0000d03d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_DFE_3_4_5_STSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DFE_3_4_5_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_DFE_3_4_5_STSr_s {
	uint32_t v[1];
	uint32_t dsc_dfe_3_4_5_sts[1];
	uint32_t _dsc_dfe_3_4_5_sts;
} BCMI_TSCE16_XGXS_DSC_DFE_3_4_5_STSr_t;

#define BCMI_TSCE16_XGXS_DSC_DFE_3_4_5_STSr_CLR(r) (r).dsc_dfe_3_4_5_sts[0] = 0
#define BCMI_TSCE16_XGXS_DSC_DFE_3_4_5_STSr_SET(r,d) (r).dsc_dfe_3_4_5_sts[0] = d
#define BCMI_TSCE16_XGXS_DSC_DFE_3_4_5_STSr_GET(r) (r).dsc_dfe_3_4_5_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_DFE_3_4_5_STSr_DFE_5_CMNf_GET(r) ((((r).dsc_dfe_3_4_5_sts[0]) >> 11) & 0x1f)
#define BCMI_TSCE16_XGXS_DSC_DFE_3_4_5_STSr_DFE_5_CMNf_SET(r,f) (r).dsc_dfe_3_4_5_sts[0]=(((r).dsc_dfe_3_4_5_sts[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_TSCE16_XGXS_DSC_DFE_3_4_5_STSr_DFE_4_CMNf_GET(r) ((((r).dsc_dfe_3_4_5_sts[0]) >> 6) & 0x1f)
#define BCMI_TSCE16_XGXS_DSC_DFE_3_4_5_STSr_DFE_4_CMNf_SET(r,f) (r).dsc_dfe_3_4_5_sts[0]=(((r).dsc_dfe_3_4_5_sts[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_TSCE16_XGXS_DSC_DFE_3_4_5_STSr_DFE_3_CMNf_GET(r) (((r).dsc_dfe_3_4_5_sts[0]) & 0x3f)
#define BCMI_TSCE16_XGXS_DSC_DFE_3_4_5_STSr_DFE_3_CMNf_SET(r,f) (r).dsc_dfe_3_4_5_sts[0]=(((r).dsc_dfe_3_4_5_sts[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_DFE_3_4_5_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_DFE_3_4_5_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_DFE_3_4_5_STSr,(_r._dsc_dfe_3_4_5_sts))
#define BCMI_TSCE16_XGXS_WRITE_DSC_DFE_3_4_5_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_3_4_5_STSr,(_r._dsc_dfe_3_4_5_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_DFE_3_4_5_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_3_4_5_STSr,(_r._dsc_dfe_3_4_5_sts))
#define BCMI_TSCE16_XGXS_READLN_DSC_DFE_3_4_5_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_DFE_3_4_5_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_3_4_5_sts))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_DFE_3_4_5_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_3_4_5_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dfe_3_4_5_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_DFE_3_4_5_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_DFE_3_4_5_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_dfe_3_4_5_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_DFE_3_4_5_STSr BCMI_TSCE16_XGXS_DSC_DFE_3_4_5_STSr
#define DSC_DFE_3_4_5_STSr_SIZE BCMI_TSCE16_XGXS_DSC_DFE_3_4_5_STSr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_DFE_3_4_5_STSr_t DSC_DFE_3_4_5_STSr_t;
#define DSC_DFE_3_4_5_STSr_CLR BCMI_TSCE16_XGXS_DSC_DFE_3_4_5_STSr_CLR
#define DSC_DFE_3_4_5_STSr_SET BCMI_TSCE16_XGXS_DSC_DFE_3_4_5_STSr_SET
#define DSC_DFE_3_4_5_STSr_GET BCMI_TSCE16_XGXS_DSC_DFE_3_4_5_STSr_GET
#define DSC_DFE_3_4_5_STSr_DFE_5_CMNf_GET BCMI_TSCE16_XGXS_DSC_DFE_3_4_5_STSr_DFE_5_CMNf_GET
#define DSC_DFE_3_4_5_STSr_DFE_5_CMNf_SET BCMI_TSCE16_XGXS_DSC_DFE_3_4_5_STSr_DFE_5_CMNf_SET
#define DSC_DFE_3_4_5_STSr_DFE_4_CMNf_GET BCMI_TSCE16_XGXS_DSC_DFE_3_4_5_STSr_DFE_4_CMNf_GET
#define DSC_DFE_3_4_5_STSr_DFE_4_CMNf_SET BCMI_TSCE16_XGXS_DSC_DFE_3_4_5_STSr_DFE_4_CMNf_SET
#define DSC_DFE_3_4_5_STSr_DFE_3_CMNf_GET BCMI_TSCE16_XGXS_DSC_DFE_3_4_5_STSr_DFE_3_CMNf_GET
#define DSC_DFE_3_4_5_STSr_DFE_3_CMNf_SET BCMI_TSCE16_XGXS_DSC_DFE_3_4_5_STSr_DFE_3_CMNf_SET
#define READ_DSC_DFE_3_4_5_STSr BCMI_TSCE16_XGXS_READ_DSC_DFE_3_4_5_STSr
#define WRITE_DSC_DFE_3_4_5_STSr BCMI_TSCE16_XGXS_WRITE_DSC_DFE_3_4_5_STSr
#define MODIFY_DSC_DFE_3_4_5_STSr BCMI_TSCE16_XGXS_MODIFY_DSC_DFE_3_4_5_STSr
#define READLN_DSC_DFE_3_4_5_STSr BCMI_TSCE16_XGXS_READLN_DSC_DFE_3_4_5_STSr
#define WRITELN_DSC_DFE_3_4_5_STSr BCMI_TSCE16_XGXS_WRITELN_DSC_DFE_3_4_5_STSr
#define WRITEALL_DSC_DFE_3_4_5_STSr BCMI_TSCE16_XGXS_WRITEALL_DSC_DFE_3_4_5_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_DFE_3_4_5_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_VGA_TAP_BIN
 * BLOCKS:   DSC_D
 * REGADDR:  0xd03e
 * DESC:     VGA binary tap values
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     VGA1_CTRL_BIN    VGA 1 ctrl value.
 *     VGA2_CTRL_BIN    VGA 2 ctrl value.
 *     VGA3_CTRL_BIN    VGA 3 ctrl value.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_VGA_TAP_BINr (0x0000d03e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_VGA_TAP_BINr_SIZE 4

/*
 * This structure should be used to declare and program DSC_VGA_TAP_BIN.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_VGA_TAP_BINr_s {
	uint32_t v[1];
	uint32_t dsc_vga_tap_bin[1];
	uint32_t _dsc_vga_tap_bin;
} BCMI_TSCE16_XGXS_DSC_VGA_TAP_BINr_t;

#define BCMI_TSCE16_XGXS_DSC_VGA_TAP_BINr_CLR(r) (r).dsc_vga_tap_bin[0] = 0
#define BCMI_TSCE16_XGXS_DSC_VGA_TAP_BINr_SET(r,d) (r).dsc_vga_tap_bin[0] = d
#define BCMI_TSCE16_XGXS_DSC_VGA_TAP_BINr_GET(r) (r).dsc_vga_tap_bin[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_VGA_TAP_BINr_VGA3_CTRL_BINf_GET(r) ((((r).dsc_vga_tap_bin[0]) >> 8) & 0xf)
#define BCMI_TSCE16_XGXS_DSC_VGA_TAP_BINr_VGA3_CTRL_BINf_SET(r,f) (r).dsc_vga_tap_bin[0]=(((r).dsc_vga_tap_bin[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_TSCE16_XGXS_DSC_VGA_TAP_BINr_VGA2_CTRL_BINf_GET(r) ((((r).dsc_vga_tap_bin[0]) >> 4) & 0xf)
#define BCMI_TSCE16_XGXS_DSC_VGA_TAP_BINr_VGA2_CTRL_BINf_SET(r,f) (r).dsc_vga_tap_bin[0]=(((r).dsc_vga_tap_bin[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_TSCE16_XGXS_DSC_VGA_TAP_BINr_VGA1_CTRL_BINf_GET(r) (((r).dsc_vga_tap_bin[0]) & 0xf)
#define BCMI_TSCE16_XGXS_DSC_VGA_TAP_BINr_VGA1_CTRL_BINf_SET(r,f) (r).dsc_vga_tap_bin[0]=(((r).dsc_vga_tap_bin[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_VGA_TAP_BIN.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_VGA_TAP_BINr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_VGA_TAP_BINr,(_r._dsc_vga_tap_bin))
#define BCMI_TSCE16_XGXS_WRITE_DSC_VGA_TAP_BINr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_VGA_TAP_BINr,(_r._dsc_vga_tap_bin)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_VGA_TAP_BINr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_VGA_TAP_BINr,(_r._dsc_vga_tap_bin))
#define BCMI_TSCE16_XGXS_READLN_DSC_VGA_TAP_BINr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_VGA_TAP_BINr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_vga_tap_bin))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_VGA_TAP_BINr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_VGA_TAP_BINr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_vga_tap_bin))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_VGA_TAP_BINr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_VGA_TAP_BINr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_vga_tap_bin))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_VGA_TAP_BINr BCMI_TSCE16_XGXS_DSC_VGA_TAP_BINr
#define DSC_VGA_TAP_BINr_SIZE BCMI_TSCE16_XGXS_DSC_VGA_TAP_BINr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_VGA_TAP_BINr_t DSC_VGA_TAP_BINr_t;
#define DSC_VGA_TAP_BINr_CLR BCMI_TSCE16_XGXS_DSC_VGA_TAP_BINr_CLR
#define DSC_VGA_TAP_BINr_SET BCMI_TSCE16_XGXS_DSC_VGA_TAP_BINr_SET
#define DSC_VGA_TAP_BINr_GET BCMI_TSCE16_XGXS_DSC_VGA_TAP_BINr_GET
#define DSC_VGA_TAP_BINr_VGA3_CTRL_BINf_GET BCMI_TSCE16_XGXS_DSC_VGA_TAP_BINr_VGA3_CTRL_BINf_GET
#define DSC_VGA_TAP_BINr_VGA3_CTRL_BINf_SET BCMI_TSCE16_XGXS_DSC_VGA_TAP_BINr_VGA3_CTRL_BINf_SET
#define DSC_VGA_TAP_BINr_VGA2_CTRL_BINf_GET BCMI_TSCE16_XGXS_DSC_VGA_TAP_BINr_VGA2_CTRL_BINf_GET
#define DSC_VGA_TAP_BINr_VGA2_CTRL_BINf_SET BCMI_TSCE16_XGXS_DSC_VGA_TAP_BINr_VGA2_CTRL_BINf_SET
#define DSC_VGA_TAP_BINr_VGA1_CTRL_BINf_GET BCMI_TSCE16_XGXS_DSC_VGA_TAP_BINr_VGA1_CTRL_BINf_GET
#define DSC_VGA_TAP_BINr_VGA1_CTRL_BINf_SET BCMI_TSCE16_XGXS_DSC_VGA_TAP_BINr_VGA1_CTRL_BINf_SET
#define READ_DSC_VGA_TAP_BINr BCMI_TSCE16_XGXS_READ_DSC_VGA_TAP_BINr
#define WRITE_DSC_VGA_TAP_BINr BCMI_TSCE16_XGXS_WRITE_DSC_VGA_TAP_BINr
#define MODIFY_DSC_VGA_TAP_BINr BCMI_TSCE16_XGXS_MODIFY_DSC_VGA_TAP_BINr
#define READLN_DSC_VGA_TAP_BINr BCMI_TSCE16_XGXS_READLN_DSC_VGA_TAP_BINr
#define WRITELN_DSC_VGA_TAP_BINr BCMI_TSCE16_XGXS_WRITELN_DSC_VGA_TAP_BINr
#define WRITEALL_DSC_VGA_TAP_BINr BCMI_TSCE16_XGXS_WRITEALL_DSC_VGA_TAP_BINr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_VGA_TAP_BINr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_E_CTL
 * BLOCKS:   DSC_E
 * REGADDR:  0xd040
 * DESC:     dsc_e_ctrl
 * RESETVAL: 0x30 (48)
 * ACCESS:   R/W
 * FIELDS:
 *     PD_CH_P1         Power down +1 channel
 *     OFFSET_PD        Power down analog offset cancellation loop
 *     EN_HGAIN         Enable high gain in DFE sum path for non-DFE mode
 *     P1_THRESH_SEL    P1 slicer target level
 *     M1_THRESH_ZERO   sets m1 target to 0mV for OS TR
 *     M1_THRESH_SEL    00, 125mV; 01, 150mV (default)10, 175mV; 11, 200mV
 *     PF_HIZ           When this bit=1, the zero in peaking filteris shifted to higher frequency
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_E_CTLr (0x0000d040 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_E_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_E_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_E_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_e_ctl[1];
	uint32_t _dsc_e_ctl;
} BCMI_TSCE16_XGXS_DSC_E_CTLr_t;

#define BCMI_TSCE16_XGXS_DSC_E_CTLr_CLR(r) (r).dsc_e_ctl[0] = 0
#define BCMI_TSCE16_XGXS_DSC_E_CTLr_SET(r,d) (r).dsc_e_ctl[0] = d
#define BCMI_TSCE16_XGXS_DSC_E_CTLr_GET(r) (r).dsc_e_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_E_CTLr_PF_HIZf_GET(r) ((((r).dsc_e_ctl[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_E_CTLr_PF_HIZf_SET(r,f) (r).dsc_e_ctl[0]=(((r).dsc_e_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_DSC_E_CTLr_M1_THRESH_SELf_GET(r) ((((r).dsc_e_ctl[0]) >> 5) & 0x3)
#define BCMI_TSCE16_XGXS_DSC_E_CTLr_M1_THRESH_SELf_SET(r,f) (r).dsc_e_ctl[0]=(((r).dsc_e_ctl[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5)) | (3 << (16 + 5))
#define BCMI_TSCE16_XGXS_DSC_E_CTLr_M1_THRESH_ZEROf_GET(r) ((((r).dsc_e_ctl[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_E_CTLr_M1_THRESH_ZEROf_SET(r,f) (r).dsc_e_ctl[0]=(((r).dsc_e_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_DSC_E_CTLr_P1_THRESH_SELf_GET(r) ((((r).dsc_e_ctl[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_E_CTLr_P1_THRESH_SELf_SET(r,f) (r).dsc_e_ctl[0]=(((r).dsc_e_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_DSC_E_CTLr_EN_HGAINf_GET(r) ((((r).dsc_e_ctl[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_E_CTLr_EN_HGAINf_SET(r,f) (r).dsc_e_ctl[0]=(((r).dsc_e_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_DSC_E_CTLr_OFFSET_PDf_GET(r) ((((r).dsc_e_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_E_CTLr_OFFSET_PDf_SET(r,f) (r).dsc_e_ctl[0]=(((r).dsc_e_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_DSC_E_CTLr_PD_CH_P1f_GET(r) (((r).dsc_e_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_DSC_E_CTLr_PD_CH_P1f_SET(r,f) (r).dsc_e_ctl[0]=(((r).dsc_e_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_E_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_E_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_E_CTLr,(_r._dsc_e_ctl))
#define BCMI_TSCE16_XGXS_WRITE_DSC_E_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_E_CTLr,(_r._dsc_e_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_E_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_E_CTLr,(_r._dsc_e_ctl))
#define BCMI_TSCE16_XGXS_READLN_DSC_E_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_E_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_e_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_E_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_E_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_e_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_E_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_E_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_e_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_E_CTLr BCMI_TSCE16_XGXS_DSC_E_CTLr
#define DSC_E_CTLr_SIZE BCMI_TSCE16_XGXS_DSC_E_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_E_CTLr_t DSC_E_CTLr_t;
#define DSC_E_CTLr_CLR BCMI_TSCE16_XGXS_DSC_E_CTLr_CLR
#define DSC_E_CTLr_SET BCMI_TSCE16_XGXS_DSC_E_CTLr_SET
#define DSC_E_CTLr_GET BCMI_TSCE16_XGXS_DSC_E_CTLr_GET
#define DSC_E_CTLr_PF_HIZf_GET BCMI_TSCE16_XGXS_DSC_E_CTLr_PF_HIZf_GET
#define DSC_E_CTLr_PF_HIZf_SET BCMI_TSCE16_XGXS_DSC_E_CTLr_PF_HIZf_SET
#define DSC_E_CTLr_M1_THRESH_SELf_GET BCMI_TSCE16_XGXS_DSC_E_CTLr_M1_THRESH_SELf_GET
#define DSC_E_CTLr_M1_THRESH_SELf_SET BCMI_TSCE16_XGXS_DSC_E_CTLr_M1_THRESH_SELf_SET
#define DSC_E_CTLr_M1_THRESH_ZEROf_GET BCMI_TSCE16_XGXS_DSC_E_CTLr_M1_THRESH_ZEROf_GET
#define DSC_E_CTLr_M1_THRESH_ZEROf_SET BCMI_TSCE16_XGXS_DSC_E_CTLr_M1_THRESH_ZEROf_SET
#define DSC_E_CTLr_P1_THRESH_SELf_GET BCMI_TSCE16_XGXS_DSC_E_CTLr_P1_THRESH_SELf_GET
#define DSC_E_CTLr_P1_THRESH_SELf_SET BCMI_TSCE16_XGXS_DSC_E_CTLr_P1_THRESH_SELf_SET
#define DSC_E_CTLr_EN_HGAINf_GET BCMI_TSCE16_XGXS_DSC_E_CTLr_EN_HGAINf_GET
#define DSC_E_CTLr_EN_HGAINf_SET BCMI_TSCE16_XGXS_DSC_E_CTLr_EN_HGAINf_SET
#define DSC_E_CTLr_OFFSET_PDf_GET BCMI_TSCE16_XGXS_DSC_E_CTLr_OFFSET_PDf_GET
#define DSC_E_CTLr_OFFSET_PDf_SET BCMI_TSCE16_XGXS_DSC_E_CTLr_OFFSET_PDf_SET
#define DSC_E_CTLr_PD_CH_P1f_GET BCMI_TSCE16_XGXS_DSC_E_CTLr_PD_CH_P1f_GET
#define DSC_E_CTLr_PD_CH_P1f_SET BCMI_TSCE16_XGXS_DSC_E_CTLr_PD_CH_P1f_SET
#define READ_DSC_E_CTLr BCMI_TSCE16_XGXS_READ_DSC_E_CTLr
#define WRITE_DSC_E_CTLr BCMI_TSCE16_XGXS_WRITE_DSC_E_CTLr
#define MODIFY_DSC_E_CTLr BCMI_TSCE16_XGXS_MODIFY_DSC_E_CTLr
#define READLN_DSC_E_CTLr BCMI_TSCE16_XGXS_READLN_DSC_E_CTLr
#define WRITELN_DSC_E_CTLr BCMI_TSCE16_XGXS_WRITELN_DSC_E_CTLr
#define WRITEALL_DSC_E_CTLr BCMI_TSCE16_XGXS_WRITEALL_DSC_E_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_E_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_E_PF_CTL
 * BLOCKS:   DSC_E
 * REGADDR:  0xd041
 * DESC:     dsc_e_pf_ctrl
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PF_CTRL          Peaking filter control, approx 0-8 dB boost in~0.5 dB steps. Gray code
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_E_PF_CTLr (0x0000d041 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_E_PF_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_E_PF_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_E_PF_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_e_pf_ctl[1];
	uint32_t _dsc_e_pf_ctl;
} BCMI_TSCE16_XGXS_DSC_E_PF_CTLr_t;

#define BCMI_TSCE16_XGXS_DSC_E_PF_CTLr_CLR(r) (r).dsc_e_pf_ctl[0] = 0
#define BCMI_TSCE16_XGXS_DSC_E_PF_CTLr_SET(r,d) (r).dsc_e_pf_ctl[0] = d
#define BCMI_TSCE16_XGXS_DSC_E_PF_CTLr_GET(r) (r).dsc_e_pf_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_E_PF_CTLr_PF_CTRLf_GET(r) (((r).dsc_e_pf_ctl[0]) & 0xf)
#define BCMI_TSCE16_XGXS_DSC_E_PF_CTLr_PF_CTRLf_SET(r,f) (r).dsc_e_pf_ctl[0]=(((r).dsc_e_pf_ctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_E_PF_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_E_PF_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_E_PF_CTLr,(_r._dsc_e_pf_ctl))
#define BCMI_TSCE16_XGXS_WRITE_DSC_E_PF_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_E_PF_CTLr,(_r._dsc_e_pf_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_E_PF_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_E_PF_CTLr,(_r._dsc_e_pf_ctl))
#define BCMI_TSCE16_XGXS_READLN_DSC_E_PF_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_E_PF_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_e_pf_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_E_PF_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_E_PF_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_e_pf_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_E_PF_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_E_PF_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_e_pf_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_E_PF_CTLr BCMI_TSCE16_XGXS_DSC_E_PF_CTLr
#define DSC_E_PF_CTLr_SIZE BCMI_TSCE16_XGXS_DSC_E_PF_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_E_PF_CTLr_t DSC_E_PF_CTLr_t;
#define DSC_E_PF_CTLr_CLR BCMI_TSCE16_XGXS_DSC_E_PF_CTLr_CLR
#define DSC_E_PF_CTLr_SET BCMI_TSCE16_XGXS_DSC_E_PF_CTLr_SET
#define DSC_E_PF_CTLr_GET BCMI_TSCE16_XGXS_DSC_E_PF_CTLr_GET
#define DSC_E_PF_CTLr_PF_CTRLf_GET BCMI_TSCE16_XGXS_DSC_E_PF_CTLr_PF_CTRLf_GET
#define DSC_E_PF_CTLr_PF_CTRLf_SET BCMI_TSCE16_XGXS_DSC_E_PF_CTLr_PF_CTRLf_SET
#define READ_DSC_E_PF_CTLr BCMI_TSCE16_XGXS_READ_DSC_E_PF_CTLr
#define WRITE_DSC_E_PF_CTLr BCMI_TSCE16_XGXS_WRITE_DSC_E_PF_CTLr
#define MODIFY_DSC_E_PF_CTLr BCMI_TSCE16_XGXS_MODIFY_DSC_E_PF_CTLr
#define READLN_DSC_E_PF_CTLr BCMI_TSCE16_XGXS_READLN_DSC_E_PF_CTLr
#define WRITELN_DSC_E_PF_CTLr BCMI_TSCE16_XGXS_WRITELN_DSC_E_PF_CTLr
#define WRITEALL_DSC_E_PF_CTLr BCMI_TSCE16_XGXS_WRITEALL_DSC_E_PF_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_E_PF_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_E_PF2_LOWP_CTL
 * BLOCKS:   DSC_E
 * REGADDR:  0xd042
 * DESC:     dsc_e_pf2_lowp_ctrl
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PF2_LOWP_CTRL    Low frequency peaking filter, low pass000 (Gray) - min peaking100 (Gray) - max peaking
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_E_PF2_LOWP_CTLr (0x0000d042 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_E_PF2_LOWP_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_E_PF2_LOWP_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_E_PF2_LOWP_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_e_pf2_lowp_ctl[1];
	uint32_t _dsc_e_pf2_lowp_ctl;
} BCMI_TSCE16_XGXS_DSC_E_PF2_LOWP_CTLr_t;

#define BCMI_TSCE16_XGXS_DSC_E_PF2_LOWP_CTLr_CLR(r) (r).dsc_e_pf2_lowp_ctl[0] = 0
#define BCMI_TSCE16_XGXS_DSC_E_PF2_LOWP_CTLr_SET(r,d) (r).dsc_e_pf2_lowp_ctl[0] = d
#define BCMI_TSCE16_XGXS_DSC_E_PF2_LOWP_CTLr_GET(r) (r).dsc_e_pf2_lowp_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_E_PF2_LOWP_CTLr_PF2_LOWP_CTRLf_GET(r) (((r).dsc_e_pf2_lowp_ctl[0]) & 0x7)
#define BCMI_TSCE16_XGXS_DSC_E_PF2_LOWP_CTLr_PF2_LOWP_CTRLf_SET(r,f) (r).dsc_e_pf2_lowp_ctl[0]=(((r).dsc_e_pf2_lowp_ctl[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access DSC_E_PF2_LOWP_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_E_PF2_LOWP_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_E_PF2_LOWP_CTLr,(_r._dsc_e_pf2_lowp_ctl))
#define BCMI_TSCE16_XGXS_WRITE_DSC_E_PF2_LOWP_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_E_PF2_LOWP_CTLr,(_r._dsc_e_pf2_lowp_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_E_PF2_LOWP_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_E_PF2_LOWP_CTLr,(_r._dsc_e_pf2_lowp_ctl))
#define BCMI_TSCE16_XGXS_READLN_DSC_E_PF2_LOWP_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_E_PF2_LOWP_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_e_pf2_lowp_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_E_PF2_LOWP_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_E_PF2_LOWP_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_e_pf2_lowp_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_E_PF2_LOWP_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_E_PF2_LOWP_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_e_pf2_lowp_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_E_PF2_LOWP_CTLr BCMI_TSCE16_XGXS_DSC_E_PF2_LOWP_CTLr
#define DSC_E_PF2_LOWP_CTLr_SIZE BCMI_TSCE16_XGXS_DSC_E_PF2_LOWP_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_E_PF2_LOWP_CTLr_t DSC_E_PF2_LOWP_CTLr_t;
#define DSC_E_PF2_LOWP_CTLr_CLR BCMI_TSCE16_XGXS_DSC_E_PF2_LOWP_CTLr_CLR
#define DSC_E_PF2_LOWP_CTLr_SET BCMI_TSCE16_XGXS_DSC_E_PF2_LOWP_CTLr_SET
#define DSC_E_PF2_LOWP_CTLr_GET BCMI_TSCE16_XGXS_DSC_E_PF2_LOWP_CTLr_GET
#define DSC_E_PF2_LOWP_CTLr_PF2_LOWP_CTRLf_GET BCMI_TSCE16_XGXS_DSC_E_PF2_LOWP_CTLr_PF2_LOWP_CTRLf_GET
#define DSC_E_PF2_LOWP_CTLr_PF2_LOWP_CTRLf_SET BCMI_TSCE16_XGXS_DSC_E_PF2_LOWP_CTLr_PF2_LOWP_CTRLf_SET
#define READ_DSC_E_PF2_LOWP_CTLr BCMI_TSCE16_XGXS_READ_DSC_E_PF2_LOWP_CTLr
#define WRITE_DSC_E_PF2_LOWP_CTLr BCMI_TSCE16_XGXS_WRITE_DSC_E_PF2_LOWP_CTLr
#define MODIFY_DSC_E_PF2_LOWP_CTLr BCMI_TSCE16_XGXS_MODIFY_DSC_E_PF2_LOWP_CTLr
#define READLN_DSC_E_PF2_LOWP_CTLr BCMI_TSCE16_XGXS_READLN_DSC_E_PF2_LOWP_CTLr
#define WRITELN_DSC_E_PF2_LOWP_CTLr BCMI_TSCE16_XGXS_WRITELN_DSC_E_PF2_LOWP_CTLr
#define WRITEALL_DSC_E_PF2_LOWP_CTLr BCMI_TSCE16_XGXS_WRITEALL_DSC_E_PF2_LOWP_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_E_PF2_LOWP_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  CL72UR_CTL0
 * BLOCKS:   CL72_USER_RX
 * REGADDR:  0xd050
 * DESC:     Control 0 Register
 * RESETVAL: 0x4 (4)
 * ACCESS:   R/W
 * FIELDS:
 *     CL72_RX_TRAINING_EN RX Training EnableEnables the frame lock fsm on the RX sides
 *     CL72_TR_COARSE_LOCK Set to TRUE (1'b1) by the micro when coarse lock to recovered clock has occured.cl72_pmd, then, proceeds with establishing frame_lock.
 *     CL72_RX_SIGNAL_OK Firmware sets this bit to 1'b0 when the training is in progressand sets this bit to 1'b1 when the training is complete
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_CL72UR_CTL0r (0x0000d050 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_CL72UR_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program CL72UR_CTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_CL72UR_CTL0r_s {
	uint32_t v[1];
	uint32_t cl72ur_ctl0[1];
	uint32_t _cl72ur_ctl0;
} BCMI_TSCE16_XGXS_CL72UR_CTL0r_t;

#define BCMI_TSCE16_XGXS_CL72UR_CTL0r_CLR(r) (r).cl72ur_ctl0[0] = 0
#define BCMI_TSCE16_XGXS_CL72UR_CTL0r_SET(r,d) (r).cl72ur_ctl0[0] = d
#define BCMI_TSCE16_XGXS_CL72UR_CTL0r_GET(r) (r).cl72ur_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_CL72UR_CTL0r_CL72_RX_SIGNAL_OKf_GET(r) ((((r).cl72ur_ctl0[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_CL72UR_CTL0r_CL72_RX_SIGNAL_OKf_SET(r,f) (r).cl72ur_ctl0[0]=(((r).cl72ur_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_CL72UR_CTL0r_CL72_TR_COARSE_LOCKf_GET(r) ((((r).cl72ur_ctl0[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_CL72UR_CTL0r_CL72_TR_COARSE_LOCKf_SET(r,f) (r).cl72ur_ctl0[0]=(((r).cl72ur_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_CL72UR_CTL0r_CL72_RX_TRAINING_ENf_GET(r) (((r).cl72ur_ctl0[0]) & 0x1)
#define BCMI_TSCE16_XGXS_CL72UR_CTL0r_CL72_RX_TRAINING_ENf_SET(r,f) (r).cl72ur_ctl0[0]=(((r).cl72ur_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL72UR_CTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_CL72UR_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72UR_CTL0r,(_r._cl72ur_ctl0))
#define BCMI_TSCE16_XGXS_WRITE_CL72UR_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UR_CTL0r,(_r._cl72ur_ctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_CL72UR_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UR_CTL0r,(_r._cl72ur_ctl0))
#define BCMI_TSCE16_XGXS_READLN_CL72UR_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72UR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72ur_ctl0))
#define BCMI_TSCE16_XGXS_WRITELN_CL72UR_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72ur_ctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_CL72UR_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72ur_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL72UR_CTL0r BCMI_TSCE16_XGXS_CL72UR_CTL0r
#define CL72UR_CTL0r_SIZE BCMI_TSCE16_XGXS_CL72UR_CTL0r_SIZE
typedef BCMI_TSCE16_XGXS_CL72UR_CTL0r_t CL72UR_CTL0r_t;
#define CL72UR_CTL0r_CLR BCMI_TSCE16_XGXS_CL72UR_CTL0r_CLR
#define CL72UR_CTL0r_SET BCMI_TSCE16_XGXS_CL72UR_CTL0r_SET
#define CL72UR_CTL0r_GET BCMI_TSCE16_XGXS_CL72UR_CTL0r_GET
#define CL72UR_CTL0r_CL72_RX_SIGNAL_OKf_GET BCMI_TSCE16_XGXS_CL72UR_CTL0r_CL72_RX_SIGNAL_OKf_GET
#define CL72UR_CTL0r_CL72_RX_SIGNAL_OKf_SET BCMI_TSCE16_XGXS_CL72UR_CTL0r_CL72_RX_SIGNAL_OKf_SET
#define CL72UR_CTL0r_CL72_TR_COARSE_LOCKf_GET BCMI_TSCE16_XGXS_CL72UR_CTL0r_CL72_TR_COARSE_LOCKf_GET
#define CL72UR_CTL0r_CL72_TR_COARSE_LOCKf_SET BCMI_TSCE16_XGXS_CL72UR_CTL0r_CL72_TR_COARSE_LOCKf_SET
#define CL72UR_CTL0r_CL72_RX_TRAINING_ENf_GET BCMI_TSCE16_XGXS_CL72UR_CTL0r_CL72_RX_TRAINING_ENf_GET
#define CL72UR_CTL0r_CL72_RX_TRAINING_ENf_SET BCMI_TSCE16_XGXS_CL72UR_CTL0r_CL72_RX_TRAINING_ENf_SET
#define READ_CL72UR_CTL0r BCMI_TSCE16_XGXS_READ_CL72UR_CTL0r
#define WRITE_CL72UR_CTL0r BCMI_TSCE16_XGXS_WRITE_CL72UR_CTL0r
#define MODIFY_CL72UR_CTL0r BCMI_TSCE16_XGXS_MODIFY_CL72UR_CTL0r
#define READLN_CL72UR_CTL0r BCMI_TSCE16_XGXS_READLN_CL72UR_CTL0r
#define WRITELN_CL72UR_CTL0r BCMI_TSCE16_XGXS_WRITELN_CL72UR_CTL0r
#define WRITEALL_CL72UR_CTL0r BCMI_TSCE16_XGXS_WRITEALL_CL72UR_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_CL72UR_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  CL72UR_CTL1
 * BLOCKS:   CL72_USER_RX
 * REGADDR:  0xd051
 * DESC:     Control 1 Register
 * RESETVAL: 0x52 (82)
 * ACCESS:   R/W
 * FIELDS:
 *     CL72_GOOD_MARKER_CNT Number of good marker to checkbefore enabling frame lock
 *     CL72_BAD_MARKER_CNT Number of bad marker to checkbefore losing frame lock
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_CL72UR_CTL1r (0x0000d051 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_CL72UR_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program CL72UR_CTL1.
 *
 */
typedef union BCMI_TSCE16_XGXS_CL72UR_CTL1r_s {
	uint32_t v[1];
	uint32_t cl72ur_ctl1[1];
	uint32_t _cl72ur_ctl1;
} BCMI_TSCE16_XGXS_CL72UR_CTL1r_t;

#define BCMI_TSCE16_XGXS_CL72UR_CTL1r_CLR(r) (r).cl72ur_ctl1[0] = 0
#define BCMI_TSCE16_XGXS_CL72UR_CTL1r_SET(r,d) (r).cl72ur_ctl1[0] = d
#define BCMI_TSCE16_XGXS_CL72UR_CTL1r_GET(r) (r).cl72ur_ctl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_CL72UR_CTL1r_CL72_BAD_MARKER_CNTf_GET(r) ((((r).cl72ur_ctl1[0]) >> 4) & 0x7)
#define BCMI_TSCE16_XGXS_CL72UR_CTL1r_CL72_BAD_MARKER_CNTf_SET(r,f) (r).cl72ur_ctl1[0]=(((r).cl72ur_ctl1[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_TSCE16_XGXS_CL72UR_CTL1r_CL72_GOOD_MARKER_CNTf_GET(r) (((r).cl72ur_ctl1[0]) & 0x3)
#define BCMI_TSCE16_XGXS_CL72UR_CTL1r_CL72_GOOD_MARKER_CNTf_SET(r,f) (r).cl72ur_ctl1[0]=(((r).cl72ur_ctl1[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access CL72UR_CTL1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_CL72UR_CTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72UR_CTL1r,(_r._cl72ur_ctl1))
#define BCMI_TSCE16_XGXS_WRITE_CL72UR_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UR_CTL1r,(_r._cl72ur_ctl1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_CL72UR_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UR_CTL1r,(_r._cl72ur_ctl1))
#define BCMI_TSCE16_XGXS_READLN_CL72UR_CTL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72UR_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72ur_ctl1))
#define BCMI_TSCE16_XGXS_WRITELN_CL72UR_CTL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UR_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72ur_ctl1))
#define BCMI_TSCE16_XGXS_WRITEALL_CL72UR_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UR_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72ur_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL72UR_CTL1r BCMI_TSCE16_XGXS_CL72UR_CTL1r
#define CL72UR_CTL1r_SIZE BCMI_TSCE16_XGXS_CL72UR_CTL1r_SIZE
typedef BCMI_TSCE16_XGXS_CL72UR_CTL1r_t CL72UR_CTL1r_t;
#define CL72UR_CTL1r_CLR BCMI_TSCE16_XGXS_CL72UR_CTL1r_CLR
#define CL72UR_CTL1r_SET BCMI_TSCE16_XGXS_CL72UR_CTL1r_SET
#define CL72UR_CTL1r_GET BCMI_TSCE16_XGXS_CL72UR_CTL1r_GET
#define CL72UR_CTL1r_CL72_BAD_MARKER_CNTf_GET BCMI_TSCE16_XGXS_CL72UR_CTL1r_CL72_BAD_MARKER_CNTf_GET
#define CL72UR_CTL1r_CL72_BAD_MARKER_CNTf_SET BCMI_TSCE16_XGXS_CL72UR_CTL1r_CL72_BAD_MARKER_CNTf_SET
#define CL72UR_CTL1r_CL72_GOOD_MARKER_CNTf_GET BCMI_TSCE16_XGXS_CL72UR_CTL1r_CL72_GOOD_MARKER_CNTf_GET
#define CL72UR_CTL1r_CL72_GOOD_MARKER_CNTf_SET BCMI_TSCE16_XGXS_CL72UR_CTL1r_CL72_GOOD_MARKER_CNTf_SET
#define READ_CL72UR_CTL1r BCMI_TSCE16_XGXS_READ_CL72UR_CTL1r
#define WRITE_CL72UR_CTL1r BCMI_TSCE16_XGXS_WRITE_CL72UR_CTL1r
#define MODIFY_CL72UR_CTL1r BCMI_TSCE16_XGXS_MODIFY_CL72UR_CTL1r
#define READLN_CL72UR_CTL1r BCMI_TSCE16_XGXS_READLN_CL72UR_CTL1r
#define WRITELN_CL72UR_CTL1r BCMI_TSCE16_XGXS_WRITELN_CL72UR_CTL1r
#define WRITEALL_CL72UR_CTL1r BCMI_TSCE16_XGXS_WRITEALL_CL72UR_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_CL72UR_CTL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  CL72UR_CTL2
 * BLOCKS:   CL72_USER_RX
 * REGADDR:  0xd052
 * DESC:     Control 2 Register
 * RESETVAL: 0x310 (784)
 * ACCESS:   R/W
 * FIELDS:
 *     CL72_CTRL_FRAME_DLY 0   : dis1-7 : early delay w.r.t cl72 rcvd data (7 vals)8  : sync to cl72 rcvd data9-15 : late delay w.r.t cl72 rcvd data (7 vals)
 *     CL72_DME_CELL_BOUNDARY_CHK Check for DME cell boundary transitions0 - disabled1 - enabled
 *     CL72_STRICT_DME_CHK This field specifies whether the edges of DME cells are allowedto shift by a couple samples0 - ignore bits 0, 3, 4 and 7 of the DME cell1 - check all 8 bits of the DME cell
 *     CL72_STRICT_MARKER_CHK When determining frame lock, this field can be used tospecifies whether the edges of frame markers are allowedto shift by a couple samples0 - ignore first and last two samples of the marker1 - do not ignore first and last two samples of the markercheck for all 16 ones followed by 16 zeros
 *     CL72_PPM_OFFSET_EN if enabled, cl72 tracks ppm offset of incoming datawhile checking from frame lock, one bit offset ineither direction for every frame (~4384 bits)
 *     CL72_RX_DP_LN_CLK_EN cl72 Rx datapath lane clock enable0 - disabled1 - enabled
 *     CL72_FRAME_CONSISTENCY_CHK_EN cl72 frame consistency check enable0 - disabled1 - enabled - checks that three consective frames from the link partnerhas the same status response/coffcient update request informationbefore it set the sets the latched status bits
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_CL72UR_CTL2r (0x0000d052 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_CL72UR_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program CL72UR_CTL2.
 *
 */
typedef union BCMI_TSCE16_XGXS_CL72UR_CTL2r_s {
	uint32_t v[1];
	uint32_t cl72ur_ctl2[1];
	uint32_t _cl72ur_ctl2;
} BCMI_TSCE16_XGXS_CL72UR_CTL2r_t;

#define BCMI_TSCE16_XGXS_CL72UR_CTL2r_CLR(r) (r).cl72ur_ctl2[0] = 0
#define BCMI_TSCE16_XGXS_CL72UR_CTL2r_SET(r,d) (r).cl72ur_ctl2[0] = d
#define BCMI_TSCE16_XGXS_CL72UR_CTL2r_GET(r) (r).cl72ur_ctl2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_CL72UR_CTL2r_CL72_FRAME_CONSISTENCY_CHK_ENf_GET(r) ((((r).cl72ur_ctl2[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_CL72UR_CTL2r_CL72_FRAME_CONSISTENCY_CHK_ENf_SET(r,f) (r).cl72ur_ctl2[0]=(((r).cl72ur_ctl2[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_CL72UR_CTL2r_CL72_RX_DP_LN_CLK_ENf_GET(r) ((((r).cl72ur_ctl2[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_CL72UR_CTL2r_CL72_RX_DP_LN_CLK_ENf_SET(r,f) (r).cl72ur_ctl2[0]=(((r).cl72ur_ctl2[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_CL72UR_CTL2r_CL72_PPM_OFFSET_ENf_GET(r) ((((r).cl72ur_ctl2[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_CL72UR_CTL2r_CL72_PPM_OFFSET_ENf_SET(r,f) (r).cl72ur_ctl2[0]=(((r).cl72ur_ctl2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_CL72UR_CTL2r_CL72_STRICT_MARKER_CHKf_GET(r) ((((r).cl72ur_ctl2[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_CL72UR_CTL2r_CL72_STRICT_MARKER_CHKf_SET(r,f) (r).cl72ur_ctl2[0]=(((r).cl72ur_ctl2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_CL72UR_CTL2r_CL72_STRICT_DME_CHKf_GET(r) ((((r).cl72ur_ctl2[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_CL72UR_CTL2r_CL72_STRICT_DME_CHKf_SET(r,f) (r).cl72ur_ctl2[0]=(((r).cl72ur_ctl2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_CL72UR_CTL2r_CL72_DME_CELL_BOUNDARY_CHKf_GET(r) ((((r).cl72ur_ctl2[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_CL72UR_CTL2r_CL72_DME_CELL_BOUNDARY_CHKf_SET(r,f) (r).cl72ur_ctl2[0]=(((r).cl72ur_ctl2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_CL72UR_CTL2r_CL72_CTRL_FRAME_DLYf_GET(r) (((r).cl72ur_ctl2[0]) & 0xf)
#define BCMI_TSCE16_XGXS_CL72UR_CTL2r_CL72_CTRL_FRAME_DLYf_SET(r,f) (r).cl72ur_ctl2[0]=(((r).cl72ur_ctl2[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access CL72UR_CTL2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_CL72UR_CTL2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72UR_CTL2r,(_r._cl72ur_ctl2))
#define BCMI_TSCE16_XGXS_WRITE_CL72UR_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UR_CTL2r,(_r._cl72ur_ctl2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_CL72UR_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UR_CTL2r,(_r._cl72ur_ctl2))
#define BCMI_TSCE16_XGXS_READLN_CL72UR_CTL2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72UR_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72ur_ctl2))
#define BCMI_TSCE16_XGXS_WRITELN_CL72UR_CTL2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UR_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72ur_ctl2))
#define BCMI_TSCE16_XGXS_WRITEALL_CL72UR_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UR_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72ur_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL72UR_CTL2r BCMI_TSCE16_XGXS_CL72UR_CTL2r
#define CL72UR_CTL2r_SIZE BCMI_TSCE16_XGXS_CL72UR_CTL2r_SIZE
typedef BCMI_TSCE16_XGXS_CL72UR_CTL2r_t CL72UR_CTL2r_t;
#define CL72UR_CTL2r_CLR BCMI_TSCE16_XGXS_CL72UR_CTL2r_CLR
#define CL72UR_CTL2r_SET BCMI_TSCE16_XGXS_CL72UR_CTL2r_SET
#define CL72UR_CTL2r_GET BCMI_TSCE16_XGXS_CL72UR_CTL2r_GET
#define CL72UR_CTL2r_CL72_FRAME_CONSISTENCY_CHK_ENf_GET BCMI_TSCE16_XGXS_CL72UR_CTL2r_CL72_FRAME_CONSISTENCY_CHK_ENf_GET
#define CL72UR_CTL2r_CL72_FRAME_CONSISTENCY_CHK_ENf_SET BCMI_TSCE16_XGXS_CL72UR_CTL2r_CL72_FRAME_CONSISTENCY_CHK_ENf_SET
#define CL72UR_CTL2r_CL72_RX_DP_LN_CLK_ENf_GET BCMI_TSCE16_XGXS_CL72UR_CTL2r_CL72_RX_DP_LN_CLK_ENf_GET
#define CL72UR_CTL2r_CL72_RX_DP_LN_CLK_ENf_SET BCMI_TSCE16_XGXS_CL72UR_CTL2r_CL72_RX_DP_LN_CLK_ENf_SET
#define CL72UR_CTL2r_CL72_PPM_OFFSET_ENf_GET BCMI_TSCE16_XGXS_CL72UR_CTL2r_CL72_PPM_OFFSET_ENf_GET
#define CL72UR_CTL2r_CL72_PPM_OFFSET_ENf_SET BCMI_TSCE16_XGXS_CL72UR_CTL2r_CL72_PPM_OFFSET_ENf_SET
#define CL72UR_CTL2r_CL72_STRICT_MARKER_CHKf_GET BCMI_TSCE16_XGXS_CL72UR_CTL2r_CL72_STRICT_MARKER_CHKf_GET
#define CL72UR_CTL2r_CL72_STRICT_MARKER_CHKf_SET BCMI_TSCE16_XGXS_CL72UR_CTL2r_CL72_STRICT_MARKER_CHKf_SET
#define CL72UR_CTL2r_CL72_STRICT_DME_CHKf_GET BCMI_TSCE16_XGXS_CL72UR_CTL2r_CL72_STRICT_DME_CHKf_GET
#define CL72UR_CTL2r_CL72_STRICT_DME_CHKf_SET BCMI_TSCE16_XGXS_CL72UR_CTL2r_CL72_STRICT_DME_CHKf_SET
#define CL72UR_CTL2r_CL72_DME_CELL_BOUNDARY_CHKf_GET BCMI_TSCE16_XGXS_CL72UR_CTL2r_CL72_DME_CELL_BOUNDARY_CHKf_GET
#define CL72UR_CTL2r_CL72_DME_CELL_BOUNDARY_CHKf_SET BCMI_TSCE16_XGXS_CL72UR_CTL2r_CL72_DME_CELL_BOUNDARY_CHKf_SET
#define CL72UR_CTL2r_CL72_CTRL_FRAME_DLYf_GET BCMI_TSCE16_XGXS_CL72UR_CTL2r_CL72_CTRL_FRAME_DLYf_GET
#define CL72UR_CTL2r_CL72_CTRL_FRAME_DLYf_SET BCMI_TSCE16_XGXS_CL72UR_CTL2r_CL72_CTRL_FRAME_DLYf_SET
#define READ_CL72UR_CTL2r BCMI_TSCE16_XGXS_READ_CL72UR_CTL2r
#define WRITE_CL72UR_CTL2r BCMI_TSCE16_XGXS_WRITE_CL72UR_CTL2r
#define MODIFY_CL72UR_CTL2r BCMI_TSCE16_XGXS_MODIFY_CL72UR_CTL2r
#define READLN_CL72UR_CTL2r BCMI_TSCE16_XGXS_READLN_CL72UR_CTL2r
#define WRITELN_CL72UR_CTL2r BCMI_TSCE16_XGXS_WRITELN_CL72UR_CTL2r
#define WRITEALL_CL72UR_CTL2r BCMI_TSCE16_XGXS_WRITEALL_CL72UR_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_CL72UR_CTL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  CL72UR_STS0
 * BLOCKS:   CL72_USER_RX
 * REGADDR:  0xd053
 * DESC:     Status 0 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL72_FRAME_LOCK  Frame Lock signal statusThis bit provides status of the frame lock signal from the frame lock fsm.1 - frame locked0 - frame not lockedThe status bit in the IEEE registers space is set by firmware
 *     CL72_REMOTE_RX_READY remote_rx_ready statusThis bit provides status of the remote_rx_ready signal from the link partner.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_CL72UR_STS0r (0x0000d053 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_CL72UR_STS0r_SIZE 4

/*
 * This structure should be used to declare and program CL72UR_STS0.
 *
 */
typedef union BCMI_TSCE16_XGXS_CL72UR_STS0r_s {
	uint32_t v[1];
	uint32_t cl72ur_sts0[1];
	uint32_t _cl72ur_sts0;
} BCMI_TSCE16_XGXS_CL72UR_STS0r_t;

#define BCMI_TSCE16_XGXS_CL72UR_STS0r_CLR(r) (r).cl72ur_sts0[0] = 0
#define BCMI_TSCE16_XGXS_CL72UR_STS0r_SET(r,d) (r).cl72ur_sts0[0] = d
#define BCMI_TSCE16_XGXS_CL72UR_STS0r_GET(r) (r).cl72ur_sts0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_CL72UR_STS0r_CL72_REMOTE_RX_READYf_GET(r) ((((r).cl72ur_sts0[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_CL72UR_STS0r_CL72_REMOTE_RX_READYf_SET(r,f) (r).cl72ur_sts0[0]=(((r).cl72ur_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_CL72UR_STS0r_CL72_FRAME_LOCKf_GET(r) (((r).cl72ur_sts0[0]) & 0x1)
#define BCMI_TSCE16_XGXS_CL72UR_STS0r_CL72_FRAME_LOCKf_SET(r,f) (r).cl72ur_sts0[0]=(((r).cl72ur_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL72UR_STS0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_CL72UR_STS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72UR_STS0r,(_r._cl72ur_sts0))
#define BCMI_TSCE16_XGXS_WRITE_CL72UR_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UR_STS0r,(_r._cl72ur_sts0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_CL72UR_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UR_STS0r,(_r._cl72ur_sts0))
#define BCMI_TSCE16_XGXS_READLN_CL72UR_STS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72UR_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72ur_sts0))
#define BCMI_TSCE16_XGXS_WRITELN_CL72UR_STS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UR_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72ur_sts0))
#define BCMI_TSCE16_XGXS_WRITEALL_CL72UR_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UR_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72ur_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL72UR_STS0r BCMI_TSCE16_XGXS_CL72UR_STS0r
#define CL72UR_STS0r_SIZE BCMI_TSCE16_XGXS_CL72UR_STS0r_SIZE
typedef BCMI_TSCE16_XGXS_CL72UR_STS0r_t CL72UR_STS0r_t;
#define CL72UR_STS0r_CLR BCMI_TSCE16_XGXS_CL72UR_STS0r_CLR
#define CL72UR_STS0r_SET BCMI_TSCE16_XGXS_CL72UR_STS0r_SET
#define CL72UR_STS0r_GET BCMI_TSCE16_XGXS_CL72UR_STS0r_GET
#define CL72UR_STS0r_CL72_REMOTE_RX_READYf_GET BCMI_TSCE16_XGXS_CL72UR_STS0r_CL72_REMOTE_RX_READYf_GET
#define CL72UR_STS0r_CL72_REMOTE_RX_READYf_SET BCMI_TSCE16_XGXS_CL72UR_STS0r_CL72_REMOTE_RX_READYf_SET
#define CL72UR_STS0r_CL72_FRAME_LOCKf_GET BCMI_TSCE16_XGXS_CL72UR_STS0r_CL72_FRAME_LOCKf_GET
#define CL72UR_STS0r_CL72_FRAME_LOCKf_SET BCMI_TSCE16_XGXS_CL72UR_STS0r_CL72_FRAME_LOCKf_SET
#define READ_CL72UR_STS0r BCMI_TSCE16_XGXS_READ_CL72UR_STS0r
#define WRITE_CL72UR_STS0r BCMI_TSCE16_XGXS_WRITE_CL72UR_STS0r
#define MODIFY_CL72UR_STS0r BCMI_TSCE16_XGXS_MODIFY_CL72UR_STS0r
#define READLN_CL72UR_STS0r BCMI_TSCE16_XGXS_READLN_CL72UR_STS0r
#define WRITELN_CL72UR_STS0r BCMI_TSCE16_XGXS_WRITELN_CL72UR_STS0r
#define WRITEALL_CL72UR_STS0r BCMI_TSCE16_XGXS_WRITEALL_CL72UR_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_CL72UR_STS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  CL72UR_UC_INTR_CTL0
 * BLOCKS:   CL72_USER_RX
 * REGADDR:  0xd054
 * DESC:     Micro Interrupt Control 0 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL72_MICRO_UPDATE_CHG_INT_EN Update field micro interrupt enable. Enables an interrupt when the update field value changes in the training frame received from Link PartnerThe Link parnter request a change to the Local Device TX FIR tap values via the update field1 - Enable. Generates an interrupt when cl72_micro_lstatus_update_chg = 1'b1.0 - Disable
 *     CL72_MICRO_STATUS_CHG_INT_EN Status field change micro interrupt enable. Enables an interrupt when the status field value changes in the training frame received from Link PartnerWhen the Local Devices requests Link Partner to change its TX FIR tap values, then the Link Partner updatestaps and sends a response on the stataus field of the training frame1 - Enable. Generates an interrupt when cl72_micro_lstatus_status_chg = 1'b1.0 - Disable
 *     CL72_MICRO_FRAME_LOCK_INT_EN frame_lock change micro interrupt enable.1 - Enable0 - Disable
 *     CL72_MICRO_UPDATE_REQ_INT_FRC Force an interrupt on cl72_micro_update_req_int pin0 -  interrupt on the cl72_micro_update_req_int pingenerated when the update field value changes in the trainingframe received from Link Partner andcl72_micro_update_chg_int_en field is set to 1'b11 -  interrupt on the cl72_micro_update_req_int pingenerated by the cl72_micro_update_req_int_frc_val field
 *     CL72_MICRO_UPDATE_REQ_INT_FRC_VAL Force value on cl72_micro_update_req_int pinwhen cl72_micro_update_req_int_frc field is set to 1'b1
 *     CL72_MICRO_STATUS_RESP_INT_FRC Force an interrupt on cl72_micro_status_resp_int pin0 -  interrupt on the cl72_micro_status_resp_int pingenerated when the status field value changes in the trainingframe received from Link Partner andcl72_micro_status_chg_int_en field is set to 1'b11 -  interrupt on the cl72_micro_status_resp_int pingenerated by the cl72_micro_status_resp_int_frc_val field
 *     CL72_MICRO_STATUS_RESP_INT_FRC_VAL Force value on cl72_micro_status_resp_int pinwhen cl72_micro_status_resp_int_frc field is set to 1'b1
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r (0x0000d054 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program CL72UR_UC_INTR_CTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_s {
	uint32_t v[1];
	uint32_t cl72ur_uc_intr_ctl0[1];
	uint32_t _cl72ur_uc_intr_ctl0;
} BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_t;

#define BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_CLR(r) (r).cl72ur_uc_intr_ctl0[0] = 0
#define BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_SET(r,d) (r).cl72ur_uc_intr_ctl0[0] = d
#define BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_GET(r) (r).cl72ur_uc_intr_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_CL72_MICRO_STATUS_RESP_INT_FRC_VALf_GET(r) ((((r).cl72ur_uc_intr_ctl0[0]) >> 11) & 0x1)
#define BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_CL72_MICRO_STATUS_RESP_INT_FRC_VALf_SET(r,f) (r).cl72ur_uc_intr_ctl0[0]=(((r).cl72ur_uc_intr_ctl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_CL72_MICRO_STATUS_RESP_INT_FRCf_GET(r) ((((r).cl72ur_uc_intr_ctl0[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_CL72_MICRO_STATUS_RESP_INT_FRCf_SET(r,f) (r).cl72ur_uc_intr_ctl0[0]=(((r).cl72ur_uc_intr_ctl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_CL72_MICRO_UPDATE_REQ_INT_FRC_VALf_GET(r) ((((r).cl72ur_uc_intr_ctl0[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_CL72_MICRO_UPDATE_REQ_INT_FRC_VALf_SET(r,f) (r).cl72ur_uc_intr_ctl0[0]=(((r).cl72ur_uc_intr_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_CL72_MICRO_UPDATE_REQ_INT_FRCf_GET(r) ((((r).cl72ur_uc_intr_ctl0[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_CL72_MICRO_UPDATE_REQ_INT_FRCf_SET(r,f) (r).cl72ur_uc_intr_ctl0[0]=(((r).cl72ur_uc_intr_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_CL72_MICRO_FRAME_LOCK_INT_ENf_GET(r) ((((r).cl72ur_uc_intr_ctl0[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_CL72_MICRO_FRAME_LOCK_INT_ENf_SET(r,f) (r).cl72ur_uc_intr_ctl0[0]=(((r).cl72ur_uc_intr_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_CL72_MICRO_STATUS_CHG_INT_ENf_GET(r) ((((r).cl72ur_uc_intr_ctl0[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_CL72_MICRO_STATUS_CHG_INT_ENf_SET(r,f) (r).cl72ur_uc_intr_ctl0[0]=(((r).cl72ur_uc_intr_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_CL72_MICRO_UPDATE_CHG_INT_ENf_GET(r) (((r).cl72ur_uc_intr_ctl0[0]) & 0x1)
#define BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_CL72_MICRO_UPDATE_CHG_INT_ENf_SET(r,f) (r).cl72ur_uc_intr_ctl0[0]=(((r).cl72ur_uc_intr_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL72UR_UC_INTR_CTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_CL72UR_UC_INTR_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r,(_r._cl72ur_uc_intr_ctl0))
#define BCMI_TSCE16_XGXS_WRITE_CL72UR_UC_INTR_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r,(_r._cl72ur_uc_intr_ctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_CL72UR_UC_INTR_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r,(_r._cl72ur_uc_intr_ctl0))
#define BCMI_TSCE16_XGXS_READLN_CL72UR_UC_INTR_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72ur_uc_intr_ctl0))
#define BCMI_TSCE16_XGXS_WRITELN_CL72UR_UC_INTR_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72ur_uc_intr_ctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_CL72UR_UC_INTR_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72ur_uc_intr_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL72UR_UC_INTR_CTL0r BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r
#define CL72UR_UC_INTR_CTL0r_SIZE BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_SIZE
typedef BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_t CL72UR_UC_INTR_CTL0r_t;
#define CL72UR_UC_INTR_CTL0r_CLR BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_CLR
#define CL72UR_UC_INTR_CTL0r_SET BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_SET
#define CL72UR_UC_INTR_CTL0r_GET BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_GET
#define CL72UR_UC_INTR_CTL0r_CL72_MICRO_STATUS_RESP_INT_FRC_VALf_GET BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_CL72_MICRO_STATUS_RESP_INT_FRC_VALf_GET
#define CL72UR_UC_INTR_CTL0r_CL72_MICRO_STATUS_RESP_INT_FRC_VALf_SET BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_CL72_MICRO_STATUS_RESP_INT_FRC_VALf_SET
#define CL72UR_UC_INTR_CTL0r_CL72_MICRO_STATUS_RESP_INT_FRCf_GET BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_CL72_MICRO_STATUS_RESP_INT_FRCf_GET
#define CL72UR_UC_INTR_CTL0r_CL72_MICRO_STATUS_RESP_INT_FRCf_SET BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_CL72_MICRO_STATUS_RESP_INT_FRCf_SET
#define CL72UR_UC_INTR_CTL0r_CL72_MICRO_UPDATE_REQ_INT_FRC_VALf_GET BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_CL72_MICRO_UPDATE_REQ_INT_FRC_VALf_GET
#define CL72UR_UC_INTR_CTL0r_CL72_MICRO_UPDATE_REQ_INT_FRC_VALf_SET BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_CL72_MICRO_UPDATE_REQ_INT_FRC_VALf_SET
#define CL72UR_UC_INTR_CTL0r_CL72_MICRO_UPDATE_REQ_INT_FRCf_GET BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_CL72_MICRO_UPDATE_REQ_INT_FRCf_GET
#define CL72UR_UC_INTR_CTL0r_CL72_MICRO_UPDATE_REQ_INT_FRCf_SET BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_CL72_MICRO_UPDATE_REQ_INT_FRCf_SET
#define CL72UR_UC_INTR_CTL0r_CL72_MICRO_FRAME_LOCK_INT_ENf_GET BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_CL72_MICRO_FRAME_LOCK_INT_ENf_GET
#define CL72UR_UC_INTR_CTL0r_CL72_MICRO_FRAME_LOCK_INT_ENf_SET BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_CL72_MICRO_FRAME_LOCK_INT_ENf_SET
#define CL72UR_UC_INTR_CTL0r_CL72_MICRO_STATUS_CHG_INT_ENf_GET BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_CL72_MICRO_STATUS_CHG_INT_ENf_GET
#define CL72UR_UC_INTR_CTL0r_CL72_MICRO_STATUS_CHG_INT_ENf_SET BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_CL72_MICRO_STATUS_CHG_INT_ENf_SET
#define CL72UR_UC_INTR_CTL0r_CL72_MICRO_UPDATE_CHG_INT_ENf_GET BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_CL72_MICRO_UPDATE_CHG_INT_ENf_GET
#define CL72UR_UC_INTR_CTL0r_CL72_MICRO_UPDATE_CHG_INT_ENf_SET BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r_CL72_MICRO_UPDATE_CHG_INT_ENf_SET
#define READ_CL72UR_UC_INTR_CTL0r BCMI_TSCE16_XGXS_READ_CL72UR_UC_INTR_CTL0r
#define WRITE_CL72UR_UC_INTR_CTL0r BCMI_TSCE16_XGXS_WRITE_CL72UR_UC_INTR_CTL0r
#define MODIFY_CL72UR_UC_INTR_CTL0r BCMI_TSCE16_XGXS_MODIFY_CL72UR_UC_INTR_CTL0r
#define READLN_CL72UR_UC_INTR_CTL0r BCMI_TSCE16_XGXS_READLN_CL72UR_UC_INTR_CTL0r
#define WRITELN_CL72UR_UC_INTR_CTL0r BCMI_TSCE16_XGXS_WRITELN_CL72UR_UC_INTR_CTL0r
#define WRITEALL_CL72UR_UC_INTR_CTL0r BCMI_TSCE16_XGXS_WRITEALL_CL72UR_UC_INTR_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_CL72UR_UC_INTR_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  CL72UR_UC_STS0
 * BLOCKS:   CL72_USER_RX
 * REGADDR:  0xd055
 * DESC:     Micro Status 0 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL72_MICRO_UPDATE_CHG_LSTATUS coeffcient update field change latched status -  This bit is set to 1'b1 when the update field value changes in thetraining frame received from the Link Partner.This bit cleared when this register is read.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_CL72UR_UC_STS0r (0x0000d055 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_CL72UR_UC_STS0r_SIZE 4

/*
 * This structure should be used to declare and program CL72UR_UC_STS0.
 *
 */
typedef union BCMI_TSCE16_XGXS_CL72UR_UC_STS0r_s {
	uint32_t v[1];
	uint32_t cl72ur_uc_sts0[1];
	uint32_t _cl72ur_uc_sts0;
} BCMI_TSCE16_XGXS_CL72UR_UC_STS0r_t;

#define BCMI_TSCE16_XGXS_CL72UR_UC_STS0r_CLR(r) (r).cl72ur_uc_sts0[0] = 0
#define BCMI_TSCE16_XGXS_CL72UR_UC_STS0r_SET(r,d) (r).cl72ur_uc_sts0[0] = d
#define BCMI_TSCE16_XGXS_CL72UR_UC_STS0r_GET(r) (r).cl72ur_uc_sts0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_CL72UR_UC_STS0r_CL72_MICRO_UPDATE_CHG_LSTATUSf_GET(r) (((r).cl72ur_uc_sts0[0]) & 0x1)
#define BCMI_TSCE16_XGXS_CL72UR_UC_STS0r_CL72_MICRO_UPDATE_CHG_LSTATUSf_SET(r,f) (r).cl72ur_uc_sts0[0]=(((r).cl72ur_uc_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL72UR_UC_STS0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_CL72UR_UC_STS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72UR_UC_STS0r,(_r._cl72ur_uc_sts0))
#define BCMI_TSCE16_XGXS_WRITE_CL72UR_UC_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UR_UC_STS0r,(_r._cl72ur_uc_sts0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_CL72UR_UC_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UR_UC_STS0r,(_r._cl72ur_uc_sts0))
#define BCMI_TSCE16_XGXS_READLN_CL72UR_UC_STS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72UR_UC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72ur_uc_sts0))
#define BCMI_TSCE16_XGXS_WRITELN_CL72UR_UC_STS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UR_UC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72ur_uc_sts0))
#define BCMI_TSCE16_XGXS_WRITEALL_CL72UR_UC_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UR_UC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72ur_uc_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL72UR_UC_STS0r BCMI_TSCE16_XGXS_CL72UR_UC_STS0r
#define CL72UR_UC_STS0r_SIZE BCMI_TSCE16_XGXS_CL72UR_UC_STS0r_SIZE
typedef BCMI_TSCE16_XGXS_CL72UR_UC_STS0r_t CL72UR_UC_STS0r_t;
#define CL72UR_UC_STS0r_CLR BCMI_TSCE16_XGXS_CL72UR_UC_STS0r_CLR
#define CL72UR_UC_STS0r_SET BCMI_TSCE16_XGXS_CL72UR_UC_STS0r_SET
#define CL72UR_UC_STS0r_GET BCMI_TSCE16_XGXS_CL72UR_UC_STS0r_GET
#define CL72UR_UC_STS0r_CL72_MICRO_UPDATE_CHG_LSTATUSf_GET BCMI_TSCE16_XGXS_CL72UR_UC_STS0r_CL72_MICRO_UPDATE_CHG_LSTATUSf_GET
#define CL72UR_UC_STS0r_CL72_MICRO_UPDATE_CHG_LSTATUSf_SET BCMI_TSCE16_XGXS_CL72UR_UC_STS0r_CL72_MICRO_UPDATE_CHG_LSTATUSf_SET
#define READ_CL72UR_UC_STS0r BCMI_TSCE16_XGXS_READ_CL72UR_UC_STS0r
#define WRITE_CL72UR_UC_STS0r BCMI_TSCE16_XGXS_WRITE_CL72UR_UC_STS0r
#define MODIFY_CL72UR_UC_STS0r BCMI_TSCE16_XGXS_MODIFY_CL72UR_UC_STS0r
#define READLN_CL72UR_UC_STS0r BCMI_TSCE16_XGXS_READLN_CL72UR_UC_STS0r
#define WRITELN_CL72UR_UC_STS0r BCMI_TSCE16_XGXS_WRITELN_CL72UR_UC_STS0r
#define WRITEALL_CL72UR_UC_STS0r BCMI_TSCE16_XGXS_WRITEALL_CL72UR_UC_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_CL72UR_UC_STS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  CL72UR_UC_STS1
 * BLOCKS:   CL72_USER_RX
 * REGADDR:  0xd056
 * DESC:     Micro Status 1 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL72_MICRO_STATUS_CHG_LSTATUS coeffcient status field latched status - This bit is set to 1'b1 when the status field value changes in thetraining frame received from the Link Partner.This bit cleared when this register is read.
 *     CL72_MICRO_FRAME_LOCK_LSTATUS Frame lock change latched status - This bit is set to 1'b1 when a change is detected on the frame lock signalThis bit cleared when this register is read.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_CL72UR_UC_STS1r (0x0000d056 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_CL72UR_UC_STS1r_SIZE 4

/*
 * This structure should be used to declare and program CL72UR_UC_STS1.
 *
 */
typedef union BCMI_TSCE16_XGXS_CL72UR_UC_STS1r_s {
	uint32_t v[1];
	uint32_t cl72ur_uc_sts1[1];
	uint32_t _cl72ur_uc_sts1;
} BCMI_TSCE16_XGXS_CL72UR_UC_STS1r_t;

#define BCMI_TSCE16_XGXS_CL72UR_UC_STS1r_CLR(r) (r).cl72ur_uc_sts1[0] = 0
#define BCMI_TSCE16_XGXS_CL72UR_UC_STS1r_SET(r,d) (r).cl72ur_uc_sts1[0] = d
#define BCMI_TSCE16_XGXS_CL72UR_UC_STS1r_GET(r) (r).cl72ur_uc_sts1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_CL72UR_UC_STS1r_CL72_MICRO_FRAME_LOCK_LSTATUSf_GET(r) ((((r).cl72ur_uc_sts1[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_CL72UR_UC_STS1r_CL72_MICRO_FRAME_LOCK_LSTATUSf_SET(r,f) (r).cl72ur_uc_sts1[0]=(((r).cl72ur_uc_sts1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_CL72UR_UC_STS1r_CL72_MICRO_STATUS_CHG_LSTATUSf_GET(r) (((r).cl72ur_uc_sts1[0]) & 0x1)
#define BCMI_TSCE16_XGXS_CL72UR_UC_STS1r_CL72_MICRO_STATUS_CHG_LSTATUSf_SET(r,f) (r).cl72ur_uc_sts1[0]=(((r).cl72ur_uc_sts1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL72UR_UC_STS1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_CL72UR_UC_STS1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72UR_UC_STS1r,(_r._cl72ur_uc_sts1))
#define BCMI_TSCE16_XGXS_WRITE_CL72UR_UC_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UR_UC_STS1r,(_r._cl72ur_uc_sts1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_CL72UR_UC_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UR_UC_STS1r,(_r._cl72ur_uc_sts1))
#define BCMI_TSCE16_XGXS_READLN_CL72UR_UC_STS1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72UR_UC_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72ur_uc_sts1))
#define BCMI_TSCE16_XGXS_WRITELN_CL72UR_UC_STS1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UR_UC_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72ur_uc_sts1))
#define BCMI_TSCE16_XGXS_WRITEALL_CL72UR_UC_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UR_UC_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72ur_uc_sts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL72UR_UC_STS1r BCMI_TSCE16_XGXS_CL72UR_UC_STS1r
#define CL72UR_UC_STS1r_SIZE BCMI_TSCE16_XGXS_CL72UR_UC_STS1r_SIZE
typedef BCMI_TSCE16_XGXS_CL72UR_UC_STS1r_t CL72UR_UC_STS1r_t;
#define CL72UR_UC_STS1r_CLR BCMI_TSCE16_XGXS_CL72UR_UC_STS1r_CLR
#define CL72UR_UC_STS1r_SET BCMI_TSCE16_XGXS_CL72UR_UC_STS1r_SET
#define CL72UR_UC_STS1r_GET BCMI_TSCE16_XGXS_CL72UR_UC_STS1r_GET
#define CL72UR_UC_STS1r_CL72_MICRO_FRAME_LOCK_LSTATUSf_GET BCMI_TSCE16_XGXS_CL72UR_UC_STS1r_CL72_MICRO_FRAME_LOCK_LSTATUSf_GET
#define CL72UR_UC_STS1r_CL72_MICRO_FRAME_LOCK_LSTATUSf_SET BCMI_TSCE16_XGXS_CL72UR_UC_STS1r_CL72_MICRO_FRAME_LOCK_LSTATUSf_SET
#define CL72UR_UC_STS1r_CL72_MICRO_STATUS_CHG_LSTATUSf_GET BCMI_TSCE16_XGXS_CL72UR_UC_STS1r_CL72_MICRO_STATUS_CHG_LSTATUSf_GET
#define CL72UR_UC_STS1r_CL72_MICRO_STATUS_CHG_LSTATUSf_SET BCMI_TSCE16_XGXS_CL72UR_UC_STS1r_CL72_MICRO_STATUS_CHG_LSTATUSf_SET
#define READ_CL72UR_UC_STS1r BCMI_TSCE16_XGXS_READ_CL72UR_UC_STS1r
#define WRITE_CL72UR_UC_STS1r BCMI_TSCE16_XGXS_WRITE_CL72UR_UC_STS1r
#define MODIFY_CL72UR_UC_STS1r BCMI_TSCE16_XGXS_MODIFY_CL72UR_UC_STS1r
#define READLN_CL72UR_UC_STS1r BCMI_TSCE16_XGXS_READLN_CL72UR_UC_STS1r
#define WRITELN_CL72UR_UC_STS1r BCMI_TSCE16_XGXS_WRITELN_CL72UR_UC_STS1r
#define WRITEALL_CL72UR_UC_STS1r BCMI_TSCE16_XGXS_WRITEALL_CL72UR_UC_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_CL72UR_UC_STS1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  CL72UT_XMT_UPD_PAGE
 * BLOCKS:   CL72_USER_TX
 * REGADDR:  0xd060
 * DESC:     cl72 Send Coefficient Update Request to Link Partner Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL72_XMT_UPDATE_PAGE Local Device (LD) Coefficient Update registerContains correction information from the local receiverto the link partner transmit equalizer.Bit15:14   Reserved Transmitted as 0, ignored on reception.13   Preset1 = Preset coefficients0 = Normal operation12   Initialize 1 = Initialize coefficients0 = Normal operation11:6 Reserved Transmitted as 0, ignored on reception.5:4  Coefficient (+1) update5 41 1 = reserved0 1 = increment1 0 = decrement0 0 = hold3:2  Coefficient (0) update3 21 1 = reserved0 1 = increment1 0 = decrement0 0 = hold1:0  Coefficient (-1) update1 01 1 = reserved0 1 = increment1 0 = decrement0 0 = hold
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_CL72UT_XMT_UPD_PAGEr (0x0000d060 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_CL72UT_XMT_UPD_PAGEr_SIZE 4

/*
 * This structure should be used to declare and program CL72UT_XMT_UPD_PAGE.
 *
 */
typedef union BCMI_TSCE16_XGXS_CL72UT_XMT_UPD_PAGEr_s {
	uint32_t v[1];
	uint32_t cl72ut_xmt_upd_page[1];
	uint32_t _cl72ut_xmt_upd_page;
} BCMI_TSCE16_XGXS_CL72UT_XMT_UPD_PAGEr_t;

#define BCMI_TSCE16_XGXS_CL72UT_XMT_UPD_PAGEr_CLR(r) (r).cl72ut_xmt_upd_page[0] = 0
#define BCMI_TSCE16_XGXS_CL72UT_XMT_UPD_PAGEr_SET(r,d) (r).cl72ut_xmt_upd_page[0] = d
#define BCMI_TSCE16_XGXS_CL72UT_XMT_UPD_PAGEr_GET(r) (r).cl72ut_xmt_upd_page[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_CL72UT_XMT_UPD_PAGEr_CL72_XMT_UPDATE_PAGEf_GET(r) (((r).cl72ut_xmt_upd_page[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_CL72UT_XMT_UPD_PAGEr_CL72_XMT_UPDATE_PAGEf_SET(r,f) (r).cl72ut_xmt_upd_page[0]=(((r).cl72ut_xmt_upd_page[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CL72UT_XMT_UPD_PAGE.
 *
 */
#define BCMI_TSCE16_XGXS_READ_CL72UT_XMT_UPD_PAGEr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72UT_XMT_UPD_PAGEr,(_r._cl72ut_xmt_upd_page))
#define BCMI_TSCE16_XGXS_WRITE_CL72UT_XMT_UPD_PAGEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UT_XMT_UPD_PAGEr,(_r._cl72ut_xmt_upd_page)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_CL72UT_XMT_UPD_PAGEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UT_XMT_UPD_PAGEr,(_r._cl72ut_xmt_upd_page))
#define BCMI_TSCE16_XGXS_READLN_CL72UT_XMT_UPD_PAGEr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72UT_XMT_UPD_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72ut_xmt_upd_page))
#define BCMI_TSCE16_XGXS_WRITELN_CL72UT_XMT_UPD_PAGEr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UT_XMT_UPD_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72ut_xmt_upd_page))
#define BCMI_TSCE16_XGXS_WRITEALL_CL72UT_XMT_UPD_PAGEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UT_XMT_UPD_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72ut_xmt_upd_page))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL72UT_XMT_UPD_PAGEr BCMI_TSCE16_XGXS_CL72UT_XMT_UPD_PAGEr
#define CL72UT_XMT_UPD_PAGEr_SIZE BCMI_TSCE16_XGXS_CL72UT_XMT_UPD_PAGEr_SIZE
typedef BCMI_TSCE16_XGXS_CL72UT_XMT_UPD_PAGEr_t CL72UT_XMT_UPD_PAGEr_t;
#define CL72UT_XMT_UPD_PAGEr_CLR BCMI_TSCE16_XGXS_CL72UT_XMT_UPD_PAGEr_CLR
#define CL72UT_XMT_UPD_PAGEr_SET BCMI_TSCE16_XGXS_CL72UT_XMT_UPD_PAGEr_SET
#define CL72UT_XMT_UPD_PAGEr_GET BCMI_TSCE16_XGXS_CL72UT_XMT_UPD_PAGEr_GET
#define CL72UT_XMT_UPD_PAGEr_CL72_XMT_UPDATE_PAGEf_GET BCMI_TSCE16_XGXS_CL72UT_XMT_UPD_PAGEr_CL72_XMT_UPDATE_PAGEf_GET
#define CL72UT_XMT_UPD_PAGEr_CL72_XMT_UPDATE_PAGEf_SET BCMI_TSCE16_XGXS_CL72UT_XMT_UPD_PAGEr_CL72_XMT_UPDATE_PAGEf_SET
#define READ_CL72UT_XMT_UPD_PAGEr BCMI_TSCE16_XGXS_READ_CL72UT_XMT_UPD_PAGEr
#define WRITE_CL72UT_XMT_UPD_PAGEr BCMI_TSCE16_XGXS_WRITE_CL72UT_XMT_UPD_PAGEr
#define MODIFY_CL72UT_XMT_UPD_PAGEr BCMI_TSCE16_XGXS_MODIFY_CL72UT_XMT_UPD_PAGEr
#define READLN_CL72UT_XMT_UPD_PAGEr BCMI_TSCE16_XGXS_READLN_CL72UT_XMT_UPD_PAGEr
#define WRITELN_CL72UT_XMT_UPD_PAGEr BCMI_TSCE16_XGXS_WRITELN_CL72UT_XMT_UPD_PAGEr
#define WRITEALL_CL72UT_XMT_UPD_PAGEr BCMI_TSCE16_XGXS_WRITEALL_CL72UT_XMT_UPD_PAGEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_CL72UT_XMT_UPD_PAGEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  CL72UT_LD_XMT_STS_PAGE
 * BLOCKS:   CL72_USER_TX
 * REGADDR:  0xd061
 * DESC:     cl72 Send Local Device's Coeffcient Status to Link Partner Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL72_LD_XMT_STATUS_PAGE Local Device's transmit status page
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_CL72UT_LD_XMT_STS_PAGEr (0x0000d061 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_CL72UT_LD_XMT_STS_PAGEr_SIZE 4

/*
 * This structure should be used to declare and program CL72UT_LD_XMT_STS_PAGE.
 *
 */
typedef union BCMI_TSCE16_XGXS_CL72UT_LD_XMT_STS_PAGEr_s {
	uint32_t v[1];
	uint32_t cl72ut_ld_xmt_sts_page[1];
	uint32_t _cl72ut_ld_xmt_sts_page;
} BCMI_TSCE16_XGXS_CL72UT_LD_XMT_STS_PAGEr_t;

#define BCMI_TSCE16_XGXS_CL72UT_LD_XMT_STS_PAGEr_CLR(r) (r).cl72ut_ld_xmt_sts_page[0] = 0
#define BCMI_TSCE16_XGXS_CL72UT_LD_XMT_STS_PAGEr_SET(r,d) (r).cl72ut_ld_xmt_sts_page[0] = d
#define BCMI_TSCE16_XGXS_CL72UT_LD_XMT_STS_PAGEr_GET(r) (r).cl72ut_ld_xmt_sts_page[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_CL72UT_LD_XMT_STS_PAGEr_CL72_LD_XMT_STATUS_PAGEf_GET(r) (((r).cl72ut_ld_xmt_sts_page[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_CL72UT_LD_XMT_STS_PAGEr_CL72_LD_XMT_STATUS_PAGEf_SET(r,f) (r).cl72ut_ld_xmt_sts_page[0]=(((r).cl72ut_ld_xmt_sts_page[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CL72UT_LD_XMT_STS_PAGE.
 *
 */
#define BCMI_TSCE16_XGXS_READ_CL72UT_LD_XMT_STS_PAGEr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72UT_LD_XMT_STS_PAGEr,(_r._cl72ut_ld_xmt_sts_page))
#define BCMI_TSCE16_XGXS_WRITE_CL72UT_LD_XMT_STS_PAGEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UT_LD_XMT_STS_PAGEr,(_r._cl72ut_ld_xmt_sts_page)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_CL72UT_LD_XMT_STS_PAGEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UT_LD_XMT_STS_PAGEr,(_r._cl72ut_ld_xmt_sts_page))
#define BCMI_TSCE16_XGXS_READLN_CL72UT_LD_XMT_STS_PAGEr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72UT_LD_XMT_STS_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72ut_ld_xmt_sts_page))
#define BCMI_TSCE16_XGXS_WRITELN_CL72UT_LD_XMT_STS_PAGEr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UT_LD_XMT_STS_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72ut_ld_xmt_sts_page))
#define BCMI_TSCE16_XGXS_WRITEALL_CL72UT_LD_XMT_STS_PAGEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UT_LD_XMT_STS_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72ut_ld_xmt_sts_page))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL72UT_LD_XMT_STS_PAGEr BCMI_TSCE16_XGXS_CL72UT_LD_XMT_STS_PAGEr
#define CL72UT_LD_XMT_STS_PAGEr_SIZE BCMI_TSCE16_XGXS_CL72UT_LD_XMT_STS_PAGEr_SIZE
typedef BCMI_TSCE16_XGXS_CL72UT_LD_XMT_STS_PAGEr_t CL72UT_LD_XMT_STS_PAGEr_t;
#define CL72UT_LD_XMT_STS_PAGEr_CLR BCMI_TSCE16_XGXS_CL72UT_LD_XMT_STS_PAGEr_CLR
#define CL72UT_LD_XMT_STS_PAGEr_SET BCMI_TSCE16_XGXS_CL72UT_LD_XMT_STS_PAGEr_SET
#define CL72UT_LD_XMT_STS_PAGEr_GET BCMI_TSCE16_XGXS_CL72UT_LD_XMT_STS_PAGEr_GET
#define CL72UT_LD_XMT_STS_PAGEr_CL72_LD_XMT_STATUS_PAGEf_GET BCMI_TSCE16_XGXS_CL72UT_LD_XMT_STS_PAGEr_CL72_LD_XMT_STATUS_PAGEf_GET
#define CL72UT_LD_XMT_STS_PAGEr_CL72_LD_XMT_STATUS_PAGEf_SET BCMI_TSCE16_XGXS_CL72UT_LD_XMT_STS_PAGEr_CL72_LD_XMT_STATUS_PAGEf_SET
#define READ_CL72UT_LD_XMT_STS_PAGEr BCMI_TSCE16_XGXS_READ_CL72UT_LD_XMT_STS_PAGEr
#define WRITE_CL72UT_LD_XMT_STS_PAGEr BCMI_TSCE16_XGXS_WRITE_CL72UT_LD_XMT_STS_PAGEr
#define MODIFY_CL72UT_LD_XMT_STS_PAGEr BCMI_TSCE16_XGXS_MODIFY_CL72UT_LD_XMT_STS_PAGEr
#define READLN_CL72UT_LD_XMT_STS_PAGEr BCMI_TSCE16_XGXS_READLN_CL72UT_LD_XMT_STS_PAGEr
#define WRITELN_CL72UT_LD_XMT_STS_PAGEr BCMI_TSCE16_XGXS_WRITELN_CL72UT_LD_XMT_STS_PAGEr
#define WRITEALL_CL72UT_LD_XMT_STS_PAGEr BCMI_TSCE16_XGXS_WRITEALL_CL72UT_LD_XMT_STS_PAGEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_CL72UT_LD_XMT_STS_PAGEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  CL72UT_CTL0
 * BLOCKS:   CL72_USER_TX
 * REGADDR:  0xd062
 * DESC:     cl72 Control 0 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL72_SW_RX_TRAINED Set to TRUE (1'b1) by the micro when the remote transmitand local equalizers have been optimized and normal datatransmission may commence; set to FALSE (1'b0) otherwise.
 *     CL72_SW_FRAME_LOCK Set to TRUE (1'b1) by the micro to indicate to the training fsmframe lock has been achieved
 *     CL72_SW_REMOTE_RX_READY Set to TRUE (1'b1) by the micro to indicate to the training fsmlink parnter rx ready bit is set. It indicates that the remote is trained
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_CL72UT_CTL0r (0x0000d062 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_CL72UT_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program CL72UT_CTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_CL72UT_CTL0r_s {
	uint32_t v[1];
	uint32_t cl72ut_ctl0[1];
	uint32_t _cl72ut_ctl0;
} BCMI_TSCE16_XGXS_CL72UT_CTL0r_t;

#define BCMI_TSCE16_XGXS_CL72UT_CTL0r_CLR(r) (r).cl72ut_ctl0[0] = 0
#define BCMI_TSCE16_XGXS_CL72UT_CTL0r_SET(r,d) (r).cl72ut_ctl0[0] = d
#define BCMI_TSCE16_XGXS_CL72UT_CTL0r_GET(r) (r).cl72ut_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_CL72UT_CTL0r_CL72_SW_REMOTE_RX_READYf_GET(r) ((((r).cl72ut_ctl0[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_CL72UT_CTL0r_CL72_SW_REMOTE_RX_READYf_SET(r,f) (r).cl72ut_ctl0[0]=(((r).cl72ut_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_CL72UT_CTL0r_CL72_SW_FRAME_LOCKf_GET(r) ((((r).cl72ut_ctl0[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_CL72UT_CTL0r_CL72_SW_FRAME_LOCKf_SET(r,f) (r).cl72ut_ctl0[0]=(((r).cl72ut_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_CL72UT_CTL0r_CL72_SW_RX_TRAINEDf_GET(r) (((r).cl72ut_ctl0[0]) & 0x1)
#define BCMI_TSCE16_XGXS_CL72UT_CTL0r_CL72_SW_RX_TRAINEDf_SET(r,f) (r).cl72ut_ctl0[0]=(((r).cl72ut_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL72UT_CTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_CL72UT_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72UT_CTL0r,(_r._cl72ut_ctl0))
#define BCMI_TSCE16_XGXS_WRITE_CL72UT_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UT_CTL0r,(_r._cl72ut_ctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_CL72UT_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UT_CTL0r,(_r._cl72ut_ctl0))
#define BCMI_TSCE16_XGXS_READLN_CL72UT_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72UT_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72ut_ctl0))
#define BCMI_TSCE16_XGXS_WRITELN_CL72UT_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UT_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72ut_ctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_CL72UT_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UT_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72ut_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL72UT_CTL0r BCMI_TSCE16_XGXS_CL72UT_CTL0r
#define CL72UT_CTL0r_SIZE BCMI_TSCE16_XGXS_CL72UT_CTL0r_SIZE
typedef BCMI_TSCE16_XGXS_CL72UT_CTL0r_t CL72UT_CTL0r_t;
#define CL72UT_CTL0r_CLR BCMI_TSCE16_XGXS_CL72UT_CTL0r_CLR
#define CL72UT_CTL0r_SET BCMI_TSCE16_XGXS_CL72UT_CTL0r_SET
#define CL72UT_CTL0r_GET BCMI_TSCE16_XGXS_CL72UT_CTL0r_GET
#define CL72UT_CTL0r_CL72_SW_REMOTE_RX_READYf_GET BCMI_TSCE16_XGXS_CL72UT_CTL0r_CL72_SW_REMOTE_RX_READYf_GET
#define CL72UT_CTL0r_CL72_SW_REMOTE_RX_READYf_SET BCMI_TSCE16_XGXS_CL72UT_CTL0r_CL72_SW_REMOTE_RX_READYf_SET
#define CL72UT_CTL0r_CL72_SW_FRAME_LOCKf_GET BCMI_TSCE16_XGXS_CL72UT_CTL0r_CL72_SW_FRAME_LOCKf_GET
#define CL72UT_CTL0r_CL72_SW_FRAME_LOCKf_SET BCMI_TSCE16_XGXS_CL72UT_CTL0r_CL72_SW_FRAME_LOCKf_SET
#define CL72UT_CTL0r_CL72_SW_RX_TRAINEDf_GET BCMI_TSCE16_XGXS_CL72UT_CTL0r_CL72_SW_RX_TRAINEDf_GET
#define CL72UT_CTL0r_CL72_SW_RX_TRAINEDf_SET BCMI_TSCE16_XGXS_CL72UT_CTL0r_CL72_SW_RX_TRAINEDf_SET
#define READ_CL72UT_CTL0r BCMI_TSCE16_XGXS_READ_CL72UT_CTL0r
#define WRITE_CL72UT_CTL0r BCMI_TSCE16_XGXS_WRITE_CL72UT_CTL0r
#define MODIFY_CL72UT_CTL0r BCMI_TSCE16_XGXS_MODIFY_CL72UT_CTL0r
#define READLN_CL72UT_CTL0r BCMI_TSCE16_XGXS_READLN_CL72UT_CTL0r
#define WRITELN_CL72UT_CTL0r BCMI_TSCE16_XGXS_WRITELN_CL72UT_CTL0r
#define WRITEALL_CL72UT_CTL0r BCMI_TSCE16_XGXS_WRITEALL_CL72UT_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_CL72UT_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  CL72UT_CTL1
 * BLOCKS:   CL72_USER_TX
 * REGADDR:  0xd063
 * DESC:     cl72 Control 1 Register
 * RESETVAL: 0x4 (4)
 * ACCESS:   R/W
 * FIELDS:
 *     CL72_BRK_RING_OSC PRBS 11 Ring Oscillator control1: No oscillating - low power mode0: Osciallate - normal mode
 *     CL72_DIS_MAX_WAIT_TIMER disable max wait timer1 = max wait timer disabled0 = max wait timer enabled
 *     CL72_TX_DP_LN_CLK_EN cl72 Tx Datapath lane clock enable0 - disabled1 - enabled
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_CL72UT_CTL1r (0x0000d063 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_CL72UT_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program CL72UT_CTL1.
 *
 */
typedef union BCMI_TSCE16_XGXS_CL72UT_CTL1r_s {
	uint32_t v[1];
	uint32_t cl72ut_ctl1[1];
	uint32_t _cl72ut_ctl1;
} BCMI_TSCE16_XGXS_CL72UT_CTL1r_t;

#define BCMI_TSCE16_XGXS_CL72UT_CTL1r_CLR(r) (r).cl72ut_ctl1[0] = 0
#define BCMI_TSCE16_XGXS_CL72UT_CTL1r_SET(r,d) (r).cl72ut_ctl1[0] = d
#define BCMI_TSCE16_XGXS_CL72UT_CTL1r_GET(r) (r).cl72ut_ctl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_CL72UT_CTL1r_CL72_TX_DP_LN_CLK_ENf_GET(r) ((((r).cl72ut_ctl1[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_CL72UT_CTL1r_CL72_TX_DP_LN_CLK_ENf_SET(r,f) (r).cl72ut_ctl1[0]=(((r).cl72ut_ctl1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_CL72UT_CTL1r_CL72_DIS_MAX_WAIT_TIMERf_GET(r) ((((r).cl72ut_ctl1[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_CL72UT_CTL1r_CL72_DIS_MAX_WAIT_TIMERf_SET(r,f) (r).cl72ut_ctl1[0]=(((r).cl72ut_ctl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_CL72UT_CTL1r_CL72_BRK_RING_OSCf_GET(r) (((r).cl72ut_ctl1[0]) & 0x1)
#define BCMI_TSCE16_XGXS_CL72UT_CTL1r_CL72_BRK_RING_OSCf_SET(r,f) (r).cl72ut_ctl1[0]=(((r).cl72ut_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL72UT_CTL1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_CL72UT_CTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72UT_CTL1r,(_r._cl72ut_ctl1))
#define BCMI_TSCE16_XGXS_WRITE_CL72UT_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UT_CTL1r,(_r._cl72ut_ctl1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_CL72UT_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UT_CTL1r,(_r._cl72ut_ctl1))
#define BCMI_TSCE16_XGXS_READLN_CL72UT_CTL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72UT_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72ut_ctl1))
#define BCMI_TSCE16_XGXS_WRITELN_CL72UT_CTL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UT_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72ut_ctl1))
#define BCMI_TSCE16_XGXS_WRITEALL_CL72UT_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UT_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72ut_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL72UT_CTL1r BCMI_TSCE16_XGXS_CL72UT_CTL1r
#define CL72UT_CTL1r_SIZE BCMI_TSCE16_XGXS_CL72UT_CTL1r_SIZE
typedef BCMI_TSCE16_XGXS_CL72UT_CTL1r_t CL72UT_CTL1r_t;
#define CL72UT_CTL1r_CLR BCMI_TSCE16_XGXS_CL72UT_CTL1r_CLR
#define CL72UT_CTL1r_SET BCMI_TSCE16_XGXS_CL72UT_CTL1r_SET
#define CL72UT_CTL1r_GET BCMI_TSCE16_XGXS_CL72UT_CTL1r_GET
#define CL72UT_CTL1r_CL72_TX_DP_LN_CLK_ENf_GET BCMI_TSCE16_XGXS_CL72UT_CTL1r_CL72_TX_DP_LN_CLK_ENf_GET
#define CL72UT_CTL1r_CL72_TX_DP_LN_CLK_ENf_SET BCMI_TSCE16_XGXS_CL72UT_CTL1r_CL72_TX_DP_LN_CLK_ENf_SET
#define CL72UT_CTL1r_CL72_DIS_MAX_WAIT_TIMERf_GET BCMI_TSCE16_XGXS_CL72UT_CTL1r_CL72_DIS_MAX_WAIT_TIMERf_GET
#define CL72UT_CTL1r_CL72_DIS_MAX_WAIT_TIMERf_SET BCMI_TSCE16_XGXS_CL72UT_CTL1r_CL72_DIS_MAX_WAIT_TIMERf_SET
#define CL72UT_CTL1r_CL72_BRK_RING_OSCf_GET BCMI_TSCE16_XGXS_CL72UT_CTL1r_CL72_BRK_RING_OSCf_GET
#define CL72UT_CTL1r_CL72_BRK_RING_OSCf_SET BCMI_TSCE16_XGXS_CL72UT_CTL1r_CL72_BRK_RING_OSCf_SET
#define READ_CL72UT_CTL1r BCMI_TSCE16_XGXS_READ_CL72UT_CTL1r
#define WRITE_CL72UT_CTL1r BCMI_TSCE16_XGXS_WRITE_CL72UT_CTL1r
#define MODIFY_CL72UT_CTL1r BCMI_TSCE16_XGXS_MODIFY_CL72UT_CTL1r
#define READLN_CL72UT_CTL1r BCMI_TSCE16_XGXS_READLN_CL72UT_CTL1r
#define WRITELN_CL72UT_CTL1r BCMI_TSCE16_XGXS_WRITELN_CL72UT_CTL1r
#define WRITEALL_CL72UT_CTL1r BCMI_TSCE16_XGXS_WRITEALL_CL72UT_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_CL72UT_CTL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  CL72UT_CTL2
 * BLOCKS:   CL72_USER_TX
 * REGADDR:  0xd064
 * DESC:     cl72 Control 2 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL72_TXFIR_PRE   pre cursor tap coeeficient value.XFI - defaults
 *     CL72_TXFIR_POST  post cursor tap coeeficient value.XFI - defaults
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_CL72UT_CTL2r (0x0000d064 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_CL72UT_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program CL72UT_CTL2.
 *
 */
typedef union BCMI_TSCE16_XGXS_CL72UT_CTL2r_s {
	uint32_t v[1];
	uint32_t cl72ut_ctl2[1];
	uint32_t _cl72ut_ctl2;
} BCMI_TSCE16_XGXS_CL72UT_CTL2r_t;

#define BCMI_TSCE16_XGXS_CL72UT_CTL2r_CLR(r) (r).cl72ut_ctl2[0] = 0
#define BCMI_TSCE16_XGXS_CL72UT_CTL2r_SET(r,d) (r).cl72ut_ctl2[0] = d
#define BCMI_TSCE16_XGXS_CL72UT_CTL2r_GET(r) (r).cl72ut_ctl2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_CL72UT_CTL2r_CL72_TXFIR_POSTf_GET(r) ((((r).cl72ut_ctl2[0]) >> 8) & 0x1f)
#define BCMI_TSCE16_XGXS_CL72UT_CTL2r_CL72_TXFIR_POSTf_SET(r,f) (r).cl72ut_ctl2[0]=(((r).cl72ut_ctl2[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_TSCE16_XGXS_CL72UT_CTL2r_CL72_TXFIR_PREf_GET(r) (((r).cl72ut_ctl2[0]) & 0xf)
#define BCMI_TSCE16_XGXS_CL72UT_CTL2r_CL72_TXFIR_PREf_SET(r,f) (r).cl72ut_ctl2[0]=(((r).cl72ut_ctl2[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access CL72UT_CTL2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_CL72UT_CTL2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72UT_CTL2r,(_r._cl72ut_ctl2))
#define BCMI_TSCE16_XGXS_WRITE_CL72UT_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UT_CTL2r,(_r._cl72ut_ctl2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_CL72UT_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UT_CTL2r,(_r._cl72ut_ctl2))
#define BCMI_TSCE16_XGXS_READLN_CL72UT_CTL2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72UT_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72ut_ctl2))
#define BCMI_TSCE16_XGXS_WRITELN_CL72UT_CTL2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UT_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72ut_ctl2))
#define BCMI_TSCE16_XGXS_WRITEALL_CL72UT_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UT_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72ut_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL72UT_CTL2r BCMI_TSCE16_XGXS_CL72UT_CTL2r
#define CL72UT_CTL2r_SIZE BCMI_TSCE16_XGXS_CL72UT_CTL2r_SIZE
typedef BCMI_TSCE16_XGXS_CL72UT_CTL2r_t CL72UT_CTL2r_t;
#define CL72UT_CTL2r_CLR BCMI_TSCE16_XGXS_CL72UT_CTL2r_CLR
#define CL72UT_CTL2r_SET BCMI_TSCE16_XGXS_CL72UT_CTL2r_SET
#define CL72UT_CTL2r_GET BCMI_TSCE16_XGXS_CL72UT_CTL2r_GET
#define CL72UT_CTL2r_CL72_TXFIR_POSTf_GET BCMI_TSCE16_XGXS_CL72UT_CTL2r_CL72_TXFIR_POSTf_GET
#define CL72UT_CTL2r_CL72_TXFIR_POSTf_SET BCMI_TSCE16_XGXS_CL72UT_CTL2r_CL72_TXFIR_POSTf_SET
#define CL72UT_CTL2r_CL72_TXFIR_PREf_GET BCMI_TSCE16_XGXS_CL72UT_CTL2r_CL72_TXFIR_PREf_GET
#define CL72UT_CTL2r_CL72_TXFIR_PREf_SET BCMI_TSCE16_XGXS_CL72UT_CTL2r_CL72_TXFIR_PREf_SET
#define READ_CL72UT_CTL2r BCMI_TSCE16_XGXS_READ_CL72UT_CTL2r
#define WRITE_CL72UT_CTL2r BCMI_TSCE16_XGXS_WRITE_CL72UT_CTL2r
#define MODIFY_CL72UT_CTL2r BCMI_TSCE16_XGXS_MODIFY_CL72UT_CTL2r
#define READLN_CL72UT_CTL2r BCMI_TSCE16_XGXS_READLN_CL72UT_CTL2r
#define WRITELN_CL72UT_CTL2r BCMI_TSCE16_XGXS_WRITELN_CL72UT_CTL2r
#define WRITEALL_CL72UT_CTL2r BCMI_TSCE16_XGXS_WRITEALL_CL72UT_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_CL72UT_CTL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  CL72UT_CTL3
 * BLOCKS:   CL72_USER_TX
 * REGADDR:  0xd065
 * DESC:     cl72 Control 3 Register
 * RESETVAL: 0x24 (36)
 * ACCESS:   R/W
 * FIELDS:
 *     CL72_TXFIR_MAIN  main cursor tap coeeficient value.XFI - defaults
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_CL72UT_CTL3r (0x0000d065 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_CL72UT_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program CL72UT_CTL3.
 *
 */
typedef union BCMI_TSCE16_XGXS_CL72UT_CTL3r_s {
	uint32_t v[1];
	uint32_t cl72ut_ctl3[1];
	uint32_t _cl72ut_ctl3;
} BCMI_TSCE16_XGXS_CL72UT_CTL3r_t;

#define BCMI_TSCE16_XGXS_CL72UT_CTL3r_CLR(r) (r).cl72ut_ctl3[0] = 0
#define BCMI_TSCE16_XGXS_CL72UT_CTL3r_SET(r,d) (r).cl72ut_ctl3[0] = d
#define BCMI_TSCE16_XGXS_CL72UT_CTL3r_GET(r) (r).cl72ut_ctl3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_CL72UT_CTL3r_CL72_TXFIR_MAINf_GET(r) (((r).cl72ut_ctl3[0]) & 0x3f)
#define BCMI_TSCE16_XGXS_CL72UT_CTL3r_CL72_TXFIR_MAINf_SET(r,f) (r).cl72ut_ctl3[0]=(((r).cl72ut_ctl3[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access CL72UT_CTL3.
 *
 */
#define BCMI_TSCE16_XGXS_READ_CL72UT_CTL3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72UT_CTL3r,(_r._cl72ut_ctl3))
#define BCMI_TSCE16_XGXS_WRITE_CL72UT_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UT_CTL3r,(_r._cl72ut_ctl3)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_CL72UT_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UT_CTL3r,(_r._cl72ut_ctl3))
#define BCMI_TSCE16_XGXS_READLN_CL72UT_CTL3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72UT_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72ut_ctl3))
#define BCMI_TSCE16_XGXS_WRITELN_CL72UT_CTL3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UT_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72ut_ctl3))
#define BCMI_TSCE16_XGXS_WRITEALL_CL72UT_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UT_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72ut_ctl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL72UT_CTL3r BCMI_TSCE16_XGXS_CL72UT_CTL3r
#define CL72UT_CTL3r_SIZE BCMI_TSCE16_XGXS_CL72UT_CTL3r_SIZE
typedef BCMI_TSCE16_XGXS_CL72UT_CTL3r_t CL72UT_CTL3r_t;
#define CL72UT_CTL3r_CLR BCMI_TSCE16_XGXS_CL72UT_CTL3r_CLR
#define CL72UT_CTL3r_SET BCMI_TSCE16_XGXS_CL72UT_CTL3r_SET
#define CL72UT_CTL3r_GET BCMI_TSCE16_XGXS_CL72UT_CTL3r_GET
#define CL72UT_CTL3r_CL72_TXFIR_MAINf_GET BCMI_TSCE16_XGXS_CL72UT_CTL3r_CL72_TXFIR_MAINf_GET
#define CL72UT_CTL3r_CL72_TXFIR_MAINf_SET BCMI_TSCE16_XGXS_CL72UT_CTL3r_CL72_TXFIR_MAINf_SET
#define READ_CL72UT_CTL3r BCMI_TSCE16_XGXS_READ_CL72UT_CTL3r
#define WRITE_CL72UT_CTL3r BCMI_TSCE16_XGXS_WRITE_CL72UT_CTL3r
#define MODIFY_CL72UT_CTL3r BCMI_TSCE16_XGXS_MODIFY_CL72UT_CTL3r
#define READLN_CL72UT_CTL3r BCMI_TSCE16_XGXS_READLN_CL72UT_CTL3r
#define WRITELN_CL72UT_CTL3r BCMI_TSCE16_XGXS_WRITELN_CL72UT_CTL3r
#define WRITEALL_CL72UT_CTL3r BCMI_TSCE16_XGXS_WRITEALL_CL72UT_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_CL72UT_CTL3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  CL72UT_STS0
 * BLOCKS:   CL72_USER_TX
 * REGADDR:  0xd066
 * DESC:     cl72 Status 0 Register
 * RESETVAL: 0x2 (2)
 * ACCESS:   R/O
 * FIELDS:
 *     CL72_LOCAL_RX_READY Set to TRUE (1'b1) by the FSM when the remote transmitand local equalizers have been optimized and normal datatransmission may commence; set to FALSE (1'b0) otherwise.
 *     CL72_TRAINING_FSM_SIGNAL_DETECT 1 - cl72 is in SEND_DATA state0 - cl72 is in training state
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_CL72UT_STS0r (0x0000d066 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_CL72UT_STS0r_SIZE 4

/*
 * This structure should be used to declare and program CL72UT_STS0.
 *
 */
typedef union BCMI_TSCE16_XGXS_CL72UT_STS0r_s {
	uint32_t v[1];
	uint32_t cl72ut_sts0[1];
	uint32_t _cl72ut_sts0;
} BCMI_TSCE16_XGXS_CL72UT_STS0r_t;

#define BCMI_TSCE16_XGXS_CL72UT_STS0r_CLR(r) (r).cl72ut_sts0[0] = 0
#define BCMI_TSCE16_XGXS_CL72UT_STS0r_SET(r,d) (r).cl72ut_sts0[0] = d
#define BCMI_TSCE16_XGXS_CL72UT_STS0r_GET(r) (r).cl72ut_sts0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_CL72UT_STS0r_CL72_TRAINING_FSM_SIGNAL_DETECTf_GET(r) ((((r).cl72ut_sts0[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_CL72UT_STS0r_CL72_TRAINING_FSM_SIGNAL_DETECTf_SET(r,f) (r).cl72ut_sts0[0]=(((r).cl72ut_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_CL72UT_STS0r_CL72_LOCAL_RX_READYf_GET(r) (((r).cl72ut_sts0[0]) & 0x1)
#define BCMI_TSCE16_XGXS_CL72UT_STS0r_CL72_LOCAL_RX_READYf_SET(r,f) (r).cl72ut_sts0[0]=(((r).cl72ut_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL72UT_STS0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_CL72UT_STS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72UT_STS0r,(_r._cl72ut_sts0))
#define BCMI_TSCE16_XGXS_WRITE_CL72UT_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UT_STS0r,(_r._cl72ut_sts0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_CL72UT_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UT_STS0r,(_r._cl72ut_sts0))
#define BCMI_TSCE16_XGXS_READLN_CL72UT_STS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72UT_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72ut_sts0))
#define BCMI_TSCE16_XGXS_WRITELN_CL72UT_STS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UT_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72ut_sts0))
#define BCMI_TSCE16_XGXS_WRITEALL_CL72UT_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UT_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72ut_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL72UT_STS0r BCMI_TSCE16_XGXS_CL72UT_STS0r
#define CL72UT_STS0r_SIZE BCMI_TSCE16_XGXS_CL72UT_STS0r_SIZE
typedef BCMI_TSCE16_XGXS_CL72UT_STS0r_t CL72UT_STS0r_t;
#define CL72UT_STS0r_CLR BCMI_TSCE16_XGXS_CL72UT_STS0r_CLR
#define CL72UT_STS0r_SET BCMI_TSCE16_XGXS_CL72UT_STS0r_SET
#define CL72UT_STS0r_GET BCMI_TSCE16_XGXS_CL72UT_STS0r_GET
#define CL72UT_STS0r_CL72_TRAINING_FSM_SIGNAL_DETECTf_GET BCMI_TSCE16_XGXS_CL72UT_STS0r_CL72_TRAINING_FSM_SIGNAL_DETECTf_GET
#define CL72UT_STS0r_CL72_TRAINING_FSM_SIGNAL_DETECTf_SET BCMI_TSCE16_XGXS_CL72UT_STS0r_CL72_TRAINING_FSM_SIGNAL_DETECTf_SET
#define CL72UT_STS0r_CL72_LOCAL_RX_READYf_GET BCMI_TSCE16_XGXS_CL72UT_STS0r_CL72_LOCAL_RX_READYf_GET
#define CL72UT_STS0r_CL72_LOCAL_RX_READYf_SET BCMI_TSCE16_XGXS_CL72UT_STS0r_CL72_LOCAL_RX_READYf_SET
#define READ_CL72UT_STS0r BCMI_TSCE16_XGXS_READ_CL72UT_STS0r
#define WRITE_CL72UT_STS0r BCMI_TSCE16_XGXS_WRITE_CL72UT_STS0r
#define MODIFY_CL72UT_STS0r BCMI_TSCE16_XGXS_MODIFY_CL72UT_STS0r
#define READLN_CL72UT_STS0r BCMI_TSCE16_XGXS_READLN_CL72UT_STS0r
#define WRITELN_CL72UT_STS0r BCMI_TSCE16_XGXS_WRITELN_CL72UT_STS0r
#define WRITEALL_CL72UT_STS0r BCMI_TSCE16_XGXS_WRITEALL_CL72UT_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_CL72UT_STS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  CL72UT_CTL4
 * BLOCKS:   CL72_USER_TX
 * REGADDR:  0xd067
 * DESC:     cl72 Control 4 Register
 * RESETVAL: 0x3f5 (1013)
 * ACCESS:   R/W
 * FIELDS:
 *     CL72_PRBS_SEED_VAL prbs seed valueThese bits can be used to specify the cl72/cl93 prbs seed valuesPLEASE NOTE: The default value of these register bits for each lane is unique. The IEEE P802.3bj/D2.1defines the following default seed values for each lane:Lane 0 - 11'h3F5Lane 1 - 11'h513Lane 2 - 11'h5A7Lane 3 - 11'h36F
 *     CL72_CL93PRBS_POLY_SEL cl93 mode prbs polynomial selectThese bits are used to select the following prbs polynomials when prbs_mode_sel field is set to 1'b1:2'b00: 1 + x5 + x6 + x10 + x112'b01: 1 + x5 + x6 + x9  + x112'b10: 1 + x4 + x6 + x8  + x112'b11: 1 + x4 + x6 + x7  + x11PLEASE NOTE:The default value of these register bits for each lane is unique. The IEEE P802.3bj/D2.1defines the following default seed values for each lane:Lane 0 - 2'b00Lane 1 - 2'b01Lane 2 - 2'b10Lane 3 - 2'b11
 *     CL72_PRBS_MODE_SEL This field is used to select prbs mode0 - cl72 mode. Uses 1 + x9  + x11 prbs polynomial1 - cl93 mode. The prbs polynomial is specified by the  cl72_cl93prbs_poly_sel field
 *     CL72_PRBS_SEED_SEL These bits used to select the seed for prbs generator during the training sequence:2'b00 - cl72 mode - random seed every frame, cl93 mode - seed specified by the cl72_prbs_seed_val field2'b01 - random seed every frame2'b10 - random seed first frame only and then same seed every frame2'b11 - seed specified by the prbs_seed_val field
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_CL72UT_CTL4r (0x0000d067 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_CL72UT_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program CL72UT_CTL4.
 *
 */
typedef union BCMI_TSCE16_XGXS_CL72UT_CTL4r_s {
	uint32_t v[1];
	uint32_t cl72ut_ctl4[1];
	uint32_t _cl72ut_ctl4;
} BCMI_TSCE16_XGXS_CL72UT_CTL4r_t;

#define BCMI_TSCE16_XGXS_CL72UT_CTL4r_CLR(r) (r).cl72ut_ctl4[0] = 0
#define BCMI_TSCE16_XGXS_CL72UT_CTL4r_SET(r,d) (r).cl72ut_ctl4[0] = d
#define BCMI_TSCE16_XGXS_CL72UT_CTL4r_GET(r) (r).cl72ut_ctl4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_CL72UT_CTL4r_CL72_PRBS_SEED_SELf_GET(r) ((((r).cl72ut_ctl4[0]) >> 14) & 0x3)
#define BCMI_TSCE16_XGXS_CL72UT_CTL4r_CL72_PRBS_SEED_SELf_SET(r,f) (r).cl72ut_ctl4[0]=(((r).cl72ut_ctl4[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCE16_XGXS_CL72UT_CTL4r_CL72_PRBS_MODE_SELf_GET(r) ((((r).cl72ut_ctl4[0]) >> 13) & 0x1)
#define BCMI_TSCE16_XGXS_CL72UT_CTL4r_CL72_PRBS_MODE_SELf_SET(r,f) (r).cl72ut_ctl4[0]=(((r).cl72ut_ctl4[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCE16_XGXS_CL72UT_CTL4r_CL72_CL93PRBS_POLY_SELf_GET(r) ((((r).cl72ut_ctl4[0]) >> 11) & 0x3)
#define BCMI_TSCE16_XGXS_CL72UT_CTL4r_CL72_CL93PRBS_POLY_SELf_SET(r,f) (r).cl72ut_ctl4[0]=(((r).cl72ut_ctl4[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11)) | (3 << (16 + 11))
#define BCMI_TSCE16_XGXS_CL72UT_CTL4r_CL72_PRBS_SEED_VALf_GET(r) (((r).cl72ut_ctl4[0]) & 0x7ff)
#define BCMI_TSCE16_XGXS_CL72UT_CTL4r_CL72_PRBS_SEED_VALf_SET(r,f) (r).cl72ut_ctl4[0]=(((r).cl72ut_ctl4[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff)) | (0x7ff << 16)

/*
 * These macros can be used to access CL72UT_CTL4.
 *
 */
#define BCMI_TSCE16_XGXS_READ_CL72UT_CTL4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72UT_CTL4r,(_r._cl72ut_ctl4))
#define BCMI_TSCE16_XGXS_WRITE_CL72UT_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UT_CTL4r,(_r._cl72ut_ctl4)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_CL72UT_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UT_CTL4r,(_r._cl72ut_ctl4))
#define BCMI_TSCE16_XGXS_READLN_CL72UT_CTL4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CL72UT_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72ut_ctl4))
#define BCMI_TSCE16_XGXS_WRITELN_CL72UT_CTL4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UT_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl72ut_ctl4))
#define BCMI_TSCE16_XGXS_WRITEALL_CL72UT_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CL72UT_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl72ut_ctl4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL72UT_CTL4r BCMI_TSCE16_XGXS_CL72UT_CTL4r
#define CL72UT_CTL4r_SIZE BCMI_TSCE16_XGXS_CL72UT_CTL4r_SIZE
typedef BCMI_TSCE16_XGXS_CL72UT_CTL4r_t CL72UT_CTL4r_t;
#define CL72UT_CTL4r_CLR BCMI_TSCE16_XGXS_CL72UT_CTL4r_CLR
#define CL72UT_CTL4r_SET BCMI_TSCE16_XGXS_CL72UT_CTL4r_SET
#define CL72UT_CTL4r_GET BCMI_TSCE16_XGXS_CL72UT_CTL4r_GET
#define CL72UT_CTL4r_CL72_PRBS_SEED_SELf_GET BCMI_TSCE16_XGXS_CL72UT_CTL4r_CL72_PRBS_SEED_SELf_GET
#define CL72UT_CTL4r_CL72_PRBS_SEED_SELf_SET BCMI_TSCE16_XGXS_CL72UT_CTL4r_CL72_PRBS_SEED_SELf_SET
#define CL72UT_CTL4r_CL72_PRBS_MODE_SELf_GET BCMI_TSCE16_XGXS_CL72UT_CTL4r_CL72_PRBS_MODE_SELf_GET
#define CL72UT_CTL4r_CL72_PRBS_MODE_SELf_SET BCMI_TSCE16_XGXS_CL72UT_CTL4r_CL72_PRBS_MODE_SELf_SET
#define CL72UT_CTL4r_CL72_CL93PRBS_POLY_SELf_GET BCMI_TSCE16_XGXS_CL72UT_CTL4r_CL72_CL93PRBS_POLY_SELf_GET
#define CL72UT_CTL4r_CL72_CL93PRBS_POLY_SELf_SET BCMI_TSCE16_XGXS_CL72UT_CTL4r_CL72_CL93PRBS_POLY_SELf_SET
#define CL72UT_CTL4r_CL72_PRBS_SEED_VALf_GET BCMI_TSCE16_XGXS_CL72UT_CTL4r_CL72_PRBS_SEED_VALf_GET
#define CL72UT_CTL4r_CL72_PRBS_SEED_VALf_SET BCMI_TSCE16_XGXS_CL72UT_CTL4r_CL72_PRBS_SEED_VALf_SET
#define READ_CL72UT_CTL4r BCMI_TSCE16_XGXS_READ_CL72UT_CTL4r
#define WRITE_CL72UT_CTL4r BCMI_TSCE16_XGXS_WRITE_CL72UT_CTL4r
#define MODIFY_CL72UT_CTL4r BCMI_TSCE16_XGXS_MODIFY_CL72UT_CTL4r
#define READLN_CL72UT_CTL4r BCMI_TSCE16_XGXS_READLN_CL72UT_CTL4r
#define WRITELN_CL72UT_CTL4r BCMI_TSCE16_XGXS_WRITELN_CL72UT_CTL4r
#define WRITEALL_CL72UT_CTL4r BCMI_TSCE16_XGXS_WRITEALL_CL72UT_CTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_CL72UT_CTL4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_PI_CTL0
 * BLOCKS:   TX_PI
 * REGADDR:  0xd070
 * DESC:     TX Phase Interpolator Control 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PI_EN         Transmit Phase Interpolator Enable. If 1'b0 will gate off the TX PI clock and also freeze the PI code.
 *     TX_PI_JITTER_FILTER_EN This enables the IIR filter for the phase_sum_val logic from the CDR ( or external CDR in case of Repeater ) .
 *     TX_PI_EXT_CTRL_EN Enable for the phase error (inc/dec) from the remote loopback ( or HS Phase FIFO in case of Repeater )
 *     TX_PI_FREQ_OVERRIDE_EN Enable for the frequency override mode. It should be 1'b1 for fixed frequency and jitter generation modes.
 *     TX_PI_SJ_GEN_EN  Sinusoidal Jitter (SJ) Enable. This has priority over tx_pi_ssc_gen_en if both are enabled simultaneously.
 *     TX_PI_SSC_GEN_EN Spread Spectrum Jitter (SSC) Enable. This has priority over tx_pi_ssc_gen_en if both are enabled simultaneously.
 *     TX_PI_JIT_SSC_FREQ_MODE SSJ Mode Select:1'b1 : 10G SSC mode and 1'b0: 6G SSC mode
 *     TX_PI_RESET_CODE_DBG Debug register.Resets the TX PI code going to AFE. This is just a debug register and is not recommended to be used during normal operation of TX PI.
 *     TX_PI_SECOND_ORDER_LOOP_EN 2nd Order Loop Enable. 1'b1 will enable the 2nd order loop of the IIR filter. 1'b0 will reset the all the flops related to the 2nd order loop.This bit is only valid when tx_pi_jitter_filter_en is set to 1'b1.
 *     TX_PI_FIRST_ORDER_BWSEL_INTEG First order bandwidth control.2'd0 -  80 KHz2'd1 - 160 KHz2'd2 - 321 KHz2'd3 - 642 KHz
 *     TX_PI_SECOND_ORDER_BWSEL_INTEG Second order bandwidth control. Valid values are 0, 1, 2 and 3.
 *     TX_PI_FRC_PHASE_STEP_MUX_SEL Force tx_phase_step mux select to 1'b1.1'b1 - will force the dsm2_rs_3 to be selected by the tx_phase_step mux.1'b0 - back to back inc and dec from the filter will be cancelled out.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_PI_CTL0r (0x0000d070 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_PI_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_CTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_PI_CTL0r_s {
	uint32_t v[1];
	uint32_t tx_pi_ctl0[1];
	uint32_t _tx_pi_ctl0;
} BCMI_TSCE16_XGXS_TX_PI_CTL0r_t;

#define BCMI_TSCE16_XGXS_TX_PI_CTL0r_CLR(r) (r).tx_pi_ctl0[0] = 0
#define BCMI_TSCE16_XGXS_TX_PI_CTL0r_SET(r,d) (r).tx_pi_ctl0[0] = d
#define BCMI_TSCE16_XGXS_TX_PI_CTL0r_GET(r) (r).tx_pi_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_FRC_PHASE_STEP_MUX_SELf_GET(r) ((((r).tx_pi_ctl0[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_FRC_PHASE_STEP_MUX_SELf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_GET(r) ((((r).tx_pi_ctl0[0]) >> 12) & 0x3)
#define BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_GET(r) ((((r).tx_pi_ctl0[0]) >> 10) & 0x3)
#define BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_GET(r) ((((r).tx_pi_ctl0[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_RESET_CODE_DBGf_GET(r) ((((r).tx_pi_ctl0[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_RESET_CODE_DBGf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_GET(r) ((((r).tx_pi_ctl0[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_SSC_GEN_ENf_GET(r) ((((r).tx_pi_ctl0[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_SSC_GEN_ENf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_SJ_GEN_ENf_GET(r) ((((r).tx_pi_ctl0[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_SJ_GEN_ENf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_GET(r) ((((r).tx_pi_ctl0[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_EXT_CTRL_ENf_GET(r) ((((r).tx_pi_ctl0[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_EXT_CTRL_ENf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_JITTER_FILTER_ENf_GET(r) ((((r).tx_pi_ctl0[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_JITTER_FILTER_ENf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_ENf_GET(r) (((r).tx_pi_ctl0[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_ENf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_PI_CTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_PI_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL0r,(_r._tx_pi_ctl0))
#define BCMI_TSCE16_XGXS_WRITE_TX_PI_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL0r,(_r._tx_pi_ctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_PI_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL0r,(_r._tx_pi_ctl0))
#define BCMI_TSCE16_XGXS_READLN_TX_PI_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl0))
#define BCMI_TSCE16_XGXS_WRITELN_TX_PI_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_PI_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_CTL0r BCMI_TSCE16_XGXS_TX_PI_CTL0r
#define TX_PI_CTL0r_SIZE BCMI_TSCE16_XGXS_TX_PI_CTL0r_SIZE
typedef BCMI_TSCE16_XGXS_TX_PI_CTL0r_t TX_PI_CTL0r_t;
#define TX_PI_CTL0r_CLR BCMI_TSCE16_XGXS_TX_PI_CTL0r_CLR
#define TX_PI_CTL0r_SET BCMI_TSCE16_XGXS_TX_PI_CTL0r_SET
#define TX_PI_CTL0r_GET BCMI_TSCE16_XGXS_TX_PI_CTL0r_GET
#define TX_PI_CTL0r_TX_PI_FRC_PHASE_STEP_MUX_SELf_GET BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_FRC_PHASE_STEP_MUX_SELf_GET
#define TX_PI_CTL0r_TX_PI_FRC_PHASE_STEP_MUX_SELf_SET BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_FRC_PHASE_STEP_MUX_SELf_SET
#define TX_PI_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_GET BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_GET
#define TX_PI_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_SET BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_SET
#define TX_PI_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_GET BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_GET
#define TX_PI_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_SET BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_SET
#define TX_PI_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_GET BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_GET
#define TX_PI_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_SET BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_SET
#define TX_PI_CTL0r_TX_PI_RESET_CODE_DBGf_GET BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_RESET_CODE_DBGf_GET
#define TX_PI_CTL0r_TX_PI_RESET_CODE_DBGf_SET BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_RESET_CODE_DBGf_SET
#define TX_PI_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_GET BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_GET
#define TX_PI_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_SET BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_SET
#define TX_PI_CTL0r_TX_PI_SSC_GEN_ENf_GET BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_SSC_GEN_ENf_GET
#define TX_PI_CTL0r_TX_PI_SSC_GEN_ENf_SET BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_SSC_GEN_ENf_SET
#define TX_PI_CTL0r_TX_PI_SJ_GEN_ENf_GET BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_SJ_GEN_ENf_GET
#define TX_PI_CTL0r_TX_PI_SJ_GEN_ENf_SET BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_SJ_GEN_ENf_SET
#define TX_PI_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_GET BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_GET
#define TX_PI_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_SET BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_SET
#define TX_PI_CTL0r_TX_PI_EXT_CTRL_ENf_GET BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_EXT_CTRL_ENf_GET
#define TX_PI_CTL0r_TX_PI_EXT_CTRL_ENf_SET BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_EXT_CTRL_ENf_SET
#define TX_PI_CTL0r_TX_PI_JITTER_FILTER_ENf_GET BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_JITTER_FILTER_ENf_GET
#define TX_PI_CTL0r_TX_PI_JITTER_FILTER_ENf_SET BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_JITTER_FILTER_ENf_SET
#define TX_PI_CTL0r_TX_PI_ENf_GET BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_ENf_GET
#define TX_PI_CTL0r_TX_PI_ENf_SET BCMI_TSCE16_XGXS_TX_PI_CTL0r_TX_PI_ENf_SET
#define READ_TX_PI_CTL0r BCMI_TSCE16_XGXS_READ_TX_PI_CTL0r
#define WRITE_TX_PI_CTL0r BCMI_TSCE16_XGXS_WRITE_TX_PI_CTL0r
#define MODIFY_TX_PI_CTL0r BCMI_TSCE16_XGXS_MODIFY_TX_PI_CTL0r
#define READLN_TX_PI_CTL0r BCMI_TSCE16_XGXS_READLN_TX_PI_CTL0r
#define WRITELN_TX_PI_CTL0r BCMI_TSCE16_XGXS_WRITELN_TX_PI_CTL0r
#define WRITEALL_TX_PI_CTL0r BCMI_TSCE16_XGXS_WRITEALL_TX_PI_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_PI_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_PI_CTL1
 * BLOCKS:   TX_PI
 * REGADDR:  0xd071
 * DESC:     TX Phase Interpolator Control 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PI_FREQ_OVERRIDE_VAL Fixed Frequncy Override Value: Valid values are -8192 to +8192. Register tx_pi_freq_override_en should be 1'b1 to enable the Fixed Frequncy Override mode.+8192 (-8192) value in this register will result into 1 TX PI phase inc (dec) every 20T tclk. This results into (1/64 * 1/20)UI phase inc (or dec) per UI = 781.25(-781.25) ppm. So 1 ppm = 10.486 value.If tx_pi_jit_gen_en is set to 1'b1 then this register provides initilization value for Jitter Gen Integ Reg. Valid values in jitter generation mode are -8192 to +8191
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_PI_CTL1r (0x0000d071 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_PI_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_CTL1.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_PI_CTL1r_s {
	uint32_t v[1];
	uint32_t tx_pi_ctl1[1];
	uint32_t _tx_pi_ctl1;
} BCMI_TSCE16_XGXS_TX_PI_CTL1r_t;

#define BCMI_TSCE16_XGXS_TX_PI_CTL1r_CLR(r) (r).tx_pi_ctl1[0] = 0
#define BCMI_TSCE16_XGXS_TX_PI_CTL1r_SET(r,d) (r).tx_pi_ctl1[0] = d
#define BCMI_TSCE16_XGXS_TX_PI_CTL1r_GET(r) (r).tx_pi_ctl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_PI_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_GET(r) (((r).tx_pi_ctl1[0]) & 0x7fff)
#define BCMI_TSCE16_XGXS_TX_PI_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_SET(r,f) (r).tx_pi_ctl1[0]=(((r).tx_pi_ctl1[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff)) | (0x7fff << 16)

/*
 * These macros can be used to access TX_PI_CTL1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_PI_CTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL1r,(_r._tx_pi_ctl1))
#define BCMI_TSCE16_XGXS_WRITE_TX_PI_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL1r,(_r._tx_pi_ctl1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_PI_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL1r,(_r._tx_pi_ctl1))
#define BCMI_TSCE16_XGXS_READLN_TX_PI_CTL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl1))
#define BCMI_TSCE16_XGXS_WRITELN_TX_PI_CTL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl1))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_PI_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_CTL1r BCMI_TSCE16_XGXS_TX_PI_CTL1r
#define TX_PI_CTL1r_SIZE BCMI_TSCE16_XGXS_TX_PI_CTL1r_SIZE
typedef BCMI_TSCE16_XGXS_TX_PI_CTL1r_t TX_PI_CTL1r_t;
#define TX_PI_CTL1r_CLR BCMI_TSCE16_XGXS_TX_PI_CTL1r_CLR
#define TX_PI_CTL1r_SET BCMI_TSCE16_XGXS_TX_PI_CTL1r_SET
#define TX_PI_CTL1r_GET BCMI_TSCE16_XGXS_TX_PI_CTL1r_GET
#define TX_PI_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_GET BCMI_TSCE16_XGXS_TX_PI_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_GET
#define TX_PI_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_SET BCMI_TSCE16_XGXS_TX_PI_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_SET
#define READ_TX_PI_CTL1r BCMI_TSCE16_XGXS_READ_TX_PI_CTL1r
#define WRITE_TX_PI_CTL1r BCMI_TSCE16_XGXS_WRITE_TX_PI_CTL1r
#define MODIFY_TX_PI_CTL1r BCMI_TSCE16_XGXS_MODIFY_TX_PI_CTL1r
#define READLN_TX_PI_CTL1r BCMI_TSCE16_XGXS_READLN_TX_PI_CTL1r
#define WRITELN_TX_PI_CTL1r BCMI_TSCE16_XGXS_WRITELN_TX_PI_CTL1r
#define WRITEALL_TX_PI_CTL1r BCMI_TSCE16_XGXS_WRITEALL_TX_PI_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_PI_CTL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_PI_CTL2
 * BLOCKS:   TX_PI
 * REGADDR:  0xd072
 * DESC:     TX Phase Interpolator Control 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PI_JIT_FREQ_IDX Jitter Generator Frequency Index. Valid values are from 0 to 63. Each value maps to a table into the spec which then provides various Jitter generator parameters.In SJ  mode: It provides ndiv, Nsj (or Nsj_div_ndiv), sj_gain1 and sj_gain2. Refer Jitter Generator spec for the table details.In SSC mode: It provides Nssc.                                               Refer Jitter Generator spec for the table details.
 *     TX_PI_JIT_AMP    Jitter Generator Amplification Factor. Valid values are 0 to 63.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_PI_CTL2r (0x0000d072 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_PI_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_CTL2.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_PI_CTL2r_s {
	uint32_t v[1];
	uint32_t tx_pi_ctl2[1];
	uint32_t _tx_pi_ctl2;
} BCMI_TSCE16_XGXS_TX_PI_CTL2r_t;

#define BCMI_TSCE16_XGXS_TX_PI_CTL2r_CLR(r) (r).tx_pi_ctl2[0] = 0
#define BCMI_TSCE16_XGXS_TX_PI_CTL2r_SET(r,d) (r).tx_pi_ctl2[0] = d
#define BCMI_TSCE16_XGXS_TX_PI_CTL2r_GET(r) (r).tx_pi_ctl2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_PI_CTL2r_TX_PI_JIT_AMPf_GET(r) ((((r).tx_pi_ctl2[0]) >> 8) & 0x3f)
#define BCMI_TSCE16_XGXS_TX_PI_CTL2r_TX_PI_JIT_AMPf_SET(r,f) (r).tx_pi_ctl2[0]=(((r).tx_pi_ctl2[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_TSCE16_XGXS_TX_PI_CTL2r_TX_PI_JIT_FREQ_IDXf_GET(r) (((r).tx_pi_ctl2[0]) & 0x3f)
#define BCMI_TSCE16_XGXS_TX_PI_CTL2r_TX_PI_JIT_FREQ_IDXf_SET(r,f) (r).tx_pi_ctl2[0]=(((r).tx_pi_ctl2[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access TX_PI_CTL2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_PI_CTL2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL2r,(_r._tx_pi_ctl2))
#define BCMI_TSCE16_XGXS_WRITE_TX_PI_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL2r,(_r._tx_pi_ctl2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_PI_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL2r,(_r._tx_pi_ctl2))
#define BCMI_TSCE16_XGXS_READLN_TX_PI_CTL2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl2))
#define BCMI_TSCE16_XGXS_WRITELN_TX_PI_CTL2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl2))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_PI_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_CTL2r BCMI_TSCE16_XGXS_TX_PI_CTL2r
#define TX_PI_CTL2r_SIZE BCMI_TSCE16_XGXS_TX_PI_CTL2r_SIZE
typedef BCMI_TSCE16_XGXS_TX_PI_CTL2r_t TX_PI_CTL2r_t;
#define TX_PI_CTL2r_CLR BCMI_TSCE16_XGXS_TX_PI_CTL2r_CLR
#define TX_PI_CTL2r_SET BCMI_TSCE16_XGXS_TX_PI_CTL2r_SET
#define TX_PI_CTL2r_GET BCMI_TSCE16_XGXS_TX_PI_CTL2r_GET
#define TX_PI_CTL2r_TX_PI_JIT_AMPf_GET BCMI_TSCE16_XGXS_TX_PI_CTL2r_TX_PI_JIT_AMPf_GET
#define TX_PI_CTL2r_TX_PI_JIT_AMPf_SET BCMI_TSCE16_XGXS_TX_PI_CTL2r_TX_PI_JIT_AMPf_SET
#define TX_PI_CTL2r_TX_PI_JIT_FREQ_IDXf_GET BCMI_TSCE16_XGXS_TX_PI_CTL2r_TX_PI_JIT_FREQ_IDXf_GET
#define TX_PI_CTL2r_TX_PI_JIT_FREQ_IDXf_SET BCMI_TSCE16_XGXS_TX_PI_CTL2r_TX_PI_JIT_FREQ_IDXf_SET
#define READ_TX_PI_CTL2r BCMI_TSCE16_XGXS_READ_TX_PI_CTL2r
#define WRITE_TX_PI_CTL2r BCMI_TSCE16_XGXS_WRITE_TX_PI_CTL2r
#define MODIFY_TX_PI_CTL2r BCMI_TSCE16_XGXS_MODIFY_TX_PI_CTL2r
#define READLN_TX_PI_CTL2r BCMI_TSCE16_XGXS_READLN_TX_PI_CTL2r
#define WRITELN_TX_PI_CTL2r BCMI_TSCE16_XGXS_WRITELN_TX_PI_CTL2r
#define WRITEALL_TX_PI_CTL2r BCMI_TSCE16_XGXS_WRITEALL_TX_PI_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_PI_CTL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_PI_CTL3
 * BLOCKS:   TX_PI
 * REGADDR:  0xd073
 * DESC:     TX Phase Interpolator Control 3
 * RESETVAL: 0x3100 (12544)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PI_PHASE_OVERRIDE Manual Phase Override Mode. When 1'b1 the PI phase can be moved manually using registers. All the filter logic is bypassed during manual mode.
 *     TX_PI_PHASE_STROBE Manual Phase strobe. When set to 1'b1 then it will generate 1 phase step (inc/dec depending on tx_pi_phase_step_dir) or multiple phase steps if tx_pi_phase_step_osr is 1'b1.If tx_pi_phase_override is 1'b0 then manual phase steps will be added with the output of the IIR filter phase steps during the time when there is no phase steps from the IIR filter.Self Clearing Register. Must be polled for 1'b0 before writing it to 1'b1 again for correct Manual Phase Step Shift.
 *     TX_PI_PHASE_STEP_DIR Manual Phase Step direction.1'b0: Increment1'b1: Decrement
 *     TX_PI_PHASE_INVERT 1'b1 : will invert (i.e. swap) the final inc and dec before the PI code shifter logic.
 *     TX_PI_PHASE_STEP_NUM Defines the number of phase steps movement for every manual strobe. Valid values are 1 to 15.
 *     TX_PI_EXT_PHASE_BWSEL_INTEG External Phase bandwidth control. Valid values are 0 to 7.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_PI_CTL3r (0x0000d073 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_PI_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_CTL3.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_PI_CTL3r_s {
	uint32_t v[1];
	uint32_t tx_pi_ctl3[1];
	uint32_t _tx_pi_ctl3;
} BCMI_TSCE16_XGXS_TX_PI_CTL3r_t;

#define BCMI_TSCE16_XGXS_TX_PI_CTL3r_CLR(r) (r).tx_pi_ctl3[0] = 0
#define BCMI_TSCE16_XGXS_TX_PI_CTL3r_SET(r,d) (r).tx_pi_ctl3[0] = d
#define BCMI_TSCE16_XGXS_TX_PI_CTL3r_GET(r) (r).tx_pi_ctl3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_PI_CTL3r_TX_PI_EXT_PHASE_BWSEL_INTEGf_GET(r) ((((r).tx_pi_ctl3[0]) >> 12) & 0x7)
#define BCMI_TSCE16_XGXS_TX_PI_CTL3r_TX_PI_EXT_PHASE_BWSEL_INTEGf_SET(r,f) (r).tx_pi_ctl3[0]=(((r).tx_pi_ctl3[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12)) | (7 << (16 + 12))
#define BCMI_TSCE16_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STEP_NUMf_GET(r) ((((r).tx_pi_ctl3[0]) >> 8) & 0xf)
#define BCMI_TSCE16_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STEP_NUMf_SET(r,f) (r).tx_pi_ctl3[0]=(((r).tx_pi_ctl3[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_TSCE16_XGXS_TX_PI_CTL3r_TX_PI_PHASE_INVERTf_GET(r) ((((r).tx_pi_ctl3[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_TX_PI_CTL3r_TX_PI_PHASE_INVERTf_SET(r,f) (r).tx_pi_ctl3[0]=(((r).tx_pi_ctl3[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STEP_DIRf_GET(r) ((((r).tx_pi_ctl3[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STEP_DIRf_SET(r,f) (r).tx_pi_ctl3[0]=(((r).tx_pi_ctl3[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STROBEf_GET(r) ((((r).tx_pi_ctl3[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STROBEf_SET(r,f) (r).tx_pi_ctl3[0]=(((r).tx_pi_ctl3[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_TX_PI_CTL3r_TX_PI_PHASE_OVERRIDEf_GET(r) (((r).tx_pi_ctl3[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TX_PI_CTL3r_TX_PI_PHASE_OVERRIDEf_SET(r,f) (r).tx_pi_ctl3[0]=(((r).tx_pi_ctl3[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_PI_CTL3.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_PI_CTL3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL3r,(_r._tx_pi_ctl3))
#define BCMI_TSCE16_XGXS_WRITE_TX_PI_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL3r,(_r._tx_pi_ctl3)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_PI_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL3r,(_r._tx_pi_ctl3))
#define BCMI_TSCE16_XGXS_READLN_TX_PI_CTL3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl3))
#define BCMI_TSCE16_XGXS_WRITELN_TX_PI_CTL3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl3))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_PI_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_ctl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_CTL3r BCMI_TSCE16_XGXS_TX_PI_CTL3r
#define TX_PI_CTL3r_SIZE BCMI_TSCE16_XGXS_TX_PI_CTL3r_SIZE
typedef BCMI_TSCE16_XGXS_TX_PI_CTL3r_t TX_PI_CTL3r_t;
#define TX_PI_CTL3r_CLR BCMI_TSCE16_XGXS_TX_PI_CTL3r_CLR
#define TX_PI_CTL3r_SET BCMI_TSCE16_XGXS_TX_PI_CTL3r_SET
#define TX_PI_CTL3r_GET BCMI_TSCE16_XGXS_TX_PI_CTL3r_GET
#define TX_PI_CTL3r_TX_PI_EXT_PHASE_BWSEL_INTEGf_GET BCMI_TSCE16_XGXS_TX_PI_CTL3r_TX_PI_EXT_PHASE_BWSEL_INTEGf_GET
#define TX_PI_CTL3r_TX_PI_EXT_PHASE_BWSEL_INTEGf_SET BCMI_TSCE16_XGXS_TX_PI_CTL3r_TX_PI_EXT_PHASE_BWSEL_INTEGf_SET
#define TX_PI_CTL3r_TX_PI_PHASE_STEP_NUMf_GET BCMI_TSCE16_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STEP_NUMf_GET
#define TX_PI_CTL3r_TX_PI_PHASE_STEP_NUMf_SET BCMI_TSCE16_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STEP_NUMf_SET
#define TX_PI_CTL3r_TX_PI_PHASE_INVERTf_GET BCMI_TSCE16_XGXS_TX_PI_CTL3r_TX_PI_PHASE_INVERTf_GET
#define TX_PI_CTL3r_TX_PI_PHASE_INVERTf_SET BCMI_TSCE16_XGXS_TX_PI_CTL3r_TX_PI_PHASE_INVERTf_SET
#define TX_PI_CTL3r_TX_PI_PHASE_STEP_DIRf_GET BCMI_TSCE16_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STEP_DIRf_GET
#define TX_PI_CTL3r_TX_PI_PHASE_STEP_DIRf_SET BCMI_TSCE16_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STEP_DIRf_SET
#define TX_PI_CTL3r_TX_PI_PHASE_STROBEf_GET BCMI_TSCE16_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STROBEf_GET
#define TX_PI_CTL3r_TX_PI_PHASE_STROBEf_SET BCMI_TSCE16_XGXS_TX_PI_CTL3r_TX_PI_PHASE_STROBEf_SET
#define TX_PI_CTL3r_TX_PI_PHASE_OVERRIDEf_GET BCMI_TSCE16_XGXS_TX_PI_CTL3r_TX_PI_PHASE_OVERRIDEf_GET
#define TX_PI_CTL3r_TX_PI_PHASE_OVERRIDEf_SET BCMI_TSCE16_XGXS_TX_PI_CTL3r_TX_PI_PHASE_OVERRIDEf_SET
#define READ_TX_PI_CTL3r BCMI_TSCE16_XGXS_READ_TX_PI_CTL3r
#define WRITE_TX_PI_CTL3r BCMI_TSCE16_XGXS_WRITE_TX_PI_CTL3r
#define MODIFY_TX_PI_CTL3r BCMI_TSCE16_XGXS_MODIFY_TX_PI_CTL3r
#define READLN_TX_PI_CTL3r BCMI_TSCE16_XGXS_READLN_TX_PI_CTL3r
#define WRITELN_TX_PI_CTL3r BCMI_TSCE16_XGXS_WRITELN_TX_PI_CTL3r
#define WRITEALL_TX_PI_CTL3r BCMI_TSCE16_XGXS_WRITEALL_TX_PI_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_PI_CTL3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_PI_CTL4
 * BLOCKS:   TX_PI
 * REGADDR:  0xd074
 * DESC:     TX Phase Interpolator Control 4
 * RESETVAL: 0x4 (4)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PI_FRZ_FRC    IIR filter freeze control by force. 1'b1 will force the freeze value indicated by tx_pi_frz_frc_val otherwise Normal IIR operation.
 *     TX_PI_FRZ_FRC_VAL Force value for the IIR filter freeze. 1'b1 is freeze, 1'b0 is normal IIR operation.
 *     TX_PI_FRZ_MODE   Freeze Mode. 1'b1 will freeze the integ2 reg so that during the freeze, TX PI will generate the phase steps based on the integ2 freeze value.1'b1 will freeze the integ2 reg so that during the freeze, TX PI will generate the phase steps based on the integ2 freeze value.1'b0 will force the phase_sum_val input from the CDR loop timing path of the IIR filter to 0s which will result in slowly bringing the TX clock to 0 ppm from PLL/VCO clock.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_PI_CTL4r (0x0000d074 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_PI_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_CTL4.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_PI_CTL4r_s {
	uint32_t v[1];
	uint32_t tx_pi_ctl4[1];
	uint32_t _tx_pi_ctl4;
} BCMI_TSCE16_XGXS_TX_PI_CTL4r_t;

#define BCMI_TSCE16_XGXS_TX_PI_CTL4r_CLR(r) (r).tx_pi_ctl4[0] = 0
#define BCMI_TSCE16_XGXS_TX_PI_CTL4r_SET(r,d) (r).tx_pi_ctl4[0] = d
#define BCMI_TSCE16_XGXS_TX_PI_CTL4r_GET(r) (r).tx_pi_ctl4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_PI_CTL4r_TX_PI_FRZ_MODEf_GET(r) ((((r).tx_pi_ctl4[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_TX_PI_CTL4r_TX_PI_FRZ_MODEf_SET(r,f) (r).tx_pi_ctl4[0]=(((r).tx_pi_ctl4[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_TX_PI_CTL4r_TX_PI_FRZ_FRC_VALf_GET(r) ((((r).tx_pi_ctl4[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_TX_PI_CTL4r_TX_PI_FRZ_FRC_VALf_SET(r,f) (r).tx_pi_ctl4[0]=(((r).tx_pi_ctl4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_TX_PI_CTL4r_TX_PI_FRZ_FRCf_GET(r) (((r).tx_pi_ctl4[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TX_PI_CTL4r_TX_PI_FRZ_FRCf_SET(r,f) (r).tx_pi_ctl4[0]=(((r).tx_pi_ctl4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_PI_CTL4.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_PI_CTL4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL4r,(_r._tx_pi_ctl4))
#define BCMI_TSCE16_XGXS_WRITE_TX_PI_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL4r,(_r._tx_pi_ctl4)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_PI_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL4r,(_r._tx_pi_ctl4))
#define BCMI_TSCE16_XGXS_READLN_TX_PI_CTL4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl4))
#define BCMI_TSCE16_XGXS_WRITELN_TX_PI_CTL4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl4))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_PI_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_ctl4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_CTL4r BCMI_TSCE16_XGXS_TX_PI_CTL4r
#define TX_PI_CTL4r_SIZE BCMI_TSCE16_XGXS_TX_PI_CTL4r_SIZE
typedef BCMI_TSCE16_XGXS_TX_PI_CTL4r_t TX_PI_CTL4r_t;
#define TX_PI_CTL4r_CLR BCMI_TSCE16_XGXS_TX_PI_CTL4r_CLR
#define TX_PI_CTL4r_SET BCMI_TSCE16_XGXS_TX_PI_CTL4r_SET
#define TX_PI_CTL4r_GET BCMI_TSCE16_XGXS_TX_PI_CTL4r_GET
#define TX_PI_CTL4r_TX_PI_FRZ_MODEf_GET BCMI_TSCE16_XGXS_TX_PI_CTL4r_TX_PI_FRZ_MODEf_GET
#define TX_PI_CTL4r_TX_PI_FRZ_MODEf_SET BCMI_TSCE16_XGXS_TX_PI_CTL4r_TX_PI_FRZ_MODEf_SET
#define TX_PI_CTL4r_TX_PI_FRZ_FRC_VALf_GET BCMI_TSCE16_XGXS_TX_PI_CTL4r_TX_PI_FRZ_FRC_VALf_GET
#define TX_PI_CTL4r_TX_PI_FRZ_FRC_VALf_SET BCMI_TSCE16_XGXS_TX_PI_CTL4r_TX_PI_FRZ_FRC_VALf_SET
#define TX_PI_CTL4r_TX_PI_FRZ_FRCf_GET BCMI_TSCE16_XGXS_TX_PI_CTL4r_TX_PI_FRZ_FRCf_GET
#define TX_PI_CTL4r_TX_PI_FRZ_FRCf_SET BCMI_TSCE16_XGXS_TX_PI_CTL4r_TX_PI_FRZ_FRCf_SET
#define READ_TX_PI_CTL4r BCMI_TSCE16_XGXS_READ_TX_PI_CTL4r
#define WRITE_TX_PI_CTL4r BCMI_TSCE16_XGXS_WRITE_TX_PI_CTL4r
#define MODIFY_TX_PI_CTL4r BCMI_TSCE16_XGXS_MODIFY_TX_PI_CTL4r
#define READLN_TX_PI_CTL4r BCMI_TSCE16_XGXS_READLN_TX_PI_CTL4r
#define WRITELN_TX_PI_CTL4r BCMI_TSCE16_XGXS_WRITELN_TX_PI_CTL4r
#define WRITEALL_TX_PI_CTL4r BCMI_TSCE16_XGXS_WRITEALL_TX_PI_CTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_PI_CTL4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_PI_CTL5
 * BLOCKS:   TX_PI
 * REGADDR:  0xd075
 * DESC:     TX Phase Interpolator Control 5
 * RESETVAL: 0x4 (4)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PI_HS_FIFO_PHSERR_INVERT 1'b1: Inverts the hs_fifo_phserr[4:0] to invert the meaning of inc/dec from hs_fifo_phserr[4:0]. When this bit is 1'b0, 1'b1 is increment and 1'b0 is decrement.
 *     TX_PI_REPEATER_MODE_EN Selects the source of the Loop Timing CDR and Phase Detector inc/dec information.1'b1: Select external CDR and hs_fifo_phserr[4:0] from the high speed Phase FIFO PD inside AFE for ultra-low latency path.1'b0: selects the internal CDR and inc/dec from the Remote Loopback Phase Detector.
 *     TX_PI_EXT_PD_SEL Selects the source of the Phase Detector inc/dec information.1'b1: Select external PD path irrespective of rg_tx_pi_repeater_mode_en1'b0: Select PD path based on rg_tx_pi_repeater_mode_en
 *     AFE_TX_FIFO_RESETB 1'b0: will assert the reset pin tx_fifo_resetb to 1'b0.1'b1: Once this bit is written to 1'b1 then phase error (bit 4) from FIFO is looked for 2 transitions and then reset is de-asserted to the Phase FIFO.
 *     AFE_TX_FIFO_RESETB_FRC_ON 1'b0: Normal mode where reset pin tx_fifo_resetb is controlled as per the description of the register afe_tx_fifo_resetb.1'b1: force the reset pin tx_fifo_resetb to value indicated in the register afe_tx_fifo_resetb.
 *     TX_PI_PD_BYPASS_FLT 1'b1 will enable filter bypass for inc/dec indication from all sources to get a quicker phase locking time.
 *     TX_PI_PD_BYPASS_VCO 1'b1 will enable filter and vco bypass for inc/dec indication from all sources to get a quicker phase locking time.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_PI_CTL5r (0x0000d075 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_PI_CTL5r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_CTL5.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_PI_CTL5r_s {
	uint32_t v[1];
	uint32_t tx_pi_ctl5[1];
	uint32_t _tx_pi_ctl5;
} BCMI_TSCE16_XGXS_TX_PI_CTL5r_t;

#define BCMI_TSCE16_XGXS_TX_PI_CTL5r_CLR(r) (r).tx_pi_ctl5[0] = 0
#define BCMI_TSCE16_XGXS_TX_PI_CTL5r_SET(r,d) (r).tx_pi_ctl5[0] = d
#define BCMI_TSCE16_XGXS_TX_PI_CTL5r_GET(r) (r).tx_pi_ctl5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_PI_CTL5r_TX_PI_PD_BYPASS_VCOf_GET(r) ((((r).tx_pi_ctl5[0]) >> 11) & 0x1)
#define BCMI_TSCE16_XGXS_TX_PI_CTL5r_TX_PI_PD_BYPASS_VCOf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCE16_XGXS_TX_PI_CTL5r_TX_PI_PD_BYPASS_FLTf_GET(r) ((((r).tx_pi_ctl5[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_TX_PI_CTL5r_TX_PI_PD_BYPASS_FLTf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_TX_PI_CTL5r_AFE_TX_FIFO_RESETB_FRC_ONf_GET(r) ((((r).tx_pi_ctl5[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_TX_PI_CTL5r_AFE_TX_FIFO_RESETB_FRC_ONf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_TX_PI_CTL5r_AFE_TX_FIFO_RESETBf_GET(r) ((((r).tx_pi_ctl5[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_TX_PI_CTL5r_AFE_TX_FIFO_RESETBf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_TX_PI_CTL5r_TX_PI_EXT_PD_SELf_GET(r) ((((r).tx_pi_ctl5[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_TX_PI_CTL5r_TX_PI_EXT_PD_SELf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_TX_PI_CTL5r_TX_PI_REPEATER_MODE_ENf_GET(r) ((((r).tx_pi_ctl5[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_TX_PI_CTL5r_TX_PI_REPEATER_MODE_ENf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_INVERTf_GET(r) ((((r).tx_pi_ctl5[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_INVERTf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access TX_PI_CTL5.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_PI_CTL5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL5r,(_r._tx_pi_ctl5))
#define BCMI_TSCE16_XGXS_WRITE_TX_PI_CTL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL5r,(_r._tx_pi_ctl5)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_PI_CTL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL5r,(_r._tx_pi_ctl5))
#define BCMI_TSCE16_XGXS_READLN_TX_PI_CTL5r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl5))
#define BCMI_TSCE16_XGXS_WRITELN_TX_PI_CTL5r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl5))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_PI_CTL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_ctl5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_CTL5r BCMI_TSCE16_XGXS_TX_PI_CTL5r
#define TX_PI_CTL5r_SIZE BCMI_TSCE16_XGXS_TX_PI_CTL5r_SIZE
typedef BCMI_TSCE16_XGXS_TX_PI_CTL5r_t TX_PI_CTL5r_t;
#define TX_PI_CTL5r_CLR BCMI_TSCE16_XGXS_TX_PI_CTL5r_CLR
#define TX_PI_CTL5r_SET BCMI_TSCE16_XGXS_TX_PI_CTL5r_SET
#define TX_PI_CTL5r_GET BCMI_TSCE16_XGXS_TX_PI_CTL5r_GET
#define TX_PI_CTL5r_TX_PI_PD_BYPASS_VCOf_GET BCMI_TSCE16_XGXS_TX_PI_CTL5r_TX_PI_PD_BYPASS_VCOf_GET
#define TX_PI_CTL5r_TX_PI_PD_BYPASS_VCOf_SET BCMI_TSCE16_XGXS_TX_PI_CTL5r_TX_PI_PD_BYPASS_VCOf_SET
#define TX_PI_CTL5r_TX_PI_PD_BYPASS_FLTf_GET BCMI_TSCE16_XGXS_TX_PI_CTL5r_TX_PI_PD_BYPASS_FLTf_GET
#define TX_PI_CTL5r_TX_PI_PD_BYPASS_FLTf_SET BCMI_TSCE16_XGXS_TX_PI_CTL5r_TX_PI_PD_BYPASS_FLTf_SET
#define TX_PI_CTL5r_AFE_TX_FIFO_RESETB_FRC_ONf_GET BCMI_TSCE16_XGXS_TX_PI_CTL5r_AFE_TX_FIFO_RESETB_FRC_ONf_GET
#define TX_PI_CTL5r_AFE_TX_FIFO_RESETB_FRC_ONf_SET BCMI_TSCE16_XGXS_TX_PI_CTL5r_AFE_TX_FIFO_RESETB_FRC_ONf_SET
#define TX_PI_CTL5r_AFE_TX_FIFO_RESETBf_GET BCMI_TSCE16_XGXS_TX_PI_CTL5r_AFE_TX_FIFO_RESETBf_GET
#define TX_PI_CTL5r_AFE_TX_FIFO_RESETBf_SET BCMI_TSCE16_XGXS_TX_PI_CTL5r_AFE_TX_FIFO_RESETBf_SET
#define TX_PI_CTL5r_TX_PI_EXT_PD_SELf_GET BCMI_TSCE16_XGXS_TX_PI_CTL5r_TX_PI_EXT_PD_SELf_GET
#define TX_PI_CTL5r_TX_PI_EXT_PD_SELf_SET BCMI_TSCE16_XGXS_TX_PI_CTL5r_TX_PI_EXT_PD_SELf_SET
#define TX_PI_CTL5r_TX_PI_REPEATER_MODE_ENf_GET BCMI_TSCE16_XGXS_TX_PI_CTL5r_TX_PI_REPEATER_MODE_ENf_GET
#define TX_PI_CTL5r_TX_PI_REPEATER_MODE_ENf_SET BCMI_TSCE16_XGXS_TX_PI_CTL5r_TX_PI_REPEATER_MODE_ENf_SET
#define TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_INVERTf_GET BCMI_TSCE16_XGXS_TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_INVERTf_GET
#define TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_INVERTf_SET BCMI_TSCE16_XGXS_TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_INVERTf_SET
#define READ_TX_PI_CTL5r BCMI_TSCE16_XGXS_READ_TX_PI_CTL5r
#define WRITE_TX_PI_CTL5r BCMI_TSCE16_XGXS_WRITE_TX_PI_CTL5r
#define MODIFY_TX_PI_CTL5r BCMI_TSCE16_XGXS_MODIFY_TX_PI_CTL5r
#define READLN_TX_PI_CTL5r BCMI_TSCE16_XGXS_READLN_TX_PI_CTL5r
#define WRITELN_TX_PI_CTL5r BCMI_TSCE16_XGXS_WRITELN_TX_PI_CTL5r
#define WRITEALL_TX_PI_CTL5r BCMI_TSCE16_XGXS_WRITEALL_TX_PI_CTL5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_PI_CTL5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_PI_STS0
 * BLOCKS:   TX_PI
 * REGADDR:  0xd078
 * DESC:     TX Phase Interpolator Status 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_PI_PHASE_CNTR TX PI Phase Counter. Signed Value.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_PI_STS0r (0x0000d078 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_PI_STS0r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_STS0.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_PI_STS0r_s {
	uint32_t v[1];
	uint32_t tx_pi_sts0[1];
	uint32_t _tx_pi_sts0;
} BCMI_TSCE16_XGXS_TX_PI_STS0r_t;

#define BCMI_TSCE16_XGXS_TX_PI_STS0r_CLR(r) (r).tx_pi_sts0[0] = 0
#define BCMI_TSCE16_XGXS_TX_PI_STS0r_SET(r,d) (r).tx_pi_sts0[0] = d
#define BCMI_TSCE16_XGXS_TX_PI_STS0r_GET(r) (r).tx_pi_sts0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_PI_STS0r_TX_PI_PHASE_CNTRf_GET(r) (((r).tx_pi_sts0[0]) & 0x7f)
#define BCMI_TSCE16_XGXS_TX_PI_STS0r_TX_PI_PHASE_CNTRf_SET(r,f) (r).tx_pi_sts0[0]=(((r).tx_pi_sts0[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access TX_PI_STS0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_PI_STS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_PI_STS0r,(_r._tx_pi_sts0))
#define BCMI_TSCE16_XGXS_WRITE_TX_PI_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_STS0r,(_r._tx_pi_sts0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_PI_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_STS0r,(_r._tx_pi_sts0))
#define BCMI_TSCE16_XGXS_READLN_TX_PI_STS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_PI_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts0))
#define BCMI_TSCE16_XGXS_WRITELN_TX_PI_STS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts0))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_PI_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_STS0r BCMI_TSCE16_XGXS_TX_PI_STS0r
#define TX_PI_STS0r_SIZE BCMI_TSCE16_XGXS_TX_PI_STS0r_SIZE
typedef BCMI_TSCE16_XGXS_TX_PI_STS0r_t TX_PI_STS0r_t;
#define TX_PI_STS0r_CLR BCMI_TSCE16_XGXS_TX_PI_STS0r_CLR
#define TX_PI_STS0r_SET BCMI_TSCE16_XGXS_TX_PI_STS0r_SET
#define TX_PI_STS0r_GET BCMI_TSCE16_XGXS_TX_PI_STS0r_GET
#define TX_PI_STS0r_TX_PI_PHASE_CNTRf_GET BCMI_TSCE16_XGXS_TX_PI_STS0r_TX_PI_PHASE_CNTRf_GET
#define TX_PI_STS0r_TX_PI_PHASE_CNTRf_SET BCMI_TSCE16_XGXS_TX_PI_STS0r_TX_PI_PHASE_CNTRf_SET
#define READ_TX_PI_STS0r BCMI_TSCE16_XGXS_READ_TX_PI_STS0r
#define WRITE_TX_PI_STS0r BCMI_TSCE16_XGXS_WRITE_TX_PI_STS0r
#define MODIFY_TX_PI_STS0r BCMI_TSCE16_XGXS_MODIFY_TX_PI_STS0r
#define READLN_TX_PI_STS0r BCMI_TSCE16_XGXS_READLN_TX_PI_STS0r
#define WRITELN_TX_PI_STS0r BCMI_TSCE16_XGXS_WRITELN_TX_PI_STS0r
#define WRITEALL_TX_PI_STS0r BCMI_TSCE16_XGXS_WRITEALL_TX_PI_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_PI_STS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_PI_STS1
 * BLOCKS:   TX_PI
 * REGADDR:  0xd079
 * DESC:     TX Phase Interpolator Status 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_PI_INTEG1_REG TX PI integ1 register. Signed Value.This field is meant for internal debug only.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_PI_STS1r (0x0000d079 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_PI_STS1r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_STS1.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_PI_STS1r_s {
	uint32_t v[1];
	uint32_t tx_pi_sts1[1];
	uint32_t _tx_pi_sts1;
} BCMI_TSCE16_XGXS_TX_PI_STS1r_t;

#define BCMI_TSCE16_XGXS_TX_PI_STS1r_CLR(r) (r).tx_pi_sts1[0] = 0
#define BCMI_TSCE16_XGXS_TX_PI_STS1r_SET(r,d) (r).tx_pi_sts1[0] = d
#define BCMI_TSCE16_XGXS_TX_PI_STS1r_GET(r) (r).tx_pi_sts1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_PI_STS1r_TX_PI_INTEG1_REGf_GET(r) (((r).tx_pi_sts1[0]) & 0x3fff)
#define BCMI_TSCE16_XGXS_TX_PI_STS1r_TX_PI_INTEG1_REGf_SET(r,f) (r).tx_pi_sts1[0]=(((r).tx_pi_sts1[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access TX_PI_STS1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_PI_STS1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_PI_STS1r,(_r._tx_pi_sts1))
#define BCMI_TSCE16_XGXS_WRITE_TX_PI_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_STS1r,(_r._tx_pi_sts1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_PI_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_STS1r,(_r._tx_pi_sts1))
#define BCMI_TSCE16_XGXS_READLN_TX_PI_STS1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_PI_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts1))
#define BCMI_TSCE16_XGXS_WRITELN_TX_PI_STS1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts1))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_PI_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_sts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_STS1r BCMI_TSCE16_XGXS_TX_PI_STS1r
#define TX_PI_STS1r_SIZE BCMI_TSCE16_XGXS_TX_PI_STS1r_SIZE
typedef BCMI_TSCE16_XGXS_TX_PI_STS1r_t TX_PI_STS1r_t;
#define TX_PI_STS1r_CLR BCMI_TSCE16_XGXS_TX_PI_STS1r_CLR
#define TX_PI_STS1r_SET BCMI_TSCE16_XGXS_TX_PI_STS1r_SET
#define TX_PI_STS1r_GET BCMI_TSCE16_XGXS_TX_PI_STS1r_GET
#define TX_PI_STS1r_TX_PI_INTEG1_REGf_GET BCMI_TSCE16_XGXS_TX_PI_STS1r_TX_PI_INTEG1_REGf_GET
#define TX_PI_STS1r_TX_PI_INTEG1_REGf_SET BCMI_TSCE16_XGXS_TX_PI_STS1r_TX_PI_INTEG1_REGf_SET
#define READ_TX_PI_STS1r BCMI_TSCE16_XGXS_READ_TX_PI_STS1r
#define WRITE_TX_PI_STS1r BCMI_TSCE16_XGXS_WRITE_TX_PI_STS1r
#define MODIFY_TX_PI_STS1r BCMI_TSCE16_XGXS_MODIFY_TX_PI_STS1r
#define READLN_TX_PI_STS1r BCMI_TSCE16_XGXS_READLN_TX_PI_STS1r
#define WRITELN_TX_PI_STS1r BCMI_TSCE16_XGXS_WRITELN_TX_PI_STS1r
#define WRITEALL_TX_PI_STS1r BCMI_TSCE16_XGXS_WRITEALL_TX_PI_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_PI_STS1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_PI_STS2
 * BLOCKS:   TX_PI
 * REGADDR:  0xd07a
 * DESC:     TX Phase Interpolator Status 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_PI_INTEG2_REG TX PI integ2 register. Signed Value. Once settled, it can provide the information of the ppm on the TX clock w.r.t. PLL/VCO clock.+8192 (-8192) is equal to +781.25 (-781.25) ppm which means tclk is slower (faster) w.r.t. PLL/VCO clock.Divide this register value by 10.485 to get the tclk ppm.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_PI_STS2r (0x0000d07a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_PI_STS2r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_STS2.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_PI_STS2r_s {
	uint32_t v[1];
	uint32_t tx_pi_sts2[1];
	uint32_t _tx_pi_sts2;
} BCMI_TSCE16_XGXS_TX_PI_STS2r_t;

#define BCMI_TSCE16_XGXS_TX_PI_STS2r_CLR(r) (r).tx_pi_sts2[0] = 0
#define BCMI_TSCE16_XGXS_TX_PI_STS2r_SET(r,d) (r).tx_pi_sts2[0] = d
#define BCMI_TSCE16_XGXS_TX_PI_STS2r_GET(r) (r).tx_pi_sts2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_PI_STS2r_TX_PI_INTEG2_REGf_GET(r) (((r).tx_pi_sts2[0]) & 0x7fff)
#define BCMI_TSCE16_XGXS_TX_PI_STS2r_TX_PI_INTEG2_REGf_SET(r,f) (r).tx_pi_sts2[0]=(((r).tx_pi_sts2[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff)) | (0x7fff << 16)

/*
 * These macros can be used to access TX_PI_STS2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_PI_STS2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_PI_STS2r,(_r._tx_pi_sts2))
#define BCMI_TSCE16_XGXS_WRITE_TX_PI_STS2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_STS2r,(_r._tx_pi_sts2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_PI_STS2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_STS2r,(_r._tx_pi_sts2))
#define BCMI_TSCE16_XGXS_READLN_TX_PI_STS2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_PI_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts2))
#define BCMI_TSCE16_XGXS_WRITELN_TX_PI_STS2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts2))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_PI_STS2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_STS2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_sts2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_STS2r BCMI_TSCE16_XGXS_TX_PI_STS2r
#define TX_PI_STS2r_SIZE BCMI_TSCE16_XGXS_TX_PI_STS2r_SIZE
typedef BCMI_TSCE16_XGXS_TX_PI_STS2r_t TX_PI_STS2r_t;
#define TX_PI_STS2r_CLR BCMI_TSCE16_XGXS_TX_PI_STS2r_CLR
#define TX_PI_STS2r_SET BCMI_TSCE16_XGXS_TX_PI_STS2r_SET
#define TX_PI_STS2r_GET BCMI_TSCE16_XGXS_TX_PI_STS2r_GET
#define TX_PI_STS2r_TX_PI_INTEG2_REGf_GET BCMI_TSCE16_XGXS_TX_PI_STS2r_TX_PI_INTEG2_REGf_GET
#define TX_PI_STS2r_TX_PI_INTEG2_REGf_SET BCMI_TSCE16_XGXS_TX_PI_STS2r_TX_PI_INTEG2_REGf_SET
#define READ_TX_PI_STS2r BCMI_TSCE16_XGXS_READ_TX_PI_STS2r
#define WRITE_TX_PI_STS2r BCMI_TSCE16_XGXS_WRITE_TX_PI_STS2r
#define MODIFY_TX_PI_STS2r BCMI_TSCE16_XGXS_MODIFY_TX_PI_STS2r
#define READLN_TX_PI_STS2r BCMI_TSCE16_XGXS_READLN_TX_PI_STS2r
#define WRITELN_TX_PI_STS2r BCMI_TSCE16_XGXS_WRITELN_TX_PI_STS2r
#define WRITEALL_TX_PI_STS2r BCMI_TSCE16_XGXS_WRITEALL_TX_PI_STS2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_PI_STS2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_PI_STS3
 * BLOCKS:   TX_PI
 * REGADDR:  0xd07b
 * DESC:     TX Phase Interpolator Status 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_PI_PHASE_ERR  TX PI Phase Error. Signed Value. Valid values are -8 to +8.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_PI_STS3r (0x0000d07b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_PI_STS3r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_STS3.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_PI_STS3r_s {
	uint32_t v[1];
	uint32_t tx_pi_sts3[1];
	uint32_t _tx_pi_sts3;
} BCMI_TSCE16_XGXS_TX_PI_STS3r_t;

#define BCMI_TSCE16_XGXS_TX_PI_STS3r_CLR(r) (r).tx_pi_sts3[0] = 0
#define BCMI_TSCE16_XGXS_TX_PI_STS3r_SET(r,d) (r).tx_pi_sts3[0] = d
#define BCMI_TSCE16_XGXS_TX_PI_STS3r_GET(r) (r).tx_pi_sts3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_PI_STS3r_TX_PI_PHASE_ERRf_GET(r) (((r).tx_pi_sts3[0]) & 0x3f)
#define BCMI_TSCE16_XGXS_TX_PI_STS3r_TX_PI_PHASE_ERRf_SET(r,f) (r).tx_pi_sts3[0]=(((r).tx_pi_sts3[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access TX_PI_STS3.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_PI_STS3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_PI_STS3r,(_r._tx_pi_sts3))
#define BCMI_TSCE16_XGXS_WRITE_TX_PI_STS3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_STS3r,(_r._tx_pi_sts3)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_PI_STS3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_STS3r,(_r._tx_pi_sts3))
#define BCMI_TSCE16_XGXS_READLN_TX_PI_STS3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_PI_STS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts3))
#define BCMI_TSCE16_XGXS_WRITELN_TX_PI_STS3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_STS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts3))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_PI_STS3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_STS3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_sts3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_STS3r BCMI_TSCE16_XGXS_TX_PI_STS3r
#define TX_PI_STS3r_SIZE BCMI_TSCE16_XGXS_TX_PI_STS3r_SIZE
typedef BCMI_TSCE16_XGXS_TX_PI_STS3r_t TX_PI_STS3r_t;
#define TX_PI_STS3r_CLR BCMI_TSCE16_XGXS_TX_PI_STS3r_CLR
#define TX_PI_STS3r_SET BCMI_TSCE16_XGXS_TX_PI_STS3r_SET
#define TX_PI_STS3r_GET BCMI_TSCE16_XGXS_TX_PI_STS3r_GET
#define TX_PI_STS3r_TX_PI_PHASE_ERRf_GET BCMI_TSCE16_XGXS_TX_PI_STS3r_TX_PI_PHASE_ERRf_GET
#define TX_PI_STS3r_TX_PI_PHASE_ERRf_SET BCMI_TSCE16_XGXS_TX_PI_STS3r_TX_PI_PHASE_ERRf_SET
#define READ_TX_PI_STS3r BCMI_TSCE16_XGXS_READ_TX_PI_STS3r
#define WRITE_TX_PI_STS3r BCMI_TSCE16_XGXS_WRITE_TX_PI_STS3r
#define MODIFY_TX_PI_STS3r BCMI_TSCE16_XGXS_MODIFY_TX_PI_STS3r
#define READLN_TX_PI_STS3r BCMI_TSCE16_XGXS_READLN_TX_PI_STS3r
#define WRITELN_TX_PI_STS3r BCMI_TSCE16_XGXS_WRITELN_TX_PI_STS3r
#define WRITEALL_TX_PI_STS3r BCMI_TSCE16_XGXS_WRITEALL_TX_PI_STS3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_PI_STS3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_PI_STS4
 * BLOCKS:   TX_PI
 * REGADDR:  0xd07c
 * DESC:     TX Phase Interpolator Status 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_PI_HS_FIFO_PHSERR Bit 4 of hs_fifo_pherr.
 *     ST_AFE_TX_FIFO_RESETB Status of the final afe_tx_fifo_resetb signal connected to the AFE pin.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_PI_STS4r (0x0000d07c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_PI_STS4r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_STS4.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_PI_STS4r_s {
	uint32_t v[1];
	uint32_t tx_pi_sts4[1];
	uint32_t _tx_pi_sts4;
} BCMI_TSCE16_XGXS_TX_PI_STS4r_t;

#define BCMI_TSCE16_XGXS_TX_PI_STS4r_CLR(r) (r).tx_pi_sts4[0] = 0
#define BCMI_TSCE16_XGXS_TX_PI_STS4r_SET(r,d) (r).tx_pi_sts4[0] = d
#define BCMI_TSCE16_XGXS_TX_PI_STS4r_GET(r) (r).tx_pi_sts4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_PI_STS4r_ST_AFE_TX_FIFO_RESETBf_GET(r) ((((r).tx_pi_sts4[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_TX_PI_STS4r_ST_AFE_TX_FIFO_RESETBf_SET(r,f) (r).tx_pi_sts4[0]=(((r).tx_pi_sts4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_TX_PI_STS4r_TX_PI_HS_FIFO_PHSERRf_GET(r) (((r).tx_pi_sts4[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TX_PI_STS4r_TX_PI_HS_FIFO_PHSERRf_SET(r,f) (r).tx_pi_sts4[0]=(((r).tx_pi_sts4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_PI_STS4.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_PI_STS4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_PI_STS4r,(_r._tx_pi_sts4))
#define BCMI_TSCE16_XGXS_WRITE_TX_PI_STS4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_STS4r,(_r._tx_pi_sts4)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_PI_STS4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_STS4r,(_r._tx_pi_sts4))
#define BCMI_TSCE16_XGXS_READLN_TX_PI_STS4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_PI_STS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts4))
#define BCMI_TSCE16_XGXS_WRITELN_TX_PI_STS4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_STS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts4))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_PI_STS4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_STS4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_sts4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_STS4r BCMI_TSCE16_XGXS_TX_PI_STS4r
#define TX_PI_STS4r_SIZE BCMI_TSCE16_XGXS_TX_PI_STS4r_SIZE
typedef BCMI_TSCE16_XGXS_TX_PI_STS4r_t TX_PI_STS4r_t;
#define TX_PI_STS4r_CLR BCMI_TSCE16_XGXS_TX_PI_STS4r_CLR
#define TX_PI_STS4r_SET BCMI_TSCE16_XGXS_TX_PI_STS4r_SET
#define TX_PI_STS4r_GET BCMI_TSCE16_XGXS_TX_PI_STS4r_GET
#define TX_PI_STS4r_ST_AFE_TX_FIFO_RESETBf_GET BCMI_TSCE16_XGXS_TX_PI_STS4r_ST_AFE_TX_FIFO_RESETBf_GET
#define TX_PI_STS4r_ST_AFE_TX_FIFO_RESETBf_SET BCMI_TSCE16_XGXS_TX_PI_STS4r_ST_AFE_TX_FIFO_RESETBf_SET
#define TX_PI_STS4r_TX_PI_HS_FIFO_PHSERRf_GET BCMI_TSCE16_XGXS_TX_PI_STS4r_TX_PI_HS_FIFO_PHSERRf_GET
#define TX_PI_STS4r_TX_PI_HS_FIFO_PHSERRf_SET BCMI_TSCE16_XGXS_TX_PI_STS4r_TX_PI_HS_FIFO_PHSERRf_SET
#define READ_TX_PI_STS4r BCMI_TSCE16_XGXS_READ_TX_PI_STS4r
#define WRITE_TX_PI_STS4r BCMI_TSCE16_XGXS_WRITE_TX_PI_STS4r
#define MODIFY_TX_PI_STS4r BCMI_TSCE16_XGXS_MODIFY_TX_PI_STS4r
#define READLN_TX_PI_STS4r BCMI_TSCE16_XGXS_READLN_TX_PI_STS4r
#define WRITELN_TX_PI_STS4r BCMI_TSCE16_XGXS_WRITELN_TX_PI_STS4r
#define WRITEALL_TX_PI_STS4r BCMI_TSCE16_XGXS_WRITEALL_TX_PI_STS4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_PI_STS4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_PI_TX_FIFO_OVFB_STS
 * BLOCKS:   TX_PI
 * REGADDR:  0xd07d
 * DESC:     TX FIFO Overflow Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_FIFO_OVFB     Indiactes live status of the tx_fifo_ovfb signal from AFE/High Speed Phase FIFO.
 *     TX_FIFO_OVFB_FALL_EDGE_LH lathc high indication for 1 -> 0 transition on tx_fifo_ovfb signal from AFE/High Speed Phase FIFO. This is clear on read status.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_PI_TX_FIFO_OVFB_STSr (0x0000d07d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_PI_TX_FIFO_OVFB_STSr_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_TX_FIFO_OVFB_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_PI_TX_FIFO_OVFB_STSr_s {
	uint32_t v[1];
	uint32_t tx_pi_tx_fifo_ovfb_sts[1];
	uint32_t _tx_pi_tx_fifo_ovfb_sts;
} BCMI_TSCE16_XGXS_TX_PI_TX_FIFO_OVFB_STSr_t;

#define BCMI_TSCE16_XGXS_TX_PI_TX_FIFO_OVFB_STSr_CLR(r) (r).tx_pi_tx_fifo_ovfb_sts[0] = 0
#define BCMI_TSCE16_XGXS_TX_PI_TX_FIFO_OVFB_STSr_SET(r,d) (r).tx_pi_tx_fifo_ovfb_sts[0] = d
#define BCMI_TSCE16_XGXS_TX_PI_TX_FIFO_OVFB_STSr_GET(r) (r).tx_pi_tx_fifo_ovfb_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFB_FALL_EDGE_LHf_GET(r) ((((r).tx_pi_tx_fifo_ovfb_sts[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFB_FALL_EDGE_LHf_SET(r,f) (r).tx_pi_tx_fifo_ovfb_sts[0]=(((r).tx_pi_tx_fifo_ovfb_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFBf_GET(r) (((r).tx_pi_tx_fifo_ovfb_sts[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFBf_SET(r,f) (r).tx_pi_tx_fifo_ovfb_sts[0]=(((r).tx_pi_tx_fifo_ovfb_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_PI_TX_FIFO_OVFB_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_PI_TX_FIFO_OVFB_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_PI_TX_FIFO_OVFB_STSr,(_r._tx_pi_tx_fifo_ovfb_sts))
#define BCMI_TSCE16_XGXS_WRITE_TX_PI_TX_FIFO_OVFB_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_TX_FIFO_OVFB_STSr,(_r._tx_pi_tx_fifo_ovfb_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_PI_TX_FIFO_OVFB_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_TX_FIFO_OVFB_STSr,(_r._tx_pi_tx_fifo_ovfb_sts))
#define BCMI_TSCE16_XGXS_READLN_TX_PI_TX_FIFO_OVFB_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_PI_TX_FIFO_OVFB_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_tx_fifo_ovfb_sts))
#define BCMI_TSCE16_XGXS_WRITELN_TX_PI_TX_FIFO_OVFB_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_TX_FIFO_OVFB_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_tx_fifo_ovfb_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_PI_TX_FIFO_OVFB_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_PI_TX_FIFO_OVFB_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_tx_fifo_ovfb_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_TX_FIFO_OVFB_STSr BCMI_TSCE16_XGXS_TX_PI_TX_FIFO_OVFB_STSr
#define TX_PI_TX_FIFO_OVFB_STSr_SIZE BCMI_TSCE16_XGXS_TX_PI_TX_FIFO_OVFB_STSr_SIZE
typedef BCMI_TSCE16_XGXS_TX_PI_TX_FIFO_OVFB_STSr_t TX_PI_TX_FIFO_OVFB_STSr_t;
#define TX_PI_TX_FIFO_OVFB_STSr_CLR BCMI_TSCE16_XGXS_TX_PI_TX_FIFO_OVFB_STSr_CLR
#define TX_PI_TX_FIFO_OVFB_STSr_SET BCMI_TSCE16_XGXS_TX_PI_TX_FIFO_OVFB_STSr_SET
#define TX_PI_TX_FIFO_OVFB_STSr_GET BCMI_TSCE16_XGXS_TX_PI_TX_FIFO_OVFB_STSr_GET
#define TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFB_FALL_EDGE_LHf_GET BCMI_TSCE16_XGXS_TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFB_FALL_EDGE_LHf_GET
#define TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFB_FALL_EDGE_LHf_SET BCMI_TSCE16_XGXS_TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFB_FALL_EDGE_LHf_SET
#define TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFBf_GET BCMI_TSCE16_XGXS_TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFBf_GET
#define TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFBf_SET BCMI_TSCE16_XGXS_TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFBf_SET
#define READ_TX_PI_TX_FIFO_OVFB_STSr BCMI_TSCE16_XGXS_READ_TX_PI_TX_FIFO_OVFB_STSr
#define WRITE_TX_PI_TX_FIFO_OVFB_STSr BCMI_TSCE16_XGXS_WRITE_TX_PI_TX_FIFO_OVFB_STSr
#define MODIFY_TX_PI_TX_FIFO_OVFB_STSr BCMI_TSCE16_XGXS_MODIFY_TX_PI_TX_FIFO_OVFB_STSr
#define READLN_TX_PI_TX_FIFO_OVFB_STSr BCMI_TSCE16_XGXS_READLN_TX_PI_TX_FIFO_OVFB_STSr
#define WRITELN_TX_PI_TX_FIFO_OVFB_STSr BCMI_TSCE16_XGXS_WRITELN_TX_PI_TX_FIFO_OVFB_STSr
#define WRITEALL_TX_PI_TX_FIFO_OVFB_STSr BCMI_TSCE16_XGXS_WRITEALL_TX_PI_TX_FIFO_OVFB_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_PI_TX_FIFO_OVFB_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RXTXCOM_OSR_MODE_CTL
 * BLOCKS:   RXTXCOM_CKRST_CTRL
 * REGADDR:  0xd080
 * DESC:     OSR_MODE_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     OSR_MODE_FRC_VAL oversample (OS) mode Decoding of this register is as follows.OSX1          4'd0OSX2          4'd1OSX3          4'd2OSX3P3        4'd3OSX4          4'd4OSX5          4'd5OSX7P5        4'd6OSX8          4'd7OSX8P25       4'd8OSX10         4'd9
 *     OSR_MODE_FRC     oversample (OS) mode force. Setting this bit will allow the register value to be used for OS mode.Othersise, the pin input values are used for OS mode
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_CTLr (0x0000d080 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXTXCOM_OSR_MODE_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_CTLr_s {
	uint32_t v[1];
	uint32_t rxtxcom_osr_mode_ctl[1];
	uint32_t _rxtxcom_osr_mode_ctl;
} BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_CTLr_t;

#define BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_CTLr_CLR(r) (r).rxtxcom_osr_mode_ctl[0] = 0
#define BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_CTLr_SET(r,d) (r).rxtxcom_osr_mode_ctl[0] = d
#define BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_CTLr_GET(r) (r).rxtxcom_osr_mode_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRCf_GET(r) ((((r).rxtxcom_osr_mode_ctl[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRCf_SET(r,f) (r).rxtxcom_osr_mode_ctl[0]=(((r).rxtxcom_osr_mode_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRC_VALf_GET(r) (((r).rxtxcom_osr_mode_ctl[0]) & 0xf)
#define BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRC_VALf_SET(r,f) (r).rxtxcom_osr_mode_ctl[0]=(((r).rxtxcom_osr_mode_ctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access RXTXCOM_OSR_MODE_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RXTXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_CTLr,(_r._rxtxcom_osr_mode_ctl))
#define BCMI_TSCE16_XGXS_WRITE_RXTXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_CTLr,(_r._rxtxcom_osr_mode_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RXTXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_CTLr,(_r._rxtxcom_osr_mode_ctl))
#define BCMI_TSCE16_XGXS_READLN_RXTXCOM_OSR_MODE_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_osr_mode_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_RXTXCOM_OSR_MODE_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_osr_mode_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_RXTXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxtxcom_osr_mode_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXTXCOM_OSR_MODE_CTLr BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_CTLr
#define RXTXCOM_OSR_MODE_CTLr_SIZE BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_CTLr_t RXTXCOM_OSR_MODE_CTLr_t;
#define RXTXCOM_OSR_MODE_CTLr_CLR BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_CTLr_CLR
#define RXTXCOM_OSR_MODE_CTLr_SET BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_CTLr_SET
#define RXTXCOM_OSR_MODE_CTLr_GET BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_CTLr_GET
#define RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRCf_GET BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRCf_GET
#define RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRCf_SET BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRCf_SET
#define RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRC_VALf_GET BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRC_VALf_GET
#define RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRC_VALf_SET BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRC_VALf_SET
#define READ_RXTXCOM_OSR_MODE_CTLr BCMI_TSCE16_XGXS_READ_RXTXCOM_OSR_MODE_CTLr
#define WRITE_RXTXCOM_OSR_MODE_CTLr BCMI_TSCE16_XGXS_WRITE_RXTXCOM_OSR_MODE_CTLr
#define MODIFY_RXTXCOM_OSR_MODE_CTLr BCMI_TSCE16_XGXS_MODIFY_RXTXCOM_OSR_MODE_CTLr
#define READLN_RXTXCOM_OSR_MODE_CTLr BCMI_TSCE16_XGXS_READLN_RXTXCOM_OSR_MODE_CTLr
#define WRITELN_RXTXCOM_OSR_MODE_CTLr BCMI_TSCE16_XGXS_WRITELN_RXTXCOM_OSR_MODE_CTLr
#define WRITEALL_RXTXCOM_OSR_MODE_CTLr BCMI_TSCE16_XGXS_WRITEALL_RXTXCOM_OSR_MODE_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RXTXCOM_LN_CLK_RST_N_PWRDWN_CTL
 * BLOCKS:   RXTXCOM_CKRST_CTRL
 * REGADDR:  0xd081
 * DESC:     LANE_CLK_RESET_N_POWERDOWN_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_DP_S_RSTB     Active Low Lane Soft Reset for datapath. If asserted by writing to 1'b0 will reset the datapath for a lane.This soft reset is equivalent to the hard reset input pin pmd_ln_dp_h_rstb_i.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr (0x0000d081 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXTXCOM_LN_CLK_RST_N_PWRDWN_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_s {
	uint32_t v[1];
	uint32_t rxtxcom_ln_clk_rst_n_pwrdwn_ctl[1];
	uint32_t _rxtxcom_ln_clk_rst_n_pwrdwn_ctl;
} BCMI_TSCE16_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_t;

#define BCMI_TSCE16_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_CLR(r) (r).rxtxcom_ln_clk_rst_n_pwrdwn_ctl[0] = 0
#define BCMI_TSCE16_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SET(r,d) (r).rxtxcom_ln_clk_rst_n_pwrdwn_ctl[0] = d
#define BCMI_TSCE16_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_GET(r) (r).rxtxcom_ln_clk_rst_n_pwrdwn_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_LN_DP_S_RSTBf_GET(r) (((r).rxtxcom_ln_clk_rst_n_pwrdwn_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_LN_DP_S_RSTBf_SET(r,f) (r).rxtxcom_ln_clk_rst_n_pwrdwn_ctl[0]=(((r).rxtxcom_ln_clk_rst_n_pwrdwn_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXTXCOM_LN_CLK_RST_N_PWRDWN_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr,(_r._rxtxcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCE16_XGXS_WRITE_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr,(_r._rxtxcom_ln_clk_rst_n_pwrdwn_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr,(_r._rxtxcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCE16_XGXS_READLN_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxtxcom_ln_clk_rst_n_pwrdwn_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCE16_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SIZE BCMI_TSCE16_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_t RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_t;
#define RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_CLR BCMI_TSCE16_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_CLR
#define RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SET BCMI_TSCE16_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SET
#define RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_GET BCMI_TSCE16_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_GET
#define RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_LN_DP_S_RSTBf_GET BCMI_TSCE16_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_LN_DP_S_RSTBf_GET
#define RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_LN_DP_S_RSTBf_SET BCMI_TSCE16_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_LN_DP_S_RSTBf_SET
#define READ_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCE16_XGXS_READ_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITE_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCE16_XGXS_WRITE_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define MODIFY_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCE16_XGXS_MODIFY_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define READLN_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCE16_XGXS_READLN_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITELN_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCE16_XGXS_WRITELN_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITEALL_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCE16_XGXS_WRITEALL_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTL
 * BLOCKS:   RXTXCOM_CKRST_CTRL
 * REGADDR:  0xd083
 * DESC:     LANE_RESET_N_PWRDN_PIN_KILL_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMD_LN_H_RSTB_PKILL 1'b1 will disable the pmd_ln_h_rstb input pin.
 *     PMD_LN_DP_H_RSTB_PKILL 1'b1 will disable the pmd_ln_dp_h_rstb input pin.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr (0x0000d083 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_s {
	uint32_t v[1];
	uint32_t rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl[1];
	uint32_t _rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl;
} BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_t;

#define BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR(r) (r).rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl[0] = 0
#define BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET(r,d) (r).rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl[0] = d
#define BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET(r) (r).rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_DP_H_RSTB_PKILLf_GET(r) ((((r).rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_DP_H_RSTB_PKILLf_SET(r,f) (r).rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl[0]=(((r).rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_H_RSTB_PKILLf_GET(r) (((r).rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_H_RSTB_PKILLf_SET(r,f) (r).rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl[0]=(((r).rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCE16_XGXS_WRITE_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCE16_XGXS_READLN_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_t RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_t;
#define RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR
#define RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET
#define RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET
#define RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_DP_H_RSTB_PKILLf_GET BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_DP_H_RSTB_PKILLf_GET
#define RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_DP_H_RSTB_PKILLf_SET BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_DP_H_RSTB_PKILLf_SET
#define RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_H_RSTB_PKILLf_GET BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_H_RSTB_PKILLf_GET
#define RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_H_RSTB_PKILLf_SET BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_H_RSTB_PKILLf_SET
#define READ_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCE16_XGXS_READ_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITE_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCE16_XGXS_WRITE_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define MODIFY_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCE16_XGXS_MODIFY_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define READLN_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCE16_XGXS_READLN_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITELN_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCE16_XGXS_WRITELN_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITEALL_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCE16_XGXS_WRITEALL_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RXTXCOM_UC_ACK_LN_CTL
 * BLOCKS:   RXTXCOM_CKRST_CTRL
 * REGADDR:  0xd085
 * DESC:     UC_ACK_LANE_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UC_ACK_LANE_CFG_DONE uC will write this to 1 to indicate it's configuration of the lane is complete. Writing to 1'b1 willshould release internal hold on lane_dp_reset, only if lane_dp_reset_state is 3'b001.
 *     UC_ACK_LANE_DP_RESET uC will write this to 1 to acknowledge a reset event after seeing "lane_dp_reset_coccured".
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RXTXCOM_UC_ACK_LN_CTLr (0x0000d085 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RXTXCOM_UC_ACK_LN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXTXCOM_UC_ACK_LN_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_RXTXCOM_UC_ACK_LN_CTLr_s {
	uint32_t v[1];
	uint32_t rxtxcom_uc_ack_ln_ctl[1];
	uint32_t _rxtxcom_uc_ack_ln_ctl;
} BCMI_TSCE16_XGXS_RXTXCOM_UC_ACK_LN_CTLr_t;

#define BCMI_TSCE16_XGXS_RXTXCOM_UC_ACK_LN_CTLr_CLR(r) (r).rxtxcom_uc_ack_ln_ctl[0] = 0
#define BCMI_TSCE16_XGXS_RXTXCOM_UC_ACK_LN_CTLr_SET(r,d) (r).rxtxcom_uc_ack_ln_ctl[0] = d
#define BCMI_TSCE16_XGXS_RXTXCOM_UC_ACK_LN_CTLr_GET(r) (r).rxtxcom_uc_ack_ln_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_DP_RESETf_GET(r) ((((r).rxtxcom_uc_ack_ln_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_DP_RESETf_SET(r,f) (r).rxtxcom_uc_ack_ln_ctl[0]=(((r).rxtxcom_uc_ack_ln_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_CFG_DONEf_GET(r) (((r).rxtxcom_uc_ack_ln_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_CFG_DONEf_SET(r,f) (r).rxtxcom_uc_ack_ln_ctl[0]=(((r).rxtxcom_uc_ack_ln_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXTXCOM_UC_ACK_LN_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RXTXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXTXCOM_UC_ACK_LN_CTLr,(_r._rxtxcom_uc_ack_ln_ctl))
#define BCMI_TSCE16_XGXS_WRITE_RXTXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_UC_ACK_LN_CTLr,(_r._rxtxcom_uc_ack_ln_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RXTXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_UC_ACK_LN_CTLr,(_r._rxtxcom_uc_ack_ln_ctl))
#define BCMI_TSCE16_XGXS_READLN_RXTXCOM_UC_ACK_LN_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXTXCOM_UC_ACK_LN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_uc_ack_ln_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_RXTXCOM_UC_ACK_LN_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_UC_ACK_LN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_uc_ack_ln_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_RXTXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_UC_ACK_LN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxtxcom_uc_ack_ln_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXTXCOM_UC_ACK_LN_CTLr BCMI_TSCE16_XGXS_RXTXCOM_UC_ACK_LN_CTLr
#define RXTXCOM_UC_ACK_LN_CTLr_SIZE BCMI_TSCE16_XGXS_RXTXCOM_UC_ACK_LN_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_RXTXCOM_UC_ACK_LN_CTLr_t RXTXCOM_UC_ACK_LN_CTLr_t;
#define RXTXCOM_UC_ACK_LN_CTLr_CLR BCMI_TSCE16_XGXS_RXTXCOM_UC_ACK_LN_CTLr_CLR
#define RXTXCOM_UC_ACK_LN_CTLr_SET BCMI_TSCE16_XGXS_RXTXCOM_UC_ACK_LN_CTLr_SET
#define RXTXCOM_UC_ACK_LN_CTLr_GET BCMI_TSCE16_XGXS_RXTXCOM_UC_ACK_LN_CTLr_GET
#define RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_DP_RESETf_GET BCMI_TSCE16_XGXS_RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_DP_RESETf_GET
#define RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_DP_RESETf_SET BCMI_TSCE16_XGXS_RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_DP_RESETf_SET
#define RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_CFG_DONEf_GET BCMI_TSCE16_XGXS_RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_CFG_DONEf_GET
#define RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_CFG_DONEf_SET BCMI_TSCE16_XGXS_RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_CFG_DONEf_SET
#define READ_RXTXCOM_UC_ACK_LN_CTLr BCMI_TSCE16_XGXS_READ_RXTXCOM_UC_ACK_LN_CTLr
#define WRITE_RXTXCOM_UC_ACK_LN_CTLr BCMI_TSCE16_XGXS_WRITE_RXTXCOM_UC_ACK_LN_CTLr
#define MODIFY_RXTXCOM_UC_ACK_LN_CTLr BCMI_TSCE16_XGXS_MODIFY_RXTXCOM_UC_ACK_LN_CTLr
#define READLN_RXTXCOM_UC_ACK_LN_CTLr BCMI_TSCE16_XGXS_READLN_RXTXCOM_UC_ACK_LN_CTLr
#define WRITELN_RXTXCOM_UC_ACK_LN_CTLr BCMI_TSCE16_XGXS_WRITELN_RXTXCOM_UC_ACK_LN_CTLr
#define WRITEALL_RXTXCOM_UC_ACK_LN_CTLr BCMI_TSCE16_XGXS_WRITEALL_RXTXCOM_UC_ACK_LN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RXTXCOM_UC_ACK_LN_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RXTXCOM_LN_RST_OCC_CTL
 * BLOCKS:   RXTXCOM_CKRST_CTRL
 * REGADDR:  0xd086
 * DESC:     LANE_REG_RESET_OCCURRED_CONTROL
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     LANE_REG_RESET_OCCURRED Set to 1'b1 upon lane level register reset and remains so until cleared by register write from uC.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_OCC_CTLr (0x0000d086 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_OCC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXTXCOM_LN_RST_OCC_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_OCC_CTLr_s {
	uint32_t v[1];
	uint32_t rxtxcom_ln_rst_occ_ctl[1];
	uint32_t _rxtxcom_ln_rst_occ_ctl;
} BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_OCC_CTLr_t;

#define BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_OCC_CTLr_CLR(r) (r).rxtxcom_ln_rst_occ_ctl[0] = 0
#define BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_OCC_CTLr_SET(r,d) (r).rxtxcom_ln_rst_occ_ctl[0] = d
#define BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_OCC_CTLr_GET(r) (r).rxtxcom_ln_rst_occ_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_OCC_CTLr_LANE_REG_RESET_OCCURREDf_GET(r) (((r).rxtxcom_ln_rst_occ_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_OCC_CTLr_LANE_REG_RESET_OCCURREDf_SET(r,f) (r).rxtxcom_ln_rst_occ_ctl[0]=(((r).rxtxcom_ln_rst_occ_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXTXCOM_LN_RST_OCC_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RXTXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_OCC_CTLr,(_r._rxtxcom_ln_rst_occ_ctl))
#define BCMI_TSCE16_XGXS_WRITE_RXTXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_OCC_CTLr,(_r._rxtxcom_ln_rst_occ_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RXTXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_OCC_CTLr,(_r._rxtxcom_ln_rst_occ_ctl))
#define BCMI_TSCE16_XGXS_READLN_RXTXCOM_LN_RST_OCC_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_ln_rst_occ_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_RXTXCOM_LN_RST_OCC_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_ln_rst_occ_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_RXTXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxtxcom_ln_rst_occ_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXTXCOM_LN_RST_OCC_CTLr BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_OCC_CTLr
#define RXTXCOM_LN_RST_OCC_CTLr_SIZE BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_OCC_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_OCC_CTLr_t RXTXCOM_LN_RST_OCC_CTLr_t;
#define RXTXCOM_LN_RST_OCC_CTLr_CLR BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_OCC_CTLr_CLR
#define RXTXCOM_LN_RST_OCC_CTLr_SET BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_OCC_CTLr_SET
#define RXTXCOM_LN_RST_OCC_CTLr_GET BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_OCC_CTLr_GET
#define RXTXCOM_LN_RST_OCC_CTLr_LANE_REG_RESET_OCCURREDf_GET BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_OCC_CTLr_LANE_REG_RESET_OCCURREDf_GET
#define RXTXCOM_LN_RST_OCC_CTLr_LANE_REG_RESET_OCCURREDf_SET BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_OCC_CTLr_LANE_REG_RESET_OCCURREDf_SET
#define READ_RXTXCOM_LN_RST_OCC_CTLr BCMI_TSCE16_XGXS_READ_RXTXCOM_LN_RST_OCC_CTLr
#define WRITE_RXTXCOM_LN_RST_OCC_CTLr BCMI_TSCE16_XGXS_WRITE_RXTXCOM_LN_RST_OCC_CTLr
#define MODIFY_RXTXCOM_LN_RST_OCC_CTLr BCMI_TSCE16_XGXS_MODIFY_RXTXCOM_LN_RST_OCC_CTLr
#define READLN_RXTXCOM_LN_RST_OCC_CTLr BCMI_TSCE16_XGXS_READLN_RXTXCOM_LN_RST_OCC_CTLr
#define WRITELN_RXTXCOM_LN_RST_OCC_CTLr BCMI_TSCE16_XGXS_WRITELN_RXTXCOM_LN_RST_OCC_CTLr
#define WRITEALL_RXTXCOM_LN_RST_OCC_CTLr BCMI_TSCE16_XGXS_WRITEALL_RXTXCOM_LN_RST_OCC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RXTXCOM_LN_RST_OCC_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RXTXCOM_LN_DP_RST_ST_STS
 * BLOCKS:   RXTXCOM_CKRST_CTRL
 * REGADDR:  0xd089
 * DESC:     LANE_DP_RESET_STATE_STATUS
 * RESETVAL: 0x7 (7)
 * ACCESS:   R/O
 * FIELDS:
 *     LANE_DP_RESET_STATE Bit 2: lane_dp_reset_active   : Set to 1'b1 whenenver lane_dp_reset is currently requested through any register or pin controls.Bit 1: lane_dp_reset_occurred : Set to 1'b1 whenenver lane_dp_reset is currently requested through any register or pin controls and is latched high.Bit 0: lane_dp_reset_held     : Set to 1'b1 whenenver lane_dp_reset is internally held. Cleared to 1'b0, only if lane_dp_reset_state==001 and uc_ack_lane_cfg_done == 1.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RXTXCOM_LN_DP_RST_ST_STSr (0x0000d089 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_SIZE 4

/*
 * This structure should be used to declare and program RXTXCOM_LN_DP_RST_ST_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_s {
	uint32_t v[1];
	uint32_t rxtxcom_ln_dp_rst_st_sts[1];
	uint32_t _rxtxcom_ln_dp_rst_st_sts;
} BCMI_TSCE16_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_t;

#define BCMI_TSCE16_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_CLR(r) (r).rxtxcom_ln_dp_rst_st_sts[0] = 0
#define BCMI_TSCE16_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_SET(r,d) (r).rxtxcom_ln_dp_rst_st_sts[0] = d
#define BCMI_TSCE16_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_GET(r) (r).rxtxcom_ln_dp_rst_st_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_LANE_DP_RESET_STATEf_GET(r) (((r).rxtxcom_ln_dp_rst_st_sts[0]) & 0x7)
#define BCMI_TSCE16_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_LANE_DP_RESET_STATEf_SET(r,f) (r).rxtxcom_ln_dp_rst_st_sts[0]=(((r).rxtxcom_ln_dp_rst_st_sts[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access RXTXCOM_LN_DP_RST_ST_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RXTXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXTXCOM_LN_DP_RST_ST_STSr,(_r._rxtxcom_ln_dp_rst_st_sts))
#define BCMI_TSCE16_XGXS_WRITE_RXTXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_LN_DP_RST_ST_STSr,(_r._rxtxcom_ln_dp_rst_st_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RXTXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_LN_DP_RST_ST_STSr,(_r._rxtxcom_ln_dp_rst_st_sts))
#define BCMI_TSCE16_XGXS_READLN_RXTXCOM_LN_DP_RST_ST_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXTXCOM_LN_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_ln_dp_rst_st_sts))
#define BCMI_TSCE16_XGXS_WRITELN_RXTXCOM_LN_DP_RST_ST_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_LN_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_ln_dp_rst_st_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_RXTXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_LN_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxtxcom_ln_dp_rst_st_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXTXCOM_LN_DP_RST_ST_STSr BCMI_TSCE16_XGXS_RXTXCOM_LN_DP_RST_ST_STSr
#define RXTXCOM_LN_DP_RST_ST_STSr_SIZE BCMI_TSCE16_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_SIZE
typedef BCMI_TSCE16_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_t RXTXCOM_LN_DP_RST_ST_STSr_t;
#define RXTXCOM_LN_DP_RST_ST_STSr_CLR BCMI_TSCE16_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_CLR
#define RXTXCOM_LN_DP_RST_ST_STSr_SET BCMI_TSCE16_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_SET
#define RXTXCOM_LN_DP_RST_ST_STSr_GET BCMI_TSCE16_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_GET
#define RXTXCOM_LN_DP_RST_ST_STSr_LANE_DP_RESET_STATEf_GET BCMI_TSCE16_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_LANE_DP_RESET_STATEf_GET
#define RXTXCOM_LN_DP_RST_ST_STSr_LANE_DP_RESET_STATEf_SET BCMI_TSCE16_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_LANE_DP_RESET_STATEf_SET
#define READ_RXTXCOM_LN_DP_RST_ST_STSr BCMI_TSCE16_XGXS_READ_RXTXCOM_LN_DP_RST_ST_STSr
#define WRITE_RXTXCOM_LN_DP_RST_ST_STSr BCMI_TSCE16_XGXS_WRITE_RXTXCOM_LN_DP_RST_ST_STSr
#define MODIFY_RXTXCOM_LN_DP_RST_ST_STSr BCMI_TSCE16_XGXS_MODIFY_RXTXCOM_LN_DP_RST_ST_STSr
#define READLN_RXTXCOM_LN_DP_RST_ST_STSr BCMI_TSCE16_XGXS_READLN_RXTXCOM_LN_DP_RST_ST_STSr
#define WRITELN_RXTXCOM_LN_DP_RST_ST_STSr BCMI_TSCE16_XGXS_WRITELN_RXTXCOM_LN_DP_RST_ST_STSr
#define WRITEALL_RXTXCOM_LN_DP_RST_ST_STSr BCMI_TSCE16_XGXS_WRITEALL_RXTXCOM_LN_DP_RST_ST_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RXTXCOM_LN_DP_RST_ST_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RXTXCOM_MCST_MASK_CTL
 * BLOCKS:   RXTXCOM_CKRST_CTRL
 * REGADDR:  0xd08a
 * DESC:     MULTICAST_MASK_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MULTICAST_MASK_CONTROL This masks the lane from a broadcast or multicast write operation.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RXTXCOM_MCST_MASK_CTLr (0x0000d08a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RXTXCOM_MCST_MASK_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXTXCOM_MCST_MASK_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_RXTXCOM_MCST_MASK_CTLr_s {
	uint32_t v[1];
	uint32_t rxtxcom_mcst_mask_ctl[1];
	uint32_t _rxtxcom_mcst_mask_ctl;
} BCMI_TSCE16_XGXS_RXTXCOM_MCST_MASK_CTLr_t;

#define BCMI_TSCE16_XGXS_RXTXCOM_MCST_MASK_CTLr_CLR(r) (r).rxtxcom_mcst_mask_ctl[0] = 0
#define BCMI_TSCE16_XGXS_RXTXCOM_MCST_MASK_CTLr_SET(r,d) (r).rxtxcom_mcst_mask_ctl[0] = d
#define BCMI_TSCE16_XGXS_RXTXCOM_MCST_MASK_CTLr_GET(r) (r).rxtxcom_mcst_mask_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RXTXCOM_MCST_MASK_CTLr_MULTICAST_MASK_CONTROLf_GET(r) (((r).rxtxcom_mcst_mask_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_RXTXCOM_MCST_MASK_CTLr_MULTICAST_MASK_CONTROLf_SET(r,f) (r).rxtxcom_mcst_mask_ctl[0]=(((r).rxtxcom_mcst_mask_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXTXCOM_MCST_MASK_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RXTXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXTXCOM_MCST_MASK_CTLr,(_r._rxtxcom_mcst_mask_ctl))
#define BCMI_TSCE16_XGXS_WRITE_RXTXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_MCST_MASK_CTLr,(_r._rxtxcom_mcst_mask_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RXTXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_MCST_MASK_CTLr,(_r._rxtxcom_mcst_mask_ctl))
#define BCMI_TSCE16_XGXS_READLN_RXTXCOM_MCST_MASK_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXTXCOM_MCST_MASK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_mcst_mask_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_RXTXCOM_MCST_MASK_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_MCST_MASK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_mcst_mask_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_RXTXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_MCST_MASK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxtxcom_mcst_mask_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXTXCOM_MCST_MASK_CTLr BCMI_TSCE16_XGXS_RXTXCOM_MCST_MASK_CTLr
#define RXTXCOM_MCST_MASK_CTLr_SIZE BCMI_TSCE16_XGXS_RXTXCOM_MCST_MASK_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_RXTXCOM_MCST_MASK_CTLr_t RXTXCOM_MCST_MASK_CTLr_t;
#define RXTXCOM_MCST_MASK_CTLr_CLR BCMI_TSCE16_XGXS_RXTXCOM_MCST_MASK_CTLr_CLR
#define RXTXCOM_MCST_MASK_CTLr_SET BCMI_TSCE16_XGXS_RXTXCOM_MCST_MASK_CTLr_SET
#define RXTXCOM_MCST_MASK_CTLr_GET BCMI_TSCE16_XGXS_RXTXCOM_MCST_MASK_CTLr_GET
#define RXTXCOM_MCST_MASK_CTLr_MULTICAST_MASK_CONTROLf_GET BCMI_TSCE16_XGXS_RXTXCOM_MCST_MASK_CTLr_MULTICAST_MASK_CONTROLf_GET
#define RXTXCOM_MCST_MASK_CTLr_MULTICAST_MASK_CONTROLf_SET BCMI_TSCE16_XGXS_RXTXCOM_MCST_MASK_CTLr_MULTICAST_MASK_CONTROLf_SET
#define READ_RXTXCOM_MCST_MASK_CTLr BCMI_TSCE16_XGXS_READ_RXTXCOM_MCST_MASK_CTLr
#define WRITE_RXTXCOM_MCST_MASK_CTLr BCMI_TSCE16_XGXS_WRITE_RXTXCOM_MCST_MASK_CTLr
#define MODIFY_RXTXCOM_MCST_MASK_CTLr BCMI_TSCE16_XGXS_MODIFY_RXTXCOM_MCST_MASK_CTLr
#define READLN_RXTXCOM_MCST_MASK_CTLr BCMI_TSCE16_XGXS_READLN_RXTXCOM_MCST_MASK_CTLr
#define WRITELN_RXTXCOM_MCST_MASK_CTLr BCMI_TSCE16_XGXS_WRITELN_RXTXCOM_MCST_MASK_CTLr
#define WRITEALL_RXTXCOM_MCST_MASK_CTLr BCMI_TSCE16_XGXS_WRITEALL_RXTXCOM_MCST_MASK_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RXTXCOM_MCST_MASK_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RXTXCOM_OSR_MODE_STS_MC_MASK
 * BLOCKS:   RXTXCOM_CKRST_CTRL
 * REGADDR:  0xd08b
 * DESC:     OSR_MODE_STATUS_MC_MASK
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     OSR_MODE         OSR Mode status after the mux.OSR Mode status after the osr_mode_frc/frc_val mux.Decoding of this register is as follows.OSX1          4'd0OSX2          4'd1OSX3          4'd2OSX3P3        4'd3OSX4          4'd4OSX5          4'd5OSX7P5        4'd6OSX8          4'd7OSX8P25       4'd8OSX10         4'd9
 *     MULTICAST_MASK_CONTROL_STATUS Status of multicast mask control for masking lane from multicast write operation.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr (0x0000d08b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_SIZE 4

/*
 * This structure should be used to declare and program RXTXCOM_OSR_MODE_STS_MC_MASK.
 *
 */
typedef union BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_s {
	uint32_t v[1];
	uint32_t rxtxcom_osr_mode_sts_mc_mask[1];
	uint32_t _rxtxcom_osr_mode_sts_mc_mask;
} BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_t;

#define BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_CLR(r) (r).rxtxcom_osr_mode_sts_mc_mask[0] = 0
#define BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_SET(r,d) (r).rxtxcom_osr_mode_sts_mc_mask[0] = d
#define BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_GET(r) (r).rxtxcom_osr_mode_sts_mc_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_MULTICAST_MASK_CONTROL_STATUSf_GET(r) ((((r).rxtxcom_osr_mode_sts_mc_mask[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_MULTICAST_MASK_CONTROL_STATUSf_SET(r,f) (r).rxtxcom_osr_mode_sts_mc_mask[0]=(((r).rxtxcom_osr_mode_sts_mc_mask[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_OSR_MODEf_GET(r) (((r).rxtxcom_osr_mode_sts_mc_mask[0]) & 0xf)
#define BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_OSR_MODEf_SET(r,f) (r).rxtxcom_osr_mode_sts_mc_mask[0]=(((r).rxtxcom_osr_mode_sts_mc_mask[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access RXTXCOM_OSR_MODE_STS_MC_MASK.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RXTXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr,(_r._rxtxcom_osr_mode_sts_mc_mask))
#define BCMI_TSCE16_XGXS_WRITE_RXTXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr,(_r._rxtxcom_osr_mode_sts_mc_mask)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RXTXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr,(_r._rxtxcom_osr_mode_sts_mc_mask))
#define BCMI_TSCE16_XGXS_READLN_RXTXCOM_OSR_MODE_STS_MC_MASKr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_osr_mode_sts_mc_mask))
#define BCMI_TSCE16_XGXS_WRITELN_RXTXCOM_OSR_MODE_STS_MC_MASKr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_osr_mode_sts_mc_mask))
#define BCMI_TSCE16_XGXS_WRITEALL_RXTXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxtxcom_osr_mode_sts_mc_mask))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXTXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr
#define RXTXCOM_OSR_MODE_STS_MC_MASKr_SIZE BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_SIZE
typedef BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_t RXTXCOM_OSR_MODE_STS_MC_MASKr_t;
#define RXTXCOM_OSR_MODE_STS_MC_MASKr_CLR BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_CLR
#define RXTXCOM_OSR_MODE_STS_MC_MASKr_SET BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_SET
#define RXTXCOM_OSR_MODE_STS_MC_MASKr_GET BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_GET
#define RXTXCOM_OSR_MODE_STS_MC_MASKr_MULTICAST_MASK_CONTROL_STATUSf_GET BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_MULTICAST_MASK_CONTROL_STATUSf_GET
#define RXTXCOM_OSR_MODE_STS_MC_MASKr_MULTICAST_MASK_CONTROL_STATUSf_SET BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_MULTICAST_MASK_CONTROL_STATUSf_SET
#define RXTXCOM_OSR_MODE_STS_MC_MASKr_OSR_MODEf_GET BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_OSR_MODEf_GET
#define RXTXCOM_OSR_MODE_STS_MC_MASKr_OSR_MODEf_SET BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_OSR_MODEf_SET
#define READ_RXTXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCE16_XGXS_READ_RXTXCOM_OSR_MODE_STS_MC_MASKr
#define WRITE_RXTXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCE16_XGXS_WRITE_RXTXCOM_OSR_MODE_STS_MC_MASKr
#define MODIFY_RXTXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCE16_XGXS_MODIFY_RXTXCOM_OSR_MODE_STS_MC_MASKr
#define READLN_RXTXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCE16_XGXS_READLN_RXTXCOM_OSR_MODE_STS_MC_MASKr
#define WRITELN_RXTXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCE16_XGXS_WRITELN_RXTXCOM_OSR_MODE_STS_MC_MASKr
#define WRITEALL_RXTXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCE16_XGXS_WRITEALL_RXTXCOM_OSR_MODE_STS_MC_MASKr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STS
 * BLOCKS:   RXTXCOM_CKRST_CTRL
 * REGADDR:  0xd08c
 * DESC:     AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     OSR_MODE_PIN     Indicates the status of the pmd_osr_mode input pin.Decoding of pmd_osr_mode[3:0] pin and osr_mode registers are as follows.OSX1          4'd0OSX2          4'd1OSX3          4'd2OSX3P3        4'd3OSX4          4'd4OSX5          4'd5OSX7P5        4'd6OSX8          4'd7OSX8P25       4'd8OSX10         4'd9
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr (0x0000d08c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SIZE 4

/*
 * This structure should be used to declare and program RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_s {
	uint32_t v[1];
	uint32_t rxtxcom_afe_rst_pwrdn_osr_mode_pin_sts[1];
	uint32_t _rxtxcom_afe_rst_pwrdn_osr_mode_pin_sts;
} BCMI_TSCE16_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_t;

#define BCMI_TSCE16_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_CLR(r) (r).rxtxcom_afe_rst_pwrdn_osr_mode_pin_sts[0] = 0
#define BCMI_TSCE16_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SET(r,d) (r).rxtxcom_afe_rst_pwrdn_osr_mode_pin_sts[0] = d
#define BCMI_TSCE16_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_GET(r) (r).rxtxcom_afe_rst_pwrdn_osr_mode_pin_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_OSR_MODE_PINf_GET(r) (((r).rxtxcom_afe_rst_pwrdn_osr_mode_pin_sts[0]) & 0xf)
#define BCMI_TSCE16_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_OSR_MODE_PINf_SET(r,f) (r).rxtxcom_afe_rst_pwrdn_osr_mode_pin_sts[0]=(((r).rxtxcom_afe_rst_pwrdn_osr_mode_pin_sts[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr,(_r._rxtxcom_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_TSCE16_XGXS_WRITE_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr,(_r._rxtxcom_afe_rst_pwrdn_osr_mode_pin_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr,(_r._rxtxcom_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_TSCE16_XGXS_READLN_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_TSCE16_XGXS_WRITELN_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxtxcom_afe_rst_pwrdn_osr_mode_pin_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_TSCE16_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SIZE BCMI_TSCE16_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SIZE
typedef BCMI_TSCE16_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_t RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_t;
#define RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_CLR BCMI_TSCE16_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_CLR
#define RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SET BCMI_TSCE16_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SET
#define RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_GET BCMI_TSCE16_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_GET
#define RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_OSR_MODE_PINf_GET BCMI_TSCE16_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_OSR_MODE_PINf_GET
#define RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_OSR_MODE_PINf_SET BCMI_TSCE16_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_OSR_MODE_PINf_SET
#define READ_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_TSCE16_XGXS_READ_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define WRITE_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_TSCE16_XGXS_WRITE_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define MODIFY_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_TSCE16_XGXS_MODIFY_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define READLN_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_TSCE16_XGXS_READLN_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define WRITELN_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_TSCE16_XGXS_WRITELN_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define WRITEALL_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_TSCE16_XGXS_WRITEALL_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RXTXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RXTXCOM_LN_S_RSTB_CTL
 * BLOCKS:   RXTXCOM_CKRST_CTRL
 * REGADDR:  0xd08e
 * DESC:     LN_S_RSTB_CONTROL
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_S_RSTB        Active Low Lane Soft Reset. If asserted by writing to 1'b0 will reset the registers and datapath for a lane.This soft reset is equivalent to the hard reset input pin pmd_ln_h_rstb_i.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RXTXCOM_LN_S_RSTB_CTLr (0x0000d08e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RXTXCOM_LN_S_RSTB_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXTXCOM_LN_S_RSTB_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_RXTXCOM_LN_S_RSTB_CTLr_s {
	uint32_t v[1];
	uint32_t rxtxcom_ln_s_rstb_ctl[1];
	uint32_t _rxtxcom_ln_s_rstb_ctl;
} BCMI_TSCE16_XGXS_RXTXCOM_LN_S_RSTB_CTLr_t;

#define BCMI_TSCE16_XGXS_RXTXCOM_LN_S_RSTB_CTLr_CLR(r) (r).rxtxcom_ln_s_rstb_ctl[0] = 0
#define BCMI_TSCE16_XGXS_RXTXCOM_LN_S_RSTB_CTLr_SET(r,d) (r).rxtxcom_ln_s_rstb_ctl[0] = d
#define BCMI_TSCE16_XGXS_RXTXCOM_LN_S_RSTB_CTLr_GET(r) (r).rxtxcom_ln_s_rstb_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RXTXCOM_LN_S_RSTB_CTLr_LN_S_RSTBf_GET(r) (((r).rxtxcom_ln_s_rstb_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_RXTXCOM_LN_S_RSTB_CTLr_LN_S_RSTBf_SET(r,f) (r).rxtxcom_ln_s_rstb_ctl[0]=(((r).rxtxcom_ln_s_rstb_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXTXCOM_LN_S_RSTB_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RXTXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXTXCOM_LN_S_RSTB_CTLr,(_r._rxtxcom_ln_s_rstb_ctl))
#define BCMI_TSCE16_XGXS_WRITE_RXTXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_LN_S_RSTB_CTLr,(_r._rxtxcom_ln_s_rstb_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RXTXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_LN_S_RSTB_CTLr,(_r._rxtxcom_ln_s_rstb_ctl))
#define BCMI_TSCE16_XGXS_READLN_RXTXCOM_LN_S_RSTB_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXTXCOM_LN_S_RSTB_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_ln_s_rstb_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_RXTXCOM_LN_S_RSTB_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_LN_S_RSTB_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_ln_s_rstb_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_RXTXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXTXCOM_LN_S_RSTB_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxtxcom_ln_s_rstb_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXTXCOM_LN_S_RSTB_CTLr BCMI_TSCE16_XGXS_RXTXCOM_LN_S_RSTB_CTLr
#define RXTXCOM_LN_S_RSTB_CTLr_SIZE BCMI_TSCE16_XGXS_RXTXCOM_LN_S_RSTB_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_RXTXCOM_LN_S_RSTB_CTLr_t RXTXCOM_LN_S_RSTB_CTLr_t;
#define RXTXCOM_LN_S_RSTB_CTLr_CLR BCMI_TSCE16_XGXS_RXTXCOM_LN_S_RSTB_CTLr_CLR
#define RXTXCOM_LN_S_RSTB_CTLr_SET BCMI_TSCE16_XGXS_RXTXCOM_LN_S_RSTB_CTLr_SET
#define RXTXCOM_LN_S_RSTB_CTLr_GET BCMI_TSCE16_XGXS_RXTXCOM_LN_S_RSTB_CTLr_GET
#define RXTXCOM_LN_S_RSTB_CTLr_LN_S_RSTBf_GET BCMI_TSCE16_XGXS_RXTXCOM_LN_S_RSTB_CTLr_LN_S_RSTBf_GET
#define RXTXCOM_LN_S_RSTB_CTLr_LN_S_RSTBf_SET BCMI_TSCE16_XGXS_RXTXCOM_LN_S_RSTB_CTLr_LN_S_RSTBf_SET
#define READ_RXTXCOM_LN_S_RSTB_CTLr BCMI_TSCE16_XGXS_READ_RXTXCOM_LN_S_RSTB_CTLr
#define WRITE_RXTXCOM_LN_S_RSTB_CTLr BCMI_TSCE16_XGXS_WRITE_RXTXCOM_LN_S_RSTB_CTLr
#define MODIFY_RXTXCOM_LN_S_RSTB_CTLr BCMI_TSCE16_XGXS_MODIFY_RXTXCOM_LN_S_RSTB_CTLr
#define READLN_RXTXCOM_LN_S_RSTB_CTLr BCMI_TSCE16_XGXS_READLN_RXTXCOM_LN_S_RSTB_CTLr
#define WRITELN_RXTXCOM_LN_S_RSTB_CTLr BCMI_TSCE16_XGXS_WRITELN_RXTXCOM_LN_S_RSTB_CTLr
#define WRITEALL_RXTXCOM_LN_S_RSTB_CTLr BCMI_TSCE16_XGXS_WRITEALL_RXTXCOM_LN_S_RSTB_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RXTXCOM_LN_S_RSTB_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_CTL0
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd090
 * DESC:     RX_CTRL_0
 * RESETVAL: 0x1c00 (7168)
 * ACCESS:   R/W
 * FIELDS:
 *     SUM_PSEUDO_DIFF  0: Tail device in the summer is biased by constant-gm bias, 1: Tail device in the summer is pulled up to Vdd amsbus ctrl_out  0:0
 *     RX_CM_SEL        0: Input CM of the CTLE is coming from the Const Gm bias, 1: Input CM of the CTLE is coming from a resistor ladder equal to 5/7*Vdd amsbus ctrl_out  1:1
 *     SIGDET_PWRDN     Signal Detect Power Down, Rx_sigdet_pwrdn in AMS amsbus ctrl_out  2:2
 *     SIGDET_BYPASS    1: Bypass SigDetect output and send 1 at SigDetect output, Rx_sigdet_bypass in AMS amsbus ctrl_out  3:3
 *     RCM_SUM          0: (Default) All the fixed summer load is connected to Vcm, 1: 500-Ohms of the fixed Summer load is connected to Vdd amsbus ctrl_out  4:4
 *     VGA_CM_SEL       Refer to AMS. amsbus ctrl_out  5:5
 *     AMS_SPARE_0_2    ams reserved[8:6] amsbus ctrl_out  8:6
 *     EN_RXCK_TESTPORT test port enable.1: enables the test clock outp/n sent to PLL, En_rxck_testport in AMS amsbus ctrl_out  9:9
 *     EN_RXCK_TEST     RX Test Port Output Rate Selection, En_rxck_test in AMS amsbus ctrl_out  11:10
 *     TERM_CM_ENA      0: Common mode DC floating, 1: Common mode connected to DC voltage, Term_CM_ena in AMS amsbus ctrl_out  12:12
 *     TERM_CMULT_ENA   1: Common mode capacitor multiplier active ON, Term_CMULT_ena in AMS amsbus ctrl_out  13:13
 *     TERM_LOWZGND     1: Input common mode DC value 0, Term_lowZgnd in AMS amsbus ctrl_out  14:14
 *     TERM_LOWZVDD     1: Input common mode DC value VDD, Term_lowZvdd in AMS amsbus ctrl_out  15:15
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_CTL0r (0x0000d090 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program RX_CTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_CTL0r_s {
	uint32_t v[1];
	uint32_t rx_ctl0[1];
	uint32_t _rx_ctl0;
} BCMI_TSCE16_XGXS_RX_CTL0r_t;

#define BCMI_TSCE16_XGXS_RX_CTL0r_CLR(r) (r).rx_ctl0[0] = 0
#define BCMI_TSCE16_XGXS_RX_CTL0r_SET(r,d) (r).rx_ctl0[0] = d
#define BCMI_TSCE16_XGXS_RX_CTL0r_GET(r) (r).rx_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_CTL0r_TERM_LOWZVDDf_GET(r) ((((r).rx_ctl0[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CTL0r_TERM_LOWZVDDf_SET(r,f) (r).rx_ctl0[0]=(((r).rx_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_RX_CTL0r_TERM_LOWZGNDf_GET(r) ((((r).rx_ctl0[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CTL0r_TERM_LOWZGNDf_SET(r,f) (r).rx_ctl0[0]=(((r).rx_ctl0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_RX_CTL0r_TERM_CMULT_ENAf_GET(r) ((((r).rx_ctl0[0]) >> 13) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CTL0r_TERM_CMULT_ENAf_SET(r,f) (r).rx_ctl0[0]=(((r).rx_ctl0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCE16_XGXS_RX_CTL0r_TERM_CM_ENAf_GET(r) ((((r).rx_ctl0[0]) >> 12) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CTL0r_TERM_CM_ENAf_SET(r,f) (r).rx_ctl0[0]=(((r).rx_ctl0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCE16_XGXS_RX_CTL0r_EN_RXCK_TESTf_GET(r) ((((r).rx_ctl0[0]) >> 10) & 0x3)
#define BCMI_TSCE16_XGXS_RX_CTL0r_EN_RXCK_TESTf_SET(r,f) (r).rx_ctl0[0]=(((r).rx_ctl0[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCE16_XGXS_RX_CTL0r_EN_RXCK_TESTPORTf_GET(r) ((((r).rx_ctl0[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CTL0r_EN_RXCK_TESTPORTf_SET(r,f) (r).rx_ctl0[0]=(((r).rx_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_RX_CTL0r_AMS_SPARE_0_2f_GET(r) ((((r).rx_ctl0[0]) >> 6) & 0x7)
#define BCMI_TSCE16_XGXS_RX_CTL0r_AMS_SPARE_0_2f_SET(r,f) (r).rx_ctl0[0]=(((r).rx_ctl0[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_TSCE16_XGXS_RX_CTL0r_VGA_CM_SELf_GET(r) ((((r).rx_ctl0[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CTL0r_VGA_CM_SELf_SET(r,f) (r).rx_ctl0[0]=(((r).rx_ctl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_RX_CTL0r_RCM_SUMf_GET(r) ((((r).rx_ctl0[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CTL0r_RCM_SUMf_SET(r,f) (r).rx_ctl0[0]=(((r).rx_ctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_RX_CTL0r_SIGDET_BYPASSf_GET(r) ((((r).rx_ctl0[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CTL0r_SIGDET_BYPASSf_SET(r,f) (r).rx_ctl0[0]=(((r).rx_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_RX_CTL0r_SIGDET_PWRDNf_GET(r) ((((r).rx_ctl0[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CTL0r_SIGDET_PWRDNf_SET(r,f) (r).rx_ctl0[0]=(((r).rx_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_RX_CTL0r_RX_CM_SELf_GET(r) ((((r).rx_ctl0[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CTL0r_RX_CM_SELf_SET(r,f) (r).rx_ctl0[0]=(((r).rx_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_RX_CTL0r_SUM_PSEUDO_DIFFf_GET(r) (((r).rx_ctl0[0]) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CTL0r_SUM_PSEUDO_DIFFf_SET(r,f) (r).rx_ctl0[0]=(((r).rx_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_CTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_CTL0r,(_r._rx_ctl0))
#define BCMI_TSCE16_XGXS_WRITE_RX_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CTL0r,(_r._rx_ctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CTL0r,(_r._rx_ctl0))
#define BCMI_TSCE16_XGXS_READLN_RX_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ctl0))
#define BCMI_TSCE16_XGXS_WRITELN_RX_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_CTL0r BCMI_TSCE16_XGXS_RX_CTL0r
#define RX_CTL0r_SIZE BCMI_TSCE16_XGXS_RX_CTL0r_SIZE
typedef BCMI_TSCE16_XGXS_RX_CTL0r_t RX_CTL0r_t;
#define RX_CTL0r_CLR BCMI_TSCE16_XGXS_RX_CTL0r_CLR
#define RX_CTL0r_SET BCMI_TSCE16_XGXS_RX_CTL0r_SET
#define RX_CTL0r_GET BCMI_TSCE16_XGXS_RX_CTL0r_GET
#define RX_CTL0r_TERM_LOWZVDDf_GET BCMI_TSCE16_XGXS_RX_CTL0r_TERM_LOWZVDDf_GET
#define RX_CTL0r_TERM_LOWZVDDf_SET BCMI_TSCE16_XGXS_RX_CTL0r_TERM_LOWZVDDf_SET
#define RX_CTL0r_TERM_LOWZGNDf_GET BCMI_TSCE16_XGXS_RX_CTL0r_TERM_LOWZGNDf_GET
#define RX_CTL0r_TERM_LOWZGNDf_SET BCMI_TSCE16_XGXS_RX_CTL0r_TERM_LOWZGNDf_SET
#define RX_CTL0r_TERM_CMULT_ENAf_GET BCMI_TSCE16_XGXS_RX_CTL0r_TERM_CMULT_ENAf_GET
#define RX_CTL0r_TERM_CMULT_ENAf_SET BCMI_TSCE16_XGXS_RX_CTL0r_TERM_CMULT_ENAf_SET
#define RX_CTL0r_TERM_CM_ENAf_GET BCMI_TSCE16_XGXS_RX_CTL0r_TERM_CM_ENAf_GET
#define RX_CTL0r_TERM_CM_ENAf_SET BCMI_TSCE16_XGXS_RX_CTL0r_TERM_CM_ENAf_SET
#define RX_CTL0r_EN_RXCK_TESTf_GET BCMI_TSCE16_XGXS_RX_CTL0r_EN_RXCK_TESTf_GET
#define RX_CTL0r_EN_RXCK_TESTf_SET BCMI_TSCE16_XGXS_RX_CTL0r_EN_RXCK_TESTf_SET
#define RX_CTL0r_EN_RXCK_TESTPORTf_GET BCMI_TSCE16_XGXS_RX_CTL0r_EN_RXCK_TESTPORTf_GET
#define RX_CTL0r_EN_RXCK_TESTPORTf_SET BCMI_TSCE16_XGXS_RX_CTL0r_EN_RXCK_TESTPORTf_SET
#define RX_CTL0r_AMS_SPARE_0_2f_GET BCMI_TSCE16_XGXS_RX_CTL0r_AMS_SPARE_0_2f_GET
#define RX_CTL0r_AMS_SPARE_0_2f_SET BCMI_TSCE16_XGXS_RX_CTL0r_AMS_SPARE_0_2f_SET
#define RX_CTL0r_VGA_CM_SELf_GET BCMI_TSCE16_XGXS_RX_CTL0r_VGA_CM_SELf_GET
#define RX_CTL0r_VGA_CM_SELf_SET BCMI_TSCE16_XGXS_RX_CTL0r_VGA_CM_SELf_SET
#define RX_CTL0r_RCM_SUMf_GET BCMI_TSCE16_XGXS_RX_CTL0r_RCM_SUMf_GET
#define RX_CTL0r_RCM_SUMf_SET BCMI_TSCE16_XGXS_RX_CTL0r_RCM_SUMf_SET
#define RX_CTL0r_SIGDET_BYPASSf_GET BCMI_TSCE16_XGXS_RX_CTL0r_SIGDET_BYPASSf_GET
#define RX_CTL0r_SIGDET_BYPASSf_SET BCMI_TSCE16_XGXS_RX_CTL0r_SIGDET_BYPASSf_SET
#define RX_CTL0r_SIGDET_PWRDNf_GET BCMI_TSCE16_XGXS_RX_CTL0r_SIGDET_PWRDNf_GET
#define RX_CTL0r_SIGDET_PWRDNf_SET BCMI_TSCE16_XGXS_RX_CTL0r_SIGDET_PWRDNf_SET
#define RX_CTL0r_RX_CM_SELf_GET BCMI_TSCE16_XGXS_RX_CTL0r_RX_CM_SELf_GET
#define RX_CTL0r_RX_CM_SELf_SET BCMI_TSCE16_XGXS_RX_CTL0r_RX_CM_SELf_SET
#define RX_CTL0r_SUM_PSEUDO_DIFFf_GET BCMI_TSCE16_XGXS_RX_CTL0r_SUM_PSEUDO_DIFFf_GET
#define RX_CTL0r_SUM_PSEUDO_DIFFf_SET BCMI_TSCE16_XGXS_RX_CTL0r_SUM_PSEUDO_DIFFf_SET
#define READ_RX_CTL0r BCMI_TSCE16_XGXS_READ_RX_CTL0r
#define WRITE_RX_CTL0r BCMI_TSCE16_XGXS_WRITE_RX_CTL0r
#define MODIFY_RX_CTL0r BCMI_TSCE16_XGXS_MODIFY_RX_CTL0r
#define READLN_RX_CTL0r BCMI_TSCE16_XGXS_READLN_RX_CTL0r
#define WRITELN_RX_CTL0r BCMI_TSCE16_XGXS_WRITELN_RX_CTL0r
#define WRITEALL_RX_CTL0r BCMI_TSCE16_XGXS_WRITEALL_RX_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_CTL1
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd091
 * DESC:     RX_CTRL_1
 * RESETVAL: 0x1048 (4168)
 * ACCESS:   R/W
 * FIELDS:
 *     VGA_OUT_IDLE     Not use. Please use vga_op_short from dsc register amsbus ctrl_out  16:16
 *     VGA_EN_HGAIN     Increases the gain of the VGA amsbus ctrl_out  17:17
 *     CURR_CTLE        Controls the current biasing for the RX CTLE amsbus ctrl_out  20:18
 *     CURR_PI          Controls the current biasing for the RX Phase Interpolators (Peak, Zero, Eyemon), Curr_pi in AMS amsbus ctrl_out  23:21
 *     AMS_SPARE_1_0    ams reserved[26:24] amsbus ctrl_out  26:24
 *     CURR_DFE_2       Controls the current biasing for DFE TAPS amsbus ctrl_out  29:27
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_CTL1r (0x0000d091 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program RX_CTL1.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_CTL1r_s {
	uint32_t v[1];
	uint32_t rx_ctl1[1];
	uint32_t _rx_ctl1;
} BCMI_TSCE16_XGXS_RX_CTL1r_t;

#define BCMI_TSCE16_XGXS_RX_CTL1r_CLR(r) (r).rx_ctl1[0] = 0
#define BCMI_TSCE16_XGXS_RX_CTL1r_SET(r,d) (r).rx_ctl1[0] = d
#define BCMI_TSCE16_XGXS_RX_CTL1r_GET(r) (r).rx_ctl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_CTL1r_CURR_DFE_2f_GET(r) ((((r).rx_ctl1[0]) >> 11) & 0x7)
#define BCMI_TSCE16_XGXS_RX_CTL1r_CURR_DFE_2f_SET(r,f) (r).rx_ctl1[0]=(((r).rx_ctl1[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_TSCE16_XGXS_RX_CTL1r_AMS_SPARE_1_0f_GET(r) ((((r).rx_ctl1[0]) >> 8) & 0x7)
#define BCMI_TSCE16_XGXS_RX_CTL1r_AMS_SPARE_1_0f_SET(r,f) (r).rx_ctl1[0]=(((r).rx_ctl1[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_TSCE16_XGXS_RX_CTL1r_CURR_PIf_GET(r) ((((r).rx_ctl1[0]) >> 5) & 0x7)
#define BCMI_TSCE16_XGXS_RX_CTL1r_CURR_PIf_SET(r,f) (r).rx_ctl1[0]=(((r).rx_ctl1[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5)) | (7 << (16 + 5))
#define BCMI_TSCE16_XGXS_RX_CTL1r_CURR_CTLEf_GET(r) ((((r).rx_ctl1[0]) >> 2) & 0x7)
#define BCMI_TSCE16_XGXS_RX_CTL1r_CURR_CTLEf_SET(r,f) (r).rx_ctl1[0]=(((r).rx_ctl1[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2)) | (7 << (16 + 2))
#define BCMI_TSCE16_XGXS_RX_CTL1r_VGA_EN_HGAINf_GET(r) ((((r).rx_ctl1[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CTL1r_VGA_EN_HGAINf_SET(r,f) (r).rx_ctl1[0]=(((r).rx_ctl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_RX_CTL1r_VGA_OUT_IDLEf_GET(r) (((r).rx_ctl1[0]) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CTL1r_VGA_OUT_IDLEf_SET(r,f) (r).rx_ctl1[0]=(((r).rx_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_CTL1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_CTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_CTL1r,(_r._rx_ctl1))
#define BCMI_TSCE16_XGXS_WRITE_RX_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CTL1r,(_r._rx_ctl1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CTL1r,(_r._rx_ctl1))
#define BCMI_TSCE16_XGXS_READLN_RX_CTL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ctl1))
#define BCMI_TSCE16_XGXS_WRITELN_RX_CTL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ctl1))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_CTL1r BCMI_TSCE16_XGXS_RX_CTL1r
#define RX_CTL1r_SIZE BCMI_TSCE16_XGXS_RX_CTL1r_SIZE
typedef BCMI_TSCE16_XGXS_RX_CTL1r_t RX_CTL1r_t;
#define RX_CTL1r_CLR BCMI_TSCE16_XGXS_RX_CTL1r_CLR
#define RX_CTL1r_SET BCMI_TSCE16_XGXS_RX_CTL1r_SET
#define RX_CTL1r_GET BCMI_TSCE16_XGXS_RX_CTL1r_GET
#define RX_CTL1r_CURR_DFE_2f_GET BCMI_TSCE16_XGXS_RX_CTL1r_CURR_DFE_2f_GET
#define RX_CTL1r_CURR_DFE_2f_SET BCMI_TSCE16_XGXS_RX_CTL1r_CURR_DFE_2f_SET
#define RX_CTL1r_AMS_SPARE_1_0f_GET BCMI_TSCE16_XGXS_RX_CTL1r_AMS_SPARE_1_0f_GET
#define RX_CTL1r_AMS_SPARE_1_0f_SET BCMI_TSCE16_XGXS_RX_CTL1r_AMS_SPARE_1_0f_SET
#define RX_CTL1r_CURR_PIf_GET BCMI_TSCE16_XGXS_RX_CTL1r_CURR_PIf_GET
#define RX_CTL1r_CURR_PIf_SET BCMI_TSCE16_XGXS_RX_CTL1r_CURR_PIf_SET
#define RX_CTL1r_CURR_CTLEf_GET BCMI_TSCE16_XGXS_RX_CTL1r_CURR_CTLEf_GET
#define RX_CTL1r_CURR_CTLEf_SET BCMI_TSCE16_XGXS_RX_CTL1r_CURR_CTLEf_SET
#define RX_CTL1r_VGA_EN_HGAINf_GET BCMI_TSCE16_XGXS_RX_CTL1r_VGA_EN_HGAINf_GET
#define RX_CTL1r_VGA_EN_HGAINf_SET BCMI_TSCE16_XGXS_RX_CTL1r_VGA_EN_HGAINf_SET
#define RX_CTL1r_VGA_OUT_IDLEf_GET BCMI_TSCE16_XGXS_RX_CTL1r_VGA_OUT_IDLEf_GET
#define RX_CTL1r_VGA_OUT_IDLEf_SET BCMI_TSCE16_XGXS_RX_CTL1r_VGA_OUT_IDLEf_SET
#define READ_RX_CTL1r BCMI_TSCE16_XGXS_READ_RX_CTL1r
#define WRITE_RX_CTL1r BCMI_TSCE16_XGXS_WRITE_RX_CTL1r
#define MODIFY_RX_CTL1r BCMI_TSCE16_XGXS_MODIFY_RX_CTL1r
#define READLN_RX_CTL1r BCMI_TSCE16_XGXS_READLN_RX_CTL1r
#define WRITELN_RX_CTL1r BCMI_TSCE16_XGXS_WRITELN_RX_CTL1r
#define WRITEALL_RX_CTL1r BCMI_TSCE16_XGXS_WRITEALL_RX_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_CTL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_CTL2
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd092
 * DESC:     RX_CTRL_2
 * RESETVAL: 0x7e92 (32402)
 * ACCESS:   R/W
 * FIELDS:
 *     CURR_DFE_1       Controls the current biasing for DFE TAPS amsbus ctrl_out  32:30
 *     CURR_DFE_SUMMER  Controls the current biasing for DFE Summer amsbus ctrl_out  35:33
 *     CURR_VGA         Controls the current biasing for VGA amsbus ctrl_out  38:36
 *     EN_DFE_TAP_FB    Enable the Feedback to control each tap of dfe amsbus ctrl_out  43:39
 *     AMS_SPARE_2_0    ams reserved[45:44] amsbus ctrl_out  45:44
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_CTL2r (0x0000d092 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program RX_CTL2.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_CTL2r_s {
	uint32_t v[1];
	uint32_t rx_ctl2[1];
	uint32_t _rx_ctl2;
} BCMI_TSCE16_XGXS_RX_CTL2r_t;

#define BCMI_TSCE16_XGXS_RX_CTL2r_CLR(r) (r).rx_ctl2[0] = 0
#define BCMI_TSCE16_XGXS_RX_CTL2r_SET(r,d) (r).rx_ctl2[0] = d
#define BCMI_TSCE16_XGXS_RX_CTL2r_GET(r) (r).rx_ctl2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_CTL2r_AMS_SPARE_2_0f_GET(r) ((((r).rx_ctl2[0]) >> 14) & 0x3)
#define BCMI_TSCE16_XGXS_RX_CTL2r_AMS_SPARE_2_0f_SET(r,f) (r).rx_ctl2[0]=(((r).rx_ctl2[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCE16_XGXS_RX_CTL2r_EN_DFE_TAP_FBf_GET(r) ((((r).rx_ctl2[0]) >> 9) & 0x1f)
#define BCMI_TSCE16_XGXS_RX_CTL2r_EN_DFE_TAP_FBf_SET(r,f) (r).rx_ctl2[0]=(((r).rx_ctl2[0] & ~((uint32_t)0x1f << 9)) | ((((uint32_t)f) & 0x1f) << 9)) | (31 << (16 + 9))
#define BCMI_TSCE16_XGXS_RX_CTL2r_CURR_VGAf_GET(r) ((((r).rx_ctl2[0]) >> 6) & 0x7)
#define BCMI_TSCE16_XGXS_RX_CTL2r_CURR_VGAf_SET(r,f) (r).rx_ctl2[0]=(((r).rx_ctl2[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_TSCE16_XGXS_RX_CTL2r_CURR_DFE_SUMMERf_GET(r) ((((r).rx_ctl2[0]) >> 3) & 0x7)
#define BCMI_TSCE16_XGXS_RX_CTL2r_CURR_DFE_SUMMERf_SET(r,f) (r).rx_ctl2[0]=(((r).rx_ctl2[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3)) | (7 << (16 + 3))
#define BCMI_TSCE16_XGXS_RX_CTL2r_CURR_DFE_1f_GET(r) (((r).rx_ctl2[0]) & 0x7)
#define BCMI_TSCE16_XGXS_RX_CTL2r_CURR_DFE_1f_SET(r,f) (r).rx_ctl2[0]=(((r).rx_ctl2[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access RX_CTL2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_CTL2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_CTL2r,(_r._rx_ctl2))
#define BCMI_TSCE16_XGXS_WRITE_RX_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CTL2r,(_r._rx_ctl2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CTL2r,(_r._rx_ctl2))
#define BCMI_TSCE16_XGXS_READLN_RX_CTL2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ctl2))
#define BCMI_TSCE16_XGXS_WRITELN_RX_CTL2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ctl2))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_CTL2r BCMI_TSCE16_XGXS_RX_CTL2r
#define RX_CTL2r_SIZE BCMI_TSCE16_XGXS_RX_CTL2r_SIZE
typedef BCMI_TSCE16_XGXS_RX_CTL2r_t RX_CTL2r_t;
#define RX_CTL2r_CLR BCMI_TSCE16_XGXS_RX_CTL2r_CLR
#define RX_CTL2r_SET BCMI_TSCE16_XGXS_RX_CTL2r_SET
#define RX_CTL2r_GET BCMI_TSCE16_XGXS_RX_CTL2r_GET
#define RX_CTL2r_AMS_SPARE_2_0f_GET BCMI_TSCE16_XGXS_RX_CTL2r_AMS_SPARE_2_0f_GET
#define RX_CTL2r_AMS_SPARE_2_0f_SET BCMI_TSCE16_XGXS_RX_CTL2r_AMS_SPARE_2_0f_SET
#define RX_CTL2r_EN_DFE_TAP_FBf_GET BCMI_TSCE16_XGXS_RX_CTL2r_EN_DFE_TAP_FBf_GET
#define RX_CTL2r_EN_DFE_TAP_FBf_SET BCMI_TSCE16_XGXS_RX_CTL2r_EN_DFE_TAP_FBf_SET
#define RX_CTL2r_CURR_VGAf_GET BCMI_TSCE16_XGXS_RX_CTL2r_CURR_VGAf_GET
#define RX_CTL2r_CURR_VGAf_SET BCMI_TSCE16_XGXS_RX_CTL2r_CURR_VGAf_SET
#define RX_CTL2r_CURR_DFE_SUMMERf_GET BCMI_TSCE16_XGXS_RX_CTL2r_CURR_DFE_SUMMERf_GET
#define RX_CTL2r_CURR_DFE_SUMMERf_SET BCMI_TSCE16_XGXS_RX_CTL2r_CURR_DFE_SUMMERf_SET
#define RX_CTL2r_CURR_DFE_1f_GET BCMI_TSCE16_XGXS_RX_CTL2r_CURR_DFE_1f_GET
#define RX_CTL2r_CURR_DFE_1f_SET BCMI_TSCE16_XGXS_RX_CTL2r_CURR_DFE_1f_SET
#define READ_RX_CTL2r BCMI_TSCE16_XGXS_READ_RX_CTL2r
#define WRITE_RX_CTL2r BCMI_TSCE16_XGXS_WRITE_RX_CTL2r
#define MODIFY_RX_CTL2r BCMI_TSCE16_XGXS_MODIFY_RX_CTL2r
#define READLN_RX_CTL2r BCMI_TSCE16_XGXS_READLN_RX_CTL2r
#define WRITELN_RX_CTL2r BCMI_TSCE16_XGXS_WRITELN_RX_CTL2r
#define WRITEALL_RX_CTL2r BCMI_TSCE16_XGXS_WRITEALL_RX_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_CTL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_CTL3
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd093
 * DESC:     RX_CTRL_3
 * RESETVAL: 0x288f (10383)
 * ACCESS:   R/W
 * FIELDS:
 *     EN_VCCTRL        1: enables common mode control for DFE signal path amsbus ctrl_out  46:46
 *     EN_CLK33         1: enables the divide by 33 output clock amsbus ctrl_out  47:47
 *     EN_CLK16         1: enables the divide by 16 output clock amsbus ctrl_out  48:48
 *     EN_20B_DEMUX     1: Endable 2 to 20 Demux; 0: Enables 2 to 10 Demux amsbus ctrl_out  49:49
 *     RX_DFE_OS2X_MODE Enables OS2X mode for DFE amsbus ctrl_out  50:50
 *     OS2X_MODE_EVEN_ODD Allow even or odd path to be selected for OSR2X mode amsbus ctrl_out  51:51
 *     CURR_VDDR_AFE    Controls the current biasing for the RX afe amsbus ctrl_out  54:52
 *     CURR_SIGDET      Current control for the Signal detect, Curr_sigdet in AMS amsbus ctrl_out  57:55
 *     I4DEADZONE       1 = adds additional half LSB current to each DFE tap 1-5 amsbus ctrl_out  58:58
 *     SELI1P25DFE      1: increase all DFE tap current 1.25x, sel_i1p25dfe in AMS amsbus ctrl_out  59:59
 *     LL_EN            1: Low latency mode enabled in RX, LowLatency_ena in AMS amsbus ctrl_out  60:60
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_CTL3r (0x0000d093 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program RX_CTL3.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_CTL3r_s {
	uint32_t v[1];
	uint32_t rx_ctl3[1];
	uint32_t _rx_ctl3;
} BCMI_TSCE16_XGXS_RX_CTL3r_t;

#define BCMI_TSCE16_XGXS_RX_CTL3r_CLR(r) (r).rx_ctl3[0] = 0
#define BCMI_TSCE16_XGXS_RX_CTL3r_SET(r,d) (r).rx_ctl3[0] = d
#define BCMI_TSCE16_XGXS_RX_CTL3r_GET(r) (r).rx_ctl3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_CTL3r_LL_ENf_GET(r) ((((r).rx_ctl3[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CTL3r_LL_ENf_SET(r,f) (r).rx_ctl3[0]=(((r).rx_ctl3[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_RX_CTL3r_SELI1P25DFEf_GET(r) ((((r).rx_ctl3[0]) >> 13) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CTL3r_SELI1P25DFEf_SET(r,f) (r).rx_ctl3[0]=(((r).rx_ctl3[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCE16_XGXS_RX_CTL3r_I4DEADZONEf_GET(r) ((((r).rx_ctl3[0]) >> 12) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CTL3r_I4DEADZONEf_SET(r,f) (r).rx_ctl3[0]=(((r).rx_ctl3[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCE16_XGXS_RX_CTL3r_CURR_SIGDETf_GET(r) ((((r).rx_ctl3[0]) >> 9) & 0x7)
#define BCMI_TSCE16_XGXS_RX_CTL3r_CURR_SIGDETf_SET(r,f) (r).rx_ctl3[0]=(((r).rx_ctl3[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9)) | (7 << (16 + 9))
#define BCMI_TSCE16_XGXS_RX_CTL3r_CURR_VDDR_AFEf_GET(r) ((((r).rx_ctl3[0]) >> 6) & 0x7)
#define BCMI_TSCE16_XGXS_RX_CTL3r_CURR_VDDR_AFEf_SET(r,f) (r).rx_ctl3[0]=(((r).rx_ctl3[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_TSCE16_XGXS_RX_CTL3r_OS2X_MODE_EVEN_ODDf_GET(r) ((((r).rx_ctl3[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CTL3r_OS2X_MODE_EVEN_ODDf_SET(r,f) (r).rx_ctl3[0]=(((r).rx_ctl3[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_RX_CTL3r_RX_DFE_OS2X_MODEf_GET(r) ((((r).rx_ctl3[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CTL3r_RX_DFE_OS2X_MODEf_SET(r,f) (r).rx_ctl3[0]=(((r).rx_ctl3[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_RX_CTL3r_EN_20B_DEMUXf_GET(r) ((((r).rx_ctl3[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CTL3r_EN_20B_DEMUXf_SET(r,f) (r).rx_ctl3[0]=(((r).rx_ctl3[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_RX_CTL3r_EN_CLK16f_GET(r) ((((r).rx_ctl3[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CTL3r_EN_CLK16f_SET(r,f) (r).rx_ctl3[0]=(((r).rx_ctl3[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_RX_CTL3r_EN_CLK33f_GET(r) ((((r).rx_ctl3[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CTL3r_EN_CLK33f_SET(r,f) (r).rx_ctl3[0]=(((r).rx_ctl3[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_RX_CTL3r_EN_VCCTRLf_GET(r) (((r).rx_ctl3[0]) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CTL3r_EN_VCCTRLf_SET(r,f) (r).rx_ctl3[0]=(((r).rx_ctl3[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_CTL3.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_CTL3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_CTL3r,(_r._rx_ctl3))
#define BCMI_TSCE16_XGXS_WRITE_RX_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CTL3r,(_r._rx_ctl3)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CTL3r,(_r._rx_ctl3))
#define BCMI_TSCE16_XGXS_READLN_RX_CTL3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ctl3))
#define BCMI_TSCE16_XGXS_WRITELN_RX_CTL3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ctl3))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_ctl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_CTL3r BCMI_TSCE16_XGXS_RX_CTL3r
#define RX_CTL3r_SIZE BCMI_TSCE16_XGXS_RX_CTL3r_SIZE
typedef BCMI_TSCE16_XGXS_RX_CTL3r_t RX_CTL3r_t;
#define RX_CTL3r_CLR BCMI_TSCE16_XGXS_RX_CTL3r_CLR
#define RX_CTL3r_SET BCMI_TSCE16_XGXS_RX_CTL3r_SET
#define RX_CTL3r_GET BCMI_TSCE16_XGXS_RX_CTL3r_GET
#define RX_CTL3r_LL_ENf_GET BCMI_TSCE16_XGXS_RX_CTL3r_LL_ENf_GET
#define RX_CTL3r_LL_ENf_SET BCMI_TSCE16_XGXS_RX_CTL3r_LL_ENf_SET
#define RX_CTL3r_SELI1P25DFEf_GET BCMI_TSCE16_XGXS_RX_CTL3r_SELI1P25DFEf_GET
#define RX_CTL3r_SELI1P25DFEf_SET BCMI_TSCE16_XGXS_RX_CTL3r_SELI1P25DFEf_SET
#define RX_CTL3r_I4DEADZONEf_GET BCMI_TSCE16_XGXS_RX_CTL3r_I4DEADZONEf_GET
#define RX_CTL3r_I4DEADZONEf_SET BCMI_TSCE16_XGXS_RX_CTL3r_I4DEADZONEf_SET
#define RX_CTL3r_CURR_SIGDETf_GET BCMI_TSCE16_XGXS_RX_CTL3r_CURR_SIGDETf_GET
#define RX_CTL3r_CURR_SIGDETf_SET BCMI_TSCE16_XGXS_RX_CTL3r_CURR_SIGDETf_SET
#define RX_CTL3r_CURR_VDDR_AFEf_GET BCMI_TSCE16_XGXS_RX_CTL3r_CURR_VDDR_AFEf_GET
#define RX_CTL3r_CURR_VDDR_AFEf_SET BCMI_TSCE16_XGXS_RX_CTL3r_CURR_VDDR_AFEf_SET
#define RX_CTL3r_OS2X_MODE_EVEN_ODDf_GET BCMI_TSCE16_XGXS_RX_CTL3r_OS2X_MODE_EVEN_ODDf_GET
#define RX_CTL3r_OS2X_MODE_EVEN_ODDf_SET BCMI_TSCE16_XGXS_RX_CTL3r_OS2X_MODE_EVEN_ODDf_SET
#define RX_CTL3r_RX_DFE_OS2X_MODEf_GET BCMI_TSCE16_XGXS_RX_CTL3r_RX_DFE_OS2X_MODEf_GET
#define RX_CTL3r_RX_DFE_OS2X_MODEf_SET BCMI_TSCE16_XGXS_RX_CTL3r_RX_DFE_OS2X_MODEf_SET
#define RX_CTL3r_EN_20B_DEMUXf_GET BCMI_TSCE16_XGXS_RX_CTL3r_EN_20B_DEMUXf_GET
#define RX_CTL3r_EN_20B_DEMUXf_SET BCMI_TSCE16_XGXS_RX_CTL3r_EN_20B_DEMUXf_SET
#define RX_CTL3r_EN_CLK16f_GET BCMI_TSCE16_XGXS_RX_CTL3r_EN_CLK16f_GET
#define RX_CTL3r_EN_CLK16f_SET BCMI_TSCE16_XGXS_RX_CTL3r_EN_CLK16f_SET
#define RX_CTL3r_EN_CLK33f_GET BCMI_TSCE16_XGXS_RX_CTL3r_EN_CLK33f_GET
#define RX_CTL3r_EN_CLK33f_SET BCMI_TSCE16_XGXS_RX_CTL3r_EN_CLK33f_SET
#define RX_CTL3r_EN_VCCTRLf_GET BCMI_TSCE16_XGXS_RX_CTL3r_EN_VCCTRLf_GET
#define RX_CTL3r_EN_VCCTRLf_SET BCMI_TSCE16_XGXS_RX_CTL3r_EN_VCCTRLf_SET
#define READ_RX_CTL3r BCMI_TSCE16_XGXS_READ_RX_CTL3r
#define WRITE_RX_CTL3r BCMI_TSCE16_XGXS_WRITE_RX_CTL3r
#define MODIFY_RX_CTL3r BCMI_TSCE16_XGXS_MODIFY_RX_CTL3r
#define READLN_RX_CTL3r BCMI_TSCE16_XGXS_READLN_RX_CTL3r
#define WRITELN_RX_CTL3r BCMI_TSCE16_XGXS_WRITELN_RX_CTL3r
#define WRITEALL_RX_CTL3r BCMI_TSCE16_XGXS_WRITEALL_RX_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_CTL3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_CTL4
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd094
 * DESC:     RX_CTRL_4
 * RESETVAL: 0x20 (32)
 * ACCESS:   R/W
 * FIELDS:
 *     RECCLKDIV        Recovered clock divider = 1/(div3o4o5 * (recclkdiv<5:1> + 1)) amsbus ctrl_out  65:61
 *     DIV3O4O5         {00, 01, 10, 11} = {N/A, /3, /4, /5} amsbus ctrl_out  67:66
 *     EN_RECCLKDIV     enables the additional recovered clock dividers amsbus ctrl_out  68:68
 *     AMS_SPARE_4_0    AMS reserved[71:69] amsbus ctrl_out  71:69
 *     OC_2X            1: doubles the DC offset range amsbus ctrl_out  72:72
 *     VGA_PON          vga rescal bits, dfs changed to 0 for vgapon rescal offset amsbus ctrl_out  76:73
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_CTL4r (0x0000d094 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program RX_CTL4.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_CTL4r_s {
	uint32_t v[1];
	uint32_t rx_ctl4[1];
	uint32_t _rx_ctl4;
} BCMI_TSCE16_XGXS_RX_CTL4r_t;

#define BCMI_TSCE16_XGXS_RX_CTL4r_CLR(r) (r).rx_ctl4[0] = 0
#define BCMI_TSCE16_XGXS_RX_CTL4r_SET(r,d) (r).rx_ctl4[0] = d
#define BCMI_TSCE16_XGXS_RX_CTL4r_GET(r) (r).rx_ctl4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_CTL4r_VGA_PONf_GET(r) ((((r).rx_ctl4[0]) >> 12) & 0xf)
#define BCMI_TSCE16_XGXS_RX_CTL4r_VGA_PONf_SET(r,f) (r).rx_ctl4[0]=(((r).rx_ctl4[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCE16_XGXS_RX_CTL4r_OC_2Xf_GET(r) ((((r).rx_ctl4[0]) >> 11) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CTL4r_OC_2Xf_SET(r,f) (r).rx_ctl4[0]=(((r).rx_ctl4[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCE16_XGXS_RX_CTL4r_AMS_SPARE_4_0f_GET(r) ((((r).rx_ctl4[0]) >> 8) & 0x7)
#define BCMI_TSCE16_XGXS_RX_CTL4r_AMS_SPARE_4_0f_SET(r,f) (r).rx_ctl4[0]=(((r).rx_ctl4[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_TSCE16_XGXS_RX_CTL4r_EN_RECCLKDIVf_GET(r) ((((r).rx_ctl4[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CTL4r_EN_RECCLKDIVf_SET(r,f) (r).rx_ctl4[0]=(((r).rx_ctl4[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_RX_CTL4r_DIV3O4O5f_GET(r) ((((r).rx_ctl4[0]) >> 5) & 0x3)
#define BCMI_TSCE16_XGXS_RX_CTL4r_DIV3O4O5f_SET(r,f) (r).rx_ctl4[0]=(((r).rx_ctl4[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5)) | (3 << (16 + 5))
#define BCMI_TSCE16_XGXS_RX_CTL4r_RECCLKDIVf_GET(r) (((r).rx_ctl4[0]) & 0x1f)
#define BCMI_TSCE16_XGXS_RX_CTL4r_RECCLKDIVf_SET(r,f) (r).rx_ctl4[0]=(((r).rx_ctl4[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access RX_CTL4.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_CTL4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_CTL4r,(_r._rx_ctl4))
#define BCMI_TSCE16_XGXS_WRITE_RX_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CTL4r,(_r._rx_ctl4)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CTL4r,(_r._rx_ctl4))
#define BCMI_TSCE16_XGXS_READLN_RX_CTL4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ctl4))
#define BCMI_TSCE16_XGXS_WRITELN_RX_CTL4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ctl4))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_ctl4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_CTL4r BCMI_TSCE16_XGXS_RX_CTL4r
#define RX_CTL4r_SIZE BCMI_TSCE16_XGXS_RX_CTL4r_SIZE
typedef BCMI_TSCE16_XGXS_RX_CTL4r_t RX_CTL4r_t;
#define RX_CTL4r_CLR BCMI_TSCE16_XGXS_RX_CTL4r_CLR
#define RX_CTL4r_SET BCMI_TSCE16_XGXS_RX_CTL4r_SET
#define RX_CTL4r_GET BCMI_TSCE16_XGXS_RX_CTL4r_GET
#define RX_CTL4r_VGA_PONf_GET BCMI_TSCE16_XGXS_RX_CTL4r_VGA_PONf_GET
#define RX_CTL4r_VGA_PONf_SET BCMI_TSCE16_XGXS_RX_CTL4r_VGA_PONf_SET
#define RX_CTL4r_OC_2Xf_GET BCMI_TSCE16_XGXS_RX_CTL4r_OC_2Xf_GET
#define RX_CTL4r_OC_2Xf_SET BCMI_TSCE16_XGXS_RX_CTL4r_OC_2Xf_SET
#define RX_CTL4r_AMS_SPARE_4_0f_GET BCMI_TSCE16_XGXS_RX_CTL4r_AMS_SPARE_4_0f_GET
#define RX_CTL4r_AMS_SPARE_4_0f_SET BCMI_TSCE16_XGXS_RX_CTL4r_AMS_SPARE_4_0f_SET
#define RX_CTL4r_EN_RECCLKDIVf_GET BCMI_TSCE16_XGXS_RX_CTL4r_EN_RECCLKDIVf_GET
#define RX_CTL4r_EN_RECCLKDIVf_SET BCMI_TSCE16_XGXS_RX_CTL4r_EN_RECCLKDIVf_SET
#define RX_CTL4r_DIV3O4O5f_GET BCMI_TSCE16_XGXS_RX_CTL4r_DIV3O4O5f_GET
#define RX_CTL4r_DIV3O4O5f_SET BCMI_TSCE16_XGXS_RX_CTL4r_DIV3O4O5f_SET
#define RX_CTL4r_RECCLKDIVf_GET BCMI_TSCE16_XGXS_RX_CTL4r_RECCLKDIVf_GET
#define RX_CTL4r_RECCLKDIVf_SET BCMI_TSCE16_XGXS_RX_CTL4r_RECCLKDIVf_SET
#define READ_RX_CTL4r BCMI_TSCE16_XGXS_READ_RX_CTL4r
#define WRITE_RX_CTL4r BCMI_TSCE16_XGXS_WRITE_RX_CTL4r
#define MODIFY_RX_CTL4r BCMI_TSCE16_XGXS_MODIFY_RX_CTL4r
#define READLN_RX_CTL4r BCMI_TSCE16_XGXS_READLN_RX_CTL4r
#define WRITELN_RX_CTL4r BCMI_TSCE16_XGXS_WRITELN_RX_CTL4r
#define WRITEALL_RX_CTL4r BCMI_TSCE16_XGXS_WRITEALL_RX_CTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_CTL4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_CTL5
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd095
 * DESC:     RX_CTRL_5
 * RESETVAL: 0xfa0 (4000)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_PON           reciever rescal bits, dfs changed to 0 for rxpon rescal offset amsbus ctrl_out  80:77
 *     CURR_IN_OFFSET   controls current biasing for input offset correction, Curr_in_offset in AMS amsbus ctrl_out  83:81
 *     CTLE_GAIN_CTRL   Controls for DC gain adjustment for CTLE amsbus ctrl_out  87:84
 *     EN_DFECLK        1:normal mode, 0=non-dfe mode amsbus ctrl_out  88:88
 *     DCC1_PHASE_FLIP  1: Flips the clock phase from slicer to dfe tap dcc1 for debug purpose. 0 : normal operation amsbus ctrl_out  89:89
 *     PI_PD            1: powers down the the phase interpolator amsbus ctrl_out  90:90
 *     SLCR_CALIB_RANGE_SEL To select the slicer calibration range amsbus ctrl_out  91:91
 *     DCC2_PHASE_FLIP  1: Flips the clock phase from slicer to dfe tap dcc2 for debug purpose. 0 : normal operation amsbus ctrl_out  92:92
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_CTL5r (0x0000d095 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_CTL5r_SIZE 4

/*
 * This structure should be used to declare and program RX_CTL5.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_CTL5r_s {
	uint32_t v[1];
	uint32_t rx_ctl5[1];
	uint32_t _rx_ctl5;
} BCMI_TSCE16_XGXS_RX_CTL5r_t;

#define BCMI_TSCE16_XGXS_RX_CTL5r_CLR(r) (r).rx_ctl5[0] = 0
#define BCMI_TSCE16_XGXS_RX_CTL5r_SET(r,d) (r).rx_ctl5[0] = d
#define BCMI_TSCE16_XGXS_RX_CTL5r_GET(r) (r).rx_ctl5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_CTL5r_DCC2_PHASE_FLIPf_GET(r) ((((r).rx_ctl5[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CTL5r_DCC2_PHASE_FLIPf_SET(r,f) (r).rx_ctl5[0]=(((r).rx_ctl5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_RX_CTL5r_SLCR_CALIB_RANGE_SELf_GET(r) ((((r).rx_ctl5[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CTL5r_SLCR_CALIB_RANGE_SELf_SET(r,f) (r).rx_ctl5[0]=(((r).rx_ctl5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_RX_CTL5r_PI_PDf_GET(r) ((((r).rx_ctl5[0]) >> 13) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CTL5r_PI_PDf_SET(r,f) (r).rx_ctl5[0]=(((r).rx_ctl5[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCE16_XGXS_RX_CTL5r_DCC1_PHASE_FLIPf_GET(r) ((((r).rx_ctl5[0]) >> 12) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CTL5r_DCC1_PHASE_FLIPf_SET(r,f) (r).rx_ctl5[0]=(((r).rx_ctl5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCE16_XGXS_RX_CTL5r_EN_DFECLKf_GET(r) ((((r).rx_ctl5[0]) >> 11) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CTL5r_EN_DFECLKf_SET(r,f) (r).rx_ctl5[0]=(((r).rx_ctl5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCE16_XGXS_RX_CTL5r_CTLE_GAIN_CTRLf_GET(r) ((((r).rx_ctl5[0]) >> 7) & 0xf)
#define BCMI_TSCE16_XGXS_RX_CTL5r_CTLE_GAIN_CTRLf_SET(r,f) (r).rx_ctl5[0]=(((r).rx_ctl5[0] & ~((uint32_t)0xf << 7)) | ((((uint32_t)f) & 0xf) << 7)) | (15 << (16 + 7))
#define BCMI_TSCE16_XGXS_RX_CTL5r_CURR_IN_OFFSETf_GET(r) ((((r).rx_ctl5[0]) >> 4) & 0x7)
#define BCMI_TSCE16_XGXS_RX_CTL5r_CURR_IN_OFFSETf_SET(r,f) (r).rx_ctl5[0]=(((r).rx_ctl5[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_TSCE16_XGXS_RX_CTL5r_RX_PONf_GET(r) (((r).rx_ctl5[0]) & 0xf)
#define BCMI_TSCE16_XGXS_RX_CTL5r_RX_PONf_SET(r,f) (r).rx_ctl5[0]=(((r).rx_ctl5[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access RX_CTL5.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_CTL5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_CTL5r,(_r._rx_ctl5))
#define BCMI_TSCE16_XGXS_WRITE_RX_CTL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CTL5r,(_r._rx_ctl5)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_CTL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CTL5r,(_r._rx_ctl5))
#define BCMI_TSCE16_XGXS_READLN_RX_CTL5r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ctl5))
#define BCMI_TSCE16_XGXS_WRITELN_RX_CTL5r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ctl5))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_CTL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_ctl5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_CTL5r BCMI_TSCE16_XGXS_RX_CTL5r
#define RX_CTL5r_SIZE BCMI_TSCE16_XGXS_RX_CTL5r_SIZE
typedef BCMI_TSCE16_XGXS_RX_CTL5r_t RX_CTL5r_t;
#define RX_CTL5r_CLR BCMI_TSCE16_XGXS_RX_CTL5r_CLR
#define RX_CTL5r_SET BCMI_TSCE16_XGXS_RX_CTL5r_SET
#define RX_CTL5r_GET BCMI_TSCE16_XGXS_RX_CTL5r_GET
#define RX_CTL5r_DCC2_PHASE_FLIPf_GET BCMI_TSCE16_XGXS_RX_CTL5r_DCC2_PHASE_FLIPf_GET
#define RX_CTL5r_DCC2_PHASE_FLIPf_SET BCMI_TSCE16_XGXS_RX_CTL5r_DCC2_PHASE_FLIPf_SET
#define RX_CTL5r_SLCR_CALIB_RANGE_SELf_GET BCMI_TSCE16_XGXS_RX_CTL5r_SLCR_CALIB_RANGE_SELf_GET
#define RX_CTL5r_SLCR_CALIB_RANGE_SELf_SET BCMI_TSCE16_XGXS_RX_CTL5r_SLCR_CALIB_RANGE_SELf_SET
#define RX_CTL5r_PI_PDf_GET BCMI_TSCE16_XGXS_RX_CTL5r_PI_PDf_GET
#define RX_CTL5r_PI_PDf_SET BCMI_TSCE16_XGXS_RX_CTL5r_PI_PDf_SET
#define RX_CTL5r_DCC1_PHASE_FLIPf_GET BCMI_TSCE16_XGXS_RX_CTL5r_DCC1_PHASE_FLIPf_GET
#define RX_CTL5r_DCC1_PHASE_FLIPf_SET BCMI_TSCE16_XGXS_RX_CTL5r_DCC1_PHASE_FLIPf_SET
#define RX_CTL5r_EN_DFECLKf_GET BCMI_TSCE16_XGXS_RX_CTL5r_EN_DFECLKf_GET
#define RX_CTL5r_EN_DFECLKf_SET BCMI_TSCE16_XGXS_RX_CTL5r_EN_DFECLKf_SET
#define RX_CTL5r_CTLE_GAIN_CTRLf_GET BCMI_TSCE16_XGXS_RX_CTL5r_CTLE_GAIN_CTRLf_GET
#define RX_CTL5r_CTLE_GAIN_CTRLf_SET BCMI_TSCE16_XGXS_RX_CTL5r_CTLE_GAIN_CTRLf_SET
#define RX_CTL5r_CURR_IN_OFFSETf_GET BCMI_TSCE16_XGXS_RX_CTL5r_CURR_IN_OFFSETf_GET
#define RX_CTL5r_CURR_IN_OFFSETf_SET BCMI_TSCE16_XGXS_RX_CTL5r_CURR_IN_OFFSETf_SET
#define RX_CTL5r_RX_PONf_GET BCMI_TSCE16_XGXS_RX_CTL5r_RX_PONf_GET
#define RX_CTL5r_RX_PONf_SET BCMI_TSCE16_XGXS_RX_CTL5r_RX_PONf_SET
#define READ_RX_CTL5r BCMI_TSCE16_XGXS_READ_RX_CTL5r
#define WRITE_RX_CTL5r BCMI_TSCE16_XGXS_WRITE_RX_CTL5r
#define MODIFY_RX_CTL5r BCMI_TSCE16_XGXS_MODIFY_RX_CTL5r
#define READLN_RX_CTL5r BCMI_TSCE16_XGXS_READLN_RX_CTL5r
#define WRITELN_RX_CTL5r BCMI_TSCE16_XGXS_WRITELN_RX_CTL5r
#define WRITEALL_RX_CTL5r BCMI_TSCE16_XGXS_WRITEALL_RX_CTL5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_CTL5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_CTL6
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd096
 * DESC:     RX_CTRL_6
 * RESETVAL: 0x1078 (4216)
 * ACCESS:   R/W
 * FIELDS:
 *     M1_SIGN          To control the polarity of m1 threshold adjust amsbus ctrl_out  93:93
 *     HIZ_1            amsbus ctrl_out  94:94
 *     EN_SIGDET_CALIB  1: Enable signal detect calibration amsbus ctrl_out  95:95
 *     SUM_GAIN_CTRL    amsbus ctrl_out  99:96
 *     SIGDET_CALIBRATION_SELECT During signal detect calibration, the output of D2C is delivered to the output pin o_rx_sigdet. amsbus ctrl_out  100:100
 *     SIGDET_OFFSET_CORRECTION_POS Adjust the offset of the positive level detection. (Default: XFI 10.3125Gbps) amsbus ctrl_out  105:101
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_CTL6r (0x0000d096 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_CTL6r_SIZE 4

/*
 * This structure should be used to declare and program RX_CTL6.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_CTL6r_s {
	uint32_t v[1];
	uint32_t rx_ctl6[1];
	uint32_t _rx_ctl6;
} BCMI_TSCE16_XGXS_RX_CTL6r_t;

#define BCMI_TSCE16_XGXS_RX_CTL6r_CLR(r) (r).rx_ctl6[0] = 0
#define BCMI_TSCE16_XGXS_RX_CTL6r_SET(r,d) (r).rx_ctl6[0] = d
#define BCMI_TSCE16_XGXS_RX_CTL6r_GET(r) (r).rx_ctl6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_CTL6r_SIGDET_OFFSET_CORRECTION_POSf_GET(r) ((((r).rx_ctl6[0]) >> 8) & 0x1f)
#define BCMI_TSCE16_XGXS_RX_CTL6r_SIGDET_OFFSET_CORRECTION_POSf_SET(r,f) (r).rx_ctl6[0]=(((r).rx_ctl6[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_TSCE16_XGXS_RX_CTL6r_SIGDET_CALIBRATION_SELECTf_GET(r) ((((r).rx_ctl6[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CTL6r_SIGDET_CALIBRATION_SELECTf_SET(r,f) (r).rx_ctl6[0]=(((r).rx_ctl6[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_RX_CTL6r_SUM_GAIN_CTRLf_GET(r) ((((r).rx_ctl6[0]) >> 3) & 0xf)
#define BCMI_TSCE16_XGXS_RX_CTL6r_SUM_GAIN_CTRLf_SET(r,f) (r).rx_ctl6[0]=(((r).rx_ctl6[0] & ~((uint32_t)0xf << 3)) | ((((uint32_t)f) & 0xf) << 3)) | (15 << (16 + 3))
#define BCMI_TSCE16_XGXS_RX_CTL6r_EN_SIGDET_CALIBf_GET(r) ((((r).rx_ctl6[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CTL6r_EN_SIGDET_CALIBf_SET(r,f) (r).rx_ctl6[0]=(((r).rx_ctl6[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_RX_CTL6r_HIZ_1f_GET(r) ((((r).rx_ctl6[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CTL6r_HIZ_1f_SET(r,f) (r).rx_ctl6[0]=(((r).rx_ctl6[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_RX_CTL6r_M1_SIGNf_GET(r) (((r).rx_ctl6[0]) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CTL6r_M1_SIGNf_SET(r,f) (r).rx_ctl6[0]=(((r).rx_ctl6[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_CTL6.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_CTL6r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_CTL6r,(_r._rx_ctl6))
#define BCMI_TSCE16_XGXS_WRITE_RX_CTL6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CTL6r,(_r._rx_ctl6)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_CTL6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CTL6r,(_r._rx_ctl6))
#define BCMI_TSCE16_XGXS_READLN_RX_CTL6r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ctl6))
#define BCMI_TSCE16_XGXS_WRITELN_RX_CTL6r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ctl6))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_CTL6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_ctl6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_CTL6r BCMI_TSCE16_XGXS_RX_CTL6r
#define RX_CTL6r_SIZE BCMI_TSCE16_XGXS_RX_CTL6r_SIZE
typedef BCMI_TSCE16_XGXS_RX_CTL6r_t RX_CTL6r_t;
#define RX_CTL6r_CLR BCMI_TSCE16_XGXS_RX_CTL6r_CLR
#define RX_CTL6r_SET BCMI_TSCE16_XGXS_RX_CTL6r_SET
#define RX_CTL6r_GET BCMI_TSCE16_XGXS_RX_CTL6r_GET
#define RX_CTL6r_SIGDET_OFFSET_CORRECTION_POSf_GET BCMI_TSCE16_XGXS_RX_CTL6r_SIGDET_OFFSET_CORRECTION_POSf_GET
#define RX_CTL6r_SIGDET_OFFSET_CORRECTION_POSf_SET BCMI_TSCE16_XGXS_RX_CTL6r_SIGDET_OFFSET_CORRECTION_POSf_SET
#define RX_CTL6r_SIGDET_CALIBRATION_SELECTf_GET BCMI_TSCE16_XGXS_RX_CTL6r_SIGDET_CALIBRATION_SELECTf_GET
#define RX_CTL6r_SIGDET_CALIBRATION_SELECTf_SET BCMI_TSCE16_XGXS_RX_CTL6r_SIGDET_CALIBRATION_SELECTf_SET
#define RX_CTL6r_SUM_GAIN_CTRLf_GET BCMI_TSCE16_XGXS_RX_CTL6r_SUM_GAIN_CTRLf_GET
#define RX_CTL6r_SUM_GAIN_CTRLf_SET BCMI_TSCE16_XGXS_RX_CTL6r_SUM_GAIN_CTRLf_SET
#define RX_CTL6r_EN_SIGDET_CALIBf_GET BCMI_TSCE16_XGXS_RX_CTL6r_EN_SIGDET_CALIBf_GET
#define RX_CTL6r_EN_SIGDET_CALIBf_SET BCMI_TSCE16_XGXS_RX_CTL6r_EN_SIGDET_CALIBf_SET
#define RX_CTL6r_HIZ_1f_GET BCMI_TSCE16_XGXS_RX_CTL6r_HIZ_1f_GET
#define RX_CTL6r_HIZ_1f_SET BCMI_TSCE16_XGXS_RX_CTL6r_HIZ_1f_SET
#define RX_CTL6r_M1_SIGNf_GET BCMI_TSCE16_XGXS_RX_CTL6r_M1_SIGNf_GET
#define RX_CTL6r_M1_SIGNf_SET BCMI_TSCE16_XGXS_RX_CTL6r_M1_SIGNf_SET
#define READ_RX_CTL6r BCMI_TSCE16_XGXS_READ_RX_CTL6r
#define WRITE_RX_CTL6r BCMI_TSCE16_XGXS_WRITE_RX_CTL6r
#define MODIFY_RX_CTL6r BCMI_TSCE16_XGXS_MODIFY_RX_CTL6r
#define READLN_RX_CTL6r BCMI_TSCE16_XGXS_READLN_RX_CTL6r
#define WRITELN_RX_CTL6r BCMI_TSCE16_XGXS_WRITELN_RX_CTL6r
#define WRITEALL_RX_CTL6r BCMI_TSCE16_XGXS_WRITEALL_RX_CTL6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_CTL6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_CTL7
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd097
 * DESC:     RX_CTRL_7
 * RESETVAL: 0x130 (304)
 * ACCESS:   R/W
 * FIELDS:
 *     SIGDET_OFFSET_CORRECTION_NEG Adjust the offset of the negative level detection. (Default: XFI 10.3125Gbps) amsbus ctrl_out  110:106
 *     SIGDET_THRESHOLD Not used. Please use sigdet_threshold from sigdet module, Rx_sigdet_threshold in AMS amsbus ctrl_out  115:111
 *     AMS_SPARE_7_0    ams_reserved[119:116] amsbus ctrl_out  119:116
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_CTL7r (0x0000d097 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_CTL7r_SIZE 4

/*
 * This structure should be used to declare and program RX_CTL7.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_CTL7r_s {
	uint32_t v[1];
	uint32_t rx_ctl7[1];
	uint32_t _rx_ctl7;
} BCMI_TSCE16_XGXS_RX_CTL7r_t;

#define BCMI_TSCE16_XGXS_RX_CTL7r_CLR(r) (r).rx_ctl7[0] = 0
#define BCMI_TSCE16_XGXS_RX_CTL7r_SET(r,d) (r).rx_ctl7[0] = d
#define BCMI_TSCE16_XGXS_RX_CTL7r_GET(r) (r).rx_ctl7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_CTL7r_AMS_SPARE_7_0f_GET(r) ((((r).rx_ctl7[0]) >> 10) & 0xf)
#define BCMI_TSCE16_XGXS_RX_CTL7r_AMS_SPARE_7_0f_SET(r,f) (r).rx_ctl7[0]=(((r).rx_ctl7[0] & ~((uint32_t)0xf << 10)) | ((((uint32_t)f) & 0xf) << 10)) | (15 << (16 + 10))
#define BCMI_TSCE16_XGXS_RX_CTL7r_SIGDET_THRESHOLDf_GET(r) ((((r).rx_ctl7[0]) >> 5) & 0x1f)
#define BCMI_TSCE16_XGXS_RX_CTL7r_SIGDET_THRESHOLDf_SET(r,f) (r).rx_ctl7[0]=(((r).rx_ctl7[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_TSCE16_XGXS_RX_CTL7r_SIGDET_OFFSET_CORRECTION_NEGf_GET(r) (((r).rx_ctl7[0]) & 0x1f)
#define BCMI_TSCE16_XGXS_RX_CTL7r_SIGDET_OFFSET_CORRECTION_NEGf_SET(r,f) (r).rx_ctl7[0]=(((r).rx_ctl7[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access RX_CTL7.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_CTL7r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_CTL7r,(_r._rx_ctl7))
#define BCMI_TSCE16_XGXS_WRITE_RX_CTL7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CTL7r,(_r._rx_ctl7)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_CTL7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CTL7r,(_r._rx_ctl7))
#define BCMI_TSCE16_XGXS_READLN_RX_CTL7r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ctl7))
#define BCMI_TSCE16_XGXS_WRITELN_RX_CTL7r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ctl7))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_CTL7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_ctl7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_CTL7r BCMI_TSCE16_XGXS_RX_CTL7r
#define RX_CTL7r_SIZE BCMI_TSCE16_XGXS_RX_CTL7r_SIZE
typedef BCMI_TSCE16_XGXS_RX_CTL7r_t RX_CTL7r_t;
#define RX_CTL7r_CLR BCMI_TSCE16_XGXS_RX_CTL7r_CLR
#define RX_CTL7r_SET BCMI_TSCE16_XGXS_RX_CTL7r_SET
#define RX_CTL7r_GET BCMI_TSCE16_XGXS_RX_CTL7r_GET
#define RX_CTL7r_AMS_SPARE_7_0f_GET BCMI_TSCE16_XGXS_RX_CTL7r_AMS_SPARE_7_0f_GET
#define RX_CTL7r_AMS_SPARE_7_0f_SET BCMI_TSCE16_XGXS_RX_CTL7r_AMS_SPARE_7_0f_SET
#define RX_CTL7r_SIGDET_THRESHOLDf_GET BCMI_TSCE16_XGXS_RX_CTL7r_SIGDET_THRESHOLDf_GET
#define RX_CTL7r_SIGDET_THRESHOLDf_SET BCMI_TSCE16_XGXS_RX_CTL7r_SIGDET_THRESHOLDf_SET
#define RX_CTL7r_SIGDET_OFFSET_CORRECTION_NEGf_GET BCMI_TSCE16_XGXS_RX_CTL7r_SIGDET_OFFSET_CORRECTION_NEGf_GET
#define RX_CTL7r_SIGDET_OFFSET_CORRECTION_NEGf_SET BCMI_TSCE16_XGXS_RX_CTL7r_SIGDET_OFFSET_CORRECTION_NEGf_SET
#define READ_RX_CTL7r BCMI_TSCE16_XGXS_READ_RX_CTL7r
#define WRITE_RX_CTL7r BCMI_TSCE16_XGXS_WRITE_RX_CTL7r
#define MODIFY_RX_CTL7r BCMI_TSCE16_XGXS_MODIFY_RX_CTL7r
#define READLN_RX_CTL7r BCMI_TSCE16_XGXS_READLN_RX_CTL7r
#define WRITELN_RX_CTL7r BCMI_TSCE16_XGXS_WRITELN_RX_CTL7r
#define WRITEALL_RX_CTL7r BCMI_TSCE16_XGXS_WRITEALL_RX_CTL7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_CTL7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_INT
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd098
 * DESC:     RX_CTRL_INT
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     VGAPON_SEL       Force select AMS vgapon else select vgapon_int(sum of external rescal and AMS vgapon)
 *     RXPON_SEL        Force select AMS rxpon else select rxpon_int (sum of external rescal and AMS rxpon )
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_INTr (0x0000d098 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_INTr_SIZE 4

/*
 * This structure should be used to declare and program RX_INT.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_INTr_s {
	uint32_t v[1];
	uint32_t rx_int[1];
	uint32_t _rx_int;
} BCMI_TSCE16_XGXS_RX_INTr_t;

#define BCMI_TSCE16_XGXS_RX_INTr_CLR(r) (r).rx_int[0] = 0
#define BCMI_TSCE16_XGXS_RX_INTr_SET(r,d) (r).rx_int[0] = d
#define BCMI_TSCE16_XGXS_RX_INTr_GET(r) (r).rx_int[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_INTr_RXPON_SELf_GET(r) ((((r).rx_int[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_RX_INTr_RXPON_SELf_SET(r,f) (r).rx_int[0]=(((r).rx_int[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_RX_INTr_VGAPON_SELf_GET(r) (((r).rx_int[0]) & 0x1)
#define BCMI_TSCE16_XGXS_RX_INTr_VGAPON_SELf_SET(r,f) (r).rx_int[0]=(((r).rx_int[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_INT.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_INTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_INTr,(_r._rx_int))
#define BCMI_TSCE16_XGXS_WRITE_RX_INTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_INTr,(_r._rx_int)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_INTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_INTr,(_r._rx_int))
#define BCMI_TSCE16_XGXS_READLN_RX_INTr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_INTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_int))
#define BCMI_TSCE16_XGXS_WRITELN_RX_INTr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_INTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_int))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_INTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_INTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_int))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_INTr BCMI_TSCE16_XGXS_RX_INTr
#define RX_INTr_SIZE BCMI_TSCE16_XGXS_RX_INTr_SIZE
typedef BCMI_TSCE16_XGXS_RX_INTr_t RX_INTr_t;
#define RX_INTr_CLR BCMI_TSCE16_XGXS_RX_INTr_CLR
#define RX_INTr_SET BCMI_TSCE16_XGXS_RX_INTr_SET
#define RX_INTr_GET BCMI_TSCE16_XGXS_RX_INTr_GET
#define RX_INTr_RXPON_SELf_GET BCMI_TSCE16_XGXS_RX_INTr_RXPON_SELf_GET
#define RX_INTr_RXPON_SELf_SET BCMI_TSCE16_XGXS_RX_INTr_RXPON_SELf_SET
#define RX_INTr_VGAPON_SELf_GET BCMI_TSCE16_XGXS_RX_INTr_VGAPON_SELf_GET
#define RX_INTr_VGAPON_SELf_SET BCMI_TSCE16_XGXS_RX_INTr_VGAPON_SELf_SET
#define READ_RX_INTr BCMI_TSCE16_XGXS_READ_RX_INTr
#define WRITE_RX_INTr BCMI_TSCE16_XGXS_WRITE_RX_INTr
#define MODIFY_RX_INTr BCMI_TSCE16_XGXS_MODIFY_RX_INTr
#define READLN_RX_INTr BCMI_TSCE16_XGXS_READLN_RX_INTr
#define WRITELN_RX_INTr BCMI_TSCE16_XGXS_WRITELN_RX_INTr
#define WRITEALL_RX_INTr BCMI_TSCE16_XGXS_WRITEALL_RX_INTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_INTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_STS
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd099
 * DESC:     RX_STS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RXPON_MUX        rxpon at AFE interface
 *     VGAPON_MUX       vgapon at AFE interface
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_STSr (0x0000d099 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_STSr_SIZE 4

/*
 * This structure should be used to declare and program RX_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_STSr_s {
	uint32_t v[1];
	uint32_t rx_sts[1];
	uint32_t _rx_sts;
} BCMI_TSCE16_XGXS_RX_STSr_t;

#define BCMI_TSCE16_XGXS_RX_STSr_CLR(r) (r).rx_sts[0] = 0
#define BCMI_TSCE16_XGXS_RX_STSr_SET(r,d) (r).rx_sts[0] = d
#define BCMI_TSCE16_XGXS_RX_STSr_GET(r) (r).rx_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_STSr_VGAPON_MUXf_GET(r) ((((r).rx_sts[0]) >> 4) & 0xf)
#define BCMI_TSCE16_XGXS_RX_STSr_VGAPON_MUXf_SET(r,f) (r).rx_sts[0]=(((r).rx_sts[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_TSCE16_XGXS_RX_STSr_RXPON_MUXf_GET(r) (((r).rx_sts[0]) & 0xf)
#define BCMI_TSCE16_XGXS_RX_STSr_RXPON_MUXf_SET(r,f) (r).rx_sts[0]=(((r).rx_sts[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access RX_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_STSr,(_r._rx_sts))
#define BCMI_TSCE16_XGXS_WRITE_RX_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_STSr,(_r._rx_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_STSr,(_r._rx_sts))
#define BCMI_TSCE16_XGXS_READLN_RX_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_sts))
#define BCMI_TSCE16_XGXS_WRITELN_RX_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_STSr BCMI_TSCE16_XGXS_RX_STSr
#define RX_STSr_SIZE BCMI_TSCE16_XGXS_RX_STSr_SIZE
typedef BCMI_TSCE16_XGXS_RX_STSr_t RX_STSr_t;
#define RX_STSr_CLR BCMI_TSCE16_XGXS_RX_STSr_CLR
#define RX_STSr_SET BCMI_TSCE16_XGXS_RX_STSr_SET
#define RX_STSr_GET BCMI_TSCE16_XGXS_RX_STSr_GET
#define RX_STSr_VGAPON_MUXf_GET BCMI_TSCE16_XGXS_RX_STSr_VGAPON_MUXf_GET
#define RX_STSr_VGAPON_MUXf_SET BCMI_TSCE16_XGXS_RX_STSr_VGAPON_MUXf_SET
#define RX_STSr_RXPON_MUXf_GET BCMI_TSCE16_XGXS_RX_STSr_RXPON_MUXf_GET
#define RX_STSr_RXPON_MUXf_SET BCMI_TSCE16_XGXS_RX_STSr_RXPON_MUXf_SET
#define READ_RX_STSr BCMI_TSCE16_XGXS_READ_RX_STSr
#define WRITE_RX_STSr BCMI_TSCE16_XGXS_WRITE_RX_STSr
#define MODIFY_RX_STSr BCMI_TSCE16_XGXS_MODIFY_RX_STSr
#define READLN_RX_STSr BCMI_TSCE16_XGXS_READLN_RX_STSr
#define WRITELN_RX_STSr BCMI_TSCE16_XGXS_WRITELN_RX_STSr
#define WRITEALL_RX_STSr BCMI_TSCE16_XGXS_WRITEALL_RX_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_CTL0
 * BLOCKS:   AMS_TX
 * REGADDR:  0xd0a0
 * DESC:     TX_CTRL_0
 * RESETVAL: 0x2800 (10240)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PWRDN         power down TX. AC-JTAG should still work even if tx is powered down. amsbus ctrl_out  0:0
 *     TICKSEL          Local timing adjustment for loading of buffered 20-bit data into MUX 20:2, step=1/5 of 20T. amsbus ctrl_out  2:1
 *     TX_PON           Resistive Calibration Bits , can be used as offset. amsbus ctrl_out  6:3
 *     ENABLE_OS_2      1: Subsamples data from the low speed mux to the FIR in order to have the TX FIR 1-UI apart. [16]&[7] not high at same time amsbus ctrl_out  7:7
 *     LL_SELPATH_TX    1: enables low latency path in the TX. Controlled by auto data path select as well. lowlatency_selectpathtx in AMS amsbus ctrl_out  8:8
 *     LL_POLARITY_FLIP 1: In the low latecy mode, inverts the polarity of the data received. lowlatency_polarity_flip in AMS. amsbus ctrl_out  9:9
 *     LL_FIFO_ZERO_OUT 1: in the low latency mode the fifo output is forced to 0. TX output is 0. lowlatency_fifo_ctrl in AMS. amsbus ctrl_out  10:10
 *     LL_FIFO_CTRL     fifo depth control. see AMS. lowlatency_fifo_ctrl in AMS amsbus ctrl_out  13:11
 *     TX_FIFO_RESETB   Not use, please use afe_tx_fifo_rstb from TXPI module amsbus ctrl_out  14:14
 *     LOWLATENCY_EN    FIFO and phase detector is enabled. amsbus ctrl_out  15:15
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_CTL0r (0x0000d0a0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program TX_CTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_CTL0r_s {
	uint32_t v[1];
	uint32_t tx_ctl0[1];
	uint32_t _tx_ctl0;
} BCMI_TSCE16_XGXS_TX_CTL0r_t;

#define BCMI_TSCE16_XGXS_TX_CTL0r_CLR(r) (r).tx_ctl0[0] = 0
#define BCMI_TSCE16_XGXS_TX_CTL0r_SET(r,d) (r).tx_ctl0[0] = d
#define BCMI_TSCE16_XGXS_TX_CTL0r_GET(r) (r).tx_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_CTL0r_LOWLATENCY_ENf_GET(r) ((((r).tx_ctl0[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_TX_CTL0r_LOWLATENCY_ENf_SET(r,f) (r).tx_ctl0[0]=(((r).tx_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_TX_CTL0r_TX_FIFO_RESETBf_GET(r) ((((r).tx_ctl0[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_TX_CTL0r_TX_FIFO_RESETBf_SET(r,f) (r).tx_ctl0[0]=(((r).tx_ctl0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_TX_CTL0r_LL_FIFO_CTRLf_GET(r) ((((r).tx_ctl0[0]) >> 11) & 0x7)
#define BCMI_TSCE16_XGXS_TX_CTL0r_LL_FIFO_CTRLf_SET(r,f) (r).tx_ctl0[0]=(((r).tx_ctl0[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_TSCE16_XGXS_TX_CTL0r_LL_FIFO_ZERO_OUTf_GET(r) ((((r).tx_ctl0[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_TX_CTL0r_LL_FIFO_ZERO_OUTf_SET(r,f) (r).tx_ctl0[0]=(((r).tx_ctl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_TX_CTL0r_LL_POLARITY_FLIPf_GET(r) ((((r).tx_ctl0[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_TX_CTL0r_LL_POLARITY_FLIPf_SET(r,f) (r).tx_ctl0[0]=(((r).tx_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_TX_CTL0r_LL_SELPATH_TXf_GET(r) ((((r).tx_ctl0[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_TX_CTL0r_LL_SELPATH_TXf_SET(r,f) (r).tx_ctl0[0]=(((r).tx_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_TX_CTL0r_ENABLE_OS_2f_GET(r) ((((r).tx_ctl0[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_TX_CTL0r_ENABLE_OS_2f_SET(r,f) (r).tx_ctl0[0]=(((r).tx_ctl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_TX_CTL0r_TX_PONf_GET(r) ((((r).tx_ctl0[0]) >> 3) & 0xf)
#define BCMI_TSCE16_XGXS_TX_CTL0r_TX_PONf_SET(r,f) (r).tx_ctl0[0]=(((r).tx_ctl0[0] & ~((uint32_t)0xf << 3)) | ((((uint32_t)f) & 0xf) << 3)) | (15 << (16 + 3))
#define BCMI_TSCE16_XGXS_TX_CTL0r_TICKSELf_GET(r) ((((r).tx_ctl0[0]) >> 1) & 0x3)
#define BCMI_TSCE16_XGXS_TX_CTL0r_TICKSELf_SET(r,f) (r).tx_ctl0[0]=(((r).tx_ctl0[0] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1)) | (3 << (16 + 1))
#define BCMI_TSCE16_XGXS_TX_CTL0r_TX_PWRDNf_GET(r) (((r).tx_ctl0[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TX_CTL0r_TX_PWRDNf_SET(r,f) (r).tx_ctl0[0]=(((r).tx_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_CTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_CTL0r,(_r._tx_ctl0))
#define BCMI_TSCE16_XGXS_WRITE_TX_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL0r,(_r._tx_ctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL0r,(_r._tx_ctl0))
#define BCMI_TSCE16_XGXS_READLN_TX_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ctl0))
#define BCMI_TSCE16_XGXS_WRITELN_TX_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_CTL0r BCMI_TSCE16_XGXS_TX_CTL0r
#define TX_CTL0r_SIZE BCMI_TSCE16_XGXS_TX_CTL0r_SIZE
typedef BCMI_TSCE16_XGXS_TX_CTL0r_t TX_CTL0r_t;
#define TX_CTL0r_CLR BCMI_TSCE16_XGXS_TX_CTL0r_CLR
#define TX_CTL0r_SET BCMI_TSCE16_XGXS_TX_CTL0r_SET
#define TX_CTL0r_GET BCMI_TSCE16_XGXS_TX_CTL0r_GET
#define TX_CTL0r_LOWLATENCY_ENf_GET BCMI_TSCE16_XGXS_TX_CTL0r_LOWLATENCY_ENf_GET
#define TX_CTL0r_LOWLATENCY_ENf_SET BCMI_TSCE16_XGXS_TX_CTL0r_LOWLATENCY_ENf_SET
#define TX_CTL0r_TX_FIFO_RESETBf_GET BCMI_TSCE16_XGXS_TX_CTL0r_TX_FIFO_RESETBf_GET
#define TX_CTL0r_TX_FIFO_RESETBf_SET BCMI_TSCE16_XGXS_TX_CTL0r_TX_FIFO_RESETBf_SET
#define TX_CTL0r_LL_FIFO_CTRLf_GET BCMI_TSCE16_XGXS_TX_CTL0r_LL_FIFO_CTRLf_GET
#define TX_CTL0r_LL_FIFO_CTRLf_SET BCMI_TSCE16_XGXS_TX_CTL0r_LL_FIFO_CTRLf_SET
#define TX_CTL0r_LL_FIFO_ZERO_OUTf_GET BCMI_TSCE16_XGXS_TX_CTL0r_LL_FIFO_ZERO_OUTf_GET
#define TX_CTL0r_LL_FIFO_ZERO_OUTf_SET BCMI_TSCE16_XGXS_TX_CTL0r_LL_FIFO_ZERO_OUTf_SET
#define TX_CTL0r_LL_POLARITY_FLIPf_GET BCMI_TSCE16_XGXS_TX_CTL0r_LL_POLARITY_FLIPf_GET
#define TX_CTL0r_LL_POLARITY_FLIPf_SET BCMI_TSCE16_XGXS_TX_CTL0r_LL_POLARITY_FLIPf_SET
#define TX_CTL0r_LL_SELPATH_TXf_GET BCMI_TSCE16_XGXS_TX_CTL0r_LL_SELPATH_TXf_GET
#define TX_CTL0r_LL_SELPATH_TXf_SET BCMI_TSCE16_XGXS_TX_CTL0r_LL_SELPATH_TXf_SET
#define TX_CTL0r_ENABLE_OS_2f_GET BCMI_TSCE16_XGXS_TX_CTL0r_ENABLE_OS_2f_GET
#define TX_CTL0r_ENABLE_OS_2f_SET BCMI_TSCE16_XGXS_TX_CTL0r_ENABLE_OS_2f_SET
#define TX_CTL0r_TX_PONf_GET BCMI_TSCE16_XGXS_TX_CTL0r_TX_PONf_GET
#define TX_CTL0r_TX_PONf_SET BCMI_TSCE16_XGXS_TX_CTL0r_TX_PONf_SET
#define TX_CTL0r_TICKSELf_GET BCMI_TSCE16_XGXS_TX_CTL0r_TICKSELf_GET
#define TX_CTL0r_TICKSELf_SET BCMI_TSCE16_XGXS_TX_CTL0r_TICKSELf_SET
#define TX_CTL0r_TX_PWRDNf_GET BCMI_TSCE16_XGXS_TX_CTL0r_TX_PWRDNf_GET
#define TX_CTL0r_TX_PWRDNf_SET BCMI_TSCE16_XGXS_TX_CTL0r_TX_PWRDNf_SET
#define READ_TX_CTL0r BCMI_TSCE16_XGXS_READ_TX_CTL0r
#define WRITE_TX_CTL0r BCMI_TSCE16_XGXS_WRITE_TX_CTL0r
#define MODIFY_TX_CTL0r BCMI_TSCE16_XGXS_MODIFY_TX_CTL0r
#define READLN_TX_CTL0r BCMI_TSCE16_XGXS_READLN_TX_CTL0r
#define WRITELN_TX_CTL0r BCMI_TSCE16_XGXS_WRITELN_TX_CTL0r
#define WRITEALL_TX_CTL0r BCMI_TSCE16_XGXS_WRITEALL_TX_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_CTL1
 * BLOCKS:   AMS_TX
 * REGADDR:  0xd0a1
 * DESC:     TX_CTRL_1
 * RESETVAL: 0x744 (1860)
 * ACCESS:   R/W
 * FIELDS:
 *     ENABLE_OS_4      1: Subsamples data from the low speed mux to the FIR in order to have the TX FIR 1-UI apart. [16]&[7] not high at same time amsbus ctrl_out  16:16
 *     EN_HIGH_CURRENT  Enables 2X (high) current for IDLE block. 0 - disabled, 1 - enabled amsbus ctrl_out  17:17
 *     RXDTCT_TH_SEL    Controls the threshold for the RXdetect. FOR USE IN PCIE-GEN3 MODE amsbus ctrl_out  19:18
 *     CNTRL_RXDETECT_EN 1:Enables RXDetect. CNTRL bit is ORed with direct control pin. FOR USE IN PCIE-GEN3 MODE amsbus ctrl_out  20:20
 *     TESTSEL          TX Test Clock output Selection amsbus ctrl_out  22:21
 *     TESTCLK_ENA      Enables TX test clock output into test port, Testclk_en in AMS amsbus ctrl_out  23:23
 *     EN_WCLK16        Enable 16T clock amsbus ctrl_out  24:24
 *     EN_WCLK20        Enable 20T clock amsbus ctrl_out  25:25
 *     EN_WCLK33        Enable 33T clock amsbus ctrl_out  26:26
 *     EN_SLOW          enable slew rate control amsbus ctrl_out  30:27
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_CTL1r (0x0000d0a1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program TX_CTL1.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_CTL1r_s {
	uint32_t v[1];
	uint32_t tx_ctl1[1];
	uint32_t _tx_ctl1;
} BCMI_TSCE16_XGXS_TX_CTL1r_t;

#define BCMI_TSCE16_XGXS_TX_CTL1r_CLR(r) (r).tx_ctl1[0] = 0
#define BCMI_TSCE16_XGXS_TX_CTL1r_SET(r,d) (r).tx_ctl1[0] = d
#define BCMI_TSCE16_XGXS_TX_CTL1r_GET(r) (r).tx_ctl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_CTL1r_EN_SLOWf_GET(r) ((((r).tx_ctl1[0]) >> 11) & 0xf)
#define BCMI_TSCE16_XGXS_TX_CTL1r_EN_SLOWf_SET(r,f) (r).tx_ctl1[0]=(((r).tx_ctl1[0] & ~((uint32_t)0xf << 11)) | ((((uint32_t)f) & 0xf) << 11)) | (15 << (16 + 11))
#define BCMI_TSCE16_XGXS_TX_CTL1r_EN_WCLK33f_GET(r) ((((r).tx_ctl1[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_TX_CTL1r_EN_WCLK33f_SET(r,f) (r).tx_ctl1[0]=(((r).tx_ctl1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_TX_CTL1r_EN_WCLK20f_GET(r) ((((r).tx_ctl1[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_TX_CTL1r_EN_WCLK20f_SET(r,f) (r).tx_ctl1[0]=(((r).tx_ctl1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_TX_CTL1r_EN_WCLK16f_GET(r) ((((r).tx_ctl1[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_TX_CTL1r_EN_WCLK16f_SET(r,f) (r).tx_ctl1[0]=(((r).tx_ctl1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_TX_CTL1r_TESTCLK_ENAf_GET(r) ((((r).tx_ctl1[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_TX_CTL1r_TESTCLK_ENAf_SET(r,f) (r).tx_ctl1[0]=(((r).tx_ctl1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_TX_CTL1r_TESTSELf_GET(r) ((((r).tx_ctl1[0]) >> 5) & 0x3)
#define BCMI_TSCE16_XGXS_TX_CTL1r_TESTSELf_SET(r,f) (r).tx_ctl1[0]=(((r).tx_ctl1[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5)) | (3 << (16 + 5))
#define BCMI_TSCE16_XGXS_TX_CTL1r_CNTRL_RXDETECT_ENf_GET(r) ((((r).tx_ctl1[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_TX_CTL1r_CNTRL_RXDETECT_ENf_SET(r,f) (r).tx_ctl1[0]=(((r).tx_ctl1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_TX_CTL1r_RXDTCT_TH_SELf_GET(r) ((((r).tx_ctl1[0]) >> 2) & 0x3)
#define BCMI_TSCE16_XGXS_TX_CTL1r_RXDTCT_TH_SELf_SET(r,f) (r).tx_ctl1[0]=(((r).tx_ctl1[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCE16_XGXS_TX_CTL1r_EN_HIGH_CURRENTf_GET(r) ((((r).tx_ctl1[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_TX_CTL1r_EN_HIGH_CURRENTf_SET(r,f) (r).tx_ctl1[0]=(((r).tx_ctl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_TX_CTL1r_ENABLE_OS_4f_GET(r) (((r).tx_ctl1[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TX_CTL1r_ENABLE_OS_4f_SET(r,f) (r).tx_ctl1[0]=(((r).tx_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_CTL1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_CTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_CTL1r,(_r._tx_ctl1))
#define BCMI_TSCE16_XGXS_WRITE_TX_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL1r,(_r._tx_ctl1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL1r,(_r._tx_ctl1))
#define BCMI_TSCE16_XGXS_READLN_TX_CTL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ctl1))
#define BCMI_TSCE16_XGXS_WRITELN_TX_CTL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ctl1))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_CTL1r BCMI_TSCE16_XGXS_TX_CTL1r
#define TX_CTL1r_SIZE BCMI_TSCE16_XGXS_TX_CTL1r_SIZE
typedef BCMI_TSCE16_XGXS_TX_CTL1r_t TX_CTL1r_t;
#define TX_CTL1r_CLR BCMI_TSCE16_XGXS_TX_CTL1r_CLR
#define TX_CTL1r_SET BCMI_TSCE16_XGXS_TX_CTL1r_SET
#define TX_CTL1r_GET BCMI_TSCE16_XGXS_TX_CTL1r_GET
#define TX_CTL1r_EN_SLOWf_GET BCMI_TSCE16_XGXS_TX_CTL1r_EN_SLOWf_GET
#define TX_CTL1r_EN_SLOWf_SET BCMI_TSCE16_XGXS_TX_CTL1r_EN_SLOWf_SET
#define TX_CTL1r_EN_WCLK33f_GET BCMI_TSCE16_XGXS_TX_CTL1r_EN_WCLK33f_GET
#define TX_CTL1r_EN_WCLK33f_SET BCMI_TSCE16_XGXS_TX_CTL1r_EN_WCLK33f_SET
#define TX_CTL1r_EN_WCLK20f_GET BCMI_TSCE16_XGXS_TX_CTL1r_EN_WCLK20f_GET
#define TX_CTL1r_EN_WCLK20f_SET BCMI_TSCE16_XGXS_TX_CTL1r_EN_WCLK20f_SET
#define TX_CTL1r_EN_WCLK16f_GET BCMI_TSCE16_XGXS_TX_CTL1r_EN_WCLK16f_GET
#define TX_CTL1r_EN_WCLK16f_SET BCMI_TSCE16_XGXS_TX_CTL1r_EN_WCLK16f_SET
#define TX_CTL1r_TESTCLK_ENAf_GET BCMI_TSCE16_XGXS_TX_CTL1r_TESTCLK_ENAf_GET
#define TX_CTL1r_TESTCLK_ENAf_SET BCMI_TSCE16_XGXS_TX_CTL1r_TESTCLK_ENAf_SET
#define TX_CTL1r_TESTSELf_GET BCMI_TSCE16_XGXS_TX_CTL1r_TESTSELf_GET
#define TX_CTL1r_TESTSELf_SET BCMI_TSCE16_XGXS_TX_CTL1r_TESTSELf_SET
#define TX_CTL1r_CNTRL_RXDETECT_ENf_GET BCMI_TSCE16_XGXS_TX_CTL1r_CNTRL_RXDETECT_ENf_GET
#define TX_CTL1r_CNTRL_RXDETECT_ENf_SET BCMI_TSCE16_XGXS_TX_CTL1r_CNTRL_RXDETECT_ENf_SET
#define TX_CTL1r_RXDTCT_TH_SELf_GET BCMI_TSCE16_XGXS_TX_CTL1r_RXDTCT_TH_SELf_GET
#define TX_CTL1r_RXDTCT_TH_SELf_SET BCMI_TSCE16_XGXS_TX_CTL1r_RXDTCT_TH_SELf_SET
#define TX_CTL1r_EN_HIGH_CURRENTf_GET BCMI_TSCE16_XGXS_TX_CTL1r_EN_HIGH_CURRENTf_GET
#define TX_CTL1r_EN_HIGH_CURRENTf_SET BCMI_TSCE16_XGXS_TX_CTL1r_EN_HIGH_CURRENTf_SET
#define TX_CTL1r_ENABLE_OS_4f_GET BCMI_TSCE16_XGXS_TX_CTL1r_ENABLE_OS_4f_GET
#define TX_CTL1r_ENABLE_OS_4f_SET BCMI_TSCE16_XGXS_TX_CTL1r_ENABLE_OS_4f_SET
#define READ_TX_CTL1r BCMI_TSCE16_XGXS_READ_TX_CTL1r
#define WRITE_TX_CTL1r BCMI_TSCE16_XGXS_WRITE_TX_CTL1r
#define MODIFY_TX_CTL1r BCMI_TSCE16_XGXS_MODIFY_TX_CTL1r
#define READLN_TX_CTL1r BCMI_TSCE16_XGXS_READLN_TX_CTL1r
#define WRITELN_TX_CTL1r BCMI_TSCE16_XGXS_WRITELN_TX_CTL1r
#define WRITEALL_TX_CTL1r BCMI_TSCE16_XGXS_WRITEALL_TX_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_CTL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_CTL2
 * BLOCKS:   AMS_TX
 * REGADDR:  0xd0a2
 * DESC:     TX_CTRL_2
 * RESETVAL: 0x5250 (21072)
 * ACCESS:   R/W
 * FIELDS:
 *     EN_HPF           enable a HPF continuous time equalization to the driver. amsbus ctrl_out  34:31
 *     DCC_EN           enable duty cycle correction circuit amsbus ctrl_out  35:35
 *     IBIAS_OPAMP_CNTL current biasing control for the opamps used in dcc and calibration amsbus ctrl_out  38:36
 *     IBIAS_PI_CNTL    current biasing control for the opamps used in phase interpolator. amsbus ctrl_out  41:39
 *     IBIAS_PIBUF_CNTL current biasing control for the opamps used in phase interpolator buffer. amsbus ctrl_out  44:42
 *     FIFO_PHSDETECT_MODE 1: phsdetect at 2.5G, 0: phsdetect at 1.25G amsbus ctrl_out  45:45
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_CTL2r (0x0000d0a2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program TX_CTL2.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_CTL2r_s {
	uint32_t v[1];
	uint32_t tx_ctl2[1];
	uint32_t _tx_ctl2;
} BCMI_TSCE16_XGXS_TX_CTL2r_t;

#define BCMI_TSCE16_XGXS_TX_CTL2r_CLR(r) (r).tx_ctl2[0] = 0
#define BCMI_TSCE16_XGXS_TX_CTL2r_SET(r,d) (r).tx_ctl2[0] = d
#define BCMI_TSCE16_XGXS_TX_CTL2r_GET(r) (r).tx_ctl2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_CTL2r_FIFO_PHSDETECT_MODEf_GET(r) ((((r).tx_ctl2[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_TX_CTL2r_FIFO_PHSDETECT_MODEf_SET(r,f) (r).tx_ctl2[0]=(((r).tx_ctl2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_TX_CTL2r_IBIAS_PIBUF_CNTLf_GET(r) ((((r).tx_ctl2[0]) >> 11) & 0x7)
#define BCMI_TSCE16_XGXS_TX_CTL2r_IBIAS_PIBUF_CNTLf_SET(r,f) (r).tx_ctl2[0]=(((r).tx_ctl2[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_TSCE16_XGXS_TX_CTL2r_IBIAS_PI_CNTLf_GET(r) ((((r).tx_ctl2[0]) >> 8) & 0x7)
#define BCMI_TSCE16_XGXS_TX_CTL2r_IBIAS_PI_CNTLf_SET(r,f) (r).tx_ctl2[0]=(((r).tx_ctl2[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_TSCE16_XGXS_TX_CTL2r_IBIAS_OPAMP_CNTLf_GET(r) ((((r).tx_ctl2[0]) >> 5) & 0x7)
#define BCMI_TSCE16_XGXS_TX_CTL2r_IBIAS_OPAMP_CNTLf_SET(r,f) (r).tx_ctl2[0]=(((r).tx_ctl2[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5)) | (7 << (16 + 5))
#define BCMI_TSCE16_XGXS_TX_CTL2r_DCC_ENf_GET(r) ((((r).tx_ctl2[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_TX_CTL2r_DCC_ENf_SET(r,f) (r).tx_ctl2[0]=(((r).tx_ctl2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_TX_CTL2r_EN_HPFf_GET(r) (((r).tx_ctl2[0]) & 0xf)
#define BCMI_TSCE16_XGXS_TX_CTL2r_EN_HPFf_SET(r,f) (r).tx_ctl2[0]=(((r).tx_ctl2[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access TX_CTL2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_CTL2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_CTL2r,(_r._tx_ctl2))
#define BCMI_TSCE16_XGXS_WRITE_TX_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL2r,(_r._tx_ctl2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL2r,(_r._tx_ctl2))
#define BCMI_TSCE16_XGXS_READLN_TX_CTL2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ctl2))
#define BCMI_TSCE16_XGXS_WRITELN_TX_CTL2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ctl2))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_CTL2r BCMI_TSCE16_XGXS_TX_CTL2r
#define TX_CTL2r_SIZE BCMI_TSCE16_XGXS_TX_CTL2r_SIZE
typedef BCMI_TSCE16_XGXS_TX_CTL2r_t TX_CTL2r_t;
#define TX_CTL2r_CLR BCMI_TSCE16_XGXS_TX_CTL2r_CLR
#define TX_CTL2r_SET BCMI_TSCE16_XGXS_TX_CTL2r_SET
#define TX_CTL2r_GET BCMI_TSCE16_XGXS_TX_CTL2r_GET
#define TX_CTL2r_FIFO_PHSDETECT_MODEf_GET BCMI_TSCE16_XGXS_TX_CTL2r_FIFO_PHSDETECT_MODEf_GET
#define TX_CTL2r_FIFO_PHSDETECT_MODEf_SET BCMI_TSCE16_XGXS_TX_CTL2r_FIFO_PHSDETECT_MODEf_SET
#define TX_CTL2r_IBIAS_PIBUF_CNTLf_GET BCMI_TSCE16_XGXS_TX_CTL2r_IBIAS_PIBUF_CNTLf_GET
#define TX_CTL2r_IBIAS_PIBUF_CNTLf_SET BCMI_TSCE16_XGXS_TX_CTL2r_IBIAS_PIBUF_CNTLf_SET
#define TX_CTL2r_IBIAS_PI_CNTLf_GET BCMI_TSCE16_XGXS_TX_CTL2r_IBIAS_PI_CNTLf_GET
#define TX_CTL2r_IBIAS_PI_CNTLf_SET BCMI_TSCE16_XGXS_TX_CTL2r_IBIAS_PI_CNTLf_SET
#define TX_CTL2r_IBIAS_OPAMP_CNTLf_GET BCMI_TSCE16_XGXS_TX_CTL2r_IBIAS_OPAMP_CNTLf_GET
#define TX_CTL2r_IBIAS_OPAMP_CNTLf_SET BCMI_TSCE16_XGXS_TX_CTL2r_IBIAS_OPAMP_CNTLf_SET
#define TX_CTL2r_DCC_ENf_GET BCMI_TSCE16_XGXS_TX_CTL2r_DCC_ENf_GET
#define TX_CTL2r_DCC_ENf_SET BCMI_TSCE16_XGXS_TX_CTL2r_DCC_ENf_SET
#define TX_CTL2r_EN_HPFf_GET BCMI_TSCE16_XGXS_TX_CTL2r_EN_HPFf_GET
#define TX_CTL2r_EN_HPFf_SET BCMI_TSCE16_XGXS_TX_CTL2r_EN_HPFf_SET
#define READ_TX_CTL2r BCMI_TSCE16_XGXS_READ_TX_CTL2r
#define WRITE_TX_CTL2r BCMI_TSCE16_XGXS_WRITE_TX_CTL2r
#define MODIFY_TX_CTL2r BCMI_TSCE16_XGXS_MODIFY_TX_CTL2r
#define READLN_TX_CTL2r BCMI_TSCE16_XGXS_READLN_TX_CTL2r
#define WRITELN_TX_CTL2r BCMI_TSCE16_XGXS_WRITELN_TX_CTL2r
#define WRITEALL_TX_CTL2r BCMI_TSCE16_XGXS_WRITEALL_TX_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_CTL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_CTL3
 * BLOCKS:   AMS_TX
 * REGADDR:  0xd0a3
 * DESC:     TX_CTRL_3
 * RESETVAL: 0x1556 (5462)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_SPARE_3_0    AMS reserved bit[47:46] amsbus ctrl_out  47:46
 *     REFCALSHUNT      Controls the reference value for calibrating the NMOS part of the shunt slices amsbus ctrl_out  51:48
 *     REFCALP          Controls the reference value for calibrating the PMOS part of the series slices amsbus ctrl_out  55:52
 *     REFCALM          Controls the reference value for calibrating the NMOS part of the series slices amsbus ctrl_out  59:56
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_CTL3r (0x0000d0a3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program TX_CTL3.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_CTL3r_s {
	uint32_t v[1];
	uint32_t tx_ctl3[1];
	uint32_t _tx_ctl3;
} BCMI_TSCE16_XGXS_TX_CTL3r_t;

#define BCMI_TSCE16_XGXS_TX_CTL3r_CLR(r) (r).tx_ctl3[0] = 0
#define BCMI_TSCE16_XGXS_TX_CTL3r_SET(r,d) (r).tx_ctl3[0] = d
#define BCMI_TSCE16_XGXS_TX_CTL3r_GET(r) (r).tx_ctl3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_CTL3r_REFCALMf_GET(r) ((((r).tx_ctl3[0]) >> 10) & 0xf)
#define BCMI_TSCE16_XGXS_TX_CTL3r_REFCALMf_SET(r,f) (r).tx_ctl3[0]=(((r).tx_ctl3[0] & ~((uint32_t)0xf << 10)) | ((((uint32_t)f) & 0xf) << 10)) | (15 << (16 + 10))
#define BCMI_TSCE16_XGXS_TX_CTL3r_REFCALPf_GET(r) ((((r).tx_ctl3[0]) >> 6) & 0xf)
#define BCMI_TSCE16_XGXS_TX_CTL3r_REFCALPf_SET(r,f) (r).tx_ctl3[0]=(((r).tx_ctl3[0] & ~((uint32_t)0xf << 6)) | ((((uint32_t)f) & 0xf) << 6)) | (15 << (16 + 6))
#define BCMI_TSCE16_XGXS_TX_CTL3r_REFCALSHUNTf_GET(r) ((((r).tx_ctl3[0]) >> 2) & 0xf)
#define BCMI_TSCE16_XGXS_TX_CTL3r_REFCALSHUNTf_SET(r,f) (r).tx_ctl3[0]=(((r).tx_ctl3[0] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2)) | (15 << (16 + 2))
#define BCMI_TSCE16_XGXS_TX_CTL3r_AMS_SPARE_3_0f_GET(r) (((r).tx_ctl3[0]) & 0x3)
#define BCMI_TSCE16_XGXS_TX_CTL3r_AMS_SPARE_3_0f_SET(r,f) (r).tx_ctl3[0]=(((r).tx_ctl3[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access TX_CTL3.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_CTL3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_CTL3r,(_r._tx_ctl3))
#define BCMI_TSCE16_XGXS_WRITE_TX_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL3r,(_r._tx_ctl3)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL3r,(_r._tx_ctl3))
#define BCMI_TSCE16_XGXS_READLN_TX_CTL3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ctl3))
#define BCMI_TSCE16_XGXS_WRITELN_TX_CTL3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ctl3))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_ctl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_CTL3r BCMI_TSCE16_XGXS_TX_CTL3r
#define TX_CTL3r_SIZE BCMI_TSCE16_XGXS_TX_CTL3r_SIZE
typedef BCMI_TSCE16_XGXS_TX_CTL3r_t TX_CTL3r_t;
#define TX_CTL3r_CLR BCMI_TSCE16_XGXS_TX_CTL3r_CLR
#define TX_CTL3r_SET BCMI_TSCE16_XGXS_TX_CTL3r_SET
#define TX_CTL3r_GET BCMI_TSCE16_XGXS_TX_CTL3r_GET
#define TX_CTL3r_REFCALMf_GET BCMI_TSCE16_XGXS_TX_CTL3r_REFCALMf_GET
#define TX_CTL3r_REFCALMf_SET BCMI_TSCE16_XGXS_TX_CTL3r_REFCALMf_SET
#define TX_CTL3r_REFCALPf_GET BCMI_TSCE16_XGXS_TX_CTL3r_REFCALPf_GET
#define TX_CTL3r_REFCALPf_SET BCMI_TSCE16_XGXS_TX_CTL3r_REFCALPf_SET
#define TX_CTL3r_REFCALSHUNTf_GET BCMI_TSCE16_XGXS_TX_CTL3r_REFCALSHUNTf_GET
#define TX_CTL3r_REFCALSHUNTf_SET BCMI_TSCE16_XGXS_TX_CTL3r_REFCALSHUNTf_SET
#define TX_CTL3r_AMS_SPARE_3_0f_GET BCMI_TSCE16_XGXS_TX_CTL3r_AMS_SPARE_3_0f_GET
#define TX_CTL3r_AMS_SPARE_3_0f_SET BCMI_TSCE16_XGXS_TX_CTL3r_AMS_SPARE_3_0f_SET
#define READ_TX_CTL3r BCMI_TSCE16_XGXS_READ_TX_CTL3r
#define WRITE_TX_CTL3r BCMI_TSCE16_XGXS_WRITE_TX_CTL3r
#define MODIFY_TX_CTL3r BCMI_TSCE16_XGXS_MODIFY_TX_CTL3r
#define READLN_TX_CTL3r BCMI_TSCE16_XGXS_READLN_TX_CTL3r
#define WRITELN_TX_CTL3r BCMI_TSCE16_XGXS_WRITELN_TX_CTL3r
#define WRITEALL_TX_CTL3r BCMI_TSCE16_XGXS_WRITEALL_TX_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_CTL3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_CTL4
 * BLOCKS:   AMS_TX
 * REGADDR:  0xd0a4
 * DESC:     TX_CTRL_4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SHNTPRE_POST1PRE Direct Control of Shunt slices for pre in group post1pre. BUFFERED CONTROL from VERT Slices amsbus ctrl_out  65:60
 *     SHNTPOST1_POST1PRE Direct Control of Shunt slices for post1 in group post1pre. BUFFERED CONTROL from VERT Slices amsbus ctrl_out  71:66
 *     SHNTPOST2_POST2  Direct Control of Shunt slices for post1 in group post2. BUFFERED CONTROL from VERT Slices amsbus ctrl_out  81:78
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_CTL4r (0x0000d0a4 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program TX_CTL4.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_CTL4r_s {
	uint32_t v[1];
	uint32_t tx_ctl4[1];
	uint32_t _tx_ctl4;
} BCMI_TSCE16_XGXS_TX_CTL4r_t;

#define BCMI_TSCE16_XGXS_TX_CTL4r_CLR(r) (r).tx_ctl4[0] = 0
#define BCMI_TSCE16_XGXS_TX_CTL4r_SET(r,d) (r).tx_ctl4[0] = d
#define BCMI_TSCE16_XGXS_TX_CTL4r_GET(r) (r).tx_ctl4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_CTL4r_SHNTPOST2_POST2f_GET(r) ((((r).tx_ctl4[0]) >> 12) & 0xf)
#define BCMI_TSCE16_XGXS_TX_CTL4r_SHNTPOST2_POST2f_SET(r,f) (r).tx_ctl4[0]=(((r).tx_ctl4[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCE16_XGXS_TX_CTL4r_SHNTPOST1_POST1PREf_GET(r) ((((r).tx_ctl4[0]) >> 6) & 0x3f)
#define BCMI_TSCE16_XGXS_TX_CTL4r_SHNTPOST1_POST1PREf_SET(r,f) (r).tx_ctl4[0]=(((r).tx_ctl4[0] & ~((uint32_t)0x3f << 6)) | ((((uint32_t)f) & 0x3f) << 6)) | (63 << (16 + 6))
#define BCMI_TSCE16_XGXS_TX_CTL4r_SHNTPRE_POST1PREf_GET(r) (((r).tx_ctl4[0]) & 0x3f)
#define BCMI_TSCE16_XGXS_TX_CTL4r_SHNTPRE_POST1PREf_SET(r,f) (r).tx_ctl4[0]=(((r).tx_ctl4[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access TX_CTL4.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_CTL4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_CTL4r,(_r._tx_ctl4))
#define BCMI_TSCE16_XGXS_WRITE_TX_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL4r,(_r._tx_ctl4)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL4r,(_r._tx_ctl4))
#define BCMI_TSCE16_XGXS_READLN_TX_CTL4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ctl4))
#define BCMI_TSCE16_XGXS_WRITELN_TX_CTL4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ctl4))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_ctl4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_CTL4r BCMI_TSCE16_XGXS_TX_CTL4r
#define TX_CTL4r_SIZE BCMI_TSCE16_XGXS_TX_CTL4r_SIZE
typedef BCMI_TSCE16_XGXS_TX_CTL4r_t TX_CTL4r_t;
#define TX_CTL4r_CLR BCMI_TSCE16_XGXS_TX_CTL4r_CLR
#define TX_CTL4r_SET BCMI_TSCE16_XGXS_TX_CTL4r_SET
#define TX_CTL4r_GET BCMI_TSCE16_XGXS_TX_CTL4r_GET
#define TX_CTL4r_SHNTPOST2_POST2f_GET BCMI_TSCE16_XGXS_TX_CTL4r_SHNTPOST2_POST2f_GET
#define TX_CTL4r_SHNTPOST2_POST2f_SET BCMI_TSCE16_XGXS_TX_CTL4r_SHNTPOST2_POST2f_SET
#define TX_CTL4r_SHNTPOST1_POST1PREf_GET BCMI_TSCE16_XGXS_TX_CTL4r_SHNTPOST1_POST1PREf_GET
#define TX_CTL4r_SHNTPOST1_POST1PREf_SET BCMI_TSCE16_XGXS_TX_CTL4r_SHNTPOST1_POST1PREf_SET
#define TX_CTL4r_SHNTPRE_POST1PREf_GET BCMI_TSCE16_XGXS_TX_CTL4r_SHNTPRE_POST1PREf_GET
#define TX_CTL4r_SHNTPRE_POST1PREf_SET BCMI_TSCE16_XGXS_TX_CTL4r_SHNTPRE_POST1PREf_SET
#define READ_TX_CTL4r BCMI_TSCE16_XGXS_READ_TX_CTL4r
#define WRITE_TX_CTL4r BCMI_TSCE16_XGXS_WRITE_TX_CTL4r
#define MODIFY_TX_CTL4r BCMI_TSCE16_XGXS_MODIFY_TX_CTL4r
#define READLN_TX_CTL4r BCMI_TSCE16_XGXS_READLN_TX_CTL4r
#define WRITELN_TX_CTL4r BCMI_TSCE16_XGXS_WRITELN_TX_CTL4r
#define WRITEALL_TX_CTL4r BCMI_TSCE16_XGXS_WRITEALL_TX_CTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_CTL4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_CTL5
 * BLOCKS:   AMS_TX
 * REGADDR:  0xd0a5
 * DESC:     TX_CTRL_5
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SHNTMAIN_POST1PRE Direct Control of Shunt slices for main in group post1pre. INVERTED CONTROL from VERT Slices amsbus ctrl_out  77:72
 *     SHNTMAIN_POST2   Direct Control of Shunt slices for main in group post2. INVERTED CONTROL from VERT Slices amsbus ctrl_out  85:82
 *     EN_POST2         Enables post2 path amsbus ctrl_out  86:86
 *     EN_POST1         Enables post1 path amsbus ctrl_out  87:87
 *     EN_PRE           Enables pre path amsbus ctrl_out  88:88
 *     POST2TO1         Converts post2 taps to post1 taps amsbus ctrl_out  89:89
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_CTL5r (0x0000d0a5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_CTL5r_SIZE 4

/*
 * This structure should be used to declare and program TX_CTL5.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_CTL5r_s {
	uint32_t v[1];
	uint32_t tx_ctl5[1];
	uint32_t _tx_ctl5;
} BCMI_TSCE16_XGXS_TX_CTL5r_t;

#define BCMI_TSCE16_XGXS_TX_CTL5r_CLR(r) (r).tx_ctl5[0] = 0
#define BCMI_TSCE16_XGXS_TX_CTL5r_SET(r,d) (r).tx_ctl5[0] = d
#define BCMI_TSCE16_XGXS_TX_CTL5r_GET(r) (r).tx_ctl5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_CTL5r_POST2TO1f_GET(r) ((((r).tx_ctl5[0]) >> 13) & 0x1)
#define BCMI_TSCE16_XGXS_TX_CTL5r_POST2TO1f_SET(r,f) (r).tx_ctl5[0]=(((r).tx_ctl5[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCE16_XGXS_TX_CTL5r_EN_PREf_GET(r) ((((r).tx_ctl5[0]) >> 12) & 0x1)
#define BCMI_TSCE16_XGXS_TX_CTL5r_EN_PREf_SET(r,f) (r).tx_ctl5[0]=(((r).tx_ctl5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCE16_XGXS_TX_CTL5r_EN_POST1f_GET(r) ((((r).tx_ctl5[0]) >> 11) & 0x1)
#define BCMI_TSCE16_XGXS_TX_CTL5r_EN_POST1f_SET(r,f) (r).tx_ctl5[0]=(((r).tx_ctl5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCE16_XGXS_TX_CTL5r_EN_POST2f_GET(r) ((((r).tx_ctl5[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_TX_CTL5r_EN_POST2f_SET(r,f) (r).tx_ctl5[0]=(((r).tx_ctl5[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_TX_CTL5r_SHNTMAIN_POST2f_GET(r) ((((r).tx_ctl5[0]) >> 6) & 0xf)
#define BCMI_TSCE16_XGXS_TX_CTL5r_SHNTMAIN_POST2f_SET(r,f) (r).tx_ctl5[0]=(((r).tx_ctl5[0] & ~((uint32_t)0xf << 6)) | ((((uint32_t)f) & 0xf) << 6)) | (15 << (16 + 6))
#define BCMI_TSCE16_XGXS_TX_CTL5r_SHNTMAIN_POST1PREf_GET(r) (((r).tx_ctl5[0]) & 0x3f)
#define BCMI_TSCE16_XGXS_TX_CTL5r_SHNTMAIN_POST1PREf_SET(r,f) (r).tx_ctl5[0]=(((r).tx_ctl5[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access TX_CTL5.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_CTL5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_CTL5r,(_r._tx_ctl5))
#define BCMI_TSCE16_XGXS_WRITE_TX_CTL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL5r,(_r._tx_ctl5)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_CTL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL5r,(_r._tx_ctl5))
#define BCMI_TSCE16_XGXS_READLN_TX_CTL5r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ctl5))
#define BCMI_TSCE16_XGXS_WRITELN_TX_CTL5r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ctl5))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_CTL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_ctl5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_CTL5r BCMI_TSCE16_XGXS_TX_CTL5r
#define TX_CTL5r_SIZE BCMI_TSCE16_XGXS_TX_CTL5r_SIZE
typedef BCMI_TSCE16_XGXS_TX_CTL5r_t TX_CTL5r_t;
#define TX_CTL5r_CLR BCMI_TSCE16_XGXS_TX_CTL5r_CLR
#define TX_CTL5r_SET BCMI_TSCE16_XGXS_TX_CTL5r_SET
#define TX_CTL5r_GET BCMI_TSCE16_XGXS_TX_CTL5r_GET
#define TX_CTL5r_POST2TO1f_GET BCMI_TSCE16_XGXS_TX_CTL5r_POST2TO1f_GET
#define TX_CTL5r_POST2TO1f_SET BCMI_TSCE16_XGXS_TX_CTL5r_POST2TO1f_SET
#define TX_CTL5r_EN_PREf_GET BCMI_TSCE16_XGXS_TX_CTL5r_EN_PREf_GET
#define TX_CTL5r_EN_PREf_SET BCMI_TSCE16_XGXS_TX_CTL5r_EN_PREf_SET
#define TX_CTL5r_EN_POST1f_GET BCMI_TSCE16_XGXS_TX_CTL5r_EN_POST1f_GET
#define TX_CTL5r_EN_POST1f_SET BCMI_TSCE16_XGXS_TX_CTL5r_EN_POST1f_SET
#define TX_CTL5r_EN_POST2f_GET BCMI_TSCE16_XGXS_TX_CTL5r_EN_POST2f_GET
#define TX_CTL5r_EN_POST2f_SET BCMI_TSCE16_XGXS_TX_CTL5r_EN_POST2f_SET
#define TX_CTL5r_SHNTMAIN_POST2f_GET BCMI_TSCE16_XGXS_TX_CTL5r_SHNTMAIN_POST2f_GET
#define TX_CTL5r_SHNTMAIN_POST2f_SET BCMI_TSCE16_XGXS_TX_CTL5r_SHNTMAIN_POST2f_SET
#define TX_CTL5r_SHNTMAIN_POST1PREf_GET BCMI_TSCE16_XGXS_TX_CTL5r_SHNTMAIN_POST1PREf_GET
#define TX_CTL5r_SHNTMAIN_POST1PREf_SET BCMI_TSCE16_XGXS_TX_CTL5r_SHNTMAIN_POST1PREf_SET
#define READ_TX_CTL5r BCMI_TSCE16_XGXS_READ_TX_CTL5r
#define WRITE_TX_CTL5r BCMI_TSCE16_XGXS_WRITE_TX_CTL5r
#define MODIFY_TX_CTL5r BCMI_TSCE16_XGXS_MODIFY_TX_CTL5r
#define READLN_TX_CTL5r BCMI_TSCE16_XGXS_READLN_TX_CTL5r
#define WRITELN_TX_CTL5r BCMI_TSCE16_XGXS_WRITELN_TX_CTL5r
#define WRITEALL_TX_CTL5r BCMI_TSCE16_XGXS_WRITEALL_TX_CTL5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_CTL5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_CTL6
 * BLOCKS:   AMS_TX
 * REGADDR:  0xd0a6
 * DESC:     TX_CTRL_6
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     EN_SHUNTMODE     enable shunt mode, ams[90] amsbus ctrl_out  90:90
 *     PD_PHASEDET      1: power down phase detection in TCA loop amsbus ctrl_out  91:91
 *     AMS_SPARE_6_0    Enables the Current Mode Slices of the Driver. amsbus ctrl_out  95:92
 *     DIS_CAL          Disables the calibratin amplifiers amsbus ctrl_out  100:96
 *     SHNTPOST1_POST1  Direct Control of Shunt slices for post1 in group post1. BUFFERED CONTROL from VERT Slices amsbus ctrl_out  105:101
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_CTL6r (0x0000d0a6 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_CTL6r_SIZE 4

/*
 * This structure should be used to declare and program TX_CTL6.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_CTL6r_s {
	uint32_t v[1];
	uint32_t tx_ctl6[1];
	uint32_t _tx_ctl6;
} BCMI_TSCE16_XGXS_TX_CTL6r_t;

#define BCMI_TSCE16_XGXS_TX_CTL6r_CLR(r) (r).tx_ctl6[0] = 0
#define BCMI_TSCE16_XGXS_TX_CTL6r_SET(r,d) (r).tx_ctl6[0] = d
#define BCMI_TSCE16_XGXS_TX_CTL6r_GET(r) (r).tx_ctl6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_CTL6r_SHNTPOST1_POST1f_GET(r) ((((r).tx_ctl6[0]) >> 11) & 0x1f)
#define BCMI_TSCE16_XGXS_TX_CTL6r_SHNTPOST1_POST1f_SET(r,f) (r).tx_ctl6[0]=(((r).tx_ctl6[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_TSCE16_XGXS_TX_CTL6r_DIS_CALf_GET(r) ((((r).tx_ctl6[0]) >> 6) & 0x1f)
#define BCMI_TSCE16_XGXS_TX_CTL6r_DIS_CALf_SET(r,f) (r).tx_ctl6[0]=(((r).tx_ctl6[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_TSCE16_XGXS_TX_CTL6r_AMS_SPARE_6_0f_GET(r) ((((r).tx_ctl6[0]) >> 2) & 0xf)
#define BCMI_TSCE16_XGXS_TX_CTL6r_AMS_SPARE_6_0f_SET(r,f) (r).tx_ctl6[0]=(((r).tx_ctl6[0] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2)) | (15 << (16 + 2))
#define BCMI_TSCE16_XGXS_TX_CTL6r_PD_PHASEDETf_GET(r) ((((r).tx_ctl6[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_TX_CTL6r_PD_PHASEDETf_SET(r,f) (r).tx_ctl6[0]=(((r).tx_ctl6[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_TX_CTL6r_EN_SHUNTMODEf_GET(r) (((r).tx_ctl6[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TX_CTL6r_EN_SHUNTMODEf_SET(r,f) (r).tx_ctl6[0]=(((r).tx_ctl6[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_CTL6.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_CTL6r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_CTL6r,(_r._tx_ctl6))
#define BCMI_TSCE16_XGXS_WRITE_TX_CTL6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL6r,(_r._tx_ctl6)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_CTL6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL6r,(_r._tx_ctl6))
#define BCMI_TSCE16_XGXS_READLN_TX_CTL6r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ctl6))
#define BCMI_TSCE16_XGXS_WRITELN_TX_CTL6r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ctl6))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_CTL6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_ctl6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_CTL6r BCMI_TSCE16_XGXS_TX_CTL6r
#define TX_CTL6r_SIZE BCMI_TSCE16_XGXS_TX_CTL6r_SIZE
typedef BCMI_TSCE16_XGXS_TX_CTL6r_t TX_CTL6r_t;
#define TX_CTL6r_CLR BCMI_TSCE16_XGXS_TX_CTL6r_CLR
#define TX_CTL6r_SET BCMI_TSCE16_XGXS_TX_CTL6r_SET
#define TX_CTL6r_GET BCMI_TSCE16_XGXS_TX_CTL6r_GET
#define TX_CTL6r_SHNTPOST1_POST1f_GET BCMI_TSCE16_XGXS_TX_CTL6r_SHNTPOST1_POST1f_GET
#define TX_CTL6r_SHNTPOST1_POST1f_SET BCMI_TSCE16_XGXS_TX_CTL6r_SHNTPOST1_POST1f_SET
#define TX_CTL6r_DIS_CALf_GET BCMI_TSCE16_XGXS_TX_CTL6r_DIS_CALf_GET
#define TX_CTL6r_DIS_CALf_SET BCMI_TSCE16_XGXS_TX_CTL6r_DIS_CALf_SET
#define TX_CTL6r_AMS_SPARE_6_0f_GET BCMI_TSCE16_XGXS_TX_CTL6r_AMS_SPARE_6_0f_GET
#define TX_CTL6r_AMS_SPARE_6_0f_SET BCMI_TSCE16_XGXS_TX_CTL6r_AMS_SPARE_6_0f_SET
#define TX_CTL6r_PD_PHASEDETf_GET BCMI_TSCE16_XGXS_TX_CTL6r_PD_PHASEDETf_GET
#define TX_CTL6r_PD_PHASEDETf_SET BCMI_TSCE16_XGXS_TX_CTL6r_PD_PHASEDETf_SET
#define TX_CTL6r_EN_SHUNTMODEf_GET BCMI_TSCE16_XGXS_TX_CTL6r_EN_SHUNTMODEf_GET
#define TX_CTL6r_EN_SHUNTMODEf_SET BCMI_TSCE16_XGXS_TX_CTL6r_EN_SHUNTMODEf_SET
#define READ_TX_CTL6r BCMI_TSCE16_XGXS_READ_TX_CTL6r
#define WRITE_TX_CTL6r BCMI_TSCE16_XGXS_WRITE_TX_CTL6r
#define MODIFY_TX_CTL6r BCMI_TSCE16_XGXS_MODIFY_TX_CTL6r
#define READLN_TX_CTL6r BCMI_TSCE16_XGXS_READLN_TX_CTL6r
#define WRITELN_TX_CTL6r BCMI_TSCE16_XGXS_WRITELN_TX_CTL6r
#define WRITEALL_TX_CTL6r BCMI_TSCE16_XGXS_WRITEALL_TX_CTL6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_CTL6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_CTL7
 * BLOCKS:   AMS_TX
 * REGADDR:  0xd0a7
 * DESC:     TX_CTRL_7
 * RESETVAL: 0xaa0 (2720)
 * ACCESS:   R/W
 * FIELDS:
 *     SHNTMAIN_POST1   Direct Control of Shunt slices for main in group post1. INVERTED CONTROL from VERT Slices amsbus ctrl_out  110:106
 *     REFCALMCS        Controls the reference value for calibrating the NMOS part of the series Current slices amsbus ctrl_out  114:111
 *     REFCALPCS        Controls the reference value for calibrating the PMOS part of the series Current slices amsbus ctrl_out  118:115
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_CTL7r (0x0000d0a7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_CTL7r_SIZE 4

/*
 * This structure should be used to declare and program TX_CTL7.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_CTL7r_s {
	uint32_t v[1];
	uint32_t tx_ctl7[1];
	uint32_t _tx_ctl7;
} BCMI_TSCE16_XGXS_TX_CTL7r_t;

#define BCMI_TSCE16_XGXS_TX_CTL7r_CLR(r) (r).tx_ctl7[0] = 0
#define BCMI_TSCE16_XGXS_TX_CTL7r_SET(r,d) (r).tx_ctl7[0] = d
#define BCMI_TSCE16_XGXS_TX_CTL7r_GET(r) (r).tx_ctl7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_CTL7r_REFCALPCSf_GET(r) ((((r).tx_ctl7[0]) >> 9) & 0xf)
#define BCMI_TSCE16_XGXS_TX_CTL7r_REFCALPCSf_SET(r,f) (r).tx_ctl7[0]=(((r).tx_ctl7[0] & ~((uint32_t)0xf << 9)) | ((((uint32_t)f) & 0xf) << 9)) | (15 << (16 + 9))
#define BCMI_TSCE16_XGXS_TX_CTL7r_REFCALMCSf_GET(r) ((((r).tx_ctl7[0]) >> 5) & 0xf)
#define BCMI_TSCE16_XGXS_TX_CTL7r_REFCALMCSf_SET(r,f) (r).tx_ctl7[0]=(((r).tx_ctl7[0] & ~((uint32_t)0xf << 5)) | ((((uint32_t)f) & 0xf) << 5)) | (15 << (16 + 5))
#define BCMI_TSCE16_XGXS_TX_CTL7r_SHNTMAIN_POST1f_GET(r) (((r).tx_ctl7[0]) & 0x1f)
#define BCMI_TSCE16_XGXS_TX_CTL7r_SHNTMAIN_POST1f_SET(r,f) (r).tx_ctl7[0]=(((r).tx_ctl7[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access TX_CTL7.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_CTL7r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_CTL7r,(_r._tx_ctl7))
#define BCMI_TSCE16_XGXS_WRITE_TX_CTL7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL7r,(_r._tx_ctl7)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_CTL7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL7r,(_r._tx_ctl7))
#define BCMI_TSCE16_XGXS_READLN_TX_CTL7r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ctl7))
#define BCMI_TSCE16_XGXS_WRITELN_TX_CTL7r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ctl7))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_CTL7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_ctl7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_CTL7r BCMI_TSCE16_XGXS_TX_CTL7r
#define TX_CTL7r_SIZE BCMI_TSCE16_XGXS_TX_CTL7r_SIZE
typedef BCMI_TSCE16_XGXS_TX_CTL7r_t TX_CTL7r_t;
#define TX_CTL7r_CLR BCMI_TSCE16_XGXS_TX_CTL7r_CLR
#define TX_CTL7r_SET BCMI_TSCE16_XGXS_TX_CTL7r_SET
#define TX_CTL7r_GET BCMI_TSCE16_XGXS_TX_CTL7r_GET
#define TX_CTL7r_REFCALPCSf_GET BCMI_TSCE16_XGXS_TX_CTL7r_REFCALPCSf_GET
#define TX_CTL7r_REFCALPCSf_SET BCMI_TSCE16_XGXS_TX_CTL7r_REFCALPCSf_SET
#define TX_CTL7r_REFCALMCSf_GET BCMI_TSCE16_XGXS_TX_CTL7r_REFCALMCSf_GET
#define TX_CTL7r_REFCALMCSf_SET BCMI_TSCE16_XGXS_TX_CTL7r_REFCALMCSf_SET
#define TX_CTL7r_SHNTMAIN_POST1f_GET BCMI_TSCE16_XGXS_TX_CTL7r_SHNTMAIN_POST1f_GET
#define TX_CTL7r_SHNTMAIN_POST1f_SET BCMI_TSCE16_XGXS_TX_CTL7r_SHNTMAIN_POST1f_SET
#define READ_TX_CTL7r BCMI_TSCE16_XGXS_READ_TX_CTL7r
#define WRITE_TX_CTL7r BCMI_TSCE16_XGXS_WRITE_TX_CTL7r
#define MODIFY_TX_CTL7r BCMI_TSCE16_XGXS_MODIFY_TX_CTL7r
#define READLN_TX_CTL7r BCMI_TSCE16_XGXS_READLN_TX_CTL7r
#define WRITELN_TX_CTL7r BCMI_TSCE16_XGXS_WRITELN_TX_CTL7r
#define WRITEALL_TX_CTL7r BCMI_TSCE16_XGXS_WRITEALL_TX_CTL7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_CTL7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_CTL8
 * BLOCKS:   AMS_TX
 * REGADDR:  0xd0a8
 * DESC:     TX_CTRL_8
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SHNTEN_MAIN      Direct Control of Shunt slices for main in group main. INVERTED CONTROL from VERT Slices amsbus ctrl_out  119:119
 *     AMS_SPARE_8_0    AMS reserved bit[127:120] amsbus ctrl_out  127:120
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_CTL8r (0x0000d0a8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_CTL8r_SIZE 4

/*
 * This structure should be used to declare and program TX_CTL8.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_CTL8r_s {
	uint32_t v[1];
	uint32_t tx_ctl8[1];
	uint32_t _tx_ctl8;
} BCMI_TSCE16_XGXS_TX_CTL8r_t;

#define BCMI_TSCE16_XGXS_TX_CTL8r_CLR(r) (r).tx_ctl8[0] = 0
#define BCMI_TSCE16_XGXS_TX_CTL8r_SET(r,d) (r).tx_ctl8[0] = d
#define BCMI_TSCE16_XGXS_TX_CTL8r_GET(r) (r).tx_ctl8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_CTL8r_AMS_SPARE_8_0f_GET(r) ((((r).tx_ctl8[0]) >> 1) & 0xff)
#define BCMI_TSCE16_XGXS_TX_CTL8r_AMS_SPARE_8_0f_SET(r,f) (r).tx_ctl8[0]=(((r).tx_ctl8[0] & ~((uint32_t)0xff << 1)) | ((((uint32_t)f) & 0xff) << 1)) | (255 << (16 + 1))
#define BCMI_TSCE16_XGXS_TX_CTL8r_SHNTEN_MAINf_GET(r) (((r).tx_ctl8[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TX_CTL8r_SHNTEN_MAINf_SET(r,f) (r).tx_ctl8[0]=(((r).tx_ctl8[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_CTL8.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_CTL8r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_CTL8r,(_r._tx_ctl8))
#define BCMI_TSCE16_XGXS_WRITE_TX_CTL8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL8r,(_r._tx_ctl8)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_CTL8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL8r,(_r._tx_ctl8))
#define BCMI_TSCE16_XGXS_READLN_TX_CTL8r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ctl8))
#define BCMI_TSCE16_XGXS_WRITELN_TX_CTL8r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ctl8))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_CTL8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_ctl8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_CTL8r BCMI_TSCE16_XGXS_TX_CTL8r
#define TX_CTL8r_SIZE BCMI_TSCE16_XGXS_TX_CTL8r_SIZE
typedef BCMI_TSCE16_XGXS_TX_CTL8r_t TX_CTL8r_t;
#define TX_CTL8r_CLR BCMI_TSCE16_XGXS_TX_CTL8r_CLR
#define TX_CTL8r_SET BCMI_TSCE16_XGXS_TX_CTL8r_SET
#define TX_CTL8r_GET BCMI_TSCE16_XGXS_TX_CTL8r_GET
#define TX_CTL8r_AMS_SPARE_8_0f_GET BCMI_TSCE16_XGXS_TX_CTL8r_AMS_SPARE_8_0f_GET
#define TX_CTL8r_AMS_SPARE_8_0f_SET BCMI_TSCE16_XGXS_TX_CTL8r_AMS_SPARE_8_0f_SET
#define TX_CTL8r_SHNTEN_MAINf_GET BCMI_TSCE16_XGXS_TX_CTL8r_SHNTEN_MAINf_GET
#define TX_CTL8r_SHNTEN_MAINf_SET BCMI_TSCE16_XGXS_TX_CTL8r_SHNTEN_MAINf_SET
#define READ_TX_CTL8r BCMI_TSCE16_XGXS_READ_TX_CTL8r
#define WRITE_TX_CTL8r BCMI_TSCE16_XGXS_WRITE_TX_CTL8r
#define MODIFY_TX_CTL8r BCMI_TSCE16_XGXS_MODIFY_TX_CTL8r
#define READLN_TX_CTL8r BCMI_TSCE16_XGXS_READLN_TX_CTL8r
#define WRITELN_TX_CTL8r BCMI_TSCE16_XGXS_WRITELN_TX_CTL8r
#define WRITEALL_TX_CTL8r BCMI_TSCE16_XGXS_WRITEALL_TX_CTL8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_CTL8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_INT
 * BLOCKS:   AMS_TX
 * REGADDR:  0xd0a9
 * DESC:     TX_CTRL_INT
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TXPON_SEL        1=select AMS txpon value, 0= select txpon_int (sum or external rescal)
 *     AUTO_LL_SELPATH_TX_DIS 0= Enable auto switching mode for TX datapath. If ll_selpath_tx is 1 then TX datapath is automtically switched to normal tx_data datapath when CL72/Remote_Loopback/PRBS_Gen/Pattern_Gen/TX_EEE_alert_pattern/TX_disable_1s/0s_pattern TX data sources are selected or enabled. 1= use AMS register field ll_selpath_tx to select between ULL and normal TX datapath.
 *     SEL_TXMASTER     select TX lane as master, only one TX lane can be set to master
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_INTr (0x0000d0a9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_INTr_SIZE 4

/*
 * This structure should be used to declare and program TX_INT.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_INTr_s {
	uint32_t v[1];
	uint32_t tx_int[1];
	uint32_t _tx_int;
} BCMI_TSCE16_XGXS_TX_INTr_t;

#define BCMI_TSCE16_XGXS_TX_INTr_CLR(r) (r).tx_int[0] = 0
#define BCMI_TSCE16_XGXS_TX_INTr_SET(r,d) (r).tx_int[0] = d
#define BCMI_TSCE16_XGXS_TX_INTr_GET(r) (r).tx_int[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_INTr_SEL_TXMASTERf_GET(r) ((((r).tx_int[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_TX_INTr_SEL_TXMASTERf_SET(r,f) (r).tx_int[0]=(((r).tx_int[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_TX_INTr_AUTO_LL_SELPATH_TX_DISf_GET(r) ((((r).tx_int[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_TX_INTr_AUTO_LL_SELPATH_TX_DISf_SET(r,f) (r).tx_int[0]=(((r).tx_int[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_TX_INTr_TXPON_SELf_GET(r) ((((r).tx_int[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_TX_INTr_TXPON_SELf_SET(r,f) (r).tx_int[0]=(((r).tx_int[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access TX_INT.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_INTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_INTr,(_r._tx_int))
#define BCMI_TSCE16_XGXS_WRITE_TX_INTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_INTr,(_r._tx_int)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_INTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_INTr,(_r._tx_int))
#define BCMI_TSCE16_XGXS_READLN_TX_INTr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_INTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_int))
#define BCMI_TSCE16_XGXS_WRITELN_TX_INTr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_INTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_int))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_INTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_INTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_int))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_INTr BCMI_TSCE16_XGXS_TX_INTr
#define TX_INTr_SIZE BCMI_TSCE16_XGXS_TX_INTr_SIZE
typedef BCMI_TSCE16_XGXS_TX_INTr_t TX_INTr_t;
#define TX_INTr_CLR BCMI_TSCE16_XGXS_TX_INTr_CLR
#define TX_INTr_SET BCMI_TSCE16_XGXS_TX_INTr_SET
#define TX_INTr_GET BCMI_TSCE16_XGXS_TX_INTr_GET
#define TX_INTr_SEL_TXMASTERf_GET BCMI_TSCE16_XGXS_TX_INTr_SEL_TXMASTERf_GET
#define TX_INTr_SEL_TXMASTERf_SET BCMI_TSCE16_XGXS_TX_INTr_SEL_TXMASTERf_SET
#define TX_INTr_AUTO_LL_SELPATH_TX_DISf_GET BCMI_TSCE16_XGXS_TX_INTr_AUTO_LL_SELPATH_TX_DISf_GET
#define TX_INTr_AUTO_LL_SELPATH_TX_DISf_SET BCMI_TSCE16_XGXS_TX_INTr_AUTO_LL_SELPATH_TX_DISf_SET
#define TX_INTr_TXPON_SELf_GET BCMI_TSCE16_XGXS_TX_INTr_TXPON_SELf_GET
#define TX_INTr_TXPON_SELf_SET BCMI_TSCE16_XGXS_TX_INTr_TXPON_SELf_SET
#define READ_TX_INTr BCMI_TSCE16_XGXS_READ_TX_INTr
#define WRITE_TX_INTr BCMI_TSCE16_XGXS_WRITE_TX_INTr
#define MODIFY_TX_INTr BCMI_TSCE16_XGXS_MODIFY_TX_INTr
#define READLN_TX_INTr BCMI_TSCE16_XGXS_READLN_TX_INTr
#define WRITELN_TX_INTr BCMI_TSCE16_XGXS_WRITELN_TX_INTr
#define WRITEALL_TX_INTr BCMI_TSCE16_XGXS_WRITEALL_TX_INTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_INTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_STS
 * BLOCKS:   AMS_TX
 * REGADDR:  0xd0aa
 * DESC:     TX_STS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TXPON_MUX        txpon at AFE interface
 *     RESCAL           external rescal input value
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_STSr (0x0000d0aa | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_STSr_SIZE 4

/*
 * This structure should be used to declare and program TX_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_STSr_s {
	uint32_t v[1];
	uint32_t tx_sts[1];
	uint32_t _tx_sts;
} BCMI_TSCE16_XGXS_TX_STSr_t;

#define BCMI_TSCE16_XGXS_TX_STSr_CLR(r) (r).tx_sts[0] = 0
#define BCMI_TSCE16_XGXS_TX_STSr_SET(r,d) (r).tx_sts[0] = d
#define BCMI_TSCE16_XGXS_TX_STSr_GET(r) (r).tx_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_STSr_RESCALf_GET(r) ((((r).tx_sts[0]) >> 4) & 0xf)
#define BCMI_TSCE16_XGXS_TX_STSr_RESCALf_SET(r,f) (r).tx_sts[0]=(((r).tx_sts[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_TSCE16_XGXS_TX_STSr_TXPON_MUXf_GET(r) (((r).tx_sts[0]) & 0xf)
#define BCMI_TSCE16_XGXS_TX_STSr_TXPON_MUXf_SET(r,f) (r).tx_sts[0]=(((r).tx_sts[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access TX_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_STSr,(_r._tx_sts))
#define BCMI_TSCE16_XGXS_WRITE_TX_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_STSr,(_r._tx_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_STSr,(_r._tx_sts))
#define BCMI_TSCE16_XGXS_READLN_TX_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_sts))
#define BCMI_TSCE16_XGXS_WRITELN_TX_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_STSr BCMI_TSCE16_XGXS_TX_STSr
#define TX_STSr_SIZE BCMI_TSCE16_XGXS_TX_STSr_SIZE
typedef BCMI_TSCE16_XGXS_TX_STSr_t TX_STSr_t;
#define TX_STSr_CLR BCMI_TSCE16_XGXS_TX_STSr_CLR
#define TX_STSr_SET BCMI_TSCE16_XGXS_TX_STSr_SET
#define TX_STSr_GET BCMI_TSCE16_XGXS_TX_STSr_GET
#define TX_STSr_RESCALf_GET BCMI_TSCE16_XGXS_TX_STSr_RESCALf_GET
#define TX_STSr_RESCALf_SET BCMI_TSCE16_XGXS_TX_STSr_RESCALf_SET
#define TX_STSr_TXPON_MUXf_GET BCMI_TSCE16_XGXS_TX_STSr_TXPON_MUXf_GET
#define TX_STSr_TXPON_MUXf_SET BCMI_TSCE16_XGXS_TX_STSr_TXPON_MUXf_SET
#define READ_TX_STSr BCMI_TSCE16_XGXS_READ_TX_STSr
#define WRITE_TX_STSr BCMI_TSCE16_XGXS_WRITE_TX_STSr
#define MODIFY_TX_STSr BCMI_TSCE16_XGXS_MODIFY_TX_STSr
#define READLN_TX_STSr BCMI_TSCE16_XGXS_READLN_TX_STSr
#define WRITELN_TX_STSr BCMI_TSCE16_XGXS_WRITELN_TX_STSr
#define WRITEALL_TX_STSr BCMI_TSCE16_XGXS_WRITEALL_TX_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PLL_CTL0
 * BLOCKS:   AMSCOM
 * REGADDR:  0xd0b0
 * DESC:     PLL_CTRL_0
 * RESETVAL: 0x2480 (9344)
 * ACCESS:   R/W
 * FIELDS:
 *     PLL_SPARE_0_0    AMS reserved[6:0] amsbus ctrl_out  6:0
 *     LC_REFCLK_ADJ_1_0 Set the refclk input and output bias for LC ref channel amsbus ctrl_out  8:7
 *     RPAR             Change filter resistor for PLL bandwidth, these value include interfonnect resistance of 150 ohms. amsbus ctrl_out  11:9
 *     PLL_SPARE_0_1    AMS reserved[12:12] amsbus ctrl_out  12:12
 *     TERM_CM_EN       enable common-mode input termination amsbus ctrl_out  13:13
 *     CPAR             Change filter shunt capacitor amsbus ctrl_out  15:14
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PLL_CTL0r (0x0000d0b0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PLL_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_PLL_CTL0r_s {
	uint32_t v[1];
	uint32_t pll_ctl0[1];
	uint32_t _pll_ctl0;
} BCMI_TSCE16_XGXS_PLL_CTL0r_t;

#define BCMI_TSCE16_XGXS_PLL_CTL0r_CLR(r) (r).pll_ctl0[0] = 0
#define BCMI_TSCE16_XGXS_PLL_CTL0r_SET(r,d) (r).pll_ctl0[0] = d
#define BCMI_TSCE16_XGXS_PLL_CTL0r_GET(r) (r).pll_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PLL_CTL0r_CPARf_GET(r) ((((r).pll_ctl0[0]) >> 14) & 0x3)
#define BCMI_TSCE16_XGXS_PLL_CTL0r_CPARf_SET(r,f) (r).pll_ctl0[0]=(((r).pll_ctl0[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCE16_XGXS_PLL_CTL0r_TERM_CM_ENf_GET(r) ((((r).pll_ctl0[0]) >> 13) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CTL0r_TERM_CM_ENf_SET(r,f) (r).pll_ctl0[0]=(((r).pll_ctl0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCE16_XGXS_PLL_CTL0r_PLL_SPARE_0_1f_GET(r) ((((r).pll_ctl0[0]) >> 12) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CTL0r_PLL_SPARE_0_1f_SET(r,f) (r).pll_ctl0[0]=(((r).pll_ctl0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCE16_XGXS_PLL_CTL0r_RPARf_GET(r) ((((r).pll_ctl0[0]) >> 9) & 0x7)
#define BCMI_TSCE16_XGXS_PLL_CTL0r_RPARf_SET(r,f) (r).pll_ctl0[0]=(((r).pll_ctl0[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9)) | (7 << (16 + 9))
#define BCMI_TSCE16_XGXS_PLL_CTL0r_LC_REFCLK_ADJ_1_0f_GET(r) ((((r).pll_ctl0[0]) >> 7) & 0x3)
#define BCMI_TSCE16_XGXS_PLL_CTL0r_LC_REFCLK_ADJ_1_0f_SET(r,f) (r).pll_ctl0[0]=(((r).pll_ctl0[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7)) | (3 << (16 + 7))
#define BCMI_TSCE16_XGXS_PLL_CTL0r_PLL_SPARE_0_0f_GET(r) (((r).pll_ctl0[0]) & 0x7f)
#define BCMI_TSCE16_XGXS_PLL_CTL0r_PLL_SPARE_0_0f_SET(r,f) (r).pll_ctl0[0]=(((r).pll_ctl0[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access PLL_CTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PLL_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CTL0r,(_r._pll_ctl0))
#define BCMI_TSCE16_XGXS_WRITE_PLL_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL0r,(_r._pll_ctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PLL_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL0r,(_r._pll_ctl0))
#define BCMI_TSCE16_XGXS_READLN_PLL_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_ctl0))
#define BCMI_TSCE16_XGXS_WRITELN_PLL_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_ctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_PLL_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CTL0r BCMI_TSCE16_XGXS_PLL_CTL0r
#define PLL_CTL0r_SIZE BCMI_TSCE16_XGXS_PLL_CTL0r_SIZE
typedef BCMI_TSCE16_XGXS_PLL_CTL0r_t PLL_CTL0r_t;
#define PLL_CTL0r_CLR BCMI_TSCE16_XGXS_PLL_CTL0r_CLR
#define PLL_CTL0r_SET BCMI_TSCE16_XGXS_PLL_CTL0r_SET
#define PLL_CTL0r_GET BCMI_TSCE16_XGXS_PLL_CTL0r_GET
#define PLL_CTL0r_CPARf_GET BCMI_TSCE16_XGXS_PLL_CTL0r_CPARf_GET
#define PLL_CTL0r_CPARf_SET BCMI_TSCE16_XGXS_PLL_CTL0r_CPARf_SET
#define PLL_CTL0r_TERM_CM_ENf_GET BCMI_TSCE16_XGXS_PLL_CTL0r_TERM_CM_ENf_GET
#define PLL_CTL0r_TERM_CM_ENf_SET BCMI_TSCE16_XGXS_PLL_CTL0r_TERM_CM_ENf_SET
#define PLL_CTL0r_PLL_SPARE_0_1f_GET BCMI_TSCE16_XGXS_PLL_CTL0r_PLL_SPARE_0_1f_GET
#define PLL_CTL0r_PLL_SPARE_0_1f_SET BCMI_TSCE16_XGXS_PLL_CTL0r_PLL_SPARE_0_1f_SET
#define PLL_CTL0r_RPARf_GET BCMI_TSCE16_XGXS_PLL_CTL0r_RPARf_GET
#define PLL_CTL0r_RPARf_SET BCMI_TSCE16_XGXS_PLL_CTL0r_RPARf_SET
#define PLL_CTL0r_LC_REFCLK_ADJ_1_0f_GET BCMI_TSCE16_XGXS_PLL_CTL0r_LC_REFCLK_ADJ_1_0f_GET
#define PLL_CTL0r_LC_REFCLK_ADJ_1_0f_SET BCMI_TSCE16_XGXS_PLL_CTL0r_LC_REFCLK_ADJ_1_0f_SET
#define PLL_CTL0r_PLL_SPARE_0_0f_GET BCMI_TSCE16_XGXS_PLL_CTL0r_PLL_SPARE_0_0f_GET
#define PLL_CTL0r_PLL_SPARE_0_0f_SET BCMI_TSCE16_XGXS_PLL_CTL0r_PLL_SPARE_0_0f_SET
#define READ_PLL_CTL0r BCMI_TSCE16_XGXS_READ_PLL_CTL0r
#define WRITE_PLL_CTL0r BCMI_TSCE16_XGXS_WRITE_PLL_CTL0r
#define MODIFY_PLL_CTL0r BCMI_TSCE16_XGXS_MODIFY_PLL_CTL0r
#define READLN_PLL_CTL0r BCMI_TSCE16_XGXS_READLN_PLL_CTL0r
#define WRITELN_PLL_CTL0r BCMI_TSCE16_XGXS_WRITELN_PLL_CTL0r
#define WRITEALL_PLL_CTL0r BCMI_TSCE16_XGXS_WRITEALL_PLL_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PLL_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PLL_CTL1
 * BLOCKS:   AMSCOM
 * REGADDR:  0xd0b1
 * DESC:     PLL_CTRL_1
 * RESETVAL: 0x7 (7)
 * ACCESS:   R/W
 * FIELDS:
 *     CURR_SEL         Change Ipump (diffenrential) current settings, step size of 100uA. amsbus ctrl_out  19:16
 *     PLL_SPARE_1_0    AMS reserved[20:20] amsbus ctrl_out  20:20
 *     EN_8P5G_VCO      8.5G mode control. Turn on extra capacitor band. amsbus ctrl_out  21:21
 *     VCO_RANGE        VCO freq control bits. Refer to AMS VCO table for frequency details. amsbus ctrl_out  28:22
 *     ENB_8T           0: off; 1: enable RTL clock 8T amsbus ctrl_out  29:29
 *     ENB_10T          0: off; 1: enable RTL clock 10T amsbus ctrl_out  30:30
 *     EN_HCUR_VCO      Program the vco current 0:0%(defualt), 1: +20% amsbus ctrl_out  31:31
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PLL_CTL1r (0x0000d0b1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PLL_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CTL1.
 *
 */
typedef union BCMI_TSCE16_XGXS_PLL_CTL1r_s {
	uint32_t v[1];
	uint32_t pll_ctl1[1];
	uint32_t _pll_ctl1;
} BCMI_TSCE16_XGXS_PLL_CTL1r_t;

#define BCMI_TSCE16_XGXS_PLL_CTL1r_CLR(r) (r).pll_ctl1[0] = 0
#define BCMI_TSCE16_XGXS_PLL_CTL1r_SET(r,d) (r).pll_ctl1[0] = d
#define BCMI_TSCE16_XGXS_PLL_CTL1r_GET(r) (r).pll_ctl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PLL_CTL1r_EN_HCUR_VCOf_GET(r) ((((r).pll_ctl1[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CTL1r_EN_HCUR_VCOf_SET(r,f) (r).pll_ctl1[0]=(((r).pll_ctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_PLL_CTL1r_ENB_10Tf_GET(r) ((((r).pll_ctl1[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CTL1r_ENB_10Tf_SET(r,f) (r).pll_ctl1[0]=(((r).pll_ctl1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_PLL_CTL1r_ENB_8Tf_GET(r) ((((r).pll_ctl1[0]) >> 13) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CTL1r_ENB_8Tf_SET(r,f) (r).pll_ctl1[0]=(((r).pll_ctl1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCE16_XGXS_PLL_CTL1r_VCO_RANGEf_GET(r) ((((r).pll_ctl1[0]) >> 6) & 0x7f)
#define BCMI_TSCE16_XGXS_PLL_CTL1r_VCO_RANGEf_SET(r,f) (r).pll_ctl1[0]=(((r).pll_ctl1[0] & ~((uint32_t)0x7f << 6)) | ((((uint32_t)f) & 0x7f) << 6)) | (127 << (16 + 6))
#define BCMI_TSCE16_XGXS_PLL_CTL1r_EN_8P5G_VCOf_GET(r) ((((r).pll_ctl1[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CTL1r_EN_8P5G_VCOf_SET(r,f) (r).pll_ctl1[0]=(((r).pll_ctl1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_PLL_CTL1r_PLL_SPARE_1_0f_GET(r) ((((r).pll_ctl1[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CTL1r_PLL_SPARE_1_0f_SET(r,f) (r).pll_ctl1[0]=(((r).pll_ctl1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_PLL_CTL1r_CURR_SELf_GET(r) (((r).pll_ctl1[0]) & 0xf)
#define BCMI_TSCE16_XGXS_PLL_CTL1r_CURR_SELf_SET(r,f) (r).pll_ctl1[0]=(((r).pll_ctl1[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access PLL_CTL1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PLL_CTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CTL1r,(_r._pll_ctl1))
#define BCMI_TSCE16_XGXS_WRITE_PLL_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL1r,(_r._pll_ctl1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PLL_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL1r,(_r._pll_ctl1))
#define BCMI_TSCE16_XGXS_READLN_PLL_CTL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_ctl1))
#define BCMI_TSCE16_XGXS_WRITELN_PLL_CTL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_ctl1))
#define BCMI_TSCE16_XGXS_WRITEALL_PLL_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CTL1r BCMI_TSCE16_XGXS_PLL_CTL1r
#define PLL_CTL1r_SIZE BCMI_TSCE16_XGXS_PLL_CTL1r_SIZE
typedef BCMI_TSCE16_XGXS_PLL_CTL1r_t PLL_CTL1r_t;
#define PLL_CTL1r_CLR BCMI_TSCE16_XGXS_PLL_CTL1r_CLR
#define PLL_CTL1r_SET BCMI_TSCE16_XGXS_PLL_CTL1r_SET
#define PLL_CTL1r_GET BCMI_TSCE16_XGXS_PLL_CTL1r_GET
#define PLL_CTL1r_EN_HCUR_VCOf_GET BCMI_TSCE16_XGXS_PLL_CTL1r_EN_HCUR_VCOf_GET
#define PLL_CTL1r_EN_HCUR_VCOf_SET BCMI_TSCE16_XGXS_PLL_CTL1r_EN_HCUR_VCOf_SET
#define PLL_CTL1r_ENB_10Tf_GET BCMI_TSCE16_XGXS_PLL_CTL1r_ENB_10Tf_GET
#define PLL_CTL1r_ENB_10Tf_SET BCMI_TSCE16_XGXS_PLL_CTL1r_ENB_10Tf_SET
#define PLL_CTL1r_ENB_8Tf_GET BCMI_TSCE16_XGXS_PLL_CTL1r_ENB_8Tf_GET
#define PLL_CTL1r_ENB_8Tf_SET BCMI_TSCE16_XGXS_PLL_CTL1r_ENB_8Tf_SET
#define PLL_CTL1r_VCO_RANGEf_GET BCMI_TSCE16_XGXS_PLL_CTL1r_VCO_RANGEf_GET
#define PLL_CTL1r_VCO_RANGEf_SET BCMI_TSCE16_XGXS_PLL_CTL1r_VCO_RANGEf_SET
#define PLL_CTL1r_EN_8P5G_VCOf_GET BCMI_TSCE16_XGXS_PLL_CTL1r_EN_8P5G_VCOf_GET
#define PLL_CTL1r_EN_8P5G_VCOf_SET BCMI_TSCE16_XGXS_PLL_CTL1r_EN_8P5G_VCOf_SET
#define PLL_CTL1r_PLL_SPARE_1_0f_GET BCMI_TSCE16_XGXS_PLL_CTL1r_PLL_SPARE_1_0f_GET
#define PLL_CTL1r_PLL_SPARE_1_0f_SET BCMI_TSCE16_XGXS_PLL_CTL1r_PLL_SPARE_1_0f_SET
#define PLL_CTL1r_CURR_SELf_GET BCMI_TSCE16_XGXS_PLL_CTL1r_CURR_SELf_GET
#define PLL_CTL1r_CURR_SELf_SET BCMI_TSCE16_XGXS_PLL_CTL1r_CURR_SELf_SET
#define READ_PLL_CTL1r BCMI_TSCE16_XGXS_READ_PLL_CTL1r
#define WRITE_PLL_CTL1r BCMI_TSCE16_XGXS_WRITE_PLL_CTL1r
#define MODIFY_PLL_CTL1r BCMI_TSCE16_XGXS_MODIFY_PLL_CTL1r
#define READLN_PLL_CTL1r BCMI_TSCE16_XGXS_READLN_PLL_CTL1r
#define WRITELN_PLL_CTL1r BCMI_TSCE16_XGXS_WRITELN_PLL_CTL1r
#define WRITEALL_PLL_CTL1r BCMI_TSCE16_XGXS_WRITEALL_PLL_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PLL_CTL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PLL_CTL2
 * BLOCKS:   AMSCOM
 * REGADDR:  0xd0b2
 * DESC:     PLL_CTRL_2
 * RESETVAL: 0x80 (128)
 * ACCESS:   R/W
 * FIELDS:
 *     VCO_PON          Resistor Calibration control setting, used to control VCO current as well. Dfs=0 for offset value amsbus ctrl_out  35:32
 *     EN_8P5G          8.5G mode control, trun on extra capacitor band to lower VCO frequency. amsbus ctrl_out  36:36
 *     CALIB_ADJ        Set control voltage for the calibration. amsbus ctrl_out  39:37
 *     EN_CMOS_REFCLK_CH_HIZ 1: Enable o_pll_cmos_refclk when it is used as an input or output channel,0:default amsbus ctrl_out  40:40
 *     PLL_CLKVCO_CAL_INVERT Edge selection for VCO calibration (0:rising edge, 1:falling edge) amsbus ctrl_out  41:41
 *     VCOBUF_PON       Resistor Calibration control setting, used to control VCO buffer current as well. Dfs=0 for offset value. amsbus ctrl_out  45:42
 *     EN_I4IQBUF       Control IQ TX/RX buffer current. amsbus ctrl_out  47:46
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PLL_CTL2r (0x0000d0b2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PLL_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CTL2.
 *
 */
typedef union BCMI_TSCE16_XGXS_PLL_CTL2r_s {
	uint32_t v[1];
	uint32_t pll_ctl2[1];
	uint32_t _pll_ctl2;
} BCMI_TSCE16_XGXS_PLL_CTL2r_t;

#define BCMI_TSCE16_XGXS_PLL_CTL2r_CLR(r) (r).pll_ctl2[0] = 0
#define BCMI_TSCE16_XGXS_PLL_CTL2r_SET(r,d) (r).pll_ctl2[0] = d
#define BCMI_TSCE16_XGXS_PLL_CTL2r_GET(r) (r).pll_ctl2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PLL_CTL2r_EN_I4IQBUFf_GET(r) ((((r).pll_ctl2[0]) >> 14) & 0x3)
#define BCMI_TSCE16_XGXS_PLL_CTL2r_EN_I4IQBUFf_SET(r,f) (r).pll_ctl2[0]=(((r).pll_ctl2[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCE16_XGXS_PLL_CTL2r_VCOBUF_PONf_GET(r) ((((r).pll_ctl2[0]) >> 10) & 0xf)
#define BCMI_TSCE16_XGXS_PLL_CTL2r_VCOBUF_PONf_SET(r,f) (r).pll_ctl2[0]=(((r).pll_ctl2[0] & ~((uint32_t)0xf << 10)) | ((((uint32_t)f) & 0xf) << 10)) | (15 << (16 + 10))
#define BCMI_TSCE16_XGXS_PLL_CTL2r_PLL_CLKVCO_CAL_INVERTf_GET(r) ((((r).pll_ctl2[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CTL2r_PLL_CLKVCO_CAL_INVERTf_SET(r,f) (r).pll_ctl2[0]=(((r).pll_ctl2[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_PLL_CTL2r_EN_CMOS_REFCLK_CH_HIZf_GET(r) ((((r).pll_ctl2[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CTL2r_EN_CMOS_REFCLK_CH_HIZf_SET(r,f) (r).pll_ctl2[0]=(((r).pll_ctl2[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_PLL_CTL2r_CALIB_ADJf_GET(r) ((((r).pll_ctl2[0]) >> 5) & 0x7)
#define BCMI_TSCE16_XGXS_PLL_CTL2r_CALIB_ADJf_SET(r,f) (r).pll_ctl2[0]=(((r).pll_ctl2[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5)) | (7 << (16 + 5))
#define BCMI_TSCE16_XGXS_PLL_CTL2r_EN_8P5Gf_GET(r) ((((r).pll_ctl2[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CTL2r_EN_8P5Gf_SET(r,f) (r).pll_ctl2[0]=(((r).pll_ctl2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_PLL_CTL2r_VCO_PONf_GET(r) (((r).pll_ctl2[0]) & 0xf)
#define BCMI_TSCE16_XGXS_PLL_CTL2r_VCO_PONf_SET(r,f) (r).pll_ctl2[0]=(((r).pll_ctl2[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access PLL_CTL2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PLL_CTL2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CTL2r,(_r._pll_ctl2))
#define BCMI_TSCE16_XGXS_WRITE_PLL_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL2r,(_r._pll_ctl2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PLL_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL2r,(_r._pll_ctl2))
#define BCMI_TSCE16_XGXS_READLN_PLL_CTL2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_ctl2))
#define BCMI_TSCE16_XGXS_WRITELN_PLL_CTL2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_ctl2))
#define BCMI_TSCE16_XGXS_WRITEALL_PLL_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CTL2r BCMI_TSCE16_XGXS_PLL_CTL2r
#define PLL_CTL2r_SIZE BCMI_TSCE16_XGXS_PLL_CTL2r_SIZE
typedef BCMI_TSCE16_XGXS_PLL_CTL2r_t PLL_CTL2r_t;
#define PLL_CTL2r_CLR BCMI_TSCE16_XGXS_PLL_CTL2r_CLR
#define PLL_CTL2r_SET BCMI_TSCE16_XGXS_PLL_CTL2r_SET
#define PLL_CTL2r_GET BCMI_TSCE16_XGXS_PLL_CTL2r_GET
#define PLL_CTL2r_EN_I4IQBUFf_GET BCMI_TSCE16_XGXS_PLL_CTL2r_EN_I4IQBUFf_GET
#define PLL_CTL2r_EN_I4IQBUFf_SET BCMI_TSCE16_XGXS_PLL_CTL2r_EN_I4IQBUFf_SET
#define PLL_CTL2r_VCOBUF_PONf_GET BCMI_TSCE16_XGXS_PLL_CTL2r_VCOBUF_PONf_GET
#define PLL_CTL2r_VCOBUF_PONf_SET BCMI_TSCE16_XGXS_PLL_CTL2r_VCOBUF_PONf_SET
#define PLL_CTL2r_PLL_CLKVCO_CAL_INVERTf_GET BCMI_TSCE16_XGXS_PLL_CTL2r_PLL_CLKVCO_CAL_INVERTf_GET
#define PLL_CTL2r_PLL_CLKVCO_CAL_INVERTf_SET BCMI_TSCE16_XGXS_PLL_CTL2r_PLL_CLKVCO_CAL_INVERTf_SET
#define PLL_CTL2r_EN_CMOS_REFCLK_CH_HIZf_GET BCMI_TSCE16_XGXS_PLL_CTL2r_EN_CMOS_REFCLK_CH_HIZf_GET
#define PLL_CTL2r_EN_CMOS_REFCLK_CH_HIZf_SET BCMI_TSCE16_XGXS_PLL_CTL2r_EN_CMOS_REFCLK_CH_HIZf_SET
#define PLL_CTL2r_CALIB_ADJf_GET BCMI_TSCE16_XGXS_PLL_CTL2r_CALIB_ADJf_GET
#define PLL_CTL2r_CALIB_ADJf_SET BCMI_TSCE16_XGXS_PLL_CTL2r_CALIB_ADJf_SET
#define PLL_CTL2r_EN_8P5Gf_GET BCMI_TSCE16_XGXS_PLL_CTL2r_EN_8P5Gf_GET
#define PLL_CTL2r_EN_8P5Gf_SET BCMI_TSCE16_XGXS_PLL_CTL2r_EN_8P5Gf_SET
#define PLL_CTL2r_VCO_PONf_GET BCMI_TSCE16_XGXS_PLL_CTL2r_VCO_PONf_GET
#define PLL_CTL2r_VCO_PONf_SET BCMI_TSCE16_XGXS_PLL_CTL2r_VCO_PONf_SET
#define READ_PLL_CTL2r BCMI_TSCE16_XGXS_READ_PLL_CTL2r
#define WRITE_PLL_CTL2r BCMI_TSCE16_XGXS_WRITE_PLL_CTL2r
#define MODIFY_PLL_CTL2r BCMI_TSCE16_XGXS_MODIFY_PLL_CTL2r
#define READLN_PLL_CTL2r BCMI_TSCE16_XGXS_READLN_PLL_CTL2r
#define WRITELN_PLL_CTL2r BCMI_TSCE16_XGXS_WRITELN_PLL_CTL2r
#define WRITEALL_PLL_CTL2r BCMI_TSCE16_XGXS_WRITEALL_PLL_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PLL_CTL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PLL_CTL3
 * BLOCKS:   AMSCOM
 * REGADDR:  0xd0b3
 * DESC:     PLL_CTRL_3
 * RESETVAL: 0x460e (17934)
 * ACCESS:   R/W
 * FIELDS:
 *     BAND_IQBUF_CTR   TX/RX IQ Clock buffer band controls amsbus ctrl_out  50:48
 *     ENB_16T          1: Enable o_pll_cmos_vco16; 0: Off amsbus ctrl_out  51:51
 *     EN_TEST_FRAC_CLK 1:enable frac-N divider (MMD) output as CMOS test clock amsbus ctrl_out  52:52
 *     EN_CML_REFOUT_OVERWR 1:en_cml_refout thru pll_ctrl[57], 0:thru i_pd_CML_refclk_out pin. en_cml_refout_overwrite in AMS amsbus ctrl_out  53:53
 *     EN_CMOS_REFOUT_OVERWR 1:en_cmos_refout thru pll_ctrl[58], 0:thru refsel<2> pin. en_cmos_refout_overwrite in AMS amsbus ctrl_out  54:54
 *     EN_RCLK_REFOUT   1:select RX recovered clk as the clock source for en_cmos_refout. amsbus ctrl_out  55:55
 *     PLLCLKSEL        Select the clock source for en_cmos_refout. amsbus ctrl_out  56:56
 *     REF_CML_PD       When pll_ctrl<53>=1 0: CML reference is on; When pll_ctrl<53>=0 X: CML reference is off amsbus ctrl_out  57:57
 *     REF_CMOS_HZ      When pll_ctrl<54>=1 0: refcmos is not high Z;when pll_ctrl<54>=0 X: refcmos is high Z amsbus ctrl_out  58:58
 *     REF_CML_CURX2    Refer AMS for description. amsbus ctrl_out  59:59
 *     CP_BIAS          CP Bias setting amsbus ctrl_out  62:60
 *     EN_MMD_HALFRATE  0: Use 1T clock; 1: Use 2T clock amsbus ctrl_out  63:63
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PLL_CTL3r (0x0000d0b3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PLL_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CTL3.
 *
 */
typedef union BCMI_TSCE16_XGXS_PLL_CTL3r_s {
	uint32_t v[1];
	uint32_t pll_ctl3[1];
	uint32_t _pll_ctl3;
} BCMI_TSCE16_XGXS_PLL_CTL3r_t;

#define BCMI_TSCE16_XGXS_PLL_CTL3r_CLR(r) (r).pll_ctl3[0] = 0
#define BCMI_TSCE16_XGXS_PLL_CTL3r_SET(r,d) (r).pll_ctl3[0] = d
#define BCMI_TSCE16_XGXS_PLL_CTL3r_GET(r) (r).pll_ctl3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PLL_CTL3r_EN_MMD_HALFRATEf_GET(r) ((((r).pll_ctl3[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CTL3r_EN_MMD_HALFRATEf_SET(r,f) (r).pll_ctl3[0]=(((r).pll_ctl3[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_PLL_CTL3r_CP_BIASf_GET(r) ((((r).pll_ctl3[0]) >> 12) & 0x7)
#define BCMI_TSCE16_XGXS_PLL_CTL3r_CP_BIASf_SET(r,f) (r).pll_ctl3[0]=(((r).pll_ctl3[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12)) | (7 << (16 + 12))
#define BCMI_TSCE16_XGXS_PLL_CTL3r_REF_CML_CURX2f_GET(r) ((((r).pll_ctl3[0]) >> 11) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CTL3r_REF_CML_CURX2f_SET(r,f) (r).pll_ctl3[0]=(((r).pll_ctl3[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCE16_XGXS_PLL_CTL3r_REF_CMOS_HZf_GET(r) ((((r).pll_ctl3[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CTL3r_REF_CMOS_HZf_SET(r,f) (r).pll_ctl3[0]=(((r).pll_ctl3[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_PLL_CTL3r_REF_CML_PDf_GET(r) ((((r).pll_ctl3[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CTL3r_REF_CML_PDf_SET(r,f) (r).pll_ctl3[0]=(((r).pll_ctl3[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_PLL_CTL3r_PLLCLKSELf_GET(r) ((((r).pll_ctl3[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CTL3r_PLLCLKSELf_SET(r,f) (r).pll_ctl3[0]=(((r).pll_ctl3[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_PLL_CTL3r_EN_RCLK_REFOUTf_GET(r) ((((r).pll_ctl3[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CTL3r_EN_RCLK_REFOUTf_SET(r,f) (r).pll_ctl3[0]=(((r).pll_ctl3[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_PLL_CTL3r_EN_CMOS_REFOUT_OVERWRf_GET(r) ((((r).pll_ctl3[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CTL3r_EN_CMOS_REFOUT_OVERWRf_SET(r,f) (r).pll_ctl3[0]=(((r).pll_ctl3[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_PLL_CTL3r_EN_CML_REFOUT_OVERWRf_GET(r) ((((r).pll_ctl3[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CTL3r_EN_CML_REFOUT_OVERWRf_SET(r,f) (r).pll_ctl3[0]=(((r).pll_ctl3[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_PLL_CTL3r_EN_TEST_FRAC_CLKf_GET(r) ((((r).pll_ctl3[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CTL3r_EN_TEST_FRAC_CLKf_SET(r,f) (r).pll_ctl3[0]=(((r).pll_ctl3[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_PLL_CTL3r_ENB_16Tf_GET(r) ((((r).pll_ctl3[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CTL3r_ENB_16Tf_SET(r,f) (r).pll_ctl3[0]=(((r).pll_ctl3[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_PLL_CTL3r_BAND_IQBUF_CTRf_GET(r) (((r).pll_ctl3[0]) & 0x7)
#define BCMI_TSCE16_XGXS_PLL_CTL3r_BAND_IQBUF_CTRf_SET(r,f) (r).pll_ctl3[0]=(((r).pll_ctl3[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access PLL_CTL3.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PLL_CTL3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CTL3r,(_r._pll_ctl3))
#define BCMI_TSCE16_XGXS_WRITE_PLL_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL3r,(_r._pll_ctl3)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PLL_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL3r,(_r._pll_ctl3))
#define BCMI_TSCE16_XGXS_READLN_PLL_CTL3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_ctl3))
#define BCMI_TSCE16_XGXS_WRITELN_PLL_CTL3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_ctl3))
#define BCMI_TSCE16_XGXS_WRITEALL_PLL_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_ctl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CTL3r BCMI_TSCE16_XGXS_PLL_CTL3r
#define PLL_CTL3r_SIZE BCMI_TSCE16_XGXS_PLL_CTL3r_SIZE
typedef BCMI_TSCE16_XGXS_PLL_CTL3r_t PLL_CTL3r_t;
#define PLL_CTL3r_CLR BCMI_TSCE16_XGXS_PLL_CTL3r_CLR
#define PLL_CTL3r_SET BCMI_TSCE16_XGXS_PLL_CTL3r_SET
#define PLL_CTL3r_GET BCMI_TSCE16_XGXS_PLL_CTL3r_GET
#define PLL_CTL3r_EN_MMD_HALFRATEf_GET BCMI_TSCE16_XGXS_PLL_CTL3r_EN_MMD_HALFRATEf_GET
#define PLL_CTL3r_EN_MMD_HALFRATEf_SET BCMI_TSCE16_XGXS_PLL_CTL3r_EN_MMD_HALFRATEf_SET
#define PLL_CTL3r_CP_BIASf_GET BCMI_TSCE16_XGXS_PLL_CTL3r_CP_BIASf_GET
#define PLL_CTL3r_CP_BIASf_SET BCMI_TSCE16_XGXS_PLL_CTL3r_CP_BIASf_SET
#define PLL_CTL3r_REF_CML_CURX2f_GET BCMI_TSCE16_XGXS_PLL_CTL3r_REF_CML_CURX2f_GET
#define PLL_CTL3r_REF_CML_CURX2f_SET BCMI_TSCE16_XGXS_PLL_CTL3r_REF_CML_CURX2f_SET
#define PLL_CTL3r_REF_CMOS_HZf_GET BCMI_TSCE16_XGXS_PLL_CTL3r_REF_CMOS_HZf_GET
#define PLL_CTL3r_REF_CMOS_HZf_SET BCMI_TSCE16_XGXS_PLL_CTL3r_REF_CMOS_HZf_SET
#define PLL_CTL3r_REF_CML_PDf_GET BCMI_TSCE16_XGXS_PLL_CTL3r_REF_CML_PDf_GET
#define PLL_CTL3r_REF_CML_PDf_SET BCMI_TSCE16_XGXS_PLL_CTL3r_REF_CML_PDf_SET
#define PLL_CTL3r_PLLCLKSELf_GET BCMI_TSCE16_XGXS_PLL_CTL3r_PLLCLKSELf_GET
#define PLL_CTL3r_PLLCLKSELf_SET BCMI_TSCE16_XGXS_PLL_CTL3r_PLLCLKSELf_SET
#define PLL_CTL3r_EN_RCLK_REFOUTf_GET BCMI_TSCE16_XGXS_PLL_CTL3r_EN_RCLK_REFOUTf_GET
#define PLL_CTL3r_EN_RCLK_REFOUTf_SET BCMI_TSCE16_XGXS_PLL_CTL3r_EN_RCLK_REFOUTf_SET
#define PLL_CTL3r_EN_CMOS_REFOUT_OVERWRf_GET BCMI_TSCE16_XGXS_PLL_CTL3r_EN_CMOS_REFOUT_OVERWRf_GET
#define PLL_CTL3r_EN_CMOS_REFOUT_OVERWRf_SET BCMI_TSCE16_XGXS_PLL_CTL3r_EN_CMOS_REFOUT_OVERWRf_SET
#define PLL_CTL3r_EN_CML_REFOUT_OVERWRf_GET BCMI_TSCE16_XGXS_PLL_CTL3r_EN_CML_REFOUT_OVERWRf_GET
#define PLL_CTL3r_EN_CML_REFOUT_OVERWRf_SET BCMI_TSCE16_XGXS_PLL_CTL3r_EN_CML_REFOUT_OVERWRf_SET
#define PLL_CTL3r_EN_TEST_FRAC_CLKf_GET BCMI_TSCE16_XGXS_PLL_CTL3r_EN_TEST_FRAC_CLKf_GET
#define PLL_CTL3r_EN_TEST_FRAC_CLKf_SET BCMI_TSCE16_XGXS_PLL_CTL3r_EN_TEST_FRAC_CLKf_SET
#define PLL_CTL3r_ENB_16Tf_GET BCMI_TSCE16_XGXS_PLL_CTL3r_ENB_16Tf_GET
#define PLL_CTL3r_ENB_16Tf_SET BCMI_TSCE16_XGXS_PLL_CTL3r_ENB_16Tf_SET
#define PLL_CTL3r_BAND_IQBUF_CTRf_GET BCMI_TSCE16_XGXS_PLL_CTL3r_BAND_IQBUF_CTRf_GET
#define PLL_CTL3r_BAND_IQBUF_CTRf_SET BCMI_TSCE16_XGXS_PLL_CTL3r_BAND_IQBUF_CTRf_SET
#define READ_PLL_CTL3r BCMI_TSCE16_XGXS_READ_PLL_CTL3r
#define WRITE_PLL_CTL3r BCMI_TSCE16_XGXS_WRITE_PLL_CTL3r
#define MODIFY_PLL_CTL3r BCMI_TSCE16_XGXS_MODIFY_PLL_CTL3r
#define READLN_PLL_CTL3r BCMI_TSCE16_XGXS_READLN_PLL_CTL3r
#define WRITELN_PLL_CTL3r BCMI_TSCE16_XGXS_WRITELN_PLL_CTL3r
#define WRITEALL_PLL_CTL3r BCMI_TSCE16_XGXS_WRITEALL_PLL_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PLL_CTL3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PLL_CTL4
 * BLOCKS:   AMSCOM
 * REGADDR:  0xd0b4
 * DESC:     PLL_CTRL_4
 * RESETVAL: 0x501 (1281)
 * ACCESS:   R/W
 * FIELDS:
 *     LC_REFCLK_ADJ_3_2 Set the refclk input and output bias for LC ref channel amsbus ctrl_out  65:64
 *     CP_OPAMP_BIAS    increase ref current for the CP. amsbus ctrl_out  67:66
 *     CMOS_TPORT_EN    Refer AMS for description. amsbus ctrl_out  68:68
 *     BIAS_VDD_SEL     00: 0.80V; 01: 0.88V; 10: 0.73V; 11: 0.98V amsbus ctrl_out  70:69
 *     VCO_HKVCO        Refer AMS for description. amsbus ctrl_out  71:71
 *     BIAS_EN          0: Bias Block is Off; 1: Normal Operation, Bias Enabled amsbus ctrl_out  72:72
 *     VCO_TEST_CLK_EN  VCO Divider Test Enable amsbus ctrl_out  73:73
 *     TEST_AMP         Sets amplitude without changing the output impedence amsbus ctrl_out  75:74
 *     TEST_SEL         Selects the signal to be tested amsbus ctrl_out  78:76
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PLL_CTL4r (0x0000d0b4 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PLL_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CTL4.
 *
 */
typedef union BCMI_TSCE16_XGXS_PLL_CTL4r_s {
	uint32_t v[1];
	uint32_t pll_ctl4[1];
	uint32_t _pll_ctl4;
} BCMI_TSCE16_XGXS_PLL_CTL4r_t;

#define BCMI_TSCE16_XGXS_PLL_CTL4r_CLR(r) (r).pll_ctl4[0] = 0
#define BCMI_TSCE16_XGXS_PLL_CTL4r_SET(r,d) (r).pll_ctl4[0] = d
#define BCMI_TSCE16_XGXS_PLL_CTL4r_GET(r) (r).pll_ctl4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PLL_CTL4r_TEST_SELf_GET(r) ((((r).pll_ctl4[0]) >> 12) & 0x7)
#define BCMI_TSCE16_XGXS_PLL_CTL4r_TEST_SELf_SET(r,f) (r).pll_ctl4[0]=(((r).pll_ctl4[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12)) | (7 << (16 + 12))
#define BCMI_TSCE16_XGXS_PLL_CTL4r_TEST_AMPf_GET(r) ((((r).pll_ctl4[0]) >> 10) & 0x3)
#define BCMI_TSCE16_XGXS_PLL_CTL4r_TEST_AMPf_SET(r,f) (r).pll_ctl4[0]=(((r).pll_ctl4[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCE16_XGXS_PLL_CTL4r_VCO_TEST_CLK_ENf_GET(r) ((((r).pll_ctl4[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CTL4r_VCO_TEST_CLK_ENf_SET(r,f) (r).pll_ctl4[0]=(((r).pll_ctl4[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_PLL_CTL4r_BIAS_ENf_GET(r) ((((r).pll_ctl4[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CTL4r_BIAS_ENf_SET(r,f) (r).pll_ctl4[0]=(((r).pll_ctl4[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_PLL_CTL4r_VCO_HKVCOf_GET(r) ((((r).pll_ctl4[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CTL4r_VCO_HKVCOf_SET(r,f) (r).pll_ctl4[0]=(((r).pll_ctl4[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_PLL_CTL4r_BIAS_VDD_SELf_GET(r) ((((r).pll_ctl4[0]) >> 5) & 0x3)
#define BCMI_TSCE16_XGXS_PLL_CTL4r_BIAS_VDD_SELf_SET(r,f) (r).pll_ctl4[0]=(((r).pll_ctl4[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5)) | (3 << (16 + 5))
#define BCMI_TSCE16_XGXS_PLL_CTL4r_CMOS_TPORT_ENf_GET(r) ((((r).pll_ctl4[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CTL4r_CMOS_TPORT_ENf_SET(r,f) (r).pll_ctl4[0]=(((r).pll_ctl4[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_PLL_CTL4r_CP_OPAMP_BIASf_GET(r) ((((r).pll_ctl4[0]) >> 2) & 0x3)
#define BCMI_TSCE16_XGXS_PLL_CTL4r_CP_OPAMP_BIASf_SET(r,f) (r).pll_ctl4[0]=(((r).pll_ctl4[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCE16_XGXS_PLL_CTL4r_LC_REFCLK_ADJ_3_2f_GET(r) (((r).pll_ctl4[0]) & 0x3)
#define BCMI_TSCE16_XGXS_PLL_CTL4r_LC_REFCLK_ADJ_3_2f_SET(r,f) (r).pll_ctl4[0]=(((r).pll_ctl4[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access PLL_CTL4.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PLL_CTL4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CTL4r,(_r._pll_ctl4))
#define BCMI_TSCE16_XGXS_WRITE_PLL_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL4r,(_r._pll_ctl4)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PLL_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL4r,(_r._pll_ctl4))
#define BCMI_TSCE16_XGXS_READLN_PLL_CTL4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_ctl4))
#define BCMI_TSCE16_XGXS_WRITELN_PLL_CTL4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_ctl4))
#define BCMI_TSCE16_XGXS_WRITEALL_PLL_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_ctl4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CTL4r BCMI_TSCE16_XGXS_PLL_CTL4r
#define PLL_CTL4r_SIZE BCMI_TSCE16_XGXS_PLL_CTL4r_SIZE
typedef BCMI_TSCE16_XGXS_PLL_CTL4r_t PLL_CTL4r_t;
#define PLL_CTL4r_CLR BCMI_TSCE16_XGXS_PLL_CTL4r_CLR
#define PLL_CTL4r_SET BCMI_TSCE16_XGXS_PLL_CTL4r_SET
#define PLL_CTL4r_GET BCMI_TSCE16_XGXS_PLL_CTL4r_GET
#define PLL_CTL4r_TEST_SELf_GET BCMI_TSCE16_XGXS_PLL_CTL4r_TEST_SELf_GET
#define PLL_CTL4r_TEST_SELf_SET BCMI_TSCE16_XGXS_PLL_CTL4r_TEST_SELf_SET
#define PLL_CTL4r_TEST_AMPf_GET BCMI_TSCE16_XGXS_PLL_CTL4r_TEST_AMPf_GET
#define PLL_CTL4r_TEST_AMPf_SET BCMI_TSCE16_XGXS_PLL_CTL4r_TEST_AMPf_SET
#define PLL_CTL4r_VCO_TEST_CLK_ENf_GET BCMI_TSCE16_XGXS_PLL_CTL4r_VCO_TEST_CLK_ENf_GET
#define PLL_CTL4r_VCO_TEST_CLK_ENf_SET BCMI_TSCE16_XGXS_PLL_CTL4r_VCO_TEST_CLK_ENf_SET
#define PLL_CTL4r_BIAS_ENf_GET BCMI_TSCE16_XGXS_PLL_CTL4r_BIAS_ENf_GET
#define PLL_CTL4r_BIAS_ENf_SET BCMI_TSCE16_XGXS_PLL_CTL4r_BIAS_ENf_SET
#define PLL_CTL4r_VCO_HKVCOf_GET BCMI_TSCE16_XGXS_PLL_CTL4r_VCO_HKVCOf_GET
#define PLL_CTL4r_VCO_HKVCOf_SET BCMI_TSCE16_XGXS_PLL_CTL4r_VCO_HKVCOf_SET
#define PLL_CTL4r_BIAS_VDD_SELf_GET BCMI_TSCE16_XGXS_PLL_CTL4r_BIAS_VDD_SELf_GET
#define PLL_CTL4r_BIAS_VDD_SELf_SET BCMI_TSCE16_XGXS_PLL_CTL4r_BIAS_VDD_SELf_SET
#define PLL_CTL4r_CMOS_TPORT_ENf_GET BCMI_TSCE16_XGXS_PLL_CTL4r_CMOS_TPORT_ENf_GET
#define PLL_CTL4r_CMOS_TPORT_ENf_SET BCMI_TSCE16_XGXS_PLL_CTL4r_CMOS_TPORT_ENf_SET
#define PLL_CTL4r_CP_OPAMP_BIASf_GET BCMI_TSCE16_XGXS_PLL_CTL4r_CP_OPAMP_BIASf_GET
#define PLL_CTL4r_CP_OPAMP_BIASf_SET BCMI_TSCE16_XGXS_PLL_CTL4r_CP_OPAMP_BIASf_SET
#define PLL_CTL4r_LC_REFCLK_ADJ_3_2f_GET BCMI_TSCE16_XGXS_PLL_CTL4r_LC_REFCLK_ADJ_3_2f_GET
#define PLL_CTL4r_LC_REFCLK_ADJ_3_2f_SET BCMI_TSCE16_XGXS_PLL_CTL4r_LC_REFCLK_ADJ_3_2f_SET
#define READ_PLL_CTL4r BCMI_TSCE16_XGXS_READ_PLL_CTL4r
#define WRITE_PLL_CTL4r BCMI_TSCE16_XGXS_WRITE_PLL_CTL4r
#define MODIFY_PLL_CTL4r BCMI_TSCE16_XGXS_MODIFY_PLL_CTL4r
#define READLN_PLL_CTL4r BCMI_TSCE16_XGXS_READLN_PLL_CTL4r
#define WRITELN_PLL_CTL4r BCMI_TSCE16_XGXS_WRITELN_PLL_CTL4r
#define WRITEALL_PLL_CTL4r BCMI_TSCE16_XGXS_WRITEALL_PLL_CTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PLL_CTL4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PLL_CTL5
 * BLOCKS:   AMSCOM
 * REGADDR:  0xd0b5
 * DESC:     PLL_CTRL_5
 * RESETVAL: 0x1405 (5125)
 * ACCESS:   R/W
 * FIELDS:
 *     REFOUT_DIV_SEL   reference divider selection amsbus ctrl_out  81:79
 *     TEST_VC          Enable VCO control voltage on PTESTP/N; active high amsbus ctrl_out  82:82
 *     TEST_SEL_OVERWRITE 0: testport sel thr i_testsel[2:0], 1: testport sel thr pll_ctrl[78:76]. amsbus ctrl_out  83:83
 *     TERM_SEL         reference clock pairs input termination. REFCLK input term_sel in AMS amsbus ctrl_out  85:84
 *     PLL_PWRDN        1= Power down the PLL core (~8mA reduction) amsbus ctrl_out  86:86
 *     EN_REFOUT_DIV    0: Reference Divider Off; 1: Reference Divider On amsbus ctrl_out  87:87
 *     PWDB_EXTR_D2C    0: power down the dummy D2C for IQ buffer amsbus ctrl_out  88:88
 *     REFDIV_TEST_SEL  Reference Divider Test Selection amsbus ctrl_out  91:89
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PLL_CTL5r (0x0000d0b5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PLL_CTL5r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CTL5.
 *
 */
typedef union BCMI_TSCE16_XGXS_PLL_CTL5r_s {
	uint32_t v[1];
	uint32_t pll_ctl5[1];
	uint32_t _pll_ctl5;
} BCMI_TSCE16_XGXS_PLL_CTL5r_t;

#define BCMI_TSCE16_XGXS_PLL_CTL5r_CLR(r) (r).pll_ctl5[0] = 0
#define BCMI_TSCE16_XGXS_PLL_CTL5r_SET(r,d) (r).pll_ctl5[0] = d
#define BCMI_TSCE16_XGXS_PLL_CTL5r_GET(r) (r).pll_ctl5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PLL_CTL5r_REFDIV_TEST_SELf_GET(r) ((((r).pll_ctl5[0]) >> 10) & 0x7)
#define BCMI_TSCE16_XGXS_PLL_CTL5r_REFDIV_TEST_SELf_SET(r,f) (r).pll_ctl5[0]=(((r).pll_ctl5[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10)) | (7 << (16 + 10))
#define BCMI_TSCE16_XGXS_PLL_CTL5r_PWDB_EXTR_D2Cf_GET(r) ((((r).pll_ctl5[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CTL5r_PWDB_EXTR_D2Cf_SET(r,f) (r).pll_ctl5[0]=(((r).pll_ctl5[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_PLL_CTL5r_EN_REFOUT_DIVf_GET(r) ((((r).pll_ctl5[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CTL5r_EN_REFOUT_DIVf_SET(r,f) (r).pll_ctl5[0]=(((r).pll_ctl5[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_PLL_CTL5r_PLL_PWRDNf_GET(r) ((((r).pll_ctl5[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CTL5r_PLL_PWRDNf_SET(r,f) (r).pll_ctl5[0]=(((r).pll_ctl5[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_PLL_CTL5r_TERM_SELf_GET(r) ((((r).pll_ctl5[0]) >> 5) & 0x3)
#define BCMI_TSCE16_XGXS_PLL_CTL5r_TERM_SELf_SET(r,f) (r).pll_ctl5[0]=(((r).pll_ctl5[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5)) | (3 << (16 + 5))
#define BCMI_TSCE16_XGXS_PLL_CTL5r_TEST_SEL_OVERWRITEf_GET(r) ((((r).pll_ctl5[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CTL5r_TEST_SEL_OVERWRITEf_SET(r,f) (r).pll_ctl5[0]=(((r).pll_ctl5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_PLL_CTL5r_TEST_VCf_GET(r) ((((r).pll_ctl5[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CTL5r_TEST_VCf_SET(r,f) (r).pll_ctl5[0]=(((r).pll_ctl5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_PLL_CTL5r_REFOUT_DIV_SELf_GET(r) (((r).pll_ctl5[0]) & 0x7)
#define BCMI_TSCE16_XGXS_PLL_CTL5r_REFOUT_DIV_SELf_SET(r,f) (r).pll_ctl5[0]=(((r).pll_ctl5[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access PLL_CTL5.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PLL_CTL5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CTL5r,(_r._pll_ctl5))
#define BCMI_TSCE16_XGXS_WRITE_PLL_CTL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL5r,(_r._pll_ctl5)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PLL_CTL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL5r,(_r._pll_ctl5))
#define BCMI_TSCE16_XGXS_READLN_PLL_CTL5r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_ctl5))
#define BCMI_TSCE16_XGXS_WRITELN_PLL_CTL5r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_ctl5))
#define BCMI_TSCE16_XGXS_WRITEALL_PLL_CTL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_ctl5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CTL5r BCMI_TSCE16_XGXS_PLL_CTL5r
#define PLL_CTL5r_SIZE BCMI_TSCE16_XGXS_PLL_CTL5r_SIZE
typedef BCMI_TSCE16_XGXS_PLL_CTL5r_t PLL_CTL5r_t;
#define PLL_CTL5r_CLR BCMI_TSCE16_XGXS_PLL_CTL5r_CLR
#define PLL_CTL5r_SET BCMI_TSCE16_XGXS_PLL_CTL5r_SET
#define PLL_CTL5r_GET BCMI_TSCE16_XGXS_PLL_CTL5r_GET
#define PLL_CTL5r_REFDIV_TEST_SELf_GET BCMI_TSCE16_XGXS_PLL_CTL5r_REFDIV_TEST_SELf_GET
#define PLL_CTL5r_REFDIV_TEST_SELf_SET BCMI_TSCE16_XGXS_PLL_CTL5r_REFDIV_TEST_SELf_SET
#define PLL_CTL5r_PWDB_EXTR_D2Cf_GET BCMI_TSCE16_XGXS_PLL_CTL5r_PWDB_EXTR_D2Cf_GET
#define PLL_CTL5r_PWDB_EXTR_D2Cf_SET BCMI_TSCE16_XGXS_PLL_CTL5r_PWDB_EXTR_D2Cf_SET
#define PLL_CTL5r_EN_REFOUT_DIVf_GET BCMI_TSCE16_XGXS_PLL_CTL5r_EN_REFOUT_DIVf_GET
#define PLL_CTL5r_EN_REFOUT_DIVf_SET BCMI_TSCE16_XGXS_PLL_CTL5r_EN_REFOUT_DIVf_SET
#define PLL_CTL5r_PLL_PWRDNf_GET BCMI_TSCE16_XGXS_PLL_CTL5r_PLL_PWRDNf_GET
#define PLL_CTL5r_PLL_PWRDNf_SET BCMI_TSCE16_XGXS_PLL_CTL5r_PLL_PWRDNf_SET
#define PLL_CTL5r_TERM_SELf_GET BCMI_TSCE16_XGXS_PLL_CTL5r_TERM_SELf_GET
#define PLL_CTL5r_TERM_SELf_SET BCMI_TSCE16_XGXS_PLL_CTL5r_TERM_SELf_SET
#define PLL_CTL5r_TEST_SEL_OVERWRITEf_GET BCMI_TSCE16_XGXS_PLL_CTL5r_TEST_SEL_OVERWRITEf_GET
#define PLL_CTL5r_TEST_SEL_OVERWRITEf_SET BCMI_TSCE16_XGXS_PLL_CTL5r_TEST_SEL_OVERWRITEf_SET
#define PLL_CTL5r_TEST_VCf_GET BCMI_TSCE16_XGXS_PLL_CTL5r_TEST_VCf_GET
#define PLL_CTL5r_TEST_VCf_SET BCMI_TSCE16_XGXS_PLL_CTL5r_TEST_VCf_SET
#define PLL_CTL5r_REFOUT_DIV_SELf_GET BCMI_TSCE16_XGXS_PLL_CTL5r_REFOUT_DIV_SELf_GET
#define PLL_CTL5r_REFOUT_DIV_SELf_SET BCMI_TSCE16_XGXS_PLL_CTL5r_REFOUT_DIV_SELf_SET
#define READ_PLL_CTL5r BCMI_TSCE16_XGXS_READ_PLL_CTL5r
#define WRITE_PLL_CTL5r BCMI_TSCE16_XGXS_WRITE_PLL_CTL5r
#define MODIFY_PLL_CTL5r BCMI_TSCE16_XGXS_MODIFY_PLL_CTL5r
#define READLN_PLL_CTL5r BCMI_TSCE16_XGXS_READLN_PLL_CTL5r
#define WRITELN_PLL_CTL5r BCMI_TSCE16_XGXS_WRITELN_PLL_CTL5r
#define WRITEALL_PLL_CTL5r BCMI_TSCE16_XGXS_WRITEALL_PLL_CTL5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PLL_CTL5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PLL_CTL6
 * BLOCKS:   AMSCOM
 * REGADDR:  0xd0b6
 * DESC:     PLL_CTRL_6
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PLL_PON          Resistor Calibration Control Setting, dfs=0 for offset value. amsbus ctrl_out  95:92
 *     VCO_GM_BOOST     VCO GM boost, 00: 100%, 01: 116%, 10: 116%, 11: 132% amsbus ctrl_out  97:96
 *     VCO_I_BOOST      VCO Current Boost, 00: 100%, 01: 130%, 10: 130%, 11: 160% amsbus ctrl_out  99:98
 *     PFD_OFFSET_ENLARGE 1: In offset_PFD mode, offset is extended by ~300ps. pfd_offset_enlarge in AMS. amsbus ctrl_out  100:100
 *     PLL_SPARE6_1     AMS reserved[101:101] amsbus ctrl_out  101:101
 *     PFD_OFFSET       In frac-N mode, reset pulse can be offset by 664ps(typical)/418ps(min), pfd_offset in AMS. amsbus ctrl_out  103:102
 *     I_NDIV_FRAC_L    Fractional control of feedback divider[3:0] amsbus ctrl_out  107:104
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PLL_CTL6r (0x0000d0b6 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PLL_CTL6r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CTL6.
 *
 */
typedef union BCMI_TSCE16_XGXS_PLL_CTL6r_s {
	uint32_t v[1];
	uint32_t pll_ctl6[1];
	uint32_t _pll_ctl6;
} BCMI_TSCE16_XGXS_PLL_CTL6r_t;

#define BCMI_TSCE16_XGXS_PLL_CTL6r_CLR(r) (r).pll_ctl6[0] = 0
#define BCMI_TSCE16_XGXS_PLL_CTL6r_SET(r,d) (r).pll_ctl6[0] = d
#define BCMI_TSCE16_XGXS_PLL_CTL6r_GET(r) (r).pll_ctl6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PLL_CTL6r_I_NDIV_FRAC_Lf_GET(r) ((((r).pll_ctl6[0]) >> 12) & 0xf)
#define BCMI_TSCE16_XGXS_PLL_CTL6r_I_NDIV_FRAC_Lf_SET(r,f) (r).pll_ctl6[0]=(((r).pll_ctl6[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCE16_XGXS_PLL_CTL6r_PFD_OFFSETf_GET(r) ((((r).pll_ctl6[0]) >> 10) & 0x3)
#define BCMI_TSCE16_XGXS_PLL_CTL6r_PFD_OFFSETf_SET(r,f) (r).pll_ctl6[0]=(((r).pll_ctl6[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCE16_XGXS_PLL_CTL6r_PLL_SPARE6_1f_GET(r) ((((r).pll_ctl6[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CTL6r_PLL_SPARE6_1f_SET(r,f) (r).pll_ctl6[0]=(((r).pll_ctl6[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_PLL_CTL6r_PFD_OFFSET_ENLARGEf_GET(r) ((((r).pll_ctl6[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CTL6r_PFD_OFFSET_ENLARGEf_SET(r,f) (r).pll_ctl6[0]=(((r).pll_ctl6[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_PLL_CTL6r_VCO_I_BOOSTf_GET(r) ((((r).pll_ctl6[0]) >> 6) & 0x3)
#define BCMI_TSCE16_XGXS_PLL_CTL6r_VCO_I_BOOSTf_SET(r,f) (r).pll_ctl6[0]=(((r).pll_ctl6[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCE16_XGXS_PLL_CTL6r_VCO_GM_BOOSTf_GET(r) ((((r).pll_ctl6[0]) >> 4) & 0x3)
#define BCMI_TSCE16_XGXS_PLL_CTL6r_VCO_GM_BOOSTf_SET(r,f) (r).pll_ctl6[0]=(((r).pll_ctl6[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCE16_XGXS_PLL_CTL6r_PLL_PONf_GET(r) (((r).pll_ctl6[0]) & 0xf)
#define BCMI_TSCE16_XGXS_PLL_CTL6r_PLL_PONf_SET(r,f) (r).pll_ctl6[0]=(((r).pll_ctl6[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access PLL_CTL6.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PLL_CTL6r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CTL6r,(_r._pll_ctl6))
#define BCMI_TSCE16_XGXS_WRITE_PLL_CTL6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL6r,(_r._pll_ctl6)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PLL_CTL6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL6r,(_r._pll_ctl6))
#define BCMI_TSCE16_XGXS_READLN_PLL_CTL6r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_ctl6))
#define BCMI_TSCE16_XGXS_WRITELN_PLL_CTL6r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_ctl6))
#define BCMI_TSCE16_XGXS_WRITEALL_PLL_CTL6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_ctl6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CTL6r BCMI_TSCE16_XGXS_PLL_CTL6r
#define PLL_CTL6r_SIZE BCMI_TSCE16_XGXS_PLL_CTL6r_SIZE
typedef BCMI_TSCE16_XGXS_PLL_CTL6r_t PLL_CTL6r_t;
#define PLL_CTL6r_CLR BCMI_TSCE16_XGXS_PLL_CTL6r_CLR
#define PLL_CTL6r_SET BCMI_TSCE16_XGXS_PLL_CTL6r_SET
#define PLL_CTL6r_GET BCMI_TSCE16_XGXS_PLL_CTL6r_GET
#define PLL_CTL6r_I_NDIV_FRAC_Lf_GET BCMI_TSCE16_XGXS_PLL_CTL6r_I_NDIV_FRAC_Lf_GET
#define PLL_CTL6r_I_NDIV_FRAC_Lf_SET BCMI_TSCE16_XGXS_PLL_CTL6r_I_NDIV_FRAC_Lf_SET
#define PLL_CTL6r_PFD_OFFSETf_GET BCMI_TSCE16_XGXS_PLL_CTL6r_PFD_OFFSETf_GET
#define PLL_CTL6r_PFD_OFFSETf_SET BCMI_TSCE16_XGXS_PLL_CTL6r_PFD_OFFSETf_SET
#define PLL_CTL6r_PLL_SPARE6_1f_GET BCMI_TSCE16_XGXS_PLL_CTL6r_PLL_SPARE6_1f_GET
#define PLL_CTL6r_PLL_SPARE6_1f_SET BCMI_TSCE16_XGXS_PLL_CTL6r_PLL_SPARE6_1f_SET
#define PLL_CTL6r_PFD_OFFSET_ENLARGEf_GET BCMI_TSCE16_XGXS_PLL_CTL6r_PFD_OFFSET_ENLARGEf_GET
#define PLL_CTL6r_PFD_OFFSET_ENLARGEf_SET BCMI_TSCE16_XGXS_PLL_CTL6r_PFD_OFFSET_ENLARGEf_SET
#define PLL_CTL6r_VCO_I_BOOSTf_GET BCMI_TSCE16_XGXS_PLL_CTL6r_VCO_I_BOOSTf_GET
#define PLL_CTL6r_VCO_I_BOOSTf_SET BCMI_TSCE16_XGXS_PLL_CTL6r_VCO_I_BOOSTf_SET
#define PLL_CTL6r_VCO_GM_BOOSTf_GET BCMI_TSCE16_XGXS_PLL_CTL6r_VCO_GM_BOOSTf_GET
#define PLL_CTL6r_VCO_GM_BOOSTf_SET BCMI_TSCE16_XGXS_PLL_CTL6r_VCO_GM_BOOSTf_SET
#define PLL_CTL6r_PLL_PONf_GET BCMI_TSCE16_XGXS_PLL_CTL6r_PLL_PONf_GET
#define PLL_CTL6r_PLL_PONf_SET BCMI_TSCE16_XGXS_PLL_CTL6r_PLL_PONf_SET
#define READ_PLL_CTL6r BCMI_TSCE16_XGXS_READ_PLL_CTL6r
#define WRITE_PLL_CTL6r BCMI_TSCE16_XGXS_WRITE_PLL_CTL6r
#define MODIFY_PLL_CTL6r BCMI_TSCE16_XGXS_MODIFY_PLL_CTL6r
#define READLN_PLL_CTL6r BCMI_TSCE16_XGXS_READLN_PLL_CTL6r
#define WRITELN_PLL_CTL6r BCMI_TSCE16_XGXS_WRITELN_PLL_CTL6r
#define WRITEALL_PLL_CTL6r BCMI_TSCE16_XGXS_WRITEALL_PLL_CTL6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PLL_CTL6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PLL_CTL7
 * BLOCKS:   AMSCOM
 * REGADDR:  0xd0b7
 * DESC:     PLL_CTRL_7
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     I_NDIV_FRAC_H    Fractional control of feedback divider[17:4] amsbus ctrl_out  121:108
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PLL_CTL7r (0x0000d0b7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PLL_CTL7r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CTL7.
 *
 */
typedef union BCMI_TSCE16_XGXS_PLL_CTL7r_s {
	uint32_t v[1];
	uint32_t pll_ctl7[1];
	uint32_t _pll_ctl7;
} BCMI_TSCE16_XGXS_PLL_CTL7r_t;

#define BCMI_TSCE16_XGXS_PLL_CTL7r_CLR(r) (r).pll_ctl7[0] = 0
#define BCMI_TSCE16_XGXS_PLL_CTL7r_SET(r,d) (r).pll_ctl7[0] = d
#define BCMI_TSCE16_XGXS_PLL_CTL7r_GET(r) (r).pll_ctl7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PLL_CTL7r_I_NDIV_FRAC_Hf_GET(r) (((r).pll_ctl7[0]) & 0x3fff)
#define BCMI_TSCE16_XGXS_PLL_CTL7r_I_NDIV_FRAC_Hf_SET(r,f) (r).pll_ctl7[0]=(((r).pll_ctl7[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access PLL_CTL7.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PLL_CTL7r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CTL7r,(_r._pll_ctl7))
#define BCMI_TSCE16_XGXS_WRITE_PLL_CTL7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL7r,(_r._pll_ctl7)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PLL_CTL7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL7r,(_r._pll_ctl7))
#define BCMI_TSCE16_XGXS_READLN_PLL_CTL7r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_ctl7))
#define BCMI_TSCE16_XGXS_WRITELN_PLL_CTL7r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_ctl7))
#define BCMI_TSCE16_XGXS_WRITEALL_PLL_CTL7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_ctl7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CTL7r BCMI_TSCE16_XGXS_PLL_CTL7r
#define PLL_CTL7r_SIZE BCMI_TSCE16_XGXS_PLL_CTL7r_SIZE
typedef BCMI_TSCE16_XGXS_PLL_CTL7r_t PLL_CTL7r_t;
#define PLL_CTL7r_CLR BCMI_TSCE16_XGXS_PLL_CTL7r_CLR
#define PLL_CTL7r_SET BCMI_TSCE16_XGXS_PLL_CTL7r_SET
#define PLL_CTL7r_GET BCMI_TSCE16_XGXS_PLL_CTL7r_GET
#define PLL_CTL7r_I_NDIV_FRAC_Hf_GET BCMI_TSCE16_XGXS_PLL_CTL7r_I_NDIV_FRAC_Hf_GET
#define PLL_CTL7r_I_NDIV_FRAC_Hf_SET BCMI_TSCE16_XGXS_PLL_CTL7r_I_NDIV_FRAC_Hf_SET
#define READ_PLL_CTL7r BCMI_TSCE16_XGXS_READ_PLL_CTL7r
#define WRITE_PLL_CTL7r BCMI_TSCE16_XGXS_WRITE_PLL_CTL7r
#define MODIFY_PLL_CTL7r BCMI_TSCE16_XGXS_MODIFY_PLL_CTL7r
#define READLN_PLL_CTL7r BCMI_TSCE16_XGXS_READLN_PLL_CTL7r
#define WRITELN_PLL_CTL7r BCMI_TSCE16_XGXS_WRITELN_PLL_CTL7r
#define WRITEALL_PLL_CTL7r BCMI_TSCE16_XGXS_WRITEALL_PLL_CTL7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PLL_CTL7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PLL_CTL8
 * BLOCKS:   AMSCOM
 * REGADDR:  0xd0b8
 * DESC:     PLL_CTRL_8
 * RESETVAL: 0x4442 (17474)
 * ACCESS:   R/W
 * FIELDS:
 *     I_NDIV_INT       Feedback divider integer control (divider ratio=code) amsbus ctrl_out  131:122
 *     CML_REFCLK_BIAS  Set the refclk input and output bias for CML ref channel amsbus ctrl_out  133:132
 *     VCOFB_DIV        VCO feedback divider amsbus ctrl_out  135:134
 *     I_PLL_SDM_PWRDNB Power down sdm rtl only when LOW amsbus ctrl_out  136:136
 *     I_NDIV_DITHER_EN Enable 1 bit dithering of the fractional input amsbus ctrl_out  137:137
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PLL_CTL8r (0x0000d0b8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PLL_CTL8r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CTL8.
 *
 */
typedef union BCMI_TSCE16_XGXS_PLL_CTL8r_s {
	uint32_t v[1];
	uint32_t pll_ctl8[1];
	uint32_t _pll_ctl8;
} BCMI_TSCE16_XGXS_PLL_CTL8r_t;

#define BCMI_TSCE16_XGXS_PLL_CTL8r_CLR(r) (r).pll_ctl8[0] = 0
#define BCMI_TSCE16_XGXS_PLL_CTL8r_SET(r,d) (r).pll_ctl8[0] = d
#define BCMI_TSCE16_XGXS_PLL_CTL8r_GET(r) (r).pll_ctl8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PLL_CTL8r_I_NDIV_DITHER_ENf_GET(r) ((((r).pll_ctl8[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CTL8r_I_NDIV_DITHER_ENf_SET(r,f) (r).pll_ctl8[0]=(((r).pll_ctl8[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_PLL_CTL8r_I_PLL_SDM_PWRDNBf_GET(r) ((((r).pll_ctl8[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CTL8r_I_PLL_SDM_PWRDNBf_SET(r,f) (r).pll_ctl8[0]=(((r).pll_ctl8[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_PLL_CTL8r_VCOFB_DIVf_GET(r) ((((r).pll_ctl8[0]) >> 12) & 0x3)
#define BCMI_TSCE16_XGXS_PLL_CTL8r_VCOFB_DIVf_SET(r,f) (r).pll_ctl8[0]=(((r).pll_ctl8[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_TSCE16_XGXS_PLL_CTL8r_CML_REFCLK_BIASf_GET(r) ((((r).pll_ctl8[0]) >> 10) & 0x3)
#define BCMI_TSCE16_XGXS_PLL_CTL8r_CML_REFCLK_BIASf_SET(r,f) (r).pll_ctl8[0]=(((r).pll_ctl8[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCE16_XGXS_PLL_CTL8r_I_NDIV_INTf_GET(r) (((r).pll_ctl8[0]) & 0x3ff)
#define BCMI_TSCE16_XGXS_PLL_CTL8r_I_NDIV_INTf_SET(r,f) (r).pll_ctl8[0]=(((r).pll_ctl8[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access PLL_CTL8.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PLL_CTL8r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CTL8r,(_r._pll_ctl8))
#define BCMI_TSCE16_XGXS_WRITE_PLL_CTL8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL8r,(_r._pll_ctl8)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PLL_CTL8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL8r,(_r._pll_ctl8))
#define BCMI_TSCE16_XGXS_READLN_PLL_CTL8r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_ctl8))
#define BCMI_TSCE16_XGXS_WRITELN_PLL_CTL8r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_ctl8))
#define BCMI_TSCE16_XGXS_WRITEALL_PLL_CTL8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_ctl8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CTL8r BCMI_TSCE16_XGXS_PLL_CTL8r
#define PLL_CTL8r_SIZE BCMI_TSCE16_XGXS_PLL_CTL8r_SIZE
typedef BCMI_TSCE16_XGXS_PLL_CTL8r_t PLL_CTL8r_t;
#define PLL_CTL8r_CLR BCMI_TSCE16_XGXS_PLL_CTL8r_CLR
#define PLL_CTL8r_SET BCMI_TSCE16_XGXS_PLL_CTL8r_SET
#define PLL_CTL8r_GET BCMI_TSCE16_XGXS_PLL_CTL8r_GET
#define PLL_CTL8r_I_NDIV_DITHER_ENf_GET BCMI_TSCE16_XGXS_PLL_CTL8r_I_NDIV_DITHER_ENf_GET
#define PLL_CTL8r_I_NDIV_DITHER_ENf_SET BCMI_TSCE16_XGXS_PLL_CTL8r_I_NDIV_DITHER_ENf_SET
#define PLL_CTL8r_I_PLL_SDM_PWRDNBf_GET BCMI_TSCE16_XGXS_PLL_CTL8r_I_PLL_SDM_PWRDNBf_GET
#define PLL_CTL8r_I_PLL_SDM_PWRDNBf_SET BCMI_TSCE16_XGXS_PLL_CTL8r_I_PLL_SDM_PWRDNBf_SET
#define PLL_CTL8r_VCOFB_DIVf_GET BCMI_TSCE16_XGXS_PLL_CTL8r_VCOFB_DIVf_GET
#define PLL_CTL8r_VCOFB_DIVf_SET BCMI_TSCE16_XGXS_PLL_CTL8r_VCOFB_DIVf_SET
#define PLL_CTL8r_CML_REFCLK_BIASf_GET BCMI_TSCE16_XGXS_PLL_CTL8r_CML_REFCLK_BIASf_GET
#define PLL_CTL8r_CML_REFCLK_BIASf_SET BCMI_TSCE16_XGXS_PLL_CTL8r_CML_REFCLK_BIASf_SET
#define PLL_CTL8r_I_NDIV_INTf_GET BCMI_TSCE16_XGXS_PLL_CTL8r_I_NDIV_INTf_GET
#define PLL_CTL8r_I_NDIV_INTf_SET BCMI_TSCE16_XGXS_PLL_CTL8r_I_NDIV_INTf_SET
#define READ_PLL_CTL8r BCMI_TSCE16_XGXS_READ_PLL_CTL8r
#define WRITE_PLL_CTL8r BCMI_TSCE16_XGXS_WRITE_PLL_CTL8r
#define MODIFY_PLL_CTL8r BCMI_TSCE16_XGXS_MODIFY_PLL_CTL8r
#define READLN_PLL_CTL8r BCMI_TSCE16_XGXS_READLN_PLL_CTL8r
#define WRITELN_PLL_CTL8r BCMI_TSCE16_XGXS_WRITELN_PLL_CTL8r
#define WRITEALL_PLL_CTL8r BCMI_TSCE16_XGXS_WRITEALL_PLL_CTL8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PLL_CTL8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PLL_CTL9
 * BLOCKS:   AMSCOM
 * REGADDR:  0xd0b9
 * DESC:     PLL_CTRL_9
 * RESETVAL: 0x5285 (21125)
 * ACCESS:   R/W
 * FIELDS:
 *     MMD_RESETB       Reset Delta Sigma modulator. amsbus ctrl_out  138:138
 *     I_PLL_FRAC_MODE  integer division mapping for MMD amsbus ctrl_out  140:139
 *     SEL_FP3CAP       Controls the filter cap for the third loop filter pole in WIS mode amsbus ctrl_out  144:141
 *     VCO_SUPPLY_ADJ   0: 0.88VDD; 1: 0.80VDD amsbus ctrl_out  145:145
 *     BIAS_DIV_CTRL    control current biasing for the CML divider. amsbus ctrl_out  148:146
 *     BIAS_IQ_CTRL     control current biasing for the IQ buffer. bias_IQ_ctrl in AMS amsbus ctrl_out  151:149
 *     CML_REFCLK_ADJ   Set the refclk input and output bias for CML ref channel amsbus ctrl_out  153:152
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PLL_CTL9r (0x0000d0b9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PLL_CTL9r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CTL9.
 *
 */
typedef union BCMI_TSCE16_XGXS_PLL_CTL9r_s {
	uint32_t v[1];
	uint32_t pll_ctl9[1];
	uint32_t _pll_ctl9;
} BCMI_TSCE16_XGXS_PLL_CTL9r_t;

#define BCMI_TSCE16_XGXS_PLL_CTL9r_CLR(r) (r).pll_ctl9[0] = 0
#define BCMI_TSCE16_XGXS_PLL_CTL9r_SET(r,d) (r).pll_ctl9[0] = d
#define BCMI_TSCE16_XGXS_PLL_CTL9r_GET(r) (r).pll_ctl9[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PLL_CTL9r_CML_REFCLK_ADJf_GET(r) ((((r).pll_ctl9[0]) >> 14) & 0x3)
#define BCMI_TSCE16_XGXS_PLL_CTL9r_CML_REFCLK_ADJf_SET(r,f) (r).pll_ctl9[0]=(((r).pll_ctl9[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCE16_XGXS_PLL_CTL9r_BIAS_IQ_CTRLf_GET(r) ((((r).pll_ctl9[0]) >> 11) & 0x7)
#define BCMI_TSCE16_XGXS_PLL_CTL9r_BIAS_IQ_CTRLf_SET(r,f) (r).pll_ctl9[0]=(((r).pll_ctl9[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_TSCE16_XGXS_PLL_CTL9r_BIAS_DIV_CTRLf_GET(r) ((((r).pll_ctl9[0]) >> 8) & 0x7)
#define BCMI_TSCE16_XGXS_PLL_CTL9r_BIAS_DIV_CTRLf_SET(r,f) (r).pll_ctl9[0]=(((r).pll_ctl9[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_TSCE16_XGXS_PLL_CTL9r_VCO_SUPPLY_ADJf_GET(r) ((((r).pll_ctl9[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CTL9r_VCO_SUPPLY_ADJf_SET(r,f) (r).pll_ctl9[0]=(((r).pll_ctl9[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_PLL_CTL9r_SEL_FP3CAPf_GET(r) ((((r).pll_ctl9[0]) >> 3) & 0xf)
#define BCMI_TSCE16_XGXS_PLL_CTL9r_SEL_FP3CAPf_SET(r,f) (r).pll_ctl9[0]=(((r).pll_ctl9[0] & ~((uint32_t)0xf << 3)) | ((((uint32_t)f) & 0xf) << 3)) | (15 << (16 + 3))
#define BCMI_TSCE16_XGXS_PLL_CTL9r_I_PLL_FRAC_MODEf_GET(r) ((((r).pll_ctl9[0]) >> 1) & 0x3)
#define BCMI_TSCE16_XGXS_PLL_CTL9r_I_PLL_FRAC_MODEf_SET(r,f) (r).pll_ctl9[0]=(((r).pll_ctl9[0] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1)) | (3 << (16 + 1))
#define BCMI_TSCE16_XGXS_PLL_CTL9r_MMD_RESETBf_GET(r) (((r).pll_ctl9[0]) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CTL9r_MMD_RESETBf_SET(r,f) (r).pll_ctl9[0]=(((r).pll_ctl9[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PLL_CTL9.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PLL_CTL9r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CTL9r,(_r._pll_ctl9))
#define BCMI_TSCE16_XGXS_WRITE_PLL_CTL9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL9r,(_r._pll_ctl9)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PLL_CTL9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL9r,(_r._pll_ctl9))
#define BCMI_TSCE16_XGXS_READLN_PLL_CTL9r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_ctl9))
#define BCMI_TSCE16_XGXS_WRITELN_PLL_CTL9r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_ctl9))
#define BCMI_TSCE16_XGXS_WRITEALL_PLL_CTL9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_ctl9))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CTL9r BCMI_TSCE16_XGXS_PLL_CTL9r
#define PLL_CTL9r_SIZE BCMI_TSCE16_XGXS_PLL_CTL9r_SIZE
typedef BCMI_TSCE16_XGXS_PLL_CTL9r_t PLL_CTL9r_t;
#define PLL_CTL9r_CLR BCMI_TSCE16_XGXS_PLL_CTL9r_CLR
#define PLL_CTL9r_SET BCMI_TSCE16_XGXS_PLL_CTL9r_SET
#define PLL_CTL9r_GET BCMI_TSCE16_XGXS_PLL_CTL9r_GET
#define PLL_CTL9r_CML_REFCLK_ADJf_GET BCMI_TSCE16_XGXS_PLL_CTL9r_CML_REFCLK_ADJf_GET
#define PLL_CTL9r_CML_REFCLK_ADJf_SET BCMI_TSCE16_XGXS_PLL_CTL9r_CML_REFCLK_ADJf_SET
#define PLL_CTL9r_BIAS_IQ_CTRLf_GET BCMI_TSCE16_XGXS_PLL_CTL9r_BIAS_IQ_CTRLf_GET
#define PLL_CTL9r_BIAS_IQ_CTRLf_SET BCMI_TSCE16_XGXS_PLL_CTL9r_BIAS_IQ_CTRLf_SET
#define PLL_CTL9r_BIAS_DIV_CTRLf_GET BCMI_TSCE16_XGXS_PLL_CTL9r_BIAS_DIV_CTRLf_GET
#define PLL_CTL9r_BIAS_DIV_CTRLf_SET BCMI_TSCE16_XGXS_PLL_CTL9r_BIAS_DIV_CTRLf_SET
#define PLL_CTL9r_VCO_SUPPLY_ADJf_GET BCMI_TSCE16_XGXS_PLL_CTL9r_VCO_SUPPLY_ADJf_GET
#define PLL_CTL9r_VCO_SUPPLY_ADJf_SET BCMI_TSCE16_XGXS_PLL_CTL9r_VCO_SUPPLY_ADJf_SET
#define PLL_CTL9r_SEL_FP3CAPf_GET BCMI_TSCE16_XGXS_PLL_CTL9r_SEL_FP3CAPf_GET
#define PLL_CTL9r_SEL_FP3CAPf_SET BCMI_TSCE16_XGXS_PLL_CTL9r_SEL_FP3CAPf_SET
#define PLL_CTL9r_I_PLL_FRAC_MODEf_GET BCMI_TSCE16_XGXS_PLL_CTL9r_I_PLL_FRAC_MODEf_GET
#define PLL_CTL9r_I_PLL_FRAC_MODEf_SET BCMI_TSCE16_XGXS_PLL_CTL9r_I_PLL_FRAC_MODEf_SET
#define PLL_CTL9r_MMD_RESETBf_GET BCMI_TSCE16_XGXS_PLL_CTL9r_MMD_RESETBf_GET
#define PLL_CTL9r_MMD_RESETBf_SET BCMI_TSCE16_XGXS_PLL_CTL9r_MMD_RESETBf_SET
#define READ_PLL_CTL9r BCMI_TSCE16_XGXS_READ_PLL_CTL9r
#define WRITE_PLL_CTL9r BCMI_TSCE16_XGXS_WRITE_PLL_CTL9r
#define MODIFY_PLL_CTL9r BCMI_TSCE16_XGXS_MODIFY_PLL_CTL9r
#define READLN_PLL_CTL9r BCMI_TSCE16_XGXS_READLN_PLL_CTL9r
#define WRITELN_PLL_CTL9r BCMI_TSCE16_XGXS_WRITELN_PLL_CTL9r
#define WRITEALL_PLL_CTL9r BCMI_TSCE16_XGXS_WRITEALL_PLL_CTL9r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PLL_CTL9r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PLL_CTL_10
 * BLOCKS:   AMSCOM
 * REGADDR:  0xd0ba
 * DESC:     PLL_CTRL_10
 * RESETVAL: 0x15 (21)
 * ACCESS:   R/W
 * FIELDS:
 *     REFCLK_IN_BIAS   set refclk input bias. amsbus ctrl_out  159:154
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PLL_CTL_10r (0x0000d0ba | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PLL_CTL_10r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CTL_10.
 *
 */
typedef union BCMI_TSCE16_XGXS_PLL_CTL_10r_s {
	uint32_t v[1];
	uint32_t pll_ctl_10[1];
	uint32_t _pll_ctl_10;
} BCMI_TSCE16_XGXS_PLL_CTL_10r_t;

#define BCMI_TSCE16_XGXS_PLL_CTL_10r_CLR(r) (r).pll_ctl_10[0] = 0
#define BCMI_TSCE16_XGXS_PLL_CTL_10r_SET(r,d) (r).pll_ctl_10[0] = d
#define BCMI_TSCE16_XGXS_PLL_CTL_10r_GET(r) (r).pll_ctl_10[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PLL_CTL_10r_REFCLK_IN_BIASf_GET(r) (((r).pll_ctl_10[0]) & 0x3f)
#define BCMI_TSCE16_XGXS_PLL_CTL_10r_REFCLK_IN_BIASf_SET(r,f) (r).pll_ctl_10[0]=(((r).pll_ctl_10[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access PLL_CTL_10.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PLL_CTL_10r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CTL_10r,(_r._pll_ctl_10))
#define BCMI_TSCE16_XGXS_WRITE_PLL_CTL_10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL_10r,(_r._pll_ctl_10)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PLL_CTL_10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL_10r,(_r._pll_ctl_10))
#define BCMI_TSCE16_XGXS_READLN_PLL_CTL_10r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CTL_10r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_ctl_10))
#define BCMI_TSCE16_XGXS_WRITELN_PLL_CTL_10r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL_10r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_ctl_10))
#define BCMI_TSCE16_XGXS_WRITEALL_PLL_CTL_10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CTL_10r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_ctl_10))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CTL_10r BCMI_TSCE16_XGXS_PLL_CTL_10r
#define PLL_CTL_10r_SIZE BCMI_TSCE16_XGXS_PLL_CTL_10r_SIZE
typedef BCMI_TSCE16_XGXS_PLL_CTL_10r_t PLL_CTL_10r_t;
#define PLL_CTL_10r_CLR BCMI_TSCE16_XGXS_PLL_CTL_10r_CLR
#define PLL_CTL_10r_SET BCMI_TSCE16_XGXS_PLL_CTL_10r_SET
#define PLL_CTL_10r_GET BCMI_TSCE16_XGXS_PLL_CTL_10r_GET
#define PLL_CTL_10r_REFCLK_IN_BIASf_GET BCMI_TSCE16_XGXS_PLL_CTL_10r_REFCLK_IN_BIASf_GET
#define PLL_CTL_10r_REFCLK_IN_BIASf_SET BCMI_TSCE16_XGXS_PLL_CTL_10r_REFCLK_IN_BIASf_SET
#define READ_PLL_CTL_10r BCMI_TSCE16_XGXS_READ_PLL_CTL_10r
#define WRITE_PLL_CTL_10r BCMI_TSCE16_XGXS_WRITE_PLL_CTL_10r
#define MODIFY_PLL_CTL_10r BCMI_TSCE16_XGXS_MODIFY_PLL_CTL_10r
#define READLN_PLL_CTL_10r BCMI_TSCE16_XGXS_READLN_PLL_CTL_10r
#define WRITELN_PLL_CTL_10r BCMI_TSCE16_XGXS_WRITELN_PLL_CTL_10r
#define WRITEALL_PLL_CTL_10r BCMI_TSCE16_XGXS_WRITEALL_PLL_CTL_10r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PLL_CTL_10r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PLL_INT
 * BLOCKS:   AMSCOM
 * REGADDR:  0xd0be
 * DESC:     PLL_CTRL_INT
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     REFCLK_DIV4_FRC_VAL force value for refclk_div4 when refclk_div_frc set to 1 in register
 *     REFCLK_DIV2_FRC_VAL force value for refclk_div2 when refclk_div_frc set to 1 in register
 *     REFCLK_DIV_FRC   force refclk_div value from register bits instead of pins pmd_refclk_div2 and pmd_refclk_div4
 *     REFCLK_TERM_FRC  0: refclk termination control driven from from input pins; 1: driven from term_sel register
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PLL_INTr (0x0000d0be | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PLL_INTr_SIZE 4

/*
 * This structure should be used to declare and program PLL_INT.
 *
 */
typedef union BCMI_TSCE16_XGXS_PLL_INTr_s {
	uint32_t v[1];
	uint32_t pll_int[1];
	uint32_t _pll_int;
} BCMI_TSCE16_XGXS_PLL_INTr_t;

#define BCMI_TSCE16_XGXS_PLL_INTr_CLR(r) (r).pll_int[0] = 0
#define BCMI_TSCE16_XGXS_PLL_INTr_SET(r,d) (r).pll_int[0] = d
#define BCMI_TSCE16_XGXS_PLL_INTr_GET(r) (r).pll_int[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PLL_INTr_REFCLK_TERM_FRCf_GET(r) ((((r).pll_int[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_INTr_REFCLK_TERM_FRCf_SET(r,f) (r).pll_int[0]=(((r).pll_int[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_PLL_INTr_REFCLK_DIV_FRCf_GET(r) ((((r).pll_int[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_INTr_REFCLK_DIV_FRCf_SET(r,f) (r).pll_int[0]=(((r).pll_int[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_PLL_INTr_REFCLK_DIV2_FRC_VALf_GET(r) ((((r).pll_int[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_INTr_REFCLK_DIV2_FRC_VALf_SET(r,f) (r).pll_int[0]=(((r).pll_int[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_PLL_INTr_REFCLK_DIV4_FRC_VALf_GET(r) (((r).pll_int[0]) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_INTr_REFCLK_DIV4_FRC_VALf_SET(r,f) (r).pll_int[0]=(((r).pll_int[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PLL_INT.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PLL_INTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_INTr,(_r._pll_int))
#define BCMI_TSCE16_XGXS_WRITE_PLL_INTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_INTr,(_r._pll_int)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PLL_INTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_INTr,(_r._pll_int))
#define BCMI_TSCE16_XGXS_READLN_PLL_INTr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_INTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_int))
#define BCMI_TSCE16_XGXS_WRITELN_PLL_INTr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_INTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_int))
#define BCMI_TSCE16_XGXS_WRITEALL_PLL_INTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_INTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_int))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_INTr BCMI_TSCE16_XGXS_PLL_INTr
#define PLL_INTr_SIZE BCMI_TSCE16_XGXS_PLL_INTr_SIZE
typedef BCMI_TSCE16_XGXS_PLL_INTr_t PLL_INTr_t;
#define PLL_INTr_CLR BCMI_TSCE16_XGXS_PLL_INTr_CLR
#define PLL_INTr_SET BCMI_TSCE16_XGXS_PLL_INTr_SET
#define PLL_INTr_GET BCMI_TSCE16_XGXS_PLL_INTr_GET
#define PLL_INTr_REFCLK_TERM_FRCf_GET BCMI_TSCE16_XGXS_PLL_INTr_REFCLK_TERM_FRCf_GET
#define PLL_INTr_REFCLK_TERM_FRCf_SET BCMI_TSCE16_XGXS_PLL_INTr_REFCLK_TERM_FRCf_SET
#define PLL_INTr_REFCLK_DIV_FRCf_GET BCMI_TSCE16_XGXS_PLL_INTr_REFCLK_DIV_FRCf_GET
#define PLL_INTr_REFCLK_DIV_FRCf_SET BCMI_TSCE16_XGXS_PLL_INTr_REFCLK_DIV_FRCf_SET
#define PLL_INTr_REFCLK_DIV2_FRC_VALf_GET BCMI_TSCE16_XGXS_PLL_INTr_REFCLK_DIV2_FRC_VALf_GET
#define PLL_INTr_REFCLK_DIV2_FRC_VALf_SET BCMI_TSCE16_XGXS_PLL_INTr_REFCLK_DIV2_FRC_VALf_SET
#define PLL_INTr_REFCLK_DIV4_FRC_VALf_GET BCMI_TSCE16_XGXS_PLL_INTr_REFCLK_DIV4_FRC_VALf_GET
#define PLL_INTr_REFCLK_DIV4_FRC_VALf_SET BCMI_TSCE16_XGXS_PLL_INTr_REFCLK_DIV4_FRC_VALf_SET
#define READ_PLL_INTr BCMI_TSCE16_XGXS_READ_PLL_INTr
#define WRITE_PLL_INTr BCMI_TSCE16_XGXS_WRITE_PLL_INTr
#define MODIFY_PLL_INTr BCMI_TSCE16_XGXS_MODIFY_PLL_INTr
#define READLN_PLL_INTr BCMI_TSCE16_XGXS_READLN_PLL_INTr
#define WRITELN_PLL_INTr BCMI_TSCE16_XGXS_WRITELN_PLL_INTr
#define WRITEALL_PLL_INTr BCMI_TSCE16_XGXS_WRITEALL_PLL_INTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PLL_INTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PLL_STS
 * BLOCKS:   AMSCOM
 * REGADDR:  0xd0bf
 * DESC:     PLL_STS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     AFE_REV_ID       AFE o_rev_id[3:0] output
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PLL_STSr (0x0000d0bf | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PLL_STSr_SIZE 4

/*
 * This structure should be used to declare and program PLL_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_PLL_STSr_s {
	uint32_t v[1];
	uint32_t pll_sts[1];
	uint32_t _pll_sts;
} BCMI_TSCE16_XGXS_PLL_STSr_t;

#define BCMI_TSCE16_XGXS_PLL_STSr_CLR(r) (r).pll_sts[0] = 0
#define BCMI_TSCE16_XGXS_PLL_STSr_SET(r,d) (r).pll_sts[0] = d
#define BCMI_TSCE16_XGXS_PLL_STSr_GET(r) (r).pll_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PLL_STSr_AFE_REV_IDf_GET(r) (((r).pll_sts[0]) & 0xf)
#define BCMI_TSCE16_XGXS_PLL_STSr_AFE_REV_IDf_SET(r,f) (r).pll_sts[0]=(((r).pll_sts[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access PLL_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PLL_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_STSr,(_r._pll_sts))
#define BCMI_TSCE16_XGXS_WRITE_PLL_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_STSr,(_r._pll_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PLL_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_STSr,(_r._pll_sts))
#define BCMI_TSCE16_XGXS_READLN_PLL_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_sts))
#define BCMI_TSCE16_XGXS_WRITELN_PLL_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_PLL_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_STSr BCMI_TSCE16_XGXS_PLL_STSr
#define PLL_STSr_SIZE BCMI_TSCE16_XGXS_PLL_STSr_SIZE
typedef BCMI_TSCE16_XGXS_PLL_STSr_t PLL_STSr_t;
#define PLL_STSr_CLR BCMI_TSCE16_XGXS_PLL_STSr_CLR
#define PLL_STSr_SET BCMI_TSCE16_XGXS_PLL_STSr_SET
#define PLL_STSr_GET BCMI_TSCE16_XGXS_PLL_STSr_GET
#define PLL_STSr_AFE_REV_IDf_GET BCMI_TSCE16_XGXS_PLL_STSr_AFE_REV_IDf_GET
#define PLL_STSr_AFE_REV_IDf_SET BCMI_TSCE16_XGXS_PLL_STSr_AFE_REV_IDf_SET
#define READ_PLL_STSr BCMI_TSCE16_XGXS_READ_PLL_STSr
#define WRITE_PLL_STSr BCMI_TSCE16_XGXS_WRITE_PLL_STSr
#define MODIFY_PLL_STSr BCMI_TSCE16_XGXS_MODIFY_PLL_STSr
#define READLN_PLL_STSr BCMI_TSCE16_XGXS_READLN_PLL_STSr
#define WRITELN_PLL_STSr BCMI_TSCE16_XGXS_WRITELN_PLL_STSr
#define WRITEALL_PLL_STSr BCMI_TSCE16_XGXS_WRITEALL_PLL_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PLL_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SIGDET_CTL0
 * BLOCKS:   SIGDET
 * REGADDR:  0xd0c0
 * DESC:     SIGDET_CTRL_0
 * RESETVAL: 0x5229 (21033)
 * ACCESS:   R/W
 * FIELDS:
 *     SIGNAL_DETECT_FILTER_COUNT Defines the width of the signal_detect==1'b1 pulses which will be filtered. Valid range is 0 to 31which maps to 0 to 448 clock cycles. Refer PMD spec for more details about the mapping.
 *     LOS_FILTER_COUNT Defines the width of the signal_detect==1'b0 pulses which will be filtered. Valid range is 0 to 31which maps to 0 to 448 clock cycles. Refer PMD spec for more details about the mapping.
 *     ENERGY_DETECT_MASK_COUNT Defines the mask_count timer for energy_detect. Valid range is 0 to 31which maps to 0 to 448 clock cycles. Refer PMD spec for more details about the mapping.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SIGDET_CTL0r (0x0000d0c0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SIGDET_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program SIGDET_CTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_SIGDET_CTL0r_s {
	uint32_t v[1];
	uint32_t sigdet_ctl0[1];
	uint32_t _sigdet_ctl0;
} BCMI_TSCE16_XGXS_SIGDET_CTL0r_t;

#define BCMI_TSCE16_XGXS_SIGDET_CTL0r_CLR(r) (r).sigdet_ctl0[0] = 0
#define BCMI_TSCE16_XGXS_SIGDET_CTL0r_SET(r,d) (r).sigdet_ctl0[0] = d
#define BCMI_TSCE16_XGXS_SIGDET_CTL0r_GET(r) (r).sigdet_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SIGDET_CTL0r_ENERGY_DETECT_MASK_COUNTf_GET(r) ((((r).sigdet_ctl0[0]) >> 10) & 0x1f)
#define BCMI_TSCE16_XGXS_SIGDET_CTL0r_ENERGY_DETECT_MASK_COUNTf_SET(r,f) (r).sigdet_ctl0[0]=(((r).sigdet_ctl0[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_TSCE16_XGXS_SIGDET_CTL0r_LOS_FILTER_COUNTf_GET(r) ((((r).sigdet_ctl0[0]) >> 5) & 0x1f)
#define BCMI_TSCE16_XGXS_SIGDET_CTL0r_LOS_FILTER_COUNTf_SET(r,f) (r).sigdet_ctl0[0]=(((r).sigdet_ctl0[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_TSCE16_XGXS_SIGDET_CTL0r_SIGNAL_DETECT_FILTER_COUNTf_GET(r) (((r).sigdet_ctl0[0]) & 0x1f)
#define BCMI_TSCE16_XGXS_SIGDET_CTL0r_SIGNAL_DETECT_FILTER_COUNTf_SET(r,f) (r).sigdet_ctl0[0]=(((r).sigdet_ctl0[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access SIGDET_CTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SIGDET_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SIGDET_CTL0r,(_r._sigdet_ctl0))
#define BCMI_TSCE16_XGXS_WRITE_SIGDET_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SIGDET_CTL0r,(_r._sigdet_ctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SIGDET_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SIGDET_CTL0r,(_r._sigdet_ctl0))
#define BCMI_TSCE16_XGXS_READLN_SIGDET_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SIGDET_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_ctl0))
#define BCMI_TSCE16_XGXS_WRITELN_SIGDET_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SIGDET_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_ctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_SIGDET_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SIGDET_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sigdet_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SIGDET_CTL0r BCMI_TSCE16_XGXS_SIGDET_CTL0r
#define SIGDET_CTL0r_SIZE BCMI_TSCE16_XGXS_SIGDET_CTL0r_SIZE
typedef BCMI_TSCE16_XGXS_SIGDET_CTL0r_t SIGDET_CTL0r_t;
#define SIGDET_CTL0r_CLR BCMI_TSCE16_XGXS_SIGDET_CTL0r_CLR
#define SIGDET_CTL0r_SET BCMI_TSCE16_XGXS_SIGDET_CTL0r_SET
#define SIGDET_CTL0r_GET BCMI_TSCE16_XGXS_SIGDET_CTL0r_GET
#define SIGDET_CTL0r_ENERGY_DETECT_MASK_COUNTf_GET BCMI_TSCE16_XGXS_SIGDET_CTL0r_ENERGY_DETECT_MASK_COUNTf_GET
#define SIGDET_CTL0r_ENERGY_DETECT_MASK_COUNTf_SET BCMI_TSCE16_XGXS_SIGDET_CTL0r_ENERGY_DETECT_MASK_COUNTf_SET
#define SIGDET_CTL0r_LOS_FILTER_COUNTf_GET BCMI_TSCE16_XGXS_SIGDET_CTL0r_LOS_FILTER_COUNTf_GET
#define SIGDET_CTL0r_LOS_FILTER_COUNTf_SET BCMI_TSCE16_XGXS_SIGDET_CTL0r_LOS_FILTER_COUNTf_SET
#define SIGDET_CTL0r_SIGNAL_DETECT_FILTER_COUNTf_GET BCMI_TSCE16_XGXS_SIGDET_CTL0r_SIGNAL_DETECT_FILTER_COUNTf_GET
#define SIGDET_CTL0r_SIGNAL_DETECT_FILTER_COUNTf_SET BCMI_TSCE16_XGXS_SIGDET_CTL0r_SIGNAL_DETECT_FILTER_COUNTf_SET
#define READ_SIGDET_CTL0r BCMI_TSCE16_XGXS_READ_SIGDET_CTL0r
#define WRITE_SIGDET_CTL0r BCMI_TSCE16_XGXS_WRITE_SIGDET_CTL0r
#define MODIFY_SIGDET_CTL0r BCMI_TSCE16_XGXS_MODIFY_SIGDET_CTL0r
#define READLN_SIGDET_CTL0r BCMI_TSCE16_XGXS_READLN_SIGDET_CTL0r
#define WRITELN_SIGDET_CTL0r BCMI_TSCE16_XGXS_WRITELN_SIGDET_CTL0r
#define WRITEALL_SIGDET_CTL0r BCMI_TSCE16_XGXS_WRITEALL_SIGDET_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SIGDET_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SIGDET_CTL1
 * BLOCKS:   SIGDET
 * REGADDR:  0xd0c1
 * DESC:     SIGDET_CTRL_1
 * RESETVAL: 0x8 (8)
 * ACCESS:   R/W
 * FIELDS:
 *     AFE_SIGNAL_DETECT_DIS 1'b1 will disable the signal_detect from AFE.
 *     EXT_LOS_EN       1'b1 will enable the external (optical) LOS path into the sigdet filter.
 *     EXT_LOS_INV      1'b1 will invert the polarity of the pmd_ext_los pin.
 *     IGNORE_LP_MODE   1'b1 will ignore the pmd_rx_mode (low power mode) input pin. Set to 1'b0 if EEE mode is supported by the PCS
 *     SIGNAL_DETECT_FILTER_1US 1'b1 will use 1us heartbeat for los_count counter instead of comclk.
 *     ENERGY_DETECT_FRC pmd_energy_detect Force.
 *     ENERGY_DETECT_FRC_VAL pmd_energy_detect Force Value.
 *     SIGNAL_DETECT_FRC pmd_signal_detect Force.
 *     SIGNAL_DETECT_FRC_VAL pmd_signal_detect Force Value.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SIGDET_CTL1r (0x0000d0c1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SIGDET_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program SIGDET_CTL1.
 *
 */
typedef union BCMI_TSCE16_XGXS_SIGDET_CTL1r_s {
	uint32_t v[1];
	uint32_t sigdet_ctl1[1];
	uint32_t _sigdet_ctl1;
} BCMI_TSCE16_XGXS_SIGDET_CTL1r_t;

#define BCMI_TSCE16_XGXS_SIGDET_CTL1r_CLR(r) (r).sigdet_ctl1[0] = 0
#define BCMI_TSCE16_XGXS_SIGDET_CTL1r_SET(r,d) (r).sigdet_ctl1[0] = d
#define BCMI_TSCE16_XGXS_SIGDET_CTL1r_GET(r) (r).sigdet_ctl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FRC_VALf_GET(r) ((((r).sigdet_ctl1[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FRC_VALf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FRCf_GET(r) ((((r).sigdet_ctl1[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FRCf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_SIGDET_CTL1r_ENERGY_DETECT_FRC_VALf_GET(r) ((((r).sigdet_ctl1[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_SIGDET_CTL1r_ENERGY_DETECT_FRC_VALf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_SIGDET_CTL1r_ENERGY_DETECT_FRCf_GET(r) ((((r).sigdet_ctl1[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_SIGDET_CTL1r_ENERGY_DETECT_FRCf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FILTER_1USf_GET(r) ((((r).sigdet_ctl1[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FILTER_1USf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_SIGDET_CTL1r_IGNORE_LP_MODEf_GET(r) ((((r).sigdet_ctl1[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_SIGDET_CTL1r_IGNORE_LP_MODEf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_SIGDET_CTL1r_EXT_LOS_INVf_GET(r) ((((r).sigdet_ctl1[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_SIGDET_CTL1r_EXT_LOS_INVf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_SIGDET_CTL1r_EXT_LOS_ENf_GET(r) ((((r).sigdet_ctl1[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_SIGDET_CTL1r_EXT_LOS_ENf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_SIGDET_CTL1r_AFE_SIGNAL_DETECT_DISf_GET(r) (((r).sigdet_ctl1[0]) & 0x1)
#define BCMI_TSCE16_XGXS_SIGDET_CTL1r_AFE_SIGNAL_DETECT_DISf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SIGDET_CTL1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SIGDET_CTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SIGDET_CTL1r,(_r._sigdet_ctl1))
#define BCMI_TSCE16_XGXS_WRITE_SIGDET_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SIGDET_CTL1r,(_r._sigdet_ctl1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SIGDET_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SIGDET_CTL1r,(_r._sigdet_ctl1))
#define BCMI_TSCE16_XGXS_READLN_SIGDET_CTL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SIGDET_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_ctl1))
#define BCMI_TSCE16_XGXS_WRITELN_SIGDET_CTL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SIGDET_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_ctl1))
#define BCMI_TSCE16_XGXS_WRITEALL_SIGDET_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SIGDET_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sigdet_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SIGDET_CTL1r BCMI_TSCE16_XGXS_SIGDET_CTL1r
#define SIGDET_CTL1r_SIZE BCMI_TSCE16_XGXS_SIGDET_CTL1r_SIZE
typedef BCMI_TSCE16_XGXS_SIGDET_CTL1r_t SIGDET_CTL1r_t;
#define SIGDET_CTL1r_CLR BCMI_TSCE16_XGXS_SIGDET_CTL1r_CLR
#define SIGDET_CTL1r_SET BCMI_TSCE16_XGXS_SIGDET_CTL1r_SET
#define SIGDET_CTL1r_GET BCMI_TSCE16_XGXS_SIGDET_CTL1r_GET
#define SIGDET_CTL1r_SIGNAL_DETECT_FRC_VALf_GET BCMI_TSCE16_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FRC_VALf_GET
#define SIGDET_CTL1r_SIGNAL_DETECT_FRC_VALf_SET BCMI_TSCE16_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FRC_VALf_SET
#define SIGDET_CTL1r_SIGNAL_DETECT_FRCf_GET BCMI_TSCE16_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FRCf_GET
#define SIGDET_CTL1r_SIGNAL_DETECT_FRCf_SET BCMI_TSCE16_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FRCf_SET
#define SIGDET_CTL1r_ENERGY_DETECT_FRC_VALf_GET BCMI_TSCE16_XGXS_SIGDET_CTL1r_ENERGY_DETECT_FRC_VALf_GET
#define SIGDET_CTL1r_ENERGY_DETECT_FRC_VALf_SET BCMI_TSCE16_XGXS_SIGDET_CTL1r_ENERGY_DETECT_FRC_VALf_SET
#define SIGDET_CTL1r_ENERGY_DETECT_FRCf_GET BCMI_TSCE16_XGXS_SIGDET_CTL1r_ENERGY_DETECT_FRCf_GET
#define SIGDET_CTL1r_ENERGY_DETECT_FRCf_SET BCMI_TSCE16_XGXS_SIGDET_CTL1r_ENERGY_DETECT_FRCf_SET
#define SIGDET_CTL1r_SIGNAL_DETECT_FILTER_1USf_GET BCMI_TSCE16_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FILTER_1USf_GET
#define SIGDET_CTL1r_SIGNAL_DETECT_FILTER_1USf_SET BCMI_TSCE16_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FILTER_1USf_SET
#define SIGDET_CTL1r_IGNORE_LP_MODEf_GET BCMI_TSCE16_XGXS_SIGDET_CTL1r_IGNORE_LP_MODEf_GET
#define SIGDET_CTL1r_IGNORE_LP_MODEf_SET BCMI_TSCE16_XGXS_SIGDET_CTL1r_IGNORE_LP_MODEf_SET
#define SIGDET_CTL1r_EXT_LOS_INVf_GET BCMI_TSCE16_XGXS_SIGDET_CTL1r_EXT_LOS_INVf_GET
#define SIGDET_CTL1r_EXT_LOS_INVf_SET BCMI_TSCE16_XGXS_SIGDET_CTL1r_EXT_LOS_INVf_SET
#define SIGDET_CTL1r_EXT_LOS_ENf_GET BCMI_TSCE16_XGXS_SIGDET_CTL1r_EXT_LOS_ENf_GET
#define SIGDET_CTL1r_EXT_LOS_ENf_SET BCMI_TSCE16_XGXS_SIGDET_CTL1r_EXT_LOS_ENf_SET
#define SIGDET_CTL1r_AFE_SIGNAL_DETECT_DISf_GET BCMI_TSCE16_XGXS_SIGDET_CTL1r_AFE_SIGNAL_DETECT_DISf_GET
#define SIGDET_CTL1r_AFE_SIGNAL_DETECT_DISf_SET BCMI_TSCE16_XGXS_SIGDET_CTL1r_AFE_SIGNAL_DETECT_DISf_SET
#define READ_SIGDET_CTL1r BCMI_TSCE16_XGXS_READ_SIGDET_CTL1r
#define WRITE_SIGDET_CTL1r BCMI_TSCE16_XGXS_WRITE_SIGDET_CTL1r
#define MODIFY_SIGDET_CTL1r BCMI_TSCE16_XGXS_MODIFY_SIGDET_CTL1r
#define READLN_SIGDET_CTL1r BCMI_TSCE16_XGXS_READLN_SIGDET_CTL1r
#define WRITELN_SIGDET_CTL1r BCMI_TSCE16_XGXS_WRITELN_SIGDET_CTL1r
#define WRITEALL_SIGDET_CTL1r BCMI_TSCE16_XGXS_WRITEALL_SIGDET_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SIGDET_CTL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SIGDET_CTL2
 * BLOCKS:   SIGDET
 * REGADDR:  0xd0c2
 * DESC:     SIGDET_CTRL_2
 * RESETVAL: 0xfd29 (64809)
 * ACCESS:   R/W
 * FIELDS:
 *     LOS_THRESH       AFE signal detect threshold to be used when filtered signal_detect == 1.
 *     SIGNAL_DETECT_THRESH AFE signal detect threshold to be used when filtered signal_detect == 0.
 *     HOLD_LOS_COUNT   HOLD_LOS state counter. Value 0 to 7 maps to 2 to 16 in increments of 2.
 *     HOLD_SD_COUNT    HOLD_SD state counter. Value 0 to 7 maps to 2 to 16 in increments of 2.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SIGDET_CTL2r (0x0000d0c2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SIGDET_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program SIGDET_CTL2.
 *
 */
typedef union BCMI_TSCE16_XGXS_SIGDET_CTL2r_s {
	uint32_t v[1];
	uint32_t sigdet_ctl2[1];
	uint32_t _sigdet_ctl2;
} BCMI_TSCE16_XGXS_SIGDET_CTL2r_t;

#define BCMI_TSCE16_XGXS_SIGDET_CTL2r_CLR(r) (r).sigdet_ctl2[0] = 0
#define BCMI_TSCE16_XGXS_SIGDET_CTL2r_SET(r,d) (r).sigdet_ctl2[0] = d
#define BCMI_TSCE16_XGXS_SIGDET_CTL2r_GET(r) (r).sigdet_ctl2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SIGDET_CTL2r_HOLD_SD_COUNTf_GET(r) ((((r).sigdet_ctl2[0]) >> 13) & 0x7)
#define BCMI_TSCE16_XGXS_SIGDET_CTL2r_HOLD_SD_COUNTf_SET(r,f) (r).sigdet_ctl2[0]=(((r).sigdet_ctl2[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13)) | (7 << (16 + 13))
#define BCMI_TSCE16_XGXS_SIGDET_CTL2r_HOLD_LOS_COUNTf_GET(r) ((((r).sigdet_ctl2[0]) >> 10) & 0x7)
#define BCMI_TSCE16_XGXS_SIGDET_CTL2r_HOLD_LOS_COUNTf_SET(r,f) (r).sigdet_ctl2[0]=(((r).sigdet_ctl2[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10)) | (7 << (16 + 10))
#define BCMI_TSCE16_XGXS_SIGDET_CTL2r_SIGNAL_DETECT_THRESHf_GET(r) ((((r).sigdet_ctl2[0]) >> 5) & 0x1f)
#define BCMI_TSCE16_XGXS_SIGDET_CTL2r_SIGNAL_DETECT_THRESHf_SET(r,f) (r).sigdet_ctl2[0]=(((r).sigdet_ctl2[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_TSCE16_XGXS_SIGDET_CTL2r_LOS_THRESHf_GET(r) (((r).sigdet_ctl2[0]) & 0x1f)
#define BCMI_TSCE16_XGXS_SIGDET_CTL2r_LOS_THRESHf_SET(r,f) (r).sigdet_ctl2[0]=(((r).sigdet_ctl2[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access SIGDET_CTL2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SIGDET_CTL2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SIGDET_CTL2r,(_r._sigdet_ctl2))
#define BCMI_TSCE16_XGXS_WRITE_SIGDET_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SIGDET_CTL2r,(_r._sigdet_ctl2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SIGDET_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SIGDET_CTL2r,(_r._sigdet_ctl2))
#define BCMI_TSCE16_XGXS_READLN_SIGDET_CTL2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SIGDET_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_ctl2))
#define BCMI_TSCE16_XGXS_WRITELN_SIGDET_CTL2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SIGDET_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_ctl2))
#define BCMI_TSCE16_XGXS_WRITEALL_SIGDET_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SIGDET_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sigdet_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SIGDET_CTL2r BCMI_TSCE16_XGXS_SIGDET_CTL2r
#define SIGDET_CTL2r_SIZE BCMI_TSCE16_XGXS_SIGDET_CTL2r_SIZE
typedef BCMI_TSCE16_XGXS_SIGDET_CTL2r_t SIGDET_CTL2r_t;
#define SIGDET_CTL2r_CLR BCMI_TSCE16_XGXS_SIGDET_CTL2r_CLR
#define SIGDET_CTL2r_SET BCMI_TSCE16_XGXS_SIGDET_CTL2r_SET
#define SIGDET_CTL2r_GET BCMI_TSCE16_XGXS_SIGDET_CTL2r_GET
#define SIGDET_CTL2r_HOLD_SD_COUNTf_GET BCMI_TSCE16_XGXS_SIGDET_CTL2r_HOLD_SD_COUNTf_GET
#define SIGDET_CTL2r_HOLD_SD_COUNTf_SET BCMI_TSCE16_XGXS_SIGDET_CTL2r_HOLD_SD_COUNTf_SET
#define SIGDET_CTL2r_HOLD_LOS_COUNTf_GET BCMI_TSCE16_XGXS_SIGDET_CTL2r_HOLD_LOS_COUNTf_GET
#define SIGDET_CTL2r_HOLD_LOS_COUNTf_SET BCMI_TSCE16_XGXS_SIGDET_CTL2r_HOLD_LOS_COUNTf_SET
#define SIGDET_CTL2r_SIGNAL_DETECT_THRESHf_GET BCMI_TSCE16_XGXS_SIGDET_CTL2r_SIGNAL_DETECT_THRESHf_GET
#define SIGDET_CTL2r_SIGNAL_DETECT_THRESHf_SET BCMI_TSCE16_XGXS_SIGDET_CTL2r_SIGNAL_DETECT_THRESHf_SET
#define SIGDET_CTL2r_LOS_THRESHf_GET BCMI_TSCE16_XGXS_SIGDET_CTL2r_LOS_THRESHf_GET
#define SIGDET_CTL2r_LOS_THRESHf_SET BCMI_TSCE16_XGXS_SIGDET_CTL2r_LOS_THRESHf_SET
#define READ_SIGDET_CTL2r BCMI_TSCE16_XGXS_READ_SIGDET_CTL2r
#define WRITE_SIGDET_CTL2r BCMI_TSCE16_XGXS_WRITE_SIGDET_CTL2r
#define MODIFY_SIGDET_CTL2r BCMI_TSCE16_XGXS_MODIFY_SIGDET_CTL2r
#define READLN_SIGDET_CTL2r BCMI_TSCE16_XGXS_READLN_SIGDET_CTL2r
#define WRITELN_SIGDET_CTL2r BCMI_TSCE16_XGXS_WRITELN_SIGDET_CTL2r
#define WRITEALL_SIGDET_CTL2r BCMI_TSCE16_XGXS_WRITEALL_SIGDET_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SIGDET_CTL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SIGDET_STS0
 * BLOCKS:   SIGDET
 * REGADDR:  0xd0c8
 * DESC:     SIGDET_STATUS_0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     SIGNAL_DETECT    Filtered version of Signal Detect after frc/frc_val.
 *     SIGNAL_DETECT_CHANGE This latches the transition on signal_detect and cleared on read.
 *     SIGNAL_DETECT_RAW Raw version of Signal Detect going into the filter.
 *     SIGNAL_DETECT_RAW_CHANGE This latches the transition on signal_detect_raw and cleared on read.
 *     EXT_SIGDET       External LOS/sigdet from the pin going into the sigdet filter.
 *     EXT_SIGDET_CHANGE This latches the transition on ext_sigdet and cleared on read.
 *     AFE_SIGDET       Internal sigdet from the AFE sigdet block going into the sigdet filter.
 *     AFE_SIGDET_CHANGE This latches the transition on afe_sigdet and cleared on read.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SIGDET_STS0r (0x0000d0c8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SIGDET_STS0r_SIZE 4

/*
 * This structure should be used to declare and program SIGDET_STS0.
 *
 */
typedef union BCMI_TSCE16_XGXS_SIGDET_STS0r_s {
	uint32_t v[1];
	uint32_t sigdet_sts0[1];
	uint32_t _sigdet_sts0;
} BCMI_TSCE16_XGXS_SIGDET_STS0r_t;

#define BCMI_TSCE16_XGXS_SIGDET_STS0r_CLR(r) (r).sigdet_sts0[0] = 0
#define BCMI_TSCE16_XGXS_SIGDET_STS0r_SET(r,d) (r).sigdet_sts0[0] = d
#define BCMI_TSCE16_XGXS_SIGDET_STS0r_GET(r) (r).sigdet_sts0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SIGDET_STS0r_AFE_SIGDET_CHANGEf_GET(r) ((((r).sigdet_sts0[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_SIGDET_STS0r_AFE_SIGDET_CHANGEf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_SIGDET_STS0r_AFE_SIGDETf_GET(r) ((((r).sigdet_sts0[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_SIGDET_STS0r_AFE_SIGDETf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_SIGDET_STS0r_EXT_SIGDET_CHANGEf_GET(r) ((((r).sigdet_sts0[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_SIGDET_STS0r_EXT_SIGDET_CHANGEf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_SIGDET_STS0r_EXT_SIGDETf_GET(r) ((((r).sigdet_sts0[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_SIGDET_STS0r_EXT_SIGDETf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_GET(r) ((((r).sigdet_sts0[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAWf_GET(r) ((((r).sigdet_sts0[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAWf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_GET(r) ((((r).sigdet_sts0[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_SIGDET_STS0r_SIGNAL_DETECTf_GET(r) (((r).sigdet_sts0[0]) & 0x1)
#define BCMI_TSCE16_XGXS_SIGDET_STS0r_SIGNAL_DETECTf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SIGDET_STS0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SIGDET_STS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SIGDET_STS0r,(_r._sigdet_sts0))
#define BCMI_TSCE16_XGXS_WRITE_SIGDET_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SIGDET_STS0r,(_r._sigdet_sts0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SIGDET_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SIGDET_STS0r,(_r._sigdet_sts0))
#define BCMI_TSCE16_XGXS_READLN_SIGDET_STS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SIGDET_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_sts0))
#define BCMI_TSCE16_XGXS_WRITELN_SIGDET_STS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SIGDET_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_sts0))
#define BCMI_TSCE16_XGXS_WRITEALL_SIGDET_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SIGDET_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sigdet_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SIGDET_STS0r BCMI_TSCE16_XGXS_SIGDET_STS0r
#define SIGDET_STS0r_SIZE BCMI_TSCE16_XGXS_SIGDET_STS0r_SIZE
typedef BCMI_TSCE16_XGXS_SIGDET_STS0r_t SIGDET_STS0r_t;
#define SIGDET_STS0r_CLR BCMI_TSCE16_XGXS_SIGDET_STS0r_CLR
#define SIGDET_STS0r_SET BCMI_TSCE16_XGXS_SIGDET_STS0r_SET
#define SIGDET_STS0r_GET BCMI_TSCE16_XGXS_SIGDET_STS0r_GET
#define SIGDET_STS0r_AFE_SIGDET_CHANGEf_GET BCMI_TSCE16_XGXS_SIGDET_STS0r_AFE_SIGDET_CHANGEf_GET
#define SIGDET_STS0r_AFE_SIGDET_CHANGEf_SET BCMI_TSCE16_XGXS_SIGDET_STS0r_AFE_SIGDET_CHANGEf_SET
#define SIGDET_STS0r_AFE_SIGDETf_GET BCMI_TSCE16_XGXS_SIGDET_STS0r_AFE_SIGDETf_GET
#define SIGDET_STS0r_AFE_SIGDETf_SET BCMI_TSCE16_XGXS_SIGDET_STS0r_AFE_SIGDETf_SET
#define SIGDET_STS0r_EXT_SIGDET_CHANGEf_GET BCMI_TSCE16_XGXS_SIGDET_STS0r_EXT_SIGDET_CHANGEf_GET
#define SIGDET_STS0r_EXT_SIGDET_CHANGEf_SET BCMI_TSCE16_XGXS_SIGDET_STS0r_EXT_SIGDET_CHANGEf_SET
#define SIGDET_STS0r_EXT_SIGDETf_GET BCMI_TSCE16_XGXS_SIGDET_STS0r_EXT_SIGDETf_GET
#define SIGDET_STS0r_EXT_SIGDETf_SET BCMI_TSCE16_XGXS_SIGDET_STS0r_EXT_SIGDETf_SET
#define SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_GET BCMI_TSCE16_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_GET
#define SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_SET BCMI_TSCE16_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_SET
#define SIGDET_STS0r_SIGNAL_DETECT_RAWf_GET BCMI_TSCE16_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAWf_GET
#define SIGDET_STS0r_SIGNAL_DETECT_RAWf_SET BCMI_TSCE16_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAWf_SET
#define SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_GET BCMI_TSCE16_XGXS_SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_GET
#define SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_SET BCMI_TSCE16_XGXS_SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_SET
#define SIGDET_STS0r_SIGNAL_DETECTf_GET BCMI_TSCE16_XGXS_SIGDET_STS0r_SIGNAL_DETECTf_GET
#define SIGDET_STS0r_SIGNAL_DETECTf_SET BCMI_TSCE16_XGXS_SIGDET_STS0r_SIGNAL_DETECTf_SET
#define READ_SIGDET_STS0r BCMI_TSCE16_XGXS_READ_SIGDET_STS0r
#define WRITE_SIGDET_STS0r BCMI_TSCE16_XGXS_WRITE_SIGDET_STS0r
#define MODIFY_SIGDET_STS0r BCMI_TSCE16_XGXS_MODIFY_SIGDET_STS0r
#define READLN_SIGDET_STS0r BCMI_TSCE16_XGXS_READLN_SIGDET_STS0r
#define WRITELN_SIGDET_STS0r BCMI_TSCE16_XGXS_WRITELN_SIGDET_STS0r
#define WRITEALL_SIGDET_STS0r BCMI_TSCE16_XGXS_WRITEALL_SIGDET_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SIGDET_STS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SIGDET_STS1
 * BLOCKS:   SIGDET
 * REGADDR:  0xd0c9
 * DESC:     SIGDET_STATUS_1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     UC_SIGNAL_DETECT Filtered version of Signal Detect after frc/frc_val.
 *     UC_SIGNAL_DETECT_CHANGE This latches the transition on uc_signal_detect and cleared on read.
 *     UC_EXT_SIGDET    External LOS/sigdet from the pin going into the sigdet filter.
 *     UC_EXT_SIGDET_CHANGE This latches the transition on uc_ext_sigdet and cleared on read.
 *     UC_AFE_SIGDET    Internal sigdet from the AFE sigdet block going into the sigdet filter.
 *     UC_AFE_SIGDET_CHANGE This latches the transition on uc_afe_sigdet and cleared on read.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SIGDET_STS1r (0x0000d0c9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SIGDET_STS1r_SIZE 4

/*
 * This structure should be used to declare and program SIGDET_STS1.
 *
 */
typedef union BCMI_TSCE16_XGXS_SIGDET_STS1r_s {
	uint32_t v[1];
	uint32_t sigdet_sts1[1];
	uint32_t _sigdet_sts1;
} BCMI_TSCE16_XGXS_SIGDET_STS1r_t;

#define BCMI_TSCE16_XGXS_SIGDET_STS1r_CLR(r) (r).sigdet_sts1[0] = 0
#define BCMI_TSCE16_XGXS_SIGDET_STS1r_SET(r,d) (r).sigdet_sts1[0] = d
#define BCMI_TSCE16_XGXS_SIGDET_STS1r_GET(r) (r).sigdet_sts1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SIGDET_STS1r_UC_AFE_SIGDET_CHANGEf_GET(r) ((((r).sigdet_sts1[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_SIGDET_STS1r_UC_AFE_SIGDET_CHANGEf_SET(r,f) (r).sigdet_sts1[0]=(((r).sigdet_sts1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_SIGDET_STS1r_UC_AFE_SIGDETf_GET(r) ((((r).sigdet_sts1[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_SIGDET_STS1r_UC_AFE_SIGDETf_SET(r,f) (r).sigdet_sts1[0]=(((r).sigdet_sts1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_SIGDET_STS1r_UC_EXT_SIGDET_CHANGEf_GET(r) ((((r).sigdet_sts1[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_SIGDET_STS1r_UC_EXT_SIGDET_CHANGEf_SET(r,f) (r).sigdet_sts1[0]=(((r).sigdet_sts1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_SIGDET_STS1r_UC_EXT_SIGDETf_GET(r) ((((r).sigdet_sts1[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_SIGDET_STS1r_UC_EXT_SIGDETf_SET(r,f) (r).sigdet_sts1[0]=(((r).sigdet_sts1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_SIGDET_STS1r_UC_SIGNAL_DETECT_CHANGEf_GET(r) ((((r).sigdet_sts1[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_SIGDET_STS1r_UC_SIGNAL_DETECT_CHANGEf_SET(r,f) (r).sigdet_sts1[0]=(((r).sigdet_sts1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_SIGDET_STS1r_UC_SIGNAL_DETECTf_GET(r) (((r).sigdet_sts1[0]) & 0x1)
#define BCMI_TSCE16_XGXS_SIGDET_STS1r_UC_SIGNAL_DETECTf_SET(r,f) (r).sigdet_sts1[0]=(((r).sigdet_sts1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SIGDET_STS1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SIGDET_STS1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SIGDET_STS1r,(_r._sigdet_sts1))
#define BCMI_TSCE16_XGXS_WRITE_SIGDET_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SIGDET_STS1r,(_r._sigdet_sts1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SIGDET_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SIGDET_STS1r,(_r._sigdet_sts1))
#define BCMI_TSCE16_XGXS_READLN_SIGDET_STS1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SIGDET_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_sts1))
#define BCMI_TSCE16_XGXS_WRITELN_SIGDET_STS1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SIGDET_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_sts1))
#define BCMI_TSCE16_XGXS_WRITEALL_SIGDET_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SIGDET_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sigdet_sts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SIGDET_STS1r BCMI_TSCE16_XGXS_SIGDET_STS1r
#define SIGDET_STS1r_SIZE BCMI_TSCE16_XGXS_SIGDET_STS1r_SIZE
typedef BCMI_TSCE16_XGXS_SIGDET_STS1r_t SIGDET_STS1r_t;
#define SIGDET_STS1r_CLR BCMI_TSCE16_XGXS_SIGDET_STS1r_CLR
#define SIGDET_STS1r_SET BCMI_TSCE16_XGXS_SIGDET_STS1r_SET
#define SIGDET_STS1r_GET BCMI_TSCE16_XGXS_SIGDET_STS1r_GET
#define SIGDET_STS1r_UC_AFE_SIGDET_CHANGEf_GET BCMI_TSCE16_XGXS_SIGDET_STS1r_UC_AFE_SIGDET_CHANGEf_GET
#define SIGDET_STS1r_UC_AFE_SIGDET_CHANGEf_SET BCMI_TSCE16_XGXS_SIGDET_STS1r_UC_AFE_SIGDET_CHANGEf_SET
#define SIGDET_STS1r_UC_AFE_SIGDETf_GET BCMI_TSCE16_XGXS_SIGDET_STS1r_UC_AFE_SIGDETf_GET
#define SIGDET_STS1r_UC_AFE_SIGDETf_SET BCMI_TSCE16_XGXS_SIGDET_STS1r_UC_AFE_SIGDETf_SET
#define SIGDET_STS1r_UC_EXT_SIGDET_CHANGEf_GET BCMI_TSCE16_XGXS_SIGDET_STS1r_UC_EXT_SIGDET_CHANGEf_GET
#define SIGDET_STS1r_UC_EXT_SIGDET_CHANGEf_SET BCMI_TSCE16_XGXS_SIGDET_STS1r_UC_EXT_SIGDET_CHANGEf_SET
#define SIGDET_STS1r_UC_EXT_SIGDETf_GET BCMI_TSCE16_XGXS_SIGDET_STS1r_UC_EXT_SIGDETf_GET
#define SIGDET_STS1r_UC_EXT_SIGDETf_SET BCMI_TSCE16_XGXS_SIGDET_STS1r_UC_EXT_SIGDETf_SET
#define SIGDET_STS1r_UC_SIGNAL_DETECT_CHANGEf_GET BCMI_TSCE16_XGXS_SIGDET_STS1r_UC_SIGNAL_DETECT_CHANGEf_GET
#define SIGDET_STS1r_UC_SIGNAL_DETECT_CHANGEf_SET BCMI_TSCE16_XGXS_SIGDET_STS1r_UC_SIGNAL_DETECT_CHANGEf_SET
#define SIGDET_STS1r_UC_SIGNAL_DETECTf_GET BCMI_TSCE16_XGXS_SIGDET_STS1r_UC_SIGNAL_DETECTf_GET
#define SIGDET_STS1r_UC_SIGNAL_DETECTf_SET BCMI_TSCE16_XGXS_SIGDET_STS1r_UC_SIGNAL_DETECTf_SET
#define READ_SIGDET_STS1r BCMI_TSCE16_XGXS_READ_SIGDET_STS1r
#define WRITE_SIGDET_STS1r BCMI_TSCE16_XGXS_WRITE_SIGDET_STS1r
#define MODIFY_SIGDET_STS1r BCMI_TSCE16_XGXS_MODIFY_SIGDET_STS1r
#define READLN_SIGDET_STS1r BCMI_TSCE16_XGXS_READLN_SIGDET_STS1r
#define WRITELN_SIGDET_STS1r BCMI_TSCE16_XGXS_WRITELN_SIGDET_STS1r
#define WRITEALL_SIGDET_STS1r BCMI_TSCE16_XGXS_WRITEALL_SIGDET_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SIGDET_STS1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SIGDET_STS2
 * BLOCKS:   SIGDET
 * REGADDR:  0xd0ca
 * DESC:     SIGDET_STATUS_2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     ENERGY_DETECT    Filtered version of Energy Detect after frc/frc_val.
 *     ENERGY_DETECT_CHANGE This latches the transition on energy_detect and cleared on read.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SIGDET_STS2r (0x0000d0ca | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SIGDET_STS2r_SIZE 4

/*
 * This structure should be used to declare and program SIGDET_STS2.
 *
 */
typedef union BCMI_TSCE16_XGXS_SIGDET_STS2r_s {
	uint32_t v[1];
	uint32_t sigdet_sts2[1];
	uint32_t _sigdet_sts2;
} BCMI_TSCE16_XGXS_SIGDET_STS2r_t;

#define BCMI_TSCE16_XGXS_SIGDET_STS2r_CLR(r) (r).sigdet_sts2[0] = 0
#define BCMI_TSCE16_XGXS_SIGDET_STS2r_SET(r,d) (r).sigdet_sts2[0] = d
#define BCMI_TSCE16_XGXS_SIGDET_STS2r_GET(r) (r).sigdet_sts2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SIGDET_STS2r_ENERGY_DETECT_CHANGEf_GET(r) ((((r).sigdet_sts2[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_SIGDET_STS2r_ENERGY_DETECT_CHANGEf_SET(r,f) (r).sigdet_sts2[0]=(((r).sigdet_sts2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_SIGDET_STS2r_ENERGY_DETECTf_GET(r) (((r).sigdet_sts2[0]) & 0x1)
#define BCMI_TSCE16_XGXS_SIGDET_STS2r_ENERGY_DETECTf_SET(r,f) (r).sigdet_sts2[0]=(((r).sigdet_sts2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SIGDET_STS2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SIGDET_STS2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SIGDET_STS2r,(_r._sigdet_sts2))
#define BCMI_TSCE16_XGXS_WRITE_SIGDET_STS2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SIGDET_STS2r,(_r._sigdet_sts2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SIGDET_STS2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SIGDET_STS2r,(_r._sigdet_sts2))
#define BCMI_TSCE16_XGXS_READLN_SIGDET_STS2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SIGDET_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_sts2))
#define BCMI_TSCE16_XGXS_WRITELN_SIGDET_STS2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SIGDET_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_sts2))
#define BCMI_TSCE16_XGXS_WRITEALL_SIGDET_STS2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SIGDET_STS2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sigdet_sts2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SIGDET_STS2r BCMI_TSCE16_XGXS_SIGDET_STS2r
#define SIGDET_STS2r_SIZE BCMI_TSCE16_XGXS_SIGDET_STS2r_SIZE
typedef BCMI_TSCE16_XGXS_SIGDET_STS2r_t SIGDET_STS2r_t;
#define SIGDET_STS2r_CLR BCMI_TSCE16_XGXS_SIGDET_STS2r_CLR
#define SIGDET_STS2r_SET BCMI_TSCE16_XGXS_SIGDET_STS2r_SET
#define SIGDET_STS2r_GET BCMI_TSCE16_XGXS_SIGDET_STS2r_GET
#define SIGDET_STS2r_ENERGY_DETECT_CHANGEf_GET BCMI_TSCE16_XGXS_SIGDET_STS2r_ENERGY_DETECT_CHANGEf_GET
#define SIGDET_STS2r_ENERGY_DETECT_CHANGEf_SET BCMI_TSCE16_XGXS_SIGDET_STS2r_ENERGY_DETECT_CHANGEf_SET
#define SIGDET_STS2r_ENERGY_DETECTf_GET BCMI_TSCE16_XGXS_SIGDET_STS2r_ENERGY_DETECTf_GET
#define SIGDET_STS2r_ENERGY_DETECTf_SET BCMI_TSCE16_XGXS_SIGDET_STS2r_ENERGY_DETECTf_SET
#define READ_SIGDET_STS2r BCMI_TSCE16_XGXS_READ_SIGDET_STS2r
#define WRITE_SIGDET_STS2r BCMI_TSCE16_XGXS_WRITE_SIGDET_STS2r
#define MODIFY_SIGDET_STS2r BCMI_TSCE16_XGXS_MODIFY_SIGDET_STS2r
#define READLN_SIGDET_STS2r BCMI_TSCE16_XGXS_READLN_SIGDET_STS2r
#define WRITELN_SIGDET_STS2r BCMI_TSCE16_XGXS_WRITELN_SIGDET_STS2r
#define WRITEALL_SIGDET_STS2r BCMI_TSCE16_XGXS_WRITEALL_SIGDET_STS2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SIGDET_STS2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SIGDET_STS3
 * BLOCKS:   SIGDET
 * REGADDR:  0xd0cb
 * DESC:     SIGDET_STATUS_3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PMD_SIGNAL_DETECT Filtered version of Signal Detect after frc/frc_val.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SIGDET_STS3r (0x0000d0cb | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SIGDET_STS3r_SIZE 4

/*
 * This structure should be used to declare and program SIGDET_STS3.
 *
 */
typedef union BCMI_TSCE16_XGXS_SIGDET_STS3r_s {
	uint32_t v[1];
	uint32_t sigdet_sts3[1];
	uint32_t _sigdet_sts3;
} BCMI_TSCE16_XGXS_SIGDET_STS3r_t;

#define BCMI_TSCE16_XGXS_SIGDET_STS3r_CLR(r) (r).sigdet_sts3[0] = 0
#define BCMI_TSCE16_XGXS_SIGDET_STS3r_SET(r,d) (r).sigdet_sts3[0] = d
#define BCMI_TSCE16_XGXS_SIGDET_STS3r_GET(r) (r).sigdet_sts3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SIGDET_STS3r_PMD_SIGNAL_DETECTf_GET(r) (((r).sigdet_sts3[0]) & 0x1)
#define BCMI_TSCE16_XGXS_SIGDET_STS3r_PMD_SIGNAL_DETECTf_SET(r,f) (r).sigdet_sts3[0]=(((r).sigdet_sts3[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SIGDET_STS3.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SIGDET_STS3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SIGDET_STS3r,(_r._sigdet_sts3))
#define BCMI_TSCE16_XGXS_WRITE_SIGDET_STS3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SIGDET_STS3r,(_r._sigdet_sts3)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SIGDET_STS3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SIGDET_STS3r,(_r._sigdet_sts3))
#define BCMI_TSCE16_XGXS_READLN_SIGDET_STS3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SIGDET_STS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_sts3))
#define BCMI_TSCE16_XGXS_WRITELN_SIGDET_STS3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SIGDET_STS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_sts3))
#define BCMI_TSCE16_XGXS_WRITEALL_SIGDET_STS3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SIGDET_STS3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sigdet_sts3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SIGDET_STS3r BCMI_TSCE16_XGXS_SIGDET_STS3r
#define SIGDET_STS3r_SIZE BCMI_TSCE16_XGXS_SIGDET_STS3r_SIZE
typedef BCMI_TSCE16_XGXS_SIGDET_STS3r_t SIGDET_STS3r_t;
#define SIGDET_STS3r_CLR BCMI_TSCE16_XGXS_SIGDET_STS3r_CLR
#define SIGDET_STS3r_SET BCMI_TSCE16_XGXS_SIGDET_STS3r_SET
#define SIGDET_STS3r_GET BCMI_TSCE16_XGXS_SIGDET_STS3r_GET
#define SIGDET_STS3r_PMD_SIGNAL_DETECTf_GET BCMI_TSCE16_XGXS_SIGDET_STS3r_PMD_SIGNAL_DETECTf_GET
#define SIGDET_STS3r_PMD_SIGNAL_DETECTf_SET BCMI_TSCE16_XGXS_SIGDET_STS3r_PMD_SIGNAL_DETECTf_SET
#define READ_SIGDET_STS3r BCMI_TSCE16_XGXS_READ_SIGDET_STS3r
#define WRITE_SIGDET_STS3r BCMI_TSCE16_XGXS_WRITE_SIGDET_STS3r
#define MODIFY_SIGDET_STS3r BCMI_TSCE16_XGXS_MODIFY_SIGDET_STS3r
#define READLN_SIGDET_STS3r BCMI_TSCE16_XGXS_READLN_SIGDET_STS3r
#define WRITELN_SIGDET_STS3r BCMI_TSCE16_XGXS_WRITELN_SIGDET_STS3r
#define WRITEALL_SIGDET_STS3r BCMI_TSCE16_XGXS_WRITEALL_SIGDET_STS3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SIGDET_STS3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  SIGDET_STS4
 * BLOCKS:   SIGDET
 * REGADDR:  0xd0cc
 * DESC:     SIGDET_STATUS_4
 * RESETVAL: 0x9 (9)
 * ACCESS:   R/O
 * FIELDS:
 *     AFE_SIGDET_THRESH Live status of sigdet_thresh going to AFE.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_SIGDET_STS4r (0x0000d0cc | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_SIGDET_STS4r_SIZE 4

/*
 * This structure should be used to declare and program SIGDET_STS4.
 *
 */
typedef union BCMI_TSCE16_XGXS_SIGDET_STS4r_s {
	uint32_t v[1];
	uint32_t sigdet_sts4[1];
	uint32_t _sigdet_sts4;
} BCMI_TSCE16_XGXS_SIGDET_STS4r_t;

#define BCMI_TSCE16_XGXS_SIGDET_STS4r_CLR(r) (r).sigdet_sts4[0] = 0
#define BCMI_TSCE16_XGXS_SIGDET_STS4r_SET(r,d) (r).sigdet_sts4[0] = d
#define BCMI_TSCE16_XGXS_SIGDET_STS4r_GET(r) (r).sigdet_sts4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_SIGDET_STS4r_AFE_SIGDET_THRESHf_GET(r) (((r).sigdet_sts4[0]) & 0x1f)
#define BCMI_TSCE16_XGXS_SIGDET_STS4r_AFE_SIGDET_THRESHf_SET(r,f) (r).sigdet_sts4[0]=(((r).sigdet_sts4[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access SIGDET_STS4.
 *
 */
#define BCMI_TSCE16_XGXS_READ_SIGDET_STS4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SIGDET_STS4r,(_r._sigdet_sts4))
#define BCMI_TSCE16_XGXS_WRITE_SIGDET_STS4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SIGDET_STS4r,(_r._sigdet_sts4)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_SIGDET_STS4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SIGDET_STS4r,(_r._sigdet_sts4))
#define BCMI_TSCE16_XGXS_READLN_SIGDET_STS4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_SIGDET_STS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_sts4))
#define BCMI_TSCE16_XGXS_WRITELN_SIGDET_STS4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SIGDET_STS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_sts4))
#define BCMI_TSCE16_XGXS_WRITEALL_SIGDET_STS4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_SIGDET_STS4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sigdet_sts4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SIGDET_STS4r BCMI_TSCE16_XGXS_SIGDET_STS4r
#define SIGDET_STS4r_SIZE BCMI_TSCE16_XGXS_SIGDET_STS4r_SIZE
typedef BCMI_TSCE16_XGXS_SIGDET_STS4r_t SIGDET_STS4r_t;
#define SIGDET_STS4r_CLR BCMI_TSCE16_XGXS_SIGDET_STS4r_CLR
#define SIGDET_STS4r_SET BCMI_TSCE16_XGXS_SIGDET_STS4r_SET
#define SIGDET_STS4r_GET BCMI_TSCE16_XGXS_SIGDET_STS4r_GET
#define SIGDET_STS4r_AFE_SIGDET_THRESHf_GET BCMI_TSCE16_XGXS_SIGDET_STS4r_AFE_SIGDET_THRESHf_GET
#define SIGDET_STS4r_AFE_SIGDET_THRESHf_SET BCMI_TSCE16_XGXS_SIGDET_STS4r_AFE_SIGDET_THRESHf_SET
#define READ_SIGDET_STS4r BCMI_TSCE16_XGXS_READ_SIGDET_STS4r
#define WRITE_SIGDET_STS4r BCMI_TSCE16_XGXS_WRITE_SIGDET_STS4r
#define MODIFY_SIGDET_STS4r BCMI_TSCE16_XGXS_MODIFY_SIGDET_STS4r
#define READLN_SIGDET_STS4r BCMI_TSCE16_XGXS_READLN_SIGDET_STS4r
#define WRITELN_SIGDET_STS4r BCMI_TSCE16_XGXS_WRITELN_SIGDET_STS4r
#define WRITEALL_SIGDET_STS4r BCMI_TSCE16_XGXS_WRITEALL_SIGDET_STS4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_SIGDET_STS4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TLB_RX_PRBS_CHK_CNT_CFG
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd0d0
 * DESC:     PRBS Checker Count Control
 * RESETVAL: 0x602 (1538)
 * ACCESS:   R/W
 * FIELDS:
 *     PRBS_CHK_LOCK_CNT specifies the number of consecutive valid clock cycles without any bit errorfor PRBS checker to go into PRBS lock state. Valid values are 0 to 31 where0 indicate that PRBS will lock as soon as it gets the first clock cycle with no bit error.likewise 31 indicates that PRBS will lock as soon as it gets the 32 consecutive clocks with no error.
 *     PRBS_CHK_OOL_CNT specifies the number of consecutive valid clock cycles with 1 or more bit errorsfor PRBS checker to go out of PRBS lock state. Valid values are 0 to 31 where0 indicate that PRBS will go out of lock as soon as it gets the first clock cycle with 1 or more bit errors.likewise 31 indicates that PRBS will go out of lock as soon as it gets the 32 consecutive clocks with 1 or more errors.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr (0x0000d0d0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_CNT_CFG.
 *
 */
typedef union BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_cnt_cfg[1];
	uint32_t _tlb_rx_prbs_chk_cnt_cfg;
} BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_t;

#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_CLR(r) (r).tlb_rx_prbs_chk_cnt_cfg[0] = 0
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_SET(r,d) (r).tlb_rx_prbs_chk_cnt_cfg[0] = d
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_GET(r) (r).tlb_rx_prbs_chk_cnt_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_GET(r) ((((r).tlb_rx_prbs_chk_cnt_cfg[0]) >> 8) & 0x1f)
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_SET(r,f) (r).tlb_rx_prbs_chk_cnt_cfg[0]=(((r).tlb_rx_prbs_chk_cnt_cfg[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_GET(r) (((r).tlb_rx_prbs_chk_cnt_cfg[0]) & 0x1f)
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_SET(r,f) (r).tlb_rx_prbs_chk_cnt_cfg[0]=(((r).tlb_rx_prbs_chk_cnt_cfg[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_CNT_CFG.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TLB_RX_PRBS_CHK_CNT_CFGr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr,(_r._tlb_rx_prbs_chk_cnt_cfg))
#define BCMI_TSCE16_XGXS_WRITE_TLB_RX_PRBS_CHK_CNT_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr,(_r._tlb_rx_prbs_chk_cnt_cfg)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TLB_RX_PRBS_CHK_CNT_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr,(_r._tlb_rx_prbs_chk_cnt_cfg))
#define BCMI_TSCE16_XGXS_READLN_TLB_RX_PRBS_CHK_CNT_CFGr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_cnt_cfg))
#define BCMI_TSCE16_XGXS_WRITELN_TLB_RX_PRBS_CHK_CNT_CFGr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_cnt_cfg))
#define BCMI_TSCE16_XGXS_WRITEALL_TLB_RX_PRBS_CHK_CNT_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_chk_cnt_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_CNT_CFGr BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr
#define TLB_RX_PRBS_CHK_CNT_CFGr_SIZE BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_SIZE
typedef BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_t TLB_RX_PRBS_CHK_CNT_CFGr_t;
#define TLB_RX_PRBS_CHK_CNT_CFGr_CLR BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_CLR
#define TLB_RX_PRBS_CHK_CNT_CFGr_SET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_SET
#define TLB_RX_PRBS_CHK_CNT_CFGr_GET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_GET
#define TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_GET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_GET
#define TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_SET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_SET
#define TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_GET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_GET
#define TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_SET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_SET
#define READ_TLB_RX_PRBS_CHK_CNT_CFGr BCMI_TSCE16_XGXS_READ_TLB_RX_PRBS_CHK_CNT_CFGr
#define WRITE_TLB_RX_PRBS_CHK_CNT_CFGr BCMI_TSCE16_XGXS_WRITE_TLB_RX_PRBS_CHK_CNT_CFGr
#define MODIFY_TLB_RX_PRBS_CHK_CNT_CFGr BCMI_TSCE16_XGXS_MODIFY_TLB_RX_PRBS_CHK_CNT_CFGr
#define READLN_TLB_RX_PRBS_CHK_CNT_CFGr BCMI_TSCE16_XGXS_READLN_TLB_RX_PRBS_CHK_CNT_CFGr
#define WRITELN_TLB_RX_PRBS_CHK_CNT_CFGr BCMI_TSCE16_XGXS_WRITELN_TLB_RX_PRBS_CHK_CNT_CFGr
#define WRITEALL_TLB_RX_PRBS_CHK_CNT_CFGr BCMI_TSCE16_XGXS_WRITEALL_TLB_RX_PRBS_CHK_CNT_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TLB_RX_PRBS_CHK_CFG
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd0d1
 * DESC:     PRBS Checker Control
 * RESETVAL: 0x2a (42)
 * ACCESS:   R/W
 * FIELDS:
 *     PRBS_CHK_EN      PRBS checker enable.1 => enable  the PRBS checker.0 => disable the PRBS checker.
 *     PRBS_CHK_MODE_SEL PRBS checker mode select. Selects the PRBS polynomial as shown below3'd0 -> PRBS 73'd1 -> PRBS 93'd2 -> PRBS 113'd3 -> PRBS 153'd4 -> PRBS 233'd5 -> PRBS 313'd6 -> PRBS 58 (1 + x^39 + x^58)3'd7 -> reserved for future use.
 *     PRBS_CHK_INV     PRBS Invert enable.1 => will invert all the data bits to the PRBS checker.0 => will send normal data to the PRBS checker.
 *     PRBS_CHK_MODE    PRBS LOCK state machine select.2'd0 -> Self-sync mode w/ hysteresis. PRBS seed register is continuously seeded with previous received bits.This mode results in faster locking, but bit errors are counted multiple times (often by 3x).2'd1 -> Initial seed mode w/ hysteresis. PRBS seed registers is seeded with previous received bits only till PRBS lock isacquired and then they run locally independently from the received data until the checker goes out of PRBS lock.2'd2 -> Initial seed mode w/o hysteresis. Similar to mode 1 above except once locked it stays locked until PRBS is disabled.2'd3 -> reserved for future use.
 *     PRBS_CHK_EN_AUTO_MODE PRBS Checker Enable Mode Control.1 => select (rx_dsc_lock & prbs_chk_en) as PRBS checker enable control.0 => select                prbs_chk_en  as PRBS checker enable control.
 *     PRBS_CHK_ERR_CNT_BURST_MODE PRBS Error Counter Mode.1 => Each busrt of error will be counted as 1 error in the error counter. Each error busrt must be separated by 1 error-free cycle of data which in worst case should be 39 bits.0 => Each bit error will be counted.
 *     TRNSUM_ERROR_COUNT_EN Training sum error counter Mode enable.1 => will make the PRBS error counter used as trnsum_error counter. PRBS checker can not be used during this mode.0 => PRBS checker mode.
 *     PRBS_CHK_CLK_EN_FRC_ON PRBS checker clock enable.1'b1 will enable the PRBS checker clock. Recommended to be enabled before enabling the prbs_chk_en.
 *     PRBS_CHK_BURST_ERR_CNT_EN PRBS checker clock enable.1'b1 will enable the PRBS checker clock. Recommended to be enabled before enabling the prbs_chk_en.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr (0x0000d0d1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_CFG.
 *
 */
typedef union BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_cfg[1];
	uint32_t _tlb_rx_prbs_chk_cfg;
} BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_t;

#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_CLR(r) (r).tlb_rx_prbs_chk_cfg[0] = 0
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_SET(r,d) (r).tlb_rx_prbs_chk_cfg[0] = d
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_GET(r) (r).tlb_rx_prbs_chk_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_BURST_ERR_CNT_ENf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_BURST_ERR_CNT_ENf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 11) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 5) & 0x3)
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5)) | (3 << (16 + 5))
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 1) & 0x7)
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1)) | (7 << (16 + 1))
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_GET(r) (((r).tlb_rx_prbs_chk_cfg[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_CFG.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TLB_RX_PRBS_CHK_CFGr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr,(_r._tlb_rx_prbs_chk_cfg))
#define BCMI_TSCE16_XGXS_WRITE_TLB_RX_PRBS_CHK_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr,(_r._tlb_rx_prbs_chk_cfg)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TLB_RX_PRBS_CHK_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr,(_r._tlb_rx_prbs_chk_cfg))
#define BCMI_TSCE16_XGXS_READLN_TLB_RX_PRBS_CHK_CFGr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_cfg))
#define BCMI_TSCE16_XGXS_WRITELN_TLB_RX_PRBS_CHK_CFGr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_cfg))
#define BCMI_TSCE16_XGXS_WRITEALL_TLB_RX_PRBS_CHK_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_chk_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_CFGr BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr
#define TLB_RX_PRBS_CHK_CFGr_SIZE BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_SIZE
typedef BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_t TLB_RX_PRBS_CHK_CFGr_t;
#define TLB_RX_PRBS_CHK_CFGr_CLR BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_CLR
#define TLB_RX_PRBS_CHK_CFGr_SET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_SET
#define TLB_RX_PRBS_CHK_CFGr_GET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_BURST_ERR_CNT_ENf_GET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_BURST_ERR_CNT_ENf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_BURST_ERR_CNT_ENf_SET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_BURST_ERR_CNT_ENf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_GET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_SET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_SET
#define TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_GET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_GET
#define TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_SET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_GET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_SET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_GET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_SET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_GET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_SET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_GET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_SET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_GET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_SET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_GET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_SET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_SET
#define READ_TLB_RX_PRBS_CHK_CFGr BCMI_TSCE16_XGXS_READ_TLB_RX_PRBS_CHK_CFGr
#define WRITE_TLB_RX_PRBS_CHK_CFGr BCMI_TSCE16_XGXS_WRITE_TLB_RX_PRBS_CHK_CFGr
#define MODIFY_TLB_RX_PRBS_CHK_CFGr BCMI_TSCE16_XGXS_MODIFY_TLB_RX_PRBS_CHK_CFGr
#define READLN_TLB_RX_PRBS_CHK_CFGr BCMI_TSCE16_XGXS_READLN_TLB_RX_PRBS_CHK_CFGr
#define WRITELN_TLB_RX_PRBS_CHK_CFGr BCMI_TSCE16_XGXS_WRITELN_TLB_RX_PRBS_CHK_CFGr
#define WRITEALL_TLB_RX_PRBS_CHK_CFGr BCMI_TSCE16_XGXS_WRITEALL_TLB_RX_PRBS_CHK_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TLB_RX_DIG_LPBK_CFG
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd0d2
 * DESC:     Digital Loopback Control
 * RESETVAL: 0xe (14)
 * ACCESS:   R/W
 * FIELDS:
 *     DIG_LPBK_EN      TX to RX Parallel Loopback (Digital Loopback) Enable.1 => Loopback is Enabled.0 => Loopback is Disabled.
 *     DIG_LPBK_PD_MODE Digital Loopback Phase Detector Mode. For normal operating conditions keep it at the default value of 1'b1.1'b0 - swap inc/dec. 1'b1 - normal mode.
 *     DIG_LPBK_PD_FLT_BYPASS Digital Loopback Phase Detector Filter Bypass. For repeater applications, it should be 1'b1.For other applications filter can be enabled for better jitter tolerance performance for the didgital loopback.
 *     DIG_LPBK_PD_BIAS_EN 1'b1 will enable PD inc bias mode where there will be inc generated every 16th clock cycle..1'b0 will disable the PD bias mode so inc/dec will be generated based on the PD output.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr (0x0000d0d2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_DIG_LPBK_CFG.
 *
 */
typedef union BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_rx_dig_lpbk_cfg[1];
	uint32_t _tlb_rx_dig_lpbk_cfg;
} BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr_t;

#define BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr_CLR(r) (r).tlb_rx_dig_lpbk_cfg[0] = 0
#define BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr_SET(r,d) (r).tlb_rx_dig_lpbk_cfg[0] = d
#define BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr_GET(r) (r).tlb_rx_dig_lpbk_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_BIAS_ENf_GET(r) ((((r).tlb_rx_dig_lpbk_cfg[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_BIAS_ENf_SET(r,f) (r).tlb_rx_dig_lpbk_cfg[0]=(((r).tlb_rx_dig_lpbk_cfg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_FLT_BYPASSf_GET(r) ((((r).tlb_rx_dig_lpbk_cfg[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_FLT_BYPASSf_SET(r,f) (r).tlb_rx_dig_lpbk_cfg[0]=(((r).tlb_rx_dig_lpbk_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_GET(r) ((((r).tlb_rx_dig_lpbk_cfg[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_SET(r,f) (r).tlb_rx_dig_lpbk_cfg[0]=(((r).tlb_rx_dig_lpbk_cfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_GET(r) (((r).tlb_rx_dig_lpbk_cfg[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_SET(r,f) (r).tlb_rx_dig_lpbk_cfg[0]=(((r).tlb_rx_dig_lpbk_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_DIG_LPBK_CFG.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TLB_RX_DIG_LPBK_CFGr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr,(_r._tlb_rx_dig_lpbk_cfg))
#define BCMI_TSCE16_XGXS_WRITE_TLB_RX_DIG_LPBK_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr,(_r._tlb_rx_dig_lpbk_cfg)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TLB_RX_DIG_LPBK_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr,(_r._tlb_rx_dig_lpbk_cfg))
#define BCMI_TSCE16_XGXS_READLN_TLB_RX_DIG_LPBK_CFGr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_dig_lpbk_cfg))
#define BCMI_TSCE16_XGXS_WRITELN_TLB_RX_DIG_LPBK_CFGr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_dig_lpbk_cfg))
#define BCMI_TSCE16_XGXS_WRITEALL_TLB_RX_DIG_LPBK_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_dig_lpbk_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_DIG_LPBK_CFGr BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr
#define TLB_RX_DIG_LPBK_CFGr_SIZE BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr_SIZE
typedef BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr_t TLB_RX_DIG_LPBK_CFGr_t;
#define TLB_RX_DIG_LPBK_CFGr_CLR BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr_CLR
#define TLB_RX_DIG_LPBK_CFGr_SET BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr_SET
#define TLB_RX_DIG_LPBK_CFGr_GET BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr_GET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_BIAS_ENf_GET BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_BIAS_ENf_GET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_BIAS_ENf_SET BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_BIAS_ENf_SET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_FLT_BYPASSf_GET BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_FLT_BYPASSf_GET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_FLT_BYPASSf_SET BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_FLT_BYPASSf_SET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_GET BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_GET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_SET BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_SET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_GET BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_GET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_SET BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_SET
#define READ_TLB_RX_DIG_LPBK_CFGr BCMI_TSCE16_XGXS_READ_TLB_RX_DIG_LPBK_CFGr
#define WRITE_TLB_RX_DIG_LPBK_CFGr BCMI_TSCE16_XGXS_WRITE_TLB_RX_DIG_LPBK_CFGr
#define MODIFY_TLB_RX_DIG_LPBK_CFGr BCMI_TSCE16_XGXS_MODIFY_TLB_RX_DIG_LPBK_CFGr
#define READLN_TLB_RX_DIG_LPBK_CFGr BCMI_TSCE16_XGXS_READLN_TLB_RX_DIG_LPBK_CFGr
#define WRITELN_TLB_RX_DIG_LPBK_CFGr BCMI_TSCE16_XGXS_WRITELN_TLB_RX_DIG_LPBK_CFGr
#define WRITEALL_TLB_RX_DIG_LPBK_CFGr BCMI_TSCE16_XGXS_WRITEALL_TLB_RX_DIG_LPBK_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TLB_RX_TLB_RX_MISC_CFG
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd0d3
 * DESC:     TLB RX Misc. Control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_PMD_DP_INVERT RX PMD Datapath Invert Control.When Enabled by writing to 1'b1, it will invert all the datapath bits of the logical lane.Recommended for use in case P and N pads are swapped on the PCB board.
 *     RX_AGGREGATOR_BYPASS_EN RX Aggregator Bypass EnableWhen Enabled by writing to 1'b1, DSC Data will bypass the RX Data aggregator block and sent directly to PCS along with a sync pulse which will indicate the (clk_cnt ==0).Recommended for use if low latency is desired and where data aggregation will be done in the PCS block based on the sync pulse.
 *     DBG_MASK_DIG_LPBK_EN Mask bit for dig_lpbk_en in the pmd_rx_lock equation. This is a debug register.1 => pmd_rx_lock will be forced to 1'b0 during digital loopback.0 => pmd_rx_lock will be forced to 1'b1 during digital loopback.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TLB_RX_TLB_RX_MISC_CFGr (0x0000d0d3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TLB_RX_TLB_RX_MISC_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_TLB_RX_MISC_CFG.
 *
 */
typedef union BCMI_TSCE16_XGXS_TLB_RX_TLB_RX_MISC_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_rx_tlb_rx_misc_cfg[1];
	uint32_t _tlb_rx_tlb_rx_misc_cfg;
} BCMI_TSCE16_XGXS_TLB_RX_TLB_RX_MISC_CFGr_t;

#define BCMI_TSCE16_XGXS_TLB_RX_TLB_RX_MISC_CFGr_CLR(r) (r).tlb_rx_tlb_rx_misc_cfg[0] = 0
#define BCMI_TSCE16_XGXS_TLB_RX_TLB_RX_MISC_CFGr_SET(r,d) (r).tlb_rx_tlb_rx_misc_cfg[0] = d
#define BCMI_TSCE16_XGXS_TLB_RX_TLB_RX_MISC_CFGr_GET(r) (r).tlb_rx_tlb_rx_misc_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TLB_RX_TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_GET(r) ((((r).tlb_rx_tlb_rx_misc_cfg[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_RX_TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_SET(r,f) (r).tlb_rx_tlb_rx_misc_cfg[0]=(((r).tlb_rx_tlb_rx_misc_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_TLB_RX_TLB_RX_MISC_CFGr_RX_AGGREGATOR_BYPASS_ENf_GET(r) ((((r).tlb_rx_tlb_rx_misc_cfg[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_RX_TLB_RX_MISC_CFGr_RX_AGGREGATOR_BYPASS_ENf_SET(r,f) (r).tlb_rx_tlb_rx_misc_cfg[0]=(((r).tlb_rx_tlb_rx_misc_cfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_TLB_RX_TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_GET(r) (((r).tlb_rx_tlb_rx_misc_cfg[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_RX_TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_SET(r,f) (r).tlb_rx_tlb_rx_misc_cfg[0]=(((r).tlb_rx_tlb_rx_misc_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_TLB_RX_MISC_CFG.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TLB_RX_TLB_RX_MISC_CFGr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_RX_TLB_RX_MISC_CFGr,(_r._tlb_rx_tlb_rx_misc_cfg))
#define BCMI_TSCE16_XGXS_WRITE_TLB_RX_TLB_RX_MISC_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_TLB_RX_MISC_CFGr,(_r._tlb_rx_tlb_rx_misc_cfg)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TLB_RX_TLB_RX_MISC_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_TLB_RX_MISC_CFGr,(_r._tlb_rx_tlb_rx_misc_cfg))
#define BCMI_TSCE16_XGXS_READLN_TLB_RX_TLB_RX_MISC_CFGr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_RX_TLB_RX_MISC_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_tlb_rx_misc_cfg))
#define BCMI_TSCE16_XGXS_WRITELN_TLB_RX_TLB_RX_MISC_CFGr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_TLB_RX_MISC_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_tlb_rx_misc_cfg))
#define BCMI_TSCE16_XGXS_WRITEALL_TLB_RX_TLB_RX_MISC_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_TLB_RX_MISC_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_tlb_rx_misc_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_TLB_RX_MISC_CFGr BCMI_TSCE16_XGXS_TLB_RX_TLB_RX_MISC_CFGr
#define TLB_RX_TLB_RX_MISC_CFGr_SIZE BCMI_TSCE16_XGXS_TLB_RX_TLB_RX_MISC_CFGr_SIZE
typedef BCMI_TSCE16_XGXS_TLB_RX_TLB_RX_MISC_CFGr_t TLB_RX_TLB_RX_MISC_CFGr_t;
#define TLB_RX_TLB_RX_MISC_CFGr_CLR BCMI_TSCE16_XGXS_TLB_RX_TLB_RX_MISC_CFGr_CLR
#define TLB_RX_TLB_RX_MISC_CFGr_SET BCMI_TSCE16_XGXS_TLB_RX_TLB_RX_MISC_CFGr_SET
#define TLB_RX_TLB_RX_MISC_CFGr_GET BCMI_TSCE16_XGXS_TLB_RX_TLB_RX_MISC_CFGr_GET
#define TLB_RX_TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_GET BCMI_TSCE16_XGXS_TLB_RX_TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_GET
#define TLB_RX_TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_SET BCMI_TSCE16_XGXS_TLB_RX_TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_SET
#define TLB_RX_TLB_RX_MISC_CFGr_RX_AGGREGATOR_BYPASS_ENf_GET BCMI_TSCE16_XGXS_TLB_RX_TLB_RX_MISC_CFGr_RX_AGGREGATOR_BYPASS_ENf_GET
#define TLB_RX_TLB_RX_MISC_CFGr_RX_AGGREGATOR_BYPASS_ENf_SET BCMI_TSCE16_XGXS_TLB_RX_TLB_RX_MISC_CFGr_RX_AGGREGATOR_BYPASS_ENf_SET
#define TLB_RX_TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_GET BCMI_TSCE16_XGXS_TLB_RX_TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_GET
#define TLB_RX_TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_SET BCMI_TSCE16_XGXS_TLB_RX_TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_SET
#define READ_TLB_RX_TLB_RX_MISC_CFGr BCMI_TSCE16_XGXS_READ_TLB_RX_TLB_RX_MISC_CFGr
#define WRITE_TLB_RX_TLB_RX_MISC_CFGr BCMI_TSCE16_XGXS_WRITE_TLB_RX_TLB_RX_MISC_CFGr
#define MODIFY_TLB_RX_TLB_RX_MISC_CFGr BCMI_TSCE16_XGXS_MODIFY_TLB_RX_TLB_RX_MISC_CFGr
#define READLN_TLB_RX_TLB_RX_MISC_CFGr BCMI_TSCE16_XGXS_READLN_TLB_RX_TLB_RX_MISC_CFGr
#define WRITELN_TLB_RX_TLB_RX_MISC_CFGr BCMI_TSCE16_XGXS_WRITELN_TLB_RX_TLB_RX_MISC_CFGr
#define WRITEALL_TLB_RX_TLB_RX_MISC_CFGr BCMI_TSCE16_XGXS_WRITEALL_TLB_RX_TLB_RX_MISC_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TLB_RX_TLB_RX_MISC_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TLB_RX_PRBS_CHK_EN_TMR_CTL
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd0d4
 * DESC:     TLB RX PRBS Checker Enable Timer Control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PRBS_CHK_EN_TIMER_MODE prbs_chk_en timer mode.2'b0x => prbs_chk_en timer is disabled and PRBS checker mode is enabled as per prbs_chk_en register.2'b10 => use heartbeat_toggle_1us for the timer.2'b11 => use heartbeat_toggle_1ms for the timer.
 *     PRBS_CHK_EN_TIMEOUT PRBS timer timeout value.Valid range 0 to 31 which maps to 0 to 448. Should be programmed before enabling the PRBS checker in timer mode.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr (0x0000d0d4 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_EN_TMR_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_en_tmr_ctl[1];
	uint32_t _tlb_rx_prbs_chk_en_tmr_ctl;
} BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_t;

#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_CLR(r) (r).tlb_rx_prbs_chk_en_tmr_ctl[0] = 0
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_SET(r,d) (r).tlb_rx_prbs_chk_en_tmr_ctl[0] = d
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_GET(r) (r).tlb_rx_prbs_chk_en_tmr_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_GET(r) ((((r).tlb_rx_prbs_chk_en_tmr_ctl[0]) >> 8) & 0x1f)
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_SET(r,f) (r).tlb_rx_prbs_chk_en_tmr_ctl[0]=(((r).tlb_rx_prbs_chk_en_tmr_ctl[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_GET(r) (((r).tlb_rx_prbs_chk_en_tmr_ctl[0]) & 0x3)
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_SET(r,f) (r).tlb_rx_prbs_chk_en_tmr_ctl[0]=(((r).tlb_rx_prbs_chk_en_tmr_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_EN_TMR_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TLB_RX_PRBS_CHK_EN_TMR_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr,(_r._tlb_rx_prbs_chk_en_tmr_ctl))
#define BCMI_TSCE16_XGXS_WRITE_TLB_RX_PRBS_CHK_EN_TMR_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr,(_r._tlb_rx_prbs_chk_en_tmr_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TLB_RX_PRBS_CHK_EN_TMR_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr,(_r._tlb_rx_prbs_chk_en_tmr_ctl))
#define BCMI_TSCE16_XGXS_READLN_TLB_RX_PRBS_CHK_EN_TMR_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_en_tmr_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_TLB_RX_PRBS_CHK_EN_TMR_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_en_tmr_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_TLB_RX_PRBS_CHK_EN_TMR_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_chk_en_tmr_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_SIZE BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_t TLB_RX_PRBS_CHK_EN_TMR_CTLr_t;
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_CLR BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_CLR
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_SET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_SET
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_GET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_GET
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_GET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_GET
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_SET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_SET
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_GET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_GET
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_SET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_SET
#define READ_TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_TSCE16_XGXS_READ_TLB_RX_PRBS_CHK_EN_TMR_CTLr
#define WRITE_TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_TSCE16_XGXS_WRITE_TLB_RX_PRBS_CHK_EN_TMR_CTLr
#define MODIFY_TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_TSCE16_XGXS_MODIFY_TLB_RX_PRBS_CHK_EN_TMR_CTLr
#define READLN_TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_TSCE16_XGXS_READLN_TLB_RX_PRBS_CHK_EN_TMR_CTLr
#define WRITELN_TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_TSCE16_XGXS_WRITELN_TLB_RX_PRBS_CHK_EN_TMR_CTLr
#define WRITEALL_TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_TSCE16_XGXS_WRITEALL_TLB_RX_PRBS_CHK_EN_TMR_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TLB_RX_PRBS_CHK_BURST_ERR_CNT_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd0d5
 * DESC:     PRBS Checker Burst Error Counter Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PRBS_CHK_BURST_ERR_CNT PRBS Checker Burst Error Counter Status Register. It is a clear on read register. This register countsthe number of Burst in errors separated by atleast 1 clock cycle worth of data without any bit in error.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr (0x0000d0d5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_BURST_ERR_CNT_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_burst_err_cnt_sts[1];
	uint32_t _tlb_rx_prbs_chk_burst_err_cnt_sts;
} BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_t;

#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_CLR(r) (r).tlb_rx_prbs_chk_burst_err_cnt_sts[0] = 0
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_SET(r,d) (r).tlb_rx_prbs_chk_burst_err_cnt_sts[0] = d
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_GET(r) (r).tlb_rx_prbs_chk_burst_err_cnt_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_PRBS_CHK_BURST_ERR_CNTf_GET(r) (((r).tlb_rx_prbs_chk_burst_err_cnt_sts[0]) & 0x3ff)
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_PRBS_CHK_BURST_ERR_CNTf_SET(r,f) (r).tlb_rx_prbs_chk_burst_err_cnt_sts[0]=(((r).tlb_rx_prbs_chk_burst_err_cnt_sts[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_BURST_ERR_CNT_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr,(_r._tlb_rx_prbs_chk_burst_err_cnt_sts))
#define BCMI_TSCE16_XGXS_WRITE_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr,(_r._tlb_rx_prbs_chk_burst_err_cnt_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr,(_r._tlb_rx_prbs_chk_burst_err_cnt_sts))
#define BCMI_TSCE16_XGXS_READLN_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_burst_err_cnt_sts))
#define BCMI_TSCE16_XGXS_WRITELN_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_burst_err_cnt_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_chk_burst_err_cnt_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr
#define TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_SIZE BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_SIZE
typedef BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_t TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_t;
#define TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_CLR BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_CLR
#define TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_SET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_SET
#define TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_GET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_GET
#define TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_PRBS_CHK_BURST_ERR_CNTf_GET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_PRBS_CHK_BURST_ERR_CNTf_GET
#define TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_PRBS_CHK_BURST_ERR_CNTf_SET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_PRBS_CHK_BURST_ERR_CNTf_SET
#define READ_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr BCMI_TSCE16_XGXS_READ_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr
#define WRITE_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr BCMI_TSCE16_XGXS_WRITE_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr
#define MODIFY_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr BCMI_TSCE16_XGXS_MODIFY_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr
#define READLN_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr BCMI_TSCE16_XGXS_READLN_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr
#define WRITELN_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr BCMI_TSCE16_XGXS_WRITELN_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr
#define WRITEALL_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr BCMI_TSCE16_XGXS_WRITEALL_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TLB_RX_DBG_PMD_RX_LOCK_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd0d6
 * DESC:     Debug PMD RX LOCK Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DBG_PMD_RX_LOCK  Debug PMD RX LOCK Indication. This is a live indication of the status of the pmd_rx_lock output port.1 => PMD is in LOCKED state and RX PCS data should have acceptable BER.0 => PMD is not LOCKED yet.
 *     DBG_PMD_RX_LOCK_CHANGE Set to 1'b1 when change/transition on PMD RX LOCK. This is a sticky bit and cleared upon read. This is a debug register.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr (0x0000d0d6 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_DBG_PMD_RX_LOCK_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_dbg_pmd_rx_lock_sts[1];
	uint32_t _tlb_rx_dbg_pmd_rx_lock_sts;
} BCMI_TSCE16_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_t;

#define BCMI_TSCE16_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_CLR(r) (r).tlb_rx_dbg_pmd_rx_lock_sts[0] = 0
#define BCMI_TSCE16_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_SET(r,d) (r).tlb_rx_dbg_pmd_rx_lock_sts[0] = d
#define BCMI_TSCE16_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_GET(r) (r).tlb_rx_dbg_pmd_rx_lock_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCK_CHANGEf_GET(r) ((((r).tlb_rx_dbg_pmd_rx_lock_sts[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCK_CHANGEf_SET(r,f) (r).tlb_rx_dbg_pmd_rx_lock_sts[0]=(((r).tlb_rx_dbg_pmd_rx_lock_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCKf_GET(r) (((r).tlb_rx_dbg_pmd_rx_lock_sts[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCKf_SET(r,f) (r).tlb_rx_dbg_pmd_rx_lock_sts[0]=(((r).tlb_rx_dbg_pmd_rx_lock_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_DBG_PMD_RX_LOCK_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TLB_RX_DBG_PMD_RX_LOCK_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr,(_r._tlb_rx_dbg_pmd_rx_lock_sts))
#define BCMI_TSCE16_XGXS_WRITE_TLB_RX_DBG_PMD_RX_LOCK_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr,(_r._tlb_rx_dbg_pmd_rx_lock_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TLB_RX_DBG_PMD_RX_LOCK_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr,(_r._tlb_rx_dbg_pmd_rx_lock_sts))
#define BCMI_TSCE16_XGXS_READLN_TLB_RX_DBG_PMD_RX_LOCK_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_dbg_pmd_rx_lock_sts))
#define BCMI_TSCE16_XGXS_WRITELN_TLB_RX_DBG_PMD_RX_LOCK_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_dbg_pmd_rx_lock_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_TLB_RX_DBG_PMD_RX_LOCK_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_dbg_pmd_rx_lock_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_DBG_PMD_RX_LOCK_STSr BCMI_TSCE16_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr
#define TLB_RX_DBG_PMD_RX_LOCK_STSr_SIZE BCMI_TSCE16_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_SIZE
typedef BCMI_TSCE16_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_t TLB_RX_DBG_PMD_RX_LOCK_STSr_t;
#define TLB_RX_DBG_PMD_RX_LOCK_STSr_CLR BCMI_TSCE16_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_CLR
#define TLB_RX_DBG_PMD_RX_LOCK_STSr_SET BCMI_TSCE16_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_SET
#define TLB_RX_DBG_PMD_RX_LOCK_STSr_GET BCMI_TSCE16_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_GET
#define TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCK_CHANGEf_GET BCMI_TSCE16_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCK_CHANGEf_GET
#define TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCK_CHANGEf_SET BCMI_TSCE16_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCK_CHANGEf_SET
#define TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCKf_GET BCMI_TSCE16_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCKf_GET
#define TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCKf_SET BCMI_TSCE16_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCKf_SET
#define READ_TLB_RX_DBG_PMD_RX_LOCK_STSr BCMI_TSCE16_XGXS_READ_TLB_RX_DBG_PMD_RX_LOCK_STSr
#define WRITE_TLB_RX_DBG_PMD_RX_LOCK_STSr BCMI_TSCE16_XGXS_WRITE_TLB_RX_DBG_PMD_RX_LOCK_STSr
#define MODIFY_TLB_RX_DBG_PMD_RX_LOCK_STSr BCMI_TSCE16_XGXS_MODIFY_TLB_RX_DBG_PMD_RX_LOCK_STSr
#define READLN_TLB_RX_DBG_PMD_RX_LOCK_STSr BCMI_TSCE16_XGXS_READLN_TLB_RX_DBG_PMD_RX_LOCK_STSr
#define WRITELN_TLB_RX_DBG_PMD_RX_LOCK_STSr BCMI_TSCE16_XGXS_WRITELN_TLB_RX_DBG_PMD_RX_LOCK_STSr
#define WRITEALL_TLB_RX_DBG_PMD_RX_LOCK_STSr BCMI_TSCE16_XGXS_WRITEALL_TLB_RX_DBG_PMD_RX_LOCK_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TLB_RX_UC_PMD_RX_LOCK_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd0d7
 * DESC:     Debug PMD RX LOCK Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     UC_PMD_RX_LOCK   Debug PMD RX LOCK Indication. This is a live indication of the status of the pmd_rx_lock output port.1 => PMD is in LOCKED state and RX PCS data should have acceptable BER.0 => PMD is not LOCKED yet.
 *     UC_PMD_RX_LOCK_CHANGE Set to 1'b1 when change/transition on PMD RX LOCK. This is a sticky bit and cleared upon read. This is a debug register.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr (0x0000d0d7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_UC_PMD_RX_LOCK_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_uc_pmd_rx_lock_sts[1];
	uint32_t _tlb_rx_uc_pmd_rx_lock_sts;
} BCMI_TSCE16_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_t;

#define BCMI_TSCE16_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_CLR(r) (r).tlb_rx_uc_pmd_rx_lock_sts[0] = 0
#define BCMI_TSCE16_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_SET(r,d) (r).tlb_rx_uc_pmd_rx_lock_sts[0] = d
#define BCMI_TSCE16_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_GET(r) (r).tlb_rx_uc_pmd_rx_lock_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCK_CHANGEf_GET(r) ((((r).tlb_rx_uc_pmd_rx_lock_sts[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCK_CHANGEf_SET(r,f) (r).tlb_rx_uc_pmd_rx_lock_sts[0]=(((r).tlb_rx_uc_pmd_rx_lock_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCKf_GET(r) (((r).tlb_rx_uc_pmd_rx_lock_sts[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCKf_SET(r,f) (r).tlb_rx_uc_pmd_rx_lock_sts[0]=(((r).tlb_rx_uc_pmd_rx_lock_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_UC_PMD_RX_LOCK_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TLB_RX_UC_PMD_RX_LOCK_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr,(_r._tlb_rx_uc_pmd_rx_lock_sts))
#define BCMI_TSCE16_XGXS_WRITE_TLB_RX_UC_PMD_RX_LOCK_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr,(_r._tlb_rx_uc_pmd_rx_lock_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TLB_RX_UC_PMD_RX_LOCK_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr,(_r._tlb_rx_uc_pmd_rx_lock_sts))
#define BCMI_TSCE16_XGXS_READLN_TLB_RX_UC_PMD_RX_LOCK_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_uc_pmd_rx_lock_sts))
#define BCMI_TSCE16_XGXS_WRITELN_TLB_RX_UC_PMD_RX_LOCK_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_uc_pmd_rx_lock_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_TLB_RX_UC_PMD_RX_LOCK_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_uc_pmd_rx_lock_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_UC_PMD_RX_LOCK_STSr BCMI_TSCE16_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr
#define TLB_RX_UC_PMD_RX_LOCK_STSr_SIZE BCMI_TSCE16_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_SIZE
typedef BCMI_TSCE16_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_t TLB_RX_UC_PMD_RX_LOCK_STSr_t;
#define TLB_RX_UC_PMD_RX_LOCK_STSr_CLR BCMI_TSCE16_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_CLR
#define TLB_RX_UC_PMD_RX_LOCK_STSr_SET BCMI_TSCE16_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_SET
#define TLB_RX_UC_PMD_RX_LOCK_STSr_GET BCMI_TSCE16_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_GET
#define TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCK_CHANGEf_GET BCMI_TSCE16_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCK_CHANGEf_GET
#define TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCK_CHANGEf_SET BCMI_TSCE16_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCK_CHANGEf_SET
#define TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCKf_GET BCMI_TSCE16_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCKf_GET
#define TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCKf_SET BCMI_TSCE16_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCKf_SET
#define READ_TLB_RX_UC_PMD_RX_LOCK_STSr BCMI_TSCE16_XGXS_READ_TLB_RX_UC_PMD_RX_LOCK_STSr
#define WRITE_TLB_RX_UC_PMD_RX_LOCK_STSr BCMI_TSCE16_XGXS_WRITE_TLB_RX_UC_PMD_RX_LOCK_STSr
#define MODIFY_TLB_RX_UC_PMD_RX_LOCK_STSr BCMI_TSCE16_XGXS_MODIFY_TLB_RX_UC_PMD_RX_LOCK_STSr
#define READLN_TLB_RX_UC_PMD_RX_LOCK_STSr BCMI_TSCE16_XGXS_READLN_TLB_RX_UC_PMD_RX_LOCK_STSr
#define WRITELN_TLB_RX_UC_PMD_RX_LOCK_STSr BCMI_TSCE16_XGXS_WRITELN_TLB_RX_UC_PMD_RX_LOCK_STSr
#define WRITEALL_TLB_RX_UC_PMD_RX_LOCK_STSr BCMI_TSCE16_XGXS_WRITEALL_TLB_RX_UC_PMD_RX_LOCK_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TLB_RX_DIG_LPBK_PD_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd0d8
 * DESC:     Digital Loopback Status
 * RESETVAL: 0x2 (2)
 * ACCESS:   R/O
 * FIELDS:
 *     DIG_LPBK_PD_LATE_IND 1 means dp_rclk20 is sampling data late so reduce the delay of the dp_rclk20 clock phase. This will result in RX PI phase step decrement.
 *     DIG_LPBK_PD_EARLY_IND 1 means dp_rclk20 is sampling data earlier so delay the dp_rclk20 clock phase. This will result in RX PI phase step increment.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_PD_STSr (0x0000d0d8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_PD_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_DIG_LPBK_PD_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_PD_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_dig_lpbk_pd_sts[1];
	uint32_t _tlb_rx_dig_lpbk_pd_sts;
} BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_PD_STSr_t;

#define BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_PD_STSr_CLR(r) (r).tlb_rx_dig_lpbk_pd_sts[0] = 0
#define BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_PD_STSr_SET(r,d) (r).tlb_rx_dig_lpbk_pd_sts[0] = d
#define BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_PD_STSr_GET(r) (r).tlb_rx_dig_lpbk_pd_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_GET(r) ((((r).tlb_rx_dig_lpbk_pd_sts[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_SET(r,f) (r).tlb_rx_dig_lpbk_pd_sts[0]=(((r).tlb_rx_dig_lpbk_pd_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_GET(r) (((r).tlb_rx_dig_lpbk_pd_sts[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_SET(r,f) (r).tlb_rx_dig_lpbk_pd_sts[0]=(((r).tlb_rx_dig_lpbk_pd_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_DIG_LPBK_PD_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TLB_RX_DIG_LPBK_PD_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_PD_STSr,(_r._tlb_rx_dig_lpbk_pd_sts))
#define BCMI_TSCE16_XGXS_WRITE_TLB_RX_DIG_LPBK_PD_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_PD_STSr,(_r._tlb_rx_dig_lpbk_pd_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TLB_RX_DIG_LPBK_PD_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_PD_STSr,(_r._tlb_rx_dig_lpbk_pd_sts))
#define BCMI_TSCE16_XGXS_READLN_TLB_RX_DIG_LPBK_PD_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_PD_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_dig_lpbk_pd_sts))
#define BCMI_TSCE16_XGXS_WRITELN_TLB_RX_DIG_LPBK_PD_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_PD_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_dig_lpbk_pd_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_TLB_RX_DIG_LPBK_PD_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_PD_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_dig_lpbk_pd_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_DIG_LPBK_PD_STSr BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_PD_STSr
#define TLB_RX_DIG_LPBK_PD_STSr_SIZE BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_PD_STSr_SIZE
typedef BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_PD_STSr_t TLB_RX_DIG_LPBK_PD_STSr_t;
#define TLB_RX_DIG_LPBK_PD_STSr_CLR BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_PD_STSr_CLR
#define TLB_RX_DIG_LPBK_PD_STSr_SET BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_PD_STSr_SET
#define TLB_RX_DIG_LPBK_PD_STSr_GET BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_PD_STSr_GET
#define TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_GET BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_GET
#define TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_SET BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_SET
#define TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_GET BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_GET
#define TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_SET BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_SET
#define READ_TLB_RX_DIG_LPBK_PD_STSr BCMI_TSCE16_XGXS_READ_TLB_RX_DIG_LPBK_PD_STSr
#define WRITE_TLB_RX_DIG_LPBK_PD_STSr BCMI_TSCE16_XGXS_WRITE_TLB_RX_DIG_LPBK_PD_STSr
#define MODIFY_TLB_RX_DIG_LPBK_PD_STSr BCMI_TSCE16_XGXS_MODIFY_TLB_RX_DIG_LPBK_PD_STSr
#define READLN_TLB_RX_DIG_LPBK_PD_STSr BCMI_TSCE16_XGXS_READLN_TLB_RX_DIG_LPBK_PD_STSr
#define WRITELN_TLB_RX_DIG_LPBK_PD_STSr BCMI_TSCE16_XGXS_WRITELN_TLB_RX_DIG_LPBK_PD_STSr
#define WRITEALL_TLB_RX_DIG_LPBK_PD_STSr BCMI_TSCE16_XGXS_WRITEALL_TLB_RX_DIG_LPBK_PD_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TLB_RX_DIG_LPBK_PD_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TLB_RX_PRBS_CHK_LOCK_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd0d9
 * DESC:     PRBS Checker LOCK Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PRBS_CHK_LOCK    PRBS Checker LOCK Indication. This is a live indication of the status of the PRBS Checker state machine.1 => PRBS Checker is in LOCKED state.0 => PRBS Checker is out of LOCK state and state machine is searching for a LOCK.
 *     PRBS_CHK_ERR_CNT_NO_CLR PRBS Checker Error Counter which does not get cleared upon read.MSB bit 14 is OR of the MSB bits [30:14] of the internal error counter.LSB bits [13:0] are assigned to LSB bits [13:0] of the internal error counter.It can be cleared by reading the status register prbs_chk_err_cnt_msb.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr (0x0000d0d9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_LOCK_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_lock_sts[1];
	uint32_t _tlb_rx_prbs_chk_lock_sts;
} BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_t;

#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_CLR(r) (r).tlb_rx_prbs_chk_lock_sts[0] = 0
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_SET(r,d) (r).tlb_rx_prbs_chk_lock_sts[0] = d
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_GET(r) (r).tlb_rx_prbs_chk_lock_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_ERR_CNT_NO_CLRf_GET(r) ((((r).tlb_rx_prbs_chk_lock_sts[0]) >> 1) & 0x7fff)
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_ERR_CNT_NO_CLRf_SET(r,f) (r).tlb_rx_prbs_chk_lock_sts[0]=(((r).tlb_rx_prbs_chk_lock_sts[0] & ~((uint32_t)0x7fff << 1)) | ((((uint32_t)f) & 0x7fff) << 1)) | (32767 << (16 + 1))
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_GET(r) (((r).tlb_rx_prbs_chk_lock_sts[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_SET(r,f) (r).tlb_rx_prbs_chk_lock_sts[0]=(((r).tlb_rx_prbs_chk_lock_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_LOCK_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TLB_RX_PRBS_CHK_LOCK_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr,(_r._tlb_rx_prbs_chk_lock_sts))
#define BCMI_TSCE16_XGXS_WRITE_TLB_RX_PRBS_CHK_LOCK_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr,(_r._tlb_rx_prbs_chk_lock_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TLB_RX_PRBS_CHK_LOCK_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr,(_r._tlb_rx_prbs_chk_lock_sts))
#define BCMI_TSCE16_XGXS_READLN_TLB_RX_PRBS_CHK_LOCK_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_lock_sts))
#define BCMI_TSCE16_XGXS_WRITELN_TLB_RX_PRBS_CHK_LOCK_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_lock_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_TLB_RX_PRBS_CHK_LOCK_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_chk_lock_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_LOCK_STSr BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr
#define TLB_RX_PRBS_CHK_LOCK_STSr_SIZE BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_SIZE
typedef BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_t TLB_RX_PRBS_CHK_LOCK_STSr_t;
#define TLB_RX_PRBS_CHK_LOCK_STSr_CLR BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_CLR
#define TLB_RX_PRBS_CHK_LOCK_STSr_SET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_SET
#define TLB_RX_PRBS_CHK_LOCK_STSr_GET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_GET
#define TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_ERR_CNT_NO_CLRf_GET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_ERR_CNT_NO_CLRf_GET
#define TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_ERR_CNT_NO_CLRf_SET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_ERR_CNT_NO_CLRf_SET
#define TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_GET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_GET
#define TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_SET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_SET
#define READ_TLB_RX_PRBS_CHK_LOCK_STSr BCMI_TSCE16_XGXS_READ_TLB_RX_PRBS_CHK_LOCK_STSr
#define WRITE_TLB_RX_PRBS_CHK_LOCK_STSr BCMI_TSCE16_XGXS_WRITE_TLB_RX_PRBS_CHK_LOCK_STSr
#define MODIFY_TLB_RX_PRBS_CHK_LOCK_STSr BCMI_TSCE16_XGXS_MODIFY_TLB_RX_PRBS_CHK_LOCK_STSr
#define READLN_TLB_RX_PRBS_CHK_LOCK_STSr BCMI_TSCE16_XGXS_READLN_TLB_RX_PRBS_CHK_LOCK_STSr
#define WRITELN_TLB_RX_PRBS_CHK_LOCK_STSr BCMI_TSCE16_XGXS_WRITELN_TLB_RX_PRBS_CHK_LOCK_STSr
#define WRITEALL_TLB_RX_PRBS_CHK_LOCK_STSr BCMI_TSCE16_XGXS_WRITEALL_TLB_RX_PRBS_CHK_LOCK_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TLB_RX_PRBS_CHK_ERR_CNT_MSB_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd0da
 * DESC:     PRBS Checker Error Counter MSB Status
 * RESETVAL: 0x8000 (32768)
 * ACCESS:   R/O
 * FIELDS:
 *     PRBS_CHK_ERR_CNT_MSB 15 bits MSB portion of PRBS Checker Error Counter Status Register. It is a clear on read register.Once MSB bits [30:16] of the counter are read then LSB bits [15:0] of the error counter is loadedinto a holding register and internal PRBS error counter's all bits are cleared to 0s(or if there are any error in that particular clock cycle then that will be loaded).MSB portion must be read first before reading the LSB portion of the error counter.
 *     PRBS_CHK_LOCK_LOST_LH PRBS Checker LOCK_LOST Latch High Indication. This register captures the 1->0 transition on theprbs_chk_lock live status register and keep it latched until read. This is a clear on read status registers.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr (0x0000d0da | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_ERR_CNT_MSB_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_err_cnt_msb_sts[1];
	uint32_t _tlb_rx_prbs_chk_err_cnt_msb_sts;
} BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_t;

#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_CLR(r) (r).tlb_rx_prbs_chk_err_cnt_msb_sts[0] = 0
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SET(r,d) (r).tlb_rx_prbs_chk_err_cnt_msb_sts[0] = d
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_GET(r) (r).tlb_rx_prbs_chk_err_cnt_msb_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_GET(r) ((((r).tlb_rx_prbs_chk_err_cnt_msb_sts[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_SET(r,f) (r).tlb_rx_prbs_chk_err_cnt_msb_sts[0]=(((r).tlb_rx_prbs_chk_err_cnt_msb_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_GET(r) (((r).tlb_rx_prbs_chk_err_cnt_msb_sts[0]) & 0x7fff)
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_SET(r,f) (r).tlb_rx_prbs_chk_err_cnt_msb_sts[0]=(((r).tlb_rx_prbs_chk_err_cnt_msb_sts[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff)) | (0x7fff << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_ERR_CNT_MSB_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr,(_r._tlb_rx_prbs_chk_err_cnt_msb_sts))
#define BCMI_TSCE16_XGXS_WRITE_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr,(_r._tlb_rx_prbs_chk_err_cnt_msb_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr,(_r._tlb_rx_prbs_chk_err_cnt_msb_sts))
#define BCMI_TSCE16_XGXS_READLN_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_err_cnt_msb_sts))
#define BCMI_TSCE16_XGXS_WRITELN_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_err_cnt_msb_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_chk_err_cnt_msb_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SIZE BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SIZE
typedef BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_t TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_t;
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_CLR BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_CLR
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SET
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_GET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_GET
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_GET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_GET
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_SET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_SET
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_GET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_GET
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_SET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_SET
#define READ_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_TSCE16_XGXS_READ_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr
#define WRITE_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_TSCE16_XGXS_WRITE_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr
#define MODIFY_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_TSCE16_XGXS_MODIFY_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr
#define READLN_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_TSCE16_XGXS_READLN_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr
#define WRITELN_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_TSCE16_XGXS_WRITELN_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr
#define WRITEALL_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_TSCE16_XGXS_WRITEALL_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TLB_RX_PRBS_CHK_ERR_CNT_LSB_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd0db
 * DESC:     PRBS Checker Error Counter LSB Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PRBS_CHK_ERR_CNT_LSB 16 bits LSB portion of PRBS Checker Error Counter Status Register. This register indicatesthe value in the holding register when MSB portion [30:16] of the error counter are read.MSB portion must be read first before reading the LSB portion of the error counter.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr (0x0000d0db | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_ERR_CNT_LSB_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_err_cnt_lsb_sts[1];
	uint32_t _tlb_rx_prbs_chk_err_cnt_lsb_sts;
} BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_t;

#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_CLR(r) (r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0] = 0
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SET(r,d) (r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0] = d
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_GET(r) (r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_GET(r) (((r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_SET(r,f) (r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0]=(((r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_ERR_CNT_LSB_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr,(_r._tlb_rx_prbs_chk_err_cnt_lsb_sts))
#define BCMI_TSCE16_XGXS_WRITE_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr,(_r._tlb_rx_prbs_chk_err_cnt_lsb_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr,(_r._tlb_rx_prbs_chk_err_cnt_lsb_sts))
#define BCMI_TSCE16_XGXS_READLN_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_err_cnt_lsb_sts))
#define BCMI_TSCE16_XGXS_WRITELN_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_err_cnt_lsb_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_chk_err_cnt_lsb_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SIZE BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SIZE
typedef BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_t TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_t;
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_CLR BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_CLR
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SET
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_GET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_GET
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_GET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_GET
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_SET BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_SET
#define READ_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_TSCE16_XGXS_READ_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr
#define WRITE_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_TSCE16_XGXS_WRITE_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr
#define MODIFY_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_TSCE16_XGXS_MODIFY_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr
#define READLN_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_TSCE16_XGXS_READLN_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr
#define WRITELN_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_TSCE16_XGXS_WRITELN_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr
#define WRITEALL_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_TSCE16_XGXS_WRITEALL_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TLB_RX_PMD_RX_LOCK_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd0dc
 * DESC:     PMD RX LOCK Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PMD_RX_LOCK      PMD RX LOCK Indication. This is a live indication of the status of the pmd_rx_lock output port.1 => PMD is in LOCKED state and RX PCS data should have acceptable BER.0 => PMD is not LOCKED yet.
 *     PMD_RX_LOCK_CHANGE Set to 1'b1 when change/transition on PMD RX LOCK. This is a sticky bit and cleared upon read.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TLB_RX_PMD_RX_LOCK_STSr (0x0000d0dc | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TLB_RX_PMD_RX_LOCK_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PMD_RX_LOCK_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_TLB_RX_PMD_RX_LOCK_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_pmd_rx_lock_sts[1];
	uint32_t _tlb_rx_pmd_rx_lock_sts;
} BCMI_TSCE16_XGXS_TLB_RX_PMD_RX_LOCK_STSr_t;

#define BCMI_TSCE16_XGXS_TLB_RX_PMD_RX_LOCK_STSr_CLR(r) (r).tlb_rx_pmd_rx_lock_sts[0] = 0
#define BCMI_TSCE16_XGXS_TLB_RX_PMD_RX_LOCK_STSr_SET(r,d) (r).tlb_rx_pmd_rx_lock_sts[0] = d
#define BCMI_TSCE16_XGXS_TLB_RX_PMD_RX_LOCK_STSr_GET(r) (r).tlb_rx_pmd_rx_lock_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_GET(r) ((((r).tlb_rx_pmd_rx_lock_sts[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_SET(r,f) (r).tlb_rx_pmd_rx_lock_sts[0]=(((r).tlb_rx_pmd_rx_lock_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_GET(r) (((r).tlb_rx_pmd_rx_lock_sts[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_SET(r,f) (r).tlb_rx_pmd_rx_lock_sts[0]=(((r).tlb_rx_pmd_rx_lock_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_PMD_RX_LOCK_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TLB_RX_PMD_RX_LOCK_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_RX_PMD_RX_LOCK_STSr,(_r._tlb_rx_pmd_rx_lock_sts))
#define BCMI_TSCE16_XGXS_WRITE_TLB_RX_PMD_RX_LOCK_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_PMD_RX_LOCK_STSr,(_r._tlb_rx_pmd_rx_lock_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TLB_RX_PMD_RX_LOCK_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_PMD_RX_LOCK_STSr,(_r._tlb_rx_pmd_rx_lock_sts))
#define BCMI_TSCE16_XGXS_READLN_TLB_RX_PMD_RX_LOCK_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_RX_PMD_RX_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_pmd_rx_lock_sts))
#define BCMI_TSCE16_XGXS_WRITELN_TLB_RX_PMD_RX_LOCK_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_PMD_RX_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_pmd_rx_lock_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_TLB_RX_PMD_RX_LOCK_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_RX_PMD_RX_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_pmd_rx_lock_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PMD_RX_LOCK_STSr BCMI_TSCE16_XGXS_TLB_RX_PMD_RX_LOCK_STSr
#define TLB_RX_PMD_RX_LOCK_STSr_SIZE BCMI_TSCE16_XGXS_TLB_RX_PMD_RX_LOCK_STSr_SIZE
typedef BCMI_TSCE16_XGXS_TLB_RX_PMD_RX_LOCK_STSr_t TLB_RX_PMD_RX_LOCK_STSr_t;
#define TLB_RX_PMD_RX_LOCK_STSr_CLR BCMI_TSCE16_XGXS_TLB_RX_PMD_RX_LOCK_STSr_CLR
#define TLB_RX_PMD_RX_LOCK_STSr_SET BCMI_TSCE16_XGXS_TLB_RX_PMD_RX_LOCK_STSr_SET
#define TLB_RX_PMD_RX_LOCK_STSr_GET BCMI_TSCE16_XGXS_TLB_RX_PMD_RX_LOCK_STSr_GET
#define TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_GET BCMI_TSCE16_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_GET
#define TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_SET BCMI_TSCE16_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_SET
#define TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_GET BCMI_TSCE16_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_GET
#define TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_SET BCMI_TSCE16_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_SET
#define READ_TLB_RX_PMD_RX_LOCK_STSr BCMI_TSCE16_XGXS_READ_TLB_RX_PMD_RX_LOCK_STSr
#define WRITE_TLB_RX_PMD_RX_LOCK_STSr BCMI_TSCE16_XGXS_WRITE_TLB_RX_PMD_RX_LOCK_STSr
#define MODIFY_TLB_RX_PMD_RX_LOCK_STSr BCMI_TSCE16_XGXS_MODIFY_TLB_RX_PMD_RX_LOCK_STSr
#define READLN_TLB_RX_PMD_RX_LOCK_STSr BCMI_TSCE16_XGXS_READLN_TLB_RX_PMD_RX_LOCK_STSr
#define WRITELN_TLB_RX_PMD_RX_LOCK_STSr BCMI_TSCE16_XGXS_WRITELN_TLB_RX_PMD_RX_LOCK_STSr
#define WRITEALL_TLB_RX_PMD_RX_LOCK_STSr BCMI_TSCE16_XGXS_WRITEALL_TLB_RX_PMD_RX_LOCK_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TLB_RX_PMD_RX_LOCK_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TLB_TX_PATT_GEN_CFG
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd0e0
 * DESC:     Pattern Generator Control
 * RESETVAL: 0xb000 (45056)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_EN      Fixed pattern generator enable.1 => enable  the fixed pattern generator.0 => disable the fixed pattern generator.
 *     PATT_GEN_STOP_POS Valid values are 11 to 0. Defines the stop  position of the pattern in 20 bit chunks.This register value should be less than or equal to rg_patt_gen_start_pos.11 means stop at bit  220,10 means stop at bit  200, ...,0 means stop at bit    0so stop  bit is (rg_patt_gen_stop_pos*20).
 *     PATT_GEN_START_POS Valid values are 11 to 0. Defines the start position of the pattern in 20 bit chunks.11 means start at bit 239,10 means start at bit 219, ...,0 means start at bit  19so start bit is (rg_patt_gen_start_pos*20 + 19).
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TLB_TX_PATT_GEN_CFGr (0x0000d0e0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TLB_TX_PATT_GEN_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_PATT_GEN_CFG.
 *
 */
typedef union BCMI_TSCE16_XGXS_TLB_TX_PATT_GEN_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_tx_patt_gen_cfg[1];
	uint32_t _tlb_tx_patt_gen_cfg;
} BCMI_TSCE16_XGXS_TLB_TX_PATT_GEN_CFGr_t;

#define BCMI_TSCE16_XGXS_TLB_TX_PATT_GEN_CFGr_CLR(r) (r).tlb_tx_patt_gen_cfg[0] = 0
#define BCMI_TSCE16_XGXS_TLB_TX_PATT_GEN_CFGr_SET(r,d) (r).tlb_tx_patt_gen_cfg[0] = d
#define BCMI_TSCE16_XGXS_TLB_TX_PATT_GEN_CFGr_GET(r) (r).tlb_tx_patt_gen_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TLB_TX_PATT_GEN_CFGr_PATT_GEN_START_POSf_GET(r) ((((r).tlb_tx_patt_gen_cfg[0]) >> 12) & 0xf)
#define BCMI_TSCE16_XGXS_TLB_TX_PATT_GEN_CFGr_PATT_GEN_START_POSf_SET(r,f) (r).tlb_tx_patt_gen_cfg[0]=(((r).tlb_tx_patt_gen_cfg[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCE16_XGXS_TLB_TX_PATT_GEN_CFGr_PATT_GEN_STOP_POSf_GET(r) ((((r).tlb_tx_patt_gen_cfg[0]) >> 8) & 0xf)
#define BCMI_TSCE16_XGXS_TLB_TX_PATT_GEN_CFGr_PATT_GEN_STOP_POSf_SET(r,f) (r).tlb_tx_patt_gen_cfg[0]=(((r).tlb_tx_patt_gen_cfg[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_TSCE16_XGXS_TLB_TX_PATT_GEN_CFGr_PATT_GEN_ENf_GET(r) (((r).tlb_tx_patt_gen_cfg[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_TX_PATT_GEN_CFGr_PATT_GEN_ENf_SET(r,f) (r).tlb_tx_patt_gen_cfg[0]=(((r).tlb_tx_patt_gen_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_TX_PATT_GEN_CFG.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TLB_TX_PATT_GEN_CFGr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_TX_PATT_GEN_CFGr,(_r._tlb_tx_patt_gen_cfg))
#define BCMI_TSCE16_XGXS_WRITE_TLB_TX_PATT_GEN_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_TX_PATT_GEN_CFGr,(_r._tlb_tx_patt_gen_cfg)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TLB_TX_PATT_GEN_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_TX_PATT_GEN_CFGr,(_r._tlb_tx_patt_gen_cfg))
#define BCMI_TSCE16_XGXS_READLN_TLB_TX_PATT_GEN_CFGr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_TX_PATT_GEN_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_patt_gen_cfg))
#define BCMI_TSCE16_XGXS_WRITELN_TLB_TX_PATT_GEN_CFGr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_TX_PATT_GEN_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_patt_gen_cfg))
#define BCMI_TSCE16_XGXS_WRITEALL_TLB_TX_PATT_GEN_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_TX_PATT_GEN_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_tx_patt_gen_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_PATT_GEN_CFGr BCMI_TSCE16_XGXS_TLB_TX_PATT_GEN_CFGr
#define TLB_TX_PATT_GEN_CFGr_SIZE BCMI_TSCE16_XGXS_TLB_TX_PATT_GEN_CFGr_SIZE
typedef BCMI_TSCE16_XGXS_TLB_TX_PATT_GEN_CFGr_t TLB_TX_PATT_GEN_CFGr_t;
#define TLB_TX_PATT_GEN_CFGr_CLR BCMI_TSCE16_XGXS_TLB_TX_PATT_GEN_CFGr_CLR
#define TLB_TX_PATT_GEN_CFGr_SET BCMI_TSCE16_XGXS_TLB_TX_PATT_GEN_CFGr_SET
#define TLB_TX_PATT_GEN_CFGr_GET BCMI_TSCE16_XGXS_TLB_TX_PATT_GEN_CFGr_GET
#define TLB_TX_PATT_GEN_CFGr_PATT_GEN_START_POSf_GET BCMI_TSCE16_XGXS_TLB_TX_PATT_GEN_CFGr_PATT_GEN_START_POSf_GET
#define TLB_TX_PATT_GEN_CFGr_PATT_GEN_START_POSf_SET BCMI_TSCE16_XGXS_TLB_TX_PATT_GEN_CFGr_PATT_GEN_START_POSf_SET
#define TLB_TX_PATT_GEN_CFGr_PATT_GEN_STOP_POSf_GET BCMI_TSCE16_XGXS_TLB_TX_PATT_GEN_CFGr_PATT_GEN_STOP_POSf_GET
#define TLB_TX_PATT_GEN_CFGr_PATT_GEN_STOP_POSf_SET BCMI_TSCE16_XGXS_TLB_TX_PATT_GEN_CFGr_PATT_GEN_STOP_POSf_SET
#define TLB_TX_PATT_GEN_CFGr_PATT_GEN_ENf_GET BCMI_TSCE16_XGXS_TLB_TX_PATT_GEN_CFGr_PATT_GEN_ENf_GET
#define TLB_TX_PATT_GEN_CFGr_PATT_GEN_ENf_SET BCMI_TSCE16_XGXS_TLB_TX_PATT_GEN_CFGr_PATT_GEN_ENf_SET
#define READ_TLB_TX_PATT_GEN_CFGr BCMI_TSCE16_XGXS_READ_TLB_TX_PATT_GEN_CFGr
#define WRITE_TLB_TX_PATT_GEN_CFGr BCMI_TSCE16_XGXS_WRITE_TLB_TX_PATT_GEN_CFGr
#define MODIFY_TLB_TX_PATT_GEN_CFGr BCMI_TSCE16_XGXS_MODIFY_TLB_TX_PATT_GEN_CFGr
#define READLN_TLB_TX_PATT_GEN_CFGr BCMI_TSCE16_XGXS_READLN_TLB_TX_PATT_GEN_CFGr
#define WRITELN_TLB_TX_PATT_GEN_CFGr BCMI_TSCE16_XGXS_WRITELN_TLB_TX_PATT_GEN_CFGr
#define WRITEALL_TLB_TX_PATT_GEN_CFGr BCMI_TSCE16_XGXS_WRITEALL_TLB_TX_PATT_GEN_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TLB_TX_PATT_GEN_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TLB_TX_PRBS_GEN_CFG
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd0e1
 * DESC:     PRBS Generator Control
 * RESETVAL: 0xa (10)
 * ACCESS:   R/W
 * FIELDS:
 *     PRBS_GEN_EN      PRBS generator enable.1 => enable  the PRBS generator.0 => disable the PRBS generator.
 *     PRBS_GEN_MODE_SEL PRBS generator mode select. Selects the PRBS polynomial as shown below3'd0 -> PRBS 73'd1 -> PRBS 93'd2 -> PRBS 113'd3 -> PRBS 153'd4 -> PRBS 233'd5 -> PRBS 313'd6 -> PRBS 58 (1 + x^39 + x^58)3'd7 -> reserved for future use.
 *     PRBS_GEN_INV     PRBS Invert enable.1 => will invert all the data bits from the PRBS generator.0 => will send normal data from the PRBS generator.
 *     PRBS_GEN_ERR_INS PRBS Error Insert.0 to 1 transition on this signal will insert single bit error in the MSB bit of the data bus.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr (0x0000d0e1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_PRBS_GEN_CFG.
 *
 */
typedef union BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_tx_prbs_gen_cfg[1];
	uint32_t _tlb_tx_prbs_gen_cfg;
} BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr_t;

#define BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr_CLR(r) (r).tlb_tx_prbs_gen_cfg[0] = 0
#define BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr_SET(r,d) (r).tlb_tx_prbs_gen_cfg[0] = d
#define BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr_GET(r) (r).tlb_tx_prbs_gen_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_GET(r) ((((r).tlb_tx_prbs_gen_cfg[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_SET(r,f) (r).tlb_tx_prbs_gen_cfg[0]=(((r).tlb_tx_prbs_gen_cfg[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_GET(r) ((((r).tlb_tx_prbs_gen_cfg[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_SET(r,f) (r).tlb_tx_prbs_gen_cfg[0]=(((r).tlb_tx_prbs_gen_cfg[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_GET(r) ((((r).tlb_tx_prbs_gen_cfg[0]) >> 1) & 0x7)
#define BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_SET(r,f) (r).tlb_tx_prbs_gen_cfg[0]=(((r).tlb_tx_prbs_gen_cfg[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1)) | (7 << (16 + 1))
#define BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_GET(r) (((r).tlb_tx_prbs_gen_cfg[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_SET(r,f) (r).tlb_tx_prbs_gen_cfg[0]=(((r).tlb_tx_prbs_gen_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_TX_PRBS_GEN_CFG.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TLB_TX_PRBS_GEN_CFGr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr,(_r._tlb_tx_prbs_gen_cfg))
#define BCMI_TSCE16_XGXS_WRITE_TLB_TX_PRBS_GEN_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr,(_r._tlb_tx_prbs_gen_cfg)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TLB_TX_PRBS_GEN_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr,(_r._tlb_tx_prbs_gen_cfg))
#define BCMI_TSCE16_XGXS_READLN_TLB_TX_PRBS_GEN_CFGr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_prbs_gen_cfg))
#define BCMI_TSCE16_XGXS_WRITELN_TLB_TX_PRBS_GEN_CFGr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_prbs_gen_cfg))
#define BCMI_TSCE16_XGXS_WRITEALL_TLB_TX_PRBS_GEN_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_tx_prbs_gen_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_PRBS_GEN_CFGr BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr
#define TLB_TX_PRBS_GEN_CFGr_SIZE BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr_SIZE
typedef BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr_t TLB_TX_PRBS_GEN_CFGr_t;
#define TLB_TX_PRBS_GEN_CFGr_CLR BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr_CLR
#define TLB_TX_PRBS_GEN_CFGr_SET BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr_SET
#define TLB_TX_PRBS_GEN_CFGr_GET BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr_GET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_GET BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_GET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_SET BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_SET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_GET BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_GET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_SET BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_SET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_GET BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_GET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_SET BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_SET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_GET BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_GET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_SET BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_SET
#define READ_TLB_TX_PRBS_GEN_CFGr BCMI_TSCE16_XGXS_READ_TLB_TX_PRBS_GEN_CFGr
#define WRITE_TLB_TX_PRBS_GEN_CFGr BCMI_TSCE16_XGXS_WRITE_TLB_TX_PRBS_GEN_CFGr
#define MODIFY_TLB_TX_PRBS_GEN_CFGr BCMI_TSCE16_XGXS_MODIFY_TLB_TX_PRBS_GEN_CFGr
#define READLN_TLB_TX_PRBS_GEN_CFGr BCMI_TSCE16_XGXS_READLN_TLB_TX_PRBS_GEN_CFGr
#define WRITELN_TLB_TX_PRBS_GEN_CFGr BCMI_TSCE16_XGXS_WRITELN_TLB_TX_PRBS_GEN_CFGr
#define WRITEALL_TLB_TX_PRBS_GEN_CFGr BCMI_TSCE16_XGXS_WRITEALL_TLB_TX_PRBS_GEN_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TLB_TX_PRBS_GEN_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TLB_TX_RMT_LPBK_CFG
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd0e2
 * DESC:     Remote Loopback Control
 * RESETVAL: 0x2 (2)
 * ACCESS:   R/W
 * FIELDS:
 *     RMT_LPBK_EN      RX to TX Parallel Loopback (Remote Loopback) Enable.1 => Loopback is Enabled.0 => Loopback is Disabled.
 *     RMT_LPBK_PD_MODE Remote Loopback Phase Detector Mode. For normal operating conditions keep it at the default value of 1'b1.1'b0 - swap inc/dec. 1'b1 - normal mode.
 *     RMT_LPBK_PD_FRC_ON Remote loopback PD enable by force irrespective of rg_rmt_lpbk_en.1'b1 - enable the phase detector without the remote loopback enable. Can be used to lock RX and TXclock phases when there is a remote loopback outside PMD
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_CFGr (0x0000d0e2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_RMT_LPBK_CFG.
 *
 */
typedef union BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_tx_rmt_lpbk_cfg[1];
	uint32_t _tlb_tx_rmt_lpbk_cfg;
} BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_CFGr_t;

#define BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_CFGr_CLR(r) (r).tlb_tx_rmt_lpbk_cfg[0] = 0
#define BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_CFGr_SET(r,d) (r).tlb_tx_rmt_lpbk_cfg[0] = d
#define BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_CFGr_GET(r) (r).tlb_tx_rmt_lpbk_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_GET(r) ((((r).tlb_tx_rmt_lpbk_cfg[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_SET(r,f) (r).tlb_tx_rmt_lpbk_cfg[0]=(((r).tlb_tx_rmt_lpbk_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_GET(r) ((((r).tlb_tx_rmt_lpbk_cfg[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_SET(r,f) (r).tlb_tx_rmt_lpbk_cfg[0]=(((r).tlb_tx_rmt_lpbk_cfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_GET(r) (((r).tlb_tx_rmt_lpbk_cfg[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_SET(r,f) (r).tlb_tx_rmt_lpbk_cfg[0]=(((r).tlb_tx_rmt_lpbk_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_TX_RMT_LPBK_CFG.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TLB_TX_RMT_LPBK_CFGr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_CFGr,(_r._tlb_tx_rmt_lpbk_cfg))
#define BCMI_TSCE16_XGXS_WRITE_TLB_TX_RMT_LPBK_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_CFGr,(_r._tlb_tx_rmt_lpbk_cfg)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TLB_TX_RMT_LPBK_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_CFGr,(_r._tlb_tx_rmt_lpbk_cfg))
#define BCMI_TSCE16_XGXS_READLN_TLB_TX_RMT_LPBK_CFGr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_rmt_lpbk_cfg))
#define BCMI_TSCE16_XGXS_WRITELN_TLB_TX_RMT_LPBK_CFGr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_rmt_lpbk_cfg))
#define BCMI_TSCE16_XGXS_WRITEALL_TLB_TX_RMT_LPBK_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_tx_rmt_lpbk_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_RMT_LPBK_CFGr BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_CFGr
#define TLB_TX_RMT_LPBK_CFGr_SIZE BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_CFGr_SIZE
typedef BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_CFGr_t TLB_TX_RMT_LPBK_CFGr_t;
#define TLB_TX_RMT_LPBK_CFGr_CLR BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_CFGr_CLR
#define TLB_TX_RMT_LPBK_CFGr_SET BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_CFGr_SET
#define TLB_TX_RMT_LPBK_CFGr_GET BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_CFGr_GET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_GET BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_GET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_SET BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_SET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_GET BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_GET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_SET BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_SET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_GET BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_GET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_SET BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_SET
#define READ_TLB_TX_RMT_LPBK_CFGr BCMI_TSCE16_XGXS_READ_TLB_TX_RMT_LPBK_CFGr
#define WRITE_TLB_TX_RMT_LPBK_CFGr BCMI_TSCE16_XGXS_WRITE_TLB_TX_RMT_LPBK_CFGr
#define MODIFY_TLB_TX_RMT_LPBK_CFGr BCMI_TSCE16_XGXS_MODIFY_TLB_TX_RMT_LPBK_CFGr
#define READLN_TLB_TX_RMT_LPBK_CFGr BCMI_TSCE16_XGXS_READLN_TLB_TX_RMT_LPBK_CFGr
#define WRITELN_TLB_TX_RMT_LPBK_CFGr BCMI_TSCE16_XGXS_WRITELN_TLB_TX_RMT_LPBK_CFGr
#define WRITEALL_TLB_TX_RMT_LPBK_CFGr BCMI_TSCE16_XGXS_WRITEALL_TLB_TX_RMT_LPBK_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TLB_TX_TLB_TX_MISC_CFG
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd0e3
 * DESC:     TLB TX Misc. Control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PMD_DP_INVERT TX PMD Datapath Invert Control.When Enabled by writing to 1'b1, it will invert all the datapath bits of the logical lane.Recommended for use in case P and N pads are swapped on the PCB board.
 *     TX_PCS_NATIVE_ANA_FRMT_EN TX PCS Interface Native Analog Format Enable.1 => TX PCS Interface is enabled in the Native Analog Format mode. TX PCS sends the over-sampled data in this mode which is sent directly to AFE.0 => Raw Data Mode where for every data request TX PCS will send 20 bits of valid data.
 *     TX_MUX_SEL_ORDER TX Data MUX Select Priority Order. When 1'b1 then priority of Pattern and PRBS generators are swapped w.r.t. CL72.0 => TX Data Mux select order from higher to lower priority is {rmt_lpbk, patt_gen, cl72_tx, prbs_gen, tx_pcs}.1 => TX Data Mux select order from higher to lower priority is {rmt_lpbk, prbs_gen, cl72_tx, patt_gen, tx_pcs}.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TLB_TX_TLB_TX_MISC_CFGr (0x0000d0e3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TLB_TX_TLB_TX_MISC_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_TLB_TX_MISC_CFG.
 *
 */
typedef union BCMI_TSCE16_XGXS_TLB_TX_TLB_TX_MISC_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_tx_tlb_tx_misc_cfg[1];
	uint32_t _tlb_tx_tlb_tx_misc_cfg;
} BCMI_TSCE16_XGXS_TLB_TX_TLB_TX_MISC_CFGr_t;

#define BCMI_TSCE16_XGXS_TLB_TX_TLB_TX_MISC_CFGr_CLR(r) (r).tlb_tx_tlb_tx_misc_cfg[0] = 0
#define BCMI_TSCE16_XGXS_TLB_TX_TLB_TX_MISC_CFGr_SET(r,d) (r).tlb_tx_tlb_tx_misc_cfg[0] = d
#define BCMI_TSCE16_XGXS_TLB_TX_TLB_TX_MISC_CFGr_GET(r) (r).tlb_tx_tlb_tx_misc_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_GET(r) ((((r).tlb_tx_tlb_tx_misc_cfg[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_SET(r,f) (r).tlb_tx_tlb_tx_misc_cfg[0]=(((r).tlb_tx_tlb_tx_misc_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_GET(r) ((((r).tlb_tx_tlb_tx_misc_cfg[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_SET(r,f) (r).tlb_tx_tlb_tx_misc_cfg[0]=(((r).tlb_tx_tlb_tx_misc_cfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_GET(r) (((r).tlb_tx_tlb_tx_misc_cfg[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_SET(r,f) (r).tlb_tx_tlb_tx_misc_cfg[0]=(((r).tlb_tx_tlb_tx_misc_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_TX_TLB_TX_MISC_CFG.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TLB_TX_TLB_TX_MISC_CFGr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_TX_TLB_TX_MISC_CFGr,(_r._tlb_tx_tlb_tx_misc_cfg))
#define BCMI_TSCE16_XGXS_WRITE_TLB_TX_TLB_TX_MISC_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_TX_TLB_TX_MISC_CFGr,(_r._tlb_tx_tlb_tx_misc_cfg)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TLB_TX_TLB_TX_MISC_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_TX_TLB_TX_MISC_CFGr,(_r._tlb_tx_tlb_tx_misc_cfg))
#define BCMI_TSCE16_XGXS_READLN_TLB_TX_TLB_TX_MISC_CFGr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_TX_TLB_TX_MISC_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_tlb_tx_misc_cfg))
#define BCMI_TSCE16_XGXS_WRITELN_TLB_TX_TLB_TX_MISC_CFGr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_TX_TLB_TX_MISC_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_tlb_tx_misc_cfg))
#define BCMI_TSCE16_XGXS_WRITEALL_TLB_TX_TLB_TX_MISC_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_TX_TLB_TX_MISC_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_tx_tlb_tx_misc_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_TLB_TX_MISC_CFGr BCMI_TSCE16_XGXS_TLB_TX_TLB_TX_MISC_CFGr
#define TLB_TX_TLB_TX_MISC_CFGr_SIZE BCMI_TSCE16_XGXS_TLB_TX_TLB_TX_MISC_CFGr_SIZE
typedef BCMI_TSCE16_XGXS_TLB_TX_TLB_TX_MISC_CFGr_t TLB_TX_TLB_TX_MISC_CFGr_t;
#define TLB_TX_TLB_TX_MISC_CFGr_CLR BCMI_TSCE16_XGXS_TLB_TX_TLB_TX_MISC_CFGr_CLR
#define TLB_TX_TLB_TX_MISC_CFGr_SET BCMI_TSCE16_XGXS_TLB_TX_TLB_TX_MISC_CFGr_SET
#define TLB_TX_TLB_TX_MISC_CFGr_GET BCMI_TSCE16_XGXS_TLB_TX_TLB_TX_MISC_CFGr_GET
#define TLB_TX_TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_GET BCMI_TSCE16_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_GET
#define TLB_TX_TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_SET BCMI_TSCE16_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_SET
#define TLB_TX_TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_GET BCMI_TSCE16_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_GET
#define TLB_TX_TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_SET BCMI_TSCE16_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_SET
#define TLB_TX_TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_GET BCMI_TSCE16_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_GET
#define TLB_TX_TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_SET BCMI_TSCE16_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_SET
#define READ_TLB_TX_TLB_TX_MISC_CFGr BCMI_TSCE16_XGXS_READ_TLB_TX_TLB_TX_MISC_CFGr
#define WRITE_TLB_TX_TLB_TX_MISC_CFGr BCMI_TSCE16_XGXS_WRITE_TLB_TX_TLB_TX_MISC_CFGr
#define MODIFY_TLB_TX_TLB_TX_MISC_CFGr BCMI_TSCE16_XGXS_MODIFY_TLB_TX_TLB_TX_MISC_CFGr
#define READLN_TLB_TX_TLB_TX_MISC_CFGr BCMI_TSCE16_XGXS_READLN_TLB_TX_TLB_TX_MISC_CFGr
#define WRITELN_TLB_TX_TLB_TX_MISC_CFGr BCMI_TSCE16_XGXS_WRITELN_TLB_TX_TLB_TX_MISC_CFGr
#define WRITEALL_TLB_TX_TLB_TX_MISC_CFGr BCMI_TSCE16_XGXS_WRITEALL_TLB_TX_TLB_TX_MISC_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TLB_TX_TLB_TX_MISC_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TLB_TX_RMT_LPBK_PD_STS
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd0e8
 * DESC:     Remote Loopback Status
 * RESETVAL: 0x2 (2)
 * ACCESS:   R/O
 * FIELDS:
 *     RMT_LPBK_PD_LATE_IND 1 means dp_tclk20 is sampling data late so reduce the delay of the dp_tclk20 clock phase. This will result in TX PI phase step decrement.
 *     RMT_LPBK_PD_EARLY_IND 1 means dp_tclk20 is sampling data earlier so delay the dp_tclk20 clock phase. This will result in TX PI phase step increment.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_PD_STSr (0x0000d0e8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_PD_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_RMT_LPBK_PD_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_PD_STSr_s {
	uint32_t v[1];
	uint32_t tlb_tx_rmt_lpbk_pd_sts[1];
	uint32_t _tlb_tx_rmt_lpbk_pd_sts;
} BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_PD_STSr_t;

#define BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_PD_STSr_CLR(r) (r).tlb_tx_rmt_lpbk_pd_sts[0] = 0
#define BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_PD_STSr_SET(r,d) (r).tlb_tx_rmt_lpbk_pd_sts[0] = d
#define BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_PD_STSr_GET(r) (r).tlb_tx_rmt_lpbk_pd_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_GET(r) ((((r).tlb_tx_rmt_lpbk_pd_sts[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_SET(r,f) (r).tlb_tx_rmt_lpbk_pd_sts[0]=(((r).tlb_tx_rmt_lpbk_pd_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_GET(r) (((r).tlb_tx_rmt_lpbk_pd_sts[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_SET(r,f) (r).tlb_tx_rmt_lpbk_pd_sts[0]=(((r).tlb_tx_rmt_lpbk_pd_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_TX_RMT_LPBK_PD_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TLB_TX_RMT_LPBK_PD_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_PD_STSr,(_r._tlb_tx_rmt_lpbk_pd_sts))
#define BCMI_TSCE16_XGXS_WRITE_TLB_TX_RMT_LPBK_PD_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_PD_STSr,(_r._tlb_tx_rmt_lpbk_pd_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TLB_TX_RMT_LPBK_PD_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_PD_STSr,(_r._tlb_tx_rmt_lpbk_pd_sts))
#define BCMI_TSCE16_XGXS_READLN_TLB_TX_RMT_LPBK_PD_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_PD_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_rmt_lpbk_pd_sts))
#define BCMI_TSCE16_XGXS_WRITELN_TLB_TX_RMT_LPBK_PD_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_PD_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_rmt_lpbk_pd_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_TLB_TX_RMT_LPBK_PD_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_PD_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_tx_rmt_lpbk_pd_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_RMT_LPBK_PD_STSr BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_PD_STSr
#define TLB_TX_RMT_LPBK_PD_STSr_SIZE BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_PD_STSr_SIZE
typedef BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_PD_STSr_t TLB_TX_RMT_LPBK_PD_STSr_t;
#define TLB_TX_RMT_LPBK_PD_STSr_CLR BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_PD_STSr_CLR
#define TLB_TX_RMT_LPBK_PD_STSr_SET BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_PD_STSr_SET
#define TLB_TX_RMT_LPBK_PD_STSr_GET BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_PD_STSr_GET
#define TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_GET BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_GET
#define TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_SET BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_SET
#define TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_GET BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_GET
#define TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_SET BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_SET
#define READ_TLB_TX_RMT_LPBK_PD_STSr BCMI_TSCE16_XGXS_READ_TLB_TX_RMT_LPBK_PD_STSr
#define WRITE_TLB_TX_RMT_LPBK_PD_STSr BCMI_TSCE16_XGXS_WRITE_TLB_TX_RMT_LPBK_PD_STSr
#define MODIFY_TLB_TX_RMT_LPBK_PD_STSr BCMI_TSCE16_XGXS_MODIFY_TLB_TX_RMT_LPBK_PD_STSr
#define READLN_TLB_TX_RMT_LPBK_PD_STSr BCMI_TSCE16_XGXS_READLN_TLB_TX_RMT_LPBK_PD_STSr
#define WRITELN_TLB_TX_RMT_LPBK_PD_STSr BCMI_TSCE16_XGXS_WRITELN_TLB_TX_RMT_LPBK_PD_STSr
#define WRITEALL_TLB_TX_RMT_LPBK_PD_STSr BCMI_TSCE16_XGXS_WRITEALL_TLB_TX_RMT_LPBK_PD_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TLB_TX_RMT_LPBK_PD_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  REVID0
 * BLOCKS:   DIGCOM
 * REGADDR:  0xd0f0
 * DESC:     REVID0
 * RESETVAL: 0x363 (867)
 * ACCESS:   R/O
 * FIELDS:
 *     REVID_MODEL      model number
 *     REVID_PROCESS    technology process0 = 90nm1 = 65nm2 = 40nm3 = 28nm4 = 20nm5 = 16nm6-7 = reserved
 *     REVID_BONDING    bonding0 = wire bond1 = flip chip2-3 = reserved
 *     REVID_REV_NUMBER Metal mask revision number
 *     REVID_REV_LETTER All layer revision letter0 = revA1 = revB2 = revC3 = revD
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_REVID0r (0x0000d0f0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_REVID0r_SIZE 4

/*
 * This structure should be used to declare and program REVID0.
 *
 */
typedef union BCMI_TSCE16_XGXS_REVID0r_s {
	uint32_t v[1];
	uint32_t revid0[1];
	uint32_t _revid0;
} BCMI_TSCE16_XGXS_REVID0r_t;

#define BCMI_TSCE16_XGXS_REVID0r_CLR(r) (r).revid0[0] = 0
#define BCMI_TSCE16_XGXS_REVID0r_SET(r,d) (r).revid0[0] = d
#define BCMI_TSCE16_XGXS_REVID0r_GET(r) (r).revid0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_REVID0r_REVID_REV_LETTERf_GET(r) ((((r).revid0[0]) >> 14) & 0x3)
#define BCMI_TSCE16_XGXS_REVID0r_REVID_REV_LETTERf_SET(r,f) (r).revid0[0]=(((r).revid0[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCE16_XGXS_REVID0r_REVID_REV_NUMBERf_GET(r) ((((r).revid0[0]) >> 11) & 0x7)
#define BCMI_TSCE16_XGXS_REVID0r_REVID_REV_NUMBERf_SET(r,f) (r).revid0[0]=(((r).revid0[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_TSCE16_XGXS_REVID0r_REVID_BONDINGf_GET(r) ((((r).revid0[0]) >> 9) & 0x3)
#define BCMI_TSCE16_XGXS_REVID0r_REVID_BONDINGf_SET(r,f) (r).revid0[0]=(((r).revid0[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9)) | (3 << (16 + 9))
#define BCMI_TSCE16_XGXS_REVID0r_REVID_PROCESSf_GET(r) ((((r).revid0[0]) >> 6) & 0x7)
#define BCMI_TSCE16_XGXS_REVID0r_REVID_PROCESSf_SET(r,f) (r).revid0[0]=(((r).revid0[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_TSCE16_XGXS_REVID0r_REVID_MODELf_GET(r) (((r).revid0[0]) & 0x3f)
#define BCMI_TSCE16_XGXS_REVID0r_REVID_MODELf_SET(r,f) (r).revid0[0]=(((r).revid0[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access REVID0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_REVID0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_REVID0r,(_r._revid0))
#define BCMI_TSCE16_XGXS_WRITE_REVID0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_REVID0r,(_r._revid0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_REVID0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_REVID0r,(_r._revid0))
#define BCMI_TSCE16_XGXS_READLN_REVID0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_REVID0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._revid0))
#define BCMI_TSCE16_XGXS_WRITELN_REVID0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_REVID0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._revid0))
#define BCMI_TSCE16_XGXS_WRITEALL_REVID0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_REVID0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._revid0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define REVID0r BCMI_TSCE16_XGXS_REVID0r
#define REVID0r_SIZE BCMI_TSCE16_XGXS_REVID0r_SIZE
typedef BCMI_TSCE16_XGXS_REVID0r_t REVID0r_t;
#define REVID0r_CLR BCMI_TSCE16_XGXS_REVID0r_CLR
#define REVID0r_SET BCMI_TSCE16_XGXS_REVID0r_SET
#define REVID0r_GET BCMI_TSCE16_XGXS_REVID0r_GET
#define REVID0r_REVID_REV_LETTERf_GET BCMI_TSCE16_XGXS_REVID0r_REVID_REV_LETTERf_GET
#define REVID0r_REVID_REV_LETTERf_SET BCMI_TSCE16_XGXS_REVID0r_REVID_REV_LETTERf_SET
#define REVID0r_REVID_REV_NUMBERf_GET BCMI_TSCE16_XGXS_REVID0r_REVID_REV_NUMBERf_GET
#define REVID0r_REVID_REV_NUMBERf_SET BCMI_TSCE16_XGXS_REVID0r_REVID_REV_NUMBERf_SET
#define REVID0r_REVID_BONDINGf_GET BCMI_TSCE16_XGXS_REVID0r_REVID_BONDINGf_GET
#define REVID0r_REVID_BONDINGf_SET BCMI_TSCE16_XGXS_REVID0r_REVID_BONDINGf_SET
#define REVID0r_REVID_PROCESSf_GET BCMI_TSCE16_XGXS_REVID0r_REVID_PROCESSf_GET
#define REVID0r_REVID_PROCESSf_SET BCMI_TSCE16_XGXS_REVID0r_REVID_PROCESSf_SET
#define REVID0r_REVID_MODELf_GET BCMI_TSCE16_XGXS_REVID0r_REVID_MODELf_GET
#define REVID0r_REVID_MODELf_SET BCMI_TSCE16_XGXS_REVID0r_REVID_MODELf_SET
#define READ_REVID0r BCMI_TSCE16_XGXS_READ_REVID0r
#define WRITE_REVID0r BCMI_TSCE16_XGXS_WRITE_REVID0r
#define MODIFY_REVID0r BCMI_TSCE16_XGXS_MODIFY_REVID0r
#define READLN_REVID0r BCMI_TSCE16_XGXS_READLN_REVID0r
#define WRITELN_REVID0r BCMI_TSCE16_XGXS_WRITELN_REVID0r
#define WRITEALL_REVID0r BCMI_TSCE16_XGXS_WRITEALL_REVID0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_REVID0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RST_CTL_PMD
 * BLOCKS:   DIGCOM
 * REGADDR:  0xd0f1
 * DESC:     RESET_CONTROL_PMD
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     CORE_S_RSTB      Active Low Core Level Soft Reset. If asserted by writing to 1'b0 will reset the whole core.This soft reset is equivalent to the hard reset input pin pmd_por_h_rstb. This regiter bit can only bereset by assertion of the hard reset input pin pmd_por_h_rstb
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RST_CTL_PMDr (0x0000d0f1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RST_CTL_PMDr_SIZE 4

/*
 * This structure should be used to declare and program RST_CTL_PMD.
 *
 */
typedef union BCMI_TSCE16_XGXS_RST_CTL_PMDr_s {
	uint32_t v[1];
	uint32_t rst_ctl_pmd[1];
	uint32_t _rst_ctl_pmd;
} BCMI_TSCE16_XGXS_RST_CTL_PMDr_t;

#define BCMI_TSCE16_XGXS_RST_CTL_PMDr_CLR(r) (r).rst_ctl_pmd[0] = 0
#define BCMI_TSCE16_XGXS_RST_CTL_PMDr_SET(r,d) (r).rst_ctl_pmd[0] = d
#define BCMI_TSCE16_XGXS_RST_CTL_PMDr_GET(r) (r).rst_ctl_pmd[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RST_CTL_PMDr_CORE_S_RSTBf_GET(r) (((r).rst_ctl_pmd[0]) & 0x1)
#define BCMI_TSCE16_XGXS_RST_CTL_PMDr_CORE_S_RSTBf_SET(r,f) (r).rst_ctl_pmd[0]=(((r).rst_ctl_pmd[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RST_CTL_PMD.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RST_CTL_PMDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RST_CTL_PMDr,(_r._rst_ctl_pmd))
#define BCMI_TSCE16_XGXS_WRITE_RST_CTL_PMDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RST_CTL_PMDr,(_r._rst_ctl_pmd)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RST_CTL_PMDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RST_CTL_PMDr,(_r._rst_ctl_pmd))
#define BCMI_TSCE16_XGXS_READLN_RST_CTL_PMDr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RST_CTL_PMDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rst_ctl_pmd))
#define BCMI_TSCE16_XGXS_WRITELN_RST_CTL_PMDr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RST_CTL_PMDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rst_ctl_pmd))
#define BCMI_TSCE16_XGXS_WRITEALL_RST_CTL_PMDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RST_CTL_PMDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rst_ctl_pmd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RST_CTL_PMDr BCMI_TSCE16_XGXS_RST_CTL_PMDr
#define RST_CTL_PMDr_SIZE BCMI_TSCE16_XGXS_RST_CTL_PMDr_SIZE
typedef BCMI_TSCE16_XGXS_RST_CTL_PMDr_t RST_CTL_PMDr_t;
#define RST_CTL_PMDr_CLR BCMI_TSCE16_XGXS_RST_CTL_PMDr_CLR
#define RST_CTL_PMDr_SET BCMI_TSCE16_XGXS_RST_CTL_PMDr_SET
#define RST_CTL_PMDr_GET BCMI_TSCE16_XGXS_RST_CTL_PMDr_GET
#define RST_CTL_PMDr_CORE_S_RSTBf_GET BCMI_TSCE16_XGXS_RST_CTL_PMDr_CORE_S_RSTBf_GET
#define RST_CTL_PMDr_CORE_S_RSTBf_SET BCMI_TSCE16_XGXS_RST_CTL_PMDr_CORE_S_RSTBf_SET
#define READ_RST_CTL_PMDr BCMI_TSCE16_XGXS_READ_RST_CTL_PMDr
#define WRITE_RST_CTL_PMDr BCMI_TSCE16_XGXS_WRITE_RST_CTL_PMDr
#define MODIFY_RST_CTL_PMDr BCMI_TSCE16_XGXS_MODIFY_RST_CTL_PMDr
#define READLN_RST_CTL_PMDr BCMI_TSCE16_XGXS_READLN_RST_CTL_PMDr
#define WRITELN_RST_CTL_PMDr BCMI_TSCE16_XGXS_WRITELN_RST_CTL_PMDr
#define WRITEALL_RST_CTL_PMDr BCMI_TSCE16_XGXS_WRITEALL_RST_CTL_PMDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RST_CTL_PMDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RST_CTL_CORE_DP
 * BLOCKS:   DIGCOM
 * REGADDR:  0xd0f2
 * DESC:     RESET_CONTROL_CORE_DP
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMD_CORE_DP_H_RSTB_PKILL 1'b1 will disable the pmd_core_dp_h_rstb pin.
 *     SUP_RST_SEQ_FRC_VAL Suppress reset sequence.
 *     SUP_RST_SEQ_FRC  Suppress reset sequence force.
 *     PMD_MDIO_TRANS_PKILL 1'b1 will disable the pmd_mdio_trans pin.
 *     VCOCLK16_S_COMCLK_SEL Mux control for selection of comclk for pmd_vcoclk16 clock.If asserted by writing to 1'b1 will select the comclk for the pmd_vcoclk16 clock.It is recommended for user to force pmd_vcoclk16_vld to 1'b0 while vcoclk16_s_comclk_sel is asserted to 1'b1by using pmd_vcoclk16_vld_frc/frc_val registers.
 *     VCOCLK16_S_COMCLK_FRC_ON Mux control for selection of comclk for pmd_vcoclk16 by force.If asserted by writing to 1'b1 will select the comclk for the pmd_vcoclk16 clock. This is a debug bit and should be used only for recovery from a dead AFE lane clock. Use of this bit with an active AFE clock can cause clock glitches.It is recommended for user to force pmd_vcoclk16_vld to 1'b0 while vcoclk16_s_comclk_frc_on is asserted to 1'b1by using pmd_vcoclk16_vld_frc/frc_val registers.
 *     PMD_VCOCLK16_VLD_FRC pmd_vcoclk16_vld pin force.
 *     PMD_VCOCLK16_VLD_FRC_VAL pmd_vcoclk16_vld pin force value.
 *     DISABLE_ACK_TIMEOUT Setting this bit to 1 disables the ack timeout for all ports.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr (0x0000d0f2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_SIZE 4

/*
 * This structure should be used to declare and program RST_CTL_CORE_DP.
 *
 */
typedef union BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_s {
	uint32_t v[1];
	uint32_t rst_ctl_core_dp[1];
	uint32_t _rst_ctl_core_dp;
} BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_t;

#define BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_CLR(r) (r).rst_ctl_core_dp[0] = 0
#define BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_SET(r,d) (r).rst_ctl_core_dp[0] = d
#define BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_GET(r) (r).rst_ctl_core_dp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_DISABLE_ACK_TIMEOUTf_GET(r) ((((r).rst_ctl_core_dp[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_DISABLE_ACK_TIMEOUTf_SET(r,f) (r).rst_ctl_core_dp[0]=(((r).rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_PMD_VCOCLK16_VLD_FRC_VALf_GET(r) ((((r).rst_ctl_core_dp[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_PMD_VCOCLK16_VLD_FRC_VALf_SET(r,f) (r).rst_ctl_core_dp[0]=(((r).rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_PMD_VCOCLK16_VLD_FRCf_GET(r) ((((r).rst_ctl_core_dp[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_PMD_VCOCLK16_VLD_FRCf_SET(r,f) (r).rst_ctl_core_dp[0]=(((r).rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_VCOCLK16_S_COMCLK_FRC_ONf_GET(r) ((((r).rst_ctl_core_dp[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_VCOCLK16_S_COMCLK_FRC_ONf_SET(r,f) (r).rst_ctl_core_dp[0]=(((r).rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_VCOCLK16_S_COMCLK_SELf_GET(r) ((((r).rst_ctl_core_dp[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_VCOCLK16_S_COMCLK_SELf_SET(r,f) (r).rst_ctl_core_dp[0]=(((r).rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_GET(r) ((((r).rst_ctl_core_dp[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_SET(r,f) (r).rst_ctl_core_dp[0]=(((r).rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_GET(r) ((((r).rst_ctl_core_dp[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_SET(r,f) (r).rst_ctl_core_dp[0]=(((r).rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_GET(r) ((((r).rst_ctl_core_dp[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_SET(r,f) (r).rst_ctl_core_dp[0]=(((r).rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_PMD_CORE_DP_H_RSTB_PKILLf_GET(r) ((((r).rst_ctl_core_dp[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_PMD_CORE_DP_H_RSTB_PKILLf_SET(r,f) (r).rst_ctl_core_dp[0]=(((r).rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access RST_CTL_CORE_DP.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RST_CTL_CORE_DPr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr,(_r._rst_ctl_core_dp))
#define BCMI_TSCE16_XGXS_WRITE_RST_CTL_CORE_DPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr,(_r._rst_ctl_core_dp)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RST_CTL_CORE_DPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr,(_r._rst_ctl_core_dp))
#define BCMI_TSCE16_XGXS_READLN_RST_CTL_CORE_DPr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rst_ctl_core_dp))
#define BCMI_TSCE16_XGXS_WRITELN_RST_CTL_CORE_DPr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rst_ctl_core_dp))
#define BCMI_TSCE16_XGXS_WRITEALL_RST_CTL_CORE_DPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rst_ctl_core_dp))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RST_CTL_CORE_DPr BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr
#define RST_CTL_CORE_DPr_SIZE BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_SIZE
typedef BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_t RST_CTL_CORE_DPr_t;
#define RST_CTL_CORE_DPr_CLR BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_CLR
#define RST_CTL_CORE_DPr_SET BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_SET
#define RST_CTL_CORE_DPr_GET BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_GET
#define RST_CTL_CORE_DPr_DISABLE_ACK_TIMEOUTf_GET BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_DISABLE_ACK_TIMEOUTf_GET
#define RST_CTL_CORE_DPr_DISABLE_ACK_TIMEOUTf_SET BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_DISABLE_ACK_TIMEOUTf_SET
#define RST_CTL_CORE_DPr_PMD_VCOCLK16_VLD_FRC_VALf_GET BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_PMD_VCOCLK16_VLD_FRC_VALf_GET
#define RST_CTL_CORE_DPr_PMD_VCOCLK16_VLD_FRC_VALf_SET BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_PMD_VCOCLK16_VLD_FRC_VALf_SET
#define RST_CTL_CORE_DPr_PMD_VCOCLK16_VLD_FRCf_GET BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_PMD_VCOCLK16_VLD_FRCf_GET
#define RST_CTL_CORE_DPr_PMD_VCOCLK16_VLD_FRCf_SET BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_PMD_VCOCLK16_VLD_FRCf_SET
#define RST_CTL_CORE_DPr_VCOCLK16_S_COMCLK_FRC_ONf_GET BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_VCOCLK16_S_COMCLK_FRC_ONf_GET
#define RST_CTL_CORE_DPr_VCOCLK16_S_COMCLK_FRC_ONf_SET BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_VCOCLK16_S_COMCLK_FRC_ONf_SET
#define RST_CTL_CORE_DPr_VCOCLK16_S_COMCLK_SELf_GET BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_VCOCLK16_S_COMCLK_SELf_GET
#define RST_CTL_CORE_DPr_VCOCLK16_S_COMCLK_SELf_SET BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_VCOCLK16_S_COMCLK_SELf_SET
#define RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_GET BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_GET
#define RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_SET BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_SET
#define RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_GET BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_GET
#define RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_SET BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_SET
#define RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_GET BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_GET
#define RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_SET BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_SET
#define RST_CTL_CORE_DPr_PMD_CORE_DP_H_RSTB_PKILLf_GET BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_PMD_CORE_DP_H_RSTB_PKILLf_GET
#define RST_CTL_CORE_DPr_PMD_CORE_DP_H_RSTB_PKILLf_SET BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr_PMD_CORE_DP_H_RSTB_PKILLf_SET
#define READ_RST_CTL_CORE_DPr BCMI_TSCE16_XGXS_READ_RST_CTL_CORE_DPr
#define WRITE_RST_CTL_CORE_DPr BCMI_TSCE16_XGXS_WRITE_RST_CTL_CORE_DPr
#define MODIFY_RST_CTL_CORE_DPr BCMI_TSCE16_XGXS_MODIFY_RST_CTL_CORE_DPr
#define READLN_RST_CTL_CORE_DPr BCMI_TSCE16_XGXS_READLN_RST_CTL_CORE_DPr
#define WRITELN_RST_CTL_CORE_DPr BCMI_TSCE16_XGXS_WRITELN_RST_CTL_CORE_DPr
#define WRITEALL_RST_CTL_CORE_DPr BCMI_TSCE16_XGXS_WRITEALL_RST_CTL_CORE_DPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RST_CTL_CORE_DPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  MASKDATA
 * BLOCKS:   DIGCOM
 * REGADDR:  0xd0f3
 * DESC:     MASKDATA_REG
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MASKDATA         maskdata for writes that can be used with any PMI port (PMI_HP, PMI_LP or PMI_MDIO). This register will get reset to 0 after each transaction.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_MASKDATAr (0x0000d0f3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_MASKDATAr_SIZE 4

/*
 * This structure should be used to declare and program MASKDATA.
 *
 */
typedef union BCMI_TSCE16_XGXS_MASKDATAr_s {
	uint32_t v[1];
	uint32_t maskdata[1];
	uint32_t _maskdata;
} BCMI_TSCE16_XGXS_MASKDATAr_t;

#define BCMI_TSCE16_XGXS_MASKDATAr_CLR(r) (r).maskdata[0] = 0
#define BCMI_TSCE16_XGXS_MASKDATAr_SET(r,d) (r).maskdata[0] = d
#define BCMI_TSCE16_XGXS_MASKDATAr_GET(r) (r).maskdata[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_MASKDATAr_MASKDATAf_GET(r) (((r).maskdata[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_MASKDATAr_MASKDATAf_SET(r,f) (r).maskdata[0]=(((r).maskdata[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access MASKDATA.
 *
 */
#define BCMI_TSCE16_XGXS_READ_MASKDATAr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MASKDATAr,(_r._maskdata))
#define BCMI_TSCE16_XGXS_WRITE_MASKDATAr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MASKDATAr,(_r._maskdata)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_MASKDATAr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MASKDATAr,(_r._maskdata))
#define BCMI_TSCE16_XGXS_READLN_MASKDATAr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MASKDATAr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._maskdata))
#define BCMI_TSCE16_XGXS_WRITELN_MASKDATAr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MASKDATAr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._maskdata))
#define BCMI_TSCE16_XGXS_WRITEALL_MASKDATAr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MASKDATAr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._maskdata))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MASKDATAr BCMI_TSCE16_XGXS_MASKDATAr
#define MASKDATAr_SIZE BCMI_TSCE16_XGXS_MASKDATAr_SIZE
typedef BCMI_TSCE16_XGXS_MASKDATAr_t MASKDATAr_t;
#define MASKDATAr_CLR BCMI_TSCE16_XGXS_MASKDATAr_CLR
#define MASKDATAr_SET BCMI_TSCE16_XGXS_MASKDATAr_SET
#define MASKDATAr_GET BCMI_TSCE16_XGXS_MASKDATAr_GET
#define MASKDATAr_MASKDATAf_GET BCMI_TSCE16_XGXS_MASKDATAr_MASKDATAf_GET
#define MASKDATAr_MASKDATAf_SET BCMI_TSCE16_XGXS_MASKDATAr_MASKDATAf_SET
#define READ_MASKDATAr BCMI_TSCE16_XGXS_READ_MASKDATAr
#define WRITE_MASKDATAr BCMI_TSCE16_XGXS_WRITE_MASKDATAr
#define MODIFY_MASKDATAr BCMI_TSCE16_XGXS_MODIFY_MASKDATAr
#define READLN_MASKDATAr BCMI_TSCE16_XGXS_READLN_MASKDATAr
#define WRITELN_MASKDATAr BCMI_TSCE16_XGXS_WRITELN_MASKDATAr
#define WRITEALL_MASKDATAr BCMI_TSCE16_XGXS_WRITEALL_MASKDATAr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_MASKDATAr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TOP_USER_CTL0
 * BLOCKS:   DIGCOM
 * REGADDR:  0xd0f4
 * DESC:     TOP_USER_CONTROL_0
 * RESETVAL: 0x271 (625)
 * ACCESS:   R/W
 * FIELDS:
 *     HEARTBEAT_COUNT_1US Heartbeat timer count in comclk cycles to create 1us heartbeat_1us period. It should be programmed to the nearest increment of 0.25Mhz value of the comclk frequency in Mhz.For example, for comclk of 125 Mhz, it should be programmed to 10'd500. For 156.25 Mhz comclk, it should be programmed to 10'd625 and similarly for any other comclk frequency.
 *     MASKDATA_BUS_ASSIGN This 2-bit register is used to assign the maskdata bus to any port .00: maskdata register is assigned to MDIO port01: maskdata register is assigned to PMI_HP port10: maskdata register is assigned to PMI_LP port11: maskdata register is not assigned to any port
 *     CORE_DP_S_RSTB   Active Low Core Level Datapath Soft Reset. If asserted by writingto 1'b0 will reset datapath logic of all the lanes. This soft resetis equivalent to the hard reset input pin core_dp_h_rstb.Minimum assertion time is 50 comclk cycles.
 *     AFE_S_PLL_PWRDN  Active High PLL Power Down control.Minimum assertion time is 50 comclk cycles.
 *     UC_ACTIVE        When set to 1'b1 then Hardware should wait for uC handshakes to wake up from datapath resetWhen set to 1'b0 then Hardware can internally assume that uc_ack_* = 1.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TOP_USER_CTL0r (0x0000d0f4 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TOP_USER_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program TOP_USER_CTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_TOP_USER_CTL0r_s {
	uint32_t v[1];
	uint32_t top_user_ctl0[1];
	uint32_t _top_user_ctl0;
} BCMI_TSCE16_XGXS_TOP_USER_CTL0r_t;

#define BCMI_TSCE16_XGXS_TOP_USER_CTL0r_CLR(r) (r).top_user_ctl0[0] = 0
#define BCMI_TSCE16_XGXS_TOP_USER_CTL0r_SET(r,d) (r).top_user_ctl0[0] = d
#define BCMI_TSCE16_XGXS_TOP_USER_CTL0r_GET(r) (r).top_user_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TOP_USER_CTL0r_UC_ACTIVEf_GET(r) ((((r).top_user_ctl0[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_TOP_USER_CTL0r_UC_ACTIVEf_SET(r,f) (r).top_user_ctl0[0]=(((r).top_user_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_TOP_USER_CTL0r_AFE_S_PLL_PWRDNf_GET(r) ((((r).top_user_ctl0[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_TOP_USER_CTL0r_AFE_S_PLL_PWRDNf_SET(r,f) (r).top_user_ctl0[0]=(((r).top_user_ctl0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_TOP_USER_CTL0r_CORE_DP_S_RSTBf_GET(r) ((((r).top_user_ctl0[0]) >> 13) & 0x1)
#define BCMI_TSCE16_XGXS_TOP_USER_CTL0r_CORE_DP_S_RSTBf_SET(r,f) (r).top_user_ctl0[0]=(((r).top_user_ctl0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCE16_XGXS_TOP_USER_CTL0r_MASKDATA_BUS_ASSIGNf_GET(r) ((((r).top_user_ctl0[0]) >> 10) & 0x3)
#define BCMI_TSCE16_XGXS_TOP_USER_CTL0r_MASKDATA_BUS_ASSIGNf_SET(r,f) (r).top_user_ctl0[0]=(((r).top_user_ctl0[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCE16_XGXS_TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_GET(r) (((r).top_user_ctl0[0]) & 0x3ff)
#define BCMI_TSCE16_XGXS_TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_SET(r,f) (r).top_user_ctl0[0]=(((r).top_user_ctl0[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access TOP_USER_CTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TOP_USER_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TOP_USER_CTL0r,(_r._top_user_ctl0))
#define BCMI_TSCE16_XGXS_WRITE_TOP_USER_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TOP_USER_CTL0r,(_r._top_user_ctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TOP_USER_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TOP_USER_CTL0r,(_r._top_user_ctl0))
#define BCMI_TSCE16_XGXS_READLN_TOP_USER_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TOP_USER_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._top_user_ctl0))
#define BCMI_TSCE16_XGXS_WRITELN_TOP_USER_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TOP_USER_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._top_user_ctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_TOP_USER_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TOP_USER_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._top_user_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TOP_USER_CTL0r BCMI_TSCE16_XGXS_TOP_USER_CTL0r
#define TOP_USER_CTL0r_SIZE BCMI_TSCE16_XGXS_TOP_USER_CTL0r_SIZE
typedef BCMI_TSCE16_XGXS_TOP_USER_CTL0r_t TOP_USER_CTL0r_t;
#define TOP_USER_CTL0r_CLR BCMI_TSCE16_XGXS_TOP_USER_CTL0r_CLR
#define TOP_USER_CTL0r_SET BCMI_TSCE16_XGXS_TOP_USER_CTL0r_SET
#define TOP_USER_CTL0r_GET BCMI_TSCE16_XGXS_TOP_USER_CTL0r_GET
#define TOP_USER_CTL0r_UC_ACTIVEf_GET BCMI_TSCE16_XGXS_TOP_USER_CTL0r_UC_ACTIVEf_GET
#define TOP_USER_CTL0r_UC_ACTIVEf_SET BCMI_TSCE16_XGXS_TOP_USER_CTL0r_UC_ACTIVEf_SET
#define TOP_USER_CTL0r_AFE_S_PLL_PWRDNf_GET BCMI_TSCE16_XGXS_TOP_USER_CTL0r_AFE_S_PLL_PWRDNf_GET
#define TOP_USER_CTL0r_AFE_S_PLL_PWRDNf_SET BCMI_TSCE16_XGXS_TOP_USER_CTL0r_AFE_S_PLL_PWRDNf_SET
#define TOP_USER_CTL0r_CORE_DP_S_RSTBf_GET BCMI_TSCE16_XGXS_TOP_USER_CTL0r_CORE_DP_S_RSTBf_GET
#define TOP_USER_CTL0r_CORE_DP_S_RSTBf_SET BCMI_TSCE16_XGXS_TOP_USER_CTL0r_CORE_DP_S_RSTBf_SET
#define TOP_USER_CTL0r_MASKDATA_BUS_ASSIGNf_GET BCMI_TSCE16_XGXS_TOP_USER_CTL0r_MASKDATA_BUS_ASSIGNf_GET
#define TOP_USER_CTL0r_MASKDATA_BUS_ASSIGNf_SET BCMI_TSCE16_XGXS_TOP_USER_CTL0r_MASKDATA_BUS_ASSIGNf_SET
#define TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_GET BCMI_TSCE16_XGXS_TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_GET
#define TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_SET BCMI_TSCE16_XGXS_TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_SET
#define READ_TOP_USER_CTL0r BCMI_TSCE16_XGXS_READ_TOP_USER_CTL0r
#define WRITE_TOP_USER_CTL0r BCMI_TSCE16_XGXS_WRITE_TOP_USER_CTL0r
#define MODIFY_TOP_USER_CTL0r BCMI_TSCE16_XGXS_MODIFY_TOP_USER_CTL0r
#define READLN_TOP_USER_CTL0r BCMI_TSCE16_XGXS_READLN_TOP_USER_CTL0r
#define WRITELN_TOP_USER_CTL0r BCMI_TSCE16_XGXS_WRITELN_TOP_USER_CTL0r
#define WRITEALL_TOP_USER_CTL0r BCMI_TSCE16_XGXS_WRITEALL_TOP_USER_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TOP_USER_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_ACK_CORE_CTL
 * BLOCKS:   DIGCOM
 * REGADDR:  0xd0f5
 * DESC:     UC_ACK_CORE_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UC_ACK_CORE_CFG_DONE uC will write this to 1 to indicate it's configuration of the core is complete. Writing to 1'b1 willshould release internal hold on core_dp_reset, only if core_dp_reset_state is 3'b001.
 *     UC_ACK_CORE_DP_RESET uC will write this to 1 to acknowledge a reset event after seeing "core_dp_reset_coccured".
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_ACK_CORE_CTLr (0x0000d0f5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_ACK_CORE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program UC_ACK_CORE_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_ACK_CORE_CTLr_s {
	uint32_t v[1];
	uint32_t uc_ack_core_ctl[1];
	uint32_t _uc_ack_core_ctl;
} BCMI_TSCE16_XGXS_UC_ACK_CORE_CTLr_t;

#define BCMI_TSCE16_XGXS_UC_ACK_CORE_CTLr_CLR(r) (r).uc_ack_core_ctl[0] = 0
#define BCMI_TSCE16_XGXS_UC_ACK_CORE_CTLr_SET(r,d) (r).uc_ack_core_ctl[0] = d
#define BCMI_TSCE16_XGXS_UC_ACK_CORE_CTLr_GET(r) (r).uc_ack_core_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_GET(r) ((((r).uc_ack_core_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_SET(r,f) (r).uc_ack_core_ctl[0]=(((r).uc_ack_core_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_GET(r) (((r).uc_ack_core_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_SET(r,f) (r).uc_ack_core_ctl[0]=(((r).uc_ack_core_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_ACK_CORE_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_ACK_CORE_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_ACK_CORE_CTLr,(_r._uc_ack_core_ctl))
#define BCMI_TSCE16_XGXS_WRITE_UC_ACK_CORE_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_ACK_CORE_CTLr,(_r._uc_ack_core_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_ACK_CORE_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_ACK_CORE_CTLr,(_r._uc_ack_core_ctl))
#define BCMI_TSCE16_XGXS_READLN_UC_ACK_CORE_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_ACK_CORE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ack_core_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_UC_ACK_CORE_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_ACK_CORE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ack_core_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_ACK_CORE_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_ACK_CORE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ack_core_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_ACK_CORE_CTLr BCMI_TSCE16_XGXS_UC_ACK_CORE_CTLr
#define UC_ACK_CORE_CTLr_SIZE BCMI_TSCE16_XGXS_UC_ACK_CORE_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_UC_ACK_CORE_CTLr_t UC_ACK_CORE_CTLr_t;
#define UC_ACK_CORE_CTLr_CLR BCMI_TSCE16_XGXS_UC_ACK_CORE_CTLr_CLR
#define UC_ACK_CORE_CTLr_SET BCMI_TSCE16_XGXS_UC_ACK_CORE_CTLr_SET
#define UC_ACK_CORE_CTLr_GET BCMI_TSCE16_XGXS_UC_ACK_CORE_CTLr_GET
#define UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_GET BCMI_TSCE16_XGXS_UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_GET
#define UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_SET BCMI_TSCE16_XGXS_UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_SET
#define UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_GET BCMI_TSCE16_XGXS_UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_GET
#define UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_SET BCMI_TSCE16_XGXS_UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_SET
#define READ_UC_ACK_CORE_CTLr BCMI_TSCE16_XGXS_READ_UC_ACK_CORE_CTLr
#define WRITE_UC_ACK_CORE_CTLr BCMI_TSCE16_XGXS_WRITE_UC_ACK_CORE_CTLr
#define MODIFY_UC_ACK_CORE_CTLr BCMI_TSCE16_XGXS_MODIFY_UC_ACK_CORE_CTLr
#define READLN_UC_ACK_CORE_CTLr BCMI_TSCE16_XGXS_READLN_UC_ACK_CORE_CTLr
#define WRITELN_UC_ACK_CORE_CTLr BCMI_TSCE16_XGXS_WRITELN_UC_ACK_CORE_CTLr
#define WRITEALL_UC_ACK_CORE_CTLr BCMI_TSCE16_XGXS_WRITEALL_UC_ACK_CORE_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_ACK_CORE_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  CORE_RST_OCC_CTL
 * BLOCKS:   DIGCOM
 * REGADDR:  0xd0f6
 * DESC:     CORE_REG_RESET_OCCURRED_CONTROL
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     CORE_REG_RESET_OCCURRED Set to 1'b1 upon core level register reset and remains so until cleared by register write from uC.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_CORE_RST_OCC_CTLr (0x0000d0f6 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_CORE_RST_OCC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CORE_RST_OCC_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_CORE_RST_OCC_CTLr_s {
	uint32_t v[1];
	uint32_t core_rst_occ_ctl[1];
	uint32_t _core_rst_occ_ctl;
} BCMI_TSCE16_XGXS_CORE_RST_OCC_CTLr_t;

#define BCMI_TSCE16_XGXS_CORE_RST_OCC_CTLr_CLR(r) (r).core_rst_occ_ctl[0] = 0
#define BCMI_TSCE16_XGXS_CORE_RST_OCC_CTLr_SET(r,d) (r).core_rst_occ_ctl[0] = d
#define BCMI_TSCE16_XGXS_CORE_RST_OCC_CTLr_GET(r) (r).core_rst_occ_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_CORE_RST_OCC_CTLr_CORE_REG_RESET_OCCURREDf_GET(r) (((r).core_rst_occ_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_CORE_RST_OCC_CTLr_CORE_REG_RESET_OCCURREDf_SET(r,f) (r).core_rst_occ_ctl[0]=(((r).core_rst_occ_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CORE_RST_OCC_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_CORE_RST_OCC_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CORE_RST_OCC_CTLr,(_r._core_rst_occ_ctl))
#define BCMI_TSCE16_XGXS_WRITE_CORE_RST_OCC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CORE_RST_OCC_CTLr,(_r._core_rst_occ_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_CORE_RST_OCC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CORE_RST_OCC_CTLr,(_r._core_rst_occ_ctl))
#define BCMI_TSCE16_XGXS_READLN_CORE_RST_OCC_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CORE_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._core_rst_occ_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_CORE_RST_OCC_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CORE_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._core_rst_occ_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_CORE_RST_OCC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CORE_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._core_rst_occ_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CORE_RST_OCC_CTLr BCMI_TSCE16_XGXS_CORE_RST_OCC_CTLr
#define CORE_RST_OCC_CTLr_SIZE BCMI_TSCE16_XGXS_CORE_RST_OCC_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_CORE_RST_OCC_CTLr_t CORE_RST_OCC_CTLr_t;
#define CORE_RST_OCC_CTLr_CLR BCMI_TSCE16_XGXS_CORE_RST_OCC_CTLr_CLR
#define CORE_RST_OCC_CTLr_SET BCMI_TSCE16_XGXS_CORE_RST_OCC_CTLr_SET
#define CORE_RST_OCC_CTLr_GET BCMI_TSCE16_XGXS_CORE_RST_OCC_CTLr_GET
#define CORE_RST_OCC_CTLr_CORE_REG_RESET_OCCURREDf_GET BCMI_TSCE16_XGXS_CORE_RST_OCC_CTLr_CORE_REG_RESET_OCCURREDf_GET
#define CORE_RST_OCC_CTLr_CORE_REG_RESET_OCCURREDf_SET BCMI_TSCE16_XGXS_CORE_RST_OCC_CTLr_CORE_REG_RESET_OCCURREDf_SET
#define READ_CORE_RST_OCC_CTLr BCMI_TSCE16_XGXS_READ_CORE_RST_OCC_CTLr
#define WRITE_CORE_RST_OCC_CTLr BCMI_TSCE16_XGXS_WRITE_CORE_RST_OCC_CTLr
#define MODIFY_CORE_RST_OCC_CTLr BCMI_TSCE16_XGXS_MODIFY_CORE_RST_OCC_CTLr
#define READLN_CORE_RST_OCC_CTLr BCMI_TSCE16_XGXS_READLN_CORE_RST_OCC_CTLr
#define WRITELN_CORE_RST_OCC_CTLr BCMI_TSCE16_XGXS_WRITELN_CORE_RST_OCC_CTLr
#define WRITEALL_CORE_RST_OCC_CTLr BCMI_TSCE16_XGXS_WRITEALL_CORE_RST_OCC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_CORE_RST_OCC_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RST_SEQ_TMR_CTL
 * BLOCKS:   DIGCOM
 * REGADDR:  0xd0f7
 * DESC:     RST_SEQ_TIMER_CONTROL
 * RESETVAL: 0x8604 (34308)
 * ACCESS:   R/W
 * FIELDS:
 *     RST_SEQ_TIMER    Defines the number of comclk cycles between de-assertion of AFE RX/TX lane reset and clock muxing from comclk to lane clock.Valid value range is from 0 to 7 which will provide from 1 to 15 clock cycles between de-assertion of AFE RX/TX lane resetand clock muxing from comclk to lane clock. Wait_time = 2 * rst_seq_timer + 1.
 *     PWRDN_SEQ_TIMER  Defines the number of comclk cycles between de-assertion of AFE RX/TX lane pwrdn and clock muxing from comclk to lane clock.Valid value range is from 0 to 7 which will provide from 8 to 64 clock cycles between de-assertion of AFE RX/TX lane pwrdnand clock muxing from comclk to lane clock. Wait_time = 8 * (pwrdn_seq_timer + 1).
 *     RST_SEQ_DIS_FLT_MODE Defines the filter mode for rst_seq_dis/pmd_mdio_trans pin.2'd0 - filter is bypassed where input is passed to output untouched.2'd1 - filter output is 16 comclk cycles if input is > 16 comclk cycles else output is same as input signal.2'd2 - filter output is 20 comclk cycles if input is > 20 comclk cycles else output is same as input signal.2'd3 - filter output is 24 comclk cycles if input is > 24 comclk cycles else output is same as input signal.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RST_SEQ_TMR_CTLr (0x0000d0f7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RST_SEQ_TMR_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RST_SEQ_TMR_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_RST_SEQ_TMR_CTLr_s {
	uint32_t v[1];
	uint32_t rst_seq_tmr_ctl[1];
	uint32_t _rst_seq_tmr_ctl;
} BCMI_TSCE16_XGXS_RST_SEQ_TMR_CTLr_t;

#define BCMI_TSCE16_XGXS_RST_SEQ_TMR_CTLr_CLR(r) (r).rst_seq_tmr_ctl[0] = 0
#define BCMI_TSCE16_XGXS_RST_SEQ_TMR_CTLr_SET(r,d) (r).rst_seq_tmr_ctl[0] = d
#define BCMI_TSCE16_XGXS_RST_SEQ_TMR_CTLr_GET(r) (r).rst_seq_tmr_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RST_SEQ_TMR_CTLr_RST_SEQ_DIS_FLT_MODEf_GET(r) ((((r).rst_seq_tmr_ctl[0]) >> 14) & 0x3)
#define BCMI_TSCE16_XGXS_RST_SEQ_TMR_CTLr_RST_SEQ_DIS_FLT_MODEf_SET(r,f) (r).rst_seq_tmr_ctl[0]=(((r).rst_seq_tmr_ctl[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCE16_XGXS_RST_SEQ_TMR_CTLr_PWRDN_SEQ_TIMERf_GET(r) ((((r).rst_seq_tmr_ctl[0]) >> 9) & 0x7)
#define BCMI_TSCE16_XGXS_RST_SEQ_TMR_CTLr_PWRDN_SEQ_TIMERf_SET(r,f) (r).rst_seq_tmr_ctl[0]=(((r).rst_seq_tmr_ctl[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9)) | (7 << (16 + 9))
#define BCMI_TSCE16_XGXS_RST_SEQ_TMR_CTLr_RST_SEQ_TIMERf_GET(r) (((r).rst_seq_tmr_ctl[0]) & 0x7)
#define BCMI_TSCE16_XGXS_RST_SEQ_TMR_CTLr_RST_SEQ_TIMERf_SET(r,f) (r).rst_seq_tmr_ctl[0]=(((r).rst_seq_tmr_ctl[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access RST_SEQ_TMR_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RST_SEQ_TMR_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RST_SEQ_TMR_CTLr,(_r._rst_seq_tmr_ctl))
#define BCMI_TSCE16_XGXS_WRITE_RST_SEQ_TMR_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RST_SEQ_TMR_CTLr,(_r._rst_seq_tmr_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RST_SEQ_TMR_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RST_SEQ_TMR_CTLr,(_r._rst_seq_tmr_ctl))
#define BCMI_TSCE16_XGXS_READLN_RST_SEQ_TMR_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RST_SEQ_TMR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rst_seq_tmr_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_RST_SEQ_TMR_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RST_SEQ_TMR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rst_seq_tmr_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_RST_SEQ_TMR_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RST_SEQ_TMR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rst_seq_tmr_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RST_SEQ_TMR_CTLr BCMI_TSCE16_XGXS_RST_SEQ_TMR_CTLr
#define RST_SEQ_TMR_CTLr_SIZE BCMI_TSCE16_XGXS_RST_SEQ_TMR_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_RST_SEQ_TMR_CTLr_t RST_SEQ_TMR_CTLr_t;
#define RST_SEQ_TMR_CTLr_CLR BCMI_TSCE16_XGXS_RST_SEQ_TMR_CTLr_CLR
#define RST_SEQ_TMR_CTLr_SET BCMI_TSCE16_XGXS_RST_SEQ_TMR_CTLr_SET
#define RST_SEQ_TMR_CTLr_GET BCMI_TSCE16_XGXS_RST_SEQ_TMR_CTLr_GET
#define RST_SEQ_TMR_CTLr_RST_SEQ_DIS_FLT_MODEf_GET BCMI_TSCE16_XGXS_RST_SEQ_TMR_CTLr_RST_SEQ_DIS_FLT_MODEf_GET
#define RST_SEQ_TMR_CTLr_RST_SEQ_DIS_FLT_MODEf_SET BCMI_TSCE16_XGXS_RST_SEQ_TMR_CTLr_RST_SEQ_DIS_FLT_MODEf_SET
#define RST_SEQ_TMR_CTLr_PWRDN_SEQ_TIMERf_GET BCMI_TSCE16_XGXS_RST_SEQ_TMR_CTLr_PWRDN_SEQ_TIMERf_GET
#define RST_SEQ_TMR_CTLr_PWRDN_SEQ_TIMERf_SET BCMI_TSCE16_XGXS_RST_SEQ_TMR_CTLr_PWRDN_SEQ_TIMERf_SET
#define RST_SEQ_TMR_CTLr_RST_SEQ_TIMERf_GET BCMI_TSCE16_XGXS_RST_SEQ_TMR_CTLr_RST_SEQ_TIMERf_GET
#define RST_SEQ_TMR_CTLr_RST_SEQ_TIMERf_SET BCMI_TSCE16_XGXS_RST_SEQ_TMR_CTLr_RST_SEQ_TIMERf_SET
#define READ_RST_SEQ_TMR_CTLr BCMI_TSCE16_XGXS_READ_RST_SEQ_TMR_CTLr
#define WRITE_RST_SEQ_TMR_CTLr BCMI_TSCE16_XGXS_WRITE_RST_SEQ_TMR_CTLr
#define MODIFY_RST_SEQ_TMR_CTLr BCMI_TSCE16_XGXS_MODIFY_RST_SEQ_TMR_CTLr
#define READLN_RST_SEQ_TMR_CTLr BCMI_TSCE16_XGXS_READLN_RST_SEQ_TMR_CTLr
#define WRITELN_RST_SEQ_TMR_CTLr BCMI_TSCE16_XGXS_WRITELN_RST_SEQ_TMR_CTLr
#define WRITEALL_RST_SEQ_TMR_CTLr BCMI_TSCE16_XGXS_WRITEALL_RST_SEQ_TMR_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RST_SEQ_TMR_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  CORE_DP_RST_ST_STS
 * BLOCKS:   DIGCOM
 * REGADDR:  0xd0f8
 * DESC:     CORE_DP_RESET_STATE_STATUS
 * RESETVAL: 0x7 (7)
 * ACCESS:   R/O
 * FIELDS:
 *     CORE_DP_RESET_STATE Bit 2: core_dp_reset_active   : Set to 1'b1 whenenver core_dp_reset is currently requested through any register or pin controls.Bit 1: core_dp_reset_occurred : Set to 1'b1 whenenver core_dp_reset is currently requested through any register or pin controls and is latched high.Bit 0: core_dp_reset_held     : Set to 1'b1 whenenver core_dp_reset is internally held. Cleared to 1'b0, only if core_dp_reset_state==001 and uc_ack_core_cfg_done == 1.
 *     TX_LANE_RESET_RELEASED_INDEX Index of the lane number of the first TX lane in lane_reset_released state.
 *     LANE_RESET_RELEASED_INDEX Index of the lane number of the first RX lane in lane_reset_released state.
 *     LANE_RESET_RELEASED indicates if a lane is currently at {rx_lane_dp_reset_active, rx_lane_dp_reset_occurred} = 01.
 *     TX_LANE_RESET_RELEASED indicates if a lane is currently at {tx_lane_dp_reset_active, tx_lane_dp_reset_occurred} = 01.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr (0x0000d0f8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr_SIZE 4

/*
 * This structure should be used to declare and program CORE_DP_RST_ST_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr_s {
	uint32_t v[1];
	uint32_t core_dp_rst_st_sts[1];
	uint32_t _core_dp_rst_st_sts;
} BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr_t;

#define BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr_CLR(r) (r).core_dp_rst_st_sts[0] = 0
#define BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr_SET(r,d) (r).core_dp_rst_st_sts[0] = d
#define BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr_GET(r) (r).core_dp_rst_st_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASEDf_GET(r) ((((r).core_dp_rst_st_sts[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASEDf_SET(r,f) (r).core_dp_rst_st_sts[0]=(((r).core_dp_rst_st_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_GET(r) ((((r).core_dp_rst_st_sts[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_SET(r,f) (r).core_dp_rst_st_sts[0]=(((r).core_dp_rst_st_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_GET(r) ((((r).core_dp_rst_st_sts[0]) >> 8) & 0x1f)
#define BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_SET(r,f) (r).core_dp_rst_st_sts[0]=(((r).core_dp_rst_st_sts[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASED_INDEXf_GET(r) ((((r).core_dp_rst_st_sts[0]) >> 3) & 0x1f)
#define BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASED_INDEXf_SET(r,f) (r).core_dp_rst_st_sts[0]=(((r).core_dp_rst_st_sts[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3)) | (31 << (16 + 3))
#define BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_GET(r) (((r).core_dp_rst_st_sts[0]) & 0x7)
#define BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_SET(r,f) (r).core_dp_rst_st_sts[0]=(((r).core_dp_rst_st_sts[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access CORE_DP_RST_ST_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_CORE_DP_RST_ST_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr,(_r._core_dp_rst_st_sts))
#define BCMI_TSCE16_XGXS_WRITE_CORE_DP_RST_ST_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr,(_r._core_dp_rst_st_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_CORE_DP_RST_ST_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr,(_r._core_dp_rst_st_sts))
#define BCMI_TSCE16_XGXS_READLN_CORE_DP_RST_ST_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._core_dp_rst_st_sts))
#define BCMI_TSCE16_XGXS_WRITELN_CORE_DP_RST_ST_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._core_dp_rst_st_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_CORE_DP_RST_ST_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._core_dp_rst_st_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CORE_DP_RST_ST_STSr BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr
#define CORE_DP_RST_ST_STSr_SIZE BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr_SIZE
typedef BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr_t CORE_DP_RST_ST_STSr_t;
#define CORE_DP_RST_ST_STSr_CLR BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr_CLR
#define CORE_DP_RST_ST_STSr_SET BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr_SET
#define CORE_DP_RST_ST_STSr_GET BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr_GET
#define CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASEDf_GET BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASEDf_GET
#define CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASEDf_SET BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASEDf_SET
#define CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_GET BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_GET
#define CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_SET BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_SET
#define CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_GET BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_GET
#define CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_SET BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_SET
#define CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASED_INDEXf_GET BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASED_INDEXf_GET
#define CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASED_INDEXf_SET BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASED_INDEXf_SET
#define CORE_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_GET BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_GET
#define CORE_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_SET BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_SET
#define READ_CORE_DP_RST_ST_STSr BCMI_TSCE16_XGXS_READ_CORE_DP_RST_ST_STSr
#define WRITE_CORE_DP_RST_ST_STSr BCMI_TSCE16_XGXS_WRITE_CORE_DP_RST_ST_STSr
#define MODIFY_CORE_DP_RST_ST_STSr BCMI_TSCE16_XGXS_MODIFY_CORE_DP_RST_ST_STSr
#define READLN_CORE_DP_RST_ST_STSr BCMI_TSCE16_XGXS_READLN_CORE_DP_RST_ST_STSr
#define WRITELN_CORE_DP_RST_ST_STSr BCMI_TSCE16_XGXS_WRITELN_CORE_DP_RST_ST_STSr
#define WRITEALL_CORE_DP_RST_ST_STSr BCMI_TSCE16_XGXS_WRITEALL_CORE_DP_RST_ST_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_CORE_DP_RST_ST_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PMD_CORE_MODE_STS
 * BLOCKS:   DIGCOM
 * REGADDR:  0xd0f9
 * DESC:     PMD_CORE_MODE_STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PMD_CORE_MODE    This indicates the status of the core input pin pmd_core_mode.This is driven from PCS and used for communication between PCS and PMD Micro code.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PMD_CORE_MODE_STSr (0x0000d0f9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PMD_CORE_MODE_STSr_SIZE 4

/*
 * This structure should be used to declare and program PMD_CORE_MODE_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_PMD_CORE_MODE_STSr_s {
	uint32_t v[1];
	uint32_t pmd_core_mode_sts[1];
	uint32_t _pmd_core_mode_sts;
} BCMI_TSCE16_XGXS_PMD_CORE_MODE_STSr_t;

#define BCMI_TSCE16_XGXS_PMD_CORE_MODE_STSr_CLR(r) (r).pmd_core_mode_sts[0] = 0
#define BCMI_TSCE16_XGXS_PMD_CORE_MODE_STSr_SET(r,d) (r).pmd_core_mode_sts[0] = d
#define BCMI_TSCE16_XGXS_PMD_CORE_MODE_STSr_GET(r) (r).pmd_core_mode_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PMD_CORE_MODE_STSr_PMD_CORE_MODEf_GET(r) (((r).pmd_core_mode_sts[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PMD_CORE_MODE_STSr_PMD_CORE_MODEf_SET(r,f) (r).pmd_core_mode_sts[0]=(((r).pmd_core_mode_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PMD_CORE_MODE_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PMD_CORE_MODE_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PMD_CORE_MODE_STSr,(_r._pmd_core_mode_sts))
#define BCMI_TSCE16_XGXS_WRITE_PMD_CORE_MODE_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_CORE_MODE_STSr,(_r._pmd_core_mode_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PMD_CORE_MODE_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_CORE_MODE_STSr,(_r._pmd_core_mode_sts))
#define BCMI_TSCE16_XGXS_READLN_PMD_CORE_MODE_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PMD_CORE_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_core_mode_sts))
#define BCMI_TSCE16_XGXS_WRITELN_PMD_CORE_MODE_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_CORE_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_core_mode_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_PMD_CORE_MODE_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PMD_CORE_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pmd_core_mode_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_CORE_MODE_STSr BCMI_TSCE16_XGXS_PMD_CORE_MODE_STSr
#define PMD_CORE_MODE_STSr_SIZE BCMI_TSCE16_XGXS_PMD_CORE_MODE_STSr_SIZE
typedef BCMI_TSCE16_XGXS_PMD_CORE_MODE_STSr_t PMD_CORE_MODE_STSr_t;
#define PMD_CORE_MODE_STSr_CLR BCMI_TSCE16_XGXS_PMD_CORE_MODE_STSr_CLR
#define PMD_CORE_MODE_STSr_SET BCMI_TSCE16_XGXS_PMD_CORE_MODE_STSr_SET
#define PMD_CORE_MODE_STSr_GET BCMI_TSCE16_XGXS_PMD_CORE_MODE_STSr_GET
#define PMD_CORE_MODE_STSr_PMD_CORE_MODEf_GET BCMI_TSCE16_XGXS_PMD_CORE_MODE_STSr_PMD_CORE_MODEf_GET
#define PMD_CORE_MODE_STSr_PMD_CORE_MODEf_SET BCMI_TSCE16_XGXS_PMD_CORE_MODE_STSr_PMD_CORE_MODEf_SET
#define READ_PMD_CORE_MODE_STSr BCMI_TSCE16_XGXS_READ_PMD_CORE_MODE_STSr
#define WRITE_PMD_CORE_MODE_STSr BCMI_TSCE16_XGXS_WRITE_PMD_CORE_MODE_STSr
#define MODIFY_PMD_CORE_MODE_STSr BCMI_TSCE16_XGXS_MODIFY_PMD_CORE_MODE_STSr
#define READLN_PMD_CORE_MODE_STSr BCMI_TSCE16_XGXS_READLN_PMD_CORE_MODE_STSr
#define WRITELN_PMD_CORE_MODE_STSr BCMI_TSCE16_XGXS_WRITELN_PMD_CORE_MODE_STSr
#define WRITEALL_PMD_CORE_MODE_STSr BCMI_TSCE16_XGXS_WRITEALL_PMD_CORE_MODE_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PMD_CORE_MODE_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  REVID1
 * BLOCKS:   DIGCOM
 * REGADDR:  0xd0fa
 * DESC:     REVID1
 * RESETVAL: 0x403c (16444)
 * ACCESS:   R/O
 * FIELDS:
 *     REVID_EEE        EEE support present in core
 *     REVID_LLP        Ultra low latency path present in core
 *     REVID_PIR        PCS interface retiming flops present in core
 *     REVID_CL72       Clause 72 present in core
 *     REVID_MICRO      Microcontroller present in core
 *     REVID_MDIO       MDIO interface present in core
 *     REVID_MULTIPLICITY Number of lanes
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_REVID1r (0x0000d0fa | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_REVID1r_SIZE 4

/*
 * This structure should be used to declare and program REVID1.
 *
 */
typedef union BCMI_TSCE16_XGXS_REVID1r_s {
	uint32_t v[1];
	uint32_t revid1[1];
	uint32_t _revid1;
} BCMI_TSCE16_XGXS_REVID1r_t;

#define BCMI_TSCE16_XGXS_REVID1r_CLR(r) (r).revid1[0] = 0
#define BCMI_TSCE16_XGXS_REVID1r_SET(r,d) (r).revid1[0] = d
#define BCMI_TSCE16_XGXS_REVID1r_GET(r) (r).revid1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_REVID1r_REVID_MULTIPLICITYf_GET(r) ((((r).revid1[0]) >> 12) & 0xf)
#define BCMI_TSCE16_XGXS_REVID1r_REVID_MULTIPLICITYf_SET(r,f) (r).revid1[0]=(((r).revid1[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCE16_XGXS_REVID1r_REVID_MDIOf_GET(r) ((((r).revid1[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_REVID1r_REVID_MDIOf_SET(r,f) (r).revid1[0]=(((r).revid1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_REVID1r_REVID_MICROf_GET(r) ((((r).revid1[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_REVID1r_REVID_MICROf_SET(r,f) (r).revid1[0]=(((r).revid1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_REVID1r_REVID_CL72f_GET(r) ((((r).revid1[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_REVID1r_REVID_CL72f_SET(r,f) (r).revid1[0]=(((r).revid1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_REVID1r_REVID_PIRf_GET(r) ((((r).revid1[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_REVID1r_REVID_PIRf_SET(r,f) (r).revid1[0]=(((r).revid1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_REVID1r_REVID_LLPf_GET(r) ((((r).revid1[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_REVID1r_REVID_LLPf_SET(r,f) (r).revid1[0]=(((r).revid1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_REVID1r_REVID_EEEf_GET(r) (((r).revid1[0]) & 0x1)
#define BCMI_TSCE16_XGXS_REVID1r_REVID_EEEf_SET(r,f) (r).revid1[0]=(((r).revid1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access REVID1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_REVID1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_REVID1r,(_r._revid1))
#define BCMI_TSCE16_XGXS_WRITE_REVID1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_REVID1r,(_r._revid1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_REVID1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_REVID1r,(_r._revid1))
#define BCMI_TSCE16_XGXS_READLN_REVID1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_REVID1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._revid1))
#define BCMI_TSCE16_XGXS_WRITELN_REVID1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_REVID1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._revid1))
#define BCMI_TSCE16_XGXS_WRITEALL_REVID1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_REVID1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._revid1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define REVID1r BCMI_TSCE16_XGXS_REVID1r
#define REVID1r_SIZE BCMI_TSCE16_XGXS_REVID1r_SIZE
typedef BCMI_TSCE16_XGXS_REVID1r_t REVID1r_t;
#define REVID1r_CLR BCMI_TSCE16_XGXS_REVID1r_CLR
#define REVID1r_SET BCMI_TSCE16_XGXS_REVID1r_SET
#define REVID1r_GET BCMI_TSCE16_XGXS_REVID1r_GET
#define REVID1r_REVID_MULTIPLICITYf_GET BCMI_TSCE16_XGXS_REVID1r_REVID_MULTIPLICITYf_GET
#define REVID1r_REVID_MULTIPLICITYf_SET BCMI_TSCE16_XGXS_REVID1r_REVID_MULTIPLICITYf_SET
#define REVID1r_REVID_MDIOf_GET BCMI_TSCE16_XGXS_REVID1r_REVID_MDIOf_GET
#define REVID1r_REVID_MDIOf_SET BCMI_TSCE16_XGXS_REVID1r_REVID_MDIOf_SET
#define REVID1r_REVID_MICROf_GET BCMI_TSCE16_XGXS_REVID1r_REVID_MICROf_GET
#define REVID1r_REVID_MICROf_SET BCMI_TSCE16_XGXS_REVID1r_REVID_MICROf_SET
#define REVID1r_REVID_CL72f_GET BCMI_TSCE16_XGXS_REVID1r_REVID_CL72f_GET
#define REVID1r_REVID_CL72f_SET BCMI_TSCE16_XGXS_REVID1r_REVID_CL72f_SET
#define REVID1r_REVID_PIRf_GET BCMI_TSCE16_XGXS_REVID1r_REVID_PIRf_GET
#define REVID1r_REVID_PIRf_SET BCMI_TSCE16_XGXS_REVID1r_REVID_PIRf_SET
#define REVID1r_REVID_LLPf_GET BCMI_TSCE16_XGXS_REVID1r_REVID_LLPf_GET
#define REVID1r_REVID_LLPf_SET BCMI_TSCE16_XGXS_REVID1r_REVID_LLPf_SET
#define REVID1r_REVID_EEEf_GET BCMI_TSCE16_XGXS_REVID1r_REVID_EEEf_GET
#define REVID1r_REVID_EEEf_SET BCMI_TSCE16_XGXS_REVID1r_REVID_EEEf_SET
#define READ_REVID1r BCMI_TSCE16_XGXS_READ_REVID1r
#define WRITE_REVID1r BCMI_TSCE16_XGXS_WRITE_REVID1r
#define MODIFY_REVID1r BCMI_TSCE16_XGXS_MODIFY_REVID1r
#define READLN_REVID1r BCMI_TSCE16_XGXS_READLN_REVID1r
#define WRITELN_REVID1r BCMI_TSCE16_XGXS_WRITELN_REVID1r
#define WRITEALL_REVID1r BCMI_TSCE16_XGXS_WRITEALL_REVID1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_REVID1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  REVID2
 * BLOCKS:   DIGCOM
 * REGADDR:  0xd0fe
 * DESC:     REVID2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     REVID2           Revision ID2 code
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_REVID2r (0x0000d0fe | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_REVID2r_SIZE 4

/*
 * This structure should be used to declare and program REVID2.
 *
 */
typedef union BCMI_TSCE16_XGXS_REVID2r_s {
	uint32_t v[1];
	uint32_t revid2[1];
	uint32_t _revid2;
} BCMI_TSCE16_XGXS_REVID2r_t;

#define BCMI_TSCE16_XGXS_REVID2r_CLR(r) (r).revid2[0] = 0
#define BCMI_TSCE16_XGXS_REVID2r_SET(r,d) (r).revid2[0] = d
#define BCMI_TSCE16_XGXS_REVID2r_GET(r) (r).revid2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_REVID2r_REVID2f_GET(r) (((r).revid2[0]) & 0xf)
#define BCMI_TSCE16_XGXS_REVID2r_REVID2f_SET(r,f) (r).revid2[0]=(((r).revid2[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access REVID2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_REVID2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_REVID2r,(_r._revid2))
#define BCMI_TSCE16_XGXS_WRITE_REVID2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_REVID2r,(_r._revid2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_REVID2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_REVID2r,(_r._revid2))
#define BCMI_TSCE16_XGXS_READLN_REVID2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_REVID2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._revid2))
#define BCMI_TSCE16_XGXS_WRITELN_REVID2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_REVID2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._revid2))
#define BCMI_TSCE16_XGXS_WRITEALL_REVID2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_REVID2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._revid2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define REVID2r BCMI_TSCE16_XGXS_REVID2r
#define REVID2r_SIZE BCMI_TSCE16_XGXS_REVID2r_SIZE
typedef BCMI_TSCE16_XGXS_REVID2r_t REVID2r_t;
#define REVID2r_CLR BCMI_TSCE16_XGXS_REVID2r_CLR
#define REVID2r_SET BCMI_TSCE16_XGXS_REVID2r_SET
#define REVID2r_GET BCMI_TSCE16_XGXS_REVID2r_GET
#define REVID2r_REVID2f_GET BCMI_TSCE16_XGXS_REVID2r_REVID2f_GET
#define REVID2r_REVID2f_SET BCMI_TSCE16_XGXS_REVID2r_REVID2f_SET
#define READ_REVID2r BCMI_TSCE16_XGXS_READ_REVID2r
#define WRITE_REVID2r BCMI_TSCE16_XGXS_WRITE_REVID2r
#define MODIFY_REVID2r BCMI_TSCE16_XGXS_MODIFY_REVID2r
#define READLN_REVID2r BCMI_TSCE16_XGXS_READLN_REVID2r
#define WRITELN_REVID2r BCMI_TSCE16_XGXS_WRITELN_REVID2r
#define WRITEALL_REVID2r BCMI_TSCE16_XGXS_WRITEALL_REVID2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_REVID2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PATT_GEN_SEQ0
 * BLOCKS:   PATT_GEN
 * REGADDR:  0xd100
 * DESC:     Pattern Generator Sequence Word 0
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_0   Fixed Pattern Generator Sequence Word 0. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode. This word will be transmitted last.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ0r (0x0000d100 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ0r_SIZE 4

/*
 * This structure should be used to declare and program PATT_GEN_SEQ0.
 *
 */
typedef union BCMI_TSCE16_XGXS_PATT_GEN_SEQ0r_s {
	uint32_t v[1];
	uint32_t patt_gen_seq0[1];
	uint32_t _patt_gen_seq0;
} BCMI_TSCE16_XGXS_PATT_GEN_SEQ0r_t;

#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ0r_CLR(r) (r).patt_gen_seq0[0] = 0
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ0r_SET(r,d) (r).patt_gen_seq0[0] = d
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ0r_GET(r) (r).patt_gen_seq0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ0r_PATT_GEN_SEQ_0f_GET(r) (((r).patt_gen_seq0[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ0r_PATT_GEN_SEQ_0f_SET(r,f) (r).patt_gen_seq0[0]=(((r).patt_gen_seq0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATT_GEN_SEQ0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PATT_GEN_SEQ0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ0r,(_r._patt_gen_seq0))
#define BCMI_TSCE16_XGXS_WRITE_PATT_GEN_SEQ0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ0r,(_r._patt_gen_seq0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PATT_GEN_SEQ0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ0r,(_r._patt_gen_seq0))
#define BCMI_TSCE16_XGXS_READLN_PATT_GEN_SEQ0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq0))
#define BCMI_TSCE16_XGXS_WRITELN_PATT_GEN_SEQ0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq0))
#define BCMI_TSCE16_XGXS_WRITEALL_PATT_GEN_SEQ0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patt_gen_seq0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATT_GEN_SEQ0r BCMI_TSCE16_XGXS_PATT_GEN_SEQ0r
#define PATT_GEN_SEQ0r_SIZE BCMI_TSCE16_XGXS_PATT_GEN_SEQ0r_SIZE
typedef BCMI_TSCE16_XGXS_PATT_GEN_SEQ0r_t PATT_GEN_SEQ0r_t;
#define PATT_GEN_SEQ0r_CLR BCMI_TSCE16_XGXS_PATT_GEN_SEQ0r_CLR
#define PATT_GEN_SEQ0r_SET BCMI_TSCE16_XGXS_PATT_GEN_SEQ0r_SET
#define PATT_GEN_SEQ0r_GET BCMI_TSCE16_XGXS_PATT_GEN_SEQ0r_GET
#define PATT_GEN_SEQ0r_PATT_GEN_SEQ_0f_GET BCMI_TSCE16_XGXS_PATT_GEN_SEQ0r_PATT_GEN_SEQ_0f_GET
#define PATT_GEN_SEQ0r_PATT_GEN_SEQ_0f_SET BCMI_TSCE16_XGXS_PATT_GEN_SEQ0r_PATT_GEN_SEQ_0f_SET
#define READ_PATT_GEN_SEQ0r BCMI_TSCE16_XGXS_READ_PATT_GEN_SEQ0r
#define WRITE_PATT_GEN_SEQ0r BCMI_TSCE16_XGXS_WRITE_PATT_GEN_SEQ0r
#define MODIFY_PATT_GEN_SEQ0r BCMI_TSCE16_XGXS_MODIFY_PATT_GEN_SEQ0r
#define READLN_PATT_GEN_SEQ0r BCMI_TSCE16_XGXS_READLN_PATT_GEN_SEQ0r
#define WRITELN_PATT_GEN_SEQ0r BCMI_TSCE16_XGXS_WRITELN_PATT_GEN_SEQ0r
#define WRITEALL_PATT_GEN_SEQ0r BCMI_TSCE16_XGXS_WRITEALL_PATT_GEN_SEQ0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PATT_GEN_SEQ0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PATT_GEN_SEQ1
 * BLOCKS:   PATT_GEN
 * REGADDR:  0xd101
 * DESC:     Pattern Generator Sequence Word 1
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_1   Fixed Pattern Generator Sequence Word 1. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ1r (0x0000d101 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ1r_SIZE 4

/*
 * This structure should be used to declare and program PATT_GEN_SEQ1.
 *
 */
typedef union BCMI_TSCE16_XGXS_PATT_GEN_SEQ1r_s {
	uint32_t v[1];
	uint32_t patt_gen_seq1[1];
	uint32_t _patt_gen_seq1;
} BCMI_TSCE16_XGXS_PATT_GEN_SEQ1r_t;

#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ1r_CLR(r) (r).patt_gen_seq1[0] = 0
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ1r_SET(r,d) (r).patt_gen_seq1[0] = d
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ1r_GET(r) (r).patt_gen_seq1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ1r_PATT_GEN_SEQ_1f_GET(r) (((r).patt_gen_seq1[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ1r_PATT_GEN_SEQ_1f_SET(r,f) (r).patt_gen_seq1[0]=(((r).patt_gen_seq1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATT_GEN_SEQ1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PATT_GEN_SEQ1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ1r,(_r._patt_gen_seq1))
#define BCMI_TSCE16_XGXS_WRITE_PATT_GEN_SEQ1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ1r,(_r._patt_gen_seq1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PATT_GEN_SEQ1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ1r,(_r._patt_gen_seq1))
#define BCMI_TSCE16_XGXS_READLN_PATT_GEN_SEQ1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq1))
#define BCMI_TSCE16_XGXS_WRITELN_PATT_GEN_SEQ1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq1))
#define BCMI_TSCE16_XGXS_WRITEALL_PATT_GEN_SEQ1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patt_gen_seq1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATT_GEN_SEQ1r BCMI_TSCE16_XGXS_PATT_GEN_SEQ1r
#define PATT_GEN_SEQ1r_SIZE BCMI_TSCE16_XGXS_PATT_GEN_SEQ1r_SIZE
typedef BCMI_TSCE16_XGXS_PATT_GEN_SEQ1r_t PATT_GEN_SEQ1r_t;
#define PATT_GEN_SEQ1r_CLR BCMI_TSCE16_XGXS_PATT_GEN_SEQ1r_CLR
#define PATT_GEN_SEQ1r_SET BCMI_TSCE16_XGXS_PATT_GEN_SEQ1r_SET
#define PATT_GEN_SEQ1r_GET BCMI_TSCE16_XGXS_PATT_GEN_SEQ1r_GET
#define PATT_GEN_SEQ1r_PATT_GEN_SEQ_1f_GET BCMI_TSCE16_XGXS_PATT_GEN_SEQ1r_PATT_GEN_SEQ_1f_GET
#define PATT_GEN_SEQ1r_PATT_GEN_SEQ_1f_SET BCMI_TSCE16_XGXS_PATT_GEN_SEQ1r_PATT_GEN_SEQ_1f_SET
#define READ_PATT_GEN_SEQ1r BCMI_TSCE16_XGXS_READ_PATT_GEN_SEQ1r
#define WRITE_PATT_GEN_SEQ1r BCMI_TSCE16_XGXS_WRITE_PATT_GEN_SEQ1r
#define MODIFY_PATT_GEN_SEQ1r BCMI_TSCE16_XGXS_MODIFY_PATT_GEN_SEQ1r
#define READLN_PATT_GEN_SEQ1r BCMI_TSCE16_XGXS_READLN_PATT_GEN_SEQ1r
#define WRITELN_PATT_GEN_SEQ1r BCMI_TSCE16_XGXS_WRITELN_PATT_GEN_SEQ1r
#define WRITEALL_PATT_GEN_SEQ1r BCMI_TSCE16_XGXS_WRITEALL_PATT_GEN_SEQ1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PATT_GEN_SEQ1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PATT_GEN_SEQ2
 * BLOCKS:   PATT_GEN
 * REGADDR:  0xd102
 * DESC:     Pattern Generator Sequence Word 2
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_2   Fixed Pattern Generator Sequence Word 2. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ2r (0x0000d102 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ2r_SIZE 4

/*
 * This structure should be used to declare and program PATT_GEN_SEQ2.
 *
 */
typedef union BCMI_TSCE16_XGXS_PATT_GEN_SEQ2r_s {
	uint32_t v[1];
	uint32_t patt_gen_seq2[1];
	uint32_t _patt_gen_seq2;
} BCMI_TSCE16_XGXS_PATT_GEN_SEQ2r_t;

#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ2r_CLR(r) (r).patt_gen_seq2[0] = 0
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ2r_SET(r,d) (r).patt_gen_seq2[0] = d
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ2r_GET(r) (r).patt_gen_seq2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ2r_PATT_GEN_SEQ_2f_GET(r) (((r).patt_gen_seq2[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ2r_PATT_GEN_SEQ_2f_SET(r,f) (r).patt_gen_seq2[0]=(((r).patt_gen_seq2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATT_GEN_SEQ2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PATT_GEN_SEQ2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ2r,(_r._patt_gen_seq2))
#define BCMI_TSCE16_XGXS_WRITE_PATT_GEN_SEQ2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ2r,(_r._patt_gen_seq2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PATT_GEN_SEQ2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ2r,(_r._patt_gen_seq2))
#define BCMI_TSCE16_XGXS_READLN_PATT_GEN_SEQ2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq2))
#define BCMI_TSCE16_XGXS_WRITELN_PATT_GEN_SEQ2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq2))
#define BCMI_TSCE16_XGXS_WRITEALL_PATT_GEN_SEQ2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patt_gen_seq2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATT_GEN_SEQ2r BCMI_TSCE16_XGXS_PATT_GEN_SEQ2r
#define PATT_GEN_SEQ2r_SIZE BCMI_TSCE16_XGXS_PATT_GEN_SEQ2r_SIZE
typedef BCMI_TSCE16_XGXS_PATT_GEN_SEQ2r_t PATT_GEN_SEQ2r_t;
#define PATT_GEN_SEQ2r_CLR BCMI_TSCE16_XGXS_PATT_GEN_SEQ2r_CLR
#define PATT_GEN_SEQ2r_SET BCMI_TSCE16_XGXS_PATT_GEN_SEQ2r_SET
#define PATT_GEN_SEQ2r_GET BCMI_TSCE16_XGXS_PATT_GEN_SEQ2r_GET
#define PATT_GEN_SEQ2r_PATT_GEN_SEQ_2f_GET BCMI_TSCE16_XGXS_PATT_GEN_SEQ2r_PATT_GEN_SEQ_2f_GET
#define PATT_GEN_SEQ2r_PATT_GEN_SEQ_2f_SET BCMI_TSCE16_XGXS_PATT_GEN_SEQ2r_PATT_GEN_SEQ_2f_SET
#define READ_PATT_GEN_SEQ2r BCMI_TSCE16_XGXS_READ_PATT_GEN_SEQ2r
#define WRITE_PATT_GEN_SEQ2r BCMI_TSCE16_XGXS_WRITE_PATT_GEN_SEQ2r
#define MODIFY_PATT_GEN_SEQ2r BCMI_TSCE16_XGXS_MODIFY_PATT_GEN_SEQ2r
#define READLN_PATT_GEN_SEQ2r BCMI_TSCE16_XGXS_READLN_PATT_GEN_SEQ2r
#define WRITELN_PATT_GEN_SEQ2r BCMI_TSCE16_XGXS_WRITELN_PATT_GEN_SEQ2r
#define WRITEALL_PATT_GEN_SEQ2r BCMI_TSCE16_XGXS_WRITEALL_PATT_GEN_SEQ2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PATT_GEN_SEQ2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PATT_GEN_SEQ3
 * BLOCKS:   PATT_GEN
 * REGADDR:  0xd103
 * DESC:     Pattern Generator Sequence Word 3
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_3   Fixed Pattern Generator Sequence Word 3. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ3r (0x0000d103 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ3r_SIZE 4

/*
 * This structure should be used to declare and program PATT_GEN_SEQ3.
 *
 */
typedef union BCMI_TSCE16_XGXS_PATT_GEN_SEQ3r_s {
	uint32_t v[1];
	uint32_t patt_gen_seq3[1];
	uint32_t _patt_gen_seq3;
} BCMI_TSCE16_XGXS_PATT_GEN_SEQ3r_t;

#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ3r_CLR(r) (r).patt_gen_seq3[0] = 0
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ3r_SET(r,d) (r).patt_gen_seq3[0] = d
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ3r_GET(r) (r).patt_gen_seq3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ3r_PATT_GEN_SEQ_3f_GET(r) (((r).patt_gen_seq3[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ3r_PATT_GEN_SEQ_3f_SET(r,f) (r).patt_gen_seq3[0]=(((r).patt_gen_seq3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATT_GEN_SEQ3.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PATT_GEN_SEQ3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ3r,(_r._patt_gen_seq3))
#define BCMI_TSCE16_XGXS_WRITE_PATT_GEN_SEQ3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ3r,(_r._patt_gen_seq3)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PATT_GEN_SEQ3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ3r,(_r._patt_gen_seq3))
#define BCMI_TSCE16_XGXS_READLN_PATT_GEN_SEQ3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq3))
#define BCMI_TSCE16_XGXS_WRITELN_PATT_GEN_SEQ3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq3))
#define BCMI_TSCE16_XGXS_WRITEALL_PATT_GEN_SEQ3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patt_gen_seq3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATT_GEN_SEQ3r BCMI_TSCE16_XGXS_PATT_GEN_SEQ3r
#define PATT_GEN_SEQ3r_SIZE BCMI_TSCE16_XGXS_PATT_GEN_SEQ3r_SIZE
typedef BCMI_TSCE16_XGXS_PATT_GEN_SEQ3r_t PATT_GEN_SEQ3r_t;
#define PATT_GEN_SEQ3r_CLR BCMI_TSCE16_XGXS_PATT_GEN_SEQ3r_CLR
#define PATT_GEN_SEQ3r_SET BCMI_TSCE16_XGXS_PATT_GEN_SEQ3r_SET
#define PATT_GEN_SEQ3r_GET BCMI_TSCE16_XGXS_PATT_GEN_SEQ3r_GET
#define PATT_GEN_SEQ3r_PATT_GEN_SEQ_3f_GET BCMI_TSCE16_XGXS_PATT_GEN_SEQ3r_PATT_GEN_SEQ_3f_GET
#define PATT_GEN_SEQ3r_PATT_GEN_SEQ_3f_SET BCMI_TSCE16_XGXS_PATT_GEN_SEQ3r_PATT_GEN_SEQ_3f_SET
#define READ_PATT_GEN_SEQ3r BCMI_TSCE16_XGXS_READ_PATT_GEN_SEQ3r
#define WRITE_PATT_GEN_SEQ3r BCMI_TSCE16_XGXS_WRITE_PATT_GEN_SEQ3r
#define MODIFY_PATT_GEN_SEQ3r BCMI_TSCE16_XGXS_MODIFY_PATT_GEN_SEQ3r
#define READLN_PATT_GEN_SEQ3r BCMI_TSCE16_XGXS_READLN_PATT_GEN_SEQ3r
#define WRITELN_PATT_GEN_SEQ3r BCMI_TSCE16_XGXS_WRITELN_PATT_GEN_SEQ3r
#define WRITEALL_PATT_GEN_SEQ3r BCMI_TSCE16_XGXS_WRITEALL_PATT_GEN_SEQ3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PATT_GEN_SEQ3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PATT_GEN_SEQ4
 * BLOCKS:   PATT_GEN
 * REGADDR:  0xd104
 * DESC:     Pattern Generator Sequence Word 4
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_4   Fixed Pattern Generator Sequence Word 4. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ4r (0x0000d104 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ4r_SIZE 4

/*
 * This structure should be used to declare and program PATT_GEN_SEQ4.
 *
 */
typedef union BCMI_TSCE16_XGXS_PATT_GEN_SEQ4r_s {
	uint32_t v[1];
	uint32_t patt_gen_seq4[1];
	uint32_t _patt_gen_seq4;
} BCMI_TSCE16_XGXS_PATT_GEN_SEQ4r_t;

#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ4r_CLR(r) (r).patt_gen_seq4[0] = 0
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ4r_SET(r,d) (r).patt_gen_seq4[0] = d
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ4r_GET(r) (r).patt_gen_seq4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ4r_PATT_GEN_SEQ_4f_GET(r) (((r).patt_gen_seq4[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ4r_PATT_GEN_SEQ_4f_SET(r,f) (r).patt_gen_seq4[0]=(((r).patt_gen_seq4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATT_GEN_SEQ4.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PATT_GEN_SEQ4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ4r,(_r._patt_gen_seq4))
#define BCMI_TSCE16_XGXS_WRITE_PATT_GEN_SEQ4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ4r,(_r._patt_gen_seq4)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PATT_GEN_SEQ4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ4r,(_r._patt_gen_seq4))
#define BCMI_TSCE16_XGXS_READLN_PATT_GEN_SEQ4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq4))
#define BCMI_TSCE16_XGXS_WRITELN_PATT_GEN_SEQ4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq4))
#define BCMI_TSCE16_XGXS_WRITEALL_PATT_GEN_SEQ4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patt_gen_seq4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATT_GEN_SEQ4r BCMI_TSCE16_XGXS_PATT_GEN_SEQ4r
#define PATT_GEN_SEQ4r_SIZE BCMI_TSCE16_XGXS_PATT_GEN_SEQ4r_SIZE
typedef BCMI_TSCE16_XGXS_PATT_GEN_SEQ4r_t PATT_GEN_SEQ4r_t;
#define PATT_GEN_SEQ4r_CLR BCMI_TSCE16_XGXS_PATT_GEN_SEQ4r_CLR
#define PATT_GEN_SEQ4r_SET BCMI_TSCE16_XGXS_PATT_GEN_SEQ4r_SET
#define PATT_GEN_SEQ4r_GET BCMI_TSCE16_XGXS_PATT_GEN_SEQ4r_GET
#define PATT_GEN_SEQ4r_PATT_GEN_SEQ_4f_GET BCMI_TSCE16_XGXS_PATT_GEN_SEQ4r_PATT_GEN_SEQ_4f_GET
#define PATT_GEN_SEQ4r_PATT_GEN_SEQ_4f_SET BCMI_TSCE16_XGXS_PATT_GEN_SEQ4r_PATT_GEN_SEQ_4f_SET
#define READ_PATT_GEN_SEQ4r BCMI_TSCE16_XGXS_READ_PATT_GEN_SEQ4r
#define WRITE_PATT_GEN_SEQ4r BCMI_TSCE16_XGXS_WRITE_PATT_GEN_SEQ4r
#define MODIFY_PATT_GEN_SEQ4r BCMI_TSCE16_XGXS_MODIFY_PATT_GEN_SEQ4r
#define READLN_PATT_GEN_SEQ4r BCMI_TSCE16_XGXS_READLN_PATT_GEN_SEQ4r
#define WRITELN_PATT_GEN_SEQ4r BCMI_TSCE16_XGXS_WRITELN_PATT_GEN_SEQ4r
#define WRITEALL_PATT_GEN_SEQ4r BCMI_TSCE16_XGXS_WRITEALL_PATT_GEN_SEQ4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PATT_GEN_SEQ4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PATT_GEN_SEQ5
 * BLOCKS:   PATT_GEN
 * REGADDR:  0xd105
 * DESC:     Pattern Generator Sequence Word 5
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_5   Fixed Pattern Generator Sequence Word 5. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ5r (0x0000d105 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ5r_SIZE 4

/*
 * This structure should be used to declare and program PATT_GEN_SEQ5.
 *
 */
typedef union BCMI_TSCE16_XGXS_PATT_GEN_SEQ5r_s {
	uint32_t v[1];
	uint32_t patt_gen_seq5[1];
	uint32_t _patt_gen_seq5;
} BCMI_TSCE16_XGXS_PATT_GEN_SEQ5r_t;

#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ5r_CLR(r) (r).patt_gen_seq5[0] = 0
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ5r_SET(r,d) (r).patt_gen_seq5[0] = d
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ5r_GET(r) (r).patt_gen_seq5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ5r_PATT_GEN_SEQ_5f_GET(r) (((r).patt_gen_seq5[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ5r_PATT_GEN_SEQ_5f_SET(r,f) (r).patt_gen_seq5[0]=(((r).patt_gen_seq5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATT_GEN_SEQ5.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PATT_GEN_SEQ5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ5r,(_r._patt_gen_seq5))
#define BCMI_TSCE16_XGXS_WRITE_PATT_GEN_SEQ5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ5r,(_r._patt_gen_seq5)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PATT_GEN_SEQ5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ5r,(_r._patt_gen_seq5))
#define BCMI_TSCE16_XGXS_READLN_PATT_GEN_SEQ5r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq5))
#define BCMI_TSCE16_XGXS_WRITELN_PATT_GEN_SEQ5r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq5))
#define BCMI_TSCE16_XGXS_WRITEALL_PATT_GEN_SEQ5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patt_gen_seq5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATT_GEN_SEQ5r BCMI_TSCE16_XGXS_PATT_GEN_SEQ5r
#define PATT_GEN_SEQ5r_SIZE BCMI_TSCE16_XGXS_PATT_GEN_SEQ5r_SIZE
typedef BCMI_TSCE16_XGXS_PATT_GEN_SEQ5r_t PATT_GEN_SEQ5r_t;
#define PATT_GEN_SEQ5r_CLR BCMI_TSCE16_XGXS_PATT_GEN_SEQ5r_CLR
#define PATT_GEN_SEQ5r_SET BCMI_TSCE16_XGXS_PATT_GEN_SEQ5r_SET
#define PATT_GEN_SEQ5r_GET BCMI_TSCE16_XGXS_PATT_GEN_SEQ5r_GET
#define PATT_GEN_SEQ5r_PATT_GEN_SEQ_5f_GET BCMI_TSCE16_XGXS_PATT_GEN_SEQ5r_PATT_GEN_SEQ_5f_GET
#define PATT_GEN_SEQ5r_PATT_GEN_SEQ_5f_SET BCMI_TSCE16_XGXS_PATT_GEN_SEQ5r_PATT_GEN_SEQ_5f_SET
#define READ_PATT_GEN_SEQ5r BCMI_TSCE16_XGXS_READ_PATT_GEN_SEQ5r
#define WRITE_PATT_GEN_SEQ5r BCMI_TSCE16_XGXS_WRITE_PATT_GEN_SEQ5r
#define MODIFY_PATT_GEN_SEQ5r BCMI_TSCE16_XGXS_MODIFY_PATT_GEN_SEQ5r
#define READLN_PATT_GEN_SEQ5r BCMI_TSCE16_XGXS_READLN_PATT_GEN_SEQ5r
#define WRITELN_PATT_GEN_SEQ5r BCMI_TSCE16_XGXS_WRITELN_PATT_GEN_SEQ5r
#define WRITEALL_PATT_GEN_SEQ5r BCMI_TSCE16_XGXS_WRITEALL_PATT_GEN_SEQ5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PATT_GEN_SEQ5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PATT_GEN_SEQ6
 * BLOCKS:   PATT_GEN
 * REGADDR:  0xd106
 * DESC:     Pattern Generator Sequence Word 6
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_6   Fixed Pattern Generator Sequence Word 6. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ6r (0x0000d106 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ6r_SIZE 4

/*
 * This structure should be used to declare and program PATT_GEN_SEQ6.
 *
 */
typedef union BCMI_TSCE16_XGXS_PATT_GEN_SEQ6r_s {
	uint32_t v[1];
	uint32_t patt_gen_seq6[1];
	uint32_t _patt_gen_seq6;
} BCMI_TSCE16_XGXS_PATT_GEN_SEQ6r_t;

#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ6r_CLR(r) (r).patt_gen_seq6[0] = 0
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ6r_SET(r,d) (r).patt_gen_seq6[0] = d
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ6r_GET(r) (r).patt_gen_seq6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ6r_PATT_GEN_SEQ_6f_GET(r) (((r).patt_gen_seq6[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ6r_PATT_GEN_SEQ_6f_SET(r,f) (r).patt_gen_seq6[0]=(((r).patt_gen_seq6[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATT_GEN_SEQ6.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PATT_GEN_SEQ6r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ6r,(_r._patt_gen_seq6))
#define BCMI_TSCE16_XGXS_WRITE_PATT_GEN_SEQ6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ6r,(_r._patt_gen_seq6)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PATT_GEN_SEQ6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ6r,(_r._patt_gen_seq6))
#define BCMI_TSCE16_XGXS_READLN_PATT_GEN_SEQ6r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq6))
#define BCMI_TSCE16_XGXS_WRITELN_PATT_GEN_SEQ6r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq6))
#define BCMI_TSCE16_XGXS_WRITEALL_PATT_GEN_SEQ6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patt_gen_seq6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATT_GEN_SEQ6r BCMI_TSCE16_XGXS_PATT_GEN_SEQ6r
#define PATT_GEN_SEQ6r_SIZE BCMI_TSCE16_XGXS_PATT_GEN_SEQ6r_SIZE
typedef BCMI_TSCE16_XGXS_PATT_GEN_SEQ6r_t PATT_GEN_SEQ6r_t;
#define PATT_GEN_SEQ6r_CLR BCMI_TSCE16_XGXS_PATT_GEN_SEQ6r_CLR
#define PATT_GEN_SEQ6r_SET BCMI_TSCE16_XGXS_PATT_GEN_SEQ6r_SET
#define PATT_GEN_SEQ6r_GET BCMI_TSCE16_XGXS_PATT_GEN_SEQ6r_GET
#define PATT_GEN_SEQ6r_PATT_GEN_SEQ_6f_GET BCMI_TSCE16_XGXS_PATT_GEN_SEQ6r_PATT_GEN_SEQ_6f_GET
#define PATT_GEN_SEQ6r_PATT_GEN_SEQ_6f_SET BCMI_TSCE16_XGXS_PATT_GEN_SEQ6r_PATT_GEN_SEQ_6f_SET
#define READ_PATT_GEN_SEQ6r BCMI_TSCE16_XGXS_READ_PATT_GEN_SEQ6r
#define WRITE_PATT_GEN_SEQ6r BCMI_TSCE16_XGXS_WRITE_PATT_GEN_SEQ6r
#define MODIFY_PATT_GEN_SEQ6r BCMI_TSCE16_XGXS_MODIFY_PATT_GEN_SEQ6r
#define READLN_PATT_GEN_SEQ6r BCMI_TSCE16_XGXS_READLN_PATT_GEN_SEQ6r
#define WRITELN_PATT_GEN_SEQ6r BCMI_TSCE16_XGXS_WRITELN_PATT_GEN_SEQ6r
#define WRITEALL_PATT_GEN_SEQ6r BCMI_TSCE16_XGXS_WRITEALL_PATT_GEN_SEQ6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PATT_GEN_SEQ6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PATT_GEN_SEQ7
 * BLOCKS:   PATT_GEN
 * REGADDR:  0xd107
 * DESC:     Pattern Generator Sequence Word 7
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_7   Fixed Pattern Generator Sequence Word 7. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ7r (0x0000d107 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ7r_SIZE 4

/*
 * This structure should be used to declare and program PATT_GEN_SEQ7.
 *
 */
typedef union BCMI_TSCE16_XGXS_PATT_GEN_SEQ7r_s {
	uint32_t v[1];
	uint32_t patt_gen_seq7[1];
	uint32_t _patt_gen_seq7;
} BCMI_TSCE16_XGXS_PATT_GEN_SEQ7r_t;

#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ7r_CLR(r) (r).patt_gen_seq7[0] = 0
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ7r_SET(r,d) (r).patt_gen_seq7[0] = d
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ7r_GET(r) (r).patt_gen_seq7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ7r_PATT_GEN_SEQ_7f_GET(r) (((r).patt_gen_seq7[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ7r_PATT_GEN_SEQ_7f_SET(r,f) (r).patt_gen_seq7[0]=(((r).patt_gen_seq7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATT_GEN_SEQ7.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PATT_GEN_SEQ7r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ7r,(_r._patt_gen_seq7))
#define BCMI_TSCE16_XGXS_WRITE_PATT_GEN_SEQ7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ7r,(_r._patt_gen_seq7)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PATT_GEN_SEQ7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ7r,(_r._patt_gen_seq7))
#define BCMI_TSCE16_XGXS_READLN_PATT_GEN_SEQ7r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq7))
#define BCMI_TSCE16_XGXS_WRITELN_PATT_GEN_SEQ7r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq7))
#define BCMI_TSCE16_XGXS_WRITEALL_PATT_GEN_SEQ7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ7r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patt_gen_seq7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATT_GEN_SEQ7r BCMI_TSCE16_XGXS_PATT_GEN_SEQ7r
#define PATT_GEN_SEQ7r_SIZE BCMI_TSCE16_XGXS_PATT_GEN_SEQ7r_SIZE
typedef BCMI_TSCE16_XGXS_PATT_GEN_SEQ7r_t PATT_GEN_SEQ7r_t;
#define PATT_GEN_SEQ7r_CLR BCMI_TSCE16_XGXS_PATT_GEN_SEQ7r_CLR
#define PATT_GEN_SEQ7r_SET BCMI_TSCE16_XGXS_PATT_GEN_SEQ7r_SET
#define PATT_GEN_SEQ7r_GET BCMI_TSCE16_XGXS_PATT_GEN_SEQ7r_GET
#define PATT_GEN_SEQ7r_PATT_GEN_SEQ_7f_GET BCMI_TSCE16_XGXS_PATT_GEN_SEQ7r_PATT_GEN_SEQ_7f_GET
#define PATT_GEN_SEQ7r_PATT_GEN_SEQ_7f_SET BCMI_TSCE16_XGXS_PATT_GEN_SEQ7r_PATT_GEN_SEQ_7f_SET
#define READ_PATT_GEN_SEQ7r BCMI_TSCE16_XGXS_READ_PATT_GEN_SEQ7r
#define WRITE_PATT_GEN_SEQ7r BCMI_TSCE16_XGXS_WRITE_PATT_GEN_SEQ7r
#define MODIFY_PATT_GEN_SEQ7r BCMI_TSCE16_XGXS_MODIFY_PATT_GEN_SEQ7r
#define READLN_PATT_GEN_SEQ7r BCMI_TSCE16_XGXS_READLN_PATT_GEN_SEQ7r
#define WRITELN_PATT_GEN_SEQ7r BCMI_TSCE16_XGXS_WRITELN_PATT_GEN_SEQ7r
#define WRITEALL_PATT_GEN_SEQ7r BCMI_TSCE16_XGXS_WRITEALL_PATT_GEN_SEQ7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PATT_GEN_SEQ7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PATT_GEN_SEQ8
 * BLOCKS:   PATT_GEN
 * REGADDR:  0xd108
 * DESC:     Pattern Generator Sequence Word 8
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_8   Fixed Pattern Generator Sequence Word 8. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ8r (0x0000d108 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ8r_SIZE 4

/*
 * This structure should be used to declare and program PATT_GEN_SEQ8.
 *
 */
typedef union BCMI_TSCE16_XGXS_PATT_GEN_SEQ8r_s {
	uint32_t v[1];
	uint32_t patt_gen_seq8[1];
	uint32_t _patt_gen_seq8;
} BCMI_TSCE16_XGXS_PATT_GEN_SEQ8r_t;

#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ8r_CLR(r) (r).patt_gen_seq8[0] = 0
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ8r_SET(r,d) (r).patt_gen_seq8[0] = d
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ8r_GET(r) (r).patt_gen_seq8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ8r_PATT_GEN_SEQ_8f_GET(r) (((r).patt_gen_seq8[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ8r_PATT_GEN_SEQ_8f_SET(r,f) (r).patt_gen_seq8[0]=(((r).patt_gen_seq8[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATT_GEN_SEQ8.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PATT_GEN_SEQ8r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ8r,(_r._patt_gen_seq8))
#define BCMI_TSCE16_XGXS_WRITE_PATT_GEN_SEQ8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ8r,(_r._patt_gen_seq8)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PATT_GEN_SEQ8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ8r,(_r._patt_gen_seq8))
#define BCMI_TSCE16_XGXS_READLN_PATT_GEN_SEQ8r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq8))
#define BCMI_TSCE16_XGXS_WRITELN_PATT_GEN_SEQ8r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq8))
#define BCMI_TSCE16_XGXS_WRITEALL_PATT_GEN_SEQ8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ8r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patt_gen_seq8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATT_GEN_SEQ8r BCMI_TSCE16_XGXS_PATT_GEN_SEQ8r
#define PATT_GEN_SEQ8r_SIZE BCMI_TSCE16_XGXS_PATT_GEN_SEQ8r_SIZE
typedef BCMI_TSCE16_XGXS_PATT_GEN_SEQ8r_t PATT_GEN_SEQ8r_t;
#define PATT_GEN_SEQ8r_CLR BCMI_TSCE16_XGXS_PATT_GEN_SEQ8r_CLR
#define PATT_GEN_SEQ8r_SET BCMI_TSCE16_XGXS_PATT_GEN_SEQ8r_SET
#define PATT_GEN_SEQ8r_GET BCMI_TSCE16_XGXS_PATT_GEN_SEQ8r_GET
#define PATT_GEN_SEQ8r_PATT_GEN_SEQ_8f_GET BCMI_TSCE16_XGXS_PATT_GEN_SEQ8r_PATT_GEN_SEQ_8f_GET
#define PATT_GEN_SEQ8r_PATT_GEN_SEQ_8f_SET BCMI_TSCE16_XGXS_PATT_GEN_SEQ8r_PATT_GEN_SEQ_8f_SET
#define READ_PATT_GEN_SEQ8r BCMI_TSCE16_XGXS_READ_PATT_GEN_SEQ8r
#define WRITE_PATT_GEN_SEQ8r BCMI_TSCE16_XGXS_WRITE_PATT_GEN_SEQ8r
#define MODIFY_PATT_GEN_SEQ8r BCMI_TSCE16_XGXS_MODIFY_PATT_GEN_SEQ8r
#define READLN_PATT_GEN_SEQ8r BCMI_TSCE16_XGXS_READLN_PATT_GEN_SEQ8r
#define WRITELN_PATT_GEN_SEQ8r BCMI_TSCE16_XGXS_WRITELN_PATT_GEN_SEQ8r
#define WRITEALL_PATT_GEN_SEQ8r BCMI_TSCE16_XGXS_WRITEALL_PATT_GEN_SEQ8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PATT_GEN_SEQ8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PATT_GEN_SEQ9
 * BLOCKS:   PATT_GEN
 * REGADDR:  0xd109
 * DESC:     Pattern Generator Sequence Word 9
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_9   Fixed Pattern Generator Sequence Word 9. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ9r (0x0000d109 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ9r_SIZE 4

/*
 * This structure should be used to declare and program PATT_GEN_SEQ9.
 *
 */
typedef union BCMI_TSCE16_XGXS_PATT_GEN_SEQ9r_s {
	uint32_t v[1];
	uint32_t patt_gen_seq9[1];
	uint32_t _patt_gen_seq9;
} BCMI_TSCE16_XGXS_PATT_GEN_SEQ9r_t;

#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ9r_CLR(r) (r).patt_gen_seq9[0] = 0
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ9r_SET(r,d) (r).patt_gen_seq9[0] = d
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ9r_GET(r) (r).patt_gen_seq9[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ9r_PATT_GEN_SEQ_9f_GET(r) (((r).patt_gen_seq9[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ9r_PATT_GEN_SEQ_9f_SET(r,f) (r).patt_gen_seq9[0]=(((r).patt_gen_seq9[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATT_GEN_SEQ9.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PATT_GEN_SEQ9r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ9r,(_r._patt_gen_seq9))
#define BCMI_TSCE16_XGXS_WRITE_PATT_GEN_SEQ9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ9r,(_r._patt_gen_seq9)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PATT_GEN_SEQ9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ9r,(_r._patt_gen_seq9))
#define BCMI_TSCE16_XGXS_READLN_PATT_GEN_SEQ9r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq9))
#define BCMI_TSCE16_XGXS_WRITELN_PATT_GEN_SEQ9r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq9))
#define BCMI_TSCE16_XGXS_WRITEALL_PATT_GEN_SEQ9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ9r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patt_gen_seq9))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATT_GEN_SEQ9r BCMI_TSCE16_XGXS_PATT_GEN_SEQ9r
#define PATT_GEN_SEQ9r_SIZE BCMI_TSCE16_XGXS_PATT_GEN_SEQ9r_SIZE
typedef BCMI_TSCE16_XGXS_PATT_GEN_SEQ9r_t PATT_GEN_SEQ9r_t;
#define PATT_GEN_SEQ9r_CLR BCMI_TSCE16_XGXS_PATT_GEN_SEQ9r_CLR
#define PATT_GEN_SEQ9r_SET BCMI_TSCE16_XGXS_PATT_GEN_SEQ9r_SET
#define PATT_GEN_SEQ9r_GET BCMI_TSCE16_XGXS_PATT_GEN_SEQ9r_GET
#define PATT_GEN_SEQ9r_PATT_GEN_SEQ_9f_GET BCMI_TSCE16_XGXS_PATT_GEN_SEQ9r_PATT_GEN_SEQ_9f_GET
#define PATT_GEN_SEQ9r_PATT_GEN_SEQ_9f_SET BCMI_TSCE16_XGXS_PATT_GEN_SEQ9r_PATT_GEN_SEQ_9f_SET
#define READ_PATT_GEN_SEQ9r BCMI_TSCE16_XGXS_READ_PATT_GEN_SEQ9r
#define WRITE_PATT_GEN_SEQ9r BCMI_TSCE16_XGXS_WRITE_PATT_GEN_SEQ9r
#define MODIFY_PATT_GEN_SEQ9r BCMI_TSCE16_XGXS_MODIFY_PATT_GEN_SEQ9r
#define READLN_PATT_GEN_SEQ9r BCMI_TSCE16_XGXS_READLN_PATT_GEN_SEQ9r
#define WRITELN_PATT_GEN_SEQ9r BCMI_TSCE16_XGXS_WRITELN_PATT_GEN_SEQ9r
#define WRITEALL_PATT_GEN_SEQ9r BCMI_TSCE16_XGXS_WRITEALL_PATT_GEN_SEQ9r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PATT_GEN_SEQ9r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PATT_GEN_SEQ_10
 * BLOCKS:   PATT_GEN
 * REGADDR:  0xd10a
 * DESC:     Pattern Generator Sequence Word 10
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_10  Fixed Pattern Generator Sequence Word 10. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ_10r (0x0000d10a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ_10r_SIZE 4

/*
 * This structure should be used to declare and program PATT_GEN_SEQ_10.
 *
 */
typedef union BCMI_TSCE16_XGXS_PATT_GEN_SEQ_10r_s {
	uint32_t v[1];
	uint32_t patt_gen_seq_10[1];
	uint32_t _patt_gen_seq_10;
} BCMI_TSCE16_XGXS_PATT_GEN_SEQ_10r_t;

#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ_10r_CLR(r) (r).patt_gen_seq_10[0] = 0
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ_10r_SET(r,d) (r).patt_gen_seq_10[0] = d
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ_10r_GET(r) (r).patt_gen_seq_10[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ_10r_PATT_GEN_SEQ_10f_GET(r) (((r).patt_gen_seq_10[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ_10r_PATT_GEN_SEQ_10f_SET(r,f) (r).patt_gen_seq_10[0]=(((r).patt_gen_seq_10[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATT_GEN_SEQ_10.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PATT_GEN_SEQ_10r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ_10r,(_r._patt_gen_seq_10))
#define BCMI_TSCE16_XGXS_WRITE_PATT_GEN_SEQ_10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ_10r,(_r._patt_gen_seq_10)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PATT_GEN_SEQ_10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ_10r,(_r._patt_gen_seq_10))
#define BCMI_TSCE16_XGXS_READLN_PATT_GEN_SEQ_10r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ_10r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq_10))
#define BCMI_TSCE16_XGXS_WRITELN_PATT_GEN_SEQ_10r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ_10r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq_10))
#define BCMI_TSCE16_XGXS_WRITEALL_PATT_GEN_SEQ_10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ_10r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patt_gen_seq_10))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATT_GEN_SEQ_10r BCMI_TSCE16_XGXS_PATT_GEN_SEQ_10r
#define PATT_GEN_SEQ_10r_SIZE BCMI_TSCE16_XGXS_PATT_GEN_SEQ_10r_SIZE
typedef BCMI_TSCE16_XGXS_PATT_GEN_SEQ_10r_t PATT_GEN_SEQ_10r_t;
#define PATT_GEN_SEQ_10r_CLR BCMI_TSCE16_XGXS_PATT_GEN_SEQ_10r_CLR
#define PATT_GEN_SEQ_10r_SET BCMI_TSCE16_XGXS_PATT_GEN_SEQ_10r_SET
#define PATT_GEN_SEQ_10r_GET BCMI_TSCE16_XGXS_PATT_GEN_SEQ_10r_GET
#define PATT_GEN_SEQ_10r_PATT_GEN_SEQ_10f_GET BCMI_TSCE16_XGXS_PATT_GEN_SEQ_10r_PATT_GEN_SEQ_10f_GET
#define PATT_GEN_SEQ_10r_PATT_GEN_SEQ_10f_SET BCMI_TSCE16_XGXS_PATT_GEN_SEQ_10r_PATT_GEN_SEQ_10f_SET
#define READ_PATT_GEN_SEQ_10r BCMI_TSCE16_XGXS_READ_PATT_GEN_SEQ_10r
#define WRITE_PATT_GEN_SEQ_10r BCMI_TSCE16_XGXS_WRITE_PATT_GEN_SEQ_10r
#define MODIFY_PATT_GEN_SEQ_10r BCMI_TSCE16_XGXS_MODIFY_PATT_GEN_SEQ_10r
#define READLN_PATT_GEN_SEQ_10r BCMI_TSCE16_XGXS_READLN_PATT_GEN_SEQ_10r
#define WRITELN_PATT_GEN_SEQ_10r BCMI_TSCE16_XGXS_WRITELN_PATT_GEN_SEQ_10r
#define WRITEALL_PATT_GEN_SEQ_10r BCMI_TSCE16_XGXS_WRITEALL_PATT_GEN_SEQ_10r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PATT_GEN_SEQ_10r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PATT_GEN_SEQ_11
 * BLOCKS:   PATT_GEN
 * REGADDR:  0xd10b
 * DESC:     Pattern Generator Sequence Word 11
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_11  Fixed Pattern Generator Sequence Word 11. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ_11r (0x0000d10b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ_11r_SIZE 4

/*
 * This structure should be used to declare and program PATT_GEN_SEQ_11.
 *
 */
typedef union BCMI_TSCE16_XGXS_PATT_GEN_SEQ_11r_s {
	uint32_t v[1];
	uint32_t patt_gen_seq_11[1];
	uint32_t _patt_gen_seq_11;
} BCMI_TSCE16_XGXS_PATT_GEN_SEQ_11r_t;

#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ_11r_CLR(r) (r).patt_gen_seq_11[0] = 0
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ_11r_SET(r,d) (r).patt_gen_seq_11[0] = d
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ_11r_GET(r) (r).patt_gen_seq_11[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ_11r_PATT_GEN_SEQ_11f_GET(r) (((r).patt_gen_seq_11[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ_11r_PATT_GEN_SEQ_11f_SET(r,f) (r).patt_gen_seq_11[0]=(((r).patt_gen_seq_11[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATT_GEN_SEQ_11.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PATT_GEN_SEQ_11r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ_11r,(_r._patt_gen_seq_11))
#define BCMI_TSCE16_XGXS_WRITE_PATT_GEN_SEQ_11r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ_11r,(_r._patt_gen_seq_11)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PATT_GEN_SEQ_11r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ_11r,(_r._patt_gen_seq_11))
#define BCMI_TSCE16_XGXS_READLN_PATT_GEN_SEQ_11r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ_11r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq_11))
#define BCMI_TSCE16_XGXS_WRITELN_PATT_GEN_SEQ_11r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ_11r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq_11))
#define BCMI_TSCE16_XGXS_WRITEALL_PATT_GEN_SEQ_11r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ_11r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patt_gen_seq_11))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATT_GEN_SEQ_11r BCMI_TSCE16_XGXS_PATT_GEN_SEQ_11r
#define PATT_GEN_SEQ_11r_SIZE BCMI_TSCE16_XGXS_PATT_GEN_SEQ_11r_SIZE
typedef BCMI_TSCE16_XGXS_PATT_GEN_SEQ_11r_t PATT_GEN_SEQ_11r_t;
#define PATT_GEN_SEQ_11r_CLR BCMI_TSCE16_XGXS_PATT_GEN_SEQ_11r_CLR
#define PATT_GEN_SEQ_11r_SET BCMI_TSCE16_XGXS_PATT_GEN_SEQ_11r_SET
#define PATT_GEN_SEQ_11r_GET BCMI_TSCE16_XGXS_PATT_GEN_SEQ_11r_GET
#define PATT_GEN_SEQ_11r_PATT_GEN_SEQ_11f_GET BCMI_TSCE16_XGXS_PATT_GEN_SEQ_11r_PATT_GEN_SEQ_11f_GET
#define PATT_GEN_SEQ_11r_PATT_GEN_SEQ_11f_SET BCMI_TSCE16_XGXS_PATT_GEN_SEQ_11r_PATT_GEN_SEQ_11f_SET
#define READ_PATT_GEN_SEQ_11r BCMI_TSCE16_XGXS_READ_PATT_GEN_SEQ_11r
#define WRITE_PATT_GEN_SEQ_11r BCMI_TSCE16_XGXS_WRITE_PATT_GEN_SEQ_11r
#define MODIFY_PATT_GEN_SEQ_11r BCMI_TSCE16_XGXS_MODIFY_PATT_GEN_SEQ_11r
#define READLN_PATT_GEN_SEQ_11r BCMI_TSCE16_XGXS_READLN_PATT_GEN_SEQ_11r
#define WRITELN_PATT_GEN_SEQ_11r BCMI_TSCE16_XGXS_WRITELN_PATT_GEN_SEQ_11r
#define WRITEALL_PATT_GEN_SEQ_11r BCMI_TSCE16_XGXS_WRITEALL_PATT_GEN_SEQ_11r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PATT_GEN_SEQ_11r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PATT_GEN_SEQ_12
 * BLOCKS:   PATT_GEN
 * REGADDR:  0xd10c
 * DESC:     Pattern Generator Sequence Word 12
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_12  Fixed Pattern Generator Sequence Word 12. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ_12r (0x0000d10c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ_12r_SIZE 4

/*
 * This structure should be used to declare and program PATT_GEN_SEQ_12.
 *
 */
typedef union BCMI_TSCE16_XGXS_PATT_GEN_SEQ_12r_s {
	uint32_t v[1];
	uint32_t patt_gen_seq_12[1];
	uint32_t _patt_gen_seq_12;
} BCMI_TSCE16_XGXS_PATT_GEN_SEQ_12r_t;

#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ_12r_CLR(r) (r).patt_gen_seq_12[0] = 0
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ_12r_SET(r,d) (r).patt_gen_seq_12[0] = d
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ_12r_GET(r) (r).patt_gen_seq_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ_12r_PATT_GEN_SEQ_12f_GET(r) (((r).patt_gen_seq_12[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ_12r_PATT_GEN_SEQ_12f_SET(r,f) (r).patt_gen_seq_12[0]=(((r).patt_gen_seq_12[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATT_GEN_SEQ_12.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PATT_GEN_SEQ_12r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ_12r,(_r._patt_gen_seq_12))
#define BCMI_TSCE16_XGXS_WRITE_PATT_GEN_SEQ_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ_12r,(_r._patt_gen_seq_12)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PATT_GEN_SEQ_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ_12r,(_r._patt_gen_seq_12))
#define BCMI_TSCE16_XGXS_READLN_PATT_GEN_SEQ_12r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq_12))
#define BCMI_TSCE16_XGXS_WRITELN_PATT_GEN_SEQ_12r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq_12))
#define BCMI_TSCE16_XGXS_WRITEALL_PATT_GEN_SEQ_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ_12r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patt_gen_seq_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATT_GEN_SEQ_12r BCMI_TSCE16_XGXS_PATT_GEN_SEQ_12r
#define PATT_GEN_SEQ_12r_SIZE BCMI_TSCE16_XGXS_PATT_GEN_SEQ_12r_SIZE
typedef BCMI_TSCE16_XGXS_PATT_GEN_SEQ_12r_t PATT_GEN_SEQ_12r_t;
#define PATT_GEN_SEQ_12r_CLR BCMI_TSCE16_XGXS_PATT_GEN_SEQ_12r_CLR
#define PATT_GEN_SEQ_12r_SET BCMI_TSCE16_XGXS_PATT_GEN_SEQ_12r_SET
#define PATT_GEN_SEQ_12r_GET BCMI_TSCE16_XGXS_PATT_GEN_SEQ_12r_GET
#define PATT_GEN_SEQ_12r_PATT_GEN_SEQ_12f_GET BCMI_TSCE16_XGXS_PATT_GEN_SEQ_12r_PATT_GEN_SEQ_12f_GET
#define PATT_GEN_SEQ_12r_PATT_GEN_SEQ_12f_SET BCMI_TSCE16_XGXS_PATT_GEN_SEQ_12r_PATT_GEN_SEQ_12f_SET
#define READ_PATT_GEN_SEQ_12r BCMI_TSCE16_XGXS_READ_PATT_GEN_SEQ_12r
#define WRITE_PATT_GEN_SEQ_12r BCMI_TSCE16_XGXS_WRITE_PATT_GEN_SEQ_12r
#define MODIFY_PATT_GEN_SEQ_12r BCMI_TSCE16_XGXS_MODIFY_PATT_GEN_SEQ_12r
#define READLN_PATT_GEN_SEQ_12r BCMI_TSCE16_XGXS_READLN_PATT_GEN_SEQ_12r
#define WRITELN_PATT_GEN_SEQ_12r BCMI_TSCE16_XGXS_WRITELN_PATT_GEN_SEQ_12r
#define WRITEALL_PATT_GEN_SEQ_12r BCMI_TSCE16_XGXS_WRITEALL_PATT_GEN_SEQ_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PATT_GEN_SEQ_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PATT_GEN_SEQ_13
 * BLOCKS:   PATT_GEN
 * REGADDR:  0xd10d
 * DESC:     Pattern Generator Sequence Word 13
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_13  Fixed Pattern Generator Sequence Word 13. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ_13r (0x0000d10d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ_13r_SIZE 4

/*
 * This structure should be used to declare and program PATT_GEN_SEQ_13.
 *
 */
typedef union BCMI_TSCE16_XGXS_PATT_GEN_SEQ_13r_s {
	uint32_t v[1];
	uint32_t patt_gen_seq_13[1];
	uint32_t _patt_gen_seq_13;
} BCMI_TSCE16_XGXS_PATT_GEN_SEQ_13r_t;

#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ_13r_CLR(r) (r).patt_gen_seq_13[0] = 0
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ_13r_SET(r,d) (r).patt_gen_seq_13[0] = d
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ_13r_GET(r) (r).patt_gen_seq_13[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ_13r_PATT_GEN_SEQ_13f_GET(r) (((r).patt_gen_seq_13[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ_13r_PATT_GEN_SEQ_13f_SET(r,f) (r).patt_gen_seq_13[0]=(((r).patt_gen_seq_13[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATT_GEN_SEQ_13.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PATT_GEN_SEQ_13r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ_13r,(_r._patt_gen_seq_13))
#define BCMI_TSCE16_XGXS_WRITE_PATT_GEN_SEQ_13r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ_13r,(_r._patt_gen_seq_13)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PATT_GEN_SEQ_13r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ_13r,(_r._patt_gen_seq_13))
#define BCMI_TSCE16_XGXS_READLN_PATT_GEN_SEQ_13r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ_13r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq_13))
#define BCMI_TSCE16_XGXS_WRITELN_PATT_GEN_SEQ_13r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ_13r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq_13))
#define BCMI_TSCE16_XGXS_WRITEALL_PATT_GEN_SEQ_13r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ_13r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patt_gen_seq_13))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATT_GEN_SEQ_13r BCMI_TSCE16_XGXS_PATT_GEN_SEQ_13r
#define PATT_GEN_SEQ_13r_SIZE BCMI_TSCE16_XGXS_PATT_GEN_SEQ_13r_SIZE
typedef BCMI_TSCE16_XGXS_PATT_GEN_SEQ_13r_t PATT_GEN_SEQ_13r_t;
#define PATT_GEN_SEQ_13r_CLR BCMI_TSCE16_XGXS_PATT_GEN_SEQ_13r_CLR
#define PATT_GEN_SEQ_13r_SET BCMI_TSCE16_XGXS_PATT_GEN_SEQ_13r_SET
#define PATT_GEN_SEQ_13r_GET BCMI_TSCE16_XGXS_PATT_GEN_SEQ_13r_GET
#define PATT_GEN_SEQ_13r_PATT_GEN_SEQ_13f_GET BCMI_TSCE16_XGXS_PATT_GEN_SEQ_13r_PATT_GEN_SEQ_13f_GET
#define PATT_GEN_SEQ_13r_PATT_GEN_SEQ_13f_SET BCMI_TSCE16_XGXS_PATT_GEN_SEQ_13r_PATT_GEN_SEQ_13f_SET
#define READ_PATT_GEN_SEQ_13r BCMI_TSCE16_XGXS_READ_PATT_GEN_SEQ_13r
#define WRITE_PATT_GEN_SEQ_13r BCMI_TSCE16_XGXS_WRITE_PATT_GEN_SEQ_13r
#define MODIFY_PATT_GEN_SEQ_13r BCMI_TSCE16_XGXS_MODIFY_PATT_GEN_SEQ_13r
#define READLN_PATT_GEN_SEQ_13r BCMI_TSCE16_XGXS_READLN_PATT_GEN_SEQ_13r
#define WRITELN_PATT_GEN_SEQ_13r BCMI_TSCE16_XGXS_WRITELN_PATT_GEN_SEQ_13r
#define WRITEALL_PATT_GEN_SEQ_13r BCMI_TSCE16_XGXS_WRITEALL_PATT_GEN_SEQ_13r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PATT_GEN_SEQ_13r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PATT_GEN_SEQ_14
 * BLOCKS:   PATT_GEN
 * REGADDR:  0xd10e
 * DESC:     Pattern Generator Sequence Word 14
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_14  Fixed Pattern Generator Sequence Word 14. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode. This word will be transmitted first.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ_14r (0x0000d10e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ_14r_SIZE 4

/*
 * This structure should be used to declare and program PATT_GEN_SEQ_14.
 *
 */
typedef union BCMI_TSCE16_XGXS_PATT_GEN_SEQ_14r_s {
	uint32_t v[1];
	uint32_t patt_gen_seq_14[1];
	uint32_t _patt_gen_seq_14;
} BCMI_TSCE16_XGXS_PATT_GEN_SEQ_14r_t;

#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ_14r_CLR(r) (r).patt_gen_seq_14[0] = 0
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ_14r_SET(r,d) (r).patt_gen_seq_14[0] = d
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ_14r_GET(r) (r).patt_gen_seq_14[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ_14r_PATT_GEN_SEQ_14f_GET(r) (((r).patt_gen_seq_14[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PATT_GEN_SEQ_14r_PATT_GEN_SEQ_14f_SET(r,f) (r).patt_gen_seq_14[0]=(((r).patt_gen_seq_14[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATT_GEN_SEQ_14.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PATT_GEN_SEQ_14r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ_14r,(_r._patt_gen_seq_14))
#define BCMI_TSCE16_XGXS_WRITE_PATT_GEN_SEQ_14r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ_14r,(_r._patt_gen_seq_14)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PATT_GEN_SEQ_14r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ_14r,(_r._patt_gen_seq_14))
#define BCMI_TSCE16_XGXS_READLN_PATT_GEN_SEQ_14r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ_14r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq_14))
#define BCMI_TSCE16_XGXS_WRITELN_PATT_GEN_SEQ_14r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ_14r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq_14))
#define BCMI_TSCE16_XGXS_WRITEALL_PATT_GEN_SEQ_14r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PATT_GEN_SEQ_14r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patt_gen_seq_14))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATT_GEN_SEQ_14r BCMI_TSCE16_XGXS_PATT_GEN_SEQ_14r
#define PATT_GEN_SEQ_14r_SIZE BCMI_TSCE16_XGXS_PATT_GEN_SEQ_14r_SIZE
typedef BCMI_TSCE16_XGXS_PATT_GEN_SEQ_14r_t PATT_GEN_SEQ_14r_t;
#define PATT_GEN_SEQ_14r_CLR BCMI_TSCE16_XGXS_PATT_GEN_SEQ_14r_CLR
#define PATT_GEN_SEQ_14r_SET BCMI_TSCE16_XGXS_PATT_GEN_SEQ_14r_SET
#define PATT_GEN_SEQ_14r_GET BCMI_TSCE16_XGXS_PATT_GEN_SEQ_14r_GET
#define PATT_GEN_SEQ_14r_PATT_GEN_SEQ_14f_GET BCMI_TSCE16_XGXS_PATT_GEN_SEQ_14r_PATT_GEN_SEQ_14f_GET
#define PATT_GEN_SEQ_14r_PATT_GEN_SEQ_14f_SET BCMI_TSCE16_XGXS_PATT_GEN_SEQ_14r_PATT_GEN_SEQ_14f_SET
#define READ_PATT_GEN_SEQ_14r BCMI_TSCE16_XGXS_READ_PATT_GEN_SEQ_14r
#define WRITE_PATT_GEN_SEQ_14r BCMI_TSCE16_XGXS_WRITE_PATT_GEN_SEQ_14r
#define MODIFY_PATT_GEN_SEQ_14r BCMI_TSCE16_XGXS_MODIFY_PATT_GEN_SEQ_14r
#define READLN_PATT_GEN_SEQ_14r BCMI_TSCE16_XGXS_READLN_PATT_GEN_SEQ_14r
#define WRITELN_PATT_GEN_SEQ_14r BCMI_TSCE16_XGXS_WRITELN_PATT_GEN_SEQ_14r
#define WRITEALL_PATT_GEN_SEQ_14r BCMI_TSCE16_XGXS_WRITEALL_PATT_GEN_SEQ_14r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PATT_GEN_SEQ_14r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TXFIR_TAP_CTL0
 * BLOCKS:   TX_FED
 * REGADDR:  0xd110
 * DESC:     TX FIR TAP Control0 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TXFIR_POST2      tx fir post2 tap override value (binary)
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TXFIR_TAP_CTL0r (0x0000d110 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TXFIR_TAP_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_TAP_CTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_TXFIR_TAP_CTL0r_s {
	uint32_t v[1];
	uint32_t txfir_tap_ctl0[1];
	uint32_t _txfir_tap_ctl0;
} BCMI_TSCE16_XGXS_TXFIR_TAP_CTL0r_t;

#define BCMI_TSCE16_XGXS_TXFIR_TAP_CTL0r_CLR(r) (r).txfir_tap_ctl0[0] = 0
#define BCMI_TSCE16_XGXS_TXFIR_TAP_CTL0r_SET(r,d) (r).txfir_tap_ctl0[0] = d
#define BCMI_TSCE16_XGXS_TXFIR_TAP_CTL0r_GET(r) (r).txfir_tap_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TXFIR_TAP_CTL0r_TXFIR_POST2f_GET(r) (((r).txfir_tap_ctl0[0]) & 0xf)
#define BCMI_TSCE16_XGXS_TXFIR_TAP_CTL0r_TXFIR_POST2f_SET(r,f) (r).txfir_tap_ctl0[0]=(((r).txfir_tap_ctl0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access TXFIR_TAP_CTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TXFIR_TAP_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TXFIR_TAP_CTL0r,(_r._txfir_tap_ctl0))
#define BCMI_TSCE16_XGXS_WRITE_TXFIR_TAP_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXFIR_TAP_CTL0r,(_r._txfir_tap_ctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TXFIR_TAP_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXFIR_TAP_CTL0r,(_r._txfir_tap_ctl0))
#define BCMI_TSCE16_XGXS_READLN_TXFIR_TAP_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TXFIR_TAP_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl0))
#define BCMI_TSCE16_XGXS_WRITELN_TXFIR_TAP_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXFIR_TAP_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_TXFIR_TAP_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXFIR_TAP_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_tap_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_TAP_CTL0r BCMI_TSCE16_XGXS_TXFIR_TAP_CTL0r
#define TXFIR_TAP_CTL0r_SIZE BCMI_TSCE16_XGXS_TXFIR_TAP_CTL0r_SIZE
typedef BCMI_TSCE16_XGXS_TXFIR_TAP_CTL0r_t TXFIR_TAP_CTL0r_t;
#define TXFIR_TAP_CTL0r_CLR BCMI_TSCE16_XGXS_TXFIR_TAP_CTL0r_CLR
#define TXFIR_TAP_CTL0r_SET BCMI_TSCE16_XGXS_TXFIR_TAP_CTL0r_SET
#define TXFIR_TAP_CTL0r_GET BCMI_TSCE16_XGXS_TXFIR_TAP_CTL0r_GET
#define TXFIR_TAP_CTL0r_TXFIR_POST2f_GET BCMI_TSCE16_XGXS_TXFIR_TAP_CTL0r_TXFIR_POST2f_GET
#define TXFIR_TAP_CTL0r_TXFIR_POST2f_SET BCMI_TSCE16_XGXS_TXFIR_TAP_CTL0r_TXFIR_POST2f_SET
#define READ_TXFIR_TAP_CTL0r BCMI_TSCE16_XGXS_READ_TXFIR_TAP_CTL0r
#define WRITE_TXFIR_TAP_CTL0r BCMI_TSCE16_XGXS_WRITE_TXFIR_TAP_CTL0r
#define MODIFY_TXFIR_TAP_CTL0r BCMI_TSCE16_XGXS_MODIFY_TXFIR_TAP_CTL0r
#define READLN_TXFIR_TAP_CTL0r BCMI_TSCE16_XGXS_READLN_TXFIR_TAP_CTL0r
#define WRITELN_TXFIR_TAP_CTL0r BCMI_TSCE16_XGXS_WRITELN_TXFIR_TAP_CTL0r
#define WRITEALL_TXFIR_TAP_CTL0r BCMI_TSCE16_XGXS_WRITEALL_TXFIR_TAP_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TXFIR_TAP_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  MISC_CTL0
 * BLOCKS:   TX_FED
 * REGADDR:  0xd111
 * DESC:     Misc Control0 Register
 * RESETVAL: 0x20 (32)
 * ACCESS:   R/W
 * FIELDS:
 *     SDK_TX_DISABLE   sdk tx disableThis tx disable control field is for SDK use during TX programmingPlease see Eagle & Merlin PMD Internal Functional Specification for details
 *     TX_DISABLE_OUTPUT_SEL These bits select tx disable output function2'b00 - send electrical idles2'b01 - send power down2'b10 - send ones2'b11 - send zeroes
 *     CONVERT_TAPS_TO_AFE Convert txfir binary tap values to afe interface signalsAPI codes writes a value of 1'b1 to start the conversionMicro writes a value of 1'b0 to indicate that the conversion is doneIt is the responsibilty of the API code to set the correctpre/main/post1 (in cl72 register block) and post2 values beforesetting this field
 *     CONVERT_TAPS_TO_AFE_INT_EN Conversion Interrupt EnableWhen this field is set to 1'b1, then settin theconvert_txfir_taps_to_afe field  to 1'b1 generates aninterrupt to the micro1 - enabled,  0 - disabled
 *     CONVERT_TAPS_TO_AFE_ERROR Conversion ErrorMicro sets this field to 1'b1 to indicates that the conversion is notperformed because the binary taps values do not meet the constraintsIt is the responsibility of the API code to ensure taps meet theconstraints
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_MISC_CTL0r (0x0000d111 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_MISC_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program MISC_CTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_MISC_CTL0r_s {
	uint32_t v[1];
	uint32_t misc_ctl0[1];
	uint32_t _misc_ctl0;
} BCMI_TSCE16_XGXS_MISC_CTL0r_t;

#define BCMI_TSCE16_XGXS_MISC_CTL0r_CLR(r) (r).misc_ctl0[0] = 0
#define BCMI_TSCE16_XGXS_MISC_CTL0r_SET(r,d) (r).misc_ctl0[0] = d
#define BCMI_TSCE16_XGXS_MISC_CTL0r_GET(r) (r).misc_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_MISC_CTL0r_CONVERT_TAPS_TO_AFE_ERRORf_GET(r) ((((r).misc_ctl0[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_MISC_CTL0r_CONVERT_TAPS_TO_AFE_ERRORf_SET(r,f) (r).misc_ctl0[0]=(((r).misc_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_MISC_CTL0r_CONVERT_TAPS_TO_AFE_INT_ENf_GET(r) ((((r).misc_ctl0[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_MISC_CTL0r_CONVERT_TAPS_TO_AFE_INT_ENf_SET(r,f) (r).misc_ctl0[0]=(((r).misc_ctl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_MISC_CTL0r_CONVERT_TAPS_TO_AFEf_GET(r) ((((r).misc_ctl0[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_MISC_CTL0r_CONVERT_TAPS_TO_AFEf_SET(r,f) (r).misc_ctl0[0]=(((r).misc_ctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_MISC_CTL0r_TX_DISABLE_OUTPUT_SELf_GET(r) ((((r).misc_ctl0[0]) >> 2) & 0x3)
#define BCMI_TSCE16_XGXS_MISC_CTL0r_TX_DISABLE_OUTPUT_SELf_SET(r,f) (r).misc_ctl0[0]=(((r).misc_ctl0[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCE16_XGXS_MISC_CTL0r_SDK_TX_DISABLEf_GET(r) (((r).misc_ctl0[0]) & 0x1)
#define BCMI_TSCE16_XGXS_MISC_CTL0r_SDK_TX_DISABLEf_SET(r,f) (r).misc_ctl0[0]=(((r).misc_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MISC_CTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_MISC_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MISC_CTL0r,(_r._misc_ctl0))
#define BCMI_TSCE16_XGXS_WRITE_MISC_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MISC_CTL0r,(_r._misc_ctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_MISC_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MISC_CTL0r,(_r._misc_ctl0))
#define BCMI_TSCE16_XGXS_READLN_MISC_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MISC_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._misc_ctl0))
#define BCMI_TSCE16_XGXS_WRITELN_MISC_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MISC_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._misc_ctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_MISC_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MISC_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._misc_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MISC_CTL0r BCMI_TSCE16_XGXS_MISC_CTL0r
#define MISC_CTL0r_SIZE BCMI_TSCE16_XGXS_MISC_CTL0r_SIZE
typedef BCMI_TSCE16_XGXS_MISC_CTL0r_t MISC_CTL0r_t;
#define MISC_CTL0r_CLR BCMI_TSCE16_XGXS_MISC_CTL0r_CLR
#define MISC_CTL0r_SET BCMI_TSCE16_XGXS_MISC_CTL0r_SET
#define MISC_CTL0r_GET BCMI_TSCE16_XGXS_MISC_CTL0r_GET
#define MISC_CTL0r_CONVERT_TAPS_TO_AFE_ERRORf_GET BCMI_TSCE16_XGXS_MISC_CTL0r_CONVERT_TAPS_TO_AFE_ERRORf_GET
#define MISC_CTL0r_CONVERT_TAPS_TO_AFE_ERRORf_SET BCMI_TSCE16_XGXS_MISC_CTL0r_CONVERT_TAPS_TO_AFE_ERRORf_SET
#define MISC_CTL0r_CONVERT_TAPS_TO_AFE_INT_ENf_GET BCMI_TSCE16_XGXS_MISC_CTL0r_CONVERT_TAPS_TO_AFE_INT_ENf_GET
#define MISC_CTL0r_CONVERT_TAPS_TO_AFE_INT_ENf_SET BCMI_TSCE16_XGXS_MISC_CTL0r_CONVERT_TAPS_TO_AFE_INT_ENf_SET
#define MISC_CTL0r_CONVERT_TAPS_TO_AFEf_GET BCMI_TSCE16_XGXS_MISC_CTL0r_CONVERT_TAPS_TO_AFEf_GET
#define MISC_CTL0r_CONVERT_TAPS_TO_AFEf_SET BCMI_TSCE16_XGXS_MISC_CTL0r_CONVERT_TAPS_TO_AFEf_SET
#define MISC_CTL0r_TX_DISABLE_OUTPUT_SELf_GET BCMI_TSCE16_XGXS_MISC_CTL0r_TX_DISABLE_OUTPUT_SELf_GET
#define MISC_CTL0r_TX_DISABLE_OUTPUT_SELf_SET BCMI_TSCE16_XGXS_MISC_CTL0r_TX_DISABLE_OUTPUT_SELf_SET
#define MISC_CTL0r_SDK_TX_DISABLEf_GET BCMI_TSCE16_XGXS_MISC_CTL0r_SDK_TX_DISABLEf_GET
#define MISC_CTL0r_SDK_TX_DISABLEf_SET BCMI_TSCE16_XGXS_MISC_CTL0r_SDK_TX_DISABLEf_SET
#define READ_MISC_CTL0r BCMI_TSCE16_XGXS_READ_MISC_CTL0r
#define WRITE_MISC_CTL0r BCMI_TSCE16_XGXS_WRITE_MISC_CTL0r
#define MODIFY_MISC_CTL0r BCMI_TSCE16_XGXS_MODIFY_MISC_CTL0r
#define READLN_MISC_CTL0r BCMI_TSCE16_XGXS_READLN_MISC_CTL0r
#define WRITELN_MISC_CTL0r BCMI_TSCE16_XGXS_WRITELN_MISC_CTL0r
#define WRITEALL_MISC_CTL0r BCMI_TSCE16_XGXS_WRITEALL_MISC_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_MISC_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  MISC_STS0
 * BLOCKS:   TX_FED
 * REGADDR:  0xd112
 * DESC:     Misc Status 0 Register
 * RESETVAL: 0x3 (3)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_DISABLE_STATUS tx disable statusWhen this bit is set it indicates the tx_disable is active due to:1) pin at AN/PCS to PMD Interface OR2) dp_reset being asserted3) register bit dedicated to micro use4) register bit dedicated to SDK use5) tx disable timer that guarntees minimum assertion time has not expired
 *     TX_ELEC_IDLE_STATUS tx electrical idle statusWhen this bit is set it indicates the tx elecrticl idle active due to:1) tx disable being programmed to send electrical idles or2) An internal logic signal derived from PMD interface pins for EEE TX MODE
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_MISC_STS0r (0x0000d112 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_MISC_STS0r_SIZE 4

/*
 * This structure should be used to declare and program MISC_STS0.
 *
 */
typedef union BCMI_TSCE16_XGXS_MISC_STS0r_s {
	uint32_t v[1];
	uint32_t misc_sts0[1];
	uint32_t _misc_sts0;
} BCMI_TSCE16_XGXS_MISC_STS0r_t;

#define BCMI_TSCE16_XGXS_MISC_STS0r_CLR(r) (r).misc_sts0[0] = 0
#define BCMI_TSCE16_XGXS_MISC_STS0r_SET(r,d) (r).misc_sts0[0] = d
#define BCMI_TSCE16_XGXS_MISC_STS0r_GET(r) (r).misc_sts0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_MISC_STS0r_TX_ELEC_IDLE_STATUSf_GET(r) ((((r).misc_sts0[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_MISC_STS0r_TX_ELEC_IDLE_STATUSf_SET(r,f) (r).misc_sts0[0]=(((r).misc_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_MISC_STS0r_TX_DISABLE_STATUSf_GET(r) (((r).misc_sts0[0]) & 0x1)
#define BCMI_TSCE16_XGXS_MISC_STS0r_TX_DISABLE_STATUSf_SET(r,f) (r).misc_sts0[0]=(((r).misc_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MISC_STS0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_MISC_STS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MISC_STS0r,(_r._misc_sts0))
#define BCMI_TSCE16_XGXS_WRITE_MISC_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MISC_STS0r,(_r._misc_sts0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_MISC_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MISC_STS0r,(_r._misc_sts0))
#define BCMI_TSCE16_XGXS_READLN_MISC_STS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MISC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._misc_sts0))
#define BCMI_TSCE16_XGXS_WRITELN_MISC_STS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MISC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._misc_sts0))
#define BCMI_TSCE16_XGXS_WRITEALL_MISC_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MISC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._misc_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MISC_STS0r BCMI_TSCE16_XGXS_MISC_STS0r
#define MISC_STS0r_SIZE BCMI_TSCE16_XGXS_MISC_STS0r_SIZE
typedef BCMI_TSCE16_XGXS_MISC_STS0r_t MISC_STS0r_t;
#define MISC_STS0r_CLR BCMI_TSCE16_XGXS_MISC_STS0r_CLR
#define MISC_STS0r_SET BCMI_TSCE16_XGXS_MISC_STS0r_SET
#define MISC_STS0r_GET BCMI_TSCE16_XGXS_MISC_STS0r_GET
#define MISC_STS0r_TX_ELEC_IDLE_STATUSf_GET BCMI_TSCE16_XGXS_MISC_STS0r_TX_ELEC_IDLE_STATUSf_GET
#define MISC_STS0r_TX_ELEC_IDLE_STATUSf_SET BCMI_TSCE16_XGXS_MISC_STS0r_TX_ELEC_IDLE_STATUSf_SET
#define MISC_STS0r_TX_DISABLE_STATUSf_GET BCMI_TSCE16_XGXS_MISC_STS0r_TX_DISABLE_STATUSf_GET
#define MISC_STS0r_TX_DISABLE_STATUSf_SET BCMI_TSCE16_XGXS_MISC_STS0r_TX_DISABLE_STATUSf_SET
#define READ_MISC_STS0r BCMI_TSCE16_XGXS_READ_MISC_STS0r
#define WRITE_MISC_STS0r BCMI_TSCE16_XGXS_WRITE_MISC_STS0r
#define MODIFY_MISC_STS0r BCMI_TSCE16_XGXS_MODIFY_MISC_STS0r
#define READLN_MISC_STS0r BCMI_TSCE16_XGXS_READLN_MISC_STS0r
#define WRITELN_MISC_STS0r BCMI_TSCE16_XGXS_WRITELN_MISC_STS0r
#define WRITEALL_MISC_STS0r BCMI_TSCE16_XGXS_WRITEALL_MISC_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_MISC_STS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_CTL0
 * BLOCKS:   TX_FED
 * REGADDR:  0xd113
 * DESC:     Micro Control0 Register
 * RESETVAL: 0xc160 (49504)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_TX_DISABLE micro tx disableThis field is used by the Microcontroller for tx disable control during CL72 forced modePlease see Eagle & Merlin PMD Internal Functional Specification for details
 *     TX_DISABLE_TRIGGER Tx disable triggerWhen this bit is set to 1, it triggers a TX disable with timer starting at 0.No matter where the TX disable state is, it start a new timer and apply TX disable.This bit is self clearing
 *     DP_RESET_TX_DISABLE_DIS Tx disable based on data path reset0 - Enable tx disable based on data path reset1 - Disable tx disable based on data path resetNeed to set this bit to 1 if tx_disable_output_sel = 2'b01 (send TX power down).
 *     PMD_TX_DISABLE_PKILL Tx disable using the pmd_tx_disable pin disable control0 - enable tx disable from pmd_tx_disable pin1 - disable tx disable from pmd_tx_disable pin
 *     TX_DISABLE_TIMER_CTRL tx_disable timer value controlstx_disable_timer_ctrl[5] (MSB) selects the timer units0 - 2us units1 - 1ms unitstx_disable_timer_ctrl[4:0] (LSB[4:0]) = controls the number of units perthe list below0                 0 units1                 1 units2                 2 units3                 3 units4                 4 units5                 5 units6                 6 units7                 7 units8                 8 units9                10 units10               12 units11               14 units12               16 units13               20 units14               24 units15               28 units16               32 units17               40 units18               48 units19               56 units20               64 units21               80 units22               96 units23              112 units24              128 units25              160 units26              192 units27              224 units28              256 units29              320 units30              384 units31              448 units
 *     TX_EEE_QUIET_EN  Tx eee quiet mode control1 - Enable eee quiet mode when pmd_tx_mode (input pins) == 2'b010 - Disable eee quiet mode
 *     TX_EEE_ALERT_EN  Tx eee alert mode control1 - Enable eee alert mode when pmd_tx_mode (input pins) == 2'b100 - Disable eee alert mode
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_CTL0r (0x0000d113 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_CTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_ctl0[1];
	uint32_t _uc_ctl0;
} BCMI_TSCE16_XGXS_UC_CTL0r_t;

#define BCMI_TSCE16_XGXS_UC_CTL0r_CLR(r) (r).uc_ctl0[0] = 0
#define BCMI_TSCE16_XGXS_UC_CTL0r_SET(r,d) (r).uc_ctl0[0] = d
#define BCMI_TSCE16_XGXS_UC_CTL0r_GET(r) (r).uc_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_CTL0r_TX_EEE_ALERT_ENf_GET(r) ((((r).uc_ctl0[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_UC_CTL0r_TX_EEE_ALERT_ENf_SET(r,f) (r).uc_ctl0[0]=(((r).uc_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_UC_CTL0r_TX_EEE_QUIET_ENf_GET(r) ((((r).uc_ctl0[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_UC_CTL0r_TX_EEE_QUIET_ENf_SET(r,f) (r).uc_ctl0[0]=(((r).uc_ctl0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_UC_CTL0r_TX_DISABLE_TIMER_CTRLf_GET(r) ((((r).uc_ctl0[0]) >> 4) & 0x3f)
#define BCMI_TSCE16_XGXS_UC_CTL0r_TX_DISABLE_TIMER_CTRLf_SET(r,f) (r).uc_ctl0[0]=(((r).uc_ctl0[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4)) | (63 << (16 + 4))
#define BCMI_TSCE16_XGXS_UC_CTL0r_PMD_TX_DISABLE_PKILLf_GET(r) ((((r).uc_ctl0[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_UC_CTL0r_PMD_TX_DISABLE_PKILLf_SET(r,f) (r).uc_ctl0[0]=(((r).uc_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_UC_CTL0r_DP_RESET_TX_DISABLE_DISf_GET(r) ((((r).uc_ctl0[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_UC_CTL0r_DP_RESET_TX_DISABLE_DISf_SET(r,f) (r).uc_ctl0[0]=(((r).uc_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_UC_CTL0r_TX_DISABLE_TRIGGERf_GET(r) ((((r).uc_ctl0[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_UC_CTL0r_TX_DISABLE_TRIGGERf_SET(r,f) (r).uc_ctl0[0]=(((r).uc_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_UC_CTL0r_MICRO_TX_DISABLEf_GET(r) (((r).uc_ctl0[0]) & 0x1)
#define BCMI_TSCE16_XGXS_UC_CTL0r_MICRO_TX_DISABLEf_SET(r,f) (r).uc_ctl0[0]=(((r).uc_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_CTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_CTL0r,(_r._uc_ctl0))
#define BCMI_TSCE16_XGXS_WRITE_UC_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_CTL0r,(_r._uc_ctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_CTL0r,(_r._uc_ctl0))
#define BCMI_TSCE16_XGXS_READLN_UC_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ctl0))
#define BCMI_TSCE16_XGXS_WRITELN_UC_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_CTL0r BCMI_TSCE16_XGXS_UC_CTL0r
#define UC_CTL0r_SIZE BCMI_TSCE16_XGXS_UC_CTL0r_SIZE
typedef BCMI_TSCE16_XGXS_UC_CTL0r_t UC_CTL0r_t;
#define UC_CTL0r_CLR BCMI_TSCE16_XGXS_UC_CTL0r_CLR
#define UC_CTL0r_SET BCMI_TSCE16_XGXS_UC_CTL0r_SET
#define UC_CTL0r_GET BCMI_TSCE16_XGXS_UC_CTL0r_GET
#define UC_CTL0r_TX_EEE_ALERT_ENf_GET BCMI_TSCE16_XGXS_UC_CTL0r_TX_EEE_ALERT_ENf_GET
#define UC_CTL0r_TX_EEE_ALERT_ENf_SET BCMI_TSCE16_XGXS_UC_CTL0r_TX_EEE_ALERT_ENf_SET
#define UC_CTL0r_TX_EEE_QUIET_ENf_GET BCMI_TSCE16_XGXS_UC_CTL0r_TX_EEE_QUIET_ENf_GET
#define UC_CTL0r_TX_EEE_QUIET_ENf_SET BCMI_TSCE16_XGXS_UC_CTL0r_TX_EEE_QUIET_ENf_SET
#define UC_CTL0r_TX_DISABLE_TIMER_CTRLf_GET BCMI_TSCE16_XGXS_UC_CTL0r_TX_DISABLE_TIMER_CTRLf_GET
#define UC_CTL0r_TX_DISABLE_TIMER_CTRLf_SET BCMI_TSCE16_XGXS_UC_CTL0r_TX_DISABLE_TIMER_CTRLf_SET
#define UC_CTL0r_PMD_TX_DISABLE_PKILLf_GET BCMI_TSCE16_XGXS_UC_CTL0r_PMD_TX_DISABLE_PKILLf_GET
#define UC_CTL0r_PMD_TX_DISABLE_PKILLf_SET BCMI_TSCE16_XGXS_UC_CTL0r_PMD_TX_DISABLE_PKILLf_SET
#define UC_CTL0r_DP_RESET_TX_DISABLE_DISf_GET BCMI_TSCE16_XGXS_UC_CTL0r_DP_RESET_TX_DISABLE_DISf_GET
#define UC_CTL0r_DP_RESET_TX_DISABLE_DISf_SET BCMI_TSCE16_XGXS_UC_CTL0r_DP_RESET_TX_DISABLE_DISf_SET
#define UC_CTL0r_TX_DISABLE_TRIGGERf_GET BCMI_TSCE16_XGXS_UC_CTL0r_TX_DISABLE_TRIGGERf_GET
#define UC_CTL0r_TX_DISABLE_TRIGGERf_SET BCMI_TSCE16_XGXS_UC_CTL0r_TX_DISABLE_TRIGGERf_SET
#define UC_CTL0r_MICRO_TX_DISABLEf_GET BCMI_TSCE16_XGXS_UC_CTL0r_MICRO_TX_DISABLEf_GET
#define UC_CTL0r_MICRO_TX_DISABLEf_SET BCMI_TSCE16_XGXS_UC_CTL0r_MICRO_TX_DISABLEf_SET
#define READ_UC_CTL0r BCMI_TSCE16_XGXS_READ_UC_CTL0r
#define WRITE_UC_CTL0r BCMI_TSCE16_XGXS_WRITE_UC_CTL0r
#define MODIFY_UC_CTL0r BCMI_TSCE16_XGXS_MODIFY_UC_CTL0r
#define READLN_UC_CTL0r BCMI_TSCE16_XGXS_READLN_UC_CTL0r
#define WRITELN_UC_CTL0r BCMI_TSCE16_XGXS_WRITELN_UC_CTL0r
#define WRITEALL_UC_CTL0r BCMI_TSCE16_XGXS_WRITEALL_UC_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  POST2_AFE_CTL0
 * BLOCKS:   TX_FED
 * REGADDR:  0xd11b
 * DESC:     post2 slice select control register
 * RESETVAL: 0xa0 (160)
 * ACCESS:   R/W
 * FIELDS:
 *     TXFIR_POST2_POST2_1X_0 post2_1x[0] slice select - post2maps to i_txk_fir_post2_post2[0] pin on m16 afe
 *     TXFIR_DC_LEVEL_POST2_1X_0 post2_1x[0] slice select - dc_levelmaps to i_txk_fir_main_post2[0] pin on m16 afe
 *     TXFIR_POST2_POST2_1X_1 post2_1x[1] slice select - post2maps to i_txk_fir_post2_post2[1] pin on m16 afe
 *     TXFIR_DC_LEVEL_POST2_1X_1 post2_1x[1] slice select - dc_levelmaps to i_txk_fir_main_post2[1] pin on m16 afe
 *     TXFIR_POST2_POST2_2X_0 post2_2x[0] slice select - post2maps to i_txk_fir_post2_post2[2] pin on m16 afe
 *     TXFIR_DC_LEVEL_POST2_2X_0 post2_2x[0] slice select - dc_levelmaps to i_txk_fir_main_post2[2] pin on m16 afe
 *     TXFIR_POST2_POST2_2X_1 post2_2x[1] slice select - post2maps to i_txk_fir_post2_post2[3] pin on m16 afe
 *     TXFIR_DC_LEVEL_POST2_2X_1 post2_2x[1] slice select - dc_levelmaps to i_txk_fir_main_post2[3] pin on m16 afe
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_POST2_AFE_CTL0r (0x0000d11b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program POST2_AFE_CTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_s {
	uint32_t v[1];
	uint32_t post2_afe_ctl0[1];
	uint32_t _post2_afe_ctl0;
} BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_t;

#define BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_CLR(r) (r).post2_afe_ctl0[0] = 0
#define BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_SET(r,d) (r).post2_afe_ctl0[0] = d
#define BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_GET(r) (r).post2_afe_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_TXFIR_DC_LEVEL_POST2_2X_1f_GET(r) ((((r).post2_afe_ctl0[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_TXFIR_DC_LEVEL_POST2_2X_1f_SET(r,f) (r).post2_afe_ctl0[0]=(((r).post2_afe_ctl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_TXFIR_POST2_POST2_2X_1f_GET(r) ((((r).post2_afe_ctl0[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_TXFIR_POST2_POST2_2X_1f_SET(r,f) (r).post2_afe_ctl0[0]=(((r).post2_afe_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_TXFIR_DC_LEVEL_POST2_2X_0f_GET(r) ((((r).post2_afe_ctl0[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_TXFIR_DC_LEVEL_POST2_2X_0f_SET(r,f) (r).post2_afe_ctl0[0]=(((r).post2_afe_ctl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_TXFIR_POST2_POST2_2X_0f_GET(r) ((((r).post2_afe_ctl0[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_TXFIR_POST2_POST2_2X_0f_SET(r,f) (r).post2_afe_ctl0[0]=(((r).post2_afe_ctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_TXFIR_DC_LEVEL_POST2_1X_1f_GET(r) ((((r).post2_afe_ctl0[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_TXFIR_DC_LEVEL_POST2_1X_1f_SET(r,f) (r).post2_afe_ctl0[0]=(((r).post2_afe_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_TXFIR_POST2_POST2_1X_1f_GET(r) ((((r).post2_afe_ctl0[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_TXFIR_POST2_POST2_1X_1f_SET(r,f) (r).post2_afe_ctl0[0]=(((r).post2_afe_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_TXFIR_DC_LEVEL_POST2_1X_0f_GET(r) ((((r).post2_afe_ctl0[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_TXFIR_DC_LEVEL_POST2_1X_0f_SET(r,f) (r).post2_afe_ctl0[0]=(((r).post2_afe_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_TXFIR_POST2_POST2_1X_0f_GET(r) (((r).post2_afe_ctl0[0]) & 0x1)
#define BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_TXFIR_POST2_POST2_1X_0f_SET(r,f) (r).post2_afe_ctl0[0]=(((r).post2_afe_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access POST2_AFE_CTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_POST2_AFE_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_POST2_AFE_CTL0r,(_r._post2_afe_ctl0))
#define BCMI_TSCE16_XGXS_WRITE_POST2_AFE_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_POST2_AFE_CTL0r,(_r._post2_afe_ctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_POST2_AFE_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_POST2_AFE_CTL0r,(_r._post2_afe_ctl0))
#define BCMI_TSCE16_XGXS_READLN_POST2_AFE_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_POST2_AFE_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._post2_afe_ctl0))
#define BCMI_TSCE16_XGXS_WRITELN_POST2_AFE_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_POST2_AFE_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._post2_afe_ctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_POST2_AFE_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_POST2_AFE_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._post2_afe_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define POST2_AFE_CTL0r BCMI_TSCE16_XGXS_POST2_AFE_CTL0r
#define POST2_AFE_CTL0r_SIZE BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_SIZE
typedef BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_t POST2_AFE_CTL0r_t;
#define POST2_AFE_CTL0r_CLR BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_CLR
#define POST2_AFE_CTL0r_SET BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_SET
#define POST2_AFE_CTL0r_GET BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_GET
#define POST2_AFE_CTL0r_TXFIR_DC_LEVEL_POST2_2X_1f_GET BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_TXFIR_DC_LEVEL_POST2_2X_1f_GET
#define POST2_AFE_CTL0r_TXFIR_DC_LEVEL_POST2_2X_1f_SET BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_TXFIR_DC_LEVEL_POST2_2X_1f_SET
#define POST2_AFE_CTL0r_TXFIR_POST2_POST2_2X_1f_GET BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_TXFIR_POST2_POST2_2X_1f_GET
#define POST2_AFE_CTL0r_TXFIR_POST2_POST2_2X_1f_SET BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_TXFIR_POST2_POST2_2X_1f_SET
#define POST2_AFE_CTL0r_TXFIR_DC_LEVEL_POST2_2X_0f_GET BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_TXFIR_DC_LEVEL_POST2_2X_0f_GET
#define POST2_AFE_CTL0r_TXFIR_DC_LEVEL_POST2_2X_0f_SET BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_TXFIR_DC_LEVEL_POST2_2X_0f_SET
#define POST2_AFE_CTL0r_TXFIR_POST2_POST2_2X_0f_GET BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_TXFIR_POST2_POST2_2X_0f_GET
#define POST2_AFE_CTL0r_TXFIR_POST2_POST2_2X_0f_SET BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_TXFIR_POST2_POST2_2X_0f_SET
#define POST2_AFE_CTL0r_TXFIR_DC_LEVEL_POST2_1X_1f_GET BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_TXFIR_DC_LEVEL_POST2_1X_1f_GET
#define POST2_AFE_CTL0r_TXFIR_DC_LEVEL_POST2_1X_1f_SET BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_TXFIR_DC_LEVEL_POST2_1X_1f_SET
#define POST2_AFE_CTL0r_TXFIR_POST2_POST2_1X_1f_GET BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_TXFIR_POST2_POST2_1X_1f_GET
#define POST2_AFE_CTL0r_TXFIR_POST2_POST2_1X_1f_SET BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_TXFIR_POST2_POST2_1X_1f_SET
#define POST2_AFE_CTL0r_TXFIR_DC_LEVEL_POST2_1X_0f_GET BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_TXFIR_DC_LEVEL_POST2_1X_0f_GET
#define POST2_AFE_CTL0r_TXFIR_DC_LEVEL_POST2_1X_0f_SET BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_TXFIR_DC_LEVEL_POST2_1X_0f_SET
#define POST2_AFE_CTL0r_TXFIR_POST2_POST2_1X_0f_GET BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_TXFIR_POST2_POST2_1X_0f_GET
#define POST2_AFE_CTL0r_TXFIR_POST2_POST2_1X_0f_SET BCMI_TSCE16_XGXS_POST2_AFE_CTL0r_TXFIR_POST2_POST2_1X_0f_SET
#define READ_POST2_AFE_CTL0r BCMI_TSCE16_XGXS_READ_POST2_AFE_CTL0r
#define WRITE_POST2_AFE_CTL0r BCMI_TSCE16_XGXS_WRITE_POST2_AFE_CTL0r
#define MODIFY_POST2_AFE_CTL0r BCMI_TSCE16_XGXS_MODIFY_POST2_AFE_CTL0r
#define READLN_POST2_AFE_CTL0r BCMI_TSCE16_XGXS_READLN_POST2_AFE_CTL0r
#define WRITELN_POST2_AFE_CTL0r BCMI_TSCE16_XGXS_WRITELN_POST2_AFE_CTL0r
#define WRITEALL_POST2_AFE_CTL0r BCMI_TSCE16_XGXS_WRITEALL_POST2_AFE_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_POST2_AFE_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  POST1_AFE_CTL0
 * BLOCKS:   TX_FED
 * REGADDR:  0xd11c
 * DESC:     post1 slice select control register
 * RESETVAL: 0x2a0 (672)
 * ACCESS:   R/W
 * FIELDS:
 *     TXFIR_POST1_POST1_1X_0 post1_1x[0] slice select - post1maps to i_txk_fir_post1_post1[0] pin on m16 afe
 *     TXFIR_DC_LEVEL_POST1_1X_0 post1_1x[0] slice select - dc_levelmaps to i_txk_fir_main_post1[0] pin on m16 afe
 *     TXFIR_POST1_POST1_1X_1 post1_1x[1] slice select - post1maps to i_txk_fir_post1_post1[1] pin on m16 afe
 *     TXFIR_DC_LEVEL_POST1_1X_1 post1_1x[1] slice select - dc_levelmaps to i_txk_fir_main_post1[1] pin on m16 afe
 *     TXFIR_POST1_POST1_2X_0 pos1_2x[0] slice select - post1maps to i_txk_fir_post1_post1[2] pin on m16 afe
 *     TXFIR_DC_LEVEL_POST1_2X_0 post1_2x[0] slice select - dc_levelmaps to i_txk_fir_main_post1[2] pin on m16 afe
 *     TXFIR_POST1_POST1_2X_1 pos1_2x[1] slice select - post1maps to i_txk_fir_post1_post1[3] pin on m16 afe
 *     TXFIR_DC_LEVEL_POST1_2X_1 post1_2x[1] slice select - dc_levelmaps to i_txk_fir_main_post1[3] pin on m16 afe
 *     TXFIR_POST1_POST1_2X_2 pos1_2x[2] slice select - post1maps to i_txk_fir_post1_post1[4] pin on m16 afe
 *     TXFIR_DC_LEVEL_POST1_2X_2 post1_2x[2] slice select - dc_levelmaps to i_txk_fir_main_post1[4] pin on m16 afe
 *     TXFIR_PRE_POST1PRE_1X_0 post1pre_1x[0] slice select - premaps to i_txk_fir_pre_post1pre[0] pin on m16 afe
 *     TXFIR_POST1_POST1PRE_1X_0 post1pre_1x[0] slice select - post1maps to i_txk_fir_post1_post1pre[0] pin on m16 afe
 *     TXFIR_DC_LEVEL_POST1PRE_1X_0 post1pre_1x[0] slice select - dc_levelmaps to i_txk_fir_main_post1pre[0] pin on m16 afe
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_POST1_AFE_CTL0r (0x0000d11c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program POST1_AFE_CTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_s {
	uint32_t v[1];
	uint32_t post1_afe_ctl0[1];
	uint32_t _post1_afe_ctl0;
} BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_t;

#define BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_CLR(r) (r).post1_afe_ctl0[0] = 0
#define BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_SET(r,d) (r).post1_afe_ctl0[0] = d
#define BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_GET(r) (r).post1_afe_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_1X_0f_GET(r) ((((r).post1_afe_ctl0[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_1X_0f_SET(r,f) (r).post1_afe_ctl0[0]=(((r).post1_afe_ctl0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_POST1_POST1PRE_1X_0f_GET(r) ((((r).post1_afe_ctl0[0]) >> 13) & 0x1)
#define BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_POST1_POST1PRE_1X_0f_SET(r,f) (r).post1_afe_ctl0[0]=(((r).post1_afe_ctl0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_PRE_POST1PRE_1X_0f_GET(r) ((((r).post1_afe_ctl0[0]) >> 12) & 0x1)
#define BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_PRE_POST1PRE_1X_0f_SET(r,f) (r).post1_afe_ctl0[0]=(((r).post1_afe_ctl0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1_2X_2f_GET(r) ((((r).post1_afe_ctl0[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1_2X_2f_SET(r,f) (r).post1_afe_ctl0[0]=(((r).post1_afe_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_POST1_POST1_2X_2f_GET(r) ((((r).post1_afe_ctl0[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_POST1_POST1_2X_2f_SET(r,f) (r).post1_afe_ctl0[0]=(((r).post1_afe_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1_2X_1f_GET(r) ((((r).post1_afe_ctl0[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1_2X_1f_SET(r,f) (r).post1_afe_ctl0[0]=(((r).post1_afe_ctl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_POST1_POST1_2X_1f_GET(r) ((((r).post1_afe_ctl0[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_POST1_POST1_2X_1f_SET(r,f) (r).post1_afe_ctl0[0]=(((r).post1_afe_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1_2X_0f_GET(r) ((((r).post1_afe_ctl0[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1_2X_0f_SET(r,f) (r).post1_afe_ctl0[0]=(((r).post1_afe_ctl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_POST1_POST1_2X_0f_GET(r) ((((r).post1_afe_ctl0[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_POST1_POST1_2X_0f_SET(r,f) (r).post1_afe_ctl0[0]=(((r).post1_afe_ctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1_1X_1f_GET(r) ((((r).post1_afe_ctl0[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1_1X_1f_SET(r,f) (r).post1_afe_ctl0[0]=(((r).post1_afe_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_POST1_POST1_1X_1f_GET(r) ((((r).post1_afe_ctl0[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_POST1_POST1_1X_1f_SET(r,f) (r).post1_afe_ctl0[0]=(((r).post1_afe_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1_1X_0f_GET(r) ((((r).post1_afe_ctl0[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1_1X_0f_SET(r,f) (r).post1_afe_ctl0[0]=(((r).post1_afe_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_POST1_POST1_1X_0f_GET(r) (((r).post1_afe_ctl0[0]) & 0x1)
#define BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_POST1_POST1_1X_0f_SET(r,f) (r).post1_afe_ctl0[0]=(((r).post1_afe_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access POST1_AFE_CTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_POST1_AFE_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_POST1_AFE_CTL0r,(_r._post1_afe_ctl0))
#define BCMI_TSCE16_XGXS_WRITE_POST1_AFE_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_POST1_AFE_CTL0r,(_r._post1_afe_ctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_POST1_AFE_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_POST1_AFE_CTL0r,(_r._post1_afe_ctl0))
#define BCMI_TSCE16_XGXS_READLN_POST1_AFE_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_POST1_AFE_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._post1_afe_ctl0))
#define BCMI_TSCE16_XGXS_WRITELN_POST1_AFE_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_POST1_AFE_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._post1_afe_ctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_POST1_AFE_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_POST1_AFE_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._post1_afe_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define POST1_AFE_CTL0r BCMI_TSCE16_XGXS_POST1_AFE_CTL0r
#define POST1_AFE_CTL0r_SIZE BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_SIZE
typedef BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_t POST1_AFE_CTL0r_t;
#define POST1_AFE_CTL0r_CLR BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_CLR
#define POST1_AFE_CTL0r_SET BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_SET
#define POST1_AFE_CTL0r_GET BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_GET
#define POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_1X_0f_GET BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_1X_0f_GET
#define POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_1X_0f_SET BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_1X_0f_SET
#define POST1_AFE_CTL0r_TXFIR_POST1_POST1PRE_1X_0f_GET BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_POST1_POST1PRE_1X_0f_GET
#define POST1_AFE_CTL0r_TXFIR_POST1_POST1PRE_1X_0f_SET BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_POST1_POST1PRE_1X_0f_SET
#define POST1_AFE_CTL0r_TXFIR_PRE_POST1PRE_1X_0f_GET BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_PRE_POST1PRE_1X_0f_GET
#define POST1_AFE_CTL0r_TXFIR_PRE_POST1PRE_1X_0f_SET BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_PRE_POST1PRE_1X_0f_SET
#define POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1_2X_2f_GET BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1_2X_2f_GET
#define POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1_2X_2f_SET BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1_2X_2f_SET
#define POST1_AFE_CTL0r_TXFIR_POST1_POST1_2X_2f_GET BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_POST1_POST1_2X_2f_GET
#define POST1_AFE_CTL0r_TXFIR_POST1_POST1_2X_2f_SET BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_POST1_POST1_2X_2f_SET
#define POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1_2X_1f_GET BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1_2X_1f_GET
#define POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1_2X_1f_SET BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1_2X_1f_SET
#define POST1_AFE_CTL0r_TXFIR_POST1_POST1_2X_1f_GET BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_POST1_POST1_2X_1f_GET
#define POST1_AFE_CTL0r_TXFIR_POST1_POST1_2X_1f_SET BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_POST1_POST1_2X_1f_SET
#define POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1_2X_0f_GET BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1_2X_0f_GET
#define POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1_2X_0f_SET BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1_2X_0f_SET
#define POST1_AFE_CTL0r_TXFIR_POST1_POST1_2X_0f_GET BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_POST1_POST1_2X_0f_GET
#define POST1_AFE_CTL0r_TXFIR_POST1_POST1_2X_0f_SET BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_POST1_POST1_2X_0f_SET
#define POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1_1X_1f_GET BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1_1X_1f_GET
#define POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1_1X_1f_SET BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1_1X_1f_SET
#define POST1_AFE_CTL0r_TXFIR_POST1_POST1_1X_1f_GET BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_POST1_POST1_1X_1f_GET
#define POST1_AFE_CTL0r_TXFIR_POST1_POST1_1X_1f_SET BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_POST1_POST1_1X_1f_SET
#define POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1_1X_0f_GET BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1_1X_0f_GET
#define POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1_1X_0f_SET BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_DC_LEVEL_POST1_1X_0f_SET
#define POST1_AFE_CTL0r_TXFIR_POST1_POST1_1X_0f_GET BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_POST1_POST1_1X_0f_GET
#define POST1_AFE_CTL0r_TXFIR_POST1_POST1_1X_0f_SET BCMI_TSCE16_XGXS_POST1_AFE_CTL0r_TXFIR_POST1_POST1_1X_0f_SET
#define READ_POST1_AFE_CTL0r BCMI_TSCE16_XGXS_READ_POST1_AFE_CTL0r
#define WRITE_POST1_AFE_CTL0r BCMI_TSCE16_XGXS_WRITE_POST1_AFE_CTL0r
#define MODIFY_POST1_AFE_CTL0r BCMI_TSCE16_XGXS_MODIFY_POST1_AFE_CTL0r
#define READLN_POST1_AFE_CTL0r BCMI_TSCE16_XGXS_READLN_POST1_AFE_CTL0r
#define WRITELN_POST1_AFE_CTL0r BCMI_TSCE16_XGXS_WRITELN_POST1_AFE_CTL0r
#define WRITEALL_POST1_AFE_CTL0r BCMI_TSCE16_XGXS_WRITEALL_POST1_AFE_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_POST1_AFE_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  POST1PRE_AFE_CTL0
 * BLOCKS:   TX_FED
 * REGADDR:  0xd11d
 * DESC:     post1pre slice select control register
 * RESETVAL: 0x4000 (16384)
 * ACCESS:   R/W
 * FIELDS:
 *     TXFIR_PRE_POST1PRE_1X_1 post1pre_1x[1] slice select - premaps to i_txk_fir_pre_post1pre[1] pin on m16 afe
 *     TXFIR_POST1_POST1PRE_1X_1 post1pre_1x[1] slice select - post1maps to i_txk_fir_post1_post1pre[1] pin on m16 afe
 *     TXFIR_DC_LEVEL_POST1PRE_1X_1 post1pre_1x[1] slice select - dc_levelmaps to i_txk_fir_main_post1pre[1] pin on m16 afe
 *     TXFIR_PRE_POST1PRE_2X_0 post1pre_2x[0] slice select - premaps to i_txk_fir_pre_post1pre[2] pin on m16 afe
 *     TXFIR_POST1_POST1PRE_2X_0 post1pre_2x[0] slice select - post1maps to i_txk_fir_post1_post1pre[2] pin on m16 afe
 *     TXFIR_DC_LEVEL_POST1PRE_2X_0 post1pre_2x[0] slice select - dc_levelmaps to i_txk_fir_main_post1pre[2] pin on m16 afe
 *     TXFIR_PRE_POST1PRE_2X_1 post1pre_2x[1] slice select - premaps to i_txk_fir_pre_post1pre[3] pin on m16 afe
 *     TXFIR_POST1_POST1PRE_2X_1 post1pre_2x[1] slice select - post1maps to i_txk_fir_post1_post1pre[3] pin on m16 afe
 *     TXFIR_DC_LEVEL_POST1PRE_2X_1 post1pre_2x[1] slice select - dc_levelmaps to i_txk_fir_main_post1pre[3] pin on m16 afe
 *     TXFIR_PRE_POST1PRE_2X_2 post1pre_2x[2] slice select - premaps to i_txk_fir_pre_post1pre[4] pin on m16 afe
 *     TXFIR_POST1_POST1PRE_2X_2 post1pre_2x[2] slice select - post1maps to i_txk_fir_post1_post1pre[4] pin on m16 afe
 *     TXFIR_DC_LEVEL_POST1PRE_2X_2 post1pre_2x[2] slice select - dc_levelmaps to i_txk_fir_main_post1pre[4] pin on m16 afe
 *     TXFIR_PRE_POST1PRE_2X_3 post1pre_2x[3] slice select - premaps to i_txk_fir_pre_post1pre[5] pin on m16 afe
 *     TXFIR_POST1_POST1PRE_2X_3 post1pre_2x[3] slice select - post1maps to i_txk_fir_post1_post1pre[5] pin on m16 afe
 *     TXFIR_DC_LEVEL_POST1PRE_2X_3 post1pre_2x[3] slice select - dc_levelmaps to i_txk_fir_main_post1pre[5] pin on m16 afe
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r (0x0000d11d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program POST1PRE_AFE_CTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_s {
	uint32_t v[1];
	uint32_t post1pre_afe_ctl0[1];
	uint32_t _post1pre_afe_ctl0;
} BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_t;

#define BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_CLR(r) (r).post1pre_afe_ctl0[0] = 0
#define BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_SET(r,d) (r).post1pre_afe_ctl0[0] = d
#define BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_GET(r) (r).post1pre_afe_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_2X_3f_GET(r) ((((r).post1pre_afe_ctl0[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_2X_3f_SET(r,f) (r).post1pre_afe_ctl0[0]=(((r).post1pre_afe_ctl0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_POST1_POST1PRE_2X_3f_GET(r) ((((r).post1pre_afe_ctl0[0]) >> 13) & 0x1)
#define BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_POST1_POST1PRE_2X_3f_SET(r,f) (r).post1pre_afe_ctl0[0]=(((r).post1pre_afe_ctl0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_PRE_POST1PRE_2X_3f_GET(r) ((((r).post1pre_afe_ctl0[0]) >> 12) & 0x1)
#define BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_PRE_POST1PRE_2X_3f_SET(r,f) (r).post1pre_afe_ctl0[0]=(((r).post1pre_afe_ctl0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_2X_2f_GET(r) ((((r).post1pre_afe_ctl0[0]) >> 11) & 0x1)
#define BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_2X_2f_SET(r,f) (r).post1pre_afe_ctl0[0]=(((r).post1pre_afe_ctl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_POST1_POST1PRE_2X_2f_GET(r) ((((r).post1pre_afe_ctl0[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_POST1_POST1PRE_2X_2f_SET(r,f) (r).post1pre_afe_ctl0[0]=(((r).post1pre_afe_ctl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_PRE_POST1PRE_2X_2f_GET(r) ((((r).post1pre_afe_ctl0[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_PRE_POST1PRE_2X_2f_SET(r,f) (r).post1pre_afe_ctl0[0]=(((r).post1pre_afe_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_2X_1f_GET(r) ((((r).post1pre_afe_ctl0[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_2X_1f_SET(r,f) (r).post1pre_afe_ctl0[0]=(((r).post1pre_afe_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_POST1_POST1PRE_2X_1f_GET(r) ((((r).post1pre_afe_ctl0[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_POST1_POST1PRE_2X_1f_SET(r,f) (r).post1pre_afe_ctl0[0]=(((r).post1pre_afe_ctl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_PRE_POST1PRE_2X_1f_GET(r) ((((r).post1pre_afe_ctl0[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_PRE_POST1PRE_2X_1f_SET(r,f) (r).post1pre_afe_ctl0[0]=(((r).post1pre_afe_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_2X_0f_GET(r) ((((r).post1pre_afe_ctl0[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_2X_0f_SET(r,f) (r).post1pre_afe_ctl0[0]=(((r).post1pre_afe_ctl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_POST1_POST1PRE_2X_0f_GET(r) ((((r).post1pre_afe_ctl0[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_POST1_POST1PRE_2X_0f_SET(r,f) (r).post1pre_afe_ctl0[0]=(((r).post1pre_afe_ctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_PRE_POST1PRE_2X_0f_GET(r) ((((r).post1pre_afe_ctl0[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_PRE_POST1PRE_2X_0f_SET(r,f) (r).post1pre_afe_ctl0[0]=(((r).post1pre_afe_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_1X_1f_GET(r) ((((r).post1pre_afe_ctl0[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_1X_1f_SET(r,f) (r).post1pre_afe_ctl0[0]=(((r).post1pre_afe_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_POST1_POST1PRE_1X_1f_GET(r) ((((r).post1pre_afe_ctl0[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_POST1_POST1PRE_1X_1f_SET(r,f) (r).post1pre_afe_ctl0[0]=(((r).post1pre_afe_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_PRE_POST1PRE_1X_1f_GET(r) (((r).post1pre_afe_ctl0[0]) & 0x1)
#define BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_PRE_POST1PRE_1X_1f_SET(r,f) (r).post1pre_afe_ctl0[0]=(((r).post1pre_afe_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access POST1PRE_AFE_CTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_POST1PRE_AFE_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r,(_r._post1pre_afe_ctl0))
#define BCMI_TSCE16_XGXS_WRITE_POST1PRE_AFE_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r,(_r._post1pre_afe_ctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_POST1PRE_AFE_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r,(_r._post1pre_afe_ctl0))
#define BCMI_TSCE16_XGXS_READLN_POST1PRE_AFE_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._post1pre_afe_ctl0))
#define BCMI_TSCE16_XGXS_WRITELN_POST1PRE_AFE_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._post1pre_afe_ctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_POST1PRE_AFE_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._post1pre_afe_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define POST1PRE_AFE_CTL0r BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r
#define POST1PRE_AFE_CTL0r_SIZE BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_SIZE
typedef BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_t POST1PRE_AFE_CTL0r_t;
#define POST1PRE_AFE_CTL0r_CLR BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_CLR
#define POST1PRE_AFE_CTL0r_SET BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_SET
#define POST1PRE_AFE_CTL0r_GET BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_GET
#define POST1PRE_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_2X_3f_GET BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_2X_3f_GET
#define POST1PRE_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_2X_3f_SET BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_2X_3f_SET
#define POST1PRE_AFE_CTL0r_TXFIR_POST1_POST1PRE_2X_3f_GET BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_POST1_POST1PRE_2X_3f_GET
#define POST1PRE_AFE_CTL0r_TXFIR_POST1_POST1PRE_2X_3f_SET BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_POST1_POST1PRE_2X_3f_SET
#define POST1PRE_AFE_CTL0r_TXFIR_PRE_POST1PRE_2X_3f_GET BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_PRE_POST1PRE_2X_3f_GET
#define POST1PRE_AFE_CTL0r_TXFIR_PRE_POST1PRE_2X_3f_SET BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_PRE_POST1PRE_2X_3f_SET
#define POST1PRE_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_2X_2f_GET BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_2X_2f_GET
#define POST1PRE_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_2X_2f_SET BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_2X_2f_SET
#define POST1PRE_AFE_CTL0r_TXFIR_POST1_POST1PRE_2X_2f_GET BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_POST1_POST1PRE_2X_2f_GET
#define POST1PRE_AFE_CTL0r_TXFIR_POST1_POST1PRE_2X_2f_SET BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_POST1_POST1PRE_2X_2f_SET
#define POST1PRE_AFE_CTL0r_TXFIR_PRE_POST1PRE_2X_2f_GET BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_PRE_POST1PRE_2X_2f_GET
#define POST1PRE_AFE_CTL0r_TXFIR_PRE_POST1PRE_2X_2f_SET BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_PRE_POST1PRE_2X_2f_SET
#define POST1PRE_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_2X_1f_GET BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_2X_1f_GET
#define POST1PRE_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_2X_1f_SET BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_2X_1f_SET
#define POST1PRE_AFE_CTL0r_TXFIR_POST1_POST1PRE_2X_1f_GET BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_POST1_POST1PRE_2X_1f_GET
#define POST1PRE_AFE_CTL0r_TXFIR_POST1_POST1PRE_2X_1f_SET BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_POST1_POST1PRE_2X_1f_SET
#define POST1PRE_AFE_CTL0r_TXFIR_PRE_POST1PRE_2X_1f_GET BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_PRE_POST1PRE_2X_1f_GET
#define POST1PRE_AFE_CTL0r_TXFIR_PRE_POST1PRE_2X_1f_SET BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_PRE_POST1PRE_2X_1f_SET
#define POST1PRE_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_2X_0f_GET BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_2X_0f_GET
#define POST1PRE_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_2X_0f_SET BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_2X_0f_SET
#define POST1PRE_AFE_CTL0r_TXFIR_POST1_POST1PRE_2X_0f_GET BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_POST1_POST1PRE_2X_0f_GET
#define POST1PRE_AFE_CTL0r_TXFIR_POST1_POST1PRE_2X_0f_SET BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_POST1_POST1PRE_2X_0f_SET
#define POST1PRE_AFE_CTL0r_TXFIR_PRE_POST1PRE_2X_0f_GET BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_PRE_POST1PRE_2X_0f_GET
#define POST1PRE_AFE_CTL0r_TXFIR_PRE_POST1PRE_2X_0f_SET BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_PRE_POST1PRE_2X_0f_SET
#define POST1PRE_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_1X_1f_GET BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_1X_1f_GET
#define POST1PRE_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_1X_1f_SET BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_DC_LEVEL_POST1PRE_1X_1f_SET
#define POST1PRE_AFE_CTL0r_TXFIR_POST1_POST1PRE_1X_1f_GET BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_POST1_POST1PRE_1X_1f_GET
#define POST1PRE_AFE_CTL0r_TXFIR_POST1_POST1PRE_1X_1f_SET BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_POST1_POST1PRE_1X_1f_SET
#define POST1PRE_AFE_CTL0r_TXFIR_PRE_POST1PRE_1X_1f_GET BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_PRE_POST1PRE_1X_1f_GET
#define POST1PRE_AFE_CTL0r_TXFIR_PRE_POST1PRE_1X_1f_SET BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r_TXFIR_PRE_POST1PRE_1X_1f_SET
#define READ_POST1PRE_AFE_CTL0r BCMI_TSCE16_XGXS_READ_POST1PRE_AFE_CTL0r
#define WRITE_POST1PRE_AFE_CTL0r BCMI_TSCE16_XGXS_WRITE_POST1PRE_AFE_CTL0r
#define MODIFY_POST1PRE_AFE_CTL0r BCMI_TSCE16_XGXS_MODIFY_POST1PRE_AFE_CTL0r
#define READLN_POST1PRE_AFE_CTL0r BCMI_TSCE16_XGXS_READLN_POST1PRE_AFE_CTL0r
#define WRITELN_POST1PRE_AFE_CTL0r BCMI_TSCE16_XGXS_WRITELN_POST1PRE_AFE_CTL0r
#define WRITEALL_POST1PRE_AFE_CTL0r BCMI_TSCE16_XGXS_WRITEALL_POST1PRE_AFE_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_POST1PRE_AFE_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DC_LEVEL_AFE_CTL0
 * BLOCKS:   TX_FED
 * REGADDR:  0xd11e
 * DESC:     dc_level slice select control register
 * RESETVAL: 0xf (15)
 * ACCESS:   R/W
 * FIELDS:
 *     TXFIR_DC_LEVEL_0P5X txfir_dc_level_0p5x slice enablemaps to i_txk_fir_en_main pin on m16 afe
 *     TXFIR_DC_LEVEL_1X dc_level_1x slice enablemaps to i_txk_fir_en_main_cs[0] pin on m16 afe
 *     TXFIR_DC_LEVEL_2X_0 dc_level_2x[0] slice enablemaps to i_txk_fir_en_main_cs[1] pin on m16 afe
 *     TXFIR_DC_LEVEL_2X_1 dc_level_2x[1] slice enablemaps to i_txk_fir_en_main_cs[2] pin on m16 afe
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r (0x0000d11e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program DC_LEVEL_AFE_CTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r_s {
	uint32_t v[1];
	uint32_t dc_level_afe_ctl0[1];
	uint32_t _dc_level_afe_ctl0;
} BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r_t;

#define BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r_CLR(r) (r).dc_level_afe_ctl0[0] = 0
#define BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r_SET(r,d) (r).dc_level_afe_ctl0[0] = d
#define BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r_GET(r) (r).dc_level_afe_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r_TXFIR_DC_LEVEL_2X_1f_GET(r) ((((r).dc_level_afe_ctl0[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r_TXFIR_DC_LEVEL_2X_1f_SET(r,f) (r).dc_level_afe_ctl0[0]=(((r).dc_level_afe_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r_TXFIR_DC_LEVEL_2X_0f_GET(r) ((((r).dc_level_afe_ctl0[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r_TXFIR_DC_LEVEL_2X_0f_SET(r,f) (r).dc_level_afe_ctl0[0]=(((r).dc_level_afe_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r_TXFIR_DC_LEVEL_1Xf_GET(r) ((((r).dc_level_afe_ctl0[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r_TXFIR_DC_LEVEL_1Xf_SET(r,f) (r).dc_level_afe_ctl0[0]=(((r).dc_level_afe_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r_TXFIR_DC_LEVEL_0P5Xf_GET(r) (((r).dc_level_afe_ctl0[0]) & 0x1)
#define BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r_TXFIR_DC_LEVEL_0P5Xf_SET(r,f) (r).dc_level_afe_ctl0[0]=(((r).dc_level_afe_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DC_LEVEL_AFE_CTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DC_LEVEL_AFE_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r,(_r._dc_level_afe_ctl0))
#define BCMI_TSCE16_XGXS_WRITE_DC_LEVEL_AFE_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r,(_r._dc_level_afe_ctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DC_LEVEL_AFE_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r,(_r._dc_level_afe_ctl0))
#define BCMI_TSCE16_XGXS_READLN_DC_LEVEL_AFE_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dc_level_afe_ctl0))
#define BCMI_TSCE16_XGXS_WRITELN_DC_LEVEL_AFE_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dc_level_afe_ctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_DC_LEVEL_AFE_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dc_level_afe_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DC_LEVEL_AFE_CTL0r BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r
#define DC_LEVEL_AFE_CTL0r_SIZE BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r_SIZE
typedef BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r_t DC_LEVEL_AFE_CTL0r_t;
#define DC_LEVEL_AFE_CTL0r_CLR BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r_CLR
#define DC_LEVEL_AFE_CTL0r_SET BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r_SET
#define DC_LEVEL_AFE_CTL0r_GET BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r_GET
#define DC_LEVEL_AFE_CTL0r_TXFIR_DC_LEVEL_2X_1f_GET BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r_TXFIR_DC_LEVEL_2X_1f_GET
#define DC_LEVEL_AFE_CTL0r_TXFIR_DC_LEVEL_2X_1f_SET BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r_TXFIR_DC_LEVEL_2X_1f_SET
#define DC_LEVEL_AFE_CTL0r_TXFIR_DC_LEVEL_2X_0f_GET BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r_TXFIR_DC_LEVEL_2X_0f_GET
#define DC_LEVEL_AFE_CTL0r_TXFIR_DC_LEVEL_2X_0f_SET BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r_TXFIR_DC_LEVEL_2X_0f_SET
#define DC_LEVEL_AFE_CTL0r_TXFIR_DC_LEVEL_1Xf_GET BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r_TXFIR_DC_LEVEL_1Xf_GET
#define DC_LEVEL_AFE_CTL0r_TXFIR_DC_LEVEL_1Xf_SET BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r_TXFIR_DC_LEVEL_1Xf_SET
#define DC_LEVEL_AFE_CTL0r_TXFIR_DC_LEVEL_0P5Xf_GET BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r_TXFIR_DC_LEVEL_0P5Xf_GET
#define DC_LEVEL_AFE_CTL0r_TXFIR_DC_LEVEL_0P5Xf_SET BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r_TXFIR_DC_LEVEL_0P5Xf_SET
#define READ_DC_LEVEL_AFE_CTL0r BCMI_TSCE16_XGXS_READ_DC_LEVEL_AFE_CTL0r
#define WRITE_DC_LEVEL_AFE_CTL0r BCMI_TSCE16_XGXS_WRITE_DC_LEVEL_AFE_CTL0r
#define MODIFY_DC_LEVEL_AFE_CTL0r BCMI_TSCE16_XGXS_MODIFY_DC_LEVEL_AFE_CTL0r
#define READLN_DC_LEVEL_AFE_CTL0r BCMI_TSCE16_XGXS_READLN_DC_LEVEL_AFE_CTL0r
#define WRITELN_DC_LEVEL_AFE_CTL0r BCMI_TSCE16_XGXS_WRITELN_DC_LEVEL_AFE_CTL0r
#define WRITEALL_DC_LEVEL_AFE_CTL0r BCMI_TSCE16_XGXS_WRITEALL_DC_LEVEL_AFE_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DC_LEVEL_AFE_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PLL_CALCTL0
 * BLOCKS:   PLL_CAL
 * REGADDR:  0xd120
 * DESC:     PLL_CALCTL_0
 * RESETVAL: 0x1ffa (8186)
 * ACCESS:   R/W
 * FIELDS:
 *     CALIB_STEP_TIME  The number of divided vco/ref calibration clocks to wait after the pll range has been changed
 *     CAL_TH           programmable PLL calibration threshold for best, typical and worst case
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PLL_CALCTL0r (0x0000d120 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PLL_CALCTL0r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CALCTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_PLL_CALCTL0r_s {
	uint32_t v[1];
	uint32_t pll_calctl0[1];
	uint32_t _pll_calctl0;
} BCMI_TSCE16_XGXS_PLL_CALCTL0r_t;

#define BCMI_TSCE16_XGXS_PLL_CALCTL0r_CLR(r) (r).pll_calctl0[0] = 0
#define BCMI_TSCE16_XGXS_PLL_CALCTL0r_SET(r,d) (r).pll_calctl0[0] = d
#define BCMI_TSCE16_XGXS_PLL_CALCTL0r_GET(r) (r).pll_calctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PLL_CALCTL0r_CAL_THf_GET(r) ((((r).pll_calctl0[0]) >> 14) & 0x3)
#define BCMI_TSCE16_XGXS_PLL_CALCTL0r_CAL_THf_SET(r,f) (r).pll_calctl0[0]=(((r).pll_calctl0[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCE16_XGXS_PLL_CALCTL0r_CALIB_STEP_TIMEf_GET(r) (((r).pll_calctl0[0]) & 0x1fff)
#define BCMI_TSCE16_XGXS_PLL_CALCTL0r_CALIB_STEP_TIMEf_SET(r,f) (r).pll_calctl0[0]=(((r).pll_calctl0[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access PLL_CALCTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PLL_CALCTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL0r,(_r._pll_calctl0))
#define BCMI_TSCE16_XGXS_WRITE_PLL_CALCTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL0r,(_r._pll_calctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PLL_CALCTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL0r,(_r._pll_calctl0))
#define BCMI_TSCE16_XGXS_READLN_PLL_CALCTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_calctl0))
#define BCMI_TSCE16_XGXS_WRITELN_PLL_CALCTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_calctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_PLL_CALCTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_calctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CALCTL0r BCMI_TSCE16_XGXS_PLL_CALCTL0r
#define PLL_CALCTL0r_SIZE BCMI_TSCE16_XGXS_PLL_CALCTL0r_SIZE
typedef BCMI_TSCE16_XGXS_PLL_CALCTL0r_t PLL_CALCTL0r_t;
#define PLL_CALCTL0r_CLR BCMI_TSCE16_XGXS_PLL_CALCTL0r_CLR
#define PLL_CALCTL0r_SET BCMI_TSCE16_XGXS_PLL_CALCTL0r_SET
#define PLL_CALCTL0r_GET BCMI_TSCE16_XGXS_PLL_CALCTL0r_GET
#define PLL_CALCTL0r_CAL_THf_GET BCMI_TSCE16_XGXS_PLL_CALCTL0r_CAL_THf_GET
#define PLL_CALCTL0r_CAL_THf_SET BCMI_TSCE16_XGXS_PLL_CALCTL0r_CAL_THf_SET
#define PLL_CALCTL0r_CALIB_STEP_TIMEf_GET BCMI_TSCE16_XGXS_PLL_CALCTL0r_CALIB_STEP_TIMEf_GET
#define PLL_CALCTL0r_CALIB_STEP_TIMEf_SET BCMI_TSCE16_XGXS_PLL_CALCTL0r_CALIB_STEP_TIMEf_SET
#define READ_PLL_CALCTL0r BCMI_TSCE16_XGXS_READ_PLL_CALCTL0r
#define WRITE_PLL_CALCTL0r BCMI_TSCE16_XGXS_WRITE_PLL_CALCTL0r
#define MODIFY_PLL_CALCTL0r BCMI_TSCE16_XGXS_MODIFY_PLL_CALCTL0r
#define READLN_PLL_CALCTL0r BCMI_TSCE16_XGXS_READLN_PLL_CALCTL0r
#define WRITELN_PLL_CALCTL0r BCMI_TSCE16_XGXS_WRITELN_PLL_CALCTL0r
#define WRITEALL_PLL_CALCTL0r BCMI_TSCE16_XGXS_WRITEALL_PLL_CALCTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PLL_CALCTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PLL_CALCTL1
 * BLOCKS:   PLL_CAL
 * REGADDR:  0xd121
 * DESC:     PLL_CALCTL_1
 * RESETVAL: 0xfff0 (65520)
 * ACCESS:   R/W
 * FIELDS:
 *     FREQDET_TIME     ref/vco counter terminal value in lockdet module
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PLL_CALCTL1r (0x0000d121 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PLL_CALCTL1r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CALCTL1.
 *
 */
typedef union BCMI_TSCE16_XGXS_PLL_CALCTL1r_s {
	uint32_t v[1];
	uint32_t pll_calctl1[1];
	uint32_t _pll_calctl1;
} BCMI_TSCE16_XGXS_PLL_CALCTL1r_t;

#define BCMI_TSCE16_XGXS_PLL_CALCTL1r_CLR(r) (r).pll_calctl1[0] = 0
#define BCMI_TSCE16_XGXS_PLL_CALCTL1r_SET(r,d) (r).pll_calctl1[0] = d
#define BCMI_TSCE16_XGXS_PLL_CALCTL1r_GET(r) (r).pll_calctl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PLL_CALCTL1r_FREQDET_TIMEf_GET(r) (((r).pll_calctl1[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PLL_CALCTL1r_FREQDET_TIMEf_SET(r,f) (r).pll_calctl1[0]=(((r).pll_calctl1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PLL_CALCTL1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PLL_CALCTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL1r,(_r._pll_calctl1))
#define BCMI_TSCE16_XGXS_WRITE_PLL_CALCTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL1r,(_r._pll_calctl1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PLL_CALCTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL1r,(_r._pll_calctl1))
#define BCMI_TSCE16_XGXS_READLN_PLL_CALCTL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_calctl1))
#define BCMI_TSCE16_XGXS_WRITELN_PLL_CALCTL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_calctl1))
#define BCMI_TSCE16_XGXS_WRITEALL_PLL_CALCTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_calctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CALCTL1r BCMI_TSCE16_XGXS_PLL_CALCTL1r
#define PLL_CALCTL1r_SIZE BCMI_TSCE16_XGXS_PLL_CALCTL1r_SIZE
typedef BCMI_TSCE16_XGXS_PLL_CALCTL1r_t PLL_CALCTL1r_t;
#define PLL_CALCTL1r_CLR BCMI_TSCE16_XGXS_PLL_CALCTL1r_CLR
#define PLL_CALCTL1r_SET BCMI_TSCE16_XGXS_PLL_CALCTL1r_SET
#define PLL_CALCTL1r_GET BCMI_TSCE16_XGXS_PLL_CALCTL1r_GET
#define PLL_CALCTL1r_FREQDET_TIMEf_GET BCMI_TSCE16_XGXS_PLL_CALCTL1r_FREQDET_TIMEf_GET
#define PLL_CALCTL1r_FREQDET_TIMEf_SET BCMI_TSCE16_XGXS_PLL_CALCTL1r_FREQDET_TIMEf_SET
#define READ_PLL_CALCTL1r BCMI_TSCE16_XGXS_READ_PLL_CALCTL1r
#define WRITE_PLL_CALCTL1r BCMI_TSCE16_XGXS_WRITE_PLL_CALCTL1r
#define MODIFY_PLL_CALCTL1r BCMI_TSCE16_XGXS_MODIFY_PLL_CALCTL1r
#define READLN_PLL_CALCTL1r BCMI_TSCE16_XGXS_READLN_PLL_CALCTL1r
#define WRITELN_PLL_CALCTL1r BCMI_TSCE16_XGXS_WRITELN_PLL_CALCTL1r
#define WRITEALL_PLL_CALCTL1r BCMI_TSCE16_XGXS_WRITEALL_PLL_CALCTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PLL_CALCTL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PLL_CALCTL2
 * BLOCKS:   PLL_CAL
 * REGADDR:  0xd122
 * DESC:     PLL_CALCTL_2
 * RESETVAL: 0xfff (4095)
 * ACCESS:   R/W
 * FIELDS:
 *     CALIB_CAP_CHARGE_TIME The number of divided ref calibration clocks to wait for initial cap charge time
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PLL_CALCTL2r (0x0000d122 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PLL_CALCTL2r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CALCTL2.
 *
 */
typedef union BCMI_TSCE16_XGXS_PLL_CALCTL2r_s {
	uint32_t v[1];
	uint32_t pll_calctl2[1];
	uint32_t _pll_calctl2;
} BCMI_TSCE16_XGXS_PLL_CALCTL2r_t;

#define BCMI_TSCE16_XGXS_PLL_CALCTL2r_CLR(r) (r).pll_calctl2[0] = 0
#define BCMI_TSCE16_XGXS_PLL_CALCTL2r_SET(r,d) (r).pll_calctl2[0] = d
#define BCMI_TSCE16_XGXS_PLL_CALCTL2r_GET(r) (r).pll_calctl2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PLL_CALCTL2r_CALIB_CAP_CHARGE_TIMEf_GET(r) (((r).pll_calctl2[0]) & 0xfff)
#define BCMI_TSCE16_XGXS_PLL_CALCTL2r_CALIB_CAP_CHARGE_TIMEf_SET(r,f) (r).pll_calctl2[0]=(((r).pll_calctl2[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff)) | (0xfff << 16)

/*
 * These macros can be used to access PLL_CALCTL2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PLL_CALCTL2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL2r,(_r._pll_calctl2))
#define BCMI_TSCE16_XGXS_WRITE_PLL_CALCTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL2r,(_r._pll_calctl2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PLL_CALCTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL2r,(_r._pll_calctl2))
#define BCMI_TSCE16_XGXS_READLN_PLL_CALCTL2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_calctl2))
#define BCMI_TSCE16_XGXS_WRITELN_PLL_CALCTL2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_calctl2))
#define BCMI_TSCE16_XGXS_WRITEALL_PLL_CALCTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_calctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CALCTL2r BCMI_TSCE16_XGXS_PLL_CALCTL2r
#define PLL_CALCTL2r_SIZE BCMI_TSCE16_XGXS_PLL_CALCTL2r_SIZE
typedef BCMI_TSCE16_XGXS_PLL_CALCTL2r_t PLL_CALCTL2r_t;
#define PLL_CALCTL2r_CLR BCMI_TSCE16_XGXS_PLL_CALCTL2r_CLR
#define PLL_CALCTL2r_SET BCMI_TSCE16_XGXS_PLL_CALCTL2r_SET
#define PLL_CALCTL2r_GET BCMI_TSCE16_XGXS_PLL_CALCTL2r_GET
#define PLL_CALCTL2r_CALIB_CAP_CHARGE_TIMEf_GET BCMI_TSCE16_XGXS_PLL_CALCTL2r_CALIB_CAP_CHARGE_TIMEf_GET
#define PLL_CALCTL2r_CALIB_CAP_CHARGE_TIMEf_SET BCMI_TSCE16_XGXS_PLL_CALCTL2r_CALIB_CAP_CHARGE_TIMEf_SET
#define READ_PLL_CALCTL2r BCMI_TSCE16_XGXS_READ_PLL_CALCTL2r
#define WRITE_PLL_CALCTL2r BCMI_TSCE16_XGXS_WRITE_PLL_CALCTL2r
#define MODIFY_PLL_CALCTL2r BCMI_TSCE16_XGXS_MODIFY_PLL_CALCTL2r
#define READLN_PLL_CALCTL2r BCMI_TSCE16_XGXS_READLN_PLL_CALCTL2r
#define WRITELN_PLL_CALCTL2r BCMI_TSCE16_XGXS_WRITELN_PLL_CALCTL2r
#define WRITEALL_PLL_CALCTL2r BCMI_TSCE16_XGXS_WRITEALL_PLL_CALCTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PLL_CALCTL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PLL_CALCTL3
 * BLOCKS:   PLL_CAL
 * REGADDR:  0xd123
 * DESC:     PLL_CALCTL_3
 * RESETVAL: 0x1007 (4103)
 * ACCESS:   R/W
 * FIELDS:
 *     FREQDET_WIN      Frequency detect compare window in lockdet module
 *     FREQDET_TIME_MSB The MSB for freqdet_time
 *     DEBUG_CLR        set 1 to clear debug status. cal state one hot
 *     ACCEL_EN         accelerated mode enable
 *     EXT_STATE        state to be forced into when in accelerated mode, dfs to s0
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PLL_CALCTL3r (0x0000d123 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PLL_CALCTL3r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CALCTL3.
 *
 */
typedef union BCMI_TSCE16_XGXS_PLL_CALCTL3r_s {
	uint32_t v[1];
	uint32_t pll_calctl3[1];
	uint32_t _pll_calctl3;
} BCMI_TSCE16_XGXS_PLL_CALCTL3r_t;

#define BCMI_TSCE16_XGXS_PLL_CALCTL3r_CLR(r) (r).pll_calctl3[0] = 0
#define BCMI_TSCE16_XGXS_PLL_CALCTL3r_SET(r,d) (r).pll_calctl3[0] = d
#define BCMI_TSCE16_XGXS_PLL_CALCTL3r_GET(r) (r).pll_calctl3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PLL_CALCTL3r_EXT_STATEf_GET(r) ((((r).pll_calctl3[0]) >> 12) & 0xf)
#define BCMI_TSCE16_XGXS_PLL_CALCTL3r_EXT_STATEf_SET(r,f) (r).pll_calctl3[0]=(((r).pll_calctl3[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCE16_XGXS_PLL_CALCTL3r_ACCEL_ENf_GET(r) ((((r).pll_calctl3[0]) >> 11) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CALCTL3r_ACCEL_ENf_SET(r,f) (r).pll_calctl3[0]=(((r).pll_calctl3[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCE16_XGXS_PLL_CALCTL3r_DEBUG_CLRf_GET(r) ((((r).pll_calctl3[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CALCTL3r_DEBUG_CLRf_SET(r,f) (r).pll_calctl3[0]=(((r).pll_calctl3[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_PLL_CALCTL3r_FREQDET_TIME_MSBf_GET(r) ((((r).pll_calctl3[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CALCTL3r_FREQDET_TIME_MSBf_SET(r,f) (r).pll_calctl3[0]=(((r).pll_calctl3[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_PLL_CALCTL3r_FREQDET_WINf_GET(r) (((r).pll_calctl3[0]) & 0xff)
#define BCMI_TSCE16_XGXS_PLL_CALCTL3r_FREQDET_WINf_SET(r,f) (r).pll_calctl3[0]=(((r).pll_calctl3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access PLL_CALCTL3.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PLL_CALCTL3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL3r,(_r._pll_calctl3))
#define BCMI_TSCE16_XGXS_WRITE_PLL_CALCTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL3r,(_r._pll_calctl3)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PLL_CALCTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL3r,(_r._pll_calctl3))
#define BCMI_TSCE16_XGXS_READLN_PLL_CALCTL3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_calctl3))
#define BCMI_TSCE16_XGXS_WRITELN_PLL_CALCTL3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_calctl3))
#define BCMI_TSCE16_XGXS_WRITEALL_PLL_CALCTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_calctl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CALCTL3r BCMI_TSCE16_XGXS_PLL_CALCTL3r
#define PLL_CALCTL3r_SIZE BCMI_TSCE16_XGXS_PLL_CALCTL3r_SIZE
typedef BCMI_TSCE16_XGXS_PLL_CALCTL3r_t PLL_CALCTL3r_t;
#define PLL_CALCTL3r_CLR BCMI_TSCE16_XGXS_PLL_CALCTL3r_CLR
#define PLL_CALCTL3r_SET BCMI_TSCE16_XGXS_PLL_CALCTL3r_SET
#define PLL_CALCTL3r_GET BCMI_TSCE16_XGXS_PLL_CALCTL3r_GET
#define PLL_CALCTL3r_EXT_STATEf_GET BCMI_TSCE16_XGXS_PLL_CALCTL3r_EXT_STATEf_GET
#define PLL_CALCTL3r_EXT_STATEf_SET BCMI_TSCE16_XGXS_PLL_CALCTL3r_EXT_STATEf_SET
#define PLL_CALCTL3r_ACCEL_ENf_GET BCMI_TSCE16_XGXS_PLL_CALCTL3r_ACCEL_ENf_GET
#define PLL_CALCTL3r_ACCEL_ENf_SET BCMI_TSCE16_XGXS_PLL_CALCTL3r_ACCEL_ENf_SET
#define PLL_CALCTL3r_DEBUG_CLRf_GET BCMI_TSCE16_XGXS_PLL_CALCTL3r_DEBUG_CLRf_GET
#define PLL_CALCTL3r_DEBUG_CLRf_SET BCMI_TSCE16_XGXS_PLL_CALCTL3r_DEBUG_CLRf_SET
#define PLL_CALCTL3r_FREQDET_TIME_MSBf_GET BCMI_TSCE16_XGXS_PLL_CALCTL3r_FREQDET_TIME_MSBf_GET
#define PLL_CALCTL3r_FREQDET_TIME_MSBf_SET BCMI_TSCE16_XGXS_PLL_CALCTL3r_FREQDET_TIME_MSBf_SET
#define PLL_CALCTL3r_FREQDET_WINf_GET BCMI_TSCE16_XGXS_PLL_CALCTL3r_FREQDET_WINf_GET
#define PLL_CALCTL3r_FREQDET_WINf_SET BCMI_TSCE16_XGXS_PLL_CALCTL3r_FREQDET_WINf_SET
#define READ_PLL_CALCTL3r BCMI_TSCE16_XGXS_READ_PLL_CALCTL3r
#define WRITE_PLL_CALCTL3r BCMI_TSCE16_XGXS_WRITE_PLL_CALCTL3r
#define MODIFY_PLL_CALCTL3r BCMI_TSCE16_XGXS_MODIFY_PLL_CALCTL3r
#define READLN_PLL_CALCTL3r BCMI_TSCE16_XGXS_READLN_PLL_CALCTL3r
#define WRITELN_PLL_CALCTL3r BCMI_TSCE16_XGXS_WRITELN_PLL_CALCTL3r
#define WRITEALL_PLL_CALCTL3r BCMI_TSCE16_XGXS_WRITEALL_PLL_CALCTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PLL_CALCTL3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PLL_CALCTL4
 * BLOCKS:   PLL_CAL
 * REGADDR:  0xd124
 * DESC:     PLL_CALCTL_4
 * RESETVAL: 0x8240 (33344)
 * ACCESS:   R/W
 * FIELDS:
 *     EXT_RANGE        Externally programmable value for PLL_RANGE
 *     EN_CALIB_N       Enable calibration - active low
 *     CALIB_START      1 to start calib, 0 to disable calibration
 *     CAP_DELAY        additional delay to calibration step time
 *     CAL_PAUSE_REL    release pausing to calib process at posedge, for debug only
 *     CAL_PAUSE_EN     enable pausing to calib process, for debug only
 *     PLL_FORCE_CAP_PASS force cal_valid value
 *     PLL_FORCE_CAP_PASS_EN force cal_valid
 *     HALFSTEP_EN      enable half_step pll calibration
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PLL_CALCTL4r (0x0000d124 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PLL_CALCTL4r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CALCTL4.
 *
 */
typedef union BCMI_TSCE16_XGXS_PLL_CALCTL4r_s {
	uint32_t v[1];
	uint32_t pll_calctl4[1];
	uint32_t _pll_calctl4;
} BCMI_TSCE16_XGXS_PLL_CALCTL4r_t;

#define BCMI_TSCE16_XGXS_PLL_CALCTL4r_CLR(r) (r).pll_calctl4[0] = 0
#define BCMI_TSCE16_XGXS_PLL_CALCTL4r_SET(r,d) (r).pll_calctl4[0] = d
#define BCMI_TSCE16_XGXS_PLL_CALCTL4r_GET(r) (r).pll_calctl4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PLL_CALCTL4r_HALFSTEP_ENf_GET(r) ((((r).pll_calctl4[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CALCTL4r_HALFSTEP_ENf_SET(r,f) (r).pll_calctl4[0]=(((r).pll_calctl4[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_PLL_CALCTL4r_PLL_FORCE_CAP_PASS_ENf_GET(r) ((((r).pll_calctl4[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CALCTL4r_PLL_FORCE_CAP_PASS_ENf_SET(r,f) (r).pll_calctl4[0]=(((r).pll_calctl4[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_PLL_CALCTL4r_PLL_FORCE_CAP_PASSf_GET(r) ((((r).pll_calctl4[0]) >> 13) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CALCTL4r_PLL_FORCE_CAP_PASSf_SET(r,f) (r).pll_calctl4[0]=(((r).pll_calctl4[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCE16_XGXS_PLL_CALCTL4r_CAL_PAUSE_ENf_GET(r) ((((r).pll_calctl4[0]) >> 12) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CALCTL4r_CAL_PAUSE_ENf_SET(r,f) (r).pll_calctl4[0]=(((r).pll_calctl4[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCE16_XGXS_PLL_CALCTL4r_CAL_PAUSE_RELf_GET(r) ((((r).pll_calctl4[0]) >> 11) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CALCTL4r_CAL_PAUSE_RELf_SET(r,f) (r).pll_calctl4[0]=(((r).pll_calctl4[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCE16_XGXS_PLL_CALCTL4r_CAP_DELAYf_GET(r) ((((r).pll_calctl4[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CALCTL4r_CAP_DELAYf_SET(r,f) (r).pll_calctl4[0]=(((r).pll_calctl4[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_PLL_CALCTL4r_CALIB_STARTf_GET(r) ((((r).pll_calctl4[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CALCTL4r_CALIB_STARTf_SET(r,f) (r).pll_calctl4[0]=(((r).pll_calctl4[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_PLL_CALCTL4r_EN_CALIB_Nf_GET(r) ((((r).pll_calctl4[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CALCTL4r_EN_CALIB_Nf_SET(r,f) (r).pll_calctl4[0]=(((r).pll_calctl4[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_PLL_CALCTL4r_EXT_RANGEf_GET(r) (((r).pll_calctl4[0]) & 0x7f)
#define BCMI_TSCE16_XGXS_PLL_CALCTL4r_EXT_RANGEf_SET(r,f) (r).pll_calctl4[0]=(((r).pll_calctl4[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access PLL_CALCTL4.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PLL_CALCTL4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL4r,(_r._pll_calctl4))
#define BCMI_TSCE16_XGXS_WRITE_PLL_CALCTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL4r,(_r._pll_calctl4)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PLL_CALCTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL4r,(_r._pll_calctl4))
#define BCMI_TSCE16_XGXS_READLN_PLL_CALCTL4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_calctl4))
#define BCMI_TSCE16_XGXS_WRITELN_PLL_CALCTL4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_calctl4))
#define BCMI_TSCE16_XGXS_WRITEALL_PLL_CALCTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_calctl4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CALCTL4r BCMI_TSCE16_XGXS_PLL_CALCTL4r
#define PLL_CALCTL4r_SIZE BCMI_TSCE16_XGXS_PLL_CALCTL4r_SIZE
typedef BCMI_TSCE16_XGXS_PLL_CALCTL4r_t PLL_CALCTL4r_t;
#define PLL_CALCTL4r_CLR BCMI_TSCE16_XGXS_PLL_CALCTL4r_CLR
#define PLL_CALCTL4r_SET BCMI_TSCE16_XGXS_PLL_CALCTL4r_SET
#define PLL_CALCTL4r_GET BCMI_TSCE16_XGXS_PLL_CALCTL4r_GET
#define PLL_CALCTL4r_HALFSTEP_ENf_GET BCMI_TSCE16_XGXS_PLL_CALCTL4r_HALFSTEP_ENf_GET
#define PLL_CALCTL4r_HALFSTEP_ENf_SET BCMI_TSCE16_XGXS_PLL_CALCTL4r_HALFSTEP_ENf_SET
#define PLL_CALCTL4r_PLL_FORCE_CAP_PASS_ENf_GET BCMI_TSCE16_XGXS_PLL_CALCTL4r_PLL_FORCE_CAP_PASS_ENf_GET
#define PLL_CALCTL4r_PLL_FORCE_CAP_PASS_ENf_SET BCMI_TSCE16_XGXS_PLL_CALCTL4r_PLL_FORCE_CAP_PASS_ENf_SET
#define PLL_CALCTL4r_PLL_FORCE_CAP_PASSf_GET BCMI_TSCE16_XGXS_PLL_CALCTL4r_PLL_FORCE_CAP_PASSf_GET
#define PLL_CALCTL4r_PLL_FORCE_CAP_PASSf_SET BCMI_TSCE16_XGXS_PLL_CALCTL4r_PLL_FORCE_CAP_PASSf_SET
#define PLL_CALCTL4r_CAL_PAUSE_ENf_GET BCMI_TSCE16_XGXS_PLL_CALCTL4r_CAL_PAUSE_ENf_GET
#define PLL_CALCTL4r_CAL_PAUSE_ENf_SET BCMI_TSCE16_XGXS_PLL_CALCTL4r_CAL_PAUSE_ENf_SET
#define PLL_CALCTL4r_CAL_PAUSE_RELf_GET BCMI_TSCE16_XGXS_PLL_CALCTL4r_CAL_PAUSE_RELf_GET
#define PLL_CALCTL4r_CAL_PAUSE_RELf_SET BCMI_TSCE16_XGXS_PLL_CALCTL4r_CAL_PAUSE_RELf_SET
#define PLL_CALCTL4r_CAP_DELAYf_GET BCMI_TSCE16_XGXS_PLL_CALCTL4r_CAP_DELAYf_GET
#define PLL_CALCTL4r_CAP_DELAYf_SET BCMI_TSCE16_XGXS_PLL_CALCTL4r_CAP_DELAYf_SET
#define PLL_CALCTL4r_CALIB_STARTf_GET BCMI_TSCE16_XGXS_PLL_CALCTL4r_CALIB_STARTf_GET
#define PLL_CALCTL4r_CALIB_STARTf_SET BCMI_TSCE16_XGXS_PLL_CALCTL4r_CALIB_STARTf_SET
#define PLL_CALCTL4r_EN_CALIB_Nf_GET BCMI_TSCE16_XGXS_PLL_CALCTL4r_EN_CALIB_Nf_GET
#define PLL_CALCTL4r_EN_CALIB_Nf_SET BCMI_TSCE16_XGXS_PLL_CALCTL4r_EN_CALIB_Nf_SET
#define PLL_CALCTL4r_EXT_RANGEf_GET BCMI_TSCE16_XGXS_PLL_CALCTL4r_EXT_RANGEf_GET
#define PLL_CALCTL4r_EXT_RANGEf_SET BCMI_TSCE16_XGXS_PLL_CALCTL4r_EXT_RANGEf_SET
#define READ_PLL_CALCTL4r BCMI_TSCE16_XGXS_READ_PLL_CALCTL4r
#define WRITE_PLL_CALCTL4r BCMI_TSCE16_XGXS_WRITE_PLL_CALCTL4r
#define MODIFY_PLL_CALCTL4r BCMI_TSCE16_XGXS_MODIFY_PLL_CALCTL4r
#define READLN_PLL_CALCTL4r BCMI_TSCE16_XGXS_READLN_PLL_CALCTL4r
#define WRITELN_PLL_CALCTL4r BCMI_TSCE16_XGXS_WRITELN_PLL_CALCTL4r
#define WRITEALL_PLL_CALCTL4r BCMI_TSCE16_XGXS_WRITEALL_PLL_CALCTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PLL_CALCTL4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PLL_CALCTL5
 * BLOCKS:   PLL_CAL
 * REGADDR:  0xd125
 * DESC:     PLL_CALCTL_5
 * RESETVAL: 0x8160 (33120)
 * ACCESS:   R/W
 * FIELDS:
 *     PLLFORCE_FDONE_EN Force Frequency detect
 *     PLLFORCE_FDONE   Force Frequency detect value value
 *     PLL_LOCK_FRC     Force PLL Lock
 *     PLL_LOCK_FRC_VAL Force Pll Lock value
 *     LKDT_BYP         Bypass lock detect process and force Lock
 *     AUTOCAL_CNT      auto calibration count
 *     AUTOCAL_EN       auto calibration enable when no pll_lock after numbers of trials in autocal_cnt
 *     VCO_RST_EN       Enable PLL reset when PLL is in start state. For debug only, use core_dp_s/h_rstb to re-start PLL calibration
 *     LKDT_PAUSE_REL   Release pausing for Frequency detect, for debug only
 *     LKDT_PAUSE_EN    Enable pausing for Frequency detect, for debug only
 *     PLL_SEQ_START    To start the pll sequence. For debug only, use core_dp_s/h_rstb to re-start PLL calibration
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PLL_CALCTL5r (0x0000d125 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PLL_CALCTL5r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CALCTL5.
 *
 */
typedef union BCMI_TSCE16_XGXS_PLL_CALCTL5r_s {
	uint32_t v[1];
	uint32_t pll_calctl5[1];
	uint32_t _pll_calctl5;
} BCMI_TSCE16_XGXS_PLL_CALCTL5r_t;

#define BCMI_TSCE16_XGXS_PLL_CALCTL5r_CLR(r) (r).pll_calctl5[0] = 0
#define BCMI_TSCE16_XGXS_PLL_CALCTL5r_SET(r,d) (r).pll_calctl5[0] = d
#define BCMI_TSCE16_XGXS_PLL_CALCTL5r_GET(r) (r).pll_calctl5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PLL_CALCTL5r_PLL_SEQ_STARTf_GET(r) ((((r).pll_calctl5[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CALCTL5r_PLL_SEQ_STARTf_SET(r,f) (r).pll_calctl5[0]=(((r).pll_calctl5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_PLL_CALCTL5r_LKDT_PAUSE_ENf_GET(r) ((((r).pll_calctl5[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CALCTL5r_LKDT_PAUSE_ENf_SET(r,f) (r).pll_calctl5[0]=(((r).pll_calctl5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_PLL_CALCTL5r_LKDT_PAUSE_RELf_GET(r) ((((r).pll_calctl5[0]) >> 13) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CALCTL5r_LKDT_PAUSE_RELf_SET(r,f) (r).pll_calctl5[0]=(((r).pll_calctl5[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCE16_XGXS_PLL_CALCTL5r_VCO_RST_ENf_GET(r) ((((r).pll_calctl5[0]) >> 12) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CALCTL5r_VCO_RST_ENf_SET(r,f) (r).pll_calctl5[0]=(((r).pll_calctl5[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCE16_XGXS_PLL_CALCTL5r_AUTOCAL_ENf_GET(r) ((((r).pll_calctl5[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CALCTL5r_AUTOCAL_ENf_SET(r,f) (r).pll_calctl5[0]=(((r).pll_calctl5[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_PLL_CALCTL5r_AUTOCAL_CNTf_GET(r) ((((r).pll_calctl5[0]) >> 5) & 0x7)
#define BCMI_TSCE16_XGXS_PLL_CALCTL5r_AUTOCAL_CNTf_SET(r,f) (r).pll_calctl5[0]=(((r).pll_calctl5[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5)) | (7 << (16 + 5))
#define BCMI_TSCE16_XGXS_PLL_CALCTL5r_LKDT_BYPf_GET(r) ((((r).pll_calctl5[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CALCTL5r_LKDT_BYPf_SET(r,f) (r).pll_calctl5[0]=(((r).pll_calctl5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_PLL_CALCTL5r_PLL_LOCK_FRC_VALf_GET(r) ((((r).pll_calctl5[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CALCTL5r_PLL_LOCK_FRC_VALf_SET(r,f) (r).pll_calctl5[0]=(((r).pll_calctl5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_PLL_CALCTL5r_PLL_LOCK_FRCf_GET(r) ((((r).pll_calctl5[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CALCTL5r_PLL_LOCK_FRCf_SET(r,f) (r).pll_calctl5[0]=(((r).pll_calctl5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_PLL_CALCTL5r_PLLFORCE_FDONEf_GET(r) ((((r).pll_calctl5[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CALCTL5r_PLLFORCE_FDONEf_SET(r,f) (r).pll_calctl5[0]=(((r).pll_calctl5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_PLL_CALCTL5r_PLLFORCE_FDONE_ENf_GET(r) (((r).pll_calctl5[0]) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CALCTL5r_PLLFORCE_FDONE_ENf_SET(r,f) (r).pll_calctl5[0]=(((r).pll_calctl5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PLL_CALCTL5.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PLL_CALCTL5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL5r,(_r._pll_calctl5))
#define BCMI_TSCE16_XGXS_WRITE_PLL_CALCTL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL5r,(_r._pll_calctl5)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PLL_CALCTL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL5r,(_r._pll_calctl5))
#define BCMI_TSCE16_XGXS_READLN_PLL_CALCTL5r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_calctl5))
#define BCMI_TSCE16_XGXS_WRITELN_PLL_CALCTL5r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_calctl5))
#define BCMI_TSCE16_XGXS_WRITEALL_PLL_CALCTL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_calctl5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CALCTL5r BCMI_TSCE16_XGXS_PLL_CALCTL5r
#define PLL_CALCTL5r_SIZE BCMI_TSCE16_XGXS_PLL_CALCTL5r_SIZE
typedef BCMI_TSCE16_XGXS_PLL_CALCTL5r_t PLL_CALCTL5r_t;
#define PLL_CALCTL5r_CLR BCMI_TSCE16_XGXS_PLL_CALCTL5r_CLR
#define PLL_CALCTL5r_SET BCMI_TSCE16_XGXS_PLL_CALCTL5r_SET
#define PLL_CALCTL5r_GET BCMI_TSCE16_XGXS_PLL_CALCTL5r_GET
#define PLL_CALCTL5r_PLL_SEQ_STARTf_GET BCMI_TSCE16_XGXS_PLL_CALCTL5r_PLL_SEQ_STARTf_GET
#define PLL_CALCTL5r_PLL_SEQ_STARTf_SET BCMI_TSCE16_XGXS_PLL_CALCTL5r_PLL_SEQ_STARTf_SET
#define PLL_CALCTL5r_LKDT_PAUSE_ENf_GET BCMI_TSCE16_XGXS_PLL_CALCTL5r_LKDT_PAUSE_ENf_GET
#define PLL_CALCTL5r_LKDT_PAUSE_ENf_SET BCMI_TSCE16_XGXS_PLL_CALCTL5r_LKDT_PAUSE_ENf_SET
#define PLL_CALCTL5r_LKDT_PAUSE_RELf_GET BCMI_TSCE16_XGXS_PLL_CALCTL5r_LKDT_PAUSE_RELf_GET
#define PLL_CALCTL5r_LKDT_PAUSE_RELf_SET BCMI_TSCE16_XGXS_PLL_CALCTL5r_LKDT_PAUSE_RELf_SET
#define PLL_CALCTL5r_VCO_RST_ENf_GET BCMI_TSCE16_XGXS_PLL_CALCTL5r_VCO_RST_ENf_GET
#define PLL_CALCTL5r_VCO_RST_ENf_SET BCMI_TSCE16_XGXS_PLL_CALCTL5r_VCO_RST_ENf_SET
#define PLL_CALCTL5r_AUTOCAL_ENf_GET BCMI_TSCE16_XGXS_PLL_CALCTL5r_AUTOCAL_ENf_GET
#define PLL_CALCTL5r_AUTOCAL_ENf_SET BCMI_TSCE16_XGXS_PLL_CALCTL5r_AUTOCAL_ENf_SET
#define PLL_CALCTL5r_AUTOCAL_CNTf_GET BCMI_TSCE16_XGXS_PLL_CALCTL5r_AUTOCAL_CNTf_GET
#define PLL_CALCTL5r_AUTOCAL_CNTf_SET BCMI_TSCE16_XGXS_PLL_CALCTL5r_AUTOCAL_CNTf_SET
#define PLL_CALCTL5r_LKDT_BYPf_GET BCMI_TSCE16_XGXS_PLL_CALCTL5r_LKDT_BYPf_GET
#define PLL_CALCTL5r_LKDT_BYPf_SET BCMI_TSCE16_XGXS_PLL_CALCTL5r_LKDT_BYPf_SET
#define PLL_CALCTL5r_PLL_LOCK_FRC_VALf_GET BCMI_TSCE16_XGXS_PLL_CALCTL5r_PLL_LOCK_FRC_VALf_GET
#define PLL_CALCTL5r_PLL_LOCK_FRC_VALf_SET BCMI_TSCE16_XGXS_PLL_CALCTL5r_PLL_LOCK_FRC_VALf_SET
#define PLL_CALCTL5r_PLL_LOCK_FRCf_GET BCMI_TSCE16_XGXS_PLL_CALCTL5r_PLL_LOCK_FRCf_GET
#define PLL_CALCTL5r_PLL_LOCK_FRCf_SET BCMI_TSCE16_XGXS_PLL_CALCTL5r_PLL_LOCK_FRCf_SET
#define PLL_CALCTL5r_PLLFORCE_FDONEf_GET BCMI_TSCE16_XGXS_PLL_CALCTL5r_PLLFORCE_FDONEf_GET
#define PLL_CALCTL5r_PLLFORCE_FDONEf_SET BCMI_TSCE16_XGXS_PLL_CALCTL5r_PLLFORCE_FDONEf_SET
#define PLL_CALCTL5r_PLLFORCE_FDONE_ENf_GET BCMI_TSCE16_XGXS_PLL_CALCTL5r_PLLFORCE_FDONE_ENf_GET
#define PLL_CALCTL5r_PLLFORCE_FDONE_ENf_SET BCMI_TSCE16_XGXS_PLL_CALCTL5r_PLLFORCE_FDONE_ENf_SET
#define READ_PLL_CALCTL5r BCMI_TSCE16_XGXS_READ_PLL_CALCTL5r
#define WRITE_PLL_CALCTL5r BCMI_TSCE16_XGXS_WRITE_PLL_CALCTL5r
#define MODIFY_PLL_CALCTL5r BCMI_TSCE16_XGXS_MODIFY_PLL_CALCTL5r
#define READLN_PLL_CALCTL5r BCMI_TSCE16_XGXS_READLN_PLL_CALCTL5r
#define WRITELN_PLL_CALCTL5r BCMI_TSCE16_XGXS_WRITELN_PLL_CALCTL5r
#define WRITEALL_PLL_CALCTL5r BCMI_TSCE16_XGXS_WRITEALL_PLL_CALCTL5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PLL_CALCTL5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PLL_CALCTL6
 * BLOCKS:   PLL_CAL
 * REGADDR:  0xd126
 * DESC:     PLL_CALCTL_6
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PLLPON_SEL       1= select AMS pllpon value, 0= select pllpon_int (sum or external rescal)
 *     VCOPON_SEL       1= select AMS vcopon value, 0= select vcopon_int (sum or external rescal)
 *     VCOBUFPON_SEL    1= select AMS vcobufpon value, 0= select vcobufpon_int (sum or external rescal)
 *     VCORANGE_SEL     Force select AMS vcorange value else select pll_range from pll calibration
 *     BAND_IQBUF_SEL   Force select AMS band_iqbuf value else select pll_range[6:4] from pll calibration
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PLL_CALCTL6r (0x0000d126 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PLL_CALCTL6r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CALCTL6.
 *
 */
typedef union BCMI_TSCE16_XGXS_PLL_CALCTL6r_s {
	uint32_t v[1];
	uint32_t pll_calctl6[1];
	uint32_t _pll_calctl6;
} BCMI_TSCE16_XGXS_PLL_CALCTL6r_t;

#define BCMI_TSCE16_XGXS_PLL_CALCTL6r_CLR(r) (r).pll_calctl6[0] = 0
#define BCMI_TSCE16_XGXS_PLL_CALCTL6r_SET(r,d) (r).pll_calctl6[0] = d
#define BCMI_TSCE16_XGXS_PLL_CALCTL6r_GET(r) (r).pll_calctl6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PLL_CALCTL6r_BAND_IQBUF_SELf_GET(r) ((((r).pll_calctl6[0]) >> 7) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CALCTL6r_BAND_IQBUF_SELf_SET(r,f) (r).pll_calctl6[0]=(((r).pll_calctl6[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCE16_XGXS_PLL_CALCTL6r_VCORANGE_SELf_GET(r) ((((r).pll_calctl6[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CALCTL6r_VCORANGE_SELf_SET(r,f) (r).pll_calctl6[0]=(((r).pll_calctl6[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_PLL_CALCTL6r_VCOBUFPON_SELf_GET(r) ((((r).pll_calctl6[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CALCTL6r_VCOBUFPON_SELf_SET(r,f) (r).pll_calctl6[0]=(((r).pll_calctl6[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_PLL_CALCTL6r_VCOPON_SELf_GET(r) ((((r).pll_calctl6[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CALCTL6r_VCOPON_SELf_SET(r,f) (r).pll_calctl6[0]=(((r).pll_calctl6[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_PLL_CALCTL6r_PLLPON_SELf_GET(r) ((((r).pll_calctl6[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CALCTL6r_PLLPON_SELf_SET(r,f) (r).pll_calctl6[0]=(((r).pll_calctl6[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access PLL_CALCTL6.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PLL_CALCTL6r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL6r,(_r._pll_calctl6))
#define BCMI_TSCE16_XGXS_WRITE_PLL_CALCTL6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL6r,(_r._pll_calctl6)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PLL_CALCTL6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL6r,(_r._pll_calctl6))
#define BCMI_TSCE16_XGXS_READLN_PLL_CALCTL6r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_calctl6))
#define BCMI_TSCE16_XGXS_WRITELN_PLL_CALCTL6r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_calctl6))
#define BCMI_TSCE16_XGXS_WRITEALL_PLL_CALCTL6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALCTL6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_calctl6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CALCTL6r BCMI_TSCE16_XGXS_PLL_CALCTL6r
#define PLL_CALCTL6r_SIZE BCMI_TSCE16_XGXS_PLL_CALCTL6r_SIZE
typedef BCMI_TSCE16_XGXS_PLL_CALCTL6r_t PLL_CALCTL6r_t;
#define PLL_CALCTL6r_CLR BCMI_TSCE16_XGXS_PLL_CALCTL6r_CLR
#define PLL_CALCTL6r_SET BCMI_TSCE16_XGXS_PLL_CALCTL6r_SET
#define PLL_CALCTL6r_GET BCMI_TSCE16_XGXS_PLL_CALCTL6r_GET
#define PLL_CALCTL6r_BAND_IQBUF_SELf_GET BCMI_TSCE16_XGXS_PLL_CALCTL6r_BAND_IQBUF_SELf_GET
#define PLL_CALCTL6r_BAND_IQBUF_SELf_SET BCMI_TSCE16_XGXS_PLL_CALCTL6r_BAND_IQBUF_SELf_SET
#define PLL_CALCTL6r_VCORANGE_SELf_GET BCMI_TSCE16_XGXS_PLL_CALCTL6r_VCORANGE_SELf_GET
#define PLL_CALCTL6r_VCORANGE_SELf_SET BCMI_TSCE16_XGXS_PLL_CALCTL6r_VCORANGE_SELf_SET
#define PLL_CALCTL6r_VCOBUFPON_SELf_GET BCMI_TSCE16_XGXS_PLL_CALCTL6r_VCOBUFPON_SELf_GET
#define PLL_CALCTL6r_VCOBUFPON_SELf_SET BCMI_TSCE16_XGXS_PLL_CALCTL6r_VCOBUFPON_SELf_SET
#define PLL_CALCTL6r_VCOPON_SELf_GET BCMI_TSCE16_XGXS_PLL_CALCTL6r_VCOPON_SELf_GET
#define PLL_CALCTL6r_VCOPON_SELf_SET BCMI_TSCE16_XGXS_PLL_CALCTL6r_VCOPON_SELf_SET
#define PLL_CALCTL6r_PLLPON_SELf_GET BCMI_TSCE16_XGXS_PLL_CALCTL6r_PLLPON_SELf_GET
#define PLL_CALCTL6r_PLLPON_SELf_SET BCMI_TSCE16_XGXS_PLL_CALCTL6r_PLLPON_SELf_SET
#define READ_PLL_CALCTL6r BCMI_TSCE16_XGXS_READ_PLL_CALCTL6r
#define WRITE_PLL_CALCTL6r BCMI_TSCE16_XGXS_WRITE_PLL_CALCTL6r
#define MODIFY_PLL_CALCTL6r BCMI_TSCE16_XGXS_MODIFY_PLL_CALCTL6r
#define READLN_PLL_CALCTL6r BCMI_TSCE16_XGXS_READLN_PLL_CALCTL6r
#define WRITELN_PLL_CALCTL6r BCMI_TSCE16_XGXS_WRITELN_PLL_CALCTL6r
#define WRITEALL_PLL_CALCTL6r BCMI_TSCE16_XGXS_WRITEALL_PLL_CALCTL6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PLL_CALCTL6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PLL_CALSTS0
 * BLOCKS:   PLL_CAL
 * REGADDR:  0xd128
 * DESC:     PLL_CALSTS_0
 * RESETVAL: 0x13f (319)
 * ACCESS:   R/O
 * FIELDS:
 *     PLL_RANGE        Pll range value
 *     PLL_LOCK_BAR_STKY Pll lock drop sticky status, clear upon read.
 *     PLL_LOCK         Pll lock status
 *     CAL_VALID        Cal valid status
 *     CAL_STATE        Calibratin State status, default to Idle state
 *     PLL_FAIL_STKY    Pll lock drop due to frequency comparison failure sticky status, clear upon read.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PLL_CALSTS0r (0x0000d128 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PLL_CALSTS0r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CALSTS0.
 *
 */
typedef union BCMI_TSCE16_XGXS_PLL_CALSTS0r_s {
	uint32_t v[1];
	uint32_t pll_calsts0[1];
	uint32_t _pll_calsts0;
} BCMI_TSCE16_XGXS_PLL_CALSTS0r_t;

#define BCMI_TSCE16_XGXS_PLL_CALSTS0r_CLR(r) (r).pll_calsts0[0] = 0
#define BCMI_TSCE16_XGXS_PLL_CALSTS0r_SET(r,d) (r).pll_calsts0[0] = d
#define BCMI_TSCE16_XGXS_PLL_CALSTS0r_GET(r) (r).pll_calsts0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PLL_CALSTS0r_PLL_FAIL_STKYf_GET(r) ((((r).pll_calsts0[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CALSTS0r_PLL_FAIL_STKYf_SET(r,f) (r).pll_calsts0[0]=(((r).pll_calsts0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_PLL_CALSTS0r_CAL_STATEf_GET(r) ((((r).pll_calsts0[0]) >> 11) & 0xf)
#define BCMI_TSCE16_XGXS_PLL_CALSTS0r_CAL_STATEf_SET(r,f) (r).pll_calsts0[0]=(((r).pll_calsts0[0] & ~((uint32_t)0xf << 11)) | ((((uint32_t)f) & 0xf) << 11)) | (15 << (16 + 11))
#define BCMI_TSCE16_XGXS_PLL_CALSTS0r_CAL_VALIDf_GET(r) ((((r).pll_calsts0[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CALSTS0r_CAL_VALIDf_SET(r,f) (r).pll_calsts0[0]=(((r).pll_calsts0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_PLL_CALSTS0r_PLL_LOCKf_GET(r) ((((r).pll_calsts0[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CALSTS0r_PLL_LOCKf_SET(r,f) (r).pll_calsts0[0]=(((r).pll_calsts0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_PLL_CALSTS0r_PLL_LOCK_BAR_STKYf_GET(r) ((((r).pll_calsts0[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CALSTS0r_PLL_LOCK_BAR_STKYf_SET(r,f) (r).pll_calsts0[0]=(((r).pll_calsts0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_PLL_CALSTS0r_PLL_RANGEf_GET(r) (((r).pll_calsts0[0]) & 0x7f)
#define BCMI_TSCE16_XGXS_PLL_CALSTS0r_PLL_RANGEf_SET(r,f) (r).pll_calsts0[0]=(((r).pll_calsts0[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access PLL_CALSTS0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PLL_CALSTS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS0r,(_r._pll_calsts0))
#define BCMI_TSCE16_XGXS_WRITE_PLL_CALSTS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS0r,(_r._pll_calsts0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PLL_CALSTS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS0r,(_r._pll_calsts0))
#define BCMI_TSCE16_XGXS_READLN_PLL_CALSTS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_calsts0))
#define BCMI_TSCE16_XGXS_WRITELN_PLL_CALSTS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_calsts0))
#define BCMI_TSCE16_XGXS_WRITEALL_PLL_CALSTS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_calsts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CALSTS0r BCMI_TSCE16_XGXS_PLL_CALSTS0r
#define PLL_CALSTS0r_SIZE BCMI_TSCE16_XGXS_PLL_CALSTS0r_SIZE
typedef BCMI_TSCE16_XGXS_PLL_CALSTS0r_t PLL_CALSTS0r_t;
#define PLL_CALSTS0r_CLR BCMI_TSCE16_XGXS_PLL_CALSTS0r_CLR
#define PLL_CALSTS0r_SET BCMI_TSCE16_XGXS_PLL_CALSTS0r_SET
#define PLL_CALSTS0r_GET BCMI_TSCE16_XGXS_PLL_CALSTS0r_GET
#define PLL_CALSTS0r_PLL_FAIL_STKYf_GET BCMI_TSCE16_XGXS_PLL_CALSTS0r_PLL_FAIL_STKYf_GET
#define PLL_CALSTS0r_PLL_FAIL_STKYf_SET BCMI_TSCE16_XGXS_PLL_CALSTS0r_PLL_FAIL_STKYf_SET
#define PLL_CALSTS0r_CAL_STATEf_GET BCMI_TSCE16_XGXS_PLL_CALSTS0r_CAL_STATEf_GET
#define PLL_CALSTS0r_CAL_STATEf_SET BCMI_TSCE16_XGXS_PLL_CALSTS0r_CAL_STATEf_SET
#define PLL_CALSTS0r_CAL_VALIDf_GET BCMI_TSCE16_XGXS_PLL_CALSTS0r_CAL_VALIDf_GET
#define PLL_CALSTS0r_CAL_VALIDf_SET BCMI_TSCE16_XGXS_PLL_CALSTS0r_CAL_VALIDf_SET
#define PLL_CALSTS0r_PLL_LOCKf_GET BCMI_TSCE16_XGXS_PLL_CALSTS0r_PLL_LOCKf_GET
#define PLL_CALSTS0r_PLL_LOCKf_SET BCMI_TSCE16_XGXS_PLL_CALSTS0r_PLL_LOCKf_SET
#define PLL_CALSTS0r_PLL_LOCK_BAR_STKYf_GET BCMI_TSCE16_XGXS_PLL_CALSTS0r_PLL_LOCK_BAR_STKYf_GET
#define PLL_CALSTS0r_PLL_LOCK_BAR_STKYf_SET BCMI_TSCE16_XGXS_PLL_CALSTS0r_PLL_LOCK_BAR_STKYf_SET
#define PLL_CALSTS0r_PLL_RANGEf_GET BCMI_TSCE16_XGXS_PLL_CALSTS0r_PLL_RANGEf_GET
#define PLL_CALSTS0r_PLL_RANGEf_SET BCMI_TSCE16_XGXS_PLL_CALSTS0r_PLL_RANGEf_SET
#define READ_PLL_CALSTS0r BCMI_TSCE16_XGXS_READ_PLL_CALSTS0r
#define WRITE_PLL_CALSTS0r BCMI_TSCE16_XGXS_WRITE_PLL_CALSTS0r
#define MODIFY_PLL_CALSTS0r BCMI_TSCE16_XGXS_MODIFY_PLL_CALSTS0r
#define READLN_PLL_CALSTS0r BCMI_TSCE16_XGXS_READLN_PLL_CALSTS0r
#define WRITELN_PLL_CALSTS0r BCMI_TSCE16_XGXS_WRITELN_PLL_CALSTS0r
#define WRITEALL_PLL_CALSTS0r BCMI_TSCE16_XGXS_WRITEALL_PLL_CALSTS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PLL_CALSTS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PLL_CALSTS1
 * BLOCKS:   PLL_CAL
 * REGADDR:  0xd129
 * DESC:     PLL_CALSTS_1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CALREF_COUNTER   Calibration refclk counter, for debug only
 *     LKDTVCO_COUNTER_MSB LKDT vcoclk counter bit16, for debug only
 *     LKDTREF_COUNTER_MSB LKDT refclk counter bit16, for debug only
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PLL_CALSTS1r (0x0000d129 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PLL_CALSTS1r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CALSTS1.
 *
 */
typedef union BCMI_TSCE16_XGXS_PLL_CALSTS1r_s {
	uint32_t v[1];
	uint32_t pll_calsts1[1];
	uint32_t _pll_calsts1;
} BCMI_TSCE16_XGXS_PLL_CALSTS1r_t;

#define BCMI_TSCE16_XGXS_PLL_CALSTS1r_CLR(r) (r).pll_calsts1[0] = 0
#define BCMI_TSCE16_XGXS_PLL_CALSTS1r_SET(r,d) (r).pll_calsts1[0] = d
#define BCMI_TSCE16_XGXS_PLL_CALSTS1r_GET(r) (r).pll_calsts1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PLL_CALSTS1r_LKDTREF_COUNTER_MSBf_GET(r) ((((r).pll_calsts1[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CALSTS1r_LKDTREF_COUNTER_MSBf_SET(r,f) (r).pll_calsts1[0]=(((r).pll_calsts1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_PLL_CALSTS1r_LKDTVCO_COUNTER_MSBf_GET(r) ((((r).pll_calsts1[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CALSTS1r_LKDTVCO_COUNTER_MSBf_SET(r,f) (r).pll_calsts1[0]=(((r).pll_calsts1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_PLL_CALSTS1r_CALREF_COUNTERf_GET(r) (((r).pll_calsts1[0]) & 0x1fff)
#define BCMI_TSCE16_XGXS_PLL_CALSTS1r_CALREF_COUNTERf_SET(r,f) (r).pll_calsts1[0]=(((r).pll_calsts1[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access PLL_CALSTS1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PLL_CALSTS1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS1r,(_r._pll_calsts1))
#define BCMI_TSCE16_XGXS_WRITE_PLL_CALSTS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS1r,(_r._pll_calsts1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PLL_CALSTS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS1r,(_r._pll_calsts1))
#define BCMI_TSCE16_XGXS_READLN_PLL_CALSTS1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_calsts1))
#define BCMI_TSCE16_XGXS_WRITELN_PLL_CALSTS1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_calsts1))
#define BCMI_TSCE16_XGXS_WRITEALL_PLL_CALSTS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_calsts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CALSTS1r BCMI_TSCE16_XGXS_PLL_CALSTS1r
#define PLL_CALSTS1r_SIZE BCMI_TSCE16_XGXS_PLL_CALSTS1r_SIZE
typedef BCMI_TSCE16_XGXS_PLL_CALSTS1r_t PLL_CALSTS1r_t;
#define PLL_CALSTS1r_CLR BCMI_TSCE16_XGXS_PLL_CALSTS1r_CLR
#define PLL_CALSTS1r_SET BCMI_TSCE16_XGXS_PLL_CALSTS1r_SET
#define PLL_CALSTS1r_GET BCMI_TSCE16_XGXS_PLL_CALSTS1r_GET
#define PLL_CALSTS1r_LKDTREF_COUNTER_MSBf_GET BCMI_TSCE16_XGXS_PLL_CALSTS1r_LKDTREF_COUNTER_MSBf_GET
#define PLL_CALSTS1r_LKDTREF_COUNTER_MSBf_SET BCMI_TSCE16_XGXS_PLL_CALSTS1r_LKDTREF_COUNTER_MSBf_SET
#define PLL_CALSTS1r_LKDTVCO_COUNTER_MSBf_GET BCMI_TSCE16_XGXS_PLL_CALSTS1r_LKDTVCO_COUNTER_MSBf_GET
#define PLL_CALSTS1r_LKDTVCO_COUNTER_MSBf_SET BCMI_TSCE16_XGXS_PLL_CALSTS1r_LKDTVCO_COUNTER_MSBf_SET
#define PLL_CALSTS1r_CALREF_COUNTERf_GET BCMI_TSCE16_XGXS_PLL_CALSTS1r_CALREF_COUNTERf_GET
#define PLL_CALSTS1r_CALREF_COUNTERf_SET BCMI_TSCE16_XGXS_PLL_CALSTS1r_CALREF_COUNTERf_SET
#define READ_PLL_CALSTS1r BCMI_TSCE16_XGXS_READ_PLL_CALSTS1r
#define WRITE_PLL_CALSTS1r BCMI_TSCE16_XGXS_WRITE_PLL_CALSTS1r
#define MODIFY_PLL_CALSTS1r BCMI_TSCE16_XGXS_MODIFY_PLL_CALSTS1r
#define READLN_PLL_CALSTS1r BCMI_TSCE16_XGXS_READLN_PLL_CALSTS1r
#define WRITELN_PLL_CALSTS1r BCMI_TSCE16_XGXS_WRITELN_PLL_CALSTS1r
#define WRITEALL_PLL_CALSTS1r BCMI_TSCE16_XGXS_WRITEALL_PLL_CALSTS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PLL_CALSTS1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PLL_CALSTS2
 * BLOCKS:   PLL_CAL
 * REGADDR:  0xd12a
 * DESC:     PLL_CALSTS_2
 * RESETVAL: 0x6000 (24576)
 * ACCESS:   R/O
 * FIELDS:
 *     CALVCO_COUNTER   Calibration vcoclk counter, for debug only
 *     BAND_IQBUF_MUX   band_iqbuf at AFE pll_ctrl interface
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PLL_CALSTS2r (0x0000d12a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PLL_CALSTS2r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CALSTS2.
 *
 */
typedef union BCMI_TSCE16_XGXS_PLL_CALSTS2r_s {
	uint32_t v[1];
	uint32_t pll_calsts2[1];
	uint32_t _pll_calsts2;
} BCMI_TSCE16_XGXS_PLL_CALSTS2r_t;

#define BCMI_TSCE16_XGXS_PLL_CALSTS2r_CLR(r) (r).pll_calsts2[0] = 0
#define BCMI_TSCE16_XGXS_PLL_CALSTS2r_SET(r,d) (r).pll_calsts2[0] = d
#define BCMI_TSCE16_XGXS_PLL_CALSTS2r_GET(r) (r).pll_calsts2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PLL_CALSTS2r_BAND_IQBUF_MUXf_GET(r) ((((r).pll_calsts2[0]) >> 13) & 0x7)
#define BCMI_TSCE16_XGXS_PLL_CALSTS2r_BAND_IQBUF_MUXf_SET(r,f) (r).pll_calsts2[0]=(((r).pll_calsts2[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13)) | (7 << (16 + 13))
#define BCMI_TSCE16_XGXS_PLL_CALSTS2r_CALVCO_COUNTERf_GET(r) (((r).pll_calsts2[0]) & 0x1fff)
#define BCMI_TSCE16_XGXS_PLL_CALSTS2r_CALVCO_COUNTERf_SET(r,f) (r).pll_calsts2[0]=(((r).pll_calsts2[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access PLL_CALSTS2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PLL_CALSTS2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS2r,(_r._pll_calsts2))
#define BCMI_TSCE16_XGXS_WRITE_PLL_CALSTS2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS2r,(_r._pll_calsts2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PLL_CALSTS2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS2r,(_r._pll_calsts2))
#define BCMI_TSCE16_XGXS_READLN_PLL_CALSTS2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_calsts2))
#define BCMI_TSCE16_XGXS_WRITELN_PLL_CALSTS2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_calsts2))
#define BCMI_TSCE16_XGXS_WRITEALL_PLL_CALSTS2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_calsts2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CALSTS2r BCMI_TSCE16_XGXS_PLL_CALSTS2r
#define PLL_CALSTS2r_SIZE BCMI_TSCE16_XGXS_PLL_CALSTS2r_SIZE
typedef BCMI_TSCE16_XGXS_PLL_CALSTS2r_t PLL_CALSTS2r_t;
#define PLL_CALSTS2r_CLR BCMI_TSCE16_XGXS_PLL_CALSTS2r_CLR
#define PLL_CALSTS2r_SET BCMI_TSCE16_XGXS_PLL_CALSTS2r_SET
#define PLL_CALSTS2r_GET BCMI_TSCE16_XGXS_PLL_CALSTS2r_GET
#define PLL_CALSTS2r_BAND_IQBUF_MUXf_GET BCMI_TSCE16_XGXS_PLL_CALSTS2r_BAND_IQBUF_MUXf_GET
#define PLL_CALSTS2r_BAND_IQBUF_MUXf_SET BCMI_TSCE16_XGXS_PLL_CALSTS2r_BAND_IQBUF_MUXf_SET
#define PLL_CALSTS2r_CALVCO_COUNTERf_GET BCMI_TSCE16_XGXS_PLL_CALSTS2r_CALVCO_COUNTERf_GET
#define PLL_CALSTS2r_CALVCO_COUNTERf_SET BCMI_TSCE16_XGXS_PLL_CALSTS2r_CALVCO_COUNTERf_SET
#define READ_PLL_CALSTS2r BCMI_TSCE16_XGXS_READ_PLL_CALSTS2r
#define WRITE_PLL_CALSTS2r BCMI_TSCE16_XGXS_WRITE_PLL_CALSTS2r
#define MODIFY_PLL_CALSTS2r BCMI_TSCE16_XGXS_MODIFY_PLL_CALSTS2r
#define READLN_PLL_CALSTS2r BCMI_TSCE16_XGXS_READLN_PLL_CALSTS2r
#define WRITELN_PLL_CALSTS2r BCMI_TSCE16_XGXS_WRITELN_PLL_CALSTS2r
#define WRITEALL_PLL_CALSTS2r BCMI_TSCE16_XGXS_WRITEALL_PLL_CALSTS2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PLL_CALSTS2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PLL_CALSTS3
 * BLOCKS:   PLL_CAL
 * REGADDR:  0xd12b
 * DESC:     PLL_CALSTS_3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LKDTREF_COUNTER  LKDT refclk counter, for debug only
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PLL_CALSTS3r (0x0000d12b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PLL_CALSTS3r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CALSTS3.
 *
 */
typedef union BCMI_TSCE16_XGXS_PLL_CALSTS3r_s {
	uint32_t v[1];
	uint32_t pll_calsts3[1];
	uint32_t _pll_calsts3;
} BCMI_TSCE16_XGXS_PLL_CALSTS3r_t;

#define BCMI_TSCE16_XGXS_PLL_CALSTS3r_CLR(r) (r).pll_calsts3[0] = 0
#define BCMI_TSCE16_XGXS_PLL_CALSTS3r_SET(r,d) (r).pll_calsts3[0] = d
#define BCMI_TSCE16_XGXS_PLL_CALSTS3r_GET(r) (r).pll_calsts3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PLL_CALSTS3r_LKDTREF_COUNTERf_GET(r) (((r).pll_calsts3[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PLL_CALSTS3r_LKDTREF_COUNTERf_SET(r,f) (r).pll_calsts3[0]=(((r).pll_calsts3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PLL_CALSTS3.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PLL_CALSTS3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS3r,(_r._pll_calsts3))
#define BCMI_TSCE16_XGXS_WRITE_PLL_CALSTS3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS3r,(_r._pll_calsts3)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PLL_CALSTS3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS3r,(_r._pll_calsts3))
#define BCMI_TSCE16_XGXS_READLN_PLL_CALSTS3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_calsts3))
#define BCMI_TSCE16_XGXS_WRITELN_PLL_CALSTS3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_calsts3))
#define BCMI_TSCE16_XGXS_WRITEALL_PLL_CALSTS3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_calsts3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CALSTS3r BCMI_TSCE16_XGXS_PLL_CALSTS3r
#define PLL_CALSTS3r_SIZE BCMI_TSCE16_XGXS_PLL_CALSTS3r_SIZE
typedef BCMI_TSCE16_XGXS_PLL_CALSTS3r_t PLL_CALSTS3r_t;
#define PLL_CALSTS3r_CLR BCMI_TSCE16_XGXS_PLL_CALSTS3r_CLR
#define PLL_CALSTS3r_SET BCMI_TSCE16_XGXS_PLL_CALSTS3r_SET
#define PLL_CALSTS3r_GET BCMI_TSCE16_XGXS_PLL_CALSTS3r_GET
#define PLL_CALSTS3r_LKDTREF_COUNTERf_GET BCMI_TSCE16_XGXS_PLL_CALSTS3r_LKDTREF_COUNTERf_GET
#define PLL_CALSTS3r_LKDTREF_COUNTERf_SET BCMI_TSCE16_XGXS_PLL_CALSTS3r_LKDTREF_COUNTERf_SET
#define READ_PLL_CALSTS3r BCMI_TSCE16_XGXS_READ_PLL_CALSTS3r
#define WRITE_PLL_CALSTS3r BCMI_TSCE16_XGXS_WRITE_PLL_CALSTS3r
#define MODIFY_PLL_CALSTS3r BCMI_TSCE16_XGXS_MODIFY_PLL_CALSTS3r
#define READLN_PLL_CALSTS3r BCMI_TSCE16_XGXS_READLN_PLL_CALSTS3r
#define WRITELN_PLL_CALSTS3r BCMI_TSCE16_XGXS_WRITELN_PLL_CALSTS3r
#define WRITEALL_PLL_CALSTS3r BCMI_TSCE16_XGXS_WRITEALL_PLL_CALSTS3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PLL_CALSTS3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PLL_CALSTS4
 * BLOCKS:   PLL_CAL
 * REGADDR:  0xd12c
 * DESC:     PLL_CALSTS_4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LKDTVCO_COUNTER  LKDT vcoclk counter, for debug only
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PLL_CALSTS4r (0x0000d12c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PLL_CALSTS4r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CALSTS4.
 *
 */
typedef union BCMI_TSCE16_XGXS_PLL_CALSTS4r_s {
	uint32_t v[1];
	uint32_t pll_calsts4[1];
	uint32_t _pll_calsts4;
} BCMI_TSCE16_XGXS_PLL_CALSTS4r_t;

#define BCMI_TSCE16_XGXS_PLL_CALSTS4r_CLR(r) (r).pll_calsts4[0] = 0
#define BCMI_TSCE16_XGXS_PLL_CALSTS4r_SET(r,d) (r).pll_calsts4[0] = d
#define BCMI_TSCE16_XGXS_PLL_CALSTS4r_GET(r) (r).pll_calsts4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PLL_CALSTS4r_LKDTVCO_COUNTERf_GET(r) (((r).pll_calsts4[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_PLL_CALSTS4r_LKDTVCO_COUNTERf_SET(r,f) (r).pll_calsts4[0]=(((r).pll_calsts4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PLL_CALSTS4.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PLL_CALSTS4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS4r,(_r._pll_calsts4))
#define BCMI_TSCE16_XGXS_WRITE_PLL_CALSTS4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS4r,(_r._pll_calsts4)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PLL_CALSTS4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS4r,(_r._pll_calsts4))
#define BCMI_TSCE16_XGXS_READLN_PLL_CALSTS4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_calsts4))
#define BCMI_TSCE16_XGXS_WRITELN_PLL_CALSTS4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_calsts4))
#define BCMI_TSCE16_XGXS_WRITEALL_PLL_CALSTS4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_calsts4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CALSTS4r BCMI_TSCE16_XGXS_PLL_CALSTS4r
#define PLL_CALSTS4r_SIZE BCMI_TSCE16_XGXS_PLL_CALSTS4r_SIZE
typedef BCMI_TSCE16_XGXS_PLL_CALSTS4r_t PLL_CALSTS4r_t;
#define PLL_CALSTS4r_CLR BCMI_TSCE16_XGXS_PLL_CALSTS4r_CLR
#define PLL_CALSTS4r_SET BCMI_TSCE16_XGXS_PLL_CALSTS4r_SET
#define PLL_CALSTS4r_GET BCMI_TSCE16_XGXS_PLL_CALSTS4r_GET
#define PLL_CALSTS4r_LKDTVCO_COUNTERf_GET BCMI_TSCE16_XGXS_PLL_CALSTS4r_LKDTVCO_COUNTERf_GET
#define PLL_CALSTS4r_LKDTVCO_COUNTERf_SET BCMI_TSCE16_XGXS_PLL_CALSTS4r_LKDTVCO_COUNTERf_SET
#define READ_PLL_CALSTS4r BCMI_TSCE16_XGXS_READ_PLL_CALSTS4r
#define WRITE_PLL_CALSTS4r BCMI_TSCE16_XGXS_WRITE_PLL_CALSTS4r
#define MODIFY_PLL_CALSTS4r BCMI_TSCE16_XGXS_MODIFY_PLL_CALSTS4r
#define READLN_PLL_CALSTS4r BCMI_TSCE16_XGXS_READLN_PLL_CALSTS4r
#define WRITELN_PLL_CALSTS4r BCMI_TSCE16_XGXS_WRITELN_PLL_CALSTS4r
#define WRITEALL_PLL_CALSTS4r BCMI_TSCE16_XGXS_WRITEALL_PLL_CALSTS4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PLL_CALSTS4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PLL_CALSTS5
 * BLOCKS:   PLL_CAL
 * REGADDR:  0xd12d
 * DESC:     PLL_CALSTS_5
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CALSTATE_ONEHOT  Calibration state machine one hot status
 *     VCOBUFPON_MUX    vcobufpon at AFE pll_ctrl interface
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PLL_CALSTS5r (0x0000d12d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PLL_CALSTS5r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CALSTS5.
 *
 */
typedef union BCMI_TSCE16_XGXS_PLL_CALSTS5r_s {
	uint32_t v[1];
	uint32_t pll_calsts5[1];
	uint32_t _pll_calsts5;
} BCMI_TSCE16_XGXS_PLL_CALSTS5r_t;

#define BCMI_TSCE16_XGXS_PLL_CALSTS5r_CLR(r) (r).pll_calsts5[0] = 0
#define BCMI_TSCE16_XGXS_PLL_CALSTS5r_SET(r,d) (r).pll_calsts5[0] = d
#define BCMI_TSCE16_XGXS_PLL_CALSTS5r_GET(r) (r).pll_calsts5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PLL_CALSTS5r_VCOBUFPON_MUXf_GET(r) ((((r).pll_calsts5[0]) >> 10) & 0xf)
#define BCMI_TSCE16_XGXS_PLL_CALSTS5r_VCOBUFPON_MUXf_SET(r,f) (r).pll_calsts5[0]=(((r).pll_calsts5[0] & ~((uint32_t)0xf << 10)) | ((((uint32_t)f) & 0xf) << 10)) | (15 << (16 + 10))
#define BCMI_TSCE16_XGXS_PLL_CALSTS5r_CALSTATE_ONEHOTf_GET(r) (((r).pll_calsts5[0]) & 0x3ff)
#define BCMI_TSCE16_XGXS_PLL_CALSTS5r_CALSTATE_ONEHOTf_SET(r,f) (r).pll_calsts5[0]=(((r).pll_calsts5[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access PLL_CALSTS5.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PLL_CALSTS5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS5r,(_r._pll_calsts5))
#define BCMI_TSCE16_XGXS_WRITE_PLL_CALSTS5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS5r,(_r._pll_calsts5)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PLL_CALSTS5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS5r,(_r._pll_calsts5))
#define BCMI_TSCE16_XGXS_READLN_PLL_CALSTS5r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_calsts5))
#define BCMI_TSCE16_XGXS_WRITELN_PLL_CALSTS5r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_calsts5))
#define BCMI_TSCE16_XGXS_WRITEALL_PLL_CALSTS5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_calsts5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CALSTS5r BCMI_TSCE16_XGXS_PLL_CALSTS5r
#define PLL_CALSTS5r_SIZE BCMI_TSCE16_XGXS_PLL_CALSTS5r_SIZE
typedef BCMI_TSCE16_XGXS_PLL_CALSTS5r_t PLL_CALSTS5r_t;
#define PLL_CALSTS5r_CLR BCMI_TSCE16_XGXS_PLL_CALSTS5r_CLR
#define PLL_CALSTS5r_SET BCMI_TSCE16_XGXS_PLL_CALSTS5r_SET
#define PLL_CALSTS5r_GET BCMI_TSCE16_XGXS_PLL_CALSTS5r_GET
#define PLL_CALSTS5r_VCOBUFPON_MUXf_GET BCMI_TSCE16_XGXS_PLL_CALSTS5r_VCOBUFPON_MUXf_GET
#define PLL_CALSTS5r_VCOBUFPON_MUXf_SET BCMI_TSCE16_XGXS_PLL_CALSTS5r_VCOBUFPON_MUXf_SET
#define PLL_CALSTS5r_CALSTATE_ONEHOTf_GET BCMI_TSCE16_XGXS_PLL_CALSTS5r_CALSTATE_ONEHOTf_GET
#define PLL_CALSTS5r_CALSTATE_ONEHOTf_SET BCMI_TSCE16_XGXS_PLL_CALSTS5r_CALSTATE_ONEHOTf_SET
#define READ_PLL_CALSTS5r BCMI_TSCE16_XGXS_READ_PLL_CALSTS5r
#define WRITE_PLL_CALSTS5r BCMI_TSCE16_XGXS_WRITE_PLL_CALSTS5r
#define MODIFY_PLL_CALSTS5r BCMI_TSCE16_XGXS_MODIFY_PLL_CALSTS5r
#define READLN_PLL_CALSTS5r BCMI_TSCE16_XGXS_READLN_PLL_CALSTS5r
#define WRITELN_PLL_CALSTS5r BCMI_TSCE16_XGXS_WRITELN_PLL_CALSTS5r
#define WRITEALL_PLL_CALSTS5r BCMI_TSCE16_XGXS_WRITEALL_PLL_CALSTS5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PLL_CALSTS5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  PLL_CALSTS6
 * BLOCKS:   PLL_CAL
 * REGADDR:  0xd12e
 * DESC:     PLL_CALSTS_6
 * RESETVAL: 0x3f00 (16128)
 * ACCESS:   R/O
 * FIELDS:
 *     PLLPON_MUX       pllpon at AFE interface
 *     VCOPON_MUX       vcopon at AFE interface
 *     VCO_RANGE_MUX    vco_range at AFE pll_ctrl interface
 *     PLL_PWRDN_OR     pll_pwrdn at AFE pll_ctrl interface
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_PLL_CALSTS6r (0x0000d12e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_PLL_CALSTS6r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CALSTS6.
 *
 */
typedef union BCMI_TSCE16_XGXS_PLL_CALSTS6r_s {
	uint32_t v[1];
	uint32_t pll_calsts6[1];
	uint32_t _pll_calsts6;
} BCMI_TSCE16_XGXS_PLL_CALSTS6r_t;

#define BCMI_TSCE16_XGXS_PLL_CALSTS6r_CLR(r) (r).pll_calsts6[0] = 0
#define BCMI_TSCE16_XGXS_PLL_CALSTS6r_SET(r,d) (r).pll_calsts6[0] = d
#define BCMI_TSCE16_XGXS_PLL_CALSTS6r_GET(r) (r).pll_calsts6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_PLL_CALSTS6r_PLL_PWRDN_ORf_GET(r) ((((r).pll_calsts6[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_PLL_CALSTS6r_PLL_PWRDN_ORf_SET(r,f) (r).pll_calsts6[0]=(((r).pll_calsts6[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_PLL_CALSTS6r_VCO_RANGE_MUXf_GET(r) ((((r).pll_calsts6[0]) >> 8) & 0x7f)
#define BCMI_TSCE16_XGXS_PLL_CALSTS6r_VCO_RANGE_MUXf_SET(r,f) (r).pll_calsts6[0]=(((r).pll_calsts6[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8)) | (127 << (16 + 8))
#define BCMI_TSCE16_XGXS_PLL_CALSTS6r_VCOPON_MUXf_GET(r) ((((r).pll_calsts6[0]) >> 4) & 0xf)
#define BCMI_TSCE16_XGXS_PLL_CALSTS6r_VCOPON_MUXf_SET(r,f) (r).pll_calsts6[0]=(((r).pll_calsts6[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_TSCE16_XGXS_PLL_CALSTS6r_PLLPON_MUXf_GET(r) (((r).pll_calsts6[0]) & 0xf)
#define BCMI_TSCE16_XGXS_PLL_CALSTS6r_PLLPON_MUXf_SET(r,f) (r).pll_calsts6[0]=(((r).pll_calsts6[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access PLL_CALSTS6.
 *
 */
#define BCMI_TSCE16_XGXS_READ_PLL_CALSTS6r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS6r,(_r._pll_calsts6))
#define BCMI_TSCE16_XGXS_WRITE_PLL_CALSTS6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS6r,(_r._pll_calsts6)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_PLL_CALSTS6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS6r,(_r._pll_calsts6))
#define BCMI_TSCE16_XGXS_READLN_PLL_CALSTS6r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_calsts6))
#define BCMI_TSCE16_XGXS_WRITELN_PLL_CALSTS6r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_calsts6))
#define BCMI_TSCE16_XGXS_WRITEALL_PLL_CALSTS6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_PLL_CALSTS6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_calsts6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CALSTS6r BCMI_TSCE16_XGXS_PLL_CALSTS6r
#define PLL_CALSTS6r_SIZE BCMI_TSCE16_XGXS_PLL_CALSTS6r_SIZE
typedef BCMI_TSCE16_XGXS_PLL_CALSTS6r_t PLL_CALSTS6r_t;
#define PLL_CALSTS6r_CLR BCMI_TSCE16_XGXS_PLL_CALSTS6r_CLR
#define PLL_CALSTS6r_SET BCMI_TSCE16_XGXS_PLL_CALSTS6r_SET
#define PLL_CALSTS6r_GET BCMI_TSCE16_XGXS_PLL_CALSTS6r_GET
#define PLL_CALSTS6r_PLL_PWRDN_ORf_GET BCMI_TSCE16_XGXS_PLL_CALSTS6r_PLL_PWRDN_ORf_GET
#define PLL_CALSTS6r_PLL_PWRDN_ORf_SET BCMI_TSCE16_XGXS_PLL_CALSTS6r_PLL_PWRDN_ORf_SET
#define PLL_CALSTS6r_VCO_RANGE_MUXf_GET BCMI_TSCE16_XGXS_PLL_CALSTS6r_VCO_RANGE_MUXf_GET
#define PLL_CALSTS6r_VCO_RANGE_MUXf_SET BCMI_TSCE16_XGXS_PLL_CALSTS6r_VCO_RANGE_MUXf_SET
#define PLL_CALSTS6r_VCOPON_MUXf_GET BCMI_TSCE16_XGXS_PLL_CALSTS6r_VCOPON_MUXf_GET
#define PLL_CALSTS6r_VCOPON_MUXf_SET BCMI_TSCE16_XGXS_PLL_CALSTS6r_VCOPON_MUXf_SET
#define PLL_CALSTS6r_PLLPON_MUXf_GET BCMI_TSCE16_XGXS_PLL_CALSTS6r_PLLPON_MUXf_GET
#define PLL_CALSTS6r_PLLPON_MUXf_SET BCMI_TSCE16_XGXS_PLL_CALSTS6r_PLLPON_MUXf_SET
#define READ_PLL_CALSTS6r BCMI_TSCE16_XGXS_READ_PLL_CALSTS6r
#define WRITE_PLL_CALSTS6r BCMI_TSCE16_XGXS_WRITE_PLL_CALSTS6r
#define MODIFY_PLL_CALSTS6r BCMI_TSCE16_XGXS_MODIFY_PLL_CALSTS6r
#define READLN_PLL_CALSTS6r BCMI_TSCE16_XGXS_READLN_PLL_CALSTS6r
#define WRITELN_PLL_CALSTS6r BCMI_TSCE16_XGXS_WRITELN_PLL_CALSTS6r
#define WRITEALL_PLL_CALSTS6r BCMI_TSCE16_XGXS_WRITEALL_PLL_CALSTS6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_PLL_CALSTS6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TXCOM_CTL0
 * BLOCKS:   TXCOM
 * REGADDR:  0xd130
 * DESC:     TX common control 0 register
 * RESETVAL: 0x1f4 (500)
 * ACCESS:   R/W
 * FIELDS:
 *     TXCOM_CL72_MAX_WAIT_TIMER_PERIOD Maximum Training Time in msPeriod/range is 500 ms
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TXCOM_CTL0r (0x0000d130 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TXCOM_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_CTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_TXCOM_CTL0r_s {
	uint32_t v[1];
	uint32_t txcom_ctl0[1];
	uint32_t _txcom_ctl0;
} BCMI_TSCE16_XGXS_TXCOM_CTL0r_t;

#define BCMI_TSCE16_XGXS_TXCOM_CTL0r_CLR(r) (r).txcom_ctl0[0] = 0
#define BCMI_TSCE16_XGXS_TXCOM_CTL0r_SET(r,d) (r).txcom_ctl0[0] = d
#define BCMI_TSCE16_XGXS_TXCOM_CTL0r_GET(r) (r).txcom_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TXCOM_CTL0r_TXCOM_CL72_MAX_WAIT_TIMER_PERIODf_GET(r) (((r).txcom_ctl0[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_TXCOM_CTL0r_TXCOM_CL72_MAX_WAIT_TIMER_PERIODf_SET(r,f) (r).txcom_ctl0[0]=(((r).txcom_ctl0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TXCOM_CTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TXCOM_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TXCOM_CTL0r,(_r._txcom_ctl0))
#define BCMI_TSCE16_XGXS_WRITE_TXCOM_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_CTL0r,(_r._txcom_ctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TXCOM_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_CTL0r,(_r._txcom_ctl0))
#define BCMI_TSCE16_XGXS_READLN_TXCOM_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TXCOM_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ctl0))
#define BCMI_TSCE16_XGXS_WRITELN_TXCOM_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_TXCOM_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_CTL0r BCMI_TSCE16_XGXS_TXCOM_CTL0r
#define TXCOM_CTL0r_SIZE BCMI_TSCE16_XGXS_TXCOM_CTL0r_SIZE
typedef BCMI_TSCE16_XGXS_TXCOM_CTL0r_t TXCOM_CTL0r_t;
#define TXCOM_CTL0r_CLR BCMI_TSCE16_XGXS_TXCOM_CTL0r_CLR
#define TXCOM_CTL0r_SET BCMI_TSCE16_XGXS_TXCOM_CTL0r_SET
#define TXCOM_CTL0r_GET BCMI_TSCE16_XGXS_TXCOM_CTL0r_GET
#define TXCOM_CTL0r_TXCOM_CL72_MAX_WAIT_TIMER_PERIODf_GET BCMI_TSCE16_XGXS_TXCOM_CTL0r_TXCOM_CL72_MAX_WAIT_TIMER_PERIODf_GET
#define TXCOM_CTL0r_TXCOM_CL72_MAX_WAIT_TIMER_PERIODf_SET BCMI_TSCE16_XGXS_TXCOM_CTL0r_TXCOM_CL72_MAX_WAIT_TIMER_PERIODf_SET
#define READ_TXCOM_CTL0r BCMI_TSCE16_XGXS_READ_TXCOM_CTL0r
#define WRITE_TXCOM_CTL0r BCMI_TSCE16_XGXS_WRITE_TXCOM_CTL0r
#define MODIFY_TXCOM_CTL0r BCMI_TSCE16_XGXS_MODIFY_TXCOM_CTL0r
#define READLN_TXCOM_CTL0r BCMI_TSCE16_XGXS_READLN_TXCOM_CTL0r
#define WRITELN_TXCOM_CTL0r BCMI_TSCE16_XGXS_WRITELN_TXCOM_CTL0r
#define WRITEALL_TXCOM_CTL0r BCMI_TSCE16_XGXS_WRITEALL_TXCOM_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TXCOM_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TXCOM_CTL1
 * BLOCKS:   TXCOM
 * REGADDR:  0xd131
 * DESC:     TX common control 1 register
 * RESETVAL: 0xc8 (200)
 * ACCESS:   R/W
 * FIELDS:
 *     TXCOM_CL72_WAIT_CNTR_LIMIT Period/range is 100-300 framesPeriod to keep transiming frames after the local device has completed trainingThe units are training pages.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TXCOM_CTL1r (0x0000d131 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TXCOM_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_CTL1.
 *
 */
typedef union BCMI_TSCE16_XGXS_TXCOM_CTL1r_s {
	uint32_t v[1];
	uint32_t txcom_ctl1[1];
	uint32_t _txcom_ctl1;
} BCMI_TSCE16_XGXS_TXCOM_CTL1r_t;

#define BCMI_TSCE16_XGXS_TXCOM_CTL1r_CLR(r) (r).txcom_ctl1[0] = 0
#define BCMI_TSCE16_XGXS_TXCOM_CTL1r_SET(r,d) (r).txcom_ctl1[0] = d
#define BCMI_TSCE16_XGXS_TXCOM_CTL1r_GET(r) (r).txcom_ctl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TXCOM_CTL1r_TXCOM_CL72_WAIT_CNTR_LIMITf_GET(r) (((r).txcom_ctl1[0]) & 0x1ff)
#define BCMI_TSCE16_XGXS_TXCOM_CTL1r_TXCOM_CL72_WAIT_CNTR_LIMITf_SET(r,f) (r).txcom_ctl1[0]=(((r).txcom_ctl1[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff)) | (0x1ff << 16)

/*
 * These macros can be used to access TXCOM_CTL1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TXCOM_CTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TXCOM_CTL1r,(_r._txcom_ctl1))
#define BCMI_TSCE16_XGXS_WRITE_TXCOM_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_CTL1r,(_r._txcom_ctl1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TXCOM_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_CTL1r,(_r._txcom_ctl1))
#define BCMI_TSCE16_XGXS_READLN_TXCOM_CTL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TXCOM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ctl1))
#define BCMI_TSCE16_XGXS_WRITELN_TXCOM_CTL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ctl1))
#define BCMI_TSCE16_XGXS_WRITEALL_TXCOM_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_CTL1r BCMI_TSCE16_XGXS_TXCOM_CTL1r
#define TXCOM_CTL1r_SIZE BCMI_TSCE16_XGXS_TXCOM_CTL1r_SIZE
typedef BCMI_TSCE16_XGXS_TXCOM_CTL1r_t TXCOM_CTL1r_t;
#define TXCOM_CTL1r_CLR BCMI_TSCE16_XGXS_TXCOM_CTL1r_CLR
#define TXCOM_CTL1r_SET BCMI_TSCE16_XGXS_TXCOM_CTL1r_SET
#define TXCOM_CTL1r_GET BCMI_TSCE16_XGXS_TXCOM_CTL1r_GET
#define TXCOM_CTL1r_TXCOM_CL72_WAIT_CNTR_LIMITf_GET BCMI_TSCE16_XGXS_TXCOM_CTL1r_TXCOM_CL72_WAIT_CNTR_LIMITf_GET
#define TXCOM_CTL1r_TXCOM_CL72_WAIT_CNTR_LIMITf_SET BCMI_TSCE16_XGXS_TXCOM_CTL1r_TXCOM_CL72_WAIT_CNTR_LIMITf_SET
#define READ_TXCOM_CTL1r BCMI_TSCE16_XGXS_READ_TXCOM_CTL1r
#define WRITE_TXCOM_CTL1r BCMI_TSCE16_XGXS_WRITE_TXCOM_CTL1r
#define MODIFY_TXCOM_CTL1r BCMI_TSCE16_XGXS_MODIFY_TXCOM_CTL1r
#define READLN_TXCOM_CTL1r BCMI_TSCE16_XGXS_READLN_TXCOM_CTL1r
#define WRITELN_TXCOM_CTL1r BCMI_TSCE16_XGXS_WRITELN_TXCOM_CTL1r
#define WRITEALL_TXCOM_CTL1r BCMI_TSCE16_XGXS_WRITEALL_TXCOM_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TXCOM_CTL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_F_DATA_ODD_OFFS
 * BLOCKS:   DSC_F
 * REGADDR:  0xd141
 * DESC:     dsc_f_data_odd_offset
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DATA_OFFSET_ODD_BIN Status Reg: Offset for the odd data slicer
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_F_DATA_ODD_OFFSr (0x0000d141 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_F_DATA_ODD_OFFSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_F_DATA_ODD_OFFS.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_F_DATA_ODD_OFFSr_s {
	uint32_t v[1];
	uint32_t dsc_f_data_odd_offs[1];
	uint32_t _dsc_f_data_odd_offs;
} BCMI_TSCE16_XGXS_DSC_F_DATA_ODD_OFFSr_t;

#define BCMI_TSCE16_XGXS_DSC_F_DATA_ODD_OFFSr_CLR(r) (r).dsc_f_data_odd_offs[0] = 0
#define BCMI_TSCE16_XGXS_DSC_F_DATA_ODD_OFFSr_SET(r,d) (r).dsc_f_data_odd_offs[0] = d
#define BCMI_TSCE16_XGXS_DSC_F_DATA_ODD_OFFSr_GET(r) (r).dsc_f_data_odd_offs[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_F_DATA_ODD_OFFSr_DATA_OFFSET_ODD_BINf_GET(r) (((r).dsc_f_data_odd_offs[0]) & 0x3f)
#define BCMI_TSCE16_XGXS_DSC_F_DATA_ODD_OFFSr_DATA_OFFSET_ODD_BINf_SET(r,f) (r).dsc_f_data_odd_offs[0]=(((r).dsc_f_data_odd_offs[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_F_DATA_ODD_OFFS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_F_DATA_ODD_OFFSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_F_DATA_ODD_OFFSr,(_r._dsc_f_data_odd_offs))
#define BCMI_TSCE16_XGXS_WRITE_DSC_F_DATA_ODD_OFFSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_F_DATA_ODD_OFFSr,(_r._dsc_f_data_odd_offs)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_F_DATA_ODD_OFFSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_F_DATA_ODD_OFFSr,(_r._dsc_f_data_odd_offs))
#define BCMI_TSCE16_XGXS_READLN_DSC_F_DATA_ODD_OFFSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_F_DATA_ODD_OFFSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_f_data_odd_offs))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_F_DATA_ODD_OFFSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_F_DATA_ODD_OFFSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_f_data_odd_offs))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_F_DATA_ODD_OFFSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_F_DATA_ODD_OFFSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_f_data_odd_offs))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_F_DATA_ODD_OFFSr BCMI_TSCE16_XGXS_DSC_F_DATA_ODD_OFFSr
#define DSC_F_DATA_ODD_OFFSr_SIZE BCMI_TSCE16_XGXS_DSC_F_DATA_ODD_OFFSr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_F_DATA_ODD_OFFSr_t DSC_F_DATA_ODD_OFFSr_t;
#define DSC_F_DATA_ODD_OFFSr_CLR BCMI_TSCE16_XGXS_DSC_F_DATA_ODD_OFFSr_CLR
#define DSC_F_DATA_ODD_OFFSr_SET BCMI_TSCE16_XGXS_DSC_F_DATA_ODD_OFFSr_SET
#define DSC_F_DATA_ODD_OFFSr_GET BCMI_TSCE16_XGXS_DSC_F_DATA_ODD_OFFSr_GET
#define DSC_F_DATA_ODD_OFFSr_DATA_OFFSET_ODD_BINf_GET BCMI_TSCE16_XGXS_DSC_F_DATA_ODD_OFFSr_DATA_OFFSET_ODD_BINf_GET
#define DSC_F_DATA_ODD_OFFSr_DATA_OFFSET_ODD_BINf_SET BCMI_TSCE16_XGXS_DSC_F_DATA_ODD_OFFSr_DATA_OFFSET_ODD_BINf_SET
#define READ_DSC_F_DATA_ODD_OFFSr BCMI_TSCE16_XGXS_READ_DSC_F_DATA_ODD_OFFSr
#define WRITE_DSC_F_DATA_ODD_OFFSr BCMI_TSCE16_XGXS_WRITE_DSC_F_DATA_ODD_OFFSr
#define MODIFY_DSC_F_DATA_ODD_OFFSr BCMI_TSCE16_XGXS_MODIFY_DSC_F_DATA_ODD_OFFSr
#define READLN_DSC_F_DATA_ODD_OFFSr BCMI_TSCE16_XGXS_READLN_DSC_F_DATA_ODD_OFFSr
#define WRITELN_DSC_F_DATA_ODD_OFFSr BCMI_TSCE16_XGXS_WRITELN_DSC_F_DATA_ODD_OFFSr
#define WRITEALL_DSC_F_DATA_ODD_OFFSr BCMI_TSCE16_XGXS_WRITEALL_DSC_F_DATA_ODD_OFFSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_F_DATA_ODD_OFFSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_F_DATA_EVEN_OFFS
 * BLOCKS:   DSC_F
 * REGADDR:  0xd142
 * DESC:     dsc_f_data_even_offset
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DATA_OFFSET_EVN_BIN Status Reg: Offset for the even data slicer
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_F_DATA_EVEN_OFFSr (0x0000d142 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_F_DATA_EVEN_OFFSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_F_DATA_EVEN_OFFS.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_F_DATA_EVEN_OFFSr_s {
	uint32_t v[1];
	uint32_t dsc_f_data_even_offs[1];
	uint32_t _dsc_f_data_even_offs;
} BCMI_TSCE16_XGXS_DSC_F_DATA_EVEN_OFFSr_t;

#define BCMI_TSCE16_XGXS_DSC_F_DATA_EVEN_OFFSr_CLR(r) (r).dsc_f_data_even_offs[0] = 0
#define BCMI_TSCE16_XGXS_DSC_F_DATA_EVEN_OFFSr_SET(r,d) (r).dsc_f_data_even_offs[0] = d
#define BCMI_TSCE16_XGXS_DSC_F_DATA_EVEN_OFFSr_GET(r) (r).dsc_f_data_even_offs[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_F_DATA_EVEN_OFFSr_DATA_OFFSET_EVN_BINf_GET(r) (((r).dsc_f_data_even_offs[0]) & 0x3f)
#define BCMI_TSCE16_XGXS_DSC_F_DATA_EVEN_OFFSr_DATA_OFFSET_EVN_BINf_SET(r,f) (r).dsc_f_data_even_offs[0]=(((r).dsc_f_data_even_offs[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_F_DATA_EVEN_OFFS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_F_DATA_EVEN_OFFSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_F_DATA_EVEN_OFFSr,(_r._dsc_f_data_even_offs))
#define BCMI_TSCE16_XGXS_WRITE_DSC_F_DATA_EVEN_OFFSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_F_DATA_EVEN_OFFSr,(_r._dsc_f_data_even_offs)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_F_DATA_EVEN_OFFSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_F_DATA_EVEN_OFFSr,(_r._dsc_f_data_even_offs))
#define BCMI_TSCE16_XGXS_READLN_DSC_F_DATA_EVEN_OFFSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_F_DATA_EVEN_OFFSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_f_data_even_offs))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_F_DATA_EVEN_OFFSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_F_DATA_EVEN_OFFSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_f_data_even_offs))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_F_DATA_EVEN_OFFSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_F_DATA_EVEN_OFFSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_f_data_even_offs))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_F_DATA_EVEN_OFFSr BCMI_TSCE16_XGXS_DSC_F_DATA_EVEN_OFFSr
#define DSC_F_DATA_EVEN_OFFSr_SIZE BCMI_TSCE16_XGXS_DSC_F_DATA_EVEN_OFFSr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_F_DATA_EVEN_OFFSr_t DSC_F_DATA_EVEN_OFFSr_t;
#define DSC_F_DATA_EVEN_OFFSr_CLR BCMI_TSCE16_XGXS_DSC_F_DATA_EVEN_OFFSr_CLR
#define DSC_F_DATA_EVEN_OFFSr_SET BCMI_TSCE16_XGXS_DSC_F_DATA_EVEN_OFFSr_SET
#define DSC_F_DATA_EVEN_OFFSr_GET BCMI_TSCE16_XGXS_DSC_F_DATA_EVEN_OFFSr_GET
#define DSC_F_DATA_EVEN_OFFSr_DATA_OFFSET_EVN_BINf_GET BCMI_TSCE16_XGXS_DSC_F_DATA_EVEN_OFFSr_DATA_OFFSET_EVN_BINf_GET
#define DSC_F_DATA_EVEN_OFFSr_DATA_OFFSET_EVN_BINf_SET BCMI_TSCE16_XGXS_DSC_F_DATA_EVEN_OFFSr_DATA_OFFSET_EVN_BINf_SET
#define READ_DSC_F_DATA_EVEN_OFFSr BCMI_TSCE16_XGXS_READ_DSC_F_DATA_EVEN_OFFSr
#define WRITE_DSC_F_DATA_EVEN_OFFSr BCMI_TSCE16_XGXS_WRITE_DSC_F_DATA_EVEN_OFFSr
#define MODIFY_DSC_F_DATA_EVEN_OFFSr BCMI_TSCE16_XGXS_MODIFY_DSC_F_DATA_EVEN_OFFSr
#define READLN_DSC_F_DATA_EVEN_OFFSr BCMI_TSCE16_XGXS_READLN_DSC_F_DATA_EVEN_OFFSr
#define WRITELN_DSC_F_DATA_EVEN_OFFSr BCMI_TSCE16_XGXS_WRITELN_DSC_F_DATA_EVEN_OFFSr
#define WRITEALL_DSC_F_DATA_EVEN_OFFSr BCMI_TSCE16_XGXS_WRITEALL_DSC_F_DATA_EVEN_OFFSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_F_DATA_EVEN_OFFSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_F_P1_ODD_OFFS
 * BLOCKS:   DSC_F
 * REGADDR:  0xd143
 * DESC:     dsc_f_p1_odd_offset
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     P1_OFFSET_ODD_BIN Status Reg: Offset for the odd p1 slicer
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_F_P1_ODD_OFFSr (0x0000d143 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_F_P1_ODD_OFFSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_F_P1_ODD_OFFS.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_F_P1_ODD_OFFSr_s {
	uint32_t v[1];
	uint32_t dsc_f_p1_odd_offs[1];
	uint32_t _dsc_f_p1_odd_offs;
} BCMI_TSCE16_XGXS_DSC_F_P1_ODD_OFFSr_t;

#define BCMI_TSCE16_XGXS_DSC_F_P1_ODD_OFFSr_CLR(r) (r).dsc_f_p1_odd_offs[0] = 0
#define BCMI_TSCE16_XGXS_DSC_F_P1_ODD_OFFSr_SET(r,d) (r).dsc_f_p1_odd_offs[0] = d
#define BCMI_TSCE16_XGXS_DSC_F_P1_ODD_OFFSr_GET(r) (r).dsc_f_p1_odd_offs[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_F_P1_ODD_OFFSr_P1_OFFSET_ODD_BINf_GET(r) (((r).dsc_f_p1_odd_offs[0]) & 0x3f)
#define BCMI_TSCE16_XGXS_DSC_F_P1_ODD_OFFSr_P1_OFFSET_ODD_BINf_SET(r,f) (r).dsc_f_p1_odd_offs[0]=(((r).dsc_f_p1_odd_offs[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_F_P1_ODD_OFFS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_F_P1_ODD_OFFSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_F_P1_ODD_OFFSr,(_r._dsc_f_p1_odd_offs))
#define BCMI_TSCE16_XGXS_WRITE_DSC_F_P1_ODD_OFFSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_F_P1_ODD_OFFSr,(_r._dsc_f_p1_odd_offs)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_F_P1_ODD_OFFSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_F_P1_ODD_OFFSr,(_r._dsc_f_p1_odd_offs))
#define BCMI_TSCE16_XGXS_READLN_DSC_F_P1_ODD_OFFSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_F_P1_ODD_OFFSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_f_p1_odd_offs))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_F_P1_ODD_OFFSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_F_P1_ODD_OFFSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_f_p1_odd_offs))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_F_P1_ODD_OFFSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_F_P1_ODD_OFFSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_f_p1_odd_offs))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_F_P1_ODD_OFFSr BCMI_TSCE16_XGXS_DSC_F_P1_ODD_OFFSr
#define DSC_F_P1_ODD_OFFSr_SIZE BCMI_TSCE16_XGXS_DSC_F_P1_ODD_OFFSr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_F_P1_ODD_OFFSr_t DSC_F_P1_ODD_OFFSr_t;
#define DSC_F_P1_ODD_OFFSr_CLR BCMI_TSCE16_XGXS_DSC_F_P1_ODD_OFFSr_CLR
#define DSC_F_P1_ODD_OFFSr_SET BCMI_TSCE16_XGXS_DSC_F_P1_ODD_OFFSr_SET
#define DSC_F_P1_ODD_OFFSr_GET BCMI_TSCE16_XGXS_DSC_F_P1_ODD_OFFSr_GET
#define DSC_F_P1_ODD_OFFSr_P1_OFFSET_ODD_BINf_GET BCMI_TSCE16_XGXS_DSC_F_P1_ODD_OFFSr_P1_OFFSET_ODD_BINf_GET
#define DSC_F_P1_ODD_OFFSr_P1_OFFSET_ODD_BINf_SET BCMI_TSCE16_XGXS_DSC_F_P1_ODD_OFFSr_P1_OFFSET_ODD_BINf_SET
#define READ_DSC_F_P1_ODD_OFFSr BCMI_TSCE16_XGXS_READ_DSC_F_P1_ODD_OFFSr
#define WRITE_DSC_F_P1_ODD_OFFSr BCMI_TSCE16_XGXS_WRITE_DSC_F_P1_ODD_OFFSr
#define MODIFY_DSC_F_P1_ODD_OFFSr BCMI_TSCE16_XGXS_MODIFY_DSC_F_P1_ODD_OFFSr
#define READLN_DSC_F_P1_ODD_OFFSr BCMI_TSCE16_XGXS_READLN_DSC_F_P1_ODD_OFFSr
#define WRITELN_DSC_F_P1_ODD_OFFSr BCMI_TSCE16_XGXS_WRITELN_DSC_F_P1_ODD_OFFSr
#define WRITEALL_DSC_F_P1_ODD_OFFSr BCMI_TSCE16_XGXS_WRITEALL_DSC_F_P1_ODD_OFFSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_F_P1_ODD_OFFSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_F_P1_EVEN_OFFS
 * BLOCKS:   DSC_F
 * REGADDR:  0xd144
 * DESC:     dsc_f_p1_even_offset
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     P1_OFFSET_EVN_BIN Status Reg: Offset for the even p1 slicer
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_F_P1_EVEN_OFFSr (0x0000d144 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_F_P1_EVEN_OFFSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_F_P1_EVEN_OFFS.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_F_P1_EVEN_OFFSr_s {
	uint32_t v[1];
	uint32_t dsc_f_p1_even_offs[1];
	uint32_t _dsc_f_p1_even_offs;
} BCMI_TSCE16_XGXS_DSC_F_P1_EVEN_OFFSr_t;

#define BCMI_TSCE16_XGXS_DSC_F_P1_EVEN_OFFSr_CLR(r) (r).dsc_f_p1_even_offs[0] = 0
#define BCMI_TSCE16_XGXS_DSC_F_P1_EVEN_OFFSr_SET(r,d) (r).dsc_f_p1_even_offs[0] = d
#define BCMI_TSCE16_XGXS_DSC_F_P1_EVEN_OFFSr_GET(r) (r).dsc_f_p1_even_offs[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_F_P1_EVEN_OFFSr_P1_OFFSET_EVN_BINf_GET(r) (((r).dsc_f_p1_even_offs[0]) & 0x3f)
#define BCMI_TSCE16_XGXS_DSC_F_P1_EVEN_OFFSr_P1_OFFSET_EVN_BINf_SET(r,f) (r).dsc_f_p1_even_offs[0]=(((r).dsc_f_p1_even_offs[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_F_P1_EVEN_OFFS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_F_P1_EVEN_OFFSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_F_P1_EVEN_OFFSr,(_r._dsc_f_p1_even_offs))
#define BCMI_TSCE16_XGXS_WRITE_DSC_F_P1_EVEN_OFFSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_F_P1_EVEN_OFFSr,(_r._dsc_f_p1_even_offs)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_F_P1_EVEN_OFFSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_F_P1_EVEN_OFFSr,(_r._dsc_f_p1_even_offs))
#define BCMI_TSCE16_XGXS_READLN_DSC_F_P1_EVEN_OFFSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_F_P1_EVEN_OFFSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_f_p1_even_offs))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_F_P1_EVEN_OFFSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_F_P1_EVEN_OFFSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_f_p1_even_offs))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_F_P1_EVEN_OFFSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_F_P1_EVEN_OFFSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_f_p1_even_offs))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_F_P1_EVEN_OFFSr BCMI_TSCE16_XGXS_DSC_F_P1_EVEN_OFFSr
#define DSC_F_P1_EVEN_OFFSr_SIZE BCMI_TSCE16_XGXS_DSC_F_P1_EVEN_OFFSr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_F_P1_EVEN_OFFSr_t DSC_F_P1_EVEN_OFFSr_t;
#define DSC_F_P1_EVEN_OFFSr_CLR BCMI_TSCE16_XGXS_DSC_F_P1_EVEN_OFFSr_CLR
#define DSC_F_P1_EVEN_OFFSr_SET BCMI_TSCE16_XGXS_DSC_F_P1_EVEN_OFFSr_SET
#define DSC_F_P1_EVEN_OFFSr_GET BCMI_TSCE16_XGXS_DSC_F_P1_EVEN_OFFSr_GET
#define DSC_F_P1_EVEN_OFFSr_P1_OFFSET_EVN_BINf_GET BCMI_TSCE16_XGXS_DSC_F_P1_EVEN_OFFSr_P1_OFFSET_EVN_BINf_GET
#define DSC_F_P1_EVEN_OFFSr_P1_OFFSET_EVN_BINf_SET BCMI_TSCE16_XGXS_DSC_F_P1_EVEN_OFFSr_P1_OFFSET_EVN_BINf_SET
#define READ_DSC_F_P1_EVEN_OFFSr BCMI_TSCE16_XGXS_READ_DSC_F_P1_EVEN_OFFSr
#define WRITE_DSC_F_P1_EVEN_OFFSr BCMI_TSCE16_XGXS_WRITE_DSC_F_P1_EVEN_OFFSr
#define MODIFY_DSC_F_P1_EVEN_OFFSr BCMI_TSCE16_XGXS_MODIFY_DSC_F_P1_EVEN_OFFSr
#define READLN_DSC_F_P1_EVEN_OFFSr BCMI_TSCE16_XGXS_READLN_DSC_F_P1_EVEN_OFFSr
#define WRITELN_DSC_F_P1_EVEN_OFFSr BCMI_TSCE16_XGXS_WRITELN_DSC_F_P1_EVEN_OFFSr
#define WRITEALL_DSC_F_P1_EVEN_OFFSr BCMI_TSCE16_XGXS_WRITEALL_DSC_F_P1_EVEN_OFFSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_F_P1_EVEN_OFFSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_F_M1_ODD_OFFS
 * BLOCKS:   DSC_F
 * REGADDR:  0xd145
 * DESC:     dsc_f_m1_odd_offset
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     M1_OFFSET_ODD_BIN Status Reg: Offset for the odd m1 slicer
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_F_M1_ODD_OFFSr (0x0000d145 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_F_M1_ODD_OFFSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_F_M1_ODD_OFFS.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_F_M1_ODD_OFFSr_s {
	uint32_t v[1];
	uint32_t dsc_f_m1_odd_offs[1];
	uint32_t _dsc_f_m1_odd_offs;
} BCMI_TSCE16_XGXS_DSC_F_M1_ODD_OFFSr_t;

#define BCMI_TSCE16_XGXS_DSC_F_M1_ODD_OFFSr_CLR(r) (r).dsc_f_m1_odd_offs[0] = 0
#define BCMI_TSCE16_XGXS_DSC_F_M1_ODD_OFFSr_SET(r,d) (r).dsc_f_m1_odd_offs[0] = d
#define BCMI_TSCE16_XGXS_DSC_F_M1_ODD_OFFSr_GET(r) (r).dsc_f_m1_odd_offs[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_F_M1_ODD_OFFSr_M1_OFFSET_ODD_BINf_GET(r) (((r).dsc_f_m1_odd_offs[0]) & 0x3f)
#define BCMI_TSCE16_XGXS_DSC_F_M1_ODD_OFFSr_M1_OFFSET_ODD_BINf_SET(r,f) (r).dsc_f_m1_odd_offs[0]=(((r).dsc_f_m1_odd_offs[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_F_M1_ODD_OFFS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_F_M1_ODD_OFFSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_F_M1_ODD_OFFSr,(_r._dsc_f_m1_odd_offs))
#define BCMI_TSCE16_XGXS_WRITE_DSC_F_M1_ODD_OFFSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_F_M1_ODD_OFFSr,(_r._dsc_f_m1_odd_offs)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_F_M1_ODD_OFFSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_F_M1_ODD_OFFSr,(_r._dsc_f_m1_odd_offs))
#define BCMI_TSCE16_XGXS_READLN_DSC_F_M1_ODD_OFFSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_F_M1_ODD_OFFSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_f_m1_odd_offs))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_F_M1_ODD_OFFSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_F_M1_ODD_OFFSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_f_m1_odd_offs))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_F_M1_ODD_OFFSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_F_M1_ODD_OFFSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_f_m1_odd_offs))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_F_M1_ODD_OFFSr BCMI_TSCE16_XGXS_DSC_F_M1_ODD_OFFSr
#define DSC_F_M1_ODD_OFFSr_SIZE BCMI_TSCE16_XGXS_DSC_F_M1_ODD_OFFSr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_F_M1_ODD_OFFSr_t DSC_F_M1_ODD_OFFSr_t;
#define DSC_F_M1_ODD_OFFSr_CLR BCMI_TSCE16_XGXS_DSC_F_M1_ODD_OFFSr_CLR
#define DSC_F_M1_ODD_OFFSr_SET BCMI_TSCE16_XGXS_DSC_F_M1_ODD_OFFSr_SET
#define DSC_F_M1_ODD_OFFSr_GET BCMI_TSCE16_XGXS_DSC_F_M1_ODD_OFFSr_GET
#define DSC_F_M1_ODD_OFFSr_M1_OFFSET_ODD_BINf_GET BCMI_TSCE16_XGXS_DSC_F_M1_ODD_OFFSr_M1_OFFSET_ODD_BINf_GET
#define DSC_F_M1_ODD_OFFSr_M1_OFFSET_ODD_BINf_SET BCMI_TSCE16_XGXS_DSC_F_M1_ODD_OFFSr_M1_OFFSET_ODD_BINf_SET
#define READ_DSC_F_M1_ODD_OFFSr BCMI_TSCE16_XGXS_READ_DSC_F_M1_ODD_OFFSr
#define WRITE_DSC_F_M1_ODD_OFFSr BCMI_TSCE16_XGXS_WRITE_DSC_F_M1_ODD_OFFSr
#define MODIFY_DSC_F_M1_ODD_OFFSr BCMI_TSCE16_XGXS_MODIFY_DSC_F_M1_ODD_OFFSr
#define READLN_DSC_F_M1_ODD_OFFSr BCMI_TSCE16_XGXS_READLN_DSC_F_M1_ODD_OFFSr
#define WRITELN_DSC_F_M1_ODD_OFFSr BCMI_TSCE16_XGXS_WRITELN_DSC_F_M1_ODD_OFFSr
#define WRITEALL_DSC_F_M1_ODD_OFFSr BCMI_TSCE16_XGXS_WRITEALL_DSC_F_M1_ODD_OFFSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_F_M1_ODD_OFFSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_F_M1_EVEN_OFFS
 * BLOCKS:   DSC_F
 * REGADDR:  0xd146
 * DESC:     dsc_f_m1_even_offset
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     M1_OFFSET_EVN_BIN Status Reg: Offset for the even m1 slicer
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_F_M1_EVEN_OFFSr (0x0000d146 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_F_M1_EVEN_OFFSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_F_M1_EVEN_OFFS.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_F_M1_EVEN_OFFSr_s {
	uint32_t v[1];
	uint32_t dsc_f_m1_even_offs[1];
	uint32_t _dsc_f_m1_even_offs;
} BCMI_TSCE16_XGXS_DSC_F_M1_EVEN_OFFSr_t;

#define BCMI_TSCE16_XGXS_DSC_F_M1_EVEN_OFFSr_CLR(r) (r).dsc_f_m1_even_offs[0] = 0
#define BCMI_TSCE16_XGXS_DSC_F_M1_EVEN_OFFSr_SET(r,d) (r).dsc_f_m1_even_offs[0] = d
#define BCMI_TSCE16_XGXS_DSC_F_M1_EVEN_OFFSr_GET(r) (r).dsc_f_m1_even_offs[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_F_M1_EVEN_OFFSr_M1_OFFSET_EVN_BINf_GET(r) (((r).dsc_f_m1_even_offs[0]) & 0x3f)
#define BCMI_TSCE16_XGXS_DSC_F_M1_EVEN_OFFSr_M1_OFFSET_EVN_BINf_SET(r,f) (r).dsc_f_m1_even_offs[0]=(((r).dsc_f_m1_even_offs[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_F_M1_EVEN_OFFS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_F_M1_EVEN_OFFSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_F_M1_EVEN_OFFSr,(_r._dsc_f_m1_even_offs))
#define BCMI_TSCE16_XGXS_WRITE_DSC_F_M1_EVEN_OFFSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_F_M1_EVEN_OFFSr,(_r._dsc_f_m1_even_offs)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_F_M1_EVEN_OFFSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_F_M1_EVEN_OFFSr,(_r._dsc_f_m1_even_offs))
#define BCMI_TSCE16_XGXS_READLN_DSC_F_M1_EVEN_OFFSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_F_M1_EVEN_OFFSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_f_m1_even_offs))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_F_M1_EVEN_OFFSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_F_M1_EVEN_OFFSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_f_m1_even_offs))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_F_M1_EVEN_OFFSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_F_M1_EVEN_OFFSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_f_m1_even_offs))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_F_M1_EVEN_OFFSr BCMI_TSCE16_XGXS_DSC_F_M1_EVEN_OFFSr
#define DSC_F_M1_EVEN_OFFSr_SIZE BCMI_TSCE16_XGXS_DSC_F_M1_EVEN_OFFSr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_F_M1_EVEN_OFFSr_t DSC_F_M1_EVEN_OFFSr_t;
#define DSC_F_M1_EVEN_OFFSr_CLR BCMI_TSCE16_XGXS_DSC_F_M1_EVEN_OFFSr_CLR
#define DSC_F_M1_EVEN_OFFSr_SET BCMI_TSCE16_XGXS_DSC_F_M1_EVEN_OFFSr_SET
#define DSC_F_M1_EVEN_OFFSr_GET BCMI_TSCE16_XGXS_DSC_F_M1_EVEN_OFFSr_GET
#define DSC_F_M1_EVEN_OFFSr_M1_OFFSET_EVN_BINf_GET BCMI_TSCE16_XGXS_DSC_F_M1_EVEN_OFFSr_M1_OFFSET_EVN_BINf_GET
#define DSC_F_M1_EVEN_OFFSr_M1_OFFSET_EVN_BINf_SET BCMI_TSCE16_XGXS_DSC_F_M1_EVEN_OFFSr_M1_OFFSET_EVN_BINf_SET
#define READ_DSC_F_M1_EVEN_OFFSr BCMI_TSCE16_XGXS_READ_DSC_F_M1_EVEN_OFFSr
#define WRITE_DSC_F_M1_EVEN_OFFSr BCMI_TSCE16_XGXS_WRITE_DSC_F_M1_EVEN_OFFSr
#define MODIFY_DSC_F_M1_EVEN_OFFSr BCMI_TSCE16_XGXS_MODIFY_DSC_F_M1_EVEN_OFFSr
#define READLN_DSC_F_M1_EVEN_OFFSr BCMI_TSCE16_XGXS_READLN_DSC_F_M1_EVEN_OFFSr
#define WRITELN_DSC_F_M1_EVEN_OFFSr BCMI_TSCE16_XGXS_WRITELN_DSC_F_M1_EVEN_OFFSr
#define WRITEALL_DSC_F_M1_EVEN_OFFSr BCMI_TSCE16_XGXS_WRITEALL_DSC_F_M1_EVEN_OFFSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_F_M1_EVEN_OFFSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  DSC_F_DC_OFFS
 * BLOCKS:   DSC_F
 * REGADDR:  0xd147
 * DESC:     dsc_f_dc_offset
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DC_OFFSET_BIN    Status Reg: DC Offset provided at the Rx Input
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_DSC_F_DC_OFFSr (0x0000d147 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_DSC_F_DC_OFFSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_F_DC_OFFS.
 *
 */
typedef union BCMI_TSCE16_XGXS_DSC_F_DC_OFFSr_s {
	uint32_t v[1];
	uint32_t dsc_f_dc_offs[1];
	uint32_t _dsc_f_dc_offs;
} BCMI_TSCE16_XGXS_DSC_F_DC_OFFSr_t;

#define BCMI_TSCE16_XGXS_DSC_F_DC_OFFSr_CLR(r) (r).dsc_f_dc_offs[0] = 0
#define BCMI_TSCE16_XGXS_DSC_F_DC_OFFSr_SET(r,d) (r).dsc_f_dc_offs[0] = d
#define BCMI_TSCE16_XGXS_DSC_F_DC_OFFSr_GET(r) (r).dsc_f_dc_offs[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_DSC_F_DC_OFFSr_DC_OFFSET_BINf_GET(r) (((r).dsc_f_dc_offs[0]) & 0x7f)
#define BCMI_TSCE16_XGXS_DSC_F_DC_OFFSr_DC_OFFSET_BINf_SET(r,f) (r).dsc_f_dc_offs[0]=(((r).dsc_f_dc_offs[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access DSC_F_DC_OFFS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_DSC_F_DC_OFFSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_F_DC_OFFSr,(_r._dsc_f_dc_offs))
#define BCMI_TSCE16_XGXS_WRITE_DSC_F_DC_OFFSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_F_DC_OFFSr,(_r._dsc_f_dc_offs)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_DSC_F_DC_OFFSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_F_DC_OFFSr,(_r._dsc_f_dc_offs))
#define BCMI_TSCE16_XGXS_READLN_DSC_F_DC_OFFSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_DSC_F_DC_OFFSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_f_dc_offs))
#define BCMI_TSCE16_XGXS_WRITELN_DSC_F_DC_OFFSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_F_DC_OFFSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_f_dc_offs))
#define BCMI_TSCE16_XGXS_WRITEALL_DSC_F_DC_OFFSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_DSC_F_DC_OFFSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_f_dc_offs))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_F_DC_OFFSr BCMI_TSCE16_XGXS_DSC_F_DC_OFFSr
#define DSC_F_DC_OFFSr_SIZE BCMI_TSCE16_XGXS_DSC_F_DC_OFFSr_SIZE
typedef BCMI_TSCE16_XGXS_DSC_F_DC_OFFSr_t DSC_F_DC_OFFSr_t;
#define DSC_F_DC_OFFSr_CLR BCMI_TSCE16_XGXS_DSC_F_DC_OFFSr_CLR
#define DSC_F_DC_OFFSr_SET BCMI_TSCE16_XGXS_DSC_F_DC_OFFSr_SET
#define DSC_F_DC_OFFSr_GET BCMI_TSCE16_XGXS_DSC_F_DC_OFFSr_GET
#define DSC_F_DC_OFFSr_DC_OFFSET_BINf_GET BCMI_TSCE16_XGXS_DSC_F_DC_OFFSr_DC_OFFSET_BINf_GET
#define DSC_F_DC_OFFSr_DC_OFFSET_BINf_SET BCMI_TSCE16_XGXS_DSC_F_DC_OFFSr_DC_OFFSET_BINf_SET
#define READ_DSC_F_DC_OFFSr BCMI_TSCE16_XGXS_READ_DSC_F_DC_OFFSr
#define WRITE_DSC_F_DC_OFFSr BCMI_TSCE16_XGXS_WRITE_DSC_F_DC_OFFSr
#define MODIFY_DSC_F_DC_OFFSr BCMI_TSCE16_XGXS_MODIFY_DSC_F_DC_OFFSr
#define READLN_DSC_F_DC_OFFSr BCMI_TSCE16_XGXS_READLN_DSC_F_DC_OFFSr
#define WRITELN_DSC_F_DC_OFFSr BCMI_TSCE16_XGXS_WRITELN_DSC_F_DC_OFFSr
#define WRITEALL_DSC_F_DC_OFFSr BCMI_TSCE16_XGXS_WRITEALL_DSC_F_DC_OFFSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_DSC_F_DC_OFFSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  LN_ADDR0
 * BLOCKS:   DIGCOM_B
 * REGADDR:  0xd150
 * DESC:     LANE_ADDR_0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LANE_ADDR_0   Determines the logical address associated with the PMD RX lane with physical index  "_0" at the PCS interface.rx_lane_addr_0 is the logical address of the lane with pins at the PCS interface labeled "_0".
 *     TX_LANE_ADDR_0   Determines the logical address associated with the PMD TX lane with physical index  "_0" at the PCS interface.tx_lane_addr_0 is the logical address of the TX lane with pins at the PCS interface labeled "_0".
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_LN_ADDR0r (0x0000d150 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_LN_ADDR0r_SIZE 4

/*
 * This structure should be used to declare and program LN_ADDR0.
 *
 */
typedef union BCMI_TSCE16_XGXS_LN_ADDR0r_s {
	uint32_t v[1];
	uint32_t ln_addr0[1];
	uint32_t _ln_addr0;
} BCMI_TSCE16_XGXS_LN_ADDR0r_t;

#define BCMI_TSCE16_XGXS_LN_ADDR0r_CLR(r) (r).ln_addr0[0] = 0
#define BCMI_TSCE16_XGXS_LN_ADDR0r_SET(r,d) (r).ln_addr0[0] = d
#define BCMI_TSCE16_XGXS_LN_ADDR0r_GET(r) (r).ln_addr0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_LN_ADDR0r_TX_LANE_ADDR_0f_GET(r) ((((r).ln_addr0[0]) >> 8) & 0x1f)
#define BCMI_TSCE16_XGXS_LN_ADDR0r_TX_LANE_ADDR_0f_SET(r,f) (r).ln_addr0[0]=(((r).ln_addr0[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_TSCE16_XGXS_LN_ADDR0r_RX_LANE_ADDR_0f_GET(r) (((r).ln_addr0[0]) & 0x1f)
#define BCMI_TSCE16_XGXS_LN_ADDR0r_RX_LANE_ADDR_0f_SET(r,f) (r).ln_addr0[0]=(((r).ln_addr0[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN_ADDR0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_LN_ADDR0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_LN_ADDR0r,(_r._ln_addr0))
#define BCMI_TSCE16_XGXS_WRITE_LN_ADDR0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_LN_ADDR0r,(_r._ln_addr0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_LN_ADDR0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_LN_ADDR0r,(_r._ln_addr0))
#define BCMI_TSCE16_XGXS_READLN_LN_ADDR0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_LN_ADDR0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr0))
#define BCMI_TSCE16_XGXS_WRITELN_LN_ADDR0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_LN_ADDR0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr0))
#define BCMI_TSCE16_XGXS_WRITEALL_LN_ADDR0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_LN_ADDR0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ln_addr0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_ADDR0r BCMI_TSCE16_XGXS_LN_ADDR0r
#define LN_ADDR0r_SIZE BCMI_TSCE16_XGXS_LN_ADDR0r_SIZE
typedef BCMI_TSCE16_XGXS_LN_ADDR0r_t LN_ADDR0r_t;
#define LN_ADDR0r_CLR BCMI_TSCE16_XGXS_LN_ADDR0r_CLR
#define LN_ADDR0r_SET BCMI_TSCE16_XGXS_LN_ADDR0r_SET
#define LN_ADDR0r_GET BCMI_TSCE16_XGXS_LN_ADDR0r_GET
#define LN_ADDR0r_TX_LANE_ADDR_0f_GET BCMI_TSCE16_XGXS_LN_ADDR0r_TX_LANE_ADDR_0f_GET
#define LN_ADDR0r_TX_LANE_ADDR_0f_SET BCMI_TSCE16_XGXS_LN_ADDR0r_TX_LANE_ADDR_0f_SET
#define LN_ADDR0r_RX_LANE_ADDR_0f_GET BCMI_TSCE16_XGXS_LN_ADDR0r_RX_LANE_ADDR_0f_GET
#define LN_ADDR0r_RX_LANE_ADDR_0f_SET BCMI_TSCE16_XGXS_LN_ADDR0r_RX_LANE_ADDR_0f_SET
#define READ_LN_ADDR0r BCMI_TSCE16_XGXS_READ_LN_ADDR0r
#define WRITE_LN_ADDR0r BCMI_TSCE16_XGXS_WRITE_LN_ADDR0r
#define MODIFY_LN_ADDR0r BCMI_TSCE16_XGXS_MODIFY_LN_ADDR0r
#define READLN_LN_ADDR0r BCMI_TSCE16_XGXS_READLN_LN_ADDR0r
#define WRITELN_LN_ADDR0r BCMI_TSCE16_XGXS_WRITELN_LN_ADDR0r
#define WRITEALL_LN_ADDR0r BCMI_TSCE16_XGXS_WRITEALL_LN_ADDR0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_LN_ADDR0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  LN_ADDR1
 * BLOCKS:   DIGCOM_B
 * REGADDR:  0xd151
 * DESC:     LANE_ADDR_1
 * RESETVAL: 0x101 (257)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LANE_ADDR_1   Determines the logical address associated with the PMD RX lane with physical index  "_1" at the PCS interface.rx_lane_addr_1 is the logical address of the lane with pins at the PCS interface labeled "_1".
 *     TX_LANE_ADDR_1   Determines the logical address associated with the PMD TX lane with physical index  "_1" at the PCS interface.tx_lane_addr_1 is the logical address of the TX lane with pins at the PCS interface labeled "_1".
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_LN_ADDR1r (0x0000d151 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_LN_ADDR1r_SIZE 4

/*
 * This structure should be used to declare and program LN_ADDR1.
 *
 */
typedef union BCMI_TSCE16_XGXS_LN_ADDR1r_s {
	uint32_t v[1];
	uint32_t ln_addr1[1];
	uint32_t _ln_addr1;
} BCMI_TSCE16_XGXS_LN_ADDR1r_t;

#define BCMI_TSCE16_XGXS_LN_ADDR1r_CLR(r) (r).ln_addr1[0] = 0
#define BCMI_TSCE16_XGXS_LN_ADDR1r_SET(r,d) (r).ln_addr1[0] = d
#define BCMI_TSCE16_XGXS_LN_ADDR1r_GET(r) (r).ln_addr1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_LN_ADDR1r_TX_LANE_ADDR_1f_GET(r) ((((r).ln_addr1[0]) >> 8) & 0x1f)
#define BCMI_TSCE16_XGXS_LN_ADDR1r_TX_LANE_ADDR_1f_SET(r,f) (r).ln_addr1[0]=(((r).ln_addr1[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_TSCE16_XGXS_LN_ADDR1r_RX_LANE_ADDR_1f_GET(r) (((r).ln_addr1[0]) & 0x1f)
#define BCMI_TSCE16_XGXS_LN_ADDR1r_RX_LANE_ADDR_1f_SET(r,f) (r).ln_addr1[0]=(((r).ln_addr1[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN_ADDR1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_LN_ADDR1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_LN_ADDR1r,(_r._ln_addr1))
#define BCMI_TSCE16_XGXS_WRITE_LN_ADDR1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_LN_ADDR1r,(_r._ln_addr1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_LN_ADDR1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_LN_ADDR1r,(_r._ln_addr1))
#define BCMI_TSCE16_XGXS_READLN_LN_ADDR1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_LN_ADDR1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr1))
#define BCMI_TSCE16_XGXS_WRITELN_LN_ADDR1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_LN_ADDR1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr1))
#define BCMI_TSCE16_XGXS_WRITEALL_LN_ADDR1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_LN_ADDR1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ln_addr1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_ADDR1r BCMI_TSCE16_XGXS_LN_ADDR1r
#define LN_ADDR1r_SIZE BCMI_TSCE16_XGXS_LN_ADDR1r_SIZE
typedef BCMI_TSCE16_XGXS_LN_ADDR1r_t LN_ADDR1r_t;
#define LN_ADDR1r_CLR BCMI_TSCE16_XGXS_LN_ADDR1r_CLR
#define LN_ADDR1r_SET BCMI_TSCE16_XGXS_LN_ADDR1r_SET
#define LN_ADDR1r_GET BCMI_TSCE16_XGXS_LN_ADDR1r_GET
#define LN_ADDR1r_TX_LANE_ADDR_1f_GET BCMI_TSCE16_XGXS_LN_ADDR1r_TX_LANE_ADDR_1f_GET
#define LN_ADDR1r_TX_LANE_ADDR_1f_SET BCMI_TSCE16_XGXS_LN_ADDR1r_TX_LANE_ADDR_1f_SET
#define LN_ADDR1r_RX_LANE_ADDR_1f_GET BCMI_TSCE16_XGXS_LN_ADDR1r_RX_LANE_ADDR_1f_GET
#define LN_ADDR1r_RX_LANE_ADDR_1f_SET BCMI_TSCE16_XGXS_LN_ADDR1r_RX_LANE_ADDR_1f_SET
#define READ_LN_ADDR1r BCMI_TSCE16_XGXS_READ_LN_ADDR1r
#define WRITE_LN_ADDR1r BCMI_TSCE16_XGXS_WRITE_LN_ADDR1r
#define MODIFY_LN_ADDR1r BCMI_TSCE16_XGXS_MODIFY_LN_ADDR1r
#define READLN_LN_ADDR1r BCMI_TSCE16_XGXS_READLN_LN_ADDR1r
#define WRITELN_LN_ADDR1r BCMI_TSCE16_XGXS_WRITELN_LN_ADDR1r
#define WRITEALL_LN_ADDR1r BCMI_TSCE16_XGXS_WRITEALL_LN_ADDR1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_LN_ADDR1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  LN_ADDR2
 * BLOCKS:   DIGCOM_B
 * REGADDR:  0xd152
 * DESC:     LANE_ADDR_2
 * RESETVAL: 0x202 (514)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LANE_ADDR_2   Determines the logical address associated with the PMD RX lane with physical index  "_2" at the PCS interface.rx_lane_addr_2 is the logical address of the lane with pins at the PCS interface labeled "_2".
 *     TX_LANE_ADDR_2   Determines the logical address associated with the PMD TX lane with physical index  "_2" at the PCS interface.tx_lane_addr_2 is the logical address of the TX lane with pins at the PCS interface labeled "_2".
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_LN_ADDR2r (0x0000d152 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_LN_ADDR2r_SIZE 4

/*
 * This structure should be used to declare and program LN_ADDR2.
 *
 */
typedef union BCMI_TSCE16_XGXS_LN_ADDR2r_s {
	uint32_t v[1];
	uint32_t ln_addr2[1];
	uint32_t _ln_addr2;
} BCMI_TSCE16_XGXS_LN_ADDR2r_t;

#define BCMI_TSCE16_XGXS_LN_ADDR2r_CLR(r) (r).ln_addr2[0] = 0
#define BCMI_TSCE16_XGXS_LN_ADDR2r_SET(r,d) (r).ln_addr2[0] = d
#define BCMI_TSCE16_XGXS_LN_ADDR2r_GET(r) (r).ln_addr2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_LN_ADDR2r_TX_LANE_ADDR_2f_GET(r) ((((r).ln_addr2[0]) >> 8) & 0x1f)
#define BCMI_TSCE16_XGXS_LN_ADDR2r_TX_LANE_ADDR_2f_SET(r,f) (r).ln_addr2[0]=(((r).ln_addr2[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_TSCE16_XGXS_LN_ADDR2r_RX_LANE_ADDR_2f_GET(r) (((r).ln_addr2[0]) & 0x1f)
#define BCMI_TSCE16_XGXS_LN_ADDR2r_RX_LANE_ADDR_2f_SET(r,f) (r).ln_addr2[0]=(((r).ln_addr2[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN_ADDR2.
 *
 */
#define BCMI_TSCE16_XGXS_READ_LN_ADDR2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_LN_ADDR2r,(_r._ln_addr2))
#define BCMI_TSCE16_XGXS_WRITE_LN_ADDR2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_LN_ADDR2r,(_r._ln_addr2)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_LN_ADDR2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_LN_ADDR2r,(_r._ln_addr2))
#define BCMI_TSCE16_XGXS_READLN_LN_ADDR2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_LN_ADDR2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr2))
#define BCMI_TSCE16_XGXS_WRITELN_LN_ADDR2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_LN_ADDR2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr2))
#define BCMI_TSCE16_XGXS_WRITEALL_LN_ADDR2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_LN_ADDR2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ln_addr2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_ADDR2r BCMI_TSCE16_XGXS_LN_ADDR2r
#define LN_ADDR2r_SIZE BCMI_TSCE16_XGXS_LN_ADDR2r_SIZE
typedef BCMI_TSCE16_XGXS_LN_ADDR2r_t LN_ADDR2r_t;
#define LN_ADDR2r_CLR BCMI_TSCE16_XGXS_LN_ADDR2r_CLR
#define LN_ADDR2r_SET BCMI_TSCE16_XGXS_LN_ADDR2r_SET
#define LN_ADDR2r_GET BCMI_TSCE16_XGXS_LN_ADDR2r_GET
#define LN_ADDR2r_TX_LANE_ADDR_2f_GET BCMI_TSCE16_XGXS_LN_ADDR2r_TX_LANE_ADDR_2f_GET
#define LN_ADDR2r_TX_LANE_ADDR_2f_SET BCMI_TSCE16_XGXS_LN_ADDR2r_TX_LANE_ADDR_2f_SET
#define LN_ADDR2r_RX_LANE_ADDR_2f_GET BCMI_TSCE16_XGXS_LN_ADDR2r_RX_LANE_ADDR_2f_GET
#define LN_ADDR2r_RX_LANE_ADDR_2f_SET BCMI_TSCE16_XGXS_LN_ADDR2r_RX_LANE_ADDR_2f_SET
#define READ_LN_ADDR2r BCMI_TSCE16_XGXS_READ_LN_ADDR2r
#define WRITE_LN_ADDR2r BCMI_TSCE16_XGXS_WRITE_LN_ADDR2r
#define MODIFY_LN_ADDR2r BCMI_TSCE16_XGXS_MODIFY_LN_ADDR2r
#define READLN_LN_ADDR2r BCMI_TSCE16_XGXS_READLN_LN_ADDR2r
#define WRITELN_LN_ADDR2r BCMI_TSCE16_XGXS_WRITELN_LN_ADDR2r
#define WRITEALL_LN_ADDR2r BCMI_TSCE16_XGXS_WRITEALL_LN_ADDR2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_LN_ADDR2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  LN_ADDR3
 * BLOCKS:   DIGCOM_B
 * REGADDR:  0xd153
 * DESC:     LANE_ADDR_3
 * RESETVAL: 0x303 (771)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LANE_ADDR_3   Determines the logical address associated with the PMD RX lane with physical index  "_3" at the PCS interface.rx_lane_addr_3 is the logical address of the lane with pins at the PCS interface labeled "_3".
 *     TX_LANE_ADDR_3   Determines the logical address associated with the PMD TX lane with physical index  "_3" at the PCS interface.tx_lane_addr_3 is the logical address of the TX lane with pins at the PCS interface labeled "_3".
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_LN_ADDR3r (0x0000d153 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_LN_ADDR3r_SIZE 4

/*
 * This structure should be used to declare and program LN_ADDR3.
 *
 */
typedef union BCMI_TSCE16_XGXS_LN_ADDR3r_s {
	uint32_t v[1];
	uint32_t ln_addr3[1];
	uint32_t _ln_addr3;
} BCMI_TSCE16_XGXS_LN_ADDR3r_t;

#define BCMI_TSCE16_XGXS_LN_ADDR3r_CLR(r) (r).ln_addr3[0] = 0
#define BCMI_TSCE16_XGXS_LN_ADDR3r_SET(r,d) (r).ln_addr3[0] = d
#define BCMI_TSCE16_XGXS_LN_ADDR3r_GET(r) (r).ln_addr3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_LN_ADDR3r_TX_LANE_ADDR_3f_GET(r) ((((r).ln_addr3[0]) >> 8) & 0x1f)
#define BCMI_TSCE16_XGXS_LN_ADDR3r_TX_LANE_ADDR_3f_SET(r,f) (r).ln_addr3[0]=(((r).ln_addr3[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_TSCE16_XGXS_LN_ADDR3r_RX_LANE_ADDR_3f_GET(r) (((r).ln_addr3[0]) & 0x1f)
#define BCMI_TSCE16_XGXS_LN_ADDR3r_RX_LANE_ADDR_3f_SET(r,f) (r).ln_addr3[0]=(((r).ln_addr3[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN_ADDR3.
 *
 */
#define BCMI_TSCE16_XGXS_READ_LN_ADDR3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_LN_ADDR3r,(_r._ln_addr3))
#define BCMI_TSCE16_XGXS_WRITE_LN_ADDR3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_LN_ADDR3r,(_r._ln_addr3)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_LN_ADDR3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_LN_ADDR3r,(_r._ln_addr3))
#define BCMI_TSCE16_XGXS_READLN_LN_ADDR3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_LN_ADDR3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr3))
#define BCMI_TSCE16_XGXS_WRITELN_LN_ADDR3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_LN_ADDR3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr3))
#define BCMI_TSCE16_XGXS_WRITEALL_LN_ADDR3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_LN_ADDR3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ln_addr3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_ADDR3r BCMI_TSCE16_XGXS_LN_ADDR3r
#define LN_ADDR3r_SIZE BCMI_TSCE16_XGXS_LN_ADDR3r_SIZE
typedef BCMI_TSCE16_XGXS_LN_ADDR3r_t LN_ADDR3r_t;
#define LN_ADDR3r_CLR BCMI_TSCE16_XGXS_LN_ADDR3r_CLR
#define LN_ADDR3r_SET BCMI_TSCE16_XGXS_LN_ADDR3r_SET
#define LN_ADDR3r_GET BCMI_TSCE16_XGXS_LN_ADDR3r_GET
#define LN_ADDR3r_TX_LANE_ADDR_3f_GET BCMI_TSCE16_XGXS_LN_ADDR3r_TX_LANE_ADDR_3f_GET
#define LN_ADDR3r_TX_LANE_ADDR_3f_SET BCMI_TSCE16_XGXS_LN_ADDR3r_TX_LANE_ADDR_3f_SET
#define LN_ADDR3r_RX_LANE_ADDR_3f_GET BCMI_TSCE16_XGXS_LN_ADDR3r_RX_LANE_ADDR_3f_GET
#define LN_ADDR3r_RX_LANE_ADDR_3f_SET BCMI_TSCE16_XGXS_LN_ADDR3r_RX_LANE_ADDR_3f_SET
#define READ_LN_ADDR3r BCMI_TSCE16_XGXS_READ_LN_ADDR3r
#define WRITE_LN_ADDR3r BCMI_TSCE16_XGXS_WRITE_LN_ADDR3r
#define MODIFY_LN_ADDR3r BCMI_TSCE16_XGXS_MODIFY_LN_ADDR3r
#define READLN_LN_ADDR3r BCMI_TSCE16_XGXS_READLN_LN_ADDR3r
#define WRITELN_LN_ADDR3r BCMI_TSCE16_XGXS_WRITELN_LN_ADDR3r
#define WRITEALL_LN_ADDR3r BCMI_TSCE16_XGXS_WRITEALL_LN_ADDR3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_LN_ADDR3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_LN_CLK_RST_N_PWRDWN_CTL
 * BLOCKS:   RX_CKRST_CTRL
 * REGADDR:  0xd161
 * DESC:     LANE_CLK_RESET_N_POWERDOWN_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_RX_S_PWRDN    Active High Power Down control for RX Lane.If asserted by writing to 1'b1 will power down the RX Lane.
 *     AFE_SIGDET_PWRDN Power Down for Signal Detect. 1=power down
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr (0x0000d161 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RX_LN_CLK_RST_N_PWRDWN_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_s {
	uint32_t v[1];
	uint32_t rx_ln_clk_rst_n_pwrdwn_ctl[1];
	uint32_t _rx_ln_clk_rst_n_pwrdwn_ctl;
} BCMI_TSCE16_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_t;

#define BCMI_TSCE16_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_CLR(r) (r).rx_ln_clk_rst_n_pwrdwn_ctl[0] = 0
#define BCMI_TSCE16_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_SET(r,d) (r).rx_ln_clk_rst_n_pwrdwn_ctl[0] = d
#define BCMI_TSCE16_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_GET(r) (r).rx_ln_clk_rst_n_pwrdwn_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_SIGDET_PWRDNf_GET(r) ((((r).rx_ln_clk_rst_n_pwrdwn_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_SIGDET_PWRDNf_SET(r,f) (r).rx_ln_clk_rst_n_pwrdwn_ctl[0]=(((r).rx_ln_clk_rst_n_pwrdwn_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_LN_RX_S_PWRDNf_GET(r) (((r).rx_ln_clk_rst_n_pwrdwn_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_LN_RX_S_PWRDNf_SET(r,f) (r).rx_ln_clk_rst_n_pwrdwn_ctl[0]=(((r).rx_ln_clk_rst_n_pwrdwn_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_LN_CLK_RST_N_PWRDWN_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr,(_r._rx_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCE16_XGXS_WRITE_RX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr,(_r._rx_ln_clk_rst_n_pwrdwn_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr,(_r._rx_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCE16_XGXS_READLN_RX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_RX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_ln_clk_rst_n_pwrdwn_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCE16_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr
#define RX_LN_CLK_RST_N_PWRDWN_CTLr_SIZE BCMI_TSCE16_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_t RX_LN_CLK_RST_N_PWRDWN_CTLr_t;
#define RX_LN_CLK_RST_N_PWRDWN_CTLr_CLR BCMI_TSCE16_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_CLR
#define RX_LN_CLK_RST_N_PWRDWN_CTLr_SET BCMI_TSCE16_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_SET
#define RX_LN_CLK_RST_N_PWRDWN_CTLr_GET BCMI_TSCE16_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_GET
#define RX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_SIGDET_PWRDNf_GET BCMI_TSCE16_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_SIGDET_PWRDNf_GET
#define RX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_SIGDET_PWRDNf_SET BCMI_TSCE16_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_SIGDET_PWRDNf_SET
#define RX_LN_CLK_RST_N_PWRDWN_CTLr_LN_RX_S_PWRDNf_GET BCMI_TSCE16_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_LN_RX_S_PWRDNf_GET
#define RX_LN_CLK_RST_N_PWRDWN_CTLr_LN_RX_S_PWRDNf_SET BCMI_TSCE16_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_LN_RX_S_PWRDNf_SET
#define READ_RX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCE16_XGXS_READ_RX_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITE_RX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCE16_XGXS_WRITE_RX_LN_CLK_RST_N_PWRDWN_CTLr
#define MODIFY_RX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCE16_XGXS_MODIFY_RX_LN_CLK_RST_N_PWRDWN_CTLr
#define READLN_RX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCE16_XGXS_READLN_RX_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITELN_RX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCE16_XGXS_WRITELN_RX_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITEALL_RX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCE16_XGXS_WRITEALL_RX_LN_CLK_RST_N_PWRDWN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_LN_AFE_RST_PWRDWN_CTL_CTL
 * BLOCKS:   RX_CKRST_CTRL
 * REGADDR:  0xd162
 * DESC:     LANE_AFE_RESET_PWRDWN_CONTROL_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AFE_RX_PWRDN_FRC AFE RX Lane powerdown force.
 *     AFE_RX_PWRDN_FRC_VAL AFE RX Lane powerdown force value.
 *     AFE_RX_RESET_FRC AFE RX Lane reset force.
 *     AFE_RX_RESET_FRC_VAL AFE RX Lane reset force value.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr (0x0000d162 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RX_LN_AFE_RST_PWRDWN_CTL_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_s {
	uint32_t v[1];
	uint32_t rx_ln_afe_rst_pwrdwn_ctl_ctl[1];
	uint32_t _rx_ln_afe_rst_pwrdwn_ctl_ctl;
} BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_t;

#define BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_CLR(r) (r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0] = 0
#define BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_SET(r,d) (r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0] = d
#define BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_GET(r) (r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRC_VALf_GET(r) ((((r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRC_VALf_SET(r,f) (r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRCf_GET(r) ((((r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRCf_SET(r,f) (r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRC_VALf_GET(r) ((((r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRC_VALf_SET(r,f) (r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRCf_GET(r) (((r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRCf_SET(r,f) (r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_LN_AFE_RST_PWRDWN_CTL_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr,(_r._rx_ln_afe_rst_pwrdwn_ctl_ctl))
#define BCMI_TSCE16_XGXS_WRITE_RX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr,(_r._rx_ln_afe_rst_pwrdwn_ctl_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr,(_r._rx_ln_afe_rst_pwrdwn_ctl_ctl))
#define BCMI_TSCE16_XGXS_READLN_RX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ln_afe_rst_pwrdwn_ctl_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_RX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ln_afe_rst_pwrdwn_ctl_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_ln_afe_rst_pwrdwn_ctl_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_SIZE BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_t RX_LN_AFE_RST_PWRDWN_CTL_CTLr_t;
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_CLR BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_CLR
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_SET BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_SET
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_GET BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_GET
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRC_VALf_GET BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRC_VALf_GET
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRC_VALf_SET BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRC_VALf_SET
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRCf_GET BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRCf_GET
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRCf_SET BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRCf_SET
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRC_VALf_GET BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRC_VALf_GET
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRC_VALf_SET BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRC_VALf_SET
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRCf_GET BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRCf_GET
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRCf_SET BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRCf_SET
#define READ_RX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_TSCE16_XGXS_READ_RX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define WRITE_RX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_TSCE16_XGXS_WRITE_RX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define MODIFY_RX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_TSCE16_XGXS_MODIFY_RX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define READLN_RX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_TSCE16_XGXS_READLN_RX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define WRITELN_RX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_TSCE16_XGXS_WRITELN_RX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define WRITEALL_RX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_TSCE16_XGXS_WRITEALL_RX_LN_AFE_RST_PWRDWN_CTL_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_LN_RST_N_PWRDN_PIN_KILL_CTL
 * BLOCKS:   RX_CKRST_CTRL
 * REGADDR:  0xd163
 * DESC:     LANE_RESET_N_PWRDN_PIN_KILL_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMD_LN_RX_H_PWRDN_PKILL 1'b1 will disable the pmd_ln_rx_h_pwrdn input pin.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr (0x0000d163 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RX_LN_RST_N_PWRDN_PIN_KILL_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_s {
	uint32_t v[1];
	uint32_t rx_ln_rst_n_pwrdn_pin_kill_ctl[1];
	uint32_t _rx_ln_rst_n_pwrdn_pin_kill_ctl;
} BCMI_TSCE16_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_t;

#define BCMI_TSCE16_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR(r) (r).rx_ln_rst_n_pwrdn_pin_kill_ctl[0] = 0
#define BCMI_TSCE16_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET(r,d) (r).rx_ln_rst_n_pwrdn_pin_kill_ctl[0] = d
#define BCMI_TSCE16_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET(r) (r).rx_ln_rst_n_pwrdn_pin_kill_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_PWRDN_PKILLf_GET(r) (((r).rx_ln_rst_n_pwrdn_pin_kill_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_PWRDN_PKILLf_SET(r,f) (r).rx_ln_rst_n_pwrdn_pin_kill_ctl[0]=(((r).rx_ln_rst_n_pwrdn_pin_kill_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_LN_RST_N_PWRDN_PIN_KILL_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._rx_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCE16_XGXS_WRITE_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._rx_ln_rst_n_pwrdn_pin_kill_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._rx_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCE16_XGXS_READLN_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_ln_rst_n_pwrdn_pin_kill_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCE16_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE BCMI_TSCE16_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_t RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_t;
#define RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR BCMI_TSCE16_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR
#define RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET BCMI_TSCE16_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET
#define RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET BCMI_TSCE16_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET
#define RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_PWRDN_PKILLf_GET BCMI_TSCE16_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_PWRDN_PKILLf_GET
#define RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_PWRDN_PKILLf_SET BCMI_TSCE16_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_PWRDN_PKILLf_SET
#define READ_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCE16_XGXS_READ_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITE_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCE16_XGXS_WRITE_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define MODIFY_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCE16_XGXS_MODIFY_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define READLN_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCE16_XGXS_READLN_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITELN_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCE16_XGXS_WRITELN_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITEALL_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCE16_XGXS_WRITEALL_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_LN_DBG_RST_CTL
 * BLOCKS:   RX_CKRST_CTRL
 * REGADDR:  0xd164
 * DESC:     LANE_DEBUG_RESET_CONTROL
 * RESETVAL: 0x3 (3)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_RX_S_RSTB     Active Low Lane Soft Reset for RX datapath and registers. If asserted by writing to 1'b0 will reset the RX registers and datapath for a lane.This is a debug only register and it is not handled by FW-HW handshake
 *     LN_RX_DP_S_RSTB  Active Low Lane Soft Reset for RX datapath. If asserted by writing to 1'b0 will reset the RX datapath for a lane.This is a debug only register and it is not handled by FW-HW handshake
 *     SIGDET_DP_RSTB_EN If asserted by writing to 1'b1 then lane datapath reset will also reset the sigdet filetr logic alomg with lane register reset.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_LN_DBG_RST_CTLr (0x0000d164 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_LN_DBG_RST_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RX_LN_DBG_RST_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_LN_DBG_RST_CTLr_s {
	uint32_t v[1];
	uint32_t rx_ln_dbg_rst_ctl[1];
	uint32_t _rx_ln_dbg_rst_ctl;
} BCMI_TSCE16_XGXS_RX_LN_DBG_RST_CTLr_t;

#define BCMI_TSCE16_XGXS_RX_LN_DBG_RST_CTLr_CLR(r) (r).rx_ln_dbg_rst_ctl[0] = 0
#define BCMI_TSCE16_XGXS_RX_LN_DBG_RST_CTLr_SET(r,d) (r).rx_ln_dbg_rst_ctl[0] = d
#define BCMI_TSCE16_XGXS_RX_LN_DBG_RST_CTLr_GET(r) (r).rx_ln_dbg_rst_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_LN_DBG_RST_CTLr_SIGDET_DP_RSTB_ENf_GET(r) ((((r).rx_ln_dbg_rst_ctl[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_RX_LN_DBG_RST_CTLr_SIGDET_DP_RSTB_ENf_SET(r,f) (r).rx_ln_dbg_rst_ctl[0]=(((r).rx_ln_dbg_rst_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_RX_LN_DBG_RST_CTLr_LN_RX_DP_S_RSTBf_GET(r) ((((r).rx_ln_dbg_rst_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_RX_LN_DBG_RST_CTLr_LN_RX_DP_S_RSTBf_SET(r,f) (r).rx_ln_dbg_rst_ctl[0]=(((r).rx_ln_dbg_rst_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_RX_LN_DBG_RST_CTLr_LN_RX_S_RSTBf_GET(r) (((r).rx_ln_dbg_rst_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_RX_LN_DBG_RST_CTLr_LN_RX_S_RSTBf_SET(r,f) (r).rx_ln_dbg_rst_ctl[0]=(((r).rx_ln_dbg_rst_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_LN_DBG_RST_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_LN_DBG_RST_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_LN_DBG_RST_CTLr,(_r._rx_ln_dbg_rst_ctl))
#define BCMI_TSCE16_XGXS_WRITE_RX_LN_DBG_RST_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_LN_DBG_RST_CTLr,(_r._rx_ln_dbg_rst_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_LN_DBG_RST_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_LN_DBG_RST_CTLr,(_r._rx_ln_dbg_rst_ctl))
#define BCMI_TSCE16_XGXS_READLN_RX_LN_DBG_RST_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_LN_DBG_RST_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ln_dbg_rst_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_RX_LN_DBG_RST_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_LN_DBG_RST_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ln_dbg_rst_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_LN_DBG_RST_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_LN_DBG_RST_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_ln_dbg_rst_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_LN_DBG_RST_CTLr BCMI_TSCE16_XGXS_RX_LN_DBG_RST_CTLr
#define RX_LN_DBG_RST_CTLr_SIZE BCMI_TSCE16_XGXS_RX_LN_DBG_RST_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_RX_LN_DBG_RST_CTLr_t RX_LN_DBG_RST_CTLr_t;
#define RX_LN_DBG_RST_CTLr_CLR BCMI_TSCE16_XGXS_RX_LN_DBG_RST_CTLr_CLR
#define RX_LN_DBG_RST_CTLr_SET BCMI_TSCE16_XGXS_RX_LN_DBG_RST_CTLr_SET
#define RX_LN_DBG_RST_CTLr_GET BCMI_TSCE16_XGXS_RX_LN_DBG_RST_CTLr_GET
#define RX_LN_DBG_RST_CTLr_SIGDET_DP_RSTB_ENf_GET BCMI_TSCE16_XGXS_RX_LN_DBG_RST_CTLr_SIGDET_DP_RSTB_ENf_GET
#define RX_LN_DBG_RST_CTLr_SIGDET_DP_RSTB_ENf_SET BCMI_TSCE16_XGXS_RX_LN_DBG_RST_CTLr_SIGDET_DP_RSTB_ENf_SET
#define RX_LN_DBG_RST_CTLr_LN_RX_DP_S_RSTBf_GET BCMI_TSCE16_XGXS_RX_LN_DBG_RST_CTLr_LN_RX_DP_S_RSTBf_GET
#define RX_LN_DBG_RST_CTLr_LN_RX_DP_S_RSTBf_SET BCMI_TSCE16_XGXS_RX_LN_DBG_RST_CTLr_LN_RX_DP_S_RSTBf_SET
#define RX_LN_DBG_RST_CTLr_LN_RX_S_RSTBf_GET BCMI_TSCE16_XGXS_RX_LN_DBG_RST_CTLr_LN_RX_S_RSTBf_GET
#define RX_LN_DBG_RST_CTLr_LN_RX_S_RSTBf_SET BCMI_TSCE16_XGXS_RX_LN_DBG_RST_CTLr_LN_RX_S_RSTBf_SET
#define READ_RX_LN_DBG_RST_CTLr BCMI_TSCE16_XGXS_READ_RX_LN_DBG_RST_CTLr
#define WRITE_RX_LN_DBG_RST_CTLr BCMI_TSCE16_XGXS_WRITE_RX_LN_DBG_RST_CTLr
#define MODIFY_RX_LN_DBG_RST_CTLr BCMI_TSCE16_XGXS_MODIFY_RX_LN_DBG_RST_CTLr
#define READLN_RX_LN_DBG_RST_CTLr BCMI_TSCE16_XGXS_READLN_RX_LN_DBG_RST_CTLr
#define WRITELN_RX_LN_DBG_RST_CTLr BCMI_TSCE16_XGXS_WRITELN_RX_LN_DBG_RST_CTLr
#define WRITEALL_RX_LN_DBG_RST_CTLr BCMI_TSCE16_XGXS_WRITEALL_RX_LN_DBG_RST_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_LN_DBG_RST_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_CLK_N_RST_DBG_CTL
 * BLOCKS:   RX_CKRST_CTRL
 * REGADDR:  0xd167
 * DESC:     CLOCK_N_RESET_DEBUG_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_RX_S_CLKGATE_FRC_ON RX Active High Lane clock gator enable. If 1'1b1 then rx lane clock will be gated off. It does not affect the rclk goingto RMIC block so rx lane based registers can still be readable but not writable.It is recommended for user to force pmd_rx_clk_vld to 1'b0 while rx_s_clkgate_frc_on is asserted to 1'b1by using pmd_rx_clk_vld_frc/frc_val registers.
 *     LN_RX_S_COMCLK_SEL Mux control for selection of comclk for RX Lane clocks.If asserted by writing to 1'b1 will select the comclk for the lane clocks.It is recommended for user to force pmd_rx_clk_vld to 1'b0 while ln_rx_s_comclk_sel is asserted to 1'b1by using pmd_rx_clk_vld_frc/frc_val registers.
 *     LN_RX_S_COMCLK_FRC_ON Mux control for selection of comclk for RX Lane clocks by force.If asserted by writing to 1'b1 will select the comclk for the RX lane clocks. This is a debug bit and should be used only for recovery from a dead AFE lane clock. Use of this bit with an active AFE clock can cause clock glitches.It is recommended for user to force pmd_rx_clk_vld to 1'b0 while ln_rx_s_comclk_frc_on is asserted to 1'b1by using pmd_rx_clk_vld_frc/frc_val registers.
 *     PMD_RX_CLK_VLD_FRC pmd_rx_clk_vld core output pin force.
 *     PMD_RX_CLK_VLD_FRC_VAL pmd_rx_clk_vld core output pin force value.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr (0x0000d167 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RX_CLK_N_RST_DBG_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr_s {
	uint32_t v[1];
	uint32_t rx_clk_n_rst_dbg_ctl[1];
	uint32_t _rx_clk_n_rst_dbg_ctl;
} BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr_t;

#define BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr_CLR(r) (r).rx_clk_n_rst_dbg_ctl[0] = 0
#define BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr_SET(r,d) (r).rx_clk_n_rst_dbg_ctl[0] = d
#define BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr_GET(r) (r).rx_clk_n_rst_dbg_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRC_VALf_GET(r) ((((r).rx_clk_n_rst_dbg_ctl[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRC_VALf_SET(r,f) (r).rx_clk_n_rst_dbg_ctl[0]=(((r).rx_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRCf_GET(r) ((((r).rx_clk_n_rst_dbg_ctl[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRCf_SET(r,f) (r).rx_clk_n_rst_dbg_ctl[0]=(((r).rx_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_FRC_ONf_GET(r) ((((r).rx_clk_n_rst_dbg_ctl[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_FRC_ONf_SET(r,f) (r).rx_clk_n_rst_dbg_ctl[0]=(((r).rx_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_SELf_GET(r) ((((r).rx_clk_n_rst_dbg_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_SELf_SET(r,f) (r).rx_clk_n_rst_dbg_ctl[0]=(((r).rx_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_CLKGATE_FRC_ONf_GET(r) (((r).rx_clk_n_rst_dbg_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_CLKGATE_FRC_ONf_SET(r,f) (r).rx_clk_n_rst_dbg_ctl[0]=(((r).rx_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_CLK_N_RST_DBG_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_CLK_N_RST_DBG_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr,(_r._rx_clk_n_rst_dbg_ctl))
#define BCMI_TSCE16_XGXS_WRITE_RX_CLK_N_RST_DBG_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr,(_r._rx_clk_n_rst_dbg_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_CLK_N_RST_DBG_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr,(_r._rx_clk_n_rst_dbg_ctl))
#define BCMI_TSCE16_XGXS_READLN_RX_CLK_N_RST_DBG_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_clk_n_rst_dbg_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_RX_CLK_N_RST_DBG_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_clk_n_rst_dbg_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_CLK_N_RST_DBG_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_clk_n_rst_dbg_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_CLK_N_RST_DBG_CTLr BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr
#define RX_CLK_N_RST_DBG_CTLr_SIZE BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr_t RX_CLK_N_RST_DBG_CTLr_t;
#define RX_CLK_N_RST_DBG_CTLr_CLR BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr_CLR
#define RX_CLK_N_RST_DBG_CTLr_SET BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr_SET
#define RX_CLK_N_RST_DBG_CTLr_GET BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr_GET
#define RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRC_VALf_GET BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRC_VALf_GET
#define RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRC_VALf_SET BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRC_VALf_SET
#define RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRCf_GET BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRCf_GET
#define RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRCf_SET BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRCf_SET
#define RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_FRC_ONf_GET BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_FRC_ONf_GET
#define RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_FRC_ONf_SET BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_FRC_ONf_SET
#define RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_SELf_GET BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_SELf_GET
#define RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_SELf_SET BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_SELf_SET
#define RX_CLK_N_RST_DBG_CTLr_LN_RX_S_CLKGATE_FRC_ONf_GET BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_CLKGATE_FRC_ONf_GET
#define RX_CLK_N_RST_DBG_CTLr_LN_RX_S_CLKGATE_FRC_ONf_SET BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_CLKGATE_FRC_ONf_SET
#define READ_RX_CLK_N_RST_DBG_CTLr BCMI_TSCE16_XGXS_READ_RX_CLK_N_RST_DBG_CTLr
#define WRITE_RX_CLK_N_RST_DBG_CTLr BCMI_TSCE16_XGXS_WRITE_RX_CLK_N_RST_DBG_CTLr
#define MODIFY_RX_CLK_N_RST_DBG_CTLr BCMI_TSCE16_XGXS_MODIFY_RX_CLK_N_RST_DBG_CTLr
#define READLN_RX_CLK_N_RST_DBG_CTLr BCMI_TSCE16_XGXS_READLN_RX_CLK_N_RST_DBG_CTLr
#define WRITELN_RX_CLK_N_RST_DBG_CTLr BCMI_TSCE16_XGXS_WRITELN_RX_CLK_N_RST_DBG_CTLr
#define WRITEALL_RX_CLK_N_RST_DBG_CTLr BCMI_TSCE16_XGXS_WRITEALL_RX_CLK_N_RST_DBG_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_CLK_N_RST_DBG_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_PMD_LN_MODE_STS
 * BLOCKS:   RX_CKRST_CTRL
 * REGADDR:  0xd168
 * DESC:     PMD_LANE_MODE_STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PMD_LANE_MODE    This indicates the status of the core input pin pmd_lane_mode.This is driven from PCS and used for communication between PCS and PMD Micro code.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_PMD_LN_MODE_STSr (0x0000d168 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_PMD_LN_MODE_STSr_SIZE 4

/*
 * This structure should be used to declare and program RX_PMD_LN_MODE_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_PMD_LN_MODE_STSr_s {
	uint32_t v[1];
	uint32_t rx_pmd_ln_mode_sts[1];
	uint32_t _rx_pmd_ln_mode_sts;
} BCMI_TSCE16_XGXS_RX_PMD_LN_MODE_STSr_t;

#define BCMI_TSCE16_XGXS_RX_PMD_LN_MODE_STSr_CLR(r) (r).rx_pmd_ln_mode_sts[0] = 0
#define BCMI_TSCE16_XGXS_RX_PMD_LN_MODE_STSr_SET(r,d) (r).rx_pmd_ln_mode_sts[0] = d
#define BCMI_TSCE16_XGXS_RX_PMD_LN_MODE_STSr_GET(r) (r).rx_pmd_ln_mode_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_PMD_LN_MODE_STSr_PMD_LANE_MODEf_GET(r) (((r).rx_pmd_ln_mode_sts[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_RX_PMD_LN_MODE_STSr_PMD_LANE_MODEf_SET(r,f) (r).rx_pmd_ln_mode_sts[0]=(((r).rx_pmd_ln_mode_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_PMD_LN_MODE_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_PMD_LN_MODE_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_PMD_LN_MODE_STSr,(_r._rx_pmd_ln_mode_sts))
#define BCMI_TSCE16_XGXS_WRITE_RX_PMD_LN_MODE_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_PMD_LN_MODE_STSr,(_r._rx_pmd_ln_mode_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_PMD_LN_MODE_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_PMD_LN_MODE_STSr,(_r._rx_pmd_ln_mode_sts))
#define BCMI_TSCE16_XGXS_READLN_RX_PMD_LN_MODE_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_PMD_LN_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_pmd_ln_mode_sts))
#define BCMI_TSCE16_XGXS_WRITELN_RX_PMD_LN_MODE_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_PMD_LN_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_pmd_ln_mode_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_PMD_LN_MODE_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_PMD_LN_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_pmd_ln_mode_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_PMD_LN_MODE_STSr BCMI_TSCE16_XGXS_RX_PMD_LN_MODE_STSr
#define RX_PMD_LN_MODE_STSr_SIZE BCMI_TSCE16_XGXS_RX_PMD_LN_MODE_STSr_SIZE
typedef BCMI_TSCE16_XGXS_RX_PMD_LN_MODE_STSr_t RX_PMD_LN_MODE_STSr_t;
#define RX_PMD_LN_MODE_STSr_CLR BCMI_TSCE16_XGXS_RX_PMD_LN_MODE_STSr_CLR
#define RX_PMD_LN_MODE_STSr_SET BCMI_TSCE16_XGXS_RX_PMD_LN_MODE_STSr_SET
#define RX_PMD_LN_MODE_STSr_GET BCMI_TSCE16_XGXS_RX_PMD_LN_MODE_STSr_GET
#define RX_PMD_LN_MODE_STSr_PMD_LANE_MODEf_GET BCMI_TSCE16_XGXS_RX_PMD_LN_MODE_STSr_PMD_LANE_MODEf_GET
#define RX_PMD_LN_MODE_STSr_PMD_LANE_MODEf_SET BCMI_TSCE16_XGXS_RX_PMD_LN_MODE_STSr_PMD_LANE_MODEf_SET
#define READ_RX_PMD_LN_MODE_STSr BCMI_TSCE16_XGXS_READ_RX_PMD_LN_MODE_STSr
#define WRITE_RX_PMD_LN_MODE_STSr BCMI_TSCE16_XGXS_WRITE_RX_PMD_LN_MODE_STSr
#define MODIFY_RX_PMD_LN_MODE_STSr BCMI_TSCE16_XGXS_MODIFY_RX_PMD_LN_MODE_STSr
#define READLN_RX_PMD_LN_MODE_STSr BCMI_TSCE16_XGXS_READLN_RX_PMD_LN_MODE_STSr
#define WRITELN_RX_PMD_LN_MODE_STSr BCMI_TSCE16_XGXS_WRITELN_RX_PMD_LN_MODE_STSr
#define WRITEALL_RX_PMD_LN_MODE_STSr BCMI_TSCE16_XGXS_WRITEALL_RX_PMD_LN_MODE_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_PMD_LN_MODE_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RX_AFE_RST_PWRDN_OSR_MODE_PIN_STS
 * BLOCKS:   RX_CKRST_CTRL
 * REGADDR:  0xd16c
 * DESC:     AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS
 * RESETVAL: 0x2 (2)
 * ACCESS:   R/O
 * FIELDS:
 *     AFE_RX_PWRDN     Indicates the status of the afe_rx_pwrdn signal to the AFE after frc/frc_val mux.
 *     AFE_RX_RESET     Indicates the status of the afe_rx_reset signal to the AFE after frc/frc_val mux.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr (0x0000d16c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SIZE 4

/*
 * This structure should be used to declare and program RX_AFE_RST_PWRDN_OSR_MODE_PIN_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_s {
	uint32_t v[1];
	uint32_t rx_afe_rst_pwrdn_osr_mode_pin_sts[1];
	uint32_t _rx_afe_rst_pwrdn_osr_mode_pin_sts;
} BCMI_TSCE16_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_t;

#define BCMI_TSCE16_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_CLR(r) (r).rx_afe_rst_pwrdn_osr_mode_pin_sts[0] = 0
#define BCMI_TSCE16_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SET(r,d) (r).rx_afe_rst_pwrdn_osr_mode_pin_sts[0] = d
#define BCMI_TSCE16_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_GET(r) (r).rx_afe_rst_pwrdn_osr_mode_pin_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_RX_RESETf_GET(r) ((((r).rx_afe_rst_pwrdn_osr_mode_pin_sts[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_RX_RESETf_SET(r,f) (r).rx_afe_rst_pwrdn_osr_mode_pin_sts[0]=(((r).rx_afe_rst_pwrdn_osr_mode_pin_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_RX_PWRDNf_GET(r) (((r).rx_afe_rst_pwrdn_osr_mode_pin_sts[0]) & 0x1)
#define BCMI_TSCE16_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_RX_PWRDNf_SET(r,f) (r).rx_afe_rst_pwrdn_osr_mode_pin_sts[0]=(((r).rx_afe_rst_pwrdn_osr_mode_pin_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_AFE_RST_PWRDN_OSR_MODE_PIN_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr,(_r._rx_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_TSCE16_XGXS_WRITE_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr,(_r._rx_afe_rst_pwrdn_osr_mode_pin_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr,(_r._rx_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_TSCE16_XGXS_READLN_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_TSCE16_XGXS_WRITELN_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_afe_rst_pwrdn_osr_mode_pin_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_TSCE16_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SIZE BCMI_TSCE16_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SIZE
typedef BCMI_TSCE16_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_t RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_t;
#define RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_CLR BCMI_TSCE16_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_CLR
#define RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SET BCMI_TSCE16_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SET
#define RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_GET BCMI_TSCE16_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_GET
#define RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_RX_RESETf_GET BCMI_TSCE16_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_RX_RESETf_GET
#define RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_RX_RESETf_SET BCMI_TSCE16_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_RX_RESETf_SET
#define RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_RX_PWRDNf_GET BCMI_TSCE16_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_RX_PWRDNf_GET
#define RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_RX_PWRDNf_SET BCMI_TSCE16_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_RX_PWRDNf_SET
#define READ_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_TSCE16_XGXS_READ_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define WRITE_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_TSCE16_XGXS_WRITE_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define MODIFY_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_TSCE16_XGXS_MODIFY_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define READLN_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_TSCE16_XGXS_READLN_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define WRITELN_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_TSCE16_XGXS_WRITELN_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define WRITEALL_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_TSCE16_XGXS_WRITEALL_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_LN_CLK_RST_N_PWRDWN_CTL
 * BLOCKS:   TX_CKRST_CTRL
 * REGADDR:  0xd171
 * DESC:     LANE_CLK_RESET_N_POWERDOWN_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_TX_S_PWRDN    Active High Power Down control for TX Lane.If asserted by writing to 1'b1 will power down the TX Lane.
 *     AFE_TX_RESET_DEASSERT AFE TX Lane reset control. This register will be reset upon POR reg/pin or lane reset reg/pin. Lower priority than the afe_tx_reset_frc/frc_val and  afe_txclk_reset_frc/frc_val option.1 - AFE TX Lane txclk_reset/tx_reset pins will be forcefully de-asserted irrespective of core/lane datapath pin/reg resets asserted.This bit must be set to 1'b1 for TX_Disable all 1s/0s mode to allow TX AFE to transmit the all 1s/0s data.0 - AFE TX Lane txclk_reset/tx_reset pins will be asserted if core/lane pin/reg resets are asserted.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr (0x0000d171 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TX_LN_CLK_RST_N_PWRDWN_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_s {
	uint32_t v[1];
	uint32_t tx_ln_clk_rst_n_pwrdwn_ctl[1];
	uint32_t _tx_ln_clk_rst_n_pwrdwn_ctl;
} BCMI_TSCE16_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_t;

#define BCMI_TSCE16_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_CLR(r) (r).tx_ln_clk_rst_n_pwrdwn_ctl[0] = 0
#define BCMI_TSCE16_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_SET(r,d) (r).tx_ln_clk_rst_n_pwrdwn_ctl[0] = d
#define BCMI_TSCE16_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_GET(r) (r).tx_ln_clk_rst_n_pwrdwn_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_TX_RESET_DEASSERTf_GET(r) ((((r).tx_ln_clk_rst_n_pwrdwn_ctl[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_TX_RESET_DEASSERTf_SET(r,f) (r).tx_ln_clk_rst_n_pwrdwn_ctl[0]=(((r).tx_ln_clk_rst_n_pwrdwn_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_LN_TX_S_PWRDNf_GET(r) (((r).tx_ln_clk_rst_n_pwrdwn_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_LN_TX_S_PWRDNf_SET(r,f) (r).tx_ln_clk_rst_n_pwrdwn_ctl[0]=(((r).tx_ln_clk_rst_n_pwrdwn_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_LN_CLK_RST_N_PWRDWN_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr,(_r._tx_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCE16_XGXS_WRITE_TX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr,(_r._tx_ln_clk_rst_n_pwrdwn_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr,(_r._tx_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCE16_XGXS_READLN_TX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_TX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_ln_clk_rst_n_pwrdwn_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCE16_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr
#define TX_LN_CLK_RST_N_PWRDWN_CTLr_SIZE BCMI_TSCE16_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_t TX_LN_CLK_RST_N_PWRDWN_CTLr_t;
#define TX_LN_CLK_RST_N_PWRDWN_CTLr_CLR BCMI_TSCE16_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_CLR
#define TX_LN_CLK_RST_N_PWRDWN_CTLr_SET BCMI_TSCE16_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_SET
#define TX_LN_CLK_RST_N_PWRDWN_CTLr_GET BCMI_TSCE16_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_GET
#define TX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_TX_RESET_DEASSERTf_GET BCMI_TSCE16_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_TX_RESET_DEASSERTf_GET
#define TX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_TX_RESET_DEASSERTf_SET BCMI_TSCE16_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_TX_RESET_DEASSERTf_SET
#define TX_LN_CLK_RST_N_PWRDWN_CTLr_LN_TX_S_PWRDNf_GET BCMI_TSCE16_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_LN_TX_S_PWRDNf_GET
#define TX_LN_CLK_RST_N_PWRDWN_CTLr_LN_TX_S_PWRDNf_SET BCMI_TSCE16_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_LN_TX_S_PWRDNf_SET
#define READ_TX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCE16_XGXS_READ_TX_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITE_TX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCE16_XGXS_WRITE_TX_LN_CLK_RST_N_PWRDWN_CTLr
#define MODIFY_TX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCE16_XGXS_MODIFY_TX_LN_CLK_RST_N_PWRDWN_CTLr
#define READLN_TX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCE16_XGXS_READLN_TX_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITELN_TX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCE16_XGXS_WRITELN_TX_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITEALL_TX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCE16_XGXS_WRITEALL_TX_LN_CLK_RST_N_PWRDWN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_LN_AFE_RST_PWRDWN_CTL_CTL
 * BLOCKS:   TX_CKRST_CTRL
 * REGADDR:  0xd172
 * DESC:     LANE_AFE_RESET_PWRDWN_CONTROL_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AFE_TX_PWRDN_FRC AFE TX Lane powerdown force.
 *     AFE_TX_PWRDN_FRC_VAL AFE TX Lane powerdown force value.
 *     AFE_TX_RESET_FRC AFE TX Lane reset force.
 *     AFE_TX_RESET_FRC_VAL AFE TX Lane reset force value.
 *     AFE_TXCLK_RESET_FRC AFE TXCLK Lane reset force.
 *     AFE_TXCLK_RESET_FRC_VAL AFE TXCLK Lane reset force value.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr (0x0000d172 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TX_LN_AFE_RST_PWRDWN_CTL_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_s {
	uint32_t v[1];
	uint32_t tx_ln_afe_rst_pwrdwn_ctl_ctl[1];
	uint32_t _tx_ln_afe_rst_pwrdwn_ctl_ctl;
} BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_t;

#define BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_CLR(r) (r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0] = 0
#define BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_SET(r,d) (r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0] = d
#define BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_GET(r) (r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TXCLK_RESET_FRC_VALf_GET(r) ((((r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TXCLK_RESET_FRC_VALf_SET(r,f) (r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TXCLK_RESET_FRCf_GET(r) ((((r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TXCLK_RESET_FRCf_SET(r,f) (r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRC_VALf_GET(r) ((((r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRC_VALf_SET(r,f) (r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRCf_GET(r) ((((r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRCf_SET(r,f) (r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRC_VALf_GET(r) ((((r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRC_VALf_SET(r,f) (r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRCf_GET(r) (((r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRCf_SET(r,f) (r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_LN_AFE_RST_PWRDWN_CTL_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr,(_r._tx_ln_afe_rst_pwrdwn_ctl_ctl))
#define BCMI_TSCE16_XGXS_WRITE_TX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr,(_r._tx_ln_afe_rst_pwrdwn_ctl_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr,(_r._tx_ln_afe_rst_pwrdwn_ctl_ctl))
#define BCMI_TSCE16_XGXS_READLN_TX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ln_afe_rst_pwrdwn_ctl_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_TX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ln_afe_rst_pwrdwn_ctl_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_ln_afe_rst_pwrdwn_ctl_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_SIZE BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_t TX_LN_AFE_RST_PWRDWN_CTL_CTLr_t;
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_CLR BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_CLR
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_SET BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_SET
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_GET BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_GET
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TXCLK_RESET_FRC_VALf_GET BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TXCLK_RESET_FRC_VALf_GET
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TXCLK_RESET_FRC_VALf_SET BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TXCLK_RESET_FRC_VALf_SET
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TXCLK_RESET_FRCf_GET BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TXCLK_RESET_FRCf_GET
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TXCLK_RESET_FRCf_SET BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TXCLK_RESET_FRCf_SET
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRC_VALf_GET BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRC_VALf_GET
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRC_VALf_SET BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRC_VALf_SET
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRCf_GET BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRCf_GET
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRCf_SET BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRCf_SET
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRC_VALf_GET BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRC_VALf_GET
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRC_VALf_SET BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRC_VALf_SET
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRCf_GET BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRCf_GET
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRCf_SET BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRCf_SET
#define READ_TX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_TSCE16_XGXS_READ_TX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define WRITE_TX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_TSCE16_XGXS_WRITE_TX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define MODIFY_TX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_TSCE16_XGXS_MODIFY_TX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define READLN_TX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_TSCE16_XGXS_READLN_TX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define WRITELN_TX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_TSCE16_XGXS_WRITELN_TX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define WRITEALL_TX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_TSCE16_XGXS_WRITEALL_TX_LN_AFE_RST_PWRDWN_CTL_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_LN_RST_N_PWRDN_PIN_KILL_CTL
 * BLOCKS:   TX_CKRST_CTRL
 * REGADDR:  0xd173
 * DESC:     LANE_RESET_N_PWRDN_PIN_KILL_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMD_LN_TX_H_PWRDN_PKILL 1'b1 will disable the pmd_ln_tx_h_pwrdn input pin.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr (0x0000d173 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TX_LN_RST_N_PWRDN_PIN_KILL_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_s {
	uint32_t v[1];
	uint32_t tx_ln_rst_n_pwrdn_pin_kill_ctl[1];
	uint32_t _tx_ln_rst_n_pwrdn_pin_kill_ctl;
} BCMI_TSCE16_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_t;

#define BCMI_TSCE16_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR(r) (r).tx_ln_rst_n_pwrdn_pin_kill_ctl[0] = 0
#define BCMI_TSCE16_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET(r,d) (r).tx_ln_rst_n_pwrdn_pin_kill_ctl[0] = d
#define BCMI_TSCE16_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET(r) (r).tx_ln_rst_n_pwrdn_pin_kill_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_PWRDN_PKILLf_GET(r) (((r).tx_ln_rst_n_pwrdn_pin_kill_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_PWRDN_PKILLf_SET(r,f) (r).tx_ln_rst_n_pwrdn_pin_kill_ctl[0]=(((r).tx_ln_rst_n_pwrdn_pin_kill_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_LN_RST_N_PWRDN_PIN_KILL_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._tx_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCE16_XGXS_WRITE_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._tx_ln_rst_n_pwrdn_pin_kill_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._tx_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCE16_XGXS_READLN_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_ln_rst_n_pwrdn_pin_kill_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCE16_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE BCMI_TSCE16_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_t TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_t;
#define TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR BCMI_TSCE16_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR
#define TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET BCMI_TSCE16_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET
#define TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET BCMI_TSCE16_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET
#define TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_PWRDN_PKILLf_GET BCMI_TSCE16_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_PWRDN_PKILLf_GET
#define TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_PWRDN_PKILLf_SET BCMI_TSCE16_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_PWRDN_PKILLf_SET
#define READ_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCE16_XGXS_READ_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITE_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCE16_XGXS_WRITE_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define MODIFY_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCE16_XGXS_MODIFY_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define READLN_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCE16_XGXS_READLN_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITELN_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCE16_XGXS_WRITELN_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITEALL_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCE16_XGXS_WRITEALL_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_LN_DBG_RST_CTL
 * BLOCKS:   TX_CKRST_CTRL
 * REGADDR:  0xd174
 * DESC:     LANE_DEBUG_RESET_CONTROL
 * RESETVAL: 0x3 (3)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_TX_S_RSTB     Active Low Lane Soft Reset for TX datapath and registers. If asserted by writing to 1'b0 will reset the TX registers and datapath for a lane.This is a debug only register and it is not handled by FW-HW handshake
 *     LN_TX_DP_S_RSTB  Active Low Lane Soft Reset for TX datapath. If asserted by writing to 1'b0 will reset the TX datapath for a lane.This is a debug only register and it is not handled by FW-HW handshake
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_LN_DBG_RST_CTLr (0x0000d174 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_LN_DBG_RST_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TX_LN_DBG_RST_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_LN_DBG_RST_CTLr_s {
	uint32_t v[1];
	uint32_t tx_ln_dbg_rst_ctl[1];
	uint32_t _tx_ln_dbg_rst_ctl;
} BCMI_TSCE16_XGXS_TX_LN_DBG_RST_CTLr_t;

#define BCMI_TSCE16_XGXS_TX_LN_DBG_RST_CTLr_CLR(r) (r).tx_ln_dbg_rst_ctl[0] = 0
#define BCMI_TSCE16_XGXS_TX_LN_DBG_RST_CTLr_SET(r,d) (r).tx_ln_dbg_rst_ctl[0] = d
#define BCMI_TSCE16_XGXS_TX_LN_DBG_RST_CTLr_GET(r) (r).tx_ln_dbg_rst_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_GET(r) ((((r).tx_ln_dbg_rst_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_TX_LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_SET(r,f) (r).tx_ln_dbg_rst_ctl[0]=(((r).tx_ln_dbg_rst_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_TX_LN_DBG_RST_CTLr_LN_TX_S_RSTBf_GET(r) (((r).tx_ln_dbg_rst_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TX_LN_DBG_RST_CTLr_LN_TX_S_RSTBf_SET(r,f) (r).tx_ln_dbg_rst_ctl[0]=(((r).tx_ln_dbg_rst_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_LN_DBG_RST_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_LN_DBG_RST_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_LN_DBG_RST_CTLr,(_r._tx_ln_dbg_rst_ctl))
#define BCMI_TSCE16_XGXS_WRITE_TX_LN_DBG_RST_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_LN_DBG_RST_CTLr,(_r._tx_ln_dbg_rst_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_LN_DBG_RST_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_LN_DBG_RST_CTLr,(_r._tx_ln_dbg_rst_ctl))
#define BCMI_TSCE16_XGXS_READLN_TX_LN_DBG_RST_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_LN_DBG_RST_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ln_dbg_rst_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_TX_LN_DBG_RST_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_LN_DBG_RST_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ln_dbg_rst_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_LN_DBG_RST_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_LN_DBG_RST_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_ln_dbg_rst_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_LN_DBG_RST_CTLr BCMI_TSCE16_XGXS_TX_LN_DBG_RST_CTLr
#define TX_LN_DBG_RST_CTLr_SIZE BCMI_TSCE16_XGXS_TX_LN_DBG_RST_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_TX_LN_DBG_RST_CTLr_t TX_LN_DBG_RST_CTLr_t;
#define TX_LN_DBG_RST_CTLr_CLR BCMI_TSCE16_XGXS_TX_LN_DBG_RST_CTLr_CLR
#define TX_LN_DBG_RST_CTLr_SET BCMI_TSCE16_XGXS_TX_LN_DBG_RST_CTLr_SET
#define TX_LN_DBG_RST_CTLr_GET BCMI_TSCE16_XGXS_TX_LN_DBG_RST_CTLr_GET
#define TX_LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_GET BCMI_TSCE16_XGXS_TX_LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_GET
#define TX_LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_SET BCMI_TSCE16_XGXS_TX_LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_SET
#define TX_LN_DBG_RST_CTLr_LN_TX_S_RSTBf_GET BCMI_TSCE16_XGXS_TX_LN_DBG_RST_CTLr_LN_TX_S_RSTBf_GET
#define TX_LN_DBG_RST_CTLr_LN_TX_S_RSTBf_SET BCMI_TSCE16_XGXS_TX_LN_DBG_RST_CTLr_LN_TX_S_RSTBf_SET
#define READ_TX_LN_DBG_RST_CTLr BCMI_TSCE16_XGXS_READ_TX_LN_DBG_RST_CTLr
#define WRITE_TX_LN_DBG_RST_CTLr BCMI_TSCE16_XGXS_WRITE_TX_LN_DBG_RST_CTLr
#define MODIFY_TX_LN_DBG_RST_CTLr BCMI_TSCE16_XGXS_MODIFY_TX_LN_DBG_RST_CTLr
#define READLN_TX_LN_DBG_RST_CTLr BCMI_TSCE16_XGXS_READLN_TX_LN_DBG_RST_CTLr
#define WRITELN_TX_LN_DBG_RST_CTLr BCMI_TSCE16_XGXS_WRITELN_TX_LN_DBG_RST_CTLr
#define WRITEALL_TX_LN_DBG_RST_CTLr BCMI_TSCE16_XGXS_WRITEALL_TX_LN_DBG_RST_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_LN_DBG_RST_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_CLK_N_RST_DBG_CTL
 * BLOCKS:   TX_CKRST_CTRL
 * REGADDR:  0xd177
 * DESC:     CLOCK_N_RESET_DEBUG_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_TX_S_CLKGATE_FRC_ON TX Active High Lane clock gator enable. If 1'1b1 then tx lane clock will be gated off. It does not affect the tclk goingto RMIC block so tx lane based registers can still be readable but not writable.It is recommended for user to force pmd_tx_clk_vld to 1'b0 while tx_s_clkgate_frc_on is asserted to 1'b1by using pmd_tx_clk_vld_frc/frc_val registers.
 *     LN_TX_S_COMCLK_SEL Mux control for selection of comclk for TX Lane clocks.If asserted by writing to 1'b1 will select the comclk for the lane clocks.It is recommended for user to force pmd_tx_clk_vld to 1'b0 while tx_s_comclk_sel is asserted to 1'b1by using pmd_tx_clk_vld_frc/frc_val registers.
 *     LN_TX_S_COMCLK_FRC_ON Mux control for selection of comclk for TX Lane clocks by force.If asserted by writing to 1'b1 will select the comclk for the TX lane clocks. This is a debug bit and should be used only for recovery from a dead AFE lane clock. Use of this bit with an active AFE clock can cause clock glitches.It is recommended for user to force pmd_tx_clk_vld to 1'b0 while tx_s_comclk_frc_on is asserted to 1'b1by using pmd_tx_clk_vld_frc/frc_val registers.
 *     PMD_TX_CLK_VLD_FRC pmd_tx_clk_vld core output pin force.
 *     PMD_TX_CLK_VLD_FRC_VAL pmd_tx_clk_vld core output pin force value.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr (0x0000d177 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TX_CLK_N_RST_DBG_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr_s {
	uint32_t v[1];
	uint32_t tx_clk_n_rst_dbg_ctl[1];
	uint32_t _tx_clk_n_rst_dbg_ctl;
} BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr_t;

#define BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr_CLR(r) (r).tx_clk_n_rst_dbg_ctl[0] = 0
#define BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr_SET(r,d) (r).tx_clk_n_rst_dbg_ctl[0] = d
#define BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr_GET(r) (r).tx_clk_n_rst_dbg_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRC_VALf_GET(r) ((((r).tx_clk_n_rst_dbg_ctl[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRC_VALf_SET(r,f) (r).tx_clk_n_rst_dbg_ctl[0]=(((r).tx_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRCf_GET(r) ((((r).tx_clk_n_rst_dbg_ctl[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRCf_SET(r,f) (r).tx_clk_n_rst_dbg_ctl[0]=(((r).tx_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_FRC_ONf_GET(r) ((((r).tx_clk_n_rst_dbg_ctl[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_FRC_ONf_SET(r,f) (r).tx_clk_n_rst_dbg_ctl[0]=(((r).tx_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_SELf_GET(r) ((((r).tx_clk_n_rst_dbg_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_SELf_SET(r,f) (r).tx_clk_n_rst_dbg_ctl[0]=(((r).tx_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_CLKGATE_FRC_ONf_GET(r) (((r).tx_clk_n_rst_dbg_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_CLKGATE_FRC_ONf_SET(r,f) (r).tx_clk_n_rst_dbg_ctl[0]=(((r).tx_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_CLK_N_RST_DBG_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_CLK_N_RST_DBG_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr,(_r._tx_clk_n_rst_dbg_ctl))
#define BCMI_TSCE16_XGXS_WRITE_TX_CLK_N_RST_DBG_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr,(_r._tx_clk_n_rst_dbg_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_CLK_N_RST_DBG_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr,(_r._tx_clk_n_rst_dbg_ctl))
#define BCMI_TSCE16_XGXS_READLN_TX_CLK_N_RST_DBG_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_clk_n_rst_dbg_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_TX_CLK_N_RST_DBG_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_clk_n_rst_dbg_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_CLK_N_RST_DBG_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_clk_n_rst_dbg_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_CLK_N_RST_DBG_CTLr BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr
#define TX_CLK_N_RST_DBG_CTLr_SIZE BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr_t TX_CLK_N_RST_DBG_CTLr_t;
#define TX_CLK_N_RST_DBG_CTLr_CLR BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr_CLR
#define TX_CLK_N_RST_DBG_CTLr_SET BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr_SET
#define TX_CLK_N_RST_DBG_CTLr_GET BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr_GET
#define TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRC_VALf_GET BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRC_VALf_GET
#define TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRC_VALf_SET BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRC_VALf_SET
#define TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRCf_GET BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRCf_GET
#define TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRCf_SET BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRCf_SET
#define TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_FRC_ONf_GET BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_FRC_ONf_GET
#define TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_FRC_ONf_SET BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_FRC_ONf_SET
#define TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_SELf_GET BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_SELf_GET
#define TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_SELf_SET BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_SELf_SET
#define TX_CLK_N_RST_DBG_CTLr_LN_TX_S_CLKGATE_FRC_ONf_GET BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_CLKGATE_FRC_ONf_GET
#define TX_CLK_N_RST_DBG_CTLr_LN_TX_S_CLKGATE_FRC_ONf_SET BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_CLKGATE_FRC_ONf_SET
#define READ_TX_CLK_N_RST_DBG_CTLr BCMI_TSCE16_XGXS_READ_TX_CLK_N_RST_DBG_CTLr
#define WRITE_TX_CLK_N_RST_DBG_CTLr BCMI_TSCE16_XGXS_WRITE_TX_CLK_N_RST_DBG_CTLr
#define MODIFY_TX_CLK_N_RST_DBG_CTLr BCMI_TSCE16_XGXS_MODIFY_TX_CLK_N_RST_DBG_CTLr
#define READLN_TX_CLK_N_RST_DBG_CTLr BCMI_TSCE16_XGXS_READLN_TX_CLK_N_RST_DBG_CTLr
#define WRITELN_TX_CLK_N_RST_DBG_CTLr BCMI_TSCE16_XGXS_WRITELN_TX_CLK_N_RST_DBG_CTLr
#define WRITEALL_TX_CLK_N_RST_DBG_CTLr BCMI_TSCE16_XGXS_WRITEALL_TX_CLK_N_RST_DBG_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_CLK_N_RST_DBG_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_AFE_RST_PWRDN_OSR_MODE_PIN_STS
 * BLOCKS:   TX_CKRST_CTRL
 * REGADDR:  0xd17c
 * DESC:     AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS
 * RESETVAL: 0x6 (6)
 * ACCESS:   R/O
 * FIELDS:
 *     AFE_TX_PWRDN     Indicates the status of the afe_tx_pwrdn signal to the AFE after frc/frc_val mux.
 *     AFE_TX_RESET     Indicates the status of the afe_tx_reset signal to the AFE after frc/frc_val mux.
 *     AFE_TXCLK_RESET  Indicates the status of the afe_txclk_reset signal to the AFE after frc/frc_val mux.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr (0x0000d17c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SIZE 4

/*
 * This structure should be used to declare and program TX_AFE_RST_PWRDN_OSR_MODE_PIN_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_s {
	uint32_t v[1];
	uint32_t tx_afe_rst_pwrdn_osr_mode_pin_sts[1];
	uint32_t _tx_afe_rst_pwrdn_osr_mode_pin_sts;
} BCMI_TSCE16_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_t;

#define BCMI_TSCE16_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_CLR(r) (r).tx_afe_rst_pwrdn_osr_mode_pin_sts[0] = 0
#define BCMI_TSCE16_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SET(r,d) (r).tx_afe_rst_pwrdn_osr_mode_pin_sts[0] = d
#define BCMI_TSCE16_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_GET(r) (r).tx_afe_rst_pwrdn_osr_mode_pin_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_TXCLK_RESETf_GET(r) ((((r).tx_afe_rst_pwrdn_osr_mode_pin_sts[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_TXCLK_RESETf_SET(r,f) (r).tx_afe_rst_pwrdn_osr_mode_pin_sts[0]=(((r).tx_afe_rst_pwrdn_osr_mode_pin_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_TX_RESETf_GET(r) ((((r).tx_afe_rst_pwrdn_osr_mode_pin_sts[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_TX_RESETf_SET(r,f) (r).tx_afe_rst_pwrdn_osr_mode_pin_sts[0]=(((r).tx_afe_rst_pwrdn_osr_mode_pin_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_TX_PWRDNf_GET(r) (((r).tx_afe_rst_pwrdn_osr_mode_pin_sts[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_TX_PWRDNf_SET(r,f) (r).tx_afe_rst_pwrdn_osr_mode_pin_sts[0]=(((r).tx_afe_rst_pwrdn_osr_mode_pin_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_AFE_RST_PWRDN_OSR_MODE_PIN_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr,(_r._tx_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_TSCE16_XGXS_WRITE_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr,(_r._tx_afe_rst_pwrdn_osr_mode_pin_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr,(_r._tx_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_TSCE16_XGXS_READLN_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_TSCE16_XGXS_WRITELN_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_afe_rst_pwrdn_osr_mode_pin_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_TSCE16_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SIZE BCMI_TSCE16_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SIZE
typedef BCMI_TSCE16_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_t TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_t;
#define TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_CLR BCMI_TSCE16_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_CLR
#define TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SET BCMI_TSCE16_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SET
#define TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_GET BCMI_TSCE16_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_GET
#define TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_TXCLK_RESETf_GET BCMI_TSCE16_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_TXCLK_RESETf_GET
#define TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_TXCLK_RESETf_SET BCMI_TSCE16_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_TXCLK_RESETf_SET
#define TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_TX_RESETf_GET BCMI_TSCE16_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_TX_RESETf_GET
#define TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_TX_RESETf_SET BCMI_TSCE16_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_TX_RESETf_SET
#define TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_TX_PWRDNf_GET BCMI_TSCE16_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_TX_PWRDNf_GET
#define TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_TX_PWRDNf_SET BCMI_TSCE16_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_AFE_TX_PWRDNf_SET
#define READ_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_TSCE16_XGXS_READ_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define WRITE_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_TSCE16_XGXS_WRITE_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define MODIFY_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_TSCE16_XGXS_MODIFY_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define READLN_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_TSCE16_XGXS_READLN_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define WRITELN_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_TSCE16_XGXS_WRITELN_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define WRITEALL_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_TSCE16_XGXS_WRITEALL_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_AFE_RST_PWRDN_OSR_MODE_PIN_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TX_CLK_N_RST_MISC_CTL
 * BLOCKS:   TX_CKRST_CTRL
 * REGADDR:  0xd17d
 * DESC:     CLOCK_N_RESET_MISC_CONTROL
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PI_LOOP_FILTER_STABLE This register bit is ANDed with pmd_tx_clk_vld before frc/frc_val mux. This register will be controlled by the firmware when TX_PI is enabled.When TX_PI is enabled then this register will be written to 1'b0 while TX_PI is acquiring the lock with the source clock and will be written to 1'b1 by firmwareto indicate that clocks are locked. It indicates to chip level via pmd_tx_clk_vld to reset any datapath FIFOs and come out of reset when TX clock is stable.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TX_CLK_N_RST_MISC_CTLr (0x0000d17d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TX_CLK_N_RST_MISC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TX_CLK_N_RST_MISC_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_TX_CLK_N_RST_MISC_CTLr_s {
	uint32_t v[1];
	uint32_t tx_clk_n_rst_misc_ctl[1];
	uint32_t _tx_clk_n_rst_misc_ctl;
} BCMI_TSCE16_XGXS_TX_CLK_N_RST_MISC_CTLr_t;

#define BCMI_TSCE16_XGXS_TX_CLK_N_RST_MISC_CTLr_CLR(r) (r).tx_clk_n_rst_misc_ctl[0] = 0
#define BCMI_TSCE16_XGXS_TX_CLK_N_RST_MISC_CTLr_SET(r,d) (r).tx_clk_n_rst_misc_ctl[0] = d
#define BCMI_TSCE16_XGXS_TX_CLK_N_RST_MISC_CTLr_GET(r) (r).tx_clk_n_rst_misc_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TX_CLK_N_RST_MISC_CTLr_TX_PI_LOOP_FILTER_STABLEf_GET(r) (((r).tx_clk_n_rst_misc_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TX_CLK_N_RST_MISC_CTLr_TX_PI_LOOP_FILTER_STABLEf_SET(r,f) (r).tx_clk_n_rst_misc_ctl[0]=(((r).tx_clk_n_rst_misc_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_CLK_N_RST_MISC_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TX_CLK_N_RST_MISC_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_CLK_N_RST_MISC_CTLr,(_r._tx_clk_n_rst_misc_ctl))
#define BCMI_TSCE16_XGXS_WRITE_TX_CLK_N_RST_MISC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CLK_N_RST_MISC_CTLr,(_r._tx_clk_n_rst_misc_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TX_CLK_N_RST_MISC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CLK_N_RST_MISC_CTLr,(_r._tx_clk_n_rst_misc_ctl))
#define BCMI_TSCE16_XGXS_READLN_TX_CLK_N_RST_MISC_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TX_CLK_N_RST_MISC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_clk_n_rst_misc_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_TX_CLK_N_RST_MISC_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CLK_N_RST_MISC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_clk_n_rst_misc_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_TX_CLK_N_RST_MISC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TX_CLK_N_RST_MISC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_clk_n_rst_misc_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_CLK_N_RST_MISC_CTLr BCMI_TSCE16_XGXS_TX_CLK_N_RST_MISC_CTLr
#define TX_CLK_N_RST_MISC_CTLr_SIZE BCMI_TSCE16_XGXS_TX_CLK_N_RST_MISC_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_TX_CLK_N_RST_MISC_CTLr_t TX_CLK_N_RST_MISC_CTLr_t;
#define TX_CLK_N_RST_MISC_CTLr_CLR BCMI_TSCE16_XGXS_TX_CLK_N_RST_MISC_CTLr_CLR
#define TX_CLK_N_RST_MISC_CTLr_SET BCMI_TSCE16_XGXS_TX_CLK_N_RST_MISC_CTLr_SET
#define TX_CLK_N_RST_MISC_CTLr_GET BCMI_TSCE16_XGXS_TX_CLK_N_RST_MISC_CTLr_GET
#define TX_CLK_N_RST_MISC_CTLr_TX_PI_LOOP_FILTER_STABLEf_GET BCMI_TSCE16_XGXS_TX_CLK_N_RST_MISC_CTLr_TX_PI_LOOP_FILTER_STABLEf_GET
#define TX_CLK_N_RST_MISC_CTLr_TX_PI_LOOP_FILTER_STABLEf_SET BCMI_TSCE16_XGXS_TX_CLK_N_RST_MISC_CTLr_TX_PI_LOOP_FILTER_STABLEf_SET
#define READ_TX_CLK_N_RST_MISC_CTLr BCMI_TSCE16_XGXS_READ_TX_CLK_N_RST_MISC_CTLr
#define WRITE_TX_CLK_N_RST_MISC_CTLr BCMI_TSCE16_XGXS_WRITE_TX_CLK_N_RST_MISC_CTLr
#define MODIFY_TX_CLK_N_RST_MISC_CTLr BCMI_TSCE16_XGXS_MODIFY_TX_CLK_N_RST_MISC_CTLr
#define READLN_TX_CLK_N_RST_MISC_CTLr BCMI_TSCE16_XGXS_READLN_TX_CLK_N_RST_MISC_CTLr
#define WRITELN_TX_CLK_N_RST_MISC_CTLr BCMI_TSCE16_XGXS_WRITELN_TX_CLK_N_RST_MISC_CTLr
#define WRITEALL_TX_CLK_N_RST_MISC_CTLr BCMI_TSCE16_XGXS_WRITEALL_TX_CLK_N_RST_MISC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TX_CLK_N_RST_MISC_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RXCOM_OSR_MODE_CTL
 * BLOCKS:   RXCOM_CKRST_CTRL
 * REGADDR:  0xd180
 * DESC:     OSR_MODE_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_OSR_MODE_FRC_VAL oversample (OS) mode Decoding of this register is as follows.OSX1          4'd0OSX2          4'd1OSX3          4'd2OSX3P3        4'd3OSX4          4'd4OSX5          4'd5OSX7P5        4'd6OSX8          4'd7OSX8P25       4'd8OSX10         4'd9
 *     RX_OSR_MODE_FRC  oversample (OS) mode force. Setting this bit will allow the register value to be used for OS mode.Othersise, the pin input values are used for OS mode
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_CTLr (0x0000d180 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXCOM_OSR_MODE_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_CTLr_s {
	uint32_t v[1];
	uint32_t rxcom_osr_mode_ctl[1];
	uint32_t _rxcom_osr_mode_ctl;
} BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_CTLr_t;

#define BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_CTLr_CLR(r) (r).rxcom_osr_mode_ctl[0] = 0
#define BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_CTLr_SET(r,d) (r).rxcom_osr_mode_ctl[0] = d
#define BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_CTLr_GET(r) (r).rxcom_osr_mode_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRCf_GET(r) ((((r).rxcom_osr_mode_ctl[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRCf_SET(r,f) (r).rxcom_osr_mode_ctl[0]=(((r).rxcom_osr_mode_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRC_VALf_GET(r) (((r).rxcom_osr_mode_ctl[0]) & 0xf)
#define BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRC_VALf_SET(r,f) (r).rxcom_osr_mode_ctl[0]=(((r).rxcom_osr_mode_ctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access RXCOM_OSR_MODE_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_CTLr,(_r._rxcom_osr_mode_ctl))
#define BCMI_TSCE16_XGXS_WRITE_RXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_CTLr,(_r._rxcom_osr_mode_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_CTLr,(_r._rxcom_osr_mode_ctl))
#define BCMI_TSCE16_XGXS_READLN_RXCOM_OSR_MODE_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_osr_mode_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_RXCOM_OSR_MODE_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_osr_mode_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_RXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxcom_osr_mode_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXCOM_OSR_MODE_CTLr BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_CTLr
#define RXCOM_OSR_MODE_CTLr_SIZE BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_CTLr_t RXCOM_OSR_MODE_CTLr_t;
#define RXCOM_OSR_MODE_CTLr_CLR BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_CTLr_CLR
#define RXCOM_OSR_MODE_CTLr_SET BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_CTLr_SET
#define RXCOM_OSR_MODE_CTLr_GET BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_CTLr_GET
#define RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRCf_GET BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRCf_GET
#define RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRCf_SET BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRCf_SET
#define RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRC_VALf_GET BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRC_VALf_GET
#define RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRC_VALf_SET BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRC_VALf_SET
#define READ_RXCOM_OSR_MODE_CTLr BCMI_TSCE16_XGXS_READ_RXCOM_OSR_MODE_CTLr
#define WRITE_RXCOM_OSR_MODE_CTLr BCMI_TSCE16_XGXS_WRITE_RXCOM_OSR_MODE_CTLr
#define MODIFY_RXCOM_OSR_MODE_CTLr BCMI_TSCE16_XGXS_MODIFY_RXCOM_OSR_MODE_CTLr
#define READLN_RXCOM_OSR_MODE_CTLr BCMI_TSCE16_XGXS_READLN_RXCOM_OSR_MODE_CTLr
#define WRITELN_RXCOM_OSR_MODE_CTLr BCMI_TSCE16_XGXS_WRITELN_RXCOM_OSR_MODE_CTLr
#define WRITEALL_RXCOM_OSR_MODE_CTLr BCMI_TSCE16_XGXS_WRITEALL_RXCOM_OSR_MODE_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RXCOM_LN_CLK_RST_N_PWRDWN_CTL
 * BLOCKS:   RXCOM_CKRST_CTRL
 * REGADDR:  0xd181
 * DESC:     LANE_CLK_RESET_N_POWERDOWN_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LN_DP_S_RSTB  Active Low Lane Soft Reset for datapath. If asserted by writing to 1'b0 will reset the datapath for a lane.This soft reset is equivalent to the hard reset input pin pmd_ln_dp_h_rstb_i.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr (0x0000d181 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXCOM_LN_CLK_RST_N_PWRDWN_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_s {
	uint32_t v[1];
	uint32_t rxcom_ln_clk_rst_n_pwrdwn_ctl[1];
	uint32_t _rxcom_ln_clk_rst_n_pwrdwn_ctl;
} BCMI_TSCE16_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_t;

#define BCMI_TSCE16_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_CLR(r) (r).rxcom_ln_clk_rst_n_pwrdwn_ctl[0] = 0
#define BCMI_TSCE16_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SET(r,d) (r).rxcom_ln_clk_rst_n_pwrdwn_ctl[0] = d
#define BCMI_TSCE16_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_GET(r) (r).rxcom_ln_clk_rst_n_pwrdwn_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_RX_LN_DP_S_RSTBf_GET(r) (((r).rxcom_ln_clk_rst_n_pwrdwn_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_RX_LN_DP_S_RSTBf_SET(r,f) (r).rxcom_ln_clk_rst_n_pwrdwn_ctl[0]=(((r).rxcom_ln_clk_rst_n_pwrdwn_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXCOM_LN_CLK_RST_N_PWRDWN_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr,(_r._rxcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCE16_XGXS_WRITE_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr,(_r._rxcom_ln_clk_rst_n_pwrdwn_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr,(_r._rxcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCE16_XGXS_READLN_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxcom_ln_clk_rst_n_pwrdwn_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCE16_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SIZE BCMI_TSCE16_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_t RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_t;
#define RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_CLR BCMI_TSCE16_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_CLR
#define RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SET BCMI_TSCE16_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SET
#define RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_GET BCMI_TSCE16_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_GET
#define RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_RX_LN_DP_S_RSTBf_GET BCMI_TSCE16_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_RX_LN_DP_S_RSTBf_GET
#define RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_RX_LN_DP_S_RSTBf_SET BCMI_TSCE16_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_RX_LN_DP_S_RSTBf_SET
#define READ_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCE16_XGXS_READ_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITE_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCE16_XGXS_WRITE_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define MODIFY_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCE16_XGXS_MODIFY_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define READLN_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCE16_XGXS_READLN_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITELN_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCE16_XGXS_WRITELN_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITEALL_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCE16_XGXS_WRITEALL_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTL
 * BLOCKS:   RXCOM_CKRST_CTRL
 * REGADDR:  0xd183
 * DESC:     LANE_RESET_N_PWRDN_PIN_KILL_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMD_LN_RX_H_RSTB_PKILL 1'b1 will disable the pmd_ln_h_rstb input pin.
 *     PMD_LN_RX_DP_H_RSTB_PKILL 1'b1 will disable the pmd_ln_dp_h_rstb input pin.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr (0x0000d183 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_s {
	uint32_t v[1];
	uint32_t rxcom_ln_rst_n_pwrdn_pin_kill_ctl[1];
	uint32_t _rxcom_ln_rst_n_pwrdn_pin_kill_ctl;
} BCMI_TSCE16_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_t;

#define BCMI_TSCE16_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR(r) (r).rxcom_ln_rst_n_pwrdn_pin_kill_ctl[0] = 0
#define BCMI_TSCE16_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET(r,d) (r).rxcom_ln_rst_n_pwrdn_pin_kill_ctl[0] = d
#define BCMI_TSCE16_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET(r) (r).rxcom_ln_rst_n_pwrdn_pin_kill_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_DP_H_RSTB_PKILLf_GET(r) ((((r).rxcom_ln_rst_n_pwrdn_pin_kill_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_DP_H_RSTB_PKILLf_SET(r,f) (r).rxcom_ln_rst_n_pwrdn_pin_kill_ctl[0]=(((r).rxcom_ln_rst_n_pwrdn_pin_kill_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_RSTB_PKILLf_GET(r) (((r).rxcom_ln_rst_n_pwrdn_pin_kill_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_RSTB_PKILLf_SET(r,f) (r).rxcom_ln_rst_n_pwrdn_pin_kill_ctl[0]=(((r).rxcom_ln_rst_n_pwrdn_pin_kill_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._rxcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCE16_XGXS_WRITE_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._rxcom_ln_rst_n_pwrdn_pin_kill_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._rxcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCE16_XGXS_READLN_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxcom_ln_rst_n_pwrdn_pin_kill_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCE16_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE BCMI_TSCE16_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_t RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_t;
#define RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR BCMI_TSCE16_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR
#define RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET BCMI_TSCE16_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET
#define RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET BCMI_TSCE16_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET
#define RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_DP_H_RSTB_PKILLf_GET BCMI_TSCE16_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_DP_H_RSTB_PKILLf_GET
#define RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_DP_H_RSTB_PKILLf_SET BCMI_TSCE16_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_DP_H_RSTB_PKILLf_SET
#define RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_RSTB_PKILLf_GET BCMI_TSCE16_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_RSTB_PKILLf_GET
#define RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_RSTB_PKILLf_SET BCMI_TSCE16_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_RSTB_PKILLf_SET
#define READ_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCE16_XGXS_READ_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITE_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCE16_XGXS_WRITE_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define MODIFY_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCE16_XGXS_MODIFY_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define READLN_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCE16_XGXS_READLN_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITELN_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCE16_XGXS_WRITELN_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITEALL_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCE16_XGXS_WRITEALL_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RXCOM_UC_ACK_LN_CTL
 * BLOCKS:   RXCOM_CKRST_CTRL
 * REGADDR:  0xd185
 * DESC:     UC_ACK_LANE_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_UC_ACK_LANE_CFG_DONE uC will write this to 1 to indicate it's configuration of the lane is complete. Writing to 1'b1 willshould release internal hold on lane_dp_reset, only if lane_dp_reset_state is 3'b001.
 *     RX_UC_ACK_LANE_DP_RESET uC will write this to 1 to acknowledge a reset event after seeing "lane_dp_reset_coccured".
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RXCOM_UC_ACK_LN_CTLr (0x0000d185 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RXCOM_UC_ACK_LN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXCOM_UC_ACK_LN_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_RXCOM_UC_ACK_LN_CTLr_s {
	uint32_t v[1];
	uint32_t rxcom_uc_ack_ln_ctl[1];
	uint32_t _rxcom_uc_ack_ln_ctl;
} BCMI_TSCE16_XGXS_RXCOM_UC_ACK_LN_CTLr_t;

#define BCMI_TSCE16_XGXS_RXCOM_UC_ACK_LN_CTLr_CLR(r) (r).rxcom_uc_ack_ln_ctl[0] = 0
#define BCMI_TSCE16_XGXS_RXCOM_UC_ACK_LN_CTLr_SET(r,d) (r).rxcom_uc_ack_ln_ctl[0] = d
#define BCMI_TSCE16_XGXS_RXCOM_UC_ACK_LN_CTLr_GET(r) (r).rxcom_uc_ack_ln_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_DP_RESETf_GET(r) ((((r).rxcom_uc_ack_ln_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_DP_RESETf_SET(r,f) (r).rxcom_uc_ack_ln_ctl[0]=(((r).rxcom_uc_ack_ln_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_CFG_DONEf_GET(r) (((r).rxcom_uc_ack_ln_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_CFG_DONEf_SET(r,f) (r).rxcom_uc_ack_ln_ctl[0]=(((r).rxcom_uc_ack_ln_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXCOM_UC_ACK_LN_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXCOM_UC_ACK_LN_CTLr,(_r._rxcom_uc_ack_ln_ctl))
#define BCMI_TSCE16_XGXS_WRITE_RXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_UC_ACK_LN_CTLr,(_r._rxcom_uc_ack_ln_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_UC_ACK_LN_CTLr,(_r._rxcom_uc_ack_ln_ctl))
#define BCMI_TSCE16_XGXS_READLN_RXCOM_UC_ACK_LN_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXCOM_UC_ACK_LN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_uc_ack_ln_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_RXCOM_UC_ACK_LN_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_UC_ACK_LN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_uc_ack_ln_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_RXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_UC_ACK_LN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxcom_uc_ack_ln_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXCOM_UC_ACK_LN_CTLr BCMI_TSCE16_XGXS_RXCOM_UC_ACK_LN_CTLr
#define RXCOM_UC_ACK_LN_CTLr_SIZE BCMI_TSCE16_XGXS_RXCOM_UC_ACK_LN_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_RXCOM_UC_ACK_LN_CTLr_t RXCOM_UC_ACK_LN_CTLr_t;
#define RXCOM_UC_ACK_LN_CTLr_CLR BCMI_TSCE16_XGXS_RXCOM_UC_ACK_LN_CTLr_CLR
#define RXCOM_UC_ACK_LN_CTLr_SET BCMI_TSCE16_XGXS_RXCOM_UC_ACK_LN_CTLr_SET
#define RXCOM_UC_ACK_LN_CTLr_GET BCMI_TSCE16_XGXS_RXCOM_UC_ACK_LN_CTLr_GET
#define RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_DP_RESETf_GET BCMI_TSCE16_XGXS_RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_DP_RESETf_GET
#define RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_DP_RESETf_SET BCMI_TSCE16_XGXS_RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_DP_RESETf_SET
#define RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_CFG_DONEf_GET BCMI_TSCE16_XGXS_RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_CFG_DONEf_GET
#define RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_CFG_DONEf_SET BCMI_TSCE16_XGXS_RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_CFG_DONEf_SET
#define READ_RXCOM_UC_ACK_LN_CTLr BCMI_TSCE16_XGXS_READ_RXCOM_UC_ACK_LN_CTLr
#define WRITE_RXCOM_UC_ACK_LN_CTLr BCMI_TSCE16_XGXS_WRITE_RXCOM_UC_ACK_LN_CTLr
#define MODIFY_RXCOM_UC_ACK_LN_CTLr BCMI_TSCE16_XGXS_MODIFY_RXCOM_UC_ACK_LN_CTLr
#define READLN_RXCOM_UC_ACK_LN_CTLr BCMI_TSCE16_XGXS_READLN_RXCOM_UC_ACK_LN_CTLr
#define WRITELN_RXCOM_UC_ACK_LN_CTLr BCMI_TSCE16_XGXS_WRITELN_RXCOM_UC_ACK_LN_CTLr
#define WRITEALL_RXCOM_UC_ACK_LN_CTLr BCMI_TSCE16_XGXS_WRITEALL_RXCOM_UC_ACK_LN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RXCOM_UC_ACK_LN_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RXCOM_LN_RST_OCC_CTL
 * BLOCKS:   RXCOM_CKRST_CTRL
 * REGADDR:  0xd186
 * DESC:     LANE_REG_RESET_OCCURRED_CONTROL
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LANE_REG_RESET_OCCURRED Set to 1'b1 upon lane level register reset and remains so until cleared by register write from uC.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RXCOM_LN_RST_OCC_CTLr (0x0000d186 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RXCOM_LN_RST_OCC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXCOM_LN_RST_OCC_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_RXCOM_LN_RST_OCC_CTLr_s {
	uint32_t v[1];
	uint32_t rxcom_ln_rst_occ_ctl[1];
	uint32_t _rxcom_ln_rst_occ_ctl;
} BCMI_TSCE16_XGXS_RXCOM_LN_RST_OCC_CTLr_t;

#define BCMI_TSCE16_XGXS_RXCOM_LN_RST_OCC_CTLr_CLR(r) (r).rxcom_ln_rst_occ_ctl[0] = 0
#define BCMI_TSCE16_XGXS_RXCOM_LN_RST_OCC_CTLr_SET(r,d) (r).rxcom_ln_rst_occ_ctl[0] = d
#define BCMI_TSCE16_XGXS_RXCOM_LN_RST_OCC_CTLr_GET(r) (r).rxcom_ln_rst_occ_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RXCOM_LN_RST_OCC_CTLr_RX_LANE_REG_RESET_OCCURREDf_GET(r) (((r).rxcom_ln_rst_occ_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_RXCOM_LN_RST_OCC_CTLr_RX_LANE_REG_RESET_OCCURREDf_SET(r,f) (r).rxcom_ln_rst_occ_ctl[0]=(((r).rxcom_ln_rst_occ_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXCOM_LN_RST_OCC_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXCOM_LN_RST_OCC_CTLr,(_r._rxcom_ln_rst_occ_ctl))
#define BCMI_TSCE16_XGXS_WRITE_RXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_LN_RST_OCC_CTLr,(_r._rxcom_ln_rst_occ_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_LN_RST_OCC_CTLr,(_r._rxcom_ln_rst_occ_ctl))
#define BCMI_TSCE16_XGXS_READLN_RXCOM_LN_RST_OCC_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXCOM_LN_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_ln_rst_occ_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_RXCOM_LN_RST_OCC_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_LN_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_ln_rst_occ_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_RXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_LN_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxcom_ln_rst_occ_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXCOM_LN_RST_OCC_CTLr BCMI_TSCE16_XGXS_RXCOM_LN_RST_OCC_CTLr
#define RXCOM_LN_RST_OCC_CTLr_SIZE BCMI_TSCE16_XGXS_RXCOM_LN_RST_OCC_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_RXCOM_LN_RST_OCC_CTLr_t RXCOM_LN_RST_OCC_CTLr_t;
#define RXCOM_LN_RST_OCC_CTLr_CLR BCMI_TSCE16_XGXS_RXCOM_LN_RST_OCC_CTLr_CLR
#define RXCOM_LN_RST_OCC_CTLr_SET BCMI_TSCE16_XGXS_RXCOM_LN_RST_OCC_CTLr_SET
#define RXCOM_LN_RST_OCC_CTLr_GET BCMI_TSCE16_XGXS_RXCOM_LN_RST_OCC_CTLr_GET
#define RXCOM_LN_RST_OCC_CTLr_RX_LANE_REG_RESET_OCCURREDf_GET BCMI_TSCE16_XGXS_RXCOM_LN_RST_OCC_CTLr_RX_LANE_REG_RESET_OCCURREDf_GET
#define RXCOM_LN_RST_OCC_CTLr_RX_LANE_REG_RESET_OCCURREDf_SET BCMI_TSCE16_XGXS_RXCOM_LN_RST_OCC_CTLr_RX_LANE_REG_RESET_OCCURREDf_SET
#define READ_RXCOM_LN_RST_OCC_CTLr BCMI_TSCE16_XGXS_READ_RXCOM_LN_RST_OCC_CTLr
#define WRITE_RXCOM_LN_RST_OCC_CTLr BCMI_TSCE16_XGXS_WRITE_RXCOM_LN_RST_OCC_CTLr
#define MODIFY_RXCOM_LN_RST_OCC_CTLr BCMI_TSCE16_XGXS_MODIFY_RXCOM_LN_RST_OCC_CTLr
#define READLN_RXCOM_LN_RST_OCC_CTLr BCMI_TSCE16_XGXS_READLN_RXCOM_LN_RST_OCC_CTLr
#define WRITELN_RXCOM_LN_RST_OCC_CTLr BCMI_TSCE16_XGXS_WRITELN_RXCOM_LN_RST_OCC_CTLr
#define WRITEALL_RXCOM_LN_RST_OCC_CTLr BCMI_TSCE16_XGXS_WRITEALL_RXCOM_LN_RST_OCC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RXCOM_LN_RST_OCC_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RXCOM_LN_DP_RST_ST_STS
 * BLOCKS:   RXCOM_CKRST_CTRL
 * REGADDR:  0xd189
 * DESC:     LANE_DP_RESET_STATE_STATUS
 * RESETVAL: 0x7 (7)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_LANE_DP_RESET_STATE Bit 2: lane_dp_reset_active   : Set to 1'b1 whenenver lane_dp_reset is currently requested through any register or pin controls.Bit 1: lane_dp_reset_occurred : Set to 1'b1 whenenver lane_dp_reset is currently requested through any register or pin controls and is latched high.Bit 0: lane_dp_reset_held     : Set to 1'b1 whenenver lane_dp_reset is internally held. Cleared to 1'b0, only if lane_dp_reset_state==001 and uc_ack_lane_cfg_done == 1.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RXCOM_LN_DP_RST_ST_STSr (0x0000d189 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RXCOM_LN_DP_RST_ST_STSr_SIZE 4

/*
 * This structure should be used to declare and program RXCOM_LN_DP_RST_ST_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_RXCOM_LN_DP_RST_ST_STSr_s {
	uint32_t v[1];
	uint32_t rxcom_ln_dp_rst_st_sts[1];
	uint32_t _rxcom_ln_dp_rst_st_sts;
} BCMI_TSCE16_XGXS_RXCOM_LN_DP_RST_ST_STSr_t;

#define BCMI_TSCE16_XGXS_RXCOM_LN_DP_RST_ST_STSr_CLR(r) (r).rxcom_ln_dp_rst_st_sts[0] = 0
#define BCMI_TSCE16_XGXS_RXCOM_LN_DP_RST_ST_STSr_SET(r,d) (r).rxcom_ln_dp_rst_st_sts[0] = d
#define BCMI_TSCE16_XGXS_RXCOM_LN_DP_RST_ST_STSr_GET(r) (r).rxcom_ln_dp_rst_st_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RXCOM_LN_DP_RST_ST_STSr_RX_LANE_DP_RESET_STATEf_GET(r) (((r).rxcom_ln_dp_rst_st_sts[0]) & 0x7)
#define BCMI_TSCE16_XGXS_RXCOM_LN_DP_RST_ST_STSr_RX_LANE_DP_RESET_STATEf_SET(r,f) (r).rxcom_ln_dp_rst_st_sts[0]=(((r).rxcom_ln_dp_rst_st_sts[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access RXCOM_LN_DP_RST_ST_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXCOM_LN_DP_RST_ST_STSr,(_r._rxcom_ln_dp_rst_st_sts))
#define BCMI_TSCE16_XGXS_WRITE_RXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_LN_DP_RST_ST_STSr,(_r._rxcom_ln_dp_rst_st_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_LN_DP_RST_ST_STSr,(_r._rxcom_ln_dp_rst_st_sts))
#define BCMI_TSCE16_XGXS_READLN_RXCOM_LN_DP_RST_ST_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXCOM_LN_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_ln_dp_rst_st_sts))
#define BCMI_TSCE16_XGXS_WRITELN_RXCOM_LN_DP_RST_ST_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_LN_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_ln_dp_rst_st_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_RXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_LN_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxcom_ln_dp_rst_st_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXCOM_LN_DP_RST_ST_STSr BCMI_TSCE16_XGXS_RXCOM_LN_DP_RST_ST_STSr
#define RXCOM_LN_DP_RST_ST_STSr_SIZE BCMI_TSCE16_XGXS_RXCOM_LN_DP_RST_ST_STSr_SIZE
typedef BCMI_TSCE16_XGXS_RXCOM_LN_DP_RST_ST_STSr_t RXCOM_LN_DP_RST_ST_STSr_t;
#define RXCOM_LN_DP_RST_ST_STSr_CLR BCMI_TSCE16_XGXS_RXCOM_LN_DP_RST_ST_STSr_CLR
#define RXCOM_LN_DP_RST_ST_STSr_SET BCMI_TSCE16_XGXS_RXCOM_LN_DP_RST_ST_STSr_SET
#define RXCOM_LN_DP_RST_ST_STSr_GET BCMI_TSCE16_XGXS_RXCOM_LN_DP_RST_ST_STSr_GET
#define RXCOM_LN_DP_RST_ST_STSr_RX_LANE_DP_RESET_STATEf_GET BCMI_TSCE16_XGXS_RXCOM_LN_DP_RST_ST_STSr_RX_LANE_DP_RESET_STATEf_GET
#define RXCOM_LN_DP_RST_ST_STSr_RX_LANE_DP_RESET_STATEf_SET BCMI_TSCE16_XGXS_RXCOM_LN_DP_RST_ST_STSr_RX_LANE_DP_RESET_STATEf_SET
#define READ_RXCOM_LN_DP_RST_ST_STSr BCMI_TSCE16_XGXS_READ_RXCOM_LN_DP_RST_ST_STSr
#define WRITE_RXCOM_LN_DP_RST_ST_STSr BCMI_TSCE16_XGXS_WRITE_RXCOM_LN_DP_RST_ST_STSr
#define MODIFY_RXCOM_LN_DP_RST_ST_STSr BCMI_TSCE16_XGXS_MODIFY_RXCOM_LN_DP_RST_ST_STSr
#define READLN_RXCOM_LN_DP_RST_ST_STSr BCMI_TSCE16_XGXS_READLN_RXCOM_LN_DP_RST_ST_STSr
#define WRITELN_RXCOM_LN_DP_RST_ST_STSr BCMI_TSCE16_XGXS_WRITELN_RXCOM_LN_DP_RST_ST_STSr
#define WRITEALL_RXCOM_LN_DP_RST_ST_STSr BCMI_TSCE16_XGXS_WRITEALL_RXCOM_LN_DP_RST_ST_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RXCOM_LN_DP_RST_ST_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RXCOM_MCST_MASK_CTL
 * BLOCKS:   RXCOM_CKRST_CTRL
 * REGADDR:  0xd18a
 * DESC:     MULTICAST_MASK_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_MULTICAST_MASK_CONTROL This masks the lane from a broadcast or multicast write operation.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RXCOM_MCST_MASK_CTLr (0x0000d18a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RXCOM_MCST_MASK_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXCOM_MCST_MASK_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_RXCOM_MCST_MASK_CTLr_s {
	uint32_t v[1];
	uint32_t rxcom_mcst_mask_ctl[1];
	uint32_t _rxcom_mcst_mask_ctl;
} BCMI_TSCE16_XGXS_RXCOM_MCST_MASK_CTLr_t;

#define BCMI_TSCE16_XGXS_RXCOM_MCST_MASK_CTLr_CLR(r) (r).rxcom_mcst_mask_ctl[0] = 0
#define BCMI_TSCE16_XGXS_RXCOM_MCST_MASK_CTLr_SET(r,d) (r).rxcom_mcst_mask_ctl[0] = d
#define BCMI_TSCE16_XGXS_RXCOM_MCST_MASK_CTLr_GET(r) (r).rxcom_mcst_mask_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RXCOM_MCST_MASK_CTLr_RX_MULTICAST_MASK_CONTROLf_GET(r) (((r).rxcom_mcst_mask_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_RXCOM_MCST_MASK_CTLr_RX_MULTICAST_MASK_CONTROLf_SET(r,f) (r).rxcom_mcst_mask_ctl[0]=(((r).rxcom_mcst_mask_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXCOM_MCST_MASK_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXCOM_MCST_MASK_CTLr,(_r._rxcom_mcst_mask_ctl))
#define BCMI_TSCE16_XGXS_WRITE_RXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_MCST_MASK_CTLr,(_r._rxcom_mcst_mask_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_MCST_MASK_CTLr,(_r._rxcom_mcst_mask_ctl))
#define BCMI_TSCE16_XGXS_READLN_RXCOM_MCST_MASK_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXCOM_MCST_MASK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_mcst_mask_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_RXCOM_MCST_MASK_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_MCST_MASK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_mcst_mask_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_RXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_MCST_MASK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxcom_mcst_mask_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXCOM_MCST_MASK_CTLr BCMI_TSCE16_XGXS_RXCOM_MCST_MASK_CTLr
#define RXCOM_MCST_MASK_CTLr_SIZE BCMI_TSCE16_XGXS_RXCOM_MCST_MASK_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_RXCOM_MCST_MASK_CTLr_t RXCOM_MCST_MASK_CTLr_t;
#define RXCOM_MCST_MASK_CTLr_CLR BCMI_TSCE16_XGXS_RXCOM_MCST_MASK_CTLr_CLR
#define RXCOM_MCST_MASK_CTLr_SET BCMI_TSCE16_XGXS_RXCOM_MCST_MASK_CTLr_SET
#define RXCOM_MCST_MASK_CTLr_GET BCMI_TSCE16_XGXS_RXCOM_MCST_MASK_CTLr_GET
#define RXCOM_MCST_MASK_CTLr_RX_MULTICAST_MASK_CONTROLf_GET BCMI_TSCE16_XGXS_RXCOM_MCST_MASK_CTLr_RX_MULTICAST_MASK_CONTROLf_GET
#define RXCOM_MCST_MASK_CTLr_RX_MULTICAST_MASK_CONTROLf_SET BCMI_TSCE16_XGXS_RXCOM_MCST_MASK_CTLr_RX_MULTICAST_MASK_CONTROLf_SET
#define READ_RXCOM_MCST_MASK_CTLr BCMI_TSCE16_XGXS_READ_RXCOM_MCST_MASK_CTLr
#define WRITE_RXCOM_MCST_MASK_CTLr BCMI_TSCE16_XGXS_WRITE_RXCOM_MCST_MASK_CTLr
#define MODIFY_RXCOM_MCST_MASK_CTLr BCMI_TSCE16_XGXS_MODIFY_RXCOM_MCST_MASK_CTLr
#define READLN_RXCOM_MCST_MASK_CTLr BCMI_TSCE16_XGXS_READLN_RXCOM_MCST_MASK_CTLr
#define WRITELN_RXCOM_MCST_MASK_CTLr BCMI_TSCE16_XGXS_WRITELN_RXCOM_MCST_MASK_CTLr
#define WRITEALL_RXCOM_MCST_MASK_CTLr BCMI_TSCE16_XGXS_WRITEALL_RXCOM_MCST_MASK_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RXCOM_MCST_MASK_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RXCOM_OSR_MODE_STS_MC_MASK
 * BLOCKS:   RXCOM_CKRST_CTRL
 * REGADDR:  0xd18b
 * DESC:     OSR_MODE_STATUS_MC_MASK
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_OSR_MODE      OSR Mode status after the mux.OSR Mode status after the osr_mode_frc/frc_val mux.Decoding of this register is as follows.OSX1          4'd0OSX2          4'd1OSX3          4'd2OSX3P3        4'd3OSX4          4'd4OSX5          4'd5OSX7P5        4'd6OSX8          4'd7OSX8P25       4'd8OSX10         4'd9
 *     RX_MULTICAST_MASK_CONTROL_STATUS Status of multicast mask control for masking lane from multicast write operation.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr (0x0000d18b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_SIZE 4

/*
 * This structure should be used to declare and program RXCOM_OSR_MODE_STS_MC_MASK.
 *
 */
typedef union BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_s {
	uint32_t v[1];
	uint32_t rxcom_osr_mode_sts_mc_mask[1];
	uint32_t _rxcom_osr_mode_sts_mc_mask;
} BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_t;

#define BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_CLR(r) (r).rxcom_osr_mode_sts_mc_mask[0] = 0
#define BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_SET(r,d) (r).rxcom_osr_mode_sts_mc_mask[0] = d
#define BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_GET(r) (r).rxcom_osr_mode_sts_mc_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_RX_MULTICAST_MASK_CONTROL_STATUSf_GET(r) ((((r).rxcom_osr_mode_sts_mc_mask[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_RX_MULTICAST_MASK_CONTROL_STATUSf_SET(r,f) (r).rxcom_osr_mode_sts_mc_mask[0]=(((r).rxcom_osr_mode_sts_mc_mask[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_RX_OSR_MODEf_GET(r) (((r).rxcom_osr_mode_sts_mc_mask[0]) & 0xf)
#define BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_RX_OSR_MODEf_SET(r,f) (r).rxcom_osr_mode_sts_mc_mask[0]=(((r).rxcom_osr_mode_sts_mc_mask[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access RXCOM_OSR_MODE_STS_MC_MASK.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr,(_r._rxcom_osr_mode_sts_mc_mask))
#define BCMI_TSCE16_XGXS_WRITE_RXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr,(_r._rxcom_osr_mode_sts_mc_mask)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr,(_r._rxcom_osr_mode_sts_mc_mask))
#define BCMI_TSCE16_XGXS_READLN_RXCOM_OSR_MODE_STS_MC_MASKr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_osr_mode_sts_mc_mask))
#define BCMI_TSCE16_XGXS_WRITELN_RXCOM_OSR_MODE_STS_MC_MASKr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_osr_mode_sts_mc_mask))
#define BCMI_TSCE16_XGXS_WRITEALL_RXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxcom_osr_mode_sts_mc_mask))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr
#define RXCOM_OSR_MODE_STS_MC_MASKr_SIZE BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_SIZE
typedef BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_t RXCOM_OSR_MODE_STS_MC_MASKr_t;
#define RXCOM_OSR_MODE_STS_MC_MASKr_CLR BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_CLR
#define RXCOM_OSR_MODE_STS_MC_MASKr_SET BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_SET
#define RXCOM_OSR_MODE_STS_MC_MASKr_GET BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_GET
#define RXCOM_OSR_MODE_STS_MC_MASKr_RX_MULTICAST_MASK_CONTROL_STATUSf_GET BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_RX_MULTICAST_MASK_CONTROL_STATUSf_GET
#define RXCOM_OSR_MODE_STS_MC_MASKr_RX_MULTICAST_MASK_CONTROL_STATUSf_SET BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_RX_MULTICAST_MASK_CONTROL_STATUSf_SET
#define RXCOM_OSR_MODE_STS_MC_MASKr_RX_OSR_MODEf_GET BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_RX_OSR_MODEf_GET
#define RXCOM_OSR_MODE_STS_MC_MASKr_RX_OSR_MODEf_SET BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_RX_OSR_MODEf_SET
#define READ_RXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCE16_XGXS_READ_RXCOM_OSR_MODE_STS_MC_MASKr
#define WRITE_RXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCE16_XGXS_WRITE_RXCOM_OSR_MODE_STS_MC_MASKr
#define MODIFY_RXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCE16_XGXS_MODIFY_RXCOM_OSR_MODE_STS_MC_MASKr
#define READLN_RXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCE16_XGXS_READLN_RXCOM_OSR_MODE_STS_MC_MASKr
#define WRITELN_RXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCE16_XGXS_WRITELN_RXCOM_OSR_MODE_STS_MC_MASKr
#define WRITEALL_RXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCE16_XGXS_WRITEALL_RXCOM_OSR_MODE_STS_MC_MASKr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STS
 * BLOCKS:   RXCOM_CKRST_CTRL
 * REGADDR:  0xd18c
 * DESC:     AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_OSR_MODE_PIN  Indicates the status of the pmd_osr_mode input pin.Decoding of pmd_osr_mode[3:0] pin and osr_mode registers are as follows.OSX1          4'd0OSX2          4'd1OSX3          4'd2OSX3P3        4'd3OSX4          4'd4OSX5          4'd5OSX7P5        4'd6OSX8          4'd7OSX8P25       4'd8OSX10         4'd9
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr (0x0000d18c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SIZE 4

/*
 * This structure should be used to declare and program RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_s {
	uint32_t v[1];
	uint32_t rxcom_afe_rst_pwrdn_osr_mode_pin_sts[1];
	uint32_t _rxcom_afe_rst_pwrdn_osr_mode_pin_sts;
} BCMI_TSCE16_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_t;

#define BCMI_TSCE16_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_CLR(r) (r).rxcom_afe_rst_pwrdn_osr_mode_pin_sts[0] = 0
#define BCMI_TSCE16_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SET(r,d) (r).rxcom_afe_rst_pwrdn_osr_mode_pin_sts[0] = d
#define BCMI_TSCE16_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_GET(r) (r).rxcom_afe_rst_pwrdn_osr_mode_pin_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_RX_OSR_MODE_PINf_GET(r) (((r).rxcom_afe_rst_pwrdn_osr_mode_pin_sts[0]) & 0xf)
#define BCMI_TSCE16_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_RX_OSR_MODE_PINf_SET(r,f) (r).rxcom_afe_rst_pwrdn_osr_mode_pin_sts[0]=(((r).rxcom_afe_rst_pwrdn_osr_mode_pin_sts[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr,(_r._rxcom_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_TSCE16_XGXS_WRITE_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr,(_r._rxcom_afe_rst_pwrdn_osr_mode_pin_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr,(_r._rxcom_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_TSCE16_XGXS_READLN_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_TSCE16_XGXS_WRITELN_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxcom_afe_rst_pwrdn_osr_mode_pin_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_TSCE16_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SIZE BCMI_TSCE16_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SIZE
typedef BCMI_TSCE16_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_t RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_t;
#define RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_CLR BCMI_TSCE16_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_CLR
#define RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SET BCMI_TSCE16_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SET
#define RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_GET BCMI_TSCE16_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_GET
#define RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_RX_OSR_MODE_PINf_GET BCMI_TSCE16_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_RX_OSR_MODE_PINf_GET
#define RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_RX_OSR_MODE_PINf_SET BCMI_TSCE16_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_RX_OSR_MODE_PINf_SET
#define READ_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_TSCE16_XGXS_READ_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define WRITE_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_TSCE16_XGXS_WRITE_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define MODIFY_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_TSCE16_XGXS_MODIFY_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define READLN_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_TSCE16_XGXS_READLN_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define WRITELN_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_TSCE16_XGXS_WRITELN_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define WRITEALL_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_TSCE16_XGXS_WRITEALL_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  RXCOM_LN_S_RSTB_CTL
 * BLOCKS:   RXCOM_CKRST_CTRL
 * REGADDR:  0xd18e
 * DESC:     LN_S_RSTB_CONTROL
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LN_S_RSTB     Active Low Lane Soft Reset. If asserted by writing to 1'b0 will reset the registers and datapath for a lane.This soft reset is equivalent to the hard reset input pin pmd_ln_h_rstb_i.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_RXCOM_LN_S_RSTB_CTLr (0x0000d18e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_RXCOM_LN_S_RSTB_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXCOM_LN_S_RSTB_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_RXCOM_LN_S_RSTB_CTLr_s {
	uint32_t v[1];
	uint32_t rxcom_ln_s_rstb_ctl[1];
	uint32_t _rxcom_ln_s_rstb_ctl;
} BCMI_TSCE16_XGXS_RXCOM_LN_S_RSTB_CTLr_t;

#define BCMI_TSCE16_XGXS_RXCOM_LN_S_RSTB_CTLr_CLR(r) (r).rxcom_ln_s_rstb_ctl[0] = 0
#define BCMI_TSCE16_XGXS_RXCOM_LN_S_RSTB_CTLr_SET(r,d) (r).rxcom_ln_s_rstb_ctl[0] = d
#define BCMI_TSCE16_XGXS_RXCOM_LN_S_RSTB_CTLr_GET(r) (r).rxcom_ln_s_rstb_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_RXCOM_LN_S_RSTB_CTLr_RX_LN_S_RSTBf_GET(r) (((r).rxcom_ln_s_rstb_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_RXCOM_LN_S_RSTB_CTLr_RX_LN_S_RSTBf_SET(r,f) (r).rxcom_ln_s_rstb_ctl[0]=(((r).rxcom_ln_s_rstb_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXCOM_LN_S_RSTB_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_RXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXCOM_LN_S_RSTB_CTLr,(_r._rxcom_ln_s_rstb_ctl))
#define BCMI_TSCE16_XGXS_WRITE_RXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_LN_S_RSTB_CTLr,(_r._rxcom_ln_s_rstb_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_RXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_LN_S_RSTB_CTLr,(_r._rxcom_ln_s_rstb_ctl))
#define BCMI_TSCE16_XGXS_READLN_RXCOM_LN_S_RSTB_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_RXCOM_LN_S_RSTB_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_ln_s_rstb_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_RXCOM_LN_S_RSTB_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_LN_S_RSTB_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_ln_s_rstb_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_RXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_RXCOM_LN_S_RSTB_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxcom_ln_s_rstb_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXCOM_LN_S_RSTB_CTLr BCMI_TSCE16_XGXS_RXCOM_LN_S_RSTB_CTLr
#define RXCOM_LN_S_RSTB_CTLr_SIZE BCMI_TSCE16_XGXS_RXCOM_LN_S_RSTB_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_RXCOM_LN_S_RSTB_CTLr_t RXCOM_LN_S_RSTB_CTLr_t;
#define RXCOM_LN_S_RSTB_CTLr_CLR BCMI_TSCE16_XGXS_RXCOM_LN_S_RSTB_CTLr_CLR
#define RXCOM_LN_S_RSTB_CTLr_SET BCMI_TSCE16_XGXS_RXCOM_LN_S_RSTB_CTLr_SET
#define RXCOM_LN_S_RSTB_CTLr_GET BCMI_TSCE16_XGXS_RXCOM_LN_S_RSTB_CTLr_GET
#define RXCOM_LN_S_RSTB_CTLr_RX_LN_S_RSTBf_GET BCMI_TSCE16_XGXS_RXCOM_LN_S_RSTB_CTLr_RX_LN_S_RSTBf_GET
#define RXCOM_LN_S_RSTB_CTLr_RX_LN_S_RSTBf_SET BCMI_TSCE16_XGXS_RXCOM_LN_S_RSTB_CTLr_RX_LN_S_RSTBf_SET
#define READ_RXCOM_LN_S_RSTB_CTLr BCMI_TSCE16_XGXS_READ_RXCOM_LN_S_RSTB_CTLr
#define WRITE_RXCOM_LN_S_RSTB_CTLr BCMI_TSCE16_XGXS_WRITE_RXCOM_LN_S_RSTB_CTLr
#define MODIFY_RXCOM_LN_S_RSTB_CTLr BCMI_TSCE16_XGXS_MODIFY_RXCOM_LN_S_RSTB_CTLr
#define READLN_RXCOM_LN_S_RSTB_CTLr BCMI_TSCE16_XGXS_READLN_RXCOM_LN_S_RSTB_CTLr
#define WRITELN_RXCOM_LN_S_RSTB_CTLr BCMI_TSCE16_XGXS_WRITELN_RXCOM_LN_S_RSTB_CTLr
#define WRITEALL_RXCOM_LN_S_RSTB_CTLr BCMI_TSCE16_XGXS_WRITEALL_RXCOM_LN_S_RSTB_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_RXCOM_LN_S_RSTB_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TXCOM_OSR_MODE_CTL
 * BLOCKS:   TXCOM_CKRST_CTRL
 * REGADDR:  0xd190
 * DESC:     OSR_MODE_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_OSR_MODE_FRC_VAL oversample (OS) mode Decoding of this register is as follows.OSX1          4'd0OSX2          4'd1OSX3          4'd2OSX3P3        4'd3OSX4          4'd4OSX5          4'd5OSX7P5        4'd6OSX8          4'd7OSX8P25       4'd8OSX10         4'd9
 *     TX_OSR_MODE_FRC  oversample (OS) mode force. Setting this bit will allow the register value to be used for OS mode.Othersise, the pin input values are used for OS mode
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_CTLr (0x0000d190 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_OSR_MODE_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_CTLr_s {
	uint32_t v[1];
	uint32_t txcom_osr_mode_ctl[1];
	uint32_t _txcom_osr_mode_ctl;
} BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_CTLr_t;

#define BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_CTLr_CLR(r) (r).txcom_osr_mode_ctl[0] = 0
#define BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_CTLr_SET(r,d) (r).txcom_osr_mode_ctl[0] = d
#define BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_CTLr_GET(r) (r).txcom_osr_mode_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRCf_GET(r) ((((r).txcom_osr_mode_ctl[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRCf_SET(r,f) (r).txcom_osr_mode_ctl[0]=(((r).txcom_osr_mode_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRC_VALf_GET(r) (((r).txcom_osr_mode_ctl[0]) & 0xf)
#define BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRC_VALf_SET(r,f) (r).txcom_osr_mode_ctl[0]=(((r).txcom_osr_mode_ctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access TXCOM_OSR_MODE_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_CTLr,(_r._txcom_osr_mode_ctl))
#define BCMI_TSCE16_XGXS_WRITE_TXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_CTLr,(_r._txcom_osr_mode_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_CTLr,(_r._txcom_osr_mode_ctl))
#define BCMI_TSCE16_XGXS_READLN_TXCOM_OSR_MODE_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_osr_mode_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_TXCOM_OSR_MODE_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_osr_mode_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_TXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_osr_mode_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_OSR_MODE_CTLr BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_CTLr
#define TXCOM_OSR_MODE_CTLr_SIZE BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_CTLr_t TXCOM_OSR_MODE_CTLr_t;
#define TXCOM_OSR_MODE_CTLr_CLR BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_CTLr_CLR
#define TXCOM_OSR_MODE_CTLr_SET BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_CTLr_SET
#define TXCOM_OSR_MODE_CTLr_GET BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_CTLr_GET
#define TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRCf_GET BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRCf_GET
#define TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRCf_SET BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRCf_SET
#define TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRC_VALf_GET BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRC_VALf_GET
#define TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRC_VALf_SET BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRC_VALf_SET
#define READ_TXCOM_OSR_MODE_CTLr BCMI_TSCE16_XGXS_READ_TXCOM_OSR_MODE_CTLr
#define WRITE_TXCOM_OSR_MODE_CTLr BCMI_TSCE16_XGXS_WRITE_TXCOM_OSR_MODE_CTLr
#define MODIFY_TXCOM_OSR_MODE_CTLr BCMI_TSCE16_XGXS_MODIFY_TXCOM_OSR_MODE_CTLr
#define READLN_TXCOM_OSR_MODE_CTLr BCMI_TSCE16_XGXS_READLN_TXCOM_OSR_MODE_CTLr
#define WRITELN_TXCOM_OSR_MODE_CTLr BCMI_TSCE16_XGXS_WRITELN_TXCOM_OSR_MODE_CTLr
#define WRITEALL_TXCOM_OSR_MODE_CTLr BCMI_TSCE16_XGXS_WRITEALL_TXCOM_OSR_MODE_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TXCOM_LN_CLK_RST_N_PWRDWN_CTL
 * BLOCKS:   TXCOM_CKRST_CTRL
 * REGADDR:  0xd191
 * DESC:     LANE_CLK_RESET_N_POWERDOWN_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_LN_DP_S_RSTB  Active Low Lane Soft Reset for datapath. If asserted by writing to 1'b0 will reset the datapath for a lane.This soft reset is equivalent to the hard reset input pin pmd_ln_dp_h_rstb_i.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr (0x0000d191 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_LN_CLK_RST_N_PWRDWN_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_s {
	uint32_t v[1];
	uint32_t txcom_ln_clk_rst_n_pwrdwn_ctl[1];
	uint32_t _txcom_ln_clk_rst_n_pwrdwn_ctl;
} BCMI_TSCE16_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_t;

#define BCMI_TSCE16_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_CLR(r) (r).txcom_ln_clk_rst_n_pwrdwn_ctl[0] = 0
#define BCMI_TSCE16_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SET(r,d) (r).txcom_ln_clk_rst_n_pwrdwn_ctl[0] = d
#define BCMI_TSCE16_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_GET(r) (r).txcom_ln_clk_rst_n_pwrdwn_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_TX_LN_DP_S_RSTBf_GET(r) (((r).txcom_ln_clk_rst_n_pwrdwn_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_TX_LN_DP_S_RSTBf_SET(r,f) (r).txcom_ln_clk_rst_n_pwrdwn_ctl[0]=(((r).txcom_ln_clk_rst_n_pwrdwn_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TXCOM_LN_CLK_RST_N_PWRDWN_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr,(_r._txcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCE16_XGXS_WRITE_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr,(_r._txcom_ln_clk_rst_n_pwrdwn_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr,(_r._txcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCE16_XGXS_READLN_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_ln_clk_rst_n_pwrdwn_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCE16_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SIZE BCMI_TSCE16_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_t TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_t;
#define TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_CLR BCMI_TSCE16_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_CLR
#define TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SET BCMI_TSCE16_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SET
#define TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_GET BCMI_TSCE16_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_GET
#define TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_TX_LN_DP_S_RSTBf_GET BCMI_TSCE16_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_TX_LN_DP_S_RSTBf_GET
#define TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_TX_LN_DP_S_RSTBf_SET BCMI_TSCE16_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_TX_LN_DP_S_RSTBf_SET
#define READ_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCE16_XGXS_READ_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITE_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCE16_XGXS_WRITE_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define MODIFY_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCE16_XGXS_MODIFY_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define READLN_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCE16_XGXS_READLN_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITELN_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCE16_XGXS_WRITELN_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITEALL_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCE16_XGXS_WRITEALL_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTL
 * BLOCKS:   TXCOM_CKRST_CTRL
 * REGADDR:  0xd193
 * DESC:     LANE_RESET_N_PWRDN_PIN_KILL_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMD_LN_TX_H_RSTB_PKILL 1'b1 will disable the pmd_ln_h_rstb input pin.
 *     PMD_LN_TX_DP_H_RSTB_PKILL 1'b1 will disable the pmd_ln_dp_h_rstb input pin.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr (0x0000d193 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_s {
	uint32_t v[1];
	uint32_t txcom_ln_rst_n_pwrdn_pin_kill_ctl[1];
	uint32_t _txcom_ln_rst_n_pwrdn_pin_kill_ctl;
} BCMI_TSCE16_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_t;

#define BCMI_TSCE16_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR(r) (r).txcom_ln_rst_n_pwrdn_pin_kill_ctl[0] = 0
#define BCMI_TSCE16_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET(r,d) (r).txcom_ln_rst_n_pwrdn_pin_kill_ctl[0] = d
#define BCMI_TSCE16_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET(r) (r).txcom_ln_rst_n_pwrdn_pin_kill_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_DP_H_RSTB_PKILLf_GET(r) ((((r).txcom_ln_rst_n_pwrdn_pin_kill_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_DP_H_RSTB_PKILLf_SET(r,f) (r).txcom_ln_rst_n_pwrdn_pin_kill_ctl[0]=(((r).txcom_ln_rst_n_pwrdn_pin_kill_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_RSTB_PKILLf_GET(r) (((r).txcom_ln_rst_n_pwrdn_pin_kill_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_RSTB_PKILLf_SET(r,f) (r).txcom_ln_rst_n_pwrdn_pin_kill_ctl[0]=(((r).txcom_ln_rst_n_pwrdn_pin_kill_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._txcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCE16_XGXS_WRITE_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._txcom_ln_rst_n_pwrdn_pin_kill_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._txcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCE16_XGXS_READLN_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_ln_rst_n_pwrdn_pin_kill_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCE16_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE BCMI_TSCE16_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_t TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_t;
#define TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR BCMI_TSCE16_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR
#define TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET BCMI_TSCE16_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET
#define TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET BCMI_TSCE16_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET
#define TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_DP_H_RSTB_PKILLf_GET BCMI_TSCE16_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_DP_H_RSTB_PKILLf_GET
#define TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_DP_H_RSTB_PKILLf_SET BCMI_TSCE16_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_DP_H_RSTB_PKILLf_SET
#define TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_RSTB_PKILLf_GET BCMI_TSCE16_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_RSTB_PKILLf_GET
#define TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_RSTB_PKILLf_SET BCMI_TSCE16_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_RSTB_PKILLf_SET
#define READ_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCE16_XGXS_READ_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITE_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCE16_XGXS_WRITE_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define MODIFY_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCE16_XGXS_MODIFY_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define READLN_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCE16_XGXS_READLN_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITELN_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCE16_XGXS_WRITELN_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITEALL_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCE16_XGXS_WRITEALL_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TXCOM_UC_ACK_LN_CTL
 * BLOCKS:   TXCOM_CKRST_CTRL
 * REGADDR:  0xd195
 * DESC:     UC_ACK_LANE_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_UC_ACK_LANE_CFG_DONE uC will write this to 1 to indicate it's configuration of the lane is complete. Writing to 1'b1 willshould release internal hold on lane_dp_reset, only if lane_dp_reset_state is 3'b001.
 *     TX_UC_ACK_LANE_DP_RESET uC will write this to 1 to acknowledge a reset event after seeing "lane_dp_reset_coccured".
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TXCOM_UC_ACK_LN_CTLr (0x0000d195 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TXCOM_UC_ACK_LN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_UC_ACK_LN_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_TXCOM_UC_ACK_LN_CTLr_s {
	uint32_t v[1];
	uint32_t txcom_uc_ack_ln_ctl[1];
	uint32_t _txcom_uc_ack_ln_ctl;
} BCMI_TSCE16_XGXS_TXCOM_UC_ACK_LN_CTLr_t;

#define BCMI_TSCE16_XGXS_TXCOM_UC_ACK_LN_CTLr_CLR(r) (r).txcom_uc_ack_ln_ctl[0] = 0
#define BCMI_TSCE16_XGXS_TXCOM_UC_ACK_LN_CTLr_SET(r,d) (r).txcom_uc_ack_ln_ctl[0] = d
#define BCMI_TSCE16_XGXS_TXCOM_UC_ACK_LN_CTLr_GET(r) (r).txcom_uc_ack_ln_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_DP_RESETf_GET(r) ((((r).txcom_uc_ack_ln_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_DP_RESETf_SET(r,f) (r).txcom_uc_ack_ln_ctl[0]=(((r).txcom_uc_ack_ln_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_CFG_DONEf_GET(r) (((r).txcom_uc_ack_ln_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_CFG_DONEf_SET(r,f) (r).txcom_uc_ack_ln_ctl[0]=(((r).txcom_uc_ack_ln_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TXCOM_UC_ACK_LN_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TXCOM_UC_ACK_LN_CTLr,(_r._txcom_uc_ack_ln_ctl))
#define BCMI_TSCE16_XGXS_WRITE_TXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_UC_ACK_LN_CTLr,(_r._txcom_uc_ack_ln_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_UC_ACK_LN_CTLr,(_r._txcom_uc_ack_ln_ctl))
#define BCMI_TSCE16_XGXS_READLN_TXCOM_UC_ACK_LN_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TXCOM_UC_ACK_LN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_uc_ack_ln_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_TXCOM_UC_ACK_LN_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_UC_ACK_LN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_uc_ack_ln_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_TXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_UC_ACK_LN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_uc_ack_ln_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_UC_ACK_LN_CTLr BCMI_TSCE16_XGXS_TXCOM_UC_ACK_LN_CTLr
#define TXCOM_UC_ACK_LN_CTLr_SIZE BCMI_TSCE16_XGXS_TXCOM_UC_ACK_LN_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_TXCOM_UC_ACK_LN_CTLr_t TXCOM_UC_ACK_LN_CTLr_t;
#define TXCOM_UC_ACK_LN_CTLr_CLR BCMI_TSCE16_XGXS_TXCOM_UC_ACK_LN_CTLr_CLR
#define TXCOM_UC_ACK_LN_CTLr_SET BCMI_TSCE16_XGXS_TXCOM_UC_ACK_LN_CTLr_SET
#define TXCOM_UC_ACK_LN_CTLr_GET BCMI_TSCE16_XGXS_TXCOM_UC_ACK_LN_CTLr_GET
#define TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_DP_RESETf_GET BCMI_TSCE16_XGXS_TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_DP_RESETf_GET
#define TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_DP_RESETf_SET BCMI_TSCE16_XGXS_TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_DP_RESETf_SET
#define TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_CFG_DONEf_GET BCMI_TSCE16_XGXS_TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_CFG_DONEf_GET
#define TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_CFG_DONEf_SET BCMI_TSCE16_XGXS_TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_CFG_DONEf_SET
#define READ_TXCOM_UC_ACK_LN_CTLr BCMI_TSCE16_XGXS_READ_TXCOM_UC_ACK_LN_CTLr
#define WRITE_TXCOM_UC_ACK_LN_CTLr BCMI_TSCE16_XGXS_WRITE_TXCOM_UC_ACK_LN_CTLr
#define MODIFY_TXCOM_UC_ACK_LN_CTLr BCMI_TSCE16_XGXS_MODIFY_TXCOM_UC_ACK_LN_CTLr
#define READLN_TXCOM_UC_ACK_LN_CTLr BCMI_TSCE16_XGXS_READLN_TXCOM_UC_ACK_LN_CTLr
#define WRITELN_TXCOM_UC_ACK_LN_CTLr BCMI_TSCE16_XGXS_WRITELN_TXCOM_UC_ACK_LN_CTLr
#define WRITEALL_TXCOM_UC_ACK_LN_CTLr BCMI_TSCE16_XGXS_WRITEALL_TXCOM_UC_ACK_LN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TXCOM_UC_ACK_LN_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TXCOM_LN_RST_OCC_CTL
 * BLOCKS:   TXCOM_CKRST_CTRL
 * REGADDR:  0xd196
 * DESC:     LANE_REG_RESET_OCCURRED_CONTROL
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_LANE_REG_RESET_OCCURRED Set to 1'b1 upon lane level register reset and remains so until cleared by register write from uC.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TXCOM_LN_RST_OCC_CTLr (0x0000d196 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TXCOM_LN_RST_OCC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_LN_RST_OCC_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_TXCOM_LN_RST_OCC_CTLr_s {
	uint32_t v[1];
	uint32_t txcom_ln_rst_occ_ctl[1];
	uint32_t _txcom_ln_rst_occ_ctl;
} BCMI_TSCE16_XGXS_TXCOM_LN_RST_OCC_CTLr_t;

#define BCMI_TSCE16_XGXS_TXCOM_LN_RST_OCC_CTLr_CLR(r) (r).txcom_ln_rst_occ_ctl[0] = 0
#define BCMI_TSCE16_XGXS_TXCOM_LN_RST_OCC_CTLr_SET(r,d) (r).txcom_ln_rst_occ_ctl[0] = d
#define BCMI_TSCE16_XGXS_TXCOM_LN_RST_OCC_CTLr_GET(r) (r).txcom_ln_rst_occ_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TXCOM_LN_RST_OCC_CTLr_TX_LANE_REG_RESET_OCCURREDf_GET(r) (((r).txcom_ln_rst_occ_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TXCOM_LN_RST_OCC_CTLr_TX_LANE_REG_RESET_OCCURREDf_SET(r,f) (r).txcom_ln_rst_occ_ctl[0]=(((r).txcom_ln_rst_occ_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TXCOM_LN_RST_OCC_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TXCOM_LN_RST_OCC_CTLr,(_r._txcom_ln_rst_occ_ctl))
#define BCMI_TSCE16_XGXS_WRITE_TXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_LN_RST_OCC_CTLr,(_r._txcom_ln_rst_occ_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_LN_RST_OCC_CTLr,(_r._txcom_ln_rst_occ_ctl))
#define BCMI_TSCE16_XGXS_READLN_TXCOM_LN_RST_OCC_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TXCOM_LN_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ln_rst_occ_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_TXCOM_LN_RST_OCC_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_LN_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ln_rst_occ_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_TXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_LN_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_ln_rst_occ_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_LN_RST_OCC_CTLr BCMI_TSCE16_XGXS_TXCOM_LN_RST_OCC_CTLr
#define TXCOM_LN_RST_OCC_CTLr_SIZE BCMI_TSCE16_XGXS_TXCOM_LN_RST_OCC_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_TXCOM_LN_RST_OCC_CTLr_t TXCOM_LN_RST_OCC_CTLr_t;
#define TXCOM_LN_RST_OCC_CTLr_CLR BCMI_TSCE16_XGXS_TXCOM_LN_RST_OCC_CTLr_CLR
#define TXCOM_LN_RST_OCC_CTLr_SET BCMI_TSCE16_XGXS_TXCOM_LN_RST_OCC_CTLr_SET
#define TXCOM_LN_RST_OCC_CTLr_GET BCMI_TSCE16_XGXS_TXCOM_LN_RST_OCC_CTLr_GET
#define TXCOM_LN_RST_OCC_CTLr_TX_LANE_REG_RESET_OCCURREDf_GET BCMI_TSCE16_XGXS_TXCOM_LN_RST_OCC_CTLr_TX_LANE_REG_RESET_OCCURREDf_GET
#define TXCOM_LN_RST_OCC_CTLr_TX_LANE_REG_RESET_OCCURREDf_SET BCMI_TSCE16_XGXS_TXCOM_LN_RST_OCC_CTLr_TX_LANE_REG_RESET_OCCURREDf_SET
#define READ_TXCOM_LN_RST_OCC_CTLr BCMI_TSCE16_XGXS_READ_TXCOM_LN_RST_OCC_CTLr
#define WRITE_TXCOM_LN_RST_OCC_CTLr BCMI_TSCE16_XGXS_WRITE_TXCOM_LN_RST_OCC_CTLr
#define MODIFY_TXCOM_LN_RST_OCC_CTLr BCMI_TSCE16_XGXS_MODIFY_TXCOM_LN_RST_OCC_CTLr
#define READLN_TXCOM_LN_RST_OCC_CTLr BCMI_TSCE16_XGXS_READLN_TXCOM_LN_RST_OCC_CTLr
#define WRITELN_TXCOM_LN_RST_OCC_CTLr BCMI_TSCE16_XGXS_WRITELN_TXCOM_LN_RST_OCC_CTLr
#define WRITEALL_TXCOM_LN_RST_OCC_CTLr BCMI_TSCE16_XGXS_WRITEALL_TXCOM_LN_RST_OCC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TXCOM_LN_RST_OCC_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TXCOM_LN_DP_RST_ST_STS
 * BLOCKS:   TXCOM_CKRST_CTRL
 * REGADDR:  0xd199
 * DESC:     LANE_DP_RESET_STATE_STATUS
 * RESETVAL: 0x7 (7)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_LANE_DP_RESET_STATE Bit 2: lane_dp_reset_active   : Set to 1'b1 whenenver lane_dp_reset is currently requested through any register or pin controls.Bit 1: lane_dp_reset_occurred : Set to 1'b1 whenenver lane_dp_reset is currently requested through any register or pin controls and is latched high.Bit 0: lane_dp_reset_held     : Set to 1'b1 whenenver lane_dp_reset is internally held. Cleared to 1'b0, only if lane_dp_reset_state==001 and uc_ack_lane_cfg_done == 1.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TXCOM_LN_DP_RST_ST_STSr (0x0000d199 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TXCOM_LN_DP_RST_ST_STSr_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_LN_DP_RST_ST_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_TXCOM_LN_DP_RST_ST_STSr_s {
	uint32_t v[1];
	uint32_t txcom_ln_dp_rst_st_sts[1];
	uint32_t _txcom_ln_dp_rst_st_sts;
} BCMI_TSCE16_XGXS_TXCOM_LN_DP_RST_ST_STSr_t;

#define BCMI_TSCE16_XGXS_TXCOM_LN_DP_RST_ST_STSr_CLR(r) (r).txcom_ln_dp_rst_st_sts[0] = 0
#define BCMI_TSCE16_XGXS_TXCOM_LN_DP_RST_ST_STSr_SET(r,d) (r).txcom_ln_dp_rst_st_sts[0] = d
#define BCMI_TSCE16_XGXS_TXCOM_LN_DP_RST_ST_STSr_GET(r) (r).txcom_ln_dp_rst_st_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TXCOM_LN_DP_RST_ST_STSr_TX_LANE_DP_RESET_STATEf_GET(r) (((r).txcom_ln_dp_rst_st_sts[0]) & 0x7)
#define BCMI_TSCE16_XGXS_TXCOM_LN_DP_RST_ST_STSr_TX_LANE_DP_RESET_STATEf_SET(r,f) (r).txcom_ln_dp_rst_st_sts[0]=(((r).txcom_ln_dp_rst_st_sts[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access TXCOM_LN_DP_RST_ST_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TXCOM_LN_DP_RST_ST_STSr,(_r._txcom_ln_dp_rst_st_sts))
#define BCMI_TSCE16_XGXS_WRITE_TXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_LN_DP_RST_ST_STSr,(_r._txcom_ln_dp_rst_st_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_LN_DP_RST_ST_STSr,(_r._txcom_ln_dp_rst_st_sts))
#define BCMI_TSCE16_XGXS_READLN_TXCOM_LN_DP_RST_ST_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TXCOM_LN_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ln_dp_rst_st_sts))
#define BCMI_TSCE16_XGXS_WRITELN_TXCOM_LN_DP_RST_ST_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_LN_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ln_dp_rst_st_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_TXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_LN_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_ln_dp_rst_st_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_LN_DP_RST_ST_STSr BCMI_TSCE16_XGXS_TXCOM_LN_DP_RST_ST_STSr
#define TXCOM_LN_DP_RST_ST_STSr_SIZE BCMI_TSCE16_XGXS_TXCOM_LN_DP_RST_ST_STSr_SIZE
typedef BCMI_TSCE16_XGXS_TXCOM_LN_DP_RST_ST_STSr_t TXCOM_LN_DP_RST_ST_STSr_t;
#define TXCOM_LN_DP_RST_ST_STSr_CLR BCMI_TSCE16_XGXS_TXCOM_LN_DP_RST_ST_STSr_CLR
#define TXCOM_LN_DP_RST_ST_STSr_SET BCMI_TSCE16_XGXS_TXCOM_LN_DP_RST_ST_STSr_SET
#define TXCOM_LN_DP_RST_ST_STSr_GET BCMI_TSCE16_XGXS_TXCOM_LN_DP_RST_ST_STSr_GET
#define TXCOM_LN_DP_RST_ST_STSr_TX_LANE_DP_RESET_STATEf_GET BCMI_TSCE16_XGXS_TXCOM_LN_DP_RST_ST_STSr_TX_LANE_DP_RESET_STATEf_GET
#define TXCOM_LN_DP_RST_ST_STSr_TX_LANE_DP_RESET_STATEf_SET BCMI_TSCE16_XGXS_TXCOM_LN_DP_RST_ST_STSr_TX_LANE_DP_RESET_STATEf_SET
#define READ_TXCOM_LN_DP_RST_ST_STSr BCMI_TSCE16_XGXS_READ_TXCOM_LN_DP_RST_ST_STSr
#define WRITE_TXCOM_LN_DP_RST_ST_STSr BCMI_TSCE16_XGXS_WRITE_TXCOM_LN_DP_RST_ST_STSr
#define MODIFY_TXCOM_LN_DP_RST_ST_STSr BCMI_TSCE16_XGXS_MODIFY_TXCOM_LN_DP_RST_ST_STSr
#define READLN_TXCOM_LN_DP_RST_ST_STSr BCMI_TSCE16_XGXS_READLN_TXCOM_LN_DP_RST_ST_STSr
#define WRITELN_TXCOM_LN_DP_RST_ST_STSr BCMI_TSCE16_XGXS_WRITELN_TXCOM_LN_DP_RST_ST_STSr
#define WRITEALL_TXCOM_LN_DP_RST_ST_STSr BCMI_TSCE16_XGXS_WRITEALL_TXCOM_LN_DP_RST_ST_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TXCOM_LN_DP_RST_ST_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TXCOM_MCST_MASK_CTL
 * BLOCKS:   TXCOM_CKRST_CTRL
 * REGADDR:  0xd19a
 * DESC:     MULTICAST_MASK_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_MULTICAST_MASK_CONTROL This masks the lane from a broadcast or multicast write operation.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TXCOM_MCST_MASK_CTLr (0x0000d19a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TXCOM_MCST_MASK_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_MCST_MASK_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_TXCOM_MCST_MASK_CTLr_s {
	uint32_t v[1];
	uint32_t txcom_mcst_mask_ctl[1];
	uint32_t _txcom_mcst_mask_ctl;
} BCMI_TSCE16_XGXS_TXCOM_MCST_MASK_CTLr_t;

#define BCMI_TSCE16_XGXS_TXCOM_MCST_MASK_CTLr_CLR(r) (r).txcom_mcst_mask_ctl[0] = 0
#define BCMI_TSCE16_XGXS_TXCOM_MCST_MASK_CTLr_SET(r,d) (r).txcom_mcst_mask_ctl[0] = d
#define BCMI_TSCE16_XGXS_TXCOM_MCST_MASK_CTLr_GET(r) (r).txcom_mcst_mask_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TXCOM_MCST_MASK_CTLr_TX_MULTICAST_MASK_CONTROLf_GET(r) (((r).txcom_mcst_mask_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TXCOM_MCST_MASK_CTLr_TX_MULTICAST_MASK_CONTROLf_SET(r,f) (r).txcom_mcst_mask_ctl[0]=(((r).txcom_mcst_mask_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TXCOM_MCST_MASK_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TXCOM_MCST_MASK_CTLr,(_r._txcom_mcst_mask_ctl))
#define BCMI_TSCE16_XGXS_WRITE_TXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_MCST_MASK_CTLr,(_r._txcom_mcst_mask_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_MCST_MASK_CTLr,(_r._txcom_mcst_mask_ctl))
#define BCMI_TSCE16_XGXS_READLN_TXCOM_MCST_MASK_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TXCOM_MCST_MASK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_mcst_mask_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_TXCOM_MCST_MASK_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_MCST_MASK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_mcst_mask_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_TXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_MCST_MASK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_mcst_mask_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_MCST_MASK_CTLr BCMI_TSCE16_XGXS_TXCOM_MCST_MASK_CTLr
#define TXCOM_MCST_MASK_CTLr_SIZE BCMI_TSCE16_XGXS_TXCOM_MCST_MASK_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_TXCOM_MCST_MASK_CTLr_t TXCOM_MCST_MASK_CTLr_t;
#define TXCOM_MCST_MASK_CTLr_CLR BCMI_TSCE16_XGXS_TXCOM_MCST_MASK_CTLr_CLR
#define TXCOM_MCST_MASK_CTLr_SET BCMI_TSCE16_XGXS_TXCOM_MCST_MASK_CTLr_SET
#define TXCOM_MCST_MASK_CTLr_GET BCMI_TSCE16_XGXS_TXCOM_MCST_MASK_CTLr_GET
#define TXCOM_MCST_MASK_CTLr_TX_MULTICAST_MASK_CONTROLf_GET BCMI_TSCE16_XGXS_TXCOM_MCST_MASK_CTLr_TX_MULTICAST_MASK_CONTROLf_GET
#define TXCOM_MCST_MASK_CTLr_TX_MULTICAST_MASK_CONTROLf_SET BCMI_TSCE16_XGXS_TXCOM_MCST_MASK_CTLr_TX_MULTICAST_MASK_CONTROLf_SET
#define READ_TXCOM_MCST_MASK_CTLr BCMI_TSCE16_XGXS_READ_TXCOM_MCST_MASK_CTLr
#define WRITE_TXCOM_MCST_MASK_CTLr BCMI_TSCE16_XGXS_WRITE_TXCOM_MCST_MASK_CTLr
#define MODIFY_TXCOM_MCST_MASK_CTLr BCMI_TSCE16_XGXS_MODIFY_TXCOM_MCST_MASK_CTLr
#define READLN_TXCOM_MCST_MASK_CTLr BCMI_TSCE16_XGXS_READLN_TXCOM_MCST_MASK_CTLr
#define WRITELN_TXCOM_MCST_MASK_CTLr BCMI_TSCE16_XGXS_WRITELN_TXCOM_MCST_MASK_CTLr
#define WRITEALL_TXCOM_MCST_MASK_CTLr BCMI_TSCE16_XGXS_WRITEALL_TXCOM_MCST_MASK_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TXCOM_MCST_MASK_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TXCOM_OSR_MODE_STS_MC_MASK
 * BLOCKS:   TXCOM_CKRST_CTRL
 * REGADDR:  0xd19b
 * DESC:     OSR_MODE_STATUS_MC_MASK
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_OSR_MODE      OSR Mode status after the mux.OSR Mode status after the osr_mode_frc/frc_val mux.Decoding of this register is as follows.OSX1          4'd0OSX2          4'd1OSX3          4'd2OSX3P3        4'd3OSX4          4'd4OSX5          4'd5OSX7P5        4'd6OSX8          4'd7OSX8P25       4'd8OSX10         4'd9
 *     TX_MULTICAST_MASK_CONTROL_STATUS Status of multicast mask control for masking lane from multicast write operation.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr (0x0000d19b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_OSR_MODE_STS_MC_MASK.
 *
 */
typedef union BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_s {
	uint32_t v[1];
	uint32_t txcom_osr_mode_sts_mc_mask[1];
	uint32_t _txcom_osr_mode_sts_mc_mask;
} BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_t;

#define BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_CLR(r) (r).txcom_osr_mode_sts_mc_mask[0] = 0
#define BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_SET(r,d) (r).txcom_osr_mode_sts_mc_mask[0] = d
#define BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_GET(r) (r).txcom_osr_mode_sts_mc_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_TX_MULTICAST_MASK_CONTROL_STATUSf_GET(r) ((((r).txcom_osr_mode_sts_mc_mask[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_TX_MULTICAST_MASK_CONTROL_STATUSf_SET(r,f) (r).txcom_osr_mode_sts_mc_mask[0]=(((r).txcom_osr_mode_sts_mc_mask[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_TX_OSR_MODEf_GET(r) (((r).txcom_osr_mode_sts_mc_mask[0]) & 0xf)
#define BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_TX_OSR_MODEf_SET(r,f) (r).txcom_osr_mode_sts_mc_mask[0]=(((r).txcom_osr_mode_sts_mc_mask[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access TXCOM_OSR_MODE_STS_MC_MASK.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr,(_r._txcom_osr_mode_sts_mc_mask))
#define BCMI_TSCE16_XGXS_WRITE_TXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr,(_r._txcom_osr_mode_sts_mc_mask)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr,(_r._txcom_osr_mode_sts_mc_mask))
#define BCMI_TSCE16_XGXS_READLN_TXCOM_OSR_MODE_STS_MC_MASKr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_osr_mode_sts_mc_mask))
#define BCMI_TSCE16_XGXS_WRITELN_TXCOM_OSR_MODE_STS_MC_MASKr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_osr_mode_sts_mc_mask))
#define BCMI_TSCE16_XGXS_WRITEALL_TXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_osr_mode_sts_mc_mask))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr
#define TXCOM_OSR_MODE_STS_MC_MASKr_SIZE BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_SIZE
typedef BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_t TXCOM_OSR_MODE_STS_MC_MASKr_t;
#define TXCOM_OSR_MODE_STS_MC_MASKr_CLR BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_CLR
#define TXCOM_OSR_MODE_STS_MC_MASKr_SET BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_SET
#define TXCOM_OSR_MODE_STS_MC_MASKr_GET BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_GET
#define TXCOM_OSR_MODE_STS_MC_MASKr_TX_MULTICAST_MASK_CONTROL_STATUSf_GET BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_TX_MULTICAST_MASK_CONTROL_STATUSf_GET
#define TXCOM_OSR_MODE_STS_MC_MASKr_TX_MULTICAST_MASK_CONTROL_STATUSf_SET BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_TX_MULTICAST_MASK_CONTROL_STATUSf_SET
#define TXCOM_OSR_MODE_STS_MC_MASKr_TX_OSR_MODEf_GET BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_TX_OSR_MODEf_GET
#define TXCOM_OSR_MODE_STS_MC_MASKr_TX_OSR_MODEf_SET BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_TX_OSR_MODEf_SET
#define READ_TXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCE16_XGXS_READ_TXCOM_OSR_MODE_STS_MC_MASKr
#define WRITE_TXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCE16_XGXS_WRITE_TXCOM_OSR_MODE_STS_MC_MASKr
#define MODIFY_TXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCE16_XGXS_MODIFY_TXCOM_OSR_MODE_STS_MC_MASKr
#define READLN_TXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCE16_XGXS_READLN_TXCOM_OSR_MODE_STS_MC_MASKr
#define WRITELN_TXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCE16_XGXS_WRITELN_TXCOM_OSR_MODE_STS_MC_MASKr
#define WRITEALL_TXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCE16_XGXS_WRITEALL_TXCOM_OSR_MODE_STS_MC_MASKr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STS
 * BLOCKS:   TXCOM_CKRST_CTRL
 * REGADDR:  0xd19c
 * DESC:     AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_OSR_MODE_PIN  Indicates the status of the pmd_osr_mode input pin.Decoding of pmd_osr_mode[3:0] pin and osr_mode registers are as follows.OSX1          4'd0OSX2          4'd1OSX3          4'd2OSX3P3        4'd3OSX4          4'd4OSX5          4'd5OSX7P5        4'd6OSX8          4'd7OSX8P25       4'd8OSX10         4'd9
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr (0x0000d19c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STS.
 *
 */
typedef union BCMI_TSCE16_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_s {
	uint32_t v[1];
	uint32_t txcom_afe_rst_pwrdn_osr_mode_pin_sts[1];
	uint32_t _txcom_afe_rst_pwrdn_osr_mode_pin_sts;
} BCMI_TSCE16_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_t;

#define BCMI_TSCE16_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_CLR(r) (r).txcom_afe_rst_pwrdn_osr_mode_pin_sts[0] = 0
#define BCMI_TSCE16_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SET(r,d) (r).txcom_afe_rst_pwrdn_osr_mode_pin_sts[0] = d
#define BCMI_TSCE16_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_GET(r) (r).txcom_afe_rst_pwrdn_osr_mode_pin_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_TX_OSR_MODE_PINf_GET(r) (((r).txcom_afe_rst_pwrdn_osr_mode_pin_sts[0]) & 0xf)
#define BCMI_TSCE16_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_TX_OSR_MODE_PINf_SET(r,f) (r).txcom_afe_rst_pwrdn_osr_mode_pin_sts[0]=(((r).txcom_afe_rst_pwrdn_osr_mode_pin_sts[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STS.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr,(_r._txcom_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_TSCE16_XGXS_WRITE_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr,(_r._txcom_afe_rst_pwrdn_osr_mode_pin_sts)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr,(_r._txcom_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_TSCE16_XGXS_READLN_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_TSCE16_XGXS_WRITELN_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_afe_rst_pwrdn_osr_mode_pin_sts))
#define BCMI_TSCE16_XGXS_WRITEALL_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_afe_rst_pwrdn_osr_mode_pin_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_TSCE16_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SIZE BCMI_TSCE16_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SIZE
typedef BCMI_TSCE16_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_t TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_t;
#define TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_CLR BCMI_TSCE16_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_CLR
#define TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SET BCMI_TSCE16_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SET
#define TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_GET BCMI_TSCE16_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_GET
#define TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_TX_OSR_MODE_PINf_GET BCMI_TSCE16_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_TX_OSR_MODE_PINf_GET
#define TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_TX_OSR_MODE_PINf_SET BCMI_TSCE16_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_TX_OSR_MODE_PINf_SET
#define READ_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_TSCE16_XGXS_READ_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define WRITE_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_TSCE16_XGXS_WRITE_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define MODIFY_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_TSCE16_XGXS_MODIFY_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define READLN_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_TSCE16_XGXS_READLN_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define WRITELN_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_TSCE16_XGXS_WRITELN_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define WRITEALL_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_TSCE16_XGXS_WRITEALL_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TXCOM_AFE_RST_PWRDN_OSR_MODE_PIN_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  TXCOM_LN_S_RSTB_CTL
 * BLOCKS:   TXCOM_CKRST_CTRL
 * REGADDR:  0xd19e
 * DESC:     LN_S_RSTB_CONTROL
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_LN_S_RSTB     Active Low Lane Soft Reset. If asserted by writing to 1'b0 will reset the registers and datapath for a lane.This soft reset is equivalent to the hard reset input pin pmd_ln_h_rstb_i.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_TXCOM_LN_S_RSTB_CTLr (0x0000d19e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_TXCOM_LN_S_RSTB_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_LN_S_RSTB_CTL.
 *
 */
typedef union BCMI_TSCE16_XGXS_TXCOM_LN_S_RSTB_CTLr_s {
	uint32_t v[1];
	uint32_t txcom_ln_s_rstb_ctl[1];
	uint32_t _txcom_ln_s_rstb_ctl;
} BCMI_TSCE16_XGXS_TXCOM_LN_S_RSTB_CTLr_t;

#define BCMI_TSCE16_XGXS_TXCOM_LN_S_RSTB_CTLr_CLR(r) (r).txcom_ln_s_rstb_ctl[0] = 0
#define BCMI_TSCE16_XGXS_TXCOM_LN_S_RSTB_CTLr_SET(r,d) (r).txcom_ln_s_rstb_ctl[0] = d
#define BCMI_TSCE16_XGXS_TXCOM_LN_S_RSTB_CTLr_GET(r) (r).txcom_ln_s_rstb_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_TXCOM_LN_S_RSTB_CTLr_TX_LN_S_RSTBf_GET(r) (((r).txcom_ln_s_rstb_ctl[0]) & 0x1)
#define BCMI_TSCE16_XGXS_TXCOM_LN_S_RSTB_CTLr_TX_LN_S_RSTBf_SET(r,f) (r).txcom_ln_s_rstb_ctl[0]=(((r).txcom_ln_s_rstb_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TXCOM_LN_S_RSTB_CTL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_TXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TXCOM_LN_S_RSTB_CTLr,(_r._txcom_ln_s_rstb_ctl))
#define BCMI_TSCE16_XGXS_WRITE_TXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_LN_S_RSTB_CTLr,(_r._txcom_ln_s_rstb_ctl)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_TXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_LN_S_RSTB_CTLr,(_r._txcom_ln_s_rstb_ctl))
#define BCMI_TSCE16_XGXS_READLN_TXCOM_LN_S_RSTB_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_TXCOM_LN_S_RSTB_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ln_s_rstb_ctl))
#define BCMI_TSCE16_XGXS_WRITELN_TXCOM_LN_S_RSTB_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_LN_S_RSTB_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ln_s_rstb_ctl))
#define BCMI_TSCE16_XGXS_WRITEALL_TXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_TXCOM_LN_S_RSTB_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_ln_s_rstb_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_LN_S_RSTB_CTLr BCMI_TSCE16_XGXS_TXCOM_LN_S_RSTB_CTLr
#define TXCOM_LN_S_RSTB_CTLr_SIZE BCMI_TSCE16_XGXS_TXCOM_LN_S_RSTB_CTLr_SIZE
typedef BCMI_TSCE16_XGXS_TXCOM_LN_S_RSTB_CTLr_t TXCOM_LN_S_RSTB_CTLr_t;
#define TXCOM_LN_S_RSTB_CTLr_CLR BCMI_TSCE16_XGXS_TXCOM_LN_S_RSTB_CTLr_CLR
#define TXCOM_LN_S_RSTB_CTLr_SET BCMI_TSCE16_XGXS_TXCOM_LN_S_RSTB_CTLr_SET
#define TXCOM_LN_S_RSTB_CTLr_GET BCMI_TSCE16_XGXS_TXCOM_LN_S_RSTB_CTLr_GET
#define TXCOM_LN_S_RSTB_CTLr_TX_LN_S_RSTBf_GET BCMI_TSCE16_XGXS_TXCOM_LN_S_RSTB_CTLr_TX_LN_S_RSTBf_GET
#define TXCOM_LN_S_RSTB_CTLr_TX_LN_S_RSTBf_SET BCMI_TSCE16_XGXS_TXCOM_LN_S_RSTB_CTLr_TX_LN_S_RSTBf_SET
#define READ_TXCOM_LN_S_RSTB_CTLr BCMI_TSCE16_XGXS_READ_TXCOM_LN_S_RSTB_CTLr
#define WRITE_TXCOM_LN_S_RSTB_CTLr BCMI_TSCE16_XGXS_WRITE_TXCOM_LN_S_RSTB_CTLr
#define MODIFY_TXCOM_LN_S_RSTB_CTLr BCMI_TSCE16_XGXS_MODIFY_TXCOM_LN_S_RSTB_CTLr
#define READLN_TXCOM_LN_S_RSTB_CTLr BCMI_TSCE16_XGXS_READLN_TXCOM_LN_S_RSTB_CTLr
#define WRITELN_TXCOM_LN_S_RSTB_CTLr BCMI_TSCE16_XGXS_WRITELN_TXCOM_LN_S_RSTB_CTLr
#define WRITEALL_TXCOM_LN_S_RSTB_CTLr BCMI_TSCE16_XGXS_WRITEALL_TXCOM_LN_S_RSTB_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_TXCOM_LN_S_RSTB_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_CLK_CTL0
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd200
 * DESC:     Clock control registers 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_MASTER_CLK_EN master clock enable:By default the clock to micro sub-system is disabled andonly the micro control and status registers can be accessed throughthe RMIC interface. Setting this field to 1'b1 enable the master clock0 - disabled1 - enables
 *     MICRO_CORE_CLK_EN micro core clock enable (m0):While the micro-code is being loaded into the code RAM, the clock tomicro_core (m0) is normally disabled and a reset is asserted0 - disabled1 - enables
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_CLK_CTL0r (0x0000d200 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_CLK_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_CLK_CTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_CLK_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_clk_ctl0[1];
	uint32_t _uc_clk_ctl0;
} BCMI_TSCE16_XGXS_UC_CLK_CTL0r_t;

#define BCMI_TSCE16_XGXS_UC_CLK_CTL0r_CLR(r) (r).uc_clk_ctl0[0] = 0
#define BCMI_TSCE16_XGXS_UC_CLK_CTL0r_SET(r,d) (r).uc_clk_ctl0[0] = d
#define BCMI_TSCE16_XGXS_UC_CLK_CTL0r_GET(r) (r).uc_clk_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_CLK_CTL0r_MICRO_CORE_CLK_ENf_GET(r) ((((r).uc_clk_ctl0[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_UC_CLK_CTL0r_MICRO_CORE_CLK_ENf_SET(r,f) (r).uc_clk_ctl0[0]=(((r).uc_clk_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_UC_CLK_CTL0r_MICRO_MASTER_CLK_ENf_GET(r) (((r).uc_clk_ctl0[0]) & 0x1)
#define BCMI_TSCE16_XGXS_UC_CLK_CTL0r_MICRO_MASTER_CLK_ENf_SET(r,f) (r).uc_clk_ctl0[0]=(((r).uc_clk_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_CLK_CTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_CLK_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_CLK_CTL0r,(_r._uc_clk_ctl0))
#define BCMI_TSCE16_XGXS_WRITE_UC_CLK_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_CLK_CTL0r,(_r._uc_clk_ctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_CLK_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_CLK_CTL0r,(_r._uc_clk_ctl0))
#define BCMI_TSCE16_XGXS_READLN_UC_CLK_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_CLK_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_clk_ctl0))
#define BCMI_TSCE16_XGXS_WRITELN_UC_CLK_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_CLK_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_clk_ctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_CLK_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_CLK_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_clk_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_CLK_CTL0r BCMI_TSCE16_XGXS_UC_CLK_CTL0r
#define UC_CLK_CTL0r_SIZE BCMI_TSCE16_XGXS_UC_CLK_CTL0r_SIZE
typedef BCMI_TSCE16_XGXS_UC_CLK_CTL0r_t UC_CLK_CTL0r_t;
#define UC_CLK_CTL0r_CLR BCMI_TSCE16_XGXS_UC_CLK_CTL0r_CLR
#define UC_CLK_CTL0r_SET BCMI_TSCE16_XGXS_UC_CLK_CTL0r_SET
#define UC_CLK_CTL0r_GET BCMI_TSCE16_XGXS_UC_CLK_CTL0r_GET
#define UC_CLK_CTL0r_MICRO_CORE_CLK_ENf_GET BCMI_TSCE16_XGXS_UC_CLK_CTL0r_MICRO_CORE_CLK_ENf_GET
#define UC_CLK_CTL0r_MICRO_CORE_CLK_ENf_SET BCMI_TSCE16_XGXS_UC_CLK_CTL0r_MICRO_CORE_CLK_ENf_SET
#define UC_CLK_CTL0r_MICRO_MASTER_CLK_ENf_GET BCMI_TSCE16_XGXS_UC_CLK_CTL0r_MICRO_MASTER_CLK_ENf_GET
#define UC_CLK_CTL0r_MICRO_MASTER_CLK_ENf_SET BCMI_TSCE16_XGXS_UC_CLK_CTL0r_MICRO_MASTER_CLK_ENf_SET
#define READ_UC_CLK_CTL0r BCMI_TSCE16_XGXS_READ_UC_CLK_CTL0r
#define WRITE_UC_CLK_CTL0r BCMI_TSCE16_XGXS_WRITE_UC_CLK_CTL0r
#define MODIFY_UC_CLK_CTL0r BCMI_TSCE16_XGXS_MODIFY_UC_CLK_CTL0r
#define READLN_UC_CLK_CTL0r BCMI_TSCE16_XGXS_READLN_UC_CLK_CTL0r
#define WRITELN_UC_CLK_CTL0r BCMI_TSCE16_XGXS_WRITELN_UC_CLK_CTL0r
#define WRITEALL_UC_CLK_CTL0r BCMI_TSCE16_XGXS_WRITEALL_UC_CLK_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_CLK_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_RST_CTL0
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd201
 * DESC:     Reset control registers 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_MASTER_RSTB master reset :By default a reset to micro controller sub-system is asserted, andonly the micro control and status registers can be accessed throughthe RMIC interface. Setting this field to 1'b1 de-assert a reset to the micro-subsystem0 - asserted1 - de-asserted
 *     MICRO_CORE_RSTB  micro core reset (m0):While the micro-code is being loaded into the code RAM, the clock tomicro_core (m0) is normally disabled and a reset is asserted.Setting this field to 1'b1 de-asserts a reset to the micro.0 - disabled1 - enables
 *     MICRO_PRAM_IF_RSTB PRAM interface reset :By default a reset to the PRAM interface is asserted, andonly the micro control and status registers can be accessed throughthe RMIC interface. Setting this field to 1'b1 de-assert a reset to the PRAM interface0 - asserted1 - de-asserted
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_RST_CTL0r (0x0000d201 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_RST_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RST_CTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_RST_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_rst_ctl0[1];
	uint32_t _uc_rst_ctl0;
} BCMI_TSCE16_XGXS_UC_RST_CTL0r_t;

#define BCMI_TSCE16_XGXS_UC_RST_CTL0r_CLR(r) (r).uc_rst_ctl0[0] = 0
#define BCMI_TSCE16_XGXS_UC_RST_CTL0r_SET(r,d) (r).uc_rst_ctl0[0] = d
#define BCMI_TSCE16_XGXS_UC_RST_CTL0r_GET(r) (r).uc_rst_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_RST_CTL0r_MICRO_PRAM_IF_RSTBf_GET(r) ((((r).uc_rst_ctl0[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RST_CTL0r_MICRO_PRAM_IF_RSTBf_SET(r,f) (r).uc_rst_ctl0[0]=(((r).uc_rst_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_UC_RST_CTL0r_MICRO_CORE_RSTBf_GET(r) ((((r).uc_rst_ctl0[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RST_CTL0r_MICRO_CORE_RSTBf_SET(r,f) (r).uc_rst_ctl0[0]=(((r).uc_rst_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_UC_RST_CTL0r_MICRO_MASTER_RSTBf_GET(r) (((r).uc_rst_ctl0[0]) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RST_CTL0r_MICRO_MASTER_RSTBf_SET(r,f) (r).uc_rst_ctl0[0]=(((r).uc_rst_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RST_CTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_RST_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_RST_CTL0r,(_r._uc_rst_ctl0))
#define BCMI_TSCE16_XGXS_WRITE_UC_RST_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RST_CTL0r,(_r._uc_rst_ctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_RST_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RST_CTL0r,(_r._uc_rst_ctl0))
#define BCMI_TSCE16_XGXS_READLN_UC_RST_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_RST_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rst_ctl0))
#define BCMI_TSCE16_XGXS_WRITELN_UC_RST_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RST_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rst_ctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_RST_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RST_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rst_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RST_CTL0r BCMI_TSCE16_XGXS_UC_RST_CTL0r
#define UC_RST_CTL0r_SIZE BCMI_TSCE16_XGXS_UC_RST_CTL0r_SIZE
typedef BCMI_TSCE16_XGXS_UC_RST_CTL0r_t UC_RST_CTL0r_t;
#define UC_RST_CTL0r_CLR BCMI_TSCE16_XGXS_UC_RST_CTL0r_CLR
#define UC_RST_CTL0r_SET BCMI_TSCE16_XGXS_UC_RST_CTL0r_SET
#define UC_RST_CTL0r_GET BCMI_TSCE16_XGXS_UC_RST_CTL0r_GET
#define UC_RST_CTL0r_MICRO_PRAM_IF_RSTBf_GET BCMI_TSCE16_XGXS_UC_RST_CTL0r_MICRO_PRAM_IF_RSTBf_GET
#define UC_RST_CTL0r_MICRO_PRAM_IF_RSTBf_SET BCMI_TSCE16_XGXS_UC_RST_CTL0r_MICRO_PRAM_IF_RSTBf_SET
#define UC_RST_CTL0r_MICRO_CORE_RSTBf_GET BCMI_TSCE16_XGXS_UC_RST_CTL0r_MICRO_CORE_RSTBf_GET
#define UC_RST_CTL0r_MICRO_CORE_RSTBf_SET BCMI_TSCE16_XGXS_UC_RST_CTL0r_MICRO_CORE_RSTBf_SET
#define UC_RST_CTL0r_MICRO_MASTER_RSTBf_GET BCMI_TSCE16_XGXS_UC_RST_CTL0r_MICRO_MASTER_RSTBf_GET
#define UC_RST_CTL0r_MICRO_MASTER_RSTBf_SET BCMI_TSCE16_XGXS_UC_RST_CTL0r_MICRO_MASTER_RSTBf_SET
#define READ_UC_RST_CTL0r BCMI_TSCE16_XGXS_READ_UC_RST_CTL0r
#define WRITE_UC_RST_CTL0r BCMI_TSCE16_XGXS_WRITE_UC_RST_CTL0r
#define MODIFY_UC_RST_CTL0r BCMI_TSCE16_XGXS_MODIFY_UC_RST_CTL0r
#define READLN_UC_RST_CTL0r BCMI_TSCE16_XGXS_READLN_UC_RST_CTL0r
#define WRITELN_UC_RST_CTL0r BCMI_TSCE16_XGXS_WRITELN_UC_RST_CTL0r
#define WRITEALL_UC_RST_CTL0r BCMI_TSCE16_XGXS_WRITEALL_UC_RST_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_RST_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_AHB_CTL0
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd202
 * DESC:     rmi to ahb control registers 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_WRDATASIZE write data size select'd0 : 8-bit'd1 : 16-bit'd2 : 32-bit'd3 : reserved
 *     MICRO_RA_RDDATASIZE read data size select'd0 : 8-bit'd1 : 16-bit'd2 : 32-bit'd3 : reserved
 *     MICRO_RA_INIT    Intialize code/data RAM2'b01: initailize code RAM - write zeroes to all locations2'b10: initialize data RAM - write zeroes to all loactions2'b00, 2'b11: ignored
 *     MICRO_AUTOINC_WRADDR_EN Automatic increment write address enable0 - disabled, micro_ra_wraddr_lsw and micro_ra_wraddr_msw field specify the constant addresswhere the data from the micro_ra_wrdata_msw and micro_ra_wrdata_lsw is written.1 - enabled, micro_ra_wraddr_lsw and micro_ra_wraddr_msw field specify the start addresswhere the data from the micro_ra_wrdata_msw and micro_ra_wrdata_lsw is written.the address automatically increments based on the micro_ra_wrdatasize field afterthe write has been performed
 *     MICRO_AUTOINC_RDADDR_EN Automatic increment read address enable0 - disabled, micro_ra_rdaddr_lsw and micro_ra_rdaddr_msw field specify the constant addresswhere the data is read via the micro_ra_rddata_msw and micro_ra_rddata_lsw fileds1 - enabled, micro_ra_rdaddr_lsw and micro_ra_rdaddr_msw field specify the start addresswhere the data is read via the micro_ra_rddata_msw and micro_ra_rddata_lsw filedsthe address automatically increments based on the micro_ra_rddatasize field afterthe read has been performed
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_AHB_CTL0r (0x0000d202 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_AHB_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_CTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_AHB_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_ahb_ctl0[1];
	uint32_t _uc_ahb_ctl0;
} BCMI_TSCE16_XGXS_UC_AHB_CTL0r_t;

#define BCMI_TSCE16_XGXS_UC_AHB_CTL0r_CLR(r) (r).uc_ahb_ctl0[0] = 0
#define BCMI_TSCE16_XGXS_UC_AHB_CTL0r_SET(r,d) (r).uc_ahb_ctl0[0] = d
#define BCMI_TSCE16_XGXS_UC_AHB_CTL0r_GET(r) (r).uc_ahb_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_AHB_CTL0r_MICRO_AUTOINC_RDADDR_ENf_GET(r) ((((r).uc_ahb_ctl0[0]) >> 13) & 0x1)
#define BCMI_TSCE16_XGXS_UC_AHB_CTL0r_MICRO_AUTOINC_RDADDR_ENf_SET(r,f) (r).uc_ahb_ctl0[0]=(((r).uc_ahb_ctl0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCE16_XGXS_UC_AHB_CTL0r_MICRO_AUTOINC_WRADDR_ENf_GET(r) ((((r).uc_ahb_ctl0[0]) >> 12) & 0x1)
#define BCMI_TSCE16_XGXS_UC_AHB_CTL0r_MICRO_AUTOINC_WRADDR_ENf_SET(r,f) (r).uc_ahb_ctl0[0]=(((r).uc_ahb_ctl0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCE16_XGXS_UC_AHB_CTL0r_MICRO_RA_INITf_GET(r) ((((r).uc_ahb_ctl0[0]) >> 8) & 0x3)
#define BCMI_TSCE16_XGXS_UC_AHB_CTL0r_MICRO_RA_INITf_SET(r,f) (r).uc_ahb_ctl0[0]=(((r).uc_ahb_ctl0[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_TSCE16_XGXS_UC_AHB_CTL0r_MICRO_RA_RDDATASIZEf_GET(r) ((((r).uc_ahb_ctl0[0]) >> 4) & 0x3)
#define BCMI_TSCE16_XGXS_UC_AHB_CTL0r_MICRO_RA_RDDATASIZEf_SET(r,f) (r).uc_ahb_ctl0[0]=(((r).uc_ahb_ctl0[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCE16_XGXS_UC_AHB_CTL0r_MICRO_RA_WRDATASIZEf_GET(r) (((r).uc_ahb_ctl0[0]) & 0x3)
#define BCMI_TSCE16_XGXS_UC_AHB_CTL0r_MICRO_RA_WRDATASIZEf_SET(r,f) (r).uc_ahb_ctl0[0]=(((r).uc_ahb_ctl0[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access UC_AHB_CTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_AHB_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_AHB_CTL0r,(_r._uc_ahb_ctl0))
#define BCMI_TSCE16_XGXS_WRITE_UC_AHB_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_CTL0r,(_r._uc_ahb_ctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_AHB_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_CTL0r,(_r._uc_ahb_ctl0))
#define BCMI_TSCE16_XGXS_READLN_UC_AHB_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_AHB_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_ctl0))
#define BCMI_TSCE16_XGXS_WRITELN_UC_AHB_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_ctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_AHB_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_CTL0r BCMI_TSCE16_XGXS_UC_AHB_CTL0r
#define UC_AHB_CTL0r_SIZE BCMI_TSCE16_XGXS_UC_AHB_CTL0r_SIZE
typedef BCMI_TSCE16_XGXS_UC_AHB_CTL0r_t UC_AHB_CTL0r_t;
#define UC_AHB_CTL0r_CLR BCMI_TSCE16_XGXS_UC_AHB_CTL0r_CLR
#define UC_AHB_CTL0r_SET BCMI_TSCE16_XGXS_UC_AHB_CTL0r_SET
#define UC_AHB_CTL0r_GET BCMI_TSCE16_XGXS_UC_AHB_CTL0r_GET
#define UC_AHB_CTL0r_MICRO_AUTOINC_RDADDR_ENf_GET BCMI_TSCE16_XGXS_UC_AHB_CTL0r_MICRO_AUTOINC_RDADDR_ENf_GET
#define UC_AHB_CTL0r_MICRO_AUTOINC_RDADDR_ENf_SET BCMI_TSCE16_XGXS_UC_AHB_CTL0r_MICRO_AUTOINC_RDADDR_ENf_SET
#define UC_AHB_CTL0r_MICRO_AUTOINC_WRADDR_ENf_GET BCMI_TSCE16_XGXS_UC_AHB_CTL0r_MICRO_AUTOINC_WRADDR_ENf_GET
#define UC_AHB_CTL0r_MICRO_AUTOINC_WRADDR_ENf_SET BCMI_TSCE16_XGXS_UC_AHB_CTL0r_MICRO_AUTOINC_WRADDR_ENf_SET
#define UC_AHB_CTL0r_MICRO_RA_INITf_GET BCMI_TSCE16_XGXS_UC_AHB_CTL0r_MICRO_RA_INITf_GET
#define UC_AHB_CTL0r_MICRO_RA_INITf_SET BCMI_TSCE16_XGXS_UC_AHB_CTL0r_MICRO_RA_INITf_SET
#define UC_AHB_CTL0r_MICRO_RA_RDDATASIZEf_GET BCMI_TSCE16_XGXS_UC_AHB_CTL0r_MICRO_RA_RDDATASIZEf_GET
#define UC_AHB_CTL0r_MICRO_RA_RDDATASIZEf_SET BCMI_TSCE16_XGXS_UC_AHB_CTL0r_MICRO_RA_RDDATASIZEf_SET
#define UC_AHB_CTL0r_MICRO_RA_WRDATASIZEf_GET BCMI_TSCE16_XGXS_UC_AHB_CTL0r_MICRO_RA_WRDATASIZEf_GET
#define UC_AHB_CTL0r_MICRO_RA_WRDATASIZEf_SET BCMI_TSCE16_XGXS_UC_AHB_CTL0r_MICRO_RA_WRDATASIZEf_SET
#define READ_UC_AHB_CTL0r BCMI_TSCE16_XGXS_READ_UC_AHB_CTL0r
#define WRITE_UC_AHB_CTL0r BCMI_TSCE16_XGXS_WRITE_UC_AHB_CTL0r
#define MODIFY_UC_AHB_CTL0r BCMI_TSCE16_XGXS_MODIFY_UC_AHB_CTL0r
#define READLN_UC_AHB_CTL0r BCMI_TSCE16_XGXS_READLN_UC_AHB_CTL0r
#define WRITELN_UC_AHB_CTL0r BCMI_TSCE16_XGXS_WRITELN_UC_AHB_CTL0r
#define WRITEALL_UC_AHB_CTL0r BCMI_TSCE16_XGXS_WRITEALL_UC_AHB_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_AHB_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_AHB_STS0
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd203
 * DESC:     rmi to ahb status registers 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RA_INITDONE When this bit is set, it indicate that code/data RAM initialization process is completeThis reamins set until
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_AHB_STS0r (0x0000d203 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_AHB_STS0r_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_STS0.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_AHB_STS0r_s {
	uint32_t v[1];
	uint32_t uc_ahb_sts0[1];
	uint32_t _uc_ahb_sts0;
} BCMI_TSCE16_XGXS_UC_AHB_STS0r_t;

#define BCMI_TSCE16_XGXS_UC_AHB_STS0r_CLR(r) (r).uc_ahb_sts0[0] = 0
#define BCMI_TSCE16_XGXS_UC_AHB_STS0r_SET(r,d) (r).uc_ahb_sts0[0] = d
#define BCMI_TSCE16_XGXS_UC_AHB_STS0r_GET(r) (r).uc_ahb_sts0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_AHB_STS0r_MICRO_RA_INITDONEf_GET(r) (((r).uc_ahb_sts0[0]) & 0x1)
#define BCMI_TSCE16_XGXS_UC_AHB_STS0r_MICRO_RA_INITDONEf_SET(r,f) (r).uc_ahb_sts0[0]=(((r).uc_ahb_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_AHB_STS0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_AHB_STS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_AHB_STS0r,(_r._uc_ahb_sts0))
#define BCMI_TSCE16_XGXS_WRITE_UC_AHB_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_STS0r,(_r._uc_ahb_sts0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_AHB_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_STS0r,(_r._uc_ahb_sts0))
#define BCMI_TSCE16_XGXS_READLN_UC_AHB_STS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_AHB_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_sts0))
#define BCMI_TSCE16_XGXS_WRITELN_UC_AHB_STS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_sts0))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_AHB_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_STS0r BCMI_TSCE16_XGXS_UC_AHB_STS0r
#define UC_AHB_STS0r_SIZE BCMI_TSCE16_XGXS_UC_AHB_STS0r_SIZE
typedef BCMI_TSCE16_XGXS_UC_AHB_STS0r_t UC_AHB_STS0r_t;
#define UC_AHB_STS0r_CLR BCMI_TSCE16_XGXS_UC_AHB_STS0r_CLR
#define UC_AHB_STS0r_SET BCMI_TSCE16_XGXS_UC_AHB_STS0r_SET
#define UC_AHB_STS0r_GET BCMI_TSCE16_XGXS_UC_AHB_STS0r_GET
#define UC_AHB_STS0r_MICRO_RA_INITDONEf_GET BCMI_TSCE16_XGXS_UC_AHB_STS0r_MICRO_RA_INITDONEf_GET
#define UC_AHB_STS0r_MICRO_RA_INITDONEf_SET BCMI_TSCE16_XGXS_UC_AHB_STS0r_MICRO_RA_INITDONEf_SET
#define READ_UC_AHB_STS0r BCMI_TSCE16_XGXS_READ_UC_AHB_STS0r
#define WRITE_UC_AHB_STS0r BCMI_TSCE16_XGXS_WRITE_UC_AHB_STS0r
#define MODIFY_UC_AHB_STS0r BCMI_TSCE16_XGXS_MODIFY_UC_AHB_STS0r
#define READLN_UC_AHB_STS0r BCMI_TSCE16_XGXS_READLN_UC_AHB_STS0r
#define WRITELN_UC_AHB_STS0r BCMI_TSCE16_XGXS_WRITELN_UC_AHB_STS0r
#define WRITEALL_UC_AHB_STS0r BCMI_TSCE16_XGXS_WRITEALL_UC_AHB_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_AHB_STS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_AHB_WRADDR_LSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd204
 * DESC:     rmi to ahb write address LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_WRADDR_LSW These bits are used to generate the lower 16-bits of the address on the AHB-Lite bus during write transactionsbit 0 is not used during 16-bit transactions andbits[1:0] are not used during 32-bit transactions
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_AHB_WRADDR_LSWr (0x0000d204 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_AHB_WRADDR_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_WRADDR_LSW.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_AHB_WRADDR_LSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_wraddr_lsw[1];
	uint32_t _uc_ahb_wraddr_lsw;
} BCMI_TSCE16_XGXS_UC_AHB_WRADDR_LSWr_t;

#define BCMI_TSCE16_XGXS_UC_AHB_WRADDR_LSWr_CLR(r) (r).uc_ahb_wraddr_lsw[0] = 0
#define BCMI_TSCE16_XGXS_UC_AHB_WRADDR_LSWr_SET(r,d) (r).uc_ahb_wraddr_lsw[0] = d
#define BCMI_TSCE16_XGXS_UC_AHB_WRADDR_LSWr_GET(r) (r).uc_ahb_wraddr_lsw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_AHB_WRADDR_LSWr_MICRO_RA_WRADDR_LSWf_GET(r) (((r).uc_ahb_wraddr_lsw[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_UC_AHB_WRADDR_LSWr_MICRO_RA_WRADDR_LSWf_SET(r,f) (r).uc_ahb_wraddr_lsw[0]=(((r).uc_ahb_wraddr_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_WRADDR_LSW.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_AHB_WRADDR_LSWr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_AHB_WRADDR_LSWr,(_r._uc_ahb_wraddr_lsw))
#define BCMI_TSCE16_XGXS_WRITE_UC_AHB_WRADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_WRADDR_LSWr,(_r._uc_ahb_wraddr_lsw)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_AHB_WRADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_WRADDR_LSWr,(_r._uc_ahb_wraddr_lsw))
#define BCMI_TSCE16_XGXS_READLN_UC_AHB_WRADDR_LSWr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_AHB_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_wraddr_lsw))
#define BCMI_TSCE16_XGXS_WRITELN_UC_AHB_WRADDR_LSWr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_wraddr_lsw))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_AHB_WRADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_wraddr_lsw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_WRADDR_LSWr BCMI_TSCE16_XGXS_UC_AHB_WRADDR_LSWr
#define UC_AHB_WRADDR_LSWr_SIZE BCMI_TSCE16_XGXS_UC_AHB_WRADDR_LSWr_SIZE
typedef BCMI_TSCE16_XGXS_UC_AHB_WRADDR_LSWr_t UC_AHB_WRADDR_LSWr_t;
#define UC_AHB_WRADDR_LSWr_CLR BCMI_TSCE16_XGXS_UC_AHB_WRADDR_LSWr_CLR
#define UC_AHB_WRADDR_LSWr_SET BCMI_TSCE16_XGXS_UC_AHB_WRADDR_LSWr_SET
#define UC_AHB_WRADDR_LSWr_GET BCMI_TSCE16_XGXS_UC_AHB_WRADDR_LSWr_GET
#define UC_AHB_WRADDR_LSWr_MICRO_RA_WRADDR_LSWf_GET BCMI_TSCE16_XGXS_UC_AHB_WRADDR_LSWr_MICRO_RA_WRADDR_LSWf_GET
#define UC_AHB_WRADDR_LSWr_MICRO_RA_WRADDR_LSWf_SET BCMI_TSCE16_XGXS_UC_AHB_WRADDR_LSWr_MICRO_RA_WRADDR_LSWf_SET
#define READ_UC_AHB_WRADDR_LSWr BCMI_TSCE16_XGXS_READ_UC_AHB_WRADDR_LSWr
#define WRITE_UC_AHB_WRADDR_LSWr BCMI_TSCE16_XGXS_WRITE_UC_AHB_WRADDR_LSWr
#define MODIFY_UC_AHB_WRADDR_LSWr BCMI_TSCE16_XGXS_MODIFY_UC_AHB_WRADDR_LSWr
#define READLN_UC_AHB_WRADDR_LSWr BCMI_TSCE16_XGXS_READLN_UC_AHB_WRADDR_LSWr
#define WRITELN_UC_AHB_WRADDR_LSWr BCMI_TSCE16_XGXS_WRITELN_UC_AHB_WRADDR_LSWr
#define WRITEALL_UC_AHB_WRADDR_LSWr BCMI_TSCE16_XGXS_WRITEALL_UC_AHB_WRADDR_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_AHB_WRADDR_LSWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_AHB_WRADDR_MSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd205
 * DESC:     rmi to ahb write address MSW (bits 31:16) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_WRADDR_MSW These bits are used to generate the upper 16-bits of the address on the AHB-Lite bus during write transactions
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_AHB_WRADDR_MSWr (0x0000d205 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_AHB_WRADDR_MSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_WRADDR_MSW.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_AHB_WRADDR_MSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_wraddr_msw[1];
	uint32_t _uc_ahb_wraddr_msw;
} BCMI_TSCE16_XGXS_UC_AHB_WRADDR_MSWr_t;

#define BCMI_TSCE16_XGXS_UC_AHB_WRADDR_MSWr_CLR(r) (r).uc_ahb_wraddr_msw[0] = 0
#define BCMI_TSCE16_XGXS_UC_AHB_WRADDR_MSWr_SET(r,d) (r).uc_ahb_wraddr_msw[0] = d
#define BCMI_TSCE16_XGXS_UC_AHB_WRADDR_MSWr_GET(r) (r).uc_ahb_wraddr_msw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_AHB_WRADDR_MSWr_MICRO_RA_WRADDR_MSWf_GET(r) (((r).uc_ahb_wraddr_msw[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_UC_AHB_WRADDR_MSWr_MICRO_RA_WRADDR_MSWf_SET(r,f) (r).uc_ahb_wraddr_msw[0]=(((r).uc_ahb_wraddr_msw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_WRADDR_MSW.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_AHB_WRADDR_MSWr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_AHB_WRADDR_MSWr,(_r._uc_ahb_wraddr_msw))
#define BCMI_TSCE16_XGXS_WRITE_UC_AHB_WRADDR_MSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_WRADDR_MSWr,(_r._uc_ahb_wraddr_msw)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_AHB_WRADDR_MSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_WRADDR_MSWr,(_r._uc_ahb_wraddr_msw))
#define BCMI_TSCE16_XGXS_READLN_UC_AHB_WRADDR_MSWr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_AHB_WRADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_wraddr_msw))
#define BCMI_TSCE16_XGXS_WRITELN_UC_AHB_WRADDR_MSWr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_WRADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_wraddr_msw))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_AHB_WRADDR_MSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_WRADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_wraddr_msw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_WRADDR_MSWr BCMI_TSCE16_XGXS_UC_AHB_WRADDR_MSWr
#define UC_AHB_WRADDR_MSWr_SIZE BCMI_TSCE16_XGXS_UC_AHB_WRADDR_MSWr_SIZE
typedef BCMI_TSCE16_XGXS_UC_AHB_WRADDR_MSWr_t UC_AHB_WRADDR_MSWr_t;
#define UC_AHB_WRADDR_MSWr_CLR BCMI_TSCE16_XGXS_UC_AHB_WRADDR_MSWr_CLR
#define UC_AHB_WRADDR_MSWr_SET BCMI_TSCE16_XGXS_UC_AHB_WRADDR_MSWr_SET
#define UC_AHB_WRADDR_MSWr_GET BCMI_TSCE16_XGXS_UC_AHB_WRADDR_MSWr_GET
#define UC_AHB_WRADDR_MSWr_MICRO_RA_WRADDR_MSWf_GET BCMI_TSCE16_XGXS_UC_AHB_WRADDR_MSWr_MICRO_RA_WRADDR_MSWf_GET
#define UC_AHB_WRADDR_MSWr_MICRO_RA_WRADDR_MSWf_SET BCMI_TSCE16_XGXS_UC_AHB_WRADDR_MSWr_MICRO_RA_WRADDR_MSWf_SET
#define READ_UC_AHB_WRADDR_MSWr BCMI_TSCE16_XGXS_READ_UC_AHB_WRADDR_MSWr
#define WRITE_UC_AHB_WRADDR_MSWr BCMI_TSCE16_XGXS_WRITE_UC_AHB_WRADDR_MSWr
#define MODIFY_UC_AHB_WRADDR_MSWr BCMI_TSCE16_XGXS_MODIFY_UC_AHB_WRADDR_MSWr
#define READLN_UC_AHB_WRADDR_MSWr BCMI_TSCE16_XGXS_READLN_UC_AHB_WRADDR_MSWr
#define WRITELN_UC_AHB_WRADDR_MSWr BCMI_TSCE16_XGXS_WRITELN_UC_AHB_WRADDR_MSWr
#define WRITEALL_UC_AHB_WRADDR_MSWr BCMI_TSCE16_XGXS_WRITEALL_UC_AHB_WRADDR_MSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_AHB_WRADDR_MSWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_AHB_WRDATA_LSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd206
 * DESC:     rmi to ahb write data LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_WRDATA_LSW These bits are used to generate the lower 16-bits of the data on the AHB-Lite bus during write transactionsWrite transaction on the AHB-Lite is initiated when this register is written
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_AHB_WRDATA_LSWr (0x0000d206 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_AHB_WRDATA_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_WRDATA_LSW.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_AHB_WRDATA_LSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_wrdata_lsw[1];
	uint32_t _uc_ahb_wrdata_lsw;
} BCMI_TSCE16_XGXS_UC_AHB_WRDATA_LSWr_t;

#define BCMI_TSCE16_XGXS_UC_AHB_WRDATA_LSWr_CLR(r) (r).uc_ahb_wrdata_lsw[0] = 0
#define BCMI_TSCE16_XGXS_UC_AHB_WRDATA_LSWr_SET(r,d) (r).uc_ahb_wrdata_lsw[0] = d
#define BCMI_TSCE16_XGXS_UC_AHB_WRDATA_LSWr_GET(r) (r).uc_ahb_wrdata_lsw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_AHB_WRDATA_LSWr_MICRO_RA_WRDATA_LSWf_GET(r) (((r).uc_ahb_wrdata_lsw[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_UC_AHB_WRDATA_LSWr_MICRO_RA_WRDATA_LSWf_SET(r,f) (r).uc_ahb_wrdata_lsw[0]=(((r).uc_ahb_wrdata_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_WRDATA_LSW.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_AHB_WRDATA_LSWr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_AHB_WRDATA_LSWr,(_r._uc_ahb_wrdata_lsw))
#define BCMI_TSCE16_XGXS_WRITE_UC_AHB_WRDATA_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_WRDATA_LSWr,(_r._uc_ahb_wrdata_lsw)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_AHB_WRDATA_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_WRDATA_LSWr,(_r._uc_ahb_wrdata_lsw))
#define BCMI_TSCE16_XGXS_READLN_UC_AHB_WRDATA_LSWr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_AHB_WRDATA_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_wrdata_lsw))
#define BCMI_TSCE16_XGXS_WRITELN_UC_AHB_WRDATA_LSWr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_WRDATA_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_wrdata_lsw))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_AHB_WRDATA_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_WRDATA_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_wrdata_lsw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_WRDATA_LSWr BCMI_TSCE16_XGXS_UC_AHB_WRDATA_LSWr
#define UC_AHB_WRDATA_LSWr_SIZE BCMI_TSCE16_XGXS_UC_AHB_WRDATA_LSWr_SIZE
typedef BCMI_TSCE16_XGXS_UC_AHB_WRDATA_LSWr_t UC_AHB_WRDATA_LSWr_t;
#define UC_AHB_WRDATA_LSWr_CLR BCMI_TSCE16_XGXS_UC_AHB_WRDATA_LSWr_CLR
#define UC_AHB_WRDATA_LSWr_SET BCMI_TSCE16_XGXS_UC_AHB_WRDATA_LSWr_SET
#define UC_AHB_WRDATA_LSWr_GET BCMI_TSCE16_XGXS_UC_AHB_WRDATA_LSWr_GET
#define UC_AHB_WRDATA_LSWr_MICRO_RA_WRDATA_LSWf_GET BCMI_TSCE16_XGXS_UC_AHB_WRDATA_LSWr_MICRO_RA_WRDATA_LSWf_GET
#define UC_AHB_WRDATA_LSWr_MICRO_RA_WRDATA_LSWf_SET BCMI_TSCE16_XGXS_UC_AHB_WRDATA_LSWr_MICRO_RA_WRDATA_LSWf_SET
#define READ_UC_AHB_WRDATA_LSWr BCMI_TSCE16_XGXS_READ_UC_AHB_WRDATA_LSWr
#define WRITE_UC_AHB_WRDATA_LSWr BCMI_TSCE16_XGXS_WRITE_UC_AHB_WRDATA_LSWr
#define MODIFY_UC_AHB_WRDATA_LSWr BCMI_TSCE16_XGXS_MODIFY_UC_AHB_WRDATA_LSWr
#define READLN_UC_AHB_WRDATA_LSWr BCMI_TSCE16_XGXS_READLN_UC_AHB_WRDATA_LSWr
#define WRITELN_UC_AHB_WRDATA_LSWr BCMI_TSCE16_XGXS_WRITELN_UC_AHB_WRDATA_LSWr
#define WRITEALL_UC_AHB_WRDATA_LSWr BCMI_TSCE16_XGXS_WRITEALL_UC_AHB_WRDATA_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_AHB_WRDATA_LSWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_AHB_WRDATA_MSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd207
 * DESC:     rmi to ahb write data MSW (bits 31:16) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_WRDATA_MSW These bits are used  to generate the upper 16-bits of the data on the AHB-Lite bus during write transactions
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_AHB_WRDATA_MSWr (0x0000d207 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_AHB_WRDATA_MSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_WRDATA_MSW.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_AHB_WRDATA_MSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_wrdata_msw[1];
	uint32_t _uc_ahb_wrdata_msw;
} BCMI_TSCE16_XGXS_UC_AHB_WRDATA_MSWr_t;

#define BCMI_TSCE16_XGXS_UC_AHB_WRDATA_MSWr_CLR(r) (r).uc_ahb_wrdata_msw[0] = 0
#define BCMI_TSCE16_XGXS_UC_AHB_WRDATA_MSWr_SET(r,d) (r).uc_ahb_wrdata_msw[0] = d
#define BCMI_TSCE16_XGXS_UC_AHB_WRDATA_MSWr_GET(r) (r).uc_ahb_wrdata_msw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_AHB_WRDATA_MSWr_MICRO_RA_WRDATA_MSWf_GET(r) (((r).uc_ahb_wrdata_msw[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_UC_AHB_WRDATA_MSWr_MICRO_RA_WRDATA_MSWf_SET(r,f) (r).uc_ahb_wrdata_msw[0]=(((r).uc_ahb_wrdata_msw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_WRDATA_MSW.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_AHB_WRDATA_MSWr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_AHB_WRDATA_MSWr,(_r._uc_ahb_wrdata_msw))
#define BCMI_TSCE16_XGXS_WRITE_UC_AHB_WRDATA_MSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_WRDATA_MSWr,(_r._uc_ahb_wrdata_msw)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_AHB_WRDATA_MSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_WRDATA_MSWr,(_r._uc_ahb_wrdata_msw))
#define BCMI_TSCE16_XGXS_READLN_UC_AHB_WRDATA_MSWr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_AHB_WRDATA_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_wrdata_msw))
#define BCMI_TSCE16_XGXS_WRITELN_UC_AHB_WRDATA_MSWr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_WRDATA_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_wrdata_msw))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_AHB_WRDATA_MSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_WRDATA_MSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_wrdata_msw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_WRDATA_MSWr BCMI_TSCE16_XGXS_UC_AHB_WRDATA_MSWr
#define UC_AHB_WRDATA_MSWr_SIZE BCMI_TSCE16_XGXS_UC_AHB_WRDATA_MSWr_SIZE
typedef BCMI_TSCE16_XGXS_UC_AHB_WRDATA_MSWr_t UC_AHB_WRDATA_MSWr_t;
#define UC_AHB_WRDATA_MSWr_CLR BCMI_TSCE16_XGXS_UC_AHB_WRDATA_MSWr_CLR
#define UC_AHB_WRDATA_MSWr_SET BCMI_TSCE16_XGXS_UC_AHB_WRDATA_MSWr_SET
#define UC_AHB_WRDATA_MSWr_GET BCMI_TSCE16_XGXS_UC_AHB_WRDATA_MSWr_GET
#define UC_AHB_WRDATA_MSWr_MICRO_RA_WRDATA_MSWf_GET BCMI_TSCE16_XGXS_UC_AHB_WRDATA_MSWr_MICRO_RA_WRDATA_MSWf_GET
#define UC_AHB_WRDATA_MSWr_MICRO_RA_WRDATA_MSWf_SET BCMI_TSCE16_XGXS_UC_AHB_WRDATA_MSWr_MICRO_RA_WRDATA_MSWf_SET
#define READ_UC_AHB_WRDATA_MSWr BCMI_TSCE16_XGXS_READ_UC_AHB_WRDATA_MSWr
#define WRITE_UC_AHB_WRDATA_MSWr BCMI_TSCE16_XGXS_WRITE_UC_AHB_WRDATA_MSWr
#define MODIFY_UC_AHB_WRDATA_MSWr BCMI_TSCE16_XGXS_MODIFY_UC_AHB_WRDATA_MSWr
#define READLN_UC_AHB_WRDATA_MSWr BCMI_TSCE16_XGXS_READLN_UC_AHB_WRDATA_MSWr
#define WRITELN_UC_AHB_WRDATA_MSWr BCMI_TSCE16_XGXS_WRITELN_UC_AHB_WRDATA_MSWr
#define WRITEALL_UC_AHB_WRDATA_MSWr BCMI_TSCE16_XGXS_WRITEALL_UC_AHB_WRDATA_MSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_AHB_WRDATA_MSWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_AHB_RDADDR_LSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd208
 * DESC:     rmi to ahb read address LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_RDADDR_LSW These bits are used to generate the lower 16-bits of the address on the AHB-Lite bus during read transactionsbit 0 is not used during 16-bit transactions andbits[1:0] are not used during 32-bit transactionsRead transaction is initiated on the AHB-Lite when this register is written
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_AHB_RDADDR_LSWr (0x0000d208 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_AHB_RDADDR_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_RDADDR_LSW.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_AHB_RDADDR_LSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_rdaddr_lsw[1];
	uint32_t _uc_ahb_rdaddr_lsw;
} BCMI_TSCE16_XGXS_UC_AHB_RDADDR_LSWr_t;

#define BCMI_TSCE16_XGXS_UC_AHB_RDADDR_LSWr_CLR(r) (r).uc_ahb_rdaddr_lsw[0] = 0
#define BCMI_TSCE16_XGXS_UC_AHB_RDADDR_LSWr_SET(r,d) (r).uc_ahb_rdaddr_lsw[0] = d
#define BCMI_TSCE16_XGXS_UC_AHB_RDADDR_LSWr_GET(r) (r).uc_ahb_rdaddr_lsw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_AHB_RDADDR_LSWr_MICRO_RA_RDADDR_LSWf_GET(r) (((r).uc_ahb_rdaddr_lsw[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_UC_AHB_RDADDR_LSWr_MICRO_RA_RDADDR_LSWf_SET(r,f) (r).uc_ahb_rdaddr_lsw[0]=(((r).uc_ahb_rdaddr_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_RDADDR_LSW.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_AHB_RDADDR_LSWr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_AHB_RDADDR_LSWr,(_r._uc_ahb_rdaddr_lsw))
#define BCMI_TSCE16_XGXS_WRITE_UC_AHB_RDADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_RDADDR_LSWr,(_r._uc_ahb_rdaddr_lsw)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_AHB_RDADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_RDADDR_LSWr,(_r._uc_ahb_rdaddr_lsw))
#define BCMI_TSCE16_XGXS_READLN_UC_AHB_RDADDR_LSWr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_AHB_RDADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_rdaddr_lsw))
#define BCMI_TSCE16_XGXS_WRITELN_UC_AHB_RDADDR_LSWr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_RDADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_rdaddr_lsw))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_AHB_RDADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_RDADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_rdaddr_lsw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_RDADDR_LSWr BCMI_TSCE16_XGXS_UC_AHB_RDADDR_LSWr
#define UC_AHB_RDADDR_LSWr_SIZE BCMI_TSCE16_XGXS_UC_AHB_RDADDR_LSWr_SIZE
typedef BCMI_TSCE16_XGXS_UC_AHB_RDADDR_LSWr_t UC_AHB_RDADDR_LSWr_t;
#define UC_AHB_RDADDR_LSWr_CLR BCMI_TSCE16_XGXS_UC_AHB_RDADDR_LSWr_CLR
#define UC_AHB_RDADDR_LSWr_SET BCMI_TSCE16_XGXS_UC_AHB_RDADDR_LSWr_SET
#define UC_AHB_RDADDR_LSWr_GET BCMI_TSCE16_XGXS_UC_AHB_RDADDR_LSWr_GET
#define UC_AHB_RDADDR_LSWr_MICRO_RA_RDADDR_LSWf_GET BCMI_TSCE16_XGXS_UC_AHB_RDADDR_LSWr_MICRO_RA_RDADDR_LSWf_GET
#define UC_AHB_RDADDR_LSWr_MICRO_RA_RDADDR_LSWf_SET BCMI_TSCE16_XGXS_UC_AHB_RDADDR_LSWr_MICRO_RA_RDADDR_LSWf_SET
#define READ_UC_AHB_RDADDR_LSWr BCMI_TSCE16_XGXS_READ_UC_AHB_RDADDR_LSWr
#define WRITE_UC_AHB_RDADDR_LSWr BCMI_TSCE16_XGXS_WRITE_UC_AHB_RDADDR_LSWr
#define MODIFY_UC_AHB_RDADDR_LSWr BCMI_TSCE16_XGXS_MODIFY_UC_AHB_RDADDR_LSWr
#define READLN_UC_AHB_RDADDR_LSWr BCMI_TSCE16_XGXS_READLN_UC_AHB_RDADDR_LSWr
#define WRITELN_UC_AHB_RDADDR_LSWr BCMI_TSCE16_XGXS_WRITELN_UC_AHB_RDADDR_LSWr
#define WRITEALL_UC_AHB_RDADDR_LSWr BCMI_TSCE16_XGXS_WRITEALL_UC_AHB_RDADDR_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_AHB_RDADDR_LSWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_AHB_RDADDR_MSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd209
 * DESC:     rmi to ahb read address MSW (bits 31:16) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_RDADDR_MSW These bits are used by to generate the upper 16-bits of the address on the AHB-Lite bus during read transactions
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_AHB_RDADDR_MSWr (0x0000d209 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_AHB_RDADDR_MSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_RDADDR_MSW.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_AHB_RDADDR_MSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_rdaddr_msw[1];
	uint32_t _uc_ahb_rdaddr_msw;
} BCMI_TSCE16_XGXS_UC_AHB_RDADDR_MSWr_t;

#define BCMI_TSCE16_XGXS_UC_AHB_RDADDR_MSWr_CLR(r) (r).uc_ahb_rdaddr_msw[0] = 0
#define BCMI_TSCE16_XGXS_UC_AHB_RDADDR_MSWr_SET(r,d) (r).uc_ahb_rdaddr_msw[0] = d
#define BCMI_TSCE16_XGXS_UC_AHB_RDADDR_MSWr_GET(r) (r).uc_ahb_rdaddr_msw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_AHB_RDADDR_MSWr_MICRO_RA_RDADDR_MSWf_GET(r) (((r).uc_ahb_rdaddr_msw[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_UC_AHB_RDADDR_MSWr_MICRO_RA_RDADDR_MSWf_SET(r,f) (r).uc_ahb_rdaddr_msw[0]=(((r).uc_ahb_rdaddr_msw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_RDADDR_MSW.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_AHB_RDADDR_MSWr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_AHB_RDADDR_MSWr,(_r._uc_ahb_rdaddr_msw))
#define BCMI_TSCE16_XGXS_WRITE_UC_AHB_RDADDR_MSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_RDADDR_MSWr,(_r._uc_ahb_rdaddr_msw)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_AHB_RDADDR_MSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_RDADDR_MSWr,(_r._uc_ahb_rdaddr_msw))
#define BCMI_TSCE16_XGXS_READLN_UC_AHB_RDADDR_MSWr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_AHB_RDADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_rdaddr_msw))
#define BCMI_TSCE16_XGXS_WRITELN_UC_AHB_RDADDR_MSWr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_RDADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_rdaddr_msw))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_AHB_RDADDR_MSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_RDADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_rdaddr_msw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_RDADDR_MSWr BCMI_TSCE16_XGXS_UC_AHB_RDADDR_MSWr
#define UC_AHB_RDADDR_MSWr_SIZE BCMI_TSCE16_XGXS_UC_AHB_RDADDR_MSWr_SIZE
typedef BCMI_TSCE16_XGXS_UC_AHB_RDADDR_MSWr_t UC_AHB_RDADDR_MSWr_t;
#define UC_AHB_RDADDR_MSWr_CLR BCMI_TSCE16_XGXS_UC_AHB_RDADDR_MSWr_CLR
#define UC_AHB_RDADDR_MSWr_SET BCMI_TSCE16_XGXS_UC_AHB_RDADDR_MSWr_SET
#define UC_AHB_RDADDR_MSWr_GET BCMI_TSCE16_XGXS_UC_AHB_RDADDR_MSWr_GET
#define UC_AHB_RDADDR_MSWr_MICRO_RA_RDADDR_MSWf_GET BCMI_TSCE16_XGXS_UC_AHB_RDADDR_MSWr_MICRO_RA_RDADDR_MSWf_GET
#define UC_AHB_RDADDR_MSWr_MICRO_RA_RDADDR_MSWf_SET BCMI_TSCE16_XGXS_UC_AHB_RDADDR_MSWr_MICRO_RA_RDADDR_MSWf_SET
#define READ_UC_AHB_RDADDR_MSWr BCMI_TSCE16_XGXS_READ_UC_AHB_RDADDR_MSWr
#define WRITE_UC_AHB_RDADDR_MSWr BCMI_TSCE16_XGXS_WRITE_UC_AHB_RDADDR_MSWr
#define MODIFY_UC_AHB_RDADDR_MSWr BCMI_TSCE16_XGXS_MODIFY_UC_AHB_RDADDR_MSWr
#define READLN_UC_AHB_RDADDR_MSWr BCMI_TSCE16_XGXS_READLN_UC_AHB_RDADDR_MSWr
#define WRITELN_UC_AHB_RDADDR_MSWr BCMI_TSCE16_XGXS_WRITELN_UC_AHB_RDADDR_MSWr
#define WRITEALL_UC_AHB_RDADDR_MSWr BCMI_TSCE16_XGXS_WRITEALL_UC_AHB_RDADDR_MSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_AHB_RDADDR_MSWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_AHB_RDDATA_LSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd20a
 * DESC:     rmi to ahb read data LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RA_RDDATA_LSW These are the lower 16-bits of the read data from the AHB-Lite slave deviceRead transaction is initiated on the AHB-Lite when this register is read
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_AHB_RDDATA_LSWr (0x0000d20a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_AHB_RDDATA_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_RDDATA_LSW.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_AHB_RDDATA_LSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_rddata_lsw[1];
	uint32_t _uc_ahb_rddata_lsw;
} BCMI_TSCE16_XGXS_UC_AHB_RDDATA_LSWr_t;

#define BCMI_TSCE16_XGXS_UC_AHB_RDDATA_LSWr_CLR(r) (r).uc_ahb_rddata_lsw[0] = 0
#define BCMI_TSCE16_XGXS_UC_AHB_RDDATA_LSWr_SET(r,d) (r).uc_ahb_rddata_lsw[0] = d
#define BCMI_TSCE16_XGXS_UC_AHB_RDDATA_LSWr_GET(r) (r).uc_ahb_rddata_lsw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_AHB_RDDATA_LSWr_MICRO_RA_RDDATA_LSWf_GET(r) (((r).uc_ahb_rddata_lsw[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_UC_AHB_RDDATA_LSWr_MICRO_RA_RDDATA_LSWf_SET(r,f) (r).uc_ahb_rddata_lsw[0]=(((r).uc_ahb_rddata_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_RDDATA_LSW.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_AHB_RDDATA_LSWr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_AHB_RDDATA_LSWr,(_r._uc_ahb_rddata_lsw))
#define BCMI_TSCE16_XGXS_WRITE_UC_AHB_RDDATA_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_RDDATA_LSWr,(_r._uc_ahb_rddata_lsw)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_AHB_RDDATA_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_RDDATA_LSWr,(_r._uc_ahb_rddata_lsw))
#define BCMI_TSCE16_XGXS_READLN_UC_AHB_RDDATA_LSWr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_AHB_RDDATA_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_rddata_lsw))
#define BCMI_TSCE16_XGXS_WRITELN_UC_AHB_RDDATA_LSWr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_RDDATA_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_rddata_lsw))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_AHB_RDDATA_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_RDDATA_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_rddata_lsw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_RDDATA_LSWr BCMI_TSCE16_XGXS_UC_AHB_RDDATA_LSWr
#define UC_AHB_RDDATA_LSWr_SIZE BCMI_TSCE16_XGXS_UC_AHB_RDDATA_LSWr_SIZE
typedef BCMI_TSCE16_XGXS_UC_AHB_RDDATA_LSWr_t UC_AHB_RDDATA_LSWr_t;
#define UC_AHB_RDDATA_LSWr_CLR BCMI_TSCE16_XGXS_UC_AHB_RDDATA_LSWr_CLR
#define UC_AHB_RDDATA_LSWr_SET BCMI_TSCE16_XGXS_UC_AHB_RDDATA_LSWr_SET
#define UC_AHB_RDDATA_LSWr_GET BCMI_TSCE16_XGXS_UC_AHB_RDDATA_LSWr_GET
#define UC_AHB_RDDATA_LSWr_MICRO_RA_RDDATA_LSWf_GET BCMI_TSCE16_XGXS_UC_AHB_RDDATA_LSWr_MICRO_RA_RDDATA_LSWf_GET
#define UC_AHB_RDDATA_LSWr_MICRO_RA_RDDATA_LSWf_SET BCMI_TSCE16_XGXS_UC_AHB_RDDATA_LSWr_MICRO_RA_RDDATA_LSWf_SET
#define READ_UC_AHB_RDDATA_LSWr BCMI_TSCE16_XGXS_READ_UC_AHB_RDDATA_LSWr
#define WRITE_UC_AHB_RDDATA_LSWr BCMI_TSCE16_XGXS_WRITE_UC_AHB_RDDATA_LSWr
#define MODIFY_UC_AHB_RDDATA_LSWr BCMI_TSCE16_XGXS_MODIFY_UC_AHB_RDDATA_LSWr
#define READLN_UC_AHB_RDDATA_LSWr BCMI_TSCE16_XGXS_READLN_UC_AHB_RDDATA_LSWr
#define WRITELN_UC_AHB_RDDATA_LSWr BCMI_TSCE16_XGXS_WRITELN_UC_AHB_RDDATA_LSWr
#define WRITEALL_UC_AHB_RDDATA_LSWr BCMI_TSCE16_XGXS_WRITEALL_UC_AHB_RDDATA_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_AHB_RDDATA_LSWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_AHB_RDDATA_MSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd20b
 * DESC:     rmi to ahb read data MSW (bits 31:16) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RA_RDDATA_MSW These are the upper 16-bits of the read data from the AHB-Lite slave device
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_AHB_RDDATA_MSWr (0x0000d20b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_AHB_RDDATA_MSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_RDDATA_MSW.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_AHB_RDDATA_MSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_rddata_msw[1];
	uint32_t _uc_ahb_rddata_msw;
} BCMI_TSCE16_XGXS_UC_AHB_RDDATA_MSWr_t;

#define BCMI_TSCE16_XGXS_UC_AHB_RDDATA_MSWr_CLR(r) (r).uc_ahb_rddata_msw[0] = 0
#define BCMI_TSCE16_XGXS_UC_AHB_RDDATA_MSWr_SET(r,d) (r).uc_ahb_rddata_msw[0] = d
#define BCMI_TSCE16_XGXS_UC_AHB_RDDATA_MSWr_GET(r) (r).uc_ahb_rddata_msw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_AHB_RDDATA_MSWr_MICRO_RA_RDDATA_MSWf_GET(r) (((r).uc_ahb_rddata_msw[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_UC_AHB_RDDATA_MSWr_MICRO_RA_RDDATA_MSWf_SET(r,f) (r).uc_ahb_rddata_msw[0]=(((r).uc_ahb_rddata_msw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_RDDATA_MSW.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_AHB_RDDATA_MSWr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_AHB_RDDATA_MSWr,(_r._uc_ahb_rddata_msw))
#define BCMI_TSCE16_XGXS_WRITE_UC_AHB_RDDATA_MSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_RDDATA_MSWr,(_r._uc_ahb_rddata_msw)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_AHB_RDDATA_MSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_RDDATA_MSWr,(_r._uc_ahb_rddata_msw))
#define BCMI_TSCE16_XGXS_READLN_UC_AHB_RDDATA_MSWr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_AHB_RDDATA_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_rddata_msw))
#define BCMI_TSCE16_XGXS_WRITELN_UC_AHB_RDDATA_MSWr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_RDDATA_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_rddata_msw))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_AHB_RDDATA_MSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_AHB_RDDATA_MSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_rddata_msw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_RDDATA_MSWr BCMI_TSCE16_XGXS_UC_AHB_RDDATA_MSWr
#define UC_AHB_RDDATA_MSWr_SIZE BCMI_TSCE16_XGXS_UC_AHB_RDDATA_MSWr_SIZE
typedef BCMI_TSCE16_XGXS_UC_AHB_RDDATA_MSWr_t UC_AHB_RDDATA_MSWr_t;
#define UC_AHB_RDDATA_MSWr_CLR BCMI_TSCE16_XGXS_UC_AHB_RDDATA_MSWr_CLR
#define UC_AHB_RDDATA_MSWr_SET BCMI_TSCE16_XGXS_UC_AHB_RDDATA_MSWr_SET
#define UC_AHB_RDDATA_MSWr_GET BCMI_TSCE16_XGXS_UC_AHB_RDDATA_MSWr_GET
#define UC_AHB_RDDATA_MSWr_MICRO_RA_RDDATA_MSWf_GET BCMI_TSCE16_XGXS_UC_AHB_RDDATA_MSWr_MICRO_RA_RDDATA_MSWf_GET
#define UC_AHB_RDDATA_MSWr_MICRO_RA_RDDATA_MSWf_SET BCMI_TSCE16_XGXS_UC_AHB_RDDATA_MSWr_MICRO_RA_RDDATA_MSWf_SET
#define READ_UC_AHB_RDDATA_MSWr BCMI_TSCE16_XGXS_READ_UC_AHB_RDDATA_MSWr
#define WRITE_UC_AHB_RDDATA_MSWr BCMI_TSCE16_XGXS_WRITE_UC_AHB_RDDATA_MSWr
#define MODIFY_UC_AHB_RDDATA_MSWr BCMI_TSCE16_XGXS_MODIFY_UC_AHB_RDDATA_MSWr
#define READLN_UC_AHB_RDDATA_MSWr BCMI_TSCE16_XGXS_READLN_UC_AHB_RDDATA_MSWr
#define WRITELN_UC_AHB_RDDATA_MSWr BCMI_TSCE16_XGXS_WRITELN_UC_AHB_RDDATA_MSWr
#define WRITEALL_UC_AHB_RDDATA_MSWr BCMI_TSCE16_XGXS_WRITEALL_UC_AHB_RDDATA_MSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_AHB_RDDATA_MSWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_PRAMIF_CTL0
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd20c
 * DESC:     pram i/f to ahb control registers 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_PRAMIF_EN  When this bit is set, pram if interface can generate write transactions on theAHB-Lite bus, the start address of the transaction is specifieldin the pramif_ahb_wraddr_lsw and pramif_ahb_wraddr_msw fields
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_PRAMIF_CTL0r (0x0000d20c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_PRAMIF_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_PRAMIF_CTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_PRAMIF_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_pramif_ctl0[1];
	uint32_t _uc_pramif_ctl0;
} BCMI_TSCE16_XGXS_UC_PRAMIF_CTL0r_t;

#define BCMI_TSCE16_XGXS_UC_PRAMIF_CTL0r_CLR(r) (r).uc_pramif_ctl0[0] = 0
#define BCMI_TSCE16_XGXS_UC_PRAMIF_CTL0r_SET(r,d) (r).uc_pramif_ctl0[0] = d
#define BCMI_TSCE16_XGXS_UC_PRAMIF_CTL0r_GET(r) (r).uc_pramif_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_PRAMIF_CTL0r_MICRO_PRAMIF_ENf_GET(r) (((r).uc_pramif_ctl0[0]) & 0x1)
#define BCMI_TSCE16_XGXS_UC_PRAMIF_CTL0r_MICRO_PRAMIF_ENf_SET(r,f) (r).uc_pramif_ctl0[0]=(((r).uc_pramif_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_PRAMIF_CTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_PRAMIF_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_PRAMIF_CTL0r,(_r._uc_pramif_ctl0))
#define BCMI_TSCE16_XGXS_WRITE_UC_PRAMIF_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_PRAMIF_CTL0r,(_r._uc_pramif_ctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_PRAMIF_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_PRAMIF_CTL0r,(_r._uc_pramif_ctl0))
#define BCMI_TSCE16_XGXS_READLN_UC_PRAMIF_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_PRAMIF_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_pramif_ctl0))
#define BCMI_TSCE16_XGXS_WRITELN_UC_PRAMIF_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_PRAMIF_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_pramif_ctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_PRAMIF_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_PRAMIF_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_pramif_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_PRAMIF_CTL0r BCMI_TSCE16_XGXS_UC_PRAMIF_CTL0r
#define UC_PRAMIF_CTL0r_SIZE BCMI_TSCE16_XGXS_UC_PRAMIF_CTL0r_SIZE
typedef BCMI_TSCE16_XGXS_UC_PRAMIF_CTL0r_t UC_PRAMIF_CTL0r_t;
#define UC_PRAMIF_CTL0r_CLR BCMI_TSCE16_XGXS_UC_PRAMIF_CTL0r_CLR
#define UC_PRAMIF_CTL0r_SET BCMI_TSCE16_XGXS_UC_PRAMIF_CTL0r_SET
#define UC_PRAMIF_CTL0r_GET BCMI_TSCE16_XGXS_UC_PRAMIF_CTL0r_GET
#define UC_PRAMIF_CTL0r_MICRO_PRAMIF_ENf_GET BCMI_TSCE16_XGXS_UC_PRAMIF_CTL0r_MICRO_PRAMIF_ENf_GET
#define UC_PRAMIF_CTL0r_MICRO_PRAMIF_ENf_SET BCMI_TSCE16_XGXS_UC_PRAMIF_CTL0r_MICRO_PRAMIF_ENf_SET
#define READ_UC_PRAMIF_CTL0r BCMI_TSCE16_XGXS_READ_UC_PRAMIF_CTL0r
#define WRITE_UC_PRAMIF_CTL0r BCMI_TSCE16_XGXS_WRITE_UC_PRAMIF_CTL0r
#define MODIFY_UC_PRAMIF_CTL0r BCMI_TSCE16_XGXS_MODIFY_UC_PRAMIF_CTL0r
#define READLN_UC_PRAMIF_CTL0r BCMI_TSCE16_XGXS_READLN_UC_PRAMIF_CTL0r
#define WRITELN_UC_PRAMIF_CTL0r BCMI_TSCE16_XGXS_WRITELN_UC_PRAMIF_CTL0r
#define WRITEALL_UC_PRAMIF_CTL0r BCMI_TSCE16_XGXS_WRITEALL_UC_PRAMIF_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_PRAMIF_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_PRAMIF_AHB_WRADDR_LSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd20d
 * DESC:     pram i/f to ahb write address LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_PRAMIF_AHB_WRADDR_LSW These bits are used to generate the lower 14-bits of the address on the AHB-Lite bus during pram interface write transactionsbits[1:0] are not used for 32 transactions
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr (0x0000d20d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_PRAMIF_AHB_WRADDR_LSW.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_s {
	uint32_t v[1];
	uint32_t uc_pramif_ahb_wraddr_lsw[1];
	uint32_t _uc_pramif_ahb_wraddr_lsw;
} BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_t;

#define BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_CLR(r) (r).uc_pramif_ahb_wraddr_lsw[0] = 0
#define BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_SET(r,d) (r).uc_pramif_ahb_wraddr_lsw[0] = d
#define BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_GET(r) (r).uc_pramif_ahb_wraddr_lsw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_MICRO_PRAMIF_AHB_WRADDR_LSWf_GET(r) ((((r).uc_pramif_ahb_wraddr_lsw[0]) >> 2) & 0x3fff)
#define BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_MICRO_PRAMIF_AHB_WRADDR_LSWf_SET(r,f) (r).uc_pramif_ahb_wraddr_lsw[0]=(((r).uc_pramif_ahb_wraddr_lsw[0] & ~((uint32_t)0x3fff << 2)) | ((((uint32_t)f) & 0x3fff) << 2)) | (16383 << (16 + 2))

/*
 * These macros can be used to access UC_PRAMIF_AHB_WRADDR_LSW.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_PRAMIF_AHB_WRADDR_LSWr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr,(_r._uc_pramif_ahb_wraddr_lsw))
#define BCMI_TSCE16_XGXS_WRITE_UC_PRAMIF_AHB_WRADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr,(_r._uc_pramif_ahb_wraddr_lsw)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_PRAMIF_AHB_WRADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr,(_r._uc_pramif_ahb_wraddr_lsw))
#define BCMI_TSCE16_XGXS_READLN_UC_PRAMIF_AHB_WRADDR_LSWr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_pramif_ahb_wraddr_lsw))
#define BCMI_TSCE16_XGXS_WRITELN_UC_PRAMIF_AHB_WRADDR_LSWr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_pramif_ahb_wraddr_lsw))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_PRAMIF_AHB_WRADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_pramif_ahb_wraddr_lsw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_PRAMIF_AHB_WRADDR_LSWr BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr
#define UC_PRAMIF_AHB_WRADDR_LSWr_SIZE BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_SIZE
typedef BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_t UC_PRAMIF_AHB_WRADDR_LSWr_t;
#define UC_PRAMIF_AHB_WRADDR_LSWr_CLR BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_CLR
#define UC_PRAMIF_AHB_WRADDR_LSWr_SET BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_SET
#define UC_PRAMIF_AHB_WRADDR_LSWr_GET BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_GET
#define UC_PRAMIF_AHB_WRADDR_LSWr_MICRO_PRAMIF_AHB_WRADDR_LSWf_GET BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_MICRO_PRAMIF_AHB_WRADDR_LSWf_GET
#define UC_PRAMIF_AHB_WRADDR_LSWr_MICRO_PRAMIF_AHB_WRADDR_LSWf_SET BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_MICRO_PRAMIF_AHB_WRADDR_LSWf_SET
#define READ_UC_PRAMIF_AHB_WRADDR_LSWr BCMI_TSCE16_XGXS_READ_UC_PRAMIF_AHB_WRADDR_LSWr
#define WRITE_UC_PRAMIF_AHB_WRADDR_LSWr BCMI_TSCE16_XGXS_WRITE_UC_PRAMIF_AHB_WRADDR_LSWr
#define MODIFY_UC_PRAMIF_AHB_WRADDR_LSWr BCMI_TSCE16_XGXS_MODIFY_UC_PRAMIF_AHB_WRADDR_LSWr
#define READLN_UC_PRAMIF_AHB_WRADDR_LSWr BCMI_TSCE16_XGXS_READLN_UC_PRAMIF_AHB_WRADDR_LSWr
#define WRITELN_UC_PRAMIF_AHB_WRADDR_LSWr BCMI_TSCE16_XGXS_WRITELN_UC_PRAMIF_AHB_WRADDR_LSWr
#define WRITEALL_UC_PRAMIF_AHB_WRADDR_LSWr BCMI_TSCE16_XGXS_WRITEALL_UC_PRAMIF_AHB_WRADDR_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_PRAMIF_AHB_WRADDR_MSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd20e
 * DESC:     pram i/f to ahb write address MSW (bits 31:16) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_PRAMIF_AHB_WRADDR_MSW These bits are used to generate the upper 16-bits of the address on the AHB-Lite bus during pram interface write transactions
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr (0x0000d20e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_PRAMIF_AHB_WRADDR_MSW.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_s {
	uint32_t v[1];
	uint32_t uc_pramif_ahb_wraddr_msw[1];
	uint32_t _uc_pramif_ahb_wraddr_msw;
} BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_t;

#define BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_CLR(r) (r).uc_pramif_ahb_wraddr_msw[0] = 0
#define BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_SET(r,d) (r).uc_pramif_ahb_wraddr_msw[0] = d
#define BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_GET(r) (r).uc_pramif_ahb_wraddr_msw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_MICRO_PRAMIF_AHB_WRADDR_MSWf_GET(r) (((r).uc_pramif_ahb_wraddr_msw[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_MICRO_PRAMIF_AHB_WRADDR_MSWf_SET(r,f) (r).uc_pramif_ahb_wraddr_msw[0]=(((r).uc_pramif_ahb_wraddr_msw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_PRAMIF_AHB_WRADDR_MSW.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_PRAMIF_AHB_WRADDR_MSWr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr,(_r._uc_pramif_ahb_wraddr_msw))
#define BCMI_TSCE16_XGXS_WRITE_UC_PRAMIF_AHB_WRADDR_MSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr,(_r._uc_pramif_ahb_wraddr_msw)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_PRAMIF_AHB_WRADDR_MSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr,(_r._uc_pramif_ahb_wraddr_msw))
#define BCMI_TSCE16_XGXS_READLN_UC_PRAMIF_AHB_WRADDR_MSWr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_pramif_ahb_wraddr_msw))
#define BCMI_TSCE16_XGXS_WRITELN_UC_PRAMIF_AHB_WRADDR_MSWr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_pramif_ahb_wraddr_msw))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_PRAMIF_AHB_WRADDR_MSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_pramif_ahb_wraddr_msw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_PRAMIF_AHB_WRADDR_MSWr BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr
#define UC_PRAMIF_AHB_WRADDR_MSWr_SIZE BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_SIZE
typedef BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_t UC_PRAMIF_AHB_WRADDR_MSWr_t;
#define UC_PRAMIF_AHB_WRADDR_MSWr_CLR BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_CLR
#define UC_PRAMIF_AHB_WRADDR_MSWr_SET BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_SET
#define UC_PRAMIF_AHB_WRADDR_MSWr_GET BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_GET
#define UC_PRAMIF_AHB_WRADDR_MSWr_MICRO_PRAMIF_AHB_WRADDR_MSWf_GET BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_MICRO_PRAMIF_AHB_WRADDR_MSWf_GET
#define UC_PRAMIF_AHB_WRADDR_MSWr_MICRO_PRAMIF_AHB_WRADDR_MSWf_SET BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_MICRO_PRAMIF_AHB_WRADDR_MSWf_SET
#define READ_UC_PRAMIF_AHB_WRADDR_MSWr BCMI_TSCE16_XGXS_READ_UC_PRAMIF_AHB_WRADDR_MSWr
#define WRITE_UC_PRAMIF_AHB_WRADDR_MSWr BCMI_TSCE16_XGXS_WRITE_UC_PRAMIF_AHB_WRADDR_MSWr
#define MODIFY_UC_PRAMIF_AHB_WRADDR_MSWr BCMI_TSCE16_XGXS_MODIFY_UC_PRAMIF_AHB_WRADDR_MSWr
#define READLN_UC_PRAMIF_AHB_WRADDR_MSWr BCMI_TSCE16_XGXS_READLN_UC_PRAMIF_AHB_WRADDR_MSWr
#define WRITELN_UC_PRAMIF_AHB_WRADDR_MSWr BCMI_TSCE16_XGXS_WRITELN_UC_PRAMIF_AHB_WRADDR_MSWr
#define WRITEALL_UC_PRAMIF_AHB_WRADDR_MSWr BCMI_TSCE16_XGXS_WRITEALL_UC_PRAMIF_AHB_WRADDR_MSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_PVT_STS0
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd210
 * DESC:     pvt temperature status register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_PVT_TEMPDATA_RMI temperature data{6'd0,tempearture_data[9:0]}reads the current value of the temperature data capatured
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_PVT_STS0r (0x0000d210 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_PVT_STS0r_SIZE 4

/*
 * This structure should be used to declare and program UC_PVT_STS0.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_PVT_STS0r_s {
	uint32_t v[1];
	uint32_t uc_pvt_sts0[1];
	uint32_t _uc_pvt_sts0;
} BCMI_TSCE16_XGXS_UC_PVT_STS0r_t;

#define BCMI_TSCE16_XGXS_UC_PVT_STS0r_CLR(r) (r).uc_pvt_sts0[0] = 0
#define BCMI_TSCE16_XGXS_UC_PVT_STS0r_SET(r,d) (r).uc_pvt_sts0[0] = d
#define BCMI_TSCE16_XGXS_UC_PVT_STS0r_GET(r) (r).uc_pvt_sts0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_PVT_STS0r_MICRO_PVT_TEMPDATA_RMIf_GET(r) (((r).uc_pvt_sts0[0]) & 0x3ff)
#define BCMI_TSCE16_XGXS_UC_PVT_STS0r_MICRO_PVT_TEMPDATA_RMIf_SET(r,f) (r).uc_pvt_sts0[0]=(((r).uc_pvt_sts0[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access UC_PVT_STS0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_PVT_STS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_PVT_STS0r,(_r._uc_pvt_sts0))
#define BCMI_TSCE16_XGXS_WRITE_UC_PVT_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_PVT_STS0r,(_r._uc_pvt_sts0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_PVT_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_PVT_STS0r,(_r._uc_pvt_sts0))
#define BCMI_TSCE16_XGXS_READLN_UC_PVT_STS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_PVT_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_pvt_sts0))
#define BCMI_TSCE16_XGXS_WRITELN_UC_PVT_STS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_PVT_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_pvt_sts0))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_PVT_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_PVT_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_pvt_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_PVT_STS0r BCMI_TSCE16_XGXS_UC_PVT_STS0r
#define UC_PVT_STS0r_SIZE BCMI_TSCE16_XGXS_UC_PVT_STS0r_SIZE
typedef BCMI_TSCE16_XGXS_UC_PVT_STS0r_t UC_PVT_STS0r_t;
#define UC_PVT_STS0r_CLR BCMI_TSCE16_XGXS_UC_PVT_STS0r_CLR
#define UC_PVT_STS0r_SET BCMI_TSCE16_XGXS_UC_PVT_STS0r_SET
#define UC_PVT_STS0r_GET BCMI_TSCE16_XGXS_UC_PVT_STS0r_GET
#define UC_PVT_STS0r_MICRO_PVT_TEMPDATA_RMIf_GET BCMI_TSCE16_XGXS_UC_PVT_STS0r_MICRO_PVT_TEMPDATA_RMIf_GET
#define UC_PVT_STS0r_MICRO_PVT_TEMPDATA_RMIf_SET BCMI_TSCE16_XGXS_UC_PVT_STS0r_MICRO_PVT_TEMPDATA_RMIf_SET
#define READ_UC_PVT_STS0r BCMI_TSCE16_XGXS_READ_UC_PVT_STS0r
#define WRITE_UC_PVT_STS0r BCMI_TSCE16_XGXS_WRITE_UC_PVT_STS0r
#define MODIFY_UC_PVT_STS0r BCMI_TSCE16_XGXS_MODIFY_UC_PVT_STS0r
#define READLN_UC_PVT_STS0r BCMI_TSCE16_XGXS_READLN_UC_PVT_STS0r
#define WRITELN_UC_PVT_STS0r BCMI_TSCE16_XGXS_WRITELN_UC_PVT_STS0r
#define WRITEALL_UC_PVT_STS0r BCMI_TSCE16_XGXS_WRITEALL_UC_PVT_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_PVT_STS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_RMI_TO_UC_MBOX0
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd211
 * DESC:     rmi to micro mailbox register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RMI_TO_MICRO_MBOX0 There bits represents bits [15:0] of the message from rmi to microWrite to this registers can optionaly generate an interrupt to the micro
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX0r (0x0000d211 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_TO_UC_MBOX0.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_to_uc_mbox0[1];
	uint32_t _uc_rmi_to_uc_mbox0;
} BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX0r_t;

#define BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX0r_CLR(r) (r).uc_rmi_to_uc_mbox0[0] = 0
#define BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX0r_SET(r,d) (r).uc_rmi_to_uc_mbox0[0] = d
#define BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX0r_GET(r) (r).uc_rmi_to_uc_mbox0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX0r_MICRO_RMI_TO_MICRO_MBOX0f_GET(r) (((r).uc_rmi_to_uc_mbox0[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX0r_MICRO_RMI_TO_MICRO_MBOX0f_SET(r,f) (r).uc_rmi_to_uc_mbox0[0]=(((r).uc_rmi_to_uc_mbox0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_TO_UC_MBOX0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_RMI_TO_UC_MBOX0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX0r,(_r._uc_rmi_to_uc_mbox0))
#define BCMI_TSCE16_XGXS_WRITE_UC_RMI_TO_UC_MBOX0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX0r,(_r._uc_rmi_to_uc_mbox0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_RMI_TO_UC_MBOX0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX0r,(_r._uc_rmi_to_uc_mbox0))
#define BCMI_TSCE16_XGXS_READLN_UC_RMI_TO_UC_MBOX0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_to_uc_mbox0))
#define BCMI_TSCE16_XGXS_WRITELN_UC_RMI_TO_UC_MBOX0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_to_uc_mbox0))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_RMI_TO_UC_MBOX0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_to_uc_mbox0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_TO_UC_MBOX0r BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX0r
#define UC_RMI_TO_UC_MBOX0r_SIZE BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX0r_SIZE
typedef BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX0r_t UC_RMI_TO_UC_MBOX0r_t;
#define UC_RMI_TO_UC_MBOX0r_CLR BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX0r_CLR
#define UC_RMI_TO_UC_MBOX0r_SET BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX0r_SET
#define UC_RMI_TO_UC_MBOX0r_GET BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX0r_GET
#define UC_RMI_TO_UC_MBOX0r_MICRO_RMI_TO_MICRO_MBOX0f_GET BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX0r_MICRO_RMI_TO_MICRO_MBOX0f_GET
#define UC_RMI_TO_UC_MBOX0r_MICRO_RMI_TO_MICRO_MBOX0f_SET BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX0r_MICRO_RMI_TO_MICRO_MBOX0f_SET
#define READ_UC_RMI_TO_UC_MBOX0r BCMI_TSCE16_XGXS_READ_UC_RMI_TO_UC_MBOX0r
#define WRITE_UC_RMI_TO_UC_MBOX0r BCMI_TSCE16_XGXS_WRITE_UC_RMI_TO_UC_MBOX0r
#define MODIFY_UC_RMI_TO_UC_MBOX0r BCMI_TSCE16_XGXS_MODIFY_UC_RMI_TO_UC_MBOX0r
#define READLN_UC_RMI_TO_UC_MBOX0r BCMI_TSCE16_XGXS_READLN_UC_RMI_TO_UC_MBOX0r
#define WRITELN_UC_RMI_TO_UC_MBOX0r BCMI_TSCE16_XGXS_WRITELN_UC_RMI_TO_UC_MBOX0r
#define WRITEALL_UC_RMI_TO_UC_MBOX0r BCMI_TSCE16_XGXS_WRITEALL_UC_RMI_TO_UC_MBOX0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_RMI_TO_UC_MBOX1
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd212
 * DESC:     rmi to micro mailbox register 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RMI_TO_MICRO_MBOX1 There bits represents bits [31:16] of the message from rmi to micro
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX1r (0x0000d212 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX1r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_TO_UC_MBOX1.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX1r_s {
	uint32_t v[1];
	uint32_t uc_rmi_to_uc_mbox1[1];
	uint32_t _uc_rmi_to_uc_mbox1;
} BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX1r_t;

#define BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX1r_CLR(r) (r).uc_rmi_to_uc_mbox1[0] = 0
#define BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX1r_SET(r,d) (r).uc_rmi_to_uc_mbox1[0] = d
#define BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX1r_GET(r) (r).uc_rmi_to_uc_mbox1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX1r_MICRO_RMI_TO_MICRO_MBOX1f_GET(r) (((r).uc_rmi_to_uc_mbox1[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX1r_MICRO_RMI_TO_MICRO_MBOX1f_SET(r,f) (r).uc_rmi_to_uc_mbox1[0]=(((r).uc_rmi_to_uc_mbox1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_TO_UC_MBOX1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_RMI_TO_UC_MBOX1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX1r,(_r._uc_rmi_to_uc_mbox1))
#define BCMI_TSCE16_XGXS_WRITE_UC_RMI_TO_UC_MBOX1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX1r,(_r._uc_rmi_to_uc_mbox1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_RMI_TO_UC_MBOX1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX1r,(_r._uc_rmi_to_uc_mbox1))
#define BCMI_TSCE16_XGXS_READLN_UC_RMI_TO_UC_MBOX1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_to_uc_mbox1))
#define BCMI_TSCE16_XGXS_WRITELN_UC_RMI_TO_UC_MBOX1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_to_uc_mbox1))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_RMI_TO_UC_MBOX1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_to_uc_mbox1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_TO_UC_MBOX1r BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX1r
#define UC_RMI_TO_UC_MBOX1r_SIZE BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX1r_SIZE
typedef BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX1r_t UC_RMI_TO_UC_MBOX1r_t;
#define UC_RMI_TO_UC_MBOX1r_CLR BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX1r_CLR
#define UC_RMI_TO_UC_MBOX1r_SET BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX1r_SET
#define UC_RMI_TO_UC_MBOX1r_GET BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX1r_GET
#define UC_RMI_TO_UC_MBOX1r_MICRO_RMI_TO_MICRO_MBOX1f_GET BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX1r_MICRO_RMI_TO_MICRO_MBOX1f_GET
#define UC_RMI_TO_UC_MBOX1r_MICRO_RMI_TO_MICRO_MBOX1f_SET BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX1r_MICRO_RMI_TO_MICRO_MBOX1f_SET
#define READ_UC_RMI_TO_UC_MBOX1r BCMI_TSCE16_XGXS_READ_UC_RMI_TO_UC_MBOX1r
#define WRITE_UC_RMI_TO_UC_MBOX1r BCMI_TSCE16_XGXS_WRITE_UC_RMI_TO_UC_MBOX1r
#define MODIFY_UC_RMI_TO_UC_MBOX1r BCMI_TSCE16_XGXS_MODIFY_UC_RMI_TO_UC_MBOX1r
#define READLN_UC_RMI_TO_UC_MBOX1r BCMI_TSCE16_XGXS_READLN_UC_RMI_TO_UC_MBOX1r
#define WRITELN_UC_RMI_TO_UC_MBOX1r BCMI_TSCE16_XGXS_WRITELN_UC_RMI_TO_UC_MBOX1r
#define WRITEALL_UC_RMI_TO_UC_MBOX1r BCMI_TSCE16_XGXS_WRITEALL_UC_RMI_TO_UC_MBOX1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_RMI_TO_UC_MBOX1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_UC_TO_RMI_MBOX0
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd213
 * DESC:     micro to rmi mailbox register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_TO_RMI_MBOX0 There bits represents bits [15:0] of the message from rmi to micro
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX0r (0x0000d213 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX0r_SIZE 4

/*
 * This structure should be used to declare and program UC_UC_TO_RMI_MBOX0.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX0r_s {
	uint32_t v[1];
	uint32_t uc_uc_to_rmi_mbox0[1];
	uint32_t _uc_uc_to_rmi_mbox0;
} BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX0r_t;

#define BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX0r_CLR(r) (r).uc_uc_to_rmi_mbox0[0] = 0
#define BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX0r_SET(r,d) (r).uc_uc_to_rmi_mbox0[0] = d
#define BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX0r_GET(r) (r).uc_uc_to_rmi_mbox0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX0r_MICRO_TO_RMI_MBOX0f_GET(r) (((r).uc_uc_to_rmi_mbox0[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX0r_MICRO_TO_RMI_MBOX0f_SET(r,f) (r).uc_uc_to_rmi_mbox0[0]=(((r).uc_uc_to_rmi_mbox0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_UC_TO_RMI_MBOX0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_UC_TO_RMI_MBOX0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX0r,(_r._uc_uc_to_rmi_mbox0))
#define BCMI_TSCE16_XGXS_WRITE_UC_UC_TO_RMI_MBOX0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX0r,(_r._uc_uc_to_rmi_mbox0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_UC_TO_RMI_MBOX0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX0r,(_r._uc_uc_to_rmi_mbox0))
#define BCMI_TSCE16_XGXS_READLN_UC_UC_TO_RMI_MBOX0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_to_rmi_mbox0))
#define BCMI_TSCE16_XGXS_WRITELN_UC_UC_TO_RMI_MBOX0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_to_rmi_mbox0))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_UC_TO_RMI_MBOX0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_uc_to_rmi_mbox0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_UC_TO_RMI_MBOX0r BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX0r
#define UC_UC_TO_RMI_MBOX0r_SIZE BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX0r_SIZE
typedef BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX0r_t UC_UC_TO_RMI_MBOX0r_t;
#define UC_UC_TO_RMI_MBOX0r_CLR BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX0r_CLR
#define UC_UC_TO_RMI_MBOX0r_SET BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX0r_SET
#define UC_UC_TO_RMI_MBOX0r_GET BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX0r_GET
#define UC_UC_TO_RMI_MBOX0r_MICRO_TO_RMI_MBOX0f_GET BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX0r_MICRO_TO_RMI_MBOX0f_GET
#define UC_UC_TO_RMI_MBOX0r_MICRO_TO_RMI_MBOX0f_SET BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX0r_MICRO_TO_RMI_MBOX0f_SET
#define READ_UC_UC_TO_RMI_MBOX0r BCMI_TSCE16_XGXS_READ_UC_UC_TO_RMI_MBOX0r
#define WRITE_UC_UC_TO_RMI_MBOX0r BCMI_TSCE16_XGXS_WRITE_UC_UC_TO_RMI_MBOX0r
#define MODIFY_UC_UC_TO_RMI_MBOX0r BCMI_TSCE16_XGXS_MODIFY_UC_UC_TO_RMI_MBOX0r
#define READLN_UC_UC_TO_RMI_MBOX0r BCMI_TSCE16_XGXS_READLN_UC_UC_TO_RMI_MBOX0r
#define WRITELN_UC_UC_TO_RMI_MBOX0r BCMI_TSCE16_XGXS_WRITELN_UC_UC_TO_RMI_MBOX0r
#define WRITEALL_UC_UC_TO_RMI_MBOX0r BCMI_TSCE16_XGXS_WRITEALL_UC_UC_TO_RMI_MBOX0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_UC_TO_RMI_MBOX1
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd214
 * DESC:     micro to rmi mailbox register 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_TO_RMI_MBOX1 There bits represents bits [31:16] of the message from rmi to micro
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX1r (0x0000d214 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX1r_SIZE 4

/*
 * This structure should be used to declare and program UC_UC_TO_RMI_MBOX1.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX1r_s {
	uint32_t v[1];
	uint32_t uc_uc_to_rmi_mbox1[1];
	uint32_t _uc_uc_to_rmi_mbox1;
} BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX1r_t;

#define BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX1r_CLR(r) (r).uc_uc_to_rmi_mbox1[0] = 0
#define BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX1r_SET(r,d) (r).uc_uc_to_rmi_mbox1[0] = d
#define BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX1r_GET(r) (r).uc_uc_to_rmi_mbox1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX1r_MICRO_TO_RMI_MBOX1f_GET(r) (((r).uc_uc_to_rmi_mbox1[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX1r_MICRO_TO_RMI_MBOX1f_SET(r,f) (r).uc_uc_to_rmi_mbox1[0]=(((r).uc_uc_to_rmi_mbox1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_UC_TO_RMI_MBOX1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_UC_TO_RMI_MBOX1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX1r,(_r._uc_uc_to_rmi_mbox1))
#define BCMI_TSCE16_XGXS_WRITE_UC_UC_TO_RMI_MBOX1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX1r,(_r._uc_uc_to_rmi_mbox1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_UC_TO_RMI_MBOX1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX1r,(_r._uc_uc_to_rmi_mbox1))
#define BCMI_TSCE16_XGXS_READLN_UC_UC_TO_RMI_MBOX1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_to_rmi_mbox1))
#define BCMI_TSCE16_XGXS_WRITELN_UC_UC_TO_RMI_MBOX1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_to_rmi_mbox1))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_UC_TO_RMI_MBOX1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_uc_to_rmi_mbox1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_UC_TO_RMI_MBOX1r BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX1r
#define UC_UC_TO_RMI_MBOX1r_SIZE BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX1r_SIZE
typedef BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX1r_t UC_UC_TO_RMI_MBOX1r_t;
#define UC_UC_TO_RMI_MBOX1r_CLR BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX1r_CLR
#define UC_UC_TO_RMI_MBOX1r_SET BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX1r_SET
#define UC_UC_TO_RMI_MBOX1r_GET BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX1r_GET
#define UC_UC_TO_RMI_MBOX1r_MICRO_TO_RMI_MBOX1f_GET BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX1r_MICRO_TO_RMI_MBOX1f_GET
#define UC_UC_TO_RMI_MBOX1r_MICRO_TO_RMI_MBOX1f_SET BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX1r_MICRO_TO_RMI_MBOX1f_SET
#define READ_UC_UC_TO_RMI_MBOX1r BCMI_TSCE16_XGXS_READ_UC_UC_TO_RMI_MBOX1r
#define WRITE_UC_UC_TO_RMI_MBOX1r BCMI_TSCE16_XGXS_WRITE_UC_UC_TO_RMI_MBOX1r
#define MODIFY_UC_UC_TO_RMI_MBOX1r BCMI_TSCE16_XGXS_MODIFY_UC_UC_TO_RMI_MBOX1r
#define READLN_UC_UC_TO_RMI_MBOX1r BCMI_TSCE16_XGXS_READLN_UC_UC_TO_RMI_MBOX1r
#define WRITELN_UC_UC_TO_RMI_MBOX1r BCMI_TSCE16_XGXS_WRITELN_UC_UC_TO_RMI_MBOX1r
#define WRITEALL_UC_UC_TO_RMI_MBOX1r BCMI_TSCE16_XGXS_WRITEALL_UC_UC_TO_RMI_MBOX1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_UC_TO_RMI_MBOX1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_RMI_MBOX_CTL0
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd215
 * DESC:     rmi mailbox control register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RMI_MBOX_SEND_MSGIN Send message in (to the micro)This field is set by the RMIC to indicate to the Micro that the message in thermi_to_micro_mbox1, and rmi_to_micro_mbox0 regiters is valid.
 *     MICRO_GEN_INTR_RMI_MBOX0WR Generate interrupt when micro_rmi_to_micro_mbox0 field is written0 - disabled1 - enbled
 *     MICRO_GEN_INTR_RMI_MBOX1WR Generate interrupt when micro_rmi_to_micro_mbox1 field is written0 - disabled1 - enbled
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_RMI_MBOX_CTL0r (0x0000d215 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_RMI_MBOX_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_MBOX_CTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_RMI_MBOX_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_mbox_ctl0[1];
	uint32_t _uc_rmi_mbox_ctl0;
} BCMI_TSCE16_XGXS_UC_RMI_MBOX_CTL0r_t;

#define BCMI_TSCE16_XGXS_UC_RMI_MBOX_CTL0r_CLR(r) (r).uc_rmi_mbox_ctl0[0] = 0
#define BCMI_TSCE16_XGXS_UC_RMI_MBOX_CTL0r_SET(r,d) (r).uc_rmi_mbox_ctl0[0] = d
#define BCMI_TSCE16_XGXS_UC_RMI_MBOX_CTL0r_GET(r) (r).uc_rmi_mbox_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX1WRf_GET(r) ((((r).uc_rmi_mbox_ctl0[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX1WRf_SET(r,f) (r).uc_rmi_mbox_ctl0[0]=(((r).uc_rmi_mbox_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX0WRf_GET(r) ((((r).uc_rmi_mbox_ctl0[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX0WRf_SET(r,f) (r).uc_rmi_mbox_ctl0[0]=(((r).uc_rmi_mbox_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_UC_RMI_MBOX_CTL0r_MICRO_RMI_MBOX_SEND_MSGINf_GET(r) (((r).uc_rmi_mbox_ctl0[0]) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RMI_MBOX_CTL0r_MICRO_RMI_MBOX_SEND_MSGINf_SET(r,f) (r).uc_rmi_mbox_ctl0[0]=(((r).uc_rmi_mbox_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RMI_MBOX_CTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_RMI_MBOX_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_RMI_MBOX_CTL0r,(_r._uc_rmi_mbox_ctl0))
#define BCMI_TSCE16_XGXS_WRITE_UC_RMI_MBOX_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_MBOX_CTL0r,(_r._uc_rmi_mbox_ctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_RMI_MBOX_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_MBOX_CTL0r,(_r._uc_rmi_mbox_ctl0))
#define BCMI_TSCE16_XGXS_READLN_UC_RMI_MBOX_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_RMI_MBOX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_mbox_ctl0))
#define BCMI_TSCE16_XGXS_WRITELN_UC_RMI_MBOX_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_MBOX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_mbox_ctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_RMI_MBOX_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_MBOX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_mbox_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_MBOX_CTL0r BCMI_TSCE16_XGXS_UC_RMI_MBOX_CTL0r
#define UC_RMI_MBOX_CTL0r_SIZE BCMI_TSCE16_XGXS_UC_RMI_MBOX_CTL0r_SIZE
typedef BCMI_TSCE16_XGXS_UC_RMI_MBOX_CTL0r_t UC_RMI_MBOX_CTL0r_t;
#define UC_RMI_MBOX_CTL0r_CLR BCMI_TSCE16_XGXS_UC_RMI_MBOX_CTL0r_CLR
#define UC_RMI_MBOX_CTL0r_SET BCMI_TSCE16_XGXS_UC_RMI_MBOX_CTL0r_SET
#define UC_RMI_MBOX_CTL0r_GET BCMI_TSCE16_XGXS_UC_RMI_MBOX_CTL0r_GET
#define UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX1WRf_GET BCMI_TSCE16_XGXS_UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX1WRf_GET
#define UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX1WRf_SET BCMI_TSCE16_XGXS_UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX1WRf_SET
#define UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX0WRf_GET BCMI_TSCE16_XGXS_UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX0WRf_GET
#define UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX0WRf_SET BCMI_TSCE16_XGXS_UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX0WRf_SET
#define UC_RMI_MBOX_CTL0r_MICRO_RMI_MBOX_SEND_MSGINf_GET BCMI_TSCE16_XGXS_UC_RMI_MBOX_CTL0r_MICRO_RMI_MBOX_SEND_MSGINf_GET
#define UC_RMI_MBOX_CTL0r_MICRO_RMI_MBOX_SEND_MSGINf_SET BCMI_TSCE16_XGXS_UC_RMI_MBOX_CTL0r_MICRO_RMI_MBOX_SEND_MSGINf_SET
#define READ_UC_RMI_MBOX_CTL0r BCMI_TSCE16_XGXS_READ_UC_RMI_MBOX_CTL0r
#define WRITE_UC_RMI_MBOX_CTL0r BCMI_TSCE16_XGXS_WRITE_UC_RMI_MBOX_CTL0r
#define MODIFY_UC_RMI_MBOX_CTL0r BCMI_TSCE16_XGXS_MODIFY_UC_RMI_MBOX_CTL0r
#define READLN_UC_RMI_MBOX_CTL0r BCMI_TSCE16_XGXS_READLN_UC_RMI_MBOX_CTL0r
#define WRITELN_UC_RMI_MBOX_CTL0r BCMI_TSCE16_XGXS_WRITELN_UC_RMI_MBOX_CTL0r
#define WRITEALL_UC_RMI_MBOX_CTL0r BCMI_TSCE16_XGXS_WRITEALL_UC_RMI_MBOX_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_RMI_MBOX_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_RMI_AHB_CTL1
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd216
 * DESC:     ahb control register 1
 * RESETVAL: 0x7 (7)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_M0_HRESP_EN m0 response error signaling enable0 - disabled1 - enabled
 *     MICRO_SW_PMI_HP_RSTB Software reset pmi_hp interface logicThis bit is to initialize the pmi_hp block0 - reset asserted1 - reset de-asserted
 *     MICRO_SW_PMI_HP_EXT_RSTB Software reset pmi_hp_ext interface logicThis bit is to initialize the pmi_hp_ext block0 - reset asserted1 - reset de-asserted
 *     MICRO_PMI_HP_ACK_TIMEOUT_DIS pmi_hp_ack_* timeout disableWhen micro initates a read/write transctions on the pmi_hp busit allows upto 256 clock cycles for pmi_hp_ack_mc/pmi_hp_ack_uc to be assertedIf pmi_hp_ack_* is not received within this time, then it1. terminates the current transactions on the pmi_hp bus2. set the pmi_hp_ack_timeout_status field of the ahbcommon_pmi_hp_status0 register.3. performs the response error signaling on the micro AHB bus when micro_m0_hresp_en field is set to 1'b1This timeout period/error reporting/reponse error signaling can be disabled by setting this field i.e.0: enabled1: disabled
 *     MICRO_PMI_HP_EXT_ACK_TIMEOUT_DIS pmi_hp_ext_ack_* timeout disableWhen micro initates a read/write transctions on the pmi_hp_ext busit allows upto 256 clock cycles for pmi_hp_ext_ack_mc/pmi_hp_ext_ack_uc to be assertedIf pmi_hp_ext_ack_* is not received within this time, then it1. terminates the current transactions on the pmi_hp_ext bus2. set the pmi_hp_ext_ack_timeout_status field of the ahbcommon_pmi_hp_status0 register.3. performs the response error signaling on the micro AHB bus if micro_m0_hresp_en field is set to 1'b1This timeout period/error reporting/reponse error signaling can be disabled by setting this field i.e.0: enabled1: disabled
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r (0x0000d216 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_AHB_CTL1.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r_s {
	uint32_t v[1];
	uint32_t uc_rmi_ahb_ctl1[1];
	uint32_t _uc_rmi_ahb_ctl1;
} BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r_t;

#define BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r_CLR(r) (r).uc_rmi_ahb_ctl1[0] = 0
#define BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r_SET(r,d) (r).uc_rmi_ahb_ctl1[0] = d
#define BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r_GET(r) (r).uc_rmi_ahb_ctl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r_MICRO_PMI_HP_EXT_ACK_TIMEOUT_DISf_GET(r) ((((r).uc_rmi_ahb_ctl1[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r_MICRO_PMI_HP_EXT_ACK_TIMEOUT_DISf_SET(r,f) (r).uc_rmi_ahb_ctl1[0]=(((r).uc_rmi_ahb_ctl1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r_MICRO_PMI_HP_ACK_TIMEOUT_DISf_GET(r) ((((r).uc_rmi_ahb_ctl1[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r_MICRO_PMI_HP_ACK_TIMEOUT_DISf_SET(r,f) (r).uc_rmi_ahb_ctl1[0]=(((r).uc_rmi_ahb_ctl1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_EXT_RSTBf_GET(r) ((((r).uc_rmi_ahb_ctl1[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_EXT_RSTBf_SET(r,f) (r).uc_rmi_ahb_ctl1[0]=(((r).uc_rmi_ahb_ctl1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_RSTBf_GET(r) ((((r).uc_rmi_ahb_ctl1[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_RSTBf_SET(r,f) (r).uc_rmi_ahb_ctl1[0]=(((r).uc_rmi_ahb_ctl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r_MICRO_M0_HRESP_ENf_GET(r) (((r).uc_rmi_ahb_ctl1[0]) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r_MICRO_M0_HRESP_ENf_SET(r,f) (r).uc_rmi_ahb_ctl1[0]=(((r).uc_rmi_ahb_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RMI_AHB_CTL1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_RMI_AHB_CTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r,(_r._uc_rmi_ahb_ctl1))
#define BCMI_TSCE16_XGXS_WRITE_UC_RMI_AHB_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r,(_r._uc_rmi_ahb_ctl1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_RMI_AHB_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r,(_r._uc_rmi_ahb_ctl1))
#define BCMI_TSCE16_XGXS_READLN_UC_RMI_AHB_CTL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ahb_ctl1))
#define BCMI_TSCE16_XGXS_WRITELN_UC_RMI_AHB_CTL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ahb_ctl1))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_RMI_AHB_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_ahb_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_AHB_CTL1r BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r
#define UC_RMI_AHB_CTL1r_SIZE BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r_SIZE
typedef BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r_t UC_RMI_AHB_CTL1r_t;
#define UC_RMI_AHB_CTL1r_CLR BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r_CLR
#define UC_RMI_AHB_CTL1r_SET BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r_SET
#define UC_RMI_AHB_CTL1r_GET BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r_GET
#define UC_RMI_AHB_CTL1r_MICRO_PMI_HP_EXT_ACK_TIMEOUT_DISf_GET BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r_MICRO_PMI_HP_EXT_ACK_TIMEOUT_DISf_GET
#define UC_RMI_AHB_CTL1r_MICRO_PMI_HP_EXT_ACK_TIMEOUT_DISf_SET BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r_MICRO_PMI_HP_EXT_ACK_TIMEOUT_DISf_SET
#define UC_RMI_AHB_CTL1r_MICRO_PMI_HP_ACK_TIMEOUT_DISf_GET BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r_MICRO_PMI_HP_ACK_TIMEOUT_DISf_GET
#define UC_RMI_AHB_CTL1r_MICRO_PMI_HP_ACK_TIMEOUT_DISf_SET BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r_MICRO_PMI_HP_ACK_TIMEOUT_DISf_SET
#define UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_EXT_RSTBf_GET BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_EXT_RSTBf_GET
#define UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_EXT_RSTBf_SET BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_EXT_RSTBf_SET
#define UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_RSTBf_GET BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_RSTBf_GET
#define UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_RSTBf_SET BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_RSTBf_SET
#define UC_RMI_AHB_CTL1r_MICRO_M0_HRESP_ENf_GET BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r_MICRO_M0_HRESP_ENf_GET
#define UC_RMI_AHB_CTL1r_MICRO_M0_HRESP_ENf_SET BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r_MICRO_M0_HRESP_ENf_SET
#define READ_UC_RMI_AHB_CTL1r BCMI_TSCE16_XGXS_READ_UC_RMI_AHB_CTL1r
#define WRITE_UC_RMI_AHB_CTL1r BCMI_TSCE16_XGXS_WRITE_UC_RMI_AHB_CTL1r
#define MODIFY_UC_RMI_AHB_CTL1r BCMI_TSCE16_XGXS_MODIFY_UC_RMI_AHB_CTL1r
#define READLN_UC_RMI_AHB_CTL1r BCMI_TSCE16_XGXS_READLN_UC_RMI_AHB_CTL1r
#define WRITELN_UC_RMI_AHB_CTL1r BCMI_TSCE16_XGXS_WRITELN_UC_RMI_AHB_CTL1r
#define WRITEALL_UC_RMI_AHB_CTL1r BCMI_TSCE16_XGXS_WRITEALL_UC_RMI_AHB_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_RMI_AHB_CTL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_RMI_AHB_STS1
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd217
 * DESC:     ahb status register 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_M0_DEFAULT_SLAVE_ERROR m0 default slave error detected. M0 attempted to access un-used address1 - error detected - latched high clear on read0 - no error
 *     MICRO_RMI_DEFAULT_SLAVE_ERROR register interface default slave error detected. Register interface attempted to access un-used address1 - error detected - latched high clear on read0 - no error
 *     MICRO_PR_DEFAULT_SLAVE_ERROR PRAM interface default slave error detected. PRAM interface attempted to access un-used address1 - error detected - latched high clear on read0 - no error
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_RMI_AHB_STS1r (0x0000d217 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_RMI_AHB_STS1r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_AHB_STS1.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_RMI_AHB_STS1r_s {
	uint32_t v[1];
	uint32_t uc_rmi_ahb_sts1[1];
	uint32_t _uc_rmi_ahb_sts1;
} BCMI_TSCE16_XGXS_UC_RMI_AHB_STS1r_t;

#define BCMI_TSCE16_XGXS_UC_RMI_AHB_STS1r_CLR(r) (r).uc_rmi_ahb_sts1[0] = 0
#define BCMI_TSCE16_XGXS_UC_RMI_AHB_STS1r_SET(r,d) (r).uc_rmi_ahb_sts1[0] = d
#define BCMI_TSCE16_XGXS_UC_RMI_AHB_STS1r_GET(r) (r).uc_rmi_ahb_sts1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_RMI_AHB_STS1r_MICRO_PR_DEFAULT_SLAVE_ERRORf_GET(r) ((((r).uc_rmi_ahb_sts1[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RMI_AHB_STS1r_MICRO_PR_DEFAULT_SLAVE_ERRORf_SET(r,f) (r).uc_rmi_ahb_sts1[0]=(((r).uc_rmi_ahb_sts1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_UC_RMI_AHB_STS1r_MICRO_RMI_DEFAULT_SLAVE_ERRORf_GET(r) ((((r).uc_rmi_ahb_sts1[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RMI_AHB_STS1r_MICRO_RMI_DEFAULT_SLAVE_ERRORf_SET(r,f) (r).uc_rmi_ahb_sts1[0]=(((r).uc_rmi_ahb_sts1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_UC_RMI_AHB_STS1r_MICRO_M0_DEFAULT_SLAVE_ERRORf_GET(r) (((r).uc_rmi_ahb_sts1[0]) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RMI_AHB_STS1r_MICRO_M0_DEFAULT_SLAVE_ERRORf_SET(r,f) (r).uc_rmi_ahb_sts1[0]=(((r).uc_rmi_ahb_sts1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RMI_AHB_STS1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_RMI_AHB_STS1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_RMI_AHB_STS1r,(_r._uc_rmi_ahb_sts1))
#define BCMI_TSCE16_XGXS_WRITE_UC_RMI_AHB_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_AHB_STS1r,(_r._uc_rmi_ahb_sts1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_RMI_AHB_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_AHB_STS1r,(_r._uc_rmi_ahb_sts1))
#define BCMI_TSCE16_XGXS_READLN_UC_RMI_AHB_STS1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_RMI_AHB_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ahb_sts1))
#define BCMI_TSCE16_XGXS_WRITELN_UC_RMI_AHB_STS1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_AHB_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ahb_sts1))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_RMI_AHB_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_AHB_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_ahb_sts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_AHB_STS1r BCMI_TSCE16_XGXS_UC_RMI_AHB_STS1r
#define UC_RMI_AHB_STS1r_SIZE BCMI_TSCE16_XGXS_UC_RMI_AHB_STS1r_SIZE
typedef BCMI_TSCE16_XGXS_UC_RMI_AHB_STS1r_t UC_RMI_AHB_STS1r_t;
#define UC_RMI_AHB_STS1r_CLR BCMI_TSCE16_XGXS_UC_RMI_AHB_STS1r_CLR
#define UC_RMI_AHB_STS1r_SET BCMI_TSCE16_XGXS_UC_RMI_AHB_STS1r_SET
#define UC_RMI_AHB_STS1r_GET BCMI_TSCE16_XGXS_UC_RMI_AHB_STS1r_GET
#define UC_RMI_AHB_STS1r_MICRO_PR_DEFAULT_SLAVE_ERRORf_GET BCMI_TSCE16_XGXS_UC_RMI_AHB_STS1r_MICRO_PR_DEFAULT_SLAVE_ERRORf_GET
#define UC_RMI_AHB_STS1r_MICRO_PR_DEFAULT_SLAVE_ERRORf_SET BCMI_TSCE16_XGXS_UC_RMI_AHB_STS1r_MICRO_PR_DEFAULT_SLAVE_ERRORf_SET
#define UC_RMI_AHB_STS1r_MICRO_RMI_DEFAULT_SLAVE_ERRORf_GET BCMI_TSCE16_XGXS_UC_RMI_AHB_STS1r_MICRO_RMI_DEFAULT_SLAVE_ERRORf_GET
#define UC_RMI_AHB_STS1r_MICRO_RMI_DEFAULT_SLAVE_ERRORf_SET BCMI_TSCE16_XGXS_UC_RMI_AHB_STS1r_MICRO_RMI_DEFAULT_SLAVE_ERRORf_SET
#define UC_RMI_AHB_STS1r_MICRO_M0_DEFAULT_SLAVE_ERRORf_GET BCMI_TSCE16_XGXS_UC_RMI_AHB_STS1r_MICRO_M0_DEFAULT_SLAVE_ERRORf_GET
#define UC_RMI_AHB_STS1r_MICRO_M0_DEFAULT_SLAVE_ERRORf_SET BCMI_TSCE16_XGXS_UC_RMI_AHB_STS1r_MICRO_M0_DEFAULT_SLAVE_ERRORf_SET
#define READ_UC_RMI_AHB_STS1r BCMI_TSCE16_XGXS_READ_UC_RMI_AHB_STS1r
#define WRITE_UC_RMI_AHB_STS1r BCMI_TSCE16_XGXS_WRITE_UC_RMI_AHB_STS1r
#define MODIFY_UC_RMI_AHB_STS1r BCMI_TSCE16_XGXS_MODIFY_UC_RMI_AHB_STS1r
#define READLN_UC_RMI_AHB_STS1r BCMI_TSCE16_XGXS_READLN_UC_RMI_AHB_STS1r
#define WRITELN_UC_RMI_AHB_STS1r BCMI_TSCE16_XGXS_WRITELN_UC_RMI_AHB_STS1r
#define WRITEALL_UC_RMI_AHB_STS1r BCMI_TSCE16_XGXS_WRITEALL_UC_RMI_AHB_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_RMI_AHB_STS1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_RMI_RA_AINC_NXT_WRADDR_LSW
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd218
 * DESC:     rmi to ahb auto-incremented write address LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RA_AUTOINC_NXT_WRADDR_LSW When the micro_autoinc_wraddr_en is set, then these bitsindicate the lower 16-bits of the address that will be usedduring the next write transaction.These bits allow address tracking when rmi interface auto addressincrement mode is used
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr (0x0000d218 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_RA_AINC_NXT_WRADDR_LSW.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_s {
	uint32_t v[1];
	uint32_t uc_rmi_ra_ainc_nxt_wraddr_lsw[1];
	uint32_t _uc_rmi_ra_ainc_nxt_wraddr_lsw;
} BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_t;

#define BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_CLR(r) (r).uc_rmi_ra_ainc_nxt_wraddr_lsw[0] = 0
#define BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_SET(r,d) (r).uc_rmi_ra_ainc_nxt_wraddr_lsw[0] = d
#define BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_GET(r) (r).uc_rmi_ra_ainc_nxt_wraddr_lsw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_MICRO_RA_AUTOINC_NXT_WRADDR_LSWf_GET(r) (((r).uc_rmi_ra_ainc_nxt_wraddr_lsw[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_MICRO_RA_AUTOINC_NXT_WRADDR_LSWf_SET(r,f) (r).uc_rmi_ra_ainc_nxt_wraddr_lsw[0]=(((r).uc_rmi_ra_ainc_nxt_wraddr_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_RA_AINC_NXT_WRADDR_LSW.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_RMI_RA_AINC_NXT_WRADDR_LSWr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr,(_r._uc_rmi_ra_ainc_nxt_wraddr_lsw))
#define BCMI_TSCE16_XGXS_WRITE_UC_RMI_RA_AINC_NXT_WRADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr,(_r._uc_rmi_ra_ainc_nxt_wraddr_lsw)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_RMI_RA_AINC_NXT_WRADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr,(_r._uc_rmi_ra_ainc_nxt_wraddr_lsw))
#define BCMI_TSCE16_XGXS_READLN_UC_RMI_RA_AINC_NXT_WRADDR_LSWr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ra_ainc_nxt_wraddr_lsw))
#define BCMI_TSCE16_XGXS_WRITELN_UC_RMI_RA_AINC_NXT_WRADDR_LSWr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ra_ainc_nxt_wraddr_lsw))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_RMI_RA_AINC_NXT_WRADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_ra_ainc_nxt_wraddr_lsw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_RA_AINC_NXT_WRADDR_LSWr BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr
#define UC_RMI_RA_AINC_NXT_WRADDR_LSWr_SIZE BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_SIZE
typedef BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_t UC_RMI_RA_AINC_NXT_WRADDR_LSWr_t;
#define UC_RMI_RA_AINC_NXT_WRADDR_LSWr_CLR BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_CLR
#define UC_RMI_RA_AINC_NXT_WRADDR_LSWr_SET BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_SET
#define UC_RMI_RA_AINC_NXT_WRADDR_LSWr_GET BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_GET
#define UC_RMI_RA_AINC_NXT_WRADDR_LSWr_MICRO_RA_AUTOINC_NXT_WRADDR_LSWf_GET BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_MICRO_RA_AUTOINC_NXT_WRADDR_LSWf_GET
#define UC_RMI_RA_AINC_NXT_WRADDR_LSWr_MICRO_RA_AUTOINC_NXT_WRADDR_LSWf_SET BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_MICRO_RA_AUTOINC_NXT_WRADDR_LSWf_SET
#define READ_UC_RMI_RA_AINC_NXT_WRADDR_LSWr BCMI_TSCE16_XGXS_READ_UC_RMI_RA_AINC_NXT_WRADDR_LSWr
#define WRITE_UC_RMI_RA_AINC_NXT_WRADDR_LSWr BCMI_TSCE16_XGXS_WRITE_UC_RMI_RA_AINC_NXT_WRADDR_LSWr
#define MODIFY_UC_RMI_RA_AINC_NXT_WRADDR_LSWr BCMI_TSCE16_XGXS_MODIFY_UC_RMI_RA_AINC_NXT_WRADDR_LSWr
#define READLN_UC_RMI_RA_AINC_NXT_WRADDR_LSWr BCMI_TSCE16_XGXS_READLN_UC_RMI_RA_AINC_NXT_WRADDR_LSWr
#define WRITELN_UC_RMI_RA_AINC_NXT_WRADDR_LSWr BCMI_TSCE16_XGXS_WRITELN_UC_RMI_RA_AINC_NXT_WRADDR_LSWr
#define WRITEALL_UC_RMI_RA_AINC_NXT_WRADDR_LSWr BCMI_TSCE16_XGXS_WRITEALL_UC_RMI_RA_AINC_NXT_WRADDR_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_RMI_RA_AINC_NXT_RDADDR_LSW
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd219
 * DESC:     rmi to ahb auto-incremented read address LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RA_AUTOINC_NXT_RDADDR_LSW When the micro_autoinc_rdaddr_en is set, then these bitsindicate the lower 16-bits of the address that will be usedduring the next read transaction.These bits allow address tracking when rmi interface auto addressincrement mode is used
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr (0x0000d219 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_RA_AINC_NXT_RDADDR_LSW.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_s {
	uint32_t v[1];
	uint32_t uc_rmi_ra_ainc_nxt_rdaddr_lsw[1];
	uint32_t _uc_rmi_ra_ainc_nxt_rdaddr_lsw;
} BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_t;

#define BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_CLR(r) (r).uc_rmi_ra_ainc_nxt_rdaddr_lsw[0] = 0
#define BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_SET(r,d) (r).uc_rmi_ra_ainc_nxt_rdaddr_lsw[0] = d
#define BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_GET(r) (r).uc_rmi_ra_ainc_nxt_rdaddr_lsw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_MICRO_RA_AUTOINC_NXT_RDADDR_LSWf_GET(r) (((r).uc_rmi_ra_ainc_nxt_rdaddr_lsw[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_MICRO_RA_AUTOINC_NXT_RDADDR_LSWf_SET(r,f) (r).uc_rmi_ra_ainc_nxt_rdaddr_lsw[0]=(((r).uc_rmi_ra_ainc_nxt_rdaddr_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_RA_AINC_NXT_RDADDR_LSW.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_RMI_RA_AINC_NXT_RDADDR_LSWr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr,(_r._uc_rmi_ra_ainc_nxt_rdaddr_lsw))
#define BCMI_TSCE16_XGXS_WRITE_UC_RMI_RA_AINC_NXT_RDADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr,(_r._uc_rmi_ra_ainc_nxt_rdaddr_lsw)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_RMI_RA_AINC_NXT_RDADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr,(_r._uc_rmi_ra_ainc_nxt_rdaddr_lsw))
#define BCMI_TSCE16_XGXS_READLN_UC_RMI_RA_AINC_NXT_RDADDR_LSWr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ra_ainc_nxt_rdaddr_lsw))
#define BCMI_TSCE16_XGXS_WRITELN_UC_RMI_RA_AINC_NXT_RDADDR_LSWr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ra_ainc_nxt_rdaddr_lsw))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_RMI_RA_AINC_NXT_RDADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_ra_ainc_nxt_rdaddr_lsw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_RA_AINC_NXT_RDADDR_LSWr BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr
#define UC_RMI_RA_AINC_NXT_RDADDR_LSWr_SIZE BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_SIZE
typedef BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_t UC_RMI_RA_AINC_NXT_RDADDR_LSWr_t;
#define UC_RMI_RA_AINC_NXT_RDADDR_LSWr_CLR BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_CLR
#define UC_RMI_RA_AINC_NXT_RDADDR_LSWr_SET BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_SET
#define UC_RMI_RA_AINC_NXT_RDADDR_LSWr_GET BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_GET
#define UC_RMI_RA_AINC_NXT_RDADDR_LSWr_MICRO_RA_AUTOINC_NXT_RDADDR_LSWf_GET BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_MICRO_RA_AUTOINC_NXT_RDADDR_LSWf_GET
#define UC_RMI_RA_AINC_NXT_RDADDR_LSWr_MICRO_RA_AUTOINC_NXT_RDADDR_LSWf_SET BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_MICRO_RA_AUTOINC_NXT_RDADDR_LSWf_SET
#define READ_UC_RMI_RA_AINC_NXT_RDADDR_LSWr BCMI_TSCE16_XGXS_READ_UC_RMI_RA_AINC_NXT_RDADDR_LSWr
#define WRITE_UC_RMI_RA_AINC_NXT_RDADDR_LSWr BCMI_TSCE16_XGXS_WRITE_UC_RMI_RA_AINC_NXT_RDADDR_LSWr
#define MODIFY_UC_RMI_RA_AINC_NXT_RDADDR_LSWr BCMI_TSCE16_XGXS_MODIFY_UC_RMI_RA_AINC_NXT_RDADDR_LSWr
#define READLN_UC_RMI_RA_AINC_NXT_RDADDR_LSWr BCMI_TSCE16_XGXS_READLN_UC_RMI_RA_AINC_NXT_RDADDR_LSWr
#define WRITELN_UC_RMI_RA_AINC_NXT_RDADDR_LSWr BCMI_TSCE16_XGXS_WRITELN_UC_RMI_RA_AINC_NXT_RDADDR_LSWr
#define WRITEALL_UC_RMI_RA_AINC_NXT_RDADDR_LSWr BCMI_TSCE16_XGXS_WRITEALL_UC_RMI_RA_AINC_NXT_RDADDR_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_RMI_PR_AINC_NXT_WRADDR_LSW
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd21a
 * DESC:     pram i/f to ahb auto-incremented write address LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_PR_AUTOINC_NXT_WRADDR_LSW When pram interface is used to write to the code/data RAMthen these bits indicate the lower 16-bits of the address that will be usedduring the next write transaction.These bits allow address tracking
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr (0x0000d21a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_PR_AINC_NXT_WRADDR_LSW.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_s {
	uint32_t v[1];
	uint32_t uc_rmi_pr_ainc_nxt_wraddr_lsw[1];
	uint32_t _uc_rmi_pr_ainc_nxt_wraddr_lsw;
} BCMI_TSCE16_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_t;

#define BCMI_TSCE16_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_CLR(r) (r).uc_rmi_pr_ainc_nxt_wraddr_lsw[0] = 0
#define BCMI_TSCE16_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_SET(r,d) (r).uc_rmi_pr_ainc_nxt_wraddr_lsw[0] = d
#define BCMI_TSCE16_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_GET(r) (r).uc_rmi_pr_ainc_nxt_wraddr_lsw[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_MICRO_PR_AUTOINC_NXT_WRADDR_LSWf_GET(r) (((r).uc_rmi_pr_ainc_nxt_wraddr_lsw[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_MICRO_PR_AUTOINC_NXT_WRADDR_LSWf_SET(r,f) (r).uc_rmi_pr_ainc_nxt_wraddr_lsw[0]=(((r).uc_rmi_pr_ainc_nxt_wraddr_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_PR_AINC_NXT_WRADDR_LSW.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_RMI_PR_AINC_NXT_WRADDR_LSWr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr,(_r._uc_rmi_pr_ainc_nxt_wraddr_lsw))
#define BCMI_TSCE16_XGXS_WRITE_UC_RMI_PR_AINC_NXT_WRADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr,(_r._uc_rmi_pr_ainc_nxt_wraddr_lsw)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_RMI_PR_AINC_NXT_WRADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr,(_r._uc_rmi_pr_ainc_nxt_wraddr_lsw))
#define BCMI_TSCE16_XGXS_READLN_UC_RMI_PR_AINC_NXT_WRADDR_LSWr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_pr_ainc_nxt_wraddr_lsw))
#define BCMI_TSCE16_XGXS_WRITELN_UC_RMI_PR_AINC_NXT_WRADDR_LSWr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_pr_ainc_nxt_wraddr_lsw))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_RMI_PR_AINC_NXT_WRADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_pr_ainc_nxt_wraddr_lsw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_PR_AINC_NXT_WRADDR_LSWr BCMI_TSCE16_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr
#define UC_RMI_PR_AINC_NXT_WRADDR_LSWr_SIZE BCMI_TSCE16_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_SIZE
typedef BCMI_TSCE16_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_t UC_RMI_PR_AINC_NXT_WRADDR_LSWr_t;
#define UC_RMI_PR_AINC_NXT_WRADDR_LSWr_CLR BCMI_TSCE16_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_CLR
#define UC_RMI_PR_AINC_NXT_WRADDR_LSWr_SET BCMI_TSCE16_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_SET
#define UC_RMI_PR_AINC_NXT_WRADDR_LSWr_GET BCMI_TSCE16_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_GET
#define UC_RMI_PR_AINC_NXT_WRADDR_LSWr_MICRO_PR_AUTOINC_NXT_WRADDR_LSWf_GET BCMI_TSCE16_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_MICRO_PR_AUTOINC_NXT_WRADDR_LSWf_GET
#define UC_RMI_PR_AINC_NXT_WRADDR_LSWr_MICRO_PR_AUTOINC_NXT_WRADDR_LSWf_SET BCMI_TSCE16_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_MICRO_PR_AUTOINC_NXT_WRADDR_LSWf_SET
#define READ_UC_RMI_PR_AINC_NXT_WRADDR_LSWr BCMI_TSCE16_XGXS_READ_UC_RMI_PR_AINC_NXT_WRADDR_LSWr
#define WRITE_UC_RMI_PR_AINC_NXT_WRADDR_LSWr BCMI_TSCE16_XGXS_WRITE_UC_RMI_PR_AINC_NXT_WRADDR_LSWr
#define MODIFY_UC_RMI_PR_AINC_NXT_WRADDR_LSWr BCMI_TSCE16_XGXS_MODIFY_UC_RMI_PR_AINC_NXT_WRADDR_LSWr
#define READLN_UC_RMI_PR_AINC_NXT_WRADDR_LSWr BCMI_TSCE16_XGXS_READLN_UC_RMI_PR_AINC_NXT_WRADDR_LSWr
#define WRITELN_UC_RMI_PR_AINC_NXT_WRADDR_LSWr BCMI_TSCE16_XGXS_WRITELN_UC_RMI_PR_AINC_NXT_WRADDR_LSWr
#define WRITEALL_UC_RMI_PR_AINC_NXT_WRADDR_LSWr BCMI_TSCE16_XGXS_WRITEALL_UC_RMI_PR_AINC_NXT_WRADDR_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_RMI_PVT_CTL0
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd21b
 * DESC:     rmi pvt temperature control register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_PVT_TEMPDATA_FRCVAL temperature data force valueWhen micro_pvt_tempdata_frc field is set to 1'b1 then micro_pvt_tempdata_frcvalfield is used to set the temperature value. The temperature value can be readvia micro_pvt_tempdata_rmi field of the pvt_status0 register orvia ahbcommon_pvt_tempdata filed of the ahbcommon_pvt_tempdata register
 *     MICRO_PVT_TEMPDATA_FRC temperature dat force enableWhen micro_pvt_tempdata_frc field is set to 1'b1 then micro_pvt_tempdata_frcvalfield is used to set the temperature value. The temperature value can be readvia micro_pvt_tempdata_rmi field of the pvt_status0 register orvia ahbcommon_pvt_tempdata filed of the ahbcommon_pvt_tempdata register
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_RMI_PVT_CTL0r (0x0000d21b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_RMI_PVT_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_PVT_CTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_RMI_PVT_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_pvt_ctl0[1];
	uint32_t _uc_rmi_pvt_ctl0;
} BCMI_TSCE16_XGXS_UC_RMI_PVT_CTL0r_t;

#define BCMI_TSCE16_XGXS_UC_RMI_PVT_CTL0r_CLR(r) (r).uc_rmi_pvt_ctl0[0] = 0
#define BCMI_TSCE16_XGXS_UC_RMI_PVT_CTL0r_SET(r,d) (r).uc_rmi_pvt_ctl0[0] = d
#define BCMI_TSCE16_XGXS_UC_RMI_PVT_CTL0r_GET(r) (r).uc_rmi_pvt_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCf_GET(r) ((((r).uc_rmi_pvt_ctl0[0]) >> 12) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCf_SET(r,f) (r).uc_rmi_pvt_ctl0[0]=(((r).uc_rmi_pvt_ctl0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCE16_XGXS_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCVALf_GET(r) (((r).uc_rmi_pvt_ctl0[0]) & 0x3ff)
#define BCMI_TSCE16_XGXS_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCVALf_SET(r,f) (r).uc_rmi_pvt_ctl0[0]=(((r).uc_rmi_pvt_ctl0[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access UC_RMI_PVT_CTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_RMI_PVT_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_RMI_PVT_CTL0r,(_r._uc_rmi_pvt_ctl0))
#define BCMI_TSCE16_XGXS_WRITE_UC_RMI_PVT_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_PVT_CTL0r,(_r._uc_rmi_pvt_ctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_RMI_PVT_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_PVT_CTL0r,(_r._uc_rmi_pvt_ctl0))
#define BCMI_TSCE16_XGXS_READLN_UC_RMI_PVT_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_RMI_PVT_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_pvt_ctl0))
#define BCMI_TSCE16_XGXS_WRITELN_UC_RMI_PVT_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_PVT_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_pvt_ctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_RMI_PVT_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_PVT_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_pvt_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_PVT_CTL0r BCMI_TSCE16_XGXS_UC_RMI_PVT_CTL0r
#define UC_RMI_PVT_CTL0r_SIZE BCMI_TSCE16_XGXS_UC_RMI_PVT_CTL0r_SIZE
typedef BCMI_TSCE16_XGXS_UC_RMI_PVT_CTL0r_t UC_RMI_PVT_CTL0r_t;
#define UC_RMI_PVT_CTL0r_CLR BCMI_TSCE16_XGXS_UC_RMI_PVT_CTL0r_CLR
#define UC_RMI_PVT_CTL0r_SET BCMI_TSCE16_XGXS_UC_RMI_PVT_CTL0r_SET
#define UC_RMI_PVT_CTL0r_GET BCMI_TSCE16_XGXS_UC_RMI_PVT_CTL0r_GET
#define UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCf_GET BCMI_TSCE16_XGXS_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCf_GET
#define UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCf_SET BCMI_TSCE16_XGXS_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCf_SET
#define UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCVALf_GET BCMI_TSCE16_XGXS_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCVALf_GET
#define UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCVALf_SET BCMI_TSCE16_XGXS_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCVALf_SET
#define READ_UC_RMI_PVT_CTL0r BCMI_TSCE16_XGXS_READ_UC_RMI_PVT_CTL0r
#define WRITE_UC_RMI_PVT_CTL0r BCMI_TSCE16_XGXS_WRITE_UC_RMI_PVT_CTL0r
#define MODIFY_UC_RMI_PVT_CTL0r BCMI_TSCE16_XGXS_MODIFY_UC_RMI_PVT_CTL0r
#define READLN_UC_RMI_PVT_CTL0r BCMI_TSCE16_XGXS_READLN_UC_RMI_PVT_CTL0r
#define WRITELN_UC_RMI_PVT_CTL0r BCMI_TSCE16_XGXS_WRITELN_UC_RMI_PVT_CTL0r
#define WRITEALL_UC_RMI_PVT_CTL0r BCMI_TSCE16_XGXS_WRITEALL_UC_RMI_PVT_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_RMI_PVT_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_CODE_RAM_ECCCTL0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd220
 * DESC:     code ram ecc control 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_ECCG_MODE  ecc code generation mode0: Hardware mode - ECC code generated by hardware, ECC error checking enabled1: Software mode - ECC code from the rg_ra_ecc_wrdata field are written into code/data RAMECC error checking disabled. This mode is only supportedwhen register interface is used
 *     MICRO_ECC_FRC_DISABLE ecc force disable0: ECC Enabled  - ECC error code generation determine by the micro_eccg_mode fieldECC error checking enabled in hardware mode only1: ECC Disabled - ECC error codes values written into the RAM set to zeroECC error checking disabled
 *     MICRO_ECC_CORRUPT This field allows the ecc codes to be corrupted for testing.2'b00 - normal mode2'b01 - corrupt the ECC code written into the code/data RAM2'b10 - corrupt data - add 1 bit data error on the RX side2'b11 - corrupt data - add 2 bit data error on the RA side
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCTL0r (0x0000d220 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_CODE_RAM_ECCCTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCTL0r_s {
	uint32_t v[1];
	uint32_t uc_code_ram_eccctl0[1];
	uint32_t _uc_code_ram_eccctl0;
} BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCTL0r_t;

#define BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCTL0r_CLR(r) (r).uc_code_ram_eccctl0[0] = 0
#define BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCTL0r_SET(r,d) (r).uc_code_ram_eccctl0[0] = d
#define BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCTL0r_GET(r) (r).uc_code_ram_eccctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCTL0r_MICRO_ECC_CORRUPTf_GET(r) ((((r).uc_code_ram_eccctl0[0]) >> 4) & 0x3)
#define BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCTL0r_MICRO_ECC_CORRUPTf_SET(r,f) (r).uc_code_ram_eccctl0[0]=(((r).uc_code_ram_eccctl0[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCTL0r_MICRO_ECC_FRC_DISABLEf_GET(r) ((((r).uc_code_ram_eccctl0[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCTL0r_MICRO_ECC_FRC_DISABLEf_SET(r,f) (r).uc_code_ram_eccctl0[0]=(((r).uc_code_ram_eccctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCTL0r_MICRO_ECCG_MODEf_GET(r) (((r).uc_code_ram_eccctl0[0]) & 0x1)
#define BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCTL0r_MICRO_ECCG_MODEf_SET(r,f) (r).uc_code_ram_eccctl0[0]=(((r).uc_code_ram_eccctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_CODE_RAM_ECCCTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_CODE_RAM_ECCCTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCTL0r,(_r._uc_code_ram_eccctl0))
#define BCMI_TSCE16_XGXS_WRITE_UC_CODE_RAM_ECCCTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCTL0r,(_r._uc_code_ram_eccctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_CODE_RAM_ECCCTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCTL0r,(_r._uc_code_ram_eccctl0))
#define BCMI_TSCE16_XGXS_READLN_UC_CODE_RAM_ECCCTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_code_ram_eccctl0))
#define BCMI_TSCE16_XGXS_WRITELN_UC_CODE_RAM_ECCCTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_code_ram_eccctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_CODE_RAM_ECCCTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_code_ram_eccctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_CODE_RAM_ECCCTL0r BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCTL0r
#define UC_CODE_RAM_ECCCTL0r_SIZE BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCTL0r_SIZE
typedef BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCTL0r_t UC_CODE_RAM_ECCCTL0r_t;
#define UC_CODE_RAM_ECCCTL0r_CLR BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCTL0r_CLR
#define UC_CODE_RAM_ECCCTL0r_SET BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCTL0r_SET
#define UC_CODE_RAM_ECCCTL0r_GET BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCTL0r_GET
#define UC_CODE_RAM_ECCCTL0r_MICRO_ECC_CORRUPTf_GET BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCTL0r_MICRO_ECC_CORRUPTf_GET
#define UC_CODE_RAM_ECCCTL0r_MICRO_ECC_CORRUPTf_SET BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCTL0r_MICRO_ECC_CORRUPTf_SET
#define UC_CODE_RAM_ECCCTL0r_MICRO_ECC_FRC_DISABLEf_GET BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCTL0r_MICRO_ECC_FRC_DISABLEf_GET
#define UC_CODE_RAM_ECCCTL0r_MICRO_ECC_FRC_DISABLEf_SET BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCTL0r_MICRO_ECC_FRC_DISABLEf_SET
#define UC_CODE_RAM_ECCCTL0r_MICRO_ECCG_MODEf_GET BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCTL0r_MICRO_ECCG_MODEf_GET
#define UC_CODE_RAM_ECCCTL0r_MICRO_ECCG_MODEf_SET BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCTL0r_MICRO_ECCG_MODEf_SET
#define READ_UC_CODE_RAM_ECCCTL0r BCMI_TSCE16_XGXS_READ_UC_CODE_RAM_ECCCTL0r
#define WRITE_UC_CODE_RAM_ECCCTL0r BCMI_TSCE16_XGXS_WRITE_UC_CODE_RAM_ECCCTL0r
#define MODIFY_UC_CODE_RAM_ECCCTL0r BCMI_TSCE16_XGXS_MODIFY_UC_CODE_RAM_ECCCTL0r
#define READLN_UC_CODE_RAM_ECCCTL0r BCMI_TSCE16_XGXS_READLN_UC_CODE_RAM_ECCCTL0r
#define WRITELN_UC_CODE_RAM_ECCCTL0r BCMI_TSCE16_XGXS_WRITELN_UC_CODE_RAM_ECCCTL0r
#define WRITEALL_UC_CODE_RAM_ECCCTL0r BCMI_TSCE16_XGXS_WRITEALL_UC_CODE_RAM_ECCCTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_CODE_RAM_ECCCONTRO1
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd221
 * DESC:     code ram ecc control 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_ECC_WRDATA This foield is used to write the ECC codes into the code/data when ECC software modes is enabled
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCONTRO1r (0x0000d221 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCONTRO1r_SIZE 4

/*
 * This structure should be used to declare and program UC_CODE_RAM_ECCCONTRO1.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCONTRO1r_s {
	uint32_t v[1];
	uint32_t uc_code_ram_ecccontro1[1];
	uint32_t _uc_code_ram_ecccontro1;
} BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCONTRO1r_t;

#define BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCONTRO1r_CLR(r) (r).uc_code_ram_ecccontro1[0] = 0
#define BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCONTRO1r_SET(r,d) (r).uc_code_ram_ecccontro1[0] = d
#define BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCONTRO1r_GET(r) (r).uc_code_ram_ecccontro1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCONTRO1r_MICRO_RA_ECC_WRDATAf_GET(r) (((r).uc_code_ram_ecccontro1[0]) & 0x7f)
#define BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCONTRO1r_MICRO_RA_ECC_WRDATAf_SET(r,f) (r).uc_code_ram_ecccontro1[0]=(((r).uc_code_ram_ecccontro1[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access UC_CODE_RAM_ECCCONTRO1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_CODE_RAM_ECCCONTRO1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCONTRO1r,(_r._uc_code_ram_ecccontro1))
#define BCMI_TSCE16_XGXS_WRITE_UC_CODE_RAM_ECCCONTRO1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCONTRO1r,(_r._uc_code_ram_ecccontro1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_CODE_RAM_ECCCONTRO1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCONTRO1r,(_r._uc_code_ram_ecccontro1))
#define BCMI_TSCE16_XGXS_READLN_UC_CODE_RAM_ECCCONTRO1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCONTRO1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_code_ram_ecccontro1))
#define BCMI_TSCE16_XGXS_WRITELN_UC_CODE_RAM_ECCCONTRO1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCONTRO1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_code_ram_ecccontro1))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_CODE_RAM_ECCCONTRO1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCONTRO1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_code_ram_ecccontro1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_CODE_RAM_ECCCONTRO1r BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCONTRO1r
#define UC_CODE_RAM_ECCCONTRO1r_SIZE BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCONTRO1r_SIZE
typedef BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCONTRO1r_t UC_CODE_RAM_ECCCONTRO1r_t;
#define UC_CODE_RAM_ECCCONTRO1r_CLR BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCONTRO1r_CLR
#define UC_CODE_RAM_ECCCONTRO1r_SET BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCONTRO1r_SET
#define UC_CODE_RAM_ECCCONTRO1r_GET BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCONTRO1r_GET
#define UC_CODE_RAM_ECCCONTRO1r_MICRO_RA_ECC_WRDATAf_GET BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCONTRO1r_MICRO_RA_ECC_WRDATAf_GET
#define UC_CODE_RAM_ECCCONTRO1r_MICRO_RA_ECC_WRDATAf_SET BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCONTRO1r_MICRO_RA_ECC_WRDATAf_SET
#define READ_UC_CODE_RAM_ECCCONTRO1r BCMI_TSCE16_XGXS_READ_UC_CODE_RAM_ECCCONTRO1r
#define WRITE_UC_CODE_RAM_ECCCONTRO1r BCMI_TSCE16_XGXS_WRITE_UC_CODE_RAM_ECCCONTRO1r
#define MODIFY_UC_CODE_RAM_ECCCONTRO1r BCMI_TSCE16_XGXS_MODIFY_UC_CODE_RAM_ECCCONTRO1r
#define READLN_UC_CODE_RAM_ECCCONTRO1r BCMI_TSCE16_XGXS_READLN_UC_CODE_RAM_ECCCONTRO1r
#define WRITELN_UC_CODE_RAM_ECCCONTRO1r BCMI_TSCE16_XGXS_WRITELN_UC_CODE_RAM_ECCCONTRO1r
#define WRITEALL_UC_CODE_RAM_ECCCONTRO1r BCMI_TSCE16_XGXS_WRITEALL_UC_CODE_RAM_ECCCONTRO1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCCONTRO1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_CODE_RAM_ECCSTS0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd222
 * DESC:     code ram ecc status 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_CODE_RAM_ECC_ADDRESS First ecc error address
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS0r (0x0000d222 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS0r_SIZE 4

/*
 * This structure should be used to declare and program UC_CODE_RAM_ECCSTS0.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS0r_s {
	uint32_t v[1];
	uint32_t uc_code_ram_eccsts0[1];
	uint32_t _uc_code_ram_eccsts0;
} BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS0r_t;

#define BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS0r_CLR(r) (r).uc_code_ram_eccsts0[0] = 0
#define BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS0r_SET(r,d) (r).uc_code_ram_eccsts0[0] = d
#define BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS0r_GET(r) (r).uc_code_ram_eccsts0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS0r_MICRO_CODE_RAM_ECC_ADDRESSf_GET(r) (((r).uc_code_ram_eccsts0[0]) & 0x7fff)
#define BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS0r_MICRO_CODE_RAM_ECC_ADDRESSf_SET(r,f) (r).uc_code_ram_eccsts0[0]=(((r).uc_code_ram_eccsts0[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff)) | (0x7fff << 16)

/*
 * These macros can be used to access UC_CODE_RAM_ECCSTS0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_CODE_RAM_ECCSTS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS0r,(_r._uc_code_ram_eccsts0))
#define BCMI_TSCE16_XGXS_WRITE_UC_CODE_RAM_ECCSTS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS0r,(_r._uc_code_ram_eccsts0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_CODE_RAM_ECCSTS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS0r,(_r._uc_code_ram_eccsts0))
#define BCMI_TSCE16_XGXS_READLN_UC_CODE_RAM_ECCSTS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_code_ram_eccsts0))
#define BCMI_TSCE16_XGXS_WRITELN_UC_CODE_RAM_ECCSTS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_code_ram_eccsts0))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_CODE_RAM_ECCSTS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_code_ram_eccsts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_CODE_RAM_ECCSTS0r BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS0r
#define UC_CODE_RAM_ECCSTS0r_SIZE BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS0r_SIZE
typedef BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS0r_t UC_CODE_RAM_ECCSTS0r_t;
#define UC_CODE_RAM_ECCSTS0r_CLR BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS0r_CLR
#define UC_CODE_RAM_ECCSTS0r_SET BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS0r_SET
#define UC_CODE_RAM_ECCSTS0r_GET BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS0r_GET
#define UC_CODE_RAM_ECCSTS0r_MICRO_CODE_RAM_ECC_ADDRESSf_GET BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS0r_MICRO_CODE_RAM_ECC_ADDRESSf_GET
#define UC_CODE_RAM_ECCSTS0r_MICRO_CODE_RAM_ECC_ADDRESSf_SET BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS0r_MICRO_CODE_RAM_ECC_ADDRESSf_SET
#define READ_UC_CODE_RAM_ECCSTS0r BCMI_TSCE16_XGXS_READ_UC_CODE_RAM_ECCSTS0r
#define WRITE_UC_CODE_RAM_ECCSTS0r BCMI_TSCE16_XGXS_WRITE_UC_CODE_RAM_ECCSTS0r
#define MODIFY_UC_CODE_RAM_ECCSTS0r BCMI_TSCE16_XGXS_MODIFY_UC_CODE_RAM_ECCSTS0r
#define READLN_UC_CODE_RAM_ECCSTS0r BCMI_TSCE16_XGXS_READLN_UC_CODE_RAM_ECCSTS0r
#define WRITELN_UC_CODE_RAM_ECCSTS0r BCMI_TSCE16_XGXS_WRITELN_UC_CODE_RAM_ECCSTS0r
#define WRITEALL_UC_CODE_RAM_ECCSTS0r BCMI_TSCE16_XGXS_WRITEALL_UC_CODE_RAM_ECCSTS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_CODE_RAM_ECCSTS1
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd223
 * DESC:     code ram ecc status 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RA_ECC_RDDATA When the register interface is used to read code/data RAM, then this field can be usedread the ECC codes currently stored in the code/data RAM
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS1r (0x0000d223 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS1r_SIZE 4

/*
 * This structure should be used to declare and program UC_CODE_RAM_ECCSTS1.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS1r_s {
	uint32_t v[1];
	uint32_t uc_code_ram_eccsts1[1];
	uint32_t _uc_code_ram_eccsts1;
} BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS1r_t;

#define BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS1r_CLR(r) (r).uc_code_ram_eccsts1[0] = 0
#define BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS1r_SET(r,d) (r).uc_code_ram_eccsts1[0] = d
#define BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS1r_GET(r) (r).uc_code_ram_eccsts1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS1r_MICRO_RA_ECC_RDDATAf_GET(r) (((r).uc_code_ram_eccsts1[0]) & 0x7f)
#define BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS1r_MICRO_RA_ECC_RDDATAf_SET(r,f) (r).uc_code_ram_eccsts1[0]=(((r).uc_code_ram_eccsts1[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access UC_CODE_RAM_ECCSTS1.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_CODE_RAM_ECCSTS1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS1r,(_r._uc_code_ram_eccsts1))
#define BCMI_TSCE16_XGXS_WRITE_UC_CODE_RAM_ECCSTS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS1r,(_r._uc_code_ram_eccsts1)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_CODE_RAM_ECCSTS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS1r,(_r._uc_code_ram_eccsts1))
#define BCMI_TSCE16_XGXS_READLN_UC_CODE_RAM_ECCSTS1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_code_ram_eccsts1))
#define BCMI_TSCE16_XGXS_WRITELN_UC_CODE_RAM_ECCSTS1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_code_ram_eccsts1))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_CODE_RAM_ECCSTS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_code_ram_eccsts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_CODE_RAM_ECCSTS1r BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS1r
#define UC_CODE_RAM_ECCSTS1r_SIZE BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS1r_SIZE
typedef BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS1r_t UC_CODE_RAM_ECCSTS1r_t;
#define UC_CODE_RAM_ECCSTS1r_CLR BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS1r_CLR
#define UC_CODE_RAM_ECCSTS1r_SET BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS1r_SET
#define UC_CODE_RAM_ECCSTS1r_GET BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS1r_GET
#define UC_CODE_RAM_ECCSTS1r_MICRO_RA_ECC_RDDATAf_GET BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS1r_MICRO_RA_ECC_RDDATAf_GET
#define UC_CODE_RAM_ECCSTS1r_MICRO_RA_ECC_RDDATAf_SET BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS1r_MICRO_RA_ECC_RDDATAf_SET
#define READ_UC_CODE_RAM_ECCSTS1r BCMI_TSCE16_XGXS_READ_UC_CODE_RAM_ECCSTS1r
#define WRITE_UC_CODE_RAM_ECCSTS1r BCMI_TSCE16_XGXS_WRITE_UC_CODE_RAM_ECCSTS1r
#define MODIFY_UC_CODE_RAM_ECCSTS1r BCMI_TSCE16_XGXS_MODIFY_UC_CODE_RAM_ECCSTS1r
#define READLN_UC_CODE_RAM_ECCSTS1r BCMI_TSCE16_XGXS_READLN_UC_CODE_RAM_ECCSTS1r
#define WRITELN_UC_CODE_RAM_ECCSTS1r BCMI_TSCE16_XGXS_WRITELN_UC_CODE_RAM_ECCSTS1r
#define WRITEALL_UC_CODE_RAM_ECCSTS1r BCMI_TSCE16_XGXS_WRITEALL_UC_CODE_RAM_ECCSTS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_CODE_RAM_ECCSTS1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_CODE_RAM_TESTIFCTL0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd224
 * DESC:     code ram test interface control 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_CODE_RAM_TM Test Mode.These pins are used to put the instance into various testmodes that can be used for a number of different purposesincluding extended screening, yield improvement and debug.The default mode of the instance is tm<?:0>='d0. It ishighly recommended that the user has control over all thetm<?:0> inputs. All tm<?:0> inputs are asynchronous. Seethe Test Modes section of the on line M16SP WebSpecification for further details.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_CODE_RAM_TESTIFCTL0r (0x0000d224 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_CODE_RAM_TESTIFCTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_CODE_RAM_TESTIFCTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_CODE_RAM_TESTIFCTL0r_s {
	uint32_t v[1];
	uint32_t uc_code_ram_testifctl0[1];
	uint32_t _uc_code_ram_testifctl0;
} BCMI_TSCE16_XGXS_UC_CODE_RAM_TESTIFCTL0r_t;

#define BCMI_TSCE16_XGXS_UC_CODE_RAM_TESTIFCTL0r_CLR(r) (r).uc_code_ram_testifctl0[0] = 0
#define BCMI_TSCE16_XGXS_UC_CODE_RAM_TESTIFCTL0r_SET(r,d) (r).uc_code_ram_testifctl0[0] = d
#define BCMI_TSCE16_XGXS_UC_CODE_RAM_TESTIFCTL0r_GET(r) (r).uc_code_ram_testifctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_CODE_RAM_TESTIFCTL0r_MICRO_CODE_RAM_TMf_GET(r) (((r).uc_code_ram_testifctl0[0]) & 0x7f)
#define BCMI_TSCE16_XGXS_UC_CODE_RAM_TESTIFCTL0r_MICRO_CODE_RAM_TMf_SET(r,f) (r).uc_code_ram_testifctl0[0]=(((r).uc_code_ram_testifctl0[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access UC_CODE_RAM_TESTIFCTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_CODE_RAM_TESTIFCTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_CODE_RAM_TESTIFCTL0r,(_r._uc_code_ram_testifctl0))
#define BCMI_TSCE16_XGXS_WRITE_UC_CODE_RAM_TESTIFCTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_CODE_RAM_TESTIFCTL0r,(_r._uc_code_ram_testifctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_CODE_RAM_TESTIFCTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_CODE_RAM_TESTIFCTL0r,(_r._uc_code_ram_testifctl0))
#define BCMI_TSCE16_XGXS_READLN_UC_CODE_RAM_TESTIFCTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_CODE_RAM_TESTIFCTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_code_ram_testifctl0))
#define BCMI_TSCE16_XGXS_WRITELN_UC_CODE_RAM_TESTIFCTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_CODE_RAM_TESTIFCTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_code_ram_testifctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_CODE_RAM_TESTIFCTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_CODE_RAM_TESTIFCTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_code_ram_testifctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_CODE_RAM_TESTIFCTL0r BCMI_TSCE16_XGXS_UC_CODE_RAM_TESTIFCTL0r
#define UC_CODE_RAM_TESTIFCTL0r_SIZE BCMI_TSCE16_XGXS_UC_CODE_RAM_TESTIFCTL0r_SIZE
typedef BCMI_TSCE16_XGXS_UC_CODE_RAM_TESTIFCTL0r_t UC_CODE_RAM_TESTIFCTL0r_t;
#define UC_CODE_RAM_TESTIFCTL0r_CLR BCMI_TSCE16_XGXS_UC_CODE_RAM_TESTIFCTL0r_CLR
#define UC_CODE_RAM_TESTIFCTL0r_SET BCMI_TSCE16_XGXS_UC_CODE_RAM_TESTIFCTL0r_SET
#define UC_CODE_RAM_TESTIFCTL0r_GET BCMI_TSCE16_XGXS_UC_CODE_RAM_TESTIFCTL0r_GET
#define UC_CODE_RAM_TESTIFCTL0r_MICRO_CODE_RAM_TMf_GET BCMI_TSCE16_XGXS_UC_CODE_RAM_TESTIFCTL0r_MICRO_CODE_RAM_TMf_GET
#define UC_CODE_RAM_TESTIFCTL0r_MICRO_CODE_RAM_TMf_SET BCMI_TSCE16_XGXS_UC_CODE_RAM_TESTIFCTL0r_MICRO_CODE_RAM_TMf_SET
#define READ_UC_CODE_RAM_TESTIFCTL0r BCMI_TSCE16_XGXS_READ_UC_CODE_RAM_TESTIFCTL0r
#define WRITE_UC_CODE_RAM_TESTIFCTL0r BCMI_TSCE16_XGXS_WRITE_UC_CODE_RAM_TESTIFCTL0r
#define MODIFY_UC_CODE_RAM_TESTIFCTL0r BCMI_TSCE16_XGXS_MODIFY_UC_CODE_RAM_TESTIFCTL0r
#define READLN_UC_CODE_RAM_TESTIFCTL0r BCMI_TSCE16_XGXS_READLN_UC_CODE_RAM_TESTIFCTL0r
#define WRITELN_UC_CODE_RAM_TESTIFCTL0r BCMI_TSCE16_XGXS_WRITELN_UC_CODE_RAM_TESTIFCTL0r
#define WRITEALL_UC_CODE_RAM_TESTIFCTL0r BCMI_TSCE16_XGXS_WRITEALL_UC_CODE_RAM_TESTIFCTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_CODE_RAM_TESTIFCTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_RAM_CTL0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd225
 * DESC:     ram configuration register 0
 * RESETVAL: 0x8401 (33793)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_DR_LOOKTAB_EN Data RAM lookup table enable1 - Data RAM mapped in the data region by hardwarestarting at address 0x2000_0000 (for software compatibilty)0 - Data RAM not mapped by hardwareFirmware defines code/data regiions
 *     MICRO_PROTECT_FWCODE protect firmware code during micro master reset1 - RAM address, data, chip select and write enable are set to inactive stateto prevent timing violations from corrupting the contents of the RAMIf this field is used then the software has to clear this filed before re-starting the micro0 - RAM address, data, chip select and write enable are set to inactive stateby using micro_master_rstb register field to prevent timing violations from corrupting the contents of the RAM
 *     MICRO_DR_SIZE    Data/Code RAM allocation when the micro_dr_looktab_en field is set to 1'b1The RAM is 36KB and this field can be used to allocate data/code RAM on a 1KB granualarity6'd0  : Data RAM = 0KB,  Code RAM = 36KB6'd1  : Data RAM = 1KB,  Code RAM = 35KB6'd2  : Data RAM = 2KB,  Code RAM = 34KB...   : Data RAM = .. ,  Code RAM = .....   : Data RAM = .. ,  Code RAM = ..6'd35 : Data RAM = 35KB, Code RAM = 1KB6'd36 : Data RAM = 36KB, Code RAM = 0KBPLEASE NOTE: the micro in the PMD core does not have any additional RAM to store Code/Datatherfore a value of 0 and 36 should not be used
 *     MICRO_RAMCLK_NONINV Code/Data RAM clock non-inverted0 - inverted1 - non-invertedWhen non-inverted clock to RAM is used, then a wait state to be inserted during read access.However, it eliminates the use of both edges of the clock (duty cycle) and makes the timing closer easier
 *     MICRO_IGNORE_M0_CODE_WRITES Ignore Micro writes to the code portion of the RAM0 - Allow writes1 - Ignore writes
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_RAM_CTL0r (0x0000d225 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_RAM_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RAM_CTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_RAM_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_ram_ctl0[1];
	uint32_t _uc_ram_ctl0;
} BCMI_TSCE16_XGXS_UC_RAM_CTL0r_t;

#define BCMI_TSCE16_XGXS_UC_RAM_CTL0r_CLR(r) (r).uc_ram_ctl0[0] = 0
#define BCMI_TSCE16_XGXS_UC_RAM_CTL0r_SET(r,d) (r).uc_ram_ctl0[0] = d
#define BCMI_TSCE16_XGXS_UC_RAM_CTL0r_GET(r) (r).uc_ram_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_RAM_CTL0r_MICRO_IGNORE_M0_CODE_WRITESf_GET(r) ((((r).uc_ram_ctl0[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RAM_CTL0r_MICRO_IGNORE_M0_CODE_WRITESf_SET(r,f) (r).uc_ram_ctl0[0]=(((r).uc_ram_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_UC_RAM_CTL0r_MICRO_RAMCLK_NONINVf_GET(r) ((((r).uc_ram_ctl0[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RAM_CTL0r_MICRO_RAMCLK_NONINVf_SET(r,f) (r).uc_ram_ctl0[0]=(((r).uc_ram_ctl0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_UC_RAM_CTL0r_MICRO_DR_SIZEf_GET(r) ((((r).uc_ram_ctl0[0]) >> 8) & 0x3f)
#define BCMI_TSCE16_XGXS_UC_RAM_CTL0r_MICRO_DR_SIZEf_SET(r,f) (r).uc_ram_ctl0[0]=(((r).uc_ram_ctl0[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_TSCE16_XGXS_UC_RAM_CTL0r_MICRO_PROTECT_FWCODEf_GET(r) ((((r).uc_ram_ctl0[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RAM_CTL0r_MICRO_PROTECT_FWCODEf_SET(r,f) (r).uc_ram_ctl0[0]=(((r).uc_ram_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_UC_RAM_CTL0r_MICRO_DR_LOOKTAB_ENf_GET(r) (((r).uc_ram_ctl0[0]) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RAM_CTL0r_MICRO_DR_LOOKTAB_ENf_SET(r,f) (r).uc_ram_ctl0[0]=(((r).uc_ram_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RAM_CTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_RAM_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_RAM_CTL0r,(_r._uc_ram_ctl0))
#define BCMI_TSCE16_XGXS_WRITE_UC_RAM_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RAM_CTL0r,(_r._uc_ram_ctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_RAM_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RAM_CTL0r,(_r._uc_ram_ctl0))
#define BCMI_TSCE16_XGXS_READLN_UC_RAM_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_RAM_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_ctl0))
#define BCMI_TSCE16_XGXS_WRITELN_UC_RAM_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RAM_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_ctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_RAM_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RAM_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ram_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RAM_CTL0r BCMI_TSCE16_XGXS_UC_RAM_CTL0r
#define UC_RAM_CTL0r_SIZE BCMI_TSCE16_XGXS_UC_RAM_CTL0r_SIZE
typedef BCMI_TSCE16_XGXS_UC_RAM_CTL0r_t UC_RAM_CTL0r_t;
#define UC_RAM_CTL0r_CLR BCMI_TSCE16_XGXS_UC_RAM_CTL0r_CLR
#define UC_RAM_CTL0r_SET BCMI_TSCE16_XGXS_UC_RAM_CTL0r_SET
#define UC_RAM_CTL0r_GET BCMI_TSCE16_XGXS_UC_RAM_CTL0r_GET
#define UC_RAM_CTL0r_MICRO_IGNORE_M0_CODE_WRITESf_GET BCMI_TSCE16_XGXS_UC_RAM_CTL0r_MICRO_IGNORE_M0_CODE_WRITESf_GET
#define UC_RAM_CTL0r_MICRO_IGNORE_M0_CODE_WRITESf_SET BCMI_TSCE16_XGXS_UC_RAM_CTL0r_MICRO_IGNORE_M0_CODE_WRITESf_SET
#define UC_RAM_CTL0r_MICRO_RAMCLK_NONINVf_GET BCMI_TSCE16_XGXS_UC_RAM_CTL0r_MICRO_RAMCLK_NONINVf_GET
#define UC_RAM_CTL0r_MICRO_RAMCLK_NONINVf_SET BCMI_TSCE16_XGXS_UC_RAM_CTL0r_MICRO_RAMCLK_NONINVf_SET
#define UC_RAM_CTL0r_MICRO_DR_SIZEf_GET BCMI_TSCE16_XGXS_UC_RAM_CTL0r_MICRO_DR_SIZEf_GET
#define UC_RAM_CTL0r_MICRO_DR_SIZEf_SET BCMI_TSCE16_XGXS_UC_RAM_CTL0r_MICRO_DR_SIZEf_SET
#define UC_RAM_CTL0r_MICRO_PROTECT_FWCODEf_GET BCMI_TSCE16_XGXS_UC_RAM_CTL0r_MICRO_PROTECT_FWCODEf_GET
#define UC_RAM_CTL0r_MICRO_PROTECT_FWCODEf_SET BCMI_TSCE16_XGXS_UC_RAM_CTL0r_MICRO_PROTECT_FWCODEf_SET
#define UC_RAM_CTL0r_MICRO_DR_LOOKTAB_ENf_GET BCMI_TSCE16_XGXS_UC_RAM_CTL0r_MICRO_DR_LOOKTAB_ENf_GET
#define UC_RAM_CTL0r_MICRO_DR_LOOKTAB_ENf_SET BCMI_TSCE16_XGXS_UC_RAM_CTL0r_MICRO_DR_LOOKTAB_ENf_SET
#define READ_UC_RAM_CTL0r BCMI_TSCE16_XGXS_READ_UC_RAM_CTL0r
#define WRITE_UC_RAM_CTL0r BCMI_TSCE16_XGXS_WRITE_UC_RAM_CTL0r
#define MODIFY_UC_RAM_CTL0r BCMI_TSCE16_XGXS_MODIFY_UC_RAM_CTL0r
#define READLN_UC_RAM_CTL0r BCMI_TSCE16_XGXS_READLN_UC_RAM_CTL0r
#define WRITELN_UC_RAM_CTL0r BCMI_TSCE16_XGXS_WRITELN_UC_RAM_CTL0r
#define WRITEALL_UC_RAM_CTL0r BCMI_TSCE16_XGXS_WRITEALL_UC_RAM_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_RAM_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_RMI_EXT_INTR_CTL0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd226
 * DESC:     rmi external interrupt control register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RMI_MBOX_MSGOUT_INTR_EN Message out (from Micro) interrupt enableWhen this field is set to 1'b1 then the micro_rmi_mbox_msgout_status field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 *     MICRO_RMI_ECC_CORR_ERR_INTR_EN ECC 1 bit correctable error detect interrupt enableWhen this field is set to 1'b1 then the micro_rmi_ecc_corr_err_status field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 *     MICRO_RMI_ECC_UNCORR_ERR_INTR_EN ECC 2 bit un-correctable error detect interrupt enableWhen this field is set to 1'b1 then the micro_rmi_ecc_uncorr_err_status field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 *     MICRO_RMI_ECC_MULTIROW_ERR_INTR_EN ECC error on multiple row detect interrupt enableWhen this field is set to 1'b1 then the micro_rmi_ecc_multirow_err_status field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 *     MICRO_RMI_M0_LOCKUP_INTR_EN M0 lockup interrupt enableWhen this field is set to 1'b1 then the micro_rmi_m0_lockup_status field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 *     MICRO_RMI_M0_SYSTEMRESETREQ_INTR_EN M0 systemresetreq interrupt enableWhen this field is set to 1'b1 then the micro_rmi_m0_systemresetreq_status field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r (0x0000d226 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_EXT_INTR_CTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_ext_intr_ctl0[1];
	uint32_t _uc_rmi_ext_intr_ctl0;
} BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r_t;

#define BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r_CLR(r) (r).uc_rmi_ext_intr_ctl0[0] = 0
#define BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r_SET(r,d) (r).uc_rmi_ext_intr_ctl0[0] = d
#define BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r_GET(r) (r).uc_rmi_ext_intr_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_SYSTEMRESETREQ_INTR_ENf_GET(r) ((((r).uc_rmi_ext_intr_ctl0[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_SYSTEMRESETREQ_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_LOCKUP_INTR_ENf_GET(r) ((((r).uc_rmi_ext_intr_ctl0[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_LOCKUP_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_MULTIROW_ERR_INTR_ENf_GET(r) ((((r).uc_rmi_ext_intr_ctl0[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_MULTIROW_ERR_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_UNCORR_ERR_INTR_ENf_GET(r) ((((r).uc_rmi_ext_intr_ctl0[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_UNCORR_ERR_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_CORR_ERR_INTR_ENf_GET(r) ((((r).uc_rmi_ext_intr_ctl0[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_CORR_ERR_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_MBOX_MSGOUT_INTR_ENf_GET(r) (((r).uc_rmi_ext_intr_ctl0[0]) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_MBOX_MSGOUT_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RMI_EXT_INTR_CTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_RMI_EXT_INTR_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r,(_r._uc_rmi_ext_intr_ctl0))
#define BCMI_TSCE16_XGXS_WRITE_UC_RMI_EXT_INTR_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r,(_r._uc_rmi_ext_intr_ctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_RMI_EXT_INTR_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r,(_r._uc_rmi_ext_intr_ctl0))
#define BCMI_TSCE16_XGXS_READLN_UC_RMI_EXT_INTR_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ext_intr_ctl0))
#define BCMI_TSCE16_XGXS_WRITELN_UC_RMI_EXT_INTR_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ext_intr_ctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_RMI_EXT_INTR_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_ext_intr_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_EXT_INTR_CTL0r BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r
#define UC_RMI_EXT_INTR_CTL0r_SIZE BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r_SIZE
typedef BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r_t UC_RMI_EXT_INTR_CTL0r_t;
#define UC_RMI_EXT_INTR_CTL0r_CLR BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r_CLR
#define UC_RMI_EXT_INTR_CTL0r_SET BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r_SET
#define UC_RMI_EXT_INTR_CTL0r_GET BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_SYSTEMRESETREQ_INTR_ENf_GET BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_SYSTEMRESETREQ_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_SYSTEMRESETREQ_INTR_ENf_SET BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_SYSTEMRESETREQ_INTR_ENf_SET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_LOCKUP_INTR_ENf_GET BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_LOCKUP_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_LOCKUP_INTR_ENf_SET BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_LOCKUP_INTR_ENf_SET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_MULTIROW_ERR_INTR_ENf_GET BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_MULTIROW_ERR_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_MULTIROW_ERR_INTR_ENf_SET BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_MULTIROW_ERR_INTR_ENf_SET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_UNCORR_ERR_INTR_ENf_GET BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_UNCORR_ERR_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_UNCORR_ERR_INTR_ENf_SET BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_UNCORR_ERR_INTR_ENf_SET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_CORR_ERR_INTR_ENf_GET BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_CORR_ERR_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_CORR_ERR_INTR_ENf_SET BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_CORR_ERR_INTR_ENf_SET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_MBOX_MSGOUT_INTR_ENf_GET BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_MBOX_MSGOUT_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_MBOX_MSGOUT_INTR_ENf_SET BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_MBOX_MSGOUT_INTR_ENf_SET
#define READ_UC_RMI_EXT_INTR_CTL0r BCMI_TSCE16_XGXS_READ_UC_RMI_EXT_INTR_CTL0r
#define WRITE_UC_RMI_EXT_INTR_CTL0r BCMI_TSCE16_XGXS_WRITE_UC_RMI_EXT_INTR_CTL0r
#define MODIFY_UC_RMI_EXT_INTR_CTL0r BCMI_TSCE16_XGXS_MODIFY_UC_RMI_EXT_INTR_CTL0r
#define READLN_UC_RMI_EXT_INTR_CTL0r BCMI_TSCE16_XGXS_READLN_UC_RMI_EXT_INTR_CTL0r
#define WRITELN_UC_RMI_EXT_INTR_CTL0r BCMI_TSCE16_XGXS_WRITELN_UC_RMI_EXT_INTR_CTL0r
#define WRITEALL_UC_RMI_EXT_INTR_CTL0r BCMI_TSCE16_XGXS_WRITEALL_UC_RMI_EXT_INTR_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_RMI_EXT_INTR_STS0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd227
 * DESC:     rmi external interrupt status register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RMI_MBOX_MSGOUT_STATUS Message out (from Micro) statusThis field is set to 1'b1 when the RMIC receives a message from the Micro.It indicates to the RMIC that the message on the micro_to_rmi_mbox3,micro_to_rmi_mbox2, micro_to_rmi_mbox1 and micro_to_rmi_mbox0 registers is validThis bits remain remains set until this register is read
 *     MICRO_RMI_ECC_CORR_ERR_STATUS ECC 1 bit correctable error detected statusThis field is set to 1'b1 when the ECC logic detects one bit correctable error.This bits remain remains set until this register is read
 *     MICRO_RMI_ECC_UNCORR_ERR_STATUS ECC 2 bit un-correctable error detected statusThis field is set to 1'b1 when the ECC logic detects one bit un-correctable error.This bits remain remains set until this register is read
 *     MICRO_RMI_ECC_MULTIROW_ERR_STATUS ECC error on multiple row detected  statusThis field is set to 1'b1 when the ECC logic detects correctable or uncorrecatble errors on multiple rows.This bits remain remains set until this register is read
 *     MICRO_RMI_M0_LOCKUP_STATUS M0 lockup statusThis field indicates the status of the M0 "lockup" signal
 *     MICRO_RMI_M0_SYSTEMRESETREQ_STATUS M0 systemresetreq statusThis field indicates the status of the M0 "systemresetreq" signal
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r (0x0000d227 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_EXT_INTR_STS0.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_ext_intr_sts0[1];
	uint32_t _uc_rmi_ext_intr_sts0;
} BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r_t;

#define BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r_CLR(r) (r).uc_rmi_ext_intr_sts0[0] = 0
#define BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r_SET(r,d) (r).uc_rmi_ext_intr_sts0[0] = d
#define BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r_GET(r) (r).uc_rmi_ext_intr_sts0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_SYSTEMRESETREQ_STATUSf_GET(r) ((((r).uc_rmi_ext_intr_sts0[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_SYSTEMRESETREQ_STATUSf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_LOCKUP_STATUSf_GET(r) ((((r).uc_rmi_ext_intr_sts0[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_LOCKUP_STATUSf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_MULTIROW_ERR_STATUSf_GET(r) ((((r).uc_rmi_ext_intr_sts0[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_MULTIROW_ERR_STATUSf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_UNCORR_ERR_STATUSf_GET(r) ((((r).uc_rmi_ext_intr_sts0[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_UNCORR_ERR_STATUSf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_CORR_ERR_STATUSf_GET(r) ((((r).uc_rmi_ext_intr_sts0[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_CORR_ERR_STATUSf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_MBOX_MSGOUT_STATUSf_GET(r) (((r).uc_rmi_ext_intr_sts0[0]) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_MBOX_MSGOUT_STATUSf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RMI_EXT_INTR_STS0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_RMI_EXT_INTR_STS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r,(_r._uc_rmi_ext_intr_sts0))
#define BCMI_TSCE16_XGXS_WRITE_UC_RMI_EXT_INTR_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r,(_r._uc_rmi_ext_intr_sts0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_RMI_EXT_INTR_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r,(_r._uc_rmi_ext_intr_sts0))
#define BCMI_TSCE16_XGXS_READLN_UC_RMI_EXT_INTR_STS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ext_intr_sts0))
#define BCMI_TSCE16_XGXS_WRITELN_UC_RMI_EXT_INTR_STS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ext_intr_sts0))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_RMI_EXT_INTR_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_ext_intr_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_EXT_INTR_STS0r BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r
#define UC_RMI_EXT_INTR_STS0r_SIZE BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r_SIZE
typedef BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r_t UC_RMI_EXT_INTR_STS0r_t;
#define UC_RMI_EXT_INTR_STS0r_CLR BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r_CLR
#define UC_RMI_EXT_INTR_STS0r_SET BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r_SET
#define UC_RMI_EXT_INTR_STS0r_GET BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_SYSTEMRESETREQ_STATUSf_GET BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_SYSTEMRESETREQ_STATUSf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_SYSTEMRESETREQ_STATUSf_SET BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_SYSTEMRESETREQ_STATUSf_SET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_LOCKUP_STATUSf_GET BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_LOCKUP_STATUSf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_LOCKUP_STATUSf_SET BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_LOCKUP_STATUSf_SET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_MULTIROW_ERR_STATUSf_GET BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_MULTIROW_ERR_STATUSf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_MULTIROW_ERR_STATUSf_SET BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_MULTIROW_ERR_STATUSf_SET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_UNCORR_ERR_STATUSf_GET BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_UNCORR_ERR_STATUSf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_UNCORR_ERR_STATUSf_SET BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_UNCORR_ERR_STATUSf_SET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_CORR_ERR_STATUSf_GET BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_CORR_ERR_STATUSf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_CORR_ERR_STATUSf_SET BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_CORR_ERR_STATUSf_SET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_MBOX_MSGOUT_STATUSf_GET BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_MBOX_MSGOUT_STATUSf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_MBOX_MSGOUT_STATUSf_SET BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_MBOX_MSGOUT_STATUSf_SET
#define READ_UC_RMI_EXT_INTR_STS0r BCMI_TSCE16_XGXS_READ_UC_RMI_EXT_INTR_STS0r
#define WRITE_UC_RMI_EXT_INTR_STS0r BCMI_TSCE16_XGXS_WRITE_UC_RMI_EXT_INTR_STS0r
#define MODIFY_UC_RMI_EXT_INTR_STS0r BCMI_TSCE16_XGXS_MODIFY_UC_RMI_EXT_INTR_STS0r
#define READLN_UC_RMI_EXT_INTR_STS0r BCMI_TSCE16_XGXS_READLN_UC_RMI_EXT_INTR_STS0r
#define WRITELN_UC_RMI_EXT_INTR_STS0r BCMI_TSCE16_XGXS_WRITELN_UC_RMI_EXT_INTR_STS0r
#define WRITEALL_UC_RMI_EXT_INTR_STS0r BCMI_TSCE16_XGXS_WRITEALL_UC_RMI_EXT_INTR_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_RMI_EXT_INTR_STS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_RMI_PMI_IF_CTL0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd228
 * DESC:     pmi interface control register 0
 * RESETVAL: 0x101 (257)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_PMI_HP_FAST_READ_EN pmi hp interface fast read enable1 - use pmi_hp_read_vld during read0 - use pmi_hp_ack during read
 *     MICRO_PMI_HP_FAST_DUAL_META_FF_EN pmi hp interface fast dual meta flops enable1 - use both the rising and falling edges of the clock for dual meta flops0 - use only the rising edges of the clock for dual meta flops
 *     MICRO_PMI_HP_FAST_BKTOBK_EN pmi hp interface fast back to back enable1 - skip over some of the states in the fsm during back to back transition0 - state transitions as in f28
 *     MICRO_PMI_HP_EXT_FAST_READ_EN pmi hp ext interface fast read enable1 - use pmi_hp_ext_read_vld during read0 - use pmi_hp_ext_ack during read
 *     MICRO_PMI_HP_EXT_FAST_DUAL_META_FF_EN pmi_hp_ext interface fast dual meta flops enable1 - use both the rising and falling edges of the clock for dual meta flops0 - use only the rising edges of the clock for dual meta flops
 *     MICRO_PMI_HP_EXT_FAST_BKTOBK_EN pmi_hp_ext interface fast back to back enable1 - skip over some of the states in the fsm during back to back transition0 - state transitions as in f28
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r (0x0000d228 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_PMI_IF_CTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_pmi_if_ctl0[1];
	uint32_t _uc_rmi_pmi_if_ctl0;
} BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r_t;

#define BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r_CLR(r) (r).uc_rmi_pmi_if_ctl0[0] = 0
#define BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r_SET(r,d) (r).uc_rmi_pmi_if_ctl0[0] = d
#define BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r_GET(r) (r).uc_rmi_pmi_if_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_BKTOBK_ENf_GET(r) ((((r).uc_rmi_pmi_if_ctl0[0]) >> 10) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_BKTOBK_ENf_SET(r,f) (r).uc_rmi_pmi_if_ctl0[0]=(((r).uc_rmi_pmi_if_ctl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_DUAL_META_FF_ENf_GET(r) ((((r).uc_rmi_pmi_if_ctl0[0]) >> 9) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_DUAL_META_FF_ENf_SET(r,f) (r).uc_rmi_pmi_if_ctl0[0]=(((r).uc_rmi_pmi_if_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_READ_ENf_GET(r) ((((r).uc_rmi_pmi_if_ctl0[0]) >> 8) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_READ_ENf_SET(r,f) (r).uc_rmi_pmi_if_ctl0[0]=(((r).uc_rmi_pmi_if_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_BKTOBK_ENf_GET(r) ((((r).uc_rmi_pmi_if_ctl0[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_BKTOBK_ENf_SET(r,f) (r).uc_rmi_pmi_if_ctl0[0]=(((r).uc_rmi_pmi_if_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_DUAL_META_FF_ENf_GET(r) ((((r).uc_rmi_pmi_if_ctl0[0]) >> 1) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_DUAL_META_FF_ENf_SET(r,f) (r).uc_rmi_pmi_if_ctl0[0]=(((r).uc_rmi_pmi_if_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_READ_ENf_GET(r) (((r).uc_rmi_pmi_if_ctl0[0]) & 0x1)
#define BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_READ_ENf_SET(r,f) (r).uc_rmi_pmi_if_ctl0[0]=(((r).uc_rmi_pmi_if_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RMI_PMI_IF_CTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_RMI_PMI_IF_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r,(_r._uc_rmi_pmi_if_ctl0))
#define BCMI_TSCE16_XGXS_WRITE_UC_RMI_PMI_IF_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r,(_r._uc_rmi_pmi_if_ctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_RMI_PMI_IF_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r,(_r._uc_rmi_pmi_if_ctl0))
#define BCMI_TSCE16_XGXS_READLN_UC_RMI_PMI_IF_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_pmi_if_ctl0))
#define BCMI_TSCE16_XGXS_WRITELN_UC_RMI_PMI_IF_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_pmi_if_ctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_RMI_PMI_IF_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_pmi_if_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_PMI_IF_CTL0r BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r
#define UC_RMI_PMI_IF_CTL0r_SIZE BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r_SIZE
typedef BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r_t UC_RMI_PMI_IF_CTL0r_t;
#define UC_RMI_PMI_IF_CTL0r_CLR BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r_CLR
#define UC_RMI_PMI_IF_CTL0r_SET BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r_SET
#define UC_RMI_PMI_IF_CTL0r_GET BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r_GET
#define UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_BKTOBK_ENf_GET BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_BKTOBK_ENf_GET
#define UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_BKTOBK_ENf_SET BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_BKTOBK_ENf_SET
#define UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_DUAL_META_FF_ENf_GET BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_DUAL_META_FF_ENf_GET
#define UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_DUAL_META_FF_ENf_SET BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_DUAL_META_FF_ENf_SET
#define UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_READ_ENf_GET BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_READ_ENf_GET
#define UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_READ_ENf_SET BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_READ_ENf_SET
#define UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_BKTOBK_ENf_GET BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_BKTOBK_ENf_GET
#define UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_BKTOBK_ENf_SET BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_BKTOBK_ENf_SET
#define UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_DUAL_META_FF_ENf_GET BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_DUAL_META_FF_ENf_GET
#define UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_DUAL_META_FF_ENf_SET BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_DUAL_META_FF_ENf_SET
#define UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_READ_ENf_GET BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_READ_ENf_GET
#define UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_READ_ENf_SET BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_READ_ENf_SET
#define READ_UC_RMI_PMI_IF_CTL0r BCMI_TSCE16_XGXS_READ_UC_RMI_PMI_IF_CTL0r
#define WRITE_UC_RMI_PMI_IF_CTL0r BCMI_TSCE16_XGXS_WRITE_UC_RMI_PMI_IF_CTL0r
#define MODIFY_UC_RMI_PMI_IF_CTL0r BCMI_TSCE16_XGXS_MODIFY_UC_RMI_PMI_IF_CTL0r
#define READLN_UC_RMI_PMI_IF_CTL0r BCMI_TSCE16_XGXS_READLN_UC_RMI_PMI_IF_CTL0r
#define WRITELN_UC_RMI_PMI_IF_CTL0r BCMI_TSCE16_XGXS_WRITELN_UC_RMI_PMI_IF_CTL0r
#define WRITEALL_UC_RMI_PMI_IF_CTL0r BCMI_TSCE16_XGXS_WRITEALL_UC_RMI_PMI_IF_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_RMI_PMI_IF_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_RMI_SILICON_DBG_CTL0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd229
 * DESC:     Silicon debug control register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_SILICON_DEBUG_STATUS_MUX_SEL This field is used to select the data to be muxed to rmi_silicon_debug_status0 registers0 - register interface - {5'd0, init_req,  wraddr_changed,  write_req,rdaddr_changed, read_req, ra_state[1:0],1'b0, ra_his_state[2:0]}1 - pram interface     - {2'b00, pif_state_status[1:0], pif_his_state_status[3:0],pr_hready, pr_cr_chipsel, pr_state[1:0], 1'b0,pr_his_state[2:0]};2 - pmi_hp interface   - {1'b0, pmi_state[2:0], 4'h0, pmi_his_state[7:0]}3 - pmi_hp_ext interface   - {1'b0, pmi_state[2:0], 4'h0, pmi_his_state[7:0]}
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_CTL0r (0x0000d229 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_SILICON_DBG_CTL0.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_silicon_dbg_ctl0[1];
	uint32_t _uc_rmi_silicon_dbg_ctl0;
} BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_CTL0r_t;

#define BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_CTL0r_CLR(r) (r).uc_rmi_silicon_dbg_ctl0[0] = 0
#define BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_CTL0r_SET(r,d) (r).uc_rmi_silicon_dbg_ctl0[0] = d
#define BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_CTL0r_GET(r) (r).uc_rmi_silicon_dbg_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_CTL0r_MICRO_SILICON_DEBUG_STATUS_MUX_SELf_GET(r) (((r).uc_rmi_silicon_dbg_ctl0[0]) & 0x3)
#define BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_CTL0r_MICRO_SILICON_DEBUG_STATUS_MUX_SELf_SET(r,f) (r).uc_rmi_silicon_dbg_ctl0[0]=(((r).uc_rmi_silicon_dbg_ctl0[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access UC_RMI_SILICON_DBG_CTL0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_RMI_SILICON_DBG_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_CTL0r,(_r._uc_rmi_silicon_dbg_ctl0))
#define BCMI_TSCE16_XGXS_WRITE_UC_RMI_SILICON_DBG_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_CTL0r,(_r._uc_rmi_silicon_dbg_ctl0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_RMI_SILICON_DBG_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_CTL0r,(_r._uc_rmi_silicon_dbg_ctl0))
#define BCMI_TSCE16_XGXS_READLN_UC_RMI_SILICON_DBG_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_silicon_dbg_ctl0))
#define BCMI_TSCE16_XGXS_WRITELN_UC_RMI_SILICON_DBG_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_silicon_dbg_ctl0))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_RMI_SILICON_DBG_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_silicon_dbg_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_SILICON_DBG_CTL0r BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_CTL0r
#define UC_RMI_SILICON_DBG_CTL0r_SIZE BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_CTL0r_SIZE
typedef BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_CTL0r_t UC_RMI_SILICON_DBG_CTL0r_t;
#define UC_RMI_SILICON_DBG_CTL0r_CLR BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_CTL0r_CLR
#define UC_RMI_SILICON_DBG_CTL0r_SET BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_CTL0r_SET
#define UC_RMI_SILICON_DBG_CTL0r_GET BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_CTL0r_GET
#define UC_RMI_SILICON_DBG_CTL0r_MICRO_SILICON_DEBUG_STATUS_MUX_SELf_GET BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_CTL0r_MICRO_SILICON_DEBUG_STATUS_MUX_SELf_GET
#define UC_RMI_SILICON_DBG_CTL0r_MICRO_SILICON_DEBUG_STATUS_MUX_SELf_SET BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_CTL0r_MICRO_SILICON_DEBUG_STATUS_MUX_SELf_SET
#define READ_UC_RMI_SILICON_DBG_CTL0r BCMI_TSCE16_XGXS_READ_UC_RMI_SILICON_DBG_CTL0r
#define WRITE_UC_RMI_SILICON_DBG_CTL0r BCMI_TSCE16_XGXS_WRITE_UC_RMI_SILICON_DBG_CTL0r
#define MODIFY_UC_RMI_SILICON_DBG_CTL0r BCMI_TSCE16_XGXS_MODIFY_UC_RMI_SILICON_DBG_CTL0r
#define READLN_UC_RMI_SILICON_DBG_CTL0r BCMI_TSCE16_XGXS_READLN_UC_RMI_SILICON_DBG_CTL0r
#define WRITELN_UC_RMI_SILICON_DBG_CTL0r BCMI_TSCE16_XGXS_WRITELN_UC_RMI_SILICON_DBG_CTL0r
#define WRITEALL_UC_RMI_SILICON_DBG_CTL0r BCMI_TSCE16_XGXS_WRITEALL_UC_RMI_SILICON_DBG_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  UC_RMI_SILICON_DBG_STS0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd22a
 * DESC:     Silicon debug status register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_SILICON_DEBUG_STATUS_MUXED_DATA Muxed status data is made avaialable on this field.micro_silicon_debug_status_mux_sel is used to select the data source
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_STS0r (0x0000d22a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_STS0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_SILICON_DBG_STS0.
 *
 */
typedef union BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_STS0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_silicon_dbg_sts0[1];
	uint32_t _uc_rmi_silicon_dbg_sts0;
} BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_STS0r_t;

#define BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_STS0r_CLR(r) (r).uc_rmi_silicon_dbg_sts0[0] = 0
#define BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_STS0r_SET(r,d) (r).uc_rmi_silicon_dbg_sts0[0] = d
#define BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_STS0r_GET(r) (r).uc_rmi_silicon_dbg_sts0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_STS0r_MICRO_SILICON_DEBUG_STATUS_MUXED_DATAf_GET(r) (((r).uc_rmi_silicon_dbg_sts0[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_STS0r_MICRO_SILICON_DEBUG_STATUS_MUXED_DATAf_SET(r,f) (r).uc_rmi_silicon_dbg_sts0[0]=(((r).uc_rmi_silicon_dbg_sts0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_SILICON_DBG_STS0.
 *
 */
#define BCMI_TSCE16_XGXS_READ_UC_RMI_SILICON_DBG_STS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_STS0r,(_r._uc_rmi_silicon_dbg_sts0))
#define BCMI_TSCE16_XGXS_WRITE_UC_RMI_SILICON_DBG_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_STS0r,(_r._uc_rmi_silicon_dbg_sts0)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_UC_RMI_SILICON_DBG_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_STS0r,(_r._uc_rmi_silicon_dbg_sts0))
#define BCMI_TSCE16_XGXS_READLN_UC_RMI_SILICON_DBG_STS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_silicon_dbg_sts0))
#define BCMI_TSCE16_XGXS_WRITELN_UC_RMI_SILICON_DBG_STS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_silicon_dbg_sts0))
#define BCMI_TSCE16_XGXS_WRITEALL_UC_RMI_SILICON_DBG_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_silicon_dbg_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_SILICON_DBG_STS0r BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_STS0r
#define UC_RMI_SILICON_DBG_STS0r_SIZE BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_STS0r_SIZE
typedef BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_STS0r_t UC_RMI_SILICON_DBG_STS0r_t;
#define UC_RMI_SILICON_DBG_STS0r_CLR BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_STS0r_CLR
#define UC_RMI_SILICON_DBG_STS0r_SET BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_STS0r_SET
#define UC_RMI_SILICON_DBG_STS0r_GET BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_STS0r_GET
#define UC_RMI_SILICON_DBG_STS0r_MICRO_SILICON_DEBUG_STATUS_MUXED_DATAf_GET BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_STS0r_MICRO_SILICON_DEBUG_STATUS_MUXED_DATAf_GET
#define UC_RMI_SILICON_DBG_STS0r_MICRO_SILICON_DEBUG_STATUS_MUXED_DATAf_SET BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_STS0r_MICRO_SILICON_DEBUG_STATUS_MUXED_DATAf_SET
#define READ_UC_RMI_SILICON_DBG_STS0r BCMI_TSCE16_XGXS_READ_UC_RMI_SILICON_DBG_STS0r
#define WRITE_UC_RMI_SILICON_DBG_STS0r BCMI_TSCE16_XGXS_WRITE_UC_RMI_SILICON_DBG_STS0r
#define MODIFY_UC_RMI_SILICON_DBG_STS0r BCMI_TSCE16_XGXS_MODIFY_UC_RMI_SILICON_DBG_STS0r
#define READLN_UC_RMI_SILICON_DBG_STS0r BCMI_TSCE16_XGXS_READLN_UC_RMI_SILICON_DBG_STS0r
#define WRITELN_UC_RMI_SILICON_DBG_STS0r BCMI_TSCE16_XGXS_WRITELN_UC_RMI_SILICON_DBG_STS0r
#define WRITEALL_UC_RMI_SILICON_DBG_STS0r BCMI_TSCE16_XGXS_WRITEALL_UC_RMI_SILICON_DBG_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_UC_RMI_SILICON_DBG_STS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  MDIO_BCST_PORT_ADDR
 * BLOCKS:   MDIO_MMDSEL_AER
 * REGADDR:  0xffdc
 * DESC:     Broadcast Port Address
 * RESETVAL: 0x1f (31)
 * ACCESS:   R/W
 * FIELDS:
 *     MDIO_BRCST_PORT_ADDR Braodcast port address that can be used to broadcast mdio commandsto multiple controllers connected to the same mdio station manager
 *     MDIO_DRV_COMCLK  Debug control bit to select between mdio_clk and comclk to drive out mdio_out and mdio_oeb signals.0=mdio_clk, 1=comclk
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_MDIO_BCST_PORT_ADDRr (0x0000ffdc | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_MDIO_BCST_PORT_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program MDIO_BCST_PORT_ADDR.
 *
 */
typedef union BCMI_TSCE16_XGXS_MDIO_BCST_PORT_ADDRr_s {
	uint32_t v[1];
	uint32_t mdio_bcst_port_addr[1];
	uint32_t _mdio_bcst_port_addr;
} BCMI_TSCE16_XGXS_MDIO_BCST_PORT_ADDRr_t;

#define BCMI_TSCE16_XGXS_MDIO_BCST_PORT_ADDRr_CLR(r) (r).mdio_bcst_port_addr[0] = 0
#define BCMI_TSCE16_XGXS_MDIO_BCST_PORT_ADDRr_SET(r,d) (r).mdio_bcst_port_addr[0] = d
#define BCMI_TSCE16_XGXS_MDIO_BCST_PORT_ADDRr_GET(r) (r).mdio_bcst_port_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_MDIO_BCST_PORT_ADDRr_MDIO_DRV_COMCLKf_GET(r) ((((r).mdio_bcst_port_addr[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_MDIO_BCST_PORT_ADDRr_MDIO_DRV_COMCLKf_SET(r,f) (r).mdio_bcst_port_addr[0]=(((r).mdio_bcst_port_addr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_GET(r) (((r).mdio_bcst_port_addr[0]) & 0x1f)
#define BCMI_TSCE16_XGXS_MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_SET(r,f) (r).mdio_bcst_port_addr[0]=(((r).mdio_bcst_port_addr[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access MDIO_BCST_PORT_ADDR.
 *
 */
#define BCMI_TSCE16_XGXS_READ_MDIO_BCST_PORT_ADDRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MDIO_BCST_PORT_ADDRr,(_r._mdio_bcst_port_addr))
#define BCMI_TSCE16_XGXS_WRITE_MDIO_BCST_PORT_ADDRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MDIO_BCST_PORT_ADDRr,(_r._mdio_bcst_port_addr)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_MDIO_BCST_PORT_ADDRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MDIO_BCST_PORT_ADDRr,(_r._mdio_bcst_port_addr))
#define BCMI_TSCE16_XGXS_READLN_MDIO_BCST_PORT_ADDRr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MDIO_BCST_PORT_ADDRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_bcst_port_addr))
#define BCMI_TSCE16_XGXS_WRITELN_MDIO_BCST_PORT_ADDRr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MDIO_BCST_PORT_ADDRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_bcst_port_addr))
#define BCMI_TSCE16_XGXS_WRITEALL_MDIO_BCST_PORT_ADDRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MDIO_BCST_PORT_ADDRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._mdio_bcst_port_addr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MDIO_BCST_PORT_ADDRr BCMI_TSCE16_XGXS_MDIO_BCST_PORT_ADDRr
#define MDIO_BCST_PORT_ADDRr_SIZE BCMI_TSCE16_XGXS_MDIO_BCST_PORT_ADDRr_SIZE
typedef BCMI_TSCE16_XGXS_MDIO_BCST_PORT_ADDRr_t MDIO_BCST_PORT_ADDRr_t;
#define MDIO_BCST_PORT_ADDRr_CLR BCMI_TSCE16_XGXS_MDIO_BCST_PORT_ADDRr_CLR
#define MDIO_BCST_PORT_ADDRr_SET BCMI_TSCE16_XGXS_MDIO_BCST_PORT_ADDRr_SET
#define MDIO_BCST_PORT_ADDRr_GET BCMI_TSCE16_XGXS_MDIO_BCST_PORT_ADDRr_GET
#define MDIO_BCST_PORT_ADDRr_MDIO_DRV_COMCLKf_GET BCMI_TSCE16_XGXS_MDIO_BCST_PORT_ADDRr_MDIO_DRV_COMCLKf_GET
#define MDIO_BCST_PORT_ADDRr_MDIO_DRV_COMCLKf_SET BCMI_TSCE16_XGXS_MDIO_BCST_PORT_ADDRr_MDIO_DRV_COMCLKf_SET
#define MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_GET BCMI_TSCE16_XGXS_MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_GET
#define MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_SET BCMI_TSCE16_XGXS_MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_SET
#define READ_MDIO_BCST_PORT_ADDRr BCMI_TSCE16_XGXS_READ_MDIO_BCST_PORT_ADDRr
#define WRITE_MDIO_BCST_PORT_ADDRr BCMI_TSCE16_XGXS_WRITE_MDIO_BCST_PORT_ADDRr
#define MODIFY_MDIO_BCST_PORT_ADDRr BCMI_TSCE16_XGXS_MODIFY_MDIO_BCST_PORT_ADDRr
#define READLN_MDIO_BCST_PORT_ADDRr BCMI_TSCE16_XGXS_READLN_MDIO_BCST_PORT_ADDRr
#define WRITELN_MDIO_BCST_PORT_ADDRr BCMI_TSCE16_XGXS_WRITELN_MDIO_BCST_PORT_ADDRr
#define WRITEALL_MDIO_BCST_PORT_ADDRr BCMI_TSCE16_XGXS_WRITEALL_MDIO_BCST_PORT_ADDRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_MDIO_BCST_PORT_ADDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  MDIO_MMD_SEL
 * BLOCKS:   MDIO_MMDSEL_AER
 * REGADDR:  0xffdd
 * DESC:     MMD Select
 * RESETVAL: 0x404d (16461)
 * ACCESS:   R/W
 * FIELDS:
 *     MDIO_DEV_CL22_EN When set and mdio_multi_mmds_en=1 then CL22 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_DEV_PMD_EN  When set and mdio_multi_mmds_en=1 then the PMD device=1 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_DEV_AN_EN   When set and mdio_multi_mmds_en=1 then the AN device=7 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_DEV_PHY_EN  When set and mdio_multi_mmds_en=1 then the PHY device=4 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_DEV_DTE_EN  When set and mdio_multi_mmds_en=1 then the DTE device=5 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_DEV_PCS_EN  When set and mdio_multi_mmds_en=1 then the PCS device=3 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_MULTI_MMDS_EN When set enables the multiple MMD functionality.  MD_ST is ignored andeach device can be accessed directly with the appropriate CL22 or CL45protocol.
 *     MDIO_MULTI_PRTS_EN When set enables multiple prtad functionality.  Each of the lanes'mmds can be accessed with consecutive PRTADs.  Lane 0 is accessedwith PRTAD_STRAP, lane 1 with PRTAD_STRAP+1, lane 2 with PRTAD_STRAP+2and lane 3 with PRTAD_STRAP+3.
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_MDIO_MMD_SELr (0x0000ffdd | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_MDIO_MMD_SELr_SIZE 4

/*
 * This structure should be used to declare and program MDIO_MMD_SEL.
 *
 */
typedef union BCMI_TSCE16_XGXS_MDIO_MMD_SELr_s {
	uint32_t v[1];
	uint32_t mdio_mmd_sel[1];
	uint32_t _mdio_mmd_sel;
} BCMI_TSCE16_XGXS_MDIO_MMD_SELr_t;

#define BCMI_TSCE16_XGXS_MDIO_MMD_SELr_CLR(r) (r).mdio_mmd_sel[0] = 0
#define BCMI_TSCE16_XGXS_MDIO_MMD_SELr_SET(r,d) (r).mdio_mmd_sel[0] = d
#define BCMI_TSCE16_XGXS_MDIO_MMD_SELr_GET(r) (r).mdio_mmd_sel[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 15) & 0x1)
#define BCMI_TSCE16_XGXS_MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCE16_XGXS_MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 14) & 0x1)
#define BCMI_TSCE16_XGXS_MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCE16_XGXS_MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 6) & 0x1)
#define BCMI_TSCE16_XGXS_MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCE16_XGXS_MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 5) & 0x1)
#define BCMI_TSCE16_XGXS_MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCE16_XGXS_MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 4) & 0x1)
#define BCMI_TSCE16_XGXS_MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCE16_XGXS_MDIO_MMD_SELr_MDIO_DEV_AN_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 3) & 0x1)
#define BCMI_TSCE16_XGXS_MDIO_MMD_SELr_MDIO_DEV_AN_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCE16_XGXS_MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 2) & 0x1)
#define BCMI_TSCE16_XGXS_MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCE16_XGXS_MDIO_MMD_SELr_MDIO_DEV_CL22_ENf_GET(r) (((r).mdio_mmd_sel[0]) & 0x1)
#define BCMI_TSCE16_XGXS_MDIO_MMD_SELr_MDIO_DEV_CL22_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MDIO_MMD_SEL.
 *
 */
#define BCMI_TSCE16_XGXS_READ_MDIO_MMD_SELr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MDIO_MMD_SELr,(_r._mdio_mmd_sel))
#define BCMI_TSCE16_XGXS_WRITE_MDIO_MMD_SELr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MDIO_MMD_SELr,(_r._mdio_mmd_sel)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_MDIO_MMD_SELr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MDIO_MMD_SELr,(_r._mdio_mmd_sel))
#define BCMI_TSCE16_XGXS_READLN_MDIO_MMD_SELr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MDIO_MMD_SELr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_mmd_sel))
#define BCMI_TSCE16_XGXS_WRITELN_MDIO_MMD_SELr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MDIO_MMD_SELr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_mmd_sel))
#define BCMI_TSCE16_XGXS_WRITEALL_MDIO_MMD_SELr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MDIO_MMD_SELr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._mdio_mmd_sel))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MDIO_MMD_SELr BCMI_TSCE16_XGXS_MDIO_MMD_SELr
#define MDIO_MMD_SELr_SIZE BCMI_TSCE16_XGXS_MDIO_MMD_SELr_SIZE
typedef BCMI_TSCE16_XGXS_MDIO_MMD_SELr_t MDIO_MMD_SELr_t;
#define MDIO_MMD_SELr_CLR BCMI_TSCE16_XGXS_MDIO_MMD_SELr_CLR
#define MDIO_MMD_SELr_SET BCMI_TSCE16_XGXS_MDIO_MMD_SELr_SET
#define MDIO_MMD_SELr_GET BCMI_TSCE16_XGXS_MDIO_MMD_SELr_GET
#define MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_GET BCMI_TSCE16_XGXS_MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_GET
#define MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_SET BCMI_TSCE16_XGXS_MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_SET
#define MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_GET BCMI_TSCE16_XGXS_MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_GET
#define MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_SET BCMI_TSCE16_XGXS_MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_GET BCMI_TSCE16_XGXS_MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_SET BCMI_TSCE16_XGXS_MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_GET BCMI_TSCE16_XGXS_MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_SET BCMI_TSCE16_XGXS_MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_GET BCMI_TSCE16_XGXS_MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_SET BCMI_TSCE16_XGXS_MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_AN_ENf_GET BCMI_TSCE16_XGXS_MDIO_MMD_SELr_MDIO_DEV_AN_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_AN_ENf_SET BCMI_TSCE16_XGXS_MDIO_MMD_SELr_MDIO_DEV_AN_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_GET BCMI_TSCE16_XGXS_MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_SET BCMI_TSCE16_XGXS_MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_CL22_ENf_GET BCMI_TSCE16_XGXS_MDIO_MMD_SELr_MDIO_DEV_CL22_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_CL22_ENf_SET BCMI_TSCE16_XGXS_MDIO_MMD_SELr_MDIO_DEV_CL22_ENf_SET
#define READ_MDIO_MMD_SELr BCMI_TSCE16_XGXS_READ_MDIO_MMD_SELr
#define WRITE_MDIO_MMD_SELr BCMI_TSCE16_XGXS_WRITE_MDIO_MMD_SELr
#define MODIFY_MDIO_MMD_SELr BCMI_TSCE16_XGXS_MODIFY_MDIO_MMD_SELr
#define READLN_MDIO_MMD_SELr BCMI_TSCE16_XGXS_READLN_MDIO_MMD_SELr
#define WRITELN_MDIO_MMD_SELr BCMI_TSCE16_XGXS_WRITELN_MDIO_MMD_SELr
#define WRITEALL_MDIO_MMD_SELr BCMI_TSCE16_XGXS_WRITEALL_MDIO_MMD_SELr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_MDIO_MMD_SELr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  MDIO_AER
 * BLOCKS:   MDIO_MMDSEL_AER
 * REGADDR:  0xffde
 * DESC:     AER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MDIO_AER         Provides upper 16-bits of 32-bit address for mdio transactions
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_MDIO_AERr (0x0000ffde | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_MDIO_AERr_SIZE 4

/*
 * This structure should be used to declare and program MDIO_AER.
 *
 */
typedef union BCMI_TSCE16_XGXS_MDIO_AERr_s {
	uint32_t v[1];
	uint32_t mdio_aer[1];
	uint32_t _mdio_aer;
} BCMI_TSCE16_XGXS_MDIO_AERr_t;

#define BCMI_TSCE16_XGXS_MDIO_AERr_CLR(r) (r).mdio_aer[0] = 0
#define BCMI_TSCE16_XGXS_MDIO_AERr_SET(r,d) (r).mdio_aer[0] = d
#define BCMI_TSCE16_XGXS_MDIO_AERr_GET(r) (r).mdio_aer[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_MDIO_AERr_MDIO_AERf_GET(r) (((r).mdio_aer[0]) & 0xffff)
#define BCMI_TSCE16_XGXS_MDIO_AERr_MDIO_AERf_SET(r,f) (r).mdio_aer[0]=(((r).mdio_aer[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access MDIO_AER.
 *
 */
#define BCMI_TSCE16_XGXS_READ_MDIO_AERr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MDIO_AERr,(_r._mdio_aer))
#define BCMI_TSCE16_XGXS_WRITE_MDIO_AERr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MDIO_AERr,(_r._mdio_aer)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_MDIO_AERr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MDIO_AERr,(_r._mdio_aer))
#define BCMI_TSCE16_XGXS_READLN_MDIO_AERr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_MDIO_AERr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_aer))
#define BCMI_TSCE16_XGXS_WRITELN_MDIO_AERr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MDIO_AERr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_aer))
#define BCMI_TSCE16_XGXS_WRITEALL_MDIO_AERr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_MDIO_AERr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._mdio_aer))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MDIO_AERr BCMI_TSCE16_XGXS_MDIO_AERr
#define MDIO_AERr_SIZE BCMI_TSCE16_XGXS_MDIO_AERr_SIZE
typedef BCMI_TSCE16_XGXS_MDIO_AERr_t MDIO_AERr_t;
#define MDIO_AERr_CLR BCMI_TSCE16_XGXS_MDIO_AERr_CLR
#define MDIO_AERr_SET BCMI_TSCE16_XGXS_MDIO_AERr_SET
#define MDIO_AERr_GET BCMI_TSCE16_XGXS_MDIO_AERr_GET
#define MDIO_AERr_MDIO_AERf_GET BCMI_TSCE16_XGXS_MDIO_AERr_MDIO_AERf_GET
#define MDIO_AERr_MDIO_AERf_SET BCMI_TSCE16_XGXS_MDIO_AERr_MDIO_AERf_SET
#define READ_MDIO_AERr BCMI_TSCE16_XGXS_READ_MDIO_AERr
#define WRITE_MDIO_AERr BCMI_TSCE16_XGXS_WRITE_MDIO_AERr
#define MODIFY_MDIO_AERr BCMI_TSCE16_XGXS_MODIFY_MDIO_AERr
#define READLN_MDIO_AERr BCMI_TSCE16_XGXS_READLN_MDIO_AERr
#define WRITELN_MDIO_AERr BCMI_TSCE16_XGXS_WRITELN_MDIO_AERr
#define WRITEALL_MDIO_AERr BCMI_TSCE16_XGXS_WRITEALL_MDIO_AERr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_MDIO_AERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCE16_XGXS
 * REGISTER:  BLK_ADDR
 * BLOCKS:   MDIO_BLK_ADDR
 * REGADDR:  0xffdf
 * DESC:     BLK_ADDR
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MDIO_BLK_ADDR    Block address (used for clause 22 transactions to get the address bits 14:4)
 *
 ******************************************************************************/
#define BCMI_TSCE16_XGXS_BLK_ADDRr (0x0000ffdf | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCE16_XGXS_BLK_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program BLK_ADDR.
 *
 */
typedef union BCMI_TSCE16_XGXS_BLK_ADDRr_s {
	uint32_t v[1];
	uint32_t blk_addr[1];
	uint32_t _blk_addr;
} BCMI_TSCE16_XGXS_BLK_ADDRr_t;

#define BCMI_TSCE16_XGXS_BLK_ADDRr_CLR(r) (r).blk_addr[0] = 0
#define BCMI_TSCE16_XGXS_BLK_ADDRr_SET(r,d) (r).blk_addr[0] = d
#define BCMI_TSCE16_XGXS_BLK_ADDRr_GET(r) (r).blk_addr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCE16_XGXS_BLK_ADDRr_MDIO_BLK_ADDRf_GET(r) ((((r).blk_addr[0]) >> 4) & 0x7ff)
#define BCMI_TSCE16_XGXS_BLK_ADDRr_MDIO_BLK_ADDRf_SET(r,f) (r).blk_addr[0]=(((r).blk_addr[0] & ~((uint32_t)0x7ff << 4)) | ((((uint32_t)f) & 0x7ff) << 4)) | (2047 << (16 + 4))

/*
 * These macros can be used to access BLK_ADDR.
 *
 */
#define BCMI_TSCE16_XGXS_READ_BLK_ADDRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_BLK_ADDRr,(_r._blk_addr))
#define BCMI_TSCE16_XGXS_WRITE_BLK_ADDRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_BLK_ADDRr,(_r._blk_addr)&0xffff)
#define BCMI_TSCE16_XGXS_MODIFY_BLK_ADDRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_BLK_ADDRr,(_r._blk_addr))
#define BCMI_TSCE16_XGXS_READLN_BLK_ADDRr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCE16_XGXS_BLK_ADDRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._blk_addr))
#define BCMI_TSCE16_XGXS_WRITELN_BLK_ADDRr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_BLK_ADDRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._blk_addr))
#define BCMI_TSCE16_XGXS_WRITEALL_BLK_ADDRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCE16_XGXS_BLK_ADDRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._blk_addr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define BLK_ADDRr BCMI_TSCE16_XGXS_BLK_ADDRr
#define BLK_ADDRr_SIZE BCMI_TSCE16_XGXS_BLK_ADDRr_SIZE
typedef BCMI_TSCE16_XGXS_BLK_ADDRr_t BLK_ADDRr_t;
#define BLK_ADDRr_CLR BCMI_TSCE16_XGXS_BLK_ADDRr_CLR
#define BLK_ADDRr_SET BCMI_TSCE16_XGXS_BLK_ADDRr_SET
#define BLK_ADDRr_GET BCMI_TSCE16_XGXS_BLK_ADDRr_GET
#define BLK_ADDRr_MDIO_BLK_ADDRf_GET BCMI_TSCE16_XGXS_BLK_ADDRr_MDIO_BLK_ADDRf_GET
#define BLK_ADDRr_MDIO_BLK_ADDRf_SET BCMI_TSCE16_XGXS_BLK_ADDRr_MDIO_BLK_ADDRf_SET
#define READ_BLK_ADDRr BCMI_TSCE16_XGXS_READ_BLK_ADDRr
#define WRITE_BLK_ADDRr BCMI_TSCE16_XGXS_WRITE_BLK_ADDRr
#define MODIFY_BLK_ADDRr BCMI_TSCE16_XGXS_MODIFY_BLK_ADDRr
#define READLN_BLK_ADDRr BCMI_TSCE16_XGXS_READLN_BLK_ADDRr
#define WRITELN_BLK_ADDRr BCMI_TSCE16_XGXS_WRITELN_BLK_ADDRr
#define WRITEALL_BLK_ADDRr BCMI_TSCE16_XGXS_WRITEALL_BLK_ADDRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCE16_XGXS_BLK_ADDRr'
 ******************************************************************************/




#endif /* __BCMI_TSCE16_XGXS_DEFS_H__ */
