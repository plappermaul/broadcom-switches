/*
 * $Id: $
 * 
 * $Copyright: (c) 2016 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 * 
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */

#ifndef __BCM_MPLS_H__
#define __BCM_MPLS_H__

#include <bcm/types.h>
#include <bcm/multicast.h>
#include <bcm/policer.h>
#include <bcm/vlan.h>
#include <bcm/switch.h>

#if defined(INCLUDE_L3)
/* MPLS EXP Map Structure. */
typedef struct bcm_mpls_exp_map_s {
    int priority;       /* Internal priority. */
    bcm_color_t color;  /* Color. */
    uint8 dscp;         /* Diff Serv Code Point. */
    uint8 exp;          /* EXP value. */
    uint8 pkt_pri;      /* Packet priority value. */
    uint8 pkt_cfi;      /* Packet CFI value. */
} bcm_mpls_exp_map_t;
#endif

/* MPLS Egress Label Structure. */
#define BCM_MPLS_EGRESS_LABEL_TTL_SET       0x00000001 
#define BCM_MPLS_EGRESS_LABEL_TTL_COPY      0x00000002 
#define BCM_MPLS_EGRESS_LABEL_TTL_DECREMENT 0x00000004 
#define BCM_MPLS_EGRESS_LABEL_EXP_SET       0x00000008 
#define BCM_MPLS_EGRESS_LABEL_EXP_REMARK    0x00000010 
#define BCM_MPLS_EGRESS_LABEL_EXP_COPY      0x00000020 
#define BCM_MPLS_EGRESS_LABEL_PRI_SET       0x00000040 
#define BCM_MPLS_EGRESS_LABEL_PRI_REMARK    0x00000080 
#define BCM_MPLS_EGRESS_LABEL_DROP          0x00000100 
#define BCM_MPLS_EGRESS_LABEL_PHP_IPV4      0x00000200 
#define BCM_MPLS_EGRESS_LABEL_PHP_IPV6      0x00000400 
#define BCM_MPLS_EGRESS_LABEL_PHP_L2        0x00000800 
#define BCM_MPLS_EGRESS_LABEL_ENTROPY_ENABLE 0x00001000 /* Enable Entropy for
                                                          outgoing Tunnel-label
                                                          and PW-label */
#define BCM_MPLS_EGRESS_LABEL_ACTION_VALID  0x00002000 /* When set action is
                                                          taken from action
                                                          field */
#define BCM_MPLS_EGRESS_LABEL_REPLACE       0x00004000 /* Replace existing
                                                          entry. */
#define BCM_MPLS_EGRESS_LABEL_WITH_ID       0x00008000 /* Add using the
                                                          specified ID. */
#define BCM_MPLS_EGRESS_LABEL_WIDE          0x00010000 /* Set wide entry in
                                                          egress. */
#define BCM_MPLS_EGRESS_LABEL_IML           0x00020000 /* Label is EVPN Implicit
                                                          Multicast. */
#define BCM_MPLS_EGRESS_LABEL_PROTECTION    0x00040000 /* Egress Protection
                                                          object. */
#define BCM_MPLS_EGRESS_LABEL_PRESERVE      0x00080000 /* Label used for swap is
                                                          preserved. */
#define BCM_MPLS_EGRESS_LABEL_ENTROPY_INDICATION_ENABLE 0x00100000 /* Add Entropy Indication
                                                          label for outgoing
                                                          Tunnel-label */
#define BCM_MPLS_EGRESS_LABEL_EVPN          0x00200000 /* Create an EVPN tunnel */
#define BCM_MPLS_EGRESS_LABEL_ECN_TO_EXP_MAP 0x00400000 /* Use a specified
                                                          ECN_TO_EXP mapping to
                                                          derive MPLS EXP. */
#define BCM_MPLS_EGRESS_LABEL_INT_CN_TO_EXP_MAP 0x00800000 /* Use a specified
                                                          INT_CN_TO_EXP mapping
                                                          to derive MPLS EXP. */
#define BCM_MPLS_EGRESS_LABEL_ECN_EXP_MAP_TRUST 0x01000000 /* Trust ECN mapping. */

/* MPLS label egress actions. */
typedef enum bcm_mpls_egress_action_e {
    BCM_MPLS_EGRESS_ACTION_SWAP = 0, 
    BCM_MPLS_EGRESS_ACTION_PHP  = 1, 
    BCM_MPLS_EGRESS_ACTION_PUSH = 2, 
    BCM_MPLS_EGRESS_ACTION_NOP  = 3, 
    BCM_MPLS_EGRESS_ACTION_SWAP_OR_PUSH = 4 
} bcm_mpls_egress_action_t;

/* bcm_mpls_egress_label_s */
typedef struct bcm_mpls_egress_label_s {
    uint32 flags;                       /* BCM_MPLS_EGRESS_LABEL_xxx. */
    bcm_mpls_label_t label; 
    int qos_map_id;                     /* EXP map ID. */
    uint8 exp; 
    uint8 ttl; 
    uint8 pkt_pri; 
    uint8 pkt_cfi; 
    bcm_if_t tunnel_id;                 /* Tunnel Interface. */
    bcm_if_t l3_intf_id;                /* l3 Interface ID. */
    bcm_mpls_egress_action_t action;    /* MPLS label action, relevant when
                                           BCM_MPLS_EGRESS_LABEL_ACTION_VALID is
                                           set. */
    int ecn_map_id;                     /* Ecn map id for IP ECN to EXP mapping. */
    int int_cn_map_id;                  /* Ecn map id for INT_CN to EXP mapping. */
    bcm_failover_t egress_failover_id;  /* Failover object index for Egress
                                           Protection. */
    bcm_if_t egress_failover_if_id;     /* Failover MPLS Tunnel identifier for
                                           Egress Protection. */
    int outlif_counting_profile;        /* Out LIF counting profile */
} bcm_mpls_egress_label_t;

#if defined(INCLUDE_L3)
/* MPLS port match criteria. */
typedef enum bcm_mpls_port_match_e {
    BCM_MPLS_PORT_MATCH_INVALID = 0,    /* Illegal. */
    BCM_MPLS_PORT_MATCH_NONE = 1,       /* No source match criteria. */
    BCM_MPLS_PORT_MATCH_PORT = 2,       /* {Module, Port} or Trunk. */
    BCM_MPLS_PORT_MATCH_PORT_VLAN = 3,  /* Mod/port/trunk + outer VLAN. */
    BCM_MPLS_PORT_MATCH_PORT_INNER_VLAN = 4, /* Mod/port/trunk + inner VLAN. */
    BCM_MPLS_PORT_MATCH_PORT_VLAN_STACKED = 5, /* Mod/port/trunk + outer/inner VLAN. */
    BCM_MPLS_PORT_MATCH_VLAN_PRI = 6,   /* Mod/port/trunk + VLAN-PRI + VLAN-CFI. */
    BCM_MPLS_PORT_MATCH_LABEL = 7,      /* MPLS label. */
    BCM_MPLS_PORT_MATCH_LABEL_PORT = 8, /* MPLS label + Mod/port/trunk. */
    BCM_MPLS_PORT_MATCH_LABEL_VLAN = 9, /* MPLS label + VLAN. */
    BCM_MPLS_PORT_MATCH_PORT_SUBPORT_PKT_VID = 10, /* Mod/port/trunk + LLTAG VLAN ID. */
    BCM_MPLS_PORT_MATCH_PORT_SUBPORT_PKT_VID_OUTER_VLAN = 11, /* Mod/port/trunk + LLTAG VLAN ID +
                                           outer VLAN ID. */
    BCM_MPLS_PORT_MATCH_PORT_SUBPORT_PKT_VID_INNER_VLAN = 12, /* Mod/port/trunk + LLTAG VLAN ID +
                                           inner VLAN ID. */
    BCM_MPLS_PORT_MATCH_SHARE = 13,     /* Multiple match criteria Share one
                                           MPLS logical port. */
    BCM_MPLS_PORT_MATCH_COUNT = 14      /* Must be last. */
} bcm_mpls_port_match_t;
#endif

#if defined(INCLUDE_L3)
/* MPLS interface flags. */
#define BCM_MPLS_PORT_REPLACE               0x00000001 /* Replace existing
                                                          entry. */
#define BCM_MPLS_PORT_WITH_ID               0x00000002 /* Add using the
                                                          specified ID. */
#define BCM_MPLS_PORT_ENCAP_WITH_ID         0x00000004 /* Use the specified
                                                          encap id to allocate
                                                          and setup
                                                          encapsulation. */
#define BCM_MPLS_PORT_EGRESS_UNTAGGED       0x00000008 /* Indicates tag is
                                                          stripped on logical
                                                          port egress. */
#define BCM_MPLS_PORT_DROP                  0x00000010 /* Drop matching packets. */
#define BCM_MPLS_PORT_NETWORK               0x00000020 /* Network-facing
                                                          interface. */
#define BCM_MPLS_PORT_CONTROL_WORD          0x00000040 /* Use control word
                                                          (VPWS). */
#define BCM_MPLS_PORT_SEQUENCED             0x00000080 /* Use sequence number
                                                          (VPWS). */
#define BCM_MPLS_PORT_COUNTED               0x00000100 /* Maintain packet/byte
                                                          counts. */
#define BCM_MPLS_PORT_INT_PRI_SET           0x00000200 /* Use specified int_pri
                                                          value for internal
                                                          priority. */
#define BCM_MPLS_PORT_INT_PRI_MAP           0x00000400 /* Use specified exp_map
                                                          to derive internal
                                                          priority. */
#define BCM_MPLS_PORT_COLOR_MAP             0x00000800 /* Use specified exp_map
                                                          to derive internal
                                                          color. */
#define BCM_MPLS_PORT_EGRESS_TUNNEL         0x00001000 /* Specified egress
                                                          tunnel interface is
                                                          valid. */
#define BCM_MPLS_PORT_NO_EGRESS_TUNNEL_ENCAP 0x00002000 /* Specified egress
                                                          tunnel interface is
                                                          valid.
                                                                                
                                                           Do not encapsulate
                                                          outer MAC but update
                                                          MAC Address on the
                                                          packet. */
#define BCM_MPLS_PORT_SERVICE_TAGGED        0x00004000 /* Service tag mode. */
#define BCM_MPLS_PORT_SERVICE_VLAN_ADD      0x00008000 /* Add SD-tag. */
#define BCM_MPLS_PORT_SERVICE_VLAN_REPLACE  0x00010000 /* Replace VLAN not TPID. */
#define BCM_MPLS_PORT_SERVICE_VLAN_DELETE   0x00020000 /* Delete VLAN tag. */
#define BCM_MPLS_PORT_SERVICE_VLAN_TPID_REPLACE 0x00040000 /* Replace VLAN and TPID. */
#define BCM_MPLS_PORT_SERVICE_VLAN_PRI_TPID_REPLACE 0x00080000 /* Replace VLAN, VLAN-PRI
                                                          and TPID. */
#define BCM_MPLS_PORT_SERVICE_VLAN_PRI_REPLACE 0x00100000 /* Replace VLAN and
                                                          VLAN-PRI. */
#define BCM_MPLS_PORT_SERVICE_PRI_REPLACE   0x00200000 /* Replace VLAN-PRI only. */
#define BCM_MPLS_PORT_SERVICE_TPID_REPLACE  0x00400000 /* Replace TPID only. */
#define BCM_MPLS_PORT_INNER_VLAN_PRESERVE   0x00800000 /* Preserve the inner or
                                                          customer VLAN tag */
#define BCM_MPLS_PORT_FAILOVER              0x01000000 /* Failover Port */
#define BCM_MPLS_PORT_INNER_VLAN_ADD        0x02000000 /* Insert Native VLAN tag
                                                          for untagged pcakets */
#define BCM_MPLS_PORT_ENTROPY_ENABLE        0x04000000 /* Enable MPLS Entropy
                                                          Label for L2-VPN */
#define BCM_MPLS_PORT_PW_FAILOVER           0x08000000 /* Port for PW Redundancy */
#define BCM_MPLS_PORT_EXTENDED              0x10000000 /* Use the extended P2P
                                                          service */
#define BCM_MPLS_PORT_WITH_GAL              0x20000000 /* indicating OAMoGALoPWE
                                                          is supported. */
#define BCM_MPLS_PORT_LOCAL_PROTECTION      0x40000000 /* Local protection
                                                          according to link
                                                          status. */
#define BCM_MPLS_PORT_FORWARD_GROUP         0x80000000 /* Enable VLAN-Port
                                                          property FORWARD_GROUP
                                                          to MPLS-Port */
#endif

#if defined(INCLUDE_L3)
/* More MPLS interface flags. */
#define BCM_MPLS_PORT2_INGRESS_ONLY         0x00000001 /* Indicates ingress
                                                          settings */
#define BCM_MPLS_PORT2_EGRESS_ONLY          0x00000002 /* Indicates egress
                                                          settings */
#define BCM_MPLS_PORT2_EGRESS_PROTECTION    0x00000004 /* Egress protection
                                                          object */
#define BCM_MPLS_PORT2_TUNNEL_PUSH_INFO     0x00000008 /* Allocate MPLS Push
                                                          profile information */
#define BCM_MPLS_PORT2_LEARN_ENCAP          0x00000010 /* Learning information
                                                          is a pointer to
                                                          encapsulation database
                                                          entry */
#define BCM_MPLS_PORT2_CASCADED             0x00000020 /* Set in case the mpls
                                                          port is over overlay */
#define BCM_MPLS_PORT2_INGRESS_WIDE         0x00000040 /* use Wide mode
                                                          (additional data) */
#define BCM_MPLS_PORT2_TUNNEL_HEADER_EGRESS_VLAN_TRANSLATION 0x00000080 /* If set, MPLS tunnel
                                                          header's VLAN will be
                                                          translated; else,
                                                          payload's VLAN will be
                                                          translated. */
#define BCM_MPLS_PORT2_PROXY_MODE           0x00000100 /* Act as proxy mode, and
                                                          do packet
                                                          modifications for HG
                                                          output port on
                                                          stacking mode */
#define BCM_MPLS_PORT2_INGRESS_ENTROPY_ENABLE 0x00000200 /* If set, enables
                                                          termination of entropy
                                                          label following the
                                                          ingressing match label */
#define BCM_MPLS_PORT2_ENCAP_OPTIMIZED      0x00000400 /* Indicate that FEC
                                                          should be set as
                                                          format C (EEI) */
#define BCM_MPLS_PORT2_QOS_NONE             0x00000800 /* Indicate that no QOS
                                                          configuration on the
                                                          MPLS port. */
#define BCM_MPLS_PORT2_INGRESS_ECN_MAP      0x00001000 /* Use specified
                                                          EXP_TO_ECN map to
                                                          derive IP ECN. */
#define BCM_MPLS_PORT2_KEEP_TTL             0x00002000 /* Retain incoming TTL by
                                                          disabling decrement
                                                          for MPLS flows. */
#endif

#if defined(INCLUDE_L3)
/* VCCV Control Channel Type */
typedef enum bcm_mpls_port_control_channel_type_e {
    bcmMplsPortControlChannelNone         = 0, 
    bcmMplsPortControlChannelAch          = 1, 
    bcmMplsPortControlChannelRouterAlert  = 2, 
    bcmMplsPortControlChannelTtl          = 3, 
    bcmMplsPortControlChannelGalUnderPw   = 4 
} bcm_mpls_port_control_channel_type_t;
#endif

#if defined(INCLUDE_L3)
/* MPLS port type. */
typedef struct bcm_mpls_port_s {
    bcm_gport_t mpls_port_id;           /* GPORT identifier. */
    uint32 flags;                       /* BCM_MPLS_PORT_xxx. */
    uint32 flags2;                      /* BCM_MPLS_PORT2_xxx. */
    int if_class;                       /* Interface class ID. */
    int exp_map;                        /* Incoming EXP map ID. */
    int int_pri;                        /* Internal priority. */
    uint8 pkt_pri;                      /* Packet priority. */
    uint8 pkt_cfi;                      /* Packet CFI. */
    uint16 service_tpid;                /* Service VLAN TPID value. */
    bcm_gport_t port;                   /* Match port and/or egress port. */
    bcm_mpls_port_match_t criteria;     /* Match criteria. */
    bcm_vlan_t match_vlan;              /* Outer VLAN ID to match. */
    bcm_vlan_t match_inner_vlan;        /* Inner VLAN ID to match. */
    bcm_mpls_label_t match_label;       /* VC label to match. */
    bcm_if_t egress_tunnel_if;          /* MPLS tunnel egress object. */
    bcm_mpls_egress_label_t egress_label; /* Outgoing VC label. */
    int mtu;                            /* MPLS port MTU. */
    bcm_vlan_t egress_service_vlan;     /* Service VLAN to Add/Replace. */
    uint32 pw_seq_number;               /* Initial-value of Pseudo-wire Sequence
                                           number */
    bcm_if_t encap_id;                  /* Encap Identifier. */
    bcm_failover_t ingress_failover_id; /* Ingress Failover Object Identifier. */
    bcm_gport_t ingress_failover_port_id; /* Ingress Failover MPLS Port
                                           Identifier. */
    bcm_failover_t failover_id;         /* Failover Object Identifier. */
    bcm_gport_t failover_port_id;       /* Failover MPLS Port Identifier. */
    bcm_policer_t policer_id;           /* Policer ID to be associated with the
                                           MPLS gport */
    bcm_multicast_t failover_mc_group;  /* MC group used for bi-cast. */
    bcm_failover_t pw_failover_id;      /* Failover Object Identifier for
                                           Redundant PW. */
    bcm_gport_t pw_failover_port_id;    /* Redundant PW port Identifier. */
    bcm_mpls_port_control_channel_type_t vccv_type; /* Indicate VCCV Control Channel */
    bcm_switch_network_group_t network_group_id; /* Split Horizon network group
                                           identifier */
    bcm_vlan_t match_subport_pkt_vid;   /* LLTAG VLAN ID to match. */
    bcm_gport_t tunnel_id;              /* Tunnel Id pointing to ingress LSP. */
    bcm_gport_t per_flow_queue_base;    /* Base queue of the per flow queue set.
                                           Actual queue is decided based on
                                           internal priority and qos map. */
    int qos_map_id;                     /* QOS map identifier. */
    bcm_failover_t egress_failover_id;  /* Failover object index for Egress
                                           Protection */
    bcm_gport_t egress_failover_port_id; /* Failover MPLS Port identifier for
                                           Egress Protection */
    int ecn_map_id;                     /* ECN map identifier. */
    uint32 class_id;                    /* Class ID */
    uint32 egress_class_id;             /* Egress Class ID */
    int inlif_counting_profile;         /* In LIF counting profile */
    bcm_mpls_egress_label_t egress_tunnel_label; /* A mpls tunnel to be binded with the
                                           pwe */
} bcm_mpls_port_t;
#endif

#if defined(INCLUDE_L3)
/* MPLS label actions. */
typedef enum bcm_mpls_switch_action_e {
    BCM_MPLS_SWITCH_ACTION_SWAP        = 0, 
    BCM_MPLS_SWITCH_ACTION_PHP         = 1, 
    BCM_MPLS_SWITCH_ACTION_POP         = 2, 
    BCM_MPLS_SWITCH_ACTION_POP_DIRECT  = 3, 
    BCM_MPLS_SWITCH_ACTION_NOP         = 4, 
    BCM_MPLS_SWITCH_EGRESS_ACTION_PUSH = 5, 
    BCM_MPLS_SWITCH_ACTION_INVALID     = 6 
} bcm_mpls_switch_action_t;
#endif

#if defined(INCLUDE_L3)
/* MPLS tunnel switch flags. */
#define BCM_MPLS_SWITCH_LOOKUP_SECOND_LABEL 0x00000001 /* Key contains label and
                                                          second_label. */
#define BCM_MPLS_SWITCH_COUNTED             0x00000002 /* Maintain packet/byte
                                                          counts. */
#define BCM_MPLS_SWITCH_INT_PRI_SET         0x00000004 /* Use specified int_pri
                                                          value for internal
                                                          priority. */
#define BCM_MPLS_SWITCH_INT_PRI_MAP         0x00000008 /* Use specified exp_map
                                                          to derive internal
                                                          priority. */
#define BCM_MPLS_SWITCH_COLOR_MAP           0x00000010 /* Use specified exp_map
                                                          to derive internal
                                                          color. */
#define BCM_MPLS_SWITCH_OUTER_EXP           0x00000020 /* Get EXP from
                                                          popped/swapped label. */
#define BCM_MPLS_SWITCH_OUTER_TTL           0x00000040 /* Get TTL from
                                                          popped/swapped label. */
#define BCM_MPLS_SWITCH_INNER_EXP           0x00000080 /* (POP/PHP) Get EXP from
                                                          header following
                                                          popped label. */
#define BCM_MPLS_SWITCH_INNER_TTL           0x00000100 /* (POP/PHP) Get TTL from
                                                          header following
                                                          popped label. */
#define BCM_MPLS_SWITCH_TTL_DECREMENT       0x00000200 /* Decrement the TTL
                                                          value by 1. */
#define BCM_MPLS_SWITCH_LOOKUP_L3_INGRESS_INTF 0x00000400 /* indicate that ingress
                                                          interface ingress_if
                                                          be a part of the
                                                          lookup key. */
#define BCM_MPLS_SWITCH_DROP                0x00000800 /* Drop all packets. */
#define BCM_MPLS_SWITCH_P2MP                0x00001000 /* Indicate
                                                          Point-to-Multipoint
                                                          Label. */
#define BCM_MPLS_SWITCH_SKIP_ETHERNET       0x00002000 /* If set then SKIP
                                                          following Ethernet and
                                                          forward packet
                                                          according to next (L3)
                                                          header. */
#define BCM_MPLS_SWITCH_EXPECT_BOS          0x00004000 /* if present then
                                                          terminated tunnel
                                                          expected to be BOS,
                                                          otherwise expected to
                                                          be not BOS. */
#define BCM_MPLS_SWITCH_TRAP_TTL_0          0x00008000 /* Trap packets with
                                                          terminated label where
                                                          TTL = 0. relevant when
                                                          action is POP. */
#define BCM_MPLS_SWITCH_TRAP_TTL_1          0x00010000 /* Trap packets with
                                                          terminated label where
                                                          TTL = 1. relevant when
                                                          action is POP. */
#define BCM_MPLS_SWITCH_LOOKUP_INT_PRI      0x00020000 /* indicate that int_pri
                                                          is valid and be a part
                                                          of the key for label
                                                          (ILM) lookup. */
#define BCM_MPLS_SWITCH_FRR                 0x00040000 /* Indicate Fast Reroute
                                                          Label. */
#define BCM_MPLS_SWITCH_ENCAP_SET           0x00080000 /* Set the TTL/EXP
                                                          encapsulation info. */
#define BCM_MPLS_SWITCH_NEXT_HEADER_L2      0x00100000 /* next header is
                                                          Ethernet, relevant for
                                                          POP and PHP action. */
#define BCM_MPLS_SWITCH_NEXT_HEADER_IPV4    0x00200000 /* next header is IPv4,
                                                          relevant for POP and
                                                          PHP action. */
#define BCM_MPLS_SWITCH_NEXT_HEADER_IPV6    0x00400000 /* next header is IPv6,
                                                          relevant for POP and
                                                          PHP action. */
#define BCM_MPLS_SWITCH_DIRECT_ATTACHED     0x00800000 /* Indicates that
                                                          egress_port is valid
                                                          and should be used
                                                          when directly attached
                                                          to egress (without
                                                          passing through next
                                                          hop object). Used only
                                                          for DNX chips. */
#define BCM_MPLS_SWITCH_ENTROPY_ENABLE      0x01000000 /* Enable MPLS Entropy
                                                          for Incoming
                                                          Tunnel-Label */
#define BCM_MPLS_SWITCH_REPLACE             0x02000000 /* Replace existing
                                                          entry. */
#define BCM_MPLS_SWITCH_WITH_ID             0x04000000 /* Add using the
                                                          specified ID. */
#define BCM_MPLS_SWITCH_WIDE                0x08000000 /* Create with wide mode. */
#define BCM_MPLS_SWITCH_LOOKUP_NONE         0x10000000 /* No source match done */
#define BCM_MPLS_SWITCH_EVPN_IML            0x20000000 /* Differentiate IML
                                                          labels from ordinary
                                                          labels */
#define BCM_MPLS_SWITCH_INGRESS_ECN_MAP     0x40000000 /* Use a specified
                                                          EXP_TO_ECN mapping to
                                                          derive IP ECN. */
#define BCM_MPLS_SWITCH_TUNNEL_TERM_ECN_MAP 0x80000000 /* Use a specified tunnel
                                                          termination ecn
                                                          mapping to derive IP
                                                          ECN. */
#define BCM_MPLS_SWITCH_KEEP_TTL            BCM_MPLS_SWITCH_TRAP_TTL_0 /* Retain incoming TTL by
                                                          disabling decrement
                                                          for MPLS flows. */
#endif

#if defined(INCLUDE_L3)
/* MPLS tunnel switch structure. */
typedef struct bcm_mpls_tunnel_switch_s {
    uint32 flags;                       /* BCM_MPLS_SWITCH_xxx. */
    bcm_mpls_label_t label;             /* Incoming label value. */
    bcm_mpls_label_t second_label;      /* Incoming second label. */
    bcm_gport_t port;                   /* Incoming port. */
    bcm_mpls_switch_action_t action;    /* MPLS label action. */
    bcm_mpls_switch_action_t action_if_bos; /* MPLS label action if BOS. */
    bcm_mpls_switch_action_t action_if_not_bos; /* MPLS label action if not BOS. */
    bcm_multicast_t mc_group;           /* P2MP Multicast group. */
    int exp_map;                        /* EXP-map ID. */
    int int_pri;                        /* Internal priority. */
    bcm_policer_t policer_id;           /* Policer ID to be associated with the
                                           incoming label. */
    bcm_vpn_t vpn;                      /* L3 VPN used if action is POP. */
    bcm_mpls_egress_label_t egress_label; /* Outgoing label information. */
    bcm_if_t egress_if;                 /* Outgoing egress object. */
    bcm_if_t ingress_if;                /* Ingress Interface object. */
    int mtu;                            /* MTU. */
    int qos_map_id;                     /* QOS map identifier. */
    bcm_failover_t failover_id;         /* Failover Object Identifier for
                                           protected tunnel. Used for 1+1
                                           protection also */
    bcm_gport_t tunnel_id;              /* Tunnel ID. */
    bcm_gport_t failover_tunnel_id;     /* Failover Tunnel ID. */
    bcm_if_t tunnel_if;                 /* hierarchical interface, relevant for
                                           when action is
                                           BCM_MPLS_SWITCH_ACTION_POP. */
    bcm_gport_t egress_port;            /* Outgoing egress port. */
    uint16 oam_global_context_id;       /* OAM global context id passed from
                                           ingress to egress XGS chip. */
    uint32 class_id;                    /* Class ID */
    int inlif_counting_profile;         /* In LIF counting profile */
    int ecn_map_id;                     /* ECN map identifier */
    int tunnel_term_ecn_map_id;         /* Tunnel termination ecn map identifier */
} bcm_mpls_tunnel_switch_t;
#endif

#if defined(INCLUDE_L3)
/* MPLS Entropy identifier Config Structure. */
typedef struct bcm_mpls_entropy_identifier_s {
    bcm_mpls_label_t label; /* Incoming entropy label value. */
    bcm_mpls_label_t mask;  /* Entropy label mask. */
    int pri;                /* Priority value of the entropy label. */
    uint32 flags;           /* BCM_MPLS_ENTROPY_xxx. */
} bcm_mpls_entropy_identifier_t;
#endif

#if defined(INCLUDE_L3)
/* Initialize the MPLS port structure. */
extern void bcm_mpls_port_t_init(
    bcm_mpls_port_t *mpls_port);
#endif

#if defined(INCLUDE_L3)
/* Initialize the MPLS egress label structure. */
extern void bcm_mpls_egress_label_t_init(
    bcm_mpls_egress_label_t *label);
#endif

#if defined(INCLUDE_L3)
/* Initialize the MPLS tunnel switch structure. */
extern void bcm_mpls_tunnel_switch_t_init(
    bcm_mpls_tunnel_switch_t *info);
#endif

#if defined(INCLUDE_L3)
/* Initialize the MPLS entropy label structure. */
extern void bcm_mpls_entropy_identifier_t_init(
    bcm_mpls_entropy_identifier_t *info);
#endif

#if defined(INCLUDE_L3)
/* Initialize a MPLS EXP map structure. */
extern void bcm_mpls_exp_map_t_init(
    bcm_mpls_exp_map_t *exp_map);
#endif

#ifndef BCM_HIDE_DISPATCHABLE

#if defined(INCLUDE_L3)
/* Initialize the BCM MPLS subsystem. */
extern int bcm_mpls_init(
    int unit);
#endif

#if defined(INCLUDE_L3)
/* Detach the MPLS software module. */
extern int bcm_mpls_cleanup(
    int unit);
#endif

#endif /* BCM_HIDE_DISPATCHABLE */

#if defined(INCLUDE_L3)
/* Flags for bcm_mpls_vpn_id_create. */
#define BCM_MPLS_VPN_L3         0x00000001 
#define BCM_MPLS_VPN_VPWS       0x00000002 
#define BCM_MPLS_VPN_VPLS       0x00000004 
#define BCM_MPLS_VPN_REPLACE    0x00000008 
#define BCM_MPLS_VPN_WITH_ID    0x00000010 
#endif

#if defined(INCLUDE_L3)
/* MPLS VPN Definitions. */
#define BCM_MPLS_VPWS_VPN_INVALID   0xFFFE     /* Invalid VPWS VPN ID */
#define BCM_MPLS_VPLS_VPN_INVALID   0xFFFF     /* Invalid VPLS VPN ID */
#endif

#if defined(INCLUDE_L3)
/* Invalid Class ID definition. */
#define BCM_CLASS_ID_INVALID    0xFFFFFFFF /* Invalid Class ID */
#endif

#if defined(INCLUDE_L3)
/* MPLS VPN Config Structure. */
typedef struct bcm_mpls_vpn_config_s {
    uint32 flags;                       /* BCM_MPLS_VPN_xxx. */
    bcm_vpn_t vpn; 
    int lookup_id; 
    bcm_multicast_t broadcast_group; 
    bcm_multicast_t unknown_unicast_group; 
    bcm_multicast_t unknown_multicast_group; 
    bcm_policer_t policer_id;           /* Policer id to be used */
    bcm_vlan_protocol_packet_ctrl_t protocol_pkt; /* Protocol packet control */
} bcm_mpls_vpn_config_t;
#endif

#if defined(INCLUDE_L3)
/* Initialize an MPLS VPN config structure. */
extern void bcm_mpls_vpn_config_t_init(
    bcm_mpls_vpn_config_t *info);
#endif

#ifndef BCM_HIDE_DISPATCHABLE

#if defined(INCLUDE_L3)
/* bcm_mpls_vpn_id_create */
extern int bcm_mpls_vpn_id_create(
    int unit, 
    bcm_mpls_vpn_config_t *info);
#endif

#if defined(INCLUDE_L3)
/* bcm_mpls_vpn_id_destroy */
extern int bcm_mpls_vpn_id_destroy(
    int unit, 
    bcm_vpn_t vpn);
#endif

#if defined(INCLUDE_L3)
/* bcm_mpls_vpn_id_destroy_all */
extern int bcm_mpls_vpn_id_destroy_all(
    int unit);
#endif

#if defined(INCLUDE_L3)
/* bcm_mpls_vpn_id_get */
extern int bcm_mpls_vpn_id_get(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_mpls_vpn_config_t *info);
#endif

#endif /* BCM_HIDE_DISPATCHABLE */

/* MPLS vpn callback function prototype */
#if defined(INCLUDE_L3)
typedef int(*bcm_mpls_vpn_traverse_cb)(
    int unit, 
    bcm_mpls_vpn_config_t *info, 
    void *user_data);
#endif

#ifndef BCM_HIDE_DISPATCHABLE

#if defined(INCLUDE_L3)
/* bcm_mpls_vpn_traverse */
extern int bcm_mpls_vpn_traverse(
    int unit, 
    bcm_mpls_vpn_traverse_cb cb, 
    void *user_data);
#endif

#if defined(INCLUDE_L3)
/* Add a MPLS logical port to the specified VPN */
extern int bcm_mpls_port_add(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_mpls_port_t *mpls_port);
#endif

#if defined(INCLUDE_L3)
/* Delete the given MPLS logical port from the specified VPN */
extern int bcm_mpls_port_delete(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_gport_t mpls_port_id);
#endif

#if defined(INCLUDE_L3)
/* bcm_mpls_port_delete_all */
extern int bcm_mpls_port_delete_all(
    int unit, 
    bcm_vpn_t vpn);
#endif

#if defined(INCLUDE_L3)
/* bcm_mpls_port_get */
extern int bcm_mpls_port_get(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_mpls_port_t *mpls_port);
#endif

#if defined(INCLUDE_L3)
/* bcm_mpls_port_get_all */
extern int bcm_mpls_port_get_all(
    int unit, 
    bcm_vpn_t vpn, 
    int port_max, 
    bcm_mpls_port_t *port_array, 
    int *port_count);
#endif

#endif /* BCM_HIDE_DISPATCHABLE */

#if defined(INCLUDE_L3)
/* MPLS statistics counters. */
typedef enum bcm_mpls_stat_e {
    bcmMplsInBytes = 0, 
    bcmMplsOutBytes = 1, 
    bcmMplsInPkts = 2, 
    bcmMplsOutPkts = 3 
} bcm_mpls_stat_t;
#endif

#if defined(INCLUDE_L3)
/* bcm_mpls_stat_info_s */
typedef struct bcm_mpls_stat_info_s {
    bcm_mpls_stat_t stat;               /* To specify In/Out Bytes/Pkts */
    uint32 num_entries;                 /* Number of Counter Entries */
    uint32 *counter_indexes;            /* Pointer to Counter indexes */
    bcm_stat_value_t *counter_values;   /* Pointer to counter values */
} bcm_mpls_stat_info_t;
#endif

#if defined(INCLUDE_L3)
/* Initialize a MPLS tunnel Stat info structure. */
extern void bcm_mpls_stat_info_t_init(
    bcm_mpls_stat_info_t *stat_info);
#endif

#ifndef BCM_HIDE_DISPATCHABLE

#if defined(INCLUDE_L3)
/* Attach counters entries to the MPLS tunnel */
extern int bcm_mpls_tunnel_stat_attach(
    int unit, 
    bcm_if_t intf_id, 
    uint32 stat_counter_id);
#endif

#if defined(INCLUDE_L3)
/* Detach counters entries to the given MPLS tunnel. */
extern int bcm_mpls_tunnel_stat_detach(
    int unit, 
    bcm_if_t intf_id);
#endif

#if defined(INCLUDE_L3)
/* Get the specified counter statistic for the given MPLS tunnel */
extern int bcm_mpls_tunnel_stat_counter_get(
    int unit, 
    bcm_if_t intf_id, 
    bcm_mpls_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values);
#endif

#if defined(INCLUDE_L3)
/* Get the specified counter statistic for the given MPLS tunnel */
extern int bcm_mpls_tunnel_stat_counter_sync_get(
    int unit, 
    bcm_if_t intf_id, 
    bcm_mpls_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values);
#endif

#if defined(INCLUDE_L3)
/* Provide stat counter ids associated with given MPLS tunnel */
extern int bcm_mpls_tunnel_stat_id_get(
    int unit, 
    bcm_if_t intf_id, 
    bcm_mpls_stat_t stat, 
    uint32 *stat_counter_id);
#endif

#if defined(INCLUDE_L3)
/* Set the specified counter statistic for the given MPLS tunnel */
extern int bcm_mpls_tunnel_stat_counter_set(
    int unit, 
    bcm_if_t intf_id, 
    bcm_mpls_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values);
#endif

#if defined(INCLUDE_L3)
/* bcm_mpls_tunnel_label_counter_id_detach */
extern int bcm_mpls_tunnel_label_counter_id_detach(
    int unit, 
    bcm_if_t intf_id, 
    uint32 stat_counter_id);
#endif

#if defined(INCLUDE_L3)
/* bcm_mpls_tunnel_label_counter_id_stat_get */
extern int bcm_mpls_tunnel_label_counter_id_stat_get(
    int unit, 
    bcm_if_t intf_id, 
    uint32 stat_counter_id, 
    bcm_mpls_stat_info_t *stat_info);
#endif

#if defined(INCLUDE_L3)
/* bcm_mpls_tunnel_label_counter_id_stat_set */
extern int bcm_mpls_tunnel_label_counter_id_stat_set(
    int unit, 
    bcm_if_t intf_id, 
    uint32 stat_counter_id, 
    bcm_mpls_stat_info_t *stat_info);
#endif

#if defined(INCLUDE_L3)
/* bcm_mpls_tunnel_label_counter_id_stat_sync_get */
extern int bcm_mpls_tunnel_label_counter_id_stat_sync_get(
    int unit, 
    bcm_if_t intf_id, 
    uint32 stat_counter_id, 
    bcm_mpls_stat_info_t *stat_info);
#endif

#if defined(INCLUDE_L3)
/* mpls_tunnel_label_counter_id_num_get */
extern int bcm_mpls_tunnel_label_counter_id_num_get(
    int unit, 
    bcm_if_t intf_id, 
    int *num_counters, 
    uint32 *stat_counter_id);
#endif

#if defined(INCLUDE_L3)
/* bcm_mpls_tunnel_initiator_set */
extern int bcm_mpls_tunnel_initiator_set(
    int unit, 
    bcm_if_t intf, 
    int num_labels, 
    bcm_mpls_egress_label_t *label_array);
#endif

#if defined(INCLUDE_L3)
/* bcm_mpls_tunnel_initiator_create */
extern int bcm_mpls_tunnel_initiator_create(
    int unit, 
    bcm_if_t intf, 
    int num_labels, 
    bcm_mpls_egress_label_t *label_array);
#endif

#if defined(INCLUDE_L3)
/* bcm_mpls_tunnel_initiator_clear */
extern int bcm_mpls_tunnel_initiator_clear(
    int unit, 
    bcm_if_t intf);
#endif

#if defined(INCLUDE_L3)
/* bcm_mpls_tunnel_initiator_clear_all */
extern int bcm_mpls_tunnel_initiator_clear_all(
    int unit);
#endif

#if defined(INCLUDE_L3)
/* bcm_mpls_tunnel_initiator_get */
extern int bcm_mpls_tunnel_initiator_get(
    int unit, 
    bcm_if_t intf, 
    int label_max, 
    bcm_mpls_egress_label_t *label_array, 
    int *label_count);
#endif

#if defined(INCLUDE_L3)
/* bcm_mpls_tunnel_switch_add */
extern int bcm_mpls_tunnel_switch_add(
    int unit, 
    bcm_mpls_tunnel_switch_t *info);
#endif

#if defined(INCLUDE_L3)
/* bcm_mpls_tunnel_switch_create */
extern int bcm_mpls_tunnel_switch_create(
    int unit, 
    bcm_mpls_tunnel_switch_t *info);
#endif

#if defined(INCLUDE_L3)
/* bcm_mpls_tunnel_switch_delete */
extern int bcm_mpls_tunnel_switch_delete(
    int unit, 
    bcm_mpls_tunnel_switch_t *info);
#endif

#if defined(INCLUDE_L3)
/* bcm_mpls_tunnel_switch_delete_all */
extern int bcm_mpls_tunnel_switch_delete_all(
    int unit);
#endif

#if defined(INCLUDE_L3)
/* bcm_mpls_tunnel_switch_get */
extern int bcm_mpls_tunnel_switch_get(
    int unit, 
    bcm_mpls_tunnel_switch_t *info);
#endif

#endif /* BCM_HIDE_DISPATCHABLE */

/* MPLS tunnel callback function prototype. */
#if defined(INCLUDE_L3)
typedef int (*bcm_mpls_tunnel_switch_traverse_cb)(
    int unit, 
    bcm_mpls_tunnel_switch_t *info, 
    void *user_data);
#endif

#ifndef BCM_HIDE_DISPATCHABLE

#if defined(INCLUDE_L3)
/* bcm_mpls_tunnel_switch_traverse */
extern int bcm_mpls_tunnel_switch_traverse(
    int unit, 
    bcm_mpls_tunnel_switch_traverse_cb cb, 
    void *user_data);
#endif

#endif /* BCM_HIDE_DISPATCHABLE */

#if defined(INCLUDE_L3)
/* MPLS entropy label config flags. */
#define BCM_MPLS_ENTROPY_LABEL_IDENTIFIER_TOS 0x00000001 /* Identifies entropy
                                                          label, if present at
                                                          the top of the label
                                                          stack, based on a
                                                          match of the upper
                                                          label bits */
#endif

#ifndef BCM_HIDE_DISPATCHABLE

#if defined(INCLUDE_L3)
/* bcm_mpls_entropy_identifier_add */
extern int bcm_mpls_entropy_identifier_add(
    int unit, 
    uint32 options, 
    bcm_mpls_entropy_identifier_t *info);
#endif

#if defined(INCLUDE_L3)
/* bcm_mpls_entropy_identifier_get */
extern int bcm_mpls_entropy_identifier_get(
    int unit, 
    bcm_mpls_entropy_identifier_t *info);
#endif

#if defined(INCLUDE_L3)
/* bcm_mpls_entropy_identifier_delete */
extern int bcm_mpls_entropy_identifier_delete(
    int unit, 
    bcm_mpls_entropy_identifier_t *info);
#endif

#if defined(INCLUDE_L3)
/* bcm_mpls_entropy_identifier_delete_all */
extern int bcm_mpls_entropy_identifier_delete_all(
    int unit);
#endif

#endif /* BCM_HIDE_DISPATCHABLE */

/* MPLS entropy label callback function prototype. */
#if defined(INCLUDE_L3)
typedef int (*bcm_mpls_entropy_identifier_traverse_cb)(
    int unit, 
    bcm_mpls_entropy_identifier_t *info, 
    void *user_data);
#endif

#ifndef BCM_HIDE_DISPATCHABLE

#if defined(INCLUDE_L3)
/* bcm_mpls_entropy_identifier_traverse */
extern int bcm_mpls_entropy_identifier_traverse(
    int unit, 
    bcm_mpls_entropy_identifier_traverse_cb cb, 
    void *user_data);
#endif

#endif /* BCM_HIDE_DISPATCHABLE */

#if defined(INCLUDE_L3)
/* MPLS EXP map modes. */
#define BCM_MPLS_EXP_MAP_WITH_ID    0x01       
#define BCM_MPLS_EXP_MAP_INGRESS    0x02       
#define BCM_MPLS_EXP_MAP_EGRESS     0x04       
#define BCM_MPLS_EXP_MAP_EGRESS_L2  0x08       
#endif

#ifndef BCM_HIDE_DISPATCHABLE

#if defined(INCLUDE_L3)
/* Create an MPLS EXP map instance. */
extern int bcm_mpls_exp_map_create(
    int unit, 
    uint32 flags, 
    int *exp_map_id);
#endif

#if defined(INCLUDE_L3)
/* Destroy an MPLS EXP map instance. */
extern int bcm_mpls_exp_map_destroy(
    int unit, 
    int exp_map_id);
#endif

#if defined(INCLUDE_L3)
/* 
 * Set the { internal priority, color }-to-EXP mapping in the specified
 * EXP map.
 */
extern int bcm_mpls_exp_map_set(
    int unit, 
    int exp_map_id, 
    bcm_mpls_exp_map_t *exp_map);
#endif

#if defined(INCLUDE_L3)
/* 
 * Get the { internal priority, color }-to-EXP mapping in the specified
 * EXP map.
 */
extern int bcm_mpls_exp_map_get(
    int unit, 
    int exp_map_id, 
    bcm_mpls_exp_map_t *exp_map);
#endif

#if defined(INCLUDE_L3)
/* Enable statistics collection for MPLS label or MPLS gport */
extern int bcm_mpls_label_stat_enable_set(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port, 
    int enable);
#endif

#if defined(INCLUDE_L3)
/* bcm_mpls_label_stat_get */
extern int bcm_mpls_label_stat_get(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint64 *val);
#endif

#if defined(INCLUDE_L3)
/* bcm_mpls_label_stat_sync_get */
extern int bcm_mpls_label_stat_sync_get(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint64 *val);
#endif

#if defined(INCLUDE_L3)
/* bcm_mpls_label_stat_get32 */
extern int bcm_mpls_label_stat_get32(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint32 *val);
#endif

#if defined(INCLUDE_L3)
/* bcm_mpls_label_stat_sync_get32 */
extern int bcm_mpls_label_stat_sync_get32(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint32 *val);
#endif

#if defined(INCLUDE_L3)
/* bcm_mpls_label_stat_clear */
extern int bcm_mpls_label_stat_clear(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat);
#endif

#if defined(INCLUDE_L3)
/* bcm_mpls_port_stat_enable_set */
extern int bcm_mpls_port_stat_enable_set(
    int unit, 
    bcm_gport_t mpls_port, 
    int enable);
#endif

#endif /* BCM_HIDE_DISPATCHABLE */

#if defined(INCLUDE_L3)
/* Types of statistics that are maintained per MPLS gport. */
typedef enum bcm_mpls_port_stat_e {
    bcmMplsPortStatUnicastPackets = 0, 
    bcmMplsPortStatUnicastBytes = 1, 
    bcmMplsPortStatNonUnicastPackets = 2, 
    bcmMplsPortStatNonUnicastBytes = 3, 
    bcmMplsPortStatDropPackets = 4, 
    bcmMplsPortStatDropBytes = 5, 
    bcmMplsPortStatFloodPackets = 6, 
    bcmMplsPortStatFloodBytes = 7, 
    bcmMplsPortStatFloodDropPackets = 8, 
    bcmMplsPortStatFloodDropBytes = 9, 
    bcmMplsPortStatGreenPackets = 10, 
    bcmMplsPortStatGreenBytes = 11, 
    bcmMplsPortStatYellowPackets = 12, 
    bcmMplsPortStatYellowBytes = 13, 
    bcmMplsPortStatRedPackets = 14, 
    bcmMplsPortStatRedBytes = 15 
} bcm_mpls_port_stat_t;
#endif

#ifndef BCM_HIDE_DISPATCHABLE

#if defined(INCLUDE_L3)
/* bcm_mpls_port_stat_set */
extern int bcm_mpls_port_stat_set(
    int unit, 
    bcm_gport_t mpls_port, 
    bcm_cos_t cos, 
    bcm_mpls_port_stat_t stat, 
    uint64 val);
#endif

#if defined(INCLUDE_L3)
/* bcm_mpls_port_stat_set32 */
extern int bcm_mpls_port_stat_set32(
    int unit, 
    bcm_gport_t mpls_port, 
    bcm_cos_t cos, 
    bcm_mpls_port_stat_t stat, 
    uint32 val);
#endif

#if defined(INCLUDE_L3)
/* bcm_mpls_port_stat_get */
extern int bcm_mpls_port_stat_get(
    int unit, 
    bcm_gport_t mpls_port, 
    bcm_cos_t cos, 
    bcm_mpls_port_stat_t stat, 
    uint64 *val);
#endif

#if defined(INCLUDE_L3)
/* bcm_mpls_port_stat_get32 */
extern int bcm_mpls_port_stat_get32(
    int unit, 
    bcm_gport_t mpls_port, 
    bcm_cos_t cos, 
    bcm_mpls_port_stat_t stat, 
    uint32 *val);
#endif

#if defined(INCLUDE_L3)
/* Provide stat counter ids associated with given mpls gport and vpn */
extern int bcm_mpls_port_stat_id_get(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint32 *stat_counter_id);
#endif

#if defined(INCLUDE_L3)
/* Provide stat counter ids associated with given mpls gport and label */
extern int bcm_mpls_label_stat_id_get(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint32 *stat_counter_id);
#endif

#if defined(INCLUDE_L3)
/* Attach counters entries to the given mpls gport and vpn */
extern int bcm_mpls_port_stat_attach(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_gport_t port, 
    uint32 stat_counter_id);
#endif

#if defined(INCLUDE_L3)
/* Detach counters entries to the given mpls port and vpn */
extern int bcm_mpls_port_stat_detach(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_gport_t port);
#endif

#if defined(INCLUDE_L3)
/* Get counter statistic values for specific vpn and gport */
extern int bcm_mpls_port_stat_counter_get(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values);
#endif

#if defined(INCLUDE_L3)
/* Get counter statistic values for specific vpn and gport */
extern int bcm_mpls_port_stat_counter_sync_get(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values);
#endif

#if defined(INCLUDE_L3)
/* Set counter statistic values for specific vpn and gport */
extern int bcm_mpls_port_stat_counter_set(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values);
#endif

#if defined(INCLUDE_L3)
/* Attach counters entries to the given mpls label and gport */
extern int bcm_mpls_label_stat_attach(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port, 
    uint32 stat_counter_id);
#endif

#if defined(INCLUDE_L3)
/* Detach counters entries to the given mpls label and gport */
extern int bcm_mpls_label_stat_detach(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port);
#endif

#if defined(INCLUDE_L3)
/* Get counter statistic values for specific MPLS label and gport */
extern int bcm_mpls_label_stat_counter_sync_get(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values);
#endif

#if defined(INCLUDE_L3)
/* Get counter statistic values for specific MPLS label and gport */
extern int bcm_mpls_label_stat_counter_get(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values);
#endif

#if defined(INCLUDE_L3)
/* Set counter statistic values for specific MPLS label and gport */
extern int bcm_mpls_label_stat_counter_set(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values);
#endif

#endif /* BCM_HIDE_DISPATCHABLE */

#if defined(INCLUDE_L3)
#define BCM_MPLS_INDEXED_LABEL_SET(_label, _label_value, _index)  _SHR_MPLS_INDEXED_LABEL_SET(_label, _label_value,_index) 
#define BCM_MPLS_INDEXED_LABEL_VALUE_GET(_label)  _SHR_MPLS_INDEXED_LABEL_VALUE_GET(_label) 
#define BCM_MPLS_INDEXED_LABEL_INDEX_GET(_label)  _SHR_MPLS_INDEXED_LABEL_INDEX_GET(_label) 
#endif

#if defined(INCLUDE_L3)
/* MPLS range action */
typedef struct bcm_mpls_range_action_s {
    uint32 flags;                       /* BCM_MPLS_RANGE_ACTION_xxx */
    bcm_mpls_label_t compressed_label;  /* lowest label in the range */
} bcm_mpls_range_action_t;
#endif

/* MPLS range action flags. */
#define BCM_MPLS_RANGE_ACTION_COMPRESSED    0x00000001 /* Given label range will
                                                          be represented by the
                                                          lowest label */
#define BCM_MPLS_RANGE_ACTION_EVPN_IML      0x00000002 /* Specify a range for
                                                          EVPN IML labels */
#define BCM_MPLS_RANGE_ACTION_VID           0x00000004 /* Mpls range profile:
                                                          ptagged, outer tag
                                                          valid */
#define BCM_MPLS_RANGE_ACTION_INNER_VID     0x00000008 /* Mpls range profile:
                                                          ptagged, inner tag
                                                          valid */
#define BCM_MPLS_RANGE_ACTION_CONTROL_WORD  0x00000010 /*  Indicate that all the
                                                          labels in the range
                                                          have CW */

#ifndef BCM_HIDE_DISPATCHABLE

#if defined(INCLUDE_L3)
/* Set range of labels per in lif */
extern int bcm_mpls_range_action_add(
    int unit, 
    bcm_mpls_label_t label_low, 
    bcm_mpls_label_t label_high, 
    bcm_mpls_range_action_t *action);
#endif

#if defined(INCLUDE_L3)
/* Remove range of labels per in-lif */
extern int bcm_mpls_range_action_remove(
    int unit, 
    bcm_mpls_label_t label_low, 
    bcm_mpls_label_t label_high);
#endif

#if defined(INCLUDE_L3)
/* Get range of labels per in lif */
extern int bcm_mpls_range_action_get(
    int unit, 
    bcm_mpls_label_t label_low, 
    bcm_mpls_label_t label_high, 
    bcm_mpls_range_action_t *action);
#endif

#endif /* BCM_HIDE_DISPATCHABLE */

#if defined(INCLUDE_L3)
/* Initialize the MPLS range action structure. */
extern void bcm_mpls_range_action_t_init(
    bcm_mpls_range_action_t *label);
#endif

#endif /* __BCM_MPLS_H__ */
