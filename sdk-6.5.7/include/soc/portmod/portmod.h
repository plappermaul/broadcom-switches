/*
 *         
 * $Id:$
 * 
 * $Copyright: (c) 2016 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 *         
 *     
 * DO NOT EDIT THIS FILE!
 *
 */

#ifndef _PORTMOD_H__H_
#define _PORTMOD_H__H_

#include <phymod/phymod.h>
#include <phymod/phymod_diagnostics.h>
#include <soc/portmod/portmod_defs.h>

/*!
 * @enum portmod_dispatch_type_e
 * @brief Supported Drivers 
 */ 
typedef enum portmod_dispatch_type_e {
#ifdef PORTMOD_PM4X25_SUPPORT
    portmodDispatchTypePm4x25,
#endif /*PORTMOD_PM4X25_SUPPORT  */
#ifdef PORTMOD_PM4X10_SUPPORT
    portmodDispatchTypePm4x10,
#endif /*PORTMOD_PM4X10_SUPPORT  */
#ifdef PORTMOD_PM4X10TD_SUPPORT
    portmodDispatchTypePm4x10td,
#endif /*PORTMOD_PM4X10TD_SUPPORT  */
#ifdef PORTMOD_PM12X10_SUPPORT
    portmodDispatchTypePm12x10,
#endif /*PORTMOD_PM12X10_SUPPORT  */
#ifdef PORTMOD_PM4x10Q_SUPPORT
    portmodDispatchTypePm4x10Q,
#endif /*PORTMOD_PM4x10Q_SUPPORT  */
#ifdef PORTMOD_PM_QTC_SUPPORT
    portmodDispatchTypePm_qtc,
#endif /*PORTMOD_PM_QTC_SUPPORT  */
#ifdef PORTMOD_PM_OS_ILKN_SUPPORT
    portmodDispatchTypePmOsILKN,
#endif /*PORTMOD_PM_OS_ILKN_SUPPORT  */
#ifdef PORTMOD_DNX_FABRIC_SUPPORT
    portmodDispatchTypeDnx_fabric,
#endif /*PORTMOD_DNX_FABRIC_SUPPORT  */
#ifdef PORTMOD_DNX_FABRIC_O_NIF_SUPPORT
    portmodDispatchTypeDnx_fabric_o_nif,
#endif /*PORTMOD_DNX_FABRIC_O_NIF_SUPPORT  */
#ifdef PORTMOD_PM8X50_FABRIC_SUPPORT
    portmodDispatchTypePm8x50_fabric,
#endif /*PORTMOD_PM8X50_FABRIC_SUPPORT  */
#ifdef PORTMOD_PM4X25TD_SUPPORT
    portmodDispatchTypePm4x25td,
#endif /*PORTMOD_PM4X25TD_SUPPORT  */
#ifdef PORTMOD_PM12X10_XGS_SUPPORT
    portmodDispatchTypePm12x10_xgs,
#endif /*PORTMOD_PM12X10_XGS_SUPPORT  */
#ifdef PORTMOD_PM4X2P5_SUPPORT
    portmodDispatchTypePm4x2p5,
#endif /*PORTMOD_PM4X2P5_SUPPORT  */
#ifdef PORTMOD_PMNULL_SUPPORT
    portmodDispatchTypePmNull,
#endif /*PORTMOD_PMNULL_SUPPORT  */
    portmodDispatchTypeCount
} portmod_dispatch_type_t;

#ifdef PORTMOD_DIAG
extern enum_mapping_t portmod_dispatch_type_t_mapping[];
#endif /*PORTMOD_DIAG*/

/* portmod_dispatch_type_t validation */
int portmod_dispatch_type_t_validate(int unit, portmod_dispatch_type_t portmod_dispatch_type);
/*! 
 * @brief Flags for user access struct 
 */ 
#define PORTMOD_USER_ACCESS_FW_LOAD_REVERSE 0x1 /**< Load FW in reverse mode */
#define PORTMOD_USER_ACCESS_REG_VAL_OFFSET_ZERO 0x2 /**< When reading register using UCMEM the data is in offset 0 */

#define PORTMOD_USER_ACCESS_FW_LOAD_REVERSE_SET(user_data) ((user_data->flags) |= PORTMOD_USER_ACCESS_FW_LOAD_REVERSE)
#define PORTMOD_USER_ACCESS_REG_VAL_OFFSET_ZERO_SET(user_data) ((user_data->flags) |= PORTMOD_USER_ACCESS_REG_VAL_OFFSET_ZERO)

#define PORTMOD_USER_ACCESS_FW_LOAD_REVERSE_CLR(user_data) ((user_data->flags) &= ~PORTMOD_USER_ACCESS_FW_LOAD_REVERSE)
#define PORTMOD_USER_ACCESS_REG_VAL_OFFSET_ZERO_CLR(user_data) ((user_data->flags) &= ~PORTMOD_USER_ACCESS_REG_VAL_OFFSET_ZERO)

#define PORTMOD_USER_ACCESS_FW_LOAD_REVERSE_GET(user_data) ((user_data->flags) & PORTMOD_USER_ACCESS_FW_LOAD_REVERSE ? 1 : 0)
#define PORTMOD_USER_ACCESS_REG_VAL_OFFSET_ZERO_GET(user_data) ((user_data->flags) & PORTMOD_USER_ACCESS_REG_VAL_OFFSET_ZERO ? 1 : 0)


/*!
 * @struct portmod_default_user_access_s
 * @brief Expected user access structure when using PM default bus 
 */ 
typedef struct portmod_default_user_access_s {
    int unit; /**< Unit that will be used for phy access */
    int blk_id; /**< block id */
    sal_mutex_t mutex; /**< Mutex operation for phy access */
    uint32 flags; /**< user access flags */
} portmod_default_user_access_t;

/* portmod_default_user_access_t initialization and validation */
int portmod_default_user_access_t_validate(int unit, const portmod_default_user_access_t* portmod_default_user_access);
int portmod_default_user_access_t_init(int unit, portmod_default_user_access_t* portmod_default_user_access);


/*!
 * @struct portmod_pm4x10q_user_data_s
 * @brief Expected qsgmii user access structure when using PMQ default bus 
 */ 
typedef struct portmod_pm4x10q_user_data_s {
    phymod_access_t pm4x10_access; /**< Unit that will be used for phy access */
    portmod_default_user_access_t qsgmiie_user_data; /**< qsgmii_access */
} portmod_pm4x10q_user_data_t;

/* portmod_pm4x10q_user_data_t initialization and validation */
int portmod_pm4x10q_user_data_t_validate(int unit, const portmod_pm4x10q_user_data_t* portmod_pm4x10q_user_data);
int portmod_pm4x10q_user_data_t_init(int unit, portmod_pm4x10q_user_data_t* portmod_pm4x10q_user_data);


/*!
 * @struct portmod_fifo_status_s
 * @brief In Fifo Time stamp Value. 
 */ 
typedef struct portmod_fifo_status_s {
    uint32 timestamps_in_fifo; /**< Timestamps in Fifo */
} portmod_fifo_status_t;

/* portmod_fifo_status_t initialization and validation */
int portmod_fifo_status_t_validate(int unit, const portmod_fifo_status_t* portmod_fifo_status);
int portmod_fifo_status_t_init(int unit, portmod_fifo_status_t* portmod_fifo_status);


/*!
 * @struct portmod_pfc_config_s
 * @brief PFC Config Information. 
 */ 
typedef struct portmod_pfc_config_s {
    uint32 type; /**< PFC Ether Type */
    uint32 opcode; /**< PFC Message Opcode */
    uint32 classes; /**< PFC Classes */
    uint32 da_oui; /**< PFC OUI Msg OUI Dest Addr */
    uint32 da_nonoui; /**< PFC Non OUI Dest Addr */
    uint32 rxpass; /**< PFC rxpass */
} portmod_pfc_config_t;

/* portmod_pfc_config_t initialization and validation */
int portmod_pfc_config_t_validate(int unit, const portmod_pfc_config_t* portmod_pfc_config);
int portmod_pfc_config_t_init(int unit, portmod_pfc_config_t* portmod_pfc_config);


/*!
 * @struct portmod_eee_s
 * @brief EEE Timer Information. 
 */ 
typedef struct portmod_eee_s {
    uint32 enable; /**< EEE Enable */
    uint32 tx_idle_time; /**< EEE tx idle time */
    uint32 tx_wake_time; /**< EEE tx wake time */
} portmod_eee_t;

/* portmod_eee_t initialization and validation */
int portmod_eee_t_validate(int unit, const portmod_eee_t* portmod_eee);
int portmod_eee_t_init(int unit, portmod_eee_t* portmod_eee);


/*!
 * @struct portmod_eee_clock_s
 * @brief EEE clock gate Information. 
 */ 
typedef struct portmod_eee_clock_s {
    uint32 clock_gate; /**< EEE Clock Gate */
    uint32 clock_count; /**< EEE clock counter */
    uint32 timer_pulse; /**< EEE timer pulse */
} portmod_eee_clock_t;

/* portmod_eee_clock_t initialization and validation */
int portmod_eee_clock_t_validate(int unit, const portmod_eee_clock_t* portmod_eee_clock);
int portmod_eee_clock_t_init(int unit, portmod_eee_clock_t* portmod_eee_clock);


/*!
 * @struct portmod_vlan_tag_s
 * @brief Vlan Tag Inner/Outer Values. 
 */ 
typedef struct portmod_vlan_tag_s {
    int inner_vlan_tag; /**< Inner Vlan Tag */
    int outer_vlan_tag; /**< Outer Vlan Tag */
} portmod_vlan_tag_t;

/* portmod_vlan_tag_t initialization and validation */
int portmod_vlan_tag_t_validate(int unit, const portmod_vlan_tag_t* portmod_vlan_tag);
int portmod_vlan_tag_t_init(int unit, portmod_vlan_tag_t* portmod_vlan_tag);

#define PORTMOD_MAC_PASS_CONTROL_FRAME 0x1 /**< pass control frame to system side */
#define PORTMOD_MAC_PASS_PFC_FRAME 0x2 /**< pass pfc frame to system side */
#define PORTMOD_MAC_PASS_PAUSE_FRAME 0x4 /**< pass pause frame to system side */


/*!
 * @struct portmod_rx_control_s
 * @brief Rx Control Pass control frames. 
 */ 
typedef struct portmod_rx_control_s {
    uint32 flags; /**< bitmap for rx Frames */
    uint32 pass_control_frames; /**< Pass Control Frames */
    uint32 pass_pfc_frames; /**< Pass PFC Frames */
    uint32 pass_pause_frames; /**< Pass pause Frames */
} portmod_rx_control_t;

/* portmod_rx_control_t initialization and validation */
int portmod_rx_control_t_validate(int unit, const portmod_rx_control_t* portmod_rx_control);
int portmod_rx_control_t_init(int unit, portmod_rx_control_t* portmod_rx_control);

typedef struct portmod_multi_get_s {
    uint32 flags;
    uint32 dev_addr;
    uint32 offset;
    uint32 max_size;
    unsigned char* data;
    uint32* actual_size;
} portmod_multi_get_t;

/* portmod_multi_get_t initialization and validation */
int portmod_multi_get_t_validate(int unit, const portmod_multi_get_t* portmod_multi_get);
int portmod_multi_get_t_init(int unit, portmod_multi_get_t* portmod_multi_get);

#define PORTMOD_NUM_PATTERN_DATA_INTS (8)
#define PORTMOD_TSCE_LANE_NAME_LEN (30)

#define PORTMOD_PCS_8B9B_LFEC _SHR_PORT_PCS_8B9BLFEC
#define PORTMOD_PCS_8B10B _SHR_PORT_PCS_8B10B
#define PORTMOD_PCS_64B66B_FEC _SHR_PORT_PCS_64B66BFEC /**< 64/66b FEC */
#define PORTMOD_PCS_64B66B_BEC _SHR_PORT_PCS_64B66BBEC /**< 64/66b BEC */
#define PORTMOD_PCS_64B66B _SHR_PORT_PCS_64B66B /**< 64/66b without FEC */
#define PORTMOD_PCS_64B66B_RS_FEC _SHR_PORT_PCS_64B66B_RS_FEC /**< 64/66b reed solomon FEC */
#define PORTMOD_PCS_64B66B_LOW_LATENCY_RS_FEC _SHR_PORT_PCS_64B66B_LOW_LATENCY_RS_FEC /**< 64/66b low latency reed solomon FEC */
#define PORTMOD_PCS_UNKNOWN _SHR_PORT_PCS_UNKNOWN /**< unknown pcs */

#define PORTMOD_CL37_DISABLE (0x0)
#define PORTMOD_CL37_W_BAM (0x1)
#define PORTMOD_CL37_WO_BAM (0x2)
#define PORTMOD_CL37_W_10G (0x3)
#define PORTMOD_CL37_HR2SPM (0x4)
#define PORTMOD_CL37_HR2SPM_W_10G (0x5)
#define PORTMOD_CL37_W_BAM_HG (0x6)
#define PORTMOD_CL37_SGMII_COMBO (0x7)

#define PORTMOD_CL73_DISABLE (0x0)
#define PORTMOD_CL73_WO_BAM (0x2)
#define PORTMOD_CL73_W_BAM (0x1)
#define PORTMOD_CL73_HPAM (0x4)
#define PORTMOD_CL73_CL37 (0x5)
#define PORTMOD_CL73_HG (0x6)
#define PORTMOD_CL73_HPAM_VS_SW (0x8)

typedef _shr_port_pcs_t portmod_port_pcs_t;

/*! 
 * @brief Flags for port enable set. no flags means RX+TX for MAC and PHY 
 */ 
#define PORTMOD_PORT_ENABLE_MAC 0x1 /**< enable/disable the MAC(RX/TX according to the flags) */
#define PORTMOD_PORT_ENABLE_PHY 0x2 /**< enable/disable the Serdes (RX/TX according to the flags) */
#define PORTMOD_PORT_ENABLE_TX 0x4 /**< enable/disable TX */
#define PORTMOD_PORT_ENABLE_RX 0x8 /**< enable/disable RX */
#define PORTMOD_PORT_ENABLE_INTERNAL_PHY_ONLY 0x10 /**< enable/disable only the internal phy */

#define PORTMOD_PORT_ENABLE_MAC_SET(flags) ((flags) |= PORTMOD_PORT_ENABLE_MAC)
#define PORTMOD_PORT_ENABLE_PHY_SET(flags) ((flags) |= PORTMOD_PORT_ENABLE_PHY)
#define PORTMOD_PORT_ENABLE_TX_SET(flags) ((flags) |= PORTMOD_PORT_ENABLE_TX)
#define PORTMOD_PORT_ENABLE_RX_SET(flags) ((flags) |= PORTMOD_PORT_ENABLE_RX)
#define PORTMOD_PORT_ENABLE_INTERNAL_PHY_ONLY_SET(flags) ((flags) |= PORTMOD_PORT_ENABLE_INTERNAL_PHY_ONLY)

#define PORTMOD_PORT_ENABLE_MAC_CLR(flags) ((flags) &= ~PORTMOD_PORT_ENABLE_MAC)
#define PORTMOD_PORT_ENABLE_PHY_CLR(flags) ((flags) &= ~PORTMOD_PORT_ENABLE_PHY)
#define PORTMOD_PORT_ENABLE_TX_CLR(flags) ((flags) &= ~PORTMOD_PORT_ENABLE_TX)
#define PORTMOD_PORT_ENABLE_RX_CLR(flags) ((flags) &= ~PORTMOD_PORT_ENABLE_RX)
#define PORTMOD_PORT_ENABLE_INTERNAL_PHY_ONLY_CLR(flags) ((flags) &= ~PORTMOD_PORT_ENABLE_INTERNAL_PHY_ONLY)

#define PORTMOD_PORT_ENABLE_MAC_GET(flags) ((flags) & PORTMOD_PORT_ENABLE_MAC ? 1 : 0)
#define PORTMOD_PORT_ENABLE_PHY_GET(flags) ((flags) & PORTMOD_PORT_ENABLE_PHY ? 1 : 0)
#define PORTMOD_PORT_ENABLE_TX_GET(flags) ((flags) & PORTMOD_PORT_ENABLE_TX ? 1 : 0)
#define PORTMOD_PORT_ENABLE_RX_GET(flags) ((flags) & PORTMOD_PORT_ENABLE_RX ? 1 : 0)
#define PORTMOD_PORT_ENABLE_INTERNAL_PHY_ONLY_GET(flags) ((flags) & PORTMOD_PORT_ENABLE_INTERNAL_PHY_ONLY ? 1 : 0)

/*! 
 * @brief Flags for TX paramas setting method 
 */ 
#define PORTMOD_USER_SET_TX_PREEMPHASIS_BY_CONFIG 0x1 /**< preemphasis by configuration setting */
#define PORTMOD_USER_SET_TX_AMP_BY_CONFIG 0x2 /**< preemphasis by configuration setting */
#define PORTMOD_USER_SET_TX_PREEMPHASIS_BY_API 0x4 /**< by api call */
#define PORTMOD_USER_SET_TX_AMP_BY_API 0x8 /**< by api call */

#define PORTMOD_USER_SET_TX_PREEMPHASIS_BY_CONFIG_SET(flags) ((flags) |= PORTMOD_USER_SET_TX_PREEMPHASIS_BY_CONFIG)
#define PORTMOD_USER_SET_TX_AMP_BY_CONFIG_SET(flags) ((flags) |= PORTMOD_USER_SET_TX_AMP_BY_CONFIG)
#define PORTMOD_USER_SET_TX_PREEMPHASIS_BY_API_SET(flags) ((flags) |= PORTMOD_USER_SET_TX_PREEMPHASIS_BY_API)
#define PORTMOD_USER_SET_TX_AMP_BY_API_SET(flags) ((flags) |= PORTMOD_USER_SET_TX_AMP_BY_API)

#define PORTMOD_USER_SET_TX_PREEMPHASIS_BY_CONFIG_CLR(flags) ((flags) &= ~PORTMOD_USER_SET_TX_PREEMPHASIS_BY_CONFIG)
#define PORTMOD_USER_SET_TX_AMP_BY_CONFIG_CLR(flags) ((flags) &= ~PORTMOD_USER_SET_TX_AMP_BY_CONFIG)
#define PORTMOD_USER_SET_TX_PREEMPHASIS_BY_API_CLR(flags) ((flags) &= ~PORTMOD_USER_SET_TX_PREEMPHASIS_BY_API)
#define PORTMOD_USER_SET_TX_AMP_BY_API_CLR(flags) ((flags) &= ~PORTMOD_USER_SET_TX_AMP_BY_API)

#define PORTMOD_USER_SET_TX_PREEMPHASIS_BY_CONFIG_GET(flags) ((flags) & PORTMOD_USER_SET_TX_PREEMPHASIS_BY_CONFIG ? 1 : 0)
#define PORTMOD_USER_SET_TX_AMP_BY_CONFIG_GET(flags) ((flags) & PORTMOD_USER_SET_TX_AMP_BY_CONFIG ? 1 : 0)
#define PORTMOD_USER_SET_TX_PREEMPHASIS_BY_API_GET(flags) ((flags) & PORTMOD_USER_SET_TX_PREEMPHASIS_BY_API ? 1 : 0)
#define PORTMOD_USER_SET_TX_AMP_BY_API_GET(flags) ((flags) & PORTMOD_USER_SET_TX_AMP_BY_API ? 1 : 0)

/*! 
 * @brief properties for portmod_port_encoding_set, portmod_port_encoding_get 
 */ 
#define PORTMOD_ENCODING_LOW_LATENCY_LLFC 0x1
#define PORTMOD_ENCODING_FEC_ERROR_DETECT 0x2 /**< enable/disable the MAC(RX/TX according to the flags) */
#define PORTMOD_ENCODING_EXTRCT_CIG_FROM_LLFC 0x4 /**< enable/disable the MAC(RX/TX according to the flags) */

#define PORTMOD_ENCODING_LOW_LATENCY_LLFC_SET(properties) ((properties) |= PORTMOD_ENCODING_LOW_LATENCY_LLFC)
#define PORTMOD_ENCODING_FEC_ERROR_DETECT_SET(properties) ((properties) |= PORTMOD_ENCODING_FEC_ERROR_DETECT)
#define PORTMOD_ENCODING_EXTRCT_CIG_FROM_LLFC_SET(properties) ((properties) |= PORTMOD_ENCODING_EXTRCT_CIG_FROM_LLFC)

#define PORTMOD_ENCODING_LOW_LATENCY_LLFC_CLR(properties) ((properties) &= ~PORTMOD_ENCODING_LOW_LATENCY_LLFC)
#define PORTMOD_ENCODING_FEC_ERROR_DETECT_CLR(properties) ((properties) &= ~PORTMOD_ENCODING_FEC_ERROR_DETECT)
#define PORTMOD_ENCODING_EXTRCT_CIG_FROM_LLFC_CLR(properties) ((properties) &= ~PORTMOD_ENCODING_EXTRCT_CIG_FROM_LLFC)

#define PORTMOD_ENCODING_LOW_LATENCY_LLFC_GET(properties) ((properties) & PORTMOD_ENCODING_LOW_LATENCY_LLFC ? 1 : 0)
#define PORTMOD_ENCODING_FEC_ERROR_DETECT_GET(properties) ((properties) & PORTMOD_ENCODING_FEC_ERROR_DETECT ? 1 : 0)
#define PORTMOD_ENCODING_EXTRCT_CIG_FROM_LLFC_GET(properties) ((properties) & PORTMOD_ENCODING_EXTRCT_CIG_FROM_LLFC ? 1 : 0)

#define PORTMOD_MAX_CORES_PER_PORT (3)


/*!
 * @enum portmod_loopback_mode_e
 * @brief looopback modes for portmod_port_loopback_set, portmod_port_loopback_get 
 */ 
typedef enum portmod_loopback_mode_e {
    portmodLoopbackMacOuter = 0,
    portmodLoopbackMacCore = 1,
    portmodLoopbackMacPCS = 2,
    portmodLoopbackMacAsyncFifo = 3,
    portmodLoopbackPhyGloopPCS = 4,
    portmodLoopbackPhyGloopPMD = 5,
    portmodLoopbackPhyRloopPCS = 6, /**< remote PHY loopback in the PCS layer */
    portmodLoopbackPhyRloopPMD = 7, /**< remote PHY loopback in the PMD layer */
    portmodLoopbackCount
} portmod_loopback_mode_t;

#ifdef PORTMOD_DIAG
extern enum_mapping_t portmod_loopback_mode_t_mapping[];
#endif /*PORTMOD_DIAG*/

/* portmod_loopback_mode_t validation */
int portmod_loopback_mode_t_validate(int unit, portmod_loopback_mode_t portmod_loopback_mode);

/*!
 * @enum portmod_core_port_mode_e
 * @brief Port Modes for MAC  
 */ 
typedef enum portmod_core_port_mode_e {
    portmodPortModeQuad = 0,
    portmodPortModeTri012 = 1,
    portmodPortModeTri023 = 2,
    portmodPortModeDual = 3,
    portmodPortModeSingle = 4,
    portmodPortModeCount
} portmod_core_port_mode_t;

#ifdef PORTMOD_DIAG
extern enum_mapping_t portmod_core_port_mode_t_mapping[];
#endif /*PORTMOD_DIAG*/

/* portmod_core_port_mode_t validation */
int portmod_core_port_mode_t_validate(int unit, portmod_core_port_mode_t portmod_core_port_mode);

/*!
 * @enum portmod_prbs_mode_e
 * @brief Psuedo Random Bit Stream (PRBS) modes  
 */ 
typedef enum portmod_prbs_mode_e {
    portmodPrbsModePhy = 0,
    portmodPrbsModeMac = 1,
    portmodPrbsModeCount
} portmod_prbs_mode_t;

#ifdef PORTMOD_DIAG
extern enum_mapping_t portmod_prbs_mode_t_mapping[];
#endif /*PORTMOD_DIAG*/

/* portmod_prbs_mode_t validation */
int portmod_prbs_mode_t_validate(int unit, portmod_prbs_mode_t portmod_prbs_mode);

/*!
 * @enum portmod_ext_to_int_phy_ctrlcode_e
 * @brief Control Codes to Call Internal Phy PortMod functions from legacy External Phy  
 */ 
typedef enum portmod_ext_to_int_phy_ctrlcode_e {
    portmodExtToInt_CtrlCode_Init = 0,
    portmodExtToInt_CtrlCode_Reset = 1,
    portmodExtToInt_CtrlCode_Link = 2,
    portmodExtToInt_CtrlCode_Enable = 3,
    portmodExtToInt_CtrlCode_Duplex = 4,
    portmodExtToInt_CtrlCode_Speed = 5,
    portmodExtToInt_CtrlCode_Master = 6,
    portmodExtToInt_CtrlCode_AN = 7,
    portmodExtToInt_CtrlCode_AdvLocal = 8,
    portmodExtToInt_CtrlCode_AdvRemote = 9,
    portmodExtToInt_CtrlCode_LB = 10,
    portmodExtToInt_CtrlCode_Interface = 11,
    portmodExtToInt_CtrlCode_Ability = 12,
    portmodExtToInt_CtrlCode_AbilityAdvert = 13,
    portmodExtToInt_CtrlCode_AbilityRemote = 14,
    portmodExtToInt_CtrlCode_AbilityLocal = 15,
    portmodExtToInt_CtrlCode_LinkupEvt = 16,
    portmodExtToInt_CtrlCode_LinkdnEvt = 17,
    portmodExtToInt_CtrlCode_MDIX = 18,
    portmodExtToInt_CtrlCode_MDIXStatus = 19,
    portmodExtToInt_CtrlCode_MediumConfig = 20,
    portmodExtToInt_CtrlCode_Medium = 21,
    portmodExtToInt_CtrlCode_CableDiag = 22,
    portmodExtToInt_CtrlCode_Control = 23,
    portmodExtToInt_CtrlCode_Firmware = 24,
    portmodExtToInt_CtrlCode_TimesyncConfig = 25,
    portmodExtToInt_CtrlCode_TimesyncControl = 26,
    portmodExtToInt_CtrlCode_TimesyncEnhancedCapture = 27,
    portmodExtToInt_CtrlCode_DiagCtrl = 28,
    portmodExtToInt_CtrlCode_LaneControl = 29,
    portmodExtToInt_CtrlCode_OAMConfig = 30,
    portmodExtToInt_CtrlCode_OAMControl = 31,
    portmodExtToInt_CtrlCode_Multi = 32,
    portmodExtToInt_CtrlCode_Probe = 33,
    portmodExtToInt_CtrlCode_PreconditionBeforeProbe = 34,
    portmodExtToInt_CtrlCode_LinkfaultGet = 35,
    portmodExtToInt_CtrlCode_Count
} portmod_ext_to_int_phy_ctrlcode_t;

#ifdef PORTMOD_DIAG
extern enum_mapping_t portmod_ext_to_int_phy_ctrlcode_t_mapping[];
#endif /*PORTMOD_DIAG*/

/* portmod_ext_to_int_phy_ctrlcode_t validation */
int portmod_ext_to_int_phy_ctrlcode_t_validate(int unit, portmod_ext_to_int_phy_ctrlcode_t portmod_ext_to_int_phy_ctrlcode);

/*!
 * @struct portmod_portphy_ability_s
 * @brief portmod version of port's ability mapping. 
 */ 
typedef struct portmod_portphy_ability_s {
    portmod_port_mode_t cur_mode;
    portmod_port_mode_t speed_half_duplex;
    portmod_port_mode_t speed_full_duplex;
    portmod_port_mode_t pause;
    portmod_port_mode_t interface;
    portmod_port_mode_t medium;
    portmod_port_mode_t loopback;
    portmod_port_mode_t flags;
    portmod_port_mode_t eee;
    portmod_port_mode_t fcmap;
    portmod_pa_encap_t encap;
} portmod_portphy_ability_t;

/* portmod_portphy_ability_t initialization and validation */
int portmod_portphy_ability_t_validate(int unit, const portmod_portphy_ability_t* portmod_portphy_ability);
int portmod_portphy_ability_t_init(int unit, portmod_portphy_ability_t* portmod_portphy_ability);


/*!
 * @struct portmod_pdata_s
 * @brief portmod version of port's pdata to transger data. 
 */ 
typedef struct portmod_pdata_s {
    uint32_t data;
    uint32_t enable;
    portmod_port_if_t pif;
    portmod_port_ability_t* ability;
} portmod_pdata_t;

/* portmod_pdata_t initialization and validation */
int portmod_pdata_t_validate(int unit, const portmod_pdata_t* portmod_pdata);
int portmod_pdata_t_init(int unit, portmod_pdata_t* portmod_pdata);


/*!
 * @struct portmod_port_mode_info_s
 * @brief port mode info. 
 */ 
typedef struct portmod_port_mode_info_s {
    portmod_core_port_mode_t cur_mode;
    int lanes;
    int port_index;
} portmod_port_mode_info_t;

/* portmod_port_mode_info_t initialization and validation */
int portmod_port_mode_info_t_validate(int unit, const portmod_port_mode_info_t* portmod_port_mode_info);
int portmod_port_mode_info_t_init(int unit, portmod_port_mode_info_t* portmod_port_mode_info);


/*!
 * @struct portmod_port_diag_info_s
 * @brief This structure return port diagnostics information from the PMM 
 */ 
typedef struct portmod_port_diag_info_s {
    int original_port; /**< in case of alias this field will be the original port */
    soc_port_if_t interface; /**< interface type */
    int pm_id; /**< pm id which the port belongs */
    portmod_pbmp_t phys; /**< The PHYs that assemble the port */
    int sub_phy; /**< qsgmii only; Sub PHY index */
    int medium; /**< Fiber or Copper; */
    portmod_port_mode_info_t core_mode; /**< core port mode */
    phymod_polarity_t polarity; /**< phy polority */
} portmod_port_diag_info_t;

/* portmod_port_diag_info_t initialization and validation */
int portmod_port_diag_info_t_validate(int unit, const portmod_port_diag_info_t* portmod_port_diag_info);
int portmod_port_diag_info_t_init(int unit, portmod_port_diag_info_t* portmod_port_diag_info);


/*!
 * @struct portmod_pm_core_info_s
 * @brief This structure return port diagnostics information from the PMM 
 */ 
typedef struct portmod_pm_core_info_s {
    phymod_ref_clk_t ref_clk; /**< reference clock */
    phymod_lane_map_t lane_map; /**< lane map */
    int nof_phys; /**< internal + external phys */
} portmod_pm_core_info_t;

/* portmod_pm_core_info_t initialization and validation */
int portmod_pm_core_info_t_validate(int unit, const portmod_pm_core_info_t* portmod_pm_core_info);
int portmod_pm_core_info_t_init(int unit, portmod_pm_core_info_t* portmod_pm_core_info);


/*!
 * @struct portmod_pm_diag_info_s
 * @brief PM diagnostics information 
 */ 
typedef struct portmod_pm_diag_info_s {
    portmod_dispatch_type_t type; /**< PM type */
    portmod_pm_core_info_t core_info; /**< PM core information */
    portmod_pbmp_t phys; /**< Which PHYs are connected to the PM */
    soc_pbmp_t ports; /**< Which ports are connected to the PM */
    uint16 serdes_id0; /**< Serdes ID */
    uint16 phy_id0; /**< Phy ID0 */
    uint16 phy_id1; /**< Phy ID1 */
    char name[PORTMOD_TSCE_LANE_NAME_LEN];
} portmod_pm_diag_info_t;

/* portmod_pm_diag_info_t initialization and validation */
int portmod_pm_diag_info_t_validate(int unit, const portmod_pm_diag_info_t* portmod_pm_diag_info);
int portmod_pm_diag_info_t_init(int unit, portmod_pm_diag_info_t* portmod_pm_diag_info);


/*!
 * @struct portmod_port_init_config_s
 * @brief port config information. 
 */ 
typedef struct portmod_port_init_config_s {
    phymod_phy_reset_t phy_reset_config;
    phymod_pattern_t pattern;
    int cx4_10g;
    int pdetect1000x;
    phymod_an_mode_type_t an_mode; /**< spn_PHY_AN_MODE - Specify the AN mode */
    int an_master_lane; /**< spn_PHY_AUTONEG_MASTER_LANE - Specify the AN master lane */
    int an_cl72; /**< spn_PHY_AN_C72 - Specify if the link training should be enabled */
    int fs_cl72; /**<  spn_FORCED_INIT_CL72 - if trainig should be enabled in Forced speed mode */
    int an_fec; /**<  spn_FORCED_INIT_FEC specify if FEC should be enabled in AN mode  */
    int serdes_fec_enable; /**<  spn_SERDES_FEC_ENABLE, 0 - no FEC(default), 1 - CL74, 2 - CL91 */
    int sgmii_mstr;
    int serdes_driver_current;
    int serdes_1000x_at_6250_vco; /**< run 1G at 6.25 VCO */
    int pll_divider_req; /**< specify the PLL divider value to use for the speed */
    int rxaui_mode;
    int port_fallback_lane;
    int tx_params_user_flag[PHYMOD_MAX_LANES_PER_PORT];
    phymod_tx_t tx_params[PHYMOD_MAX_LANES_PER_PORT]; /**< tx params from config */
    int an_cl37; /**< AN CL37 */
    int cl37_sgmii_war;
    int cl37_sgmii_cnt;
    int cl37_sgmii_RESTART_CNT; /**< threshold for cl37_sgmii_cnt */
    int an_cl73; /**< AN_CL73 */
    int is_hg; /**< is higig port */
    int ext_phy_tx_params_user_flag[PHYMOD_MAX_LANES_PER_PORT];
    phymod_tx_t ext_phy_tx_params[PHYMOD_MAX_LANES_PER_PORT]; /**< external phy tx params from config */
    phymod_polarity_t polarity[PORTMOD_MAX_CORES_PER_PORT];
    uint8 polarity_overwrite; /**<  Get polarity form config to overwrite PM's polarity when port probe  */
    phymod_lane_map_t lane_map[PORTMOD_MAX_CORES_PER_PORT];
    uint8 lane_map_overwrite; /**<  Get lane map form config to overwrite PM's lane map when port probe  */
    phymod_firmware_load_method_t fw_load_method[PORTMOD_MAX_CORES_PER_PORT];
    uint8 fw_load_method_overwrite; /**<  Get fw load method form config to overwrite PM's fw load method when port probe  */
    phymod_ref_clk_t ref_clk;
    uint8 ref_clk_overwrite; /**<  Get ref clk form config to overwrite PM's ref clk when port probe  */
} portmod_port_init_config_t;

/* portmod_port_init_config_t initialization and validation */
int portmod_port_init_config_t_validate(int unit, const portmod_port_init_config_t* portmod_port_init_config);
int portmod_port_init_config_t_init(int unit, portmod_port_init_config_t* portmod_port_init_config);

typedef _shr_port_encap_t portmod_encap_t;


/*!
 * @struct portmod_port_interface_config_s
 * @brief  This structure contains the rate, settings as medium, scrambler en, etc. and flags which allow/forbid the change of PLL/TX parameters/FW configuration/etc. 
 */ 
typedef struct portmod_port_interface_config_s {
    soc_port_if_t interface;
    soc_port_if_t line_interface;
    soc_port_if_t serdes_interface;
    uint32 interface_modes; /**< see PHYMOD_INTF_MODES_ */
    uint32 flags; /**< see PHYMOD_INTF_F_ */
    uint32 port_refclk_int;
    int port_num_lanes;
    int speed; /**< speed at which the port should be initialized */
    int max_speed; /**< Max Port Speed Supported */
    portmod_encap_t encap_mode; /**< Encap Mode */
    int pll_divider_req;
    int port_op_mode; /**< mainly used by ext phy for repeater/retimer */
} portmod_port_interface_config_t;

/* portmod_port_interface_config_t initialization and validation */
int portmod_port_interface_config_t_validate(int unit, const portmod_port_interface_config_t* portmod_port_interface_config);
int portmod_port_interface_config_t_init(int unit, portmod_port_interface_config_t* portmod_port_interface_config);

/*! 
 * @brief Port Add Flags 
 */ 
#define PORTMOD_PORT_ADD_F_INIT_PASS1 0x1 /**< phymod init PASS1:do some initializations before FW load.If broadcast is not supported, download FW unicast */
#define PORTMOD_PORT_ADD_F_INIT_PASS2 0x2 /**< phymod init PASS2:do some initializations after FW load */
#define PORTMOD_PORT_ADD_F_FIRMWARE_LOAD_VERIFY 0x4 /**< Verify FW loaded correctly */
#define PORTMOD_PORT_ADD_F_RX_SRIP_CRC 0x8 /**< Set port RX to strip CRC mode */
#define PORTMOD_PORT_ADD_F_TX_APPEND_CRC 0x10 /**< Set port TX to append CRC before sending the packet */
#define PORTMOD_PORT_ADD_F_TX_REPLACE_CRC 0x20 /**< Set port TX to replace CRC before sending the packet */
#define PORTMOD_PORT_ADD_F_TX_PASS_THROUGH_CRC 0x40 /**< Set port TX to pass through CRC */
#define PORTMOD_PORT_ADD_F_EGR_1588_TIMESTAMP_MODE_48BIT 0x80 /**< Enable 48-bit time stamping */
#define PORTMOD_PORT_ADD_F_INIT_CORE_PROBE 0x100 /**< Do Core Probe. This is stage 1 of 3 stage init. INIT_UNTIL, RESUME AFTER are other 2 stages. If no flag is set - all 3 will be performed. */
#define PORTMOD_PORT_ADD_F_PORT_ATTACH_EXT_PHY_SKIP 0x200 /**< Skip external phy port attach */
#define PORTMOD_PORT_ADD_F_ELK 0x400 /**< flag for ELK */
#define PORTMOD_PORT_ADD_F_AUTONEG_CONFIG_SKIP 0x800 /**< Skip autoneg configuration in port attach */

#define PORTMOD_PORT_ADD_F_INIT_PASS1_SET(info) ((info)->flags |= PORTMOD_PORT_ADD_F_INIT_PASS1)
#define PORTMOD_PORT_ADD_F_INIT_PASS2_SET(info) ((info)->flags |= PORTMOD_PORT_ADD_F_INIT_PASS2)
#define PORTMOD_PORT_ADD_F_FIRMWARE_LOAD_VERIFY_SET(info) ((info)->flags |= PORTMOD_PORT_ADD_F_FIRMWARE_LOAD_VERIFY)
#define PORTMOD_PORT_ADD_F_RX_SRIP_CRC_SET(info) ((info)->flags |= PORTMOD_PORT_ADD_F_RX_SRIP_CRC)
#define PORTMOD_PORT_ADD_F_TX_APPEND_CRC_SET(info) ((info)->flags |= PORTMOD_PORT_ADD_F_TX_APPEND_CRC)
#define PORTMOD_PORT_ADD_F_TX_REPLACE_CRC_SET(info) ((info)->flags |= PORTMOD_PORT_ADD_F_TX_REPLACE_CRC)
#define PORTMOD_PORT_ADD_F_TX_PASS_THROUGH_CRC_SET(info) ((info)->flags |= PORTMOD_PORT_ADD_F_TX_PASS_THROUGH_CRC)
#define PORTMOD_PORT_ADD_F_EGR_1588_TIMESTAMP_MODE_48BIT_SET(info) ((info)->flags |= PORTMOD_PORT_ADD_F_EGR_1588_TIMESTAMP_MODE_48BIT)
#define PORTMOD_PORT_ADD_F_INIT_CORE_PROBE_SET(info) ((info)->flags |= PORTMOD_PORT_ADD_F_INIT_CORE_PROBE)
#define PORTMOD_PORT_ADD_F_PORT_ATTACH_EXT_PHY_SKIP_SET(info) ((info)->flags |= PORTMOD_PORT_ADD_F_PORT_ATTACH_EXT_PHY_SKIP)
#define PORTMOD_PORT_ADD_F_ELK_SET(info) ((info)->flags |= PORTMOD_PORT_ADD_F_ELK)
#define PORTMOD_PORT_ADD_F_AUTONEG_CONFIG_SKIP_SET(info) ((info)->flags |= PORTMOD_PORT_ADD_F_AUTONEG_CONFIG_SKIP)

#define PORTMOD_PORT_ADD_F_INIT_PASS1_CLR(info) ((info)->flags &= ~PORTMOD_PORT_ADD_F_INIT_PASS1)
#define PORTMOD_PORT_ADD_F_INIT_PASS2_CLR(info) ((info)->flags &= ~PORTMOD_PORT_ADD_F_INIT_PASS2)
#define PORTMOD_PORT_ADD_F_FIRMWARE_LOAD_VERIFY_CLR(info) ((info)->flags &= ~PORTMOD_PORT_ADD_F_FIRMWARE_LOAD_VERIFY)
#define PORTMOD_PORT_ADD_F_RX_SRIP_CRC_CLR(info) ((info)->flags &= ~PORTMOD_PORT_ADD_F_RX_SRIP_CRC)
#define PORTMOD_PORT_ADD_F_TX_APPEND_CRC_CLR(info) ((info)->flags &= ~PORTMOD_PORT_ADD_F_TX_APPEND_CRC)
#define PORTMOD_PORT_ADD_F_TX_REPLACE_CRC_CLR(info) ((info)->flags &= ~PORTMOD_PORT_ADD_F_TX_REPLACE_CRC)
#define PORTMOD_PORT_ADD_F_TX_PASS_THROUGH_CRC_CLR(info) ((info)->flags &= ~PORTMOD_PORT_ADD_F_TX_PASS_THROUGH_CRC)
#define PORTMOD_PORT_ADD_F_EGR_1588_TIMESTAMP_MODE_48BIT_CLR(info) ((info)->flags &= ~PORTMOD_PORT_ADD_F_EGR_1588_TIMESTAMP_MODE_48BIT)
#define PORTMOD_PORT_ADD_F_INIT_CORE_PROBE_CLR(info) ((info)->flags &= ~PORTMOD_PORT_ADD_F_INIT_CORE_PROBE)
#define PORTMOD_PORT_ADD_F_PORT_ATTACH_EXT_PHY_SKIP_CLR(info) ((info)->flags &= ~PORTMOD_PORT_ADD_F_PORT_ATTACH_EXT_PHY_SKIP)
#define PORTMOD_PORT_ADD_F_ELK_CLR(info) ((info)->flags &= ~PORTMOD_PORT_ADD_F_ELK)
#define PORTMOD_PORT_ADD_F_AUTONEG_CONFIG_SKIP_CLR(info) ((info)->flags &= ~PORTMOD_PORT_ADD_F_AUTONEG_CONFIG_SKIP)

#define PORTMOD_PORT_ADD_F_INIT_PASS1_GET(info) ((info)->flags & PORTMOD_PORT_ADD_F_INIT_PASS1 ? 1 : 0)
#define PORTMOD_PORT_ADD_F_INIT_PASS2_GET(info) ((info)->flags & PORTMOD_PORT_ADD_F_INIT_PASS2 ? 1 : 0)
#define PORTMOD_PORT_ADD_F_FIRMWARE_LOAD_VERIFY_GET(info) ((info)->flags & PORTMOD_PORT_ADD_F_FIRMWARE_LOAD_VERIFY ? 1 : 0)
#define PORTMOD_PORT_ADD_F_RX_SRIP_CRC_GET(info) ((info)->flags & PORTMOD_PORT_ADD_F_RX_SRIP_CRC ? 1 : 0)
#define PORTMOD_PORT_ADD_F_TX_APPEND_CRC_GET(info) ((info)->flags & PORTMOD_PORT_ADD_F_TX_APPEND_CRC ? 1 : 0)
#define PORTMOD_PORT_ADD_F_TX_REPLACE_CRC_GET(info) ((info)->flags & PORTMOD_PORT_ADD_F_TX_REPLACE_CRC ? 1 : 0)
#define PORTMOD_PORT_ADD_F_TX_PASS_THROUGH_CRC_GET(info) ((info)->flags & PORTMOD_PORT_ADD_F_TX_PASS_THROUGH_CRC ? 1 : 0)
#define PORTMOD_PORT_ADD_F_EGR_1588_TIMESTAMP_MODE_48BIT_GET(info) ((info)->flags & PORTMOD_PORT_ADD_F_EGR_1588_TIMESTAMP_MODE_48BIT ? 1 : 0)
#define PORTMOD_PORT_ADD_F_INIT_CORE_PROBE_GET(info) ((info)->flags & PORTMOD_PORT_ADD_F_INIT_CORE_PROBE ? 1 : 0)
#define PORTMOD_PORT_ADD_F_PORT_ATTACH_EXT_PHY_SKIP_GET(info) ((info)->flags & PORTMOD_PORT_ADD_F_PORT_ATTACH_EXT_PHY_SKIP ? 1 : 0)
#define PORTMOD_PORT_ADD_F_ELK_GET(info) ((info)->flags & PORTMOD_PORT_ADD_F_ELK ? 1 : 0)
#define PORTMOD_PORT_ADD_F_AUTONEG_CONFIG_SKIP_GET(info) ((info)->flags & PORTMOD_PORT_ADD_F_AUTONEG_CONFIG_SKIP ? 1 : 0)

/*! 
 * @brief flags defines for the core initt 
 */ 
#define PORTMOD_CORE_INIT_FLAG_INITIALZIED 0x1
#define PORTMOD_CORE_INIT_FLAG_FIRMWARE_LOADED 0x2 /**< enable/disable the MAC(RX/TX according to the flags) */

#define PORTMOD_CORE_INIT_FLAG_INITIALZIED_SET(flag) ((flag) |= PORTMOD_CORE_INIT_FLAG_INITIALZIED)
#define PORTMOD_CORE_INIT_FLAG_FIRMWARE_LOADED_SET(flag) ((flag) |= PORTMOD_CORE_INIT_FLAG_FIRMWARE_LOADED)

#define PORTMOD_CORE_INIT_FLAG_INITIALZIED_CLR(flag) ((flag) &= ~PORTMOD_CORE_INIT_FLAG_INITIALZIED)
#define PORTMOD_CORE_INIT_FLAG_FIRMWARE_LOADED_CLR(flag) ((flag) &= ~PORTMOD_CORE_INIT_FLAG_FIRMWARE_LOADED)

#define PORTMOD_CORE_INIT_FLAG_INITIALZIED_GET(flag) ((flag) & PORTMOD_CORE_INIT_FLAG_INITIALZIED ? 1 : 0)
#define PORTMOD_CORE_INIT_FLAG_FIRMWARE_LOADED_GET(flag) ((flag) & PORTMOD_CORE_INIT_FLAG_FIRMWARE_LOADED ? 1 : 0)

typedef struct portmod_port_add_info_s {
    portmod_port_interface_config_t interface_config;
    portmod_port_init_config_t init_config;
    portmod_pbmp_t phys;
    portmod_pbmp_t phy_ports; /**< phys with qsgmii offsets. to be removed */
    int sub_phy; /**< qsgmii only; Sub PHY index */
    uint8 autoneg_en;
    uint8 link_training_en;
    uint32 flags; /**< port add flags */
    uint32 is_fabric_o_nif; /**< dnx fabric over nif. fabric port is over nif serdes */
    uint32 ilkn_core_id; /**< ilkn only. core id (0-1) */
    uint32 ilkn_port_is_over_fabric; /**< ilkn only. port is over fabric serdes or nif */
    int ilkn_burst_max; /**< ilkn only. burst_max value. */
    int ilkn_burst_min; /**< ilkn only. burst_min value. */
    int ilkn_burst_short; /**< ilkn only. burst_short value. */
    int ilkn_nof_segments; /**< ilkn only. nof_segmnets value. */
    int ilkn_metaframe_period; /**< ilkn only. metaframe sync period value. */
    uint32 rx_retransmit; /**< rx retransmit enable */
    uint32 tx_retransmit; /**< tx retransmit enable */
    phymod_operation_mode_t phy_op_mode; /**< ext phy operation mode. */
    phymod_datapath_t phy_op_datapath; /**< ext phy data path mode (e.g. ULL ultra low latency. */
    int ilkn_inb_cal_len_rx; /**< calendar length for ILKN INB */
    int ilkn_inb_cal_len_tx; /**< calendar length for ILKN INB */
    int ilkn_oob_cal_len_rx; /**< calendar length for ILKN OOB */
    int ilkn_oob_cal_len_tx; /**< calendar length for ILKN OOB */
    uint32 reserved_channel_rx; /**< reserved channel id for rx retransmit */
    uint32 reserved_channel_tx; /**< reserved channel id for tx retransmit */
} portmod_port_add_info_t;

/* portmod_port_add_info_t initialization and validation */
int portmod_port_add_info_t_validate(int unit, const portmod_port_add_info_t* portmod_port_add_info);
int portmod_port_add_info_t_init(int unit, portmod_port_add_info_t* portmod_port_add_info);


/*!
 * @struct portmod_pm_identifier_s
 * @brief This struct defines specific PM 
 */ 
typedef struct portmod_pm_identifier_s {
    portmod_dispatch_type_t type; /**< PM type */
    int phy; /**< First PHY of the PM */
} portmod_pm_identifier_t;

/* portmod_pm_identifier_t initialization and validation */
int portmod_pm_identifier_t_validate(int unit, const portmod_pm_identifier_t* portmod_pm_identifier);
int portmod_pm_identifier_t_init(int unit, portmod_pm_identifier_t* portmod_pm_identifier);


/*!
 * @struct portmod_dnx_fabric_create_info_s
 * @brief Dune Fabric PM specific information required for PM add API. 
 */ 
typedef struct portmod_dnx_fabric_create_info_s {
    phymod_ref_clk_t ref_clk; /**< SerDes quad ref clock */
    phymod_access_t access; /**< phymod access structure; defines the register access for the SerDes Core */
    phymod_lane_map_t lane_map;
    phymod_firmware_load_method_t fw_load_method;
    phymod_firmware_loader_f external_fw_loader; /**< firmware loader that will be used in case that fw_load_method=phymodFirmwareLoadMethodExternal */
    phymod_polarity_t polarity; /**< Lanes Polarity */
    int fmac_schan_id; /**< FMAC schan id */
    int fsrd_schan_id; /**< FSRD schan id */
    int fsrd_internal_quad; /**< Core instance in FSRD */
    int first_phy_offset; /**< offset for phy index get */
    int core_index; /**< core index */
    int is_over_nif; /**< is fabric pm over nif */
    portmod_pm_identifier_t fabric_o_nif_pm; /**< PM used for fabric over nif */
} portmod_dnx_fabric_create_info_t;

/* portmod_dnx_fabric_create_info_t initialization and validation */
int portmod_dnx_fabric_create_info_t_validate(int unit, const portmod_dnx_fabric_create_info_t* portmod_dnx_fabric_create_info);
int portmod_dnx_fabric_create_info_t_init(int unit, portmod_dnx_fabric_create_info_t* portmod_dnx_fabric_create_info);


/*!
 * @struct portmod_pm8x50_fabric_create_info_s
 * @brief Dune Fabric PM specific information required for PM add API. 
 */ 
typedef struct portmod_pm8x50_fabric_create_info_s {
    phymod_ref_clk_t ref_clk; /**< SerDes quad ref clock */
    phymod_access_t access; /**< phymod access structure; defines the register access for the SerDes Core */
    phymod_lane_map_t lane_map;
    phymod_firmware_load_method_t fw_load_method;
    phymod_firmware_loader_f external_fw_loader; /**< firmware loader that will be used in case that fw_load_method=phymodFirmwareLoadMethodExternal */
    phymod_polarity_t polarity; /**< Lanes Polarity */
    int fmac_schan_id; /**< FMAC schan id */
    int fsrd_schan_id; /**< FSRD schan id */
    int fsrd_internal_quad; /**< Core instance in FSRD */
    int first_phy_offset; /**< offset for phy index get */
    int core_index; /**< core index */
    int is_over_nif; /**< is fabric pm over nif */
    portmod_pm_identifier_t fabric_o_nif_pm; /**< PM used for fabric over nif */
} portmod_pm8x50_fabric_create_info_t;

/* portmod_pm8x50_fabric_create_info_t initialization and validation */
int portmod_pm8x50_fabric_create_info_t_validate(int unit, const portmod_pm8x50_fabric_create_info_t* portmod_pm8x50_fabric_create_info);
int portmod_pm8x50_fabric_create_info_t_init(int unit, portmod_pm8x50_fabric_create_info_t* portmod_pm8x50_fabric_create_info);


/*!
 * @enum portmod_call_back_action_type_e
 * @brief Psuedo Random Bit Stream (PRBS) modes  
 */ 
typedef enum portmod_call_back_action_type_e {
    portmodCallBackActionTypePre = 0,
    portmodCallBackActionTypeDuring = 1,
    portmodCallBackActionTypePost = 2,
    portmodCallBackActionTypeCount
} portmod_call_back_action_type_t;

#ifdef PORTMOD_DIAG
extern enum_mapping_t portmod_call_back_action_type_t_mapping[];
#endif /*PORTMOD_DIAG*/

/* portmod_call_back_action_type_t validation */
int portmod_call_back_action_type_t_validate(int unit, portmod_call_back_action_type_t portmod_call_back_action_type);

/*!
 * @enum portmod_intr_type_e
 * @brief Interrupt types 
 */ 
typedef enum portmod_intr_type_e {
    portmodIntrTypeMibTxMemErr = 0, /**< clmac/xlmac mib Tx err */
    portmodIntrTypeMibRxMemErr = 1, /**< clmac/xlmac mib Rx err */
    portmodIntrTypeMacTxCdcMemErr = 2, /**< clmac/xlmac tx CDC */
    portmodIntrTypeMacRxCdcMemErr = 3, /**< clmac/xlmac Rx CDC */
    portmodIntrTypeMacRxTsCdcMemErr = 4, /**< clmac/xlmac Rx TS CDC err */
    portmodIntrTypeTscErr = 5, /**< clmac TSC err */
    portmodIntrTypePmdErr = 6, /**< clmac PMD err */
    portmodIntrTypeRxFcReqFull = 7, /**< 100G CXX Flow Control Req */
    portmodIntrTypeCore0Intr = 8, /**< 100G core-0 irq */
    portmodIntrTypeCore1Intr = 9, /**< 100G core-1 irq */
    portmodIntrTypeCore2Intr = 10, /**< 100G core-2 irq */
    portmodIntrTypeCore3Intr = 11, /**< 100G core-3 irq */
    portmodIntrTypeTsc0Intr = 12, /**< 100G Tsc-0 irq */
    portmodIntrTypeTsc1Intr = 13, /**< 100G Tsc-1 irq */
    portmodIntrTypeTsc2Intr = 14, /**< 100G Tsc-2 irq */
    portmodIntrTypeLinkdown = 15, /**< Link down */
    portmodIntrTypeMacErr = 16, /**< MAC error */
    portmodIntrTypeTxPktUnderflow = 17, /**< MAC tx packet fifo underflow */
    portmodIntrTypeTxPktOverflow = 18, /**< MAC tx packet fifo overflow */
    portmodIntrTypeTxLlfcMsgOverflow = 19, /**< MAC TX LLFC message fifo overflow */
    portmodIntrTypeTxTSFifoOverflow = 20, /**< Overflow in TX two-step Time Stamp FIFO */
    portmodIntrTypeRxPktOverflow = 21, /**< MAC RX packet fifo overflow */
    portmodIntrTypeRxMsgOverflow = 22, /**< MAC RX message fifo overflow */
    portmodIntrTypeTxCdcSingleBitErr = 23, /**< Single bit error in the MAC Tx CDC memory */
    portmodIntrTypeTxCdcDoubleBitErr = 24, /**< Double bit error in the MAC Tx CDC memory */
    portmodIntrTypeRxCdcSingleBitErr = 25, /**< Single bit error in the MAC Rx CDC memory */
    portmodIntrTypeRxCdcDoubleBitErr = 26, /**< Double bit error in the MAC Rx CDC memory */
    portmodIntrTypeRxTsMemSingleBitErr = 27, /**< Single bit error in the MAC Rx Timestamp memory */
    portmodIntrTypeRxTsMemDoubleBitErr = 28, /**< Double bit error in the MAC Rx Timestamp memory */
    portmodIntrTypeLocalFaultStatus = 29, /**< Local fault by RS layer */
    portmodIntrTypeRemoteFaultStatus = 30, /**< Remote fault by RS layer */
    portmodIntrTypeLinkInterruptionStatus = 31, /**< Link interruption by RS layer */
    portmodIntrTypeTsEntryValid = 32, /**< TimeStamp */
    portmodIntrTypeCount
} portmod_intr_type_t;

#ifdef PORTMOD_DIAG
extern enum_mapping_t portmod_intr_type_t_mapping[];
#endif /*PORTMOD_DIAG*/

/* portmod_intr_type_t validation */
int portmod_intr_type_t_validate(int unit, portmod_intr_type_t portmod_intr_type);
/*! 
 * portmod_mac_soft_reset_f
 *
 * @brief external reset function 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  action          - when is this callback called
 */
typedef int (*portmod_mac_soft_reset_f)(int unit, int port, portmod_call_back_action_type_t action);


/*!
 * @struct portmod_pm4x25_create_info_s
 * @brief PM4X25 specific information required for PM add API. 
 */ 
typedef struct portmod_pm4x25_create_info_s {
    phymod_ref_clk_t ref_clk; /**< SerDes quad ref clock */
    phymod_access_t access; /**< phymod access structure; defines the register access for the SerDes Core */
    phymod_lane_map_t lane_map;
    phymod_firmware_load_method_t fw_load_method;
    phymod_firmware_loader_f external_fw_loader; /**< firmware loader that will be used in case that fw_load_method=phymodFirmwareLoadMethodExternal */
    phymod_polarity_t polarity; /**< Lanes Polarity */
    uint8 in_pm_12x10; /**< is the PM part of a PM12x10 block */
    int core_num;
    int core_num_int;
    portmod_mac_soft_reset_f portmod_mac_soft_reset; /**< used when soft reset require external method. */
    phymod_afe_pll_t afe_pll; /**< override default value of AFE/PLL reg. */
    int rescal;
} portmod_pm4x25_create_info_t;

/* portmod_pm4x25_create_info_t initialization and validation */
int portmod_pm4x25_create_info_t_validate(int unit, const portmod_pm4x25_create_info_t* portmod_pm4x25_create_info);
int portmod_pm4x25_create_info_t_init(int unit, portmod_pm4x25_create_info_t* portmod_pm4x25_create_info);

/*! 
 * portmod_phy_external_reset_f
 *
 * @brief external reset function 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  in_reset        - whether to put phy in\out reset
 */
typedef int (*portmod_phy_external_reset_f)(int unit, int port, uint32 in_reset);


/*!
 * @struct portmod_pm4x10_create_info_s
 * @brief PM4X10 specific information required for PM add API. 
 */ 
typedef struct portmod_pm4x10_create_info_s {
    portmod_pbmp_t phy_ports; /**< phys with qsgmii offsets. to be removed */
    phymod_ref_clk_t ref_clk; /**< SerDes quad ref clock */
    phymod_access_t access; /**< phymod access structure; defines the register access for the SerDes Core */
    phymod_lane_map_t lane_map;
    phymod_firmware_load_method_t fw_load_method;
    phymod_firmware_loader_f external_fw_loader; /**< firmware loader that will be used in case that fw_load_method=phymodFirmwareLoadMethodExternal */
    phymod_polarity_t polarity; /**< Lanes Polarity */
    uint8 in_pm_12x10; /**< is the PM part of a PM12x10 block */
    portmod_phy_external_reset_f portmod_phy_external_reset; /**< used when phy required external method to be taken oor */
    portmod_mac_soft_reset_f portmod_mac_soft_reset; /**< used when soft reset require external method. */
    int core_num;
    int core_num_int;
    int three_ports_mode;
    int rescal;
    int is_pm4x10q;
} portmod_pm4x10_create_info_t;

/* portmod_pm4x10_create_info_t initialization and validation */
int portmod_pm4x10_create_info_t_validate(int unit, const portmod_pm4x10_create_info_t* portmod_pm4x10_create_info);
int portmod_pm4x10_create_info_t_init(int unit, portmod_pm4x10_create_info_t* portmod_pm4x10_create_info);


/*!
 * @struct portmod_pm_qtc_create_info_s
 * @brief PM4X10 specific information required for PM add API. 
 */ 
typedef struct portmod_pm_qtc_create_info_s {
    phymod_ref_clk_t ref_clk; /**< SerDes quad ref clock */
    phymod_access_t access; /**< phymod access structure; defines the register access for the SerDes Core */
    phymod_lane_map_t lane_map;
    phymod_firmware_load_method_t fw_load_method;
    phymod_firmware_loader_f external_fw_loader; /**< firmware loader that will be used in case that fw_load_method=phymodFirmwareLoadMethodExternal */
    phymod_polarity_t polarity; /**< Lanes Polarity */
    portmod_phy_external_reset_f portmod_phy_external_reset; /**< used when phy required external method to be taken oor */
    portmod_mac_soft_reset_f portmod_mac_soft_reset; /**< used when soft reset require external method. */
    int core_num;
} portmod_pm_qtc_create_info_t;

/* portmod_pm_qtc_create_info_t initialization and validation */
int portmod_pm_qtc_create_info_t_validate(int unit, const portmod_pm_qtc_create_info_t* portmod_pm_qtc_create_info);
int portmod_pm_qtc_create_info_t_init(int unit, portmod_pm_qtc_create_info_t* portmod_pm_qtc_create_info);


/*!
 * @struct portmod_pm_gphy_create_info_s
 * @brief PM4X10 specific information required for PM add API. 
 */ 
typedef struct portmod_pm_gphy_create_info_s {
    phymod_ref_clk_t ref_clk; /**< SerDes quad ref clock */
    phymod_access_t access; /**< phymod access structure; defines the register access for the SerDes Core */
    phymod_lane_map_t lane_map;
    phymod_firmware_load_method_t fw_load_method;
    phymod_firmware_loader_f external_fw_loader; /**< firmware loader that will be used in case that fw_load_method=phymodFirmwareLoadMethodExternal */
    phymod_polarity_t polarity; /**< Lanes Polarity */
    portmod_phy_external_reset_f portmod_phy_external_reset; /**< used when phy required external method to be taken oor */
    portmod_mac_soft_reset_f portmod_mac_soft_reset; /**< used when soft reset require external method. */
    int core_num;
} portmod_pm_gphy_create_info_t;

/* portmod_pm_gphy_create_info_t initialization and validation */
int portmod_pm_gphy_create_info_t_validate(int unit, const portmod_pm_gphy_create_info_t* portmod_pm_gphy_create_info);
int portmod_pm_gphy_create_info_t_init(int unit, portmod_pm_gphy_create_info_t* portmod_pm_gphy_create_info);

/*! 
 * @brief Flags for adding PM12x10 
 */ 
#define PORTMOD_PM12x10_F_EXTERNAL_TOP_MODE 0x1 /**< Each PM4x10 handles its own access (use for default access/fw load functions) */
#define PORTMOD_PM12x10_F_USE_PM_TD 0x2 /**< Use TD version of PM4x25, PM4x10 */
#define PORTMOD_PM12x10_F_USE_PM_XGS 0x4 /**< Use XGS version PM12x10 */

#define PORTMOD_PM12x10_F_EXTERNAL_TOP_MODE_SET(flags) ((flags) |= PORTMOD_PM12x10_F_EXTERNAL_TOP_MODE)
#define PORTMOD_PM12x10_F_USE_PM_TD_SET(flags) ((flags) |= PORTMOD_PM12x10_F_USE_PM_TD)
#define PORTMOD_PM12x10_F_USE_PM_XGS_SET(flags) ((flags) |= PORTMOD_PM12x10_F_USE_PM_XGS)

#define PORTMOD_PM12x10_F_EXTERNAL_TOP_MODE_CLR(flags) ((flags) &= ~PORTMOD_PM12x10_F_EXTERNAL_TOP_MODE)
#define PORTMOD_PM12x10_F_USE_PM_TD_CLR(flags) ((flags) &= ~PORTMOD_PM12x10_F_USE_PM_TD)
#define PORTMOD_PM12x10_F_USE_PM_XGS_CLR(flags) ((flags) &= ~PORTMOD_PM12x10_F_USE_PM_XGS)

#define PORTMOD_PM12x10_F_EXTERNAL_TOP_MODE_GET(flags) ((flags) & PORTMOD_PM12x10_F_EXTERNAL_TOP_MODE ? 1 : 0)
#define PORTMOD_PM12x10_F_USE_PM_TD_GET(flags) ((flags) & PORTMOD_PM12x10_F_USE_PM_TD ? 1 : 0)
#define PORTMOD_PM12x10_F_USE_PM_XGS_GET(flags) ((flags) & PORTMOD_PM12x10_F_USE_PM_XGS ? 1 : 0)


/*!
 * @struct portmod_pm12x10_create_info_s
 * @brief PM12X10 specific information required for PM add API. 
 */ 
typedef struct portmod_pm12x10_create_info_s {
    portmod_pm4x10_create_info_t pm4x10_infos[3]; /**< initialization information for the three pm4x10 in the pm12x10 */
    portmod_pm4x25_create_info_t pm4x25_info;
    uint32 flags; /**< see PORTMOD_PM12x10_F_ */
    int blk_id; /**< block id of PM12x10 */
    int refclk_source; /**< select which quad in pm12x10 is refclk source for other 2 quads */
} portmod_pm12x10_create_info_t;

/* portmod_pm12x10_create_info_t initialization and validation */
int portmod_pm12x10_create_info_t_validate(int unit, const portmod_pm12x10_create_info_t* portmod_pm12x10_create_info);
int portmod_pm12x10_create_info_t_init(int unit, portmod_pm12x10_create_info_t* portmod_pm12x10_create_info);


/*!
 * @struct portmod_pm4x10q_create_info_s
 * @brief PM4X10Q specific information required for PM add API. 
 */ 
typedef struct portmod_pm4x10q_create_info_s {
    portmod_pm4x10_create_info_t pm4x10_info; /**< initialization information for the pm4x10 in the pm4x10Q */
    uint32 blk_id; /**< PMQ block id */
    void* qsgmii_user_acc; /**< qsgmii_access */
} portmod_pm4x10q_create_info_t;

/* portmod_pm4x10q_create_info_t initialization and validation */
int portmod_pm4x10q_create_info_t_validate(int unit, const portmod_pm4x10q_create_info_t* portmod_pm4x10q_create_info);
int portmod_pm4x10q_create_info_t_init(int unit, portmod_pm4x10q_create_info_t* portmod_pm4x10q_create_info);

#define PORTMOD_MAX_ILKN_PORTS_PER_ILKN_PM (2)


/*!
 * @struct portmod_ilkn_os_create_info_s
 * @brief Open Silicon ILKN information required for PM add API. 
 */ 
typedef struct portmod_ilkn_os_create_info_s {
    int nof_aggregated_pms; /**< Number of PMs controlled by this ILKN PM */
    portmod_pm_identifier_t* controlled_pms; /**< Array of PMs controlled by this ILKN PM */
    int wm_high[PORTMOD_MAX_ILKN_PORTS_PER_ILKN_PM]; /**< Tx fifo watermark high value for each port in the ILKN core */
    int wm_low[PORTMOD_MAX_ILKN_PORTS_PER_ILKN_PM]; /**< Tx fifo watermark low value for each port in the ILKN core */
    uint32 is_over_fabric; /**< dnx specific feature */
    uint32 core_clock_khz; /**< core clock Khz */
} portmod_ilkn_os_create_info_t;

/* portmod_ilkn_os_create_info_t initialization and validation */
int portmod_ilkn_os_create_info_t_validate(int unit, const portmod_ilkn_os_create_info_t* portmod_ilkn_os_create_info);
int portmod_ilkn_os_create_info_t_init(int unit, portmod_ilkn_os_create_info_t* portmod_ilkn_os_create_info);


/*!
 * @struct portmod_pm4x2p5_create_info_s
 * @brief PM4X2P5 specific information required for PM add API. 
 */ 
typedef struct portmod_pm4x2p5_create_info_s {
    soc_pbmp_t phy_ports; /**< phys with qsgmii offsets. to be removed */
    phymod_ref_clk_t ref_clk; /**< SerDes quad ref clock */
    phymod_access_t access; /**< phymod access structure; defines the register access for the SerDes Core */
    phymod_lane_map_t lane_map;
    phymod_firmware_load_method_t fw_load_method;
    phymod_firmware_loader_f external_fw_loader; /**< firmware loader that will be used in case that fw_load_method=phymodFirmwareLoadMethodExternal */
    phymod_polarity_t polarity; /**< Lanes Polarity */
    portmod_phy_external_reset_f portmod_phy_external_reset; /**< used when phy required external method to be taken oor */
    portmod_mac_soft_reset_f portmod_mac_soft_reset; /**< used when soft reset require external method. */
} portmod_pm4x2p5_create_info_t;

/* portmod_pm4x2p5_create_info_t initialization and validation */
int portmod_pm4x2p5_create_info_t_validate(int unit, const portmod_pm4x2p5_create_info_t* portmod_pm4x2p5_create_info);
int portmod_pm4x2p5_create_info_t_init(int unit, portmod_pm4x2p5_create_info_t* portmod_pm4x2p5_create_info);

typedef union portmod_pm_specific_create_info_u {
    portmod_pm4x10_create_info_t pm4x10;
    portmod_pm4x10q_create_info_t pm4x10q;
    portmod_pm_qtc_create_info_t pm_qtc;
    portmod_pm_gphy_create_info_t pm_gphy;
    portmod_pm4x25_create_info_t pm4x25;
    portmod_pm12x10_create_info_t pm12x10;
    portmod_ilkn_os_create_info_t os_ilkn;
    portmod_dnx_fabric_create_info_t dnx_fabric;
    portmod_pm8x50_fabric_create_info_t pm8x50_fabric;
    portmod_pm4x2p5_create_info_t pm4x2p5;
} portmod_pm_specific_create_info_t;


/*!
 * @struct portmod_remote_fault_control_s
 * @brief  This struct contains the parameters that  
 */ 
typedef struct portmod_remote_fault_control_s {
    uint8 enable; /**< enable/disable processing of local fault messages */
    uint8 drop_tx_on_fault; /**< drop tx data in case of fault */
} portmod_remote_fault_control_t;

/* portmod_remote_fault_control_t initialization and validation */
int portmod_remote_fault_control_t_validate(int unit, const portmod_remote_fault_control_t* portmod_remote_fault_control);
int portmod_remote_fault_control_t_init(int unit, portmod_remote_fault_control_t* portmod_remote_fault_control);

typedef struct portmod_local_fault_control_s {
    uint8 enable; /**< enable/disable processing of remote fault messages */
    uint8 drop_tx_on_fault; /**< drop tx data in case of fault */
} portmod_local_fault_control_t;

/* portmod_local_fault_control_t initialization and validation */
int portmod_local_fault_control_t_validate(int unit, const portmod_local_fault_control_t* portmod_local_fault_control);
int portmod_local_fault_control_t_init(int unit, portmod_local_fault_control_t* portmod_local_fault_control);


/*!
 * @struct portmod_llfc_control_s
 * @brief  link level flow control configuration 
 */ 
typedef struct portmod_llfc_control_s {
    uint8 rx_enable; /**< enable LLFX in RX path */
    uint8 tx_enable; /**< enable LLFX in TX path */
    uint8 crc_ignore;
    uint8 in_ipg_only; /**< llfc messages will be inserted only during IPG */
} portmod_llfc_control_t;

/* portmod_llfc_control_t initialization and validation */
int portmod_llfc_control_t_validate(int unit, const portmod_llfc_control_t* portmod_llfc_control);
int portmod_llfc_control_t_init(int unit, portmod_llfc_control_t* portmod_llfc_control);


/*!
 * @struct portmod_pfc_control_s
 * @brief  priority flow control configuration 
 */ 
typedef struct portmod_pfc_control_s {
    uint8 rx_enable;
    uint8 tx_enable;
    uint8 stats_en; /**< enable PFC counters */
    uint8 force_xon; /**< Instructs MAC to send Xon message to all classes of service */
    int refresh_timer; /**< use -1 for disable this feature; Threshold for pause timer to cause XOFF to be resent */
    int xoff_timer; /**< Time value sent in the Timer Field for classes in XOFF state */
} portmod_pfc_control_t;

/* portmod_pfc_control_t initialization and validation */
int portmod_pfc_control_t_validate(int unit, const portmod_pfc_control_t* portmod_pfc_control);
int portmod_pfc_control_t_init(int unit, portmod_pfc_control_t* portmod_pfc_control);


/*!
 * @struct portmod_pause_control_s
 * @brief  pause flow control configuration 
 */ 
typedef struct portmod_pause_control_s {
    uint8 rx_enable;
    uint8 tx_enable;
    int refresh_timer; /**< use -1 for disable this feature; Threshold for pause timer to cause XOFF to be resent */
    int xoff_timer; /**< Time value sent in the Timer Field for classes in XOFF state */
} portmod_pause_control_t;

/* portmod_pause_control_t initialization and validation */
int portmod_pause_control_t_validate(int unit, const portmod_pause_control_t* portmod_pause_control);
int portmod_pause_control_t_init(int unit, portmod_pause_control_t* portmod_pause_control);


/*!
 * @struct portmod_drain_cells_s
 * @brief  Information needed to restore after drain cells 
 */ 
typedef struct portmod_drain_cells_s {
    int rx_pfc_en;
    int llfc_en;
    int rx_pause;
    int tx_pause;
} portmod_drain_cells_t;

/* portmod_drain_cells_t initialization and validation */
int portmod_drain_cells_t_validate(int unit, const portmod_drain_cells_t* portmod_drain_cells);
int portmod_drain_cells_t_init(int unit, portmod_drain_cells_t* portmod_drain_cells);


/*!
 * @struct portmod_pm_create_info_s
 * @brief This struct contains the required information in order to add new PM to the PMM and create PM DB. 
 */ 
typedef struct portmod_pm_create_info_s {
    portmod_dispatch_type_t type; /**< PM type */
    portmod_pbmp_t phys; /**< which PHYs belongs to the PM */
    portmod_pm_specific_create_info_t pm_specific_info;
} portmod_pm_create_info_t;

/* portmod_pm_create_info_t initialization and validation */
int portmod_pm_create_info_t_validate(int unit, const portmod_pm_create_info_t* portmod_pm_create_info);
int portmod_pm_create_info_t_init(int unit, portmod_pm_create_info_t* portmod_pm_create_info);

#define PORTMOD_SIDE_SYSTEM (0)
#define PORTMOD_SIDE_LINE (1)

#define PORTMOD_PHYN_LAST_ONE (-1)


/*!
 * @struct portmod_access_get_params_s
 * @brief This struct used to select the access structure that will return from port_phy_lane_access_get 
 */ 
typedef struct portmod_access_get_params_s {
    int phyn; /**< hop number. 0-internal phy. 1 and up- external phys. -1 means the last one */
    int sys_side; /**< sys/line side.values: PORTMOD_SIDE_LINE, PORTMOD_SIDE_SYSTEM */
    int lane; /**< specific lane index. -1 (PORTMOD_ALL_LANES_ARE_ACTIVE) means return all lanes. -2 (PORTMOD_NO_LANE_IS_ACTIVE) means return no lane */
    int apply_lane_mask; /**< do lane masked for int core pm12x10 */
} portmod_access_get_params_t;

/* portmod_access_get_params_t initialization and validation */
int portmod_access_get_params_t_validate(int unit, const portmod_access_get_params_t* portmod_access_get_params);
int portmod_access_get_params_t_init(int unit, portmod_access_get_params_t* portmod_access_get_params);

#define PORTMOD_ALL_LANES_ARE_ACTIVE (-1)
#define PORTMOD_NO_LANE_IS_ACTIVE (-2)


/*!
 * @struct portmod_pm_instances_s
 * @brief This struct contains information about number of instances for PM type 
 */ 
typedef struct portmod_pm_instances_s {
    portmod_dispatch_type_t type; /**< Port Macro type */
    int instances; /**< the number of instances of the specified Port Macro type */
} portmod_pm_instances_t;

/* portmod_pm_instances_t initialization and validation */
int portmod_pm_instances_t_validate(int unit, const portmod_pm_instances_t* portmod_pm_instances);
int portmod_pm_instances_t_init(int unit, portmod_pm_instances_t* portmod_pm_instances);

/*! 
 * @brief Portmod Create Flags 
 */ 
#define PORTMOD_CREATE_F_PM_NULL 0x1 /**< Add PortmodNull */

#define PORTMOD_CREATE_F_PM_NULL_SET(flags) (flags |= PORTMOD_CREATE_F_PM_NULL)

#define PORTMOD_CREATE_F_PM_NULL_CLR(flags) (flags &= ~PORTMOD_CREATE_F_PM_NULL)

#define PORTMOD_CREATE_F_PM_NULL_GET(flags) (flags & PORTMOD_CREATE_F_PM_NULL ? 1 : 0)

/*! 
 * portmod_create
 *
 * @brief Allocate PMM memory for the specified unit.
                Should be recalled in case of Warm Boot 
 *
 * @param [in]  unit            - unit id
 * @param [in]  flags           - flags to indicate pmnull
 * @param [in]  max_ports       - Max ports that should be supported in portmod for the specified unit
 * @param [in]  max_phys        - Max PHYs that should be supported in portmod for the specified unit
 * @param [in]  nof_pm_instances   - Number of elements of the pm_instances array
 * @param [in]  pm_instances    - 
 */
int portmod_create(int unit, int flags, int max_ports, int max_phys, int nof_pm_instances, const portmod_pm_instances_t* pm_instances);

/*! 
 * portmod_destroy
 *
 * @brief Release unit PMM resources. 
 *
 * @param [in]  unit            - unit id
 */
int portmod_destroy(int unit);

/*! 
 * portmod_port_macro_add
 *
 * @brief Add new port macro to the unit PMM; <br> In case of warm boot should be re called in the same order as called in cold boot  
 *
 * @param [in]  unit            - unit id
 * @param [in]  pm_info         - 
 */
int portmod_port_macro_add(int unit, const portmod_pm_create_info_t* pm_info);




/*! 
 * portmod_port_add
 *
 * @brief Add new port. Add the port to the PM DB. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  add_info        - 
 */
int portmod_port_add(int unit, int port, const portmod_port_add_info_t* add_info);






/*! 
 * portmod_port_remove
 *
 * @brief Remove the port from the PM and PMM. 
            portmod_port_enable_set(unit, port, 0); should be called before 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int portmod_port_remove(int unit, int port);



/*! 
 * portmod_port_first_phy_get
 *
 * @brief get the first phy of the specified port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  phy             - 
 * @param [out]  sub_phy         - 
 */
int portmod_port_first_phy_get(int unit, int port, int* phy, int* sub_phy);

/*! 
 * portmod_port_is_valid
 *
 * @brief Get the specific port has valid pm. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  valid           - TRUE if port has valid pm_id
 */
int portmod_port_is_valid(int unit, int port, int* valid);

/*! 
 * portmod_port_pm_type_get
 *
 * @brief Get the pm type of a port. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  real_port       - real port num
 * @param [out]  pm_type         - dispatch type
 */
int portmod_port_pm_type_get(int unit, int port, int* real_port, portmod_dispatch_type_t* pm_type);

/*! 
 * portmod_port_enable_set
 *
 * @brief Port enable 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  flags           - see PORTMOD_PORT_ENABLE_...
 * @param [in]  enable          - 
 */
int portmod_port_enable_set(int unit, int port, int flags, int enable);
/*! 
 * portmod_port_enable_get
 *
 * @brief Port enable 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  flags           - see PORTMOD_PORT_ENABLE_...
 * @param [out]  enable          - 
 */
int portmod_port_enable_get(int unit, int port, int flags, int* enable);

/*! 
 * portmod_port_interface_config_set
 *
 * @brief  set/get the interface, speed and encapsulation for the specified port.
            For the First port within core this function initialize the PM, MAC and PHY before configure the port. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  config          - 
 * @param [in]  phy_init_flags   - see PORTMOD_INIT_F_...
 */
int portmod_port_interface_config_set(int unit, int port, const portmod_port_interface_config_t* config, int phy_init_flags);
/*! 
 * portmod_port_interface_config_get
 *
 * @brief  set/get the interface, speed and encapsulation for the specified port.
            For the First port within core this function initialize the PM, MAC and PHY before configure the port. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  config          - 
 * @param [in]  phy_init_flags   - see PORTMOD_INIT_F_...
 */
int portmod_port_interface_config_get(int unit, int port, portmod_port_interface_config_t* config, int phy_init_flags);

/*! 
 * portmod_port_default_interface_get
 *
 * @brief  get the default line-side (outmost) interface type of a port based on its speed, encap, number of lanes, etc, when there is or there is not an ext PHY 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  config          - 
 * @param [out]  interface       - 
 */
int portmod_port_default_interface_get(int unit, int port, const portmod_port_interface_config_t* config, soc_port_if_t* interface);

/*! 
 * portmod_port_encoding_set
 *
 * @brief chage port PCS encoding  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  properties      - 
 * @param [in]  encoding        - 
 */
int portmod_port_encoding_set(int unit, int port, uint32 properties, portmod_port_pcs_t encoding);
/*! 
 * portmod_port_encoding_get
 *
 * @brief chage port PCS encoding  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  properties      - 
 * @param [out]  encoding        - 
 */
int portmod_port_encoding_get(int unit, int port, uint32* properties, portmod_port_pcs_t* encoding);

/*! 
 * portmod_port_cl72_set
 *
 * @brief Port cl72 set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - 
 */
int portmod_port_cl72_set(int unit, int port, uint32 enable);
/*! 
 * portmod_port_cl72_get
 *
 * @brief Port cl72 set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - 
 */
int portmod_port_cl72_get(int unit, int port, uint32* enable);

/*! 
 * portmod_port_cl72_status_get
 *
 * @brief Get port cl72 status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  status          - 
 */
int portmod_port_cl72_status_get(int unit, int port, phymod_cl72_status_t* status);

/*! 
 * portmod_port_loopback_set
 *
 * @brief Port speed set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  loopback_type   - 
 * @param [in]  enable          - 
 */
int portmod_port_loopback_set(int unit, int port, portmod_loopback_mode_t loopback_type, int enable);
/*! 
 * portmod_port_loopback_get
 *
 * @brief Port speed set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  loopback_type   - 
 * @param [out]  enable          - 
 */
int portmod_port_loopback_get(int unit, int port, portmod_loopback_mode_t loopback_type, int* enable);

/*! 
 * portmod_port_rx_mac_enable_set
 *
 * @brief Port RX MAC ENABLE set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - 
 */
int portmod_port_rx_mac_enable_set(int unit, int port, int enable);
/*! 
 * portmod_port_rx_mac_enable_get
 *
 * @brief Port RX MAC ENABLE set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - 
 */
int portmod_port_rx_mac_enable_get(int unit, int port, int* enable);

/*! 
 * portmod_port_tx_mac_enable_set
 *
 * @brief Port TX MAC ENABLE set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - 
 */
int portmod_port_tx_mac_enable_set(int unit, int port, int enable);
/*! 
 * portmod_port_tx_mac_enable_get
 *
 * @brief Port TX MAC ENABLE set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - 
 */
int portmod_port_tx_mac_enable_get(int unit, int port, int* enable);

/*! 
 * portmod_port_ability_local_get
 *
 * @brief get port auto negotiation local ability 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  phy_flags       - which phy in the chain should be affected. see PORTMOD_INIT_F...
 * @param [out]  ability         - 
 */
int portmod_port_ability_local_get(int unit, int port, uint32 phy_flags, portmod_port_ability_t* ability);

/*! 
 * portmod_port_autoneg_set
 *
 * @brief Set/Get autoneg 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  phy_flags       - which phy in the chain should be affected. see PORTMOD_INIT_F...
 * @param [in]  an              - 
 */
int portmod_port_autoneg_set(int unit, int port, uint32 phy_flags, const phymod_autoneg_control_t* an);
/*! 
 * portmod_port_autoneg_get
 *
 * @brief Set/Get autoneg 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  phy_flags       - which phy in the chain should be affected. see PORTMOD_INIT_F...
 * @param [out]  an              - 
 */
int portmod_port_autoneg_get(int unit, int port, uint32 phy_flags, phymod_autoneg_control_t* an);

/*! 
 * portmod_port_autoneg_status_get
 *
 * @brief Get autoneg status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  an_status       - 
 */
int portmod_port_autoneg_status_get(int unit, int port, phymod_autoneg_status_t* an_status);

/*! 
 * portmod_port_link_get
 *
 * @brief get link status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           -  option flag to indicate where cmd coming from.
 * @param [out]  link            - link indication up/down
 */
int portmod_port_link_get(int unit, int port, int flags, int* link);

/*! 
 * @brief Port link latch down flags 
 */ 
#define PORTMOD_PORT_LINK_LATCH_DOWN_F_CLEAR 0x1 /**< clear the latch down indication */

/*! 
 * portmod_port_link_latch_down_get
 *
 * @brief get latch down link status (whether link was ever down since last clear) 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - see PORT_LINK_LATCH_DOWN_F
 * @param [out]  link            - link latch down indication
 */
int portmod_port_link_latch_down_get(int unit, int port, uint32 flags, int* link);

/*! 
 * portmod_port_phy_link_up_event
 *
 * @brief  link up event  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int portmod_port_phy_link_up_event(int unit, int port);

/*! 
 * portmod_port_phy_link_down_event
 *
 * @brief  link down event  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int portmod_port_phy_link_down_event(int unit, int port);

/*! 
 * portmod_port_prbs_config_set
 *
 * @brief PRBS configuration set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mode            - 0- PHY PRBS, 1- MAC PRBS
 * @param [in]  flags           - 
 * @param [in]  config          - PRBS configuration
 */
int portmod_port_prbs_config_set(int unit, int port, portmod_prbs_mode_t mode, int flags, const phymod_prbs_t* config);
/*! 
 * portmod_port_prbs_config_get
 *
 * @brief PRBS configuration set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mode            - 0- PHY PRBS, 1- MAC PRBS
 * @param [in]  flags           - 
 * @param [out]  config          - PRBS configuration
 */
int portmod_port_prbs_config_get(int unit, int port, portmod_prbs_mode_t mode, int flags, phymod_prbs_t* config);

/*! 
 * portmod_port_prbs_enable_set
 *
 * @brief PRBS enable set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mode            - 0- PHY PRBS, 1- MAC PRBS
 * @param [in]  flags           - 
 * @param [in]  enable          - 
 */
int portmod_port_prbs_enable_set(int unit, int port, portmod_prbs_mode_t mode, int flags, int enable);
/*! 
 * portmod_port_prbs_enable_get
 *
 * @brief PRBS enable set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mode            - 0- PHY PRBS, 1- MAC PRBS
 * @param [in]  flags           - 
 * @param [out]  enable          - 
 */
int portmod_port_prbs_enable_get(int unit, int port, portmod_prbs_mode_t mode, int flags, int* enable);

/*! 
 * portmod_port_prbs_status_get
 *
 * @brief PRBS status get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mode            - 0- PHY PRBS, 1- MAC PRBS
 * @param [in]  flags           - see PHYMOD_PRBS_STATUS_FLAGS_
 * @param [out]  status          - 
 */
int portmod_port_prbs_status_get(int unit, int port, portmod_prbs_mode_t mode, int flags, phymod_prbs_status_t* status);

/*! 
 * portmod_port_nof_lanes_get
 *
 * @brief Number of lanes get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  nof_lanes       - 
 */
int portmod_port_nof_lanes_get(int unit, int port, int* nof_lanes);

/*! 
 * portmod_port_ilkn_nof_segments_set
 *
 * @brief ILKN Number of segments set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  nof_segments    - Segemnts are a resource of the ILKN core, should be shared between the two ports on the same core.
 */
int portmod_port_ilkn_nof_segments_set(int unit, int port, uint32 nof_segments);
/*! 
 * portmod_port_ilkn_nof_segments_get
 *
 * @brief ILKN Number of segments set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  nof_segments    - Segemnts are a resource of the ILKN core, should be shared between the two ports on the same core.
 */
int portmod_port_ilkn_nof_segments_get(int unit, int port, uint32* nof_segments);

/*! 
 * portmod_ilkn_retranstmit_config_set
 *
 * @brief ILKN retransmit configuration set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  retransmit_config   - 
 */
int portmod_ilkn_retranstmit_config_set(int unit, int port, const ilkn_retransmit_config_t* retransmit_config);
/*! 
 * portmod_ilkn_retranstmit_config_get
 *
 * @brief ILKN retransmit configuration set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  retransmit_config   - 
 */
int portmod_ilkn_retranstmit_config_get(int unit, int port, ilkn_retransmit_config_t* retransmit_config);

/*! 
 * portmod_port_lanes_assign
 *
 * @brief assign lane map to specific port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  assign_map      - 
 */
int portmod_port_lanes_assign(int unit, int port, const portmod_lanes_assign_info_t* assign_map);

/*! 
 * portmod_port_lanes_retrieve
 *
 * @brief retrieve lane map of specific port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  assign_map      - 
 */
int portmod_port_lanes_retrieve(int unit, int port, portmod_lanes_assign_info_t* assign_map);

/*! 
 * portmod_port_firmware_mode_set
 *
 * @brief Set port PHYs' firmware mode 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  fw_mode         - 
 */
int portmod_port_firmware_mode_set(int unit, int port, phymod_firmware_mode_t fw_mode);
/*! 
 * portmod_port_firmware_mode_get
 *
 * @brief Set port PHYs' firmware mode 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  fw_mode         - 
 */
int portmod_port_firmware_mode_get(int unit, int port, phymod_firmware_mode_t* fw_mode);

/*! 
 * portmod_port_runt_threshold_set
 *
 * @brief Filter packets smaller than the specified threshold 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - packets smaller than the specified values will be filtered
 */
int portmod_port_runt_threshold_set(int unit, int port, int value);
/*! 
 * portmod_port_runt_threshold_get
 *
 * @brief Filter packets smaller than the specified threshold 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - packets smaller than this value are filtered
 */
int portmod_port_runt_threshold_get(int unit, int port, int* value);

/*! 
 * portmod_port_max_packet_size_set
 *
 * @brief Filter packets bigger than the specified value 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - the max packet size
 */
int portmod_port_max_packet_size_set(int unit, int port, int value);
/*! 
 * portmod_port_max_packet_size_get
 *
 * @brief Filter packets bigger than the specified value 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - the max packet size
 */
int portmod_port_max_packet_size_get(int unit, int port, int* value);

/*! 
 * portmod_port_pad_size_set
 *
 * @brief TX pad packets to the specified size. values smaller than 17 means pad is disabled. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - 
 */
int portmod_port_pad_size_set(int unit, int port, int value);
/*! 
 * portmod_port_pad_size_get
 *
 * @brief TX pad packets to the specified size. values smaller than 17 means pad is disabled. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - 
 */
int portmod_port_pad_size_get(int unit, int port, int* value);

/*! 
 * portmod_port_tx_mac_sa_set
 *
 * @brief set/get the MAC source address that will be sent in case of Pause/LLFC 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mac_sa          - 
 */
int portmod_port_tx_mac_sa_set(int unit, int port, sal_mac_addr_t mac_sa);
/*! 
 * portmod_port_tx_mac_sa_get
 *
 * @brief set/get the MAC source address that will be sent in case of Pause/LLFC 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  mac_sa          - 
 */
int portmod_port_tx_mac_sa_get(int unit, int port, sal_mac_addr_t mac_sa);

/*! 
 * portmod_port_rx_mac_sa_set
 *
 * @brief set/get SA recognized for MAC control packets in addition to the standard 0x0180C2000001 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mac_sa          - 
 */
int portmod_port_rx_mac_sa_set(int unit, int port, sal_mac_addr_t mac_sa);
/*! 
 * portmod_port_rx_mac_sa_get
 *
 * @brief set/get SA recognized for MAC control packets in addition to the standard 0x0180C2000001 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  mac_sa          - 
 */
int portmod_port_rx_mac_sa_get(int unit, int port, sal_mac_addr_t mac_sa);

/*! 
 * portmod_port_tx_average_ipg_set
 *
 * @brief set/get Average inter-packet gap 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - 
 */
int portmod_port_tx_average_ipg_set(int unit, int port, int value);
/*! 
 * portmod_port_tx_average_ipg_get
 *
 * @brief set/get Average inter-packet gap 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - 
 */
int portmod_port_tx_average_ipg_get(int unit, int port, int* value);

/*! 
 * portmod_port_tx_preamble_length_set
 *
 * @brief set/get Number of preamble bytes for transmit IEEE packets; this value should include the K.SOP and SFD character as well 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - 
 */
int portmod_port_tx_preamble_length_set(int unit, int port, int value);
/*! 
 * portmod_port_tx_preamble_length_get
 *
 * @brief set/get Number of preamble bytes for transmit IEEE packets; this value should include the K.SOP and SFD character as well 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - 
 */
int portmod_port_tx_preamble_length_get(int unit, int port, int* value);

/*! 
 * portmod_port_local_fault_control_set
 *
 * @brief local fault set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  control         - 
 */
int portmod_port_local_fault_control_set(int unit, int port, const portmod_local_fault_control_t* control);
/*! 
 * portmod_port_local_fault_control_get
 *
 * @brief local fault set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  control         - 
 */
int portmod_port_local_fault_control_get(int unit, int port, portmod_local_fault_control_t* control);

/*! 
 * portmod_port_remote_fault_control_set
 *
 * @brief remote fault set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  control         - 
 */
int portmod_port_remote_fault_control_set(int unit, int port, const portmod_remote_fault_control_t* control);
/*! 
 * portmod_port_remote_fault_control_get
 *
 * @brief remote fault set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  control         - 
 */
int portmod_port_remote_fault_control_get(int unit, int port, portmod_remote_fault_control_t* control);

/*! 
 * portmod_port_local_fault_status_get
 *
 * @brief local fault steatus get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - 
 */
int portmod_port_local_fault_status_get(int unit, int port, int* value);

/*! 
 * portmod_port_remote_fault_status_get
 *
 * @brief remote fault status get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - 
 */
int portmod_port_remote_fault_status_get(int unit, int port, int* value);

/*! 
 * portmod_port_local_fault_status_clear
 *
 * @brief local fault steatus clear 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int portmod_port_local_fault_status_clear(int unit, int port);

/*! 
 * portmod_port_remote_fault_status_clear
 *
 * @brief remote fault status clear 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int portmod_port_remote_fault_status_clear(int unit, int port);

/*! 
 * portmod_port_pause_control_set
 *
 * @brief set/get Pause FC configuration 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  control         - 
 */
int portmod_port_pause_control_set(int unit, int port, const portmod_pause_control_t* control);
/*! 
 * portmod_port_pause_control_get
 *
 * @brief set/get Pause FC configuration 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  control         - 
 */
int portmod_port_pause_control_get(int unit, int port, portmod_pause_control_t* control);

/*! 
 * portmod_port_pfc_control_set
 *
 * @brief set/get PFC FC configuration 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  control         - 
 */
int portmod_port_pfc_control_set(int unit, int port, const portmod_pfc_control_t* control);
/*! 
 * portmod_port_pfc_control_get
 *
 * @brief set/get PFC FC configuration 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  control         - 
 */
int portmod_port_pfc_control_get(int unit, int port, portmod_pfc_control_t* control);

/*! 
 * portmod_port_llfc_control_set
 *
 * @brief set/get LLFC FC configuration 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  control         - 
 */
int portmod_port_llfc_control_set(int unit, int port, const portmod_llfc_control_t* control);
/*! 
 * portmod_port_llfc_control_get
 *
 * @brief set/get LLFC FC configuration 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  control         - 
 */
int portmod_port_llfc_control_get(int unit, int port, portmod_llfc_control_t* control);

/*! 
 * @brief Port Update Flags 
 */ 
#define PORTMOD_PORT_UPDATE_F_DISABLE_MAC 0x1 /**< disable MAC when phy link status is down */
#define PORTMOD_PORT_UPDATE_F_UPDATE_SERDES_LINK 0x2 /**< Force Serdes Link Status  */

#define PORTMOD_PORT_UPDATE_F_DISABLE_MAC_SET(control) ((control)->flags |= PORTMOD_PORT_UPDATE_F_DISABLE_MAC)
#define PORTMOD_PORT_UPDATE_F_UPDATE_SERDES_LINK_SET(control) ((control)->flags |= PORTMOD_PORT_UPDATE_F_UPDATE_SERDES_LINK)

#define PORTMOD_PORT_UPDATE_F_DISABLE_MAC_CLR(control) ((control)->flags &= ~PORTMOD_PORT_UPDATE_F_DISABLE_MAC)
#define PORTMOD_PORT_UPDATE_F_UPDATE_SERDES_LINK_CLR(control) ((control)->flags &= ~PORTMOD_PORT_UPDATE_F_UPDATE_SERDES_LINK)

#define PORTMOD_PORT_UPDATE_F_DISABLE_MAC_GET(control) ((control)->flags & PORTMOD_PORT_UPDATE_F_DISABLE_MAC ? 1 : 0)
#define PORTMOD_PORT_UPDATE_F_UPDATE_SERDES_LINK_GET(control) ((control)->flags & PORTMOD_PORT_UPDATE_F_UPDATE_SERDES_LINK ? 1 : 0)


/*!
 * @struct portmod_port_update_control_s
 * @brief Expected user access structure when using PM default bus 
 */ 
typedef struct portmod_port_update_control_s {
    int link_status; /**< Current link status, use -1 to retrive the status inside the function */
    uint32 flags;
} portmod_port_update_control_t;

/* portmod_port_update_control_t initialization and validation */
int portmod_port_update_control_t_validate(int unit, const portmod_port_update_control_t* portmod_port_update_control);
int portmod_port_update_control_t_init(int unit, portmod_port_update_control_t* portmod_port_update_control);

/*! 
 * portmod_port_update
 *
 * @brief Routine for MAC/PHY sync. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  update_control   - inputs for update operation
 */
int portmod_port_update(int unit, int port, const portmod_port_update_control_t* update_control);

/*! 
 * portmod_port_core_access_get
 *
 * @brief get port cores' phymod access 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  phyn            - the number of hops from the internal phy. 0 - internal, 1- first external PHY, etc.
 * @param [in]  max_cores       - the output array number of elements
 * @param [out]  core_access_arr   - port phymod cores array
 * @param [out]  nof_cores       - number of core access structutres filled by the function
 * @param [out]  is_most_ext     - Whether this phy is the most external, can be passed as NULL
 */
int portmod_port_core_access_get(int unit, int port, int phyn, int max_cores, phymod_core_access_t* core_access_arr, int* nof_cores, int* is_most_ext);

/*! 
 * portmod_port_phy_lane_access_get
 *
 * @brief Get lane phymod access structure. can be used for per lane operations 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  params          - 
 * @param [in]  max_phys        - the output array number of elements
 * @param [out]  access          - 
 * @param [out]  nof_phys        - number of phy access structutres filled by the function
 * @param [out]  is_most_ext     - Whether this phy is the most external, can be passed as NULL
 */
int portmod_port_phy_lane_access_get(int unit, int port, const portmod_access_get_params_t* params, int max_phys, phymod_phy_access_t* access, int* nof_phys, int* is_most_ext);

/*! 
 * portmod_pm_diag_info_get
 *
 * @brief get PM diag info 
 *
 * @param [in]  unit            - unit id
 * @param [in]  pm_id           - pm id
 * @param [out]  diag_info       - 
 */
int portmod_pm_diag_info_get(int unit, int pm_id, portmod_pm_diag_info_t* diag_info);

/*! 
 * portmod_port_diag_info_get
 *
 * @brief get port diag info 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  diag_info       - 
 */
int portmod_port_diag_info_get(int unit, int port, portmod_port_diag_info_t* diag_info);

/*! 
 * portmod_port_duplex_set
 *
 * @brief Port duplex set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - 
 */
int portmod_port_duplex_set(int unit, int port, int enable);
/*! 
 * portmod_port_duplex_get
 *
 * @brief Port duplex set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - 
 */
int portmod_port_duplex_get(int unit, int port, int* enable);

/*! 
 * portmod_port_phy_reg_read
 *
 * @brief Port PHY Control register read 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - flags
 * @param [in]  reg_addr        - register address
 * @param [out]  value           - read data
 */
int portmod_port_phy_reg_read(int unit, int port, int flags, int reg_addr, uint32* value);

/*! 
 * portmod_port_phy_reg_write
 *
 * @brief Port PHY Control register write 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - see PORTMOD_PORT_PHY_CONTROL_
 * @param [in]  reg_addr        - register address
 * @param [in]  value           - 
 */
int portmod_port_phy_reg_write(int unit, int port, int flags, int reg_addr, uint32 value);

/*! 
 * portmod_port_reset_set
 *
 * @brief Port Reset set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mode            - 
 * @param [in]  opcode          - 
 * @param [in]  value           - 
 */
int portmod_port_reset_set(int unit, int port, int mode, int opcode, int value);
/*! 
 * portmod_port_reset_get
 *
 * @brief Port Reset set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mode            - 
 * @param [in]  opcode          - 
 * @param [out]  value           - 
 */
int portmod_port_reset_get(int unit, int port, int mode, int opcode, int* value);

/*! 
 * portmod_port_adv_remote_get
 *
 * @brief Port remote Adv get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - 
 */
int portmod_port_adv_remote_get(int unit, int port, int* value);

/*! 
 * portmod_port_drv_name
 *
 * @brief Port get drv name 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int portmod_port_drv_name(int unit, int port);

/*! 
 * portmod_port_drv_name_get
 *
 * @brief Drv Name Get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  name            - 
 * @param [in]  len             - 
 */
int portmod_port_drv_name_get(int unit, int port, char* name, int len);

/*! 
 * portmod_port_fec_enable_set
 *
 * @brief set/get port fec enable according to local/remote FEC ability 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - 
 */
int portmod_port_fec_enable_set(int unit, int port, uint32_t enable);
/*! 
 * portmod_port_fec_enable_get
 *
 * @brief set/get port fec enable according to local/remote FEC ability 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - 
 */
int portmod_port_fec_enable_get(int unit, int port, uint32_t* enable);

/*! 
 * portmod_port_ability_advert_set
 *
 * @brief get port auto negotiation local ability 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  phy_flags       - which phy in the chain should be affected. see PORTMOD_INIT_F...
 * @param [out]  ability         - 
 */
int portmod_port_ability_advert_set(int unit, int port, uint32 phy_flags, portmod_port_ability_t* ability);
/*! 
 * portmod_port_ability_advert_get
 *
 * @brief get port auto negotiation local ability 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  phy_flags       - which phy in the chain should be affected. see PORTMOD_INIT_F...
 * @param [out]  ability         - 
 */
int portmod_port_ability_advert_get(int unit, int port, uint32 phy_flags, portmod_port_ability_t* ability);

/*! 
 * portmod_port_ability_remote_get
 *
 * @brief Port ability remote Adv get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  phy_flags       - which phy in the chain should be affected. see PORTMOD_INIT_F...
 * @param [out]  ability         - 
 */
int portmod_port_ability_remote_get(int unit, int port, uint32 phy_flags, portmod_port_ability_t* ability);

/*! 
 * portmod_port_frame_spacing_stretch_set
 *
 * @brief Port Mac Control Spacing Stretch 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  spacing         - 
 */
int portmod_port_frame_spacing_stretch_set(int unit, int port, int spacing);
/*! 
 * portmod_port_frame_spacing_stretch_get
 *
 * @brief Port Mac Control Spacing Stretch 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  spacing         - 
 */
int portmod_port_frame_spacing_stretch_get(int unit, int port, const int* spacing);

/*! 
 * portmod_port_diag_fifo_status_get
 *
 * @brief get port timestamps in fifo 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  diag_info       - 
 */
int portmod_port_diag_fifo_status_get(int unit, int port, const portmod_fifo_status_t* diag_info);

/*! 
 * portmod_port_rx_control_set
 *
 * @brief set/get pass control frames. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  rx_ctrl         - 
 */
int portmod_port_rx_control_set(int unit, int port, const portmod_rx_control_t* rx_ctrl);
/*! 
 * portmod_port_rx_control_get
 *
 * @brief set/get pass control frames. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  rx_ctrl         - 
 */
int portmod_port_rx_control_get(int unit, int port, portmod_rx_control_t* rx_ctrl);

/*! 
 * portmod_port_pfc_config_set
 *
 * @brief set PFC config registers. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  pfc_cfg         - 
 */
int portmod_port_pfc_config_set(int unit, int port, const portmod_pfc_config_t* pfc_cfg);
/*! 
 * portmod_port_pfc_config_get
 *
 * @brief set PFC config registers. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  pfc_cfg         - 
 */
int portmod_port_pfc_config_get(int unit, int port, portmod_pfc_config_t* pfc_cfg);

/*! 
 * portmod_port_eee_set
 *
 * @brief set EEE Config. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  eee             - 
 */
int portmod_port_eee_set(int unit, int port, const portmod_eee_t* eee);
/*! 
 * portmod_port_eee_get
 *
 * @brief set EEE Config. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  eee             - 
 */
int portmod_port_eee_get(int unit, int port, portmod_eee_t* eee);

/*! 
 * portmod_port_eee_clock_set
 *
 * @brief set EEE Config. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  eee_clk         - 
 */
int portmod_port_eee_clock_set(int unit, int port, const portmod_eee_clock_t* eee_clk);
/*! 
 * portmod_port_eee_clock_get
 *
 * @brief set EEE Config. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  eee_clk         - 
 */
int portmod_port_eee_clock_get(int unit, int port, portmod_eee_clock_t* eee_clk);

/*! 
 * portmod_port_vlan_tag_set
 *
 * @brief set Vlan Inner/Outer tag. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  vlan_tag        - 
 */
int portmod_port_vlan_tag_set(int unit, int port, const portmod_vlan_tag_t* vlan_tag);
/*! 
 * portmod_port_vlan_tag_get
 *
 * @brief set Vlan Inner/Outer tag. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  vlan_tag        - 
 */
int portmod_port_vlan_tag_get(int unit, int port, portmod_vlan_tag_t* vlan_tag);

/*! 
 * portmod_port_to_phyaddr
 *
 * @brief Get Phy addr for a given port. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int portmod_port_to_phyaddr(int unit, int port);

/*! 
 * portmod_port_to_phyaddr_int
 *
 * @brief Get internal Phy addr for a given port. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int portmod_port_to_phyaddr_int(int unit, int port);

/*! 
 * portmod_port_modid_set
 *
 * @brief set modid field. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - 
 */
int portmod_port_modid_set(int unit, int port, int value);

/*! 
 * portmod_port_led_chain_config
 *
 * @brief set modid field. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - 
 */
int portmod_port_led_chain_config(int unit, int port, int value);

/*! 
 * portmod_port_clear_rx_lss_status_set
 *
 * @brief set modid field. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  lcl_fault       - 
 * @param [in]  rmt_fault       - 
 */
int portmod_port_clear_rx_lss_status_set(int unit, int port, int lcl_fault, int rmt_fault);
/*! 
 * portmod_port_clear_rx_lss_status_get
 *
 * @brief set modid field. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  lcl_fault       - 
 * @param [out]  rmt_fault       - 
 */
int portmod_port_clear_rx_lss_status_get(int unit, int port, int* lcl_fault, int* rmt_fault);

#define PORTMOD_PRIMARY_PORT_INVALID (-1)
#define PORTMOD_PORT_OFFSET_INVALID (-1)
#define PORTMOD_CORE_INDEX_INVALID (-1)
#define PORTMOD_LANE_INDEX_INVALID (-1)
#define PORTMOD_XPHY_ID_INVALID (0xFFFF)
#define PORTMOD_MAX_NUM_XPHY_SUPPORTED (512)
#define PORTMOD_XPHY_EXISTING_IDX (-2)


/*!
 * @struct portmod_lane_connection_s
 * @brief lane connection structture between internal and external phy 
 */ 
typedef struct portmod_lane_connection_s {
    int core_index; /**< the connected core in the external phy */
    int lane_index; /**< the connected lane in the external phy */
} portmod_lane_connection_t;

/* portmod_lane_connection_t initialization and validation */
int portmod_lane_connection_t_validate(int unit, const portmod_lane_connection_t* portmod_lane_connection);
int portmod_lane_connection_t_init(int unit, portmod_lane_connection_t* portmod_lane_connection);


/*!
 * @struct portmod_phy_core_info_s
 * @brief Core information structure for external phy db 
 */ 
typedef struct portmod_phy_core_info_s {
    phymod_core_access_t core_access; /**< core access */
} portmod_phy_core_info_t;

/* portmod_phy_core_info_t initialization and validation */
int portmod_phy_core_info_t_validate(int unit, const portmod_phy_core_info_t* portmod_phy_core_info);
int portmod_phy_core_info_t_init(int unit, portmod_phy_core_info_t* portmod_phy_core_info);


/*!
 * @struct portmod_xphy_lane_connection_s
 * @brief lane connection structture between internal and external phy 
 */ 
typedef struct portmod_xphy_lane_connection_s {
    uint32 xphy_id; /**< connected xphy id */
    int ss_lane_mask; /**< connected xphy system side lane mask */
    int ls_lane_mask; /**< connected xphy line side lane mask */
    int rsvd1; /**< connected xphy line side lane mask */
    int rsvd2; /**< connected xphy line side lane mask */
} portmod_xphy_lane_connection_t;

/* portmod_xphy_lane_connection_t initialization and validation */
int portmod_xphy_lane_connection_t_validate(int unit, const portmod_xphy_lane_connection_t* portmod_xphy_lane_connection);
int portmod_xphy_lane_connection_t_init(int unit, portmod_xphy_lane_connection_t* portmod_xphy_lane_connection);

/*! 
 * portmod_xphy_lane_attach
 *
 * @brief Attaches an external phy lane to a phy chain 
 *
 * @param [in]  unit            - unit id
 * @param [in]  iphy            - internal phy index representing the starting point of a phy chain
 * @param [in]  phyn            - indicate the external phy layer in the phy chain
 * @param [in]  lane_conn       - lane connection between internal and external phy
 */
int portmod_xphy_lane_attach(int unit, int iphy, int phyn, const portmod_xphy_lane_connection_t* lane_conn);

/*! 
 * portmod_xphy_lane_detach
 *
 * @brief Detaches an external phy lane from a phy chain 
 *
 * @param [in]  unit            - unit id
 * @param [in]  iphy            - internal phy index representing the starting point of a phy chain
 * @param [in]  phyn            - indicate the external phy layer in the phy chain
 */
int portmod_xphy_lane_detach(int unit, int iphy, int phyn);



/*! 
 * portmod_xphy_add
 *
 * @brief Add External Phy to DB.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  xphy_addr       - External Phy Address. Usually MDIO address.
 * @param [in]  core_access     - External Phy Access information
 * @param [out]  xphy_idx        - Indicate location of new entry.
 */
int portmod_xphy_add(int unit, int xphy_addr, const phymod_core_access_t* core_access, int* xphy_idx);

/*! 
 * portmod_xphy_delete
 *
 * @brief Remove External Phy from DB.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  xphy_addr       - External Phy Address. Usually MDIO address.
 */
int portmod_xphy_delete(int unit, int xphy_addr);

/*! 
 * portmod_xphy_wb_db_restore
 *
 * @brief  Restore External Phy  DB from WB buffer.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  xphy_idx        - index to the xphy db
 * @param [in]  xphy_addr       - external phy address
 * @param [in]  core_access     - the core_access to be used for external phys restored from WB database. external phy address , external phy type and external phy device_op_mode  will be override with values restored from WB DB.
 */
int portmod_xphy_wb_db_restore(int unit, int xphy_idx, int xphy_addr, const phymod_core_access_t* core_access);




/*! 
 * portmod_ext_phy_lane_attach
 *
 * @brief Attaches an external phy lane to a phy chain 
 *
 * @param [in]  unit            - unit id
 * @param [in]  iphy            - internal phy index representing the starting point of a phy chain
 * @param [in]  phyn            - indicate the external phy layer in the phy chain
 * @param [in]  lane_connection   - lane connection between internal and external phy
 */
int portmod_ext_phy_lane_attach(int unit, int iphy, int phyn, const portmod_lane_connection_t* lane_connection);

/*! 
 * portmod_ext_phy_lane_detach
 *
 * @brief Detaches an external phy lane from a phy chain 
 *
 * @param [in]  unit            - unit id
 * @param [in]  iphy            - internal phy index representing the starting point of a phy chain
 * @param [in]  phyn            - indicate the external phy layer in the phy chain
 */
int portmod_ext_phy_lane_detach(int unit, int iphy, int phyn);



/*! 
 * portmod_port_lag_failover_status_toggle
 *
 * @brief Toggle Lag Failover Status. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int portmod_port_lag_failover_status_toggle(int unit, int port);

/*! 
 * portmod_port_lag_failover_loopback_set
 *
 * @brief Toggle Lag Failover loopback set / get. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - 
 */
int portmod_port_lag_failover_loopback_set(int unit, int port, int value);
/*! 
 * portmod_port_lag_failover_loopback_get
 *
 * @brief Toggle Lag Failover loopback set / get. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - 
 */
int portmod_port_lag_failover_loopback_get(int unit, int port, int* value);

/*! 
 * portmod_port_mode_set
 *
 * @brief set port mode. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mode            - 
 */
int portmod_port_mode_set(int unit, int port, const portmod_port_mode_info_t* mode);
/*! 
 * portmod_port_mode_get
 *
 * @brief set port mode. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  mode            - 
 */
int portmod_port_mode_get(int unit, int port, portmod_port_mode_info_t* mode);

/*! 
 * portmod_port_encap_set
 *
 * @brief set port encap. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - 
 * @param [in]  encap           - 
 */
int portmod_port_encap_set(int unit, int port, int flags, portmod_encap_t encap);
/*! 
 * portmod_port_encap_get
 *
 * @brief set port encap. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  flags           - 
 * @param [out]  encap           - 
 */
int portmod_port_encap_get(int unit, int port, int* flags, portmod_encap_t* encap);

/*! 
 * portmod_port_higig_mode_set
 *
 * @brief set port register higig field. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mode            - 
 */
int portmod_port_higig_mode_set(int unit, int port, int mode);
/*! 
 * portmod_port_higig_mode_get
 *
 * @brief set port register higig field. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  mode            - 
 */
int portmod_port_higig_mode_get(int unit, int port, int* mode);

/*! 
 * portmod_port_higig2_mode_set
 *
 * @brief set port register higig field. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mode            - 
 */
int portmod_port_higig2_mode_set(int unit, int port, int mode);
/*! 
 * portmod_port_higig2_mode_get
 *
 * @brief set port register higig field. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  mode            - 
 */
int portmod_port_higig2_mode_get(int unit, int port, int* mode);

/*! 
 * portmod_port_config_port_type_set
 *
 * @brief set port register port type field. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  type            - 
 */
int portmod_port_config_port_type_set(int unit, int port, int type);
/*! 
 * portmod_port_config_port_type_get
 *
 * @brief set port register port type field. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  type            - 
 */
int portmod_port_config_port_type_get(int unit, int port, int* type);

/*! 
 * portmod_port_trunk_hwfailover_config_set
 *
 * @brief set/get hwfailover for trident. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  hw_count        - 
 */
int portmod_port_trunk_hwfailover_config_set(int unit, int port, int hw_count);
/*! 
 * portmod_port_trunk_hwfailover_config_get
 *
 * @brief set/get hwfailover for trident. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - 
 */
int portmod_port_trunk_hwfailover_config_get(int unit, int port, int* enable);

/*! 
 * portmod_port_trunk_hwfailover_status_get
 *
 * @brief set/get hwfailover for trident. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  loopback        - 
 */
int portmod_port_trunk_hwfailover_status_get(int unit, int port, int* loopback);

/*! 
 * portmod_port_diag_ctrl
 *
 * @brief port diagnostics control. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  inst            - 
 * @param [in]  op_type         - 
 * @param [in]  op_cmd          - 
 * @param [in]  arg             - 
 */
int portmod_port_diag_ctrl(int unit, int port, uint32 inst, int op_type, int op_cmd, const void* arg);

/*! 
 * portmod_port_ref_clk_get
 *
 * @brief Get the reference clock value 156 or 125. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  ref_clk         - 
 */
int portmod_port_ref_clk_get(int unit, int port, int* ref_clk);

/*! 
 * portmod_port_lag_failover_disable
 *
 * @brief Disable lag failover. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int portmod_port_lag_failover_disable(int unit, int port);

/*! 
 * portmod_port_lag_remove_failover_lpbk_set
 *
 * @brief Disable lag failover. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  val             - 
 */
int portmod_port_lag_remove_failover_lpbk_set(int unit, int port, int val);
/*! 
 * portmod_port_lag_remove_failover_lpbk_get
 *
 * @brief Disable lag failover. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  val             - 
 */
int portmod_port_lag_remove_failover_lpbk_get(int unit, int port, int* val);

/*! 
 * portmod_port_cntmaxsize_set
 *
 * @brief Disable lag failover. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  val             - 
 */
int portmod_port_cntmaxsize_set(int unit, int port, int val);
/*! 
 * portmod_port_cntmaxsize_get
 *
 * @brief Disable lag failover. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  val             - 
 */
int portmod_port_cntmaxsize_get(int unit, int port, int* val);



/*! 
 * portmod_port_multi_get
 *
 * @brief Read multiple bytes get. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [inout] multi_get       - 
 */
int portmod_port_multi_get(int unit, int port, portmod_multi_get_t* multi_get);

/*! 
 * portmod_port_drain_cell_get
 *
 * @brief Get Info needed to restore after drain cells. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  drain_cells     - 
 */
int portmod_port_drain_cell_get(int unit, int port, portmod_drain_cells_t* drain_cells);

/*! 
 * portmod_port_drain_cell_stop
 *
 * @brief Restore informaation after drain cells. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  drain_cells     - 
 */
int portmod_port_drain_cell_stop(int unit, int port, const portmod_drain_cells_t* drain_cells);

/*! 
 * portmod_port_drain_cell_start
 *
 * @brief Restore informaation after drain cells. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int portmod_port_drain_cell_start(int unit, int port);

/*! 
 * portmod_port_drain_cells_rx_enable
 *
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  rx_en           - 
 */
int portmod_port_drain_cells_rx_enable(int unit, int port, int rx_en);

/*! 
 * portmod_port_egress_queue_drain_rx_en
 *
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  rx_en           - 
 */
int portmod_port_egress_queue_drain_rx_en(int unit, int port, int rx_en);

/*! 
 * portmod_port_mac_ctrl_set
 *
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  ctrl            - 
 */
int portmod_port_mac_ctrl_set(int unit, int port, uint64 ctrl);

/*! 
 * portmod_port_txfifo_cell_cnt_get
 *
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  cnt             - 
 */
int portmod_port_txfifo_cell_cnt_get(int unit, int port, uint32* cnt);

/*! 
 * portmod_port_egress_queue_drain_get
 *
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  ctrl            - 
 * @param [out]  rxen            - 
 */
int portmod_port_egress_queue_drain_get(int unit, int port, uint64* ctrl, int* rxen);

/*! 
 * portmod_port_mac_reset_set
 *
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  val             - 
 */
int portmod_port_mac_reset_set(int unit, int port, int val);

/*! 
 * portmod_port_soft_reset_toggle
 *
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  idx             - 
 */
int portmod_port_soft_reset_toggle(int unit, int port, int idx);

/*! 
 * portmod_port_mac_reset_check
 *
 * @brief Check if MAC needs to be reset. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - Check for enable or disable MAC
 * @param [out]  reset           - TRUE if MAC needs to be reset
 */
int portmod_port_mac_reset_check(int unit, int port, int enable, int* reset);

/*! 
 * portmod_port_core_num_get
 *
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  core_num        - 
 */
int portmod_port_core_num_get(int unit, int port, int* core_num);


/*!
 * @struct portmod_port_higig_e2ecc_hdr_s
 * @brief PM E2ECC header . 
 */ 
typedef struct portmod_port_higig_e2ecc_hdr_s {
    uint32 words[8];
} portmod_port_higig_e2ecc_hdr_t;

/* portmod_port_higig_e2ecc_hdr_t initialization and validation */
int portmod_port_higig_e2ecc_hdr_t_validate(int unit, const portmod_port_higig_e2ecc_hdr_t* portmod_port_higig_e2ecc_hdr);
int portmod_port_higig_e2ecc_hdr_t_init(int unit, portmod_port_higig_e2ecc_hdr_t* portmod_port_higig_e2ecc_hdr);

/*! 
 * portmod_port_e2ecc_hdr_set
 *
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  e2ecc_hdr       - 
 */
int portmod_port_e2ecc_hdr_set(int unit, int port, const portmod_port_higig_e2ecc_hdr_t* e2ecc_hdr);
/*! 
 * portmod_port_e2ecc_hdr_get
 *
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  e2ecc_hdr       - 
 */
int portmod_port_e2ecc_hdr_get(int unit, int port, portmod_port_higig_e2ecc_hdr_t* e2ecc_hdr);

/*! 
 * portmod_port_e2e_enable_set
 *
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - 
 */
int portmod_port_e2e_enable_set(int unit, int port, int enable);
/*! 
 * portmod_port_e2e_enable_get
 *
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - 
 */
int portmod_port_e2e_enable_get(int unit, int port, int* enable);

/*! 
 * portmod_port_fallback_lane_get
 *
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  fallback_lane   - 
 */
int portmod_port_fallback_lane_get(int unit, int port, int* fallback_lane);

/*! 
 * portmod_port_speed_get
 *
 * @brief get the speed for the specified port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  speed           - 
 */
int portmod_port_speed_get(int unit, int port, int* speed);

/*! 
 * portmod_port_tsc_refclock_set
 *
 * @brief TSC refere clock input and output set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  ref_in          - Selects between pad and LCREF as source of refclk into this TSC PLL. 0 -- pad, 1 -- LCREF
 * @param [in]  ref_out         - Enables LCREFOUT to be driven by this TSC. 0 -- disable, 1 -- enable
 */
int portmod_port_tsc_refclock_set(int unit, int port, int ref_in, int ref_out);
/*! 
 * portmod_port_tsc_refclock_get
 *
 * @brief TSC refere clock input and output set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  ref_in          - 
 * @param [out]  ref_out         - 
 */
int portmod_port_tsc_refclock_get(int unit, int port, int* ref_in, int* ref_out);

/*! 
 * portmod_port_discard_set
 *
 * @brief Port discard set 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  discard         - Set Discardf and EP_Discard
 */
int portmod_port_discard_set(int unit, int port, int discard);

/*! 
 * portmod_port_soft_reset_set
 *
 * @brief Port soft reset set set 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  idx             - index
 * @param [in]  val             - value 0/1
 * @param [in]  flags           - 
 */
int portmod_port_soft_reset_set(int unit, int port, int idx, int val, int flags);

/*! 
 * portmod_port_tx_down
 *
 * @brief Port tx_en=0 and softreset mac 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int portmod_port_tx_down(int unit, int port);

/*! 
 * portmod_port_logical_lane_order_set
 *
 * @brief "logical lane order" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  lane_order      - 
 * @param [in]  lane_order_size   - 
 */
int portmod_port_logical_lane_order_set(int unit, int port, const int* lane_order, int lane_order_size);
/*! 
 * portmod_port_logical_lane_order_get
 *
 * @brief "logical lane order" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  lane_order_max_size   - 
 * @param [out]  lane_order      - 
 * @param [out]  lane_order_actual_size   - 
 */
int portmod_port_logical_lane_order_get(int unit, int port, int lane_order_max_size, int* lane_order, int* lane_order_actual_size);

/*! 
 * portmod_port_pgw_reconfig
 *
 * @brief reconfig pgw. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  pmode           - 
 * @param [in]  phy_port        - 
 * @param [in]  flags           - 
 */
int portmod_port_pgw_reconfig(int unit, int port, const portmod_port_mode_info_t* pmode, int phy_port, int flags);

/*! 
 * portmod_port_notify
 *
 * @brief Routine to notify internal phy of external phy link state. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  link            - link status
 */
int portmod_port_notify(int unit, int port, int link);

typedef soc_port_phy_timesync_config_t portmod_phy_timesync_config_t;

typedef _shr_port_control_phy_timesync_t portmod_port_control_phy_timesync_t;

/*! 
 * portmod_port_control_phy_timesync_set
 *
 * @brief "port control phy timesync config set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  config          - 
 * @param [in]  value           - 
 */
int portmod_port_control_phy_timesync_set(int unit, int port, portmod_port_control_phy_timesync_t config, uint64 value);
/*! 
 * portmod_port_control_phy_timesync_get
 *
 * @brief "port control phy timesync config set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  config          - 
 * @param [out]  value           - 
 */
int portmod_port_control_phy_timesync_get(int unit, int port, portmod_port_control_phy_timesync_t config, uint64* value);

/*! 
 * portmod_port_timesync_config_set
 *
 * @brief "port timesync config set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  config          - 
 */
int portmod_port_timesync_config_set(int unit, int port, const portmod_phy_timesync_config_t* config);
/*! 
 * portmod_port_timesync_config_get
 *
 * @brief "port timesync config set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  config          - 
 */
int portmod_port_timesync_config_get(int unit, int port, portmod_phy_timesync_config_t* config);

/*! 
 * portmod_port_timesync_enable_set
 *
 * @brief "port timesync enable set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - 
 */
int portmod_port_timesync_enable_set(int unit, int port, uint32 enable);
/*! 
 * portmod_port_timesync_enable_get
 *
 * @brief "port timesync enable set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - 
 */
int portmod_port_timesync_enable_get(int unit, int port, uint32* enable);

/*! 
 * portmod_port_timesync_nco_addend_set
 *
 * @brief "port timesync nco addend  set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  freq_step       - NCO Frequency Step.
 */
int portmod_port_timesync_nco_addend_set(int unit, int port, uint32 freq_step);
/*! 
 * portmod_port_timesync_nco_addend_get
 *
 * @brief "port timesync nco addend  set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  freq_step       - NCO Frequency Step.
 */
int portmod_port_timesync_nco_addend_get(int unit, int port, uint32* freq_step);

typedef phymod_timesync_framesync_t portmod_timesync_framesync_t;

/*! 
 * portmod_port_timesync_framesync_mode_set
 *
 * @brief "port timesync framesync info  set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  framesync       - Framesync Info.
 */
int portmod_port_timesync_framesync_mode_set(int unit, int port, const portmod_timesync_framesync_t* framesync);
/*! 
 * portmod_port_timesync_framesync_mode_get
 *
 * @brief "port timesync framesync info  set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  framesync       - Framesync Info.
 */
int portmod_port_timesync_framesync_mode_get(int unit, int port, portmod_timesync_framesync_t* framesync);

/*! 
 * portmod_port_timesync_local_time_set
 *
 * @brief "port timesync local time  set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  local_time      - Local Time.
 */
int portmod_port_timesync_local_time_set(int unit, int port, uint64 local_time);
/*! 
 * portmod_port_timesync_local_time_get
 *
 * @brief "port timesync local time  set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  local_time      - Local Time.
 */
int portmod_port_timesync_local_time_get(int unit, int port, uint64* local_time);

/*! 
 * portmod_port_timesync_load_ctrl_set
 *
 * @brief "port timesync framesync info  set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  load_once       - Load Once.
 * @param [in]  load_always     - Load Always.
 */
int portmod_port_timesync_load_ctrl_set(int unit, int port, uint32 load_once, uint32 load_always);
/*! 
 * portmod_port_timesync_load_ctrl_get
 *
 * @brief "port timesync framesync info  set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  load_once       - Load Once.
 * @param [out]  load_always     - Load Always.
 */
int portmod_port_timesync_load_ctrl_get(int unit, int port, uint32* load_once, uint32* load_always);

/*! 
 * portmod_port_timesync_tx_timestamp_offset_set
 *
 * @brief "port timesync tx timestamp offset set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  ts_offset       - TX AFE Delay in ns.
 */
int portmod_port_timesync_tx_timestamp_offset_set(int unit, int port, uint32 ts_offset);
/*! 
 * portmod_port_timesync_tx_timestamp_offset_get
 *
 * @brief "port timesync tx timestamp offset set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  ts_offset       - TX AFE Delay in ns.
 */
int portmod_port_timesync_tx_timestamp_offset_get(int unit, int port, uint32* ts_offset);

/*! 
 * portmod_port_timesync_rx_timestamp_offset_set
 *
 * @brief "port timesync rx timestamp offset set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  ts_offset       - RX AFE Delay in ns.
 */
int portmod_port_timesync_rx_timestamp_offset_set(int unit, int port, uint32 ts_offset);
/*! 
 * portmod_port_timesync_rx_timestamp_offset_get
 *
 * @brief "port timesync rx timestamp offset set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  ts_offset       - RX AFE Delay in ns.
 */
int portmod_port_timesync_rx_timestamp_offset_get(int unit, int port, uint32* ts_offset);

/*! 
 * portmod_port_phy_intr_enable_set
 *
 * @brief "port timesync interrupt mask set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  intr_enable     - Interrupt Eanble.
 */
int portmod_port_phy_intr_enable_set(int unit, int port, uint32 intr_enable);
/*! 
 * portmod_port_phy_intr_enable_get
 *
 * @brief "port timesync interrupt mask set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  intr_enable     - Interrupt Eanble.
 */
int portmod_port_phy_intr_enable_get(int unit, int port, uint32* intr_enable);

/*! 
 * portmod_port_phy_intr_status_get
 *
 * @brief "port phy interrupt status get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  intr_status     - Interrupt Status.
 */
int portmod_port_phy_intr_status_get(int unit, int port, uint32* intr_status);

/*! 
 * portmod_port_phy_intr_status_clear
 *
 * @brief "port phy interrupt status clear" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int portmod_port_phy_intr_status_clear(int unit, int port);

/*! 
 * portmod_port_phy_timesync_do_sync
 *
 * @brief "port timesync force frame sync." 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int portmod_port_phy_timesync_do_sync(int unit, int port);

/*! 
 * portmod_port_timesync_capture_timestamp_get
 *
 * @brief "port timesync capture timestamp get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  cap_ts          - Capture Timestamp.
 */
int portmod_port_timesync_capture_timestamp_get(int unit, int port, uint64* cap_ts);

/*! 
 * portmod_port_timesync_heartbeat_timestamp_get
 *
 * @brief "port timesync heartbeat timestamp get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  hb_ts           - Heartbeat Timestamp.
 */
int portmod_port_timesync_heartbeat_timestamp_get(int unit, int port, uint64* hb_ts);

typedef phymod_edc_config_t portmod_edc_config_t;

/*! 
 * portmod_port_edc_config_set
 *
 * @brief "port timesync tx timestamp offset set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  config          - Electronic Dispersion Compensation config.
 */
int portmod_port_edc_config_set(int unit, int port, const portmod_edc_config_t* config);
/*! 
 * portmod_port_edc_config_get
 *
 * @brief "port timesync tx timestamp offset set/get" 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  config          - Electronic Dispersion Compensation config..
 */
int portmod_port_edc_config_get(int unit, int port, portmod_edc_config_t* config);

/*! 
 * portmod_port_interrupt_enable_set
 *
 * @brief set/get interrupt enable value.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  intr_type       - portmod_intr_type_t enum
 * @param [out]  val             - value write
 */
int portmod_port_interrupt_enable_set(int unit, int port, int intr_type, uint32 val);
/*! 
 * portmod_port_interrupt_enable_get
 *
 * @brief set/get interrupt enable value.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  intr_type       - portmod_intr_type_t enum
 * @param [out]  val             - value read
 */
int portmod_port_interrupt_enable_get(int unit, int port, int intr_type, uint32* val);

/*! 
 * portmod_port_interrupt_get
 *
 * @brief get interrupt status value.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  intr_type       - portmod_intr_type_t enum
 * @param [out]  val             - value read
 */
int portmod_port_interrupt_get(int unit, int port, int intr_type, uint32* val);

/*! 
 * portmod_port_interrupts_get
 *
 * @brief get interrupt value array.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  arr_max_size    - maximum size of output array
 * @param [out]  intr_arr        - array of intr status
 * @param [out]  size            - actual siz of output array
 */
int portmod_port_interrupts_get(int unit, int port, int arr_max_size, uint32* intr_arr, uint32* size);

#define PORTMOD_PORT_REG_ACCESS_DEFAULT (0)
#define PORTMOD_PORT_REG_ACCESS_DIRECT (1)

#define PORTMOD_PORT_PGW_CONFIGURE (0)
#define PORTMOD_PORT_PGW_MAC_RESET (1)
#define PORTMOD_PORT_PGW_POWER_SAVE (2)
#define PORTMOD_PORT_PGW_MAC_UNRESET (3)


/*!
 * @enum portmod_stat_val_e
 * @brief portmod statistics  
 */ 
typedef enum portmod_stat_val_e {
    portmodIfInOctets = 0,
    portmodIfInUcastPkts = 1,
    portmodIfInNUcastPkts = 2,
    portmodIfInBroadcastPkts = 3,
    portmodIfInMulticastPkts = 4,
    portmodIfInDiscards = 5,
    portmodIfInErrors = 6,
    portmodIfOutOctets = 7,
    portmodIfOutUcastPkts = 8,
    portmodIfOutNUcastPkts = 9,
    portmodIfOutBroadcastPkts = 10,
    portmodIfOutMulticastPkts = 11,
    portmodIfOutDiscards = 12,
    portmodIfOutErrors = 13,
    portmodIpInReceives = 14,
    portmodIpInHdrErrors = 15,
    portmodIpForwDatagrams = 16,
    portmodIpInDiscards = 17,
    portmodDot1dBasePortMtuExceededDiscards = 18,
    portmodDot1dTpPortInFrames = 19,
    portmodDot1dTpPortOutFrames = 20,
    portmodDot1dPortInDiscards = 21,
    portmodEtherStatsDropEvents = 22,
    portmodEtherStatsOctets = 23,
    portmodEtherStatsPkts = 24,
    portmodEtherStatsBroadcastPkts = 25,
    portmodEtherStatsMulticastPkts = 26,
    portmodEtherStatsCRCAlignErrors = 27,
    portmodEtherStatsUndersizePkts = 28,
    portmodEtherStatsOversizePkts = 29,
    portmodEtherRxOversizePkts = 30,
    portmodEtherTxOversizePkts = 31,
    portmodEtherStatsFragments = 32,
    portmodEtherStatsJabbers = 33,
    portmodEtherStatsPkts64Octets = 34,
    portmodEtherStatsPkts65to127Octets = 35,
    portmodEtherStatsPkts128to255Octets = 36,
    portmodEtherStatsPkts256to511Octets = 37,
    portmodEtherStatsPkts512to1023Octets = 38,
    portmodEtherStatsPkts1024to1518Octets = 39,
    portmodBcmEtherStatsPkts1519to1522Octets = 40,
    portmodBcmEtherStatsPkts1522to2047Octets = 41,
    portmodBcmEtherStatsPkts2048to4095Octets = 42,
    portmodBcmEtherStatsPkts4095to9216Octets = 43,
    portmodBcmEtherStatsPkts9217to16383Octets = 44,
    portmodBcmReceivedPkts64Octets = 45,
    portmodBcmReceivedPkts65to127Octets = 46,
    portmodBcmReceivedPkts128to255Octets = 47,
    portmodBcmReceivedPkts256to511Octets = 48,
    portmodBcmReceivedPkts512to1023Octets = 49,
    portmodBcmReceivedPkts1024to1518Octets = 50,
    portmodBcmReceivedPkts1519to2047Octets = 51,
    portmodBcmReceivedPkts2048to4095Octets = 52,
    portmodBcmReceivedPkts4095to9216Octets = 53,
    portmodBcmReceivedPkts9217to16383Octets = 54,
    portmodBcmTransmittedPkts64Octets = 55,
    portmodBcmTransmittedPkts65to127Octets = 56,
    portmodBcmTransmittedPkts128to255Octets = 57,
    portmodBcmTransmittedPkts256to511Octets = 58,
    portmodBcmTransmittedPkts512to1023Octets = 59,
    portmodBcmTransmittedPkts1024to1518Octets = 60,
    portmodBcmTransmittedPkts1519to2047Octets = 61,
    portmodBcmTransmittedPkts2048to4095Octets = 62,
    portmodBcmTransmittedPkts4095to9216Octets = 63,
    portmodBcmTransmittedPkts9217to16383Octets = 64,
    portmodEtherStatsTXNoErrors = 65,
    portmodEtherStatsRXNoErrors = 66,
    portmodDot3StatsFCSErrors = 67,
    portmodDot3StatsInternalMacTransmitErrors = 68,
    portmodDot3StatsFrameTooLongs = 69,
    portmodDot3StatsSymbolErrors = 70,
    portmodDot3ControlInUnknownOpcodes = 71,
    portmodDot3InPauseFrames = 72,
    portmodDot3OutPauseFrames = 73,
    portmodIfHCInOctets = 74,
    portmodIfHCInUcastPkts = 75,
    portmodIfHCInMulticastPkts = 76,
    portmodIfHCInBroadcastPkts = 77,
    portmodIfHCOutOctets = 78,
    portmodIfHCOutUcastPkts = 79,
    portmodIfHCOutMulticastPkts = 80,
    portmodIfHCOutBroadcastPckts = 81,
    portmodIpv6IfStatsInReceives = 82,
    portmodIpv6IfStatsInHdrErrors = 83,
    portmodIpv6IfStatsInAddrErrors = 84,
    portmodIpv6IfStatsInDiscards = 85,
    portmodIpv6IfStatsOutForwDatagrams = 86,
    portmodIpv6IfStatsOutDiscards = 87,
    portmodIpv6IfStatsInMcastPkts = 88,
    portmodIpv6IfStatsOutMcastPkts = 89,
    portmodIeee8021PfcRequests = 90,
    portmodIeee8021PfcIndications = 91,
    portmodBcmIPMCBridgedPckts = 92,
    portmodBcmIPMCRoutedPckts = 93,
    portmodBcmIPMCInDroppedPckts = 94,
    portmodBcmIPMCOutDroppedPckts = 95,
    portmodBcmRxVlanTagFrame = 96,
    portmodBcmRxDoubleVlanTagFrame = 97,
    portmodBcmTxVlanTagFrame = 98,
    portmodBcmTxDoubleVlanTagFrame = 99,
    portmodBcmRxPFCControlFrame = 100,
    portmodBcmTxPFCControlFrame = 101,
    portmodBcmRxPFCFramePriority0 = 102,
    portmodBcmRxPFCFramePriority1 = 103,
    portmodBcmRxPFCFramePriority2 = 104,
    portmodBcmRxPFCFramePriority3 = 105,
    portmodBcmRxPFCFramePriority4 = 106,
    portmodBcmRxPFCFramePriority5 = 107,
    portmodBcmRxPFCFramePriority6 = 108,
    portmodBcmRxPFCFramePriority7 = 109,
    portmodBcmTxPFCFramePriority0 = 110,
    portmodBcmTxPFCFramePriority1 = 111,
    portmodBcmTxPFCFramePriority2 = 112,
    portmodBcmTxPFCFramePriority3 = 113,
    portmodBcmTxPFCFramePriority4 = 114,
    portmodBcmTxPFCFramePriority5 = 115,
    portmodBcmTxPFCFramePriority6 = 116,
    portmodBcmTxPFCFramePriority7 = 117,
    portmodCount
} portmod_stat_val_t;

#ifdef PORTMOD_DIAG
extern enum_mapping_t portmod_stat_val_t_mapping[];
#endif /*PORTMOD_DIAG*/

/* portmod_stat_val_t validation */
int portmod_stat_val_t_validate(int unit, portmod_stat_val_t portmod_stat_val);
/*! 
 * portmod_port_stats_read
 *
 * @brief  portmod stats read  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  cntr_type       - counter type
 * @param [out]  value           - read value
 */
int portmod_port_stats_read(int unit, int port, portmod_stat_val_t cntr_type, uint64* value);

/*! 
 * portmod_port_stats_clear
 *
 * @brief  portmod stats clear  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  cntr_type       - counter type
 */
int portmod_port_stats_clear(int unit, int port, portmod_stat_val_t cntr_type);

/*! 
 * portmod_port_check_legacy_phy
 *
 * @brief  portmod check if external phy is legacy 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  legacy_phy      - check if phy is legacy
 */
int portmod_port_check_legacy_phy(int unit, int port, int* legacy_phy);

/*! 
 * portmod_port_failover_mode_set
 *
 * @brief  portmod phy failover mode 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  failover        - Failover Mode set
 */
int portmod_port_failover_mode_set(int unit, int port, phymod_failover_mode_t failover);
/*! 
 * portmod_port_failover_mode_get
 *
 * @brief  portmod phy failover mode 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  failover        - Failover Mode get
 */
int portmod_port_failover_mode_get(int unit, int port, phymod_failover_mode_t* failover);



/*! 
 * portmod_port_warmboot_db_restore
 *
 * @brief  portmod restore information after warmboot 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  intf_config     - 
 * @param [in]  init_config     - 
 * @param [in]  phy_op_mode     - 
 */
int portmod_port_warmboot_db_restore(int unit, int port, const portmod_port_interface_config_t* intf_config, const portmod_port_init_config_t* init_config, phymod_operation_mode_t phy_op_mode);

/*! 
 * portmod_port_flow_control_set
 *
 * @brief  portmod port flow control config 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  merge_mode_en   - merge_mode
 * @param [in]  parallel_fc_en   - Parallel Flow control enable
 */
int portmod_port_flow_control_set(int unit, int port, int merge_mode_en, int parallel_fc_en);


/*! 
 * @brief Flags for phy init 
 */ 
#define PORTMOD_INIT_F_EXTERNAL_MOST_ONLY 0 /**< init external most phy */
#define PORTMOD_INIT_F_ALL_PHYS 1 /**< init all phys */
#define PORTMOD_INIT_F_INTERNAL_SERDES_ONLY 2 /**< init internal serdes */
#define PORTMOD_INIT_F_EXTERNAL_PHYS_ONLY 3 /**< init external phys */

/*! 
 * portmod_port_update_dynamic_state
 *
 * @brief Portmod state for any logical port dynamixc settings 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  port_dynamic_state   - flag to specify if the user updated any HW params from its defauklt value
 */
int portmod_port_update_dynamic_state(int unit, int port, uint32_t port_dynamic_state);

/*! 
 * portmod_port_phy_op_mode_get
 *
 * @brief get phy operation mode.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  val             - value read
 */
int portmod_port_phy_op_mode_get(int unit, int port, phymod_operation_mode_t* val);

/*! 
 * portmod_port_lane_map_set
 *
 * @brief override function for board lane swap.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  lane_map        - lane map
 */
int portmod_port_lane_map_set(int unit, int port, const phymod_lane_map_t* lane_map);
/*! 
 * portmod_port_lane_map_get
 *
 * @brief override function for board lane swap.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  lane_map        - lane map
 */
int portmod_port_lane_map_get(int unit, int port, phymod_lane_map_t* lane_map);

/*! 
 * portmod_port_polarity_set
 *
 * @brief override function for board lane swap.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  polarity        - polarity
 */
int portmod_port_polarity_set(int unit, int port, const phymod_polarity_t* polarity);
/*! 
 * portmod_port_polarity_get
 *
 * @brief override function for board lane swap.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  polarity        - polarity
 */
int portmod_port_polarity_get(int unit, int port, phymod_polarity_t* polarity);

/*! 
 * portmod_port_medium_config_set
 *
 * @brief set/get port medium type config.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  medium          - port medium
 * @param [out]  config          - phy config
 */
int portmod_port_medium_config_set(int unit, int port, soc_port_medium_t medium, soc_phy_config_t* config);
/*! 
 * portmod_port_medium_config_get
 *
 * @brief set/get port medium type config.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  medium          - port medium
 * @param [out]  config          - phy config
 */
int portmod_port_medium_config_get(int unit, int port, soc_port_medium_t medium, soc_phy_config_t* config);

/*! 
 * portmod_port_medium_get
 *
 * @brief get port medium type.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  medium          - port medium
 */
int portmod_port_medium_get(int unit, int port, soc_port_medium_t* medium);




/*!
 * @struct portmod_port_resources_s
 * @brief portmod port resources for flex port 
 */ 
typedef struct portmod_port_resources_s {
    portmod_dispatch_type_t pm_type; /**< portmod dispatch type */
    int speed; /**< speed at which port will be flexed */
    int num_lane; /**< lanes of flex port */
    portmod_encap_t encap_mode; /**< flex port encap mode */
} portmod_port_resources_t;

/* portmod_port_resources_t initialization and validation */
int portmod_port_resources_t_validate(int unit, const portmod_port_resources_t* portmod_port_resources);
int portmod_port_resources_t_init(int unit, portmod_port_resources_t* portmod_port_resources);

/*! 
 * portmod_pm_port_pll_div_get
 *
 * @brief dispatch [portmacro]_pll_div_get based on the pm_type in portmod_port_resources_t 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port_resource   - port resource
 * @param [out]  pll_div         -  pll div
 */
int portmod_pm_port_pll_div_get(int unit, const portmod_port_resources_t* port_resource, uint32_t* pll_div);


/*! 
 * portmod_port_master_get
 *
 * @brief get the port master mode if the port is running SGMII AN 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  master_mode     - port master mode
 */
int portmod_port_master_get(int unit, int port, int* master_mode);


#endif /*_PORTMOD_H_*/
