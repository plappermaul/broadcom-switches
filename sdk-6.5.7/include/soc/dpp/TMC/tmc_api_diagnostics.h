/* $Id$
 * $Copyright: (c) 2016 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
*/

#ifndef __SOC_TMC_API_DIAGNOSTICS_INCLUDED__
/* { */
#define __SOC_TMC_API_DIAGNOSTICS_INCLUDED__

/*************
 * INCLUDES  *
 *************/
/* { */

#include <soc/dpp/SAND/Utils/sand_header.h>

#include <soc/dpp/SAND/Management/sand_general_macros.h>
#include <soc/dpp/SAND/Management/sand_error_code.h>
#include <soc/dpp/SAND/Management/sand_general_macros.h>
#include <soc/dpp/SAND/Utils/sand_integer_arithmetic.h>
#include <soc/dpp/SAND/Utils/sand_64cnt.h>

#include <soc/dpp/TMC/tmc_api_general.h>
#include <soc/dpp/TMC/tmc_api_mgmt.h>
#include <soc/dpp/TMC/tmc_api_statistics.h>
#include <soc/dpp/TMC/tmc_api_end2end_scheduler.h>
#include <soc/dpp/TMC/tmc_api_ingress_packet_queuing.h>
#include <soc/dpp/TMC/tmc_api_ingress_traffic_mgmt.h>
#include <soc/dpp/TMC/tmc_api_egr_queuing.h>
#include <soc/dpp/TMC/tmc_api_ports.h>
/* } */
/*************
 * DEFINES   *
 *************/
/* { */






#define SOC_TMC_DIAG_LAST_PCKT_SNAPSHOT_LEN_BYTES_PB                (64)
#define SOC_TMC_DIAG_LAST_PCKT_SNAPSHOT_LEN_BYTES_ARAD              (128)
#define SOC_TMC_DIAG_LAST_PCKT_SNAPSHOT_LEN_BYTES_MAX               SOC_SAND_MAX(SOC_TMC_DIAG_LAST_PCKT_SNAPSHOT_LEN_BYTES_ARAD, SOC_TMC_DIAG_LAST_PCKT_SNAPSHOT_LEN_BYTES_PB)

/* $Id$
 * Run QDR BIST till stop/get-result API
 * is called (soc_tmcdiag_qdr_BIST_test_result_get)
 */

/*
 * Run QDR BIST till stop/get-result API
 * is called (soc_tmcdiag_dram_BIST_test_result_get)
 */


/*
 *  DRAM status
 */
#define SOC_TMC_DIAG_NOF_DDR_TRAIN_SEQS               8
#define SOC_TMC_DIAG_NOF_DLLS_PER_DRAM                4

/*
 * Maximum size of received/sent packets in bytes
 */
#define SOC_TMC_DIAG_LBG_PAYLOAD_BYTE_SIZE         (256)

/*     Number of DQSs.                                         */
#define  DIAG_DRAM_NOF_DQSS 4

/*     Select all SMSs.                                        */

/*     Number of SMSes in Soc_petra                                */

/*     Maximal number of SONEs per SMS in Soc_petra                */
#define  SOC_TMC_DIAG_NOF_SONE_PER_SMS_MAX (8192)

/*     Maximal length (in longs) of the diagnostic chain.      */
#define  SOC_TMC_DIAG_CHAIN_LENGTH_MAX_IN_UINT32S (144)

/* } */
/*************
 * MACROS    *
 *************/
/* { */

/* } */

/*************
 * TYPE DEFS *
 *************/
/* { */

typedef enum
{
  SOC_TMC_DIAG_PKT_HDR_U_TYPE      = 0x8,
  SOC_TMC_DIAG_PKT_HDR_F_TYPE      = 0x9,
  SOC_TMC_DIAG_PKT_HDR_M_TYPE      = 0xA,
  SOC_TMC_DIAG_PKT_HDR_IN_RCY_TYPE = 0xC,

  /*
   * Un-known type.
   * This type do not exist in the device.
   */
  SOC_TMC_DIAG_PKT_HDR_UNKOWN_TYPE = 0xFF

} SOC_TMC_DIAG_ING_PKT_HDR_TYPE;

/************************************************************************/
/* BIST info                                                            */
/************************************************************************/

typedef enum
{
  /*
   *  Normal mode. Starting from start address to end address.
   */
  SOC_TMC_DIAG_QDR_BIST_ADDR_MODE_NORMAL=0,
  /*
   *  Every write command the address is shifted in cyclic
   *  manner one bit left. Address is reset if it exceeds End
   *  Address. Intended for walking one / walking zero tests.
   */
  SOC_TMC_DIAG_QDR_BIST_ADDR_MODE_ADDRESS_SHIFT=1,
  /*
   *  Writes walking ones and zeros on the address bus and
   *  finds if any address bit is defective. If this mode
   *  chosen for address selection then it also override the
   *  data mode.
   */
  SOC_TMC_DIAG_QDR_BIST_ADDR_MODE_ADDRESS_TEST=2,

  SOC_TMC_DIAG_NOF_QDR_BIST_ADDR_MODES=3
}SOC_TMC_DIAG_QDR_BIST_ADDR_MODE;

typedef enum
{
  /*
   *  Normal mode. Write incrementally each of the pattern
   *  words.
   */
  SOC_TMC_DIAG_QDR_BIST_DATA_MODE_NORMAL=0,
  /*
   *  Every write command one-bit data from the BistPattern is
   *  duplicated on the entire data bus. For one burst of 2
   *  commands, 2 consecutive bits are used. All 32b of every
   *  BistPattern word are used in this mode.
   */
  SOC_TMC_DIAG_QDR_BIST_DATA_MODE_PATTERN_BIT=1,
  /*
   *  Every write command is random data, generated by
   *  x^31+x^28+1 polynomial. For one burst of two commands, 2
   *  consecutive 26b data writes are done.
   */
  SOC_TMC_DIAG_QDR_BIST_DATA_MODE_RANDOM=2,
  /*
   *  Every write command the data is shifted in cyclic manner
   *  one bit left. For one burst of 2 commands, 2 consecutive
   *  shifts are done. Only BistPattern0 word is used in this
   *  mode. Intended for walking one / walking zero tests.
   */
  SOC_TMC_DIAG_QDR_BIST_DATA_MODE_DATA_SHIFT=3,

  SOC_TMC_DIAG_NOF_QDR_BIST_DATA_MODES=4
}SOC_TMC_DIAG_QDR_BIST_DATA_MODE;

typedef enum
{
  /*
   *  Fill the data to write by 1010101... (Bits). The DATA_MODE
   *  may use this data pattern in different ways see
   *  SOC_TMC_DIAG_QDR_BIST_DATA_MODE. Random mode ignores these
   *  values.
   */
  SOC_TMC_DIAG_BIST_DATA_PATTERN_DIFF=0,
  /*
   *  Fill the data to write by 11111111... (Bits). The DATA_MODE
   *  may use this data pattern in different ways see
   *  SOC_TMC_DIAG_QDR_BIST_DATA_MODE. Random mode ignores these
   *  values.
   */
  SOC_TMC_DIAG_BIST_DATA_PATTERN_ONE=1,
  /*
   *  Fill the data to write by 00000000... (Bits). The DATA_MODE
   *  may use this data pattern in different ways see
   *  SOC_TMC_DIAG_QDR_BIST_DATA_MODE. Random mode ignores these
   *  values.
   */
  SOC_TMC_DIAG_BIST_DATA_PATTERN_ZERO=2,
  SOC_TMC_DIAG_NOF_BIST_DATA_PATTERNS=3
}SOC_TMC_DIAG_BIST_DATA_PATTERN;

typedef enum
{
  /*
   *  Normal mode. Write incrementally each of the pattern
   *  words.
   */
  SOC_TMC_DIAG_DRAM_BIST_DATA_MODE_NORMAL=0,
  /*
   *  The BIST composes the write/read pattern in the
   *  following manner. For each cycle, a different bit is
   *  selected from the BIST pattern register in an ncremental
   *  manner. This bit is duplicated on all of the DRAM data
   *  bus (all DQs receive the same bit). This allows a
   *  controllable pattern that is 256 write cycles long.
   */
  SOC_TMC_DIAG_DRAM_BIST_DATA_MODE_PATTERN_BIT=1,
  /*
   *  The PRBS will be used to generate the pattern towards
   *  the DRAM.
   */
  SOC_TMC_DIAG_DRAM_DATA_MODE_RANDOM=2,
  SOC_TMC_DIAG_NOF_DRAM_BIST_DATA_MODES =3
}SOC_TMC_DIAG_DRAM_BIST_DATA_MODE;

typedef enum
{
  /*
   *  Fill the data to write by 1111... (Bits).
   */
  SOC_TMC_DIAG_SOFT_ERROR_PATTERN_ONE = 0,
  /*
   *  Fill the data to write by 000... (Bits).
   */
  SOC_TMC_DIAG_SOFT_ERROR_PATTERN_ZERO = 1,
  /*
   *  Fill the data to write by 1010101... (Bits).
   */
  SOC_TMC_DIAG_SOFT_ERROR_PATTERN_DIFF1 = 2,
  /*
   *  Fill the data to write by 0101010... (Bits).
   */
  SOC_TMC_DIAG_SOFT_ERROR_PATTERN_DIFF2 = 3,
  /*
   *  Number of types in SOC_TMC_DIAG_SOFT_ERROR_PATTERN
   */
  SOC_TMC_NOF_DIAG_SOFT_ERROR_PATTERNS = 4
}SOC_TMC_DIAG_SOFT_ERROR_PATTERN;

typedef enum
{
  /*
   *  The error count is done per SMS (but not per SONE).
   */
  SOC_TMC_DIAG_SOFT_COUNT_TYPE_FAST = 0,
  /*
   *  The error count is done per SMS, and per SONE.
   */
  SOC_TMC_DIAG_SOFT_COUNT_TYPE_COMPLETE = 1,
  /*
   *  Number of types in SOC_TMC_DIAG_SOFT_COUNT_TYPE
   */
  SOC_TMC_NOF_DIAG_SOFT_COUNT_TYPES = 2
}SOC_TMC_DIAG_SOFT_COUNT_TYPE;

typedef struct
{
  SOC_SAND_MAGIC_NUM_VAR
  /*
   *  Number of Write commands to execute in one full bist
   *  test. Range: 1 - 0xFFFFFFFF. Use
   *  DIAG_QDR_BIST_INFINITE_TEST(0) to run the test till
   *  stop/get_result API is called.
   */
  uint32 nof_cmnds_write;
  /*
   *  Number of Read commands to execute in one full bist
   *  test. Range: 1 - 0xFFFFFFFF. Note: if nof_cmnds_write is
   *  DIAG_QDR_BIST_INFINITE_TEST(0), the test runs till
   *  stop/get_result API is called, and this field has no
   *  affect.
   */
  uint32 nof_cmnds_read;
  /*
   *  start address of the Bist test commands.
   */
  uint32 start_addr;
  /*
   *  start address of the Bist test commands. If end address
   *  is reached, address is reset to the initial write or
   *  read address.
   */
  uint32 end_addr;
  /*
   *  The read offset, in number-of-commands. If non-zero, the
   *  read is performed starting with this offset of commands
   *  from the write commands start_address. The read is only
   *  performed after the appropriate write command.
   */
  uint32 read_offset;
  /*
   *  The way to build the test data from the data patterns.
   */
  SOC_TMC_DIAG_QDR_BIST_DATA_MODE data_mode;
  /*
   *  The mode to jump between the addresses
   */
  SOC_TMC_DIAG_QDR_BIST_ADDR_MODE address_mode;
  /*
   *  How to build the initial data to write to the memory,
   *  the data_mode may use this data_patern differently.
   */
  SOC_TMC_DIAG_BIST_DATA_PATTERN data_pattern;
}SOC_TMC_DIAG_QDR_BIST_TEST_RUN_INFO;

typedef struct
{
  SOC_SAND_MAGIC_NUM_VAR
  /*
   *  If TRUE, the tests finished. Otherwise - the test is
   *  in-progress, or did not start.
   */
  uint8 is_test_finished;
  /*
   *  Tests the QDR 'ready' bit, indicating the QDR interface
   *  is up.
   */
   uint8 is_qdr_up;
  /*
   *  Number of bit errors that appeared on one reply. This
   *  may increase according to the number of bit errors on
   *  the reply.
   */
  uint32 bit_err_counter;
  /*
   *  Number of errors that appeared on one reply. This may
   *  increase by 1 for every reply, regardless of the number
   *  of different bit errors on the reply.
   */
  uint32 reply_err_counter;
  /*
   *  Indicates for each of the 18 bits if there was error. A
   *  bit is set if an error has occurred on it any time
   *  during the test. Each bit is equivalent to a bit on the
   *  external QDR data bus.
   */
  uint32 bits_error_bitmap;
  /*
   *  The address of the last erroneous burst reply
   */
  uint32 last_addr_err;
  /*
   *  The data of the last erroneous burst reply.
   */
  uint32 last_data_err;
}SOC_TMC_DIAG_QDR_BIST_TEST_RES_INFO;

typedef struct
{
  SOC_SAND_MAGIC_NUM_VAR
  /*
   *  If True the test runs indefinitely (until the
   *  mechanism BIST is disabled or the get result
   *  function is called). Otherwise, it runs only once.
   */
  uint8 is_finite_nof_cmnds;
  /*
   *  Number of Write commands per cycle. Range 0-225. 0 then
   *  no write will be performed.
   */
  uint32 writes_per_cycle;
  /*
   *  Number of Read commands per cycle. Range 0-225. 0 then
   *  no Read will be performed.
   */
  uint32 reads_per_cycle;
  /*
   *  Start address (offset) of the Bist test commands.
   *  The address must be a multiple of 32 Bytes.
   *  Units: Bytes. Range: 0 - DRAM size-32.
   */
  uint32 start_addr;
  /*
   *  End address (offset) of the Bist test commands. If end address is
   *  reached, address is reset to the initial write or read
   *  address. The format is the same as the start address.
   */
  uint32 end_addr;
  /*
   *  The way to build the test data from the data patterns.
   */
  SOC_TMC_DIAG_DRAM_BIST_DATA_MODE data_mode;
  /*
   *  How to build the initial data to write to the memory,
   *  the data_mode may use this data_pattern differently.
   */
  SOC_TMC_DIAG_BIST_DATA_PATTERN data_pattern;
}SOC_TMC_DIAG_DRAM_BIST_TEST_RUN_INFO;

typedef struct
{
  SOC_SAND_MAGIC_NUM_VAR
  /*
   * If TRUE, the tests finished.
   * Otherwise - the test is in-progress, or did not start.
   */
   uint8 is_test_finished;

  /*
   *  Tests the DRAM 'ready' bit, indicating
   *  the DRAM interface is up
   */
   uint8 is_dram_up;

  /*
   *  Number of errors that appeared on one reply. This may
   *  increase by 1 for every reply, regardless of the number
   *  of different bit errors on the reply.
   */
  uint32 reply_err_counter;
}SOC_TMC_DIAG_DRAM_BIST_TEST_RES_INFO;

typedef struct
{
  SOC_SAND_MAGIC_NUM_VAR
  /*
   *  Address to written in. Units: bytes. Alignment: 32
   *  bytes. The value must be inferior to the DRAM size - 32
   *  bytes.
   */
  uint32 address;
  /*
   *  If true, the buffer is 256 bits long. Otherwise, it is
   *  32 bits long and is duplicated 8 times to form the
   *  pattern.
   */
  uint8 is_data_size_bits_256_not_32;
  /*
   *  If true, the actions (writing / reading) are performed
   *  until stopped by the user by disabling the BIST.
   */
  uint8 is_infinite_nof_actions;
}SOC_TMC_DIAG_DRAM_ACCESS_INFO;

typedef struct
{
  SOC_SAND_MAGIC_NUM_VAR
  /*
   *  If true, all the reading actions have happened and for
   *  each address, the expected pattern has been found.
   */
  uint8 success;
  /*
   *  This field has 32 bits. If bit N equals '1', it
   *  indicates that at least in one address with a failed
   *  comparison, a difference has been found in the bit N, or
   *  N + 32,..., or N + 224 during the comparison with the
   *  expected pattern.
   */
  uint32 error_bits_global;
  /*
   *  Indicates the number of addresses whose pattern was
   *  found different during the comparison with the expected
   *  pattern.
   */
  uint32 nof_addr_with_errors;
}SOC_TMC_DIAG_DRAM_READ_COMPARE_STATUS;

typedef struct
{
  SOC_SAND_MAGIC_NUM_VAR
  /*
   *
   */
  uint8  valid;
  /*
   *
   */
  uint32 queue_qrtt;
  /*
   *
   */
  uint32 queue_id;
  /*
   *
   */
  uint32 flow_qrtt;
  /*
   *
   */
  uint32 flow_id;
  /*
   *
   */
  uint8 is_composite;
  /*
   *
   */
  uint32 sys_phy_port;
  /*
   *
   */
  uint32 dst_fap_id;
  /*
   *
   */
  uint32 dst_prt_id;
}SOC_TMC_DIAG_PACKET_WALKTROUGH;

typedef union
{
  /*
   *
   */
  struct
  {
    SOC_SAND_MAGIC_NUM_VAR
    /*
     *
     */
    uint32  destination_id;
    /*
     *
     */
    uint32 drp;
    /*
     *
     */
    uint32 snoop_cmd;
    /*
     *
     */
    uint32 class_val;
  } unicast;

  /*
   *
   */
  struct
  {
    SOC_SAND_MAGIC_NUM_VAR
    /*
     *
     */
    uint32 flow_id;
    /*
     *
     */
    uint32 drp;
    /*
     *
     */
    uint32 snoop_cmd;
  } flow;

  /*
   *
   */
  struct
  {
    SOC_SAND_MAGIC_NUM_VAR
    /*
     *
     */
    uint32 source_port_addr;
    /*
     *
     */
    uint32 multicast_id;
    /*
     *
     */
    uint32 drp;
    /*
     *
     */
    uint32 snoop_cmd;
    /*
     *
     */
    uint32 exclude_src;
    /*
     *
     */
    uint32 class_val;
  } multicast;

} SOC_TMC_DIAG_ING_PKT_HDR_DATA;

typedef struct
{
  SOC_SAND_MAGIC_NUM_VAR
  /*
   *  Up to 256 byte Data to carry on packet
   */
  uint8 data[SOC_TMC_DIAG_LBG_PAYLOAD_BYTE_SIZE];
  /*
   *  Number of bytes in packet
   */
  uint32 data_byte_size;

}SOC_TMC_DIAG_LBG_PACKET_PATTERN;

typedef struct
{
  SOC_SAND_MAGIC_NUM_VAR
 /*
  * Packet data and size
  * If packet size is less then pattern size, only a part of pattern is taken.
  * If packet size is more then pattern size, the pattern is duplicated up
  * to the packet size.
  */
  SOC_TMC_DIAG_LBG_PACKET_PATTERN pattern;
 /*
  * Packet size in bytes
  */
  uint32 packet_size;
 /*
  * number of packets to send from the CPU.
  * These packets will be sent in a burst.
  * and will be forwarded in the defined loop
  */
  uint32 nof_packets;
}SOC_TMC_DIAG_LBG_TRAFFIC_INFO;

typedef struct
{
  SOC_SAND_MAGIC_NUM_VAR
 /*
  * Soc_petra counters
  */
  SOC_TMC_STAT_ALL_STATISTIC_COUNTERS counters;
 /*
  * traffic rate in the ingress (Kbps)
  */
  uint32 ingress_rate;
 /*
  * traffic rate in the Egress (Kbps)
  */
  uint32 egress_rate;
 /*
  * credits in (Kbps)
  */
  uint32 credits;
}SOC_TMC_DIAG_LBG_RESULT_INFO;

typedef struct
{
  SOC_SAND_MAGIC_NUM_VAR
 /*
  * ports that are part of the LBG test.
  */
  uint32 ports[SOC_TMC_NOF_FAP_PORTS];
 /*
  *  number of ports
  */
  uint32 nof_ports;
}SOC_TMC_DIAG_LBG_PATH_INFO;

typedef struct
{
  SOC_SAND_MAGIC_NUM_VAR
   /*
    * the path packet will go through
    */
    SOC_TMC_DIAG_LBG_PATH_INFO     path;
}SOC_TMC_DIAG_LBG_INFO;

typedef struct
{
  SOC_SAND_MAGIC_NUM_VAR
  /*
   *
   */
  uint32 ddl_control_0;
  /*
   *
   */
  uint32 ddl_control_1;
  /*
   *
   */
  uint32 ddl_control_2;
  /*
   *
   */
  uint8 rnd_trp;
  /*
   *
   */
  uint8 rnd_trp_diff;
  /*
   *
   */
  uint8 dll_init_done;
  /*
   *
   */
  uint8 dll_ph_dn;
  /*
   *
   */
  uint8 dll_ph_up;
  /*
   *
   */
  uint8 main_ph_sel;
  /*
   *
   */
  uint8 ph2sel;
  /*
   *
   */
  uint8 hc_sel_vec;
  /*
   *
   */
  uint8 qc_sel_vec;
  /*
   *
   */
  uint8 sel_vec;
  /*
   *
   */
  uint8 sel_hg;
  /*
   *
   */
  uint8 ph_sel_hc_up;
  /*
   *
   */
  uint8 ins_dly_min_vec;
  /*
   *
   */
  uint8 ddl_init_main_ph_sel_ofst;
  /*
   *
   */
  uint8 ddl_ph_sel_hc_up;
  /*
   *
   */
  uint8 ddl_train_trig_up_limit;
  /*
   *
   */
  uint8 ddl_train_trig_dn_limit;
  /*
   *
   */
  uint8 ph_sel_err;
  /*
   *
   */
  uint8 dly_max_min_mode;
  /*
   *
   */
  uint8 ph_sel;
}SOC_TMC_DIAG_DLL_STATUS_INFO;

typedef struct
{
  SOC_SAND_MAGIC_NUM_VAR
  /*
   *
   */
  uint32 training_seq;
  /*
   *
   */
  uint32 calibration_st;
  /*
   *
   */
  uint32 ddl_periodic_training;
  /*
   *
   */
  uint8 dll_mstr_s;
  /*
   *
   */
  uint32 ddr_training_sequence[SOC_TMC_DIAG_NOF_DDR_TRAIN_SEQS];
  /*
   *  Status of the 4 DLLs.
   */
  SOC_TMC_DIAG_DLL_STATUS_INFO dll_status[SOC_TMC_DIAG_NOF_DLLS_PER_DRAM];
}SOC_TMC_DIAG_DRAM_STATUS_INFO;

typedef struct
{
  SOC_SAND_MAGIC_NUM_VAR
  /*
   *  Bitmap of the erroneous bits (i.e., with a problematic
   *  connectivity) in the training sequence operation.
   */
  uint32 bit_err_bitmap;
  /*
   *  If True, then the DRAM interface has a clocking problem
   *  due to the PLL configuration.
   */
  uint8 is_clocking_err;
  /*
   *  If True, then the respective DQS has a connectivity
   *  error.
   */
  uint8 is_dqs_con_err[DIAG_DRAM_NOF_DQSS];
  /*
   *  If True, then the PHY and DPI initialization is not
   *  done.
   */
  uint8 is_phy_ready_err;
  /*
   *  If True, then the average round trip time is too low.
   */
  uint8 is_rtt_avg_min_err;
  /*
   *  If True, then the average round trip time is too high.
   */
  uint8 is_rtt_avg_max_err;

}  SOC_TMC_DIAG_DRAM_ERR_INFO;

typedef struct
{
  SOC_SAND_MAGIC_NUM_VAR
  /*
   *  Pattern of the data written into the memories.
   */
  SOC_TMC_DIAG_SOFT_ERROR_PATTERN pattern;
  /*
   *  SMS index memory to write the pattern in. By default,
   *  write in each SMS (SOC_PETRA_DIAG_SMS_ALL value). Range: 1 -
   *  42.
   */
  uint32 sms;

} SOC_TMC_DIAG_SOFT_ERR_INFO;

typedef struct
{
  SOC_SAND_MAGIC_NUM_VAR
  /*
   *  Number of errors for SP memories.
   */
  uint32 err_sp;
  /*
   *  Number of errors for DP memories.
   */
  uint32 err_dp;
  /*
   *  Number of errors for RF memories.
   */
  uint32 err_rf;

} SOC_TMC_DIAG_SOFT_ERR_RESULT;

typedef struct
{
  SOC_SAND_MAGIC_NUM_VAR
  /*
   *  Diagnostic chain for this SMS * SONE
   */
  uint32 diag_chain[SOC_TMC_DIAG_CHAIN_LENGTH_MAX_IN_UINT32S];
  /*
   *  Number of errors per memory types per SMS and per SONE
   *  (for SONE index different from 0).
   */
  SOC_TMC_DIAG_SOFT_ERR_RESULT nof_errs;

} SOC_TMC_DIAG_SOFT_SMS_RESULT;

typedef struct
{
  SOC_SAND_MAGIC_NUM_VAR
  /*
   *  Packet received if TRUE. Arad only.
   */
  uint8 is_valid;
  /*
   *  TM-port. Range: 0 - 79.
   */
  uint32 tm_port;
  /*
   *  PP-port. Range: 0 - 63.
   */
  uint32 pp_port;
  /*
   *  Source-System-port.
   */
  uint32 src_syst_port;
  /*
   *  Header Processing type of the port on which the last
   *  packet was sampled (e.g. TM/Eth...)
   */
  SOC_TMC_PORT_HEADER_TYPE port_header_type;
  /*
   *  The ITMH fields information. Valid only if the port
   *  header type as indicated by the 'header_type' field is
   *  'TM'.
   */
  SOC_TMC_PORTS_ITMH itmh;
  /*
   *  The Packet outermost headers and payload
   */
  uint8 buffer[SOC_TMC_DIAG_LAST_PCKT_SNAPSHOT_LEN_BYTES_MAX];
  /*
   * The pavket size (in bytes)
   */
  uint32 packet_size;
} SOC_TMC_DIAG_LAST_PACKET_INFO;


/* } */

/*************
 * GLOBALS   *
 *************/
/* { */

/* } */

/*************
 * FUNCTIONS *
 *************/
/* { */

void
  SOC_TMC_DIAG_SOFT_ERR_INFO_clear(
    SOC_SAND_OUT SOC_TMC_DIAG_SOFT_ERR_INFO *info
  );

void
  SOC_TMC_DIAG_SOFT_ERR_RESULT_clear(
    SOC_SAND_OUT SOC_TMC_DIAG_SOFT_ERR_RESULT *info
  );

void
  SOC_TMC_DIAG_SOFT_SMS_RESULT_clear(
    SOC_SAND_OUT SOC_TMC_DIAG_SOFT_SMS_RESULT *info
  );

#if SOC_TMC_DEBUG_IS_LVL1

void
  SOC_TMC_DIAG_LBG_PACKET_PATTERN_print(
    SOC_SAND_IN SOC_TMC_DIAG_LBG_PACKET_PATTERN *info
  );

void
  SOC_TMC_DIAG_LBG_TRAFFIC_INFO_print(
    SOC_SAND_IN SOC_TMC_DIAG_LBG_TRAFFIC_INFO *info
  );

void
  SOC_TMC_DIAG_LBG_PATH_INFO_print(
    SOC_SAND_IN SOC_TMC_DIAG_LBG_PATH_INFO *info
  );

void
  SOC_TMC_DIAG_LBG_INFO_print(
    SOC_SAND_IN SOC_TMC_DIAG_LBG_INFO *info
  );

const char*
  SOC_TMC_DIAG_QDR_BIST_ADDR_MODE_to_string(
    SOC_SAND_IN SOC_TMC_DIAG_QDR_BIST_ADDR_MODE enum_val
  );

const char*
  SOC_TMC_DIAG_QDR_BIST_DATA_MODE_to_string(
    SOC_SAND_IN SOC_TMC_DIAG_QDR_BIST_DATA_MODE enum_val
  );

const char*
  SOC_TMC_DIAG_BIST_DATA_PATTERN_to_string(
    SOC_SAND_IN SOC_TMC_DIAG_BIST_DATA_PATTERN enum_val
  );

const char*
  SOC_TMC_DIAG_DRAM_BIST_DATA_MODE_to_string(
    SOC_SAND_IN SOC_TMC_DIAG_DRAM_BIST_DATA_MODE enum_val
  );

const char*
  SOC_TMC_DIAG_SOFT_ERROR_PATTERN_to_string(
    SOC_SAND_IN  SOC_TMC_DIAG_SOFT_ERROR_PATTERN enum_val
  );

const char*
  SOC_TMC_DIAG_SOFT_COUNT_TYPE_to_string(
    SOC_SAND_IN  SOC_TMC_DIAG_SOFT_COUNT_TYPE enum_val
  );

void
  SOC_TMC_DIAG_QDR_BIST_TEST_RUN_INFO_print(
    SOC_SAND_IN SOC_TMC_DIAG_QDR_BIST_TEST_RUN_INFO *info
  );

void
  SOC_TMC_DIAG_QDR_BIST_TEST_RES_INFO_print(
    SOC_SAND_IN SOC_TMC_DIAG_QDR_BIST_TEST_RES_INFO *info
  );

void
  SOC_TMC_DIAG_DRAM_BIST_TEST_RUN_INFO_print(
    SOC_SAND_IN SOC_TMC_DIAG_DRAM_BIST_TEST_RUN_INFO *info
  );

void
  SOC_TMC_DIAG_DRAM_BIST_TEST_RES_INFO_print(
    SOC_SAND_IN SOC_TMC_DIAG_DRAM_BIST_TEST_RES_INFO *info
  );

void
  SOC_TMC_DIAG_DRAM_ACCESS_INFO_print(
    SOC_SAND_IN SOC_TMC_DIAG_DRAM_ACCESS_INFO *info
  );

void
  SOC_TMC_DIAG_DRAM_READ_COMPARE_STATUS_print(
    SOC_SAND_IN SOC_TMC_DIAG_DRAM_READ_COMPARE_STATUS *info
  );

void
  SOC_TMC_DIAG_DLL_STATUS_INFO_print(
    SOC_SAND_IN SOC_TMC_DIAG_DLL_STATUS_INFO *info
  );

void
  SOC_TMC_DIAG_DRAM_STATUS_INFO_print(
    SOC_SAND_IN SOC_TMC_DIAG_DRAM_STATUS_INFO *info
  );

void
  SOC_TMC_DIAG_DRAM_ERR_INFO_print(
    SOC_SAND_IN  SOC_TMC_DIAG_DRAM_ERR_INFO *info
  );

void
  SOC_TMC_DIAG_SOFT_ERR_INFO_print(
    SOC_SAND_IN  SOC_TMC_DIAG_SOFT_ERR_INFO *info
  );

void
  SOC_TMC_DIAG_SOFT_ERR_RESULT_print(
    SOC_SAND_IN  SOC_TMC_DIAG_SOFT_ERR_RESULT *info
  );

void
  SOC_TMC_DIAG_SOFT_SMS_RESULT_print(
    SOC_SAND_IN  uint32                  sms_ndx,
    SOC_SAND_IN  uint32                  sone_ndx,
    SOC_SAND_IN  SOC_TMC_DIAG_SOFT_SMS_RESULT *info
  );

#endif /* SOC_TMC_DEBUG_IS_LVL1 */

void
  SOC_TMC_DIAG_LAST_PACKET_INFO_clear(
    SOC_SAND_OUT SOC_TMC_DIAG_LAST_PACKET_INFO *info
  );

#if SOC_TMC_DEBUG_IS_LVL1

void
  SOC_TMC_DIAG_LAST_PACKET_INFO_print(
    SOC_SAND_IN  SOC_TMC_DIAG_LAST_PACKET_INFO *info
  );

#endif /* SOC_TMC_DEBUG_IS_LVL1 */

/* } */

#include <soc/dpp/SAND/Utils/sand_footer.h>

/* } __SOC_TMC_API_DIAGNOSTICS_INCLUDED__*/
#endif
