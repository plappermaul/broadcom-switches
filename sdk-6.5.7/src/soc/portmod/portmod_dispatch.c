/*
 *         
 * $Id:$
 * 
 * $Copyright: (c) 2016 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 *         
 *     
 * DO NOT EDIT THIS FILE!
 *
 */

#include <soc/types.h>
#include <soc/error.h>
#include <soc/portmod/portmod_internal.h>
#include <soc/portmod/portmod.h>
#include <soc/portmod/portmod_dispatch.h>


        
#ifdef _ERR_MSG_MODULE_NAME 
#error "_ERR_MSG_MODULE_NAME redefined" 
#endif
#define _ERR_MSG_MODULE_NAME BSL_LS_SOC_PORT

#ifdef PORTMOD_PM4X25_SUPPORT
extern __portmod__dispatch__t__ portmod_pm4x25_driver;
#endif
#ifdef PORTMOD_PM4X10_SUPPORT
extern __portmod__dispatch__t__ portmod_pm4x10_driver;
#endif
#ifdef PORTMOD_PM4X10TD_SUPPORT
extern __portmod__dispatch__t__ portmod_pm4x10td_driver;
#endif
#ifdef PORTMOD_PM12X10_SUPPORT
extern __portmod__dispatch__t__ portmod_pm12x10_driver;
#endif
#ifdef PORTMOD_PM4x10Q_SUPPORT
extern __portmod__dispatch__t__ portmod_pm4x10Q_driver;
#endif
#ifdef PORTMOD_PM_QTC_SUPPORT
extern __portmod__dispatch__t__ portmod_pm_qtc_driver;
#endif
#ifdef PORTMOD_PM_OS_ILKN_SUPPORT
extern __portmod__dispatch__t__ portmod_pmOsILKN_driver;
#endif
#ifdef PORTMOD_DNX_FABRIC_SUPPORT
extern __portmod__dispatch__t__ portmod_dnx_fabric_driver;
#endif
#ifdef PORTMOD_DNX_FABRIC_O_NIF_SUPPORT
extern __portmod__dispatch__t__ portmod_dnx_fabric_o_nif_driver;
#endif
#ifdef PORTMOD_PM8X50_FABRIC_SUPPORT
extern __portmod__dispatch__t__ portmod_pm8x50_fabric_driver;
#endif
#ifdef PORTMOD_PM4X25TD_SUPPORT
extern __portmod__dispatch__t__ portmod_pm4x25td_driver;
#endif
#ifdef PORTMOD_PM12X10_XGS_SUPPORT
extern __portmod__dispatch__t__ portmod_pm12x10_xgs_driver;
#endif
#ifdef PORTMOD_PM4X2P5_SUPPORT
extern __portmod__dispatch__t__ portmod_pm4x2p5_driver;
#endif
#ifdef PORTMOD_PMNULL_SUPPORT
extern __portmod__dispatch__t__ portmod_pmNull_driver;
#endif

__portmod__dispatch__t__* __portmod__dispatch__[portmodDispatchTypeCount] = {
#ifdef PORTMOD_PM4X25_SUPPORT
    &portmod_pm4x25_driver,
#endif
#ifdef PORTMOD_PM4X10_SUPPORT
    &portmod_pm4x10_driver,
#endif
#ifdef PORTMOD_PM4X10TD_SUPPORT
    &portmod_pm4x10td_driver,
#endif
#ifdef PORTMOD_PM12X10_SUPPORT
    &portmod_pm12x10_driver,
#endif
#ifdef PORTMOD_PM4x10Q_SUPPORT
    &portmod_pm4x10Q_driver,
#endif
#ifdef PORTMOD_PM_QTC_SUPPORT
    &portmod_pm_qtc_driver,
#endif
#ifdef PORTMOD_PM_OS_ILKN_SUPPORT
    &portmod_pmOsILKN_driver,
#endif
#ifdef PORTMOD_DNX_FABRIC_SUPPORT
    &portmod_dnx_fabric_driver,
#endif
#ifdef PORTMOD_DNX_FABRIC_O_NIF_SUPPORT
    &portmod_dnx_fabric_o_nif_driver,
#endif
#ifdef PORTMOD_PM8X50_FABRIC_SUPPORT
    &portmod_pm8x50_fabric_driver,
#endif
#ifdef PORTMOD_PM4X25TD_SUPPORT
    &portmod_pm4x25td_driver,
#endif
#ifdef PORTMOD_PM12X10_XGS_SUPPORT
    &portmod_pm12x10_xgs_driver,
#endif
#ifdef PORTMOD_PM4X2P5_SUPPORT
    &portmod_pm4x2p5_driver,
#endif
#ifdef PORTMOD_PMNULL_SUPPORT
    &portmod_pmNull_driver,
#endif

};

int portmod_dispatch_type_t_validate(int unit, portmod_dispatch_type_t portmod_dispatch_type)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_dispatch_type >= portmodDispatchTypeCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_default_user_access_t_validate(int unit, const portmod_default_user_access_t* portmod_default_user_access)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_default_user_access == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_default_user_access_t_init(int unit, portmod_default_user_access_t* portmod_default_user_access)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_default_user_access == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_default_user_access NULL parameter"));
    }
    sal_memset(portmod_default_user_access, 0, sizeof(portmod_default_user_access_t));
    portmod_default_user_access->unit = -1;
    portmod_default_user_access->blk_id = -1;
    portmod_default_user_access->mutex = NULL;
    portmod_default_user_access->flags = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm4x10q_user_data_t_validate(int unit, const portmod_pm4x10q_user_data_t* portmod_pm4x10q_user_data)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm4x10q_user_data == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_default_user_access_t_validate(unit, &portmod_pm4x10q_user_data->qsgmiie_user_data)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("qsgmiie_user_data validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm4x10q_user_data_t_init(int unit, portmod_pm4x10q_user_data_t* portmod_pm4x10q_user_data)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm4x10q_user_data == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm4x10q_user_data NULL parameter"));
    }
    sal_memset(portmod_pm4x10q_user_data, 0, sizeof(portmod_pm4x10q_user_data_t));
    if(SOC_E_NONE != portmod_default_user_access_t_init(unit, &portmod_pm4x10q_user_data->qsgmiie_user_data)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("qsgmiie_user_data initialization failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_fifo_status_t_validate(int unit, const portmod_fifo_status_t* portmod_fifo_status)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_fifo_status == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_fifo_status_t_init(int unit, portmod_fifo_status_t* portmod_fifo_status)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_fifo_status == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_fifo_status NULL parameter"));
    }
    sal_memset(portmod_fifo_status, 0, sizeof(portmod_fifo_status_t));
    portmod_fifo_status->timestamps_in_fifo = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pfc_config_t_validate(int unit, const portmod_pfc_config_t* portmod_pfc_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pfc_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pfc_config_t_init(int unit, portmod_pfc_config_t* portmod_pfc_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pfc_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pfc_config NULL parameter"));
    }
    sal_memset(portmod_pfc_config, 0, sizeof(portmod_pfc_config_t));
    portmod_pfc_config->type = 0;
    portmod_pfc_config->opcode = 0;
    portmod_pfc_config->classes = 0;
    portmod_pfc_config->da_oui = 0;
    portmod_pfc_config->da_nonoui = 0;
    portmod_pfc_config->rxpass = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_eee_t_validate(int unit, const portmod_eee_t* portmod_eee)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_eee == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_eee_t_init(int unit, portmod_eee_t* portmod_eee)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_eee == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_eee NULL parameter"));
    }
    sal_memset(portmod_eee, 0, sizeof(portmod_eee_t));
    portmod_eee->enable = 0;
    portmod_eee->tx_idle_time = 0;
    portmod_eee->tx_wake_time = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_eee_clock_t_validate(int unit, const portmod_eee_clock_t* portmod_eee_clock)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_eee_clock == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_eee_clock_t_init(int unit, portmod_eee_clock_t* portmod_eee_clock)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_eee_clock == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_eee_clock NULL parameter"));
    }
    sal_memset(portmod_eee_clock, 0, sizeof(portmod_eee_clock_t));
    portmod_eee_clock->clock_gate = 0;
    portmod_eee_clock->clock_count = 0;
    portmod_eee_clock->timer_pulse = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_vlan_tag_t_validate(int unit, const portmod_vlan_tag_t* portmod_vlan_tag)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_vlan_tag == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_vlan_tag_t_init(int unit, portmod_vlan_tag_t* portmod_vlan_tag)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_vlan_tag == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_vlan_tag NULL parameter"));
    }
    sal_memset(portmod_vlan_tag, 0, sizeof(portmod_vlan_tag_t));
    portmod_vlan_tag->inner_vlan_tag = 0;
    portmod_vlan_tag->outer_vlan_tag = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_rx_control_t_validate(int unit, const portmod_rx_control_t* portmod_rx_control)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_rx_control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_rx_control_t_init(int unit, portmod_rx_control_t* portmod_rx_control)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_rx_control == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_rx_control NULL parameter"));
    }
    sal_memset(portmod_rx_control, 0, sizeof(portmod_rx_control_t));
    portmod_rx_control->flags = 0;
    portmod_rx_control->pass_control_frames = 0;
    portmod_rx_control->pass_pfc_frames = 0;
    portmod_rx_control->pass_pause_frames = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_multi_get_t_validate(int unit, const portmod_multi_get_t* portmod_multi_get)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_multi_get == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_multi_get_t_init(int unit, portmod_multi_get_t* portmod_multi_get)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_multi_get == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_multi_get NULL parameter"));
    }
    sal_memset(portmod_multi_get, 0, sizeof(portmod_multi_get_t));
    portmod_multi_get->flags = 0;
    portmod_multi_get->dev_addr = 0;
    portmod_multi_get->offset = 0;
    portmod_multi_get->max_size = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_loopback_mode_t_validate(int unit, portmod_loopback_mode_t portmod_loopback_mode)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_loopback_mode >= portmodLoopbackCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_core_port_mode_t_validate(int unit, portmod_core_port_mode_t portmod_core_port_mode)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_core_port_mode >= portmodPortModeCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_prbs_mode_t_validate(int unit, portmod_prbs_mode_t portmod_prbs_mode)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_prbs_mode >= portmodPrbsModeCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_ext_to_int_phy_ctrlcode_t_validate(int unit, portmod_ext_to_int_phy_ctrlcode_t portmod_ext_to_int_phy_ctrlcode)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_ext_to_int_phy_ctrlcode >= portmodExtToInt_CtrlCode_Count) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_portphy_ability_t_validate(int unit, const portmod_portphy_ability_t* portmod_portphy_ability)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_portphy_ability == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_portphy_ability_t_init(int unit, portmod_portphy_ability_t* portmod_portphy_ability)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_portphy_ability == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_portphy_ability NULL parameter"));
    }
    sal_memset(portmod_portphy_ability, 0, sizeof(portmod_portphy_ability_t));
    portmod_portphy_ability->cur_mode = 0;
    portmod_portphy_ability->speed_half_duplex = 0;
    portmod_portphy_ability->speed_full_duplex = 0;
    portmod_portphy_ability->pause = 0;
    portmod_portphy_ability->interface = 0;
    portmod_portphy_ability->medium = 0;
    portmod_portphy_ability->loopback = 0;
    portmod_portphy_ability->flags = 0;
    portmod_portphy_ability->eee = 0;
    portmod_portphy_ability->fcmap = 0;
    portmod_portphy_ability->encap = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pdata_t_validate(int unit, const portmod_pdata_t* portmod_pdata)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pdata == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pdata_t_init(int unit, portmod_pdata_t* portmod_pdata)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pdata == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pdata NULL parameter"));
    }
    sal_memset(portmod_pdata, 0, sizeof(portmod_pdata_t));
    portmod_pdata->data = 0;
    portmod_pdata->enable = 0;
    portmod_pdata->pif = 0;
    portmod_pdata->ability = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_mode_info_t_validate(int unit, const portmod_port_mode_info_t* portmod_port_mode_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_port_mode_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_core_port_mode_t_validate(unit, portmod_port_mode_info->cur_mode)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cur_mode validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_mode_info_t_init(int unit, portmod_port_mode_info_t* portmod_port_mode_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_port_mode_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_port_mode_info NULL parameter"));
    }
    sal_memset(portmod_port_mode_info, 0, sizeof(portmod_port_mode_info_t));
    portmod_port_mode_info->cur_mode = 0;
    portmod_port_mode_info->lanes = 0;
    portmod_port_mode_info->port_index = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_diag_info_t_validate(int unit, const portmod_port_diag_info_t* portmod_port_diag_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_port_diag_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_port_mode_info_t_validate(unit, &portmod_port_diag_info->core_mode)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("core_mode validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_diag_info_t_init(int unit, portmod_port_diag_info_t* portmod_port_diag_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_port_diag_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_port_diag_info NULL parameter"));
    }
    sal_memset(portmod_port_diag_info, 0, sizeof(portmod_port_diag_info_t));
    portmod_port_diag_info->interface = phymodInterfaceCount;
    PORTMOD_PBMP_CLEAR(portmod_port_diag_info->phys);
    portmod_port_diag_info->sub_phy = 0;
    portmod_port_diag_info->medium = 0;
    sal_memset(&(portmod_port_diag_info->core_mode), 0, sizeof(portmod_port_mode_info_t));
    sal_memset(&(portmod_port_diag_info->polarity), 0, sizeof(phymod_polarity_t));

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_core_info_t_validate(int unit, const portmod_pm_core_info_t* portmod_pm_core_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm_core_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_core_info_t_init(int unit, portmod_pm_core_info_t* portmod_pm_core_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm_core_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm_core_info NULL parameter"));
    }
    sal_memset(portmod_pm_core_info, 0, sizeof(portmod_pm_core_info_t));
    portmod_pm_core_info->ref_clk = -1;
    sal_memset(&(portmod_pm_core_info->lane_map), 0, sizeof(phymod_lane_map_t));
    portmod_pm_core_info->nof_phys = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_diag_info_t_validate(int unit, const portmod_pm_diag_info_t* portmod_pm_diag_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm_diag_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_dispatch_type_t_validate(unit, portmod_pm_diag_info->type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("type validation failed"));
    }

    if(SOC_E_NONE != portmod_pm_core_info_t_validate(unit, &portmod_pm_diag_info->core_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("core_info validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_diag_info_t_init(int unit, portmod_pm_diag_info_t* portmod_pm_diag_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm_diag_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm_diag_info NULL parameter"));
    }
    sal_memset(portmod_pm_diag_info, 0, sizeof(portmod_pm_diag_info_t));
    portmod_pm_diag_info->type = portmodDispatchTypeCount;
    sal_memset(&(portmod_pm_diag_info->core_info), 0, sizeof(portmod_pm_core_info_t));
    PORTMOD_PBMP_CLEAR(portmod_pm_diag_info->phys);
    SOC_PBMP_CLEAR(portmod_pm_diag_info->ports);
    portmod_pm_diag_info->serdes_id0 = -1;
    portmod_pm_diag_info->phy_id0 = -1;
    portmod_pm_diag_info->phy_id1 = -1;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_init_config_t_validate(int unit, const portmod_port_init_config_t* portmod_port_init_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_port_init_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_init_config_t_init(int unit, portmod_port_init_config_t* portmod_port_init_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_port_init_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_port_init_config NULL parameter"));
    }
    sal_memset(portmod_port_init_config, 0, sizeof(portmod_port_init_config_t));
    portmod_port_init_config->cx4_10g = 0;
    portmod_port_init_config->pdetect1000x = 0;
    portmod_port_init_config->an_mode = phymod_AN_MODE_NONE;
    portmod_port_init_config->an_master_lane = 0;
    portmod_port_init_config->an_cl72 = 0;
    portmod_port_init_config->fs_cl72 = 0;
    portmod_port_init_config->an_fec = 0;
    portmod_port_init_config->sgmii_mstr = 0;
    portmod_port_init_config->serdes_driver_current = 0;
    portmod_port_init_config->serdes_1000x_at_6250_vco = 0;
    portmod_port_init_config->pll_divider_req = 0;
    portmod_port_init_config->rxaui_mode = 0;
    portmod_port_init_config->port_fallback_lane = 0;
    portmod_port_init_config->an_cl37 = 0;
    portmod_port_init_config->cl37_sgmii_war = 0;
    portmod_port_init_config->cl37_sgmii_cnt = 0;
    portmod_port_init_config->cl37_sgmii_RESTART_CNT = 2;
    portmod_port_init_config->an_cl73 = 0;
    portmod_port_init_config->is_hg = 0;
    portmod_port_init_config->polarity_overwrite = 0;
    portmod_port_init_config->lane_map_overwrite = 0;
    portmod_port_init_config->fw_load_method_overwrite = 0;
    portmod_port_init_config->ref_clk = 0;
    portmod_port_init_config->ref_clk_overwrite = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_interface_config_t_validate(int unit, const portmod_port_interface_config_t* portmod_port_interface_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_port_interface_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_interface_config_t_init(int unit, portmod_port_interface_config_t* portmod_port_interface_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_port_interface_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_port_interface_config NULL parameter"));
    }
    sal_memset(portmod_port_interface_config, 0, sizeof(portmod_port_interface_config_t));
    portmod_port_interface_config->interface = SOC_PORT_IF_NULL;
    portmod_port_interface_config->line_interface = SOC_PORT_IF_NULL;
    portmod_port_interface_config->serdes_interface = SOC_PORT_IF_NULL;
    portmod_port_interface_config->interface_modes = 0;
    portmod_port_interface_config->flags = 0;
    portmod_port_interface_config->port_refclk_int = -1;
    portmod_port_interface_config->port_num_lanes = 0;
    portmod_port_interface_config->speed = 0;
    portmod_port_interface_config->max_speed = 0;
    portmod_port_interface_config->encap_mode = 0;
    portmod_port_interface_config->pll_divider_req = 0;
    portmod_port_interface_config->port_op_mode = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_add_info_t_validate(int unit, const portmod_port_add_info_t* portmod_port_add_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_port_add_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_port_interface_config_t_validate(unit, &portmod_port_add_info->interface_config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("interface_config validation failed"));
    }

    if(SOC_E_NONE != portmod_port_init_config_t_validate(unit, &portmod_port_add_info->init_config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("init_config validation failed"));
    }

    switch(portmod_port_add_info->sub_phy) {
        case 0:
        case 1:
        case 2:
        case 3:
            break;
        default:
            _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("sub_phy not allowed value"));
            break;
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_add_info_t_init(int unit, portmod_port_add_info_t* portmod_port_add_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_port_add_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_port_add_info NULL parameter"));
    }
    sal_memset(portmod_port_add_info, 0, sizeof(portmod_port_add_info_t));
    if(SOC_E_NONE != portmod_port_interface_config_t_init(unit, &portmod_port_add_info->interface_config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("interface_config initialization failed"));
    }

    if(SOC_E_NONE != portmod_port_init_config_t_init(unit, &portmod_port_add_info->init_config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("init_config initialization failed"));
    }

    PORTMOD_PBMP_CLEAR(portmod_port_add_info->phys);
    PORTMOD_PBMP_CLEAR(portmod_port_add_info->phy_ports);
    portmod_port_add_info->sub_phy = 0;
    portmod_port_add_info->autoneg_en = 0;
    portmod_port_add_info->link_training_en = 0;
    portmod_port_add_info->flags = PORTMOD_PORT_ADD_F_FIRMWARE_LOAD_VERIFY;
    portmod_port_add_info->is_fabric_o_nif = 0;
    portmod_port_add_info->ilkn_core_id = 0;
    portmod_port_add_info->ilkn_port_is_over_fabric = 0;
    portmod_port_add_info->ilkn_burst_max = -1;
    portmod_port_add_info->ilkn_burst_min = -1;
    portmod_port_add_info->ilkn_burst_short = -1;
    portmod_port_add_info->ilkn_nof_segments = -1;
    portmod_port_add_info->ilkn_metaframe_period = -1;
    portmod_port_add_info->rx_retransmit = 0;
    portmod_port_add_info->tx_retransmit = 0;
    portmod_port_add_info->phy_op_mode = 0;
    portmod_port_add_info->phy_op_datapath = 0;
    portmod_port_add_info->ilkn_inb_cal_len_rx = -1;
    portmod_port_add_info->ilkn_inb_cal_len_tx = -1;
    portmod_port_add_info->ilkn_oob_cal_len_rx = -1;
    portmod_port_add_info->ilkn_oob_cal_len_tx = -1;
    portmod_port_add_info->reserved_channel_rx = 0;
    portmod_port_add_info->reserved_channel_tx = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_identifier_t_validate(int unit, const portmod_pm_identifier_t* portmod_pm_identifier)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm_identifier == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_dispatch_type_t_validate(unit, portmod_pm_identifier->type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("type validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_identifier_t_init(int unit, portmod_pm_identifier_t* portmod_pm_identifier)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm_identifier == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm_identifier NULL parameter"));
    }
    sal_memset(portmod_pm_identifier, 0, sizeof(portmod_pm_identifier_t));
    portmod_pm_identifier->type = portmodDispatchTypeCount;
    portmod_pm_identifier->phy = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_dnx_fabric_create_info_t_validate(int unit, const portmod_dnx_fabric_create_info_t* portmod_dnx_fabric_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_dnx_fabric_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_pm_identifier_t_validate(unit, &portmod_dnx_fabric_create_info->fabric_o_nif_pm)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("fabric_o_nif_pm validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_dnx_fabric_create_info_t_init(int unit, portmod_dnx_fabric_create_info_t* portmod_dnx_fabric_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_dnx_fabric_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_dnx_fabric_create_info NULL parameter"));
    }
    sal_memset(portmod_dnx_fabric_create_info, 0, sizeof(portmod_dnx_fabric_create_info_t));
    portmod_dnx_fabric_create_info->ref_clk = phymodRefClkCount;
    phymod_access_t_init(&portmod_dnx_fabric_create_info->access);
    phymod_lane_map_t_init(&portmod_dnx_fabric_create_info->lane_map);
    portmod_dnx_fabric_create_info->fw_load_method = phymodFirmwareLoadMethodCount;
    portmod_dnx_fabric_create_info->external_fw_loader = NULL;
    portmod_dnx_fabric_create_info->fmac_schan_id = -1;
    portmod_dnx_fabric_create_info->fsrd_schan_id = -1;
    portmod_dnx_fabric_create_info->fsrd_internal_quad = -1;
    portmod_dnx_fabric_create_info->first_phy_offset = 0;
    portmod_dnx_fabric_create_info->core_index = -1;
    portmod_dnx_fabric_create_info->is_over_nif = 0;
    if(SOC_E_NONE != portmod_pm_identifier_t_init(unit, &portmod_dnx_fabric_create_info->fabric_o_nif_pm)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("fabric_o_nif_pm initialization failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm8x50_fabric_create_info_t_validate(int unit, const portmod_pm8x50_fabric_create_info_t* portmod_pm8x50_fabric_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm8x50_fabric_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_pm_identifier_t_validate(unit, &portmod_pm8x50_fabric_create_info->fabric_o_nif_pm)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("fabric_o_nif_pm validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm8x50_fabric_create_info_t_init(int unit, portmod_pm8x50_fabric_create_info_t* portmod_pm8x50_fabric_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm8x50_fabric_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm8x50_fabric_create_info NULL parameter"));
    }
    sal_memset(portmod_pm8x50_fabric_create_info, 0, sizeof(portmod_pm8x50_fabric_create_info_t));
    portmod_pm8x50_fabric_create_info->ref_clk = phymodRefClkCount;
    phymod_access_t_init(&portmod_pm8x50_fabric_create_info->access);
    phymod_lane_map_t_init(&portmod_pm8x50_fabric_create_info->lane_map);
    portmod_pm8x50_fabric_create_info->fw_load_method = phymodFirmwareLoadMethodCount;
    portmod_pm8x50_fabric_create_info->external_fw_loader = NULL;
    portmod_pm8x50_fabric_create_info->fmac_schan_id = -1;
    portmod_pm8x50_fabric_create_info->fsrd_schan_id = -1;
    portmod_pm8x50_fabric_create_info->fsrd_internal_quad = -1;
    portmod_pm8x50_fabric_create_info->first_phy_offset = 0;
    portmod_pm8x50_fabric_create_info->core_index = -1;
    portmod_pm8x50_fabric_create_info->is_over_nif = 0;
    if(SOC_E_NONE != portmod_pm_identifier_t_init(unit, &portmod_pm8x50_fabric_create_info->fabric_o_nif_pm)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("fabric_o_nif_pm initialization failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_call_back_action_type_t_validate(int unit, portmod_call_back_action_type_t portmod_call_back_action_type)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_call_back_action_type >= portmodCallBackActionTypeCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_intr_type_t_validate(int unit, portmod_intr_type_t portmod_intr_type)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_intr_type >= portmodIntrTypeCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm4x25_create_info_t_validate(int unit, const portmod_pm4x25_create_info_t* portmod_pm4x25_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm4x25_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    switch(portmod_pm4x25_create_info->in_pm_12x10) {
        case 0:
        case 1:
            break;
        default:
            _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("in_pm_12x10 not allowed value"));
            break;
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm4x25_create_info_t_init(int unit, portmod_pm4x25_create_info_t* portmod_pm4x25_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm4x25_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm4x25_create_info NULL parameter"));
    }
    sal_memset(portmod_pm4x25_create_info, 0, sizeof(portmod_pm4x25_create_info_t));
    portmod_pm4x25_create_info->ref_clk = phymodRefClkCount;
    phymod_access_t_init(&portmod_pm4x25_create_info->access);
    phymod_lane_map_t_init(&portmod_pm4x25_create_info->lane_map);
    portmod_pm4x25_create_info->fw_load_method = phymodFirmwareLoadMethodCount;
    portmod_pm4x25_create_info->external_fw_loader = NULL;
    portmod_pm4x25_create_info->in_pm_12x10 = 0;
    portmod_pm4x25_create_info->core_num = 0;
    portmod_pm4x25_create_info->core_num_int = 0;
    portmod_pm4x25_create_info->portmod_mac_soft_reset = NULL;
    phymod_afe_pll_t_init(&portmod_pm4x25_create_info->afe_pll);
    portmod_pm4x25_create_info->rescal = -1;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm4x10_create_info_t_validate(int unit, const portmod_pm4x10_create_info_t* portmod_pm4x10_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm4x10_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    switch(portmod_pm4x10_create_info->in_pm_12x10) {
        case 0:
        case 1:
            break;
        default:
            _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("in_pm_12x10 not allowed value"));
            break;
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm4x10_create_info_t_init(int unit, portmod_pm4x10_create_info_t* portmod_pm4x10_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm4x10_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm4x10_create_info NULL parameter"));
    }
    sal_memset(portmod_pm4x10_create_info, 0, sizeof(portmod_pm4x10_create_info_t));
    PORTMOD_PBMP_CLEAR(portmod_pm4x10_create_info->phy_ports);
    portmod_pm4x10_create_info->ref_clk = phymodRefClkCount;
    phymod_access_t_init(&portmod_pm4x10_create_info->access);
    phymod_lane_map_t_init(&portmod_pm4x10_create_info->lane_map);
    portmod_pm4x10_create_info->fw_load_method = phymodFirmwareLoadMethodCount;
    portmod_pm4x10_create_info->external_fw_loader = NULL;
    portmod_pm4x10_create_info->in_pm_12x10 = 0;
    portmod_pm4x10_create_info->portmod_phy_external_reset = NULL;
    portmod_pm4x10_create_info->portmod_mac_soft_reset = NULL;
    portmod_pm4x10_create_info->core_num = 0;
    portmod_pm4x10_create_info->core_num_int = 0;
    portmod_pm4x10_create_info->three_ports_mode = 0;
    portmod_pm4x10_create_info->rescal = -1;
    portmod_pm4x10_create_info->is_pm4x10q = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_qtc_create_info_t_validate(int unit, const portmod_pm_qtc_create_info_t* portmod_pm_qtc_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm_qtc_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_qtc_create_info_t_init(int unit, portmod_pm_qtc_create_info_t* portmod_pm_qtc_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm_qtc_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm_qtc_create_info NULL parameter"));
    }
    sal_memset(portmod_pm_qtc_create_info, 0, sizeof(portmod_pm_qtc_create_info_t));
    portmod_pm_qtc_create_info->ref_clk = phymodRefClkCount;
    phymod_access_t_init(&portmod_pm_qtc_create_info->access);
    phymod_lane_map_t_init(&portmod_pm_qtc_create_info->lane_map);
    portmod_pm_qtc_create_info->fw_load_method = phymodFirmwareLoadMethodCount;
    portmod_pm_qtc_create_info->external_fw_loader = NULL;
    portmod_pm_qtc_create_info->portmod_phy_external_reset = NULL;
    portmod_pm_qtc_create_info->portmod_mac_soft_reset = NULL;
    portmod_pm_qtc_create_info->core_num = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_gphy_create_info_t_validate(int unit, const portmod_pm_gphy_create_info_t* portmod_pm_gphy_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm_gphy_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_gphy_create_info_t_init(int unit, portmod_pm_gphy_create_info_t* portmod_pm_gphy_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm_gphy_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm_gphy_create_info NULL parameter"));
    }
    sal_memset(portmod_pm_gphy_create_info, 0, sizeof(portmod_pm_gphy_create_info_t));
    portmod_pm_gphy_create_info->ref_clk = phymodRefClkCount;
    phymod_access_t_init(&portmod_pm_gphy_create_info->access);
    phymod_lane_map_t_init(&portmod_pm_gphy_create_info->lane_map);
    portmod_pm_gphy_create_info->fw_load_method = phymodFirmwareLoadMethodCount;
    portmod_pm_gphy_create_info->external_fw_loader = NULL;
    portmod_pm_gphy_create_info->portmod_phy_external_reset = NULL;
    portmod_pm_gphy_create_info->portmod_mac_soft_reset = NULL;
    portmod_pm_gphy_create_info->core_num = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm12x10_create_info_t_validate(int unit, const portmod_pm12x10_create_info_t* portmod_pm12x10_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm12x10_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_pm4x25_create_info_t_validate(unit, &portmod_pm12x10_create_info->pm4x25_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pm4x25_info validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm12x10_create_info_t_init(int unit, portmod_pm12x10_create_info_t* portmod_pm12x10_create_info)
{
    int _array_iter;
        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm12x10_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm12x10_create_info NULL parameter"));
    }
    sal_memset(portmod_pm12x10_create_info, 0, sizeof(portmod_pm12x10_create_info_t));
    for(_array_iter = 0 ; _array_iter < 3 ; _array_iter++){
        if(SOC_E_NONE != portmod_pm4x10_create_info_t_init(unit, &portmod_pm12x10_create_info->pm4x10_infos[_array_iter])) {
            _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pm4x10_infos initialization failed"));
        }
    }

    if(SOC_E_NONE != portmod_pm4x25_create_info_t_init(unit, &portmod_pm12x10_create_info->pm4x25_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pm4x25_info initialization failed"));
    }

    portmod_pm12x10_create_info->blk_id = -1;
    portmod_pm12x10_create_info->refclk_source = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm4x10q_create_info_t_validate(int unit, const portmod_pm4x10q_create_info_t* portmod_pm4x10q_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm4x10q_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_pm4x10_create_info_t_validate(unit, &portmod_pm4x10q_create_info->pm4x10_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pm4x10_info validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm4x10q_create_info_t_init(int unit, portmod_pm4x10q_create_info_t* portmod_pm4x10q_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm4x10q_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm4x10q_create_info NULL parameter"));
    }
    sal_memset(portmod_pm4x10q_create_info, 0, sizeof(portmod_pm4x10q_create_info_t));
    if(SOC_E_NONE != portmod_pm4x10_create_info_t_init(unit, &portmod_pm4x10q_create_info->pm4x10_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pm4x10_info initialization failed"));
    }

    portmod_pm4x10q_create_info->qsgmii_user_acc = NULL;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_ilkn_os_create_info_t_validate(int unit, const portmod_ilkn_os_create_info_t* portmod_ilkn_os_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_ilkn_os_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_pm_identifier_t_validate(unit, portmod_ilkn_os_create_info->controlled_pms)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("controlled_pms validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_ilkn_os_create_info_t_init(int unit, portmod_ilkn_os_create_info_t* portmod_ilkn_os_create_info)
{
    int _array_iter;
        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_ilkn_os_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_ilkn_os_create_info NULL parameter"));
    }
    sal_memset(portmod_ilkn_os_create_info, 0, sizeof(portmod_ilkn_os_create_info_t));
    portmod_ilkn_os_create_info->nof_aggregated_pms = phymodRefClkCount;
    for(_array_iter = 0 ; _array_iter < PORTMOD_MAX_ILKN_PORTS_PER_ILKN_PM ; _array_iter++){        portmod_ilkn_os_create_info->wm_high[_array_iter] = 0;
    }    for(_array_iter = 0 ; _array_iter < PORTMOD_MAX_ILKN_PORTS_PER_ILKN_PM ; _array_iter++){        portmod_ilkn_os_create_info->wm_low[_array_iter] = 0;
    }    portmod_ilkn_os_create_info->is_over_fabric = 0;
    portmod_ilkn_os_create_info->core_clock_khz = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm4x2p5_create_info_t_validate(int unit, const portmod_pm4x2p5_create_info_t* portmod_pm4x2p5_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm4x2p5_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm4x2p5_create_info_t_init(int unit, portmod_pm4x2p5_create_info_t* portmod_pm4x2p5_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm4x2p5_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm4x2p5_create_info NULL parameter"));
    }
    sal_memset(portmod_pm4x2p5_create_info, 0, sizeof(portmod_pm4x2p5_create_info_t));
    SOC_PBMP_CLEAR(portmod_pm4x2p5_create_info->phy_ports);
    portmod_pm4x2p5_create_info->ref_clk = phymodRefClkCount;
    phymod_access_t_init(&portmod_pm4x2p5_create_info->access);
    phymod_lane_map_t_init(&portmod_pm4x2p5_create_info->lane_map);
    portmod_pm4x2p5_create_info->fw_load_method = phymodFirmwareLoadMethodCount;
    portmod_pm4x2p5_create_info->external_fw_loader = NULL;
    portmod_pm4x2p5_create_info->portmod_phy_external_reset = NULL;
    portmod_pm4x2p5_create_info->portmod_mac_soft_reset = NULL;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_remote_fault_control_t_validate(int unit, const portmod_remote_fault_control_t* portmod_remote_fault_control)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_remote_fault_control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_remote_fault_control_t_init(int unit, portmod_remote_fault_control_t* portmod_remote_fault_control)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_remote_fault_control == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_remote_fault_control NULL parameter"));
    }
    sal_memset(portmod_remote_fault_control, 0, sizeof(portmod_remote_fault_control_t));
    portmod_remote_fault_control->enable = 0;
    portmod_remote_fault_control->drop_tx_on_fault = 1;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_local_fault_control_t_validate(int unit, const portmod_local_fault_control_t* portmod_local_fault_control)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_local_fault_control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_local_fault_control_t_init(int unit, portmod_local_fault_control_t* portmod_local_fault_control)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_local_fault_control == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_local_fault_control NULL parameter"));
    }
    sal_memset(portmod_local_fault_control, 0, sizeof(portmod_local_fault_control_t));
    portmod_local_fault_control->enable = 0;
    portmod_local_fault_control->drop_tx_on_fault = 1;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_llfc_control_t_validate(int unit, const portmod_llfc_control_t* portmod_llfc_control)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_llfc_control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_llfc_control_t_init(int unit, portmod_llfc_control_t* portmod_llfc_control)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_llfc_control == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_llfc_control NULL parameter"));
    }
    sal_memset(portmod_llfc_control, 0, sizeof(portmod_llfc_control_t));
    portmod_llfc_control->rx_enable = 1;
    portmod_llfc_control->tx_enable = 1;
    portmod_llfc_control->crc_ignore = 0;
    portmod_llfc_control->in_ipg_only = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pfc_control_t_validate(int unit, const portmod_pfc_control_t* portmod_pfc_control)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pfc_control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pfc_control_t_init(int unit, portmod_pfc_control_t* portmod_pfc_control)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pfc_control == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pfc_control NULL parameter"));
    }
    sal_memset(portmod_pfc_control, 0, sizeof(portmod_pfc_control_t));
    portmod_pfc_control->rx_enable = 0;
    portmod_pfc_control->tx_enable = 0;
    portmod_pfc_control->stats_en = 1;
    portmod_pfc_control->force_xon = 0;
    portmod_pfc_control->refresh_timer = -1;
    portmod_pfc_control->xoff_timer = 0xFFFF;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pause_control_t_validate(int unit, const portmod_pause_control_t* portmod_pause_control)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pause_control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pause_control_t_init(int unit, portmod_pause_control_t* portmod_pause_control)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pause_control == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pause_control NULL parameter"));
    }
    sal_memset(portmod_pause_control, 0, sizeof(portmod_pause_control_t));
    portmod_pause_control->rx_enable = 0;
    portmod_pause_control->tx_enable = 0;
    portmod_pause_control->refresh_timer = 0xc000;
    portmod_pause_control->xoff_timer = 0xFFFF;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_drain_cells_t_validate(int unit, const portmod_drain_cells_t* portmod_drain_cells)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_drain_cells == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_drain_cells_t_init(int unit, portmod_drain_cells_t* portmod_drain_cells)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_drain_cells == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_drain_cells NULL parameter"));
    }
    sal_memset(portmod_drain_cells, 0, sizeof(portmod_drain_cells_t));
    portmod_drain_cells->rx_pfc_en = 0;
    portmod_drain_cells->llfc_en = 0;
    portmod_drain_cells->rx_pause = 0;
    portmod_drain_cells->tx_pause = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_create_info_t_validate(int unit, const portmod_pm_create_info_t* portmod_pm_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_dispatch_type_t_validate(unit, portmod_pm_create_info->type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("type validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_create_info_t_init(int unit, portmod_pm_create_info_t* portmod_pm_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm_create_info NULL parameter"));
    }
    sal_memset(portmod_pm_create_info, 0, sizeof(portmod_pm_create_info_t));
    portmod_pm_create_info->type = portmodDispatchTypeCount;
    PORTMOD_PBMP_CLEAR(portmod_pm_create_info->phys);
    sal_memset(&(portmod_pm_create_info->pm_specific_info), 0, sizeof(portmod_pm_specific_create_info_t));

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_access_get_params_t_validate(int unit, const portmod_access_get_params_t* portmod_access_get_params)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_access_get_params == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    switch(portmod_access_get_params->sys_side) {
        case PORTMOD_SIDE_LINE:
        case  PORTMOD_SIDE_SYSTEM:
            break;
        default:
            _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("sys_side not allowed value"));
            break;
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_access_get_params_t_init(int unit, portmod_access_get_params_t* portmod_access_get_params)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_access_get_params == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_access_get_params NULL parameter"));
    }
    sal_memset(portmod_access_get_params, 0, sizeof(portmod_access_get_params_t));
    portmod_access_get_params->phyn = -1;
    portmod_access_get_params->sys_side = PORTMOD_SIDE_LINE;
    portmod_access_get_params->lane = -1;
    portmod_access_get_params->apply_lane_mask = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_instances_t_validate(int unit, const portmod_pm_instances_t* portmod_pm_instances)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm_instances == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_dispatch_type_t_validate(unit, portmod_pm_instances->type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("type validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_instances_t_init(int unit, portmod_pm_instances_t* portmod_pm_instances)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm_instances == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm_instances NULL parameter"));
    }
    sal_memset(portmod_pm_instances, 0, sizeof(portmod_pm_instances_t));
    portmod_pm_instances->type = portmodDispatchTypeCount;
    portmod_pm_instances->instances = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_interface_type_is_supported(int unit, pm_info_t pm_info, soc_port_if_t interface, int* is_supported)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(is_supported == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("is_supported NULL parameter"));
    }
    /* Dispatch */
    __type__ = (pm_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_interface_type_is_supported) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_interface_type_is_supported(unit, interface, is_supported);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_interface_type_is_supported isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_pm_init(int unit, const portmod_pm_create_info_internal_t* pm_add_info, int wb_buffer_index, pm_info_t pm_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    __type__ = (pm_add_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_init) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_init(unit, pm_add_info, wb_buffer_index, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_init isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_pm_destroy(int unit, pm_info_t pm_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    __type__ = (pm_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_destroy) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_destroy(unit, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_destroy isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_attach(int unit, int port, const portmod_port_add_info_t* add_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_port_add_info_t_validate(unit, add_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("add_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_attach) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_attach(unit, port, pm_info, add_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_attach isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_default_bus_update(int unit, pm_info_t pm_info, const portmod_bus_update_t* update)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    __type__ = (pm_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_default_bus_update) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_default_bus_update(unit, pm_info, update);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_default_bus_update isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_pm_bypass_set(int unit, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, enable, &enable, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_bypass_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, enable, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_bypass_set(unit, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_bypass_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_pm_core_info_get(int unit, pm_info_t pm_info, int phyn, portmod_pm_core_info_t* core_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(core_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("core_info NULL parameter"));
    }
    if(SOC_E_NONE != portmod_pm_core_info_t_init(unit, core_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("core_info initialization failed"));
    }

    /* Dispatch */
    __type__ = (pm_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_core_info_get) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_core_info_get(unit, pm_info, phyn, core_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_core_info_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_pm_phys_get(int unit, pm_info_t pm_info, portmod_pbmp_t* phys)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(phys == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("phys NULL parameter"));
    }
    /* Dispatch */
    __type__ = (pm_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_phys_get) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_phys_get(unit, pm_info, phys);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_phys_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_detach(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_detach) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_detach(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_detach isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_replace(int unit, int port, int new_port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_replace) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_replace(unit, port, pm_info, new_port);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_replace isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_enable_set(int unit, int port, int flags, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    switch(enable) {
        case 0:
        case 1:
            break;
        default:
            _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable not allowed value"));
            break;
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_enable_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_enable_set(unit, port, pm_info, flags, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_enable_get(int unit, int port, int flags, int* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_enable_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_enable_get(unit, port, pm_info, flags, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_interface_config_set(int unit, int port, const portmod_port_interface_config_t* config, int phy_init_flags)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_port_interface_config_t_validate(unit, config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_interface_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_interface_config_set(unit, port, pm_info, config, phy_init_flags);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_interface_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_interface_config_get(int unit, int port, portmod_port_interface_config_t* config, int phy_init_flags)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config NULL parameter"));
    }
    if(SOC_E_NONE != portmod_port_interface_config_t_init(unit, config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_interface_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_interface_config_get(unit, port, pm_info, config, phy_init_flags);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_interface_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_default_interface_get(int unit, int port, const portmod_port_interface_config_t* config, soc_port_if_t* interface)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_port_interface_config_t_validate(unit, config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config validation failed"));
    }

    if(interface == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("interface NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_default_interface_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_default_interface_get(unit, port, pm_info, config, interface);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_default_interface_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_encoding_set(int unit, int port, uint32 properties, portmod_port_pcs_t encoding)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_encoding_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_encoding_set(unit, port, pm_info, properties, encoding);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_encoding_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_encoding_get(int unit, int port, uint32* properties, portmod_port_pcs_t* encoding)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(properties == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("properties NULL parameter"));
    }
    if(encoding == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("encoding NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_encoding_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_encoding_get(unit, port, pm_info, properties, encoding);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_encoding_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_cl72_set(int unit, int port, uint32 enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_cl72_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_cl72_set(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_cl72_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_cl72_get(int unit, int port, uint32* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_cl72_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_cl72_get(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_cl72_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_cl72_status_get(int unit, int port, phymod_cl72_status_t* status)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(status == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("status NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_cl72_status_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_cl72_status_get(unit, port, pm_info, status);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_cl72_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_loopback_set(int unit, int port, portmod_loopback_mode_t loopback_type, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_loopback_mode_t_validate(unit, loopback_type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("loopback_type validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_loopback_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_loopback_set(unit, port, pm_info, loopback_type, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_loopback_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_loopback_get(int unit, int port, portmod_loopback_mode_t loopback_type, int* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_loopback_mode_t_validate(unit, loopback_type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("loopback_type validation failed"));
    }

    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_loopback_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_loopback_get(unit, port, pm_info, loopback_type, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_loopback_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_rx_mac_enable_set(int unit, int port, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_rx_mac_enable_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_rx_mac_enable_set(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_rx_mac_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_rx_mac_enable_get(int unit, int port, int* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_rx_mac_enable_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_rx_mac_enable_get(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_rx_mac_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_tx_mac_enable_set(int unit, int port, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tx_mac_enable_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tx_mac_enable_set(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tx_mac_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_tx_mac_enable_get(int unit, int port, int* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tx_mac_enable_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tx_mac_enable_get(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tx_mac_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_ability_local_get(int unit, int port, uint32 phy_flags, portmod_port_ability_t* ability)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(ability == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ability NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_ability_local_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_ability_local_get(unit, port, pm_info, phy_flags, ability);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_ability_local_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_autoneg_set(int unit, int port, uint32 phy_flags, const phymod_autoneg_control_t* an)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_autoneg_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_autoneg_set(unit, port, pm_info, phy_flags, an);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_autoneg_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_autoneg_get(int unit, int port, uint32 phy_flags, phymod_autoneg_control_t* an)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(an == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("an NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_autoneg_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_autoneg_get(unit, port, pm_info, phy_flags, an);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_autoneg_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_autoneg_status_get(int unit, int port, phymod_autoneg_status_t* an_status)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(an_status == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("an_status NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_autoneg_status_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_autoneg_status_get(unit, port, pm_info, an_status);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_autoneg_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_link_get(int unit, int port, int flags, int* link)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(link == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("link NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_link_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_link_get(unit, port, pm_info, flags, link);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_link_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_link_latch_down_get(int unit, int port, uint32 flags, int* link)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(link == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("link NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_link_latch_down_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_link_latch_down_get(unit, port, pm_info, flags, link);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_link_latch_down_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_phy_link_up_event(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_phy_link_up_event) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_phy_link_up_event(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_phy_link_up_event isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_phy_link_down_event(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_phy_link_down_event) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_phy_link_down_event(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_phy_link_down_event isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_prbs_config_set(int unit, int port, portmod_prbs_mode_t mode, int flags, const phymod_prbs_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_prbs_mode_t_validate(unit, mode)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_prbs_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_prbs_config_set(unit, port, pm_info, mode, flags, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_prbs_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_prbs_config_get(int unit, int port, portmod_prbs_mode_t mode, int flags, phymod_prbs_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_prbs_mode_t_validate(unit, mode)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode validation failed"));
    }

    if(config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_prbs_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_prbs_config_get(unit, port, pm_info, mode, flags, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_prbs_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_prbs_enable_set(int unit, int port, portmod_prbs_mode_t mode, int flags, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_prbs_mode_t_validate(unit, mode)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode validation failed"));
    }

    switch(enable) {
        case 0:
        case 1:
            break;
        default:
            _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable not allowed value"));
            break;
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_prbs_enable_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_prbs_enable_set(unit, port, pm_info, mode, flags, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_prbs_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_prbs_enable_get(int unit, int port, portmod_prbs_mode_t mode, int flags, int* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_prbs_mode_t_validate(unit, mode)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode validation failed"));
    }

    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_prbs_enable_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_prbs_enable_get(unit, port, pm_info, mode, flags, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_prbs_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_prbs_status_get(int unit, int port, portmod_prbs_mode_t mode, int flags, phymod_prbs_status_t* status)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_prbs_mode_t_validate(unit, mode)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode validation failed"));
    }

    if(status == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("status NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_prbs_status_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_prbs_status_get(unit, port, pm_info, mode, flags, status);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_prbs_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_nof_lanes_get(int unit, int port, int* nof_lanes)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(nof_lanes == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("nof_lanes NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_nof_lanes_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_nof_lanes_get(unit, port, pm_info, nof_lanes);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_nof_lanes_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_ilkn_nof_segments_set(int unit, int port, uint32 nof_segments)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    switch(nof_segments) {
        case 2:
        case 4:
            break;
        default:
            _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("nof_segments not allowed value"));
            break;
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_ilkn_nof_segments_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_ilkn_nof_segments_set(unit, port, pm_info, nof_segments);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_ilkn_nof_segments_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_ilkn_nof_segments_get(int unit, int port, uint32* nof_segments)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(nof_segments == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("nof_segments NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_ilkn_nof_segments_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_ilkn_nof_segments_get(unit, port, pm_info, nof_segments);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_ilkn_nof_segments_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_ilkn_retranstmit_config_set(int unit, int port, const ilkn_retransmit_config_t* retransmit_config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_ilkn_retranstmit_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_ilkn_retranstmit_config_set(unit, port, pm_info, retransmit_config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_ilkn_retranstmit_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_ilkn_retranstmit_config_get(int unit, int port, ilkn_retransmit_config_t* retransmit_config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(retransmit_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("retransmit_config NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_ilkn_retranstmit_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_ilkn_retranstmit_config_get(unit, port, pm_info, retransmit_config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_ilkn_retranstmit_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_lanes_assign(int unit, int port, const portmod_lanes_assign_info_t* assign_map)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_lanes_assign) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_lanes_assign(unit, port, pm_info, assign_map);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_lanes_assign isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_lanes_retrieve(int unit, int port, portmod_lanes_assign_info_t* assign_map)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(assign_map == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("assign_map NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_lanes_retrieve) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_lanes_retrieve(unit, port, pm_info, assign_map);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_lanes_retrieve isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_firmware_mode_set(int unit, int port, phymod_firmware_mode_t fw_mode)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_firmware_mode_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_firmware_mode_set(unit, port, pm_info, fw_mode);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_firmware_mode_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_firmware_mode_get(int unit, int port, phymod_firmware_mode_t* fw_mode)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(fw_mode == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("fw_mode NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_firmware_mode_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_firmware_mode_get(unit, port, pm_info, fw_mode);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_firmware_mode_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_runt_threshold_set(int unit, int port, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_runt_threshold_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_runt_threshold_set(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_runt_threshold_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_runt_threshold_get(int unit, int port, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_runt_threshold_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_runt_threshold_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_runt_threshold_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_max_packet_size_set(int unit, int port, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_max_packet_size_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_max_packet_size_set(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_max_packet_size_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_max_packet_size_get(int unit, int port, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_max_packet_size_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_max_packet_size_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_max_packet_size_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pad_size_set(int unit, int port, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pad_size_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pad_size_set(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pad_size_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pad_size_get(int unit, int port, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pad_size_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pad_size_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pad_size_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_tx_mac_sa_set(int unit, int port, sal_mac_addr_t mac_sa)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tx_mac_sa_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tx_mac_sa_set(unit, port, pm_info, mac_sa);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tx_mac_sa_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_tx_mac_sa_get(int unit, int port, sal_mac_addr_t mac_sa)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tx_mac_sa_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tx_mac_sa_get(unit, port, pm_info, mac_sa);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tx_mac_sa_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_rx_mac_sa_set(int unit, int port, sal_mac_addr_t mac_sa)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_rx_mac_sa_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_rx_mac_sa_set(unit, port, pm_info, mac_sa);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_rx_mac_sa_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_rx_mac_sa_get(int unit, int port, sal_mac_addr_t mac_sa)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_rx_mac_sa_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_rx_mac_sa_get(unit, port, pm_info, mac_sa);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_rx_mac_sa_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_tx_average_ipg_set(int unit, int port, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tx_average_ipg_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tx_average_ipg_set(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tx_average_ipg_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_tx_average_ipg_get(int unit, int port, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tx_average_ipg_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tx_average_ipg_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tx_average_ipg_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_tx_preamble_length_set(int unit, int port, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tx_preamble_length_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tx_preamble_length_set(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tx_preamble_length_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_tx_preamble_length_get(int unit, int port, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tx_preamble_length_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tx_preamble_length_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tx_preamble_length_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_local_fault_control_set(int unit, int port, const portmod_local_fault_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_local_fault_control_t_validate(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_local_fault_control_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_local_fault_control_set(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_local_fault_control_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_local_fault_control_get(int unit, int port, portmod_local_fault_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control NULL parameter"));
    }
    if(SOC_E_NONE != portmod_local_fault_control_t_init(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_local_fault_control_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_local_fault_control_get(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_local_fault_control_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_remote_fault_control_set(int unit, int port, const portmod_remote_fault_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_remote_fault_control_t_validate(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_remote_fault_control_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_remote_fault_control_set(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_remote_fault_control_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_remote_fault_control_get(int unit, int port, portmod_remote_fault_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control NULL parameter"));
    }
    if(SOC_E_NONE != portmod_remote_fault_control_t_init(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_remote_fault_control_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_remote_fault_control_get(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_remote_fault_control_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_local_fault_status_get(int unit, int port, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_local_fault_status_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_local_fault_status_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_local_fault_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_remote_fault_status_get(int unit, int port, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_remote_fault_status_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_remote_fault_status_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_remote_fault_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_local_fault_status_clear(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_local_fault_status_clear) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_local_fault_status_clear(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_local_fault_status_clear isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_remote_fault_status_clear(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_remote_fault_status_clear) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_remote_fault_status_clear(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_remote_fault_status_clear isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pause_control_set(int unit, int port, const portmod_pause_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_pause_control_t_validate(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pause_control_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pause_control_set(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pause_control_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pause_control_get(int unit, int port, portmod_pause_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control NULL parameter"));
    }
    if(SOC_E_NONE != portmod_pause_control_t_init(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pause_control_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pause_control_get(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pause_control_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pfc_control_set(int unit, int port, const portmod_pfc_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_pfc_control_t_validate(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pfc_control_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pfc_control_set(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pfc_control_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pfc_control_get(int unit, int port, portmod_pfc_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control NULL parameter"));
    }
    if(SOC_E_NONE != portmod_pfc_control_t_init(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pfc_control_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pfc_control_get(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pfc_control_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_llfc_control_set(int unit, int port, const portmod_llfc_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_llfc_control_t_validate(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_llfc_control_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_llfc_control_set(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_llfc_control_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_llfc_control_get(int unit, int port, portmod_llfc_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control NULL parameter"));
    }
    if(SOC_E_NONE != portmod_llfc_control_t_init(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_llfc_control_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_llfc_control_get(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_llfc_control_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_update_control_t_validate(int unit, const portmod_port_update_control_t* portmod_port_update_control)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_port_update_control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_update_control_t_init(int unit, portmod_port_update_control_t* portmod_port_update_control)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_port_update_control == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_port_update_control NULL parameter"));
    }
    sal_memset(portmod_port_update_control, 0, sizeof(portmod_port_update_control_t));
    portmod_port_update_control->link_status = -1;
    portmod_port_update_control->flags = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_update(int unit, int port, const portmod_port_update_control_t* update_control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_port_update_control_t_validate(unit, update_control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("update_control validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_update) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_update(unit, port, pm_info, update_control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_update isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_core_access_get(int unit, int port, int phyn, int max_cores, phymod_core_access_t* core_access_arr, int* nof_cores, int* is_most_ext)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(core_access_arr == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("core_access_arr NULL parameter"));
    }
    if(nof_cores == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("nof_cores NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_core_access_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_core_access_get(unit, port, pm_info, phyn, max_cores, core_access_arr, nof_cores, is_most_ext);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_core_access_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_phy_lane_access_get(int unit, int port, const portmod_access_get_params_t* params, int max_phys, phymod_phy_access_t* access, int* nof_phys, int* is_most_ext)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_access_get_params_t_validate(unit, params)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("params validation failed"));
    }

    if(access == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("access NULL parameter"));
    }
    if(nof_phys == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("nof_phys NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_phy_lane_access_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_phy_lane_access_get(unit, port, pm_info, params, max_phys, access, nof_phys, is_most_ext);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_phy_lane_access_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_duplex_set(int unit, int port, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_duplex_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_duplex_set(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_duplex_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_duplex_get(int unit, int port, int* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_duplex_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_duplex_get(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_duplex_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_phy_reg_read(int unit, int port, int flags, int reg_addr, uint32* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_phy_reg_read) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_phy_reg_read(unit, port, pm_info, flags, reg_addr, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_phy_reg_read isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_phy_reg_write(int unit, int port, int flags, int reg_addr, uint32 value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_phy_reg_write) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_phy_reg_write(unit, port, pm_info, flags, reg_addr, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_phy_reg_write isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_reset_set(int unit, int port, int mode, int opcode, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_reset_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_reset_set(unit, port, pm_info, mode, opcode, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_reset_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_reset_get(int unit, int port, int mode, int opcode, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_reset_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_reset_get(unit, port, pm_info, mode, opcode, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_reset_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_adv_remote_get(int unit, int port, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_adv_remote_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_adv_remote_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_adv_remote_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_drv_name(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_drv_name) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_drv_name(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_drv_name isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_drv_name_get(int unit, int port, char* name, int len)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(name == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("name NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_drv_name_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_drv_name_get(unit, port, pm_info, name, len);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_drv_name_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_fec_enable_set(int unit, int port, uint32_t enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_fec_enable_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_fec_enable_set(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_fec_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_fec_enable_get(int unit, int port, uint32_t* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_fec_enable_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_fec_enable_get(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_fec_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_ability_advert_set(int unit, int port, uint32 phy_flags, portmod_port_ability_t* ability)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(ability == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ability NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_ability_advert_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_ability_advert_set(unit, port, pm_info, phy_flags, ability);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_ability_advert_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_ability_advert_get(int unit, int port, uint32 phy_flags, portmod_port_ability_t* ability)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(ability == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ability NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_ability_advert_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_ability_advert_get(unit, port, pm_info, phy_flags, ability);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_ability_advert_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_ability_remote_get(int unit, int port, uint32 phy_flags, portmod_port_ability_t* ability)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(ability == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ability NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_ability_remote_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_ability_remote_get(unit, port, pm_info, phy_flags, ability);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_ability_remote_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_frame_spacing_stretch_set(int unit, int port, int spacing)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_frame_spacing_stretch_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_frame_spacing_stretch_set(unit, port, pm_info, spacing);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_frame_spacing_stretch_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_frame_spacing_stretch_get(int unit, int port, const int* spacing)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_frame_spacing_stretch_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_frame_spacing_stretch_get(unit, port, pm_info, spacing);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_frame_spacing_stretch_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_diag_fifo_status_get(int unit, int port, const portmod_fifo_status_t* diag_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_fifo_status_t_validate(unit, diag_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("diag_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_diag_fifo_status_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_diag_fifo_status_get(unit, port, pm_info, diag_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_diag_fifo_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_rx_control_set(int unit, int port, const portmod_rx_control_t* rx_ctrl)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_rx_control_t_validate(unit, rx_ctrl)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("rx_ctrl validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_rx_control_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_rx_control_set(unit, port, pm_info, rx_ctrl);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_rx_control_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_rx_control_get(int unit, int port, portmod_rx_control_t* rx_ctrl)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(rx_ctrl == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("rx_ctrl NULL parameter"));
    }
    if(SOC_E_NONE != portmod_rx_control_t_init(unit, rx_ctrl)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("rx_ctrl initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_rx_control_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_rx_control_get(unit, port, pm_info, rx_ctrl);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_rx_control_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pfc_config_set(int unit, int port, const portmod_pfc_config_t* pfc_cfg)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_pfc_config_t_validate(unit, pfc_cfg)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pfc_cfg validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pfc_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pfc_config_set(unit, port, pm_info, pfc_cfg);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pfc_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pfc_config_get(int unit, int port, portmod_pfc_config_t* pfc_cfg)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(pfc_cfg == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pfc_cfg NULL parameter"));
    }
    if(SOC_E_NONE != portmod_pfc_config_t_init(unit, pfc_cfg)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pfc_cfg initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pfc_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pfc_config_get(unit, port, pm_info, pfc_cfg);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pfc_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_eee_set(int unit, int port, const portmod_eee_t* eee)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_eee_t_validate(unit, eee)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("eee validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_eee_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_eee_set(unit, port, pm_info, eee);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_eee_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_eee_get(int unit, int port, portmod_eee_t* eee)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(eee == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("eee NULL parameter"));
    }
    if(SOC_E_NONE != portmod_eee_t_init(unit, eee)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("eee initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_eee_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_eee_get(unit, port, pm_info, eee);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_eee_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_eee_clock_set(int unit, int port, const portmod_eee_clock_t* eee_clk)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_eee_clock_t_validate(unit, eee_clk)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("eee_clk validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_eee_clock_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_eee_clock_set(unit, port, pm_info, eee_clk);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_eee_clock_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_eee_clock_get(int unit, int port, portmod_eee_clock_t* eee_clk)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(eee_clk == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("eee_clk NULL parameter"));
    }
    if(SOC_E_NONE != portmod_eee_clock_t_init(unit, eee_clk)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("eee_clk initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_eee_clock_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_eee_clock_get(unit, port, pm_info, eee_clk);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_eee_clock_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_vlan_tag_set(int unit, int port, const portmod_vlan_tag_t* vlan_tag)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_vlan_tag_t_validate(unit, vlan_tag)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("vlan_tag validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_vlan_tag_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_vlan_tag_set(unit, port, pm_info, vlan_tag);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_vlan_tag_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_vlan_tag_get(int unit, int port, portmod_vlan_tag_t* vlan_tag)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(vlan_tag == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("vlan_tag NULL parameter"));
    }
    if(SOC_E_NONE != portmod_vlan_tag_t_init(unit, vlan_tag)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("vlan_tag initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_vlan_tag_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_vlan_tag_get(unit, port, pm_info, vlan_tag);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_vlan_tag_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_modid_set(int unit, int port, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_modid_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_modid_set(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_modid_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_led_chain_config(int unit, int port, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_led_chain_config) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_led_chain_config(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_led_chain_config isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_clear_rx_lss_status_set(int unit, int port, int lcl_fault, int rmt_fault)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_clear_rx_lss_status_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_clear_rx_lss_status_set(unit, port, pm_info, lcl_fault, rmt_fault);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_clear_rx_lss_status_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_clear_rx_lss_status_get(int unit, int port, int* lcl_fault, int* rmt_fault)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(lcl_fault == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("lcl_fault NULL parameter"));
    }
    if(rmt_fault == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("rmt_fault NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_clear_rx_lss_status_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_clear_rx_lss_status_get(unit, port, pm_info, lcl_fault, rmt_fault);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_clear_rx_lss_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_lane_connection_t_validate(int unit, const portmod_lane_connection_t* portmod_lane_connection)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_lane_connection == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_lane_connection_t_init(int unit, portmod_lane_connection_t* portmod_lane_connection)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_lane_connection == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_lane_connection NULL parameter"));
    }
    sal_memset(portmod_lane_connection, 0, sizeof(portmod_lane_connection_t));
    portmod_lane_connection->core_index = PORTMOD_CORE_INDEX_INVALID;
    portmod_lane_connection->lane_index = PORTMOD_LANE_INDEX_INVALID;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_phy_core_info_t_validate(int unit, const portmod_phy_core_info_t* portmod_phy_core_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_phy_core_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_phy_core_info_t_init(int unit, portmod_phy_core_info_t* portmod_phy_core_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_phy_core_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_phy_core_info NULL parameter"));
    }
    sal_memset(portmod_phy_core_info, 0, sizeof(portmod_phy_core_info_t));
    phymod_core_access_t_init(&portmod_phy_core_info->core_access);

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_xphy_lane_connection_t_validate(int unit, const portmod_xphy_lane_connection_t* portmod_xphy_lane_connection)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_xphy_lane_connection == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_xphy_lane_connection_t_init(int unit, portmod_xphy_lane_connection_t* portmod_xphy_lane_connection)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_xphy_lane_connection == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_xphy_lane_connection NULL parameter"));
    }
    sal_memset(portmod_xphy_lane_connection, 0, sizeof(portmod_xphy_lane_connection_t));
    portmod_xphy_lane_connection->xphy_id = PORTMOD_XPHY_ID_INVALID;
    portmod_xphy_lane_connection->ss_lane_mask = PORTMOD_LANE_INDEX_INVALID;
    portmod_xphy_lane_connection->ls_lane_mask = PORTMOD_LANE_INDEX_INVALID;
    portmod_xphy_lane_connection->rsvd1 = PORTMOD_LANE_INDEX_INVALID;
    portmod_xphy_lane_connection->rsvd2 = PORTMOD_LANE_INDEX_INVALID;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_xphy_lane_attach_to_pm(int unit, pm_info_t pm_info, int iphy, int phyn, const portmod_xphy_lane_connection_t* lane_connection)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_xphy_lane_connection_t_validate(unit, lane_connection)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("lane_connection validation failed"));
    }

    /* Dispatch */
    __type__ = (pm_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_xphy_lane_attach_to_pm) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_xphy_lane_attach_to_pm(unit, pm_info, iphy, phyn, lane_connection);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_xphy_lane_attach_to_pm isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_xphy_lane_detach_from_pm(int unit, pm_info_t pm_info, int iphy, int phyn, portmod_xphy_lane_connection_t* lane_connection)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_xphy_lane_connection_t_init(unit, lane_connection)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("lane_connection initialization failed"));
    }

    /* Dispatch */
    __type__ = (pm_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_xphy_lane_detach_from_pm) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_xphy_lane_detach_from_pm(unit, pm_info, iphy, phyn, lane_connection);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_xphy_lane_detach_from_pm isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_ext_phy_lane_attach_to_pm(int unit, pm_info_t pm_info, int iphy, int phyn, const portmod_lane_connection_t* lane_connection)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_lane_connection_t_validate(unit, lane_connection)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("lane_connection validation failed"));
    }

    /* Dispatch */
    __type__ = (pm_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_ext_phy_lane_attach_to_pm) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_ext_phy_lane_attach_to_pm(unit, pm_info, iphy, phyn, lane_connection);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_ext_phy_lane_attach_to_pm isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_ext_phy_lane_detach_from_pm(int unit, pm_info_t pm_info, int iphy, int phyn, portmod_lane_connection_t* lane_connection)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_lane_connection_t_init(unit, lane_connection)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("lane_connection initialization failed"));
    }

    /* Dispatch */
    __type__ = (pm_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_ext_phy_lane_detach_from_pm) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_ext_phy_lane_detach_from_pm(unit, pm_info, iphy, phyn, lane_connection);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_ext_phy_lane_detach_from_pm isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_lag_failover_status_toggle(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_lag_failover_status_toggle) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_lag_failover_status_toggle(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_lag_failover_status_toggle isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_lag_failover_loopback_set(int unit, int port, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_lag_failover_loopback_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_lag_failover_loopback_set(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_lag_failover_loopback_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_lag_failover_loopback_get(int unit, int port, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_lag_failover_loopback_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_lag_failover_loopback_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_lag_failover_loopback_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_mode_set(int unit, int port, const portmod_port_mode_info_t* mode)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_port_mode_info_t_validate(unit, mode)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_mode_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_mode_set(unit, port, pm_info, mode);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_mode_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_mode_get(int unit, int port, portmod_port_mode_info_t* mode)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(mode == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode NULL parameter"));
    }
    if(SOC_E_NONE != portmod_port_mode_info_t_init(unit, mode)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_mode_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_mode_get(unit, port, pm_info, mode);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_mode_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_encap_set(int unit, int port, int flags, portmod_encap_t encap)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_encap_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_encap_set(unit, port, pm_info, flags, encap);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_encap_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_encap_get(int unit, int port, int* flags, portmod_encap_t* encap)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(flags == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("flags NULL parameter"));
    }
    if(encap == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("encap NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_encap_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_encap_get(unit, port, pm_info, flags, encap);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_encap_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_higig_mode_set(int unit, int port, int mode)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_higig_mode_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_higig_mode_set(unit, port, pm_info, mode);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_higig_mode_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_higig_mode_get(int unit, int port, int* mode)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(mode == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_higig_mode_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_higig_mode_get(unit, port, pm_info, mode);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_higig_mode_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_higig2_mode_set(int unit, int port, int mode)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_higig2_mode_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_higig2_mode_set(unit, port, pm_info, mode);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_higig2_mode_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_higig2_mode_get(int unit, int port, int* mode)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(mode == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_higig2_mode_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_higig2_mode_get(unit, port, pm_info, mode);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_higig2_mode_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_config_port_type_set(int unit, int port, int type)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_config_port_type_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_config_port_type_set(unit, port, pm_info, type);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_config_port_type_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_config_port_type_get(int unit, int port, int* type)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(type == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("type NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_config_port_type_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_config_port_type_get(unit, port, pm_info, type);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_config_port_type_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_trunk_hwfailover_config_set(int unit, int port, int hw_count)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_trunk_hwfailover_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_trunk_hwfailover_config_set(unit, port, pm_info, hw_count);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_trunk_hwfailover_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_trunk_hwfailover_config_get(int unit, int port, int* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_trunk_hwfailover_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_trunk_hwfailover_config_get(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_trunk_hwfailover_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_trunk_hwfailover_status_get(int unit, int port, int* loopback)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(loopback == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("loopback NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_trunk_hwfailover_status_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_trunk_hwfailover_status_get(unit, port, pm_info, loopback);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_trunk_hwfailover_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_diag_ctrl(int unit, int port, uint32 inst, int op_type, int op_cmd, const void* arg)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_diag_ctrl) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_diag_ctrl(unit, port, pm_info, inst, op_type, op_cmd, arg);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_diag_ctrl isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_ref_clk_get(int unit, int port, int* ref_clk)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(ref_clk == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ref_clk NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_ref_clk_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_ref_clk_get(unit, port, pm_info, ref_clk);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_ref_clk_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_lag_failover_disable(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_lag_failover_disable) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_lag_failover_disable(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_lag_failover_disable isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_lag_remove_failover_lpbk_set(int unit, int port, int val)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_lag_remove_failover_lpbk_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_lag_remove_failover_lpbk_set(unit, port, pm_info, val);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_lag_remove_failover_lpbk_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_lag_remove_failover_lpbk_get(int unit, int port, int* val)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(val == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("val NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_lag_remove_failover_lpbk_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_lag_remove_failover_lpbk_get(unit, port, pm_info, val);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_lag_remove_failover_lpbk_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_cntmaxsize_set(int unit, int port, int val)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_cntmaxsize_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_cntmaxsize_set(unit, port, pm_info, val);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_cntmaxsize_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_cntmaxsize_get(int unit, int port, int* val)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(val == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("val NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_cntmaxsize_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_cntmaxsize_get(unit, port, pm_info, val);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_cntmaxsize_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_multi_get(int unit, int port, portmod_multi_get_t* multi_get)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(multi_get == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("multi_get NULL parameter"));
    }
    if(SOC_E_NONE != portmod_multi_get_t_validate(unit, multi_get)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("multi_get validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_multi_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_multi_get(unit, port, pm_info, multi_get);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_multi_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_drain_cell_get(int unit, int port, portmod_drain_cells_t* drain_cells)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(drain_cells == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("drain_cells NULL parameter"));
    }
    if(SOC_E_NONE != portmod_drain_cells_t_init(unit, drain_cells)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("drain_cells initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_drain_cell_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_drain_cell_get(unit, port, pm_info, drain_cells);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_drain_cell_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_drain_cell_stop(int unit, int port, const portmod_drain_cells_t* drain_cells)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_drain_cells_t_validate(unit, drain_cells)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("drain_cells validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_drain_cell_stop) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_drain_cell_stop(unit, port, pm_info, drain_cells);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_drain_cell_stop isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_drain_cell_start(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_drain_cell_start) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_drain_cell_start(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_drain_cell_start isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_drain_cells_rx_enable(int unit, int port, int rx_en)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_drain_cells_rx_enable) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_drain_cells_rx_enable(unit, port, pm_info, rx_en);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_drain_cells_rx_enable isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_egress_queue_drain_rx_en(int unit, int port, int rx_en)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_egress_queue_drain_rx_en) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_egress_queue_drain_rx_en(unit, port, pm_info, rx_en);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_egress_queue_drain_rx_en isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_mac_ctrl_set(int unit, int port, uint64 ctrl)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_mac_ctrl_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_mac_ctrl_set(unit, port, pm_info, ctrl);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_mac_ctrl_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_txfifo_cell_cnt_get(int unit, int port, uint32* cnt)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(cnt == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cnt NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_txfifo_cell_cnt_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_txfifo_cell_cnt_get(unit, port, pm_info, cnt);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_txfifo_cell_cnt_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_egress_queue_drain_get(int unit, int port, uint64* ctrl, int* rxen)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(ctrl == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ctrl NULL parameter"));
    }
    if(rxen == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("rxen NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_egress_queue_drain_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_egress_queue_drain_get(unit, port, pm_info, ctrl, rxen);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_egress_queue_drain_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_mac_reset_set(int unit, int port, int val)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_mac_reset_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_mac_reset_set(unit, port, pm_info, val);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_mac_reset_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_soft_reset_toggle(int unit, int port, int idx)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_soft_reset_toggle) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_soft_reset_toggle(unit, port, pm_info, idx);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_soft_reset_toggle isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_mac_reset_check(int unit, int port, int enable, int* reset)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(reset == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("reset NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_mac_reset_check) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_mac_reset_check(unit, port, pm_info, enable, reset);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_mac_reset_check isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_core_num_get(int unit, int port, int* core_num)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(core_num == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("core_num NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_core_num_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_core_num_get(unit, port, pm_info, core_num);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_core_num_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_higig_e2ecc_hdr_t_validate(int unit, const portmod_port_higig_e2ecc_hdr_t* portmod_port_higig_e2ecc_hdr)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_port_higig_e2ecc_hdr == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_higig_e2ecc_hdr_t_init(int unit, portmod_port_higig_e2ecc_hdr_t* portmod_port_higig_e2ecc_hdr)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_port_higig_e2ecc_hdr == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_port_higig_e2ecc_hdr NULL parameter"));
    }
    sal_memset(portmod_port_higig_e2ecc_hdr, 0, sizeof(portmod_port_higig_e2ecc_hdr_t));

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_e2ecc_hdr_set(int unit, int port, const portmod_port_higig_e2ecc_hdr_t* e2ecc_hdr)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_port_higig_e2ecc_hdr_t_validate(unit, e2ecc_hdr)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("e2ecc_hdr validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_e2ecc_hdr_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_e2ecc_hdr_set(unit, port, pm_info, e2ecc_hdr);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_e2ecc_hdr_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_e2ecc_hdr_get(int unit, int port, portmod_port_higig_e2ecc_hdr_t* e2ecc_hdr)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(e2ecc_hdr == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("e2ecc_hdr NULL parameter"));
    }
    if(SOC_E_NONE != portmod_port_higig_e2ecc_hdr_t_init(unit, e2ecc_hdr)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("e2ecc_hdr initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_e2ecc_hdr_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_e2ecc_hdr_get(unit, port, pm_info, e2ecc_hdr);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_e2ecc_hdr_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_e2e_enable_set(int unit, int port, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_e2e_enable_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_e2e_enable_set(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_e2e_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_e2e_enable_get(int unit, int port, int* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_e2e_enable_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_e2e_enable_get(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_e2e_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_fallback_lane_get(int unit, int port, int* fallback_lane)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(fallback_lane == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("fallback_lane NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_fallback_lane_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_fallback_lane_get(unit, port, pm_info, fallback_lane);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_fallback_lane_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_speed_get(int unit, int port, int* speed)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(speed == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("speed NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_speed_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_speed_get(unit, port, pm_info, speed);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_speed_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_tsc_refclock_set(int unit, int port, int ref_in, int ref_out)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tsc_refclock_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tsc_refclock_set(unit, port, pm_info, ref_in, ref_out);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tsc_refclock_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_tsc_refclock_get(int unit, int port, int* ref_in, int* ref_out)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(ref_in == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ref_in NULL parameter"));
    }
    if(ref_out == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ref_out NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tsc_refclock_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tsc_refclock_get(unit, port, pm_info, ref_in, ref_out);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tsc_refclock_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_discard_set(int unit, int port, int discard)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_discard_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_discard_set(unit, port, pm_info, discard);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_discard_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_soft_reset_set(int unit, int port, int idx, int val, int flags)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_soft_reset_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_soft_reset_set(unit, port, pm_info, idx, val, flags);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_soft_reset_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_tx_down(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tx_down) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tx_down(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tx_down isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_logical_lane_order_set(int unit, int port, const int* lane_order, int lane_order_size)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_logical_lane_order_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_logical_lane_order_set(unit, port, pm_info, lane_order, lane_order_size);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_logical_lane_order_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_logical_lane_order_get(int unit, int port, int lane_order_max_size, int* lane_order, int* lane_order_actual_size)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(lane_order == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("lane_order NULL parameter"));
    }
    if(lane_order_actual_size == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("lane_order_actual_size NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_logical_lane_order_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_logical_lane_order_get(unit, port, pm_info, lane_order_max_size, lane_order, lane_order_actual_size);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_logical_lane_order_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pgw_reconfig(int unit, int port, const portmod_port_mode_info_t* pmode, int phy_port, int flags)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_port_mode_info_t_validate(unit, pmode)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pmode validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pgw_reconfig) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pgw_reconfig(unit, port, pm_info, pmode, phy_port, flags);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pgw_reconfig isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_notify(int unit, int port, int link)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_notify) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_notify(unit, port, pm_info, link);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_notify isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_control_phy_timesync_set(int unit, int port, portmod_port_control_phy_timesync_t config, uint64 value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_control_phy_timesync_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_control_phy_timesync_set(unit, port, pm_info, config, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_control_phy_timesync_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_control_phy_timesync_get(int unit, int port, portmod_port_control_phy_timesync_t config, uint64* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_control_phy_timesync_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_control_phy_timesync_get(unit, port, pm_info, config, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_control_phy_timesync_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_config_set(int unit, int port, const portmod_phy_timesync_config_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_config_set(unit, port, pm_info, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_config_get(int unit, int port, portmod_phy_timesync_config_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_config_get(unit, port, pm_info, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_enable_set(int unit, int port, uint32 enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_enable_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_enable_set(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_enable_get(int unit, int port, uint32* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_enable_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_enable_get(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_nco_addend_set(int unit, int port, uint32 freq_step)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_nco_addend_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_nco_addend_set(unit, port, pm_info, freq_step);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_nco_addend_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_nco_addend_get(int unit, int port, uint32* freq_step)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(freq_step == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("freq_step NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_nco_addend_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_nco_addend_get(unit, port, pm_info, freq_step);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_nco_addend_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_framesync_mode_set(int unit, int port, const portmod_timesync_framesync_t* framesync)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_framesync_mode_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_framesync_mode_set(unit, port, pm_info, framesync);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_framesync_mode_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_framesync_mode_get(int unit, int port, portmod_timesync_framesync_t* framesync)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(framesync == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("framesync NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_framesync_mode_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_framesync_mode_get(unit, port, pm_info, framesync);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_framesync_mode_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_local_time_set(int unit, int port, uint64 local_time)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_local_time_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_local_time_set(unit, port, pm_info, local_time);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_local_time_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_local_time_get(int unit, int port, uint64* local_time)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(local_time == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("local_time NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_local_time_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_local_time_get(unit, port, pm_info, local_time);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_local_time_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_load_ctrl_set(int unit, int port, uint32 load_once, uint32 load_always)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_load_ctrl_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_load_ctrl_set(unit, port, pm_info, load_once, load_always);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_load_ctrl_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_load_ctrl_get(int unit, int port, uint32* load_once, uint32* load_always)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(load_once == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("load_once NULL parameter"));
    }
    if(load_always == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("load_always NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_load_ctrl_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_load_ctrl_get(unit, port, pm_info, load_once, load_always);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_load_ctrl_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_tx_timestamp_offset_set(int unit, int port, uint32 ts_offset)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_tx_timestamp_offset_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_tx_timestamp_offset_set(unit, port, pm_info, ts_offset);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_tx_timestamp_offset_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_tx_timestamp_offset_get(int unit, int port, uint32* ts_offset)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(ts_offset == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ts_offset NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_tx_timestamp_offset_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_tx_timestamp_offset_get(unit, port, pm_info, ts_offset);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_tx_timestamp_offset_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_rx_timestamp_offset_set(int unit, int port, uint32 ts_offset)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_rx_timestamp_offset_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_rx_timestamp_offset_set(unit, port, pm_info, ts_offset);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_rx_timestamp_offset_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_rx_timestamp_offset_get(int unit, int port, uint32* ts_offset)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(ts_offset == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ts_offset NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_rx_timestamp_offset_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_rx_timestamp_offset_get(unit, port, pm_info, ts_offset);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_rx_timestamp_offset_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_phy_intr_enable_set(int unit, int port, uint32 intr_enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_phy_intr_enable_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_phy_intr_enable_set(unit, port, pm_info, intr_enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_phy_intr_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_phy_intr_enable_get(int unit, int port, uint32* intr_enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(intr_enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("intr_enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_phy_intr_enable_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_phy_intr_enable_get(unit, port, pm_info, intr_enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_phy_intr_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_phy_intr_status_get(int unit, int port, uint32* intr_status)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(intr_status == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("intr_status NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_phy_intr_status_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_phy_intr_status_get(unit, port, pm_info, intr_status);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_phy_intr_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_phy_intr_status_clear(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_phy_intr_status_clear) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_phy_intr_status_clear(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_phy_intr_status_clear isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_phy_timesync_do_sync(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_phy_timesync_do_sync) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_phy_timesync_do_sync(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_phy_timesync_do_sync isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_capture_timestamp_get(int unit, int port, uint64* cap_ts)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(cap_ts == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cap_ts NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_capture_timestamp_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_capture_timestamp_get(unit, port, pm_info, cap_ts);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_capture_timestamp_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_heartbeat_timestamp_get(int unit, int port, uint64* hb_ts)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(hb_ts == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("hb_ts NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_heartbeat_timestamp_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_heartbeat_timestamp_get(unit, port, pm_info, hb_ts);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_heartbeat_timestamp_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_edc_config_set(int unit, int port, const portmod_edc_config_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_edc_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_edc_config_set(unit, port, pm_info, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_edc_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_edc_config_get(int unit, int port, portmod_edc_config_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_edc_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_edc_config_get(unit, port, pm_info, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_edc_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_interrupt_enable_set(int unit, int port, int intr_type, uint32 val)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_interrupt_enable_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_interrupt_enable_set(unit, port, pm_info, intr_type, val);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_interrupt_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_interrupt_enable_get(int unit, int port, int intr_type, uint32* val)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(val == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("val NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_interrupt_enable_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_interrupt_enable_get(unit, port, pm_info, intr_type, val);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_interrupt_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_interrupt_get(int unit, int port, int intr_type, uint32* val)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(val == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("val NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_interrupt_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_interrupt_get(unit, port, pm_info, intr_type, val);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_interrupt_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_interrupts_get(int unit, int port, int arr_max_size, uint32* intr_arr, uint32* size)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(intr_arr == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("intr_arr NULL parameter"));
    }
    if(size == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("size NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_interrupts_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_interrupts_get(unit, port, pm_info, arr_max_size, intr_arr, size);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_interrupts_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_stat_val_t_validate(int unit, portmod_stat_val_t portmod_stat_val)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_stat_val >= portmodCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_check_legacy_phy(int unit, int port, int* legacy_phy)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(legacy_phy == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("legacy_phy NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_check_legacy_phy) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_check_legacy_phy(unit, port, pm_info, legacy_phy);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_check_legacy_phy isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_failover_mode_set(int unit, int port, phymod_failover_mode_t failover)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_failover_mode_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_failover_mode_set(unit, port, pm_info, failover);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_failover_mode_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_failover_mode_get(int unit, int port, phymod_failover_mode_t* failover)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(failover == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("failover NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_failover_mode_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_failover_mode_get(unit, port, pm_info, failover);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_failover_mode_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_mac_rsv_mask_set(int unit, int port, uint32 rsv_mask)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_mac_rsv_mask_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_mac_rsv_mask_set(unit, port, pm_info, rsv_mask);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_mac_rsv_mask_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_mib_reset_toggle(int unit, int port, int port_index)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_mib_reset_toggle) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_mib_reset_toggle(unit, port, pm_info, port_index);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_mib_reset_toggle isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_warmboot_db_restore(int unit, int port, const portmod_port_interface_config_t* intf_config, const portmod_port_init_config_t* init_config, phymod_operation_mode_t phy_op_mode)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_port_interface_config_t_validate(unit, intf_config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("intf_config validation failed"));
    }

    if(SOC_E_NONE != portmod_port_init_config_t_validate(unit, init_config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("init_config validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_warmboot_db_restore) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_warmboot_db_restore(unit, port, pm_info, intf_config, init_config, phy_op_mode);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_warmboot_db_restore isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_flow_control_set(int unit, int port, int merge_mode_en, int parallel_fc_en)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_flow_control_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_flow_control_set(unit, port, pm_info, merge_mode_en, parallel_fc_en);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_flow_control_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_update_dynamic_state(int unit, int port, uint32_t port_dynamic_state)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_update_dynamic_state) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_update_dynamic_state(unit, port, pm_info, port_dynamic_state);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_update_dynamic_state isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_phy_op_mode_get(int unit, int port, phymod_operation_mode_t* val)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(val == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("val NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_phy_op_mode_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_phy_op_mode_get(unit, port, pm_info, val);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_phy_op_mode_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_lane_map_set(int unit, int port, const phymod_lane_map_t* lane_map)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_lane_map_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_lane_map_set(unit, port, pm_info, lane_map);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_lane_map_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_lane_map_get(int unit, int port, phymod_lane_map_t* lane_map)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(lane_map == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("lane_map NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_lane_map_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_lane_map_get(unit, port, pm_info, lane_map);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_lane_map_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_polarity_set(int unit, int port, const phymod_polarity_t* polarity)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_polarity_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_polarity_set(unit, port, pm_info, polarity);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_polarity_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_polarity_get(int unit, int port, phymod_polarity_t* polarity)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(polarity == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("polarity NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_polarity_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_polarity_get(unit, port, pm_info, polarity);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_polarity_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_medium_config_set(int unit, int port, soc_port_medium_t medium, soc_phy_config_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_medium_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_medium_config_set(unit, port, pm_info, medium, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_medium_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_medium_config_get(int unit, int port, soc_port_medium_t medium, soc_phy_config_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_medium_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_medium_config_get(unit, port, pm_info, medium, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_medium_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_medium_get(int unit, int port, soc_port_medium_t* medium)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(medium == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("medium NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_medium_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_medium_get(unit, port, pm_info, medium);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_medium_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_pm_is_in_pm12x10(int unit, pm_info_t pm_info, int* in_pm12x10)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(in_pm12x10 == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("in_pm12x10 NULL parameter"));
    }
    /* Dispatch */
    __type__ = (pm_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_is_in_pm12x10) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_is_in_pm12x10(unit, pm_info, in_pm12x10);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_is_in_pm12x10 isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_slow_read_rate_set(int unit, int port, int slow_read_rate)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_slow_read_rate_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_slow_read_rate_set(unit, port, pm_info, slow_read_rate);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_slow_read_rate_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_resources_t_validate(int unit, const portmod_port_resources_t* portmod_port_resources)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_port_resources == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_dispatch_type_t_validate(unit, portmod_port_resources->pm_type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pm_type validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_resources_t_init(int unit, portmod_port_resources_t* portmod_port_resources)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_port_resources == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_port_resources NULL parameter"));
    }
    sal_memset(portmod_port_resources, 0, sizeof(portmod_port_resources_t));
    portmod_port_resources->speed = 0;
    portmod_port_resources->num_lane = 0;
    portmod_port_resources->encap_mode = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_pll_div_get(int unit, int port, const portmod_port_resources_t* port_resource, uint32_t* pll_div)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_port_resources_t_validate(unit, port_resource)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("port_resource validation failed"));
    }

    if(pll_div == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pll_div NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pll_div_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pll_div_get(unit, port, port_resource, pll_div);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pll_div_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_master_get(int unit, int port, int* master_mode)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(master_mode == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("master_mode NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_master_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_master_get(unit, port, pm_info, master_mode);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_master_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_lane_count_get(int unit, int port, int line_side, int* num_lanes)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(num_lanes == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("num_lanes NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_lane_count_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_lane_count_get(unit, port, pm_info, line_side, num_lanes);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_lane_count_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}



#undef _ERR_MSG_MODULE_NAME
