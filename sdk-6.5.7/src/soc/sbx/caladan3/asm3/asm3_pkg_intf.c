/**
 * $Id: pkg_c3_lib_c.stg,v 1.25 Broadcom SDK $
 * $Copyright: (c) 2016 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * Author: vn-1109210841
 *
 * C3Asm3__PkgInt.c
 *
 * Support library for the C3 asm3 package
 */

#include <shared/bsl.h>

#ifdef __ASM3_PKG_TEMPLATE_TEST__
#include "template__PkgInt.h"
#else
#include "asm3_pkg_intf.h"
#endif /*__ASM3_PKG_TEMPLATE_TEST__*/

#include "soc/cm.h"

/**
 * ----------------------------------------------------------------------------
 * C3Asm3__Md5
 */

typedef unsigned long u8;
typedef unsigned char u1;
#define ASM3__GET_ULONG(n,b,i) {(n) = ((u8)(b)[(i)]) | ((u8)(b)[(i)+1]<<8 ) | ((u8)(b)[(i)+2]<<16 ) | ( (u8)(b)[(i)+3]<<24 );}
#define ASM3__PUT_ULONG(n,b,i) {(b)[(i)] = (u1)((n)); (b)[(i)+1] = (u1)((n)>>8); (b)[(i)+2] = (u1)((n)>>16 ); (b)[(i)+3] = (u1)((n)>>24 );}

#ifndef MALLOC_PKGC3
#include <stdlib.h>/*for the exit()*/
#define MALLOC_PKGC3(x) sal_alloc((x), "Asm3 alloc")
#define FREE_PKGC3(x) sal_free((x))
#endif

extern sal_mutex_t bankSwapLock[SOC_MAX_NUM_DEVICES];

int C3Asm3__Md5__init (C3Asm3__Md5 *_p)
{
  int i=0;

  if (_p == NULL) return 1;

  _p->m_count[0] = 0;
  _p->m_count[1] = 0;
  _p->m_state[0] = 0x67452301;
  _p->m_state[1] = 0xEFCDAB89;
  _p->m_state[2] = 0x98BADCFE;
  _p->m_state[3] = 0x10325476;

  for (i=0; i<sizeof (_p->m_pad); i++) _p->m_pad[i] = 0;
  _p->m_pad[0] = 0x80;

  return 0;
}

static int C3Asm3__Md5__process( C3Asm3__Md5 *_p, u1 _data[64] )
{
  u8 X[16], A, B, C, D;

  if (_p == NULL) return 1;

  ASM3__GET_ULONG( X[ 0], _data,  0 );
  ASM3__GET_ULONG( X[ 1], _data,  4 );
  ASM3__GET_ULONG( X[ 2], _data,  8 );
  ASM3__GET_ULONG( X[ 3], _data, 12 );
  ASM3__GET_ULONG( X[ 4], _data, 16 );
  ASM3__GET_ULONG( X[ 5], _data, 20 );
  ASM3__GET_ULONG( X[ 6], _data, 24 );
  ASM3__GET_ULONG( X[ 7], _data, 28 );
  ASM3__GET_ULONG( X[ 8], _data, 32 );
  ASM3__GET_ULONG( X[ 9], _data, 36 );
  ASM3__GET_ULONG( X[10], _data, 40 );
  ASM3__GET_ULONG( X[11], _data, 44 );
  ASM3__GET_ULONG( X[12], _data, 48 );
  ASM3__GET_ULONG( X[13], _data, 52 );
  ASM3__GET_ULONG( X[14], _data, 56 );
  ASM3__GET_ULONG( X[15], _data, 60 );

#define S(x,n) ((x << n) | ((x & 0xFFFFFFFF) >> (32 - n)))
#define P(a,b,c,d,k,s,t) {a += F(b,c,d) + X[k] + t; a = S(a,s) + b;}

  A = _p->m_state[0];
  B = _p->m_state[1];
  C = _p->m_state[2];
  D = _p->m_state[3];

#define F(x,y,z) (z ^ (x & (y ^ z)))

  P( A, B, C, D,  0,  7, 0xD76AA478 );
  P( D, A, B, C,  1, 12, 0xE8C7B756 );
  P( C, D, A, B,  2, 17, 0x242070DB );
  P( B, C, D, A,  3, 22, 0xC1BDCEEE );
  P( A, B, C, D,  4,  7, 0xF57C0FAF );
  P( D, A, B, C,  5, 12, 0x4787C62A );
  P( C, D, A, B,  6, 17, 0xA8304613 );
  P( B, C, D, A,  7, 22, 0xFD469501 );
  P( A, B, C, D,  8,  7, 0x698098D8 );
  P( D, A, B, C,  9, 12, 0x8B44F7AF );
  P( C, D, A, B, 10, 17, 0xFFFF5BB1 );
  P( B, C, D, A, 11, 22, 0x895CD7BE );
  P( A, B, C, D, 12,  7, 0x6B901122 );
  P( D, A, B, C, 13, 12, 0xFD987193 );
  P( C, D, A, B, 14, 17, 0xA679438E );
  P( B, C, D, A, 15, 22, 0x49B40821 );

#undef F

#define F(x,y,z) (y ^ (z & (x ^ y)))

  P( A, B, C, D,  1,  5, 0xF61E2562 );
  P( D, A, B, C,  6,  9, 0xC040B340 );
  P( C, D, A, B, 11, 14, 0x265E5A51 );
  P( B, C, D, A,  0, 20, 0xE9B6C7AA );
  P( A, B, C, D,  5,  5, 0xD62F105D );
  P( D, A, B, C, 10,  9, 0x02441453 );
  P( C, D, A, B, 15, 14, 0xD8A1E681 );
  P( B, C, D, A,  4, 20, 0xE7D3FBC8 );
  P( A, B, C, D,  9,  5, 0x21E1CDE6 );
  P( D, A, B, C, 14,  9, 0xC33707D6 );
  P( C, D, A, B,  3, 14, 0xF4D50D87 );
  P( B, C, D, A,  8, 20, 0x455A14ED );
  P( A, B, C, D, 13,  5, 0xA9E3E905 );
  P( D, A, B, C,  2,  9, 0xFCEFA3F8 );
  P( C, D, A, B,  7, 14, 0x676F02D9 );
  P( B, C, D, A, 12, 20, 0x8D2A4C8A );

#undef F

#define F(x,y,z) (x ^ y ^ z)

  P( A, B, C, D,  5,  4, 0xFFFA3942 );
  P( D, A, B, C,  8, 11, 0x8771F681 );
  P( C, D, A, B, 11, 16, 0x6D9D6122 );
  P( B, C, D, A, 14, 23, 0xFDE5380C );
  P( A, B, C, D,  1,  4, 0xA4BEEA44 );
  P( D, A, B, C,  4, 11, 0x4BDECFA9 );
  P( C, D, A, B,  7, 16, 0xF6BB4B60 );
  P( B, C, D, A, 10, 23, 0xBEBFBC70 );
  P( A, B, C, D, 13,  4, 0x289B7EC6 );
  P( D, A, B, C,  0, 11, 0xEAA127FA );
  P( C, D, A, B,  3, 16, 0xD4EF3085 );
  P( B, C, D, A,  6, 23, 0x04881D05 );
  P( A, B, C, D,  9,  4, 0xD9D4D039 );
  P( D, A, B, C, 12, 11, 0xE6DB99E5 );
  P( C, D, A, B, 15, 16, 0x1FA27CF8 );
  P( B, C, D, A,  2, 23, 0xC4AC5665 );

#undef F

#define F(x,y,z) (y ^ (x | ~z))

  P( A, B, C, D,  0,  6, 0xF4292244 );
  P( D, A, B, C,  7, 10, 0x432AFF97 );
  P( C, D, A, B, 14, 15, 0xAB9423A7 );
  P( B, C, D, A,  5, 21, 0xFC93A039 );
  P( A, B, C, D, 12,  6, 0x655B59C3 );
  P( D, A, B, C,  3, 10, 0x8F0CCC92 );
  P( C, D, A, B, 10, 15, 0xFFEFF47D );
  P( B, C, D, A,  1, 21, 0x85845DD1 );
  P( A, B, C, D,  8,  6, 0x6FA87E4F );
  P( D, A, B, C, 15, 10, 0xFE2CE6E0 );
  P( C, D, A, B,  6, 15, 0xA3014314 );
  P( B, C, D, A, 13, 21, 0x4E0811A1 );
  P( A, B, C, D,  4,  6, 0xF7537E82 );
  P( D, A, B, C, 11, 10, 0xBD3AF235 );
  P( C, D, A, B,  2, 15, 0x2AD7D2BB );
  P( B, C, D, A,  9, 21, 0xEB86D391 );

#undef F

  _p->m_state[0] += A;
  _p->m_state[1] += B;
  _p->m_state[2] += C;
  _p->m_state[3] += D;

  return 0;
}

/* MD5 process buffer */
int C3Asm3__Md5__update( C3Asm3__Md5 *_p, u1 *_input, int _ilen )
{
  int fill;
  u8 left;

  if (_p == NULL) return 1;
  if (_input == NULL) return 2;
  if( _ilen <= 0 ) return 3;

  left = _p->m_count[0] & 0x3F;
  fill = 64 - left;

  _p->m_count[0] += _ilen;
  _p->m_count[0] &= 0xFFFFFFFF;

  if( _p->m_count[0] < (u8) _ilen ) _p->m_count[1]++;

  if( left && _ilen >= fill ) {
    memcpy ( (void *) (_p->m_buf + left), (void *) _input, fill);
    C3Asm3__Md5__process (_p, _p->m_buf);
    _input += fill;
    _ilen  -= fill;
    left = 0;
  }

  while( _ilen >= 64 ) {
    C3Asm3__Md5__process (_p, _input);
    _input += 64;
    _ilen  -= 64;
  }

  if( _ilen > 0 ) memcpy ( (void *)(_p->m_buf + left), (void *)_input, _ilen);

  return 0;
}

/* MD5 final digest */
int C3Asm3__Md5__finish( C3Asm3__Md5 *_p, u1 output[16] )
{
  u8 last, padn, high, low;
  u1 msglen[8];
  int i=0;

  if (_p == NULL) return 1;

  high = ( _p->m_count[0] >> 29 ) | ( _p->m_count[1] <<  3 );
  low  = ( _p->m_count[0] <<  3 );

  ASM3__PUT_ULONG( low,  msglen, 0 );
  ASM3__PUT_ULONG( high, msglen, 4 );

  last = _p->m_count[0] & 0x3F;
  padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );

  C3Asm3__Md5__update( _p, (u1 *) _p->m_pad, padn );
  /* coverity[overrun-buffer-val] */
  C3Asm3__Md5__update( _p, msglen, 8 );

  ASM3__PUT_ULONG( _p->m_state[0], output,  0 );
  ASM3__PUT_ULONG( _p->m_state[1], output,  4 );
  ASM3__PUT_ULONG( _p->m_state[2], output,  8 );
  ASM3__PUT_ULONG( _p->m_state[3], output, 12 );

  for (i=0; i<sizeof( C3Asm3__Md5); i++) ((u1*)_p)[i] = 0;

  return 0;
}

/**
 * ----------------------------------------------------------------------------
 * C3Asm3__PkgNcae
 */

/* initialize interface structure to be empty */
int C3Asm3__PkgNcae__init(C3Asm3__PkgNcae *_p)
{
  if (_p == NULL) return 1;

  _p->m_name = 0; /*name associated with the value*/
  _p->m_va   = 0; /*value of the constant*/
  _p->m_fc   = 0; /*flag which indicate if value is in the bytecode*/
  _p->m_fdin = 0;

  /*corresponded bytecode parameters, valid only if m_fc is not 0*/
  _p->m_sn = 0;  /*stream number*/
  _p->m_in = 0;  /*instruction number*/
  _p->m_bo = 0;  /*offset of the sub-field in the machine word (bits)*/
  _p->m_bl = 0;  /*length of the sub-field in the machine word (bits)*/

  return 0;
}

/* destroy interface structure to be empty */
int C3Asm3__PkgNcae__destroy(C3Asm3__PkgNcae *_p)
{
  if (_p == NULL) return 1;

  if(_p->m_fdin) FREE_PKGC3((void*)_p->m_name); /* if string is dinamically allocated, free the memory*/
  if (C3Asm3__PkgNcae__init(_p)) return 2;

  return 0;
}

/* compare 2 structure and return result in a_e;
 * do not check m_fdin - flag indicating dynamic allocation,
 * we do not save it in the buffer / file or read it from there
 */
int C3Asm3__PkgNcae__equ(C3Asm3__PkgNcae *a_a, C3Asm3__PkgNcae *a_b, int *a_e)
{
  if (a_a == NULL) return 1;
  if (a_b == NULL) return 2;
  if (a_e == NULL) return 3;

  if (a_a->m_name==0 || a_b->m_name==0) return 4; /* non initialized name error */

  *a_e = (int) (
		STRNCMP_VN (a_a->m_name, a_b->m_name, STRMAX_VN)==0
		&& a_a->m_fc == a_b->m_fc
		&& a_a->m_va == a_b->m_va
		&& a_a->m_sn == a_b->m_sn
		&& a_a->m_in == a_b->m_in
		&& a_a->m_bo == a_b->m_bo
		&& a_a->m_bl == a_b->m_bl
		);

  return 0;
}

int C3Asm3__PkgNcae__writeBsc(C3Asm3__PkgNcae *_p, Bsc *_pb)
{
  unsigned int len=0;

  if (_p == NULL) return 1;
  if (_pb == NULL) return 2;
  if (_p->m_name == NULL) return 3;

  Bsc__putUnsignedB (_pb, &_p->m_fc, 1);   /*flag which indicate if value is in the byte code*/

  len = STRLEN_VN(_p->m_name);         /*calculate length of the string*/
  if (len > STRMAX_VN) return 4;
  Bsc__putUnsignedB(_pb, &len, 7);         /*length of the string*/
  Bsc__putOctetStr(_pb, (unsigned char*)_p->m_name, len); /*name associated with the value, length limit is 128*/

  Bsc__putUnsignedB   (_pb, &_p->m_va, 32);  /*value of the constant*/

  if(_p->m_fc) {
    Bsc__putUnsignedB (_pb, &_p->m_sn, 4);  /*stream number*/
    Bsc__putUnsignedB (_pb, &_p->m_in, 12); /*instruction number*/
    Bsc__putUnsignedB (_pb, &_p->m_bo, 8);  /*offset of the sub-field in the machine word (bits)*/
    Bsc__putUnsignedB (_pb, &_p->m_bl, 8);  /*length of the sub-field in the machine word (bits)*/
  }

  return 0;
}

int C3Asm3__PkgNcae__readBsc(C3Asm3__PkgNcae *_p, Bsc *_pb)
{
  unsigned int len=0;

  if (_p == NULL) return 1;
  if (_pb == NULL) return 2;

  _p->m_fdin = TRUE_VN;                   /* set flag indicated that string is dynamically allocated*/
  Bsc__getUnsignedB (_pb, &_p->m_fc, 1);  /*flag which indicate if value is in the byte code*/

  Bsc__getUnsignedB (_pb, &len, 7);       /*length of the string*/
  if (len > STRMAX_VN) return 3;
  _p->m_name = (char*)MALLOC_PKGC3(len+1);   /* allocate buffer for the string */
  if (_p->m_name == NULL) return 4;
  /*MEMSET_VN (_p->m_name, 0, len+1);*/
  Bsc__getOctetStr(_pb, (unsigned char*)_p->m_name, len); /*name associated with the value, length limit is 128*/
  _p->m_name[len] = 0;

  Bsc__getUnsignedB (_pb, &_p->m_va, 32); /*value of the constant*/

  /*corresponded bytecode parameters, valid only if m_fc is not 0*/
  if(_p->m_fc) {
    Bsc__getUnsignedB (_pb, &_p->m_sn, 4);  /*stream number*/
    Bsc__getUnsignedB (_pb, &_p->m_in, 12); /*instruction number*/
    Bsc__getUnsignedB (_pb, &_p->m_bo, 8);  /*offset of the sub-field in the machine word (bits)*/
    Bsc__getUnsignedB (_pb, &_p->m_bl, 8);  /*length of the sub-field in the machine word (bits)*/
  } else {
    _p->m_sn = 0;
    _p->m_in = 0;
    _p->m_bo = 0;
    _p->m_bl = 0;
  }

  return 0;
}

/* copy NCA structure _ps to NCA structure _pd with dynamic buffers */
int C3Asm3__PkgNcae__copyD(C3Asm3__PkgNcae *_pd, C3Asm3__PkgNcae * _ps)
{
  unsigned int len=0;

  if (_pd == NULL) return 1;
  if (_ps == NULL) return 2;

  if(C3Asm3__PkgNcae__init(_pd)) return 3;

  /* allocate and copy name string */
  len = STRLEN_VN(_ps->m_name);
  if (len > STRMAX_VN) return 4;
  _pd->m_name = (char*)MALLOC_PKGC3(len+1); /* allocate buffer for the string */
  if (_pd->m_name == NULL) return 5;
  STRNCPY_VN(_pd->m_name, _ps->m_name, len+1);

  _pd->m_fdin  = TRUE_VN;
  _pd->m_fc = _ps->m_fc;
  _pd->m_va = _ps->m_va;

  /*corresponded byte code parameters, valid only if m_fc is not 0*/
  if(_pd->m_fc) {
    _pd->m_sn = _ps->m_sn;  /*stream number*/
    _pd->m_in = _ps->m_in;  /*instruction number*/
    _pd->m_bo = _ps->m_bo;  /*offset of the sub-field in the machine word (bits)*/
    _pd->m_bl = _ps->m_bl;  /*length of the sub-field in the machine word (bits)*/
  } else {
    _pd->m_sn = 0;
    _pd->m_in = 0;
    _pd->m_bo = 0;
    _pd->m_bl = 0;
  }

  return 0;
}

/**
 * ----------------------------------------------------------------------------
 * C3Asm3__PkgInt
 */

/* initialize interface structure to be empty */
int C3Asm3__PkgInt__init(C3Asm3__PkgInt *a_p)
{
  if (a_p == NULL) return 1;

  a_p->m_magic      = 0x12345678;

  a_p->m_tver_maj   = 0;
  a_p->m_tver_min   = 0;
  a_p->m_tver_patch = 0;

  a_p->m_uver_maj   = 0;
  a_p->m_uver_min   = 0;
  a_p->m_uver_patch = 0;

  a_p->m_fdin       = 0;
  a_p->m_snum       = 0;
  a_p->m_inum       = 0;
  a_p->m_onum       = 0;
  a_p->m_ncnum      = 0;
  a_p->m_hwid       = 0;

  a_p->m_tver_name = NULL;
  a_p->m_uver_name = NULL;

  MEMSET_VN(a_p->m_md5a, 0, sizeof (a_p->m_md5a));

  a_p->m_ncat = NULL;

  a_p->m_tmap = NULL;
  a_p->m_code = NULL;

  a_p->m_fPut = NULL;
  a_p->m_fGet = NULL;
  a_p->m_pv = NULL;

  return 0;
}

/* initialize interface structure to be empty with initialization of pointers to the hw access functions*/
int C3Asm3__PkgInt__initF(C3Asm3__PkgInt *a_p, C3Asm3__HwUcode *a_fPut, C3Asm3__HwUcode *a_fGet, void *a_pv)
{
  if (a_p==NULL) return 1;
  a_p->m_fPut = a_fPut;
  a_p->m_fGet = a_fGet;
  a_p->m_pv = a_pv;
  return 0;
}      

/* destroy interface structure to be empty */
int C3Asm3__PkgInt__destroy(C3Asm3__PkgInt *a_p)
{
  int i=0;

  if (a_p == NULL) return 1;

  if(a_p->m_fdin) {
    for (i=0; i<a_p->m_ncnum; i++) C3Asm3__PkgNcae__destroy(&a_p->m_ncat[i]);
    FREE_PKGC3(a_p->m_tver_name);
    FREE_PKGC3(a_p->m_uver_name);
    FREE_PKGC3(a_p->m_ncat);
    FREE_PKGC3(a_p->m_tmap);
    FREE_PKGC3(a_p->m_code);
  }

  if (C3Asm3__PkgInt__init(a_p)) return 2;

  return 0;
}

/**
 * compare 2 interface structures and return result in a_e;
 * we do not compare m_fdin - flag indicating dynamic allocation
 * as we no not write it to file and want compare dynamic and static structures
*/
int C3Asm3__PkgInt__equ(C3Asm3__PkgInt *a_a, C3Asm3__PkgInt *a_b, int *a_e)
{
  int i=0;
  if (a_a == NULL) return 1;
  if (a_b == NULL) return 2;
  if (a_e == NULL) return 3;
  
  if (   a_a->m_uver_name==0 || a_b->m_uver_name==0 
      || a_a->m_tver_name==0 || a_b->m_tver_name==0
      || a_a->m_ncat==0      || a_b->m_ncat==0 
      || a_a->m_tmap==0      || a_b->m_tmap==0 
      || a_a->m_code==0      || a_b->m_code==0
      ) return 4; /* non initialized buffers error */

  if (   a_a->m_snum>32      || a_b->m_snum>32 
      || a_a->m_inum>0x1000  || a_b->m_inum>0x1000 
      || a_a->m_onum>32      || a_b->m_onum>32 
	 /*|| a_a->m_ncnum>0x10000 || a_b->m_ncnum>0x10000*/
      ) return 5; /*clearly invalid values*/

  *a_e = (int) (   a_a->m_magic      == a_a->m_magic 
      
		&& a_a->m_tver_maj   == a_a->m_tver_maj    
		&& a_a->m_tver_min   == a_a->m_tver_min    
		&& a_a->m_tver_patch == a_a->m_tver_patch 
		&& STRNCMP_VN (a_a->m_tver_name, a_b->m_tver_name, STRMAX_VN)==0

		&& a_a->m_uver_maj   == a_a->m_uver_maj    
		&& a_a->m_uver_min   == a_a->m_uver_min    
		&& a_a->m_uver_patch == a_a->m_uver_patch 
		&& STRNCMP_VN (a_a->m_uver_name, a_b->m_uver_name, STRMAX_VN)==0

		&& a_a->m_snum	     == a_a->m_snum	      
		&& a_a->m_inum	     == a_a->m_inum	      
		&& a_a->m_onum	     == a_a->m_onum	      
		&& a_a->m_ncnum      == a_a->m_ncnum      
		&& a_a->m_hwid       == a_a->m_hwid      
		);
  if(*a_e == 0) return 0;

  for (i=0; i<(a_a->m_inum/8); i++) {
    *a_e = (int) (a_a->m_tmap[i] == a_b->m_tmap[i]);
    if(*a_e == 0) {
      /* printf ("i=%d, tmap[i]=0x%02x\n"); debug printing*/
      return 0;
    }
  }
  
  for (i=0; i<a_a->m_snum*a_a->m_inum*a_a->m_onum; i++) {
    *a_e = (int) (a_a->m_code[i] == a_b->m_code[i]);
    if(*a_e == 0) {
      /* debug printing 
      printf ("i=%d, stream=%d, instr=%d, octet=%d, instr(a_a)=0x%02x, instr(a_b)=0x%02x\n",
	       i,
	       i/(a_a->m_inum*a_a->m_onum), 
	       (i%(a_a->m_inum*a_a->m_onum))/a_a->m_onum,
	       i%a_a->m_onum, 
	       (int)a_a->m_code[i], 
	       (int)a_b->m_code[i]);
	  */
	       
      return 0;
    }
  }

  for (i=0; i<a_a->m_ncnum; i++) {
    if (C3Asm3__PkgNcae__equ(&a_a->m_ncat[i], &a_b->m_ncat[i], a_e)) return 3;
    if(*a_e == 0) {
      /*printf ("i=%d\n", i); debug printing*/ 
      return 0;
    }
  }
    
  return 0;
}

/* serialize all interface data into the buffer */
int C3Asm3__PkgInt__writeBsc(C3Asm3__PkgInt *a_p, Bsc *a_pb)
{
  unsigned int 
    tlen=0 
    ,clen=0 
    ,i=0 
    ,pad=0
    ,len=0 /*length of the string portion of the version*/
    ;

  /*validate interface structure parameters*/
   if (a_p == NULL) return 1;
   if (a_pb == NULL) return 2;
   if (a_p->m_ncnum != 0 && a_p->m_ncat == NULL) return 3;
   if (a_p->m_snum == 0) return 4;
   if (a_p->m_inum == 0) return 5;
   if (a_p->m_tmap == NULL) return 6;
   if (a_p->m_code ==NULL) return 7;

  /* calculate md5 checksum for the interface structure */
  if (C3Asm3__PkgInt__md5a (a_p, a_p->m_md5a)) return 8;

  Bsc__putUnsignedB (a_pb, &a_p->m_magic, 32);

  /* tool version info */
  Bsc__putUnsignedB (a_pb, &a_p->m_tver_maj, 32);
  Bsc__putUnsignedB (a_pb, &a_p->m_tver_min, 32);
  Bsc__putUnsignedB (a_pb, &a_p->m_tver_patch, 32);
  len = STRLEN_VN(a_p->m_tver_name);  /*calculate length of the string*/
  if (len > STRMAX_VN) return 9;
  Bsc__putUnsignedB(a_pb, &len, 8);         /*length of the string*/
  Bsc__putOctetStr(a_pb, (unsigned char*)a_p->m_tver_name, len); /*string*/

  /* ucode version info */
  Bsc__putUnsignedB (a_pb, &a_p->m_uver_maj, 32);
  Bsc__putUnsignedB (a_pb, &a_p->m_uver_min, 32);
  Bsc__putUnsignedB (a_pb, &a_p->m_uver_patch, 32);
  len = STRLEN_VN(a_p->m_uver_name);  /*calculate length of the string*/
  if (len > STRMAX_VN) return 9;
  Bsc__putUnsignedB(a_pb, &len, 8);         /*length of the string*/
  Bsc__putOctetStr(a_pb, (unsigned char*)a_p->m_uver_name, len); /*string*/

  /* other parameters */
  Bsc__putOctetStr(a_pb, a_p->m_md5a, sizeof (a_p->m_md5a)); /* save md5 checksum */ 

  Bsc__putUnsignedB (a_pb, &a_p->m_snum, 4);
  Bsc__putUnsignedB (a_pb, &a_p->m_inum, 12);
  Bsc__putUnsignedB (a_pb, &a_p->m_onum, 4);
  Bsc__putUnsignedB (a_pb, &a_p->m_ncnum, 20);
  Bsc__putUnsignedB (a_pb, &a_p->m_hwid, 32);

  /*task map*/
  tlen = (a_p->m_inum+7)/8; /* task map length in octets */
  /*printf ("debug printing: write tlen = %d\n", tlen);*/
  Bsc__putOctetStr (a_pb, a_p->m_tmap, tlen);

  /*code*/
  clen=a_p->m_snum * a_p->m_inum * a_p->m_onum ; /* code table length in octets */
  /*printf ("debug printing: write clen = %d\n", clen);*/
  Bsc__putOctetStr (a_pb, a_p->m_code, clen);

  /*NCAT table*/
  for (i=0; i<a_p->m_ncnum; i++) {
    C3Asm3__PkgNcae__writeBsc(&a_p->m_ncat[i], a_pb);
    Bsc__putUnsignedB (a_pb, &pad, Bsc__aligningB(a_pb, 8));  /*pad, allign to the octet boundary*/
  }

  return 0;
}

/* deserialize all interface data from the buffer */
int C3Asm3__PkgInt__readBsc(C3Asm3__PkgInt *a_p, Bsc *a_pb)
{
  unsigned int 
    magic
    ,tlen=0
    ,clen=0
    ,i=0 
    ,pad=0 
    ,len=0
    ;
  unsigned char lmd5[16];

  if (a_p == NULL) return 1;
  if (a_pb == NULL) return 2;

  /* set structure flag to indicate dynamic allocation of the data buffers */
  a_p->m_fdin = TRUE_VN;

  Bsc__getUnsignedB (a_pb, &magic, 32); /*4 octets long magic number to identify binary form of package*/
  if(magic != a_p->m_magic) return 3;
  
  /* tool version info */
  Bsc__getUnsignedB (a_pb, &a_p->m_tver_maj,  32);/*ucode major version - change of the package format or major functionality*/
  Bsc__getUnsignedB (a_pb, &a_p->m_tver_min,  32);/*ucode minor version - other changes*/
  Bsc__getUnsignedB (a_pb, &a_p->m_tver_patch,32);/*ucode minor version - other changes*/
  Bsc__getUnsignedB (a_pb, &len, 8);         /*length of the string*/
  a_p->m_tver_name = (char*)MALLOC_PKGC3(len+1); /* allocate buffer for the string */
  if (a_p->m_tver_name == NULL) return 4;
  /*MEMSET_VN (a_p->m_tver_name, 0, len+1);*/
  Bsc__getOctetStr(a_pb, (unsigned char*)a_p->m_tver_name, len); /*name associated with the value, length limit is 128*/
  a_p->m_tver_name[len] = 0;

  /* ucode version info */
  Bsc__getUnsignedB (a_pb, &a_p->m_uver_maj,  32);/*ucode major version - change of the package format or major functionality*/
  Bsc__getUnsignedB (a_pb, &a_p->m_uver_min,  32);/*ucode minor version - other changes*/
  Bsc__getUnsignedB (a_pb, &a_p->m_uver_patch,32);/*ucode minor version - other changes*/
  Bsc__getUnsignedB (a_pb, &len, 8);         /*length of the string*/
  a_p->m_uver_name = (char*)MALLOC_PKGC3(len+1); /* allocate buffer for the string */
  if (a_p->m_uver_name == NULL) return 5;
  /*MEMSET_VN (a_p->m_uver_name, 0, len+1);*/
  Bsc__getOctetStr(a_pb, (unsigned char*)a_p->m_uver_name, len); /*name associated with the value, length limit is 128*/
  a_p->m_uver_name[len] = 0;

  /* other  parameters */
  Bsc__getOctetStr(a_pb, a_p->m_md5a, sizeof (a_p->m_md5a)); /* get md5 checksum */ 

  Bsc__getUnsignedB (a_pb, &a_p->m_snum, 4);   /*number of streams*/
  if (a_p->m_snum == 0) return 6;

  Bsc__getUnsignedB (a_pb, &a_p->m_inum, 12);  /*number of instructions*/
  if (a_p->m_inum == 0) return 7;

  Bsc__getUnsignedB (a_pb, &a_p->m_onum, 4);   /*number of octets in the machine word*/
  if (a_p->m_onum == 0) return 8;

  Bsc__getUnsignedB (a_pb, &a_p->m_ncnum, 20); /*number of entries in the NCAT table*/
  Bsc__getUnsignedB (a_pb, &a_p->m_hwid, 32); /*hw version*/

  /* calculate task and code tablelength in octets */
  tlen = (a_p->m_inum+7)/8; /* task map length in octets */
  clen=a_p->m_snum * a_p->m_inum * a_p->m_onum ; /* code table length in octets */
  /*printf ("debug printing: write tlen = %d, clen = %d\n", tlen, clen);*/

  /*allocate and read from buffer task map table*/
  a_p->m_tmap = (unsigned char *)MALLOC_PKGC3(tlen);
  if (a_p->m_tmap == NULL) return 9;
  Bsc__getOctetStr (a_pb, a_p->m_tmap, tlen);

  /*allocate and read from buffer code table*/
  a_p->m_code = (unsigned char *)MALLOC_PKGC3(clen);
  if (a_p->m_code == NULL) return 10;
  Bsc__getOctetStr (a_pb, a_p->m_code, clen);

  /*allocate and read NCAT table*/
  a_p->m_ncat = (C3Asm3__PkgNcae*)MALLOC_PKGC3(a_p->m_ncnum * sizeof (C3Asm3__PkgNcae));
  if (a_p->m_ncnum && a_p->m_ncat == NULL) return 11;
  for (i=0; i<a_p->m_ncnum; i++) {
    unsigned int align8;
    if (C3Asm3__PkgNcae__readBsc(&a_p->m_ncat[i], a_pb)) return 12;
    align8 = Bsc__aligningB(a_pb, 8) & 7;
    if (align8 > 0) Bsc__getUnsignedB (a_pb, &pad, align8);  /*pad, allign to the octet boundary*/
  }

  /* verify md5 sum to make sure important data are not corrupted */
  if (C3Asm3__PkgInt__md5a (a_p, lmd5)) return 13;
  for (i=0; i< sizeof (lmd5); i++) if (lmd5[i] != a_p->m_md5a[i]) return 14; /* data are corrupted */

  return 0;
}

/* copy interface structure a_b to interface structure a_a with dynamic buffers */
int C3Asm3__PkgInt__copyD(C3Asm3__PkgInt *a_d, C3Asm3__PkgInt *a_s)
{
  unsigned int tlen=0, clen=0, i=0, len=0;

  if (a_d == NULL) return 1;
  if (a_s == NULL) return 2;

  if (C3Asm3__PkgInt__init(a_d)) return 3;
  if (a_d->m_magic != a_s->m_magic) return 4;

  /* tool version info */
  a_d->m_tver_maj   = a_s->m_tver_maj;
  a_d->m_tver_min   = a_s->m_tver_min;
  a_d->m_tver_patch = a_s->m_tver_patch;
  /* allocate and copy m_uver_name string */
  len = STRLEN_VN(a_s->m_tver_name);  /*calculate length of the string*/
  if (len > STRMAX_VN) return 5;
  a_d->m_tver_name = (char*)MALLOC_PKGC3(len+1); /* allocate buffer for the string */
  if (a_d->m_tver_name == NULL) return 6;
  STRNCPY_VN(a_d->m_tver_name, a_s->m_tver_name, len+1);

  /* ucode version info */
  a_d->m_uver_maj   = a_s->m_uver_maj;
  a_d->m_uver_min   = a_s->m_uver_min;
  a_d->m_uver_patch = a_s->m_uver_patch;
  /* allocate and copy m_uver_name string */
  len = STRLEN_VN(a_s->m_uver_name);  /*calculate length of the string*/
  if (len > STRMAX_VN) return 5;
  a_d->m_uver_name = (char*)MALLOC_PKGC3(len+1); /* allocate buffer for the string */
  if (a_d->m_uver_name == NULL) return 6;
  STRNCPY_VN(a_d->m_uver_name, a_s->m_uver_name, len+1);

  /* other parameters */
  a_d->m_snum       = a_s->m_snum;
  a_d->m_inum       = a_s->m_inum;
  a_d->m_onum       = a_s->m_onum;
  a_d->m_ncnum      = a_s->m_ncnum;
  a_d->m_hwid       = a_s->m_hwid;
  a_d->m_fdin       = TRUE_VN;
  a_d->m_fPut       = a_s->m_fPut;
  a_d->m_fGet       = a_s->m_fGet;
  a_d->m_pv         = a_s->m_pv;


  /*allocate and copy task map table*/
  tlen = (a_s->m_inum+7)/8; /* task map length in octets */
  a_d->m_tmap = (unsigned char *)MALLOC_PKGC3(tlen);
  if (a_d->m_tmap == NULL) return 7;
  for (i=0; i<tlen; i++) a_d->m_tmap[i] = a_s->m_tmap[i];

  /*allocate and copy code table*/
  clen = a_s->m_snum * a_s->m_inum * a_s->m_onum ; /* code table length in octets */
  a_d->m_code = (unsigned char *)MALLOC_PKGC3(clen);
  if (a_d->m_code == NULL) return 8;
  for (i=0; i<clen; i++) a_d->m_code[i] = a_s->m_code[i];

  /*calculate size of the NCAT table and allocate it*/
  a_d->m_ncat = (C3Asm3__PkgNcae*)MALLOC_PKGC3(a_s->m_ncnum * sizeof (C3Asm3__PkgNcae));
  if (a_d->m_ncnum && a_d->m_ncat == NULL) return 9;
  
  /* copy ncat table entries */
  for (i=0; i<a_d->m_ncnum; i++)
    if (C3Asm3__PkgNcae__copyD(&a_d->m_ncat[i], &a_s->m_ncat[i])) return 10;

  /* calculate and verify md5 sum to make sure important data are not corrupted */
  if (C3Asm3__PkgInt__md5a (a_d, a_d->m_md5a)) return 11;
  for (i=0; i< sizeof (a_d->m_md5a); i++) if (a_d->m_md5a[i] != a_s->m_md5a[i]) return 12; /* corrupted data */

  return 0;
}


int C3Asm3__PkgInt__lenBuf(C3Asm3__PkgInt *a_p, unsigned int *a_l)
{
  Bsc bsc;

  if (a_p == NULL) return 1;
  if (a_l == NULL) return 2;

  Bsc__initFromBuf(&bsc, 0, 10000000); /* zero pointer to the buf will set nc flag in bsc*/
  if (C3Asm3__PkgInt__writeBsc(a_p, &bsc)) return 3;
  *a_l = Bsc__numProO(&bsc);
  
  return 0;
}

int C3Asm3__PkgInt__writeBuf(C3Asm3__PkgInt *a_p, unsigned char *a_b, unsigned int a_l)
{
  Bsc bsc;

  /*validate interface structure parameters*/
  if (a_p == NULL) return 1;
  if (a_b == NULL) return 2;
  if (a_l == 0) return 3;
  
  Bsc__initFromBuf(&bsc, a_b, a_l*8);
  if (C3Asm3__PkgInt__writeBsc(a_p, &bsc)) return 4;

  return 0;
}

int C3Asm3__PkgInt__readBuf(C3Asm3__PkgInt *a_p, unsigned char *a_b, unsigned int a_l)
{
  Bsc bsc;
  int rcode = 0;

  if (a_p == NULL) return 31;
  if (a_b == NULL) return 32;
  if (a_l == 0) return 33;

  Bsc__initFromBuf(&bsc, a_b, a_l*8);
  rcode = C3Asm3__PkgInt__readBsc(a_p, &bsc);

  return rcode;
}

int C3Asm3__PkgInt__getNc(C3Asm3__PkgInt *a_p, char *a_n, unsigned int *a_nc)
{
  int i=0;

  if (a_p  == NULL) return 1;
  if (a_n  == NULL) return 2;
  if (a_nc == NULL) return 3;
  if (a_p->m_magic != 0x12345678) return 4;


  for (i=0; i< a_p->m_ncnum; i++)
    if (!STRNCMP_VN(a_p->m_ncat[i].m_name, a_n, STRMAX_VN)) {
      C3Asm3__PkgNcae *a_e = &a_p->m_ncat[i];
      *a_nc = a_e->m_va;

      if (a_p->m_fGet && a_p->m_ncat[i].m_fc) { /* if hw access functions are initialized and it is ucode entry, then get value from the microcode */
	unsigned char *wp;
	Bsc bsc;
	if (C3Asm3__PkgInt__getWordPtr(a_p, a_e->m_sn, a_e->m_in, &wp)) return 4; /*calculate pointer to the first octet of the machine word*/
	if (a_p->m_fGet(a_p->m_pv, a_e->m_sn, a_e->m_in, wp)) return 5; /*if hardware access function is initialized then get value from hardware word and update data buffer*/
	Bsc__initFromBuf (&bsc, wp, a_p->m_onum*8); /*init bit stream class to the machine word*/
	Bsc__setLsbf (&bsc, FALSE_VN); /*set appropriate bsc attributes*/
	Bsc__setLsof (&bsc, FALSE_VN); /*set appropriate bsc attributes*/
	Bsc__moveB (&bsc, a_p->m_onum*8 - ( (a_e->m_bo) + a_e->m_bl), eBscBeg);/*move bit stream to the offset of the field, note then given offsets based on the 16+ values*/
	Bsc__getUnsignedB (&bsc, a_nc, a_e->m_bl);/*put new value to the machine word field*/
	if (a_p->m_ncat[i].m_va != *a_nc) { a_p->m_ncat[i].m_va = *a_nc; return 6; }
      } 
     
      return 0;
    }

  return 5;
}

int C3Asm3__PkgInt__updateNcEntry(C3Asm3__PkgInt *a_p, C3Asm3__PkgNcae *a_e, unsigned int *a_nc)
{
  unsigned char *wp;
  Bsc bsc;

  if (a_p  == NULL) return 1;
  if (a_e  == NULL) return 2;
  if (a_nc == NULL) return 3;

  a_e->m_va = *a_nc;
  if (a_e->m_fc) {
    if (C3Asm3__PkgInt__getWordPtr(a_p, a_e->m_sn, a_e->m_in, &wp)) return 4; /*calculate pointer to the first octet of the machine word*/
    if (a_p->m_fGet) a_p->m_fGet(a_p->m_pv, a_e->m_sn, a_e->m_in, wp); /*if hardware access function is initialized then get value from hardware word and update data buffer*/
    Bsc__initFromBuf (&bsc, wp, a_p->m_onum*8); /*init bit stream class to the machine word*/
    Bsc__setLsbf (&bsc, FALSE_VN); /*set appropriate bsc attributes*/
    Bsc__setLsof (&bsc, FALSE_VN); /*set appropriate bsc attributes*/
    Bsc__moveB (&bsc, a_p->m_onum*8 - ( (a_e->m_bo) + a_e->m_bl), eBscBeg);/*move bit stream to the offset of the field, note then given offsets based on the 16+ values*/
    Bsc__putUnsignedB (&bsc, &a_e->m_va, a_e->m_bl);/*put new value to the machine word field*/
    if (a_p->m_fPut) a_p->m_fPut(a_p->m_pv, a_e->m_sn, a_e->m_in, wp); /*if hardware access function is initialized then put value back to  hardware word from data buffer*/
  }
  return 0;
}

int C3Asm3__PkgInt__putNc(C3Asm3__PkgInt *a_p, char *a_n, unsigned int *a_nc)
{
  int lret=1, i=0;

  if (a_p  == NULL) return 1;
  if (a_n  == NULL) return 2;
  if (a_nc == NULL) return 3;
  if (a_p->m_magic != 0x12345678) return 4;
    
  for (i=0; i< a_p->m_ncnum; i++) 
    if (!STRNCMP_VN(a_p->m_ncat[i].m_name, a_n, STRMAX_VN)) 
      lret = C3Asm3__PkgInt__updateNcEntry(a_p, &a_p->m_ncat[i], a_nc);
	    

  return lret;
}

C3Asm3__PkgNcae *ncat_backup = NULL;
int ncat_num = 0;

int C3Asm3__PkgInt__backupNc(C3Asm3__PkgInt *a_p, C3Asm3__PkgInt *new)
{
    int ncat_size;
    int rv = 0;
    int i;
    
    if (a_p  == NULL) return 1;
    if (a_p->m_magic != 0x12345678) return 2;

    /*
     * Compare current with new
     */
    if (a_p->m_ncnum != new->m_ncnum) {
        LOG_CLI((BSL_META("%s: Symbol table size missmatch (current:%d vs new:%d)\n"), 
                 __func__, a_p->m_ncnum, new->m_ncnum));
        rv = 3;
    } else {
       for (i=0; i< a_p->m_ncnum; i++) {
            if (sal_strcmp(a_p->m_ncat[i].m_name, new->m_ncat[i].m_name) != 0) {
                rv = 4;
                LOG_CLI((BSL_META("%s: Non-matching constants: %s and %s at index:%d\n"),
                         __func__, a_p->m_ncat[i].m_name, new->m_ncat[i].m_name, i));
                break;
            }
        }
    }

    if (rv != 0) {
        LOG_CLI((BSL_META("************************************************\n" \
                          "*                                              *\n" \
                          "* ucode image missmatch                        *\n" \
                          "*                                              *\n" \
                          "************************************************\n")));
        return rv;
    }

    /*
     * Copy Nc data
     */
    if (ncat_backup != NULL)
        FREE_PKGC3(ncat_backup);

    ncat_size = a_p->m_ncnum * sizeof(C3Asm3__PkgNcae);
    ncat_backup = MALLOC_PKGC3(ncat_size);
    memcpy(ncat_backup, a_p->m_ncat, ncat_size);
    
    for (i=0; i< a_p->m_ncnum; i++) {
        ncat_backup[i].m_name = MALLOC_PKGC3(sal_strlen(a_p->m_ncat[i].m_name) + 1);
        ncat_backup[i].m_fdin = 1;
        /* coverity[secure_coding] */
        sal_strcpy(ncat_backup[i].m_name, a_p->m_ncat[i].m_name);
    }

    return rv;
}

int C3Asm3__PkgInt__backupNc__force(C3Asm3__PkgInt *a_p, C3Asm3__PkgInt *new)
{
    int ncat_size = 0;
    int rv = 0;
    int i;

    if (a_p  == NULL) return 1;
    if (a_p->m_magic != 0x12345678) return 2;

    /*
     * Copy Nc data
     */
    if (ncat_backup != NULL)
        FREE_PKGC3(ncat_backup);

    ncat_size = a_p->m_ncnum * sizeof(C3Asm3__PkgNcae);
    ncat_backup = MALLOC_PKGC3(ncat_size);
    ncat_num = a_p->m_ncnum;
    memcpy(ncat_backup, a_p->m_ncat, ncat_size);

    for (i=0; i< a_p->m_ncnum; i++) {
        ncat_backup[i].m_name = MALLOC_PKGC3(sal_strlen(a_p->m_ncat[i].m_name) + 1);
        ncat_backup[i].m_fdin = 1;
        /* coverity[secure_coding] */
        sal_strcpy(ncat_backup[i].m_name, a_p->m_ncat[i].m_name);
    }

    return rv;
}


int C3Asm3__PkgInt__restoreNc(int unit, C3Asm3__PkgInt *a_p)
{
    int i;
    int rv = 0;

    if (a_p  == NULL) return 1;
    if (a_p->m_magic != 0x12345678) return 2;

    /*
     * Write saved values back to memory
     */
    if (ncat_backup == NULL)
        return 3;

    /*
     * Read current values from memory to backup
     */
    sal_mutex_take(bankSwapLock[unit], sal_mutex_FOREVER);
    for (i=0; i< a_p->m_ncnum; i++) {
 
        if (a_p->m_ncat[i].m_fc == 1) {
            if (C3Asm3__PkgInt__putNc(a_p, a_p->m_ncat[i].m_name, &ncat_backup[i].m_va) != 0 ) {
            	rv = 5;
            	LOG_CLI((BSL_META("%s: Constant update failed for %sat index:%d\n"),
                         __func__, a_p->m_ncat[i].m_name, i));
                break;
            }
        }
    }
    sal_mutex_give(bankSwapLock[unit]);
    
    for (i=0; i< a_p->m_ncnum; i++) {
        C3Asm3__PkgNcae__destroy(&ncat_backup[i]);
    }

    FREE_PKGC3(ncat_backup);
    ncat_backup = NULL;

    return rv;
}


int C3Asm3__PkgInt__restoreNc__force(int unit, C3Asm3__PkgInt *a_p)
{
    int i;
    int rv = 0;

    if (a_p  == NULL) return 1;
    if (a_p->m_magic != 0x12345678) return 2;

    /*
     * Write saved values back to memory
     */
    if (ncat_backup == NULL)
        return 3;

    /*
     * Read current values from memory to backup
     */
    sal_mutex_take(bankSwapLock[unit], sal_mutex_FOREVER);
    for (i=0; (i < a_p->m_ncnum) && (i < ncat_num); i++) {

        if (a_p->m_ncat[i].m_fc == 1) {
            C3Asm3__PkgInt__putNc(a_p, a_p->m_ncat[i].m_name, &ncat_backup[i].m_va);
        }
    }
    sal_mutex_give(bankSwapLock[unit]);
    
    for (i=0; i< ncat_num; i++) {
        C3Asm3__PkgNcae__destroy(&ncat_backup[i]);
    }

    FREE_PKGC3(ncat_backup);
    ncat_backup = NULL;
    ncat_num = 0;

    return rv;
}


int C3Asm3__PkgInt__getWordPtr(C3Asm3__PkgInt *a_p, unsigned int a_sn, unsigned int a_in, unsigned char **a_wp)
{
  if (a_p  == NULL) return 1;
  if (a_wp == NULL) return 2;
  if (a_p->m_magic != 0x12345678) return 3;
  if (a_sn >= a_p->m_snum) return 4;
  if (a_in >= a_p->m_inum) return 5;
  if (a_p->m_code == NULL) return 6;

  *a_wp = &a_p->m_code[a_sn*a_p->m_inum*a_p->m_onum + a_in*a_p->m_onum];

  return 0;
}

/* get pointer to the first octet of the machine word */
int C3Asm3__PkgInt__getTask (C3Asm3__PkgInt *a_p, unsigned int a_in, unsigned int *a_t)
{
  if (a_p  == NULL) return 1;
  if (a_t == NULL) return 2;
  if (a_p->m_magic != 0x12345678) return 3;
  if (a_in >= a_p->m_inum) return 5;
  if (a_p->m_tmap == NULL) return 7;

  *a_t = ((a_p->m_tmap[a_in / 8] >> (7 - (a_in % 8))) & 0x1);

  return 0;
}

/* calculate md5a ( for all significant data fields and arrays ) */
int C3Asm3__PkgInt__md5a (C3Asm3__PkgInt *a_p, unsigned char a_d[16])
{
  /* local variables and objects */
  C3Asm3__Md5 ctx;
  Bsc bs;
  unsigned char buf[4];
  unsigned int len = 0;

  /* validate function arguments */
  if (a_p == NULL) return 1;
  if (a_d == NULL) return 2;

  /* initialize used pseudo-classes */
  Bsc__initFromBuf(&bs, buf, 8* sizeof (buf)); 
  if (C3Asm3__Md5__init( &ctx )) return 3;

  /* calculate md5 sum for the magic field */
  Bsc__putUnsigned(&bs, a_p->m_magic, 8*sizeof (buf)); 
  if (C3Asm3__Md5__update( &ctx, Bsc__ptrPduO(&bs), sizeof (buf))) return 4;

  /* ucode version info */
  /* calculate md5 sum for the m_uver_maj field*/ 
  Bsc__putUnsigned(&bs, a_p->m_uver_maj, 8*sizeof (buf)); 
  if (C3Asm3__Md5__update( &ctx, Bsc__ptrPduO(&bs), sizeof (buf))) return 7;

  /* calculate md5 sum for the m_uver_min field*/ 
  Bsc__putUnsigned(&bs, a_p->m_uver_min, 8*sizeof (buf)); 
  if (C3Asm3__Md5__update( &ctx, Bsc__ptrPduO(&bs), sizeof (buf))) return 8;

  /* calculate md5 sum for the m_uver_patch field*/ 
  Bsc__putUnsigned(&bs, a_p->m_uver_patch, 8*sizeof (buf)); 
  if (C3Asm3__Md5__update( &ctx, Bsc__ptrPduO(&bs), sizeof (buf))) return 9;

  /* calculate md5 sum for the m_uver_name field*/   
  if (a_p->m_uver_name) {
    len = STRLEN_VN(a_p->m_uver_name);
    if (len > STRMAX_VN) return 10;
    if (C3Asm3__Md5__update( &ctx, (unsigned char*)a_p->m_uver_name,  len+1)) return 11;
  }

  /* calculate md5 sum for the task map*/ 
  if (C3Asm3__Md5__update( &ctx, a_p->m_tmap, (a_p->m_inum+7)/8)) return 12;

  /* calculate md5 sum for the code */ 
  if (C3Asm3__Md5__update( &ctx, a_p->m_code, a_p->m_snum * a_p->m_inum * a_p->m_onum)) return 13;

  /* finalize calculation of the md5 check-sum */
  if (C3Asm3__Md5__finish( &ctx, a_d )) return 14;

  return 0;
}

/* utilities */
int C3Asm3__hc2i (int _c)
{
	/*
	if      ('0'<=_c && _c<='9') return (_c-'0');
	else if ('a'<=_c && _c<='f') return (10+_c-'a');
	else if ('A'<=_c && _c<='F') return (10+_c-'A');
	else return -1;
	*/

	switch (_c) {
	case '0': return 0;
	case '1': return 1;
	case '2': return 2;
	case '3': return 3;
	case '4': return 4;
	case '5': return 5;
	case '6': return 6;
	case '7': return 7;
	case '8': return 8;
	case '9': return 9;
	case 'a': case 'A': return 10;
	case 'b': case 'B': return 11;
	case 'c': case 'C': return 12;
	case 'd': case 'D': return 13;
	case 'e': case 'E': return 14;
	case 'f': case 'F': return 15;
	default: return -1;
	}
}

int C3Asm3__i2hc (int _i)
{
  /* shorter
  if (0<= _i <= 9) return (_i + (int)'0');
  else if (10<= _i <= 15) return (_i + (int)'a');
  else return -1;*/

	switch (_i&0xff) {
	case 0:  return '0';
	case 1:  return '1';
	case 2:  return '2';
	case 3:  return '3';
	case 4:  return '4';
	case 5:  return '5';
	case 6:  return '6';
	case 7:  return '7';
	case 8:  return '8';
	case 9:  return '9';
	case 10: return 'a';
	case 11: return 'b';
	case 12: return 'c';
	case 13: return 'd';
	case 14: return 'e';
	case 15: return 'f';
	default: return -1;
	}
}


int C3Asm3__s2b(u1 *_d, int _ld, u1 *_s, int _ls)
{
  int i=0;
  int j=0;
  int va = 0;
  int a = 0;
  int empty = 1;

  if (_d == NULL) return 1;
  if (_ls == 0) return 2;
  if (_s == NULL) return 3;

  for (i=0, j=0; i<_ls&&j<_ld&&_s[i]!=0; i++) {
    a = C3Asm3__hc2i (_s[i]);
    if (a >= 0) {
      if (empty) {
	va = a<<4;
	empty = 0;
      }
      else {
	va = va | a;
	_d[j++] = (u1)(va&0xff);
	va = 0;
	empty = 1;
      }
    }
  }
  return 0;
}

int C3Asm3__b2s (u1 *_d, int _ld, u1 *_s, int _ls)
{
  int i=0;
  int j=0;

  if (_d == NULL) return 1;
  if (_ls == 0) return 2;
  if (_s == NULL) return 3;

  for (i=0, j=0; i<_ls&&j<_ld; i++) {
    if (i!=0) {
      if (i%32==0) { _d[j]='\x0d'; j++; _d[j]='\x0a';  j++;}
      else if (i%8==0) { _d[j]=' '; j++; _d[j]=' ';  j++; }
      else { _d[j]=' '; j++;}
    }

    _d[j] = C3Asm3__i2hc ((_s[i]>>4)&0xf);
    j++;
    _d[j] = C3Asm3__i2hc (_s[i]&0xf);
    j++;
  }

  _d[j]=0;

  return 0;
}


/*
 * Tables should be serialized and deserialized. For now use hard-coded reference.
 */
#include <soc/sbx/sbx_drv.h>
#include <soc/sbx/caladan3/ocm.h>
#include <soc/sbx/caladan3/rce.h>
#include <soc/sbx/caladan3/rce_int.h>

int C3Asm3__PkgInt__getTablePtr(int unit, C3Asm3__PkgInt *a_p, char *a_n, const void **a_nc)
{
  extern const _soc_c3_rce_program_uc_desc_t _soc_g3p1_rce_programs_data[SOC_C3_RCE_PROGRAM_COUNT];
  extern const _soc_c3_rce_program_uc_desc_t _soc_t3p1_rce_programs_data[SOC_C3_RCE_PROGRAM_COUNT];
  
  if (a_p  == NULL) return 1;
  if (a_n  == NULL) return 2;
  if (a_nc == NULL) return 3;
  if (a_p->m_magic != 0x12345678) return 4;


  if (STRNCMP_VN("RCE", a_n, STRMAX_VN) == 0) {
    if (SOC_IS_SBX_G3P1(unit)) {
      *a_nc = _soc_g3p1_rce_programs_data;
    } else if (SOC_IS_SBX_T3P1(unit)) {
	  *a_nc = _soc_t3p1_rce_programs_data;
	} 
  } else {
    return 5;
  }

  return 0;
}

/*end of file*/
