/*
 * $Id: rce.c,v 1.74.10.5 Broadcom SDK $
 * $Copyright: (c) 2016 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 * File:    rce.c
 * Purpose: Caladan3 Rule Classifier drivers
 * Requires:
 */

#ifdef BCM_CALADAN3_SUPPORT
#include <shared/bsl.h>
#include <sal/core/libc.h>
#include <sal/core/alloc.h>
#include <soc/error.h>
#include <soc/drv.h>
#include <soc/mem.h>
#include <soc/cm.h>
#include <soc/sbx/sbx_drv.h>
#include <soc/sbx/caladan3/ocm.h>
#include <soc/sbx/caladan3/lrp.h>
#include <soc/sbx/caladan3/rce.h>
#include <soc/sbx/caladan3/rce_int.h>
#include <soc/sbx/caladan3/ucodemgr.h>


/****************************************************************************
 *
 *  Internal implementation
 */

/*
 *  CONFIG:
 *
 *  If C3_RCE_INCLUDE_NON_INSTALLED_DATA is TRUE, updates to a filter set will
 *  cause any entry that exists to have its 'hardware' pattern and action
 *  data written, even if the entry is not 'installed' (and so would not match
 *  traffic).  If an entry has never been installed, the default values will be
 *  used for that entry.  This mode will reduce performance, significantly when
 *  there are many entries but few installed, so it should only be used for
 *  debugging certain types of issue.
 *
 *  If C3_RCE_INCLUDE_NON_INSTALLED_DATA is FALSE, any entry that exists but is
 *  not 'installed' will be treated as if it did not exist, when filling in the
 *  action table and pattern space (so basically the pattern and action data
 *  for that entry in hardware will be all zeroes).
 */
#define C3_RCE_INCLUDE_NON_INSTALLED_DATA FALSE

/*
 *  CONFIG:
 *
 *  C3_RCE_ACTION_INDEX_COUNTER_BLOCK_THRESHOLD specifies the number of entry
 *  moves in a filter set update that will trigger use of a bulk transfer of
 *  the appropriate counter block, rather than doing them one at a time.
 *
 *  This is included because of the counter management mechanism -- individual
 *  counters or blocks of counters are force-ejected by a command to the
 *  hardware, and a background thread collects the results, with the original
 *  thread finally notified that the counters have been read.  This mechanism
 *  imposes a substantial overhead per read, so once a certain number of reads
 *  are required, it is faster to just transfer the whole block.
 *
 *  The optimal number tends to be disconcertingly low, and should be tweaked
 *  per target platform, since the inter-thread communication, interrupts, and
 *  other latencies involved will vary between host platform and operating
 *  system and may be affected by other configurable parameters (such as the
 *  system timer tic frequency or what else is running).
 *
 *  Probably the easiest way to adjust this is to sit with a stopwatch while
 *  adding and installing entries from lowest priority to highest priority,
 *  with the C3_RCE_ENABLE_ENTRY_INSERT_HEURISTIC setting (below) FALSE.  When
 *  you get the shortest time necessary to so add 768 entries, you probably
 *  have a value close to optimal.
 */
#define C3_RCE_ACTION_INDEX_COUNTER_BLOCK_THRESHOLD 16

/*
 *  CONFIG:
 *
 *  If C3_RCE_ACTION_INDEX_COUNTER_CLEAR_PARNOIA is TRUE, the hardware counters
 *  for an entry will be explicitly cleared when adding that entry to a filter
 *  set, and the counters for the new placement of an entry will be explicitly
 *  cleared even if there was no entry there before.  These are in addition to
 *  the times (listed below) when the hardware counters for an entry will be
 *  normally read and cleared.
 *
 *  If C3_RCE_ACTION_INDEX_COUNTER_CLEAR_PARNOIA is FALSE, the additional times
 *  at which the hardware counters for an entry will be cleared, as indicated
 *  above, will be skipped.
 *
 *  Normally, initialisation clears all of the hardware counters, group
 *  destruction clears all of the counters associated with the filter set(s)
 *  involved with that group, entry destruction clears the counters associated
 *  with an entry, an entry moving in a filter set will read and clear the
 *  counters from the entry's previous location in the filter set (accumulating
 *  in basis counters for the entry), reading an entry's counters will read and
 *  clear the entry counters (accumulating in basis counters for the entry),
 *  and setting an entry's counters will clear the hardware counters.
 *
 *  Basically, this means that any position *to* which an entry is moved will
 *  already have its counters zero, including when creating a new entry.  So,
 *  the additional clearing by C3_RCE_ACTION_INDEX_COUNTER_CLEAR_PARNOIA should
 *  be redundant (and it does add some time).  However, if there are errors in
 *  performing any of the other counter reads or clear operations, it is
 *  possible that residue will be left from one entry to another.
 *
 *  If the counts appear wrong, and there are errors reported in functions that
 *  imply counter access, setting C3_RCE_ACTION_INDEX_COUNTER_CLEAR_PARNOIA to
 *  TRUE might help reduce these bogus counts, at a slight additional time
 *  penalty when performing such operations.
 */
#define C3_RCE_ACTION_INDEX_COUNTER_CLEAR_PARNOIA FALSE

/*
 *  CONFIG:
 *
 *  If C3_RCE_ACTION_INDEX_COUNTER_SPAN_ACTIONS is TRUE, counter accesses for
 *  entries and updates for groups using multiple result registers will be done
 *  so that the entry counter values include the numbers from all of the
 *  counter tables associated with the (entry's) group's result registers.
 *  This will cause each frame to be counted once for each result register
 *  whose counter table was updated for that frame.  This can be useful if,
 *  despite multiple result registers and associated action and counter tables,
 *  a given entry will only actually count in one of them.  However, if an
 *  entry is counted in each of the associated counter tables, it will cause
 *  frames that hit the entry to be counted once for each such table.
 *
 *  If C3_RCE_ACTION_INDEX_COUNTER_SPAN_ACTIONS is FALSE, counter accesses for
 *  entries and updates for groups will only use the first counter table
 *  encountered associated with the group's result registers, and will clear
 *  the others on read/update but will not include them in the counts.  This is
 *  useful if a frame that hits an entry in a group with multiple result
 *  registers will be counted in each of the counter tables associated with
 *  that group's result registers, but it will cause counts to be lost if an
 *  entry would only be counted in one of the associated tables.
 */
#define C3_RCE_ACTION_INDEX_COUNTER_SPAN_ACTIONS FALSE

/*
 *  CONFIG:
 *
 *  If C3_RCE_ENABLE_ENTRY_INSERT_HEURISTIC is TRUE, the entry create function
 *  will use a heuristic based upon recent entry creations to determine where
 *  in a filter set to place a new entry.  The intent of this heuristic is to
 *  avoid entries moving about so much within a filter set.  The placement
 *  heuristic keeps track of some additional data when creating entries so it
 *  has an idea of what has been done recently and can try to adjust placeent
 *  by trends in the entry creation order and their placement with respect to
 *  each other within the filter set.
 *
 *  If C3_RCE_ENABLE_ENTRY_INSERT_HEURISTIC if FALSE, the entry create function
 *  will simply compress all entries to the lower positions in each filter set.
 *
 *  Since moving entries around in a filter set requires that filter set be
 *  committed (and, if action-indexed counters apply to that filter set, the
 *  counters be updated), it is probably better to leave this TRUE.  It will
 *  tend to reduce the number of commits when creating new entries, thus
 *  improving entry creation performance (or at least not hurting it, relative
 *  to always repacking the entries when creating them).
 */
#define C3_RCE_ENABLE_ENTRY_INSERT_HEURISTIC TRUE

/*
 *  CONFIG:
 *
 *  If C3_RCE_FILTER_SET_SPLIT_BALANCING is TRUE, the code that splits filter
 *  sets when it is trying make room to insert new entries will attempt to
 *  'balance' the split so the same number of entries will be in both parts of
 *  the split filter set.  This does not affect the case when the split comes
 *  before or after the filter set (insertion of a new filter set), and it only
 *  takes effect if the split is off by more than the setting below.
 *
 *  If C3_RCE_FILTER_SET_SPLIT_BALANCING is FALSE, the code that splits filter
 *  sets will always split exactly at the point of insertion for the new entry,
 *  even if this results in one filter set that is immediately filled by the
 *  new entry and another filter set that contains only a single entry.
 *
 *  The value of C3_RCE_FILTER_SET_SPLIT_BALANCING_THRESHOLD indicates how far
 *  from the middle the split can occur before balancing will be invoked, if
 *  C3_RCE_FILTER_SET_SPLIT_BALANCING is TRUE, and has no effect otherwise.
 *  C3_RCE_FILTER_SET_SPLIT_BALANCING_THRESHOLD must be at least one and less
 *  than half the number of entries that can fit in a filter set.
 *
 *  Balancing helps to improve how well entries are packed in filter sets by
 *  ensuring the splits do not result one filter set that is nearly full (or
 *  completely full with the new entry added) and one that is nearly empty.
 *  This tends to improve future performance of entry creation by avoiding the
 *  need to shift entries across filter sets or split more filter sets.
 *
 *  Splitting a filter set requires that, in addition to adding a new filter
 *  set, the remainder of the old filter set be updated.  Balancing will add
 *  another update to this, since it will almost certainly require that the
 *  filter set which will contain the entry be updated to make room for the
 *  entry.  C3_RCE_FILTER_SET_SPLIT_BALANCING_THRESHOLD allows the split to be
 *  offset by some distance from centre so that the second update will not be
 *  needed (the new entry will go into the gap opened by the split).
 *
 *  For purposes of this description a filter set is 'split' when some number
 *  of entries from that filter set are moved to a newly added filter set in
 *  order to make room for a new entry.  If no entries are moved (the new
 *  filter set is inserted entirely between existing filter sets with no entry
 *  movement), it is not considered a split by this description.
 */
#define C3_RCE_FILTER_SET_SPLIT_BALANCING TRUE
#define C3_RCE_FILTER_SET_SPLIT_BALANCING_THRESHOLD 32

/*
 *  How long must we wait after starting one key before we can start another
 *  key, expressed in RCE clocks.  We add one here just for good measure, to
 *  deal with any reasonable clock skew.
 */
#define C3_RCE_KEY_TRANSFER_SHADOW 129

/*
 *  Number of LRP instructions it takes before a 'key' instruction hits the
 *  execution phase in the pipeline
 */
#define C3_LRP_KEY_DELAY_INSTRUCTIONS 3

/*
 *  This indicates what to add to the register controlling epoch length to
 *  determine the actual epoch length.
 */
#define C3_RCE_TIMING_LRP_EPOCH_BIAS 17

#if C3_RCE_FILTER_SET_SPLIT_BALANCING
/*
 *  The setting for C3_RCE_FILTER_SET_SPLIT_BALANCING_THRESHOLD must not put
 *  the boundary outside of the filter set.
 */
#if (C3_RCE_FILTER_SET_SPLIT_BALANCING_THRESHOLD > ((C3_RCE_ENTRIES_PER_FILTER_SET / 2) - 1))
#error "C3_RCE_FILTER_SET_SPLIT_BALANCING_THRESHOLD must be at least one less than half of C3_RCE_ENTRIES_PER_FILTER_SET"
#endif /* (C3_RCE_FILTER_SET_SPLIT_BALANCING_THRESHOLD > ((C3_RCE_ENTRIES_PER_FILTER_SET / 2) - 1)) */
#if (1 > C3_RCE_FILTER_SET_SPLIT_BALANCING_THRESHOLD)
#error "C3_RCE_FILTER_SET_SPLIT_BALANCING_THRESHOLD must be greater than zero"
#endif /* (1 > C3_RCE_FILTER_SET_SPLIT_BALANCING_THRESHOLD) */
#endif /* C3_RCE_FILTER_SET_SPLIT_BALANCING */

#if defined(BROADCOM_DEBUG)
/*
 *  Formatting for disassembly needs separator bars...
 */
static const char *_soc_c3_rce_disasm_bar = "--- - ------- - ------- ---- ------ ------";

/*
 *  Names for stuff
 */
static const char *_soc_c3_rce_opcode_names[] =
{
    _SOC_C3_RCE_INSTRUCTION_NAMES
};
static const char *_soc_c3_rce_predicate_names[] =
{
    _SOC_C3_RCE_PREDICATE_NAMES
};
static const char *_soc_c3_rce_qual_type_names[] =
{
    SOC_C3_RCE_QUALIFIER_TYPE_NAMES
};
static const char *_soc_c3_rce_action_uc_type_names[] =
{
    SOC_C3_RCE_ACTION_UC_TYPE_NAMES
};
static const char *_soc_c3_rce_data_header_names[] =
{
    SOC_C3_RCE_DATA_HEADER_TYPE_NAMES
};
static const char *_soc_c3_rce_metadata_type_names[] =
{
    SOC_C3_RCE_METADATA_TYPE_NAMES
};

/*
 *  This structure is passed around by the dump functions so they can use the
 *  traverse functions to operate instead of replicating that functionality.
 */
typedef struct _soc_c3_rce_unit_dump_params_s {
    _soc_c3_rce_unit_desc_int_t *unitData;  /* unit information */
    uint32 flags;                           /* dump flags */
    const char *prefix;                     /* prefix string */
    unsigned int count;                     /* number of items dumped */
} _soc_c3_rce_unit_dump_params_t;
#endif /* defined(BROADCOM_DEBUG) */

/*
 *  These arrays are used when manipulating a single bit (or byte) of pattern,
 *  usually for a specific entry.  For example, to 'remove' an entry, we simply
 *  set its valid bit (the pattern bit corresponding to the start opcode) to
 *  zero -- there is no need to rebuild and reinstall the entire filter set.
 */
static const soc_mem_t _soc_c3_patt_mems[24] = {
    PMEM0m,  PMEM1m,  PMEM2m,  PMEM3m,  PMEM4m,  PMEM5m,  PMEM6m,  PMEM7m,
    PMEM8m,  PMEM9m,  PMEM10m, PMEM11m, PMEM12m, PMEM13m, PMEM14m, PMEM15m,
    PMEM16m, PMEM17m, PMEM18m, PMEM19m, PMEM20m, PMEM21m, PMEM22m, PMEM23m
};
static const soc_field_t _soc_c3_patt_fields[32] = {
    PBITS0f,  PBITS1f,  PBITS2f,  PBITS3f,
    PBITS4f,  PBITS5f,  PBITS6f,  PBITS7f,
    PBITS8f,  PBITS9f,  PBITS10f, PBITS11f,
    PBITS12f, PBITS13f, PBITS14f, PBITS15f,
    PBITS16f, PBITS17f, PBITS18f, PBITS19f,
    PBITS20f, PBITS21f, PBITS22f, PBITS23f,
    PBITS24f, PBITS25f, PBITS26f, PBITS27f,
    PBITS28f, PBITS29f, PBITS30f, PBITS31f
};

/*
 * For manipulating imem directly rather than imem+pmem in blocks...
 */
static const soc_field_t _soc_c3_imem_fields[8] =
{
    INSTRUCTION0f, INSTRUCTION1f, INSTRUCTION2f, INSTRUCTION3f,
    INSTRUCTION4f, INSTRUCTION5f, INSTRUCTION6f, INSTRUCTION7f
};

/*
 *  For access to debugging registers...
 */
static const soc_reg_t _soc_c3_rce_debug_key_capture[15] = {
    RC_TRACE_IF_LRP_CAPT_0r,
    RC_TRACE_IF_LRP_CAPT_1r,
    RC_TRACE_IF_LRP_CAPT_2r,
    RC_TRACE_IF_LRP_CAPT_3r,
    RC_TRACE_IF_LRP_CAPT_4r,
    RC_TRACE_IF_LRP_CAPT_5r,
    RC_TRACE_IF_LRP_CAPT_6r,
    RC_TRACE_IF_LRP_CAPT_7r,
    RC_TRACE_IF_LRP_CAPT_8r,
    RC_TRACE_IF_LRP_CAPT_9r,
    RC_TRACE_IF_LRP_CAPT_10r,
    RC_TRACE_IF_LRP_CAPT_11r,
    RC_TRACE_IF_LRP_CAPT_12r,
    RC_TRACE_IF_LRP_CAPT_13r,
    RC_TRACE_IF_LRP_CAPT_14r
};
static const soc_reg_t _soc_c3_rce_debug_key_data[15] = {
    RC_TRACE_IF_LRP_FIELD_VALUE0r,
    RC_TRACE_IF_LRP_FIELD_VALUE1r,
    RC_TRACE_IF_LRP_FIELD_VALUE2r,
    RC_TRACE_IF_LRP_FIELD_VALUE3r,
    RC_TRACE_IF_LRP_FIELD_VALUE4r,
    RC_TRACE_IF_LRP_FIELD_VALUE5r,
    RC_TRACE_IF_LRP_FIELD_VALUE6r,
    RC_TRACE_IF_LRP_FIELD_VALUE7r,
    RC_TRACE_IF_LRP_FIELD_VALUE8r,
    RC_TRACE_IF_LRP_FIELD_VALUE9r,
    RC_TRACE_IF_LRP_FIELD_VALUE10r,
    RC_TRACE_IF_LRP_FIELD_VALUE11r,
    RC_TRACE_IF_LRP_FIELD_VALUE12r,
    RC_TRACE_IF_LRP_FIELD_VALUE13r,
    RC_TRACE_IF_LRP_FIELD_VALUE14r
};
static const soc_reg_t _soc_c3_rce_debug_key_mask[15] = {
    RC_TRACE_IF_LRP_FIELD_MASK0r,
    RC_TRACE_IF_LRP_FIELD_MASK1r,
    RC_TRACE_IF_LRP_FIELD_MASK2r,
    RC_TRACE_IF_LRP_FIELD_MASK3r,
    RC_TRACE_IF_LRP_FIELD_MASK4r,
    RC_TRACE_IF_LRP_FIELD_MASK5r,
    RC_TRACE_IF_LRP_FIELD_MASK6r,
    RC_TRACE_IF_LRP_FIELD_MASK7r,
    RC_TRACE_IF_LRP_FIELD_MASK8r,
    RC_TRACE_IF_LRP_FIELD_MASK9r,
    RC_TRACE_IF_LRP_FIELD_MASK10r,
    RC_TRACE_IF_LRP_FIELD_MASK11r,
    RC_TRACE_IF_LRP_FIELD_MASK12r,
    RC_TRACE_IF_LRP_FIELD_MASK13r,
    RC_TRACE_IF_LRP_FIELD_MASK14r
};

/*
 *  When scanning LRP instructions, the streams are stored in forced LE format
 *  with forced 32b grains, which themselves are BE.
 */
#define PACK_INST(a, b, c, d) ((a) << 24 | (b) << 16 | (c) << 8 | (d))

/*
 *  This is an array of pointers to the unit information, one element in the
 *  array per unit supported.
 */
static _soc_c3_rce_unit_desc_int_t *_soc_c3_rce[SOC_MAX_NUM_DEVICES] = { NULL };


/*--------------------------------------------------------------------------
 *
 *  Implementation of various qualifier types and how they are manipulated.
 */

/*
 *  Function
 *    _soc_c3_rce_program_qualifier_build
 *  Purpose
 *    Build a qualifier by scanning a program's key for a specified field
 *  Arguments
 *    (IN) unitData = pointer to unit information
 *    (IN) programId = which program to dump
 *    (IN/OUT) headerField = pointer to header field information
 *    (IN) qualType = what qualifier type is desired
 *    (OUT) qualDesc = where to put pointer to the constructed qualifier
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    This builds a qualifier description of the requested type, if possible,
 *    that represents the requested frame field or metadatum, if available in
 *    the program's key.
 *
 *    The resulting qualifier description is owned by the caller.  It can be
 *    used to build (a) group(s) as needed, and then disposed of by the call
 *    below, soc_c3_rce_program_qualifier_free.
 *
 *    If the requested type implies a contiguous field in the key, and this is
 *    not possible (the key field is not contiguous), but it is possible to use
 *    a non-contiguous field instead, this will automatically use the
 *    non-contiguous form.  Similar for non-contiguous forms -- if it would be
 *    valid to express the field contiguously, that form will be used.
 *
 *    If a metadata field is requested but the requested bit count is zero, the
 *    resulting qualifier will be for the entire metadata field, and the
 *    headerField descriptor will be updated to indicate the correct length.
 *
 *    In any other case, a zero bit count is not valid.
 *
 *    This function does not support offsetting metadata fields; if the
 *    requested length is nonzero but is shorter than the entire field, the
 *    resulting qualifier will cover the LSbs of the field.
 *
 *    Because SOC_E_UNAVAIL would be traditional for return in case of an
 *    unsupported field (see the BCM field APIs), this returns SOC_E_UNAVAIL if
 *    it is unable to find any of the requested bits in the program's key.
 *
 *    At this time, this function will not combine fields.  This means that if
 *    the key has IPv4 source and IPv4 destination as separate fields in the
 *    key, they can not be combined into a single qualifier.
 */
static int
_soc_c3_rce_program_qualifier_build(_soc_c3_rce_unit_desc_int_t *unitData,
                                    int programId,
                                    soc_c3_rce_header_field_info_t *headerField,
                                    soc_c3_rce_qual_type_t qualType,
                                    soc_c3_rce_qual_desc_t **qualDesc)
{
    _soc_c3_rce_program_desc_int_t *progData;
    soc_c3_rce_qual_desc_t *qualInfo = NULL;
    const soc_c3_rce_qual_uc_desc_t *qualData = NULL;
    unsigned int index = ~0;
    unsigned int offset;
    int reqStart;
    int reqEnd;
    int reqSkew;
    int fldStart = 0;
    int fldEnd;
    int fldCurr;
    int fldSkew;
    int sparse;
    int result = SOC_E_NONE;

    if ((0 > qualType) || (socC3RCEQualTypeCount <= qualType)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("qualType %d is not valid\n"),
                   qualType));
        result = SOC_E_PARAM;
        goto error;
    }
    progData = unitData->progData[programId];
    switch (headerField->header) {
    case socC3RceDataDirectKey:
        /* requested field is raw key bits, special case */
        /* note: frame pivot (MSb, length) */
        fldSkew = headerField->startBit;
        reqSkew = (headerField->startBit - headerField->numBits) + 1;
        if ((SOC_C3_RCE_KEY_BIT_MINIMUM > reqSkew) ||
            (SOC_C3_RCE_KEY_BIT_MAXIMUM < fldSkew)) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("requested field %d..%d is not within key,"
                                " which includes bits %d..%d\n"),
                       fldSkew,
                       reqSkew,
                       SOC_C3_RCE_KEY_BIT_MAXIMUM,
                       SOC_C3_RCE_KEY_BIT_MINIMUM));
            result = SOC_E_PARAM;
            goto error;
        }
        break;
    case socC3RceDataMetadata:
        /* requested field is metadata, special case */
        for (index = 0;
             (socC3RceDataOffsetCount !=
              progData->ucData->qualifiers[index].hdr.header) &&
             ((socC3RceDataMetadata !=
               progData->ucData->qualifiers[index].hdr.header) &&
              (headerField->startBit !=
               progData->ucData->qualifiers[index].hdr.startBit));
             index++) {
            /* just iterate until fall off the end or find the metadatum */
        } /* for (all fields in this program's key) */
        qualData = &(progData->ucData->qualifiers[index]);
        if (0 == headerField->numBits) {
            headerField->numBits = qualData->hdr.numBits;
        }
        reqStart = headerField->numBits - 1; /* MSb is requested high bit */
        reqEnd = 0; /* LSb is bit zero */
        fldSkew = qualData->hdr.numBits - reqStart; /* req MSb skew fld MSb */
        reqSkew = 0; /* skew from LSb in key is zero */
        break;
    case socC3RceDataHeaderRaw:
    case socC3RceDataHeaderEther:
    case socC3RceDataHeaderVlan:
    case socC3RceDataHeaderIpv4:
    case socC3RceDataHeaderIpv6:
    case socC3RceDataHeaderTcpUdp:
        /* requested field is frame data */
        reqStart = headerField->startBit ^ 0x7;
        reqEnd = reqStart + headerField->numBits - 1;
        for (index = 0, qualData = &(progData->ucData->qualifiers[index]);
             socC3RceDataOffsetCount != qualData->hdr.header;
             index++, qualData = &(progData->ucData->qualifiers[index])) {
            if (headerField->header == qualData->hdr.header) {
                fldStart = qualData->hdr.startBit ^ 7;
                fldEnd = fldStart + qualData->hdr.numBits;
                if ((fldStart <= reqStart) && (fldEnd >= reqEnd)) {
                    /* found a field that covers the request */
                    break;
                }
            }
        } /* for (all fields in this program's key) */
        fldSkew = reqStart - fldStart; /* requested MSb skew from field MSb */
        reqSkew = qualData->hdr.numBits - fldSkew - headerField->numBits;
        break;
    default:
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("header type %d is not valid\n"),
                   headerField->header));
        result = SOC_E_PARAM;
        goto error;
    } /* switch (headerField->header) */
    if (socC3RceDataDirectKey == headerField->header) {
        /* block of raw key bits; never sparse mode, no mapping needed */
        sparse = FALSE;
    } else { /* if (socC3RceDataDirectKey == headerField->header) */
        /* not raw key bits; compute mapping */
        if (socC3RceDataOffsetCount == qualData->hdr.header) {
            /* no matching qualifier found */
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unit %d program %d does not have a qualifier"
                       " matching (%d,%d,%u)\n"),
                       unitData->unit,
                       programId,
                       headerField->header,
                       headerField->startBit,
                       headerField->numBits));
            result = SOC_E_UNAVAIL;
            goto error;
        } /* if (socC3RceDataOffsetCount == qualData->hdr.header) */
        /* make fldSkew MSb of the key field; reqSkew is already the LSb */
        fldSkew = reqSkew + headerField->numBits - 1;
        /* see if we can do this as a contiguous field or need to use sparse */
        for (index = 0, fldStart = 0, sparse = TRUE;
             index < SOC_C3_RCE_MAX_SEG_PER_QUALIFIER;
             index++) {
            /* figure out where this segment ends */
            fldEnd = (qualData->loc[index].numBits + fldStart) - 1;
            if ((reqSkew >= fldStart) && (fldSkew <= fldEnd)) {
                /* this segment covers the entire request */
                sparse = FALSE;
                break;
            }
            /* this segment does not cover this request; look at next segment */
            fldStart += qualData->loc[index].numBits;
        } /* for (all valid qualifier segments) */
    } /* if (socC3RceDataDirectKey == headerField->header) */
    /*
     *  NOTE: sparse mode is actually more efficient for a *single* bit, but
     *  this distinction is usually moot due to alloc cell grain size on most
     *  operating systems (between 8 and 64 bytes).  The above loop will always
     *  consider a single-bit-wide field to be contiguous.
     */
    qualInfo = sal_alloc(sizeof(*qualInfo),
                         "C3 RCE qualifier information");
    if (!qualInfo) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %u bytes for qualifier info\n"),
                   (unsigned int)sizeof(*qualInfo)));
        result = SOC_E_MEMORY;
        goto error;
    }
    sal_memset(qualInfo, 0x00, sizeof(*qualInfo));
    qualInfo->qualName = headerField->fieldName;
    if (sparse) {
        /* needed to use a sparse qualifier */
        qualInfo->paramCount = headerField->numBits;
        if (socC3RCEQualType_prefix == qualType) {
            qualInfo->qualType = socC3RCEQualType_prefix_sparse;
        } else if (socC3RCEQualType_postfix == qualType) {
            qualInfo->qualType = socC3RCEQualType_postfix_sparse;
        } else if (socC3RCEQualType_masked == qualType) {
            qualInfo->qualType = socC3RCEQualType_masked_sparse;
        } else if (socC3RCEQualType_exact == qualType) {
            qualInfo->qualType = socC3RCEQualType_exact_sparse;
        } else {
            qualInfo->qualType = qualType;
        }
    } else { /* if (sparse) */
        /* can use a contiguous qualifier */
        qualInfo->paramCount = 2;
        if (socC3RCEQualType_prefix_sparse == qualType) {
            qualInfo->qualType = socC3RCEQualType_prefix;
        } else if (socC3RCEQualType_postfix_sparse == qualType) {
            qualInfo->qualType = socC3RCEQualType_postfix;
        } else if (socC3RCEQualType_masked_sparse == qualType) {
            qualInfo->qualType = socC3RCEQualType_masked;
        } else if (socC3RCEQualType_exact_sparse == qualType) {
            qualInfo->qualType = socC3RCEQualType_exact;
        } else {
            qualInfo->qualType = qualType;
        }
    } /* if (sparse) */
    qualInfo->param = sal_alloc(sizeof(*(qualInfo->param)) *
                                qualInfo->paramCount,
                                "C3 RCE qualifier parameters");
    if (!(qualInfo->param)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %u bytes for qualifier"
                   " parameters\n"),
                   (unsigned int)(sizeof(*(qualInfo->param)) *
                   qualInfo->paramCount)));
        result = SOC_E_MEMORY;
        goto error;
    }
    if (socC3RceDataDirectKey == headerField->header) {
        /* direct key bits, just copy the ends of the block */
        qualInfo->param[0] = reqSkew;
        qualInfo->param[1] = fldSkew;
    } else { /* if (socC3RceDataDirectKey == headerField->header) */
        /* not direct key bits; handle sparse/dense mode mappings */
        if (sparse) {
            /* sparse mode; scan segments for bits of interest */
            for (index = 0, fldCurr = 0, offset = 0;
                 index < SOC_C3_RCE_MAX_SEG_PER_QUALIFIER;
                 index++) {
                fldEnd = qualData->loc[index].numBits;
                if (fldCurr + fldEnd <= reqSkew) {
                    /* entire segment is before desired field starts */
                    fldCurr += fldEnd;
                    continue;
                }
                for (fldStart = 0;
                     (fldStart < fldEnd) && (fldCurr <= fldSkew);
                     fldStart++, fldCurr++) {
                    if ((fldCurr >= reqSkew) && (fldCurr <= fldSkew)) {
                        /* add this key bit to the qualifier's bits list */
                        qualInfo->param[offset] = (fldStart +
                                                   qualData->loc[index].startBit);
                        offset++;
                    } /* if (this bit is in the requested field) */
                } /* for (all bits in this segment that are before the req end) */
            } /* for (each segment in this qualifier) */
        } else { /* if (sparse) */
            /* contiguous mode; all bits of interest are in current segment */
            qualInfo->param[0] = reqSkew + qualData->loc[index].startBit;
            qualInfo->param[1] = fldSkew + qualData->loc[index].startBit;
        } /* if (sparse) */
    } /* if (socC3RceDataDirectKey == headerField->header) */
    *qualDesc = qualInfo;
error:
    if (SOC_E_NONE != result) {
        if (qualInfo) {
            if (qualInfo->param) {
                sal_free(qualInfo->param);
            }
            sal_free(qualInfo);
        }
    }
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_program_build_prefix
 *  Purpose
 *    Builds (or counts) the instructions needed for a specific prefix match
 *    qualifier operation against the key.
 *  Arguments
 *    (IN) qual = pointer to the qualifier information
 *    (OUT) instr = pointer to buffer for instructions
 *    (OUT) instrCount = where to put number of instructions
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    If the pointer to the instruction space is NULL, it means that the caller
 *    wants only to know how many instructions will be required.
 *
 *    Prefix qualifiers can be aligned arbitrarily within the key.
 *
 *    Prefix qualifiers are masked so that most significant bits are important,
 *    while less significant bits can be ignored.
 *
 *    Embeds the values needed for the don't care state for this qualifier into
 *    the high bit of the opcodes.
 *
 *    When updating this and its associated functions, must also update
 *    _soc_c3_rce_wb_program_recover_general and its associated functions.
 */
static int
_soc_c3_rce_program_build_prefix(const _soc_c3_rce_qual_desc_int_t *qual,
                                 _soc_c3_rce_instruction_t *instr,
                                 unsigned int *instrCount)
{
    unsigned int index;
    unsigned int count;
    unsigned int bit;
    uint16 bitMask;
    uint16 bitData;
    /*
     *  The 'prefix' qualifier type takes two arguments: low key bit and high
     *  key bit.  These arguments are used when generating the RCE code to
     *  provide the data for the instructions needed.
     */
    if (qual->paramCount != 2) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("prefix qualifier accepts exactly two parameters,"
                   " %u parameters provided\n"),
                   qual->paramCount));
        return SOC_E_PARAM;
    }
    if (qual->param[0] > qual->param[1]) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("prefix qualifier requires first bit %d be <= last"
                   " bit %d\n"),
                   qual->param[0],
                   qual->param[1]));
        return SOC_E_PARAM;
    }
    if ((SOC_C3_RCE_KEY_BIT_MINIMUM > qual->param[0]) ||
        (SOC_C3_RCE_KEY_BIT_MAXIMUM < qual->param[0]) ||
        (SOC_C3_RCE_KEY_BIT_MINIMUM > qual->param[1]) ||
        (SOC_C3_RCE_KEY_BIT_MAXIMUM < qual->param[1])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("key bits are %d..%d; specified range is %d..%d\n"),
                   SOC_C3_RCE_KEY_BIT_MINIMUM,
                   SOC_C3_RCE_KEY_BIT_MAXIMUM,
                   qual->param[0],
                   qual->param[1]));
        return SOC_E_PARAM;
    }
    /*
     *  Prefix matching uses a prefix instruction, the number of bits to cover
     *  in data instructions.
     */
    count = (qual->param[1] - qual->param[0]) + 1;
    *instrCount = count + 2;
    if (instr) {
        /* caller provided a buffer for the instructions, specify them */
        for (index = 0, bit = qual->param[0]; index <= count; index++) {
            if (0 == index) {
                /* first instruction */
                COMPILER_64_SET(instr[index],
                                (1 << 31) | (_c3RCEOpcode_prefix << 8),
                                0);
            } else { /* if (0 == index) */
                /* data bits instructions */
                bitData = 1 << (bit & 15);
                bitMask = ~bitData;
                COMPILER_64_SET(instr[index],
                                (((index < count)?(1 << 31):0) |
                                 (_c3RCEOpcode_data << 8) |
                                 (_c3RCEPredicate_MaskOr << 5) |
                                 (bit >> 4)),
                                (bitData << 16) | bitMask);
                bit++;
            } /* if (0 == index) */
        } /* for (index = 0, bit = qual->param[0]; index <= count; index++) */
        /* workaround for following field interaction */
        COMPILER_64_SET(instr[index],
                        (_c3RCEOpcode_nop << 8),
                        0);
    } /* if (instr) */
    return SOC_E_NONE;
}

/*
 *  Function
 *    _soc_c3_rce_program_build_prefix_sparse
 *  Purpose
 *    Builds (or counts) the instructions needed for a specific prefix match
 *    qualifier operation against the key.
 *  Arguments
 *    (IN) qual = pointer to the qualifier information
 *    (OUT) instr = pointer to buffer for instructions
 *    (OUT) instrCount = where to put number of instructions
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    If the pointer to the instruction space is NULL, it means that the caller
 *    wants only to know how many instructions will be required.
 *
 *    Prefix qualifiers can be aligned arbitrarily within the key.
 *
 *    Prefix qualifiers are masked so that most significant bits are important,
 *    while less significant bits can be ignored.
 *
 *    Embeds the values needed for the don't care state for this qualifier into
 *    the high bit of the opcodes.
 *
 *    When updating this and its associated functions, must also update
 *    _soc_c3_rce_wb_program_recover_general and its associated functions.
 */
static int
_soc_c3_rce_program_build_prefix_sparse(const _soc_c3_rce_qual_desc_int_t *qual,
                                        _soc_c3_rce_instruction_t *instr,
                                        unsigned int *instrCount)
{
    unsigned int index;
    unsigned int count;
    unsigned int bit;
    uint16 bitMask;
    uint16 bitData;
    /*
     *  The 'sparse prefix' qualifier type takes a list of bits from the key,
     *  from LSb to MSb.  These arguments are used when generating the RCE code
     *  to provide the data for the instructions needed.
     */
    if (1 > qual->paramCount) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("prefix qualifier must be at least 1 bit long\n")));
        return SOC_E_PARAM;
    }
    /*
     *  Prefix matching uses a prefix instruction, the number of bits to cover
     *  in data instructions.
     */
    count = qual->paramCount;
    *instrCount = count + 2;
    /*
     *  Error checking is done one bit at a time, so we need to iterate thorugh
     *  the bits list do to the error checking.  If there is no output buffer,
     *  we will not write anything to it, but still need to check the bits.
     */
    for (index = 0; index <= count; index++) {
        if (0 == index) {
            if (instr) {
                /* first instruction */
                COMPILER_64_SET(instr[index],
                                (1 << 31) | (_c3RCEOpcode_prefix << 8),
                                0);
            }
        } else { /* if (0 == index) */
            bit = qual->param[index - 1];
            /* coverity[unsigned_compare] */
            if ((SOC_C3_RCE_KEY_BIT_MINIMUM > bit) ||
                (SOC_C3_RCE_KEY_BIT_MAXIMUM < bit)) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("key bits are %d..%d, but got bit %u\n"),
                           SOC_C3_RCE_KEY_BIT_MINIMUM,
                           SOC_C3_RCE_KEY_BIT_MAXIMUM,
                           bit));
                return SOC_E_PARAM;
            }
            if (instr) {
                /* data bits instructions */
                bitData = 1 << (bit & 15);
                bitMask = ~bitData;
                COMPILER_64_SET(instr[index],
                                (((index < count)?(1 << 31):0) |
                                 (_c3RCEOpcode_data << 8) |
                                 (_c3RCEPredicate_MaskOr << 5) |
                                 (bit >> 4)),
                                (bitData << 16) | bitMask);
            }
        } /* if (0 == index) */
    } /* for (index = 0; index < count; index++) */
    if (instr) {
        /* workaround for following field interaction */
        COMPILER_64_SET(instr[index],
                        (_c3RCEOpcode_nop << 8),
                        0);
    }
    return SOC_E_NONE;
}

/*
 *  Function
 *    _soc_c3_rce_entry_qualify_prefix_set
 *  Purpose
 *    Takes data/mask information and builds the pattern data for a prefix
 *    qualifier's instructions
 *  Arguments
 *    (IN) qual = pointer to the qualifier information
 *    (IN) data = pointer to the data bits
 *    (IN) mask = pointer to the mask bits
 *    (IN) patternStart = first bit in pattern for this qualifier
 *    (OUT) pattern = pointer to the buffer for pattern bits
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Prefix qualifiers are masked so that most significant bits are important,
 *    while less significant bits can be ignored.  We only keep track of the
 *    important bits and the mask here; all else is lost.
 */
static int
_soc_c3_rce_entry_qualify_prefix_set(const _soc_c3_rce_qual_desc_int_t *qual,
                                     const uint8 *data,
                                     const uint8 *mask,
                                     unsigned int patternStart,
                                     uint8 *pattern)
{
    unsigned int index;
    unsigned int dataIndex;
    unsigned int pattIndex;
    unsigned int count;
    unsigned int length;
    /*
     *  Prefix qualifiers require that the mask be zeroes until the first one,
     *  then it remains one until the end of the qualifier, scanning from the
     *  low bit to the high bit.
     */
    if (socC3RCEQualType_prefix == qual->qualType) {
        count = (qual->param[1] - qual->param[0]) + 1;
    } else if (socC3RCEQualType_prefix_sparse == qual->qualType) {
        count = qual->paramCount;
    } else {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("prefix qualifier set only understands prefix"
                   " type qualifiers, not %d\n"),
                   qual->qualType));
        return SOC_E_PARAM;
    }
    length = count;
    for (index = 0; index < count; index++) {
        if (mask[index >> 3] & (1 << (index & 7))) {
            /* this bit is one; now we have an important bit */
            length = index;
            break;
        }
    }
    for (; index < count; index++) {
        if (0 == (mask[index >> 3] & (1 << (index & 7)))) {
            /* this bit is zero; not a valid prefix mask */
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("prefix qualifier requires all zero bits in the"
                       " mask (if any) be gathered at the least"
                       " significant bits, but bit %u is a zero bit"
                       " that is more significant than a one bit\n"),
                       index));
            return SOC_E_PARAM;
        }
    }
    /* include the 'prefix' instruction */
    count++;
    /* got to here, so mask is valid; build pattern data */
    for (index = 0, pattIndex = patternStart;
         index < count;
         index++, pattIndex++) {
        if (index < length) {
            /* not to important bits yet */
            pattern[pattIndex >> 3] |= (1 << (pattIndex & 7));
        } else if (index == length) {
            /* transition to important bits now */
            pattern[pattIndex >> 3] &= (~(1 << (pattIndex & 7)));
        } else {
            /* follow important bits */
            dataIndex = index - 1;
            if (data[dataIndex >> 3] & (1 << (dataIndex & 7))) {
                /* important bit is one; set pattern bit */
                pattern[pattIndex >> 3] |= (1 << (pattIndex & 7));
            } else { /* if (data[offset >> 3] & (1 << (offset & 7))) */
                /* important bit is zero; clear pattern bit */
                pattern[pattIndex >> 3] &= (~(1 << (pattIndex & 7)));
            } /* if (data[offset >> 3] & (1 << (offset & 7))) */
        }
    } /* for (index = 0; index < count; index++) */
    return SOC_E_NONE;
}

/*
 *  Function
 *    _soc_c3_rce_entry_qualify_prefix_get
 *  Purpose
 *    Takes data/mask information and gets the pattern data for a prefix
 *    qualifier's instructions
 *  Arguments
 *    (IN) qual = pointer to the qualifier information
 *    (IN) patternStart = where in the pattern this qualifier starts
 *    (IN) pattern = pointer to the buffer for pattern bits
 *    (OUT) data = pointer to the data bits
 *    (OUT) mask = pointer to the mask bits
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Prefix qualifiers are masked so that most significant bits are important,
 *    while less significant bits can be ignored.  We only keep track of the
 *    important bits and the mask here; all else is lost.
 */
static int
_soc_c3_rce_entry_qualify_prefix_get(const _soc_c3_rce_qual_desc_int_t *qual,
                                     unsigned int patternStart,
                                     const uint8 *pattern,
                                     uint8 *data,
                                     uint8 *mask)
{
    unsigned int index;
    unsigned int dataIndex;
    unsigned int pattIndex;
    unsigned int count;
    int masked;
    /*
     *  Prefix qualifiers have information about mask and significant bits.
     */
    if (socC3RCEQualType_prefix == qual->qualType) {
        count = (qual->param[1] - qual->param[0]) + 2;
    } else if (socC3RCEQualType_prefix_sparse == qual->qualType) {
        count = qual->paramCount + 1;
    } else {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("prefix qualifier get only understands prefix"
                   " type qualifiers, not %d\n"),
                   qual->qualType));
        return SOC_E_PARAM;
    }
    for (dataIndex = 0; dataIndex < ((count + 6) >> 3); dataIndex++) {
        data[dataIndex] = 0;
        mask[dataIndex] = 0;
    }
    for (index = 0, pattIndex = patternStart, masked = TRUE;
         index < count;
         index++, pattIndex++) {
        if (masked) {
            /*
             *  Both mask and data are zero for ignored bits; we do not set
             *  this explicitly because the bytes have aleady been zeroed.
             */
            if (0 == (pattern[pattIndex >> 3] & (1 << (pattIndex & 7)))) {
                /*
                 *  Hit the first zero in the pattern; all bits after this one
                 *  are normal (must match exactly).
                 */
                masked = FALSE;
            }
        } else { /* if (masked) */
            /* this bit is important */
            dataIndex = index - 1;
            mask[dataIndex >> 3] |= (1 << (dataIndex & 7));
            if (pattern[pattIndex >> 3] & (1 << (pattIndex & 7))) {
                /* this data bit is one */
                data[dataIndex >> 3] |= (1 << (dataIndex & 7));
            } /* if (pattern[pattIndex >> 3] & (1 << (pattIndex & 7))) */
            /*
             *  There is no else for this if because we already zeroed the
             *  bytes above and the else case would have the bit set to zero.
             */
        } /* if (masked) */
    } /* for (index = 1; index < count; index++) */
    if (masked) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unexpected internal state: prefix qualifier is"
                   " still masked after all bits\n")));
        return SOC_E_INTERNAL;
    }
    return SOC_E_NONE;
}

/*
 *  Function
 *    _soc_c3_rce_program_build_postfix
 *  Purpose
 *    Builds (or counts) the instructions needed for a specific postfix match
 *    qualifier operation against the key.
 *  Arguments
 *    (IN) qual = pointer to the qualifier information
 *    (OUT) instr = pointer to buffer for instructions
 *    (OUT) instrCount = where to put number of instructions
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    If the pointer to the instruction space is NULL, it means that the caller
 *    wants only to know how many instructions will be required.
 *
 *    Postfix qualifiers can be aligned arbitrarily within the key.
 *
 *    Postfix qualifiers are masked so that least significant bits are
 *    important, while more significant bits can be ignored.
 *
 *    Embeds the values needed for the don't care state for this qualifier into
 *    the high bit of the opcodes.
 *
 *    When updating this and its associated functions, must also update
 *    _soc_c3_rce_wb_program_recover_general and its associated functions.
 */
static int
_soc_c3_rce_program_build_postfix(const _soc_c3_rce_qual_desc_int_t *qual,
                                  _soc_c3_rce_instruction_t *instr,
                                  unsigned int *instrCount)
{
    unsigned int index;
    unsigned int count;
    unsigned int bit;
    uint16 bitMask;
    uint16 bitData;
    /*
     *  The 'postfix' qualifier type takes two arguments: low key bit and high
     *  key bit.  These arguments are used when generating the RCE code to
     *  provide the data for the instructions needed.
     */
    if (qual->paramCount != 2) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("postfix qualifier accepts exactly two parameters,"
                   " %u parameters provided\n"),
                   qual->paramCount));
        return SOC_E_PARAM;
    }
    if (qual->param[1] < qual->param[0]) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("postfix qualifier requires first bit %d be <= last"
                   " bit %d\n"),
                   qual->param[1],
                   qual->param[0]));
        return SOC_E_PARAM;
    }
    if ((SOC_C3_RCE_KEY_BIT_MINIMUM > qual->param[0]) ||
        (SOC_C3_RCE_KEY_BIT_MAXIMUM < qual->param[0]) ||
        (SOC_C3_RCE_KEY_BIT_MINIMUM > qual->param[1]) ||
        (SOC_C3_RCE_KEY_BIT_MAXIMUM < qual->param[1])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("key bits are %d..%d; specified range is %d..%d\n"),
                   SOC_C3_RCE_KEY_BIT_MINIMUM,
                   SOC_C3_RCE_KEY_BIT_MAXIMUM,
                   qual->param[0],
                   qual->param[1]));
        return SOC_E_PARAM;
    }
    /*
     *  Postfix matching uses a prefix instruction, the number of bits to cover
     *  in data instructions.
     */
    count = (qual->param[1] - qual->param[0]) + 1;
    *instrCount = count + 2;
    if (instr) {
        /* caller provided a buffer for the instructions, specify them */
        for (index = 0, bit = qual->param[1]; index <= count; index++) {
            if (0 == index) {
                /* first instruction */
                COMPILER_64_SET(instr[index],
                                (1 << 31) | (_c3RCEOpcode_prefix << 8),
                                0);
            } else { /* if (0 == index) */
                /* data bits instructions */
                bitData = 1 << (bit & 15);
                bitMask = ~bitData;
                COMPILER_64_SET(instr[index],
                                (((index < count)?(1 << 31):0) |
                                 (_c3RCEOpcode_data << 8) |
                                 (_c3RCEPredicate_MaskOr << 5) |
                                 (bit >> 4)),
                                (bitData << 16) | bitMask);
                bit--;
            } /* if (0 == index) */
        } /* for (index = 0, bit = qual->param[0]; index <= count; index++) */
        /* workaround for following field interaction */
        COMPILER_64_SET(instr[index],
                        (_c3RCEOpcode_nop << 8),
                        0);
    } /* if (instr) */
    return SOC_E_NONE;
}

/*
 *  Function
 *    _soc_c3_rce_program_build_postfix_sparse
 *  Purpose
 *    Builds (or counts) the instructions needed for a specific postfix match
 *    qualifier operation against the key.
 *  Arguments
 *    (IN) qual = pointer to the qualifier information
 *    (OUT) instr = pointer to buffer for instructions
 *    (OUT) instrCount = where to put number of instructions
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    If the pointer to the instruction space is NULL, it means that the caller
 *    wants only to know how many instructions will be required.
 *
 *    Postfix qualifiers can be aligned arbitrarily within the key.
 *
 *    Postfix qualifiers are masked so that least significant bits are
 *    important, while more significant bits can be ignored.
 *
 *    Embeds the values needed for the don't care state for this qualifier into
 *    the high bit of the opcodes.
 *
 *    When updating this and its associated functions, must also update
 *    _soc_c3_rce_wb_program_recover_general and its associated functions.
 */
static int
_soc_c3_rce_program_build_postfix_sparse(const _soc_c3_rce_qual_desc_int_t *qual,
                                        _soc_c3_rce_instruction_t *instr,
                                        unsigned int *instrCount)
{
    unsigned int index;
    unsigned int count;
    unsigned int bit;
    uint16 bitMask;
    uint16 bitData;
    /*
     *  The 'sparse postfix' qualifier type takes a list of bits from the key,
     *  from LSb to MSb.  These arguments are used when generating the RCE code
     *  to provide the data for the instructions needed.
     */
    if (1 > qual->paramCount) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("postfix qualifier must be at least 1 bit long\n")));
        return SOC_E_PARAM;
    }
    /*
     *  Prefix matching uses a prefix instruction, the number of bits to cover
     *  in data instructions.
     */
    count = qual->paramCount;
    *instrCount = count + 2;
    /*
     *  Error checking is done one bit at a time, so we need to iterate thorugh
     *  the bits list do to the error checking.  If there is no output buffer,
     *  we will not write anything to it, but still need to check the bits.
     */
    for (index = 0; index <= count; index++) {
        if (0 == index) {
            if (instr) {
                /* first instruction */
                COMPILER_64_SET(instr[index],
                                (1 << 31) | (_c3RCEOpcode_prefix << 8),
                                0);
            }
        } else { /* if (0 == index) */
            bit = qual->param[count - index];
            /* coverity[unsigned_compare] */
            if ((SOC_C3_RCE_KEY_BIT_MINIMUM > bit) ||
                (SOC_C3_RCE_KEY_BIT_MAXIMUM < bit)) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("key bits are %d..%d, but got bit %u\n"),
                           SOC_C3_RCE_KEY_BIT_MINIMUM,
                           SOC_C3_RCE_KEY_BIT_MAXIMUM,
                           bit));
                return SOC_E_PARAM;
            }
            if (instr) {
                /* data bits instructions */
                bitData = 1 << (bit & 15);
                bitMask = ~bitData;
                COMPILER_64_SET(instr[index],
                                (((index < count)?(1 << 31):0) |
                                 (_c3RCEOpcode_data << 8) |
                                 (_c3RCEPredicate_MaskOr << 5) |
                                 (bit >> 4)),
                                (bitData << 16) | bitMask);
            }
        } /* if (0 == index) */
    } /* for (index = 0; index < count; index++) */
    if (instr) {
        /* workaround for following field interaction */
        COMPILER_64_SET(instr[index],
                        (_c3RCEOpcode_nop << 8),
                        0);
    }
    return SOC_E_NONE;
}

/*
 *  Function
 *    _soc_c3_rce_entry_qualify_postfix_set
 *  Purpose
 *    Takes data/mask information and builds the pattern data for a prefix
 *    qualifier's instructions
 *  Arguments
 *    (IN) qual = pointer to the qualifier information
 *    (IN) data = pointer to the data bits
 *    (IN) mask = pointer to the mask bits
 *    (IN) patternStart = first bit in pattern for this qualifier
 *    (OUT) pattern = pointer to the buffer for pattern bits
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Postfix qualifiers are masked so that least significant bits are
 *    important, while more significant bits can be ignored.  We only keep
 *    track of the important bits and the mask here; all else is lost.
 */
static int
_soc_c3_rce_entry_qualify_postfix_set(const _soc_c3_rce_qual_desc_int_t *qual,
                                      const uint8 *data,
                                      const uint8 *mask,
                                      unsigned int patternStart,
                                      uint8 *pattern)
{
    unsigned int index;
    unsigned int dataIndex;
    unsigned int pattIndex;
    unsigned int count;
    unsigned int length;
    /*
     *  Postfix qualifiers require that the mask be zeroes until the first one,
     *  then it remains one until the end of the qualifier, scanning from the
     *  high bit to the low bit.
     */
    if (socC3RCEQualType_postfix == qual->qualType) {
        count = (qual->param[1] - qual->param[0]) + 1;
    } else if (socC3RCEQualType_postfix_sparse == qual->qualType) {
        count = qual->paramCount;
    } else {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("postfix qualifier set only understands postfix"
                   " type qualifiers, not %d\n"),
                   qual->qualType));
        return SOC_E_PARAM;
    }
    length = count;
    for (index = 0; index < count; index++) {
        dataIndex = (count - 1) - index;
        if (mask[dataIndex >> 3] & (1 << (dataIndex & 7))) {
            /* this bit is one; now we have an important bit */
            length = index;
            break;
        }
    }
    while (index < count) {
        dataIndex = (count - 1) - index;
        if (0 == (mask[dataIndex >> 3] & (1 << (dataIndex & 7)))) {
            /* this bit is zero; not a valid postfix mask */
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("postfix qualifier requires all zero bits in the"
                       " mask (if any) be gathered at the most"
                       " significant bits, but bit %u is a zero bit"
                       " that is less significant than a one bit\n"),
                       dataIndex));
            return SOC_E_PARAM;
        }
        index++;
    }
    /* include the 'prefix' instruction */
    count++;
    /* got to here, so mask is valid; build pattern data */
    for (index = 0, pattIndex = patternStart;
         index < count;
         index++, pattIndex++) {
        if (index < length) {
            /* not to important bits yet */
            pattern[pattIndex >> 3] |= (1 << (pattIndex & 7));
        } else if (index == length) {
            /* transition to important bits now */
            pattern[pattIndex >> 3] &= (~(1 << (pattIndex & 7)));
        } else {
            /* follow important bits */
            dataIndex = (count - 1) - index;
            if (data[dataIndex >> 3] & (1 << (dataIndex & 7))) {
                /* important bit is one; set pattern bit */
                pattern[pattIndex >> 3] |= (1 << (pattIndex & 7));
            } else { /* if (data[offset >> 3] & (1 << (offset & 7))) */
                /* important bit is zero; clear pattern bit */
                pattern[pattIndex >> 3] &= (~(1 << (pattIndex & 7)));
            } /* if (data[offset >> 3] & (1 << (offset & 7))) */
        }
    } /* for (index = 0; index < count; index++) */
    return SOC_E_NONE;
}

/*
 *  Function
 *    _soc_c3_rce_entry_qualify_postfix_get
 *  Purpose
 *    Takes data/mask information and gets the pattern data for a postfix
 *    qualifier's instructions
 *  Arguments
 *    (IN) qual = pointer to the qualifier information
 *    (IN) patternStart = where in the pattern this qualifier starts
 *    (IN) pattern = pointer to the buffer for pattern bits
 *    (OUT) data = pointer to the data bits
 *    (OUT) mask = pointer to the mask bits
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Postfix qualifiers are masked so that least significant bits are
 *    important, while more significant bits can be ignored.  We only keep
 *    track of the important bits and the mask here; all else is lost.
 */
static int
_soc_c3_rce_entry_qualify_postfix_get(const _soc_c3_rce_qual_desc_int_t *qual,
                                      unsigned int patternStart,
                                      const uint8 *pattern,
                                      uint8 *data,
                                      uint8 *mask)
{
    unsigned int index;
    unsigned int dataIndex;
    unsigned int pattIndex;
    unsigned int count;
    int masked;
    /*
     *  Prefix qualifiers have information about mask and significant bits.
     */
    if (socC3RCEQualType_postfix == qual->qualType) {
        count = (qual->param[1] - qual->param[0]) + 2;
    } else if (socC3RCEQualType_postfix_sparse == qual->qualType) {
        count = qual->paramCount + 1;
    } else {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("postfix qualifier set only understands postfix"
                   " type qualifiers, not %d\n"),
                   qual->qualType));
        return SOC_E_PARAM;
    }
    for (dataIndex = 0; dataIndex < ((count + 6) >> 3); dataIndex++) {
        data[dataIndex] = 0;
        mask[dataIndex] = 0;
    }
    for (index = 0, pattIndex = patternStart, masked = TRUE;
         index < count;
         index++, pattIndex++) {
        if (masked) {
            /*
             *  Both mask and data are zero for ignored bits; we do not set
             *  this explicitly because the bytes have aleady been zeroed.
             */
            if (0 == (pattern[pattIndex >> 3] & (1 << (pattIndex & 7)))) {
                /*
                 *  Hit the first zero in the pattern; all bits after this one
                 *  are normal (must match exactly).
                 */
                masked = FALSE;
            }
        } else { /* if (masked) */
            /* this bit is important */
            dataIndex = (count - 1) - index;
            mask[dataIndex >> 3] |= (1 << (dataIndex & 7));
            if (pattern[pattIndex >> 3] & (1 << (pattIndex & 7))) {
                /* this data bit is one */
                data[dataIndex >> 3] |= (1 << (dataIndex & 7));
            } /* if (pattern[pattIndex >> 3] & (1 << (pattIndex & 7))) */
            /*
             *  There is no else for this if because we already zeroed the
             *  bytes above and the else case would have the bit set to zero.
             */
        } /* if (masked) */
    } /* for (index = 1; index < count; index++) */
    if (masked) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unexpected internal state: prefix qualifier is"
                   " still masked after all bits\n")));
        return SOC_E_INTERNAL;
    }
    return SOC_E_NONE;
}

/*
 *  Function
 *    _soc_c3_rce_program_build_masked
 *  Purpose
 *    Builds (or counts) the instructions needed for a specific masked match
 *    qualifier operation against the key.
 *  Arguments
 *    (IN) qual = pointer to the qualifier information
 *    (OUT) instr = pointer to buffer for instructions
 *    (OUT) instrCount = where to put number of instructions
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    If the pointer to the instruction space is NULL, it means that the caller
 *    wants only to know how many instructions will be required.
 *
 *    Masked qualifiers can be aligned arbitrarily within the key.
 *
 *    Masked qualifiers allow any bits to be significant or ignored.
 *
 *    Embeds the values needed for the don't care state for this qualifier into
 *    the high bit of the opcodes.
 *
 *    When updating this and its associated functions, must also update
 *    _soc_c3_rce_wb_program_recover_general and its associated functions.
 */
static int
_soc_c3_rce_program_build_masked(const _soc_c3_rce_qual_desc_int_t *qual,
                                 _soc_c3_rce_instruction_t *instr,
                                 unsigned int *instrCount)
{
    unsigned int index;
    unsigned int count;
    unsigned int bit;
    uint16 bitMask;
    uint16 bitData;
    /*
     *  The 'masked' qualifier type takes two arguments: low key bit and high
     *  key bit. These arguments are used when generating the RCE code to
     *  provide the data for the instructions needed.
     */
    if (qual->paramCount != 2) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("masked qualifier accepts exactly two parameters,"
                   " %u parameters provided\n"),
                   qual->paramCount));
        return SOC_E_PARAM;
    }
    if (qual->param[0] > qual->param[1]) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("masked qualifier requires first bit %d be <= last"
                   " bit %d\n"),
                   qual->param[0],
                   qual->param[1]));
        return SOC_E_PARAM;
    }
    if ((SOC_C3_RCE_KEY_BIT_MINIMUM > qual->param[0]) ||
        (SOC_C3_RCE_KEY_BIT_MAXIMUM < qual->param[0]) ||
        (SOC_C3_RCE_KEY_BIT_MINIMUM > qual->param[1]) ||
        (SOC_C3_RCE_KEY_BIT_MAXIMUM < qual->param[1])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("key bits are 0..511; specified range is %d..%d\n"),
                   qual->param[0],
                   qual->param[1]));
        return SOC_E_PARAM;
    }
    /*
     *  Masked matching uses one pair of match0/match1 instruction each for the
     *  number of bits to cover.  To make the disassembly easier to follow, as
     *  well as to simplify bulding the arguments (no need for so many shift
     *  operations), we will match all of the significant zeroes first, then
     *  all of the significant ones.  The specific order here is arbitrary;
     *  the point was to build the arguments without so much shifting.
     */
    count = (qual->param[1] - qual->param[0]) + 1;
    *instrCount = count * 2;
    if (instr) {
        /* caller provided a buffer for the instructions, specify them */
        /* first set of bits provided in buidling will be significant zeroes */
        for (index = 0, bit = qual->param[0]; index < count; index++) {
            bitData = 1 << (bit & 15);
            bitMask = ~bitData;
            COMPILER_64_SET(instr[index],
                            ((_c3RCEOpcode_match0 << 8) |
                             (_c3RCEPredicate_MaskOr << 5) |
                             (bit >> 4)),
                            (bitData << 16) | bitMask);
            bit++;
        } /* for (each bit of the qualifier to cover) */
        /* second set of bits provided in buidling will be significant ones */
        for (index = 0, bit = qual->param[0]; index < count; index++) {
            bitData = 1 << (bit & 15);
            bitMask = ~bitData;
            COMPILER_64_SET(instr[index + count],
                            ((_c3RCEOpcode_match1 << 8) |
                             (_c3RCEPredicate_MaskOr << 5) |
                             (bit >> 4)),
                            (bitData << 16) | bitMask);
            bit++;
        } /* for (each bit of the qualifier to cover) */
    } /* if (instr) */
    return SOC_E_NONE;
}

/*
 *  Function
 *    _soc_c3_rce_program_build_masked_sparse
 *  Purpose
 *    Builds (or counts) the instructions needed for a specific masked match
 *    qualifier operation against the key.
 *  Arguments
 *    (IN) qual = pointer to the qualifier information
 *    (OUT) instr = pointer to buffer for instructions
 *    (OUT) instrCount = where to put number of instructions
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    If the pointer to the instruction space is NULL, it means that the caller
 *    wants only to know how many instructions will be required.
 *
 *    Masked qualifiers can be aligned arbitrarily within the key.
 *
 *    Masked qualifiers allow any bits to be significant or ignored.
 *
 *    Embeds the values needed for the don't care state for this qualifier into
 *    the high bit of the opcodes.
 *
 *    When updating this and its associated functions, must also update
 *    _soc_c3_rce_wb_program_recover_general and its associated functions.
 */
static int
_soc_c3_rce_program_build_masked_sparse(const _soc_c3_rce_qual_desc_int_t *qual,
                                        _soc_c3_rce_instruction_t *instr,
                                        unsigned int *instrCount)
{
    unsigned int index;
    unsigned int count;
    unsigned int bit;
    uint16 bitMask;
    uint16 bitData;
    /*
     *  The 'sparse masked' qualifier type takes a list of bits from the key,
     *  from LSb to MSb.  These arguments are used when generating the RCE code
     *  to provide the data for the instructions needed.
     */
    if (1 > qual->paramCount) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("masked qualifier must be at least 1 bit long\n")));
        return SOC_E_PARAM;
    }
    /*
     *  Masked matching uses one pair of match0/match1 instruction each for the
     *  number of bits to cover.  To make the disassembly easier to follow, as
     *  well as to simplify bulding the arguments (no need for so many shift
     *  operations), we will match all of the significant zeroes first, then
     *  all of the significant ones.  The specific order here is arbitrary;
     *  the point was to build the arguments without so much shifting.
     */
    count = qual->paramCount;
    *instrCount = count * 2;
    /* need to do this loop to check arguments even if no buffer */
    /* first set of bits provided in buidling will be significant zeroes */
    for (index = 0; index < count; index++) {
        bit = qual->param[index];
        /* coverity[unsigned_compare] */
        if ((SOC_C3_RCE_KEY_BIT_MINIMUM > bit) ||
            (SOC_C3_RCE_KEY_BIT_MAXIMUM < bit)) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("key bits are %d..%d, but got bit %u\n"),
                       SOC_C3_RCE_KEY_BIT_MINIMUM,
                       SOC_C3_RCE_KEY_BIT_MAXIMUM,
                       bit));
            return SOC_E_PARAM;
        }
        if (instr) {
            /* caller provided a buffer for the instructions, specify them */
            bitData = 1 << (bit & 15);
            bitMask = ~bitData;
            COMPILER_64_SET(instr[index],
                            ((_c3RCEOpcode_match0 << 8) |
                             (_c3RCEPredicate_MaskOr << 5) |
                             (bit >> 4)),
                            (bitData << 16) | bitMask);
        }
    } /* for (each bit of the qualifier to cover) */
    if (instr) {
        /* only need to do second loop if caller provided a buffer */
        /* second set of bits provided in buidling will be significant ones */
        for (index = 0; index < count; index++) {
            bit = qual->param[index];
            bitData = 1 << (bit & 15);
            bitMask = ~bitData;
            COMPILER_64_SET(instr[index + count],
                            ((_c3RCEOpcode_match1 << 8) |
                             (_c3RCEPredicate_MaskOr << 5) |
                             (bit >> 4)),
                            (bitData << 16) | bitMask);
        } /* for (each bit of the qualifier to cover) */
    } /* if (instr) */
    return SOC_E_NONE;
}

/*
 *  Function
 *    _soc_c3_rce_entry_qualify_masked_set
 *  Purpose
 *    Takes data/mask information and builds the pattern data for a masked
 *    qualifier's instructions
 *  Arguments
 *    (IN) qual = pointer to the qualifier information
 *    (IN) data = pointer to the data bits
 *    (IN) mask = pointer to the mask bits
 *    (IN) patternStart = first bit in pattern for this qualifier
 *    (OUT) pattern = pointer to the buffer for pattern bits
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Masked qualifiers permit arbitrary masking, but are stored according to
 *    which bits must be ones and which bits must be zeroes.  A bit that is not
 *    obliged to be one way or the other is not important; a bit that is
 *    required to be both ways is invalid.
 *
 *    Any bits of data that are not important will be lost.
 */
static int
_soc_c3_rce_entry_qualify_masked_set(const _soc_c3_rce_qual_desc_int_t *qual,
                                     const uint8 *data,
                                     const uint8 *mask,
                                     unsigned int patternStart,
                                     uint8 *pattern)
{
    unsigned int index;
    unsigned int pattIndex;
    unsigned int count;
    /*
     *  Masked qualifiers have information about which bits must be one and
     *  which bits must be zero.
     */
    if (socC3RCEQualType_masked == qual->qualType) {
        count = (qual->param[1] - qual->param[0]) + 1;
    } else if (socC3RCEQualType_masked_sparse == qual->qualType) {
        count = qual->paramCount;
    } else {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("masked qualifier set only understands masked"
                   " type qualifiers, not %d\n"),
                   qual->qualType));
        return SOC_E_PARAM;
    }
    /* Build the pattern specifying the bits that must be zero */
    for (index = 0, pattIndex = patternStart;
         index < count;
         index++, pattIndex++) {
        if ((mask[index >> 3] & (1 << (index & 7))) &&
            (0 == (data[index >> 3] & (1 << (index & 7))))) {
            /* this bit is important and it must be zero */
            pattern[pattIndex >> 3] |= (1 << (pattIndex & 7));
        } else { /* if (key bit must be zero) */
            /* this bit must be one or we don't care, so skip zero check */
            pattern[pattIndex >> 3] &= (~(1 << (pattIndex & 7)));
        } /* if (key bit must be zero) */
    } /* for (index = 0; index < count; index++) */
    /* Build the pattern specifying the bits that must be one */
    for (index = 0, pattIndex = patternStart + count;
         index < count;
         index++, pattIndex++) {
        if ((mask[index >> 3] & (1 << (index & 7))) &&
            (data[index >> 3] & (1 << (index & 7)))) {
            /* this bit is important and it must be one */
            pattern[pattIndex >> 3] |= (1 << (pattIndex & 7));
        } else { /* if (key bit must be 1) */
            /* this bit must be zero or we don't care; so skip one check */
            pattern[pattIndex >> 3] &= (~(1 << (pattIndex & 7)));
        } /* if (key bit must be 1) */
    } /* for (index = 0; index < count; index++) */
    return SOC_E_NONE;
}

/*
 *  Function
 *    _soc_c3_rce_entry_qualify_masked_get
 *  Purpose
 *    Takes data/mask information and get the pattern data for a masked
 *    qualifier's instructions
 *  Arguments
 *    (IN) qual = pointer to the qualifier information
 *    (IN) patternStart = first bit in pattern for this qualifier
 *    (IN) pattern = pointer to the buffer for pattern bits
 *    (OUT) data = pointer to the data bits
 *    (OUT) mask = pointer to the mask bits
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Masked qualifiers permit arbitrary masking, but are stored according to
 *    which bits must be ones and which bits must be zeroes.  A bit that is not
 *    obliged to be one way or the other is not important; a bit that is
 *    required to be both ways is invalid.
 *
 *    Any bits of data that are not important will be lost.
 */
static int
_soc_c3_rce_entry_qualify_masked_get(const _soc_c3_rce_qual_desc_int_t *qual,
                                     unsigned int patternStart,
                                     const uint8 *pattern,
                                     uint8 *data,
                                     uint8 *mask)
{
    unsigned int index;
    unsigned int pattIndex;
    unsigned int count;
    int result = SOC_E_NONE;
    /*
     *  Masked qualifiers have information about which bits must be one and
     *  which bits must be zero.
     */
    if (socC3RCEQualType_masked == qual->qualType) {
        count = (qual->param[1] - qual->param[0]) + 1;
    } else if (socC3RCEQualType_masked_sparse == qual->qualType) {
        count = qual->paramCount;
    } else {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("masked qualifier set only understands masked"
                   " type qualifiers, not %d\n"),
                   qual->qualType));
        return SOC_E_PARAM;
    }
    for (index = 0; index < ((count + 7) >> 3); index++) {
        data[index] = 0;
        mask[index] = 0;
    }
    /* Set mask bits for the bits that must be zero */
    for (index = 0, pattIndex = patternStart;
         index < count;
         index++, pattIndex++) {
        if (pattern[pattIndex >> 3] & (1 << (pattIndex & 7))) {
            mask[index >> 3] |= (1 << (index & 7));
            /*
             *  No need to set data here because we already cleared it and the
             *  value we would want to set is zero.
             */
        } /* if (pattern[index >> 3] & (1 << (index & 7))) */
        /*
         *  There is no else to the above if statement because we already
         *  cleared data and mask and the value we would want to set in this
         *  case is to zero both.
         */
    } /* for (index = 0; index < count; index++) */
    /* Set mask and data bits for the bits that must be one */
    for (index = 0, pattIndex = patternStart + count;
         index < count;
         index++, pattIndex++) {
        if (pattern[pattIndex >> 3] & (1 << (pattIndex & 7))) {
            if (mask[index >> 3] & (1 << (index & 7))) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("unexpected state: bit %u must be both zero"
                           " and one to match\n"),
                           index));
                result = SOC_E_INTERNAL;
            }
            mask[index >> 3] |= (1 << (index & 7));
            data[index >> 3] |= (1 << (index & 7));
        } /* if (this bit is set in the pattern) */
        /*
         *  There is no else to the above if statement because we already
         *  cleared data and mask and the value we would want to set in this
         *  case is to zero both.
         */
    } /* for (index = 0; index < count; index++) */
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_program_build_exact
 *  Purpose
 *    Builds (or counts) the instructions needed for a specific exact match
 *    qualifier operation against the key.
 *  Arguments
 *    (IN) qual = pointer to the qualifier information
 *    (OUT) instr = pointer to buffer for instructions
 *    (OUT) instrCount = where to put number of instructions
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    If the pointer to the instruction space is NULL, it means that the caller
 *    wants only to know how many instructions will be required.
 *
 *    Exact qualifiers can be aligned arbitrarily within the key.
 *
 *    Exact qualifiers require all bits be significant and matched exactly.
 *
 *    There is no don't care state, so the default value embedded in the
 *    pattern assumes all bits zero.
 *
 *    When updating this and its associated functions, must also update
 *    _soc_c3_rce_wb_program_recover_general and its associated functions.
 */
static int
_soc_c3_rce_program_build_exact(const _soc_c3_rce_qual_desc_int_t *qual,
                                _soc_c3_rce_instruction_t *instr,
                                unsigned int *instrCount)
{
    unsigned int index;
    unsigned int count;
    unsigned int bit;
    uint16 bitMask;
    uint16 bitData;
    /*
     *  The 'exact' qualifier type takes two arguments: low key bit and high
     *  key bit. These arguments are used when generating the RCE code to
     *  provide the data for the instructions needed.
     */
    if (qual->paramCount != 2) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("exact qualifier accepts exactly two parameters,"
                   " %d parameters provided\n"),
                   qual->paramCount));
        return SOC_E_PARAM;
    }
    if (qual->param[0] > qual->param[1]) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("exact qualifier requires first bit %d be <= last"
                   " bit %d\n"),
                   qual->param[0],
                   qual->param[1]));
        return SOC_E_PARAM;
    }
    if ((SOC_C3_RCE_KEY_BIT_MINIMUM > qual->param[0]) ||
        (SOC_C3_RCE_KEY_BIT_MAXIMUM < qual->param[0]) ||
        (SOC_C3_RCE_KEY_BIT_MINIMUM > qual->param[1]) ||
        (SOC_C3_RCE_KEY_BIT_MAXIMUM < qual->param[1])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("key bits are 0..511; specified range is %d..%d\n"),
                   qual->param[0],
                   qual->param[1]));
        return SOC_E_PARAM;
    }
    /*
     *  Exact matching uses one 'data' instruction for each bit to match.
     *  There is no masking; all bits are significant.
     */
    count = (qual->param[1] - qual->param[0]) + 1;
    *instrCount = count;
    if (instr) {
        /* caller provided a buffer for the instructions, specify them */
        for (index = 0, bit = qual->param[0]; index < count; index++) {
            bitData = 1 << (bit & 15);
            bitMask = ~bitData;
            COMPILER_64_SET(instr[index],
                            ((_c3RCEOpcode_data << 8) |
                             (_c3RCEPredicate_MaskOr << 5) |
                             (bit >> 4)),
                            (bitData << 16) | bitMask);
            bit++;
        } /* for (each bit of the qualifier to cover) */
    } /* if (instr) */
    return SOC_E_NONE;
}

/*
 *  Function
 *    _soc_c3_rce_program_build_exact_sparse
 *  Purpose
 *    Builds (or counts) the instructions needed for a specific exact match
 *    qualifier operation against the key.
 *  Arguments
 *    (IN) qual = pointer to the qualifier information
 *    (OUT) instr = pointer to buffer for instructions
 *    (OUT) instrCount = where to put number of instructions
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    If the pointer to the instruction space is NULL, it means that the caller
 *    wants only to know how many instructions will be required.
 *
 *    Exact qualifiers can be aligned arbitrarily within the key.
 *
 *    Exact qualifiers require all bits be significant and matched exactly.
 *
 *    There is no don't care state, so the default value embedded in the
 *    pattern assumes all bits zero.
 *
 *    When updating this and its associated functions, must also update
 *    _soc_c3_rce_wb_program_recover_general and its associated functions.
 */
static int
_soc_c3_rce_program_build_exact_sparse(const _soc_c3_rce_qual_desc_int_t *qual,
                                       _soc_c3_rce_instruction_t *instr,
                                       unsigned int *instrCount)
{
    unsigned int index;
    unsigned int count;
    unsigned int bit;
    uint16 bitMask;
    uint16 bitData;
    /*
     *  The 'sparse exact' qualifier type takes a list of bits from the key,
     *  from LSb to MSb.  These arguments are used when generating the RCE code
     *  to provide the data for the instructions needed.
     */
    if (1 > qual->paramCount) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("exact qualifier must be at least 1 bit long\n")));
        return SOC_E_PARAM;
    }
    /*
     *  Exact matching uses one 'data' instruction for each bit to match.
     *  There is no masking; all bits are significant.
     */
    count = qual->paramCount;
    *instrCount = count;
    for (index = 0; index < count; index++) {
        bit = qual->param[index];
        /* coverity[unsigned_compare] */
        if ((SOC_C3_RCE_KEY_BIT_MINIMUM > bit) ||
            (SOC_C3_RCE_KEY_BIT_MAXIMUM < bit)) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("key bits are %d..%d, but got bit %u\n"),
                       SOC_C3_RCE_KEY_BIT_MINIMUM,
                       SOC_C3_RCE_KEY_BIT_MAXIMUM,
                       bit));
            return SOC_E_PARAM;
        }
        if (instr) {
            /* caller provided a buffer for the instructions, specify them */
            bitData = 1 << (bit & 15);
            bitMask = ~bitData;
            COMPILER_64_SET(instr[index],
                            ((_c3RCEOpcode_data << 8) |
                             (_c3RCEPredicate_MaskOr << 5) |
                             (bit >> 4)),
                            (bitData << 16) | bitMask);
        }
    } /* for (each bit of the qualifier to cover) */
    return SOC_E_NONE;
}

/*
 *  Function
 *    _soc_c3_rce_entry_qualify_exact_set
 *  Purpose
 *    Takes data/mask information and builds the pattern data for an exact
 *    qualifier's instructions
 *  Arguments
 *    (IN) qual = pointer to the qualifier information
 *    (IN) data = pointer to the data bits
 *    (IN) mask = pointer to the mask bits
 *    (IN) patternStart = first bit in pattern for this qualifier
 *    (OUT) pattern = pointer to the buffer for pattern bits
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Exact match qualifiers requires all bits to be important, so the mask
 *    must indicate this.
 */
static int
_soc_c3_rce_entry_qualify_exact_set(const _soc_c3_rce_qual_desc_int_t *qual,
                                    const uint8 *data,
                                    const uint8 *mask,
                                    unsigned int patternStart,
                                    uint8 *pattern)
{
    unsigned int index;
    unsigned int pattIndex;
    unsigned int count;
    /*
     *  Exact matching uses one 'data' instruction for each bit to match.
     *  There is no masking; all bits are significant.
     */
    if (socC3RCEQualType_exact == qual->qualType) {
        count = (qual->param[1] - qual->param[0]) + 1;
    } else if (socC3RCEQualType_exact_sparse == qual->qualType) {
        count = qual->paramCount;
    } else {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("exact qualifier set only understands exact"
                   " type qualifiers, not %d\n"),
                   qual->qualType));
        return SOC_E_PARAM;
    }
    for (index = 0; index < count; index++) {
        if (0 == (mask[index >> 3] & (1 << (index & 7)))) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("exact qualifier does not support bits that"
                       " are not compared (such as bit %u)\n"),
                       index));
            return SOC_E_PARAM;
        }
    }
    /* Build the pattern specifying all bits */
    for (index = 0, pattIndex = patternStart;
         index < count;
         index++, pattIndex++) {
        if (data[index >> 3] & (1 << (index & 7))) {
            /* this bit must be one */
            pattern[pattIndex >> 3] |= (1 << (pattIndex & 7));
        } else { /* if (data[index >> 3] & (1 << (index & 7))) */
            /* this bit must be zero */
            pattern[pattIndex >> 3] &= (~(1 << (pattIndex & 7)));
        } /* if (key bit must be zero) */
    } /* for (index = 0; index < count; index++) */
    return SOC_E_NONE;
}

/*
 *  Function
 *    _soc_c3_rce_entry_qualify_exact_get
 *  Purpose
 *    Takes data/mask information and get the pattern data for an exact
 *    qualifier's instructions
 *  Arguments
 *    (IN) qual = pointer to the qualifier information
 *    (IN) patternStart = first bit in pattern for this qualifier
 *    (IN) pattern = pointer to the buffer for pattern bits
 *    (OUT) data = pointer to the data bits
 *    (OUT) mask = pointer to the mask bits
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 */
static int
_soc_c3_rce_entry_qualify_exact_get(const _soc_c3_rce_qual_desc_int_t *qual,
                                    unsigned int patternStart,
                                    const uint8 *pattern,
                                    uint8 *data,
                                    uint8 *mask)
{
    unsigned int index;
    unsigned int pattIndex;
    unsigned int count;
    int result = SOC_E_NONE;
    /*
     *  Exact matching uses one 'data' instruction for each bit to match.
     *  There is no masking; all bits are significant.
     */
    if (socC3RCEQualType_exact == qual->qualType) {
        count = (qual->param[1] - qual->param[0]) + 1;
    } else if (socC3RCEQualType_exact_sparse == qual->qualType) {
        count = qual->paramCount;
    } else {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("exact qualifier set only understands exact"
                   " type qualifiers, not %d\n"),
                   qual->qualType));
        return SOC_E_PARAM;
    }
    for (index = 0; index < ((count + 7) >> 3); index++) {
        data[index] = 0;
        mask[index] = 0;
    }
    for (index = 0, pattIndex = patternStart;
         index < count;
         index++, pattIndex++) {
        mask[index >> 3] |= (1 << (index & 7));
        if (pattern[pattIndex >> 3] & (1 << (pattIndex & 7))) {
            data[index >> 3] |= (1 << (index & 7));
        } /* if (pattern[index >> 3] & (1 << (index & 7))) */
        /*
         *  There is no else to the above if statement because we already
         *  cleared data, so the bit would be set to zero, and we already set
         *  the mask bit unconditionally.
         */
    } /* for (index = 0; index < count; index++) */
    return result;
}


/*
 *  Function
 *    _soc_c3_rce_program_build_general
 *  Purpose
 *    Builds (or counts) the instructions needed for a particular qualifier.
 *  Arguments
 *    (IN) qual = pointer to the qualifier information
 *    (OUT) instr = pointer to buffer for instructions
 *    (OUT) instrCount = where to put number of instructions
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    If the pointer to the instruction space is NULL, it means that the caller
 *    wants only to know how many instructions will be required.
 *
 *    Embeds the values needed for the don't care state for this qualifier into
 *    the high bit of the opcodes.
 *
 *    When updating this and its associated functions, must also update
 *    _soc_c3_rce_wb_program_recover_general and its associated functions.
 */
static int
_soc_c3_rce_program_build_general(const _soc_c3_rce_qual_desc_int_t *qual,
                                  _soc_c3_rce_instruction_t *instr,
                                  unsigned int *instrCount)
{
    switch (qual->qualType) {
    case socC3RCEQualType_prefix:
        return _soc_c3_rce_program_build_prefix(qual, instr, instrCount);
    case socC3RCEQualType_prefix_sparse:
        return _soc_c3_rce_program_build_prefix_sparse(qual,
                                                       instr,
                                                       instrCount);
    case socC3RCEQualType_postfix:
        return _soc_c3_rce_program_build_postfix(qual, instr, instrCount);
    case socC3RCEQualType_postfix_sparse:
        return _soc_c3_rce_program_build_postfix_sparse(qual,
                                                        instr,
                                                        instrCount);
    case socC3RCEQualType_masked:
        return _soc_c3_rce_program_build_masked(qual, instr, instrCount);
    case socC3RCEQualType_masked_sparse:
        return _soc_c3_rce_program_build_masked_sparse(qual,
                                                       instr,
                                                       instrCount);
    case socC3RCEQualType_exact:
        return _soc_c3_rce_program_build_exact(qual, instr, instrCount);
    case socC3RCEQualType_exact_sparse:
        return _soc_c3_rce_program_build_exact_sparse(qual,
                                                      instr,
                                                      instrCount);
    default:
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("invalid qualifier type %d\n"),
                   qual->qualType));
        return SOC_E_PARAM;
    } /* switch (qual->qualType) */
}

/*
 *  Function
 *    _soc_c3_rce_entry_qualify_general_set
 *  Purpose
 *    Takes data/mask information and builds the pattern data for a specified
 *    qualifier's instructions
 *  Arguments
 *    (IN) qual = pointer to the qualifier information
 *    (IN) data = pointer to the data bits
 *    (IN) mask = pointer to the mask bits
 *    (IN) patternStart = first bit in pattern for this qualifier
 *    (OUT) pattern = pointer to the buffer for pattern bits
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 */
static int
_soc_c3_rce_entry_qualify_general_set(const _soc_c3_rce_qual_desc_int_t *qual,
                                      const uint8 *data,
                                      const uint8 *mask,
                                      unsigned int patternStart,
                                      uint8 *pattern)
{
    switch (qual->qualType) {
    case socC3RCEQualType_prefix:
    case socC3RCEQualType_prefix_sparse:
        return _soc_c3_rce_entry_qualify_prefix_set(qual,
                                                    data,
                                                    mask,
                                                    patternStart,
                                                    pattern);
    case socC3RCEQualType_postfix:
    case socC3RCEQualType_postfix_sparse:
        return _soc_c3_rce_entry_qualify_postfix_set(qual,
                                                     data,
                                                     mask,
                                                     patternStart,
                                                     pattern);
    case socC3RCEQualType_masked:
    case socC3RCEQualType_masked_sparse:
        return _soc_c3_rce_entry_qualify_masked_set(qual,
                                                    data,
                                                    mask,
                                                    patternStart,
                                                    pattern);
    case socC3RCEQualType_exact:
    case socC3RCEQualType_exact_sparse:
        return _soc_c3_rce_entry_qualify_exact_set(qual,
                                                   data,
                                                   mask,
                                                   patternStart,
                                                   pattern);
    default:
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("invalid qualifier type %d\n"),
                   qual->qualType));
        return SOC_E_PARAM;
    } /* switch (qual->qualType) */
}

/*
 *  Function
 *    _soc_c3_rce_entry_qualify_general_get
 *  Purpose
 *    Takes data/mask information and gets the pattern data for a specified
 *    qualifier's instructions
 *  Arguments
 *    (IN) qual = pointer to the qualifier information
 *    (IN) patternStart = first bit in pattern for this qualifier
 *    (IN) pattern = pointer to the buffer for pattern bits
 *    (OUT) data = pointer to the data bits
 *    (OUT) mask = pointer to the mask bits
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 */
static int
_soc_c3_rce_entry_qualify_general_get(const _soc_c3_rce_qual_desc_int_t *qual,
                                      unsigned int patternStart,
                                      const uint8 *pattern,
                                      uint8 *data,
                                      uint8 *mask)
{
    switch (qual->qualType) {
    case socC3RCEQualType_prefix:
    case socC3RCEQualType_prefix_sparse:
        return _soc_c3_rce_entry_qualify_prefix_get(qual,
                                                    patternStart,
                                                    pattern,
                                                    data,
                                                    mask);
    case socC3RCEQualType_postfix:
    case socC3RCEQualType_postfix_sparse:
        return _soc_c3_rce_entry_qualify_postfix_get(qual,
                                                     patternStart,
                                                     pattern,
                                                     data,
                                                     mask);
    case socC3RCEQualType_masked:
    case socC3RCEQualType_masked_sparse:
        return _soc_c3_rce_entry_qualify_masked_get(qual,
                                                    patternStart,
                                                    pattern,
                                                    data,
                                                    mask);
    case socC3RCEQualType_exact:
    case socC3RCEQualType_exact_sparse:
        return _soc_c3_rce_entry_qualify_exact_get(qual,
                                                   patternStart,
                                                   pattern,
                                                   data,
                                                   mask);
    default:
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("invalid qualifier type %d\n"),
                   qual->qualType));
        return SOC_E_PARAM;
    } /* switch (qual->qualType) */
}

#if defined(BROADCOM_DEBUG)
/*
 *  Function
 *    _soc_c3_rce_entry_qualify_general_length
 *  Purpose
 *    Returns the length of the data/mask for a given qualifier (in bits)
 *  Arguments
 *    (IN) qual = pointer to the qualifier information
 *    (OUT) bits = where to put number of bits
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 */
static int
_soc_c3_rce_entry_qualify_general_length(const _soc_c3_rce_qual_desc_int_t *qual,
                                         unsigned int *bits)
{
    switch (qual->qualType) {
    case socC3RCEQualType_prefix:
    case socC3RCEQualType_postfix:
    case socC3RCEQualType_masked:
    case socC3RCEQualType_exact:
        *bits = (qual->param[1] - qual->param[0]) + 1;
        break;
    case socC3RCEQualType_prefix_sparse:
    case socC3RCEQualType_postfix_sparse:
    case socC3RCEQualType_masked_sparse:
    case socC3RCEQualType_exact_sparse:
        *bits = qual->paramCount;
        break;
    default:
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("invalid qualifier type %d\n"),
                   qual->qualType));
        return SOC_E_PARAM;
    } /* switch (qual->qualType) */
    return SOC_E_NONE;
}
#endif /* defined (BROADCOM_DEBUG) */


/*--------------------------------------------------------------------------
 *
 *  Implementation of various action types and how they are manipulated.
 */

/*
 *  Function
 *    _soc_c3_rce_program_action_bitfield_set
 *  Purpose
 *    Set an action that is represented by a contiguous bitfield
 *  Arguments
 *    (IN) action = pointer to the action information
 *    (IN) data = pointer to the action data to set
 *    (IN) actionStart = first bit in pattern for actions
 *    (OUT) pattern = pointer to the buffer for pattern bits
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 */
static int
_soc_c3_rce_program_action_bitfield_set(const soc_c3_rce_action_desc_t *action,
                                        const uint8 *data,
                                        uint8 *pattern)
{
    unsigned int index;
    unsigned int count;
    unsigned int actIndex;
    /*
     *  bitfield based actions cover a contiguous number of bits, in order from
     *  least significant to most significant, in the action table.
     */
    count = (action->param[1] - action->param[0]) + 1;
    for (index = 0, actIndex = action->param[0];
         index < count;
         index++, actIndex++) {
        if (data[index >> 3] & (1 << (index & 7))) {
            /* this bit is set in the caller's action data */
            pattern[actIndex >> 3] |= (1 << (actIndex & 7));
        } else {
            /* this bit is not set in the caller's action data */
            pattern[actIndex >> 3] &= (~(1 << (actIndex & 7)));
        }
    } /* for (each bit in this action) */
    return SOC_E_NONE;
}

/*
 *  Function
 *    _soc_c3_rce_program_action_bitfield_get
 *  Purpose
 *    Get an action that is represented by a contiguous bitfield
 *  Arguments
 *    (IN) action = pointer to the action information
 *    (IN) actionStart = first bit in pattern for actions
 *    (IN) pattern = pointer to the buffer for pattern bits
 *    (OUT) data = pointer to buffer for the action data
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 */
static int
_soc_c3_rce_program_action_bitfield_get(const soc_c3_rce_action_desc_t *action,
                                        const uint8 *pattern,
                                        uint8 *data)
{
    unsigned int index;
    unsigned int count;
    unsigned int actIndex;
    /*
     *  bitfield based actions cover a contiguous number of bits, in order from
     *  least significant to most significant, in the action table.
     */
    count = (action->param[1] - action->param[0]) + 1;
    for (index = 0, actIndex = action->param[0];
         index < count;
         index++, actIndex++) {
        if (0 == (index & 7)) {
            data[index >> 3] = 0;
        }
        if (pattern[actIndex >> 3] & (1 << (actIndex & 7))) {
            /* this bit is set in the caller's action data */
            data[index >> 3] |= (1 << (index & 7));
        }
        /*
         *  There is no else clause here because we already cleared this byte
         *  and the value we would be writing is zero.
         */
    } /* for (each bit in this action) */
    return SOC_E_NONE;
}

/*
 *  Function
 *    _soc_c3_rce_program_action_general_set
 *  Purpose
 *    Set an action according to the program's information about the action
 *  Arguments
 *    (IN) action = pointer to the action information
 *    (IN) data = pointer to the action data to set
 *    (IN) actionStart = first bit in pattern for actions
 *    (OUT) pattern = pointer to the buffer for pattern bits
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 */
static int
_soc_c3_rce_program_action_general_set(const soc_c3_rce_action_desc_t *action,
                                       const uint8 *data,
                                       uint8 *pattern)
{
    switch (action->actionType) {
    case socC3RCEActionType_bitfield:
        return _soc_c3_rce_program_action_bitfield_set(action,
                                                       data,
                                                       pattern);
    default:
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("invalid action type %d\n"),
                   action->actionType));
        return SOC_E_PARAM;
    } /* switch (action->actionType) */
}

/*
 *  Function
 *    _soc_c3_rce_program_action_general_get
 *  Purpose
 *    Get an action according to the program's information about the action
 *  Arguments
 *    (IN) action = pointer to the action information
 *    (IN) data = pointer to the action data to set
 *    (IN) actionStart = first bit in pattern for actions
 *    (OUT) pattern = pointer to the buffer for pattern bits
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 */
static int
_soc_c3_rce_program_action_general_get(const soc_c3_rce_action_desc_t *action,
                                       const uint8 *pattern,
                                       uint8 *data)
    {
    switch (action->actionType) {
    case socC3RCEActionType_bitfield:
        return _soc_c3_rce_program_action_bitfield_get(action,
                                                       pattern,
                                                       data);
    default:
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("invalid action type %d\n"),
                   action->actionType));
        return SOC_E_PARAM;
    } /* switch (action->actionType) */
}

#if defined(BROADCOM_DEBUG)
/*
 *  Function
 *    _soc_c3_rce_program_action_general_length
 *  Purpose
 *    Returns the length of the data/mask for a given action (in bits)
 *  Arguments
 *    (IN) action = pointer to the action information
 *    (OUT) bits = where to put number of bits
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 */
static int
_soc_c3_rce_program_action_general_length(const soc_c3_rce_action_desc_t *action,
                                          unsigned int *bits)
{
    switch (action->actionType) {
    case socC3RCEActionType_bitfield:
        *bits = (action->param[1] - action->param[0]) + 1;
        break;
    default:
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("invalid action type %d\n"),
                   action->actionType));
        return SOC_E_PARAM;
    } /* switch (qual->qualType) */
    return SOC_E_NONE;
}
#endif /* defined (BROADCOM_DEBUG) */


/*--------------------------------------------------------------------------
 *
 *  Implementation of building data that will be used by the RCE hardware,
 *  or used by the LRP microcode.
 */

/*
 *  Function
 *    _soc_c3_rce_program_scan_key_template
 *  Purpose
 *    Given a key and a group descriptor and a filter set descriptor, build the
 *    key template that would be used for that filter set
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) groupData = pointer to group data
 *    (IN) keyData = pointer to key data (432b, least significant byte first)
 *    (OUT) keyPattern = pointer where to put the pattern from this key
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    This only builds the predicate results for the group template and the
 *    predicate results for the filter set's ranges, based upon the provided
 *    key.  With this done, only the opcodes themselves need to be evaluated
 *    per entry (rather than having to repeat all of these calculations for
 *    each entry in the filter set.
 *
 *    Since each filter set can refer to different ranges, we must do this per
 *    filter set (instead of per group).
 */
static int
_soc_c3_rce_program_scan_key_template(_soc_c3_rce_unit_desc_int_t *unitData,
                                      _soc_c3_rce_group_desc_int_t *groupData,
                                      _soc_c3_rce_filterset_desc_int_t *fsetData,
                                      const uint8 *keyData,
                                      uint8 *keyPattern)
{
    
    uint16 fixedData[5] = { 0x0000, 0x0000, 0x0000, 0x0000, 0x0003 };
    _soc_c3_rce_fset_range_info_t *fsetRangeInfo;
    unsigned int index;
    unsigned int opcode;
    int predOut;
    int result;
    uint16 predTemp;
    uint16 keyBlock;
    uint32 instrHigh;
    uint32 instrLow;

    /* complete the 512 bit space that the RCE sees */
    
    result = soc_reg32_get(unitData->unit,
                           RC_KEYMEM_CONFIGr,
                           REG_PORT_ANY,
                           0 /* register index */,
                           &instrHigh);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to read unit %d key global: %d (%s)\n"),
                   unitData->unit,
                   result,
                   _SHR_ERRMSG(result)));
        return result;
    }
    fixedData[4] |= (soc_reg_field_get(unitData->unit,
                                       RC_KEYMEM_CONFIGr,
                                       instrHigh,
                                       KEY_GLOBALf) << 4);
    /* build the group template part of the pattern */
    if (0 == fsetData->filterIndex) {
        /*
         *  For the first filter set of a group, we build the pattern for the
         *  group template (the common instructions to all filter sets in the
         *  group).  We only need to do this once per group.
         *
         *  We skip the range opcodes while doing this because they will be
         *  NOPs in the group template.  Individual ranges are edited into the
         *  code per filter set according to the range references for the
         *  individual filter sets.
         *
         *  That particular optimisation only applies to having the software
         *  view available.  If reading the instructions from hardware, it
         *  would be proper to process the predicate data for every filter set
         *  instead of trying to gather groups together (and not skip the range
         *  slots since they will also not be clear from pure hardware view).
         */
        sal_memset(keyPattern, 0x00, groupData->instrBlocks);
        keyPattern[0] = 1; /* this key is valid */
        for (index = groupData->rangesPerFilterSet + 1;
             index < groupData->instrCount;
             index++) {
            instrHigh = COMPILER_64_HI(groupData->instr[index]);
            /* first make sure the opcode is one that generates a pattern bit */
            opcode = (instrHigh >> 8) & 7;
            if ((_c3RCEOpcode_nop == opcode) ||
                (_c3RCEOpcode_prefix == opcode)) {
                /* template instruction ignores key; leave key pattern bit 0 */
                continue;
            }
            instrLow = COMPILER_64_LO(groupData->instr[index]);
            predOut = (instrHigh & 0x1F);
            if (predOut < 28) {
                /* doublebyte specifies LRP provided part of key space */
                predOut <<= 1;
                keyBlock = (keyData[predOut] | (keyData[predOut + 1] << 8));
            } else {
                /* doublebyte specifies RCE provided part of key space */
                keyBlock = fixedData[predOut - 28];
            }
            /* now compute the key pattern value based upon the predicate */
            opcode = (instrHigh >> 5) & 3;
            switch (opcode) {
            case _c3RCEPredicate_Range:
                predOut = ((keyBlock >= (instrLow & 0xFFFF)) &&
                           (keyBlock <= ((instrLow >> 16) & 0xFFFF)));
                break;
            case _c3RCEPredicate_Lookup:
                predOut = ((keyBlock >> ((instrLow >> 28) & 0xF)) << 3) & 8;
                predOut |= (((keyBlock >> ((instrLow >> 24) & 0xF)) << 2) & 4);
                predOut |= (((keyBlock >> ((instrLow >> 20) & 0xF)) << 1) & 2);
                predOut |= ((keyBlock >> ((instrLow >> 16) & 0xF)) & 1);
                predOut = (0 != ((instrLow >> predOut) & 1));
                break;
            case _c3RCEPredicate_MaskOr:
                predTemp = ((~(((instrLow >> 16) & 0xFFFF) ^ keyBlock)) &
                            (~(instrLow & 0xFFFF)));
                predOut = (0 != predTemp);
                break;
            case _c3RCEPredicate_MaskAnd:
                predTemp = ((~(((instrLow >> 16) & 0xFFFF) ^ keyBlock)) |
                            (instrLow & 0xFFFF));
                predOut = (0xFFFF == predTemp);
                break;
            /* coverity[dead_error_begin] */
            default:
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("unit %d encountered unexpected predicate %u"
                           " while scanning program %u group %d\n"),
                           unitData->unit,
                           opcode,
                           groupData->rceProgram,
                           groupData->groupId));
                return SOC_E_INTERNAL;
            } /* switch (predicate) */
            if (predOut) {
                keyPattern[index >> 3] |= (1 << (index & 7));
            }
        } /* for (all instructions in this group's template) */
    } else { /* if (0 == fsetData->filterIndex) */
        /* ensure range reference space is cleaned up */
        for (index = 1; index <= groupData->rangesPerFilterSet; index++) {
            keyPattern[index >> 3] &= (~(1 << (index & 7)));
        } /* for (all range slots in this filter set) */
    } /* if (0 == fsetData->filterIndex) */
    /* fill in the range part of the key pattern from the filter set data */
    for (index = 1; index <= groupData->rangesPerFilterSet; index++) {
        fsetRangeInfo = &(fsetData->rangeInfo[index - 1]);
        if (fsetRangeInfo->rangeId) {
            /* this range slot is used by this filter set */
            
            predOut = ((fsetRangeInfo->rangeFlags >>
                        _SOC_C3_RCE_RANGE_FLAG_WORD_SHIFT) & 0x1F);
            if (predOut < 28) {
                /* doublebyte specifies LRP provided part of key space */
                predOut <<= 1;
                keyBlock = (keyData[predOut] | (keyData[predOut + 1] << 8));
            } else {
                /* doublebyte specifies RCE provided part of key space */
                keyBlock = fixedData[predOut - 28];
            }
            predOut = ((keyBlock >= fsetRangeInfo->lowerLimit) &&
                       (keyBlock <= fsetRangeInfo->upperLimit));
            if (predOut) {
                keyPattern[index >> 3] |= (1 << (index & 7));
            }
        } /* if (this range slot is used in this filter set) */
    } /* for (all range slots in filter sets in this group) */
    return SOC_E_NONE;
}

/*
 *  Function
 *    _soc_c3_rce_filter_set_length
 *  Purpose
 *    Determine length of a filter set given its position in the program and
 *    the group's instruction block count.
 *  Arguments
 *    (IN) instrBlocks = group instruction block count
 *    (IN) filterSetIndex = filter set index within the program
 *    (OUT) imemLength = where to put filter set length in imem
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 */
static void
_soc_c3_rce_filter_set_length(unsigned int instrBlocks,
                              unsigned int filterSetIndex,
                              unsigned int *imemLength)
{
    if (filterSetIndex) {
        /* not the first filter set in the program */
        if (instrBlocks < C3_RCE_FILTER_SET_LENGTH_LATER) {
            *imemLength = C3_RCE_FILTER_SET_LENGTH_LATER;
        } else {
            *imemLength = instrBlocks;
        }
    } else {
        /* the first filter set in the program */
        if (instrBlocks < C3_RCE_FILTER_SET_LENGTH_FIRST) {
            *imemLength = C3_RCE_FILTER_SET_LENGTH_FIRST;
        } else {
            *imemLength = instrBlocks;
        }
    } /* if (filterSetIndex) */
}

/*
 *  Function
 *    _soc_c3_rce_program_scan
 *  Purpose
 *    Scan a program, provided a specific key, and return the IDs of entries
 *    that would be hit by that key, based upon the current state.
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) flags = flags
 *    (IN) progId = which program to scan
 *    (IN) keyData = pointer to key data (432b, least significant byte first)
 *    (OUT) hitEntries = pointer to array of space for four entry IDs
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    The 'hitEntries' points to space for four entry IDs (so it is a pointer
 *    to four elements, not just one).  hitEntries[0] will correspond to RCE
 *    result register 0 (LRP crr28), hitEntries[1] to RCE result 1 (LRP crr29),
 *    and so on.
 *
 *    This returns entry ID, not result.  The result value varies between
 *    updates (and can be looked up by entry ID, but not the other way around).
 *    A result register that does not see a hit will be returned negative.
 *
 *    On error, the hitEntries table will have been overwritten and probably
 *    not contain accurate information.
 *
 *    If bit 0 of the flags is set, this scans the cached hardware state.  If
 *    bit 0 of the flags is clear, this scans the API state.
 */
static int
_soc_c3_rce_program_scan(_soc_c3_rce_unit_desc_int_t *unitData,
                         uint32 flags,
                         unsigned int progId,
                         const uint8 *keyData,
                         int *hitEntries)
{
    _soc_c3_rce_program_desc_int_t *progData;
    _soc_c3_rce_filterset_desc_int_t *fsetData;
    _soc_c3_rce_fset_range_info_t *fsetRangeData;
    _soc_c3_rce_group_desc_int_t *groupData;
    _soc_c3_rce_entry_desc_int_t *entryData;
    unsigned int fsetGroup;
    unsigned int fsetProg;
    unsigned int maxTemplateSize;
    unsigned int maxPosition;
    unsigned int index;
    unsigned int patternByte;
    uint32 instrHigh;
    uint8 patternMask;
    uint8 *keyPattern = NULL;
    uint8 *entryPattern;
    int prefixPhase;
    int skipGroup;
    int entryHitSoFar;
    int result = SOC_E_NONE;

    progData = unitData->progData[progId];
    /* prepare allocation up front */
    for (groupData = progData->groupHead, maxTemplateSize = 0;
         groupData;
         groupData = groupData->groupNext) {
        _soc_c3_rce_filter_set_length(groupData->instrBlocks,
                                      0 /* force worst case */,
                                      &index);
        if (index > maxTemplateSize) {
            maxTemplateSize = index;
        }
    }
    keyPattern = sal_alloc(maxTemplateSize,
                            "RCE program scan key template");
    if (!keyPattern) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %u bytes for key work\n"),
                   maxTemplateSize));
        result = SOC_E_MEMORY;
        goto error;
    }
    /* clear result registers */
    for (index = 0; index < SOC_C3_RCE_RESULT_REGISTER_COUNT; index++) {
        hitEntries[index] = -1;
    }
    /* scan the program with the provided key */
    for (groupData = progData->groupHead, fsetProg = 0;
         groupData;
         groupData = groupData->groupNext) {
        /* skip this group if all its results are already filled */
        skipGroup = TRUE;
        for (index = 0; index < SOC_C3_RCE_RESULT_REGISTER_COUNT; index++) {
            if ((groupData->resultLrp & (1 << index)) &&
                (0 > hitEntries[index])) {
                /* group uses a result register that is not filled */
                skipGroup = FALSE;
            }
        }
        /* go through all of the filter sets in the group */
        for (fsetGroup = 0;
             (!skipGroup) && (fsetGroup < groupData->filterSetCount);
             fsetGroup++, fsetProg++) {
            fsetData = &(progData->fsetData[fsetProg]);
            maxPosition = (((fsetData->filterIndex + 1) *
                            C3_RCE_ENTRIES_PER_FILTER_SET));
            result = _soc_c3_rce_program_scan_key_template(unitData,
                                                           groupData,
                                                           fsetData,
                                                           keyData,
                                                           keyPattern);
            if (SOC_E_NONE != result) {
                /* called function displayed diagnostic */
                goto error;
            }
            for (entryData = fsetData->entryHead;
                 (!skipGroup) && entryData &&
                 (entryData->entryPosition < maxPosition);
                 entryData = entryData->entryNext) {
                entryHitSoFar = TRUE;
                entryPattern = entryData->pattData[(flags & 1)];
                if (0 == (entryPattern[0] & 1)) {
                    /* entry is not installed; will not hit */
                    continue;
                }
                /*
                 *  Scan ranges according to filter set configuration.
                 *
                 *  We will only use match0 or match1 instructions in this
                 *  segment, according to the 'invert' flag.  Since other
                 *  instructions (like prefix) are not used, this part is
                 *  simplified a little bit.
                 *
                 *  This optimisation only applies to having the software view;
                 *  if decoding the program from hardware, the range slots
                 *  would not be clear and so would be processed in the same
                 *  way as the rest of the filter set.
                 */
                for (index = 1;
                     entryHitSoFar && (index < groupData->rangesPerFilterSet);
                     index++) {
                    patternMask = 1 << (index & 7);
                    patternByte = index >> 3;
                    if (entryPattern[patternByte] & patternMask) {
                        fsetRangeData = &(fsetData->rangeInfo[index - 1]);
                        /* the entry cares about this range */
                        if ((0 == (fsetRangeData->rangeFlags &
                                   _SOC_C3_RCE_RANGE_FLAG_MATCH_INVERTED)) &&
                            (0 == (keyPattern[patternByte] & patternMask))) {
                            /* entry matches on one; this is zero */
                            entryHitSoFar = FALSE;
                        } else  if ((fsetRangeData->rangeFlags &
                                     _SOC_C3_RCE_RANGE_FLAG_MATCH_INVERTED) &&
                                    (keyPattern[patternByte] & patternMask)) {
                            /* entry matches on zero; this is one */
                            entryHitSoFar = FALSE;
                        }
                    } /* if (entry cares about this range) */
                } /* for (filter set range instructions) */
                /*
                 *  The rest of this runs according to the group template, and
                 *  all opcodes are allowed there, so we need to handle them
                 *  directly and deal with the addiitonal prefix behaivour.
                 *
                 *  This starts with the instruction after the last range slot.
                 *
                 *  If processing without software context, this would start at
                 *  instruction 0 of the filter set (to obtain the location of
                 *  the next filter set) and then run for the whole filter set,
                 *  checking the end flag appropriately.  We know where the
                 *  template ends here, and where to look for the next filter
                 *  set (without parsing the start instruction) because we have
                 *  the software context.
                 */
                for (index = groupData->rangesPerFilterSet + 1,
                     prefixPhase = 0;
                     entryHitSoFar && (index < groupData->instrCount);
                     index++) {
                    patternMask = 1 << (index & 7);
                    patternByte = index >> 3;
                    if (2 == prefixPhase) {
                        /* in masked mode; instruction gets ignored */
                        if (0 == (entryPattern[patternByte] & patternMask)) {
                            /* entry pattern says to leave masked mode */
                            prefixPhase = 1;
                        }
                    } else { /* if (2 == prefixPhase) */
                        /* not in masked mode; use instruction to test */
                        instrHigh = COMPILER_64_HI(groupData->instr[index]);
                        switch ((instrHigh >> 8) & 7) {
                        case _c3RCEOpcode_prefix:
                        case _c3RCEOpcode_nop:
                            /* no comparison made */
                            break;
                        case _c3RCEOpcode_data:
                            if ((entryPattern[patternByte] & patternMask) !=
                                (keyPattern[patternByte] & patternMask)) {
                                /* entry and key pattern do not match */
                                entryHitSoFar = FALSE;
                            }
                            break;
                        case _c3RCEOpcode_match0:
                            if ((entryPattern[patternByte] & patternMask) &&
                                (0 != (keyPattern[patternByte] &
                                       patternMask))) {
                                /* entry wants key pattern zero; it is one */
                                entryHitSoFar = FALSE;
                            }
                            break;
                        case _c3RCEOpcode_match1:
                            if ((entryPattern[patternByte] & patternMask) &&
                                (0 == (keyPattern[patternByte] &
                                       patternMask))) {
                                /* entry wants key pattern one; it is zero */
                                entryHitSoFar = FALSE;
                            }
                            break;
                        default:
                            /* should never see other opcodes in this part */
                            LOG_ERROR(BSL_LS_SOC_COMMON,
                                      (BSL_META("unexpected opcode %d while"
                                       " scanning unit %d program %u\n"),
                                       (instrHigh >> 8) & 7,
                                       unitData->unit,
                                       progId));
                            result = SOC_E_INTERNAL;
                            goto error;
                        } /* switch (RCE instruction 'opcode' field) */
                        if (1 == prefixPhase) {
                            /*
                             *  Hardware issue coming out of prefix mode: can't
                             *  jump right back into prefix mode; must have at
                             *  least one out-of-masked-mode instruction first.
                             */
                            prefixPhase--;
                        } else if (0 == prefixPhase) {
                            /*
                             *  Can enter prefix mode as long as not already in
                             *  prefix mode and at least one instruction has
                             *  passed since leaving masked state.
                             */
                            if (_c3RCEOpcode_prefix ==
                                ((instrHigh >> 8) & 7)) {
                                /* enter masked mode for prefix instructions */
                                if (0 == (entryPattern[patternByte] &
                                          patternMask)) {
                                    /* the entire field matters here */
                                    prefixPhase = 1;
                                } else {
                                    /* skipping at least one bit */
                                    prefixPhase = 2;
                                }
                            }
                        }
                    } /* if (2 == prefixPhase) */
                } /* for (group template instructions past ranges) */
                if (entryHitSoFar) {
                    /* this entry was hit */
                    for (index = 0;
                         index < SOC_C3_RCE_RESULT_REGISTER_COUNT;
                         index++) {
                        if ((groupData->resultLrp & (1 << index)) &&
                            (0 > hitEntries[index])) {
                            /*
                             *  The group uses this register and the register
                             *  has not yet been writting with a result.
                             */
                            hitEntries[index] = entryData->entryId;
                        }
                    } /* for (all result registers) */
                    /* we can skip the rest of this group */
                    skipGroup = TRUE;
                } /* if (entryHitSoFar) */
            } /* for (all entries in this filter set) */
        } /* for (all filter sets in this group) */
    } /* for (all groups in the program) */
error:
    if (keyPattern) {
        sal_free(keyPattern);
    }
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_lrp_program_configure
 *  Purpose
 *    Configure the LRP program translation table to enable/disable a
 *    particular RCE program
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) progId = which program to control
 *    (IN) enable = TRUE to enable the program, FALSE to disable
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    If progId is invalid, enable MUST BE FALSE.  In this case, all RCE
 *    programs will be disabled at the LRP program translation table.
 *
 *    Would have used soc_mem_read_range but it fails to actually move data
 *    when addressing the LRB_PROGRAM_TRANSLATIONm memory.  Not sure why.
 */
static int
_soc_c3_rce_lrp_program_configure(_soc_c3_rce_unit_desc_int_t *unitData,
                                  unsigned int progId,
                                  int enable)
{
    uint32 memInfo;
    unsigned int index;
    int prev;
    int result = SOC_E_NONE;

    if (progId < SOC_C3_RCE_PROGRAM_COUNT) {
        /* changing settings for one program */
        for (index = 0;
             index < soc_mem_index_count(unitData->unit,
                                         LRB_PROGRAM_TRANSLATIONm);
             index++) {
            if (unitData->progData[progId]->ucData->tmuProg & (1 << index)) {
                /* this RCE program supports this LRP key index */
                /* read current value of this translation entry */
                result = soc_mem_read(unitData->unit,
                                      LRB_PROGRAM_TRANSLATIONm,
                                      MEM_BLOCK_ANY,
                                      index,
                                      &memInfo);
                if (SOC_E_NONE != result) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META("unable to read unit %d LRP program"
                               " translation memory %u: %d (%s)\n"),
                               unitData->unit,
                               index,
                               result,
                               _SHR_ERRMSG(result)));
                    goto error;
                }
                /* see if the RCE part is already in use */
                if (soc_mem_field32_get(unitData->unit,
                                        LRB_PROGRAM_TRANSLATIONm,
                                        &memInfo,
                                        RCEf)) {
                    prev = soc_mem_field32_get(unitData->unit,
                                               LRB_PROGRAM_TRANSLATIONm,
                                               &memInfo,
                                               RPROGf);
                    if (prev != progId) {
                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                  (BSL_META("unit %d LRP key %u already is using"
                                   " RCE program %d (%s) but program %d"
                                   " (%s) also wants to support it\n"),
                                   unitData->unit,
                                   index,
                                   prev,
                                   unitData->progData[prev]->ucData->programName,
                                   progId,
                                   unitData->progData[progId]->ucData->programName));
                        result = SOC_E_CONFIG;
                        goto error;
                    } /* if (prev != progId) */
                } /* if (this LRP key invokes an RCE program currently) */
                /* adjust the RCE part as requested */
                RCE_EVERB((RCE_MSG1("unit %d lrp key %u %s RCE program %u"
                                    " (%s)\n"),
                           unitData->unit,
                           index,
                           enable?"enable":"disable",
                           progId,
                           unitData->progData[progId]->ucData->programName));
                if (enable) {
                    /* enabling this program */
                    soc_mem_field32_set(unitData->unit,
                                        LRB_PROGRAM_TRANSLATIONm,
                                        &memInfo,
                                        RPROGf,
                                        progId);
                    soc_mem_field32_set(unitData->unit,
                                        LRB_PROGRAM_TRANSLATIONm,
                                        &memInfo,
                                        RCEf,
                                        1);
                } else { /* if (enable) */
                    /* disabling this program */
                    soc_mem_field32_set(unitData->unit,
                                        LRB_PROGRAM_TRANSLATIONm,
                                        &memInfo,
                                        RPROGf,
                                        0);
                    soc_mem_field32_set(unitData->unit,
                                        LRB_PROGRAM_TRANSLATIONm,
                                        &memInfo,
                                        RCEf,
                                        0);
                } /* if (enable) */
                /* write updated value */
                result = soc_mem_write(unitData->unit,
                                       LRB_PROGRAM_TRANSLATIONm,
                                       MEM_BLOCK_ANY,
                                       index,
                                       &memInfo);
                if (SOC_E_NONE != result) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META("unable to write unit %d LRP program"
                               " translation memory %u: %d (%s)\n"),
                               unitData->unit,
                               index,
                               result,
                               _SHR_ERRMSG(result)));
                    goto error;
                }
            } /* if (this RCE program should be called for this LRP key) */
        } /* for (all elements in the program translation memory) */
    } else { /* if (progId < SOC_C3_RCE_PROGRAM_COUNT) */
        if (enable) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("can only enable one program at a time; global"
                       " option only disables programs\n")));
            result = SOC_E_PARAM;
            goto error;
        }
        RCE_EVERB((RCE_MSG1("unit %d disable all LRP keys using RCE\n"),
                   unitData->unit));
        /* disabling all RCE programs */
        for (index = 0;
             index < soc_mem_index_count(unitData->unit,
                                         LRB_PROGRAM_TRANSLATIONm);
             index++) {
            /* read current value of this translation entry */
            result = soc_mem_read(unitData->unit,
                                  LRB_PROGRAM_TRANSLATIONm,
                                  MEM_BLOCK_ANY,
                                  index,
                                  &memInfo);
            if (SOC_E_NONE != result) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("unable to read unit %d LRP program"
                           " translation memory %u: %d (%s)\n"),
                           unitData->unit,
                           index,
                           result,
                           _SHR_ERRMSG(result)));
                goto error;
            }
            /* disable this entry's RCE setting */
            soc_mem_field32_set(unitData->unit,
                                LRB_PROGRAM_TRANSLATIONm,
                                &memInfo,
                                RPROGf,
                                0);
            soc_mem_field32_set(unitData->unit,
                                LRB_PROGRAM_TRANSLATIONm,
                                &memInfo,
                                RCEf,
                                0);
            /* write updated value */
            result = soc_mem_write(unitData->unit,
                                   LRB_PROGRAM_TRANSLATIONm,
                                   MEM_BLOCK_ANY,
                                   index,
                                   &memInfo);
            if (SOC_E_NONE != result) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("unable to write unit %d LRP program"
                           " translation memory %u: %d (%s)\n"),
                           unitData->unit,
                           index,
                           result,
                           _SHR_ERRMSG(result)));
                goto error;
            }
        } /* for (all elements in the program translation memory) */
    } /* if (progId < SOC_C3_RCE_PROGRAM_COUNT) */
error:
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_programs_length_check
 *  Purpose
 *    Verify that the RCE run can complete within the appropriate time.
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) flags = flags bitmap
 *    (IN) progId = program number to adjust
 *    (IN) progAdj = adjustment to apply to program progId
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if all programs could complete
 *      SOC_E_FULL if there would be too little time
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Transient refers to a temporary state, such as adding a new filter set
 *    before removing padding, or adding padding before removing a filter set.
 *    Persistent refers to the state after such an operation.
 *
 *    Transient condition will only be checked if the configuration says it is
 *    to be checked, else it will be allowed to pass even if it does not
 *    complete in an epoch.  This way, we can enforce full compliance to the
 *    line rate (never exceed epoch) or allow glitching (transiently exceed
 *    epoch) to increase flexibility under certain circumstances.
 *
 *    It is also possible to disable the persistent state check, but that is
 *    not advised unless capacity is the primary purpose and line rate does not
 *    matter (probaly at all).
 *
 *    Any invalid value of progId will cause progAdj to be disregarded.
 *
 *    Displays diagnosics for *all* problems encounered, then returns the
 *    result according to the actual result and the configuraion.
 *
 *    If probing, all of the diagnostic messages are reduced to VERB level or
 *    lower, but otherwise errors are emitted as errors.
 */
#define SOC_C3_RCE_PROGRAM_LENGTH_CHECK_TRANSIENT 0x00000001
#define SOC_C3_RCE_PROGRAM_LENGTH_CHECK_PROBE     0x00000002
#define SOC_C3_RCE_PROGRAM_LENGTH_CHECK_PADDING   0x00000004
static int
_soc_c3_rce_program_length_check(_soc_c3_rce_unit_desc_int_t *unitData,
                                 uint32 flags,
                                 unsigned int progId,
                                 signed int progAdj,
                                 unsigned int newPadding)
{
    _soc_c3_rce_program_desc_int_t *progData;
    unsigned int keyTransfer[SOC_C3_RCE_PROGRAM_COUNT][C3_RCE_TIMING_ANALYSIS_ITERATIONS];
    unsigned int programRun[SOC_C3_RCE_PROGRAM_COUNT][C3_RCE_TIMING_ANALYSIS_ITERATIONS];
    unsigned int resultTransfer[SOC_C3_RCE_PROGRAM_COUNT][C3_RCE_TIMING_ANALYSIS_ITERATIONS];
    unsigned int resultComplete[SOC_C3_RCE_PROGRAM_COUNT][C3_RCE_TIMING_ANALYSIS_ITERATIONS];
    unsigned int keyTransferFinal[C3_RCE_TIMING_ANALYSIS_ITERATIONS];
    unsigned int programRunFinal[C3_RCE_TIMING_ANALYSIS_ITERATIONS];
    unsigned int resultTransferFinal[C3_RCE_TIMING_ANALYSIS_ITERATIONS];
    int epochFail[SOC_C3_RCE_PROGRAM_COUNT][C3_RCE_TIMING_ANALYSIS_ITERATIONS];
    unsigned int programCount;
    unsigned int cycle;
    unsigned int program;
    unsigned int programId;
    unsigned int epochTime;
    unsigned int temp;
    int result = SOC_E_NONE;
#if (!C3_RCE_TIMING_FULL_DIAGNOSTICS)
    int error = FALSE;
#endif /* (!C3_RCE_TIMING_FULL_DIAGNOSTICS) */

    /* basic sanity checks */
    for (programId = 0, epochTime = 0, program = 0, temp = 0;
         programId < SOC_C3_RCE_PROGRAM_COUNT;
         programId++) {
        if (unitData->progOrder[programId] > SOC_C3_RCE_PROGRAM_COUNT) {
            /* done with all the active programs */
            break;
        }
        /* get this program's data */
        progData = unitData->progData[unitData->progOrder[programId]];
        /* accumulate this as another program */
        if (++program < SOC_C3_RCE_PROGRAM_COUNT) {
            /* consider this program's key transfer time */
            temp += 128;
            /* consider this program's run time plus launch latency */
            if ((progId == unitData->progOrder[program]) &&
                (flags & SOC_C3_RCE_PROGRAM_LENGTH_CHECK_PADDING)) {
                epochTime += progData->instrBlockCount + newPadding + 1;
            } else {
                epochTime += progData->instrBlockCount + progData->instrBlockAdded + 1;
            }
            if (progId == unitData->progOrder[program]) {
                /* adjust this program */
                epochTime += progAdj;
            }
        }
    }
    /* check total key transfer time */
    temp = ((temp * unitData->rceClockDivide) +
            (unitData->rceClockDivide - 1));
    if (temp > (unitData->epochTime + C3_RCE_TIMING_SLACK)) {
#if defined(BROADCOM_DEBUG)
        if ((flags & SOC_C3_RCE_PROGRAM_LENGTH_CHECK_PROBE)
#if (!C3_RCE_TIMING_FULL_DIAGNOSTICS)
             || error
#endif /* (!C3_RCE_TIMING_FULL_DIAGNOSTICS) */
            ) {
            LOG_DEBUG(BSL_LS_SOC_COMMON,
                      (BSL_META("unit %d epoch time %u too short to complete"
                       " key transfer for %u programs (needs %u)\n"),
                       unitData ->unit,
                       unitData->epochTime,
                       program,
                       temp));
        } else {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unit %d epoch time %u too short to complete"
                       " key transfer for %u programs (needs %u)\n"),
                       unitData->unit,
                       unitData->epochTime,
                       program,
                       temp));
        }
#endif /* defined(BROADCOM_DEBUG) */
#if (!C3_RCE_TIMING_FULL_DIAGNOSTICS)
        error = TRUE;
#endif /* (!C3_RCE_TIMING_FULL_DIAGNOSTICS) */
        result = SOC_E_FULL;
    }
    /* check total program run time */
    epochTime = ((epochTime * unitData->rceClockDivide) +
                 (unitData->rceClockDivide - 1));
    if (epochTime > (unitData->epochTime + C3_RCE_TIMING_SLACK)) {
#if defined(BROADCOM_DEBUG)
        if ((flags & SOC_C3_RCE_PROGRAM_LENGTH_CHECK_PROBE)
#if (!C3_RCE_TIMING_FULL_DIAGNOSTICS)
             || error
#endif /* (!C3_RCE_TIMING_FULL_DIAGNOSTICS) */
            ) {
            LOG_DEBUG(BSL_LS_SOC_COMMON,
                      (BSL_META("unit %d epoch time %u too short to complete"
                       " run of all %u programs (needs %u)\n"),
                       unitData->unit,
                       unitData->epochTime,
                       program,
                       epochTime));
        } else {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unit %d epoch time %u too short to complete"
                       " run of all %u programs (needs %u)\n"),
                       unitData->unit,
                       unitData->epochTime,
                       program,
                       epochTime));
        }
#endif /* defined(BROADCOM_DEBUG) */
#if (!C3_RCE_TIMING_FULL_DIAGNOSTICS)
        error = TRUE;
#endif /* (!C3_RCE_TIMING_FULL_DIAGNOSTICS) */
        result = SOC_E_FULL;
    }
    /*
     *  We don't bother with result transfer total because it, like key
     *  transfer time, is fixed per program, and it is shorter than the key
     *  transfer time, so if that fits, so will result transfer, and if the
     *  result transfer does not fit, neither will the key transfer.  Also, the
     *  result transfer complete is the important checkpoint below, where we
     *  verify that the entire process from key submission to result transfer
     *  completes in time for the LRP switch instruction.
     */
    /* run through some cycles of planning */
    keyTransferFinal[0] = 0;
    programRunFinal[0] = 0;
    resultTransferFinal[0] = 0;
    epochTime = 0;
    programCount = 0;
    for (cycle = 0; cycle < C3_RCE_TIMING_ANALYSIS_ITERATIONS; cycle++) {
        /* place all active programs */
        for (program = 0; program < SOC_C3_RCE_PROGRAM_COUNT; program++) {
            epochFail[program][cycle] = FALSE;
            /* get the ID of the current program in the execution list */
            programId = unitData->progOrder[program];
            if (SOC_C3_RCE_PROGRAM_COUNT <= programId) {
                /* no more programs to place in this epoch */
                break;
            }
            if (!cycle) {
                programCount++;
            } else {
                if (0 == programCount) {
                    /*
                     *  This condition is fatal because nothing else can be
                     *  done and there is no point in trying to analyse timing
                     *  with zero programs in the epoch.
                     */
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META("unit %d configuration invalid:"
                               " no active programs\n"),
                               unitData->unit));
                    return SOC_E_INTERNAL;
                }
            }
            /* get this program's information */
            progData = unitData->progData[programId];
            /*
             *  Place the beginning of the key transfer.  While the key
             *  instruction is in the LRP domain, this is in the RCE domain so
             *  it must be slipped to the next RCE clock if it starts late.
             */
            temp = ((progData->keyTime +
                     epochTime +
                     (unitData->rceClockDivide - 1)) /
                    unitData->rceClockDivide) * unitData->rceClockDivide;
            keyTransfer[program][cycle] = temp;
            /* ensure it starts after previous one finishes */
            if (keyTransfer[program][cycle] < keyTransferFinal[cycle]) {
                keyTransfer[program][cycle] = keyTransferFinal[cycle];
            }
            RCE_EVERB((RCE_MSG1("unit %d epoch %u program %u key transfer"
                                " start at global clock %u (%u)\n"),
                       unitData->unit,
                       cycle,
                       programId,
                       keyTransfer[program][cycle] - epochTime,
                       keyTransfer[program][cycle]));
            /* keep track of earliest point for next key transfer start */
            keyTransferFinal[cycle] = (keyTransfer[program][cycle] +
                                       (128 * unitData->rceClockDivide));
            if (program > 0) {
                /* make sure this key starts after previous finishes */
                
                if (keyTransfer[program][cycle] <=
                    (keyTransfer[program - 1][cycle] +
                     (unitData->rceClockDivide * C3_RCE_KEY_TRANSFER_SHADOW))) {
#if defined(BROADCOM_DEBUG)
                    if ((flags & SOC_C3_RCE_PROGRAM_LENGTH_CHECK_PROBE)
#if (!C3_RCE_TIMING_FULL_DIAGNOSTICS)
                         || error
#endif /* (!C3_RCE_TIMING_FULL_DIAGNOSTICS) */
                        ) {
                        LOG_DEBUG(BSL_LS_SOC_COMMON,
                                  (BSL_META("unit %d epoch %u program %u key"
                                   " transfer starts at global clock"
                                   " %u, before previous program %u"
                                   " key transfer has finished at"
                                   " global clock %u\n"),
                                   unitData->unit,
                                   cycle,
                                   programId,
                                   keyTransfer[program][cycle],
                                   unitData->progOrder[program - 1],
                                   keyTransfer[program - 1][cycle] +
                                   (unitData->rceClockDivide *
                                   C3_RCE_KEY_TRANSFER_SHADOW)));
                    } else {
                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                  (BSL_META("unit %d epoch %u program %u key"
                                   " transfer starts at global clock"
                                   " %u, before previous program %u"
                                   " key transfer has finished at"
                                   " global clock %u\n"),
                                   unitData->unit,
                                   cycle,
                                   programId,
                                   keyTransfer[program][cycle],
                                   unitData->progOrder[program - 1],
                                   keyTransfer[program - 1][cycle] +
                                   (unitData->rceClockDivide *
                                   C3_RCE_KEY_TRANSFER_SHADOW)));
                    }
#endif /* defined(BROADCOM_DEBUG) */
#if (!C3_RCE_TIMING_FULL_DIAGNOSTICS)
                    error = TRUE;
#endif /* (!C3_RCE_TIMING_FULL_DIAGNOSTICS) */
                    epochFail[program][cycle] = TRUE;
                    result = SOC_E_CONFIG;
                } /* if (this key starts before previous key finishes) */
            } else if (cycle > 0) {
                if (keyTransfer[program][cycle] <=
                    (keyTransfer[programCount - 1][cycle - 1] +
                     (unitData->rceClockDivide *
                      C3_RCE_KEY_TRANSFER_SHADOW))) {
#if defined(BROADCOM_DEBUG)
                    if ((flags & SOC_C3_RCE_PROGRAM_LENGTH_CHECK_PROBE)
#if (!C3_RCE_TIMING_FULL_DIAGNOSTICS)
                         || error
#endif /* (!C3_RCE_TIMING_FULL_DIAGNOSTICS) */
                        ) {
                        LOG_DEBUG(BSL_LS_SOC_COMMON,
                                  (BSL_META("unit %d epoch %u program %u key"
                                   " transfer starts at global clock"
                                   " %u, before previous program %u"
                                   " key transfer has finished at"
                                   " global clock %u\n"),
                                   unitData->unit,
                                   cycle,
                                   programId,
                                   keyTransfer[program][cycle],
                                   unitData->progOrder[programCount - 1],
                                   keyTransfer[programCount - 1][cycle - 1] +
                                   (unitData->rceClockDivide *
                                   C3_RCE_KEY_TRANSFER_SHADOW)));
                    } else {
                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                  (BSL_META("unit %d epoch %u program %u key"
                                   " transfer starts at global clock"
                                   " %u, before previous program %u"
                                   " key transfer has finished at"
                                   " global clock %u\n"),
                                   unitData->unit,
                                   cycle,
                                   programId,
                                   keyTransfer[program][cycle],
                                   unitData->progOrder[programCount - 1],
                                   keyTransfer[programCount - 1][cycle - 1] +
                                   (unitData->rceClockDivide *
                                   C3_RCE_KEY_TRANSFER_SHADOW)));
                    }
#endif /* defined(BROADCOM_DEBUG) */
#if (!C3_RCE_TIMING_FULL_DIAGNOSTICS)
                    error = TRUE;
#endif /* (!C3_RCE_TIMING_FULL_DIAGNOSTICS) */
                    epochFail[program][cycle] = TRUE;
                    result = SOC_E_CONFIG;
                } /* if (this key starts before previous key finishes) */
            }
            /*
             *  Place the beginning of the program run, still aligned to RCE
             *  clock cycle.  There is a one RCE clock launch latency.
             */
            programRun[program][cycle] = keyTransferFinal[cycle];
            /* ensure it is after the previous one finishes */
            if (programRun[program][cycle] < programRunFinal[cycle]) {
                programRun[program][cycle] = programRunFinal[cycle];
            }
            /* adjust for the one RCE cycle launch latency */
            programRun[program][cycle] += unitData->rceClockDivide;
            RCE_EVERB((RCE_MSG1("unit %d epoch %u program %u run start"
                                " at global clock %u (%u)\n"),
                       unitData->unit,
                       cycle,
                       programId,
                       programRun[program][cycle] - epochTime,
                       programRun[program][cycle]));
            /* ensure next program run occurs after this one is done */
            if ((progId == programId) &&
                (flags & SOC_C3_RCE_PROGRAM_LENGTH_CHECK_PADDING)) {
                temp = progData->instrBlockCount + newPadding + 1;
            } else {
                temp = (progData->instrBlockCount +
                        progData->instrBlockAdded + 1);
            }
            if (progId == programId) {
                temp += progAdj;
            }
            temp *= unitData->rceClockDivide;
            programRunFinal[cycle] = programRun[program][cycle] + temp;
            /*
             *  Place the results tranfser.  This is over in the LRP domain, so
             *  we need to slip to the next LRP clock if they are not aligned
             *  at this point.
             */
            temp = ((programRunFinal[cycle] +
                     (unitData->lrpClockDivide - 1)) /
                    unitData->lrpClockDivide) * unitData->lrpClockDivide;
            resultTransfer[program][cycle] = temp;
            /* ensure it starts after the last result transfer finishes */
            if (resultTransfer[program][cycle] < resultTransferFinal[cycle]) {
                resultTransfer[program][cycle] = resultTransferFinal[cycle];
            }
            RCE_EVERB((RCE_MSG1("unit %d epoch %u program %u result transfer"
                                " start at global clock %u (%u)\n"),
                       unitData->unit,
                       cycle,
                       programId,
                       resultTransfer[program][cycle] - epochTime,
                       resultTransfer[program][cycle]));
            /* ensure next result transfer occurs after this one is done */
            resultTransferFinal[cycle] = (resultTransfer[program][cycle] +
                                          (187 * unitData->lrpClockDivide));;
            /*
             *  Place the results ready.  Still in the LRP clock domain.
             */
            resultComplete[program][cycle] = resultTransferFinal[cycle];
            RCE_EVERB((RCE_MSG1("unit %d epoch %u program %u result transfer"
                                " complete at global clock %u (%u)\n"),
                       unitData->unit,
                       cycle,
                       programId,
                       resultComplete[program][cycle] - epochTime,
                       resultComplete[program][cycle]));
            if (unitData->unitFlags & SOC_C3_RCE_UNIT_FLAGS_SWITCH2) {
                temp = unitData->epochTime << 1;
            } else {
                temp = unitData->epochTime;
            }
            temp += progData->switchTime + C3_RCE_TIMING_SLACK;
            if ((resultComplete[program][cycle] - epochTime) > temp) {
#if defined(BROADCOM_DEBUG)
                if ((flags & SOC_C3_RCE_PROGRAM_LENGTH_CHECK_PROBE)
#if (!C3_RCE_TIMING_FULL_DIAGNOSTICS)
                     || error
#endif /* (!C3_RCE_TIMING_FULL_DIAGNOSTICS) */
                    ) {
                    LOG_DEBUG(BSL_LS_SOC_COMMON,
                              (BSL_META("unit %d epoch %u program %u result"
                               " transfer complete at %u (%u),"
                               " which is after the results are"
                               " due at %u (%u)\n"),
                               unitData->unit,
                               cycle,
                               programId,
                               resultComplete[program][cycle] - epochTime,
                               resultComplete[program][cycle],
                               temp,
                               temp + epochTime));
                } else {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META("unit %d epoch %u program %u result"
                               " transfer complete at %u (%u),"
                               " which is after the results are"
                               " due at %u (%u)\n"),
                               unitData->unit,
                               cycle,
                               programId,
                               resultComplete[program][cycle] - epochTime,
                               resultComplete[program][cycle],
                               temp,
                               temp + epochTime));
                }
#endif /* defined(BROADCOM_DEBUG) */
#if (!C3_RCE_TIMING_FULL_DIAGNOSTICS)
                error = TRUE;
#endif /* (!C3_RCE_TIMING_FULL_DIAGNOSTICS) */
                epochFail[program][cycle] = TRUE;
                result = SOC_E_FULL;
            }
        } /* for (all programs in the program order list) */
        /*
         *  It is possible that some activity will extend beyond the end of the
         *  epoch, so we need to make sure the next time something starts, it
         *  is after it finishes from this epoch.
         */
        if (cycle < (C3_RCE_TIMING_ANALYSIS_ITERATIONS - 1)) {
            /* set earliest possible starting times for next epoch */
            keyTransferFinal[cycle + 1] = keyTransferFinal[cycle];
            programRunFinal[cycle + 1] = programRunFinal[cycle];
            resultTransferFinal[cycle + 1] = resultTransferFinal[cycle];
        }
        /* adjust epoch baseline */
        epochTime += unitData->epochTime;
    } /* for (iterating over several epochs) */
#if C3_RCE_TIMING_DUMP_RESULTS_TABLE
#if defined(BROADCOM_DEBUG)
    /* dump the results just for quick inspection */
    C3_RCE_TIMING_DUMP_RESULTS((RCE_MSG1("timing results begin (most numbers are common clocks)\n")));
    C3_RCE_TIMING_DUMP_RESULTS((RCE_MSG1("epoch pair is epoch number, first clock in epoch\n")));
    C3_RCE_TIMING_DUMP_RESULTS((RCE_MSG1("other pairs are running clock, clock within this epoch\n")));
    C3_RCE_TIMING_DUMP_RESULTS(("Epoch     Pr Key Trans   Prog Run    Res Trans   Res Ready   Deadline    Fail\n"));
    C3_RCE_TIMING_DUMP_RESULTS(("--------- -- ----------- ----------- ----------- ----------- ----------- ----\n"));
    for (cycle = 0, epochTime = 0;
         cycle < C3_RCE_TIMING_ANALYSIS_ITERATIONS;
         cycle++, epochTime += unitData->epochTime) {
        for (program = 0; program < SOC_C3_RCE_PROGRAM_COUNT; program++) {
            programId = unitData->progOrder[program];
            if (SOC_C3_RCE_PROGRAM_COUNT <= programId) {
                /* no more programs to place in this epoch */
                break;
            }
            progData = unitData->progData[programId];
            if (unitData->unitFlags & SOC_C3_RCE_UNIT_FLAGS_SWITCH2) {
                temp = unitData->epochTime << 1;
            } else {
                temp = unitData->epochTime;
            }
            temp += progData->switchTime + C3_RCE_TIMING_SLACK;
            C3_RCE_TIMING_DUMP_RESULTS(("%2u %6u %2u %6u %4u %6u %4u %6u %4u %6u %4u %6u %4u %s\n",
                                        cycle,
                                        epochTime,
                                        programId,
                                        keyTransfer[program][cycle],
                                        keyTransfer[program][cycle] - epochTime,
                                        programRun[program][cycle],
                                        programRun[program][cycle] - epochTime,
                                        resultTransfer[program][cycle],
                                        resultTransfer[program][cycle] - epochTime,
                                        resultComplete[program][cycle],
                                        resultComplete[program][cycle] - epochTime,
                                        (temp - C3_RCE_TIMING_SLACK) + epochTime,
                                        temp - C3_RCE_TIMING_SLACK,
                                        epochFail[program][cycle]?"FAIL":"----"));
        } /* for (all possible programs) */
        C3_RCE_TIMING_DUMP_RESULTS(("--------- -- ----------- ----------- ----------- ----------- ----------- ----\n"));
    } /* for (several epochs) */
    C3_RCE_TIMING_DUMP_RESULTS(("Epoch     Pr Key Trans   Prog Run    Res Trans   Res Ready   Deadline    Fail\n"));
    C3_RCE_TIMING_DUMP_RESULTS((RCE_MSG1("timing results complete\n")));
    C3_RCE_TIMING_DUMP_RESULTS((RCE_MSG1("%s\n"),
                                (SOC_E_NONE == result)?"okay":"FAIL"));
#endif /* defined(BROADCOM_DEBUG) */
#endif /* C3_RCE_TIMING_DUMP_RESULTS_TABLE */
#if !C3_RCE_TIMING_ENFORCE_PERSISTENT
    if (0 == (flags & SOC_C3_RCE_PROGRAM_LENGTH_CHECK_TRANSIENT)) {
        result = SOC_E_NONE;
    }
#endif /* !C3_RCE_TIMING_ENFORCE_PERSISTENT */
#if !C3_RCE_TIMING_ENFORCE_TRANSIENT
    if (flags & SOC_C3_RCE_PROGRAM_LENGTH_CHECK_TRANSIENT) {
        result = SOC_E_NONE;
    }
#endif /* !C3_RCE_TIMING_ENFORCE_TRANSIENT */
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_filter_set_locate
 *  Purpose
 *    Find the filter set data for a given group+fs in a program.
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) progData = pointer to the program data
 *    (IN) groupId = group ID
 *    (IN) filterSet = filter set (within that group)
 *    (OUT) fsetIndex = where to put filter set index (within program)
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 */
static int
_soc_c3_rce_filter_set_locate(_soc_c3_rce_unit_desc_int_t *unitData,
                              _soc_c3_rce_program_desc_int_t *progData,
                              int groupId,
                              unsigned int filterSet,
                              unsigned int *fsetIndex)
{
    unsigned int filterSetIndex;

    /* find the place in the program where this filter set occurs */
    for (filterSetIndex = 0;
         filterSetIndex < progData->filterSetCount;
         filterSetIndex++) {
        if ((groupId == progData->fsetData[filterSetIndex].groupId) &&
            (filterSet == progData->fsetData[filterSetIndex].filterIndex)) {
            /* found the one we want */
            break;
        }
    }
    if (filterSetIndex < progData->filterSetCount) {
        *fsetIndex = filterSetIndex;
        return SOC_E_NONE;
    } else {
        /* should not have this occur; something severe went wrong */
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to find unit %d group %d set %u\n"),
                   unitData->unit,
                   groupId,
                   filterSet));
        return SOC_E_INTERNAL;
    }
}

#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
/*
 *  Function
 *    _soc_c3_rce_entry_move_counter_update
 *  Purpose
 *    Read and update counters for a set of entries, either before the moved
 *    entries are committed to their new place, or after that commit.
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) fsetData = pointer to filter set data
 *    (IN) filterSetBase = filter set in program
 *    (IN) entryMoves = pointer to move information
 *    (IN) moveCount = number of entries in moved entries list
 *    (OUT) ctrTemp = pointer to counter update workspace
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    The move information is a filter set worth of entryIds, with each entry
 *    ID placed at the point in the filter set that corresponds to that entry.
 *    To indicate a counter that is not to be read, the buffer contains ~0; to
 *    indicate a counter to be read and discarded, another number greater than
 *    the entry limit for the unit.
 *
 *    Intended to be called as part of updating a filter set, so this reads the
 *    phase opposite the currently active phase.  Basically, calling this
 *    before the update will collect the counters from the inactive phase in
 *    preparation for that becoming the active phase, and then calling it again
 *    after the update will collect the counters from the newly inactive phase,
 *    so all of the frames that hit the counters right up to the time of the
 *    switch in the frame flow will be collected.
 *
 *    Returns the last error to occur, but tries to complete its job even if
 *    errors occur.
 *
 *    Caller should check that there are moves and not call if none.
 *
 *    In order to avoid this function, which must be called twice during a
 *    single filter set update, from failing due to OOM or memory
 *    fragmentation or something similar, the caller must provide the working
 *    buffer for the counter updates.  This should limit the failure
 *    possibilities to only problems accessing the hardware.
 */
static int
_soc_c3_rce_entry_move_counter_update(_soc_c3_rce_unit_desc_int_t *unitData,
                                      _soc_c3_rce_program_desc_int_t *progData,
                                      _soc_c3_rce_group_desc_int_t *groupData,
                                      _soc_c3_rce_filterset_desc_int_t *fsetData,
                                      unsigned int *entryMoves,
                                      unsigned int moveCount,
                                      uint64 *ctrTemp,
                                      int priorPhase)
{
    _soc_c3_rce_entry_desc_int_t *entryCurr;    /* working entry pointer */
    _soc_c3_rce_counter_read_f readFunc;        /* counter read function */
    uint64 ctrWork[2];                          /* counter read workspace */
    unsigned int actionBase;                    /* base action index */
    unsigned int actionLimit;                   /* maximum action index */
    unsigned int resultReg;                     /* result register index */
    unsigned int index;                         /* position within the fset */
#if !C3_RCE_ACTION_INDEX_COUNTER_SPAN_ACTIONS
    int needUpdate = TRUE;                      /* indicates update not done */
#endif /* !C3_RCE_ACTION_INDEX_COUNTER_SPAM_ACTIONS */
    int result = SOC_E_NONE;
    int auxRes;

    actionBase = fsetData->amemBlock << 1;
    if (fsetData->fsetFlags & _SOC_C3_RCE_FSET_FLAGS_PHASE) {
        /* read counters from new phase */
        actionBase++;
    }
    if (priorPhase) {
        /* want to read old phase now */
        actionBase ^= 1;
    }
    actionBase *= C3_RCE_ENTRIES_PER_FILTER_SET;
    actionLimit = actionBase + (C3_RCE_ENTRIES_PER_FILTER_SET - 1);
    RCE_EVERB((RCE_MSG1("unit %d update counters for program %u group %d"
                        " filter set %u phase %s (%s) counter block %u"
                        " entries moved %u, %s\n"),
               unitData->unit,
               groupData->rceProgram,
               groupData->groupId,
               fsetData->filterIndex,
               (fsetData->fsetFlags&_SOC_C3_RCE_FSET_FLAGS_PHASE)?"high":"low",
               priorPhase?"invert":"normal",
               actionBase,
               moveCount,
               (moveCount>=C3_RCE_ACTION_INDEX_COUNTER_BLOCK_THRESHOLD)?"block":"single"));
    for (resultReg = 0;
         resultReg < SOC_C3_RCE_RESULT_REGISTER_COUNT;
         resultReg++) {
        if (0 == (groupData->resultLrp & (1 << resultReg))) {
            /* this group does not use this result register */
            continue;
        }
        if (progData->ucData->resTable[resultReg]) {
            /* action table is defined; get counter read function */
            readFunc = progData->ucData->resTable[resultReg]->ctrRead;
        } else {
            /* no action table; ignore this result register */
            readFunc = NULL;
        }
        if (!readFunc) {
            /* no action-indexed counters to read for this result register */
            continue;
        }
        if (moveCount >= C3_RCE_ACTION_INDEX_COUNTER_BLOCK_THRESHOLD) {
            /* do counter reads in bulk */
            auxRes = readFunc(unitData->unit,
                              actionBase + unitData->actData[progData->actIndex[resultReg]]->firstEntryBias,
                              C3_RCE_ENTRIES_PER_FILTER_SET,
                              TRUE /* clear */,
                              ctrTemp);
            if (SOC_E_NONE == auxRes) {
#if !C3_RCE_ACTION_INDEX_COUNTER_SPAN_ACTIONS
                if (needUpdate) {
#endif /* !C3_RCE_ACTION_INDEX_COUNTER_SPAM_ACTIONS */
                    /*
                     *  Unhappily, in bulk mode, we read the entire block of
                     *  counters, so we need to update every affected entry
                     *  instead of only touching the ones specifically listed.
                     *
                     *  We base the decision here on the position before the
                     *  move, since that is where the counter would be.
                     */
                    for (entryCurr = groupData->entryHead;
                         entryCurr;
                         entryCurr = entryCurr->entryNext) {
                        if ((entryCurr->entryPosPrev >= actionBase) &&
                            (entryCurr->entryPosPrev <= actionLimit)) {
                            /* this read needs to update this entry's basis */
                            COMPILER_64_ADD_64(entryCurr->basisCounts[0],
                                               ctrTemp[(entryCurr->entryPosPrev -
                                                        actionBase) << 1]);
                            COMPILER_64_ADD_64(entryCurr->basisCounts[1],
                                               ctrTemp[((entryCurr->entryPosPrev -
                                                         actionBase) << 1) + 1]);
                        } /* if (entry was in this filter set) */
                    } /* for (all entries this group) */
#if !C3_RCE_ACTION_INDEX_COUNTER_SPAN_ACTIONS
                } /* if (needUpdate) */
#endif /* !C3_RCE_ACTION_INDEX_COUNTER_SPAM_ACTIONS */
            } else { /* if (SOC_E_NONE == auxRes) */
                result = auxRes;
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("unit %d unable to read program %u (%s)"
                           " action table %u (%s) counter block %u %s"
                           " (%u..%u): %d (%s)\n"),
                           unitData->unit,
                           groupData->rceProgram,
                           progData->ucData->programName,
                           resultReg,
                           progData->ucData->resTable[resultReg]->tableName,
                           fsetData->amemBlock,
                           (fsetData->fsetFlags&_SOC_C3_RCE_FSET_FLAGS_PHASE)?"high":"low",
                           actionBase,
                           actionBase + C3_RCE_ENTRIES_PER_FILTER_SET - 1,
                           result,
                           _SHR_ERRMSG(result)));
            } /* if (SOC_E_NONE == auxRes) */
        } else { /* if (accessing entry counters in bulk) */
            /* do counter accesses individually */
            for (index = 0;
                 index < C3_RCE_ENTRIES_PER_FILTER_SET;
                 index++) {
                if (entryMoves[index] <= unitData->entryLimit) {
                    /* this counter pair needs to be read & cleared */
                    auxRes = readFunc(unitData->unit,
                                      actionBase + index,
                                      1 /* one counter pair */,
                                      TRUE /* clear */,
                                      ctrWork);
                    if (SOC_E_NONE == auxRes) {
#if !C3_RCE_ACTION_INDEX_COUNTER_SPAN_ACTIONS
                        if (needUpdate) {
#endif /* !C3_RCE_ACTION_INDEX_COUNTER_SPAM_ACTIONS */
                            if (entryMoves[index] < unitData->entryLimit) {
                                /* this read needs to update an entry's basis */
                                entryCurr = unitData->entryData[entryMoves[index]];
                                COMPILER_64_ADD_64(entryCurr->basisCounts[0],
                                                   ctrWork[0]);
                                COMPILER_64_ADD_64(entryCurr->basisCounts[1],
                                                   ctrWork[1]);
                            }
#if !C3_RCE_ACTION_INDEX_COUNTER_SPAN_ACTIONS
                        } /* if (needUpdate) */
#endif /* !C3_RCE_ACTION_INDEX_COUNTER_SPAM_ACTIONS */
                    } else { /* if (SOC_E_NONE == auxRes) */
                        /* report the error */
                        result = auxRes;
                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                  (BSL_META("unit %d unable to read program %u"
                                   " (%s) action table %u (%s) counter"
                                   " pair %u: %d (%s)\n"),
                                   unitData->unit,
                                   groupData->rceProgram,
                                   progData->ucData->programName,
                                   resultReg,
                                   progData->ucData->resTable[resultReg]->tableName,
                                   actionBase + index,
                                   result,
                                   _SHR_ERRMSG(result)));
                        /* but keep going to try to minimise corruption */
                    } /* if (SOC_E_NONE == auxRes) */
                } /* if (entryMoves[patternBAse] <= unitData->entryLimit) */
            } /* for (all counters associated with this filter set) */
        } /* if (accessing entry counters in bulk) */
#if !C3_RCE_ACTION_INDEX_COUNTER_SPAN_ACTIONS
        needUpdate = FALSE;
#endif /* !C3_RCE_ACTION_INDEX_COUNTER_SPAM_ACTIONS */
    } /* for (all result registers) */
    return result;
}
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */

/*
 *  Function
 *    _soc_c3_rce_filter_set_build_instr
 *  Purpose
 *    Builds the instructions for blocks of a filter set
 *  Arguments
 *    (IN) instrCount = number of source instructions
 *    (IN) blkLast = last block to build
 *    (IN) nextFilterAddr = (block zero only) next filter set imem first block
 *    (IN) actionBase = (block zero only) action table index for the filter set
 *    (IN) firstSet = nonzero if initial filter set, otherwise zero
 *    (IN) source = pointer to source instructions
 *    (IN) fsetData = pointer to the filter set information
 *    (OUT) dest = pointer to instruction + pattern blocks
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Must be called before _soc_c3_rce_filter_set_build_patt.
 *
 *    This takes a stream of internal instruction representations and fills in
 *    a DMA buffer with them (after clearing the entire buffer).  This does not
 *    fill in pattern data -- the resulting instructions will have their
 *    pattern data as all zeroes.
 *
 *    dest points to the place where *the requested block(s) will go*. This
 *    means that if the caller requests starting with block 3, dest points to
 *    where this function will place block 3.
 *
 *    It will fill in NOPs past the provided instruction count until it has
 *    filled in the requested instruction blocks (8 instructions per block).
 *    Any instructions in instrEndBlock and later that have an EndF bit will
 *    have this bit set; any instructions before will not.
 *
 *    Assumes caller provides at least one instruction (the start instruction).
 *
 *    nextFilterAddr and actionBase are only used if building the first block
 *    of instructions (specifically, the initial start instruction).
 *
 *    If the filter set information pointer is NULL, this will assume there is
 *    no need to provide ranges.
 */
static int
_soc_c3_rce_filter_set_build_instr(_soc_c3_rce_unit_desc_int_t *unitData,
                                   unsigned int instrCount,
                                   unsigned int blkLast,
                                   unsigned int nextFilterAddr,
                                   unsigned int actionBase,
                                   int firstSet,
                                   _soc_c3_rce_instruction_t *source,
                                   _soc_c3_rce_filterset_desc_int_t *fsetData,
                                   _soc_c3_rce_program_block_t *dest)
{
    _soc_c3_rce_fset_range_info_t *rangeLocal;
    unsigned int rangeLimit;        /* range space upper limit */
    unsigned int blockIndex;        /* index of current working block */
    unsigned int blockProg;         /* block in ProgBlocks buffer */
    unsigned int instrNumber;       /* instruction number in filter set */
    unsigned int bitOffset;         /* instruction bit offset in imem row */
    unsigned int byteOffset;        /* instruction byte offset in imem row */
    unsigned int rowOffset;         /* instruction imem row */
    unsigned int index;             /* generic counter */
    uint64 instrData;               /* working instruction buffer */
    uint64 uuTmp;
    uint32 instrTemp;               /* working partial disassembly buffer */

    if (fsetData) {
        /* provided filter set information; deal with ranges */
        rangeLimit = unitData->groupData[fsetData->groupId]->rangesPerFilterSet;
    } else {
        /* no filter set information; skip range-related work */
        rangeLimit = 0;
    }
    /* clear the output space so we only need to OR bits into place */
    sal_memset(dest, 0x00, (blkLast + 1) * sizeof(*dest));
    /* build instructions and pattern data for the requested blocks */
    for (blockIndex = 0, blockProg = 0;
         blockIndex <= blkLast;
         blockIndex++, blockProg++) {
        for (rowOffset = 0, instrNumber = blockIndex << 3;
             rowOffset < 2;
             rowOffset++) {
            for (bitOffset = 0;
                 bitOffset < 172;
                 bitOffset += 43, instrNumber++) {
                if (0 == instrNumber) {
                    /* special case: first instruction since must be 'start' */
                    COMPILER_64_SET(instrData, 0x00000000,0x0FF00000);
                    COMPILER_64_AND(instrData, source[instrNumber]);
                    COMPILER_64_SET(uuTmp, (nextFilterAddr >> 4) & 0xFF,
                                    ((nextFilterAddr << 28) & 0xF0000000) | (actionBase & 0x000FFFFF));
                    COMPILER_64_OR(instrData, uuTmp);
                    if (firstSet) {
                        /* first filter set this program, use start-program */
                        COMPILER_64_SET(uuTmp, _c3RCEOpcode_startProgram << 8, 0);
                        COMPILER_64_OR(instrData, uuTmp);
                    } else { /* if (firstSet) */
                        /* later filter sets will use start-filter */
                        COMPILER_64_SET(uuTmp,_c3RCEOpcode_startFilter << 8,0);
                        COMPILER_64_OR(instrData,uuTmp);
                    } /* if (firstSet) */
                } else if (instrNumber <= rangeLimit) {
                    /* range space; fill in filter set's ranges */
                    rangeLocal = &(fsetData->rangeInfo[instrNumber - 1]);
                    if (rangeLocal->rangeId) {
                        /* range here; substitute range check opcode */
                        if (rangeLocal->rangeFlags &
                            _SOC_C3_RCE_RANGE_FLAG_MATCH_INVERTED) {
                            /* range needs to be inverted; match if FALSE */
                            COMPILER_64_SET(instrData,
                                            (_c3RCEOpcode_match0 << 8) |
                                            (_c3RCEPredicate_Range << 5),
                                            0);
                        } else {
                            /* range needs to be normal; match if TRUE */
                            COMPILER_64_SET(instrData,
                                            (_c3RCEOpcode_match1 << 8) |
                                            (_c3RCEPredicate_Range << 5),
                                            0);
                        }
                        /* fill in the rest of the range comparison opcode */
                        instrTemp = ((rangeLocal->upperLimit << 16) |
                                     (rangeLocal->lowerLimit));
                        COMPILER_64_SET(uuTmp,
                                        (rangeLocal->rangeFlags >>
                                         _SOC_C3_RCE_RANGE_FLAG_WORD_SHIFT) &
                                        0x1F,
                                        instrTemp);
                        COMPILER_64_OR(instrData,uuTmp);
                    } else { /* if (rangeLocal->rangeId) */
                        /* no range here; use original opcode */
                        instrData = source[instrNumber];
                    } /* if (rangeLocal->rangeId) */
                } else if (instrNumber < instrCount) {
                    /* normal instruction in the provided filter set */
                    instrData = source[instrNumber];
                } else {
                    /* instruction beyond the provided filter set */
                    COMPILER_64_SET(instrData, _c3RCEOpcode_nop << 8, 0);
                }
                /*
                 *  Strip off extra bits for tracking and ensure EndF is not
                 *  set where it should not be.
                 */
                instrTemp = (COMPILER_64_HI(instrData) >> 8) & 7;
                if ((_c3RCEOpcode_startProgram == instrTemp) ||
                    (_c3RCEOpcode_startFilter == instrTemp)) {
                    COMPILER_64_SET(uuTmp, 0x000007FF, 0xFFFFFFFF);
                    COMPILER_64_AND(instrData,uuTmp);
                } else {
                    COMPILER_64_SET(uuTmp, 0x0000077F, 0xFFFFFFFF);
                    COMPILER_64_AND(instrData, uuTmp);
                }
                /* Ensure EndF is set where is should be */
                if (blockIndex >= blkLast) {
                    /* final instruction sequence, mark EndF where we can */
                    if ((_c3RCEOpcode_nop == instrTemp) ||
                        (_c3RCEOpcode_data == instrTemp) ||
                        (_c3RCEOpcode_match0 == instrTemp) ||
                        (_c3RCEOpcode_match1 == instrTemp)) {
                        COMPILER_64_SET(uuTmp, 0x80, 0);
                        COMPILER_64_OR(instrData, uuTmp);
                    } /* if (instruction has EndF field) */
                } /* if (blockIndex >= instrEndBlock) */
#if 0 
                RCE_EVERB((RCE_MSG1("blk %3d/%3d instr %5d opcode %08X%08X\n"),
                                    blockIndex,
                                    blkLast,
                                    instrNumber,
                                    COMPILER_64_HI(instrData),
                                    COMPILER_64_LO(instrData)));
#endif 
                byteOffset = bitOffset >> 3;
                /* adjust the instruction position so it's as expected */
                COMPILER_64_SHL(instrData, bitOffset & 7);
                /* place the instruction into the buffer */
                for (index = 0;
                     !COMPILER_64_IS_ZERO(instrData);
                     index++) {
                    dest[blockProg].
                        instruction[rowOffset]
                        [((byteOffset + index) ^
                          (C3_RCE_DMA_HOST_END_MASK ^
                           C3_RCE_DMA_CHIP_END_MASK_IMEM))] |=
                        COMPILER_64_LO(instrData) & 0xFF;
                    /* shift out this byte */
                    COMPILER_64_SHR(instrData, 8);
                    /* adjust for the fact that the SHR was ASR not LSR */
                    COMPILER_64_SET(uuTmp, 0x00FFFFFF,0xFFFFFFFF);
                    COMPILER_64_AND(instrData, uuTmp);
                } /* for (index = 0; index < 7; index++) */
            } /* for (each instruction in the imem blcok row) */
        } /* for (each row of instructions in the instruction memory block) */
    } /* for (all blocks of the filter set that were requested) */
    return SOC_E_NONE;
}

/*
 *  Function
 *    _soc_c3_rce_filter_set_build_patt
 *  Purpose
 *    Builds the pattern data for blocks of a filter set
 *  Arguments
 *    (IN) unitData = pointer to unit information
 *    (IN) instrCount = number of source instructions
 *    (IN) entryHead = first of this group's entries in the filter set
 *    (IN) entryPosBase = first position value for entries in this set
 *    (IN) entryPosLimit = last position value for entries in this set
 *    (IN) pattOffset = offset in entry pattern/action data for HW pattern
 *    (IN) fsetData = pointer to the filter set information
 *    (OUT) progBlocks = pointer to program blocks for the filter set blocks
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Assumes _soc_c3_rce_filter_set_build_instr was called first.
 *
 *    This fills in the pattern part of the DMA buffer whose instructions part
 *    was filled in by _soc_c3_rce_filter_set_build_blocks_instr.  Similarly,
 *    it will fill in only the pattern data provided by the caller, and any
 *    additional pattern (due to tail padding) is left zeroed.
 *
 *    progBlocks points to the place where *the requested block(s) will go*.
 *    This means that if the caller requests starting with block 3, progBlocks
 *    points to where this function will place block 3.
 *
 *    Assumes caller provides at least one instruction block of pattern data.
 *
 *    If the filter set information pointer is NULL, this will assume there is
 *    no need to provide ranges.
 */
static int
_soc_c3_rce_filter_set_build_patt(_soc_c3_rce_unit_desc_int_t *unitData,
                                  unsigned int instrCount,
                                  _soc_c3_rce_entry_desc_int_t *entryHead,
                                  unsigned int entryPosBase,
                                  unsigned int entryPosLimit,
                                  _soc_c3_rce_filterset_desc_int_t *fsetData,
                                  _soc_c3_rce_program_block_t *progBlocks)
{
    _soc_c3_rce_entry_desc_int_t *entryData; /* working entry pointer */
    _soc_c3_rce_fset_range_info_t *rangeLocal;/* working range information */
    unsigned int *rangeRefs;        /* range references */
    unsigned int rangeCount;        /* number of ranges */
    unsigned int blockLimit;        /* last block in filter set */
    unsigned int blockIndex;        /* index of current working block */
    unsigned int byteOffset;        /* instruction byte offset in imem row */
    unsigned int rowOffset;         /* instruction imem row */
    unsigned int instrOffset;       /* instruction offset */
    unsigned int rangeChkEnd;       /* this iteration range check end */
    unsigned int index;
    uint8 current;
    uint8 mask;

    rangeCount = unitData->groupData[fsetData->groupId]->rangesPerFilterSet;
    rangeRefs = sal_alloc(sizeof(*rangeRefs) * rangeCount,
                          "range reference counter space");
    if (!rangeRefs) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %u bytes for range reference"
                   " count workspace\n"),
                   (unsigned int)(sizeof(*rangeRefs) * rangeCount)));
        return SOC_E_MEMORY;
    }
    sal_memset(rangeRefs, 0x00, sizeof(*rangeRefs) * rangeCount);
    blockLimit = (instrCount + 7) >> 3;
    for (entryData = entryHead;
         entryData && (entryData->entryPosition <= entryPosLimit);
         entryData = entryData->entryNext) {
#if !C3_RCE_INCLUDE_NON_INSTALLED_DATA
        if (entryData->pattData[0][0] & 1) {
#endif /* !C3_RCE_INCLUDE_NON_INSTALLED_DATA */
            /* figure out which byte this entry should fill */
            byteOffset = entryData->entryPosition - entryPosBase;
            rowOffset = byteOffset >> 5;
            byteOffset &= 0x1F;
            byteOffset = byteOffset ^ (C3_RCE_DMA_HOST_END_MASK ^
                                       C3_RCE_DMA_CHIP_END_MASK_IMEM);
            /* copy this entry's pattern to the pattern data blocks */
            for (blockIndex = 0, instrOffset = 0;
                 blockIndex < blockLimit;
                 blockIndex++, instrOffset += 8) {
                current = entryData->pattData[1][blockIndex];
                progBlocks[blockIndex].pattern[rowOffset][byteOffset] = current;
                if (current && (instrOffset <= rangeCount)) {
                    /* in ranges and possibly using one or more this byte */
                    rangeChkEnd = instrOffset + 7;
                    if (rangeChkEnd > rangeCount) {
                        rangeChkEnd = rangeCount;
                    }
                    /* scan valid range slots within this byte */
                    for (index = (instrOffset?instrOffset:1),
                         mask = (instrOffset?1:2);
                         index <= rangeChkEnd;
                         index++, mask <<= 1) {
                        if (current & mask) {
                            rangeRefs[index - 1]++;
                        }
                    } /* for (each range slot in this byte) */
                } /* if ((instrOffset < rangeCount) && current) */
            } /* for (every instruction block in this filter set) */
#if !C3_RCE_INCLUDE_NON_INSTALLED_DATA
        } /* if (entryData->pattData[0][0] & 1) */
#endif /* !C3_RCE_INCLUDE_NON_INSTALLED_DATA */
    } /* for (every entry in this filter set) */
    /* update committed reference counts */
    for (index = 0; index < rangeCount; index++) {
        rangeLocal = &(fsetData->rangeInfo[index]);
        rangeLocal->commitCount = rangeRefs[index];
        if (rangeLocal->rangeId &&
            (0 == rangeRefs[index]) &&
            (0 == rangeLocal->refCount)) {
            /* no API or hardware references; remove range from filter set */
            unitData->rangeData[rangeLocal->rangeId - 1]->refCount--;
            sal_memset(rangeLocal, 0x00, sizeof(*rangeLocal));
        }
    } /* for (all range slots in this filter set) */
    sal_free(rangeRefs);
    return SOC_E_NONE;
}

/*
 *  Function
 *    _soc_c3_rce_filter_set_build_actions
 *  Purpose
 *    Builds the action data for a filter set
 *  Arguments
 *    (IN) entryHead = first of this group's entries in the filter set
 *    (IN) entryPosBase = first position value for entries in this set
 *    (IN) entryPosLimit = last position value for entries in this set
 *    (IN) actOffset = offset in entry pattern/action data for HW action
 *    (IN) actIndex = array of action table index values for the program
 *    (OUT) actBlocks = pointers to buffers for the action blocks
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    This uses the 'hardware copy' of the action.
 *
 *    The action table space for the entire filter set is built here, rather
 *    than some subset.
 *
 *    The actions for a single entry can take up an integral number of memory
 *    elements greater than zero.  There are slots for 768 entries in a filter
 *    set, each one corresponds to either zero entries (no rule) or one entry
 *    (a rule exists).  Actions for entries that do not exist will be zeroed.
 *
 *    If the number of OCM elements per action slot is nonzero, it indicates at
 *    least one entire OCM element is required to hold an action slot.  Also,
 *    the number of OCM elements per action slot must be an integer.
 *
 *    If the number of action slots per OCM element is nonzero, it indicates at
 *    least one action slot will fit into a single OCM element.  Also, the
 *    number of action slots per OCM element must be an integer, and a block of
 *    768 action slots must fill an integral number of OCM elements.
 *
 *    This assumes each OCM address contains 64 bits, and addresses will fall
 *    contiguously in the DMA buffer with no interspersed ECC or similar.
 */
static int
_soc_c3_rce_filter_set_build_actions(_soc_c3_rce_unit_desc_int_t *unitData,
                                     _soc_c3_rce_entry_desc_int_t *entryHead,
                                     unsigned int entryPosBase,
                                     unsigned int entryPosLimit,
                                     const uint8 actIndex[SOC_C3_RCE_RESULT_REGISTER_COUNT],
                                     uint8 *actBlocks[SOC_C3_RCE_PROGRAM_ACTION_MAX][SOC_C3_RCE_MAX_OCM_SEG_PER_ACTION_TABLE])
{
    const _soc_c3_rce_actions_uc_desc_t *ucData; /* microcode act tbl descr */
    const _soc_c3_rce_actions_uc_ocm_desc_t *ucSegment; /* segment description */
    _soc_c3_rce_entry_desc_int_t *entryData;/* working entry information */
    uint8 *actionData;                      /* action data source */
    uint8 *actBlock;                        /* working action block */
    unsigned int elemsPerAction;            /* working elements per action */
    unsigned int actionsPerElem;            /* working actions per element */
    unsigned int bitsPerAction;             /* working bits per action */
    unsigned int byteOrderMask;             /* EOR with offset for byte order */
    unsigned int resReg;                    /* current result register */
    unsigned int ocmOffset;                 /* base address in OCM buffer */
    unsigned int ocmIndex;                  /* offset from base in OCM buffer */
    unsigned int ocmBit;                    /* which bit in OCM buffer */
    unsigned int actBit;                    /* which bit in action buffer */
    unsigned int segment;                   /* current segment */
    unsigned int segOffset;                 /* offset of segment in actions */

    for (resReg = 0; resReg < SOC_C3_RCE_RESULT_REGISTER_COUNT; resReg++) {
        if (actIndex[resReg] > unitData->actTableCount) {
            /* no result table to fill in for this result register */
            continue;
        }
        /* cache this pointer */
        ucData    = unitData->actData[actIndex[resReg]]->ucData;
        segOffset = 0;
        for (segment = 0; segment < ucData->ocmSegments; segment++) {
            if (!actBlocks[resReg][segment]) {
                /* no space for filling in the data for this action table */
                continue;
            }
            /* cache this pointer */
            ucSegment = &(ucData->seg[segment]);

            /* fill in the action data for this result register's table */
            entryData = entryHead;
            byteOrderMask = ucSegment->byteOrderMask;
            actBlock = actBlocks[resReg][segment];
            if (ucSegment->elemsPerAction) {
                /*
                 *  At least one OCM element is required to represent each action
                 *  slot.  This is also supported to allow more complex actions,
                 *  but it also allows us to make some performance improving
                 *  assumptions (like an integral number of bytes)
                 */
                elemsPerAction = ucSegment->elemsPerAction << 3;
                bitsPerAction = (ucSegment->bitsPerAction) >> 3;
                /* copy each entry's hardware actions */
                for (/* init already done */;
                     entryData && (entryData->entryPosition <= entryPosLimit);
                     entryData = entryData->entryNext) {
#if !C3_RCE_INCLUDE_NON_INSTALLED_DATA
                    if (entryData->pattData[0][0] & 1) {
#endif /* !C3_RCE_INCLUDE_NON_INSTALLED_DATA */
                        /* get source for entry's actions */
                        actionData = &(entryData->actData[1][resReg][segOffset]);
                        /* determine where to put entry's actions in buffer */
                        ocmOffset = (elemsPerAction *
                                     (entryData->entryPosition - entryPosBase));
                        /* copy this entry's actions to the buffer */
                        for (actBit = 0; actBit < bitsPerAction; actBit++) {
                            actBlock[(ocmOffset +
                                      (actBit ^ (C3_RCE_DMA_HOST_END_MASK ^
                                                 byteOrderMask)))] =
                                actionData[actBit];
                        } /* for (all bytes in this action slot) */
#if !C3_RCE_INCLUDE_NON_INSTALLED_DATA
                    } /* if (entry is installed) */
#endif /* !C3_RCE_INCLUDE_NON_INSTALLED_DATA */
                } /* for (all entries that belong to this filter set) */
            } else { /* if (elemsPerAction) */
                /*
                 *  At least one action slot per OCM.  Since we covered the 1:1
                 *  ratio already, this implies that there is more than one action
                 *  slot per OCM address and that we need to deal with this on a
                 *  bitwise basis.
                 */
                actionsPerElem = ucSegment->actionsPerElem;
                bitsPerAction = ucSegment->bitsPerAction;
                /* copy each entry's hardware actions */
                for (/* init already done */;
                     entryData && (entryData->entryPosition <= entryPosLimit);
                     entryData = entryData->entryNext) {
#if !C3_RCE_INCLUDE_NON_INSTALLED_DATA
                    if (entryData->pattData[0][0] & 1) {
#endif /* !C3_RCE_INCLUDE_NON_INSTALLED_DATA */
                        /* get source for entry's actions */
                        actionData = &(entryData->actData[1][resReg][segOffset]);
                        /* find where this entry's actions will go */
                        ocmOffset = ((entryData->entryPosition - entryPosBase) /
                                     actionsPerElem) << 3;
                        ocmBit = ((entryData->entryPosition - entryPosBase) %
                                  actionsPerElem) * bitsPerAction;
                        ocmIndex = ocmBit >> 3;
                        ocmBit &= 7;
                        /*
                         *  Copy this entry's action bits.  Note we only copy '1'
                         *  bits because the buffer was already cleared, so all
                         *  bits were zero before we started.
                         */
                        for (actBit = 0; actBit < bitsPerAction; actBit++) {
                            if (actionData[actBit >> 3] & (1 << (actBit & 7))) {
                                actBlock[(ocmOffset +
                                          (ocmIndex ^ (C3_RCE_DMA_HOST_END_MASK ^
                                                       byteOrderMask)))] |=
                                    (1 << ocmBit);
                            }
                            ocmBit++;
                            if (7 < ocmBit) {
                                ocmBit = 0;
                                ocmIndex++;
                            }
                        } /* for (all bits in this action slot) */
#if !C3_RCE_INCLUDE_NON_INSTALLED_DATA
                    } /* if (entry is installed) */
#endif /* !C3_RCE_INCLUDE_NON_INSTALLED_DATA */
                } /* for (all entries that belong to this filter set) */
            } /* if (elemsPerAction) */
            segOffset += ((ucSegment->bitsPerAction + 7) >> 3);
        } /* for (all segments in this table) */
    } /* for (all possible result registers) */
    return SOC_E_NONE;
}

/*
 *  Function
 *    _soc_c3_rce_filter_set_build
 *  Purpose
 *    Build a filter set and place it in imem + amem
 *  Arguments
 *    (IN) unitData = pointer to unit information
 *    (IN) groupData = pointer to group information
 *    (IN) firstSet = nonzero if initial filter set, otherwise zero
 *    (IN) entryHead = pointer to first entry in filter set
 *    (IN) entryPosBase = entry position base for filter set
 *    (IN) entryPosLimit = entry position high limit for filter set
 *    (IN) nextFilterAddr = instruction memory block for next filter set
 *    (IN/OUT) fsData = pointer to working filter set description
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    This allocates space in instruction/pattern memory, allocates space in
 *    action memory, builds the instruction/pattern image, builds the action
 *    image, writes the instruction/pattern image to the instruction/pattern
 *    memory, writes the action image to the action memory.
 *
 *    It fills in the provided filter set description with the appropriate
 *    data about what it has done.
 */
static int
_soc_c3_rce_filter_set_build(_soc_c3_rce_unit_desc_int_t *unitData,
                             _soc_c3_rce_group_desc_int_t *groupData,
                             int firstSet,
                             _soc_c3_rce_entry_desc_int_t *entryHead,
                             unsigned int entryPosBase,
                             unsigned int entryPosLimit,
                             unsigned int nextFilterAddr,
                             _soc_c3_rce_filterset_desc_int_t *fsData)
{
    _soc_c3_rce_program_block_t *progBlocks;  /* inst+patt DMA buffers */
    _soc_c3_rce_program_desc_int_t *progData; /* program information */
    unsigned int segmentSize[SOC_C3_RCE_MAX_OCM_SEG_PER_ACTION_TABLE];
    uint8 *actBlock[SOC_C3_RCE_RESULT_REGISTER_COUNT][SOC_C3_RCE_MAX_OCM_SEG_PER_ACTION_TABLE]; /* action mem buffers */
    unsigned int resReg;                      /* working result register */
    unsigned int allocSize;                   /* alloc size workspace */
    unsigned int actBase;                     /* base action index */
    int temp;                                 /* working space */
    int result;                               /* working result */
    const _soc_c3_rce_actions_uc_desc_t *ucData=NULL;

    /* initial conditions */
    progBlocks = NULL;
    memset(actBlock, 0, sizeof(actBlock));
    progData = unitData->progData[groupData->rceProgram];
    /* allocate working memory to prepare the new instructions */
    allocSize = sizeof(*progBlocks) * fsData->imemSize;
    progBlocks = soc_cm_salloc(unitData->unit,
                               allocSize,
                               "C3 RCE instruction/pattern memory workspace");
    if (!progBlocks) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %u bytes instruction buffer\n"),
                   allocSize));
        result = SOC_E_MEMORY;
        goto error;
    }
    for (actBase = 0; actBase < SOC_C3_RCE_RESULT_REGISTER_COUNT; actBase++) {
        if (0 == (groupData->resultLrpUniq & (1 << actBase))) {
            /* group does not use this result register */
            continue;
        }
        /* allocate working memory to prepare the new actions */
        allocSize = 0;
        ucData = unitData->actData[progData->actIndex[actBase]]->ucData;
        for (temp = 0; temp < ucData->ocmSegments; temp++) {
            if (ucData->seg[temp].elemsPerAction) {
                /*
                 *  At least one OCM element is required to represent each action slot.
                 *  This is also supported to allow more complex actions.
                 */
                segmentSize[temp] = (C3_RCE_ENTRIES_PER_FILTER_SET *
                                     ucData->seg[temp].elemsPerAction);
            } else {
                /*
                 *  Otherwise assume at least one action slot per OCM element...
                 */
                segmentSize[temp] = (C3_RCE_ENTRIES_PER_FILTER_SET /
                                     ucData->seg[temp].actionsPerElem);
            }
            /* an element of OCM is 64 bits, so eight bytes per element */
            segmentSize[temp] <<= 3;
            allocSize += segmentSize[temp];
        }

        /* NOT DMA memory because interposing layer reparses the data */
        actBlock[actBase][0] = sal_alloc(allocSize,
                                         "C3 RCE action memory workspace");
        if (!actBlock[actBase][0]) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to allocate %u bytes buffer for"
                       " actions in register %u, action table"
                       " %u (%s)\n"),
                       allocSize,
                       actBase,
                       progData->actIndex[actBase],
                       unitData->actData[progData->actIndex[actBase]]->ucData->tableName));
            result = SOC_E_MEMORY;
            goto error;
        }
        sal_memset(actBlock[actBase][0], 0x00, allocSize);
        /* update pointers for any segments after the first one */
        for (temp = 1; temp < ucData->ocmSegments; temp++) {
            actBlock[actBase][temp] = &(actBlock[actBase][temp -1][segmentSize[temp - 1]]);
        }
    } /* for (all possible result registers) */

    /* allocate new space in the instruction memory */
    result = shr_mdb_alloc(unitData->imemRes,
                           &(fsData->imemStart),
                           fsData->imemSize);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %u instruction memory blocks\n"),
                   fsData->imemSize));
        result = SOC_E_RESOURCE;
        fsData->imemStart = ~0;
        goto error;
    }
    unitData->imemBlockCount++;
    
    actBase = (~0);
    for (resReg = 0; resReg < SOC_C3_RCE_RESULT_REGISTER_COUNT; resReg++) {
        if (0 == (groupData->resultLrpUniq & (1 << resReg))) {
            /* group does not use this result register */
            continue;
        }
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
        if ((fsData->fsetFlags & _SOC_C3_RCE_FSET_FLAGS_COUNTER) &&
            ((~0) != fsData->amemBlock)) {
            /*
             *  We are using action-indexed counters in this filter set's
             *  group, and the counter block has already been allocated.
             *  Just work out the counter base from the phase.
             */
            actBase = fsData->amemBlock;
        } else { /* if (using action-indexed counters or no action space) */
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
            /*
             *  Either not using action-indexed counters, or this filter
             *  set does not yet have its block allocated.  Allocate a new
             *  block for this filter set.
             */
            /* allocate new space in the action memory */
            result = shr_mres_alloc(unitData->amemRes,
                                    progData->actIndex[resReg],
                                    0 /* flags */,
                                    1 /* one block */,
                                    &temp);
            if (SOC_E_NONE != result) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("unit %d unable to allocate program %u"
                           " result %u action memory %u (%s)"
                           " block: %d (%s)\n"),
                           unitData->unit,
                           groupData->rceProgram,
                           resReg,
                           progData->actIndex[resReg],
                           unitData->actData[progData->actIndex[resReg]]->ucData->tableName,
                           result,
                           _SHR_ERRMSG(result)));
                result = SOC_E_RESOURCE;
                fsData->amemBlock = ~0;
                goto error;
            }
            unitData->actData[progData->actIndex[resReg]]->entryActive++;
            fsData->amemBlock = temp;
            actBase = temp;
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
        } /* if (using action-indexed counters or no action space) */
        if (fsData->fsetFlags & _SOC_C3_RCE_FSET_FLAGS_COUNTER) {
            /* with action-indexed counters, blocks are double size */
            actBase <<= 1;
            if (fsData->fsetFlags & _SOC_C3_RCE_FSET_FLAGS_PHASE) {
                /* now phase one */
                actBase++;
            }
            /* flip phase for next time */
            fsData->fsetFlags ^= _SOC_C3_RCE_FSET_FLAGS_PHASE;
        }
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
        /* bias the base value to avoid result of zero */
        actBase *= C3_RCE_ENTRIES_PER_FILTER_SET;
        actBase += unitData->actData[progData->actIndex[resReg]]->firstEntryBias;
    } /* for (all possible result registers) */
    if ((~0) == actBase) {
        /* should never see this (means group has no result registers) */
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d group %d specifies no result register\n"),
                   unitData->unit,
                   groupData->groupId));
        result = SOC_E_INTERNAL;
        goto error;
    }
    /* fill in the instruction memory */
    result = _soc_c3_rce_filter_set_build_instr(unitData,
                                                groupData->instrCount,
                                                fsData->imemSize - 1,
                                                nextFilterAddr,
                                                actBase,
                                                firstSet,
                                                groupData->instr,
                                                fsData,
                                                progBlocks);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to build filter set instructions:"
                   " %d (%s)\n"),
                   result,
                   _SHR_ERRMSG(result)));
        goto error;
    }
    /* fill in pattern data */
    result = _soc_c3_rce_filter_set_build_patt(unitData,
                                               groupData->instrCount,
                                               entryHead,
                                               entryPosBase,
                                               entryPosLimit,
                                               fsData,
                                               progBlocks);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to build filter set patterns:"
                   " %d (%s)\n"),
                   result,
                   _SHR_ERRMSG(result)));
        goto error;
    }
    result = soc_cm_sflush(unitData->unit,
                           progBlocks,
                           sizeof(*progBlocks) * fsData->imemSize);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to flush cache for instruction memory:"
                   " %d (%s)\n"),
                   result,
                   _SHR_ERRMSG(result)));
        goto error;
    }
    /* commit the new program segment to instruction memory */
    /*    coverity[negative_returns : FALSE]    */
    result = soc_mem_write_range(unitData->unit,
                                 IMEM_PMEM_DMAm,
                                 MEM_BLOCK_ALL,
                                 fsData->imemStart << 5,
                                 ((fsData->imemStart + fsData->imemSize) << 5) - 1,
                                 progBlocks);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to write instruction+pattern memmory:"
                   " %d (%s)\n"),
                   result,
                   _SHR_ERRMSG(result)));
        goto error;
    }
    /* fill in the action memory image */
    result = _soc_c3_rce_filter_set_build_actions(unitData,
                                                  entryHead,
                                                  entryPosBase,
                                                  entryPosLimit,
                                                  progData->actIndex,
                                                  actBlock);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to build filter set actions:"
                   " %d (%s)\n"),
                   result,
                   _SHR_ERRMSG(result)));
        goto error;
    }
    for (resReg = 0; resReg < SOC_C3_RCE_RESULT_REGISTER_COUNT; resReg++) {
        if (0 == (groupData->resultLrpUniq & (1 << resReg))) {
            /* group does not use this result register */
            continue;
        }
        /* put the new actions into the action memory */
        ucData = unitData->actData[progData->actIndex[resReg]]->ucData;
        for (temp = 0; temp < ucData->ocmSegments; temp++) {
            result = soc_sbx_caladan3_ocm_port_mem_write(unitData->unit,
                                 ucData->seg[temp].ocmPort,
                                 ucData->seg[temp].ocmSeg,
                                 actBase,
                                 C3_RCE_ENTRIES_PER_FILTER_SET + actBase - 1,
                                 ((uint32*)actBlock[resReg][temp]));
            if (SOC_E_NONE != result) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("unit %d unable to write program %u (%s)"
                           " result %u action %u (%s) memory segment"
                           " %d to OCM %d.%d from %u through %u:"
                           " %d (%s)\n"),
                           unitData->unit,
                           groupData->rceProgram,
                           progData->ucData->programName,
                           resReg,
                           progData->actIndex[resReg],
                           ucData->tableName,
                           temp,
                           ucData->seg[temp].ocmPort,
                           ucData->seg[temp].ocmSeg,
                           actBase,
                           C3_RCE_ENTRIES_PER_FILTER_SET + actBase - 1,
                           result,
                           _SHR_ERRMSG(result)));
                goto error;
            }
        } /* for (all segments this action table) */
    } /* for (all possible result registers) */
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
    /* this must only happen after everything else is successful */
    fsData->fsetFlags |= _SOC_C3_RCE_FSET_FLAGS_EXISTS;
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
error:
    if (SOC_E_NONE != result) {
        /* failed; free new resources */
        if ((~0) != fsData->imemStart) {
            temp = shr_mdb_free(unitData->imemRes, fsData->imemStart);
            if (SOC_E_NONE != temp) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("unable to free unused instruction memory:"
                           " %d (%s)\n"),
                           result,
                           _SHR_ERRMSG(result)));
                /* but do not return as error */
            } else {
                unitData->imemBlockCount--;
            }
        } /* if (allocated an instruction memory block) */
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
        if (0 == (fsData->fsetFlags & _SOC_C3_RCE_FSET_FLAGS_EXISTS)) {
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
            if ((~0) != fsData->amemBlock) {
                for (resReg = 0;
                     resReg < SOC_C3_RCE_RESULT_REGISTER_COUNT;
                     resReg++) {
                    if (0 == (groupData->resultLrpUniq & (1 << resReg))) {
                        /* group does not use this result register */
                        continue;
                    }
                    /* free newly allocated action memory block */
                    temp = shr_mres_free(unitData->amemRes,
                                         progData->actIndex[resReg],
                                         1 /* one amem block */,
                                         fsData->amemBlock);
                    if (SOC_E_NONE != temp) {
                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                  (BSL_META("unit %d unable to free program"
                                   " %u result %u unused action"
                                   " table %u (%s) block %u:"
                                   " %d (%s)\n"),
                                   unitData->unit,
                                   groupData->rceProgram,
                                   resReg,
                                   progData->actIndex[resReg],
                                   unitData->actData[progData->actIndex[resReg]]->ucData->tableName,
                                   fsData->amemBlock,
                                   temp,
                                   _SHR_ERRMSG(temp)));
                        /* but do not return as error */
                    } else {
                        unitData->actData[progData->actIndex[resReg]]->entryActive--;
                    }
                } /* for (all possible result registers) */
            } /* if (allocated an action memory block) */
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
        } /* if (not reusing an existing action memory block) */
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
    } /* if (SOC_E_NONE != result) */
    if (progBlocks) {
        soc_cm_sfree(unitData->unit, progBlocks);
    }
    for (resReg = 0; resReg < SOC_C3_RCE_RESULT_REGISTER_COUNT; resReg++) {
        if (actBlock[resReg][0]) {
            sal_free(actBlock[resReg][0]);
            actBlock[resReg][0] = NULL;
        }
    }

    return result;
}

/*
 *  Function
 *    _soc_c3_rce_filter_set_start_update
 *  Purpose
 *    Update the next-filter-set-start address in a filter set, or (if
 *    applicable) the program start address)
 *  Arguments
 *    (IN) unitData = pointer to unit information
 *    (IN) programId = which program to manipulate
 *    (IN) fsData = proposed filter set data for program
 *    (IN) filterSet = which filter set to update
 *    (IN) startBlock = instruction memory block for start
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    If filterSet is < 0, this will update the program start address.
 *
 *    If filterSet is >= 0, this will update the next-filter-set start address
 *    on the specified filter set for the program (basically it specifies where
 *    the next filter set will start).
 *
 *    The address is specified by the instruction memory block, not the
 *    individual instruction.
 */
static int
_soc_c3_rce_filter_set_start_update(_soc_c3_rce_unit_desc_int_t *unitData,
                                    unsigned int programId,
                                    const _soc_c3_rce_filterset_desc_int_t *fsData,
                                    int filterSet,
                                    unsigned int startBlock)
{
    uint64 instrTemp;                         /* temp instr for editing */
    uint64 instrStartAddr;                    /* temp buff for instr editing */
    uint64 uuTmp = COMPILER_64_INIT(0xFFFFFF00, 0x0FFFFFFF);
    uint32 progCtrlTemp;                      /* temp buffer for reg editing */
    uint32 *imemTemp = NULL;                  /* imem PIO buffer */
    int result;

    if (0 > filterSet) {
        /* setting the program start block */
        result = soc_reg32_get(unitData->unit,
                               RC_INSTCTRL_PROGRAM_CONFIGr,
                               REG_PORT_ANY,
                               programId,
                               &progCtrlTemp);
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to read program %u (%s) control"
                       " register: %d (%s)\n"),
                       programId,
                       unitData->progData[programId]->ucData->programName,
                       result,
                       _SHR_ERRMSG(result)));
            goto error;
        }
        soc_reg_field_set(unitData->unit,
                          RC_INSTCTRL_PROGRAM_CONFIGr,
                          &progCtrlTemp,
                          BASE_ADDRf,
                          startBlock & 0xFFF);
        if (startBlock < 0xFFF) {
            /* valid starting block; enable program */
            soc_reg_field_set(unitData->unit,
                              RC_INSTCTRL_PROGRAM_CONFIGr,
                              &progCtrlTemp,
                              ENf,
                              1);
        } else {
            /* invalid starting block; disable program */
            soc_reg_field_set(unitData->unit,
                              RC_INSTCTRL_PROGRAM_CONFIGr,
                              &progCtrlTemp,
                              ENf,
                              0);
        }
        result = soc_reg32_set(unitData->unit,
                               RC_INSTCTRL_PROGRAM_CONFIGr,
                               REG_PORT_ANY,
                               programId,
                               progCtrlTemp);
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to write program %u (%s) control"
                       " register: %d (%s)\n"),
                       programId,
                       unitData->progData[programId]->ucData->programName,
                       result,
                       _SHR_ERRMSG(result)));
            goto error;
        }
    } else { /* if (0 > filterSet) */
        /* editing a filter set to set the next filter set start block */
        /* allocate buffer for the instruction memory block */
        imemTemp = soc_cm_salloc(unitData->unit,
                                 sizeof(uint32) *
                                 soc_mem_entry_words(unitData->unit, IMEMm),
                                 "C3 RCE instruction update buffer");
        if (!imemTemp) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to allocate %u bytes program temporary"
                       " buffer\n"),
                       (unsigned int)(sizeof(uint32) *
                       soc_mem_entry_words(unitData->unit,
                       IMEMm))));
            result = SOC_E_MEMORY;
            goto error;
        }
        result = soc_cm_sinval(unitData->unit, imemTemp, sizeof(*imemTemp));
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to invalidate cache for instruction"
                       " memory: %d (%s)\n"),
                       result,
                       _SHR_ERRMSG(result)));
            goto error;
        }
        /* read the instruction memory block */
        result = soc_mem_read(unitData->unit,
                              IMEMm,
                              MEM_BLOCK_ANY,
                              fsData[filterSet].imemStart,
                              imemTemp);
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to read instruction block %u:"
                       " %d (%s)\n"),
                       fsData[filterSet].imemStart,
                       result,
                       _SHR_ERRMSG(result)));
            goto error;
        }
        /* update the start opcode to point to the new next block */
        soc_mem_field64_get(unitData->unit,
                            IMEMm,
                            imemTemp,
                            INSTRUCTION0f,
                            &instrTemp);
        COMPILER_64_SET(instrStartAddr, (startBlock >> 4) & 0xFF,
                                          startBlock << 28);
        COMPILER_64_AND(instrTemp, uuTmp);
        COMPILER_64_OR(instrTemp, instrStartAddr);
        soc_mem_field64_set(unitData->unit,
                            IMEMm,
                            imemTemp,
                            INSTRUCTION0f,
                            instrTemp);
        result = soc_cm_sflush(unitData->unit, imemTemp, sizeof(*imemTemp));
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to flush cache for instruction memory:"
                       " %d (%s)\n"),
                       result,
                       _SHR_ERRMSG(result)));
            goto error;
        }
        /* write the modified instruction memory block */
        result = soc_mem_write(unitData->unit,
                               IMEMm,
                               MEM_BLOCK_ALL,
                               fsData[filterSet].imemStart,
                               imemTemp);
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to write instruction block %u:"
                       " %d (%s)\n"),
                       fsData[filterSet].imemStart,
                       result,
                       _SHR_ERRMSG(result)));
            goto error;
        }
    } /* if ((~0) == filterSetIndex) */
error:
    if (imemTemp) {
        soc_cm_sfree(unitData->unit, imemTemp);
    }
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_program_padding_length_calc
 *  Purpose
 *    Compute how much padding to apply to a program
 *  Arguments
 *    (in) unitData = pointer to unit information
 *    (in) progLength = how many program blocks in the program
 *    (out) padLength = amount of padding to add
 *    (out) padAddr = instruction memory block for padding start
 *  Returns
 *    nothing
 *  Notes
 *    Padding is allocated in blocks as specified by several constants earlier
 *    in the code.  If a program is sufficiently long, no padding will be
 *    selected, but otherwise a padding block will be selected according to the
 *    length of the program, and both padLength and padAddr are provided as
 *    appropriate to the selected amount of padding.
 */
static void
_soc_c3_rce_program_padding_length_calc(_soc_c3_rce_unit_desc_int_t *unitData,
                                        unsigned int progLength,
                                        unsigned int *padLength,
                                        unsigned int *padAddr)
{
    unsigned int padIndex;
    if (progLength < C3_RCE_PROGRAM_LENGTH_MINIMUM) {
        if (progLength >= C3_RCE_FILTER_SET_FIRST_PADDING) {
            /* this must be the case if there are any filter sets */
            padIndex = ((progLength - C3_RCE_FILTER_SET_LENGTH_FIRST) /
                           C3_RCE_FILTER_SET_LENGTH_PADDING) + 1;
            *padAddr = unitData->imemExtra[padIndex];
            *padLength = ((C3_RCE_FILTER_SET_COUNT_PADDING - padIndex) *
                          C3_RCE_FILTER_SET_LENGTH_PADDING);
        } else {
            /* must only happen when there are no filter sets in the program */
            *padAddr = unitData->imemExtra[0];
            *padLength = C3_RCE_FILTER_SET_PADDING;
        }
    } else {
        /* no need for padding */
        *padAddr = ~0;
        *padLength = 0;
    }
}

/*
 *  Function
 *    _soc_c3_rce_filter_set_update
 *  Purpose
 *    Update a filter set in a program
 *  Arguments
 *    (IN) unitData = pointer to unit information
 *    (IN) groupId = group ID
 *    (IN) filterSet = which filter set in the group to update
 *    (IN) forceFirst = TRUE if update filter set as if first even if not
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    This builds the instrucion/pattern image in imem/pmem, and the action
 *    image in amem.  It then updates the previous filter set to point to the
 *    new one, and finally frees the old imem/pmem space and amem space.
 *
 *    The 'hardware' copy of the pattern and action values will be written.
 *
 *    This will adjust padding blocks if it is updating the final filter set.
 *    It assumes the current program information to be correct.
 */
static int
_soc_c3_rce_filter_set_update(_soc_c3_rce_unit_desc_int_t *unitData,
                              int groupId,
                              unsigned int filterSet,
                              int forceFirst)
{
    _soc_c3_rce_filterset_desc_int_t fsData;  /* filter set working info */
    _soc_c3_rce_program_desc_int_t *progData; /* program description */
    _soc_c3_rce_group_desc_int_t *groupData;  /* group description */
    _soc_c3_rce_entry_desc_int_t *entryHead;  /* first entry in filter set */
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
    _soc_c3_rce_entry_desc_int_t *entryCurr;  /* current entry in filter set */
    unsigned int *entryMoves = NULL;          /* list of entry movement */
    uint64 *ctrTemp = NULL;                   /* counter read workspace */
    unsigned int moveCount = 0;               /* counter pairs to read */
    int ovrRes = SOC_E_NONE;
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
    int result;
    int auxRes;
    unsigned int index;                       /* counter pair update index */
    unsigned int imemStartNext;               /* next filter set imem start */
    unsigned int filterSetIndex;              /* which filter set in program */
    unsigned int filterSetBase;               /* group filter set min posn */
    unsigned int filterSetLimit;              /* group filter set max posn */
    unsigned int addedBlocks;                 /* added instruction blocks */
    unsigned int programBlocks;               /* current instruction blocks */

    groupData = unitData->groupData[groupId];
    progData = unitData->progData[groupData->rceProgram];
    fsData.amemBlock = ~0;
    fsData.imemStart = ~0;
    fsData.fsetFlags = 0;
    fsData.groupId = groupId;
    fsData.filterIndex = filterSet;
    programBlocks = progData->instrBlockCount;
    /* find the place in the program where this filter set occurs */
    result = _soc_c3_rce_filter_set_locate(unitData,
                                           progData,
                                           groupId,
                                           filterSet,
                                           &filterSetIndex);
    if (SOC_E_NONE != result) {
        /* called function displayed diagnostic */
        goto error;
    }
    fsData.imemSize = progData->fsetData[filterSetIndex].imemSize;
    fsData.rangeInfo = progData->fsetData[filterSetIndex].rangeInfo;
    /* find the first entry in this filter set */
    filterSetBase = filterSet * C3_RCE_ENTRIES_PER_FILTER_SET;
    filterSetLimit = filterSetBase + (C3_RCE_ENTRIES_PER_FILTER_SET - 1);
    entryHead = progData->fsetData[filterSetIndex].entryHead;
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
    fsData.fsetFlags = progData->fsetData[filterSetIndex].fsetFlags;
    if (fsData.fsetFlags & _SOC_C3_RCE_FSET_FLAGS_COUNTER) {
        /* keep existing action memory block if action indexed counters */
        fsData.amemBlock = progData->fsetData[filterSetIndex].amemBlock;
        /*
         *  The biggest problem with the counters is that reading them takes
         *  an unreasonably long time -- somwhere along the lines of 25 times
         *  as long to read the counters as to perform the entire rest of the
         *  update.
         *
         *  In order to avoid this crippling the performance, we need to
         *  minimise the counter accesses.  To do this, we use a pair of action
         *  table blocks that is fixed for the life of the filter set, keep a
         *  basis value for the counters per entry, and whenever an entry is
         *  added, shifted, or removed, we read the counters and make
         *  appropriate adjustments.
         *
         *  For the spot *from* which an entry is moved, the counter is read
         *  and the entry's basis is adjusted.
         *
         *  For the spot *to* which an entry is moved, that counter is read,
         *  but, if there is no entry moving *from* this point, the value is
         *  discarded.
         *
         *  When doing these reads, we always do read-and-clear.  Also, we must
         *  do both the current and opposite block in the action table.  The
         *  opposite block is done first (since it will not receive counter
         *  increments until after the update is performed), the update is
         *  committed, and then what was the current block is done (since it
         *  will no longer receive counter increments until after the next
         *  update).  By using this sequence, we avoid residuals that might
         *  occur between the read time and committing the update to the filter
         *  set and traffic using the updated filter set.
         */
        entryMoves = sal_alloc(sizeof(*entryMoves) *
                               C3_RCE_ENTRIES_PER_FILTER_SET,
                               "move table workspace");
        if (!entryMoves) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to allocate %u bytes for entry move"
                       " workspace\n"),
                       (unsigned int)(sizeof(*entryMoves)) *
                       C3_RCE_ENTRIES_PER_FILTER_SET));
            result = SOC_E_MEMORY;
            goto error;
        }
        /* all ones means not touched, since all zeroes is a valid position */
        for (index = 0;
             index < C3_RCE_ENTRIES_PER_FILTER_SET;
             index++) {
            entryMoves[index] = ~0;
        } /* for (all slots in the filter set) */
        /*
         *  We need to build a list that tells us how the counters will be
         *  updated to handle this update to the filter set.  We already have
         *  the buffer allocated and all of the entries in it set to indicate
         *  there are no counter accesses, which is a really optimistic view,
         *  but despite being a degenerate case, is fairly likely to happen.
         *
         *  However, we can not assume that case.  We go through the list of
         *  entries for this filter set here, and adjust the counter updates
         *  list so that it reflects the needed updates.
         *
         *  Already, all bits set (default state) indicates that the counter is
         *  not to be touched.  Any other value greater than or equal to the
         *  number of entries supported indicates the counter is to be read and
         *  that value discarded.  Any value less than the number of entries
         *  supported indicates the counter is to be read and added to the
         *  basis for that entry.
         */
        for (entryCurr = groupData->entryHead;
             entryCurr;
             entryCurr = entryCurr->entryNext) {
            if (entryCurr->entryPosition == entryCurr->entryPosPrev) {
                /* this entry has not moved; skip it */
                continue;
            }
            if ((filterSetBase <= entryCurr->entryPosPrev) &&
                (filterSetLimit >= entryCurr->entryPosPrev)) {
                /*
                 *  This entry has been moved from a position in this filter
                 *  set, so we need to read the associated counter pair and
                 *  update this entry's basis counts.
                 */
#if 0 
                RCE_EVERB((RCE_MSG1("unit %d entry %d group %d moving from"
                                    " position %u\n"),
                           unitData->unit,
                           entryCurr->entryId,
                           entryCurr->entryGroup,
                           entryCurr->entryPosPrev));
#endif 
                entryMoves[entryCurr->entryPosPrev - filterSetBase] =
                                                            entryCurr->entryId;
            } /* if (this entry moved from this filter set) */
#if C3_RCE_ACTION_INDEX_COUNTER_CLEAR_PARNOIA
            if ((filterSetBase <= entryCurr->entryPosition) &&
                (filterSetLimit >= entryCurr->entryPosition) &&
                (unitData->entryLimit <
                 entryMoves[entryCurr->entryPosition - filterSetBase])) {
                /*
                 *  This entry has been moved to a position in this filter set
                 *  and that position has not yet been marked to read for
                 *  another entry moving from this filter set and we want to be
                 *  sure counters are cleared before putting entries in place.
                 */
#if 0 
                RCE_EVERB((RCE_MSG1("unit %d entry %d group %d moving to"
                                    " position %u\n"),
                           unitData->unit,
                           entryCurr->entryId,
                           entryCurr->entryGroup,
                           entryCurr->entryPosition));
#endif 
                entryMoves[entryCurr->entryPosition - filterSetBase] =
                    unitData->entryLimit;
            } /* if (this entry moved to this filter set) */
#endif /* C3_RCE_ACTION_INDEX_COUNTER_CLEAR_PARNOIA */
        } /* for (all entries in this filter set) */
        for (index = 0;
             index < C3_RCE_ENTRIES_PER_FILTER_SET;
             index++) {
            if ((~0) != entryMoves[index]) {
                moveCount++;
            }
        } /* for (all slots in the filter set) */
        /*
         *  Now we know what moves to make, and how many moves there are.  The
         *  move count is important: if the number of counters to read is
         *  larger than some constant, it will be faster to read the entire
         *  block of counters instead of reading them one at a time.  Because
         *  of the thread interaction, interrupt overhead, and other factors,
         *  the threshold value for this is unnervingly small.
         */
        if (moveCount < C3_RCE_ACTION_INDEX_COUNTER_BLOCK_THRESHOLD) {
            ctrTemp = sal_alloc(sizeof(*ctrTemp) * 2,
                                "counter workspace for entry moves");
        } else { /* if (moveCount is below block move threshold) */
            ctrTemp = sal_alloc(sizeof(*ctrTemp) * 2 *
                                C3_RCE_ENTRIES_PER_FILTER_SET,
                                "counter workspace for entry moves");
        } /* if (moveCount is below block move threshold) */
        if (!ctrTemp) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to allocate %u bytes for counter"
                       " move workspace\n"),
                       (unsigned int)(sizeof(*ctrTemp)) * 2 *
                       C3_RCE_ENTRIES_PER_FILTER_SET));
            result = SOC_E_MEMORY;
            goto error;
        } /* if (!ctrTemp) */
    } /* if (fsData.fsetFlags & _SOC_C3_RCE_FSET_FLAGS_COUNTER) */
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
    /*
     *  The only possible size change of a program in this function is as noted
     *  just above -- a filter set that was first has moved to later and was
     *  not yet updated.  Since decreasing is the only direction the program
     *  length will take in this function, we need to adjust the padding size
     *  before we replace the filter set, or possibly at the same time.
     */
    _soc_c3_rce_program_padding_length_calc(unitData,
                                            programBlocks,
                                            &addedBlocks,
                                            &imemStartNext);
    if (filterSetIndex < (progData->filterSetCount - 1)) {
        /* not the last filter set; adjust padding first if needed */
        if (programBlocks < progData->instrBlockCount) {
            /* program length will be shorter so adjust padding */
            result = _soc_c3_rce_filter_set_start_update(unitData,
                                                         groupData->rceProgram,
                                                         progData->fsetData,
                                                         ((int)(progData->filterSetCount)) - 1,
                                                         imemStartNext);
            if (SOC_E_NONE != result) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("unable to adjust final padding block for"
                           " unit %d program %u (%s): %d (%s)\n"),
                           unitData->unit,
                           groupData->rceProgram,
                           progData->ucData->programName,
                           result,
                           _SHR_ERRMSG(result)));
                goto error;
            }
            /* adjust added blocks since we just changed the padding */
            unitData->instrBlockCount = (unitData->instrBlockCount -
                                         progData->instrBlockAdded +
                                         addedBlocks);
            progData->instrBlockAdded = addedBlocks;
        } /* if (programBlocks < progData->instrBlockCount) */
        /* when updating this block, want correct next filter set pointer */
        imemStartNext = progData->fsetData[filterSetIndex + 1].imemStart;
    }
    /* build the new instruction/pattern blocks and action block */
    result = _soc_c3_rce_filter_set_build(unitData,
                                          groupData,
                                          (0 == filterSetIndex) || forceFirst,
                                          entryHead,
                                          filterSetBase,
                                          filterSetLimit,
                                          imemStartNext,
                                          &fsData);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to build instruction/pattern/action block"
                   " for unit %d group %d set %u: %d (%s)\n"),
                   unitData->unit,
                   groupId,
                   filterSet,
                   result,
                   _SHR_ERRMSG(result)));
        fsData.imemStart = ~0;
        fsData.amemBlock = ~0;
        goto error;
    }
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
    if (entryMoves && moveCount) {
        /*
         *  Now we have the list of counters to access and know what to do
         *  with each of them (merely read and discard, or read and update a
         *  specific entry's basis).  Go through the list to deal with the
         *  'next' phase (it is currently inactive) before the switch to the
         *  updated filter set is committed to hardware.
         *
         *  This must be done BEFORE the hardware is switched to use the new
         *  filter set, else it might contaminate the values in the opposite
         *  phase counters that we are reading here.
         *
         *  Any error that occurs here will be returned, but such errors are
         *  NOT fatal to the operation, so the update operation will not be
         *  backed out.  Such errors can cause corruption or loss of counter
         *  information, but such are limited to this filter set, and there's
         *  no way to back out the reads once they are done.
         */
        auxRes = _soc_c3_rce_entry_move_counter_update(unitData,
                                                       progData,
                                                       groupData,
                                                       &fsData,
                                                       entryMoves,
                                                       moveCount,
                                                       ctrTemp,
                                                       FALSE);
        if (SOC_E_NONE != auxRes) {
            /* called function displayed diagnostic */
            ovrRes = auxRes;
        }
    } /* if (entryMoves && moveCount) */
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
    /* link this new code into the program */
    result = _soc_c3_rce_filter_set_start_update(unitData,
                                                 groupData->rceProgram,
                                                 progData->fsetData,
                                                 ((int)(filterSetIndex)) - 1,
                                                 fsData.imemStart);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to link unit %d group %d set %u into"
                   " program %u (%s): %d (%s)\n"),
                   unitData->unit,
                   groupId,
                   filterSet,
                   groupData->rceProgram,
                   progData->ucData->programName,
                   result,
                   _SHR_ERRMSG(result)));
        goto error;
    }
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
    if (entryMoves && moveCount) {
        /*
         *  Now we have the list of counters to access and know what to do
         *  with each of them (merely read and discard, or read and update a
         *  specific entry's basis).  Go through the list to deal with the
         *  'next' phase (it is currently inactive) before the switch to the
         *  updated filter set is committed to hardware.
         *
         *  This must be done BEFORE the hardware is switched to use the new
         *  filter set, else it might contaminate the values in the opposite
         *  phase counters that we are reading here.
         *
         *  Any error that occurs here will be returned, but such errors are
         *  NOT fatal to the operation, so the update operation will not be
         *  backed out.  Such errors can cause corruption or loss of counter
         *  information, but such are limited to this filter set, and there's
         *  no way to back out the reads once they are done.
         */
        auxRes = _soc_c3_rce_entry_move_counter_update(unitData,
                                                       progData,
                                                       groupData,
                                                       &fsData,
                                                       entryMoves,
                                                       moveCount,
                                                       ctrTemp,
                                                       TRUE);
        if (SOC_E_NONE != auxRes) {
            /* called function displayed diagnostic */
            ovrRes = auxRes;
        }
        /*
             *  Update the position of all entries moved *from* or *within* this
             *  filter set.  Entries moved *to* this filter set will have their
             *  position updated later, when the counters are read in the filter
             *  set whence the entry was moved.
             */
        for (index = 0; index < C3_RCE_ENTRIES_PER_FILTER_SET; index++) {
            if (entryMoves[index] < unitData->entryLimit) {
                /*
                         *  This entry moved *from* this filter set, so we have read its
                         *  counter data from hardware and adjusted its basis counts.
                         *  Update its previous position so it is current.
                         */
                unitData->entryData[entryMoves[index]]->entryPosPrev =
                    unitData->entryData[entryMoves[index]]->entryPosition;
            }
        }
    } /* if (entryMoves && moveCount) */
    
    /*
     *  Recently created entries can now take their assigned positions, so
     *  update them.
     */
    for (entryCurr = entryHead;
         entryCurr;
         entryCurr = entryCurr->entryNext) {
        if (((~0) == entryCurr->entryPosPrev) &&
            (filterSetBase <= entryCurr->entryPosition) &&
            (filterSetLimit >= entryCurr->entryPosition)) {
            entryCurr->entryPosPrev = entryCurr->entryPosition;
        }
    } /* for (all entries in the group) */
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
error:
    if (SOC_E_NONE != result) {
        /* failed; free new resources */
        if ((~0) != fsData.imemStart) {
            /* any imem block here is new */
            auxRes = shr_mdb_free(unitData->imemRes, fsData.imemStart);
            if (SOC_E_NONE != auxRes) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("unable to free new instruction memory"
                           " blocks after error: %d (%s)\n"),
                           auxRes,
                           _SHR_ERRMSG(auxRes)));
                /* but do not return as error */
            } else {
                unitData->imemBlockCount--;
            }
        } /* if ((~0) != fsData.imemStart) */
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
        if (0 == (fsData.fsetFlags & _SOC_C3_RCE_FSET_FLAGS_COUNTER)) {
            /* not using action indexed counters, so new act blocks ea. time */
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
            if ((~0) != fsData.amemBlock) {
                for (index = 0;
                     index < SOC_C3_RCE_RESULT_REGISTER_COUNT;
                     index++) {
                    if (0 == (groupData->resultLrpUniq & (1 << index))) {
                        /* group does not use this result register */
                        continue;
                    }
                    auxRes = shr_mres_free(unitData->amemRes,
                                           progData->actIndex[index],
                                           1 /* one amem block */,
                                           fsData.amemBlock);
                    if (SOC_E_NONE != auxRes) {
                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                  (BSL_META("unit %d unable to free program"
                                   " %u result %u unused action"
                                   " table %u (%s) block %u :"
                                   " %d (%s)\n"),
                                   unitData->unit,
                                   groupData->rceProgram,
                                   index,
                                   progData->actIndex[index],
                                   unitData->actData[progData->actIndex[index]]->ucData->tableName,
                                   fsData.amemBlock,
                                   auxRes,
                                   _SHR_ERRMSG(auxRes)));
                        /* but do not return as error */
                    } else { /* if (SOC_E_NONE != auxRes) */
                        unitData->actData[progData->actIndex[index]]->entryActive--;
                    } /* if (SOC_E_NONE != auxRes) */
                } /* for (all possible result registers) */
            } /* if ((~0) != fsData.amemBlock) */
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
        } /* if (!(progData->ucData->ctrRead)) */
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
    } else { /* if (SOC_E_NONE != result) */
        /* succeeded; free old resources */
        if ((~0) != progData->fsetData[filterSetIndex].imemStart) {
            /* any old imem block was replaced */
            auxRes = shr_mdb_free(unitData->imemRes,
                                  progData->fsetData[filterSetIndex].imemStart);
            if (SOC_E_NONE != auxRes) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("unable to free old instruction memory"
                           " blocks after update: %d (%s)\n"),
                           auxRes,
                           _SHR_ERRMSG(auxRes)));
                /* but do not return as error */
            } else {
                unitData->imemBlockCount--;
            }
        } /* if ((~0) != imemStartOld) */
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
        if (0 == (fsData.fsetFlags & _SOC_C3_RCE_FSET_FLAGS_COUNTER)) {
            /* not using action indexed counters; discard old action block */
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
            if ((~0) != progData->fsetData[filterSetIndex].amemBlock) {
                for (index = 0;
                     index < SOC_C3_RCE_RESULT_REGISTER_COUNT;
                     index++) {
                    if (0 == (groupData->resultLrpUniq & (1 << index))) {
                        /* group does not use this result register */
                        continue;
                    }
                    auxRes = shr_mres_free(unitData->amemRes,
                                           progData->actIndex[index],
                                           1 /* one amem block */,
                                           progData->fsetData[filterSetIndex].amemBlock);
                    if (SOC_E_NONE != auxRes) {
                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                  (BSL_META("unit %d unable to free program"
                                   " %u result %u unused action"
                                   " table %u (%s) block %u:"
                                   " %d (%s)\n"),
                                   unitData->unit,
                                   groupData->rceProgram,
                                   index,
                                   progData->actIndex[index],
                                   unitData->actData[progData->actIndex[index]]->ucData->tableName,
                                   progData->fsetData[filterSetIndex].amemBlock,
                                   auxRes,
                                   _SHR_ERRMSG(auxRes)));
                        /* but do not return as error */
                    } else {
                        unitData->actData[progData->actIndex[index]]->entryActive--;
                    }
                } /* for (all possible result registers) */
            } /* if ((~0) != amemStartOld) */
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
        } /* if (!(progData->ucData->ctrRead)) */
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
        /* update program's filter set information to reflect new blocks */
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
        progData->fsetData[filterSetIndex].fsetFlags = fsData.fsetFlags;
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
        progData->fsetData[filterSetIndex].amemBlock = fsData.amemBlock;
        progData->fsetData[filterSetIndex].imemStart = fsData.imemStart;
        progData->fsetData[filterSetIndex].imemSize = fsData.imemSize;
        /* accounting */
        unitData->instrBlockCount = (unitData->instrBlockCount -
                                     (progData->instrBlockCount +
                                      progData->instrBlockAdded) +
                                     (programBlocks + addedBlocks));
        progData->instrBlockCount = programBlocks;
        progData->instrBlockAdded = addedBlocks;
    } /* if (SOC_E_NONE != result) */
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
    if (SOC_E_NONE == result) {
        /* if there was no other error, return last counter update error */
        result = ovrRes;
    }
    if (entryMoves) {
        sal_free(entryMoves);
    }
    if (ctrTemp) {
        sal_free(ctrTemp);
    }
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_filter_set_start_fix
 *  Purpose
 *    Fix the start instruction on a filter set so it is appropriate to the
 *    position in the program.
 *  Arguments
 *    (IN) unitData = pointer to unit information
 *    (IN/OUT) fsData = pointer to filter set description
 *    (IN) isFirst = boolean indicating whether filter set is to be first
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    This accomplishes its objective by copying the IMEM/PMEM part of the
 *    filter set to a new block of IMEM/PMEM.  It does not update the action
 *    table side.
 *
 *    If this succeeds, the caller must update the program filter set list and
 *    free the appropriate copy on final success/error.
 *
 *    This will extend a filter set that is too short to be first, if it is
 *    making that filter set first, or reduce a filter set that is longer than
 *    it needs to be but was so to be first if it will no longer be first.
 */
static int
_soc_c3_rce_filter_set_start_fix(_soc_c3_rce_unit_desc_int_t *unitData,
                                 _soc_c3_rce_filterset_desc_int_t *fsData,
                                 int isFirst)
{
    uint64 instruction;
    uint64 mask;
    _soc_c3_rce_program_block_t *progBlocks = NULL;
    uint32 *imemTemp = NULL;
    unsigned int newImemStart = ~0;
    unsigned int groupSize;
    unsigned int size;
    unsigned int imemBytes;
    unsigned int imemPmemBytes;
    unsigned int index;
    uint32 opcode;
    int result = SOC_E_NONE;
    int auxRes COMPILER_ATTRIBUTE((unused));

    groupSize = unitData->groupData[fsData->groupId]->instrBlocks;
    _soc_c3_rce_filter_set_length(groupSize,
                                  !isFirst,
                                  &size);
    if (size > fsData->imemSize) {
        imemPmemBytes = size * sizeof(*progBlocks);
    } else {
        imemPmemBytes = fsData->imemSize * sizeof(*progBlocks);
    }
    /* set up buffer for the work */
    progBlocks = sal_dma_alloc(imemPmemBytes,
                               "C3 RCE instruction/pattern memory workspace");
    if (!progBlocks) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %u bytes instruction + pattern"
                            " buffer for fset copy\n"),
                   imemPmemBytes));
        result = SOC_E_MEMORY;
        goto error;
    }
    /* ensure any extra space is zeroed (NOP opcode + empty pattern) */
    sal_memset(progBlocks, 0x00, imemPmemBytes);
    /* get a new set of imem/pmem blocks */
    result = shr_mdb_alloc(unitData->imemRes,
                           &newImemStart,
                           size);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %u imem+pmem blocks for fset"
                            " copy\n"),
                   size));
        result = SOC_E_RESOURCE;
        goto error;
    }
    /*
     *  Read only the group's instruction blocks.  These are guaranteed to be
     *  covered by the new size of the filter set, and it is possible that we
     *  are reducing the size (so we don't want to read past the buffer).
     */
    sal_dma_flush(progBlocks, imemPmemBytes);
    result = soc_mem_read_range(unitData->unit,
                                IMEM_PMEM_DMAm,
                                MEM_BLOCK_ANY,
                                fsData->imemStart << 5,
                                ((fsData->imemStart + groupSize) << 5) - 1,
                                progBlocks);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to read imem space for revised filter set"
                            " at %03X..%03X: %d (%s)\n"),
                   fsData->imemStart,
                   fsData->imemStart + groupSize - 1,
                   result,
                   _SHR_ERRMSG(result)));
        goto error;
    }
    sal_dma_inval(progBlocks, imemPmemBytes);
    /* edit it so first instr is appropriate */
    progBlocks[0].instruction[0][(5 ^
                                  C3_RCE_DMA_HOST_END_MASK ^
                                  C3_RCE_DMA_CHIP_END_MASK_IMEM)] &= 0xF8;
    if (isFirst) {
        progBlocks[0].instruction[0][(5 ^
                                      C3_RCE_DMA_HOST_END_MASK ^
                                      C3_RCE_DMA_CHIP_END_MASK_IMEM)] |=
            _c3RCEOpcode_startProgram;
    } else {
        progBlocks[0].instruction[0][(5 ^
                                      C3_RCE_DMA_HOST_END_MASK ^
                                      C3_RCE_DMA_CHIP_END_MASK_IMEM)] |=
            _c3RCEOpcode_startFilter;
    }
    /*
     *  Write out the whole buffer, since we might be expanding the filter set,
     *  and we originally cleared the filter set (so all instructions were NOP)
     *  before reading in the current filter set image (to group size).
     */
    sal_dma_flush(progBlocks, imemPmemBytes);
    result = soc_mem_write_range(unitData->unit,
                                 IMEM_PMEM_DMAm,
                                 MEM_BLOCK_ANY,
                                 newImemStart << 5,
                                 ((newImemStart + size) << 5) - 1,
                                 progBlocks);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to write imem space for revised filter set"
                            " at %03X..%03X: %d (%s)\n"),
                   newImemStart,
                   newImemStart + size - 1,
                   result,
                   _SHR_ERRMSG(result)));
        goto error;
    }
    
    /* edit the end of filter set flag if needed */
    if (size != fsData->imemSize) {
        /*
         *  The chance of actually using this is so low that we're better off
         *  deferring the allocation of the memory -- it is unlikely we will
         *  ever see this situation, but it must be handled just in case.
         */
        imemBytes = sizeof(uint32) * soc_mem_entry_words(unitData->unit, IMEMm);
        imemTemp = sal_dma_alloc(imemBytes,
                                 "C3 RCE instruction memory workspace");
        if (!imemTemp) {
            result = SOC_E_MEMORY;
            goto error;
        }
        /* read new last block of instructions */
        sal_dma_flush(imemTemp, imemBytes);
        result = soc_mem_read(unitData->unit,
                              IMEMm,
                              MEM_BLOCK_ANY,
                              newImemStart + size - 1,
                              imemTemp);
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to read instruction block %03X:"
                                " %d (%s)\n"),
                       newImemStart + size - 1,
                       result,
                       _SHR_ERRMSG(result)));
            goto error;
        }
        sal_dma_inval(imemTemp, imemBytes);
        /* modify instructions to add 'endf' bit where appropriate */
        COMPILER_64_SET(mask, 0x00000080, 0x00000000);
        for (index = 0; index < C3_RCE_IMEM_INSTR_PER_BLOCK; index++) {
            soc_mem_field64_get(unitData->unit,
                                IMEMm,
                                imemTemp,
                                _soc_c3_imem_fields[index],
                                &instruction);
            opcode = (COMPILER_64_HI(instruction) >> 8) & 0x7;
            switch (opcode) {
            case _c3RCEOpcode_nop:
            case _c3RCEOpcode_data:
            case _c3RCEOpcode_match0:
            case _c3RCEOpcode_match1:
                /* these instructions contain the 'endf' bit */
                COMPILER_64_OR(instruction, mask);
                soc_mem_field64_set(unitData->unit,
                                    IMEMm,
                                    imemTemp,
                                    _soc_c3_imem_fields[index],
                                    instruction);
                break;
            default:
                /* other instructions do not */
                break;
            }
        } /* for (all instructions in an imem block) */
        /* write old last block of instructions back */
        sal_dma_flush(imemTemp, imemBytes);
        result = soc_mem_write(unitData->unit,
                               IMEMm,
                               MEM_BLOCK_ALL,
                               newImemStart + size - 1,
                               imemTemp);
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to write instruction block %03X:"
                                " %d (%s)\n"),
                       newImemStart + size - 1,
                       result,
                       _SHR_ERRMSG(result)));
            goto error;
        }
        /*
         *  If the filter set was longer than it is now, then we dropped a
         *  block of NOPs that were appended to pad it out, so we did not
         *  copy the final block with the 'endf' bit set.  We only need to
         *  remove the 'endf' bit if we made the filter set longer, so we can
         *  skip that in the reduced length case.
         */
        if (size > fsData->imemSize) {
            /* read old last block of instructions */
            sal_dma_flush(imemTemp, imemBytes);
            result = soc_mem_read(unitData->unit,
                                  IMEMm,
                                  MEM_BLOCK_ANY,
                                  newImemStart + fsData->imemSize - 1,
                                  imemTemp);
            if (SOC_E_NONE != result) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("unable to read instruction block %03X:"
                                    " %d (%s)\n"),
                           newImemStart + fsData->imemSize - 1,
                           result,
                           _SHR_ERRMSG(result)));
                goto error;
            }
            sal_dma_inval(imemTemp, imemBytes);
            /* modify instructions to remove 'endf' bit where appropriate */
            COMPILER_64_SET(mask, 0x0000077F, 0xFFFFFFFF);
            for (index = 0; index < C3_RCE_IMEM_INSTR_PER_BLOCK; index++) {
                soc_mem_field64_get(unitData->unit,
                                    IMEMm,
                                    imemTemp,
                                    _soc_c3_imem_fields[index],
                                    &instruction);
                opcode = (COMPILER_64_HI(instruction) >> 8) & 0x7;
                switch (opcode) {
                case _c3RCEOpcode_nop:
                case _c3RCEOpcode_data:
                case _c3RCEOpcode_match0:
                case _c3RCEOpcode_match1:
                    /* these instructions contain the 'endf' bit */
                    COMPILER_64_AND(instruction, mask);
                    soc_mem_field64_set(unitData->unit,
                                        IMEMm,
                                        imemTemp,
                                        _soc_c3_imem_fields[index],
                                        instruction);
                    break;
                default:
                    /* other instructions do not */
                    break;
                }
            } /* for (all instructions in an imem block) */
            /* write old last block of instructions back */
            sal_dma_flush(imemTemp, imemBytes);
            result = soc_mem_write(unitData->unit,
                                   IMEMm,
                                   MEM_BLOCK_ALL,
                                   newImemStart + fsData->imemSize - 1,
                                   imemTemp);
            if (SOC_E_NONE != result) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("unable to write instruction block %03X:"
                                    " %d (%s)\n"),
                           newImemStart + fsData->imemSize - 1,
                           result,
                           _SHR_ERRMSG(result)));
                goto error;
            }
        }
    } /* if (size != fsData->imemSize) */
    /* now update filter set descriptor to point to new copy */
    RCE_EVERB((RCE_MSG1("original filter set at %03X..%03X, revised"
                        " filter set at %03X..%03X\n"),
               fsData->imemStart,
               fsData->imemStart + fsData->imemSize - 1,
               newImemStart,
               newImemStart + size - 1));
    fsData->imemStart = newImemStart;
    fsData->imemSize = size;
    newImemStart = ~0;
error:
    if ((~0) != newImemStart) {
        auxRes = shr_mdb_free(unitData->imemRes, newImemStart);
    }
    if (imemTemp) {
        sal_dma_free(imemTemp);
    }
    if (progBlocks) {
        sal_dma_free(progBlocks);
    }
    return result;
}


/*
 *  Function
 *    _soc_c3_rce_filter_set_remove
 *  Purpose
 *    Remove a filter set from a program
 *  Arguments
 *    (IN) unitData = pointer to unit information
 *    (IN) groupId = group ID
 *    (IN) filterSet = which filter set in the group to remove
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    This removes a filter set from a program, both in the program's list of
 *    filter sets and in the hardware.
 *
 *    It will add padding blocks to ensure the program does not become shorter
 *    than 1024 instructions (128 instruction blocks).
 */
static int
_soc_c3_rce_filter_set_remove(_soc_c3_rce_unit_desc_int_t *unitData,
                              int groupId,
                              unsigned int filterSet)
{
    _soc_c3_rce_fset_range_info_t *rangeData; /* range description */
    _soc_c3_rce_program_desc_int_t *progData; /* program description */
    _soc_c3_rce_group_desc_int_t *groupData;  /* group description */
    _soc_c3_rce_filterset_desc_int_t *fsData = NULL; /* working fsets data */
    _soc_c3_rce_filterset_desc_int_t *fsTemp = NULL; /* working fsets data */
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
    uint64 *ctrTemp = NULL;                   /* counter read workspace */
    _soc_c3_rce_actions_desc_int_t *actData;  /* working action table info */
    _soc_c3_rce_counter_read_f ctrRead;       /* working counter read func */
    unsigned int ctrBase;                     /* working counter base index */
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
    unsigned int padImemStart = ~0;           /* padding imem start */
    unsigned int oldImemStart = ~0;           /* old second fset imem start */
    unsigned int newImemStart = ~0;           /* new first fset imem start */
    unsigned int oldImemSizeAdj = 0;          /* adjustment to imem size */
    unsigned int filterSetIndex;              /* which filter set in program */
    unsigned int finalProgSize;               /* final program size */
    unsigned int addedBlocks;                 /* added instruction blocks */
    unsigned int index;                       /* working index */
    int result = SOC_E_NONE;                  /* working result */
    int auxRes;                               /* spare result */

    groupData = unitData->groupData[groupId];
    progData = unitData->progData[groupData->rceProgram];
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
    if (groupData->groupFlags & _SOC_C3_RCE_GROUP_FLAG_COUNTER) {
        /*
         *  At least one result from this group refers in this program to an
         *  action table that includes action-indexed counters.
         */
        ctrTemp = sal_alloc(sizeof(*ctrTemp) * 4 *
                            C3_RCE_ENTRIES_PER_FILTER_SET,
                            "counter clearing workspace");
        if (!ctrTemp) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to allocate %u bytes for counter"
                       " manipulation workspace\n"),
                       (unsigned int)(sizeof(*ctrTemp) * 4 *
                       C3_RCE_ENTRIES_PER_FILTER_SET)));
            result = SOC_E_MEMORY;
            goto error;
        }
    } /* if (progData->ucData->ctrRead) */
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
    /* find the place in the program where this filter set occurs */
    result = _soc_c3_rce_filter_set_locate(unitData,
                                           progData,
                                           groupId,
                                           filterSet,
                                           &filterSetIndex);
    if (SOC_E_NONE != result) {
        /* called function displayed diagnostic */
        goto error;
    }
    /* build a new filter set list for the program, excluding this one */
    if (progData->filterSetCount > 1) {
        fsData = sal_alloc(sizeof(*fsData) * (progData->filterSetCount - 1),
                           "C3 RCE program filter set list");
        if (!fsData) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to allocate %u bytes for new filter"
                                " set list\n"),
                       (unsigned int)(sizeof(*fsData) *
                                      (progData->filterSetCount - 1))));
            result = SOC_E_MEMORY;
            goto error;
        }
        for (index = 0; index < filterSetIndex; index++) {
            fsData[index] = progData->fsetData[index];
        }
        for (index = filterSetIndex + 1;
             index < progData->filterSetCount;
             index++) {
            fsData[index - 1] = progData->fsetData[index];
        }
    } /* if (progData->filterSetCount > 1) */
    if ((0 == filterSetIndex) && (1 < progData->filterSetCount)) {
        /*
         *  The filter set to be removed is the initial filter set, and there
         *  is a second filter set, so the second filter set must be set up to
         *  be the first filter set.
         *
         *  In this mode, any size change will be an increase, since the first
         *  filter minimum length is greater than the minimum length for later
         *  filter sets.
         */
        oldImemSizeAdj = fsData[0].imemSize;
        oldImemStart = fsData[0].imemStart;
        result = _soc_c3_rce_filter_set_start_fix(unitData,
                                                  &(fsData[0]),
                                                  TRUE);
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to adjust second filter set to become"
                                " initial filter set: %d (%s)\n"),
                       result,
                       _SHR_ERRMSG(result)));
            goto error;
        }
        newImemStart = fsData[0].imemStart;
        oldImemSizeAdj = fsData[0].imemSize - oldImemSizeAdj;
    }
    RCE_EVERB((RCE_MSG1("removing unit %d program %u (%s) group %d filter"
                        " set %u\n"),
               unitData->unit,
               groupData->rceProgram,
               progData->ucData->programName,
               groupId,
               filterSet));
    /* figure out how big the program will be without this filter set */
    finalProgSize = (progData->instrBlockCount -
                     progData->fsetData[filterSetIndex].imemSize +
                     oldImemSizeAdj);
    /* decide on how much padding is needed based upon the new size */
    _soc_c3_rce_program_padding_length_calc(unitData,
                                            finalProgSize,
                                            &addedBlocks,
                                            &padImemStart);
    /*
     *  It is possible that we need to increase the padding on a program before
     *  we can remove a filter set, in order to satisfy constraints.  This
     *  means that there could be a temporary increase in the size of the
     *  program while the removal is going on, and possibly some permanent
     *  growth because of the granularity of the padding blocks.
     */
    result = _soc_c3_rce_program_length_check(unitData,
                                              SOC_C3_RCE_PROGRAM_LENGTH_CHECK_TRANSIENT |
                                              SOC_C3_RCE_PROGRAM_LENGTH_CHECK_PADDING,
                                              groupData->rceProgram,
                                              0 /* program adjustment */,
                                              addedBlocks);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d program %u padding can not be expanded in"
                   " anticipation of removing a filter set from group"
                   " %d (%u instruction blocks)\n"),
                   unitData->unit,
                   groupData->rceProgram,
                   groupData->groupId,
                   addedBlocks));
        goto error;
    }
    result = _soc_c3_rce_program_length_check(unitData,
                                              SOC_C3_RCE_PROGRAM_LENGTH_CHECK_PADDING,
                                              groupData->rceProgram,
                                              oldImemSizeAdj - progData->fsetData[filterSetIndex].imemSize,
                                              addedBlocks);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d program %u can not remove a filter set"
                   " from group %d because the change in required padding"
                   " would make the program run too long\n"),
                   unitData->unit,
                   groupData->rceProgram,
                   groupData->groupId));
        goto error;
    }
    /* ensure that padding length is correct: update final remaining set */
    result = _soc_c3_rce_filter_set_start_update(unitData,
                                                 groupData->rceProgram,
                                                 fsData,
                                                 ((int)(progData->filterSetCount - 1)) - 1,
                                                 padImemStart);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to adjust final padding block for"
                   " unit %d program %d (%s): %d (%s)\n"),
                   unitData->unit,
                   groupData->rceProgram,
                   progData->ucData->programName,
                   result,
                   _SHR_ERRMSG(result)));
        goto error;
    }
    /* account for the padding */
    unitData->instrBlockCount = ((unitData->instrBlockCount -
                                  progData->instrBlockAdded) +
                                 addedBlocks);
    progData->instrBlockAdded = addedBlocks;
    /* remove the selected filter set if we did not already do it */
    if ((filterSetIndex + 1) < progData->filterSetCount) {
        /* filter set to remove was not last position; unlink it now */
        result = _soc_c3_rce_filter_set_start_update(unitData,
                                                     groupData->rceProgram,
                                                     fsData,
                                                     ((int)(filterSetIndex)) - 1,
                                                     fsData[filterSetIndex].imemStart);
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to remove unit %d group %d filter set"
                       " %u from program %u (%s): %d (%s)\n"),
                       unitData->unit,
                       groupId,
                       filterSet,
                       groupData->rceProgram,
                       progData->ucData->programName,
                       result,
                       _SHR_ERRMSG(result)));
            goto error;
        }
    }
    /* account for removal of this filter set */
    unitData->instrBlockCount -= progData->fsetData[filterSetIndex].imemSize;
    unitData->instrBlockCount += oldImemSizeAdj;
    /* adjust program filter set count and instruction block count */
    progData->filterSetCount--;
    progData->instrBlockCount -= progData->fsetData[filterSetIndex].imemSize;
    progData->instrBlockCount += oldImemSizeAdj;
    /* replace program filter set list with the new one */
    fsTemp = progData->fsetData;
    progData->fsetData = fsData;
    fsData = NULL;
    /* adjust group filter set count */
    groupData->filterSetCount--;
    /* adjust range references from this filter set if anything left over */
    for (index = 0; index < groupData->rangesPerFilterSet; index++) {
        rangeData = &(fsTemp[filterSetIndex].rangeInfo[index]);
        if (rangeData->rangeId) {
            (unitData->rangeData[rangeData->rangeId - 1]->refCount)--;
        } /* if (this range slot is in use) */
    } /* for (all range slots this filter set) */
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
    if (ctrTemp) {
        for (index = 0;
             index < SOC_C3_RCE_RESULT_REGISTER_COUNT;
             index++) {
            if (0 == (groupData->resultLrpUniq & (1 << index))) {
                /* not using this result register */
                continue;
            }
            actData = unitData->actData[progData->actIndex[index]];
            if (!(ctrRead = actData->ucData->ctrRead)) {
                /* this action table does not use action-indexed counters  */
                continue;
            }
            ctrBase = ((fsTemp[filterSetIndex].amemBlock * 2 *
                        C3_RCE_ENTRIES_PER_FILTER_SET) +
                       actData->firstEntryBias);
            auxRes = ctrRead(unitData->unit,
                             ctrBase,
                             (C3_RCE_ENTRIES_PER_FILTER_SET * 2) - 1,
                             TRUE /* read and clear */,
                             ctrTemp);
            if (SOC_E_NONE != auxRes) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("unable to clear action table %u (%s)"
                           " counter space (%s) %u..%u for removed"
                           " filter set %u: %d (%s)\n"),
                           progData->actIndex[index],
                           actData->ucData->tableName,
                           actData->ucData->ctrName,
                           ctrBase,
                           ctrBase + ((C3_RCE_ENTRIES_PER_FILTER_SET * 2) - 1),
                           filterSetIndex,
                           auxRes,
                           _SHR_ERRMSG(auxRes)));
                /* consider it an error since it is important */
                result = auxRes;
            } /* if (SOC_E_NONE != auxRes) */
        } /* for (all possible result registers) */
    } /* if (ctrTemp) */
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
    /* dispose of the removed filter set's imem and amem blocks */
    for (index = 0;
         index < SOC_C3_RCE_RESULT_REGISTER_COUNT;
         index++) {
        if (groupData->resultLrpUniq & (1 << index)) {
            auxRes = shr_mres_free(unitData->amemRes,
                                   progData->actIndex[index],
                                   1 /* one amem block */,
                                   fsTemp[filterSetIndex].amemBlock);
            if (SOC_E_NONE != auxRes) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("unit %d unable to free program"
                           " %u result %u disused action"
                           " table %u (%s) block %u :"
                           " %d (%s)\n"),
                           unitData->unit,
                           groupData->rceProgram,
                           index,
                           progData->actIndex[index],
                           unitData->actData[progData->actIndex[index]]->ucData->tableName,
                           fsTemp[filterSetIndex].amemBlock,
                           auxRes,
                           _SHR_ERRMSG(auxRes)));
                /* but do not return as error */
            } else {
                unitData->actData[progData->actIndex[index]]->entryActive--;
            }
        } /* if (group uses this result register) */
    } /* for (all possible result registers) */
    auxRes = shr_mdb_free(unitData->imemRes,
                          fsTemp[filterSetIndex].imemStart);
    if (SOC_E_NONE != auxRes) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to free old instruction memory"
                   " blocks after removal: %d (%s)\n"),
                   auxRes,
                   _SHR_ERRMSG(auxRes)));
        /* but do not return as error since the remove has been committed */
    } else {
        unitData->imemBlockCount--;
    }
    /* get rid of the ranges list for this filter set */
    if (fsTemp[filterSetIndex].rangeInfo) {
        sal_free(fsTemp[filterSetIndex].rangeInfo);
    }
    if ((~0) != oldImemStart) {
        auxRes = shr_mdb_free(unitData->imemRes, oldImemStart);
        if (SOC_E_NONE != auxRes) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to free old instruction memory"
                                " blocks after removal: %d (%s)\n"),
                       auxRes,
                       _SHR_ERRMSG(auxRes)));
            /* but do not return as error since the remove has been committed */
        }
        oldImemStart = ~0;
        newImemStart = ~0;
    }
error:
    /* release working resources */
    if ((~0) != newImemStart) {
        /* rewrote second filter set as initial but aborted */
        auxRes = shr_mdb_free(unitData->imemRes, newImemStart);
        if (SOC_E_NONE != auxRes) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to free temporary instruction memory"
                                " blocks after abort: %d (%s)\n"),
                       auxRes,
                       _SHR_ERRMSG(auxRes)));
            /* but do not clobber error since another error has occurred */
        }
    }
    if (fsTemp) {
        sal_free(fsTemp);
    }
    if (fsData) {
        sal_free(fsData);
    }
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
    if (ctrTemp) {
        sal_free(ctrTemp);
    }
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_filter_set_add
 *  Purpose
 *    Add a filter set to a program
 *  Arguments
 *    (IN) unitData = pointer to unit information
 *    (IN) groupId = group ID
 *    (IN) filterSet = which filter set in the group to add
 *    (IN) programFilterSet = index for new filter set in program filter sets
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    This adds a filter set to the program in the place the caller asserts it
 *    should go.  Basically, if programFilterSet = 0, this adds the filter set
 *    to the program as the initial filter set in the program; if
 *    programFilterSet = 1, the one after the initial, and so on.  If
 *    programFilterSet is equal to or greater than than the number of filter
 *    sets in the program, this will add the new filter set to the end of the
 *    program.
 *
 *    It is an error (SOC_E_CONFIG) to try to add a filter set that would
 *    increase the total size of all programs to something that would take too
 *    long to run based upon the epoch size and other applicable parameters
 *    (such as whether the LRP microcode is performing at least two switches).
 *
 *    If a program is < 128 instruction blocks long, the padding will remain in
 *    place until after the new filter set has been added.  It will then be
 *    reduced according to the new program length.  It is possible that, if
 *    there is more than one program in use, this will make the total too long;
 *    if this happens, it is still considered an error, since we can not safely
 *    reduce the padding length until after the new filter set is in place.
 */
static int
_soc_c3_rce_filter_set_add(_soc_c3_rce_unit_desc_int_t *unitData,
                           int groupId,
                           unsigned int filterSet,
                           unsigned int programFilterSet)
{
    _soc_c3_rce_program_desc_int_t *progData; /* program description */
    _soc_c3_rce_group_desc_int_t *groupData;  /* working group data */
    _soc_c3_rce_entry_desc_int_t *entryHead;  /* first entry in filter set */
    _soc_c3_rce_filterset_desc_int_t fsData;  /* working fsets data */
    _soc_c3_rce_filterset_desc_int_t *fsTemp = NULL; /* working fsets data */
    unsigned int imemStart = ~0;              /* next filter set imem start */
    unsigned int oldImemStart = ~0;           /* old start of initial fset */
    unsigned int oldImemDiff = 0;             /* size diff now - old */
    unsigned int newImemStart = ~0;           /* new start of initial fset */
    unsigned int index;                       /* working index */
    unsigned int filterSetBase;               /* group filter set min posn */
    unsigned int filterSetLimit;              /* group filter set max posn */
    unsigned int addedBlocks;                 /* padding blocks added */
    int result = SOC_E_NONE;                  /* working result */
    int auxRes;                               /* spare result */

    sal_memset(&(fsData), 0x00, sizeof(fsData));
    fsData.amemBlock = ~0;
    fsData.imemStart = ~0;
    fsData.groupId = groupId;
    fsData.filterIndex = filterSet;
    groupData = unitData->groupData[groupId];
    progData = unitData->progData[groupData->rceProgram];
    if (groupData->maxFilterSets &&
        (groupData->filterSetCount >= groupData->maxFilterSets)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d group %d specifically limited to %u filter"
                   " sets and already has %u filter sets\n"),
                   unitData->unit,
                   groupData->groupId,
                   groupData->maxFilterSets,
                   groupData->filterSetCount));
        result = SOC_E_FULL;
        goto error;
    }
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
    if (groupData->groupFlags & _SOC_C3_RCE_GROUP_FLAG_COUNTER) {
        fsData.fsetFlags = _SOC_C3_RCE_FSET_FLAGS_COUNTER;
    } else {
        fsData.fsetFlags = 0;
    }
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
    for (index = 0; index < SOC_C3_RCE_RESULT_REGISTER_COUNT; index++) {
        if (groupData->resultLrpUniq & (1 << index)) {
            if (unitData->actData[progData->actIndex[index]]->entryActive >=
                unitData->actData[progData->actIndex[index]]->entryLimit) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("unit %d program %u (%s) result %u action"
                           " table %u (%s) has no additional space"
                           " available\n"),
                           unitData->unit,
                           groupData->rceProgram,
                           progData->ucData->programName,
                           index,
                           progData->actIndex[index],
                           unitData->actData[progData->actIndex[index]]->ucData->tableName));
                result = SOC_E_RESOURCE;
                goto error;
            } /* if (this result register's action table is full) */
        } /* if (group uses this result register) */
    } /* for (all possible result registers) */
    /* make sure group has the specified filter set */
    if (filterSet > groupData->filterSetCount) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to find unit %d group %d set %u\n"),
                   unitData->unit,
                   groupId,
                   filterSet));
        result = SOC_E_NOT_FOUND;
        goto error;
    }
    /* make sure insertion point is reasonable */
    if (programFilterSet > progData->filterSetCount) {
        /* past the end of the program; add it as last */
        programFilterSet = progData->filterSetCount;
    }
    /* figure out what another block adds to this program */
    _soc_c3_rce_filter_set_length(groupData->instrBlocks,
                                  programFilterSet,
                                  &(fsData.imemSize));
    RCE_EVERB((RCE_MSG1("unit %d group %d filter set length %u, current"
                        " total program length %u\n"),
               unitData->unit,
               groupId,
               fsData.imemSize,
               unitData->instrBlockCount));
    /* allocate a new set of filter set data */
    fsTemp = sal_alloc(sizeof(*fsTemp) * (progData->filterSetCount + 1),
                       "C3 RCE program filter set list");
    if (!fsTemp) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %u bytes for new filter set"
                   " list\n"),
                   (unsigned int)(sizeof(*fsTemp) *
                   (progData->filterSetCount + 1))));
        result = SOC_E_MEMORY;
        goto error;
    }
    /* set up new filter set's range list */
    if (groupData->rangesPerFilterSet) {
        /* allocate range list for the new filter set */
        fsData.rangeInfo = sal_alloc(sizeof(*(fsData.rangeInfo)) *
                                 groupData->rangesPerFilterSet,
                                 "C3 RCE filter set range list");
        if (!fsData.rangeInfo) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to allocate %u bytes for new filter set"
                       " list of ranges\n"),
                       (unsigned int)(sizeof(*(fsData.rangeInfo)) *
                       groupData->rangesPerFilterSet)));
            result = SOC_E_MEMORY;
            goto error;
        }
        sal_memset(fsData.rangeInfo,
                   0x00,
                   sizeof(*(fsData.rangeInfo)) * groupData->rangesPerFilterSet);
    } /* if (groupData->rangesPerFilterSet) */
    /* copy old fset list to new fset list, with a gap for the new fset */
    for (index = 0; index < programFilterSet; index++) {
        fsTemp[index] = progData->fsetData[index];
        if ((fsTemp[index].groupId == groupId) &&
            (fsTemp[index].filterIndex >= filterSet)) {
            /* need to adjust this filter set index within the group */
            fsTemp[index].filterIndex++;
        }
    }
    for (index = programFilterSet; index < progData->filterSetCount; index++) {
        fsTemp[index + 1] = progData->fsetData[index];
        if ((fsTemp[index + 1].groupId == groupId) &&
            (fsTemp[index + 1].filterIndex >= filterSet)) {
            /* need to adjust this filter set index within the group */
            fsTemp[index + 1].filterIndex++;
        }
    }
    if ((0 == programFilterSet) && (0 < progData->filterSetCount)) {
        RCE_EVERB((RCE_MSG1("new filter set as initial; need to edit"
                            " existing intial filter set at %03X..%03X so"
                            " it begins with startFilter instruction\n"),
                   fsTemp[1].imemStart,
                   fsTemp[1].imemStart + fsTemp[1].imemSize - 1));
        /*
         *  Old initial fset is moving to later; adjust it.  In this direction,
         *  size changes will be downward.
         */
        oldImemStart = fsTemp[1].imemStart;
        oldImemDiff = fsTemp[1].imemSize;
        result = _soc_c3_rce_filter_set_start_fix(unitData,
                                                  &(fsTemp[1]),
                                                  FALSE);
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to adjust initial filter set to become"
                                " later filter set: %d (%s)\n"),
                       result,
                       _SHR_ERRMSG(result)));
            goto error;
        }
        newImemStart = fsTemp[1].imemStart;
        oldImemDiff -= fsTemp[1].imemSize;
    } /* if (progData->filterSetCount) */
    /* figure out where the next pointer needs to point */
    if (progData->filterSetCount > programFilterSet) {
        /* use start of the next filter set in the program as next pointer */
        imemStart = fsTemp[programFilterSet + 1].imemStart;
        addedBlocks = 0;
    } else { /* if (progData->filterSetCount > programFilterSet) */
        /* adding to the end of the program; use the padding */
        _soc_c3_rce_program_padding_length_calc(unitData,
                                                progData->instrBlockCount +
                                                fsData.imemSize -
                                                oldImemDiff,
                                                &addedBlocks,
                                                &imemStart);
    } /* if (progData->filterSetCount > programFilterSet) */
    /* make sure final state fits within timing constraints */
    result = _soc_c3_rce_program_length_check(unitData,
                                              SOC_C3_RCE_PROGRAM_LENGTH_CHECK_PADDING,
                                              groupData->rceProgram,
                                              fsData.imemSize - oldImemDiff,
                                              addedBlocks);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d program %u can not be expanded by a filter"
                            " set from group %d (%u instruction blocks)\n"),
                   unitData->unit,
                   groupData->rceProgram,
                   groupData->groupId,
                   fsData.imemSize));
        goto error;
    }
    /* make sure transient state fits within timing constraints */
    result = _soc_c3_rce_program_length_check(unitData,
                                              SOC_C3_RCE_PROGRAM_LENGTH_CHECK_TRANSIENT,
                                              groupData->rceProgram,
                                              fsData.imemSize - oldImemDiff,
                                              0 /* replacement padding */);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d program %u can not be expanded by a filter"
                            " set from group %d (%u instruction blocks) while"
                            " waiting for padding to be removed\n"),
                   unitData->unit,
                   groupData->rceProgram,
                   groupData->groupId,
                   fsData.imemSize));
        goto error;
    }
    /* find the first entry in this filter set */
    filterSetBase = filterSet * C3_RCE_ENTRIES_PER_FILTER_SET;
    filterSetLimit = filterSetBase + (C3_RCE_ENTRIES_PER_FILTER_SET - 1);
    for (entryHead = groupData->entryHead;
         entryHead && (entryHead->entryPosition < filterSetBase);
         entryHead = entryHead->entryNext) {
        /*
         *  This loop iterates until it either falls off the group end or finds
         *  the first entry whose position places it in the desired filter set,
         *  or possibly later, within the group
         */
    }
    if (entryHead && (entryHead->entryPosition > filterSetLimit)) {
        /* but this entry is after this filter set, so we don't want it */
        entryHead = NULL;
    }
    /* build the new instruction/pattern blocks and action block */
    result = _soc_c3_rce_filter_set_build(unitData,
                                          groupData,
                                          (0 == programFilterSet),
                                          entryHead,
                                          filterSetBase,
                                          filterSetLimit,
                                          imemStart,
                                          &fsData);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to build unit %d group %d filter set %u"
                   " instructions/patterns/actions: %d (%s)\n"),
                   unitData->unit,
                   groupId,
                   filterSet,
                   result,
                   _SHR_ERRMSG(result)));
        fsData.imemStart = ~0;
        fsData.amemBlock = ~0;
        goto error;
    }
    /* update the proposed new program filter set list */
    fsTemp[programFilterSet] = fsData;
    /* link this new code into the program */
    result = _soc_c3_rce_filter_set_start_update(unitData,
                                                 groupData->rceProgram,
                                                 fsTemp,
                                                 ((int)(programFilterSet)) - 1,
                                                 fsData.imemStart);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to link unit %d group %d filter set %u into"
                   " program %u (%s): %d (%s)\n"),
                   unitData->unit,
                   groupId,
                   filterSet,
                   groupData->rceProgram,
                   progData->ucData->programName,
                   result,
                   _SHR_ERRMSG(result)));
        goto error;
    }
    /* can't back out after this point */
    if (0 == programFilterSet) {
        /* clean up from replacement of former initial filter set */
        if ((~0) != oldImemStart) {
            auxRes = shr_mdb_free(unitData->imemRes,
                                  oldImemStart);
            if (SOC_E_NONE != auxRes) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("unable to free prior initial filter set"
                                    " block in imem %03X..%03X: %d (%s)\n"),
                           oldImemStart,
                           oldImemStart + fsTemp[1].imemSize - 1,
                           result,
                           _SHR_ERRMSG(result)));
            }
        }
        oldImemStart = ~0;
        newImemStart = ~0;
    }
    /* account for the new filter set being linked into the program */
    sal_free(progData->fsetData);
    progData->fsetData = fsTemp;
    fsTemp = NULL;
    if (progData->filterSetCount > programFilterSet) {
        /* not last filter set, so no change to added blocks yet */
        unitData->instrBlockCount += fsData.imemSize - oldImemDiff;
    } else {
        /* last filter set, update added blocks */
        unitData->instrBlockCount = (unitData->instrBlockCount -
                                     progData->instrBlockAdded +
                                     addedBlocks +
                                     fsData.imemSize -
                                     oldImemDiff);
        progData->instrBlockAdded = addedBlocks;
    }
    progData->instrBlockCount += fsData.imemSize - oldImemDiff;
    progData->filterSetCount++;
    groupData->filterSetCount++;
    /* reduce the padding used by the program, if applicable */
    if (progData->instrBlockAdded) {
        /* program was using padding before; probably should reduce it */
        _soc_c3_rce_program_padding_length_calc(unitData,
                                                progData->instrBlockCount,
                                                &addedBlocks,
                                                &imemStart);
        auxRes = _soc_c3_rce_filter_set_start_update(unitData,
                                                     groupData->rceProgram,
                                                     progData->fsetData,
                                                     ((int)(progData->filterSetCount)) - 1,
                                                     imemStart);
        if (SOC_E_NONE == auxRes) {
            /* successfully removed (some) padding from the program */
            unitData->instrBlockCount = (unitData->instrBlockCount -
                                         progData->instrBlockAdded +
                                         addedBlocks);
            progData->instrBlockAdded = addedBlocks;
        } else {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to adjust final padding block for"
                       " unit %d program %u (%s): %d (%s)\n"),
                       unitData->unit,
                       groupData->rceProgram,
                       progData->ucData->programName,
                       result,
                       _SHR_ERRMSG(result)));
            /* not to be reported as error adding filter set */
        }
    } /* if (progData->instrBlockAdded) */
error:
    if (SOC_E_NONE != result) {
        /* something went wrong; free new resources */
        if ((~0) != fsData.imemStart) {
            auxRes = shr_mdb_free(unitData->imemRes, fsData.imemStart);
            if (SOC_E_NONE != auxRes) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("unable to free new instruction memory"
                           " blocks after error: %d (%s)\n"),
                           auxRes,
                           _SHR_ERRMSG(auxRes)));
                /* but do not return as error */
            } else {
                unitData->imemBlockCount--;
            }
        }
        if ((~0) != fsData.amemBlock) {
            for (index = 0;
                 index < SOC_C3_RCE_RESULT_REGISTER_COUNT;
                 index++) {
                if (groupData->resultLrpUniq & (1 << index)) {
                    auxRes = shr_mres_free(unitData->amemRes,
                                           progData->actIndex[index],
                                           1 /* one amem block */,
                                           fsData.amemBlock);
                    if (SOC_E_NONE != auxRes) {
                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                  (BSL_META("unit %d unable to free program"
                                   " %u result %u unused action"
                                   " table %u (%s) block %u:"
                                   " %d (%s)\n"),
                                   unitData->unit,
                                   groupData->rceProgram,
                                   index,
                                   progData->actIndex[index],
                                   unitData->actData[progData->actIndex[index]]->ucData->tableName,
                                   fsData.amemBlock,
                                   auxRes,
                                   _SHR_ERRMSG(auxRes)));
                        /* but do not return as error */
                    } else {
                        unitData->actData[progData->actIndex[index]]->entryActive--;
                    }
                } /* if (group uses this result register) */
            } /* for (all possible result registers) */
        } /* if ((~0) != fsData.amemBlock) */
        if ((~0) != newImemStart) {
            auxRes = shr_mdb_free(unitData->imemRes, newImemStart);
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to free new instruction memory"
                                " blocks after error: %d (%s)\n"),
                       auxRes,
                       _SHR_ERRMSG(auxRes)));
            /* but do not return as error */
        }
        if (fsData.rangeInfo) {
            sal_free(fsData.rangeInfo);
        }
    } /* if (SOC_E_NONE != result) */
    if (fsTemp) {
        sal_free(fsTemp);
    }
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_entry_qualify_range_traverse
 *  Purpose
 *    Call provided callback function once for every range that is applicable
 *    for the specified entry.
 *  Arguments
 *    (IN) unitData = pointer to unit information
 *    (IN) entryId = entry ID
 *    (IN) callback = pointer to callback function
 *    (IN) extras = pointer to caller's additional data
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if range was found or added successfully
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    If the callback returns anything other than SOC_E_NONE, the traversal is
 *    aborted and this function will return that result.
 */
static int
_soc_c3_rce_entry_qualify_range_traverse(_soc_c3_rce_unit_desc_int_t *unitData,
                                         int entryId,
                                         soc_c3_rce_entry_qualify_range_traverse_cb_t callback,
                                         void *extras)
{
    _soc_c3_rce_entry_desc_int_t *entryData;
    _soc_c3_rce_group_desc_int_t *groupData;
    _soc_c3_rce_program_desc_int_t *progData;
    _soc_c3_rce_filterset_desc_int_t *fsetData;
    unsigned int filterSet;
    unsigned int index;
    int result;

    entryData = unitData->entryData[entryId];
    groupData = unitData->groupData[entryData->entryGroup];
    progData = unitData->progData[groupData->rceProgram];
    result = _soc_c3_rce_filter_set_locate(unitData,
                                           progData,
                                           entryData->entryGroup,
                                           entryData->entryPosition /
                                           C3_RCE_ENTRIES_PER_FILTER_SET,
                                           &filterSet);
    if (SOC_E_NONE != result) {
        /* called function displayed diagnostic */
        goto error;
    }
    fsetData = &(progData->fsetData[filterSet]);
    for (index = 1; index <= groupData->rangesPerFilterSet; index++) {
        if (entryData->pattData[0][index >> 3] & (1 << (index & 7))) {
            result = callback(unitData->unit,
                              groupData->rceProgram,
                              groupData->groupId,
                              entryId,
                              fsetData->rangeInfo[index - 1].rangeId,
                              (fsetData->rangeInfo[index - 1].rangeFlags &
                               SOC_C3_RCE_RANGE_FLAG_INVERT)?-1:1,
                              extras);
            if (SOC_E_NONE != result) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("callback returned %d (%s)\n"),
                           result,
                           _SHR_ERRMSG(result)));
            }
        } /* if (this entry uses this range reference) */
    } /* for (all possible range references this filter set) */
error:
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_filter_set_range_find
 *  Purpose
 *    Searches for a range in a given filter set (based upon the group and
 *    filter set index within that group)
 *  Arguments
 *    (IN) unitData = pointer to unit information
 *    (IN) rangesPerFilterSet = ranges per filter set
 *    (IN) rangeData = pointer to range information
 *    (IN) rangeId = which range ID to locate
 *    (IN) invert = zero if range is not inverted, else range is inverted
 *    (OUT) offset = where to put offset in filter set for range
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if range was found
 *      SOC_E_RESOURCE if range was not found and no free slot
 *      SOC_E_EMPTY (and offset is first free slot) if not found
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    The offset returned is the instruction within the filter set (including
 *    the start instruction) so will be 1..(groupData->rangesPerFilterSet).
 */
static int
_soc_c3_rce_filter_set_range_find(_soc_c3_rce_unit_desc_int_t *unitData,
                                  unsigned int rangesPerFilterSet,
                                  _soc_c3_rce_fset_range_info_t *rangeData,
                                  int rangeId,
                                  int invert,
                                  unsigned int *offset)
{
    uint16 flags = 0;
    unsigned int index;
    unsigned int free;

    if (invert) {
        flags |= SOC_C3_RCE_RANGE_FLAG_INVERT;
    }
    for (index = 0, free = rangesPerFilterSet;
         index < rangesPerFilterSet;
         index++) {
        if ((rangeId == rangeData[index].rangeId) &&
            (flags == (rangeData[index].rangeFlags &
                       SOC_C3_RCE_RANGE_FLAG_INVERT))) {
            /* this is the desired range and inversion */
            break;
        }
        if ((0 == rangeData[index].rangeId) &&
            (free >= rangesPerFilterSet)) {
            /* this range slot is free */
            free = index;
        }
    } /* for (all range slots in this filter set) */
    if (index < rangesPerFilterSet) {
        /* found the desired range + invert reference */
        *offset = index + 1;
        return SOC_E_NONE;
    } else if (free < rangesPerFilterSet) {
        /* found a free slot */
        *offset = free + 1;
        return SOC_E_EMPTY;
    } else {
        /* did not find requested range or free slot */
        return SOC_E_RESOURCE;
    }
}

/*
 *  Function
 *    _soc_c3_rce_filter_set_range_add
 *  Purpose
 *    Return the instruction in the filter set that applies to a specific range
 *    and inversion setting.  If there is no reference to that range with that
 *    inversion setting in the filter set, add it.
 *  Arguments
 *    (IN) unitData = pointer to unit information
 *    (IN) fsetData = pointer to filter set information
 *    (IN) rangeId = the range ID
 *    (IN) invert = whether range should be inverted
 *    (OUT) offset = where to put offset in filter set for range
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if range was found or added successfully
 *      SOC_E_RESOURCE if the range could not be found or added
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    The offset accepted is the instruction within the filter set, so the
 *    valid range is 1..(groupData->rangesPerFilterSet).
 *
 *    This will increment the reference count for the range if it adds it.
 */
static int
_soc_c3_rce_filter_set_range_add(_soc_c3_rce_unit_desc_int_t *unitData,
                                 _soc_c3_rce_filterset_desc_int_t *fsetData,
                                 int rangeId,
                                 int invert,
                                 unsigned int *offset)
{
    soc_c3_rce_header_field_info_t headerField; /* copy of range's hdrfield */
    soc_c3_rce_qual_desc_t *qualData = NULL;  /* qualifier workspace */
    _soc_c3_rce_range_desc_int_t *rangeData;
    _soc_c3_rce_group_desc_int_t *groupData;
    _soc_c3_rce_fset_range_info_t *rangeLocal;
    uint16 upper;                             /* upper bound (adjusted) */
    uint16 lower;                             /* lower bound (adjusted) */
    int rangeInvert;                          /* whether to invert range */
    unsigned int instrNum;                    /* which instruction in fset */
    int result;

    rangeData = unitData->rangeData[rangeId - 1];
    groupData = unitData->groupData[fsetData->groupId];
    if (0 == ((1 << groupData->rceProgram) & rangeData->validProgs)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d range %d is not valid for group %d"
                   " of program %u (%s)\n"),
                   unitData->unit,
                   rangeId,
                   fsetData->groupId,
                   groupData->rceProgram,
                   unitData->progData[groupData->rceProgram]->ucData->programName));
        result = SOC_E_CONFIG;
        goto error;
    }
    result = _soc_c3_rce_filter_set_range_find(unitData,
                                               groupData->rangesPerFilterSet,
                                               fsetData->rangeInfo,
                                               rangeId,
                                               invert,
                                               &instrNum);
    if (SOC_E_EMPTY == result) {
        /* need to add the range to the filter set and have space to do so */
        /* build new range compare instruction */
        upper = rangeData->upperBound;
        lower = rangeData->lowerBound;
        if (rangeData->headerField.numBits < 16) {
            lower <<= (16 - rangeData->headerField.numBits);
            upper <<= (16 - rangeData->headerField.numBits);
            upper |= ((1 << (16 - rangeData->headerField.numBits)) - 1);
        }
        /* figure out where the range to be compared is in the key */
        sal_memcpy(&headerField,
                   &(rangeData->headerField),
                   sizeof(headerField));
        result = _soc_c3_rce_program_qualifier_build(unitData,
                                                     groupData->rceProgram,
                                                     &headerField,
                                                     socC3RCEQualType_exact,
                                                     &qualData);
        if (SOC_E_NONE != result) {
            /* we should not see this but check anyway */
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unit %d group %d of program %u (%s) can not use"
                       " range %d due to inability to build qualifier"
                       " spec: %d (%s)\n"),
                       unitData->unit,
                       fsetData->groupId,
                       groupData->rceProgram,
                       unitData->progData[groupData->rceProgram]->ucData->programName,
                       rangeId,
                       result,
                       _SHR_ERRMSG(result)));
            goto error;
        }
        if (socC3RCEQualType_exact != qualData->qualType) {
            /* we should not see this but check anyway */
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unit %d group %d of program %u (%s) can not use"
                       " range %d becuase building a qualifier changed"
                       " the comparison mode unexpectedly\n"),
                       unitData->unit,
                       fsetData->groupId,
                       groupData->rceProgram,
                       unitData->progData[groupData->rceProgram]->ucData->programName,
                       rangeId));
            result = SOC_E_CONFIG;
            goto error;
        }
        if (2 != qualData->paramCount) {
            /* we should not see this but check anyway */
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unit %d group %d of program %u (%s) can not use"
                       " range %d because the bits to compare are not"
                       " in a single block\n"),
                       unitData->unit,
                       fsetData->groupId,
                       groupData->rceProgram,
                       unitData->progData[groupData->rceProgram]->ucData->programName,
                       rangeId));
            result = SOC_E_CONFIG;
            goto error;
        }
        if (15 != (qualData->param[1] & 15)) {
            /* we should not see this but check anyway */
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unit %d group %d of program %u (%s) can not use"
                       " range %d because it is not left aligned to a"
                       " 16-bit segment of the key\n"),
                       unitData->unit,
                       fsetData->groupId,
                       groupData->rceProgram,
                       unitData->progData[groupData->rceProgram]->ucData->programName,
                       rangeId));
            result = SOC_E_CONFIG;
            goto error;
        }
        /* decide how to match the range, based upon inversion settings */
        if (SOC_C3_RCE_RANGE_FLAG_INVERT & rangeData->rangeFlags) {
            /* range was inverted at creation; invert the invert flag */
            rangeInvert = !invert;
        } else { /* if (range was inverted as created) */
            /* range was normal at creation; keep the invert flag as-is */
            rangeInvert = invert;
        } /* if (range was inverted as created) */
        /* update the filter set information to include the new range */
        rangeLocal = &(fsetData->rangeInfo[instrNum - 1]);
        sal_memset(rangeLocal, 0x00, sizeof(*rangeLocal));
        rangeLocal->rangeId = rangeId;
        /* indicate which opcode is needed (match1 or match0) */
        if (rangeInvert) {
            rangeLocal->rangeFlags |= _SOC_C3_RCE_RANGE_FLAG_MATCH_INVERTED;
        }
        /* keep track of the boundaries */
        rangeLocal->lowerLimit = rangeData->lowerBound;
        rangeLocal->upperLimit = rangeData->upperBound;
        if (rangeData->headerField.numBits < 16) {
            /* need to adjust the numbers so the values are left-justified */
            rangeInvert = 16 - rangeData->headerField.numBits;
            rangeLocal->lowerLimit <<= rangeInvert;
            rangeLocal->upperLimit <<= rangeInvert;
            rangeLocal->upperLimit |= ((1 << rangeInvert) - 1);
        }
        /* keep track of reference invert status for dumps */
        if (invert) {
            rangeLocal->rangeFlags |= SOC_C3_RCE_RANGE_FLAG_INVERT;
        }
        /* keep track of the 'word' field of the opcode */
        rangeLocal->rangeFlags |= ((qualData->param[0] & 0x1F0) <<
                                   (_SOC_C3_RCE_RANGE_FLAG_WORD_SHIFT - 4));
        /* account for this filter set referring to this range */
        rangeData->refCount++;
        /* do not adjust the reference count in the fset; caller does that */
#if defined(BROADCOM_DEBUG)
    } else if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d group %d filter set %u unable to add range"
                   " reference for range %d %s: %d (%s)\n"),
                   unitData->unit,
                   fsetData->groupId,
                   fsetData->filterIndex,
                   rangeId,
                   invert?"invert":"normal",
                   result,
                   _SHR_ERRMSG(result)));
#endif /* defined(BROADCOM_DEBUG) */
    }
error:
    if (qualData) {
        soc_c3_rce_program_qualifier_free(unitData->unit, qualData);
        qualData = NULL;
    }
    if (SOC_E_NONE == result) {
        *offset = instrNum;
    }
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_filter_set_range_delete_by_index
 *  Purpose
 *    This will decrement the range's reference count if it removes it.
 *  Arguments
 *    (IN) unitData = pointer to unit information
 *    (IN) fsetData = pointer to the filter set information
 *    (IN) offset = which range in this filter set
 *  Returns
 *    (nothing)
 *  Notes
 *    Should only be called after commit, to avoid situations where some
 *    entries in hardware might still be referring to the range slot, even if
 *    all of the API side values indicate no entries are using the range slot.
 */
static void
_soc_c3_rce_filter_set_range_delete_by_index(_soc_c3_rce_unit_desc_int_t *unitData,
                                             _soc_c3_rce_filterset_desc_int_t *fsetData,
                                             unsigned int offset)
{
    _soc_c3_rce_fset_range_info_t *rangeLocal;

    rangeLocal = &(fsetData->rangeInfo[offset - 1]);
    if (rangeLocal->refCount) {
        /* decrement reference count for entries to this range slot */
        rangeLocal->refCount--;
    }
    if ((0 == rangeLocal->refCount) &&
        (0 == rangeLocal->commitCount)) {
        /* filter set no longer has entries referring to this range slot */
        unitData->rangeData[rangeLocal->rangeId - 1]->refCount--;
        sal_memset(rangeLocal, 0x00, sizeof(*rangeLocal));
    } /* if (!(rangeLocal->refCount)) */
}

/*
 *  Function
 *    _soc_c3_rce_entry_qualify_range_set
 *  Purpose
 *    Set whether an entry qualifiers on a specific range+inversion.  This will
 *    add the range+inversion to the filter set if necessary and possible when
 *    setting the entry to qualify on a range, and will remove the
 *    range+inversion if it is present and no longer needed.
 *  Arguments
 *    (IN) unitData = pointer to unit information
 *    (IN) entryId = the entry ID
 *    (IN) rangeId = the range ID
 *    (IN) qualify = negative if inverted, zero don't care, positive if normal
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if range was found or added successfully
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    The qualify value indicates three states.
 *
 *    If qualify is negative, it indicates the intent is to set the entry so it
 *    matches on the inverse of the range.
 *
 *    If qualify is zero, it indicates the intent is to set the entry so the
 *    range does not matter for qualification.
 *
 *    If qualify is positive, it indicates the intent is to set the entry so it
 *    matches on the range as created.
 *
 *    It is possible, when switching an entry from matching on normal to
 *    inverse or inverse to normal, that there will not be enough resources to
 *    accomplish the switch.  This is particularly true when more than one
 *    entry might be using the same range+inversion.  If this happens, the
 *    entry will not be qualified on either normal or inverse of the range.
 */
static int
_soc_c3_rce_entry_qualify_range_set(_soc_c3_rce_unit_desc_int_t *unitData,
                                    int entryId,
                                    int rangeId,
                                    int qualify)
{
    _soc_c3_rce_program_desc_int_t *progData;
    _soc_c3_rce_group_desc_int_t *groupData;
    _soc_c3_rce_entry_desc_int_t *entryData;
    _soc_c3_rce_filterset_desc_int_t *fsetData = NULL;
    unsigned int offset;
    unsigned int index;
    int result;

    entryData = unitData->entryData[entryId];
    groupData = unitData->groupData[entryData->entryGroup];
    progData = unitData->progData[groupData->rceProgram];
    /* compute filter set index in group for this entry */
    offset = entryData->entryPosition / C3_RCE_ENTRIES_PER_FILTER_SET;
    /* find this entry's filter set */
    result = _soc_c3_rce_filter_set_locate(unitData,
                                           progData,
                                           entryData->entryGroup,
                                           offset,
                                           &index);
    if (SOC_E_NONE != result) {
        /* called function displayed diagnostic */
        return result;
    }
    fsetData = &(progData->fsetData[index]);
    /*
     *  First, remove any reference to this range from this entry.  Either
     *  positive or negative needs to be removed.  If the entry does not refer
     *  to this range in either way, just ignore that.
     */
    result = _soc_c3_rce_filter_set_range_find(unitData,
                                               groupData->rangesPerFilterSet,
                                               fsetData->rangeInfo,
                                               rangeId,
                                               FALSE,
                                               &offset);
    if (SOC_E_NONE == result) {
        /* found the normal form of the range in this filter set */
        if (entryData->pattData[0][offset >> 3] & (1 << (offset & 7))) {
            /* this entry refers to the normal form; remove reference */
            entryData->pattData[0][offset >> 3] &= ~(1 << (offset & 7));
            _soc_c3_rce_filter_set_range_delete_by_index(unitData,
                                                         fsetData,
                                                         offset);
        }
    }
    result = _soc_c3_rce_filter_set_range_find(unitData,
                                               groupData->rangesPerFilterSet,
                                               fsetData->rangeInfo,
                                               rangeId,
                                               TRUE,
                                               &offset);
    if (SOC_E_NONE == result) {
        /* found the inverted form of the range in this filter set */
        if (entryData->pattData[0][offset >> 3] & (1 << (offset & 7))) {
            /* this entry refers to the inverted form; remove reference */
            entryData->pattData[0][offset >> 3] &= ~(1 << (offset & 7));
            _soc_c3_rce_filter_set_range_delete_by_index(unitData,
                                                         fsetData,
                                                         offset);
        }
    }
    if (0 == qualify) {
        /* all done now -- entry no longer qualifies on this range */
        return SOC_E_NONE;
    }
    /* setting nonzero for qualify; get (add) the range ref in the fset */
    result = _soc_c3_rce_filter_set_range_add(unitData,
                                              fsetData,
                                              rangeId,
                                              (0 > qualify),
                                              &offset);
    if (SOC_E_NONE == result) {
        /* we have this range reference slotted now; qualify on it */
        entryData->pattData[0][offset >> 3] |= (1 << (offset & 7));
        /* mark this range slot as having a reference */
        fsetData->rangeInfo[offset - 1].refCount++;
#if defined(BROADCOM_DEBUG)
    } else { /* if (SOC_E_NONE == result) */
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d unable to have entry %d use range %d in"
                   " %s mode: %d (%s)\n"),
                   unitData->unit,
                   entryId,
                   rangeId,
                   (0 > qualify)?"invert":"normal",
                   result,
                   _SHR_ERRMSG(result)));
#endif /* defined(BROADCOM_DEBUG) */
    } /* if (SOC_E_NONE == result) */
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_entry_qualify_range_get
 *  Purpose
 *    Get whether an entry qualifiers on a specific range and the inversion.
 *  Arguments
 *    (IN) unitData = pointer to unit information
 *    (IN) entryId = the entry ID
 *    (IN) rangeId = the range ID
 *    (IN) qualify = where to put qualify value (see notes)
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if range was found or added successfully
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    The qualify value indicates three states.
 *
 *    If qualify is negative, it indicates the entry matches on the inverse of
 *    the range.
 *
 *    If qualify is zero, it indicates the entry ignores the range.
 *
 *    If qualify is positive, it indicates the entry matches on the range as
 *    created.
 */
static int
_soc_c3_rce_entry_qualify_range_get(_soc_c3_rce_unit_desc_int_t *unitData,
                                    int entryId,
                                    int rangeId,
                                    int *qualify)
{
    _soc_c3_rce_program_desc_int_t *progData;
    _soc_c3_rce_group_desc_int_t *groupData;
    _soc_c3_rce_entry_desc_int_t *entryData;
    _soc_c3_rce_filterset_desc_int_t *fsetData = NULL;
    unsigned int rangePos;
    unsigned int rangeNeg;
    unsigned int index;
    int result;

    entryData = unitData->entryData[entryId];
    groupData = unitData->groupData[entryData->entryGroup];
    progData = unitData->progData[groupData->rceProgram];
    /* compute filter set index in group for this entry */
    rangePos = entryData->entryPosition / C3_RCE_ENTRIES_PER_FILTER_SET;
    /* find this entry's filter set */
    result = _soc_c3_rce_filter_set_locate(unitData,
                                           progData,
                                           entryData->entryGroup,
                                           rangePos,
                                           &index);
    if (SOC_E_NONE != result) {
        /* called function displayed diagnostic */
        return result;
    }
    fsetData = &(progData->fsetData[index]);
    /*
     *  Find a reference to this range in the filter set, both for the normal
     *  mode and the inverted mode.  For each we find, retrieve the relevant
     *  bit from this entry's pattern.
     */
    result = _soc_c3_rce_filter_set_range_find(unitData,
                                               groupData->rangesPerFilterSet,
                                               fsetData->rangeInfo,
                                               rangeId,
                                               FALSE,
                                               &rangePos);
    if (SOC_E_NONE == result) {
        rangePos = (0 != (entryData->pattData[0][rangePos >> 3] &
                          (1 << (rangePos & 7))));
    } else {
        rangePos = FALSE;
    }
    result = _soc_c3_rce_filter_set_range_find(unitData,
                                               groupData->rangesPerFilterSet,
                                               fsetData->rangeInfo,
                                               rangeId,
                                               TRUE,
                                               &rangeNeg);
    if (SOC_E_NONE == result) {
        rangeNeg = (0 != (entryData->pattData[0][rangeNeg >> 3] &
                          (1 << (rangeNeg & 7))));
    } else {
        rangeNeg = FALSE;
    }
    /* decode the pattern bits into a 'positive/zero/negative' value */
    result = SOC_E_NONE;
    if (rangePos) {
        if (rangeNeg) {
            /* both should never be true at the same time */
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unit %d entry %d refers to both positive and"
                       " negative forms of range %d\n"),
                       unitData->unit,
                       entryId,
                       rangeId));
            result = SOC_E_INTERNAL;
        } else {
            *qualify = 1;
        }
    } else if (rangeNeg) {
        *qualify = -1;
    } else {
        *qualify = 0;
    }
    return result;
}


/*--------------------------------------------------------------------------
 *
 *  Implementation of entry manipulation
 */

/*
 *  Function
 *    _soc_c3_rce_entry_prio_compare
 *  Purpose
 *    Compare entry priorities
 *  Arguments
 *    (IN) prio0 = priority 0
 *    (IN) prio1 = priority 1
 *  Returns
 *    negative  if priority of prio0 < priority of prio1
 *    zero      if priority of prio0 == priority of prio1
 *    positive  if priority of prio0 > priority of prio1
 *  Notes
 *    Tbe BCM layer provides some constants, but as long as priority is always
 *    nonnegative, they constants are seamless.  Nonnegative priority values
 *    are enforced elsewhere.
 */
INLINE int
_soc_c3_rce_entry_prio_compare(int prio0,
                               int prio1)
{
    return prio0 - prio1;
}

#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
/*
 *  Function
 *    _soc_c3_rce_entry_hw_counter_read_int
 *  Purpose
 *    Get the hardware counter values for an entry
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) progData = pointer to the program data
 *    (IN) entryData = pointer to the entry data
 *    (IN) fsetIndex = which filter set in the program
 *    (OUT) counters = where to put the counters (2 uint64 values)
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Should use the entry's basis counters as a buffer.  That way, they will
 *    be adjusted even in case of error.  Otherwise caller must add the
 *    returned values to the entry's basis counters, else the returned counts
 *    will be lost.
 *
 *    If pointer to counters is NULL, this will still read and zero the
 *    hardware counters.  This mode is intended to be used when destroying
 *    an entry or some similar activity.
 */
static int
_soc_c3_rce_entry_hw_counter_read_int(_soc_c3_rce_unit_desc_int_t *unitData,
                                      _soc_c3_rce_program_desc_int_t *progData,
                                      _soc_c3_rce_entry_desc_int_t *entryData,
                                      unsigned int fsetIndex,
                                      uint64 *counters)
{
    _soc_c3_rce_group_desc_int_t *groupData;
    _soc_c3_rce_actions_desc_int_t *actData;
    _soc_c3_rce_counter_read_f ctrRead;
    uint64 ctrBuffer[2];
    int result = SOC_E_NONE;
    unsigned int resultReg;
    unsigned int base;
    unsigned int offset;
    unsigned int position;
    unsigned int index;
    int needUpdate;

    needUpdate = (NULL != counters);
    groupData = unitData->groupData[entryData->entryGroup];
    position = entryData->entryPosition % C3_RCE_ENTRIES_PER_FILTER_SET;
    base = ((progData->fsetData[fsetIndex].amemBlock << 1) *
            C3_RCE_ENTRIES_PER_FILTER_SET);
    RCE_EVERB((RCE_MSG1("read unit %d program %u group %d entry %d position"
                        " %u counter (fset %u amem %u offset %u)\n"),
               unitData->unit,
               groupData->rceProgram,
               entryData->entryGroup,
               entryData->entryId,
               entryData->entryPosition,
               fsetIndex,
               progData->fsetData[fsetIndex].amemBlock << 1,
               position));
    /* scan all of the action tables */
    for (resultReg = 0;
         (SOC_E_NONE == result) &&
         (resultReg < SOC_C3_RCE_RESULT_REGISTER_COUNT);
         resultReg++) {
        if (0 == (groupData->resultLrpUniq & (1 << resultReg))) {
            /* entry's group is not using this action table */
            continue;
        }
        actData = unitData->actData[progData->actIndex[resultReg]];
        if (!(ctrRead = actData->ucData->ctrRead)) {
            /* no action-indexed counters for this action table */
            continue;
        }
        /* calculate first counter pair address in counter space */
        offset = base + position + actData->firstEntryBias;
        /* read both counter pairs in this action table's counter space */
        for (index = 0;
             (SOC_E_NONE == result) && (index < 2);
             index++) {
            RCE_EVERB((RCE_MSG1("read unit %d action table %u (%s) counter"
                                " (%s) pair at %u: "),
                       unitData->unit,
                       progData->actIndex[resultReg],
                       actData->ucData->tableName,
                       actData->ucData->ctrName,
                       offset));
            result = ctrRead(unitData->unit,
                             offset,
                             1 /* one counter pair */,
                             TRUE /* read-and-clear */,
                             &(ctrBuffer[0]));
            if (SOC_E_NONE == result) {
                RCE_EVERB(("%08X%08X / %08X%08X\n",
                           COMPILER_64_HI(ctrBuffer[0]),
                           COMPILER_64_LO(ctrBuffer[0]),
                           COMPILER_64_HI(ctrBuffer[1]),
                           COMPILER_64_LO(ctrBuffer[1])));
                if (needUpdate) {
                    COMPILER_64_ADD_64(counters[0], ctrBuffer[0]);
                    COMPILER_64_ADD_64(counters[1], ctrBuffer[1]);
                }
            } else { /* if (SOC_E_NONE == result) */
                RCE_EVERB(("error %d (%s)\n",
                           result,
                           _SHR_ERRMSG(result)));
            } /* if (SOC_E_NONE == result) */
            /* move to next counter pair for this position */
            offset += C3_RCE_ENTRIES_PER_FILTER_SET;
        } /* for (both action table blocks in the pair) */
#if !C3_RCE_ACTION_INDEX_COUNTER_SPAN_ACTIONS
        /* got counters for one set of actions; do not accumulate others */
        needUpdate = FALSE;
#endif /* !C3_RCE_ACTION_INDEX_COUNTER_SPAN_ACTIONS */
    } /* for (all possible result registers) */
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to read unit %d entry %d counters:"
                   " %d (%s)\n"),
                   unitData->unit,
                   entryData->entryId,
                   result,
                   _SHR_ERRMSG(result)));
    } /* if (SOC_E_NONE != result) */
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_entry_hw_counter_read
 *  Purpose
 *    Get the hardware counter values for an entry
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) progData = pointer to the program data
 *    (IN) entryData = pointer to the entry data
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Updates the entry's basis counts.
 */
static int
_soc_c3_rce_entry_hw_counter_read(_soc_c3_rce_unit_desc_int_t *unitData,
                                  _soc_c3_rce_program_desc_int_t *progData,
                                  _soc_c3_rce_entry_desc_int_t *entryData)
{
    int result;
    unsigned int fsetIndex;

    result = _soc_c3_rce_filter_set_locate(unitData,
                                           progData,
                                           entryData->entryGroup,
                                           entryData->entryPosition / C3_RCE_ENTRIES_PER_FILTER_SET,
                                           &fsetIndex);
    if (SOC_E_NONE != result) {
        /* called function displayed diagnostic */
        return result;
    }
    return _soc_c3_rce_entry_hw_counter_read_int(unitData,
                                                 progData,
                                                 entryData,
                                                 fsetIndex,
                                                 &(entryData->basisCounts[0]));
}
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */

/*
 *  Function
 *    _soc_c3_rce_entry_shift
 *  Purpose
 *    Change position of entries to open a gap before the specified entry
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) groupData = pointer to group information
 *    (IN) filterIndex = index of filter set within the group
 *    (IN) entryNext = pointer to entry before which space is to be inserted
 *    (IN) oldInsertFlags = previous insertion mode flags
 *    (IN/OUT) insertFlags = where to put new insertion mode flags
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    To open a gap *after* the last entry, entryNext needs to be NULL.
 *
 *    Assumes there is at least one free position in the filter set, but
 *    detects inability to shift entries for various reasons.
 *
 *    This can move all entries before the indicated one (in case it is
 *    'prepending' space) or can move the indicated one plus all following (in
 *    case it is 'appending' space).  The entry to be inserted must not be
 *    present at the time this is called.
 *
 *    In order to minimise total moved entries, this will scan until it finds a
 *    free position in one direction, and them move that block of entries in
 *    that direction until it touches either the end of the filter set or
 *    another entry.
 */
static int
_soc_c3_rce_entry_shift(_soc_c3_rce_unit_desc_int_t *unitData,
                        _soc_c3_rce_group_desc_int_t *groupData,
                        unsigned int filterIndex,
                        _soc_c3_rce_entry_desc_int_t *entryNext,
                        uint32 oldInsertFlags,
                        uint32 *insertFlags)
{
    _soc_c3_rce_entry_desc_int_t *entryCurr;
    _soc_c3_rce_entry_desc_int_t *entryWork = NULL;
    unsigned int posMin;
    unsigned int posMax;
    unsigned int shiftDistance = 0;
    unsigned int shiftCount = 0;
    int result = SOC_E_FULL;

    /* find position limits for this filter set */
    posMin = filterIndex * C3_RCE_ENTRIES_PER_FILTER_SET;
    posMax = posMin + (C3_RCE_ENTRIES_PER_FILTER_SET - 1);
    /* clear decision about where to put the space */
    *insertFlags &= (~_SOC_C3_RCE_GROUP_INSERT_FLAG_SPACE_MASK);

    if (_SOC_C3_RCE_GROUP_INSERT_FLAG_SPACE_PREPEND ==
        (oldInsertFlags & _SOC_C3_RCE_GROUP_INSERT_FLAG_SPACE_MASK)) {
        /*
         *  Last time we started by inserting space before the desired entry
         *  position; let's try sticking the space after the proposed entry
         *  position first this time.
         */
        /* start with indicated entry */
        entryCurr = entryNext;
        while (entryCurr && (entryCurr->entryPosition < posMax)) {
            if (!(entryCurr->entryNext)) {
                /* reached ending of group */
                break;
            }
            if (entryCurr->entryPosition <
                (entryCurr->entryNext->entryPosition - 1)) {
                /* found a gap */
                break;
            }
            /* go to next entry */
            entryCurr = entryCurr->entryNext;
        }
        if (entryCurr && (entryCurr->entryPosition < posMax)) {
            /* the gap is immediately after this entry  */
            entryWork = entryCurr;
            (*insertFlags) |= _SOC_C3_RCE_GROUP_INSERT_FLAG_SPACE_APPEND;
            result = SOC_E_NONE;
        }
    } /* if (last time space was prepended) */
    if (!entryWork) {
        /*
         *  We didn't just confirm appending above, so that means either the
         *  last time we stuck the space after the desired spot, or we just now
         *  failed to find a gap before the desired spot.  Try finding a gap
         *  after the desired spot.
         */
        if (entryNext) {
            /* start before indicated entry */
            entryCurr = entryNext->entryPrev;
        } else {
            /* start with last entry in group */
            entryCurr = groupData->entryTail;
        }
        while (entryCurr && (entryCurr->entryPosition > posMin)) {
            if (!(entryCurr->entryPrev)) {
                /* reached beginning of group */
                break;
            }
            if (entryCurr->entryPosition >
                (entryCurr->entryPrev->entryPosition + 1)) {
                /* found a gap */
                break;
            }
            /* go to previous entry */
            entryCurr = entryCurr->entryPrev;
        }
        if (entryCurr && (entryCurr->entryPosition > posMin)) {
            /* the gap is immediately before this entry */
            entryWork = entryCurr;
            (*insertFlags) |= _SOC_C3_RCE_GROUP_INSERT_FLAG_SPACE_PREPEND;
            result = SOC_E_NONE;
        }
    } /* if (!entryWork) */
    if ((!entryWork) &&
        (_SOC_C3_RCE_GROUP_INSERT_FLAG_SPACE_PREPEND !=
         (oldInsertFlags & _SOC_C3_RCE_GROUP_INSERT_FLAG_SPACE_MASK))) {
        /*
         *  Did not find a gap before the entry, and did not already try
         *  scanning after the proposed position, so scan for a gap after the
         *  proposed position.
         */
        /* start with indicated entry */
        entryCurr = entryNext;
        while (entryCurr && (entryCurr->entryPosition < posMax)) {
            if (!(entryCurr->entryNext)) {
                /* reached ending of group */
                break;
            }
            if (entryCurr->entryPosition <
                (entryCurr->entryNext->entryPosition - 1)) {
                /* found a gap */
                break;
            }
            /* go to next entry */
            entryCurr = entryCurr->entryNext;
        }
        if (entryCurr && (entryCurr->entryPosition < posMax)) {
            /* the gap is immediately after this entry  */
            entryWork = entryCurr;
            (*insertFlags) |= _SOC_C3_RCE_GROUP_INSERT_FLAG_SPACE_APPEND;
            result = SOC_E_NONE;
        }
    } /* if (no gap found yet and not tried after proposed position yet) */
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to make room for a new entry in group %d"
                   " filter set %u\n"),
                   groupData->groupId,
                   filterIndex));
        goto error;
    } /* if (SOC_E_NONE != result) */
    if (!entryWork) {
        /* extra paranoia for Coverity and other coverage tools */
        /* coverity[dead_error_begin] */
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("failed to find any gap in group %d filter set %u\n"),
                   groupData->groupId,
                   filterIndex));
        result = SOC_E_INTERNAL;
        goto error;
    } /* if (!entryWork) */
    RCE_EVERB((RCE_MSG1("far end of block is entry %d position %u\n"),
               entryWork->entryId,
               entryWork->entryPosition));
    if (_SOC_C3_RCE_GROUP_INSERT_FLAG_SPACE_APPEND ==
        ((*insertFlags) & _SOC_C3_RCE_GROUP_INSERT_FLAG_SPACE_MASK)) {
        /* will be shifting a gap after the proposed position */
        if (entryWork->entryNext &&
            (entryWork->entryNext->entryPosition <= posMax)) {
            RCE_EVERB((RCE_MSG1("next entry %d %u is in this filter set\n"),
                       entryWork->entryNext->entryId,
                       entryWork->entryNext->entryPosition));
            /* there is a next entry and it is in this filter set */
            shiftDistance = ((entryWork->entryNext->entryPosition -
                              entryWork->entryPosition) - 1);
        } else {
            RCE_EVERB((RCE_MSG1("next entry not in this filter set\n")));
            /* next entry is outside of this filter set, or no next entry */
            shiftDistance = (posMax - entryWork->entryPosition);
        } /* if (workEntry->entryNext) */
        RCE_EVERB((RCE_MSG1("calculated shift distance %u, entry %d %u\n"),
                   shiftDistance,
                   entryWork->entryId,
                   entryWork->entryPosition));
        /*
         *  Here, since the entry at 'entryNext' is meant to be after the
         *  insertion point, we also want to move that entry's position.
         */
        entryCurr = entryWork;
        while (TRUE) {
#if 0 
            RCE_EVERB((RCE_MSG1("shift entry %d from %u to %u\n"),
                       entryCurr->entryId,
                       entryCurr->entryPosition,
                       entryCurr->entryPosition + shiftDistance));
#endif 
            entryCurr->entryPosition += shiftDistance;
            shiftCount++;
            if (entryCurr == entryNext) {
                /* if just updated the one after the insertion point, done. */
                break;
            }
            entryCurr = entryCurr->entryPrev;
        } /* while (TRUE) */
    } else if (_SOC_C3_RCE_GROUP_INSERT_FLAG_SPACE_PREPEND ==
               (*insertFlags & _SOC_C3_RCE_GROUP_INSERT_FLAG_SPACE_MASK)) {
        /* will be shifting a gap before the proposed position */
        if (entryWork->entryPrev &&
            (entryWork->entryPrev->entryPosition >= posMin)) {
            RCE_EVERB((RCE_MSG1("prev entry %d %u is in this filter set\n"),
                       entryWork->entryPrev->entryId,
                       entryWork->entryPrev->entryPosition));
            /* there is a previous entry and it is in this filter set */
            shiftDistance = ((entryWork->entryPosition -
                              entryWork->entryPrev->entryPosition) - 1);
        } else {
            RCE_EVERB((RCE_MSG1("prev entry not in this filter set\n")));
            /* prev entry is outside of this filter set, or no prev entry */
            shiftDistance = (entryWork->entryPosition - posMin);
        }
        RCE_EVERB((RCE_MSG1("calculated shift distance %u, entry %d %u\n"),
                   shiftDistance,
                   entryWork->entryId,
                   entryWork->entryPosition));
        /*
         *  Here, since the entry at 'entryNext' is meant to be after the
         *  insertion point, we do not want to move that entry's position.
         */
        for (entryCurr = entryWork;
             entryCurr != entryNext;
             entryCurr = entryCurr->entryNext) {
#if 0 
            RCE_EVERB((RCE_MSG1("shift entry %d from %u to %u\n"),
                       entryCurr->entryId,
                       entryCurr->entryPosition,
                       entryCurr->entryPosition - shiftDistance));
#endif 
            entryCurr->entryPosition -= shiftDistance;
            shiftCount++;
        }
    }
    if (entryNext) {
        RCE_EVERB((RCE_MSG1("unit %d program %u (%s) group %d space %u opened"
                            " before entry %d by %s shifting %u entries\n"),
                   unitData->unit,
                   groupData->rceProgram,
                   unitData->progData[groupData->rceProgram]->ucData->programName,
                   groupData->groupId,
                   shiftDistance,
                   entryNext->entryId,
                   (_SOC_C3_RCE_GROUP_INSERT_FLAG_SPACE_APPEND==((*insertFlags)&_SOC_C3_RCE_GROUP_INSERT_FLAG_SPACE_MASK))?"append":
                   (_SOC_C3_RCE_GROUP_INSERT_FLAG_SPACE_PREPEND==((*insertFlags)&_SOC_C3_RCE_GROUP_INSERT_FLAG_SPACE_MASK))?"prepend":
                   "???",
                   shiftCount));
    } else {
        RCE_EVERB((RCE_MSG1("unit %d program %u (%s) group %d space %u opened"
                            " after final entry by %s shifting %u entries\n"),
                   unitData->unit,
                   groupData->rceProgram,
                   unitData->progData[groupData->rceProgram]->ucData->programName,
                   groupData->groupId,
                   shiftDistance,
                   (_SOC_C3_RCE_GROUP_INSERT_FLAG_SPACE_APPEND==((*insertFlags)&_SOC_C3_RCE_GROUP_INSERT_FLAG_SPACE_MASK))?"append":
                   (_SOC_C3_RCE_GROUP_INSERT_FLAG_SPACE_PREPEND==((*insertFlags)&_SOC_C3_RCE_GROUP_INSERT_FLAG_SPACE_MASK))?"prepend":
                   "???",
                   shiftCount));
    }
error:
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_filter_set_split
 *  Purpose
 *    Split an existing filter set into two filter sets, with the specified
 *    entry and those after (within the original filter set) put in the new
 *    filter set, and all pf tje entries in later filter sets pushed out by
 *    one filter set.
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) progData = pointer to program data
 *    (IN) groupData = pointer to group data
 *    (IN) entryData = pointer to entry before which the fset is to be split
 *    (IN) filterSetGrp = filter set in group after the split
 *    (IN) filterSetPrg = filter set in program after the split
 *    (IN) positionFirst = first position in the filter set
 *    (IN) positionLast = last position in the filter set
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    The filterSetGrp and filterSetPrg arguments are the filter set before
 *    which the split is to be made (so, before the split, they indicate the
 *    insertion point, and after the split, they are the newly added fset).
 *    The filterSetGrp and filterSetPrg arguments must always be >= 1.
 *
 *    Commits changes to the filter sets to hardware, but does not affect entry
 *    installation state or similar.
 *
 *    Some adjustments are not committed to 'live' program data, but are built
 *    in copies of the 'live' data, to make backout easier in case of failure,
 *    but some adjustments must be made in place and so special provisions are
 *    in those places to recover the prior state.
 */
static int
_soc_c3_rce_filter_set_split(_soc_c3_rce_unit_desc_int_t *unitData,
                             _soc_c3_rce_program_desc_int_t *progData,
                             _soc_c3_rce_group_desc_int_t *groupData,
                             _soc_c3_rce_entry_desc_int_t *entryData,
                             unsigned int filterSetGrp,
                             unsigned int filterSetPrg,
                             unsigned int positionFirst,
                             unsigned int positionLast)
{
    _soc_c3_rce_filterset_desc_int_t *fsTemp = NULL;/* working fsets data */
    _soc_c3_rce_entry_desc_int_t *entryCurr;    /* working entry pointer */
    unsigned int *rangeRefs = NULL;             /* range refs new fset */
    unsigned int *rangeRefsC = NULL;            /* range refs new fset */
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
    unsigned int *entryList = NULL;             /* list of moved entries */
    int ovrRes = SOC_E_NONE;                    /* result override */
    uint64 *ctrTemp = NULL;                     /* counter update space */
    unsigned int entriesMoved = 0;              /* entries moved */
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
    unsigned int filterSetGrpOld;               /* old filter set in group */
    unsigned int filterSetPrgOld = ~0;          /* old filter set in program */
    unsigned int filterSetGrpNew;               /* new filter set in group */
    unsigned int filterSetPrgNew = ~0;          /* new filter set in program */
    unsigned int filterSetPrgTmp;               /* working filter set in prog */
    unsigned int filterSetGrpTmp;               /* working filter set in grp */
    unsigned int positionFirstTmp;              /* working filter set 1st pos */
    unsigned int positionLastTmp;               /* working filter set last ps */
    unsigned int positionFirstNew;              /* new filter set first posn */
    unsigned int positionLastNew;               /* new filter set last posn */
    unsigned int positionFirstOld;              /* old filter set first posn */
    unsigned int positionLastOld;               /* old filter set last posn */
    unsigned int blockIndex;                    /* current working block */
    unsigned int instrOffset;                   /* instruction offset */
    unsigned int rangeCount;                    /* ranges per filter set */
    unsigned int rangeChkEnd;                   /* range check end */
    unsigned int entryCount;                    /* entries to move */
    unsigned int imemStartNext;                 /* next fset imem start */
    unsigned int imemSizeDiff;                  /* imem size difference */
    unsigned int allocSize;                     /* working size calculation */
    unsigned int index;                         /* general index */
    unsigned int addedBlocks;                   /* padding blocks */
    int backoutNeeded = FALSE;                  /* whether backout is needed */
    int result = SOC_E_UNAVAIL;                 /* final result */
    int auxRes;                                 /* temporary result */
    uint8 current;                              /* working pattern byte */
    uint8 currentC;                             /* working pattern byte */
    uint8 mask;                                 /* working range mask */

    if (groupData->maxFilterSets &&
        (groupData->filterSetCount >= groupData->maxFilterSets)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d group %d specifically limited to %u filter"
                   " set%s and already has %u filter sets\n"),
                   unitData->unit,
                   groupData->groupId,
                   groupData->maxFilterSets,
                   (groupData->maxFilterSets>1)?"s":"",
                   groupData->filterSetCount));
        result = SOC_E_FULL;
        goto error;
    }
    for (entryCount = 0,
         entryCurr = progData->fsetData[filterSetPrg].entryHead;
         entryCurr != entryData;
         entryCurr = entryCurr->entryNext, entryCount++) {
        /* just scan through the filter set until we find the entry */
    }
    RCE_EVERB((RCE_MSG1("unit %d split program %u (%s) filter set %u, group"
                        " %d filter set %u, positions %u..%u, before entry %d,"
                        " %u entries to split, %u before, %u after\n"),
               unitData->unit,
               groupData->rceProgram,
               progData->ucData->programName,
               filterSetPrg,
               groupData->groupId,
               filterSetGrp,
               positionFirst,
               positionLast,
               entryData?entryData->entryId:-1,
               progData->fsetData[filterSetPrg].entryCount,
               entryCount,
               progData->fsetData[filterSetPrg].entryCount - entryCount));
    if (0 == entryCount) {
        /*
         *  Special case: if 'split' point is before the first entry in the
         *  filter set, just add a new filter set before this filter set.  No
         *  need to move entries.
         */
         /* coverity[stack_use_overflow] */
        result = _soc_c3_rce_filter_set_add(unitData,
                                            groupData->groupId,
                                            filterSetGrp,
                                            filterSetPrg);
        if (SOC_E_NONE == result) {
            /*
             *  Added new filter set; move all of the entries following it to
             *  their new position.  No need for backout data here since the
             *  only writes to be committed have already been done.
             */
            for (entryCurr = entryData;
                 entryCurr;
                 entryCurr = entryCurr->entryNext) {
                entryCurr->entryPosition += C3_RCE_ENTRIES_PER_FILTER_SET;
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
                if ((~0) != entryCurr->entryPosPrev) {
                    /* entry was in a moved filter set so adjust prior posn */
                    entryCurr->entryPosPrev += C3_RCE_ENTRIES_PER_FILTER_SET;
                }
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
            } /* for (all entries after the insertion point in group) */
        } /* if (SOC_E_NONE == result) */
        /* whether success or failure, this path is done now */
        goto error;
    } else if (entryCount >= progData->fsetData[filterSetPrg].entryCount) {
        /*
         *  Special case: if 'split' point is after the last entry in the
         *  filter set, just add a new filter set after this filter set.  No
         *  need to move entries.
         */
        result = _soc_c3_rce_filter_set_add(unitData,
                                            groupData->groupId,
                                            filterSetGrp + 1,
                                            filterSetPrg + 1);
        if (SOC_E_NONE == result) {
            /*
             *  Added new filter set; move all of the entries following it to
             *  their new position.  No need for backout data here since the
             *  only writes to be committed have already been done.
             */
            for (entryCurr = entryData;
                 entryCurr;
                 entryCurr = entryCurr->entryNext) {
                entryCurr->entryPosition += C3_RCE_ENTRIES_PER_FILTER_SET;
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
                if ((~0) != entryCurr->entryPosPrev) {
                    /* entry was in a moved filter set so adjust prior posn */
                    entryCurr->entryPosPrev += C3_RCE_ENTRIES_PER_FILTER_SET;
                }
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
            } /* for (all entries after the insertion point in group) */
        } /* if (SOC_E_NONE == result) */
        /* whether success or failure, this path is done now */
        goto error;
    }
    /*
     *  If we got to here, we know the split point has entries on both sides
     *  within this filter set, so the operation is more complicated.  We need
     *  to move at least one entry to the new filter set, including adjustments
     *  to position and counter basis, as well as range information.
     */
    if ((entryCount << 1) > progData->fsetData[filterSetPrg].entryCount) {
        /*
         *  More than half the filter set is before the specified entry, so the
         *  new filter set should include the specified entry and the remaining
         *  ones in this filter set, and be placed after this filter set.
         */
        filterSetGrpOld = filterSetGrp;
        filterSetPrgOld = filterSetPrg;
        positionFirstOld = positionFirst;
        positionLastOld = positionLast;
        filterSetGrpNew = filterSetGrp + 1;
        filterSetPrgNew = filterSetPrg + 1;
        positionFirstNew = positionFirst + C3_RCE_ENTRIES_PER_FILTER_SET;
        positionLastNew = positionLast + C3_RCE_ENTRIES_PER_FILTER_SET;
    } else { /* if (selected entry is past halfway through the filter set) */
        /*
         *  Half or more of the filter set is after the specified entry, so the
         *  new filter set should include all entries in this filter set before
         *  the specified entry, and should be placed before this filter set.
         */
        filterSetGrpNew = filterSetGrp;
        filterSetPrgNew = filterSetPrg;
        positionFirstNew = positionFirst;
        positionLastNew = positionLast;
        filterSetGrpOld = filterSetGrp + 1;
        filterSetPrgOld = filterSetPrg + 1;
        positionFirstOld = positionFirst + C3_RCE_ENTRIES_PER_FILTER_SET;
        positionLastOld = positionLast + C3_RCE_ENTRIES_PER_FILTER_SET;
    } /* if (selected entry is past halfway through the filter set) */
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
    if (groupData->groupFlags & _SOC_C3_RCE_GROUP_FLAG_COUNTER) {
        /*
         *  This group uses action-indexed counters; prepare space for the list
         *  of entries being moved, so we can keep counters in sync.
         */
        allocSize = sizeof(*entryList) * C3_RCE_ENTRIES_PER_FILTER_SET;
        entryList = sal_alloc(allocSize, "C3 RCE entry move list");
        if (!entryList) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unit %d unable to allocate %u bytes for"
                       " entry move list\n"),
                       unitData->unit,
                       allocSize));
            result = SOC_E_MEMORY;
            goto error;
        }
        sal_memset(entryList, ~0, allocSize);
        /* prepare a buffer for counter updates */
        ctrTemp = sal_alloc(sizeof(*ctrTemp) * 2 *
                            C3_RCE_ENTRIES_PER_FILTER_SET,
                            "counter workspace for entry moves");
        if (!ctrTemp) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to allocate %u bytes for counter"
                       " move workspace\n"),
                       (unsigned int)(sizeof(*ctrTemp)) * 2 *
                       C3_RCE_ENTRIES_PER_FILTER_SET));
            result = SOC_E_MEMORY;
            goto error;
        } /* if (!ctrTemp) */
    } /* if (groupData->groupFlags & _SOC_C3_RCE_GROUP_FLAG_COUNTER) */
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
    /* prepare space for a copy of the filter set list */
    allocSize = sizeof(*fsTemp) * (progData->filterSetCount + 1);
    fsTemp = sal_alloc(allocSize, "C3 RCE program filter set list");
    if (!fsTemp) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d unable to allocate %u bytes for new"
                   " filter set list\n"),
                   unitData->unit,
                   allocSize));
        result = SOC_E_MEMORY;
        goto error;
    }
    /* copy filter set data before the new one */
    for (index = 0; index < filterSetPrgNew; index++) {
        sal_memcpy(&(fsTemp[index]),
                   &(progData->fsetData[index]),
                   sizeof(*fsTemp));
    }
    /* new filter set information comes from old filter set information */
    sal_memcpy(&(fsTemp[index]),
               &(progData->fsetData[filterSetPrg]),
               sizeof(*fsTemp));
    fsTemp[index].filterIndex = filterSetGrpNew;
    /* copy filter set data after the new one */
    for (index++; index <= progData->filterSetCount; index++) {
        sal_memcpy(&(fsTemp[index]),
                   &(progData->fsetData[index - 1]),
                   sizeof(*fsTemp));
        if (groupData->groupId == fsTemp[index].groupId) {
            /* adjust remainder of this group */
            (fsTemp[index].filterIndex)++;
        }
    }
    /* adjustments to the original and new filter sets */
    if (filterSetPrgNew > filterSetPrgOld) {
        /* new filter set comes after the old one */
        fsTemp[filterSetPrgNew].entryHead = entryData;
        fsTemp[filterSetPrgNew].entryCount -= entryCount;
        /* old filter set head is still correct value, skip it */
        fsTemp[filterSetPrgOld].entryCount = entryCount;
    } else {
        /* new filter set comes before the old one */
        fsTemp[filterSetPrgNew].entryHead = fsTemp[filterSetPrg].entryHead;
        fsTemp[filterSetPrgNew].entryCount = entryCount;
        fsTemp[filterSetPrgOld].entryHead = entryData;
        fsTemp[filterSetPrgOld].entryCount -= entryCount;
    }
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
    if (!entryList) {
        /* not using action-indexed counters; get a new action table block */
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
        fsTemp[filterSetPrgOld].amemBlock = ~0;
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
    }
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
    fsTemp[filterSetPrgOld].imemStart = ~0;
    fsTemp[filterSetPrgOld].rangeInfo = NULL;
    fsTemp[filterSetPrgNew].amemBlock = ~0;
    fsTemp[filterSetPrgNew].imemStart = ~0;
    fsTemp[filterSetPrgNew].rangeInfo = NULL;
    /* ensure size is correct for the new filter sets */
    _soc_c3_rce_filter_set_length(groupData->instrBlocks,
                                  filterSetPrgOld,
                                  &(fsTemp[filterSetPrgOld].imemSize));
    _soc_c3_rce_filter_set_length(groupData->instrBlocks,
                                  filterSetPrgNew,
                                  &(fsTemp[filterSetPrgNew].imemSize));
    imemSizeDiff = ((fsTemp[filterSetPrgOld].imemSize +
                     fsTemp[filterSetPrgNew].imemSize) -
                    progData->fsetData[filterSetPrg].imemSize);
    rangeCount = groupData->rangesPerFilterSet;
    if (rangeCount) {
        /* prepare space for counting range references */
        allocSize = sizeof(*rangeRefs) * rangeCount * 2;
        rangeRefs = sal_alloc(allocSize, "range reference counter space");
        if (!rangeRefs) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unit %d unable to allocate %u bytes for range"
                       " reference count workspace\n"),
                       unitData->unit,
                       allocSize));
            result = SOC_E_MEMORY;
            goto error;
        }
        sal_memset(rangeRefs, 0x00, allocSize);
        rangeRefsC = &(rangeRefs[rangeCount]);
        /* will need new range information for the old and split filter sets */
        allocSize = sizeof(*(fsTemp[index].rangeInfo)) * rangeCount;
        fsTemp[filterSetPrgOld].rangeInfo = sal_alloc(allocSize,
                                                      "C3 RCE filter set"
                                                      " range list");
        if (!(fsTemp[filterSetPrgOld].rangeInfo)) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unit %d unable to allocate %u bytes for range"
                       " information on old filter set\n"),
                       unitData->unit,
                       allocSize));
            goto error;
        }
        fsTemp[filterSetPrgNew].rangeInfo = sal_alloc(allocSize,
                                                      "C3 RCE filter set"
                                                      " range list");
        if (!(fsTemp[filterSetPrgNew].rangeInfo)) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unit %d unable to allocate %u bytes for range"
                       " information on new filter set\n"),
                       unitData->unit,
                       allocSize));
            goto error;
        }
        /* we want all of the range information copied; will clean up later */
        sal_memcpy(fsTemp[filterSetPrgOld].rangeInfo,
                   progData->fsetData[filterSetPrg].rangeInfo,
                   allocSize);
        sal_memcpy(fsTemp[filterSetPrgNew].rangeInfo,
                   progData->fsetData[filterSetPrg].rangeInfo,
                   allocSize);
    } /* if (rangeCount) */
    /* adjust entry positions for the entries we pushed out */
    for (entryCurr = entryData; entryCurr; entryCurr = entryCurr->entryNext) {
        entryCurr->entryPosBackout = entryCurr->entryPosition;
        entryCurr->entryPosition += C3_RCE_ENTRIES_PER_FILTER_SET;
    }
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
    /*
     *  Update 'previous' position for filter sets following this one, if there
     *  are any, in this group.  The filter set we are splitting needs special
     *  work in order to correctly update its counter basis values.
     */
    if ((filterSetGrp + 1) < groupData->filterSetCount) {
        for (entryCurr = progData->fsetData[filterSetPrg + 1].entryHead;
             entryCurr;
             entryCurr = entryCurr->entryNext) {
            if ((~0) != entryCurr->entryPosPrev) {
                entryCurr->entryPosPrev += C3_RCE_ENTRIES_PER_FILTER_SET;
            } /* if (this entry has been given a position before) */
        } /* for all entries next filter set and onward */
    } /* if (there are filter sets after the split one) */
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
    /* collect ranges and counter movements for the new filter set */
    for (entryCurr = fsTemp[filterSetPrgNew].entryHead;
         entryCurr && (entryCurr->entryPosition <= positionLastNew);
         entryCurr = entryCurr->entryNext) {
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
        if (entryList &&
            ((~0) != entryCurr->entryPosPrev)) {
            /* this entry was set up in old fset but moving; update basis */
            entryCurr->entryPosPrev = ((entryCurr->entryPosPrev +
                                        positionFirstNew) -
                                       positionFirst);
            entryList[entryCurr->entryPosition -
                      positionFirstNew] = entryCurr->entryId;
            entriesMoved++;
        }
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
        for (blockIndex = 0, instrOffset = 0, currentC = 0;
             instrOffset <= rangeCount;
             blockIndex++, instrOffset += 8) {
            current = entryCurr->pattData[0][blockIndex];
            if (entryCurr->pattData[0][0] & 1) {
                currentC = entryCurr->pattData[1][blockIndex];
            }
            rangeChkEnd = instrOffset + 7;
            if (rangeChkEnd > rangeCount) {
                rangeChkEnd = rangeCount;
            }
            for (index = (instrOffset?instrOffset:1),
                 mask = (instrOffset?1:2);
                 index <= rangeChkEnd;
                 index++, mask <<= 1) {
                if (current & mask) {
                    rangeRefs[index - 1]++;
                }
                if (currentC & mask) {
                    rangeRefsC[index - 1]++;
                }
            } /* for (each range slot in this byte) */
        } /* for (all range slots in this entry) */
    } /* for (all entries in the group after the split) */
    /* adjust range reference counts for both parts of the split filter set */
    for (index = 0; index < rangeCount; index++) {
        /* this range reference is used by this many entries in the new part */
        fsTemp[filterSetPrgNew].rangeInfo[index].refCount = rangeRefs[index];
        fsTemp[filterSetPrgNew].rangeInfo[index].commitCount = rangeRefsC[index];
        /* ...so it is used by that many fewer entries in the old part */
        fsTemp[filterSetPrgOld].rangeInfo[index].refCount -= rangeRefs[index];
        fsTemp[filterSetPrgOld].rangeInfo[index].commitCount -= rangeRefsC[index];
        /* get rid of unused references in new filter set */
        if ((0 == fsTemp[filterSetPrgNew].rangeInfo[index].refCount) &&
            (0 == fsTemp[filterSetPrgNew].rangeInfo[index].commitCount) &&
            (fsTemp[filterSetPrgNew].rangeInfo[index].rangeId)) {
            /* clear this unused range reference */
            sal_memset(&(fsTemp[filterSetPrgNew].rangeInfo[index]),
                       0x00,
                       sizeof(fsTemp[filterSetPrgNew].rangeInfo[index]));
        }
        /* get rid of unused references in old filter set */
        if ((0 == fsTemp[filterSetPrgOld].rangeInfo[index].refCount) &&
            (0 == fsTemp[filterSetPrgOld].rangeInfo[index].commitCount) &&
            (fsTemp[filterSetPrgOld].rangeInfo[index].rangeId)) {
            /* clear this disused range reference */
            sal_memset(&(fsTemp[filterSetPrgOld].rangeInfo[index]),
                       0x00,
                       sizeof(fsTemp[filterSetPrgOld].rangeInfo[index]));
        }
    } /* for (all range slots in this group's filter sets) */
    backoutNeeded = TRUE;
    RCE_EVERB((RCE_MSG1("unit %d program %u (%s) filter set %u (group %d"
                        " filter set %u) split %u entries between %d,%d;"
                        " now %u(%u)=%u and %u(%u)=%u\n"),
               unitData->unit,
               groupData->rceProgram,
               progData->ucData->programName,
               filterSetPrg,
               groupData->groupId,
               filterSetGrp,
               entryCount,
               entryData?entryData->entryPrev?entryData->entryPrev->entryId:-1:-1,
               entryData?entryData->entryId:-1,
               filterSetPrgOld,
               filterSetGrpOld,
               fsTemp[filterSetPrgOld].entryCount,
               filterSetPrgNew,
               filterSetGrpNew,
               fsTemp[filterSetPrgNew].entryCount));
    /* make sure the proposed new filter set fits */
    if (filterSetPrgNew < progData->filterSetCount) {
        /* there is another filter set after this one */
        addedBlocks = 0;
    } else { /* if (filterSetPrgNew < progData->filterSetCount) */
        /* there is no filter set after this one */
        _soc_c3_rce_program_padding_length_calc(unitData,
                                                progData->instrBlockCount +
                                                imemSizeDiff,
                                                &addedBlocks,
                                                &imemStartNext);
    } /* if (filterSetPrgNew < progData->filterSetCount) */
    result = _soc_c3_rce_program_length_check(unitData,
                                              SOC_C3_RCE_PROGRAM_LENGTH_CHECK_PADDING,
                                              groupData->rceProgram,
                                              fsTemp[filterSetPrgNew].imemSize,
                                              addedBlocks);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d program %u is too long to add another"
                   " filter set for group %d (%u instruction"
                   " blocks)\n"),
                   unitData->unit,
                   groupData->rceProgram,
                   groupData->groupId,
                   fsTemp[filterSetPrgNew].imemSize));
        goto error;
    }
    /* make sure the new filter set fits even if padding is in use */
    result = _soc_c3_rce_program_length_check(unitData,
                                              SOC_C3_RCE_PROGRAM_LENGTH_CHECK_TRANSIENT,
                                              groupData->rceProgram,
                                              fsTemp[filterSetPrgNew].imemSize,
                                              0 /* padding */);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d program %u is too long to add another"
                   " filter set for group %d (%u instruction blocks)"
                   " before removing additional padding\n"),
                   unitData->unit,
                   groupData->rceProgram,
                   groupData->groupId,
                   fsTemp[filterSetPrgNew].imemSize));
        goto error;
    }
    /*
     *  Okay, so adding the new filter set looks like it will be acceptable.
     *  The later filter set needs to be reworked first, so we have a valid
     *  next filter set pointer to use when building the earlier one.
     */
    for (index = 0; index < 2; index++) {
        if (filterSetPrgNew < filterSetPrgOld) {
            /*
             *  Inserting new filter set earlier than old filter set, so we
             *  need to update the old filter set first, and then build the new
             *  filter set second.
             */
            if (0 == index) {
                filterSetPrgTmp = filterSetPrgOld;
                filterSetGrpTmp = filterSetGrpOld;
                positionFirstTmp = positionFirstOld;
                positionLastTmp = positionLastOld;
            } else {
                filterSetPrgTmp = filterSetPrgNew;
                filterSetGrpTmp = filterSetGrpNew;
                positionFirstTmp = positionFirstNew;
                positionLastTmp = positionLastNew;
            }
        } else {
            /*
             *  Inserting new filter set later than old filter set, so we need
             *  to build the new filter set first, and then update the old
             *  filter set second.
             */
            if (0 == index) {
                filterSetPrgTmp = filterSetPrgNew;
                filterSetGrpTmp = filterSetGrpNew;
                positionFirstTmp = positionFirstNew;
                positionLastTmp = positionLastNew;
            } else {
                filterSetPrgTmp = filterSetPrgOld;
                filterSetGrpTmp = filterSetGrpOld;
                positionFirstTmp = positionFirstOld;
                positionLastTmp = positionLastOld;
            }
        } /* if (new filter set is earlier than old filter set) */
        if (filterSetPrgTmp < progData->filterSetCount) {
            /*
             *  For the last filter set, the imemStartNext value would have
             *  been computed above, so we don't replace it here.  For any
             *  earlier filter set, the imemStartNext is taken from the filter
             *  set descriptor following the filter set to be updated/built.
             */
            imemStartNext = fsTemp[filterSetPrgTmp + 1].imemStart;
        } /* last fset will inherit value computed above */
        result = _soc_c3_rce_filter_set_build(unitData,
                                              groupData,
                                              (0 == filterSetPrgTmp),
                                              fsTemp[filterSetPrgTmp].entryHead,
                                              positionFirstTmp,
                                              positionLastTmp,
                                              imemStartNext,
                                              &(fsTemp[filterSetPrgTmp]));
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to build instruction/pattern/action"
                                " block for unit %d program %u (%s) set %u"
                                " (group %d set %u) (iter %d,%s): %d (%s)\n"),
                       unitData->unit,
                       groupData->rceProgram,
                       progData->ucData->programName,
                       filterSetPrgTmp,
                       groupData->groupId,
                       filterSetGrpTmp,
                       index,
                       (filterSetPrgNew < filterSetPrgOld)?"O":"N",
                       result,
                       _SHR_ERRMSG(result)));
            fsTemp[filterSetPrgTmp].imemStart = ~0;
            fsTemp[filterSetPrgTmp].amemBlock = ~0;
            goto error;
        }
    } /* for (each filter set to update/build) */
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
    /*
     *  Update couners in 'off-phase' action bank, for the entries that are
     *  going to be moved.  This is done after the new filter sets are build,
     *  but before they are linked into the program, since this phase is what
     *  will be used as soon as the counters are linked (and so needs to be
     *  read and cleared first).
     */
    if (entryList && entriesMoved) {
        auxRes = _soc_c3_rce_entry_move_counter_update(unitData,
                                                       progData,
                                                       groupData,
                                                       &(progData->fsetData[filterSetPrg]),
                                                       entryList,
                                                       entriesMoved,
                                                       ctrTemp,
                                                       TRUE);
        if (SOC_E_NONE != auxRes) {
            /* called function displayed diagnostic */
            ovrRes = auxRes;
        }
    } /* if (entryList && entriesMoved) */
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
    /*
     *  Update the filter set before whichever is first so it points to the
     *  appropriate new one.  This is the only place here where we want to
     *  manipulate the new filter set layout using the old index, because the
     *  old index is equal to whichever (new or old) is first in the program.
     */
    result = _soc_c3_rce_filter_set_start_update(unitData,
                                                 groupData->rceProgram,
                                                 fsTemp,
                                                 ((int)(filterSetPrg)) - 1,
                                                 fsTemp[filterSetPrg].imemStart);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to link updated unit %d program %u (%s) set"
                   " %u (group %d set %u) into program: %d (%s)\n"),
                   unitData->unit,
                   groupData->rceProgram,
                   progData->ucData->programName,
                   filterSetPrg,
                   groupData->groupId,
                   filterSetGrp,
                   result,
                   _SHR_ERRMSG(result)));
        goto error;
    } /* if (SOC_E_NONE != result) */
    /* do not back out new positions after this */
    backoutNeeded = FALSE;
    /* accounting */
    progData->filterSetCount++;
    groupData->filterSetCount++;
    progData->instrBlockCount += imemSizeDiff;
    unitData->instrBlockCount += imemSizeDiff;
    if (progData->instrBlockAdded) {
        /* program was using padding before; probably should reduce it */
        _soc_c3_rce_program_padding_length_calc(unitData,
                                                progData->instrBlockCount,
                                                &addedBlocks,
                                                &imemStartNext);
        auxRes = _soc_c3_rce_filter_set_start_update(unitData,
                                                     groupData->rceProgram,
                                                     fsTemp,
                                                     (int)(progData->filterSetCount - 1),
                                                     imemStartNext);
        if (SOC_E_NONE == auxRes) {
            /* successfully removed (some) padding from the program */
            unitData->instrBlockCount = (unitData->instrBlockCount -
                                         progData->instrBlockAdded +
                                         addedBlocks);
            progData->instrBlockAdded = addedBlocks;
        } else { /* if (SOC_E_NONE == auxRes) */
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to adjust padding block for"
                       " unit %d program %u (%s): %d (%s)\n"),
                       unitData->unit,
                       groupData->rceProgram,
                       progData->ucData->programName,
                       auxRes,
                       _SHR_ERRMSG(auxRes)));
            /* not to be reported as error adding filter set */
        } /* if (SOC_E_NONE == auxRes) */
    } /* if (progData->instrBlockAdded) */
    /* dispose of the old instruction/pattern and action blocks */
    auxRes = shr_mdb_free(unitData->imemRes,
                          progData->fsetData[filterSetPrg].imemStart);
    if (SOC_E_NONE != auxRes) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d unable to free old instruction memory"
                   " block for program %u (%s) filter set %u (group"
                   " %d filter set %u) at %03X: %d (%s)\n"),
                   unitData->unit,
                   groupData->rceProgram,
                   progData->ucData->programName,
                   filterSetPrg,
                   groupData->groupId,
                   filterSetGrp,
                   progData->fsetData[filterSetPrg].imemStart,
                   auxRes,
                   _SHR_ERRMSG(auxRes)));
        /* but do not return as error */
    } else {
        unitData->imemBlockCount--;
    }
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
    /*
     *  Now update the old filter set's previously 'active' phase counters.
     *  This gets the counter updates for the entries that were moved, and does
     *  so from what was the 'active' phase before, which is no longer seeing
     *  updates, so now is the time to get these counters.
     */
    if (entryList && entriesMoved) {
        auxRes = _soc_c3_rce_entry_move_counter_update(unitData,
                                                       progData,
                                                       groupData,
                                                       &(progData->fsetData[filterSetPrg]),
                                                       entryList,
                                                       entriesMoved,
                                                       ctrTemp,
                                                       FALSE);
        if (SOC_E_NONE != auxRes) {
            /* called function displayed diagnostic */
            ovrRes = auxRes;
        }
    } /* if (entryList && entriesMoved) */
    if (0 == (groupData->groupFlags & _SOC_C3_RCE_GROUP_FLAG_COUNTER)) {
        /* not using action indexed counters, so new act blocks ea. time */
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
        for (index = 0; index < SOC_C3_RCE_RESULT_REGISTER_COUNT; index++) {
            if (0 == (groupData->resultLrpUniq & (1 << index))) {
                /* group does not use this result register */
                continue;
            }
            auxRes = shr_mres_free(unitData->amemRes,
                                   progData->actIndex[index],
                                   1 /* one amem block */,
                                   progData->fsetData[filterSetPrg].amemBlock);
            if (SOC_E_NONE != auxRes) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("unit %d unable to free old action table %u"
                           " (%s) block %03X after error: %d (%s)\n"),
                           unitData->unit,
                           progData->actIndex[index],
                           unitData->actData[progData->actIndex[index]]->ucData->tableName,
                           progData->fsetData[filterSetPrg].amemBlock,
                           auxRes,
                           _SHR_ERRMSG(auxRes)));
                /* but do not return as error */
            } else {
                unitData->actData[progData->actIndex[index]]->entryActive--;
            }
        } /* for (all possible result registers) */
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
    } /* if (0 == (groupData->groupFlags & _SOC_C3_RCE_GROUP_FLAG_COUNTER)) */
    /* update previous positions for entries in the new filter set */
    for (entryCurr = fsTemp[filterSetPrgNew].entryHead;
         entryCurr && (entryCurr->entryPosition <= positionLastNew);
         entryCurr = entryCurr->entryNext) {
        entryCurr->entryPosPrev = entryCurr->entryPosition;
    }
    /* update previous positions for entries in the old filter set */
    for (entryCurr = fsTemp[filterSetPrgOld].entryHead;
         entryCurr && (entryCurr->entryPosition <= positionLastOld);
         entryCurr = entryCurr->entryNext) {
        entryCurr->entryPosPrev = entryCurr->entryPosition;
    }
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
    /* switch the program to the new filter set list */
    if (progData->fsetData[filterSetPrg].rangeInfo) {
        sal_free(progData->fsetData[filterSetPrg].rangeInfo);
    }
    sal_free(progData->fsetData);
    /* adjust range reference counts for both parts of the split filter set */
    for (index = 0; index < rangeCount; index++) {
        if (rangeRefs[index] || rangeRefsC[index]) {
            /*
             *  The new filter set refers to this range, so we need to
             *  increment the filter set references for the range itself.
             */
            unitData->rangeData[fsTemp[filterSetPrgNew].rangeInfo[index].rangeId - 1]->refCount++;
        }
        /* get rid of unused references in old filter set */
        if ((progData->fsetData[filterSetPrg].rangeInfo[index].rangeId) &&
            (!fsTemp[filterSetPrgOld].rangeInfo[index].rangeId)) {
            /*
             *  The old filter set no longer refers to this range, so we need
             *  to decrement the filter set references for the range itself.
             */
            unitData->rangeData[progData->fsetData[filterSetPrg].rangeInfo[index].rangeId - 1]->refCount--;
        }
    } /* for (all range slots in this group's filter sets) */
    progData->fsetData = fsTemp;
    /* we don't want to free this */
    fsTemp = NULL;
error:
    if (backoutNeeded) {
        /* restore previous entry positions for everything after the split */
        for (entryCurr = entryData;
             entryCurr;
             entryCurr = entryCurr->entryNext) {
            entryCurr->entryPosition = entryCurr->entryPosBackout;
        }
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
        /*
         *  Revert 'previous' position for filter sets following this one, if
         *  there are any, in this group.
         */
        if ((filterSetGrp + 1) < groupData->filterSetCount) {
            for (entryCurr = progData->fsetData[filterSetPrg + 1].entryHead;
                 entryCurr;
                 entryCurr = entryCurr->entryNext) {
                if ((~0) != entryCurr->entryPosPrev) {
                    entryCurr->entryPosPrev -= C3_RCE_ENTRIES_PER_FILTER_SET;
                } /* if (this entry has been given a position before) */
            } /* for all entries next filter set and onward */
        } /* if (there are filter sets after the split one) */
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
    }
    if (rangeRefs) {
        sal_free(rangeRefs);
    }
    if (fsTemp) {
        if ((~0) != fsTemp[filterSetPrgNew].imemStart) {
            /* any imem block here is new */
            auxRes = shr_mdb_free(unitData->imemRes,
                                  fsTemp[filterSetPrgNew].imemStart);
            if (SOC_E_NONE != auxRes) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("unable to free new instruction memory"
                           " blocks after error: %d (%s)\n"),
                           auxRes,
                           _SHR_ERRMSG(auxRes)));
                /* but do not return as error */
            } else {
                unitData->imemBlockCount--;
            }
        } /* if ((~0) != fsTemp[filterSetPrgNew].imemStart) */
        if (~0 != fsTemp[filterSetPrgNew].amemBlock) {
            /* this amem block is new */
            for (index = 0; index < SOC_C3_RCE_RESULT_REGISTER_COUNT; index++) {
                if (0 == (groupData->resultLrpUniq & (1 << index))) {
                    /* group does not use this result register */
                    continue;
                }
                auxRes = shr_mres_free(unitData->amemRes,
                                       progData->actIndex[index],
                                       1 /* one amem block */,
                                       fsTemp[filterSetPrgNew].amemBlock);
                if (SOC_E_NONE != auxRes) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META("unit %d unable to free old action table %u"
                               " (%s) block %03X after error: %d (%s)\n"),
                               unitData->unit,
                               progData->actIndex[index],
                               unitData->actData[progData->actIndex[index]]->ucData->tableName,
                               fsTemp[filterSetPrgNew].amemBlock,
                               auxRes,
                               _SHR_ERRMSG(auxRes)));
                    /* but do not return as error */
                } else {
                    unitData->actData[progData->actIndex[index]]->entryActive--;
                }
            } /* for (all possible result registers) */
        } /* if (new amem block was alloc) */
        if ((~0) != fsTemp[filterSetPrgOld].imemStart) {
            /* any imem block here is new */
            auxRes = shr_mdb_free(unitData->imemRes,
                                  fsTemp[filterSetPrgOld].imemStart);
            if (SOC_E_NONE != auxRes) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("unable to free new instruction memory"
                           " blocks after error: %d (%s)\n"),
                           auxRes,
                           _SHR_ERRMSG(auxRes)));
                /* but do not return as error */
            } else {
                unitData->imemBlockCount--;
            }
        } /* if ((~0) != fsTemp[filterSetPrgOld].imemStart) */
        if (
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
            (0 == (groupData->groupFlags & _SOC_C3_RCE_GROUP_FLAG_COUNTER)) &&
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
            (~0 != fsTemp[filterSetPrgOld].amemBlock)) {
            /* not using action indexed counters, so new act blocks ea. time */
            for (index = 0; index < SOC_C3_RCE_RESULT_REGISTER_COUNT; index++) {
                if (0 == (groupData->resultLrpUniq & (1 << index))) {
                    /* group does not use this result register */
                    continue;
                }
                auxRes = shr_mres_free(unitData->amemRes,
                                       progData->actIndex[index],
                                       1 /* one amem block */,
                                       fsTemp[filterSetPrgOld].amemBlock);
                if (SOC_E_NONE != auxRes) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META("unit %d unable to free old action table %u"
                               " (%s) block %03X after error: %d (%s)\n"),
                               unitData->unit,
                               progData->actIndex[index],
                               unitData->actData[progData->actIndex[index]]->ucData->tableName,
                               fsTemp[filterSetPrgOld].amemBlock,
                               auxRes,
                               _SHR_ERRMSG(auxRes)));
                    /* but do not return as error */
                } else {
                    unitData->actData[progData->actIndex[index]]->entryActive--;
                }
            } /* for (all possible result registers) */
        } /* if (group does not use counter and new amem block was alloc) */
        if (fsTemp[filterSetPrgOld].rangeInfo) {
            /* this was a new copy */
            sal_free(fsTemp[filterSetPrgOld].rangeInfo);
        }
        if (fsTemp[filterSetPrgNew].rangeInfo) {
            /* this was a new copy */
            sal_free(fsTemp[filterSetPrgNew].rangeInfo);
        }
        sal_free(fsTemp);
    } /* if (fsTemp) */
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
    if (entryList) {
        sal_free(entryList);
    }
    if (ctrTemp) {
        sal_free(ctrTemp);
    }
    if (SOC_E_NONE != ovrRes) {
        /* want to override result for counter update error */
        result = ovrRes;
    }
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_filter_set_entry_move
 *  Purpose
 *    Move entries between filter sets
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) progData = pointer to the program data
 *    (IN) groupData = pointer to the group data
 *    (IN) fsetSrc = source filter set in program
 *    (IN) fsetDst = destination filter set program
 *    (IN) entryData = pointer to entry before which space is to be added
 *    (IN) noempty = TRUE to avoid emptying the filter set completely
 *    (OUT) count = where to put number of entries moved (could be moved)
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Moves as many entries as it can from the source filter set to the
 *    destination filter set.
 *
 *    The filter sets must be adjacent, and in the same group.
 *
 *    If the source filter set is before the destination filter set, it moves
 *    the final entries from the source filter set to the destination filter
 *    set.  If the source filter set is after the destination filter set, it
 *    moves the initial entries from the source filter set to the destination
 *    filter set.
 *
 *    This can not move entries between filter sets if:
 *      the destination filter set is full
 *      entries added to dest filter set would require too many range refs
 *
 *    In the case of entries bringing range references across, this will move
 *    as many entries as possible, to the point of filling the destination
 *    filter set's range references.  It can not move any more after that.
 *
 *    If there is no space at the end of the destination filter set, but there
 *    is space in the destination filter set, this will use the
 *    _soc_c3_rce_entry_shift function to arrange entries to create space.
 *    This will usually result in fewer entries moved than the filter set could
 *    hold, but hopefully this works out to mean there will be less need to
 *    move the entries back in the other direction later.
 */
static int
_soc_c3_rce_filter_set_entry_move(_soc_c3_rce_unit_desc_int_t *unitData,
                                  _soc_c3_rce_program_desc_int_t *progData,
                                  _soc_c3_rce_group_desc_int_t *groupData,
                                  unsigned int fsetSrc,
                                  unsigned int fsetDst,
                                  _soc_c3_rce_entry_desc_int_t *entryData,
                                  int noempty,
                                  unsigned int *count)
{
    _soc_c3_rce_filterset_desc_int_t *fsetSrcData;/* source fset data pointer */
    _soc_c3_rce_filterset_desc_int_t *fsetDstData;/* dest fset data pointer */
    _soc_c3_rce_fset_range_info_t *rangeDst = NULL;/* temp dest range info */
    _soc_c3_rce_fset_range_info_t *rangeSrc = NULL;/* temp source range info */
    _soc_c3_rce_fset_range_info_t *rangeDstO;   /* old dest range info */
    _soc_c3_rce_fset_range_info_t *rangeSrcO;   /* old source range info */
    _soc_c3_rce_entry_desc_int_t *entryCurr;    /* working entry information */
    _soc_c3_rce_entry_desc_int_t *entryIns;     /* insertion point entry */
    _soc_c3_rce_entry_desc_int_t *fsetSrcEntryHead;/* source fset head entry */
    _soc_c3_rce_entry_desc_int_t *fsetDstEntryHead;/* dest fset head entry */
    _soc_c3_rce_entry_desc_int_t *fsetSrcEntryHeadO;/* old src fset head ent */
    _soc_c3_rce_entry_desc_int_t *fsetDstEntryHeadO;/* old dst fset head ent */
    unsigned int *rangeMapping = NULL;          /* range map workspace */
    unsigned int *rangeUnmapping = NULL;        /* range unmap workspace */
    uint8 *pattApi = NULL;                      /* range edit workspace */
    uint8 *pattHw = NULL;                       /* range edit workspace */
    uint8 *pattMask = NULL;                     /* range edit workspace */
    unsigned int fsetSrcPosMin;                 /* source fset min position */
    unsigned int fsetSrcPosMax = 0;             /* source fset max position */
    unsigned int fsetDstPosMin;                 /* dest fset min position */
    unsigned int fsetDstPosMax = 0;             /* dest fset max position */
    unsigned int positionCurr;                  /* current position */
    unsigned int positionLast;                  /* last usable position */
    unsigned int entriesMoved = 0;              /* number of entries moved */
    unsigned int rangeSrcOffset;                /* range pos in src ranges */
    unsigned int rangeDstOffset;                /* range pos in dst ranges */
    unsigned int fsetSrcEntryCount;             /* source fset entry count */
    unsigned int fsetDstEntryCount;             /* dest fset entry count */
    unsigned int fsetSrcEntryCountO;            /* old source fset ent count */
    unsigned int fsetDstEntryCountO;            /* old dest fset entry count */
    unsigned int bytesForRanges = 0;            /* bytes for range data */
    unsigned int blockIndex;                    /* instruction block */
    unsigned int instrOffset;                   /* instruction offset */
    unsigned int rangeChkEnd;                   /* range limit current blk */
    unsigned int index;                         /* working index */
    uint32 insertFlags = 0;                     /* just for discarding */
    int rangeId;                                /* range ID for copying */
    int invert;                                 /* range invert for copying */
    int direction;                              /* which direction to scan */
    int backout = FALSE;                        /* whether to undo moves */
    int result = SOC_E_NONE;
    uint8 patternApi;                           /* API pattern byte */
    uint8 patternHw;                            /* hardware pattern byte */
    uint8 patternMask;                          /* pattern mask byte */

    fsetSrcData = &(progData->fsetData[fsetSrc]);
    fsetDstData = &(progData->fsetData[fsetDst]);
    /* preserve these data for possible backout */
    rangeSrcO = fsetSrcData->rangeInfo;
    rangeDstO = fsetDstData->rangeInfo;
    fsetSrcEntryCountO = fsetSrcData->entryCount;
    fsetDstEntryCountO = fsetDstData->entryCount;
    fsetSrcEntryHeadO = fsetSrcData->entryHead;
    fsetDstEntryHeadO = fsetDstData->entryHead;
    /* make sure filter sets are in the group */
    if (fsetSrcData->groupId != groupData->groupId) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d program %u filter set %u does not belong"
                   " to group %d\n"),
                   unitData->unit,
                   unitData->groupData[fsetSrcData->groupId]->rceProgram,
                   fsetSrc,
                   groupData->groupId));
        result = SOC_E_CONFIG;
        goto error;
    }
    if (fsetSrcData->groupId != fsetDstData->groupId) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d program %u filter set %u group %d is not"
                   " same group as filter set %u group %d\n"),
                   unitData->unit,
                   unitData->groupData[fsetSrcData->groupId]->rceProgram,
                   fsetSrc,
                   fsetSrcData->groupId,
                   fsetDst,
                   fsetDstData->groupId));
        result = SOC_E_CONFIG;
        goto error;
    }
    /* filter sets must be adjacent */
    if (((fsetSrc + 1) != fsetDst) &&
        ((fsetSrc - 1) != fsetDst)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d program %u filter sets %u and %u are"
                   " not adjacent\n"),
                   unitData->unit,
                   unitData->groupData[fsetSrcData->groupId]->rceProgram,
                   fsetSrc,
                   fsetDst));
        result = SOC_E_CONFIG;
        goto error;
    }
    /* make sure destination filter set has space */
    if (fsetDstData->entryCount >= C3_RCE_ENTRIES_PER_FILTER_SET) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d program %u filter set %u already full\n"),
                   unitData->unit,
                   unitData->groupData[fsetDstData->groupId]->rceProgram,
                   fsetDst));
        /* not really an error, but need to abort (nothing to do) */
        goto error;
    }
    /* make working copy of destination filter set range info */
    rangeDst = sal_alloc(sizeof(*rangeDst) * groupData->rangesPerFilterSet,
                          "RCE range workspace");
    if (!rangeDst) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %u bytes for range workspace\n"),
                   (unsigned int)(sizeof(*rangeDst) *
                   groupData->rangesPerFilterSet)));
        result = SOC_E_MEMORY;
        goto error;
    }
    sal_memcpy(rangeDst,
               fsetDstData->rangeInfo,
               sizeof(*rangeDst) * groupData->rangesPerFilterSet);
    /* make working copy of source filter set range info */
    rangeSrc = sal_alloc(sizeof(*rangeSrc) * groupData->rangesPerFilterSet,
                          "RCE range workspace");
    if (!rangeSrc) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %u bytes for range workspace\n"),
                   (unsigned int)(sizeof(*rangeSrc) *
                   groupData->rangesPerFilterSet)));
        result = SOC_E_MEMORY;
        goto error;
    }
    sal_memcpy(rangeSrc,
               fsetSrcData->rangeInfo,
               sizeof(*rangeSrc) * groupData->rangesPerFilterSet);
    /* set up space for range mapping */
    rangeMapping = sal_alloc(sizeof(*rangeMapping) *
                             groupData->rangesPerFilterSet * 2,
                             "RCE range mapping workspace");
    if (!rangeMapping) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %u bytes for range map space\n"),
                   (unsigned int)(sizeof(*rangeMapping) *
                   groupData->rangesPerFilterSet * 2)));
        result = SOC_E_MEMORY;
        goto error;
    }
    rangeUnmapping = &(rangeMapping[groupData->rangesPerFilterSet]);
    sal_memset(rangeMapping,
               ~0,
               sizeof(*rangeMapping) * groupData->rangesPerFilterSet * 2);
    /* set up space for range editing */
    bytesForRanges = ((groupData->rangesPerFilterSet + 8) >> 3);
    pattApi = sal_alloc(bytesForRanges * 3, "RCE range editing workspace");
    if (!pattApi) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %u bytes for range editing\n"),
                   bytesForRanges * 3));
        result = SOC_E_MEMORY;
        goto error;
    }
    sal_memset(pattApi, ~0, bytesForRanges * 3);
    pattHw = &(pattApi[bytesForRanges]);
    pattMask = &(pattHw[bytesForRanges]);
    for (index = 1; index <= groupData->rangesPerFilterSet; index++) {
        pattMask[index >> 3] &= (~(1 << (index & 7)));
    }
    /* compute parameters */
    fsetSrcPosMin = fsetSrcData->filterIndex * C3_RCE_ENTRIES_PER_FILTER_SET;
    fsetSrcPosMax = fsetSrcPosMin + (C3_RCE_ENTRIES_PER_FILTER_SET - 1);
    fsetDstPosMin = fsetDstData->filterIndex * C3_RCE_ENTRIES_PER_FILTER_SET;
    fsetDstPosMax = fsetDstPosMin + (C3_RCE_ENTRIES_PER_FILTER_SET - 1);
    /* get current information into workspace */
    fsetSrcEntryCount = fsetSrcData->entryCount;
    fsetDstEntryCount = fsetDstData->entryCount;
    fsetSrcEntryHead = fsetSrcData->entryHead;
    fsetDstEntryHead = fsetDstData->entryHead;
    /* save positions for possible backout */
    backout = TRUE;
    for (entryCurr = fsetSrcData->entryHead;
         entryCurr && (entryCurr->entryPosition <= fsetSrcPosMax);
         entryCurr = entryCurr->entryNext) {
        entryCurr->entryPosBackout = entryCurr->entryPosition;
    }
    for (entryCurr = fsetDstData->entryHead;
         entryCurr && (entryCurr->entryPosition <= fsetDstPosMax);
         entryCurr = entryCurr->entryNext) {
        entryCurr->entryPosBackout = entryCurr->entryPosition;
    }
    /* select insertion point and make sure there is room */
    if (fsetSrc < fsetDst) {
        /*
         *  If source filter set comes before destination filter set, moving
         *  entries from tail of source to head of destination.
         */
        entryIns = fsetDstData->entryHead;
        if (entryIns->entryPosition == fsetDstPosMin) {
            /* no gap at beginning of destination filter set; make one */
            result = _soc_c3_rce_entry_shift(unitData,
                                             groupData,
                                             fsetDstData->filterIndex,
                                             entryIns,
                                             _SOC_C3_RCE_GROUP_INSERT_FLAG_SPACE_APPEND,
                                             &insertFlags);
            if (SOC_E_NONE != result) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("unit %d unable to create space in"
                           " beginning of program %u filter set %u:"
                           " %d (%s)\n"),
                           unitData->unit,
                           groupData->rceProgram,
                           fsetDst,
                           result,
                           _SHR_ERRMSG(result)));
                goto error;
            }
        }
        entryCurr = entryIns;
        positionCurr = entryIns->entryPosition;
        positionLast = fsetDstPosMin;
        direction = -1;
    } else { /* if (fsetSrc < fsetDst) */
        /*
         *  If destination filter set comes before source filter set, moving
         *  entries from head of source to tail of destination.
         */
        entryIns = fsetSrcData->entryHead;
        if (entryIns->entryPrev->entryPosition == fsetDstPosMax) {
            /* no gap at end of destination filter set; make one */
            result = _soc_c3_rce_entry_shift(unitData,
                                             groupData,
                                             fsetDstData->filterIndex,
                                             entryIns,
                                             _SOC_C3_RCE_GROUP_INSERT_FLAG_SPACE_PREPEND,
                                             &insertFlags);
            if (SOC_E_NONE != result) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("unit %d unable to create space in"
                           " ending of program %u filter set %u:"
                           " %d (%s)\n"),
                           unitData->unit,
                           groupData->rceProgram,
                           fsetDst,
                           result,
                           _SHR_ERRMSG(result)));
                goto error;
            }
        }
        entryCurr = entryIns->entryPrev;
        positionCurr = entryIns->entryPrev->entryPosition;
        positionLast = fsetDstPosMax;
        direction = 1;
    } /* if (fsetSrc < fsetDst) */
    RCE_EVERB((RCE_MSG1("unit %d: program %u (%u filter sets) group %d (%u"
                        " filter sets) start in direction %d at"
                        " entry %d position %u (%u); finish at position %u\n"),
               unitData->unit,
               groupData->rceProgram,
               progData->filterSetCount,
               groupData->groupId,
               groupData->filterSetCount,
               direction,
               entryCurr->entryId,
               entryCurr->entryPosition,
               positionCurr,
               positionLast));
    /* try to move entries by checking ranges and moving if okay */
    do { /*  while ((SOC_E_NONE == result) && (positionCurr != positionLast)) */
        /* go to next entry to be considered */
        positionCurr += direction;
        if (direction > 0) {
            if (positionCurr > positionLast) {
                /* all done */
                break;
            }
            if (entryCurr->entryNext == entryData) {
                /* but the next one would move the gap; must not do that */
                RCE_EVERB((RCE_MSG1("unit %d encountered intended gap before"
                                    " move was complete\n"),
                           unitData->unit));
                break;
            }
            entryCurr = entryCurr->entryNext;
        } else {
            if (positionCurr < positionLast) {
                /* all done */
                break;
            }
            if (entryCurr == entryData) {
                /* but the next one would move the gap; must not do that */
                RCE_EVERB((RCE_MSG1("unit %d encountered intended gap before"
                                    " move was complete\n"),
                           unitData->unit));
                break;
            }
            entryCurr = entryCurr->entryPrev;
        }
        sal_memset(pattApi, 0x00, bytesForRanges << 1);
        /* check whether this entry can be moved */
        for (blockIndex = 0, instrOffset = 0, patternHw = 0;
             instrOffset <= groupData->rangesPerFilterSet;
             blockIndex++, instrOffset += 8) {
            rangeChkEnd = instrOffset + 7;
            if (rangeChkEnd > groupData->rangesPerFilterSet) {
                rangeChkEnd = groupData->rangesPerFilterSet;
            }
            patternApi = entryCurr->pattData[0][blockIndex];
            if (entryCurr->pattData[0][0] & 1) {
                patternHw = entryCurr->pattData[1][blockIndex];
            }
            if ((0 == patternApi) && (0 == patternHw)) {
                /* nothing to do for this byte; skip it */
                continue;
            }
            for (index = (instrOffset?instrOffset:1),
                 patternMask = (instrOffset?1:2);
                 index <= rangeChkEnd;
                 index++, patternMask <<= 1) {
                rangeSrcOffset = index - 1;
                if (patternMask & patternApi) {
                    /* this entry has this range slot in its API state */
                    rangeId = rangeSrc[rangeSrcOffset].rangeId;
                    invert = (0 != (rangeSrc[rangeSrcOffset].rangeFlags &
                                    SOC_C3_RCE_RANGE_FLAG_INVERT));
                    RCE_EVERB((RCE_MSG1("unit %d entry %d pos %u->%u uses"
                                        " program %u filter set %u API range"
                                        " ref %u: %d,%s:%08X,%04X,%04X\n"),
                               unitData->unit,
                               entryCurr->entryId,
                               entryCurr->entryPosition,
                               positionCurr,
                               groupData->rceProgram,
                               fsetSrc,
                               rangeSrcOffset,
                               rangeId,
                               invert?"i":"n",
                               unitData->rangeData[rangeId - 1]->rangeFlags,
                               unitData->rangeData[rangeId - 1]->lowerBound,
                               unitData->rangeData[rangeId - 1]->upperBound));
                    /* find this range or a place for it in destination */
                    if (rangeMapping[rangeSrcOffset] >
                        groupData->rangesPerFilterSet) {
                        result = _soc_c3_rce_filter_set_range_find(unitData,
                                                                   groupData->rangesPerFilterSet,
                                                                   rangeDst,
                                                                   rangeId,
                                                                   invert,
                                                                   &rangeDstOffset);
                        rangeDstOffset--;
                        if (SOC_E_EMPTY == result) {
                            /* add this range to the destination, clear refs */
                            sal_memcpy(&(rangeDst[rangeDstOffset]),
                                       &(rangeSrc[rangeSrcOffset]),
                                       sizeof(rangeDst[rangeDstOffset]));
                            rangeDst[rangeDstOffset].commitCount = 0;
                            rangeDst[rangeDstOffset].refCount = 0;
                            result = SOC_E_NONE;
                        } else if (SOC_E_NONE != result) {
                            /* something went wrong; can't move this entry */
                            LOG_ERROR(BSL_LS_SOC_COMMON,
                                      (BSL_META("unit %d program %u filter set"
                                       " %u unable to accept entry %d"
                                       " because there is no available"
                                       " range slot\n"),
                                       unitData->unit,
                                       groupData->rceProgram,
                                       fsetDst,
                                       entryCurr->entryId));
                            break;
                        }
                        /* cache the map and its inverse */
                        rangeMapping[rangeSrcOffset] = rangeDstOffset;
                        rangeUnmapping[rangeDstOffset] = rangeSrcOffset;
                    } else {
                        rangeDstOffset = rangeMapping[rangeSrcOffset];
                    }
                    /* remove source range slot reference from this entry */
                    rangeSrc[rangeSrcOffset].refCount--;
                    /* add desintation range slot reference */
                    rangeDst[rangeDstOffset].refCount++;
                    RCE_EVERB((RCE_MSG1("src filter set %u range range ref %u"
                                        " now has %u,%u references to range"
                                        " %d %s\n"),
                               fsetSrc,
                               rangeSrcOffset + 1,
                               rangeSrc[rangeSrcOffset].refCount,
                               rangeSrc[rangeSrcOffset].commitCount,
                               rangeSrc[rangeSrcOffset].rangeId,
                               (rangeSrc[rangeSrcOffset].rangeFlags &
                                SOC_C3_RCE_RANGE_FLAG_INVERT)?"invert":"normal"));
                    RCE_EVERB((RCE_MSG1("dst filter set %u range range ref %u"
                                        " now has %u,%u references to range"
                                        " %d %s\n"),
                               fsetDst,
                               rangeDstOffset + 1,
                               rangeDst[rangeDstOffset].refCount,
                               rangeDst[rangeDstOffset].commitCount,
                               rangeDst[rangeDstOffset].rangeId,
                               (rangeDst[rangeDstOffset].rangeFlags &
                                SOC_C3_RCE_RANGE_FLAG_INVERT)?"invert":"normal"));
                    rangeDstOffset++;
                    pattApi[rangeDstOffset >> 3] |= (1 << (rangeDstOffset & 7));
                } /* if (this entry has this range slot in its API state) */
                if (patternMask & patternHw) {
                    /* this entry has this range slot in its hardware state */
                    rangeId = rangeSrc[rangeSrcOffset].rangeId;
                    invert = (0 != (rangeSrc[rangeSrcOffset].rangeFlags &
                                    SOC_C3_RCE_RANGE_FLAG_INVERT));
                    RCE_EVERB((RCE_MSG1("unit %d entry %d pos %u->%u uses"
                                      " program %u filter set %u HW range"
                                      " ref %u: %d,%s:%08X,%04X,%04X\n"),
                               unitData->unit,
                               entryCurr->entryId,
                               entryCurr->entryPosition,
                               positionCurr,
                               groupData->rceProgram,
                               fsetSrc,
                               rangeSrcOffset,
                               rangeId,
                               invert?"i":"n",
                               unitData->rangeData[rangeId - 1]->rangeFlags,
                               unitData->rangeData[rangeId - 1]->lowerBound,
                               unitData->rangeData[rangeId - 1]->upperBound));
                    /* find this range or a place for it in destination */
                    if (rangeMapping[rangeSrcOffset] >
                        groupData->rangesPerFilterSet) {
                        result = _soc_c3_rce_filter_set_range_find(unitData,
                                                                   groupData->rangesPerFilterSet,
                                                                   rangeDst,
                                                                   rangeId,
                                                                   invert,
                                                                   &rangeDstOffset);
                        rangeDstOffset--;
                        if (SOC_E_EMPTY == result) {
                            /* add this range to the destination, clear refs */
                            sal_memcpy(&(rangeDst[rangeDstOffset]),
                                       &(rangeSrc[rangeSrcOffset]),
                                       sizeof(rangeDst[rangeDstOffset]));
                            rangeDst[rangeDstOffset].commitCount = 0;
                            rangeDst[rangeDstOffset].refCount = 0;
                            result = SOC_E_NONE;
                        } else if (SOC_E_NONE != result) {
                            /* something went wrong; can't move this entry */
                            LOG_ERROR(BSL_LS_SOC_COMMON,
                                      (BSL_META("unit %d program %u filter set"
                                       " %u unable to accept entry %d"
                                       " because there is no available"
                                       " range slot\n"),
                                       unitData->unit,
                                       groupData->rceProgram,
                                       fsetDst,
                                       entryCurr->entryId));
                            break;
                        }
                        /* cache the map and its inverse */
                        rangeMapping[rangeSrcOffset] = rangeDstOffset;
                        rangeUnmapping[rangeDstOffset] = rangeSrcOffset;
                    } else {
                        rangeDstOffset = rangeMapping[rangeSrcOffset];
                    }
                    /* remove source range slot reference from this entry */
                    rangeSrc[rangeSrcOffset].commitCount--;
                    /* add desintation range slot reference */
                    rangeDst[rangeDstOffset].commitCount++;
                    RCE_EVERB((RCE_MSG1("src filter set %u range range ref %u"
                                        " now has %u,%u references to range"
                                        " %d %s\n"),
                               fsetSrc,
                               rangeSrcOffset + 1,
                               rangeSrc[rangeSrcOffset].refCount,
                               rangeSrc[rangeSrcOffset].commitCount,
                               rangeSrc[rangeSrcOffset].rangeId,
                               (rangeSrc[rangeSrcOffset].rangeFlags &
                                SOC_C3_RCE_RANGE_FLAG_INVERT)?"invert":"normal"));
                    RCE_EVERB((RCE_MSG1("dst filter set %u range range ref %u"
                                        " now has %u,%u references to range"
                                        " %d %s\n"),
                               fsetDst,
                               rangeDstOffset + 1,
                               rangeDst[rangeDstOffset].refCount,
                               rangeDst[rangeDstOffset].commitCount,
                               rangeDst[rangeDstOffset].rangeId,
                               (rangeDst[rangeDstOffset].rangeFlags &
                                SOC_C3_RCE_RANGE_FLAG_INVERT)?"invert":"normal"));
                    rangeDstOffset++;
                    pattHw[rangeDstOffset >> 3] |= (1 << (rangeDstOffset & 7));
                } /* if (this entyr has this range slot in its HW state */
            } /* for (each range slot in this byte) */
        } /* for (all range slots in this entry) */
        if (SOC_E_NONE == result) {
            /* put in new range references for this entry */
            entryCurr->entryFlags |= SOC_C3_RCE_ENTRY_FLAG_RANGE_UPDATE;
            for (blockIndex = 0; blockIndex < bytesForRanges; blockIndex++) {
                entryCurr->pattData[0][blockIndex] = ((entryCurr->pattData[0][blockIndex] &
                                                       pattMask[blockIndex]) |
                                                      pattApi[blockIndex]);
                entryCurr->pattData[1][blockIndex] = ((entryCurr->pattData[1][blockIndex] &
                                                       pattMask[blockIndex]) |
                                                      pattHw[blockIndex]);
            }
            /* move this entry to its new position */
            entryCurr->entryPosition = positionCurr;
            /* adjust accounting */
            fsetDstEntryCount++;
            fsetSrcEntryCount--;
            entriesMoved++;
            /* adjust head entries */
            if (direction < 0) {
                /* we just put this entry at the beginning of dst fset */
                fsetDstEntryHead = entryCurr;
            } else {
                /* we just took this entry from the beginning of src fset */
                fsetSrcEntryHead = entryCurr->entryNext;
            }
        } /* if (SOC_E_NONE == result) */
        if (noempty) {
            if (2 > fsetSrcEntryCount) {
                /* must not reduce any single filter set to zero entries */
                break;
            }
        } else {
            if (1 > fsetSrcEntryCount) {
                /* nothing left to move; reduced to zero entries in fset */
                break;
            }
        }
    } while ((SOC_E_NONE == result) && (positionCurr != positionLast));
    RCE_EVERB((RCE_MSG1("unit %d program %u filter set %u (%u -> %u),"
                        " %u (%u -> %u)\n"),
               unitData->unit,
               groupData->rceProgram,
               fsetSrc,
               fsetSrcData->entryCount,
               fsetSrcEntryCount,
               fsetDst,
               fsetDstData->entryCount,
               fsetDstEntryCount));
    for (index = 1;
         index <= C3_RCE_RANGE_MAXIMUM;
         index++) {
        int offset;
        for (offset = 0; offset < 2; offset++) {
            unsigned int beforeApi = 0;
            unsigned int afterApi = 0;
            unsigned int beforeHw = 0;
            unsigned int afterHw = 0;
            if (SOC_E_NONE ==
                _soc_c3_rce_filter_set_range_find(unitData,
                                                  groupData->rangesPerFilterSet,
                                                  fsetSrcData->rangeInfo,
                                                  index,
                                                  offset,
                                                  &rangeSrcOffset)) {
                rangeSrcOffset--;
                beforeApi += fsetSrcData->rangeInfo[rangeSrcOffset].refCount;
                beforeHw += fsetSrcData->rangeInfo[rangeSrcOffset].commitCount;
                afterApi += rangeSrc[rangeSrcOffset].refCount;
                afterHw += rangeSrc[rangeSrcOffset].commitCount;
            } else {
                rangeSrcOffset = groupData->rangesPerFilterSet;
            }
            if (SOC_E_NONE ==
                _soc_c3_rce_filter_set_range_find(unitData,
                                                  groupData->rangesPerFilterSet,
                                                  rangeDst,
                                                  index,
                                                  offset,
                                                  &rangeDstOffset)) {
                rangeDstOffset--;
                beforeApi += fsetDstData->rangeInfo[rangeDstOffset].refCount;
                beforeHw += fsetDstData->rangeInfo[rangeDstOffset].commitCount;
                afterApi += rangeDst[rangeDstOffset].refCount;
                afterHw += rangeDst[rangeDstOffset].commitCount;
            } else {
                rangeDstOffset = groupData->rangesPerFilterSet;
            }
        } /* for (both normal and inverted reference modes */
    } /* for (all possible ranges) */
    /*
     *  We only commit the destination filter set automatically here.  This
     *  is to avoid double-commit, since the source filter set is likely to
     *  become the destination filter set shortly, as a gap is rippled
     *  along a group until a space can be opened to insert a new entry,
     *  then the final filter set where the new entry is added will be
     *  updated because of the shift necessary to open the needed gap.
     */
    /* use the new range layouts and other data */
    fsetSrcData->rangeInfo = rangeSrc;
    fsetDstData->rangeInfo = rangeDst;
    fsetSrcData->entryCount = fsetSrcEntryCount;
    fsetDstData->entryCount = fsetDstEntryCount;
    fsetSrcData->entryHead = fsetSrcEntryHead;
    fsetDstData->entryHead = fsetDstEntryHead;
    /* commit the destination filter set to hardware */
    /* coverity[stack_use_overflow] */
    result = _soc_c3_rce_filter_set_update(unitData,
                                           groupData->groupId,
                                           fsetDstData->filterIndex,
                                           FALSE /* no force first */);
    if (SOC_E_NONE == result) {
        /*
         *  Success committing the new 'destination' filter set to
         *  hardware.  Leave entries and filter set states as they are (so
         *  set the 'backout' flag to FALSE), and commit changes to the
         *  top-level accounting for ranges.
         */
        backout = FALSE;
        /* get rid of old range data; keep new range data */
        for (index = 0;
             index < groupData->rangesPerFilterSet;
             index++) {
            if ((0 != rangeSrc[index].rangeId) &&
                (0 == rangeSrc[index].refCount) &&
                (0 == rangeSrc[index].commitCount)) {
                /* was used before, but it is not used now */
                unitData->rangeData[rangeSrc[index].rangeId - 1]->refCount--;
                /* clear this slot for later use */
                sal_memset(&(rangeSrc[index]),
                           0x00,
                           sizeof(*rangeSrc));
            } /* if (this range was in use before but not now) */
            if ((0 == rangeDstO[index].rangeId) &&
                (0 != rangeDst[index].rangeId)) {
                /* this range was not used before but is now */
                unitData->rangeData[rangeDst[index].rangeId - 1]->refCount++;
            } /* if (this range was not in use before but is now) */
        } /* for (all range slots in these filter sets) */
        rangeSrc = rangeSrcO;
        rangeDst = rangeDstO;
        /* mark entries as no longer having edited range data */
        for (entryCurr = fsetDstData->entryHead;
             entryCurr && (entryCurr->entryPosition <= fsetDstPosMax);
             entryCurr = entryCurr->entryNext) {
            entryCurr->entryFlags &= (~SOC_C3_RCE_ENTRY_FLAG_RANGE_UPDATE);
        }
    } else {
        /*
         *  Failed to commit the filter set to hardware; back out filter
         *  set changes and leave the 'backout' flag set so the entry
         *  position changes will be backed out shortly.
         */
        fsetSrcData->rangeInfo = rangeSrcO;
        fsetDstData->rangeInfo = rangeDstO;
        fsetSrcData->entryCount = fsetSrcEntryCountO;
        fsetDstData->entryCount = fsetDstEntryCountO;
        fsetSrcData->entryHead = fsetSrcEntryHeadO;
        fsetDstData->entryHead = fsetDstEntryHeadO;
    }
error:
    RCE_EVERB((RCE_MSG1("unit %d program %u filter set %u (%u -> %u),"
                        " %u (%u -> %u): %d (%s)\n"),
               unitData->unit,
               groupData->rceProgram,
               fsetSrc,
               fsetSrcEntryCountO,
               fsetSrcData->entryCount,
               fsetDst,
               fsetDstEntryCountO,
               fsetDstData->entryCount,
               result,
               _SHR_ERRMSG(result)));
    if (backout) {
        /* did not commit the changes, so need to back out certain changes */
        for (entryCurr = fsetSrcData->entryHead;
             entryCurr && (entryCurr->entryPosition <= fsetSrcPosMax);
             entryCurr = entryCurr->entryNext) {
            entryCurr->entryPosition = entryCurr->entryPosBackout;
            if (entryCurr->entryFlags & SOC_C3_RCE_ENTRY_FLAG_RANGE_UPDATE) {
                /* also need to back out range edits for this entry */
                sal_memset(pattApi, 0x00, bytesForRanges << 1);
                for (blockIndex = 0, instrOffset = 0, patternHw = 0;
                     instrOffset <= groupData->rangesPerFilterSet;
                     blockIndex++, instrOffset += 8) {
                    rangeChkEnd = instrOffset + 7;
                    if (rangeChkEnd > groupData->rangesPerFilterSet) {
                        rangeChkEnd = groupData->rangesPerFilterSet;
                    }
                    patternApi = entryCurr->pattData[0][blockIndex];
                    if (entryCurr->pattData[0][0] & 1) {
                        patternHw = entryCurr->pattData[1][blockIndex];
                    }
                    for (index = (instrOffset?instrOffset:1),
                         patternMask = (instrOffset?1:2);
                         index <= rangeChkEnd;
                         index++, patternMask <<= 1) {
                        rangeDstOffset = index - 1;
                        rangeSrcOffset = rangeUnmapping[rangeDstOffset];
                        if (patternMask & patternApi) {
                            pattApi[rangeSrcOffset >> 3] |= (1 << (rangeSrcOffset & 7));
                        }
                        if (patternMask & patternHw) {
                            pattHw[rangeSrcOffset >> 3] |= (1 << (rangeSrcOffset & 7));
                        }
                    } /* for (all range slots in this byte) */
                } /* for (all range slots in the fitler set) */
                for (blockIndex = 0;
                     blockIndex < bytesForRanges;
                     blockIndex++) {
                    entryCurr->pattData[0][blockIndex] = ((entryCurr->pattData[0][blockIndex] &
                                                           pattMask[blockIndex]) |
                                                          pattApi[blockIndex]);
                    entryCurr->pattData[1][blockIndex] = ((entryCurr->pattData[0][blockIndex] &
                                                           pattMask[blockIndex]) |
                                                          pattHw[blockIndex]);
                } /* for (all bytes containing range slots) */
                entryCurr->entryFlags &= (~SOC_C3_RCE_ENTRY_FLAG_RANGE_UPDATE);
            } /* if (this entry had its ranges edited) */
        } /* for (all entries in the source filter set) */
        for (entryCurr = fsetDstData->entryHead;
             entryCurr && (entryCurr->entryPosition <= fsetDstPosMax);
             entryCurr = entryCurr->entryNext) {
            entryCurr->entryPosition = entryCurr->entryPosBackout;
            if (entryCurr->entryFlags & SOC_C3_RCE_ENTRY_FLAG_RANGE_UPDATE) {
                /* also need to back out range edits for this entry */
                sal_memset(pattApi, 0x00, bytesForRanges << 1);
                for (blockIndex = 0, instrOffset = 0, patternHw = 0;
                     instrOffset <= groupData->rangesPerFilterSet;
                     blockIndex++, instrOffset += 8) {
                    rangeChkEnd = instrOffset + 7;
                    if (rangeChkEnd > groupData->rangesPerFilterSet) {
                        rangeChkEnd = groupData->rangesPerFilterSet;
                    }
                    patternApi = entryCurr->pattData[0][blockIndex];
                    if (entryCurr->pattData[0][0] & 1) {
                        patternHw = entryCurr->pattData[1][blockIndex];
                    }
                    for (index = (instrOffset?instrOffset:1),
                         patternMask = (instrOffset?1:2);
                         index <= rangeChkEnd;
                         index++, patternMask <<= 1) {
                        rangeDstOffset = index - 1;
                        rangeSrcOffset = rangeUnmapping[rangeDstOffset];
                        if (patternMask & patternApi) {
                            pattApi[rangeSrcOffset >> 3] |= (1 << (rangeSrcOffset & 7));
                        }
                        if (patternMask & patternHw) {
                            pattHw[rangeSrcOffset >> 3] |= (1 << (rangeSrcOffset & 7));
                        }
                    } /* for (all range slots in this byte) */
                } /* for (all range slots in the fitler set) */
                for (blockIndex = 0;
                     blockIndex < bytesForRanges;
                     blockIndex++) {
                    entryCurr->pattData[0][blockIndex] = ((entryCurr->pattData[0][blockIndex] &
                                                           pattMask[blockIndex]) |
                                                          pattApi[blockIndex]);
                    entryCurr->pattData[1][blockIndex] = ((entryCurr->pattData[0][blockIndex] &
                                                           pattMask[blockIndex]) |
                                                          pattHw[blockIndex]);
                } /* for (all bytes containing range slots) */
                entryCurr->entryFlags &= (~SOC_C3_RCE_ENTRY_FLAG_RANGE_UPDATE);
            } /* if (this entry had its ranges edited) */
        } /* for (all entries in the destination filter set) */
    } /* if (backout) */
    if (pattApi) {
        sal_free(pattApi);
    }
    if (rangeMapping) {
        sal_free(rangeMapping);
    }
    if (rangeDst) {
        sal_free(rangeDst);
    }
    if (rangeSrc) {
        sal_free(rangeSrc);
    }
    *count = entriesMoved;
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_filter_set_entry_move_scan
 *  Purpose
 *    Scan outward from a particular filter set, looking for filter sets in the
 *    same group that can have entries shifted to them, to make room for new
 *    entries in the group.
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) progData = pointer to the program data
 *    (IN) groupData = pointer to the group data
 *    (IN) fsetSrc = filter set in program from which entries are to be moved
 *    (IN) entryData = pointer to entry before which space must be created
 *    (OUT) count = where to put number of entries moved
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Searches outward from the specified filter set until either it can move
 *    entries out of the current filter set into the next one, or until it hits
 *    the end of the group.
 *
 *    If it finds a filter set into which some entries can be moved, attempts
 *    to propagate the move back to the original filter set, to make room in
 *    that filter set.
 *
 *    Might rearrange multiple filter sets in the attempt, particularly if
 *    range or other constraints cause problems with shifting entries.  Even if
 *    it rearranges multiple filter sets, it is still possible that it will
 *    fail to relocate entries from the original filter set due to range or
 *    other constraints.
 */
static int
_soc_c3_rce_filter_set_entry_move_scan(_soc_c3_rce_unit_desc_int_t *unitData,
                                       _soc_c3_rce_program_desc_int_t *progData,
                                       _soc_c3_rce_group_desc_int_t *groupData,
                                       unsigned int fsetSrc,
                                       _soc_c3_rce_entry_desc_int_t *entryData,
                                       unsigned int *count)
{
    unsigned int index;
    unsigned int fsetCurr;
    unsigned int moved = 0;
    int movedAnything = FALSE;
    int result = SOC_E_NONE;
    int auxRes;

    /* scan the filter sets in the group */
    if (progData->fsetData[fsetSrc].entryCount <
        C3_RCE_ENTRIES_PER_FILTER_SET) {
        /* nothing to do here; there is space */
        goto error;
    }
    for (index = 1;
         index < groupData->filterSetCount;
         index++) {
        if ((fsetSrc >= index) &&
            (progData->fsetData[fsetSrc - index].groupId ==
             groupData->groupId) &&
            (progData->fsetData[fsetSrc - index].entryCount <
             C3_RCE_ENTRIES_PER_FILTER_SET)) {
            /*
             *  This filter set is valid, belongs to the group in question, and
             *  has some space in it.  Try to propagate that space back to the
             *  origin filter set.
             */
            for (fsetCurr = (fsetSrc - index), movedAnything = FALSE;
                 fsetCurr != fsetSrc;
                 fsetCurr++) {
                /* move entries into the filter set with some space */
                result = _soc_c3_rce_filter_set_entry_move(unitData,
                                                           progData,
                                                           groupData,
                                                           fsetCurr + 1,
                                                           fsetCurr,
                                                           entryData,
                                                           TRUE,
                                                           &moved);
                if (SOC_E_NONE != result) {
                    /* called function displayed diagnostic */
                    break;
                }
                if (moved) {
                    /* managed to move some entries */
                    movedAnything = TRUE;
                } else {
                    /* but nothing moved; can't propagate nothing; give up */
                    break;
                }
            } /* for (all filter sets from current point to origin) */
            if (movedAnything) {
                /* we moved something during this attempt; update last fset */
                auxRes = _soc_c3_rce_filter_set_update(unitData,
                                                       groupData->groupId,
                                                       progData->fsetData[fsetCurr].filterIndex,
                                                       FALSE /* normal */);
                if (SOC_E_NONE == result) {
                    /* called function displayed diagnostic */
                    /* propagate error here as normal if no error yet */
                    result = auxRes;
                }
            } /* if (movedAnything) */
            if (moved || (SOC_E_NONE != result)) {
                /* succeeded or failed; either way, we're done */
                break;
            }
        } /* if (fset is valid, belongs to the group, has space) */
        if (((fsetSrc + index) < progData->filterSetCount) &&
            (progData->fsetData[fsetSrc + index].groupId ==
             groupData->groupId) &&
            (progData->fsetData[fsetSrc + index].entryCount <
             C3_RCE_ENTRIES_PER_FILTER_SET)) {
            /*
             *  This filter set is valid, belongs to the group in question, and
             *  has some space in it.  Try to propagate that space back to the
             *  origin filter set.
             */
            for (fsetCurr = (fsetSrc + index);
                 fsetCurr != fsetSrc;
                 fsetCurr--) {
                /* move entries into the filter set with some space */
                result = _soc_c3_rce_filter_set_entry_move(unitData,
                                                           progData,
                                                           groupData,
                                                           fsetCurr - 1,
                                                           fsetCurr,
                                                           entryData,
                                                           TRUE,
                                                           &moved);
                if (SOC_E_NONE != result) {
                    /* called function displayed diagnostic */
                    break;
                }
                if (moved) {
                    /* managed to move some entries */
                    movedAnything = TRUE;
                } else {
                    /* but nothing moved; can't propagate nothing; give up */
                    break;
                }
            } /* for (all filter sets from current point to origin) */
            if (movedAnything) {
                /* we moved something during this attempt; update last fset */
                auxRes = _soc_c3_rce_filter_set_update(unitData,
                                                       groupData->groupId,
                                                       progData->fsetData[fsetCurr].filterIndex,
                                                       FALSE /* normal */);
                if (SOC_E_NONE == result) {
                    /* called function displayed diagnostic */
                    /* propagate error here as normal if no error yet */
                    result = auxRes;
                }
            } /* if (movedAnything) */
            if (moved || (SOC_E_NONE != result)) {
                /* succeeded or failed; either way, we're done */
                break;
            }
        } /* if (fset is valid, belongs to the group, has space) */
    } /* for (all filter sets in this group) */
error:
    if ((SOC_E_NONE == result) &&
        (0 == *count)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d group %d contains no entry gaps that could"
                   " be moved into filter set %u to make room for a"
                   " new entry to be added\n"),
                   unitData->unit,
                   groupData->groupId,
                   progData->fsetData[fsetSrc].filterIndex));
    }
    /* indicate how many entries moved */
    *count = moved;
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_entry_create
 *  Purpose
 *    Adds an entry to an existing group
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) groupId = group ID into which the new entry will be placed
 *    (IN) entryId = entry ID for the new entry
 *    (IN) priority = priority for the new entry
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Only commits the new entry to hardware if copying from an existing entry
 *    that is committed to hardware and both ...COPY_SOURCE_QUALS and
 *    ...COPY_SOURCE_INST flags are set.
 *
 *    Because of what it might have to do to insert an entry, it is possible
 *    that all filter sets in the entire group can be updated.
 */
static int
_soc_c3_rce_entry_create(_soc_c3_rce_unit_desc_int_t *unitData,
                         uint32 flags,
                         int groupId,
                         int entryId,
                         int priority,
                         int sourceEntry)
{
    _soc_c3_rce_program_desc_int_t *programData;
    _soc_c3_rce_group_desc_int_t *groupData;
    _soc_c3_rce_entry_desc_int_t *entryNext;
    _soc_c3_rce_entry_desc_int_t *entryPrev;
    _soc_c3_rce_entry_desc_int_t *newEntryData = NULL;
    _soc_c3_rce_entry_desc_int_t *srcEntryData = NULL;
    _soc_c3_rce_fset_range_info_t *rangeTemp = NULL;
    unsigned int *rangeTranslate = NULL;        /* range translation list */
    unsigned int index;                         /* general index */
    unsigned int offset;                        /* general index */
    unsigned int allocSize;                     /* alloc size/offs workspace */
    unsigned int positionFirst;                 /* first position in fset */
    unsigned int positionLast;                  /* last position in fset */
    unsigned int filterSetProg;                 /* new entry fset in program */
    unsigned int filterSetProgPrev;             /* prev entry fset in program */
    unsigned int filterSetProgNext;             /* next entry fset in program */
    unsigned int filterSetUsedNext;             /* used space in next fset */
    unsigned int filterSetUsedPrev;             /* used space in prev fset */
    unsigned int filterSetGrpSrc;               /* source entry fset in group */
    unsigned int filterSetProgSrc;              /* source entry fset in prog */
    int filterSetGrp;                           /* new entry fset in group */
    int filterSetGrpPrev;                       /* prev entry fset in group */
    int filterSetGrpNext;                       /* next entry fset in group */
    int positionPrev;                           /* prev entry posn in group */
    int positionNext;                           /* next entry posn in group */
    int result = SOC_E_NONE;
#if (C3_RCE_FILTER_SET_SPLIT_BALANCING || C3_RCE_ENABLE_ENTRY_INSERT_HEURISTIC)
    _soc_c3_rce_entry_desc_int_t *entryCurr;
#endif /* (C3_RCE_FILTER_SET_SPLIT_BALANCING || C3_RCE_ENABLE_ENTRY_INSERT_HEURISTIC) */
#if C3_RCE_ENABLE_ENTRY_INSERT_HEURISTIC
    int backoutNeeded = FALSE;
    uint8 insertFlags = 0;
#endif /* C3_RCE_ENABLE_ENTRY_INSERT_HEURISTIC */

    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META("unit %d create entry %d in group %d\n"),
                 unitData->unit,
                 entryId,
                 groupId));
    groupData = unitData->groupData[groupId];
    programData = unitData->progData[groupData->rceProgram];
    if (flags & SOC_C3_RCE_ENTRY_COPY_SOURCE_ALL) {
        if ((0 > sourceEntry) || (unitData->entryLimit <= sourceEntry)) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("using invalid source entry %d\n"),
                       sourceEntry));
            result = SOC_E_BADID;
            goto error;
        }
        srcEntryData = unitData->entryData[sourceEntry];
        rangeTranslate = sal_alloc(sizeof(*rangeTranslate) *
                                   groupData->rangesPerFilterSet,
                                   "range translation workspace");
        if (!rangeTranslate) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to allocate %d bytes for range"
                       " translation workspace\n"),
                       (unsigned int)(sizeof(*rangeTranslate) *
                       groupData->rangesPerFilterSet)));
            result = SOC_E_MEMORY;
            goto error;
        }
        sal_memset(rangeTranslate,
                   0x00,
                   sizeof(*rangeTranslate) * groupData->rangesPerFilterSet);
        rangeTemp = sal_alloc(sizeof(*rangeTemp) *
                              groupData->rangesPerFilterSet,
                              "range counters workspace");
        if (!rangeTemp) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to allocate %d bytes for range"
                       " counter workspace\n"),
                       (unsigned int)(sizeof(*rangeTemp) *
                       groupData->rangesPerFilterSet)));
            result = SOC_E_MEMORY;
            goto error;
        }
        /* will initialise this memory cell later, once we know dest fset */
    }
    /* need space for the entry's descriptor + 2 times data size */
    allocSize = sizeof(*newEntryData) + (groupData->dataSize << 1);
    /* now allocate the descriptor */
    newEntryData = sal_alloc(allocSize, "C3 RCE entry data");
    if (!newEntryData) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %d bytes for new entry\n"),
                   allocSize));
        result = SOC_E_MEMORY;
        goto error;
    }
    /* this must occur if alloc is successful */
    sal_memset(newEntryData, 0x00, allocSize);
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
    newEntryData->entryPosPrev = ~0;
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
    /* set up pointer for qualifier data */
    newEntryData->pattData[0] = (uint8*)(&(newEntryData[1]));
    newEntryData->pattData[1] = &(newEntryData->pattData[0][groupData->dataSize]);
    allocSize = groupData->instrBlocks;
    /* set up pointers for action data */
    for (index = 0; index < SOC_C3_RCE_RESULT_REGISTER_COUNT; index++) {
        if (groupData->resultLrp & (1 << index)) {
            /* this result register is being used by this group */
            for (offset = 0; offset < index; offset++) {
                if ((groupData->resultLrpUniq & (1 << offset)) &&
                    (programData->actIndex[offset] ==
                     programData->actIndex[index])) {
                    /* uses the same action table, so same action data */
                    break;
                }
            }
            if (offset < index) {
                /* uses action data space we already allocated */
                newEntryData->actData[0][index] = newEntryData->actData[0][offset];
                newEntryData->actData[1][index] = newEntryData->actData[1][offset];
            } else { /* if (offset < index) */
                /* need to assign new action space for this one */
                newEntryData->actData[0][index] = &(newEntryData->pattData[0][allocSize]);
                newEntryData->actData[1][index] = &(newEntryData->pattData[1][allocSize]);
                allocSize += unitData->actData[programData->actIndex[index]]->actionBytes;
            } /* if (offset < index) */
        } /* if (the group uses this result register) */
    } /* for (all possible result registers) */
    /* Figure out where to insert relative to other entries, by priority */
    for (index = 0, entryNext = groupData->entryHead, entryPrev = NULL;
         entryNext &&
         (0 >= _soc_c3_rce_entry_prio_compare(priority,
                                              entryNext->entryPriority));
         index++, entryPrev = entryNext, entryNext = entryNext->entryNext) {
    } /* for (all entries in group at higher priority than proposed) */
    /*
     *  At this point, entryPrev is the entry *before* where the new one goes,
     *  and entryNext is the entry *after* where the new one goes.
     */
    do {
        /* determine position of either adjacent entries or group bounds */
        if (entryPrev) {
            /* new entry is not the first in the group */
            positionPrev = entryPrev->entryPosition;
            filterSetGrpPrev = positionPrev / C3_RCE_ENTRIES_PER_FILTER_SET;
        } else {
            /* new entry is the first in the group */
            positionPrev = -1;
            filterSetGrpPrev = -1;
        }
        if (entryNext) {
            /* new entry is not the last in the group */
            positionNext = entryNext->entryPosition;
            filterSetGrpNext = positionNext / C3_RCE_ENTRIES_PER_FILTER_SET;
        } else {
            /* new entry is the last in the group */
            if (0 > filterSetGrpPrev) {
                /* but there is no first entry either */
                filterSetGrpNext = 1;
            } else {
                /* and the group does have an earlier entry */
                filterSetGrpNext = groupData->filterSetCount;
            }
            positionNext = filterSetGrpNext * C3_RCE_ENTRIES_PER_FILTER_SET;
        }
        /*
         *  Get filter set index in program for the previous entry in this
         *  group and the next entry in this group.  Since it's a bit tedious
         *  to look for both, we will look for only one and then derive the
         *  other from that.
         *
         *  This is possible because all filter sets of a group will be
         *  contiguous within a program, and filter sets in a group will be
         *  numbered contiguously from zero through as high as needed for the
         *  group.
         */
        if (entryPrev) {
            /* previous entry exists, get its filter set in the program */
            result = _soc_c3_rce_filter_set_locate(unitData,
                                                   programData,
                                                   groupId,
                                                   filterSetGrpPrev,
                                                   &filterSetProgPrev);
            if (SOC_E_NONE != result) {
                /* called function displayed diagnostic */
                goto error;
            }
            if (filterSetGrpPrev < filterSetGrpNext) {
                /* there is a next filter set */
                filterSetProgNext = filterSetProgPrev + 1;
            } else {
                /* there is no next filter set */
                filterSetProgNext = filterSetProgPrev;
            }
        } else { /* if (entryPrev) */
            /*
             *  Whether the next entry exists or not, since the new entry is
             *  being placed in the initial filter set for the group, and the
             *  only way a filter set is allowed to have zero entries is for an
             *  empty group, both of the filter set index values need to be
             *  zero, and so the position of the filter sets in the program is
             *  computed thence.
             */
            result = _soc_c3_rce_filter_set_locate(unitData,
                                                   programData,
                                                   groupId,
                                                   0,
                                                   &filterSetProgNext);
            if (SOC_E_NONE != result) {
                /* called function displayed diagnostic */
                goto error;
            }
            filterSetProgPrev = filterSetProgNext;
        } /* if (entryPrev) */
        /* place this entry in a particular filter set */
        if (filterSetProgPrev < programData->filterSetCount) {
            filterSetUsedPrev = programData->fsetData[filterSetProgPrev].entryCount;
        } else {
            filterSetUsedPrev = C3_RCE_ENTRIES_PER_FILTER_SET;
        }
        if (filterSetProgNext < programData->filterSetCount) {
            filterSetUsedNext = programData->fsetData[filterSetProgNext].entryCount;
        } else {
            filterSetUsedNext = C3_RCE_ENTRIES_PER_FILTER_SET;
        }
        if (0 > filterSetGrpPrev) {
            /* there is no previous entry; must be in filter set zero */
            filterSetGrp = 0;
            filterSetProg = filterSetProgNext;
        } else if (filterSetGrpPrev == filterSetGrpNext) {
            /* next and prev in same filter set; use prev */
            filterSetGrp = filterSetGrpPrev;
            filterSetProg = filterSetProgPrev;
        } else {
            /* next and prev are not in same filter set */
            if (groupData->filterSetCount <= filterSetGrpNext) {
                /* next filter set is virtual; must use last valid */
                filterSetGrp = groupData->filterSetCount - 1;
                result = _soc_c3_rce_filter_set_locate(unitData,
                                                       programData,
                                                       groupId,
                                                       filterSetGrp,
                                                       &filterSetProg);
                if (SOC_E_NONE != result) {
                    /* called function displayed diagnostic */
                    goto error;
                }
            } else if (filterSetUsedPrev < filterSetUsedNext) {
                /* previous filter set has more space; use prev */
                filterSetGrp = filterSetGrpPrev;
                filterSetProg = filterSetProgPrev;
            } else {
                /* previous filter set does not have more space; use next */
                filterSetGrp = filterSetGrpNext;
                filterSetProg = filterSetProgNext;
            }
        }
        positionFirst = filterSetGrp * C3_RCE_ENTRIES_PER_FILTER_SET;
        positionLast = positionFirst + (C3_RCE_ENTRIES_PER_FILTER_SET - 1);
        if (positionPrev < positionFirst) {
            positionPrev = positionFirst - 1;
        }
        if (positionNext > positionLast) {
            positionNext = positionLast + 1;
        }
        RCE_EVERB((RCE_MSG1("unit %d add new entry %d(-,%u,%d,%u) to"
                            " program %u (%s) (%u fsets) group %d (%u fsets)"
                            " after entry %d(%u,%u,%d,%u) and before"
                            " entry %d(%u,%u,%d,%u), %u..%u\n"),
                   unitData->unit,
                   entryId,
                   filterSetProg,
                   filterSetGrp,
                   programData->fsetData[filterSetProg].entryCount,
                   groupData->rceProgram,
                   programData->ucData->programName,
                   programData->filterSetCount,
                   groupData->groupId,
                   groupData->filterSetCount,
                   entryPrev?entryPrev->entryId:-1,
                   positionPrev,
                   filterSetProgPrev,
                   filterSetGrpPrev,
                   filterSetUsedPrev,
                   entryNext?entryNext->entryId:-1,
                   positionNext,
                   filterSetProgNext,
                   filterSetGrpNext,
                   filterSetUsedNext,
                   positionFirst,
                   positionLast));
        if (programData->fsetData[filterSetProg].entryCount >=
            C3_RCE_ENTRIES_PER_FILTER_SET) {
            /*
             *  This filter set is full.  We are here because the next and
             *  previous entries are in the same (full) filter set, or because
             *  the filter sets for the previous and next entries are both full
             *  (if they are in different filter sets).  We need to make room
             *  for this entry by either pushing entries from this filter set
             *  into adjacent filter sets (if the group has filter sets with
             *  free space) or by splitting this filter set (if all the group's
             *  filter sets are full).
             */
            /*
             *  First try moving some of the entries into another filter set
             *  that has some room.  This can practically thrash every filter
             *  set in the entire group trying to arrange space, and still
             *  fail, but in the name of capacaity we try it first.
             */
            result = _soc_c3_rce_filter_set_entry_move_scan(unitData,
                                                            programData,
                                                            groupData,
                                                            filterSetProg,
                                                            entryNext,
                                                            &index);
            if (SOC_E_NONE != result) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("unit %d program %u was unable to shift"
                           " free space into filter set %u (group %d"
                           " filter set %u): %d (%s)\n"),
                           unitData->unit,
                           groupData->rceProgram,
                           filterSetProg,
                           groupData->groupId,
                           filterSetGrp,
                           result,
                           _SHR_ERRMSG(result)));
                goto error;
            }
            if ((index) ||
                ((filterSetProgPrev < programData->filterSetCount) &&
                 (filterSetUsedPrev != programData->fsetData[filterSetProgPrev].entryCount)) ||
                ((filterSetProgNext < programData->filterSetCount) &&
                 (filterSetUsedNext != programData->fsetData[filterSetProgNext].entryCount))) {
                /*
                 *  Either we successfully moved some free space to the filter
                 *  set where we want to put the entries, or at least moved
                 *  some free space to the filter set before or after the place
                 *  where the entry is meant to go.  Need to recirculate now to
                 *  confirm where to put the entry, or change where the entry
                 *  will be put to adjust for the newly available space.
                 */
                RCE_EVERB((RCE_MSG1("unit %d shifted %u entries space into the"
                                    " filter set for the proposed new entry\n"),
                           unitData->unit,
                           index));
                continue;
            }
            /*
             *  Was unable to move entries into any other filter sets even
             *  cascading them.  Need to split this filter set to add any more
             *  entries to this group.
             */
#if C3_RCE_FILTER_SET_SPLIT_BALANCING
            /* start with proposed new entry */
            entryCurr = entryNext;
            if ((entryCurr) &&
                (entryCurr->entryPosition > positionFirst) &&
                (entryCurr->entryPosition <= positionLast)) {
                /*
                 *  Proposed entry insertion point is not before the first
                 *  entry in this filter set, nor after the last entry in this
                 *  filter set.  We should check whether to balance the split.
                 */
                index = entryCurr->entryPosition - positionFirst;
                if ((index < ((C3_RCE_ENTRIES_PER_FILTER_SET / 2) -
                              C3_RCE_FILTER_SET_SPLIT_BALANCING_THRESHOLD)) ||
                    (index > ((C3_RCE_ENTRIES_PER_FILTER_SET / 2) +
                               C3_RCE_FILTER_SET_SPLIT_BALANCING_THRESHOLD))) {
                    /*
                     *  This entry is too far from the centre; instead, split
                     *  the filter set at the centre and then deal with
                     *  reshuffling the entries in the one that will have the
                     *  new entry later.
                     */
                    for (index = 0,
                         entryCurr = programData->fsetData[filterSetProg].entryHead;
                         index < (C3_RCE_ENTRIES_PER_FILTER_SET / 2);
                         index++, entryCurr = entryCurr->entryNext) {
                        /* scan to the middle of the filter set */
                    }
                    RCE_EVERB((RCE_MSG1("proposed split was too far from the"
                                        " centre of the filter set; adjusted"
                                        " split occurs between entry %d(%u)"
                                        " and entry %d(%u)\n"),
                               entryCurr->entryPrev->entryId,
                               entryCurr->entryPrev->entryPosition,
                               entryCurr->entryId,
                               entryCurr->entryPosition));
                } /* if (entry is too far off centre) */
            } /* if (insertion point is not at filter set boundary) */
            result = _soc_c3_rce_filter_set_split(unitData,
                                                  programData,
                                                  groupData,
                                                  entryCurr,
                                                  filterSetGrp,
                                                  filterSetProg,
                                                  positionFirst,
                                                  positionLast);
#else /* C3_RCE_FILTER_SET_SPLIT_BALANCING */
            result = _soc_c3_rce_filter_set_split(unitData,
                                                  programData,
                                                  groupData,
                                                  entryNext,
                                                  filterSetGrp,
                                                  filterSetProg,
                                                  positionFirst,
                                                  positionLast);
#endif /* C3_RCE_FILTER_SET_SPLIT_BALANCING */
            if (SOC_E_NONE != result) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("unit %d unable to split existing filter set"
                           " in program %u group %d to add new entry:"
                           " %d (%s)\n"),
                           unitData->unit,
                           groupData->rceProgram,
                           groupData->groupId,
                           result,
                           _SHR_ERRMSG(result)));
                goto error;
            }
        } else
#if C3_RCE_ENABLE_ENTRY_INSERT_HEURISTIC
        if ((positionPrev + 1) >= positionNext) {
            /*
             *  There is room in this filter set but there is no gap where we
             *  want to put the new entry.  Rearrange entries to open a gap
             *  where the new entry should go.
             */
            /* save current positions in case we need to back out changes */
            for (entryCurr = groupData->entryHead;
                 entryCurr;
                 entryCurr = entryCurr->entryNext) {
                entryCurr->entryPosBackout = entryCurr->entryPosition;
            }
            backoutNeeded = TRUE;
            result = _soc_c3_rce_entry_shift(unitData,
                                             groupData,
                                             filterSetGrp,
                                             entryNext,
                                             groupData->groupFlags,
                                             &groupData->groupFlags);
            if (SOC_E_NONE != result) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("unit %d unable to shift entries to make"
                           " space in group %d before entry %d:"
                           " %d (%s)\n"),
                           unitData->unit,
                           groupId,
                           entryNext?entryNext->entryId:-1,
                           result,
                           _SHR_ERRMSG(result)));
                goto error;
            }
            result = _soc_c3_rce_filter_set_update(unitData,
                                                   groupData->groupId,
                                                   filterSetGrp,
                                                   FALSE /* no force first */);
            if (SOC_E_NONE != result) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("unit %d unable to commit program %u"
                                    " filter set %u (group %d filter set %u)"
                                    " after shifting entries: %d (%s)\n"),
                           unitData->unit,
                           groupData->rceProgram,
                           filterSetProg,
                           groupData->groupId,
                           filterSetGrp,
                           result,
                           _SHR_ERRMSG(result)));
                goto error;
            }
        } else
#endif /* C3_RCE_ENABLE_ENTRY_INSERT_HEURISTIC */
        {
            /*
             *  There is room in the filter set and we do not need to rearrange
             *  entries in order to squeeze the proposed entry where it goes.
             */
            break;
        }
    } while (TRUE);
    RCE_EVERB((RCE_MSG1("unit %d add new entry %d(-,%u,%d,%u) to"
                        " program %u (%s) (%u fsets) group %d (%u fsets)"
                        " after entry %d(%u,%u,%d,%u) and before"
                        " entry %d(%u,%u,%d,%u), %u..%u\n"),
               unitData->unit,
               entryId,
               filterSetProg,
               filterSetGrp,
               programData->fsetData[filterSetProg].entryCount,
               groupData->rceProgram,
               programData->ucData->programName,
               programData->filterSetCount,
               groupData->groupId,
               groupData->filterSetCount,
               entryPrev?entryPrev->entryId:-1,
               positionPrev,
               filterSetProgPrev,
               filterSetGrpPrev,
               filterSetUsedPrev,
               entryNext?entryNext->entryId:-1,
               positionNext,
               filterSetProgNext,
               filterSetGrpNext,
               filterSetUsedNext,
               positionFirst,
               positionLast));
    newEntryData->entryId = entryId;
    newEntryData->entryPriority = priority;
    newEntryData->entryGroup = groupId;
    newEntryData->entryNext = entryNext;
    newEntryData->entryPrev = entryPrev;
    newEntryData->entryPosition = ~0;
    /* build pattern and action defaults */
    if (flags & SOC_C3_RCE_ENTRY_COPY_SOURCE_QUALS) {
        /* get this filter set's range information */
        sal_memcpy(rangeTemp,
                   programData->fsetData[filterSetProg].rangeInfo,
                   sizeof(*rangeTemp) * groupData->rangesPerFilterSet);
        /* use data from another entry */
        sal_memcpy(newEntryData->pattData[0],
                   srcEntryData->pattData[0],
                   groupData->instrBlocks);
        sal_memcpy(newEntryData->pattData[1],
                   srcEntryData->pattData[1],
                   groupData->instrBlocks);
        if (0 == (flags & SOC_C3_RCE_ENTRY_COPY_SOURCE_INST)) {
            /* don't copy 'installed' state from source entry */
            newEntryData->pattData[0][0] &= (~1);
            newEntryData->pattData[1][0] &= (~1);
        }
        filterSetGrpSrc = (srcEntryData->entryPosition /
                           C3_RCE_ENTRIES_PER_FILTER_SET);
        result = _soc_c3_rce_filter_set_locate(unitData,
                                               programData,
                                               groupId,
                                               filterSetGrpSrc,
                                               &filterSetProgSrc);
        if (SOC_E_NONE != result) {
            /* called function displayed diagnostic */
            goto error;
        }
        if (filterSetProg == filterSetProgSrc) {
            /* need to adjust range reference counts in this filter set */
            for (index = 1; index <= groupData->rangesPerFilterSet; index++) {
                if (newEntryData->pattData[0][index >> 3] & (1 << (index & 7))) {
                    rangeTemp[index - 1].refCount++;
                }
                if (newEntryData->pattData[0][0] & 1) {
                    if (newEntryData->pattData[1][index >> 3] & (1 << (index & 7))) {
                        rangeTemp[index - 1].commitCount++;
                    }
                }
            } /* for (all ranges per filter set in this group) */
        } else { /* if (filterSetProg == filterSetProgSrc) */
            /* need to translate ranges between filter sets */
            for (index = 1; index <= groupData->rangesPerFilterSet; index++) {
                if ((newEntryData->pattData[0][index >> 3] & (1 << (index & 7))) ||
                    (newEntryData->pattData[1][index >> 3] & (1 << (index & 7)))) {
                    /* entry uses this range; look it up in new fset */
                    result = _soc_c3_rce_filter_set_range_find(unitData,
                                                               groupData->rangesPerFilterSet,
                                                               rangeTemp,
                                                               programData->fsetData[filterSetProgSrc].rangeInfo[index - 1].rangeId,
                                                               programData->fsetData[filterSetProgSrc].rangeInfo[index - 1].rangeFlags &
                                                               SOC_C3_RCE_RANGE_FLAG_INVERT,
                                                               &(rangeTranslate[index - 1]));
                    if (SOC_E_EMPTY == result) {
                        /* range is not yet in new fset; add it */
                        sal_memcpy(&(rangeTemp[rangeTranslate[index - 1] - 1]),
                                   &(programData->fsetData[filterSetProgSrc].rangeInfo[index - 1]),
                                   sizeof(rangeTemp[rangeTranslate[index - 1] - 1]));
                        rangeTemp[rangeTranslate[index - 1] - 1].refCount = 0;
                        rangeTemp[rangeTranslate[index - 1] - 1].commitCount = 0;
                    } else if (SOC_E_NONE != result) {
                        /* something went wrong */
                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                  (BSL_META("unable to find range %u %s in unit"
                                   " %d program %u (%s) filter set %u,"
                                   " or add the range there: %d (%s)\n"),
                                   programData->fsetData[filterSetProgSrc].rangeInfo[index - 1].rangeId,
                                   (programData->fsetData[filterSetProgSrc].rangeInfo[index - 1].rangeFlags &
                                   SOC_C3_RCE_RANGE_FLAG_INVERT)?"invert":"normal",
                                   unitData->unit,
                                   groupData->rceProgram,
                                   programData->ucData->programName,
                                   filterSetProg,
                                   result,
                                   _SHR_ERRMSG(result)));
                        goto error;
                    }
                    /* adjust reference count and remove old bit */
                    if (newEntryData->pattData[0][index >> 3] & (1 << (index & 7))) {
                        rangeTemp[rangeTranslate[index - 1] - 1].refCount++;
                        newEntryData->pattData[0][index >> 3] &= (~(1 << (index & 7)));
                    }
                    if (newEntryData->pattData[1][index >> 3] & (1 << (index & 7))) {
                        if (newEntryData->pattData[0][0] & 1) {
                            rangeTemp[rangeTranslate[index - 1] - 1].commitCount++;
                        }
                        newEntryData->pattData[1][index >> 3] &= (~(1 << (index & 7)));
                    }
                } /* if (this range is in the qualifiers for the entry) */
            } /* for (all ranges per filter set in this group) */
            for (index = 1; index <= groupData->rangesPerFilterSet; index++) {
                /* replace old bits with new ones */
                offset = rangeTranslate[index - 1];
                if (!offset) {
                    /* we did not translate this one, so no reference here */
                    continue;
                }
                if (srcEntryData->pattData[0][index >> 3] & (1 << (index & 7))) {
                    newEntryData->pattData[0][offset >> 3] |= (1 << (offset & 7));
                }
                if (srcEntryData->pattData[1][index >> 3] & (1 << (index & 7))) {
                    newEntryData->pattData[1][offset >> 3] |= (1 << (offset & 7));
                }
            } /* for (all ranges per filter set in this group) */
        } /* if (filterSetProg == filterSetProgSrc) */
    } else { /* if (flags & SOC_C3_RCE_ENTRY_CREATE_COPY_SOURCE_QUALS) */
        /* use defaults from the group */
        sal_memcpy(newEntryData->pattData[0],
                   groupData->defaultPattern,
                   groupData->instrBlocks);
        sal_memcpy(newEntryData->pattData[1],
                   groupData->defaultPattern,
                   groupData->instrBlocks);
    } /* if (flags & SOC_C3_RCE_ENTRY_CREATE_COPY_SOURCE_QUALS) */
    for (index = 0; index < SOC_C3_RCE_RESULT_REGISTER_COUNT; index++) {
        if (groupData->resultLrpUniq & (1 << index)) {
            if (flags & SOC_C3_RCE_ENTRY_COPY_SOURCE_ACTS) {
                /* copying actions from another entry */
                sal_memcpy(newEntryData->actData[0][index],
                           srcEntryData->actData[0][index],
                           unitData->actData[programData->actIndex[index]]->actionBytes);
                sal_memcpy(newEntryData->actData[1][index],
                           srcEntryData->actData[1][index],
                           unitData->actData[programData->actIndex[index]]->actionBytes);
            } else { /* if (flags & SOC_C3_RCE_ENTRY_CREATE_COPY_SOURCE_ACTS) */
                /* use defaults from the action table */
                sal_memcpy(newEntryData->actData[0][index],
                           unitData->actData[programData->actIndex[index]]->defaultActions,
                           unitData->actData[programData->actIndex[index]]->actionBytes);
                sal_memcpy(newEntryData->actData[1][index],
                           unitData->actData[programData->actIndex[index]]->defaultActions,
                           unitData->actData[programData->actIndex[index]]->actionBytes);
            } /* if (flags & SOC_C3_RCE_ENTRY_CREATE_COPY_SOURCE_ACTS) */
        } /* if (groupData->resultLrpUniq & (1 << index)) */
    } /* for (index = 0; index < SOC_C3_RCE_RESULT_REGISTER_COUNT; index++) */
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
    if (flags & SOC_C3_RCE_ENTRY_COPY_SOURCE_CTRS) {
        /* need to copy action-indexed counter basis values (were zeroed) */
        sal_memcpy(&(newEntryData->basisCounts[0]),
                   &(srcEntryData->basisCounts[0]),
                   sizeof(newEntryData->basisCounts[0]) *
                   SOC_C3_RCE_NUM_BASIS_COUNTERS);
    }
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
    /* copy pattern and action defaults to HW state */
    if (entryNext) {
        /* somewhere within the group's entries; insert before this one */
        entryNext->entryPrev = newEntryData;
    } else { /* if (entryNext) */
        /* fell off the end of the group's entries; add to the tail */
        groupData->entryTail = newEntryData;
    } /* if (entryNext) */
    if (entryPrev) {
        /* there is an entry before this one; it must link here */
        entryPrev->entryNext = newEntryData;
    } else { /* if (entryPrev) */
        /* this new entry is the first in the group (and its first fset) */
        groupData->entryHead = newEntryData;
        programData->fsetData[filterSetProg].entryHead = newEntryData;
    } /* if (entryPrev) */
    if ((newEntryData->entryNext ==
         programData->fsetData[filterSetProg].entryHead)) {
        /*
         *  The next entry is in the same filter set as this one, and was the
         *  head for that filter set.  Since this one comes before it, this
         *  entry is now the head for the filter set.
         */
        programData->fsetData[filterSetProg].entryHead = newEntryData;
    }
    /* account for the new entry */
    groupData->entryCount++;
    programData->fsetData[filterSetProg].entryCount++;
    unitData->entryData[entryId] = newEntryData;
#if C3_RCE_ENABLE_ENTRY_INSERT_HEURISTIC
    /* recalculate entry positions as necessary, but hopefully only so */
    insertFlags = (groupData->groupFlags &
                   (~_SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_MASK));
    if (newEntryData->entryNext) {
        /* at least one entry follows new one in this group */
        insertFlags |= _SOC_C3_RCE_ENTRY_INSERT_FLAG_HAS_NEXT;
        if (newEntryData->entryPrev) {
            /* at least one entry follows and preceeds new one in this group */
            insertFlags |= _SOC_C3_RCE_ENTRY_INSERT_FLAG_HAS_PREV;
            /* now we know there's a gap between the prev and next entry */
            if ((newEntryData->entryPrev->entryId == groupData->entryLastAdded) ||
                (newEntryData->entryPrev->entryPriority == newEntryData->entryPriority) ||
                (newEntryData->entryPrev->entryPriority == (newEntryData->entryPriority + 1))) {
                /*
                 *  Last one added was before this gap, or the one just before
                 *  this gap has equal priority or priority one higher than
                 *  this entry; stick this entry next to that one.
                 */
                newEntryData->entryPosition = newEntryData->entryPrev->entryPosition + 1;
                insertFlags |= _SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_APPEND;
            } else if ((newEntryData->entryNext->entryId == groupData->entryLastAdded) ||
                       (newEntryData->entryNext->entryPriority == (newEntryData->entryPriority - 1))) {
                /*
                 *  Last one added was after this gap, or the one just after
                 *  this gap has priority of one lower than this entry; stick
                 *  this entry next to that one.
                 */
                newEntryData->entryPosition = newEntryData->entryNext->entryPosition - 1;
                insertFlags |= _SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_PREPEND;
            } else {
                /*
                 *  In any other case, we just stick the new entry roughly in
                 *  the middle of the gap, and let things fall around it.
                 *
                 *  If the gap is only one position long, the position this
                 *  selects will be that position (previous entry is -1, next
                 *  entry is +1, average is 0).  For greater widths, it will
                 *  choose a position roughly (plus or minus 1) in the middle
                 *  between the boundary positions.
                 */
                newEntryData->entryPosition = (newEntryData->entryPrev->entryPosition +
                                               newEntryData->entryNext->entryPosition) >> 1;
                insertFlags |= _SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_INSERT;
            }
        } else { /* if (newEntryData->entryPrev) */
            /* new entry is the first entry in this group */
            if ((newEntryData->entryNext->entryId == groupData->entryLastAdded) ||
                (newEntryData->entryNext->entryPriority == (newEntryData->entryPriority - 1))) {
                /*
                 *  Last one added was after this gap, or the one just after
                 *  this gap has priority of one lower than this entry; stick
                 *  this entry next to that one.
                 */
                newEntryData->entryPosition = newEntryData->entryNext->entryPosition - 1;
                insertFlags |= _SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_PREPEND;
            } else {
                /*
                 *  In any other case, we just stick the new entry roughly in
                 *  the middle of the gap, and let things fall around it.
                 *
                 *  This deliberately biases the rounding so it goes to the
                 *  'prior' position rather than the 'next' position in case of
                 *  tie, since the 'next' position could well (if the gap is
                 *  only one position long) be the next entry's position.
                 */
                newEntryData->entryPosition = (newEntryData->entryNext->entryPosition +
                                               positionFirst) >> 1;
                insertFlags |= _SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_INSERT;
            }
        } /* if (newEntryData->entryPrev) */
    } else { /* if (newEntryData->entryNext) */
        /* there is no entry after this one in this group */
        if (newEntryData->entryPrev) {
            /* there is an entry before this one... */
            insertFlags |= _SOC_C3_RCE_ENTRY_INSERT_FLAG_HAS_PREV;
            /* ...but this entry is the last entry in this group */
            if ((newEntryData->entryPrev->entryId == groupData->entryLastAdded) ||
                (newEntryData->entryPrev->entryPriority == newEntryData->entryPriority) ||
                (newEntryData->entryPrev->entryPriority == (newEntryData->entryPriority + 1))) {
                /*
                 *  Last one added was before this gap, or the one just before
                 *  this gap has equal priority or priority one higher than
                 *  this entry; stick this entry next to that one.
                 */
                newEntryData->entryPosition = newEntryData->entryPrev->entryPosition + 1;
                insertFlags |= _SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_APPEND;
            } else {
                /*
                 *  In any other case, we just stick the new entry roughly in
                 *  the middle of the gap, and let things fall around it.
                 *
                 *  This deliberately biases the rounding so it goes to the
                 *  'next' position rather than the 'prior' position in case of
                 *  tie, since the 'prior' position could well (if the gap is
                 *  only one position long) be the previous entry's position.
                 */
                newEntryData->entryPosition = (newEntryData->entryPrev->entryPosition +
                                               positionLast + 1) >> 1;
                insertFlags |= _SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_INSERT;
            }
        } else { /* if (newEntryData->entryPrev) */
            /* entry is the only entry in this group; put it in slot zero */
            newEntryData->entryPosition = 0;
            insertFlags |= _SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_APPEND;
        } /* if (newEntryData->entryPrev) */
    } /* if (newEntryData->entryNext) */
    /*
     *  We must not stick it in the adjacent filter set, though, so make sure
     *  that neither 'neighbour' nor 'average' placement did so.
     */
#if defined(BROADCOM_DEBUG)
    RCE_EVERB((RCE_MSG1("unit %d program %u (group %d filter"
                        " set %u) valid positions %u..%u\n"),
               unitData->unit,
               groupData->rceProgram,
               groupData->groupId,
               0,
               positionFirst,
               positionLast));
    if (newEntryData->entryPrev) {
        if (newEntryData->entryNext) {
            RCE_EVERB((RCE_MSG1("unit %d group %d entry %d position %u"
                                " assigned by %s %02X, between entry %d"
                                " position %u and entry %d position %u\n"),
                       unitData->unit,
                       groupId,
                       entryId,
                       newEntryData->entryPosition,
                       ((insertFlags & _SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_MASK) ==
                        _SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_APPEND)?"append":
                       ((insertFlags & _SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_MASK) ==
                        _SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_INSERT)?"insert":
                       ((insertFlags & _SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_MASK) ==
                        _SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_PREPEND)?"prepend":
                       "???",
                       groupData->groupFlags,
                       newEntryData->entryPrev->entryId,
                       newEntryData->entryPrev->entryPosition,
                       newEntryData->entryNext->entryId,
                       newEntryData->entryNext->entryPosition));
        } else { /* if (newEntryData->entryNext) */
            RCE_EVERB((RCE_MSG1("unit %d group %d entry %d position %u"
                                " assigned by %s %02X, after entry %d"
                                " position %u\n"),
                       unitData->unit,
                       groupId,
                       entryId,
                       newEntryData->entryPosition,
                       ((insertFlags & _SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_MASK) ==
                        _SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_APPEND)?"append":
                       ((insertFlags & _SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_MASK) ==
                        _SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_INSERT)?"insert":
                       ((insertFlags & _SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_MASK) ==
                        _SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_PREPEND)?"prepend":
                       "???",
                       groupData->groupFlags,
                       newEntryData->entryPrev->entryId,
                       newEntryData->entryPrev->entryPosition));
        } /* if (newEntryData->entryNext) */
    } else { /* if (newEntryData->entryPrev) */
        if (newEntryData->entryNext) {
            RCE_EVERB((RCE_MSG1("unit %d group %d entry %d position %u assigned"
                                " by %s %02X, before entry %d position %u\n"),
                       unitData->unit,
                       groupId,
                       entryId,
                       newEntryData->entryPosition,
                       ((insertFlags & _SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_MASK) ==
                        _SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_APPEND)?"append":
                       ((insertFlags & _SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_MASK) ==
                        _SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_INSERT)?"insert":
                       ((insertFlags & _SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_MASK) ==
                        _SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_PREPEND)?"prepend":
                       "???",
                       groupData->groupFlags,
                       newEntryData->entryNext->entryId,
                       newEntryData->entryNext->entryPosition));
        } else { /* if (newEntryData->entryNext) */
            RCE_EVERB((RCE_MSG1("unit %d group %d entry %d position %u assigned"
                                " by %s %02X\n"),
                       unitData->unit,
                       groupId,
                       entryId,
                       newEntryData->entryPosition,
                       ((insertFlags & _SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_MASK) ==
                        _SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_APPEND)?"append":
                       ((insertFlags & _SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_MASK) ==
                        _SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_INSERT)?"insert":
                       ((insertFlags & _SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_MASK) ==
                        _SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_PREPEND)?"prepend":
                       "???",
                       groupData->groupFlags));
        } /* if (newEntryData->entryNext) */
    } /* if (newEntryData->entryPrev) */
#endif /* defined(BROADCOM_DEBUG) */
    if (newEntryData->entryPosition < positionFirst) {
        newEntryData->entryPosition = positionFirst;
    } else if (newEntryData->entryPosition > positionLast) {
        newEntryData->entryPosition = positionLast;
    }
    RCE_EVERB((RCE_MSG1("unit %d group %d entry %d position %u assigned by"
                        " %s %02X\n"),
               unitData->unit,
               groupId,
               entryId,
               newEntryData->entryPosition,
               (_SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_APPEND == (insertFlags & _SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_MASK))?"append":
               (_SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_INSERT == (insertFlags & _SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_MASK))?"insert":
               (_SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_PREPEND == (insertFlags & _SOC_C3_RCE_GROUP_INSERT_FLAG_ENTRY_MASK))?"prepend":
               "???",
               groupData->groupFlags));
#else /* C3_RCE_ENABLE_ENTRY_INSERT_HEURISTIC */
    /* Compress this filter set and recalculate entry positions in hardware */
    RCE_EVERB((RCE_MSG1("unit %d program %u group %d, position %u through %u"
                        " begin packing for new entry %d\n"),
               unitData->unit,
               groupData->rceProgram,
               groupId,
               positionFirst,
               positionLast,
               newEntryData->entryId));
    if (entryPrev) {
        RCE_EVERB((RCE_MSG1("previous entry %d position %u\n"),
                   entryPrev->entryId,
                   entryPrev->entryPosition));
    }
    if (entryNext) {
        RCE_EVERB((RCE_MSG1("next entry %d position %u\n"),
                   entryNext->entryId,
                   entryNext->entryPosition));
    }
    for (index = positionFirst,
         entryNext = programData->fsetData[filterSetProg].entryHead;
         entryNext && (index <= positionLast);
         index++, entryNext = entryNext->entryNext) {
        if ((positionLast < entryNext->entryPosition) &&
            ((~0) != entryNext->entryPosition)) {
            RCE_EVERB((RCE_MSG1("unit %d program %u group %d done entry"
                                " packing with entry %d pos %u\n"),
                       unitData->unit,
                       groupData->rceProgram,
                       groupId,
                       entryNext->entryId,
                       entryNext->entryPosition));
            /* have left the filter set being packed; stop now */
            break;
        }
#if 0 
        RCE_EVERB((RCE_MSG1("unit %d entry %d position %u moved to position"
                            " %u by packing\n"),
                   unitData->unit,
                   entryData->entryId,
                   entryData->entryPosition,
                   index));
#endif 
        entryNext->entryPosition = index;
    }
    result = _soc_c3_rce_filter_set_update(unitData,
                                           groupData->groupId,
                                           filterSetGrp,
                                           FALSE /* no force first */);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d unable to commit program %u filter"
                            " set %u (group %d filter set %u) after"
                            " shifting entries: %d (%s)\n"),
                   unitData->unit,
                   groupData->rceProgram,
                   filterSetProg,
                   groupData->groupId,
                   filterSetGrp,
                   result,
                   _SHR_ERRMSG(result)));
        goto error;
    }
    RCE_EVERB((RCE_MSG1("unit %d group %d entry %d position %u assigned by"
                        " packing\n"),
               unitData->unit,
               groupId,
               entryId,
               newEntryData->entryPosition));
#endif /* C3_RCE_ENABLE_ENTRY_INSERT_HEURISTIC */
    /* keep track of this entry and how we stuck it in here */
    groupData->entryLastAdded = entryId;
    newEntryData->entryFlags |= SOC_C3_RCE_ENTRY_FLAG_EXISTS;
#if C3_RCE_ENABLE_ENTRY_INSERT_HEURISTIC
    groupData->groupFlags = ((groupData->groupFlags &
                              (~_SOC_C3_RCE_GROUP_INSERT_FLAG_MASK)) |
                             (insertFlags &
                              _SOC_C3_RCE_GROUP_INSERT_FLAG_MASK));
    /* track flags under which the entry was created */
    newEntryData->entryFlags &= 0x0000FFFF;
    newEntryData->entryFlags |= (insertFlags << 16);
#endif /* C3_RCE_ENABLE_ENTRY_INSERT_HEURISTIC */
    if (flags & SOC_C3_RCE_ENTRY_COPY_SOURCE_ALL) {
        /* copied state from the original entry; some final work to be done */
        if (flags & SOC_C3_RCE_ENTRY_COPY_SOURCE_QUALS) {
            /* need to update the filter set's range info */
            sal_memcpy(programData->fsetData[filterSetProg].rangeInfo,
                       rangeTemp,
                       sizeof(*programData->fsetData[filterSetProg].rangeInfo) *
                       groupData->rangesPerFilterSet);
        }
        if (newEntryData->pattData[0][0] & 1) {
            /* new entry needs to be installed to hardware */
            result = _soc_c3_rce_filter_set_update(unitData,
                                                   groupId,
                                                   filterSetGrp,
                                                   FALSE);
            if (SOC_E_NONE == result) {
                newEntryData->entryFlags |= SOC_C3_RCE_ENTRY_FLAG_INSTALLED;
            }
            /*
             *  Note that the entry is installed with the state exactly as it
             *  was, so the bits that were copied from the source entry are in
             *  the same state, with any changes since install also evident in
             *  the copied entry.
             */
        }
        if (srcEntryData->entryFlags & SOC_C3_RCE_ENTRY_FLAG_MODIFIED) {
            /* new entry data were copied from old and old was modified */
            newEntryData->entryFlags |= SOC_C3_RCE_ENTRY_FLAG_MODIFIED;
        }
    } /* if (flags & SOC_C3_RCE_ENTRY_COPY_SOURCE_ALL) */
    /* don't want to destroy the entry's memory cell */
    newEntryData = NULL;
error:
    if (rangeTranslate) {
        sal_free(rangeTranslate);
    }
    if (rangeTemp) {
        sal_free(rangeTemp);
    }
#if C3_RCE_ENABLE_ENTRY_INSERT_HEURISTIC
    if ((SOC_E_NONE != result) && backoutNeeded) {
        /* something happened and need to back out position changes */
        for (entryCurr = groupData->entryHead;
             entryCurr;
             entryCurr = entryCurr->entryNext) {
            entryCurr->entryPosition = entryCurr->entryPosBackout;
        }
    } /* if ((SOC_E_NONE != result) && backoutNeeded) */
#endif /* C3_RCE_ENABLE_ENTRY_INSERT_HEURISTIC */
    if (newEntryData) {
        sal_free(newEntryData);
    }
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_entry_qualify_clear_int
 *  Purpose
 *    Resets entry pattern to defaults (clears most qualifier forms)
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) progData = pointer to program data
 *    (IN) groupData = pointer to group data
 *    (IN) entryData = pointer to entry data
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    This reverts the entry so its pattern is the same as the default pattern
 *    for the group.  If the entry was using range references, these references
 *    are cleaned up as appropriate.
 *
 *    Does not affect actions (only resets the entry's pattern).
 *
 *    Does not commit to hardware.
 */
static int
_soc_c3_rce_entry_qualify_clear_int(_soc_c3_rce_unit_desc_int_t *unitData,
                                    _soc_c3_rce_program_desc_int_t *progData,
                                    _soc_c3_rce_group_desc_int_t *groupData,
                                    _soc_c3_rce_entry_desc_int_t *entryData,
                                    unsigned int filterSetIndex)
{
    unsigned int index;

    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META("unit %d entry %d (group %d) pattern reset\n"),
                 unitData->unit,
                 entryData->entryId,
                 entryData->entryGroup));
    /* remove range references from this entry */
    for (index = 1; index <= groupData->rangesPerFilterSet; index++) {
        if (entryData->pattData[0][index >> 3] & (1 << (index & 7))) {
            _soc_c3_rce_filter_set_range_delete_by_index(unitData,
                                                         &(progData->fsetData[filterSetIndex]),
                                                         index);
        } /* if (this entry was referring to this range) */
    } /* for (all range slots this filter set) */
    /* copy the pattern from the group's default pattern */
    sal_memcpy(entryData->pattData[0],
               groupData->defaultPattern,
               groupData->instrBlocks);
    /* but we still want the original start/installed bit */
    entryData->pattData[0][0] |= (entryData->pattData[1][0] & 1);
    return SOC_E_NONE;
}

/*
 *  Function
 *    _soc_c3_rce_entry_remove_int
 *  Purpose
 *    Removes the entry from hardware
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) progData = pointer to program data
 *    (IN) groupData = pointer to group data
 *    (IN) entryData = pointer to entry data
 *    (IN) filterSet = filter set index in program
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Clears bit zero of the entry's pattern (this would deactivate the entry
 *    for the hardware) in API state, hardware state, and pattern memory.  No
 *    other changes are made, since with the entry disabled, the rest of its
 *    pattern state is not important.
 *
 *    Backs out changes if the remove fails.
 */
static int
_soc_c3_rce_entry_remove_int(_soc_c3_rce_unit_desc_int_t *unitData,
                             _soc_c3_rce_program_desc_int_t *progData,
                             _soc_c3_rce_group_desc_int_t *groupData,
                             _soc_c3_rce_entry_desc_int_t *entryData,
                             unsigned int filterSet)
{
    _soc_c3_rce_filterset_desc_int_t *fsetData;
    uint32 *pmemTemp = NULL;
    unsigned int filterBase;
    unsigned int index;
    soc_mem_t memId;
    soc_field_t fieldId;
    int result = SOC_E_NONE;
    uint32 dataTemp;
    uint8 mask;

    /* allocate working memory to manipulate the pattern */
    pmemTemp = sal_alloc(sizeof(uint32) *
                         soc_mem_entry_words(unitData->unit, PMEM0m),
                         "C3 RCE pattern update buffer");
    if (!pmemTemp) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %u bytes for pattern buffer\n"),
                   (unsigned int)(sizeof(uint32) *
                   soc_mem_entry_words(unitData->unit, PMEM0m))));
        result = SOC_E_MEMORY;
        goto error;
    }
    /* update the pattern in pmem */
    fsetData = &(progData->fsetData[filterSet]);
    filterBase = fsetData->filterIndex *
                 C3_RCE_ENTRIES_PER_FILTER_SET;
    index = entryData->entryPosition - filterBase;
    if (index < C3_RCE_ENTRIES_PER_FILTER_SET) {
        memId = _soc_c3_patt_mems[index >> 5];
        fieldId = _soc_c3_patt_fields[index & 0x1F];
        result = soc_mem_read(unitData->unit,
                              memId,
                              SOC_BLOCK_ANY,
                              fsetData->imemStart,
                              pmemTemp);
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to read pattern memory on unit %d for"
                                " entry %d: %d (%s)\n"),
                       unitData->unit,
                       entryData->entryId,
                       result,
                       _SHR_ERRMSG(result)));
            goto error;
        }
        /* clear the 'start' bit of the pattern */
        dataTemp = soc_mem_field32_get(unitData->unit, memId, pmemTemp, fieldId);
        dataTemp &= (~0x01);
        soc_mem_field32_set(unitData->unit, memId, pmemTemp, fieldId, dataTemp);
        /* write the pattern back */
        result = soc_mem_write(unitData->unit,
                               memId,
                               SOC_BLOCK_ALL,
                               fsetData->imemStart,
                               pmemTemp);
        if (SOC_E_NONE != result) {
            /* something went wrong */
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to write pattern memory on unit %d for"
                                " entry %d: %d (%s)\n"),
                       unitData->unit,
                       entryData->entryId,
                       result,
                       _SHR_ERRMSG(result)));
            goto error;
        }
    }
    /* if entry was installed, adjust committed range counts */
    if (entryData->pattData[0][0] & 1) {
        for (index=1; index<=groupData->rangesPerFilterSet; index++) {
            dataTemp = entryData->pattData[1][index>>3];
            mask     = 1 << (index & 7);
            if (dataTemp & mask) {
                /* the HW copy was using this range */
                fsetData->rangeInfo[index-1].commitCount--;
            }
        }

        for (index = 0; index < groupData->rangesPerFilterSet; index++) {
            if (0 == fsetData->rangeInfo[index].rangeId) {
                /* this range was not in use */
                continue;
            }
            if ((0 == fsetData->rangeInfo[index].refCount) &&
                (0 == fsetData->rangeInfo[index].commitCount)) {
                /* this range is no longer in use */
                unitData->rangeData[fsetData->rangeInfo[index].rangeId - 1]->refCount--;
                sal_memset(&(fsetData->rangeInfo[index]),
                           0x00,
                           sizeof(fsetData->rangeInfo[index]));
            }
        }
    } /* if (entry was committed) */
    /* mark entry as not installed */
    entryData->pattData[0][0] &= (~0x01);
    entryData->pattData[1][0] &= (~0x01);
    entryData->entryFlags &= (~SOC_C3_RCE_ENTRY_FLAG_INSTALLED);
error:
    if (pmemTemp) {
        sal_free(pmemTemp);
    }
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_group_fset_remove
 *  Purpose
 *    Remove a filter set that has become empty during group compression
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) progData = pointer to program data
 *    (IN) groupId = group being compressed
 *    (IN) filterSetGrp = filter set in group to remove
 *    (IN) filterSetPrg = filter set in program to remove
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Will not remove a filter set from a group that has only one.
 */
static int
_soc_c3_rce_group_fset_remove(_soc_c3_rce_unit_desc_int_t *unitData,
                              _soc_c3_rce_program_desc_int_t *progData,
                              unsigned int filterSetPrg,
                              _soc_c3_rce_group_desc_int_t *groupData,
                              unsigned int filterSetGrp)
{
    _soc_c3_rce_entry_desc_int_t *entryCurr;
    unsigned int index;
    int result = SOC_E_NONE;

    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META("unit %d program %u filter set %u (group %d"
                 " filter set %u) is empty%s\n"),
                 unitData->unit,
                 groupData->rceProgram,
                 filterSetPrg,
                 groupData->groupId,
                 filterSetGrp,
                 (filterSetGrp > 0)?"and needs to be removed":""));
    if (groupData->filterSetCount > 1) {
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
        /*
         *  Before we can purge this filter set, the counters that were in
         *  it must be updated, so the associated entries have their basis
         *  values corrected and their new positions recorded properly.
         */
        result = _soc_c3_rce_filter_set_update(unitData,
                                               groupData->groupId,
                                               filterSetGrp,
                                               FALSE);
        if (SOC_E_NONE == result) {
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
            result = _soc_c3_rce_filter_set_remove(unitData,
                                                   groupData->groupId,
                                                   filterSetGrp);
            if (SOC_E_NONE == result) {
                /* adjust remaining positions */
                for (index = filterSetPrg;
                     (index < progData->filterSetCount) &&
                     (groupData->groupId ==
                      progData->fsetData[index].groupId);
                     index++) {
                    progData->fsetData[index].filterIndex--;
                } /* for (all remaining filter sets in this group) */
                if (groupData->groupId ==
                    progData->fsetData[filterSetPrg].groupId) {
                    for (entryCurr = progData->fsetData[filterSetPrg].entryHead;
                         entryCurr;
                         entryCurr = entryCurr->entryNext) {
                        entryCurr->entryPosition -= C3_RCE_ENTRIES_PER_FILTER_SET;
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
                        entryCurr->entryPosPrev -= C3_RCE_ENTRIES_PER_FILTER_SET;
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
                    } /* for (all remaining entries in this group) */
                }
            } /* if (SOC_E_NONE == result) */
            /* called function displayed diagnostic for any errors */
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
        } /* if (SOC_E_NONE == result) */
        /* called function displayed diagnostic for any errors */
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
    } /* if (groupData->filterSetCount > 1) */
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_entry_destroy
 *  Purpose
 *    Destroys an exiting entry in an existing group
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) entryId = entry ID to be destroyed
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    This will remove the entry from hardware before destroying it, if the
 *    entry is currently in hardware.
 */
static int
_soc_c3_rce_entry_destroy(_soc_c3_rce_unit_desc_int_t *unitData,
                          int entryId)
{
    _soc_c3_rce_program_desc_int_t *progData;
    _soc_c3_rce_filterset_desc_int_t *fsetData;
    _soc_c3_rce_group_desc_int_t *groupData;
    _soc_c3_rce_entry_desc_int_t *entryData;
    unsigned int fsetIndex;
    int result;

    entryData = unitData->entryData[entryId];
    groupData = unitData->groupData[entryData->entryGroup];
    progData = unitData->progData[groupData->rceProgram];
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META("unit %d destroy entry %d group %d program %u (%s)\n"),
                 unitData->unit,
                 entryId,
                 entryData->entryGroup,
                 groupData->rceProgram,
                 progData->ucData->programName));
    result = _soc_c3_rce_filter_set_locate(unitData,
                                           progData,
                                           entryData->entryGroup,
                                           entryData->entryPosition /
                                           C3_RCE_ENTRIES_PER_FILTER_SET,
                                           &fsetIndex);
    if (SOC_E_NONE != result) {
        /* called function displayed diagnostic */
        goto error;
    }
    fsetData = &(progData->fsetData[fsetIndex]);
    if (entryData->pattData[0][0] & 1) {
        /* entry is installed; remove it first */
        result = _soc_c3_rce_entry_remove_int(unitData,
                                              progData,
                                              groupData,
                                              entryData,
                                              fsetIndex);
        if (SOC_E_NONE != result) {
            /* called function displayed diagnostic */
            goto error;
        }
    } /* if (entryData->pattData[0][0] & 1) */
    /*
     *  Remove qualifiers from this entry.  This is done after the entry is
     *  removed (if applicable) to ensure enough time has passed to allow any
     *  frames that were in the pipeline when this entry was valid to be
     *  processed (frames that entered the pipeline after the 'remove' call
     *  above completed will not see this entry).
     *
     *  This cleans up qualifier based accounting (such as for ranges) as well
     *  as reverting the qualifiers for the entry.
     */
    result = _soc_c3_rce_entry_qualify_clear_int(unitData,
                                                 progData,
                                                 groupData,
                                                 entryData,
                                                 fsetIndex);
    if (SOC_E_NONE != result) {
        /* called function displayed diagnostic */
        goto error;
    }
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
    if (groupData->groupFlags & _SOC_C3_RCE_GROUP_FLAG_COUNTER) {
        /*
         *  This must occur long enough after an entry is disabled that any
         *  frames in the pipeline that hit that entry would be completely
         *  processed first.  That way, none of those frames will hit the
         *  entry's counters, and so will not contaminate whatever entry gets
         *  its counters in that position in the future.
         */
        /* now that entry is disabled, read its counters to force to zero */
        result = _soc_c3_rce_entry_hw_counter_read_int(unitData,
                                                       progData,
                                                       entryData,
                                                       fsetIndex,
                                                       NULL);
        if (SOC_E_NONE != result) {
            /* called function displayed diagnostic */
            goto error;
        }
    }
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
    if ((2 > fsetData->entryCount) && (1 < groupData->filterSetCount)) {
        /*
         *  This is the last entry in this filter set, and it is not the only
         *  filter set in the group, so this filter set needs to be destroyed.
         */
        result = _soc_c3_rce_group_fset_remove(unitData,
                                               progData,
                                               fsetIndex,
                                               groupData,
                                               entryData->entryPosition /
                                               C3_RCE_ENTRIES_PER_FILTER_SET);
        if (SOC_E_NONE != result) {
            /* called function displayed diagnostic */
            goto error;
        }
        /* filter set was removed; don't edit it now */
        fsetData = NULL;
    } /* if (last entry in not-last filter set) */
    /* remove the entry from the group */
    if (entryData->entryNext) {
        entryData->entryNext->entryPrev = entryData->entryPrev;
    }
    if (entryData->entryPrev) {
        entryData->entryPrev->entryNext = entryData->entryNext;
    }
    if (entryData == groupData->entryHead) {
        groupData->entryHead = entryData->entryNext;
    }
    if (entryData == groupData->entryTail) {
        groupData->entryTail = entryData->entryPrev;
    }
    /* if the filter set remains, update its information */
    if (fsetData) {
        /* remove the entry from the filter set */
        if (entryData == fsetData->entryHead) {
            fsetData->entryHead = entryData->entryNext;
        }
        progData->fsetData[fsetIndex].entryCount--;
    }
    /* account for the removed entry in the group and unit */
    groupData->entryCount--;
    unitData->entryData[entryId] = NULL;
    /* free the entry's descriptor */
    sal_free(entryData);
    
error:
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_entry_qualify_set
 *  Purpose
 *    Sets the specified qualifier on an entry
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) entryId = entry to manipulate
 *    (IN) qualIdx = index (within group) of qualifier to update
 *    (IN) data = pointer to the data bits
 *    (IN) mask = pointer to the mask bits
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Does not commit to hardware.
 *
 *    This sets the part of the 'API' copy of the entry's pattern that
 *    corresponds to the selected qualifier (by index).  The specifics of the
 *    qualifiers were set when creating the group.
 */
static int
_soc_c3_rce_entry_qualify_set(_soc_c3_rce_unit_desc_int_t *unitData,
                              int entryId,
                              unsigned int qualIdx,
                              const uint8 *data,
                              const uint8 *mask)
{
    _soc_c3_rce_entry_desc_int_t *entryData;
    _soc_c3_rce_group_desc_int_t *groupData;
    int result;

    entryData = unitData->entryData[entryId];
    groupData = unitData->groupData[entryData->entryGroup];
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META("unit %d entry %d set qualifier %u\n"),
                 unitData->unit,
                 entryId,
                 qualIdx));
    if (qualIdx >= groupData->qualCount) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d entry %d qualifier %d is not"
                   " valid -- group %d only has %u qualifiers\n"),
                   unitData->unit,
                   entryId,
                   qualIdx,
                   entryData->entryGroup,
                   groupData->qualCount));
        return SOC_E_NOT_FOUND;
    }
    result = _soc_c3_rce_entry_qualify_general_set(groupData->qualData[qualIdx],
                                                   data,
                                                   mask,
                                                   groupData->qualOffs[qualIdx],
                                                   entryData->pattData[0]);
    if (SOC_E_NONE == result) {
        /* mark entry as modified */
        entryData->entryFlags |= SOC_C3_RCE_ENTRY_FLAG_MODIFIED;
    }
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_entry_qualify_get
 *  Purpose
 *    Gets the specified qualifier from an entry
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) entryId = entry to manipulate
 *    (IN) qualIdx = index (within group) of qualifier to update
 *    (OUT) data = pointer to the data bits
 *    (OUT) mask = pointer to the mask bits
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    This gets the part of the 'API' copy of the entry's pattern that
 *    corresponds to the selected qualifier (by index).  The specifics of the
 *    qualifiers were set when creating the group.
 */
static int
_soc_c3_rce_entry_qualify_get(_soc_c3_rce_unit_desc_int_t *unitData,
                              int entryId,
                              unsigned int qualIdx,
                              uint8 *data,
                              uint8 *mask)
{
    _soc_c3_rce_entry_desc_int_t *entryData;
    _soc_c3_rce_group_desc_int_t *groupData;

    entryData = unitData->entryData[entryId];
    groupData = unitData->groupData[entryData->entryGroup];
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META("unit %d entry %d get qualifier %u\n"),
                 unitData->unit,
                 entryId,
                 qualIdx));
    if (qualIdx >= groupData->qualCount) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d entry %d qualifier %d is not"
                   " valid -- group %d only has %u qualifiers\n"),
                   unitData->unit,
                   entryId,
                   qualIdx,
                   entryData->entryGroup,
                   groupData->qualCount));
        return SOC_E_NOT_FOUND;
    }
    return _soc_c3_rce_entry_qualify_general_get(groupData->qualData[qualIdx],
                                                 groupData->qualOffs[qualIdx],
                                                 entryData->pattData[0],
                                                 data,
                                                 mask);
}

/*
 *  Function
 *    _soc_c3_rce_entry_qualify_clear
 *  Purpose
 *    Resets entry pattern to defaults (clears most qualifier forms)
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) entryId = entry ID to be destroyed
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    This reverts the entry so its pattern is the same as the default pattern
 *    for the group.  If the entry was using range references, these references
 *    are cleaned up as appropriate.
 *
 *    Does not affect actions (only resets the entry's pattern).
 *
 *    Does not commit to hardware.
 */
static int
_soc_c3_rce_entry_qualify_clear(_soc_c3_rce_unit_desc_int_t *unitData,
                                int entryId)
{
    _soc_c3_rce_program_desc_int_t *progData;
    _soc_c3_rce_group_desc_int_t *groupData;
    _soc_c3_rce_entry_desc_int_t *entryData;
    unsigned int filterSetIndex;
    int result;

    entryData = unitData->entryData[entryId];
    groupData = unitData->groupData[entryData->entryGroup];
    progData = unitData->progData[groupData->rceProgram];
    /* find the filter set for this entry */
    result = _soc_c3_rce_filter_set_locate(unitData,
                                           progData,
                                           entryData->entryGroup,
                                           entryData->entryPosition /
                                           C3_RCE_ENTRIES_PER_FILTER_SET,
                                           &filterSetIndex);
    if (SOC_E_NONE != result) {
        /* called function displayed diagnostic */
        goto error;
    }
    result = _soc_c3_rce_entry_qualify_clear_int(unitData,
                                                 progData,
                                                 groupData,
                                                 entryData,
                                                 filterSetIndex);
error:
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_entry_action_clear
 *  Purpose
 *    Resets entry actions to defaults
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) entryId = entry ID to be destroyed
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    This reverts the entry so its action data is the same as the default
 *    action data for the program.
 *
 *    Does not affect qualifiers (only resets the entry's actions).
 *
 *    Does not commit to hardware.
 */
static int
_soc_c3_rce_entry_action_clear(_soc_c3_rce_unit_desc_int_t *unitData,
                               int entryId)
{
    _soc_c3_rce_program_desc_int_t *progData;
    _soc_c3_rce_group_desc_int_t *groupData;
    _soc_c3_rce_entry_desc_int_t *entryData;
    unsigned int resIndex;

    entryData = unitData->entryData[entryId];
    groupData = unitData->groupData[entryData->entryGroup];
    progData = unitData->progData[groupData->rceProgram];
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META("unit %d entry %d (group %d) action reset\n"),
                 unitData->unit,
                 entryId,
                 entryData->entryGroup));
    /* copy the default action for each action table the entry uses */
    for (resIndex = 0;
         resIndex < SOC_C3_RCE_RESULT_REGISTER_COUNT;
         resIndex++) {
        if (groupData->resultLrpUniq & (1 << resIndex)) {
            sal_memcpy(entryData->actData[0][resIndex],
                       unitData->actData[progData->actIndex[resIndex]]->defaultActions,
                       unitData->actData[progData->actIndex[resIndex]]->actionBytes);
        }
    }
    return SOC_E_NONE;
}

/*
 *  Function
 *    _soc_c3_rce_entry_action_set
 *  Purpose
 *    Sets the specified action on an entry
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) entryId = entry to manipulate
 *    (IN) resReg = result register whose associated action is to be set
 *    (IN) actIdx = index (within program) of action to update
 *    (IN) value = pointer to the action value bits
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Does not commit to hardware.
 */
static int
_soc_c3_rce_entry_action_set(_soc_c3_rce_unit_desc_int_t *unitData,
                             int entryId,
                             unsigned int resReg,
                             unsigned int actIdx,
                             const uint8 *value)
{
    _soc_c3_rce_entry_desc_int_t *entryData;
    _soc_c3_rce_group_desc_int_t *groupData;
    _soc_c3_rce_program_desc_int_t *progData;
    int result;

    entryData = unitData->entryData[entryId];
    groupData = unitData->groupData[entryData->entryGroup];
    progData = unitData->progData[groupData->rceProgram];
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META("unit %d entry %d set result %u action %u\n"),
                 unitData->unit,
                 entryId,
                 resReg,
                 actIdx));
    if (resReg >= SOC_C3_RCE_RESULT_REGISTER_COUNT) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d does not support result register %u\n"),
                   unitData->unit,
                   resReg));
        return SOC_E_PARAM;
    }
    if (0 == (groupData->resultLrp & (1 << resReg))) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d group %d does not use result register %u\n"),
                   unitData->unit,
                   groupData->groupId,
                   resReg));
        return SOC_E_PARAM;
    }
    if (actIdx >= unitData->actData[progData->actIndex[resReg]]->actionCount) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d entry %d result %u action %u is not"
                   " valid -- program %u (%s) result register %u"
                   " refers to action table %u (%s), which only"
                   " has %u actions\n"),
                   unitData->unit,
                   entryId,
                   resReg,
                   actIdx,
                   groupData->rceProgram,
                   progData->ucData->programName,
                   resReg,
                   progData->actIndex[resReg],
                   unitData->actData[progData->actIndex[resReg]]->ucData->tableName,
                   unitData->actData[progData->actIndex[resReg]]->actionCount));
        return SOC_E_NOT_FOUND;
    }
    result = _soc_c3_rce_program_action_general_set(unitData->actData[progData->actIndex[resReg]]->actionData[actIdx],
                                                    value,
                                                    entryData->actData[0][resReg]);
    if (SOC_E_NONE == result) {
        /* mark entry as modified */
        entryData->entryFlags |= SOC_C3_RCE_ENTRY_FLAG_MODIFIED;
    }
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_entry_action_get
 *  Purpose
 *    Gets the specified action from an entry
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) entryId = entry to manipulate
 *    (IN) resReg = result register whose associated action is to be set
 *    (IN) actIdx = index (within group) of qualifier to update
 *    (OUT) value = pointer to where to put the value
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 */
static int
_soc_c3_rce_entry_action_get(_soc_c3_rce_unit_desc_int_t *unitData,
                             int entryId,
                             unsigned int resReg,
                             unsigned int actIdx,
                             uint8 *value)
{
    _soc_c3_rce_entry_desc_int_t *entryData;
    _soc_c3_rce_group_desc_int_t *groupData;
    _soc_c3_rce_program_desc_int_t *progData;

    entryData = unitData->entryData[entryId];
    groupData = unitData->groupData[entryData->entryGroup];
    progData = unitData->progData[groupData->rceProgram];
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META("unit %d entry %d get result %u action %u\n"),
                 unitData->unit,
                 entryId,
                 resReg,
                 actIdx));
    if (resReg >= SOC_C3_RCE_RESULT_REGISTER_COUNT) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d does not support result register %u\n"),
                   unitData->unit,
                   resReg));
        return SOC_E_PARAM;
    }
    if (0 == (groupData->resultLrp & (1 << resReg))) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d group %d does not use result register %u\n"),
                   unitData->unit,
                   groupData->groupId,
                   resReg));
        return SOC_E_PARAM;
    }
    if (actIdx >= unitData->actData[progData->actIndex[resReg]]->actionCount) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d entry %d result %u action %u is not"
                   " valid -- program %u (%s) result register %u"
                   " refers to action table %u (%s), which only"
                   " has %u actions\n"),
                   unitData->unit,
                   entryId,
                   resReg,
                   actIdx,
                   groupData->rceProgram,
                   progData->ucData->programName,
                   resReg,
                   progData->actIndex[resReg],
                   unitData->actData[progData->actIndex[resReg]]->ucData->tableName,
                   unitData->actData[progData->actIndex[resReg]]->actionCount));
        return SOC_E_NOT_FOUND;
    }
    return _soc_c3_rce_program_action_general_get(unitData->actData[progData->actIndex[resReg]]->actionData[actIdx],
                                                  entryData->actData[0][resReg],
                                                  value);
}

/*
 *  Function
 *    _soc_c3_rce_entry_install
 *  Purpose
 *    Installs the entry to hardware
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) entryId = entry to install
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Sets bit zero of the entry's pattern (this would activate the entry for
 *    the hardware), then copies API state qualifier/action data to hardware
 *    qualifer/action space, then updates the appropriate filter set of the
 *    entry's group to hardware.
 *
 *    Backs out changes if the install fails.
 */
static int
_soc_c3_rce_entry_install(_soc_c3_rce_unit_desc_int_t *unitData,
                          int entryId)
{
    _soc_c3_rce_entry_desc_int_t *entryData;
    _soc_c3_rce_group_desc_int_t *groupData;
    uint8 *dataOrig = NULL;
    int result;

    entryData = unitData->entryData[entryId];
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META("unit %d entry %d install\n"),
                 unitData->unit,
                 entryId));
    /* get the information about this group and program */
    groupData = unitData->groupData[entryData->entryGroup];
    /* allocate backout buffer in case of failure */
    dataOrig = sal_alloc(groupData->dataSize << 1,
                         "C3 RCE entry install backout temp");
    if (!dataOrig) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %u bytes working space\n"),
                   groupData->dataSize << 1));
        result = SOC_E_MEMORY;
        goto error;
    }
    /* keep current state in case of failure */
    sal_memcpy(dataOrig, entryData->pattData[0], groupData->dataSize << 1);
    /* set the pattern bit for the start instruction (mark entry active) */
    entryData->pattData[0][0] |= 1;
    /* copy the API data state to the hardware data state */
    sal_memcpy(entryData->pattData[1],
               entryData->pattData[0],
               groupData->dataSize);
    /* update the filter set in hardware */
    result = _soc_c3_rce_filter_set_update(unitData,
                                           entryData->entryGroup,
                                           entryData->entryPosition /
                                           C3_RCE_ENTRIES_PER_FILTER_SET,
                                           FALSE /* normal behaviour */);
    if (SOC_E_NONE == result) {
        /* mark entry as installed and not modified */
        entryData->entryFlags |= SOC_C3_RCE_ENTRY_FLAG_INSTALLED;
        entryData->entryFlags &= (~SOC_C3_RCE_ENTRY_FLAG_MODIFIED);
    } else {
        /* something went wrong; put back old hardware values */
        sal_memcpy(entryData->pattData[0], dataOrig, groupData->dataSize << 1);
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to update unit %d group %d filter set %u"
                   " for entry %d: %d (%s)\n"),
                   unitData->unit,
                   entryData->entryGroup,
                   entryData->entryPosition / C3_RCE_ENTRIES_PER_FILTER_SET,
                   entryId,
                   result,
                   _SHR_ERRMSG(result)));
    }
error:
    if (dataOrig) {
        sal_free(dataOrig);
    }
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_entry_remove
 *  Purpose
 *    Removes the entry from hardware
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) entryId = entry to remove
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Clears bit zero of the entry's pattern (this would deactivate the entry
 *    for the hardware) in API state, hardware state, and pattern memory.  No
 *    other changes are made, since with the entry disabled, the rest of its
 *    pattern state is not important.
 *
 *    Backs out changes if the remove fails.
 */
static int
_soc_c3_rce_entry_remove(_soc_c3_rce_unit_desc_int_t *unitData,
                         int entryId)
{
    _soc_c3_rce_entry_desc_int_t *entryData;
    _soc_c3_rce_group_desc_int_t *groupData;
    _soc_c3_rce_program_desc_int_t *progData;
    unsigned int index;
    unsigned int filterSet;
    int result = SOC_E_NONE;

    entryData = unitData->entryData[entryId];
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META("unit %d entry %d remove\n"),
                 unitData->unit,
                 entryId));
    /* get the information about this group and program */
    groupData = unitData->groupData[entryData->entryGroup];
    progData = unitData->progData[groupData->rceProgram];
    filterSet = entryData->entryPosition / C3_RCE_ENTRIES_PER_FILTER_SET;
    result = _soc_c3_rce_filter_set_locate(unitData,
                                           progData,
                                           entryData->entryGroup,
                                           filterSet,
                                           &index);
    if (SOC_E_NONE != result) {
        /* called function displayed diagnostic */
        return result;
    }
    result = _soc_c3_rce_entry_remove_int(unitData,
                                          progData,
                                          groupData,
                                          entryData,
                                          index);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to remove unit %d entry %d: %d (%s)\n"),
                   unitData->unit,
                   entryId,
                   result,
                   _SHR_ERRMSG(result)));
    }
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_entry_to_result
 *  Purpose
 *    Get the result that would be returned to the LRP on entry hit
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) entryId = entry whose action index is to be retrieved
 *    (OUT) rceProgram = where to put the program ID
 *    (OUT) entryResult = where to put the LRP result for the entry
 *    (OUT) lrpResult = where to put result registers bitmap
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    If the entry is found and installed to hardware, fills in the value that
 *    would be returned to the LRP if the entry was hit and returns SOC_E_NONE.
 *
 *    Returns SOC_E_EMPTY but still fills in the result value (that would be
 *    used for the entry) if the entry is not installed to hardware.
 *
 *    WARNING: The result value to the LRP for a given entry can change over
 *    the life of the entry, such as when an entry in the same filter set is
 *    installed, or if a filter set is refreshed for some other reason.
 */
static int
_soc_c3_rce_entry_to_result(_soc_c3_rce_unit_desc_int_t *unitData,
                            int entryId,
                            unsigned int *rceProgram,
                            unsigned int *entryResult,
                            uint8 *lrpResult)
{
    _soc_c3_rce_entry_desc_int_t *entryData;
    _soc_c3_rce_group_desc_int_t *groupData;
    _soc_c3_rce_program_desc_int_t *progData;
    unsigned int filterSet;
    unsigned int filterOffset;
    unsigned int entryBias;
    unsigned int filterBase = ~0;
    unsigned int index;

    entryData = unitData->entryData[entryId];
    groupData = unitData->groupData[entryData->entryGroup];
    progData = unitData->progData[groupData->rceProgram];
    filterSet = entryData->entryPosition / C3_RCE_ENTRIES_PER_FILTER_SET;
    filterOffset = entryData->entryPosition % C3_RCE_ENTRIES_PER_FILTER_SET;
    /* entry bias is same for all action tables used by a program */
    for (index = 0, entryBias = 0;
         index < SOC_C3_RCE_RESULT_REGISTER_COUNT;
         index++) {
        if (progData->actIndex[index] < unitData->actTableCount) {
            /* program uses this result register; get bias from action table */
            entryBias = unitData->actData[progData->actIndex[index]]->firstEntryBias;
            break;
        }
    }
    if (0 == entryBias) {
        /* but this should never happen */
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d program %u invalid entry bias %u\n"),
                   unitData->unit,
                   groupData->rceProgram,
                   entryBias));
        return SOC_E_INTERNAL;
    }
    /* scan filter sets this program for this entry's filter set */
    for (index = 0; index < progData->filterSetCount; index++) {
        if ((entryData->entryGroup == progData->fsetData[index].groupId) &&
            (filterSet == progData->fsetData[index].filterIndex)) {
            /* this filter set matches the entry's group and position  */
            filterBase = progData->fsetData[index].amemBlock;
            break;
        }
    } /* for (index = 0; index < progData->filterSetCount; index++) */
    if (index < progData->filterSetCount) {
        /* did not fall off the end of the filter sets list */
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
        if (progData->fsetData[index].fsetFlags &
            _SOC_C3_RCE_FSET_FLAGS_COUNTER) {
            /* action-indexed counters feature enabled */
            filterBase <<= 1;
            if (0 == (progData->fsetData[index].fsetFlags &
                      _SOC_C3_RCE_FSET_FLAGS_PHASE)) {
                /* next phase zero, so current phase 1 */
                filterBase++;
            }
        }
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
        *rceProgram = groupData->rceProgram;
        *entryResult = ((filterBase * C3_RCE_ENTRIES_PER_FILTER_SET) +
                        entryBias +
                        filterOffset);
        *lrpResult = groupData->resultLrp;
        if (0 == (entryData->pattData[0][0] & 1)) {
            /* this entry is not installed (so the result can not occur) */
            return SOC_E_EMPTY;
        } else {
            /* this entry is installed (so the result can occur) */
            return SOC_E_NONE;
        }
    } else { /* if (index < progData->filterSetCount) */
        /*
         *  We fell off the end of the filter sets list.  This should not
         *  happen because entry space is allocated when the group or entry is
         *  created.  This means something went wrong internally.
         */
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to find unit %d program %u (%s) group %d"
                   " filter set %u offset %u (entry %d)\n"),
                   unitData->unit,
                   groupData->rceProgram,
                   progData->ucData->programName,
                   entryData->entryGroup,
                   filterSet,
                   filterOffset,
                   entryId));
        return SOC_E_INTERNAL;
    }
}

/*
 *  Function
 *    _soc_c3_rce_entry_from_result
 *  Purpose
 *    Get the entry that would return the specified result to the LRP on hit.
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) rceProgram = program ID to search
 *    (IN) entryResult = the LRP result to locate
 *    (OUT) entryId = where to put the entry that would provide the result
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    If an entry that would return the requested result is found, and it is
 *    installed to hardware, this will fill in that entry's ID and return
 *    SOC_E_NONE to the caller.
 *
 *    If there is an entry that would have returned the result if it were
 *    installed, but it is not, this will fill in that entry's ID and return
 *    SOC_E_EMPTY to the caller.
 *
 *    If there is no entry in the program that would have returned that result,
 *    this simply returns SOC_E_NOT_FOUND to the caller.
 *
 *    WARNING: The result value to the LRP for a given entry can change over
 *    the life of the entry, such as when an entry in the same filter set is
 *    installed, or if a filter set is refreshed for some other reason.
 */
static int
_soc_c3_rce_entry_from_result(_soc_c3_rce_unit_desc_int_t *unitData,
                              unsigned int rceProgram,
                              unsigned int entryResult,
                              int *entryId)
{
    _soc_c3_rce_group_desc_int_t *groupData;
    _soc_c3_rce_entry_desc_int_t *entryData;
    _soc_c3_rce_program_desc_int_t *progData;
    unsigned int index;
    unsigned int entryBias;
    unsigned int filterSet;
    unsigned int filterOffset;
    unsigned int filterBase;

    progData = unitData->progData[rceProgram];
    /* entry bias is same for all action tables used by a program */
    for (index = 0, entryBias = 0;
         index < SOC_C3_RCE_RESULT_REGISTER_COUNT;
         index++) {
        if (progData->actIndex[index] < unitData->actTableCount) {
            /* program uses this result register; get bias from action table */
            entryBias = unitData->actData[progData->actIndex[index]]->firstEntryBias;
            break;
        }
    }
    if (0 == entryBias) {
        /* but this should never happen */
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d program %u invalid entry bias %u\n"),
                   unitData->unit,
                   rceProgram,
                   entryBias));
        return SOC_E_INTERNAL;
    }
    if (entryResult) {
        filterSet = entryResult / C3_RCE_ENTRIES_PER_FILTER_SET;
        filterOffset = entryResult % C3_RCE_ENTRIES_PER_FILTER_SET;
        /* look for a filter set with the requested result in it */
        for (index = 0; index < progData->filterSetCount; index++) {
            if (filterSet == progData->fsetData[index].amemBlock) {
                /* found the filter set with the desired value */
                break;
            }
        }
        if (index < progData->filterSetCount) {
            /* now scan for the entry at the proper position */
            groupData = unitData->groupData[progData->fsetData[index].groupId];
            filterBase = ((C3_RCE_ENTRIES_PER_FILTER_SET *
                           progData->fsetData[index].filterIndex) +
                          filterOffset);
            for (entryData = groupData->entryHead;
                 entryData && (entryData->entryPosition < filterBase);
                 entryData = entryData->entryNext) {
                /* scan until we fall off or get to where it should be */
            }
            if (entryData && (filterBase == entryData->entryPosition)) {
                /* found the entry that matches this position */
                *entryId = entryData->entryId;
                if (entryData->pattData[0][0] & 1) {
                    /* ... and it is installed */
                    return SOC_E_NONE;
                } else {
                    /* ... but it is not installed */
                    return SOC_E_EMPTY;
                }
            } /* if (entryData && (filterBase == entryData->entryPosition) */
        } /* if (index < progData->filterSetCount) */
        /* did not find a matching filter set */
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d program %u (%s) does not have any entry"
                   " that should return result %u\n"),
                   unitData->unit,
                   rceProgram,
                   progData->ucData->programName,
                   entryResult));
    } else {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d program %u (%s) result %u indicates"
                   " no hit\n"),
                   unitData->unit,
                   rceProgram,
                   progData->ucData->programName,
                   entryResult));
    }
    return SOC_E_NOT_FOUND;
}


/*--------------------------------------------------------------------------
 *
 *  Implementation of group manipulation
 */

/*
 *  Function
 *    _soc_c3_rce_group_prio_compare
 *  Purpose
 *    Compare group priorities
 *  Arguments
 *    (IN) prio0 = priority 0
 *    (IN) prio1 = priority 1
 *  Returns
 *    negative  if priority of prio0 < priority of prio1
 *    zero      if priority of prio0 == priority of prio1
 *    positive  if priority of prio0 > priority of prio1
 *  Notes
 *    Tbe BCM layer provides some constants, but as long as priority is always
 *    nonnegative, they constants are seamless.  Nonnegative priority values
 *    are enforced elsewhere.
 */
INLINE int
_soc_c3_rce_group_prio_compare(int prio0,
                               int prio1)
{
    return prio0 - prio1;
}

/*
 *  Function
 *    _soc_c3_rce_group_create
 *  Purpose
 *    Create a group
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) groupId = group ID for the new group to create
 *    (IN) newGroupData = pointer to information about group to create
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Adds the first filter set for this group to the program.  There are no
 *    entries yet, but the filter set is allocated at this point so entries can
 *    be added immediately and we know the resources exist to hold at least one
 *    filter set worth of entries (else we will refuse to create the group).
 */
static int
_soc_c3_rce_group_create(_soc_c3_rce_unit_desc_int_t *unitData,
                         int groupId,
                         const soc_c3_rce_group_desc_t *newGroupData)
{
    _soc_c3_rce_group_desc_int_t *groupData = NULL;
    _soc_c3_rce_group_desc_int_t *groupTemp;
    _soc_c3_rce_program_desc_int_t *progData;
    _soc_c3_rce_qual_desc_int_t *qualData;
    soc_c3_rce_qual_desc_t *newQualData;
    unsigned int index;
    unsigned int offset;
    unsigned int allocSize;
    unsigned int elemSize;
    unsigned int nameSize;
    uint32 opcode;
    int result = SOC_E_NONE;

    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META("unit %d create group %d\n"),
                 unitData->unit, groupId));
    allocSize = sizeof(*groupData);
    progData = unitData->progData[newGroupData->rceProgram];
    groupData = sal_alloc(allocSize, "C3 RCE group data");
    if (!groupData) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %d bytes for unit %d group %d"
                   " information\n"),
                   allocSize,
                   unitData->unit,
                   groupId));
        result = SOC_E_MEMORY;
        goto error;
    }
    /* must clear it before anything else if alloc successful */
    sal_memset(groupData, 0x00, sizeof(*groupData));
    /* basic accounting */
    progData->groupCount++;
    /* copy basic data to internal space */
    groupData->groupId = groupId;
    groupData->groupPriority = newGroupData->groupPriority;
    groupData->rceProgram = newGroupData->rceProgram;
    groupData->resultLrp = newGroupData->resultLrp;
    groupData->resultRce = newGroupData->resultRce;
    groupData->qualCount = newGroupData->qualCount;
    groupData->maxFilterSets = newGroupData->maxFilterSets;
    /*
     *  To make things simpler later, find the unique results for this group.
     *  Specifically, look at all active result registers and only set the bit
     *  for the first one we encounter that refers to a given action table.
     *
     *  If a result register that does not refer to an action table is
     *  specified, we don't worry about resources or actions here.
     */
    for (index = 0; index < SOC_C3_RCE_RESULT_REGISTER_COUNT; index++) {
        if (groupData->resultLrp & (1 << index)) {
            if (progData->actIndex[index] >= unitData->actTableCount) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("result register %u is not used for"
                           " unit %d program %u\n"),
                           index,
                           unitData->unit,
                           newGroupData->rceProgram));
                result = SOC_E_CONFIG;
                goto error;
            }
            /* this result register is used and it refers to an action table */
            for (offset = 0; offset < index; offset++) {
                if ((groupData->resultLrpUniq & (1 << offset)) &&
                    (progData->actIndex[offset] ==
                     progData->actIndex[index])) {
                    /* already included this one */
                    break;
                }
            } /* for (all remaining result registers) */
            if (offset >= index) {
                /* we did not have this one yet, so it's unique */
                RCE_EVERB((RCE_MSG1("unit %d group %d using result register"
                                    " %u, refers to action table %u (%s)\n"),
                           unitData->unit,
                           groupId,
                           index,
                           progData->actIndex[index],
                           unitData->actData[progData->actIndex[index]]->ucData->tableName));
                groupData->resultLrpUniq |= (1 << index);
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
                if (unitData->actData[progData->actIndex[index]]->ucData->ctrRead) {
                    /* this one uses action-indexed counters */
                    groupData->groupFlags |= _SOC_C3_RCE_GROUP_FLAG_COUNTER;
                    RCE_EVERB((RCE_MSG1("unit %d group %d using action-indexed"
                                        " counters due to result register"
                                        " %u action table %u (%s) counter"
                                        " segment %s\n"),
                               unitData->unit,
                               groupId,
                               index,
                               progData->actIndex[index],
                               unitData->actData[progData->actIndex[index]]->ucData->tableName,
                               unitData->actData[progData->actIndex[index]]->ucData->ctrName));
                }
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
#if defined(BROADCOM_DEBUG)
            } else {
                /* already have a reference to this one */
                RCE_EVERB((RCE_MSG1("unit %d group %d using result register"
                                    " %u, also refers to action table %u"
                                    " (%s)\n"),
                           unitData->unit,
                           groupId,
                           index,
                           progData->actIndex[index],
                           unitData->actData[progData->actIndex[index]]->ucData->tableName));
#endif /* defined(BROADCOM_DEBUG) */
            }
#if defined(BROADCOM_DEBUG)
        } else { /* if (using this result register) */
            RCE_EVERB((RCE_MSG1("unit %d group %d not using result register"
                                " %u\n"),
                       unitData->unit,
                       groupId,
                       index));
#endif /* defined(BROADCOM_DEBUG) */
        } /* if (using this result register) */
    } /* for (all possible result registers) */
    /*
     *  Only permit one bit set in the 'unique' actions bitmap.
     *
     *  The resource implications of allowing two are daunting: since the
     *  result bias is the same for all result registers, each filter set must
     *  have the same base address in all of its action tables.  May not seem
     *  so bad until you start mixing groups that refer to more than one but
     *  not all the same result registers.
     */
    for (index = 0, offset = 0;
         index < SOC_C3_RCE_RESULT_REGISTER_COUNT;
         index++) {
        if (groupData->resultLrpUniq & (1 << index)) {
            offset++;
        }
    }
    if (1 != offset) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d requires that each group provide at least"
                   " one valid result, but refer to no more than one"
                   " specific action table; group %d attempts to use"
                   " %u action tables\n"),
                   unitData->unit,
                   groupId,
                   offset));
        result = SOC_E_CONFIG;
        goto error;
    }
    /* copy the qualifiers to internal space */
    for (index = 0; index < groupData->qualCount; index++) {
        /* we keep a qualifier and its parameters in a single heap cell */
        newQualData = newGroupData->qualData[index];
        if (newQualData->qualName) {
            nameSize = sal_strlen(newQualData->qualName) + 1;
            if (nameSize > C3_RCE_QUAL_NAME_BYTES) {
                nameSize = C3_RCE_QUAL_NAME_BYTES;
            }
        } else {
            nameSize = 1;
        }
        allocSize = (sizeof(*(qualData)) +
                     (newQualData->paramCount *
                      sizeof(qualData->param[0])) +
                     nameSize);
        qualData = sal_alloc(allocSize, "C3 RCE group qualifier data");
        if (qualData) {
            sal_memset(qualData, 0x00, allocSize);
            qualData->qualType = newQualData->qualType;
            qualData->paramCount = newQualData->paramCount;
            qualData->param = (int*)&(qualData[1]);
            qualData->qualName = (char*)(&(qualData->param[qualData->paramCount]));
            for (offset = 0;
                 offset < qualData->paramCount;
                 offset++) {
                qualData->param[offset] = newQualData->param[offset];
            }
            if (nameSize > 1) {
                sal_strncpy(qualData->qualName,
                            newQualData->qualName,
                            nameSize - 1);
            }
            groupData->qualData[index] = qualData;
        } else {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to allocate %d bytes for unit %d group"
                       " %d qualifier information\n"),
                       allocSize,
                       unitData->unit,
                       groupId));
            result = SOC_E_MEMORY;
            goto error;
        }
    } /* for (index = 0; index < newGroupData->qualCount; index++) */
    /* compute number of instructions for the filter set */
    for (index = 0, allocSize = 1;
         index < groupData->qualCount;
         index++) {
        result = _soc_c3_rce_program_build_general(groupData->qualData[index],
                                                   NULL,
                                                   &elemSize);
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to determine size for unit %d group %d"
                       " qualifier %u RCE instructions: %d (%s)\n"),
                       unitData->unit,
                       groupId,
                       index,
                       result,
                       _SHR_ERRMSG(result)));
            goto error;
        }
        groupData->qualOffs[index] = allocSize;
        allocSize += elemSize;
    } /* for (all qualifiers this group) */
    /* figure out how long the filter set must be for the requested template */
    _soc_c3_rce_filter_set_length((allocSize +
                                   newGroupData->rangesPerFilterSet +
                                   7) >> 3,
                                  1 /* allow short filter sets */,
                                  &elemSize);
    /*
     *  Rather than waste space, any instructions left over on top of the
     *  requested template will be allocated to ranges.  If the caller does not
     *  use them, no loss, but at least they are not automatically lost.
     */
    groupData->rangesPerFilterSet = (elemSize << 3) - allocSize;
    /* adjust so we allocate enough space for the extended template */
    allocSize = elemSize << 3;
    groupData->instrBlocks = elemSize;
    groupData->instrCount = allocSize;
    /* allocate space for the instructions */
    allocSize *= sizeof(*(groupData->instr));
    groupData->instr = sal_alloc(allocSize,  "C3 RCE group instructions");
    if (!groupData->instr) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %d bytes for unit %d group %d"
                   " instrucitons list\n"),
                   allocSize,
                   unitData->unit,
                   groupId));
        result = SOC_E_MEMORY;
        goto error;
    }
    sal_memset(groupData->instr, 0x00, allocSize);
    /*
     *  The first instruction in a filter set must be a start instruction, but
     *  which start instruction is based upon whether it is the first filter
     *  set in a program or a later one.  That decision is made according to
     *  the placement of the filter set by group priority, so we will only fill
     *  in the parts of that instruction that can be known now -- where to put
     *  the results.
     */
    COMPILER_64_SET(groupData->instr[0],
                    0,
                    (((groupData->resultLrp & 0x0F) << 20) |
                     ((groupData->resultRce & 0x0F) << 24)));
    /* add a number of NOPs for ranges */
    for (allocSize = 1;
         allocSize <= groupData->rangesPerFilterSet;
         allocSize++) {
        COMPILER_64_SET(groupData->instr[index], (_c3RCEOpcode_nop << 8), 0);
    }
    /* adjust pattern bit index for each qualifier to skip ranges */
    for (index = 0; index < groupData->qualCount; index++) {
        groupData->qualOffs[index] += groupData->rangesPerFilterSet;
    }
    /*
     *  After that, each of the qualifiers provided by the caller is built, in
     *  the caller's specified order.  There are certain constraints, but these
     *  apply to certain features such as using prior results as qualifiers.
     */
    for (index = 0;
         index < groupData->qualCount;
         index++) {
        if (allocSize != groupData->qualOffs[index]) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("instruction count mismatch between passes"
                       " building unit %d group %d qualifier %u:"
                       " was %u now %u\n"),
                       unitData->unit,
                       groupId,
                       index,
                       groupData->qualOffs[index],
                       allocSize));
            result = SOC_E_INTERNAL;
            goto error;
        }
        result = _soc_c3_rce_program_build_general(groupData->qualData[index],
                                                   &(groupData->instr[allocSize]),
                                                   &elemSize);
        if (SOC_E_NONE != result) {
            /* should not occur at this point, but... */
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to build instructions for unit %d"
                       " group %d: %d (%s)\n"),
                       unitData->unit,
                       groupId,
                       result,
                       _SHR_ERRMSG(result)));
            goto error;
        }
        groupData->qualOffs[index] = allocSize;
        allocSize += elemSize;
    } /* for (all qualifiers this group) */
    if (allocSize != groupData->instrCount) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("instruction count mismatch between passes building"
                   " unit %d group %d: was %u now %u\n"),
                   unitData->unit,
                   groupId,
                   groupData->instrCount,
                   allocSize));
        result = SOC_E_INTERNAL;
        goto error;
    }
    /*
     *  The filter set must have at least one instruction in the final eight
     *  that has the EndF flag set.  This means we need either a NOP or one of
     *  the data comparison opcodes (prefix, start-filter and start-program do
     *  not have a place for EndF to be indicated).  The code that builds the
     *  actual RCE instrucition memory image will set the flag but we need to
     *  be sure there is a place for it in the final eight instructions.
     *
     *  If the instruction count is *not* an integral mulitple of eight, we
     *  already know there will be at least one NOP in the last block.
     *  Otherwise, we need to scan the last block to see if there is an
     *  applicable instruction.
     */
    if (0 == (groupData->instrCount & 7)) {
        /* is an integral multiple of eight; scan last eight instructions */
        result = SOC_E_NOT_FOUND; /* did not find one */
        while (allocSize > groupData->instrCount - 8) {
            allocSize--;
            opcode = (COMPILER_64_HI(groupData->instr[allocSize]) & 0x700) >> 8;
            if ((_c3RCEOpcode_nop == opcode) ||
                (_c3RCEOpcode_data == opcode) ||
                (_c3RCEOpcode_match0 == opcode) ||
                (_c3RCEOpcode_match1 == opcode)) {
                result = SOC_E_NONE; /* okay */
                break;
            }
        }
    } /* if (0 == (groupData->instrCount & 7)) */
    /*
     *  At this point, result is SOC_E_NONE if we know there will be a NOP or
     *  some other EndF-capable opcode in the last eight for the group, or is
     *  not SOC_E_NONE otherwise.  In the latter case, add an instruction block
     *  to the group (which will be filled with NOPs when programming the
     *  hardware) so there will be acceptable opcodes in the last block.
     *
     *  NOTE: this *should* *never* *happen*, but if it does, this last block
     *  is utterly wasted -- it is not useable for ranges or other expansions.
     */
    if (SOC_E_NONE != result) {
        /* need to adjust instruction block count to add a block of NOPs */
        groupData->instrBlocks++;
        result = SOC_E_NONE;
    }
#if 0
    /*
     *  It should be pretty rare that a group's template is too short for even
     *  a later filter set (and first filter set will be adjusted elsewhere),
     *  but if it does happen, adjust the claimed size so it is equal to the
     *  minimum possible filter set length.
     */
    if (groupData->instrBlocks < C3_RCE_FILTER_SET_LENGTH_LATER) {
        groupData->instrBlocks = C3_RCE_FILTER_SET_LENGTH_LATER;
    }
#endif
    /*
     *  The code that builds the filter set parts will also fill in the default
     *  pattern value that is needed for normal behaviour (no qualifiers means
     *  all frames match -- basically all qualifiers are don't care).  We now
     *  pack these bits into the default pattern buffer for use when entries
     *  are created (so they follow the convention).
     */
    groupData->defaultPattern = sal_alloc(groupData->instrBlocks,
                                          "C3 RCE group default pattern");
    if (!groupData->defaultPattern) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %u bytes for unit %d group %d"
                   " default pattern\n"),
                   groupData->instrBlocks,
                   unitData->unit,
                   groupId));
        result = SOC_E_MEMORY;
        goto error;
    }
    sal_memset(groupData->defaultPattern, 0x00, groupData->instrBlocks);
    for (index = 0; index < groupData->instrCount; index++) {
        if ((1 << 31) & COMPILER_64_HI(groupData->instr[index])) {
            groupData->defaultPattern[index >> 3] |= (1 << (index & 7));
        }
    }
    groupData->dataSize = 0;
    for (index = 0; index < SOC_C3_RCE_RESULT_REGISTER_COUNT; index++) {
        if (groupData->resultLrpUniq & (1 << index)) {
            /* we need to have space for this result's data */
            groupData->dataSize += unitData->actData[progData->actIndex[index]]->actionBytes;
        }
    }
    /* need to have space for the qualifier data */
    groupData->dataSize += groupData->instrBlocks;
    /* figure out where the group goes in the program */
    for (index = 0, groupTemp = progData->groupHead;
         (index < (progData->groupCount - 1)) &&
         (0 >= _soc_c3_rce_group_prio_compare(groupData->groupPriority,
                                              groupTemp->groupPriority));
         index++, groupTemp = groupTemp->groupNext) {
        /*
         *  This loop will scan through the groups in the program until it
         *  finds the one before which the new group should be inserted.
         */
    }
    /* attach the group to the unit */
    unitData->groupData[groupId] = groupData;
    /* now insert the group before the indicated position */
    groupData->groupNext = groupTemp;
    if (groupTemp) {
        /* somewhere within the program's groups; insert before this one */
        groupData->groupPrev = groupTemp->groupPrev;
        groupTemp->groupPrev = groupData;
        if (groupData->groupPrev) {
            /* there is a group before this one */
            groupData->groupPrev->groupNext = groupData;
        } else {
            /* this will be the first group in the program */
            progData->groupHead = groupData;
        }
    } else { /* if (groupTemp) */
        /* fell off the end of the program's groups; add to the tail */
        groupData->groupPrev = progData->groupTail;
        if (groupData->groupPrev) {
            /* there are other groups in this program */
            groupData->groupPrev->groupNext = groupData;
        } else {
            /* this is the only group in this program */
            progData->groupHead = groupData;
        }
        progData->groupTail = groupData;
    } /* if (groupTemp) */
    /* now find where in the program the initial filter set needs to go */
    if (groupData->groupNext) {
        /* there is a group after this one; find it */
        for (index = 0; index < progData->filterSetCount; index++) {
            if (progData->fsetData[index].groupId ==
                groupData->groupNext->groupId) {
                /* found the first filter set of the following group */
                break;
            }
        }
    } else { /* if (groupData->groupNext) */
        /* there is no group after this one; add as last */
        index = progData->filterSetCount + 1;
    } /* if (groupData->groupNext) */
    /* add initial filter set to the program */
    result = _soc_c3_rce_filter_set_add(unitData,
                                        groupId,
                                        0 /* first filter set in group */,
                                        index /* where to put in program */);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to add unit %d group %d filter set 0 to"
                   " program %u (%s): %d (%s)\n"),
                   unitData->unit,
                   groupId,
                   groupData->rceProgram,
                   progData->ucData->programName,
                   result,
                   _SHR_ERRMSG(result)));
        goto error;
    }
error:
    if (SOC_E_NONE != result) {
        if (groupData) {
            /* created group descriptor */
            /* free each qualifier descriptor */
            for (index = 0; index < groupData->qualCount; index++) {
                if (groupData->qualData[index]) {
                    sal_free(groupData->qualData[index]);
                }
            }
            /* free the filter set instructions */
            if (groupData->instr) {
                sal_free(groupData->instr);
            }
            /* free the filter set default pattern */
            if (groupData->defaultPattern) {
                sal_free(groupData->defaultPattern);
            }
            /* delink the group from the program's list of groups */
            if (groupData->groupPrev) {
                groupData->groupPrev->groupNext = groupData->groupNext;
            }
            if (groupData->groupNext) {
                groupData->groupNext->groupPrev = groupData->groupPrev;
            }
            if (progData->groupHead == groupData) {
                progData->groupHead = groupData->groupNext;
            }
            if (progData->groupTail == groupData) {
                progData->groupTail = groupData->groupPrev;
            }
            /* ensure group is no longer in unit */
            if (unitData->groupData[groupId] == groupData) {
                unitData->groupData[groupId] = NULL;
            }
            /* adjust accounting */
            progData->groupCount--;
            sal_free(groupData);
        } /* if (groupData) */
    } /* if (SOC_E_NONE != result) */
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_group_destroy
 *  Purpose
 *    Destroys an exiting group in an existing program
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) groupId = group ID to be destroyed
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    If the group has any entries, this will also destroy them.  In addition,
 *    since this removes the group's filter sets, it removes from hardware any
 *    residual entries that might have been left if entries were destroyed but
 *    not removed.
 */
int
_soc_c3_rce_group_destroy(_soc_c3_rce_unit_desc_int_t *unitData,
                          int groupId)
{
    _soc_c3_rce_program_desc_int_t *progData;
    _soc_c3_rce_group_desc_int_t *groupData;
    _soc_c3_rce_entry_desc_int_t *entryData;
    _soc_c3_rce_entry_desc_int_t *entryNext;
    unsigned int index;
    int result;

    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META("unit %d destroy group %d\n"),
                 unitData->unit, groupId));
    groupData = unitData->groupData[groupId];
    if (!groupData) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d group %d does not exist\n"),
                   unitData->unit,
                   groupId));
        return SOC_E_NOT_FOUND;
    }
    progData = unitData->progData[groupData->rceProgram];
    /*
     *  If there are entries, get rid of them.  We can take a shortcut here and
     *  not deal with group membership accounting or similar, but we must still
     *  handle the entry map and free the memory owned by each entry.
     */
    for (entryNext = groupData->entryHead; entryNext; /* incr in loop */) {
        entryData = entryNext;
        entryNext = entryData->entryNext;
        unitData->entryData[entryData->entryId] = NULL;
        sal_free(entryData);
    } /* for (all entries in this group) */
    groupData->entryHead = NULL;
    groupData->entryTail = NULL;
    groupData->entryCount = 0;
    /* remove all filter sets of this group from hardware */
    index = 0;
    while (groupData->filterSetCount) {
        RCE_EVERB((RCE_MSG1("unit %d group %d has %u filter sets\n"),
                   unitData->unit,
                   groupId,
                   groupData->filterSetCount));
        /* remove first of this group's remaining filter sets */
        result = _soc_c3_rce_filter_set_remove(unitData, groupId, index);
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to remove unit %d group %d filter set"
                       " %u from program %u (%s): %d (%s)\n"),
                       unitData->unit,
                       groupId,
                       index,
                       groupData->rceProgram,
                       progData->ucData->programName,
                       result,
                       _SHR_ERRMSG(result)));
            return result;
        }
        index++;
    } /* for (all filter sets this group) */
    /* delink this group from the program */
    if (groupData->groupNext) {
        groupData->groupNext->groupPrev = groupData->groupPrev;
    }
    if (groupData->groupPrev) {
        groupData->groupPrev->groupNext = groupData->groupNext;
    }
    if (progData->groupHead == groupData) {
        progData->groupHead = groupData->groupNext;
    }
    if (progData->groupTail == groupData) {
        progData->groupTail = groupData->groupPrev;
    }
    /* update accounting information */
    progData->groupCount--;
    unitData->groupData[groupId] = NULL;
    /* free memory associated with the group */
    for (index = 0; index < groupData->qualCount; index++) {
        sal_free(groupData->qualData[index]);
    }
    sal_free(groupData->instr);
    sal_free(groupData->defaultPattern);
    sal_free(groupData);
    /* done */
    return SOC_E_NONE;
}

/*
 *  Function
 *    _soc_c3_rce_group_install
 *  Purpose
 *    Installs an entire group to hardware
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) groupId = group to install
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Sets bit zero of the pattern for each entry in the group (this would
 *    activate the entry for the hardware), then copies API state
 *    qualifier/action data to hardware qualifer/action space, then updates the
 *    group's filter sets to hardware.  This operates per filter set, so it is
 *    possible that a failure will fully install some filter sets but not other
 *    filter sets.
 *
 *    Backs out changes to the failing filter set on failure.
 */
static int
_soc_c3_rce_group_install(_soc_c3_rce_unit_desc_int_t *unitData,
                          int groupId)
{
    _soc_c3_rce_entry_desc_int_t *entryCurr;
    _soc_c3_rce_entry_desc_int_t *entryHead;
    _soc_c3_rce_group_desc_int_t *groupData;
    _soc_c3_rce_program_desc_int_t *progData;
    uint8 *dataOrig = NULL;
    unsigned int dataSize;
    unsigned int fullDataSize;
    unsigned int dataOffset;
    unsigned int filterSet;
    unsigned int filterSetPrg;
    unsigned int fsetMinPos;
    unsigned int fsetMaxPos;
    int result = SOC_E_NONE;

    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META("unit %d group %d install\n"),
                 unitData->unit,
                 groupId));
    /* get the information about this group and program */
    groupData = unitData->groupData[groupId];
    progData = unitData->progData[groupData->rceProgram];

    /* allocate backout buffer in case of failure */
    dataSize = groupData->dataSize;
    fullDataSize = dataSize << 1;
    dataOrig = sal_alloc(fullDataSize * C3_RCE_ENTRIES_PER_FILTER_SET,
                         "C3 RCE group install backout temp");
    if (!dataOrig) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %u bytes working space\n"),
                   fullDataSize * C3_RCE_ENTRIES_PER_FILTER_SET));
        result = SOC_E_MEMORY;
        goto error;
    }
    result = _soc_c3_rce_filter_set_locate(unitData,
                                           progData,
                                           groupId,
                                           0,
                                           &filterSetPrg);
    if (SOC_E_NONE != result) {
        /* called function displayed diagnostic */
        goto error;
    }
    /* install and commit each filter set in the group, in turn */
    for (filterSet = 0;
         filterSet < groupData->filterSetCount;
         filterSet++) {
        fsetMinPos = filterSet * C3_RCE_ENTRIES_PER_FILTER_SET;
        fsetMaxPos = fsetMinPos + (C3_RCE_ENTRIES_PER_FILTER_SET - 1);
        RCE_EVERB((RCE_MSG1("install group %d filter set %u (%u..%u) %u %u %08X, %d %u\n"),
                   groupId,
                   filterSet,
                   fsetMinPos,
                   fsetMaxPos,
                   progData->fsetData[filterSetPrg + filterSet].amemBlock,
                   progData->fsetData[filterSetPrg + filterSet].amemBlock * 1536,
                   progData->fsetData[filterSetPrg + filterSet].amemBlock * 1536 + 768,
                   progData->fsetData[filterSetPrg + filterSet].entryHead?progData->fsetData[filterSetPrg + filterSet].entryHead->entryId:-1,
                   progData->fsetData[filterSetPrg + filterSet].entryHead?progData->fsetData[filterSetPrg + filterSet].entryHead->entryPosition:~0));
        entryHead = progData->fsetData[filterSetPrg + filterSet].entryHead;
        for (entryCurr = entryHead;
             entryCurr && (entryCurr->entryPosition <= fsetMaxPos);
             entryCurr = entryCurr->entryNext) {
#if 0 
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("install group %d entry %d position %u,%u\n"),
                       groupId,
                       entryCurr->entryId,
                       entryCurr->entryPosition,
                       entryCurr->entryPosPrev));
#else /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("install group %d entry %d position %u\n"),
                       groupId,
                       entryCurr->entryId,
                       entryCurr->entryPosition));
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
#endif 
            /* copy old data for this entry */
            dataOffset = (fullDataSize *
                          (entryCurr->entryPosition - fsetMinPos));
            sal_memcpy(&(dataOrig[dataOffset]),
                       entryCurr->pattData[0],
                       fullDataSize);
            /* mark this entry as active by setting pattern bit for start */
            entryCurr->pattData[0][0] |= 1;
            /* copy the API state to the hardware state */
            sal_memcpy(entryCurr->pattData[1],
                       entryCurr->pattData[0],
                       dataSize);
        } /* for (all entries in this filter set) */
        /* update the filter set in hardware */
        result = _soc_c3_rce_filter_set_update(unitData,
                                               groupId,
                                               filterSet,
                                               FALSE /* normal behaviour */);
        if (SOC_E_NONE == result) {
            /* mark these entries installed and not modified */
            for (entryCurr = entryHead;
                 entryCurr && (entryCurr->entryPosition <= fsetMaxPos);
                 entryCurr = entryCurr->entryNext) {
                entryCurr->entryFlags |= SOC_C3_RCE_ENTRY_FLAG_INSTALLED;
                entryCurr->entryFlags &= (~SOC_C3_RCE_ENTRY_FLAG_MODIFIED);
            } /* for (all entries in this filter set) */
        } else { /* if (SOC_E_NONE == result) */
            /* restore the previous state for these entries and abort */
            for (entryCurr = entryHead;
                 entryCurr && (entryCurr->entryPosition <= fsetMaxPos);
                 entryCurr = entryCurr->entryNext) {
                dataOffset = (fullDataSize *
                              (entryCurr->entryPosition - fsetMinPos));
                sal_memcpy(entryCurr->pattData[0],
                           &(dataOrig[dataOffset]),
                           fullDataSize);
            } /* for (all entries in this filter set) */
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to update unit %d group %d filter set"
                       " %u: %d (%s)\n"),
                       unitData->unit,
                       groupId,
                       filterSet,
                       result,
                       _SHR_ERRMSG(result)));
            goto error;
        } /* if (SOC_E_NONE == result) */
    } /* for (all filter sets in this group) */
error:
    if (dataOrig) {
        sal_free(dataOrig);
    }
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_group_remove
 *  Purpose
 *    Removes an entire group from hardware
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) groupId = group to remove
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Clears bit zero of the pattern for each entry in the group (this would
 *    deactivate the entry for the hardware), then copies API state
 *    qualifier/action data to hardware qualifer/action space, then updates the
 *    group's filter sets to hardware.  This operates per filter set, so it is
 *    possible that a failure will fully install some filter sets but not other
 *    filter sets.
 *
 *    Backs out changes to the failing filter set on failure.
 *
 *    Rather than doing a read-modify-write update for each of the superblock,
 *    we want to use IMEM_PMEM and get it over more quickly.  Since we are only
 *    modifying a single bit, and specifically that bit makes all of the other
 *    bits not matter, we'll just go ahead and update a single row of IMEM_PMEM
 *    by reading the first block for the filter set, clearing the LSb of each
 *    of the pattern bytes, and then writing it back.  Even if this does not
 *    occur atomically, it should not affect traffic behaviour adversely.
 */
static int
_soc_c3_rce_group_remove(_soc_c3_rce_unit_desc_int_t *unitData,
                         int groupId)
{
    _soc_c3_rce_entry_desc_int_t *entryCurr;
    _soc_c3_rce_entry_desc_int_t *entryHead;
    _soc_c3_rce_group_desc_int_t *groupData;
    _soc_c3_rce_program_desc_int_t *progData;
    _soc_c3_rce_program_block_t *progBlock = NULL;
    _soc_c3_rce_filterset_desc_int_t *fsetData;
    unsigned int filterSet;
    unsigned int progFSet;
    unsigned int fsetMinPos;
    unsigned int fsetMaxPos;
    unsigned int entryRow;
    unsigned int entryCol;
    int result = SOC_E_NONE;

    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META("unit %d group %d remove\n"),
                 unitData->unit,
                 groupId));
    /* allocate working buffer */
    progBlock = soc_cm_salloc(unitData->unit,
                              sizeof(*progBlock),
                              "C3 RCE instruction/pattern memory workspace");
    if (!progBlock) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %u bytes instruction buffer\n"),
                   (unsigned int)(sizeof(*progBlock))));
        result = SOC_E_MEMORY;
        goto error;
    }
    /* get the information about this group and program */
    groupData = unitData->groupData[groupId];
    progData = unitData->progData[groupData->rceProgram];
    /* find the first filter set of this group */
    for (progFSet = 0;
         (progData->fsetData[progFSet].groupId != groupId) &&
         (progFSet < progData->filterSetCount);
         progFSet++) {
        /* just scan until we get there */
    }
    if (progFSet >= progData->filterSetCount) {
        /* fell off the end */
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d unable to find group %d first filter set"
                   " in program %u (%s) (group missing)\n"),
                   unitData->unit,
                   groupId,
                   groupData->rceProgram,
                   progData->ucData->programName));
        result = SOC_E_INTERNAL;
        goto error;
    }
    /* remove each filter set in the group, in turn */
    for (filterSet = 0;
         filterSet < groupData->filterSetCount;
         filterSet++, progFSet++) {
        fsetMinPos = filterSet * C3_RCE_ENTRIES_PER_FILTER_SET;
        fsetMaxPos = fsetMinPos + (C3_RCE_ENTRIES_PER_FILTER_SET - 1);
        fsetData = &(progData->fsetData[progFSet]);
        if ((filterSet != fsetData->filterIndex) ||
            (groupId != fsetData->groupId)) {
            /* but this always match the current index */
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unit %d unable to find group %d filter set %u"
                       " in program %u (%s) (found group %d filter"
                       " set %u)\n"),
                       unitData->unit,
                       groupId,
                       filterSet,
                       groupData->rceProgram,
                       progData->ucData->programName,
                       fsetData->groupId,
                       fsetData->filterIndex));
            result = SOC_E_INTERNAL;
            goto error;
        }
        entryHead = fsetData->entryHead;
        /* get this filter set's first IMEM+PMEM block */
        result = soc_cm_sinval(unitData->unit, progBlock, sizeof(*progBlock));
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to invalidate cache for instruction"
                       " memory: %d (%s)\n"),
                       result,
                       _SHR_ERRMSG(result)));
            goto error;
        }
        result = soc_mem_read_range(unitData->unit,
                                    IMEM_PMEM_DMAm,
                                    MEM_BLOCK_ANY,
                                    fsetData->imemStart << 5,
                                    ((fsetData->imemStart + 1) << 5) - 1,
                                    progBlock);
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unit %d unable to read program %u (%s) group %d"
                       " filter set %u IMEM+PMEM at %03X: %d (%s)\n"),
                       unitData->unit,
                       groupData->rceProgram,
                       progData->ucData->programName,
                       groupId,
                       filterSet,
                       fsetData->imemStart,
                       result,
                       _SHR_ERRMSG(result)));
            goto error;
        }
        /* disable all entries in the filter set */
        for (entryRow = 0; entryRow < 24; entryRow++) {
            for (entryCol = 0; entryCol < 32; entryCol++) {
                progBlock->pattern[entryRow][entryCol] &= (~0x01);
            }
        }
        result = soc_cm_sflush(unitData->unit, progBlock, sizeof(*progBlock));
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to flush cache for instruction memory:"
                       " %d (%s)\n"),
                       result,
                       _SHR_ERRMSG(result)));
            goto error;
        }
        /* update the filter set in hardware */
        /*    coverity[negative_returns : FALSE]    */
        result = soc_mem_write_range(unitData->unit,
                                     IMEM_PMEM_DMAm,
                                     MEM_BLOCK_ALL,
                                     fsetData->imemStart << 5,
                                     ((fsetData->imemStart + 1) << 5) - 1,
                                     progBlock);
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unit %d unable to read program %u (%s) group %d"
                       " filter set %u IMEM+PMEM at %03X: %d (%s)\n"),
                       unitData->unit,
                       groupData->rceProgram,
                       progData->ucData->programName,
                       groupId,
                       filterSet,
                       fsetData->imemStart,
                       result,
                       _SHR_ERRMSG(result)));
            goto error;
        }
        /* mark these entries removed  */
        for (entryCurr = entryHead;
             entryCurr && (entryCurr->entryPosition <= fsetMaxPos);
             entryCurr = entryCurr->entryNext) {
            entryCurr->entryFlags &= (~SOC_C3_RCE_ENTRY_FLAG_INSTALLED);
            entryCurr->pattData[0][0] &= (~0x01);
            entryCurr->pattData[1][0] &= (~0x01);
        } /* for (all entries in this filter set) */
        /* mark the committed range counts zero */
        for (entryRow = 0;
             entryRow < groupData->rangesPerFilterSet;
             entryRow++) {
            if (0 == fsetData->rangeInfo[entryRow].rangeId) {
                /* this range was not in use */
                continue;
            }
            if (fsetData->rangeInfo[entryRow].commitCount) {
                /* this range was in use by installed entries now removed */
                fsetData->rangeInfo[entryRow].commitCount = 0;
                if (0 ==
                    fsetData->rangeInfo[entryRow].refCount) {
                    /* this range is not in use by API state either */
                    unitData->rangeData[fsetData->rangeInfo[entryRow].rangeId - 1]->refCount--;
                    sal_memset(&(fsetData->rangeInfo[entryRow]),
                               0x00,
                               sizeof(fsetData->rangeInfo[entryRow]));
                } /* if (this filter set does not have this range in API) */
            } /* if (this filter set had this range in hardware) */
        } /* for (all possible range slots this filter set) */
    } /* for (all filter sets in this group) */
error:
    if (progBlock) {
        soc_cm_sfree(unitData->unit, progBlock);
    }
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_group_compress
 *  Purpose
 *    Attempt to reduce the number of filter sets used by a group by removing
 *    gaps between entries in filter sets.
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) groupId = group to compress
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    This will attempt to pack the entries into fewer filter sets by moving
 *    all of the entries in a filter set to the lowest positions in that filter
 *    set, then moving any entries from the next filter set that will fit into
 *    the filter set, and repeating the process for later filter sets.  If a
 *    filter set is completely emptied by the process, it will be removed.
 */
static int
_soc_c3_rce_group_compress(_soc_c3_rce_unit_desc_int_t *unitData,
                           int groupId)
{
    _soc_c3_rce_entry_desc_int_t *entryCurr;    /* working entry */
    _soc_c3_rce_group_desc_int_t *groupData;    /* group information */
    _soc_c3_rce_program_desc_int_t *progData;   /* program information */
    _soc_c3_rce_filterset_desc_int_t *fsetData; /* working filter set info */
    unsigned int fsetPosMin;                    /* low position this fset */
    unsigned int fsetPosMax;                    /* high position this fset */
    unsigned int positionCurr;                  /* working entry position */
    unsigned int filterSetGrp;                  /* current fset in group */
    unsigned int filterSetPrg;                  /* current fset in program */
    unsigned int moved;                         /* entries moved to fset */
    unsigned int entriesNextFSet;               /* entires in next fset */
    int result = SOC_E_INTERNAL;

    groupData = unitData->groupData[groupId];
    progData = unitData->progData[groupData->rceProgram];
    /* prepare backout for all entries in the group */
    for (entryCurr = groupData->entryHead;
         entryCurr;
         entryCurr = entryCurr->entryNext) {
        entryCurr->entryPosBackout = entryCurr->entryPosition;
    }
    /* start with the first filter set in the group */
    for (filterSetGrp = 0;
         filterSetGrp < groupData->filterSetCount;
         /* adjust will occur inside loop */) {
        /* get the location of this filter set in the program */
        result = _soc_c3_rce_filter_set_locate(unitData,
                                               progData,
                                               groupId,
                                               filterSetGrp,
                                               &filterSetPrg);
        if (SOC_E_NONE != result) {
            /* called function displayed diagnostic */
            goto error;
        }
        /* parameters for this filter set */
        fsetData = &(progData->fsetData[filterSetPrg]);
        fsetPosMin = filterSetGrp * C3_RCE_ENTRIES_PER_FILTER_SET;
        fsetPosMax = fsetPosMin + (C3_RCE_ENTRIES_PER_FILTER_SET - 1);
        if (0 == fsetData->entryCount) {
            if (2 > groupData->filterSetCount) {
                /*
                 *  There are other filter sets in this group and this one is
                 *  empty; remove this filter set.
                 */
                result = _soc_c3_rce_group_fset_remove(unitData,
                                                       progData,
                                                       filterSetPrg,
                                                       groupData,
                                                       filterSetGrp);
                /*
                 *  We do not change the filter set index in program or group
                 *  here because we just deleted this one, since the next one
                 *  has moved to us, rather than us having to move to it.
                 */
                continue;
            }
            /*
             *  If there are no other filter sets in this group, there are no
             *  entries in this group.  Proceed normally (there is nothing to
             *  do here and we will be done after this).
             */
        } else if (fsetData->entryCount < C3_RCE_ENTRIES_PER_FILTER_SET) {
            /* there is space in this filter set */
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META("unit %d program %u filter set %u (group %d"
                         " filter set %u) arranging entries toward"
                         " beginning of filter set\n"),
                         unitData->unit,
                         groupData->rceProgram,
                         filterSetPrg,
                         groupData->groupId,
                         filterSetGrp));
            /* pack entries toward the low side of this filter set */
            for (entryCurr = fsetData->entryHead, positionCurr = fsetPosMin;
                 entryCurr && (entryCurr->entryPosition <= fsetPosMax);
                 entryCurr = entryCurr->entryNext, positionCurr++) {
                entryCurr->entryPosition = positionCurr;
            }
            /* have not moved entries into this filter set (yet) */
            moved = 0;
            if (filterSetGrp < (groupData->filterSetCount - 1)) {
                /* this is not the last filter set */
                entriesNextFSet = progData->fsetData[filterSetPrg + 1].entryCount;
                /* try to move entries from the next filter set to this one */
                result = _soc_c3_rce_filter_set_entry_move(unitData,
                                                           progData,
                                                           groupData,
                                                           filterSetPrg + 1,
                                                           filterSetPrg,
                                                           NULL,
                                                           FALSE,
                                                           &moved);
                LOG_VERBOSE(BSL_LS_SOC_COMMON,
                            (BSL_META("unit %d moved %u entries from program %u"
                             " filter set %u (group %d filter set %u) to"
                             " filter set %u (%u)\n"),
                             unitData->unit,
                             moved,
                             groupData->rceProgram,
                             filterSetPrg + 1,
                             groupData->groupId,
                             filterSetGrp + 1,
                             filterSetPrg,
                             filterSetGrp));
                if (SOC_E_NONE != result) {
                    /* called function displayed diagnostic */
                    goto error;
                }
            } else { /* if (filterSetGrp < (groupData->filterSetCount - 1)) */
                entriesNextFSet = 0;
            } /* if (filterSetGrp < (groupData->filterSetCount - 1)) */
            /*
             *  Since this filter set had space in it when we started, we know
             *  that we either just tried to compress it and move entries into
             *  it, or it had entries moved out of it during a previous update,
             *  or both.  We need to commit it to hardware now, and then mark
             *  the entries in it as being in their proper positions (so a
             *  future error will not try to back out the changes so far).
             */
            result = _soc_c3_rce_filter_set_update(unitData,
                                                   groupId,
                                                   filterSetGrp,
                                                   FALSE);
            if (SOC_E_NONE != result) {
                /* called function displayed diagnostic */
                goto error;
            }
            /* prevent back out of successful position changes so far */
            for (entryCurr = fsetData->entryHead;
                 entryCurr && (entryCurr->entryPosition <= fsetPosMax);
                 entryCurr = entryCurr->entryNext) {
                entryCurr->entryPosBackout = entryCurr->entryPosition;
            }
            if ((filterSetGrp < (groupData->filterSetCount - 1)) &&
                (entriesNextFSet <= moved)) {
                /* next filter set is in this group and is now empty */
                result = _soc_c3_rce_group_fset_remove(unitData,
                                                       progData,
                                                       filterSetPrg + 1,
                                                       groupData,
                                                       filterSetGrp + 1);
                if (SOC_E_NONE != result) {
                    /* called function displayed diagnostic */
                    goto error;
                }
            }
            if ((entriesNextFSet <= moved) &&
                (fsetData->entryCount < C3_RCE_ENTRIES_PER_FILTER_SET) &&
                (filterSetGrp < (groupData->filterSetCount - 1))) {
                /*
                 *  We should stay with this filter set for the next iteration
                 *  if we moved all of the entries from the next filter set
                 *  into this one and there is more room in this filter set and
                 *  there is still at least one more filter set in this group
                 *  after this one.
                 */
                continue;
#if defined(BROADCOM_DEBUG)
            } else { /* if (merged all of next, this not full, more fsets) */
                /*
                 *  We need to move to the next filter set if this one is now
                 *  full, or if we were unable to move all of the entries from
                 *  the next one into this one (this means ranges could not be
                 *  merged), or if there is no additional filter set in this
                 *  group following this one.
                 */
                LOG_VERBOSE(BSL_LS_SOC_COMMON,
                            (BSL_META("unit %d unable to move any more entries"
                             " into program %u filter set %u (group %d"
                             " filter set %u)\n"),
                             unitData->unit,
                             groupData->rceProgram,
                             filterSetPrg,
                             groupData->groupId,
                             filterSetGrp));
#endif /* defined (BROADCOM_DEBUG) */
            } /* if (merged all of next, this not full, more fsets) */
#if defined(BROADCOM_DEBUG)
        } else {
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META("unit %d program %u filter set %u (group %d"
                         " filter set %u) is full -- compression can"
                         " neither rearrange its entries nor shift"
                         " entries into it\n"),
                         unitData->unit,
                         groupData->rceProgram,
                         filterSetPrg,
                         groupData->groupId,
                         filterSetGrp));
#endif /* defined (BROADCOM_DEBUG) */
        }
        /*
         *  Any filter set that has no space in it as we get to it can not have
         *  had entries moved out of it, and there is no point in moving
         *  entries around in it (no rearrangement possible) nor in trying to
         *  move entries into it (no space), so there is no need to update it.
         */
        /*
         *  This filter set still exists, so we need to move to the next
         *  one, rather than waiting for it to come to us.
         */
        filterSetGrp++;
    } /* for (all filter sets in this group) */

error:
    /* back out any position changes not already committed */
    for (entryCurr = groupData->entryHead;
          entryCurr;
          entryCurr = entryCurr->entryNext) {
        entryCurr->entryPosition = entryCurr->entryPosBackout;
    }
    return result;
}


/*--------------------------------------------------------------------------
 *
 *  Implementation of range manipulation
 */

/*
 *  Function
 *    _soc_c3_rce_range_create
 *  Purpose
 *    Create a range
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) rangeId = range ID for the new range to create
 *    (IN) newRangeData = pointer to information about range to create
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    No effect on hardware; merely sets up internal descriptions.
 */
static int
_soc_c3_rce_range_create(_soc_c3_rce_unit_desc_int_t *unitData,
                         int rangeId,
                         const soc_c3_rce_range_desc_t *newRangeData)
{
    soc_c3_rce_header_field_info_t headerField;
    _soc_c3_rce_range_desc_int_t *rangeData = NULL;
    soc_c3_rce_qual_desc_t *qualData = NULL;
    unsigned int index;
    uint32 validProgs;
    int limit;
    int result = SOC_E_NONE;

    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META("unit %d create range %d\n"),
                 unitData->unit,
                 rangeId));
    /* some parameter checking */
    if ((0 > newRangeData->headerField.header) ||
        (socC3RceDataOffsetCount <= newRangeData->headerField.header)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("tried to set invalid header %d on unit %d"
                   " range %d creation\n"),
                   newRangeData->headerField.header,
                   unitData->unit,
                   rangeId));
        result = SOC_E_PARAM;
        goto error;
    }
    if ((1 > newRangeData->headerField.numBits) ||
        (16 < newRangeData->headerField.numBits)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d ranges require 1 <= num bits (%u) <= 16\n"),
                   unitData->unit,
                   newRangeData->headerField.numBits));
        result = SOC_E_PARAM;
        goto error;
    }
    limit = (1 << newRangeData->headerField.numBits) - 1;
    if ((0 > newRangeData->lowerBound) ||
        (limit < newRangeData->lowerBound)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("proposed range is %u bits; requires"
                   " 0 <= lower bound (%d) <= %d\n"),
                   newRangeData->headerField.numBits,
                   newRangeData->lowerBound,
                   limit));
        result = SOC_E_PARAM;
        goto error;
    }
    if ((0 > newRangeData->upperBound) ||
        (limit < newRangeData->upperBound)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("proposed range is %u bits; requires"
                   " 0 <= upper bound (%d) <= %d\n"),
                   newRangeData->headerField.numBits,
                   newRangeData->upperBound,
                   limit));
        result = SOC_E_PARAM;
        goto error;
    }
    if (newRangeData->lowerBound > newRangeData->upperBound) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("range lower bound %d must be <= upper bound %d\n"),
                   newRangeData->lowerBound,
                   newRangeData->upperBound));
        result = SOC_E_PARAM;
        goto error;
    }
    /*
     *  Since the field being used for a range can be based either upon the key
     *  or upon a header field.  Rather than duplicating the code to verify
     *  that here, we just walk all active programs.  If at least one of them
     *  provides an acceptable result (key MSb must be (n*16)+15) then we can
     *  use this range.  Otherwise just return an error now.  Warn whichever
     *  programs do not provide acceptable results.
     */
    for (index = 0, validProgs = 0;
         index < SOC_C3_RCE_PROGRAM_COUNT;
         index++) {
        if (!unitData->progData[index]) {
            /* this program is not enabled */
            continue;
        }
        sal_memcpy(&headerField,
                   &(newRangeData->headerField),
                   sizeof(headerField));
        result = _soc_c3_rce_program_qualifier_build(unitData,
                                                     index,
                                                     &headerField,
                                                     socC3RCEQualType_exact,
                                                     &qualData);
        if (SOC_E_NONE != result) {
            if (qualData) {
                soc_c3_rce_program_qualifier_free(unitData->unit, qualData);
                qualData = NULL;
            }
            LOG_WARN(BSL_LS_SOC_COMMON,
                     (BSL_META("unit %d program %u (%s) can not use range %d"
                      " due to inability to build qualifier spec:"
                      " %d (%s)\n"),
                      unitData->unit,
                      index,
                      unitData->progData[index]->ucData->programName,
                      rangeId,
                      result,
                      _SHR_ERRMSG(result)));
            result = SOC_E_NONE;
            continue;
        }
        switch (qualData->qualType) {
        case socC3RCEQualType_prefix_sparse:
        case socC3RCEQualType_postfix_sparse:
        case socC3RCEQualType_masked_sparse:
        case socC3RCEQualType_exact_sparse:
            LOG_WARN(BSL_LS_SOC_COMMON,
                     (BSL_META("unit %d program %u (%s) can not use range %d"
                      " because it is not contiguous key bits\n"),
                      unitData->unit,
                      index,
                      unitData->progData[index]->ucData->programName,
                      rangeId));
            break;
        case socC3RCEQualType_prefix:
        case socC3RCEQualType_postfix:
        case socC3RCEQualType_masked:
        case socC3RCEQualType_exact:
            if (qualData->paramCount != 2) {
                LOG_WARN(BSL_LS_SOC_COMMON,
                         (BSL_META("unit %d program %u (%s) can not use range"
                          " %d because it is not a single contiguous"
                          " block of bits\n"),
                          unitData->unit,
                          index,
                          unitData->progData[index]->ucData->programName,
                          rangeId));
                break;
            }
            if (15 != (qualData->param[1] & 15)) {
                LOG_WARN(BSL_LS_SOC_COMMON,
                         (BSL_META("unit %d program %u (%s) can not use range"
                          " %d becuase its most significant bit %d is"
                          " not left aligned within a 16 bit key"
                          " grain (must be 15+n*16)\n"),
                          unitData->unit,
                          index,
                          unitData->progData[index]->ucData->programName,
                          rangeId,
                          qualData->param[1]));
                break;
            }
            validProgs |= (1 << index);
            break;
        default:
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to parse range for unit %d range %d\n"),
                       unitData->unit,
                       rangeId));
            result = SOC_E_INTERNAL;
        } /* switch (qualData->qualType) */
        soc_c3_rce_program_qualifier_free(unitData->unit, qualData);
        qualData = NULL;
        if (SOC_E_NONE != result) {
            break;
        }
    } /* for (all programs on this unit) */
    if (SOC_E_NONE != result) {
        /* something went wrong looking at programs */
        goto error;
    }
    if (0 == validProgs) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d has no programs where proposed range %d"
                   " can be used\n"),
                   unitData->unit,
                   rangeId));
        result = SOC_E_PARAM;
        goto error;
    }
    /* allocate memory for the range description */
    if (headerField.fieldName) {
        index = sal_strlen(headerField.fieldName) + 1;
        if (index > C3_RCE_RANGE_NAME_BYTES) {
            index = C3_RCE_RANGE_NAME_BYTES;
        }
    } else {
        index = 1;
    }
    rangeData = sal_alloc(sizeof(*rangeData) + index, "C3 RCE range data");
    if (!rangeData) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %u bytes for range data\n"),
                   (unsigned int)(sizeof(*rangeData) + index)));
        result = SOC_E_MEMORY;
        return result;
    }
    /* set up the range description */
    sal_memset(rangeData, 0x00, sizeof(*rangeData) + index);
    if (newRangeData->rangeFlags & SOC_C3_RCE_RANGE_FLAG_INVERT) {
        rangeData->rangeFlags |= SOC_C3_RCE_RANGE_FLAG_INVERT;
    }
    rangeData->rangeFlags |= SOC_C3_RCE_RANGE_FLAG_VALID;
    rangeData->validProgs = validProgs;
    rangeData->lowerBound = newRangeData->lowerBound;
    rangeData->upperBound = newRangeData->upperBound;
    rangeData->headerField.header = newRangeData->headerField.header;
    rangeData->headerField.numBits = newRangeData->headerField.numBits;
    rangeData->headerField.startBit = newRangeData->headerField.startBit;
    /* we allocated space for the string just beyond the descriptor */
    rangeData->headerField.fieldName = (char*)(&(rangeData[1]));
    if (index > 1) {
        sal_strncpy(rangeData->headerField.fieldName,
                    newRangeData->headerField.fieldName,
                    index - 1);
    }
    /* commit the range */
    /* range ID is based from 1 due to a BCM layer quirk */
    unitData->rangeData[rangeId - 1] = rangeData;
error:
    if (SOC_E_NONE != result) {
        if (rangeData) {
            sal_free(rangeData);
        }
    } /* if (SOC_E_NONE != result) */
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_range_destroy
 *  Purpose
 *    Destroy a range
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) rangeId = range ID for the range to destroy
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    No effect on hardware; merely tears down internal descriptions.
 *
 *    Will not destroy a range if there are filter sets referring to it.
 */
static int
_soc_c3_rce_range_destroy(_soc_c3_rce_unit_desc_int_t *unitData,
                          int rangeId)
{
    _soc_c3_rce_range_desc_int_t *rangeData = unitData->rangeData[rangeId - 1];

    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META("unit %d destroy range %d\n"),
                 unitData->unit,
                 rangeId));
    if (rangeData->refCount) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d range %d is in use\n"),
                   unitData->unit,
                   rangeId));
        return SOC_E_CONFIG;
    }
    unitData->rangeData[rangeId - 1] = NULL;
    sal_free(rangeData);
    return SOC_E_NONE;
}


/*--------------------------------------------------------------------------
 *
 *  Implementation of other misc internals
 */

/*
 *  Function
 *    _soc_c3_rce_data_free
 *  Purpose
 *    Frees all resources used in managing the RCE
 *  Arguments
 *    (IN) unitData = pointer to unit data to release
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Does not affect hardware state
 */
static int
_soc_c3_rce_data_free(_soc_c3_rce_unit_desc_int_t **unitData)
{
    _soc_c3_rce_group_desc_int_t *groupData;
    _soc_c3_rce_program_desc_int_t *progData;
    _soc_c3_rce_actions_desc_int_t *actData;
    unsigned int group;
    unsigned int index;
    int result = SOC_E_NONE;

    if ((*unitData)->imemRes) {
        RCE_EVERB((RCE_MSG1("destroy unit %d imem allocator\n"),
                   (*unitData)->unit));
        result = shr_mdb_destroy((*unitData)->imemRes);
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to destroy unit %d instruction memory"
                       " allocator: %d (%s)\n"),
                       (*unitData)->unit,
                       result,
                       _SHR_ERRMSG(result)));
            goto error;
        }
        (*unitData)->imemRes = NULL;
    } /* if (unitData->imemRes) */
    if ((*unitData)->amemRes) {
        RCE_EVERB((RCE_MSG1("destroy unit %d amem allocator\n"),
                   (*unitData)->unit));
        result = shr_mres_destroy((*unitData)->amemRes);
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to destroy unit %d action memory"
                       " allocator: %d (%s)\n"),
                       (*unitData)->unit,
                       result,
                       _SHR_ERRMSG(result)));
            goto error;
        }
        (*unitData)->amemRes = NULL;
    } /* if (unitData->amemRes) */
    for (group = 0; group < (*unitData)->groupLimit; group++) {
        if ((groupData = (*unitData)->groupData[group] /* assign intentional */)) {
            for (index = 0; index < groupData->qualCount; index++) {
                if (groupData->qualData[index]) {
                    RCE_EVERB((RCE_MSG1("destroy unit %d group %d qual %u\n"),
                               (*unitData)->unit,
                               group,
                               index));
                    sal_free(groupData->qualData[index]);
                    groupData->qualData[index] = NULL;
                }
            }
            RCE_EVERB((RCE_MSG1("destroy unit %d group %u\n"),
                       (*unitData)->unit,
                       group));
            if (groupData->instr) {
                sal_free(groupData->instr);
                groupData->instr = NULL;
            }
            if (groupData->defaultPattern) {
                sal_free(groupData->defaultPattern);
                groupData->defaultPattern = NULL;
            }
            sal_free(groupData);
            (*unitData)->groupData[group] = NULL;
        } /* if ((groupData = unitData->groupData[group])) */
    } /* for (group = 0; group < unitData->groupLimit; group++) */
    for (index = 0; index < (*unitData)->entryLimit; index++) {
        if ((*unitData)->entryData[group]) {
            RCE_EVERB((RCE_MSG1("destroy unit %d entry %u\n"),
                       (*unitData)->unit,
                       index));
            sal_free((*unitData)->entryData[index]);
            (*unitData)->entryData[index] = NULL;
        }
    } /* for (entry = 0; entry < unitData->entryLimit; entry++) */
    /* groupData, entryData arrays are part of the unitData cell */
    for (group = 0; group < SOC_C3_RCE_PROGRAM_COUNT; group++) {
        if ((progData = (*unitData)->progData[group])) {
            if (progData->fsetData) {
                sal_free(progData->fsetData);
                progData->fsetData = NULL;
            }
            /* program descriptor is part of unit cell, don't free directly */
        } /* for (each program this unit) */
    } /* for (group = 0; group < C3_RCE_PROGRAM_COUNT; group++) */
    for (group = 0;
         group < (SOC_C3_RCE_PROGRAM_COUNT *
                  SOC_C3_RCE_RESULT_REGISTER_COUNT);
         group++) {
        if ((actData = (*unitData)->actData[group])) {
            for (index = 0; index < SOC_C3_RCE_PROGRAM_ACTION_MAX; index++) {
                if (actData->actionData[index]) {
                    sal_free(actData->actionData[index]);
                    actData->actionData[index] = NULL;
                } /* if (this action description is in use) */
            } /* for (all possible action descriptions) */
            if (actData->defaultActions) {
                sal_free(actData->defaultActions);
                actData->defaultActions = NULL;
            } /* if (default action value exists) */
        } /* if (this action table is in use) */
    } /* for (all possible action tables) */
    RCE_EVERB((RCE_MSG1("destroy unit %d information\n"),
               (*unitData)->unit));
    sal_free((*unitData));
    (*unitData) = NULL;
error:
    return result;
}

/*
 *  Function
 *    soc_c3_rce_program_info_get
 *  Purpose
 *    Expose information about a given program to the caller, so as to provide
 *    the information necessary to (hopefully) generically accomplish most of
 *    the required objectives of the API.
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) program = program number
 *    (OUT) programInfo = where to put a pointer to the program data
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    This does not provide a pointer to the actual internal tables, which are
 *    considered read-only by the code.  Instead, it copies the data into a new
 *    buffer and returns the pointer to that buffer.  At return, the caller is
 *    considered to own the buffer, and must call soc_c3_rce_program_info_free
 *    to dispose of the buffer (which may actually be comprised of more than
 *    one heap cell or similar).
 *
 *    The caller is expected to keep the program information as long as it will
 *    be needed (either long enough to build its own internal tables or for the
 *    duration of the run if the program data will be consulted directly),
 *    rather than to request and destroy it multiple times during a single run.
 */
static int
_soc_c3_rce_program_info_get(_soc_c3_rce_unit_desc_int_t *unitData,
                             int programId,
                             soc_c3_rce_program_desc_t **programInfo)
{
    soc_c3_rce_program_desc_t *progInfo = NULL;
    _soc_c3_rce_program_desc_int_t *progData;
    _soc_c3_rce_group_desc_int_t *groupData;
    unsigned int index;
    unsigned int offset;
    int result = SOC_E_NONE;

    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META("unit %d program %d info get\n"),
                 unitData->unit,
                 programId));
    progData = unitData->progData[programId];
    progInfo = sal_alloc(sizeof(*progInfo),
                         "C3 program description");
    if (!progInfo) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %u bytes for program data\n"),
                   (unsigned int)sizeof(*progInfo)));
        result = SOC_E_MEMORY;
        goto error;
    }
    sal_memset(progInfo, 0x00, sizeof(*progInfo));
    progInfo->tmuProg = progData->ucData->tmuProg;
    for (index = 0; index < SOC_C3_RCE_RESULT_REGISTER_COUNT; index++) {
        if (progData->actIndex[index] < unitData->actTableCount) {
            progInfo->actionTable[index] = progData->actIndex[index];
            for (offset = 0; offset < index; offset++) {
                if (progInfo->actionTable[index] ==
                    progData->actIndex[offset]) {
                    /* already used this one */
                    break;
                }
            }
            if (offset >= index) {
                /* did not count this one before */
                progInfo->groupMaxCount += unitData->actData[progData->actIndex[index]]->entryLimit;
            }
        } else {
            progInfo->actionTable[index] = ~0;
        }
    }
    progInfo->entryMaxCount = progInfo->groupMaxCount *
                              C3_RCE_ENTRIES_PER_FILTER_SET;
    progInfo->groupsInUse = progData->groupCount;
    for (groupData = progData->groupHead, index = 0;
         groupData;
         groupData = groupData->groupNext, index++) {
        progInfo->entriesInUse += groupData->entryCount;
    }
    if (index != progInfo->groupsInUse) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("internal error: unit %d program %d (%s) expected"
                   " number of groups %u not equal to counted number of"
                   " groups %u\n"),
                   unitData->unit,
                   programId,
                   progData->ucData->programName,
                   progInfo->groupsInUse,
                   index));
        /*
         *  While this error is not specifically fatal to this function, it
         *  really should be reported and this is the only place likely to
         *  actually notice it...
         */
        result = SOC_E_INTERNAL;
        goto error;
    }
    for (index = 0;
         progData->ucData->qualifiers[index].hdr.header !=
         socC3RceDataOffsetCount;
         index++) {
        /* just iterate through, counting how many key fields there are */
    }
    progInfo->keyFieldCount = index;
    progInfo->keyFields = sal_alloc(sizeof(*(progInfo->keyFields)) *
                                    progInfo->keyFieldCount,
                                    "C3 program key fields array");
    if (!(progInfo->keyFields)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %u bytes for key fields array\n"),
                   (unsigned int)(sizeof(*(progInfo->keyFields)) *
                   progInfo->keyFieldCount)));
        result = SOC_E_MEMORY;
        goto error;
    }
    for (index = 0;
         index < progInfo->keyFieldCount;
         index++) {
        progInfo->keyFields[index] = progData->ucData->qualifiers[index];
    }
    *programInfo = progInfo;
error:
    if (SOC_E_NONE != result) {
        if (progInfo) {
            if (progInfo->keyFields) {
                sal_free(progInfo->keyFields);
            }
            sal_free(progInfo);
        } /* if (progData) */
    } /* if (SOC_E_NONE != result) */
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_program_traverse
 *  Purpose
 *    Walk through all of the programs on a unit, calling a caller-provided
 *    function for each program.
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) callback = pointer to function to call
 *    (IN) extra = pointer to caller's additional data
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    If the callback function returns any value other than SOC_E_NONE, it will
 *    abort the traverse.
 */
static int
_soc_c3_rce_program_traverse(_soc_c3_rce_unit_desc_int_t *unitData,
                             soc_c3_rce_program_traverse_cb_t callback,
                             void *extras)
{
    unsigned int index;
    int result = SOC_E_NONE;

    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META("unit %d program traverse\n"),
                 unitData->unit));
    for (index = 0;
         (SOC_E_NONE == result) && (index < SOC_C3_RCE_PROGRAM_COUNT);
         index++) {
        if (unitData->progData[index]) {
            result = callback(unitData->unit, index, extras);
            if (SOC_E_NONE != result) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("callback from unit %d program %u (%s)"
                           " traverse returned %d (%s)\n"),
                           unitData->unit,
                           index,
                           unitData->progData[index]->ucData->programName,
                           result,
                           _SHR_ERRMSG(result)));
            }
        } /* if (unitData->progData[index]) */
    } /* for (all programs on this unit unless error) */
    return result;
}

/*
 *  Function
 *    soc_c3_rce_actiontable_info_get
 *  Purpose
 *    Expose information about a given action table program to the caller, so
 *    as to provide the information necessary to (hopefully) generically
 *    accomplish most of the required objectives of the API.
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) actionTable = action table number
 *    (OUT) actionTableInfo = where to put pointer to the information
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    This does not provide a pointer to the actual internal tables, which are
 *    considered read-only by the code.  Instead, it copies the data into a new
 *    buffer and returns the pointer to that buffer.  At return, the caller is
 *    considered to own the buffer; the soc_c3_rce_actiontable_info_free
 *    function must be called to dispose of the buffer (which may actually be
 *    comprised of more than one heap cell or similar).
 *
 *    The caller is expected to keep the action table information as long as it
 *    will be needed (either long enough to build its own internal tables or
 *    for the duration of the run if the program data will be consulted
 *    directly), rather than to request and destroy it multiple times during a
 *    single run.
 */
static int
_soc_c3_rce_actiontable_info_get(_soc_c3_rce_unit_desc_int_t *unitData,
                                 unsigned int actionTable,
                                 soc_c3_rce_actiontable_desc_t **actionTableInfo)
{
    soc_c3_rce_actiontable_desc_t *actionData = NULL;
    _soc_c3_rce_actions_desc_int_t *actInfo;
    unsigned int index;
    unsigned int nameLen;
    int result = SOC_E_NONE;

    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META("unit %d action table %u info get\n"),
                 unitData->unit,
                 actionTable));
    actInfo = unitData->actData[actionTable];
    index = sizeof(*actionData);
    nameLen = sal_strlen(actInfo->ucData->tableName) + 1;
    index += nameLen;
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
    if (actInfo->ucData->ctrName) {
        index += (sal_strlen(actInfo->ucData->ctrName) + 1);
    }
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
    actionData = sal_alloc(index,
                           "C3 action table description");
    if (!actionData) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %u bytes for action table"
                   " data\n"),
                   index));
        result = SOC_E_MEMORY;
        goto error;
    }
    sal_memset(actionData, 0x00, sizeof(*actionData));
    actionData->tableName = (char*)(&(actionData[1]));
    /* coverity[secure_coding] */
    sal_strcpy(actionData->tableName, actInfo->ucData->tableName);
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
    if (actInfo->ucData->ctrName) {
        actionData->counterName = &(actionData->tableName[nameLen]);
        /* coverity[secure_coding] */
        sal_strcpy(actionData->counterName, actInfo->ucData->ctrName);
    }
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
    actionData->entryBlocks = actInfo->entryLimit;
    actionData->entryBlocksUsed = actInfo->entryActive;
    actionData->actionCount = actInfo->actionCount;
    actionData->actFields = sal_alloc(sizeof(*(actionData->actFields)) *
                                      actionData->actionCount,
                                      "C3 action fields array");
    if (!(actionData->actFields)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to aloocate %u bytes for action fields"
                   " array\n"),
                   (unsigned int)(sizeof(*(actionData->actFields)) *
                   actionData->actionCount)));
        result = SOC_E_MEMORY;
        goto error;
    }
    for (index = 0;
         index < actionData->actionCount;
         index++) {
        actionData->actFields[index] = actInfo->ucData->actions[index];
    }
    *actionTableInfo = actionData;
error:
    if (SOC_E_NONE != result) {
        if (actionData) {
            if (actionData->actFields) {
                sal_free(actionData->actFields);
            }
            sal_free(actionData);
        } /* if (progData) */
    } /* if (SOC_E_NONE != result) */
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_group_info_get
 *  Purpose
 *    Get information about a group.  This retrieves the information about the
 *    group that was specified by the caller when creating the group.
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) groupId = group ID
 *    (OUT) groupInfo = where to put the pointer to the group information
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    This does not provide a pointer to the actual internal tables, which are
 *    considered read-only by the code.  Instead, it copies the data into a new
 *    buffer and returns the pointer to that buffer.  At return, the caller is
 *    considered to own the buffer, and must call soc_c3_rce_group_info_free to
 *    dispose of the buffer (which may actually be comprised of more than one
 *    heap cell or similar).
 *
 *    This is generally intended as a way to recover state under certain
 *    conditions.  The application is expected to keep track of the group
 *    information it needs rather than querying this function regularly.
 */
static int
_soc_c3_rce_group_info_get(_soc_c3_rce_unit_desc_int_t *unitData,
                           int groupId,
                           soc_c3_rce_group_desc_t **groupInfo)
{
    _soc_c3_rce_group_desc_int_t *groupData;
    soc_c3_rce_group_desc_t *groupTemp = NULL;
    unsigned int index;
    unsigned int offset;
    int result = SOC_E_NONE;

    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META("unit %d group %d info get\n"),
                 unitData->unit,
                 groupId));
    groupData = unitData->groupData[groupId];
    groupTemp = sal_alloc(sizeof(*groupTemp),
                          "C3 RCE group information");
    if (!groupTemp) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %u bytes for group info\n"),
                   (unsigned int)sizeof(*groupTemp)));
        result = SOC_E_MEMORY;
        goto error;
    }
    sal_memset(groupTemp, 0x00, sizeof(*groupTemp));
    groupTemp->resultLrp = groupData->resultLrp;
    groupTemp->resultRce = groupData->resultRce;
    groupTemp->groupPriority = groupData->groupPriority;
    groupTemp->rceProgram = groupData->rceProgram;
    groupTemp->qualCount = groupData->qualCount;
    groupTemp->instrCount = groupData->instrBlocks << 3;
    groupTemp->filterSetCount = groupData->filterSetCount;
    groupTemp->rangesPerFilterSet = groupData->rangesPerFilterSet;
    groupTemp->maxFilterSets = groupData->maxFilterSets;
    groupTemp->entriesInUse = groupData->entryCount;
    for (index = 0; index < groupTemp->qualCount; index++) {
        groupTemp->qualData[index] = sal_alloc(sizeof(*(groupTemp->qualData[index])) +
                                               (groupData->qualData[index]->paramCount *
                                                sizeof(int)),
                                               "C3 RCE group qual info");
        if (!(groupTemp->qualData[index])) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to allocate %u bytes for qual info\n"),
                       (unsigned int)(sizeof(*(groupTemp->qualData[index])) +
                       (groupData->qualData[index]->paramCount *
                       sizeof(int)))));
            result = SOC_E_MEMORY;
            goto error;
        }
        sal_memset(groupTemp->qualData[index],
                   0x00,
                   sizeof(*(groupTemp->qualData[index])) +
                   (groupData->qualData[index]->paramCount * sizeof(int)));
        groupTemp->qualData[index]->param = (int*)(&((groupTemp->qualData[index])[1]));
        groupTemp->qualData[index]->qualType = groupData->qualData[index]->qualType;
        groupTemp->qualData[index]->paramCount = groupData->qualData[index]->paramCount;
        groupTemp->qualData[index]->qualName = groupData->qualData[index]->qualName;
        for (offset = 0;
             offset < groupTemp->qualData[index]->paramCount;
             offset++) {
            groupTemp->qualData[index]->param[offset] = groupData->qualData[index]->param[offset];
        } /* for (all parameters used by this qualifier) */
    } /* for (all qualifiers used by this group) */
    *groupInfo = groupTemp;
error:
    if (SOC_E_NONE != result) {
        if (groupTemp) {
            for (index = 0; index < SOC_C3_RCE_GROUP_QUAL_MAX; index++) {
                if (groupTemp->qualData[index]) {
                    sal_free(groupTemp->qualData[index]);
                    groupTemp->qualData[index] = NULL;
                }
            } /* for (all possible qualifier slots) */
            sal_free(groupTemp);
        } /* if (groupTemp) */
    } /* if (SOC_E_NONE != result) */
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_group_traverse
 *  Purpose
 *    Walk through all of the groups in a program on a unit, calling a
 *    caller-provided function for each group.
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) programId = which program to scan
 *    (IN) callback = pointer to function to call
 *    (IN) extra = pointer to caller's additional data
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    If the callback function returns any value other than SOC_E_NONE, it will
 *    abort the traverse.
 */
static int
_soc_c3_rce_group_traverse(_soc_c3_rce_unit_desc_int_t *unitData,
                           int programId,
                           soc_c3_rce_group_traverse_cb_t callback,
                           void *extras)
{
    _soc_c3_rce_program_desc_int_t *progData;
    _soc_c3_rce_group_desc_int_t *groupData;
    _soc_c3_rce_group_desc_int_t *groupNext;
    int result = SOC_E_NONE;

    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META("unit %d program %d (%s) group traverse\n"),
                 unitData->unit,
                 programId,
                 unitData->progData[programId]->ucData->programName));
    progData = unitData->progData[programId];
    for (groupData = progData->groupHead;
         groupData && (SOC_E_NONE == result);
         groupData = groupNext) {
        groupNext = groupData->groupNext;
        result = callback(unitData->unit,
                          programId,
                          groupData->groupId,
                          extras);
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("callback from unit %d program %d (%s) group %d"
                       " traverse returned %d (%s)\n"),
                       unitData->unit,
                       programId,
                       unitData->progData[programId]->ucData->programName,
                       groupData->groupId,
                       result,
                       _SHR_ERRMSG(result)));
        }
    } /* for (all groups in this program unless error) */
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_entry_info_get
 *  Purpose
 *    Get information about an entry.
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) entryId = entry ID
 *    (OUT) entryInfo = where to put the pointer to the entry information
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    This does not provide a pointer to the actual internal tables, which are
 *    considered read-only by the code.  Instead, it copies the data into a new
 *    buffer and returns the pointer to that buffer.  At return, the caller is
 *    considered to own the buffer, and must call soc_c3_rce_entry_info_free to
 *    dispose of the buffer (which may actually be comprised of more than one
 *    heap cell or similar).
 *
 *    This is generally intended as a way to recover state under certain
 *    conditions.  The application is expected to keep track of the entry
 *    information it needs rather than querying this function regularly.
 */
static int
_soc_c3_rce_entry_info_get(_soc_c3_rce_unit_desc_int_t *unitData,
                           int entryId,
                           soc_c3_rce_entry_desc_t **entryInfo)
{
    _soc_c3_rce_entry_desc_int_t *entryData;
    soc_c3_rce_entry_desc_t *entryTemp = NULL;
    int result = SOC_E_NONE;

    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META("unit %d entry %d info get\n"),
                 unitData->unit,
                 entryId));
    entryData = unitData->entryData[entryId];
    entryTemp = sal_alloc(sizeof(*entryTemp),
                          "C3 RCE entry information");
    if (!entryTemp) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %u bytes for entry info\n"),
                   (unsigned int)sizeof(*entryTemp)));
        result = SOC_E_MEMORY;
        return result;
    }
    sal_memset(entryTemp, 0x00, sizeof(*entryTemp));
    entryTemp->groupId = entryData->entryGroup;
    entryTemp->entryPriority = entryData->entryPriority;
    entryTemp->entryFlags = entryData->entryFlags;
    *entryInfo = entryTemp;

    return result;
}

/*
 *  Function
 *    _soc_c3_rce_entry_traverse
 *  Purpose
 *    Walk through all of the entries in a group on a unit, calling a
 *    caller-provided function for each entry.
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) groupId = which group to scan
 *    (IN) callback = pointer to function to call
 *    (IN) extra = pointer to caller's additional data
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    If the callback function returns any value other than SOC_E_NONE, it will
 *    abort the traverse.
 */
static int
_soc_c3_rce_entry_traverse(_soc_c3_rce_unit_desc_int_t *unitData,
                           int groupId,
                           soc_c3_rce_entry_traverse_cb_t callback,
                           void *extras)
{
    _soc_c3_rce_group_desc_int_t *groupData;
    _soc_c3_rce_entry_desc_int_t *entryData;
    _soc_c3_rce_entry_desc_int_t *entryNext;
    int result = SOC_E_NONE;

    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META("unit %d group %d entry traverse\n"),
                 unitData->unit,
                 groupId));
    groupData = unitData->groupData[groupId];
    for (entryData = groupData->entryHead;
         entryData && (SOC_E_NONE == result);
         entryData = entryNext) {
        entryNext = entryData->entryNext;
        result = callback(unitData->unit,
                          groupData->rceProgram,
                          groupId,
                          entryData->entryId,
                          extras);
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("callback from unit %d program %u (%s) group %d"
                       " entry %d returned %d (%s)\n"),
                       unitData->unit,
                       groupData->rceProgram,
                       unitData->progData[groupData->rceProgram]->ucData->programName,
                       groupId,
                       entryData->entryId,
                       result,
                       _SHR_ERRMSG(result)));
        }
    } /* for (all entries in this group unless error) */
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_range_info_get
 *  Purpose
 *    Get information about a range.
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) rangeId = entry ID
 *    (OUT) rangeInfo = where to put the pointer to the range information
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    This does not provide a pointer to the actual internal tables, which are
 *    considered read-only by the code.  Instead, it copies the data into a new
 *    buffer and returns the pointer to that buffer.  At return, the caller is
 *    considered to own the buffer, and must call soc_c3_rce_range_info_free to
 *    dispose of the buffer (which may actually be comprised of more than one
 *    heap cell or similar).
 *
 *    This is generally intended as a way to recover state under certain
 *    conditions.  The application is expected to keep track of the range
 *    information it needs rather than querying this function regularly.
 */
static int
_soc_c3_rce_range_info_get(_soc_c3_rce_unit_desc_int_t *unitData,
                           int rangeId,
                           soc_c3_rce_range_desc_t **rangeInfo)
{
    _soc_c3_rce_range_desc_int_t *rangeData;
    soc_c3_rce_range_desc_t *rangeTemp = NULL;
    int result = SOC_E_NONE;

    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META("unit %d range %d info get\n"),
                 unitData->unit,
                 rangeId));
    /* Range ID is 1 based due to a quirk in the BCM API */
    rangeData = unitData->rangeData[rangeId - 1];
    rangeTemp = sal_alloc(sizeof(*rangeTemp),
                          "C3 RCE range information");
    if (!rangeTemp) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %u bytes for range info\n"),
                   (unsigned int)sizeof(*rangeTemp)));
        result = SOC_E_MEMORY;
        return result;
    }
    sal_memset(rangeTemp, 0x00, sizeof(*rangeTemp));
    rangeTemp->rangeFlags = rangeData->rangeFlags;
    rangeTemp->validProgs = rangeData->validProgs;
    rangeTemp->refCount = rangeData->refCount;
    rangeTemp->lowerBound = rangeData->lowerBound;
    rangeTemp->upperBound = rangeData->upperBound;
    rangeTemp->headerField.header = rangeData->headerField.header;
    rangeTemp->headerField.numBits = rangeData->headerField.numBits;
    rangeTemp->headerField.startBit = rangeData->headerField.startBit;
    /* since caller's copy will be const, can offer the pointer directly */
    rangeTemp->headerField.fieldName = rangeData->headerField.fieldName;
    *rangeInfo = rangeTemp;

    return result;
}

/*
 *  Function
 *    _soc_c3_rce_range_traverse
 *  Purpose
 *    Walk through all of the ranges on a unit, calling a caller-provided
 *    function for each entry.
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) callback = pointer to function to call
 *    (IN) extra = pointer to caller's additional data
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    If the callback function returns any value other than SOC_E_NONE, it will
 *    abort the traverse.
 *
 *    The callback function can use but does now own the entry information
 *    passed to it (that information will be freed when it returns).
 */
static int
_soc_c3_rce_range_traverse(_soc_c3_rce_unit_desc_int_t *unitData,
                           soc_c3_rce_range_traverse_cb_t callback,
                           void *extras)
{
    unsigned int index;
    int result = SOC_E_NONE;

    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META("unit %d range traverse\n"),
                 unitData->unit));
    for (index = 0;
         (SOC_E_NONE == result) && (index < unitData->rangeLimit);
         index++) {
        if (unitData->rangeData[index]) {
            result = callback(unitData->unit,
                              index + 1 /* range ID is 1 based by BCM quirk */,
                              extras);
            if (SOC_E_NONE != result) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("callback from unit %d range %u returned"
                           " %d (%s)\n"),
                           unitData->unit,
                           index + 1,
                           result,
                           _SHR_ERRMSG(result)));
            }
        } /* if (unitData->rangeData[index]) */
    } /* for (all ranges this unit unless error) */
    return result;
}

#if defined(BROADCOM_DEBUG)
/*
 *  Function
 *    _soc_c3_rce_instruction_disasm
 *  Purpose
 *    Disassemble a single RCE instruction
 *  Arguments
 *    (IN) unitData = pointer to unit information
 *    (IN) instruction = instruction to disassemble
 *    (IN) maxLength = bytes in output buffer
 *    (OUT) output = pointer to buffer for output
 *    (OUT) flags = where to put flags
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Output buffer should be at least 40 bytes long.
 */
#define SOC_C3_RCE_INSTR_DISASM_NEXT_M 0x00000FFF
#define SOC_C3_RCE_INSTR_DISASM_STARTP 0x00010000
#define SOC_C3_RCE_INSTR_DISASM_STARTF 0x00020000
#define SOC_C3_RCE_INSTR_DISASM_ENDF   0x00040000
static int
_soc_c3_rce_instruction_disasm(_soc_c3_rce_unit_desc_int_t *unitData,
                               _soc_c3_rce_instruction_t instruction,
                               unsigned int maxLength,
                               char *output,
                               uint32 *flags)
{
    uint32 instrHigh = COMPILER_64_HI(instruction);
    uint32 instrLow = COMPILER_64_LO(instruction);
    _soc_c3_rce_opcode_t opcode = (instrHigh >> 8) & 7;
    _soc_c3_rce_predicate_t pred;
    uint16 next;
    int endfSet = FALSE;

    *flags = 0;
    switch (opcode) {
    case _c3RCEOpcode_nop:
        endfSet = instrHigh & 0x80;
        sal_snprintf(output,
                     maxLength,
                     "%s %s",
                     _soc_c3_rce_opcode_names[opcode],
                     endfSet?"E":" ");
        break;
    case _c3RCEOpcode_prefix:
        sal_snprintf(output,
                     maxLength,
                     "%s",
                     _soc_c3_rce_opcode_names[opcode]);
        break;
    case _c3RCEOpcode_data:
    case _c3RCEOpcode_match0:
    case _c3RCEOpcode_match1:
        endfSet = instrHigh & 0x80;
        pred = (instrHigh >> 5) & 3;
        switch (pred) {
        case _c3RCEPredicate_Range:
            sal_snprintf(output,
                         maxLength,
                         "%s %s %s W=%02X L=%04X H=%04X",
                         _soc_c3_rce_opcode_names[opcode],
                         endfSet?"E":" ",
                         _soc_c3_rce_predicate_names[pred],
                         instrHigh & 0x1F,
                         instrLow & 0xFFFF,
                         (instrLow >> 16) & 0xFFFF);
            break;
        case _c3RCEPredicate_Lookup:
            sal_snprintf(output,
                         maxLength,
                         "%s %s %s W=%02X T=%04X S=%1X,%1X,%1X,%1X",
                         _soc_c3_rce_opcode_names[opcode],
                         endfSet?"E":" ",
                         _soc_c3_rce_predicate_names[pred],
                         instrHigh & 0x1F,
                         instrLow & 0xFFFF,
                         (instrLow >> 16) & 0xF,
                         (instrLow >> 20) & 0xF,
                         (instrLow >> 24) & 0xF,
                         (instrLow >> 28) & 0xF);
            break;
        case _c3RCEPredicate_MaskOr:
        case _c3RCEPredicate_MaskAnd:
            sal_snprintf(output,
                         maxLength,
                         "%s %s %s W=%02X M=%04X D=%04X",
                         _soc_c3_rce_opcode_names[opcode],
                         endfSet?"E":" ",
                         _soc_c3_rce_predicate_names[pred],
                         instrHigh & 0x1F,
                         instrLow & 0xFFFF,
                         (instrLow >> 16) & 0xFFFF);
            break;
        /* coverity[dead_error_begin] */
        default:
            sal_snprintf(output,
                         maxLength,
                         "%s %s ------- W=%02X %08X",
                         _soc_c3_rce_opcode_names[opcode],
                         (instrHigh & 0x80)?"E":" ",
                         instrHigh & 0x1F,
                         instrLow);
        }
        break;
    case _c3RCEOpcode_startFilter:
    case _c3RCEOpcode_startProgram:
        if (_c3RCEOpcode_startProgram == opcode) {
            (*flags) |= SOC_C3_RCE_INSTR_DISASM_STARTP;
        } else {
            (*flags) |= SOC_C3_RCE_INSTR_DISASM_STARTF;
        }
        next = ((instrHigh & 0xFF) << 4) | ((instrLow >> 28) & 0xF);
        (*flags) |= next;
        sal_snprintf(output,
                     maxLength,
                     "%s   B=%05X R=%02X L=%03X",
                     _soc_c3_rce_opcode_names[opcode],
                     instrLow & 0xFFFFF,
                     (instrLow >> 20) & 0xFF,
                     next);
        break;
    default:
        sal_snprintf(output,
                     maxLength,
                     "%s   %08X%08X",
                     _soc_c3_rce_opcode_names[opcode],
                     instrHigh,
                     instrLow);
    }
    if (endfSet) {
        (*flags) |= SOC_C3_RCE_INSTR_DISASM_ENDF;
    }
    return SOC_E_NONE;
}

/*
 *  Function
 *    _soc_c3_rce_program_disasm
 *  Purpose
 *    Disassemble an entire RCE program, displaying output
 *  Arguments
 *    (IN) unitData = pointer to unit information
 *    (IN) programId = which program to disassemble
 *    (IN) prefix = string to prefix to disassembly output
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Uses bsl_printf to display each line of the disassembly.
 */
#define SOC_C3_RCE_PROG_DISASM_MISSING_START     0x00000001
#define SOC_C3_RCE_PROG_DISASM_STARTF_FOR_STARTP 0x00000002
#define SOC_C3_RCE_PROG_DISASM_STARTP_FOR_STARTF 0x00000004
#define SOC_C3_RCE_PROG_DISASM_FALSE_START       0x00000008
#define SOC_C3_RCE_PROG_DISASM_EARLY_ENDF        0x00000010
static int
_soc_c3_rce_program_disasm(_soc_c3_rce_unit_desc_int_t *unitData,
                           int programId,
                           const char *prefix)
{
    _soc_c3_rce_instruction_t instruction;
    uint32 *imemTemp = NULL;
    uint32 regVal;
    uint16 next = ~0;
    unsigned int allocSize;
    unsigned int index;
    unsigned int offset;
    unsigned int progCount;
    unsigned int filterCount;
    char disasmBuffer[80];
    int result = SOC_E_NONE;
    int firstSet;
    int firstInstr;
    int finalBlock;
    uint32 flags;
    uint32 status;
    uint32 tempStatus;

    allocSize = sizeof(uint32) * soc_mem_entry_words(unitData->unit, IMEMm);
    imemTemp = soc_cm_salloc(unitData->unit,
                             allocSize,
                             "C3 RCE instruction update buffer");
    if (!imemTemp) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %u bytes for imem buffer\n"),
                   allocSize));
        result = SOC_E_MEMORY;
        goto error;
    }
    result = soc_reg32_get(unitData->unit,
                           RC_INSTCTRL_PROGRAM_CONFIGr,
                           REG_PORT_ANY,
                           programId,
                           &regVal);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to read unit %d program %d (%s) control"
                   " register: %d (%s)\n"),
                   unitData->unit,
                   programId,
                   unitData->progData[programId]->ucData->programName,
                   result,
                   _SHR_ERRMSG(result)));
        goto error;
    }
    if (soc_reg_field_get(unitData->unit,
                          RC_INSTCTRL_PROGRAM_CONFIGr,
                          regVal,
                          ENf)) {
        index = soc_reg_field_get(unitData->unit,
                                  RC_INSTCTRL_PROGRAM_CONFIGr,
                                  regVal,
                                  BASE_ADDRf);
        if (index < C3_RCE_IMEM_SIZE) {
            firstSet = TRUE;
            status = 0;
            progCount = 0;
            filterCount = 0;
            firstInstr = TRUE;
            LOG_CLI((BSL_META("%s%s\n"), prefix, _soc_c3_rce_disasm_bar));
            do {
                finalBlock = FALSE;
                result = soc_cm_sinval(unitData->unit, imemTemp, allocSize);
                if (SOC_E_NONE != result) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META("unable to invalidate cache for"
                               " instruction memory: %d (%s)\n"),
                               result,
                               _SHR_ERRMSG(result)));
                    goto error;
                }
                result = soc_mem_read(unitData->unit,
                                      IMEMm,
                                      MEM_BLOCK_ANY,
                                      index,
                                      imemTemp);
                if (SOC_E_NONE != result) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META("unable to read unit %d imem block %u:"
                               " %d (%s)\n"),
                               unitData->unit,
                               index,
                               result,
                               _SHR_ERRMSG(result)));
                    goto error;
                }
                for (offset = 0; offset < 8; offset++) {
                    tempStatus = 0;
                    soc_mem_field64_get(unitData->unit,
                                        IMEMm,
                                        imemTemp,
                                        _soc_c3_imem_fields[offset],
                                        &instruction);
                    result = _soc_c3_rce_instruction_disasm(unitData,
                                                            instruction,
                                                            sizeof(disasmBuffer) - 1,
                                                            disasmBuffer,
                                                            &flags);
                    if (SOC_E_NONE != result) {
                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                  (BSL_META("unable to disassemble instruction"
                                   " %u of unit %d imem block %u:"
                                   " %d (%s)\n"),
                                   offset,
                                   unitData->unit,
                                   index,
                                   result,
                                   _SHR_ERRMSG(result)));
                        goto error;
                    }
                    if (firstInstr) {
                        if (firstSet) {
                            if (flags & SOC_C3_RCE_INSTR_DISASM_STARTF) {
                                tempStatus |= SOC_C3_RCE_PROG_DISASM_STARTF_FOR_STARTP;
                            }
                        } else {
                            if (flags & SOC_C3_RCE_INSTR_DISASM_STARTP) {
                                tempStatus |= SOC_C3_RCE_PROG_DISASM_STARTP_FOR_STARTF;
                            }
                        }
                        if (flags & (SOC_C3_RCE_INSTR_DISASM_STARTF |
                                     SOC_C3_RCE_INSTR_DISASM_STARTP)) {
                            next = (flags & SOC_C3_RCE_INSTR_DISASM_NEXT_M);
                        } else {
                            tempStatus |= SOC_C3_RCE_PROG_DISASM_MISSING_START;
                        }
                    } else { /* if (firstInstr) */
                        if (flags & (SOC_C3_RCE_INSTR_DISASM_STARTF |
                                     SOC_C3_RCE_INSTR_DISASM_STARTP)) {
                            tempStatus |= SOC_C3_RCE_PROG_DISASM_FALSE_START;
                        }
                    } /* if (firstInstr) */
                    if (flags & SOC_C3_RCE_INSTR_DISASM_ENDF) {
                        finalBlock = TRUE;
                        if (firstSet) {
                            if (filterCount <
                                (C3_RCE_FILTER_SET_LENGTH_FIRST - 1)) {
                                tempStatus |= SOC_C3_RCE_PROG_DISASM_EARLY_ENDF;
                            }
                        } else {
                            if (filterCount <
                                (C3_RCE_FILTER_SET_LENGTH_LATER - 1)) {
                                tempStatus |= SOC_C3_RCE_PROG_DISASM_EARLY_ENDF;
                            }
                        }
                    } /* if (flags & SOC_C3_RCE_INSTR_DISASM_ENDF) */
                    if (tempStatus) {
                        LOG_CLI((BSL_META("%s%03X.%01X %-40s %s %s %s %s %s\n"),
                                 prefix,
                                 index,
                                 offset,
                                 disasmBuffer,
                                 (tempStatus & SOC_C3_RCE_PROG_DISASM_MISSING_START)?"MS":"  ",
                                 (tempStatus & SOC_C3_RCE_PROG_DISASM_STARTF_FOR_STARTP)?"FP":"  ",
                                 (tempStatus & SOC_C3_RCE_PROG_DISASM_STARTP_FOR_STARTF)?"PF":"  ",
                                 (tempStatus & SOC_C3_RCE_PROG_DISASM_FALSE_START)?"FS":"  ",
                                 (tempStatus & SOC_C3_RCE_PROG_DISASM_EARLY_ENDF)?"EE":"  "));
                    } else {
                        LOG_CLI((BSL_META("%s%03X.%01X %s\n"),
                                 prefix,
                                 index,
                                 offset,
                                 disasmBuffer));
                    }
                    firstInstr = FALSE;
                    status |= tempStatus;
                } /* for (offset = 0; offset < 8; offset++) */
                progCount++;
                filterCount++;
                if (finalBlock) {
                    index = next;
                    next = ~0;
                    filterCount = 0;
                    firstInstr = TRUE;
                    firstSet = FALSE;
                    LOG_CLI((BSL_META("%s%s\n"), prefix, _soc_c3_rce_disasm_bar));
                } else {
                    index++;
                }
            } while ((index < C3_RCE_IMEM_SIZE) && (progCount < C3_RCE_IMEM_SIZE));
            if (progCount < C3_RCE_FILTER_SET_PADDING) {
                LOG_CLI((BSL_META("%s(program is too short: %u but must be %u)\n"),
                         prefix,
                         progCount,
                         C3_RCE_FILTER_SET_PADDING));
            }
            if (progCount > C3_RCE_IMEM_SIZE) {
                LOG_CLI((BSL_META("%s(program is too long: aborted after %u)\n"),
                         prefix,
                         progCount));
            }
            if (status & SOC_C3_RCE_PROG_DISASM_MISSING_START) {
                LOG_CLI((BSL_META("%s(encountered missing start instruction)\n"),
                         prefix));
            }
            if (status & SOC_C3_RCE_PROG_DISASM_STARTF_FOR_STARTP) {
                LOG_CLI((BSL_META("%s(encountered startFi where startPr was needed)\n"),
                         prefix));
            }
            if (status & SOC_C3_RCE_PROG_DISASM_STARTP_FOR_STARTF) {
                LOG_CLI((BSL_META("%s(encountered startPr where StartFi was needed)\n"),
                         prefix));
            }
            if (status & SOC_C3_RCE_PROG_DISASM_EARLY_ENDF) {
                LOG_CLI((BSL_META("%s(encountered early EndF indication)\n"),
                         prefix));
            }
        } else { /* if (index < C3_RCE_IMEM_SIZE) */
            LOG_CLI((BSL_META("%s(program start address invalid)\n"), prefix));
        } /* if (index < C3_RCE_IMEM_SIZE) */
    } else { /* if (program is enabled) */
        LOG_CLI((BSL_META("%s(program is disabled)\n"), prefix));
    } /* if (program is enabled) */
error:
    if (imemTemp) {
        soc_cm_sfree(unitData->unit, imemTemp);
    }
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_entry_dump_range
 *  Purpose
 *    Dump a range while dumping an entry
 *  Arguments
 *    (IN) unit = unit number
 *    (IN) programId = program number
 *    (IN) groupId = group number
 *    (IN) entryId = entry number
 *    (IN) rangeId = range number
 *    (IN) matching = + or - to indiciate whether match is normal or inverse
 *    (IN) extras = pointer to dump params cast as void*
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Meant only to be called by range iterator from entry dump, below.
 */
static int
_soc_c3_rce_entry_dump_range(int unit,
                             int programId,
                             int groupId,
                             int entryId,
                             int rangeId,
                             signed int matching,
                             void *extras)
{
    _soc_c3_rce_unit_dump_params_t *params = (_soc_c3_rce_unit_dump_params_t*)extras;
    _soc_c3_rce_range_desc_int_t *rangeData;

    params->count++;
    rangeData = params->unitData->rangeData[rangeId - 1];
    if (rangeData->headerField.fieldName[0]) {
        LOG_CLI((BSL_META_U(unit,
                            "%s  range %d %s: '%s' (%s %d,%d) %04X..%04X %s\n"),
                 params->prefix,
                 rangeId,
                 (0<matching)?"normal":"invert",
                 rangeData->headerField.fieldName,
                 _soc_c3_rce_data_header_names[rangeData->headerField.header],
                 rangeData->headerField.startBit,
                 rangeData->headerField.numBits,
                 rangeData->lowerBound,
                 rangeData->upperBound,
                 (rangeData->rangeFlags & SOC_C3_RCE_RANGE_FLAG_INVERT)?
                 "invert":"normal"));
    } else {
        LOG_CLI((BSL_META_U(unit,
                            "%s  range %d %s: (%s %d,%d) %04X..%04X %s\n"),
                 params->prefix,
                 rangeId,
                 (0<matching)?"normal":"invert",
                 _soc_c3_rce_data_header_names[rangeData->headerField.header],
                 rangeData->headerField.startBit,
                 rangeData->headerField.numBits,
                 rangeData->lowerBound,
                 rangeData->upperBound,
                 (rangeData->rangeFlags & SOC_C3_RCE_RANGE_FLAG_INVERT)?
                 "invert":"normal"));
    }
    return SOC_E_NONE;
}

/*
 *  Function
 *    _soc_c3_rce_entry_dump
 *  Purpose
 *    Dump information about an entry
 *  Arguments
 *    (IN) unitData = pointer to unit information
 *    (IN) flags = flags for the dump
 *    (IN) prefix = prefix string
 *    (IN) entryId = which entry to dump
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Uses bsl_printf to display the information being dumped.
 */
static int
_soc_c3_rce_entry_dump(_soc_c3_rce_unit_desc_int_t *unitData,
                       const uint32 flags,
                       const char *prefix,
                       const int entryId)
{
    _soc_c3_rce_entry_desc_int_t *entryData = unitData->entryData[entryId];
    _soc_c3_rce_group_desc_int_t *groupData = unitData->groupData[entryData->entryGroup];
    _soc_c3_rce_program_desc_int_t *progData = unitData->progData[groupData->rceProgram];
    _soc_c3_rce_actions_desc_int_t *actData;
    _soc_c3_rce_unit_dump_params_t params;
    char *newPrefix = NULL;
    char *extPrefix = NULL;
    uint8 *dataPtr = NULL;
    uint8 *maskPtr = NULL;
    unsigned int index;
    unsigned int offset;
    unsigned int bits;
    unsigned int resIndex;
    int result = SOC_E_NONE;

    extPrefix = sal_alloc(sal_strlen(prefix) + 6, "C3 RCE entry dump prefix");
    if (!extPrefix) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %u bytes for prefix work\n"),
                   (unsigned int)(sal_strlen(prefix) + 6)));
        result = SOC_E_MEMORY;
        goto error;
    }
    sal_snprintf(extPrefix,
                 sal_strlen(prefix) + 5,
                 "%s    ",
                 prefix);
    newPrefix = sal_alloc(sal_strlen(prefix) + 4, "C3 RCE entry dump prefix");
    if (!newPrefix) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %u bytes for prefix work\n"),
                   (unsigned int)(sal_strlen(prefix) + 4)));
        result = SOC_E_MEMORY;
        goto error;
    }
    if ((flags & SOC_C3_RCE_DUMP_ENTRY_INCLUDE_A_QUALS) ||
        (flags & SOC_C3_RCE_DUMP_ENTRY_INCLUDE_H_QUALS) ||
        (flags & SOC_C3_RCE_DUMP_ENTRY_INCLUDE_A_ACTS) ||
        (flags & SOC_C3_RCE_DUMP_ENTRY_INCLUDE_H_ACTS)) {
        bits = groupData->instrBlocks * 2;
        for (resIndex = 0;
             resIndex < SOC_C3_RCE_RESULT_REGISTER_COUNT;
             resIndex++) {
            if ((groupData->resultLrp & (1 << resIndex)) &&
                (bits <
                 unitData->actData[progData->actIndex[resIndex]]->actionBytes)) {
                bits = unitData->actData[progData->actIndex[resIndex]]->actionBytes;
            } /* if (result is in use and would be bigger) */
        } /* for (all possible result registers) */
        dataPtr = sal_alloc(groupData->instrBlocks * 2, "data/mask workspace");
        if (!dataPtr) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to allocate %u bytes for data/mask\n"),
                       groupData->instrBlocks * 2));
            result = SOC_E_MEMORY;
            goto error;
        }
        maskPtr = &(dataPtr[groupData->instrBlocks]);
    }
    sal_snprintf(newPrefix,
                 sal_strlen(prefix) + 3,
                 "%s  ",
                 prefix);
    LOG_CLI((BSL_META("%sEntry %5d\n"), prefix, entryId));
    if (entryId != entryData->entryId) {
        LOG_CLI((BSL_META("%s(expected entry ID %5d but got %5d)\n"),
                 newPrefix,
                 entryId,
                 entryData->entryId));
        result = SOC_E_INTERNAL;
        goto error;
    }
    LOG_CLI((BSL_META("%sFlags          =         %08X\n"),
             newPrefix,
             entryData->entryFlags));
    LOG_CLI((BSL_META("%sGroup          = %16d\n"),
             newPrefix,
             entryData->entryGroup));
    LOG_CLI((BSL_META("%sEntry priority = %16d\n"),
             newPrefix,
             entryData->entryPriority));
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
    LOG_CLI((BSL_META("%sEntry position = %16u (prev %12u)\n"),
             newPrefix,
             entryData->entryPosition,
             entryData->entryPosPrev));
    if (groupData->groupFlags & _SOC_C3_RCE_GROUP_FLAG_COUNTER) {
        LOG_CLI((BSL_META("%sBasis bytes    = %08X%08X\n"),
                 newPrefix,
                 COMPILER_64_HI(entryData->basisCounts[0]),
                 COMPILER_64_LO(entryData->basisCounts[0])));
        LOG_CLI((BSL_META("%sBasis frames   = %08X%08X\n"),
                 newPrefix,
                 COMPILER_64_HI(entryData->basisCounts[1]),
                 COMPILER_64_LO(entryData->basisCounts[1])));
    }
#else /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
    LOG_CLI((BSL_META("%sEntry position = %16d\n"),
             newPrefix,
             entryData->entryPosition));
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
    if (flags & SOC_C3_RCE_DUMP_ENTRY_INCLUDE_RANGES) {
        params.prefix = newPrefix;
        params.count = 0;
        params.flags = flags;
        params.unitData = unitData;
        LOG_CLI((BSL_META("%sEntry API ranges:\n"), newPrefix));
        result = _soc_c3_rce_entry_qualify_range_traverse(unitData,
                                                          entryId,
                                                          &_soc_c3_rce_entry_dump_range,
                                                          (void*)(&params));
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unit %d failed traversing ranges for entry"
                       " %d: %d (%s)\n"),
                       unitData->unit,
                       entryId,
                       result,
                       _SHR_ERRMSG(result)));
            goto error;
        }
        if (0 == params.count) {
            LOG_CLI((BSL_META("%s  (none)\n"), newPrefix));
        }
    } /* if (flags & SOC_C3_RCE_DUMP_ENTRY_INCLUDE_RANGES) */
    if (flags & SOC_C3_RCE_DUMP_ENTRY_INCLUDE_A_PATT) {
        LOG_CLI((BSL_META("%sEntry API pattern (program %u, %s):\n"),
                 newPrefix,
                 groupData->rceProgram,
                 progData->ucData->programName));
        for (index = 0; index < groupData->instrBlocks; index++) {
            if (0 == index) {
                LOG_CLI((BSL_META("%s"), extPrefix));
            } else if (0 == (index & 15)) {
                LOG_CLI((BSL_META("\n%s"), extPrefix));
            } else {
                LOG_CLI((BSL_META(" ")));
            }
            LOG_CLI((BSL_META("%02X"), entryData->pattData[0][index]));
        } /* for (index = 0; index < groupData->instrBlocks; index++) */
        if (index) {
            LOG_CLI((BSL_META("\n")));
        }
    } /* if (flags & SOC_C3_RCE_DUMP_ENTRY_INCLUDE_A_RQUALS) */
    if (flags & SOC_C3_RCE_DUMP_ENTRY_INCLUDE_H_PATT) {
        LOG_CLI((BSL_META("%sEntry HW pattern (program %u, %s):\n"),
                 newPrefix,
                 groupData->rceProgram,
                 progData->ucData->programName));
        for (index = 0; index < groupData->instrBlocks; index++) {
            if (0 == index) {
                LOG_CLI((BSL_META("%s"), extPrefix));
            } else if (0 == (index & 15)) {
                LOG_CLI((BSL_META("\n%s"), extPrefix));
            } else {
                LOG_CLI((BSL_META(" ")));
            }
            LOG_CLI((BSL_META("%02X"), entryData->pattData[1][index]));
        } /* for (index = 0; index < groupData->instrBlocks; index++) */
        if (index) {
            LOG_CLI((BSL_META("\n")));
        }
    } /* if (flags & SOC_C3_RCE_DUMP_ENTRY_INCLUDE_H_RQUALS) */
    if (flags & SOC_C3_RCE_DUMP_ENTRY_INCLUDE_A_ACTION) {
        LOG_CLI((BSL_META("%sEntry API action:\n"), newPrefix));
        for (resIndex = 0;
             resIndex < SOC_C3_RCE_RESULT_REGISTER_COUNT;
             resIndex++) {
            if (groupData->resultLrp & (1 << resIndex)) {
                LOG_CLI((BSL_META("%sresult register %u, action table %u (%s):\n"),
                         extPrefix,
                         resIndex,
                         progData->actIndex[resIndex],
                         unitData->actData[progData->actIndex[resIndex]]->ucData->tableName));
                for (index = 0;
                     index <
                     unitData->actData[progData->actIndex[resIndex]]->actionBytes;
                     index++) {
                    if (0 == index) {
                        LOG_CLI((BSL_META("%s  "), extPrefix));
                    } else if (0 == (index & 15)) {
                        LOG_CLI((BSL_META("\n%s  "), extPrefix));
                    } else {
                        LOG_CLI((BSL_META(" ")));
                    }
                    LOG_CLI((BSL_META("%02X"),
                             entryData->actData[0][resIndex][index]));
                } /* for (index = 0; index < groupData->instrBlocks; index++) */
                LOG_CLI((BSL_META("\n")));
            } /* if (this entry's group uses this result register) */
        } /* for (all possible result registers) */
    } /* if (flags & SOC_C3_RCE_DUMP_ENTRY_INCLUDE_A_ACTION) */
    if (flags & SOC_C3_RCE_DUMP_ENTRY_INCLUDE_H_ACTION) {
        LOG_CLI((BSL_META("%sEntry hardware action:\n"), newPrefix));
        for (resIndex = 0;
             resIndex < SOC_C3_RCE_RESULT_REGISTER_COUNT;
             resIndex++) {
            if (groupData->resultLrp & (1 << resIndex)) {
                LOG_CLI((BSL_META("%sresult register %u, action table %u (%s):\n"),
                         extPrefix,
                         resIndex,
                         progData->actIndex[resIndex],
                         unitData->actData[progData->actIndex[resIndex]]->ucData->tableName));
                for (index = 0;
                     index <
                     unitData->actData[progData->actIndex[resIndex]]->actionBytes;
                     index++) {
                    if (0 == index) {
                        LOG_CLI((BSL_META("%s  "), extPrefix));
                    } else if (0 == (index & 15)) {
                        LOG_CLI((BSL_META("\n%s  "), extPrefix));
                    } else {
                        LOG_CLI((BSL_META(" ")));
                    }
                    LOG_CLI((BSL_META("%02X"),
                             entryData->actData[1][resIndex][index]));
                } /* for (index = 0; index < groupData->instrBlocks; index++) */
                LOG_CLI((BSL_META("\n")));
            } /* if (this entry's group uses this result register) */
        } /* for (all possible result registers) */
    } /* if (flags & SOC_C3_RCE_DUMP_ENTRY_INCLUDE_H_ACTION) */
    if (flags & SOC_C3_RCE_DUMP_ENTRY_INCLUDE_A_QUALS) {
        LOG_CLI((BSL_META("%sEntry API qualifiers:\n"), newPrefix));
        for (index = 0; index < groupData->qualCount; index++) {
            result = _soc_c3_rce_entry_qualify_general_length(groupData->qualData[index],
                                                              &bits);
            if (SOC_E_NONE != result) {
                goto error;
            }
            result = _soc_c3_rce_entry_qualify_general_get(groupData->qualData[index],
                                                           groupData->qualOffs[index],
                                                           entryData->pattData[0],
                                                           dataPtr,
                                                           maskPtr);
            if (SOC_E_NONE != result) {
                goto error;
            }
            if (groupData->qualData[index]->qualName[0]) {
                LOG_CLI((BSL_META("%squal %u, %s: %s(%u)\n"),
                         extPrefix,
                         index,
                         groupData->qualData[index]->qualName,
                         _soc_c3_rce_qual_type_names[groupData->qualData[index]->qualType],
                         groupData->qualData[index]->qualType));
            } else {
                LOG_CLI((BSL_META("%squal %u: %s(%u)\n"),
                         extPrefix,
                         index,
                         _soc_c3_rce_qual_type_names[groupData->qualData[index]->qualType],
                         groupData->qualData[index]->qualType));
            }
            LOG_CLI((BSL_META("%s  data = "), extPrefix));
            bits = (bits + 7) >> 3; /* maybe call it bytes now? */
            offset = bits;
            while (offset > 0) {
                offset--;
                LOG_CLI((BSL_META("%02X"), dataPtr[offset]));
            }
            LOG_CLI((BSL_META("\n%s  mask = "), extPrefix));
            offset = bits;
            while (offset > 0) {
                offset--;
                LOG_CLI((BSL_META("%02X"), maskPtr[offset]));
            }
            LOG_CLI((BSL_META("\n")));
        } /* for (index = 0; index < groupData->qualCount; index++) */
    } /* if (flags & SOC_C3_RCE_DUMP_ENTRY_INCLUDE_A_QUALS) */
    if (flags & SOC_C3_RCE_DUMP_ENTRY_INCLUDE_H_QUALS) {
        LOG_CLI((BSL_META("%sEntry hardware qualifiers:\n"), newPrefix));
        for (index = 0; index < groupData->qualCount; index++) {
            result = _soc_c3_rce_entry_qualify_general_get(groupData->qualData[index],
                                                           groupData->qualOffs[index],
                                                           entryData->pattData[1],
                                                           dataPtr,
                                                           maskPtr);
            if (SOC_E_NONE != result) {
                goto error;
            }
            result = _soc_c3_rce_entry_qualify_general_length(groupData->qualData[index],
                                                              &bits);
            if (SOC_E_NONE != result) {
                goto error;
            }
            if (groupData->qualData[index]->qualName[0]) {
                LOG_CLI((BSL_META("%squal %u, %s: %s(%u)\n"),
                         extPrefix,
                         index,
                         groupData->qualData[index]->qualName,
                         _soc_c3_rce_qual_type_names[groupData->qualData[index]->qualType],
                         groupData->qualData[index]->qualType));
            } else {
                LOG_CLI((BSL_META("%squal %u: %s(%u)\n"),
                         extPrefix,
                         index,
                         _soc_c3_rce_qual_type_names[groupData->qualData[index]->qualType],
                         groupData->qualData[index]->qualType));
            }
            LOG_CLI((BSL_META("%s  data = "), extPrefix));
            bits = (bits + 7) >> 3; /* maybe call it bytes now? */
            offset = bits;
            while (offset > 0) {
                offset--;
                LOG_CLI((BSL_META("%02X"), dataPtr[offset]));
            }
            LOG_CLI((BSL_META("\n%s  mask = "), extPrefix));
            offset = bits;
            while (offset > 0) {
                offset--;
                LOG_CLI((BSL_META("%02X"), maskPtr[offset]));
            }
            LOG_CLI((BSL_META("\n")));
        } /* for (index = 0; index < groupData->qualCount; index++) */
    } /* if (flags & SOC_C3_RCE_DUMP_ENTRY_INCLUDE_H_QUALS) */
    if (flags & SOC_C3_RCE_DUMP_ENTRY_INCLUDE_A_ACTS) {
        LOG_CLI((BSL_META("%sEntry API actions:\n"), newPrefix));
        for (resIndex = 0;
             resIndex < SOC_C3_RCE_RESULT_REGISTER_COUNT;
             resIndex++) {
            if (groupData->resultLrp & (1 << resIndex)) {
                actData = unitData->actData[progData->actIndex[resIndex]];
                LOG_CLI((BSL_META("%sresult %u, table %s\n"),
                         extPrefix,
                         resIndex,
                         actData->ucData->tableName));
                for (index = 0; index < actData->actionCount; index++) {
                    result = _soc_c3_rce_program_action_general_length(actData->actionData[index],
                                                                       &bits);
                    if (SOC_E_NONE != result) {
                        goto error;
                    }
                    result = _soc_c3_rce_program_action_general_get(actData->actionData[index],
                                                                    entryData->actData[0][resIndex],
                                                                    dataPtr);
                    if (SOC_E_NONE != result) {
                        goto error;
                    }
                    if (actData->ucData->actions[index].actionName) {
                        LOG_CLI((BSL_META("%s  action %u, %s: %s(%u)\n"),
                                 extPrefix,
                                 index,
                                 actData->ucData->actions[index].actionName,
                                 _soc_c3_rce_action_uc_type_names[actData->ucData->actions[index].action],
                                 actData->ucData->actions[index].action));
                    } else {
                        LOG_CLI((BSL_META("%s  action %u: %s(%u)\n"),
                                 extPrefix,
                                 index,
                                 _soc_c3_rce_action_uc_type_names[actData->ucData->actions[index].action],
                                 actData->ucData->actions[index].action));
                    }
                    LOG_CLI((BSL_META("%s    data = "), extPrefix));
                    bits = (bits + 7) >> 3; /* maybe call it bytes now? */
                    offset = bits;
                    while (offset > 0) {
                        offset--;
                        LOG_CLI((BSL_META("%02X"), dataPtr[offset]));
                    }
                    LOG_CLI((BSL_META("\n")));
                } /* for (all actions in this action table) */
            } /* if (the group is using this result) */
        } /* for (all possible result registers) */
    } /* if (flags & SOC_C3_RCE_DUMP_ENTRY_INCLUDE_A_ACTS) */
    if (flags & SOC_C3_RCE_DUMP_ENTRY_INCLUDE_H_ACTS) {
        LOG_CLI((BSL_META("%sEntry hardware actions:\n"), newPrefix));
        for (resIndex = 0;
             resIndex < SOC_C3_RCE_RESULT_REGISTER_COUNT;
             resIndex++) {
            if (groupData->resultLrp & (1 << resIndex)) {
                actData = unitData->actData[progData->actIndex[resIndex]];
                LOG_CLI((BSL_META("%sresult %u, table %s\n"),
                         extPrefix,
                         resIndex,
                         actData->ucData->tableName));
                for (index = 0; index < actData->actionCount; index++) {
                    result = _soc_c3_rce_program_action_general_length(actData->actionData[index],
                                                                       &bits);
                    if (SOC_E_NONE != result) {
                        goto error;
                    }
                    result = _soc_c3_rce_program_action_general_get(actData->actionData[index],
                                                                    entryData->actData[1][resIndex],
                                                                    dataPtr);
                    if (SOC_E_NONE != result) {
                        goto error;
                    }
                    if (actData->ucData->actions[index].actionName) {
                        LOG_CLI((BSL_META("%s  action %u, %s: %s(%u)\n"),
                                 extPrefix,
                                 index,
                                 actData->ucData->actions[index].actionName,
                                 _soc_c3_rce_action_uc_type_names[actData->ucData->actions[index].action],
                                 actData->ucData->actions[index].action));
                    } else {
                        LOG_CLI((BSL_META("%s  action %u: %s(%u)\n"),
                                 extPrefix,
                                 index,
                                 _soc_c3_rce_action_uc_type_names[actData->ucData->actions[index].action],
                                 actData->ucData->actions[index].action));
                    }
                    LOG_CLI((BSL_META("%s    data = "), extPrefix));
                    bits = (bits + 7) >> 3; /* maybe call it bytes now? */
                    offset = bits;
                    while (offset > 0) {
                        offset--;
                        LOG_CLI((BSL_META("%02X"), dataPtr[offset]));
                    }
                    LOG_CLI((BSL_META("\n")));
                } /* for (all actions in this action table) */
            } /* if (the group is using this result) */
        } /* for (all possible result registers) */
    } /* if (flags & SOC_C3_RCE_DUMP_ENTRY_INCLUDE_H_ACTS) */
error:
    if (newPrefix) {
        sal_free(newPrefix);
    }
    if (extPrefix) {
        sal_free(extPrefix);
    }
    if (dataPtr) {
        sal_free(dataPtr);
    }
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_group_dump_entry
 *  Purpose
 *    Transition to entry dump from group dump entry iterator
 *  Arguments
 *    (IN) unit = unit number
 *    (IN) programId = program number
 *    (IN) groupId = group number
 *    (IN) entryId = entry number
 *    (IN) extras = pointer to dump params cast as void*
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Meant only to be called by group iterator from program dump, below.
 */
static int
_soc_c3_rce_group_dump_entry(int unit,
                             int programId,
                             int groupId,
                             int entryId,
                             void *extras)
{
    _soc_c3_rce_unit_dump_params_t *params = (_soc_c3_rce_unit_dump_params_t*)extras;
    params->count++;
    if (groupId != params->unitData->entryData[entryId]->entryGroup) {
        LOG_CLI((BSL_META_U(unit,
                            "%s(expected membership in group %2d but claims %2d)\n"),
                 params->prefix,
                 groupId,
                 params->unitData->entryData[entryId]->entryGroup));
    }
    return _soc_c3_rce_entry_dump(params->unitData,
                                  params->flags,
                                  params->prefix,
                                  entryId);
}

/*
 *  Function
 *    _soc_c3_rce_group_dump_entry_id
 *  Purpose
 *    Display an entry's ID and handle other accounting
 *  Arguments
 *    (IN) unit = unit number
 *    (IN) programId = program number
 *    (IN) groupId = group number
 *    (IN) entryId = entry number
 *    (IN) extras = pointer to dump params cast as void*
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Meant only to be called by group iterator from program dump, below.
 */
static int
_soc_c3_rce_group_dump_entry_id(int unit,
                                int programId,
                                int groupId,
                                int entryId,
                                void *extras)
{
    _soc_c3_rce_unit_dump_params_t *params = (_soc_c3_rce_unit_dump_params_t*)extras;
    params->count++;
    if (groupId != params->unitData->entryData[entryId]->entryGroup) {
        LOG_CLI((BSL_META_U(unit,
                            "%s(expected membership in group %2d but claims %2d)\n"),
                 params->prefix,
                 groupId,
                 params->unitData->entryData[entryId]->entryGroup));
    }
    LOG_CLI((BSL_META_U(unit,
                        "%sEntry %5d, position %5u\n"),
             params->prefix,
             entryId,
             params->unitData->entryData[entryId]->entryPosition));
    return SOC_E_NONE;
}

/*
 *  Function
 *    _soc_c3_rce_group_dump
 *  Purpose
 *    Dump information about a group
 *  Arguments
 *    (IN) unitData = pointer to unit information
 *    (IN) flags = flags for the dump
 *    (IN) prefix = prefix string
 *    (IN) groupId = which group to dump
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Uses bsl_printf to display the information being dumped.
 */
static int
_soc_c3_rce_group_dump(_soc_c3_rce_unit_desc_int_t *unitData,
                       uint32 flags,
                       const char *prefix,
                       int groupId)
{
    _soc_c3_rce_unit_dump_params_t params;
    char disasmBuffer[80];
    _soc_c3_rce_group_desc_int_t *groupData = unitData->groupData[groupId];
    char *newPrefix = NULL;
    char *extPrefix = NULL;
    uint8 *dataPtr = NULL;
    uint8 *maskPtr = NULL;
    uint32 disasmFlags;
    unsigned int index;
    unsigned int offset;
    unsigned int bits;
    int result = SOC_E_NONE;

    extPrefix = sal_alloc(sal_strlen(prefix) + 6, "C3 RCE group dump prefix");
    if (!extPrefix) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %u bytes for prefix work\n"),
                   (unsigned int)(sal_strlen(prefix) + 6)));
        result = SOC_E_MEMORY;
        goto error;
    }
    sal_snprintf(extPrefix,
                 sal_strlen(prefix) + 5,
                 "%s    ",
                 prefix);
    newPrefix = sal_alloc(sal_strlen(prefix) + 4, "C3 RCE group dump prefix");
    if (!newPrefix) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %u bytes for prefix work\n"),
                   (unsigned int)(sal_strlen(prefix) + 4)));
        result = SOC_E_MEMORY;
        goto error;
    }
    dataPtr = sal_alloc(groupData->instrBlocks * 2, "data/mask buffer");
    if (!dataPtr) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %u bytes data/mask buffer\n"),
                   groupData->instrBlocks * 2));
        result = SOC_E_MEMORY;
        goto error;
    }
    sal_memset(dataPtr, 0x00, groupData->instrBlocks * 2);
    maskPtr = &(dataPtr[groupData->instrBlocks]);
    sal_snprintf(newPrefix,
                 sal_strlen(prefix) + 3,
                 "%s  ",
                 prefix);
    params.unitData = unitData;
    params.flags = flags;
    params.prefix = newPrefix;
    params.count = 0;
#if (C3_RCE_ENABLE_ACTION_INDEX_COUNTERS || C3_RCE_ENABLE_ENTRY_INSERT_HEURISTIC)
    LOG_CLI((BSL_META("%sGroup %2d (flags %08X)\n"),
             prefix,
             groupId,
             groupData->groupFlags));
#else /* (C3_RCE_ENABLE_ACTION_INDEX_COUNTERS || C3_RCE_ENABLE_ENTRY_INSERT_HEURISTIC) */
    LOG_CLI((BSL_META("%sGroup %2d\n"),
             prefix,
             groupId));
#endif /* (C3_RCE_ENABLE_ACTION_INDEX_COUNTERS || C3_RCE_ENABLE_ENTRY_INSERT_HEURISTIC) */
    if (groupId != groupData->groupId) {
        LOG_CLI((BSL_META("%s(expected group ID %2d but got %2d)\n"),
                 newPrefix,
                 groupId,
                 groupData->groupId));
        result = SOC_E_INTERNAL;
        goto error;
    }
    LOG_CLI((BSL_META("%sProgram        = %12d (%s)\n"),
             newPrefix,
             (int)(groupData->rceProgram),
             unitData->progData[groupData->rceProgram]->ucData->programName));
    LOG_CLI((BSL_META("%sGroup priority = %12d\n"),
             newPrefix,
             groupData->groupPriority));
    LOG_CLI((BSL_META("%sLRP res bitmap =            %01X (%01X)\n"),
             newPrefix,
             groupData->resultLrp,
             groupData->resultLrpUniq));
    for (index = 0; index < SOC_C3_RCE_RESULT_REGISTER_COUNT; index++) {
        if (groupData->resultLrp & (1 << index)) {
            LOG_CLI((BSL_META("%s  Result register %u -> action table %u (%s)\n"),
                     newPrefix,
                     index,
                     unitData->progData[groupData->rceProgram]->actIndex[index],
                     unitData->actData[unitData->progData[groupData->rceProgram]->actIndex[index]]->ucData->tableName));
        }
    }
    LOG_CLI((BSL_META("%sRCE res bitmap =            %01X\n"),
             newPrefix,
             groupData->resultRce));
    LOG_CLI((BSL_META("%sInstructions   = %12u\n"),
             newPrefix,
             groupData->instrCount));
    LOG_CLI((BSL_META("%sInstr. blocks  = %12u\n"),
             newPrefix,
             groupData->instrBlocks));
    LOG_CLI((BSL_META("%sPatt+Act size  = %12u bytes\n"),
             newPrefix,
             groupData->dataSize));
    LOG_CLI((BSL_META("%sFilter sets    = %12u\n"),
             newPrefix,
             groupData->filterSetCount));
    if (groupData->maxFilterSets) {
        LOG_CLI((BSL_META("%sMax fltr sets  = %12u\n"),
                 newPrefix,
                 groupData->maxFilterSets));
    } else {
        LOG_CLI((BSL_META("%sMax fltr sets  =  (unlimited)\n"), newPrefix));
    }
    LOG_CLI((BSL_META("%sRanges / FSet  = %12u\n"),
             newPrefix,
             groupData->rangesPerFilterSet));
    LOG_CLI((BSL_META("%sActive entries = %12u\n"),
             newPrefix,
             groupData->entryCount));
    LOG_CLI((BSL_META("%sLast added ent = %12d\n"),
             newPrefix,
             groupData->entryLastAdded));
    if (flags & SOC_C3_RCE_DUMP_GROUP_INCLUDE_QUALS) {
        LOG_CLI((BSL_META("%sQualifiers:\n"), newPrefix));
        for (index = 0; index < groupData->qualCount; index++) {
            if (groupData->qualData[index]->qualName[0]) {
                LOG_CLI((BSL_META("%squal %2u, %s: %s(%d), %u params\n"),
                         extPrefix,
                         index,
                         groupData->qualData[index]->qualName,
                         _soc_c3_rce_qual_type_names[groupData->qualData[index]->qualType],
                         groupData->qualData[index]->qualType,
                         groupData->qualData[index]->paramCount));
            } else {
                LOG_CLI((BSL_META("%squal %2u: %s(%d), %u params\n"),
                         extPrefix,
                         index,
                         _soc_c3_rce_qual_type_names[groupData->qualData[index]->qualType],
                         groupData->qualData[index]->qualType,
                         groupData->qualData[index]->paramCount));
            }
            for (offset = 0;
                 offset < groupData->qualData[index]->paramCount;
                 offset++) {
                if (0 == offset) {
                    LOG_CLI((BSL_META("%s  "), extPrefix));
                } else if (0 == (offset & 7)) {
                    LOG_CLI((BSL_META(",\n%s  "), extPrefix));
                } else {
                    LOG_CLI((BSL_META(", ")));
                }
                LOG_CLI((BSL_META("%3d"), groupData->qualData[index]->param[offset]));
            }
            if (offset) {
                LOG_CLI((BSL_META("\n")));
            }
            result = _soc_c3_rce_entry_qualify_general_get(groupData->qualData[index],
                                                           groupData->qualOffs[index],
                                                           groupData->defaultPattern,
                                                           dataPtr,
                                                           maskPtr);
            if (SOC_E_NONE == result) {
                result = _soc_c3_rce_entry_qualify_general_length(groupData->qualData[index],
                                                                  &bits);
                if (SOC_E_NONE == result) {
                    LOG_CLI((BSL_META("%s  default data = "), extPrefix));
                    bits = (bits + 7) >> 3; /* maybe call it bytes now? */
                    offset = bits;
                    while (offset > 0) {
                        offset--;
                        LOG_CLI((BSL_META("%02X"), dataPtr[offset]));
                    }
                    LOG_CLI((BSL_META("\n%s  default mask = "), extPrefix));
                    offset = bits;
                    while (offset > 0) {
                        offset--;
                        LOG_CLI((BSL_META("%02X"), maskPtr[offset]));
                    }
                    LOG_CLI((BSL_META("\n")));
                } /* if (SOC_E_NONE == result) */
            } /* if (SOC_E_NONE == result) */
            /* but it's not a problem if unable to do that */
            result = SOC_E_NONE;
        } /* for (index = 0; index < groupData->qualCount; index++) */
    } /* if (flags & SOC_C3_RCE_DUMP_GROUP_INCLUDE_QUALS) */
    if (flags & SOC_C3_RCE_DUMP_GROUP_INCLUDE_DFLTPATT) {
        LOG_CLI((BSL_META("%sDefault pattern:\n"), newPrefix));
        for (index = 0; index < groupData->instrBlocks; index++) {
            if (0 == index) {
                LOG_CLI((BSL_META("%s"), extPrefix));
            } else if (0 == (index & 15)) {
                LOG_CLI((BSL_META("\n%s"), extPrefix));
            } else {
                LOG_CLI((BSL_META(" ")));
            }
            LOG_CLI((BSL_META("%02X"), groupData->defaultPattern[index]));
        } /* for (index = 0; index < groupData->instrBlocks; index++) */
        if (index) {
            LOG_CLI((BSL_META("\n")));
        }
    } /* if (flags & SOC_C3_RCE_DUMP_ENTRY_INCLUDE_A_RQUALS) */
    if (flags & SOC_C3_RCE_DUMP_GROUP_INCLUDE_DISASM) {
        LOG_CLI((BSL_META("%sFilter set template disassembly:\n"), newPrefix));
        LOG_CLI((BSL_META("%s-%-42s  -  --------\n"), extPrefix, _soc_c3_rce_disasm_bar));
        for (index = 1, offset = 0;
             (SOC_E_NONE == result) && (index < groupData->instrCount);
             index++) {
            result = _soc_c3_rce_instruction_disasm(unitData,
                                                    groupData->instr[index],
                                                    sizeof(disasmBuffer) - 1,
                                                    disasmBuffer,
                                                    &disasmFlags);
            if (((offset + 1) < groupData->qualCount) &&
                (index >= groupData->qualOffs[offset + 1])) {
                offset++;
            }
            if (index <= groupData->rangesPerFilterSet) {
                LOG_CLI((BSL_META("%s+%03X.%01X %-36s  %01X  RChk %3d\n"),
                         extPrefix,
                         index >> 3,
                         index & 7,
                         disasmBuffer,
                         (COMPILER_64_HI(groupData->instr[index]) & (1 << 31))?1:0,
                         index));
            } else { /* if (index <= groupData->rangesPerFilterSet) */
                LOG_CLI((BSL_META("%s+%03X.%01X %-36s  %01X  Qual %3d\n"),
                         extPrefix,
                         index >> 3,
                         index & 7,
                         disasmBuffer,
                         (COMPILER_64_HI(groupData->instr[index]) & (1 << 31))?1:0,
                         offset));
            } /* if (index <= groupData->rangesPerFilterSet) */
        } /* for (all instructions in this group) */
        LOG_CLI((BSL_META("%s-%-42s  -  --------\n"), extPrefix, _soc_c3_rce_disasm_bar));
    } /* if (flags & SOC_C3_RCE_DUMP_GROUP_INCLUDE_DISASM) */
    if (flags & SOC_C3_RCE_DUMP_GROUP_INCLUDE_ENT_DATA) {
        result = _soc_c3_rce_entry_traverse(unitData,
                                            groupId,
                                            &_soc_c3_rce_group_dump_entry,
                                            (void*)(&params));
#if 0 
        if (!(params.count)) {
            LOG_CLI((BSL_META("%s(no active entries)\n"), newPrefix));
        }
#endif 
        if (groupData->entryCount != params.count) {
            LOG_CLI((BSL_META("%s(entry count %u not equal to scanned entries %u)\n"),
                     newPrefix,
                     groupData->entryCount,
                     params.count));
        }
    } else if (flags & SOC_C3_RCE_DUMP_GROUP_INCLUDE_ENT_ID) {
        result = _soc_c3_rce_entry_traverse(unitData,
                                            groupId,
                                            &_soc_c3_rce_group_dump_entry_id,
                                            (void*)(&params));
#if 0 
        if (!(params.count)) {
            LOG_CLI((BSL_META("%s(no active entries)\n"), newPrefix));
        }
#endif 
        if (groupData->entryCount != params.count) {
            LOG_CLI((BSL_META("%s(entry count %u not equal to scanned entries %u)\n"),
                     newPrefix,
                     groupData->entryCount,
                     params.count));
        }
    } /* if (various entry display modes) */
error:
    if (newPrefix) {
        sal_free(newPrefix);
    }
    if (extPrefix) {
        sal_free(extPrefix);
    }
    if (dataPtr) {
        sal_free(dataPtr);
    }
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_program_dump_group
 *  Purpose
 *    Transition to group dump from program dump group iterator
 *  Arguments
 *    (IN) unit = unit number
 *    (IN) programId = program number
 *    (IN) groupId = group number
 *    (IN) extras = pointer to dump params cast as void*
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Meant only to be called by group iterator from program dump, below.
 */
static int
_soc_c3_rce_program_dump_group(int unit,
                               int programId,
                               int groupId,
                               void *extras)
{
    _soc_c3_rce_unit_dump_params_t *params = (_soc_c3_rce_unit_dump_params_t*)extras;
    params->count++;
    if (programId != params->unitData->groupData[groupId]->rceProgram) {
        LOG_CLI((BSL_META_U(unit,
                            "%s(expected membership in program %2d but claims %2d)\n"),
                 params->prefix,
                 programId,
                 params->unitData->groupData[groupId]->rceProgram));
    }
    return _soc_c3_rce_group_dump(params->unitData,
                                  params->flags,
                                  params->prefix,
                                  groupId);
}

/*
 *  Function
 *    _soc_c3_rce_program_dump_group_id
 *  Purpose
 *    Display a group's ID and handle subdisplays and other accounting
 *  Arguments
 *    (IN) unit = unit number
 *    (IN) programId = program number
 *    (IN) groupId = group number
 *    (IN) extras = pointer to dump params cast as void*
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Meant only to be called by group iterator from program dump, below.
 */
static int
_soc_c3_rce_program_dump_group_id(int unit,
                                  int programId,
                                  int groupId,
                                  void *extras)
{
    _soc_c3_rce_unit_dump_params_t *params = (_soc_c3_rce_unit_dump_params_t*)extras;
    _soc_c3_rce_unit_dump_params_t newParams;
    _soc_c3_rce_group_desc_int_t *groupData = params->unitData->groupData[groupId];
    char *newPrefix = NULL;
    int result = SOC_E_NONE;

    newPrefix = sal_alloc(sal_strlen(params->prefix) + 4, "C3 RCE group dump prefix");
    if (!newPrefix) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unable to allocate %u bytes for prefix work\n"),
                   (unsigned int)(sal_strlen(params->prefix) + 4)));
        result = SOC_E_MEMORY;
        goto error;
    }
    sal_snprintf(newPrefix,
                 sal_strlen(params->prefix) + 3,
                 "%s  ",
                 params->prefix);
    newParams.unitData = params->unitData;
    newParams.flags = params->flags;
    newParams.prefix = newPrefix;
    newParams.count = 0;
    params->count++;
    if (programId != groupData->rceProgram) {
        LOG_CLI((BSL_META_U(unit,
                            "%s(expected membership in program %2d but claims %2d)\n"),
                 params->prefix,
                 programId,
                 groupData->rceProgram));
    }
#if (C3_RCE_ENABLE_ACTION_INDEX_COUNTERS || C3_RCE_ENABLE_ENTRY_INSERT_HEURISTIC)
    LOG_CLI((BSL_META_U(unit,
                        "%sGroup %2d (flags %08X)\n"),
             params->prefix,
             groupId,
             groupData->groupFlags));
#else /* (C3_RCE_ENABLE_ACTION_INDEX_COUNTERS || C3_RCE_ENABLE_ENTRY_INSERT_HEURISTIC) */
    LOG_CLI((BSL_META_U(unit,
                        "%sGroup %2d\n"),
             params->prefix,
             groupId));
#endif /* (C3_RCE_ENABLE_ACTION_INDEX_COUNTERS || C3_RCE_ENABLE_ENTRY_INSERT_HEURISTIC) */
    if (params->flags & SOC_C3_RCE_DUMP_GROUP_INCLUDE_ENT_DATA) {
        result = _soc_c3_rce_entry_traverse(params->unitData,
                                            groupId,
                                            &_soc_c3_rce_group_dump_entry,
                                            (void*)(&newParams));
#if 0 
        if (!(params.count)) {
            LOG_CLI((BSL_META_U(unit,
                                "%s(no active entries)\n"), newPrefix));
        }
#endif 
        if (groupData->entryCount != newParams.count) {
            LOG_CLI((BSL_META_U(unit,
                                "%s(entry count %u not equal to scanned entries %u)\n"),
                     newPrefix,
                     groupData->entryCount,
                     newParams.count));
        }
    } else if (params->flags & SOC_C3_RCE_DUMP_GROUP_INCLUDE_ENT_ID) {
        result = _soc_c3_rce_entry_traverse(params->unitData,
                                            groupId,
                                            &_soc_c3_rce_group_dump_entry_id,
                                            (void*)(&newParams));
#if 0 
        if (!(params.count)) {
            LOG_CLI((BSL_META_U(unit,
                                "%s(no active entries)\n"), newPrefix));
        }
#endif 
        if (groupData->entryCount != newParams.count) {
            LOG_CLI((BSL_META_U(unit,
                                "%s(entry count %u not equal to scanned entries %u)\n"),
                     newPrefix,
                     groupData->entryCount,
                     newParams.count));
        }
    } /* if (various entry display modes) */
error:
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_filter_set_dump
 *  Purpose
 *    Dump information about a single filter set
 *  Arguments
 *    (IN) unitData = pointer to unit information
 *    (IN) flags = flags for the dump
 *    (IN) prefix = prefix string
 *    (IN) programId = which program contains the filter set
 *    (IN) filterSetIndex = which filter set in the program
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Uses bsl_printf to display the information being dumped.
 */
static int
_soc_c3_rce_filter_set_dump(_soc_c3_rce_unit_desc_int_t *unitData,
                            uint32 flags,
                            const char *prefix,
                            int programId,
                            unsigned int filterSetIndex)
{
    _soc_c3_rce_filterset_desc_int_t *fsetData;
    _soc_c3_rce_fset_range_info_t *rangeLocal;
    _soc_c3_rce_entry_desc_int_t *entryData;
    _soc_c3_rce_entry_desc_int_t *entryEnd;
    unsigned int fsetMinPosition;
    unsigned int fsetMaxPosition;
    unsigned int offset;
    unsigned int count;

    fsetData = &(unitData->progData[programId]->fsetData[filterSetIndex]);
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
    LOG_CLI((BSL_META("%sFilter set %3u: group %d set %3u flags %08X\n"),
             prefix,
             filterSetIndex,
             fsetData->groupId,
             fsetData->filterIndex,
             fsetData->fsetFlags));
#else /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
    LOG_CLI((BSL_META("%sFilter set %3u: group %d set %3u\n"),
             prefix,
             filterSetIndex,
             fsetData->groupId,
             fsetData->filterIndex));
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
    LOG_CLI((BSL_META("%s  Imem block  :   %03X..%03X (len %03X)\n"),
             prefix,
             fsetData->imemStart,
             fsetData->imemStart +
             fsetData->imemSize - 1,
             fsetData->imemSize));
    LOG_CLI((BSL_META("%s  Action blk  :   %03X\n"),
             prefix,
             fsetData->amemBlock));
    fsetMinPosition = fsetData->filterIndex * C3_RCE_ENTRIES_PER_FILTER_SET;
    fsetMaxPosition = fsetMinPosition + (C3_RCE_ENTRIES_PER_FILTER_SET - 1);
    LOG_CLI((BSL_META("%s  Positions   : %5d through %5d\n"),
             prefix,
             fsetMinPosition,
             fsetMaxPosition));
    if (fsetData->entryCount) {
        LOG_CLI((BSL_META("%s  Entry count : %5d (head %d, pos %u)\n"),
                 prefix,
                 fsetData->entryCount,
                 fsetData->entryHead->entryId,
                 fsetData->entryHead->entryPosition));
    } else {
        LOG_CLI((BSL_META("%s  Entry count : %5d\n"),
                 prefix,
                 fsetData->entryCount));
    }
    if (flags & SOC_C3_RCE_DUMP_FSET_INCLUDE_RANGES) {
        LOG_CLI((BSL_META("%s  Range checks: %5d max\n"),
                 prefix,
                 unitData->groupData[fsetData->groupId]->rangesPerFilterSet));
        for (offset = 0, count = 0;
              offset < unitData->groupData[fsetData->groupId]->rangesPerFilterSet;
              offset++) {
             rangeLocal = &(fsetData->rangeInfo[offset]);
             if (rangeLocal->rangeId) {
                 LOG_CLI((BSL_META("%s    RChk %3d: Range %5d %c fl=%04X, L=%04X,"
                                   " U=%04X, r=%u, cr=%u\n"),
                          prefix,
                          offset + 1,
                          rangeLocal->rangeId,
                          (rangeLocal->rangeFlags &
                          SOC_C3_RCE_RANGE_FLAG_INVERT)?'-':'+',
                          rangeLocal->rangeFlags,
                          rangeLocal->lowerLimit,
                          rangeLocal->upperLimit,
                          rangeLocal->refCount,
                          rangeLocal->commitCount));
                 count++;
             } /* if (slot contain a range) */
         } /* for (all range slots this filter set) */
         if (0 == count) {
             LOG_CLI((BSL_META("%s    (no range checks)\n"), prefix));
         }
    } /* if (flags & SOC_C3_RCE_DUMP_FSET_INCLUDE_RANGES) */
    if (flags & SOC_C3_RCE_DUMP_FSET_INCLUDE_ENTRIES) {
        LOG_CLI((BSL_META("%s  Entries:"), prefix));
        if (unitData->progData[programId]->filterSetCount >
            (filterSetIndex + 1)) {
            entryEnd = unitData->progData[programId]->fsetData[filterSetIndex + 1].entryHead;
        } else {
            entryEnd = NULL;
        }
        for (entryData = fsetData->entryHead, count = 0;
             entryData && (entryData != entryEnd);
             entryData = entryData->entryNext) {
            if (0 == (count & 3)) {
                LOG_CLI((BSL_META("\n%s    %5d,%5u"),
                         prefix,
                         entryData->entryId,
                         entryData->entryPosition));
            } else {
                LOG_CLI((BSL_META("   %5d,%5u"),
                         entryData->entryId,
                         entryData->entryPosition));
            }
            count++;
        }
        if (!count) {
            LOG_CLI((BSL_META("\n%s    (no entries)\n"), prefix));
        } else {
            if (count != fsetData->entryCount) {
                LOG_CLI((BSL_META("\n%s    (expected %u entries but got %u)\n"),
                         prefix,
                         fsetData->entryCount,
                         count));
            } else {
                LOG_CLI((BSL_META("\n%s    (%u entries)\n"), prefix, count));
            }
        }
    } /* if (flags & SOC_C3_RCE_DUMP_FSET_INCLUDE_ENTRIES) */
    return SOC_E_NONE;
}

/*
 *  Function
 *    _soc_c3_rce_program_dump
 *  Purpose
 *    Dump information about an entire program
 *  Arguments
 *    (IN) unitData = pointer to unit information
 *    (IN) flags = flags for the dump
 *    (IN) prefix = prefix string
 *    (IN) programId = which program to dump
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Uses bsl_printf to display the information being dumped.
 */
static int
_soc_c3_rce_program_dump(_soc_c3_rce_unit_desc_int_t *unitData,
                         uint32 flags,
                         const char *prefix,
                         int programId)
{
    _soc_c3_rce_unit_dump_params_t params;
    _soc_c3_rce_program_desc_int_t *progData = unitData->progData[programId];
    char *newPrefix;
    char *extPrefix;
    unsigned int index;
    unsigned int offset;
    unsigned int count;
    int result = SOC_E_NONE;

    extPrefix = sal_alloc(sal_strlen(prefix) + 6, "C3 RCE prog dump prefix");
    if (!extPrefix) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %u bytes for prefix work\n"),
                   (unsigned int)(sal_strlen(prefix) + 6)));
        return SOC_E_MEMORY;
    }
    sal_snprintf(extPrefix,
                 sal_strlen(prefix) + 5,
                 "%s    ",
                 prefix);
    newPrefix = sal_alloc(sal_strlen(prefix) + 4, "C3 RCE prog dump prefix");
    if (!newPrefix) {
        sal_free(extPrefix);
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %u bytes for prefix work\n"),
                   (unsigned int)(sal_strlen(prefix) + 4)));
        return SOC_E_MEMORY;
    }
    sal_snprintf(newPrefix,
                 sal_strlen(prefix) + 3,
                 "%s  ",
                 prefix);
    params.unitData = unitData;
    params.flags = flags;
    params.prefix = newPrefix;
    params.count = 0;
    LOG_CLI((BSL_META("%sProgram %2d (%s)\n"),
             prefix,
             programId,
             progData->ucData->programName));
    LOG_CLI((BSL_META("%sResult register use:\n"), newPrefix));
    for (index = 0, count = 0;
         index < SOC_C3_RCE_RESULT_REGISTER_COUNT;
         index++) {
        if (progData->actIndex[index] < unitData->actTableCount) {
            LOG_CLI((BSL_META("%sresult %u -> action table %u (%s)\n"),
                     extPrefix,
                     index,
                     progData->actIndex[index],
                     unitData->actData[progData->actIndex[index]]->ucData->tableName));
            count++;
        } /* if (program uses this result register) */
    } /* for (all possible result registers) */
    if (!count) {
        /* but we should never see this */
        LOG_CLI((BSL_META("%s(no result registers)\n"), extPrefix));
    }
    LOG_CLI((BSL_META("%sProgram flags      = %08X\n"),
             newPrefix,
             progData->ucData->programFlags));
    LOG_CLI((BSL_META("%sTMU key opcode map = %08X\n"),
             newPrefix,
             progData->ucData->tmuProg));
    LOG_CLI((BSL_META("%sKey transfer start = %8d (common clock)\n"),
             newPrefix,
             progData->keyTime));
    LOG_CLI((BSL_META("%sResult deadline    = %8d (common clock)\n"),
             newPrefix,
             progData->switchTime));
    LOG_CLI((BSL_META("%sKey to switch time = %8d (common clocks)\n"),
             newPrefix,
             progData->keyToSwitch));
    LOG_CLI((BSL_META("%sInstruction blocks = %8d\n"),
             newPrefix,
             progData->instrBlockCount));
    LOG_CLI((BSL_META("%sInstruction pad    = %8d (blocks)\n"),
             newPrefix,
             progData->instrBlockAdded));
    LOG_CLI((BSL_META("%sActive groups      = %8d\n"),
             newPrefix,
             progData->groupCount));
    LOG_CLI((BSL_META("%sActive filter sets = %8d\n"),
             newPrefix,
             progData->filterSetCount));
    if (flags & SOC_C3_RCE_DUMP_PROGRAM_INCLUDE_KEY) {
        LOG_CLI((BSL_META("%sProgram key layout:\n"), newPrefix));
        for (index = 0;
             socC3RceDataOffsetCount != progData->ucData->qualifiers[index].hdr.header;
             index++) {
            if (socC3RceDataMetadata == progData->ucData->qualifiers[index].hdr.header) {
                LOG_CLI((BSL_META("%skey elem %2u: %s(%d): %s(%d), length=%u:\n"),
                         extPrefix,
                         index,
                         _soc_c3_rce_data_header_names[progData->ucData->qualifiers[index].hdr.header],
                         progData->ucData->qualifiers[index].hdr.header,
                         _soc_c3_rce_metadata_type_names[progData->ucData->qualifiers[index].hdr.startBit],
                         progData->ucData->qualifiers[index].hdr.startBit,
                         progData->ucData->qualifiers[index].hdr.numBits));
            } else {
                LOG_CLI((BSL_META("%skey elem %2u: %s(%d) start=%d, length=%u:\n"),
                         extPrefix,
                         index,
                         _soc_c3_rce_data_header_names[progData->ucData->qualifiers[index].hdr.header],
                         progData->ucData->qualifiers[index].hdr.header,
                         progData->ucData->qualifiers[index].hdr.startBit,
                         progData->ucData->qualifiers[index].hdr.numBits));
            }
            for (offset = 0;
                 (offset < SOC_C3_RCE_MAX_SEG_PER_QUALIFIER) &&
                 (0 != progData->ucData->qualifiers[index].loc[offset].numBits);
                 offset++) {
                LOG_CLI((BSL_META("%s  start %d, length %u\n"),
                         extPrefix,
                         progData->ucData->qualifiers[index].loc[offset].startBit,
                         progData->ucData->qualifiers[index].loc[offset].numBits));
            }
        } /* for (all elements of this program's key) */
    } /* if (flags & SOC_C3_RCE_DUMP_PROGRAM_INCLUDE_KEY) */
    if (flags & SOC_C3_RCE_DUMP_PROGRAM_INCLUDE_FSETS) {
        LOG_CLI((BSL_META("%sProgram filter sets:\n"), newPrefix));
        for (index = 0; index < progData->filterSetCount; index++) {
            result = _soc_c3_rce_filter_set_dump(unitData,
                                                 flags,
                                                 extPrefix,
                                                 programId,
                                                 index);
            params.count++;
        }
        if (!(params.count)) {
            LOG_CLI((BSL_META("%s(no filter sets in this program)\n"), extPrefix));
        }
        params.count = 0;
    } /* if (flags & SOC_C3_RCE_DUMP_PROGRAM_INCLUDE_FSETS) */
    if (flags & SOC_C3_RCE_DUMP_PROGRAM_INCLUDE_DISASM) {
        LOG_CLI((BSL_META("%sProgram disassembly:\n"), newPrefix));
        result = _soc_c3_rce_program_disasm(unitData, programId, extPrefix);
    }
    if (flags & SOC_C3_RCE_DUMP_PROGRAM_INCLUDE_GRP_DATA) {
        result = _soc_c3_rce_group_traverse(unitData,
                                            programId,
                                            &_soc_c3_rce_program_dump_group,
                                            (void*)(&params));
#if 0 
        if (!(params.count)) {
            LOG_CLI((BSL_META("%s(no active groups)\n"), newPrefix));
        }
#endif 
        if (progData->groupCount != params.count) {
            LOG_CLI((BSL_META("%s(group count %u not equal to scanned groups %u)\n"),
                     newPrefix,
                     progData->groupCount,
                     params.count));
        }
    } else if (flags & SOC_C3_RCE_DUMP_PROGRAM_INCLUDE_GRP_ID) {
        result = _soc_c3_rce_group_traverse(unitData,
                                            programId,
                                            &_soc_c3_rce_program_dump_group_id,
                                            (void*)(&params));
#if 0 
        if (!(params.count)) {
            LOG_CLI((BSL_META("%s(no active groups)\n"), newPrefix));
        }
#endif 
        if (progData->groupCount != params.count) {
            LOG_CLI((BSL_META("%s(group count %u not equal to scanned groups %u)\n"),
                     newPrefix,
                     progData->groupCount,
                     params.count));
        }
    } /* if (various group listing options) */
    sal_free(newPrefix);
    sal_free(extPrefix);
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_unit_dump_program
 *  Purpose
 *    Transition to program dump from unit dump program iterator
 *  Arguments
 *    (IN) unit = unit number
 *    (IN) programId = program number
 *    (IN) extras = pointer to dump params cast as void*
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Meant only to be called by program iterator from unit dump, below.
 */
static int
_soc_c3_rce_unit_dump_program(int unit,
                              int programId,
                              void *extras)
{
    _soc_c3_rce_unit_dump_params_t *params = (_soc_c3_rce_unit_dump_params_t*)extras;
    params->count++;
    return _soc_c3_rce_program_dump(params->unitData,
                                    params->flags,
                                    params->prefix,
                                    programId);
}

/*
 *  Function
 *    _soc_c3_rce_range_dump
 *  Purpose
 *    Dump information about a range
 *  Arguments
 *    (IN) unitData = pointer to unit information
 *    (IN) flags = flags for the dump
 *    (IN) prefix = prefix string
 *    (IN) rangeId = which range to dump
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Uses bsl_printf to display the information being dumped.
 */
static int
_soc_c3_rce_range_dump(_soc_c3_rce_unit_desc_int_t *unitData,
                         uint32 flags,
                         const char *prefix,
                         int rangeId)
{
    _soc_c3_rce_range_desc_int_t *rangeData = unitData->rangeData[rangeId - 1];
    int result = SOC_E_NONE;

    LOG_CLI((BSL_META("%sRange %2d\n"), prefix, rangeId));
    LOG_CLI((BSL_META("%s  Flags           = %08X\n"),
             prefix,
             rangeData->rangeFlags));
    LOG_CLI((BSL_META("%s  Valid programs  =     %04X\n"),
             prefix,
             rangeData->validProgs));
    if (rangeData->headerField.fieldName[0]) {
        LOG_CLI((BSL_META("%s  Header name     = %s\n"),
                 prefix,
                 rangeData->headerField.fieldName));
    }
    LOG_CLI((BSL_META("%s  Header type     =    %5d (%s)\n"),
             prefix,
             rangeData->headerField.header,
             ((0 <= rangeData->headerField.header) &&
             (socC3RceDataOffsetCount > rangeData->headerField.header))?
             _soc_c3_rce_data_header_names[rangeData->headerField.header]:
             "?"));
    if (socC3RceDataMetadata == rangeData->headerField.header) {
        LOG_CLI((BSL_META("%s  Metadatum       =    %5d (%s)\n"),
                 prefix,
                 rangeData->headerField.startBit,
                 ((0 <= rangeData->headerField.startBit) &&
                 (socC3RceMetadataCount > rangeData->headerField.startBit))?
                 _soc_c3_rce_metadata_type_names[rangeData->headerField.startBit]:
                 "?"));
    } else {
        LOG_CLI((BSL_META("%s  Starting bit    =    %5d\n"),
                 prefix,
                 rangeData->headerField.startBit));
    }
    LOG_CLI((BSL_META("%s  Number of bits  =    %5d\n"),
             prefix,
             rangeData->headerField.numBits));
    LOG_CLI((BSL_META("%s  Lower boundary  =    %5d\n"),
             prefix,
             rangeData->lowerBound));
    LOG_CLI((BSL_META("%s  Upper boundary  =    %5d\n"),
             prefix,
             rangeData->upperBound));
    LOG_CLI((BSL_META("%s  Reference count =    %5d\n"),
             prefix,
             rangeData->refCount));
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_unit_dump_range
 *  Purpose
 *    Transition to range dump from unit dump range iterator
 *  Arguments
 *    (IN) unit = unit number
 *    (IN) rangeId = range number
 *    (IN) extras = pointer to dump params cast as void*
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Meant only to be called by range iterator from unit dump, below.
 */
static int
_soc_c3_rce_unit_dump_range(int unit,
                            int rangeId,
                            void *extras)
{
    _soc_c3_rce_unit_dump_params_t *params = (_soc_c3_rce_unit_dump_params_t*)extras;
    params->count++;
    return _soc_c3_rce_range_dump(params->unitData,
                                  params->flags,
                                  params->prefix,
                                  rangeId);
}

/*
 *  Function
 *    _soc_c3_rce_actiontbl_dump
 *  Purpose
 *    Dump information about a particular action table
 *  Arguments
 *    (IN) unitData = pointer to unit information
 *    (IN) flags = flags for the dump
 *    (IN) prefix = prefix string
 *    (IN) index = which action table (from unit data)
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 */
static int
_soc_c3_rce_actiontbl_dump(_soc_c3_rce_unit_desc_int_t *unitData,
                           uint32 flags,
                           const char *prefix,
                           unsigned int actionTable)
{
    const _soc_c3_rce_actions_desc_int_t *actTable;
    const _soc_c3_rce_actions_uc_desc_t *ucData;
    unsigned int index;
    unsigned int offset;

    actTable = unitData->actData[actionTable];
    ucData = actTable->ucData;
    LOG_CLI((BSL_META("%sAction table %u: '%s'\n"),
             prefix,
             actionTable,
             ucData->tableName));
    for (index = 0; index < ucData->ocmSegments; index++) {
        LOG_CLI((BSL_META("%s  Table seg %2u = %s (OCM %u.%u)\n"),
                 prefix,
                 index,
                 ucData->seg[index].segmentName,
                 ucData->seg[index].ocmPort,
                 ucData->seg[index].ocmSeg));
    } /* for (all OCM segments in this action table) */
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
    LOG_CLI((BSL_META("%s  Act-Idx ctrs = %s%s%s\n"),
             prefix,
             ucData->ctrRead?"  TRUE, '":" FALSE",
             ucData->ctrName?ucData->ctrName:"",
             ucData->ctrRead?"'":""));
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
    LOG_CLI((BSL_META("%s  Action size  = %6d bytes\n"),
             prefix,
             actTable->actionBytes));
    LOG_CLI((BSL_META("%s  Capacity     = %6u entries\n"),
             prefix,
             ucData->actionLimit));
    LOG_CLI((BSL_META("%s  Ent blk lim  = %6u\n"),
             prefix,
             actTable->entryLimit));
    LOG_CLI((BSL_META("%s  Ent blk actv = %6u\n"),
             prefix,
             actTable->entryActive));
    LOG_CLI((BSL_META("%s  Entry bias   = %6u\n"),
             prefix,
             actTable->firstEntryBias));
    if (flags & SOC_C3_RCE_DUMP_UNIT_INCLUDE_ACT_DFLT) {
        LOG_CLI((BSL_META("%s  Default value:"), prefix));
        for (index = 0; index < actTable->actionBytes; index++) {
            if (0 == (index & 15)) {
                LOG_CLI((BSL_META("\n%s    "), prefix));
            } else {
                LOG_CLI((BSL_META(" ")));
            }
            LOG_CLI((BSL_META("%02X"), actTable->defaultActions[index]));
        } /* for (index = 0; index < groupData->instrBlocks; index++) */
        LOG_CLI((BSL_META("\n")));
    } /* if (flags & SOC_C3_RCE_DUMP_PROGRAM_INCLUDE_DFLTACT) */
    LOG_CLI((BSL_META("%s  Action count = %6u\n"),
             prefix,
             actTable->actionCount));
    if (flags & SOC_C3_RCE_DUMP_UNIT_INCLUDE_ACT_DATA) {
        for (index = 0;
             socC3RceActionCount !=
             ucData->actions[index].action;
             index++) {
            if (ucData->actions[index].actionName) {
                LOG_CLI((BSL_META("%s    action %2u, %s: %s(%d)\n"),
                         prefix,
                         index,
                         ucData->actions[index].actionName,
                         _soc_c3_rce_action_uc_type_names[ucData->actions[index].action],
                         ucData->actions[index].action));
            } else {
                LOG_CLI((BSL_META("%s    action %2u: %s(%d)\n"),
                         prefix,
                         index,
                         _soc_c3_rce_action_uc_type_names[ucData->actions[index].action],
                         ucData->actions[index].action));
            }
            LOG_CLI((BSL_META("%s      enable/mode at %u\n"),
                     prefix,
                     ucData->actions[index].enableIndex));
            LOG_CLI((BSL_META("%s      disable value %u (%08X)\n"),
                     prefix,
                     ucData->actions[index].disableVal,
                     ucData->actions[index].disableVal));
            for (offset = 0;
                 (offset < SOC_C3_RCE_MAX_SEG_PER_ACTION) &&
                 (0 != ucData->actions[index].loc[offset].numBits);
                 offset++) {
                LOG_CLI((BSL_META("%s      start %d, length %u\n"),
                         prefix,
                         ucData->actions[index].loc[offset].startBit,
                         ucData->actions[index].loc[offset].numBits));
            }
        } /* for (all actions this program offers) */
    } /* if (flags & SOC_C3_RCE_DUMP_UNIT_INCLUDE_ACTIONS) */
    return SOC_E_NONE;
}

/*
 *  Function
 *    _soc_c3_rce_unit_dump
 *  Purpose
 *    Dump information about the entire unit
 *  Arguments
 *    (IN) unitData = pointer to unit information
 *    (IN) flags = flags for the dump
 *    (IN) prefix = prefix string
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Uses bsl_printf to display the information being dumped.
 */
static int
_soc_c3_rce_unit_dump(_soc_c3_rce_unit_desc_int_t *unitData,
                      uint32 flags,
                      const char *prefix)
{
    _soc_c3_rce_unit_dump_params_t params;
    shr_mdb_info_t mdbInfo;
    shr_mdb_alloc_pref_t allocmode;
    shr_mdb_list_info_t mdbListInfo;
    shr_mdb_elem_bank_index_t list, lists;
    unsigned int mdbLimboElements;
    unsigned int mdbLimboBlocks;
    char *extPrefix;
    char *newPrefix;
    int result = SOC_E_NONE;
    unsigned int index;
    int free;

    extPrefix = sal_alloc(sal_strlen(prefix) + 6, "C3 RCE unit dump prefix");
    if (!extPrefix) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %u bytes for prefix work\n"),
                   (unsigned int)(sal_strlen(prefix) + 6)));
        return SOC_E_MEMORY;
    }
    sal_snprintf(extPrefix,
                 sal_strlen(prefix) + 5,
                 "%s    ",
                 prefix);
    newPrefix = sal_alloc(sal_strlen(prefix) + 4, "C3 RCE unit dump prefix");
    if (!newPrefix) {
        sal_free(extPrefix);
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to allocate %u bytes for prefix work\n"),
                   (unsigned int)(sal_strlen(prefix) + 4)));
        return SOC_E_MEMORY;
    }
    sal_snprintf(newPrefix,
                 sal_strlen(prefix) + 3,
                 "%s  ",
                 prefix);
    LOG_CLI((BSL_META("%sUnit %d RCE (flags %08X)\n"),
             prefix,
             unitData->unit,
             unitData->unitFlags));
    LOG_CLI((BSL_META("%sEpoch time         = %5d (common clocks)\n"),
             newPrefix,
             unitData->epochTime));
    LOG_CLI((BSL_META("%sLRP clock divide   = %5u\n"),
             newPrefix,
             unitData->lrpClockDivide));
    LOG_CLI((BSL_META("%sRCE clock divide   = %5u\n"),
             newPrefix,
             unitData->rceClockDivide));
    LOG_CLI((BSL_META("%sActive instr blks  = %5d\n"),
             newPrefix,
             unitData->instrBlockCount));
    LOG_CLI((BSL_META("%sMax active ranges  = %5d\n"),
             newPrefix,
             unitData->rangeLimit));
    LOG_CLI((BSL_META("%sMax active groups  = %5d\n"),
             newPrefix,
             unitData->groupLimit));
    LOG_CLI((BSL_META("%sMax active entries = %5d\n"),
             newPrefix,
             unitData->entryLimit));
    LOG_CLI((BSL_META("%sProgram exec order = "),
             newPrefix));
    for (index = 0, free = 0; index < SOC_C3_RCE_PROGRAM_COUNT; index++) {
        if (0xFF != unitData->progOrder[index]) {
            if (free) {
                LOG_CLI((BSL_META(", %2d"), unitData->progOrder[index]));
            } else {
                LOG_CLI((BSL_META("   %2d"), unitData->progOrder[index]));
            }
            free++;
        }
    }
    if (free) {
        LOG_CLI((BSL_META("\n")));
    } else {
        LOG_CLI((BSL_META(" none\n")));
    }
    if (flags & SOC_C3_RCE_DUMP_UNIT_INCLUDE_IMEM_ALLOC) {
        /* showing MDB data */
        LOG_CLI((BSL_META("%sInstruction memory management:\n"), newPrefix));
        result = shr_mdb_info(unitData->imemRes, &mdbInfo);
        if (SOC_E_NONE == result) {
            result = shr_mdb_allocmode_get(unitData->imemRes, &allocmode);
            LOG_CLI((BSL_META("%s  first element         = %8d\n"),
                     newPrefix,
                     mdbInfo.first));
            LOG_CLI((BSL_META("%s  last element          = %8d\n"),
                     newPrefix,
                     mdbInfo.last));
            LOG_CLI((BSL_META("%s  bank size             = %8d\n"),
                     newPrefix,
                     mdbInfo.bank_size));
            LOG_CLI((BSL_META("%s  free lists            = %8d\n"),
                     newPrefix,
                     mdbInfo.free_lists));
            LOG_CLI((BSL_META("%s  user lists            = %8d\n"),
                     newPrefix,
                     mdbInfo.user_lists));
            if (SOC_E_NONE == result) {
                LOG_CLI((BSL_META("%s  allocation mode       = %08X\n"),
                         newPrefix,
                         allocmode));
            }
            mdbLimboElements=0;
            mdbLimboBlocks=0;
            for (list = 0; list < mdbInfo.user_lists; list++) {
                result = shr_mdb_list_info(unitData->imemRes,
                                           list,
                                           FALSE,
                                           &mdbListInfo);
                if (SOC_E_NONE == result) {
                    mdbLimboElements += mdbListInfo.elements;
                    mdbLimboBlocks += mdbListInfo.blocks;
                }
            }
            LOG_CLI((BSL_META("%s  used elements         = %8d; blocks = %8d\n"),
                     newPrefix,
                     ((mdbInfo.last - mdbInfo.first + 1) -
                     mdbInfo.free_elems) - mdbLimboElements,
                     unitData->imemBlockCount));
            LOG_CLI((BSL_META("%s  side elements         = %8d; blocks = %8d\n"),
                     newPrefix,
                     mdbLimboElements,
                     mdbLimboBlocks));
            LOG_CLI((BSL_META("%s  free elements         = %8d; blocks = %8d\n"),
                     newPrefix,
                     mdbInfo.free_elems,
                     mdbInfo.free_blocks));
            free = 1;
            do { /* while (TRUE) */
                /* for free and user list sets */
                lists = free?mdbInfo.free_lists:mdbInfo.user_lists;
                for (list = 0; list < lists; list++) {
                    /* for each list in the set */
                    result = shr_mdb_list_info(unitData->imemRes,
                                               list,
                                               free,
                                               &mdbListInfo);
                    if (SOC_E_NONE == result) {
                        if (free) {
                            /* free lists have fixed block size */
                            LOG_CLI((BSL_META("%s  free list %2d elements = %8d;"
                                              " blocks = %8d; elem/blk = %5d\n"),
                                     newPrefix,
                                     list,
                                     mdbListInfo.elements,
                                     mdbListInfo.blocks,
                                     mdbListInfo.block_size));
                        } else {
                            /* user lists do not have fixed block size */
                            LOG_CLI((BSL_META("%s  user list %2d elements = %8d;"
                                              " blocks = %8d\n"),
                                     newPrefix,
                                     list,
                                     mdbListInfo.elements,
                                     mdbListInfo.blocks));
                        }
                    } else { /* if (BCM_E_NONE == result) */
                        LOG_CLI((BSL_META("%s  %s list %2d access error %d"
                                          " (%s)\n"),
                                 newPrefix,
                                 free?"free":"user",
                                 list,
                                 result,
                                 _SHR_ERRMSG(result)));
                        break;
                    } /* if (BCM_E_NONE == result) */
                } /* for (list = 0; list < lists; list++) */
                if ((!free) || (SOC_E_NONE != result)) {
                    break;
                }
                free = 0;
            } while (TRUE);
        } else { /* if (BCM_E_NONE == result) */
            LOG_CLI((BSL_META("%s  unable to fetch MDB allocator information:"
                              " %d (%s)\n"),
                     newPrefix,
                     result,
                     _SHR_ERRMSG(result)));
        } /* if (BCM_E_NONE == result) */
    } /* if (flags & SOC_C3_RCE_DUMP_UNIT_INCLUDE_IMEM_ALLOC) */
    if (flags & SOC_C3_RCE_DUMP_UNIT_INCLUDE_ACTIONS) {
        LOG_CLI((BSL_META("%sAction data:\n"), newPrefix));
        params.count = 0;
        for (index = 0;
             index < unitData->actTableCount;
             index++) {
            result = _soc_c3_rce_actiontbl_dump(unitData,
                                                flags,
                                                extPrefix,
                                                index);
            params.count++;
        } /* for (all available action tables) */
        if (!params.count) {
            LOG_CLI((BSL_META("%s(no action tables)\n"), extPrefix));
        }
    } /* if (flags & SOC_C3_RCE_DUMP_UNIT_INCLUDE_ACTIONS) */
    params.unitData = unitData;
    params.flags = flags;
    params.prefix = newPrefix;
    params.count = 0;
    if (flags & SOC_C3_RCE_DUMP_UNIT_INCLUDE_PADDING) {
        LOG_CLI((BSL_META("%sPadding filter sets:\n"), newPrefix));
        for (index = 0; index < C3_RCE_FILTER_SET_COUNT_PADDING; index++) {
            LOG_CLI((BSL_META("%s  padding %2d: start=%03X len=%03X\n"),
                     newPrefix,
                     index,
                     unitData->imemExtra[index],
                     (index)?C3_RCE_FILTER_SET_LENGTH_LATER:C3_RCE_FILTER_SET_LENGTH_FIRST));
            params.count++;
        }
        if (!(params.count)) {
            LOG_CLI((BSL_META("%s  (no padding filter sets)\n"), newPrefix));
        }
        params.count = 0;
    }
    params.prefix = extPrefix;
    if (flags & SOC_C3_RCE_DUMP_UNIT_INCLUDE_RANGES) {
        LOG_CLI((BSL_META("%sRanges:\n"), newPrefix));
        result = _soc_c3_rce_range_traverse(unitData,
                                            &_soc_c3_rce_unit_dump_range,
                                            (void*)(&params));
        if (!(params.count)) {
            LOG_CLI((BSL_META("%s  (no active ranges)\n"), newPrefix));
        }
        params.count = 0;
    }
    params.prefix = newPrefix;
    if (flags & SOC_C3_RCE_DUMP_UNIT_INCLUDE_PROGRAMS) {
        result = _soc_c3_rce_program_traverse(unitData,
                                              &_soc_c3_rce_unit_dump_program,
                                              (void*)(&params));
#if 0 
        if (!(params.count)) {
            LOG_CLI((BSL_META("%s(no active programs)\n"), newPrefix));
        }
#endif 
    }
    sal_free(newPrefix);
    sal_free(extPrefix);
    return result;
}
#endif /* defined(BROADCOM_DEBUG) */

/*
 *  Function
 *    _soc_c3_rce_debug_capture_parse
 *  Purpose
 *    Get the captured key (if any) and use the debug configuration to figure
 *    out which entries (if any) are referred to by the result capture
 *    registers (when there are captured results).
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (OUT) flags = flags indicating capture state
 *    (OUT) keyData = where to put key data
 *    (OUT) programId = where to put ID of program whose data were captured
 *    (OUT) entryIds = where to put array of results
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    The key is SOC_C3_RCE_KEY_BIT_MAXIMUM+33 (544) bits, returned like the
 *    qualifiers from least significant byte to most significant byte.
 *
 *    entryIds array is SOC_C3_RCE_RESULT_REGISTER_COUNT long.
 *
 *    Of the key, the first 432 bits are from the captured key.  64 bits are
 *    then skipped (the key capture does not also capture the RCE internal
 *    result fields and there seems to be no way to capture them on current
 *    hardware).  The next 16 bits are taken from the current value of the
 *    KEY_GLOBAL field in RC_KEYMEM_CONFIG, with the low 4 of those bits set
 *    according to how the hardware 'should' always set them.  To those 512
 *    bits we also throw in an extra 32 bits, the value of the trace point
 *    capture register.  Excluding the addidional 32 bits for the trace point
 *    capture register, this should mirror the key format exactly, except that
 *    the place where the real key would have the RCE internal results is
 *    filled with zeroes.
 *
 *    The additional 32b for the trace point capture information contains:
 *       0..10  key tag
 *        11    key first
 *        12    run
 *      13..16  program ID
 *      17..31  reserved
 *
 *    Most of the additional data in the trace point capture information is
 *    used internally to the hardware, but the program ID is probably important
 *    in order to understand the key format and is definitely important in
 *    parsing the results capture (if the results capture was triggered by the
 *    key capture mechanism).
 *
 *    This returns -1 in the entry ID array for a result that does not map to a
 *    valid entry ID, otherwise it returns the entry ID.  Under typical use,
 *    all of these being -1 indicates that a miss was captured; at least one of
 *    them should be a valid entry ID if a hit was captured.  This function
 *    deals with getting the program ID from either the trace point capture
 *    data or from the results capture configuration as appropriate.
 *
 *    Output data will be clobbered even on errors.
 *
 *    This resets the capture status, if possible.  If a capture was made in a
 *    mode where halt will be asserted after the capture, it is not recoverable
 *    and the RCE must be reset.
 */
static int
_soc_c3_rce_debug_capture_parse(_soc_c3_rce_unit_desc_int_t *unitData,
                                uint32 *flags,
                                uint8 *keyData,
                                int *programId,
                                int *entryIds)
{
    uint32 resDebug;
    uint32 traceCtrl;
    uint32 keyState;
    uint32 regTemp;
    uint32 resValue[SOC_C3_RCE_RESULT_REGISTER_COUNT];
    uint8 rceProgram = 0xFF;
    unsigned int index;
    unsigned int offset;
    int result;

    *flags = 0;
    for (index = 0; index < SOC_C3_RCE_RESULT_REGISTER_COUNT; index++) {
        entryIds[index] = -1;
    }
    for (index = 0; index < (SOC_C3_RCE_KEY_BIT_MAXIMUM+33)/8; index++) {
        keyData[index] = 0;
    }
    result = soc_reg32_get(unitData->unit,
                           RC_RESULTS_DEBUGr,
                           REG_PORT_ANY,
                           0,
                           &resDebug);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to read unit %d result debug reg: %d (%s)\n"),
                   unitData->unit,
                   result,
                   _SHR_ERRMSG(result)));
        return result;
    }
    if (soc_reg_field_get(unitData->unit,
                          RC_RESULTS_DEBUGr,
                          resDebug,
                          CAPTURE_ENABLEf)) {
        *flags |= SOC_C3_RCE_RESULT_TRACE_ENABLE;
    }
    if (soc_reg_field_get(unitData->unit,
                          RC_RESULTS_DEBUGr,
                          resDebug,
                          CAPTURE_STATUSf)) {
        *flags |= SOC_C3_RCE_RESULT_TRACE_CAPTURED;
    }
    if (soc_reg_field_get(unitData->unit,
                          RC_RESULTS_DEBUGr,
                          resDebug,
                          CAPTURE_TRACE_KEYf)) {
        *flags |= SOC_C3_RCE_RESULT_TRACE_FROM_KEY;
    }
    result = soc_reg32_get(unitData->unit,
                           RC_TRACE_IF_STATUSr,
                           REG_PORT_ANY,
                           0,
                           &traceCtrl);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to read unit %d trace status: %d (%s)\n"),
                   unitData->unit,
                   result,
                   _SHR_ERRMSG(result)));
        return result;
    }
    if (soc_reg_field_get(unitData->unit,
                          RC_TRACE_IF_STATUSr,
                          traceCtrl,
                          LRP_STATUSf)) {
        *flags |= SOC_C3_RCE_KEY_TRACE_CAPTURED;
    }
    result = soc_reg32_get(unitData->unit,
                           RC_TRACE_IF_STATUS_MASKr,
                           REG_PORT_ANY,
                           0,
                           &traceCtrl);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to read unit %d trace status: %d (%s)\n"),
                   unitData->unit,
                   result,
                   _SHR_ERRMSG(result)));
        return result;
    }
    if (0 == soc_reg_field_get(unitData->unit,
                               RC_TRACE_IF_STATUS_MASKr,
                               traceCtrl,
                               LRP_STATUS_DISINTf)) {
        *flags |= SOC_C3_RCE_KEY_TRACE_INTERRUPT;
    }
    result = soc_reg32_get(unitData->unit,
                           RC_TRACE_IF_LRP_CONTROLr,
                           REG_PORT_ANY,
                           0,
                           &traceCtrl);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unable to read unit %d trace status: %d (%s)\n"),
                   unitData->unit,
                   result,
                   _SHR_ERRMSG(result)));
        return result;
    }
    if (soc_reg_field_get(unitData->unit,
                          RC_TRACE_IF_LRP_CONTROLr,
                          traceCtrl,
                          HALT_ENABLEf)) {
        *flags |= SOC_C3_RCE_KEY_TRACE_HALT;
    }
    if (soc_reg_field_get(unitData->unit,
                          RC_TRACE_IF_LRP_CONTROLr,
                          traceCtrl,
                          TP_ENABLEf)) {
        *flags |= SOC_C3_RCE_KEY_TRACE_ENABLE;
    }
    /*
     *  So now we have all the status needed to determine how to parse the
     *  capture(s), according to the settings and results in the registers.
     *
     *  If SOC_C3_RCE_RESULT_TRACE_CAPTURED, then we have a result capture.
     *  If SOC_C3_RCE_RESULT_TRACE_FROM_KEY also, then the result was captured
     *  based upon a key capture, so the result control's program field is not
     *  useful (we need the program field from the captured key+status).  If
     *  this is the case but not SOC_C3_RCE_KEY_TRACE_CAPTURED, something else
     *  has changed settings and we can not parse results.
     *
     *  If SOC_C3_RCE_RESULT_TRACE_CAPTURED is set, but not
     *  SOC_C3_RCE_RESULT_TRACE_FROM_KEY, then the result was captured from the
     *  result side exclusively so we use the result capture program setting in
     *  parsing the results.
     *
     *  If SOC_C3_RCE_KEY_TRACE_CAPTURED, we also report the captured key.
     *  We'll do this first since we need the program value from this path if
     *  SOC_C3_RCE_RESULT_TRACE_CAPTURED && SOC_C3_RCE_RESULT_TRACE_FROM_KEY.
     */
    if ((*flags) & SOC_C3_RCE_KEY_TRACE_CAPTURED) {
        /* key was captured; collect it */
        for (index = 0, offset = 0;
             index < 15;
             index++) {
            result = soc_reg32_get(unitData->unit,
                                   _soc_c3_rce_debug_key_capture[index],
                                   REG_PORT_ANY,
                                   0,
                                   &regTemp);
            if (SOC_E_NONE != result) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("unit %d unable to read captured key at"
                           " register %u: %d (%s)\n"),
                           unitData->unit,
                           index,
                           result,
                           _SHR_ERRMSG(result)));
                return result;
            }
            if (index < 13) {
                keyData[offset++] = regTemp & 0xFF;
                regTemp >>= 8;
                keyData[offset++] = regTemp & 0xFF;
                regTemp >>= 8;
                keyData[offset++] = regTemp & 0xFF;
                regTemp >>= 8;
                keyData[offset++] = regTemp & 0xFF;
            } else if (13 == index) {
                keyData[offset++] = regTemp & 0xFF;
                regTemp >>= 8;
                keyData[offset++] = regTemp & 0xFF;
            }
        } /* for (all key capture registers) */
        /*
         *  The RCE internal results registers are not captured in the key, so
         *  skip them when reporting the key value.
         */
        offset += 8;
        keyState = regTemp;
        rceProgram = soc_reg_field_get(unitData->unit,
                                       RC_TRACE_IF_LRP_CAPT_14r,
                                       regTemp,
                                       PROGf);
        /*
         *  The capture facility does not capture the 'key global' and
         *  remaining four bits of the key, so we guess about it by looking at
         *  its value when this function is called.
         *
         *  The 'key_global' field is shifted left 4, and padded with bit
         *  pattern 001v where 'v' indicates a valid key; assume any captured
         *  key would be valid, so we want (key_global SHL 4) OR 0011 binary.
         */
        result = soc_reg32_get(unitData->unit,
                               RC_KEYMEM_CONFIGr,
                               REG_PORT_ANY,
                               0,
                               &regTemp);
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unit %d unable to read keymem config register:"
                       " %d (%s)\n"),
                       unitData->unit,
                       result,
                       _SHR_ERRMSG(result)));
            return result;
        }
        regTemp = (soc_reg_field_get(unitData->unit,
                                     RC_KEYMEM_CONFIGr,
                                     regTemp,
                                     KEY_GLOBALf) << 4) | 0x03;
        keyData[offset++] = regTemp & 0xFF;
        regTemp >>= 8;
        keyData[offset++] = regTemp & 0xFF;
        /* Also we provide the key capture state, added to the end. */
        keyData[offset++] = keyState & 0xFF;
        keyState >>= 8;
        keyData[offset++] = keyState & 0xFF;
        keyState >>= 8;
        keyData[offset++] = keyState & 0xFF;
        keyState >>= 8;
        keyData[offset++] = keyState & 0xFF;
    } /* if ((*flags) & SOC_C3_RCE_KEY_TRACE_CAPTURED) */
    if ((*flags) & SOC_C3_RCE_RESULT_TRACE_CAPTURED) {
        /* captured results */
        if (0 == ((*flags) & SOC_C3_RCE_RESULT_TRACE_FROM_KEY)) {
            /* captured results independently from key; get program */
            rceProgram = soc_reg_field_get(unitData->unit,
                                           RC_RESULTS_DEBUGr,
                                           resDebug,
                                           CAPTURE_PROGRAM_NUMf);
        } /* if (0 == ((*flags) & SOC_C3_RCE_RESULT_TRACE_FROM_KEY)) */
        if (rceProgram < SOC_C3_RCE_PROGRAM_COUNT) {
            *programId = rceProgram;
            /* we know what program so can parse results */
            for (index = 0;
                 index < SOC_C3_RCE_RESULT_REGISTER_COUNT;
                 index++) {
                result = soc_reg32_get(unitData->unit,
                                       RC_RESULTS_DEBUG_VALUEr,
                                       REG_PORT_ANY,
                                       index,
                                       &resValue[index]);
                if (SOC_E_NONE != result) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META("unable to read unit %d result capture"
                               " value %u: %d (%s)\n"),
                               unitData->unit,
                               index,
                               result,
                               _SHR_ERRMSG(result)));
                    return result;
                }
                result = _soc_c3_rce_entry_from_result(unitData,
                                                       rceProgram,
                                                       resValue[index],
                                                       &(entryIds[index]));
                if (SOC_E_EMPTY == result) {
                    LOG_WARN(BSL_LS_SOC_COMMON,
                             (BSL_META("unit %d entry %d appears to have"
                              " provided result %u but is not"
                              " installed???\n"),
                              unitData->unit,
                              entryIds[index],
                              resValue[index]));
                    /* but we don't want to call this an error here */
                    result = SOC_E_NONE;
                } else if (SOC_E_NOT_FOUND == result) {
                    /*
                     *  Normally, we do not expect to fill all of the result
                     *  registers with matches from a single key (an in typical
                     *  cases even an entire program only writes one or two
                     *  keys with search results).  It's also possible that we
                     *  triggered on a key search that resulted in no result.
                     *
                     *  Make sure the entry ID is -1 (no entry) and continue.
                     */
                    entryIds[index] = -1;
                    result = SOC_E_NONE;
                } else if (SOC_E_NONE != result) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META("unable to map unit %d result %u to an"
                               " entry ID: %d (%s)\n"),
                               unitData->unit,
                               resValue[index],
                               result,
                               _SHR_ERRMSG(result)));
                    entryIds[index] = -1;
                    return result;
                }
            } /* for (all capturable result registers) */
        } else { /* if (rceProgram < SOC_C3_RCE_PROGRAM_COUNT) */
            /* results but no program??? */
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unit %d unexpected capture state: result"
                       " captured using key but no captured key\n"),
                       unitData->unit));
            return SOC_E_FAIL;
        } /* if (rceProgram < SOC_C3_RCE_PROGRAM_COUNT) */
    } /* if ((*flags) & SOC_C3_RCE_RESULT_TRACE_CAPTURED) */
    /* Reset the capture state so more data can be captured */
    if ((*flags) & SOC_C3_RCE_RESULT_TRACE_CAPTURED) {
        result = soc_reg32_set(unitData->unit,
                               RC_RESULTS_DEBUGr,
                               REG_PORT_ANY,
                               0,
                               resDebug);
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unit %d unable to reset result capture state:"
                       " %d (%s)\n"),
                       unitData->unit,
                       result,
                       _SHR_ERRMSG(result)));
            return result;
        }
    }
    if ((*flags) & SOC_C3_RCE_KEY_TRACE_CAPTURED) {
        result = soc_reg32_get(unitData->unit,
                               RC_TRACE_IF_STATUSr,
                               REG_PORT_ANY,
                               0,
                               &traceCtrl);
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unable to read unit %d trace status:"
                       " %d (%s)\n"),
                       unitData->unit,
                       result,
                       _SHR_ERRMSG(result)));
            return result;
        }
        soc_reg_field_set(unitData->unit,
                          RC_TRACE_IF_STATUSr,
                          &traceCtrl,
                          LRP_STATUSf,
                          1);
        result = soc_reg32_set(unitData->unit,
                               RC_TRACE_IF_STATUSr,
                               REG_PORT_ANY,
                               0,
                               traceCtrl);
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unit %d unable to reset trace status:"
                       " %d (%s)\n"),
                       unitData->unit,
                       result,
                       _SHR_ERRMSG(result)));
            return result;
        }
    }
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_debug_capture_set
 *  Purpose
 *    Set the debug capture configuration.
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) flags = flags indicating desired capture state
 *    (IN) threshold = key capture threshold value
 *    (IN) keyData = data values for key capture
 *    (IN) keyMask = mask values for key capture
 *    (IN) programId = program whose results are to be captured
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Sets up the hardware assists for capturing results and keys according to
 *    the provided flags and arguments.
 *
 *    If SOC_C3_RCE_RESULT_TRACE_ENABLE but not
 *    SOC_C3_RCE_RESULT_TRACE_FROM_KEY, then programId must be a valid program
 *    ID and indicates which program's results to capture.
 *
 *    If SOC_C3_RCE_RESULT_TRACE_ENABLE and SOC_C3_RCE_RESULT_TRACE_FROM_KEY,
 *    the result capture will be triggered by the key capture, so programId
 *    specified here will be ignored.
 *
 *    If SOC_C3_RCE_KEY_TRACE_ENABLE, then keyData and keyMask must be
 *    provided, so the key capture knows what to capture.  Masking is allowed.
 *
 *    If not SOC_C3_RCE_KEY_TRACE_ENABLE, the keyData and keyMask will be
 *    ignored, so they may be NULL.  If either (or both) is NULL under any
 *    other condition, it will be interpreted as the trace is to match any
 *    possible values.
 *
 *    If SOC_C3_RCE_KEY_TRACE_HALT, the RCE will enter a halted state
 *    immediately after the capture, and will require reset before it will
 *    function again.  Normally, this flag will NOT be used.
 *
 *    The mask behaviour here corresponds to the BCM interpretration, where a 1
 *    indicates data bit of intereset and a 0 indicates a data bit that does
 *    not matter.  The hardware flips this meaning; this is handled here.
 *
 *    The _soc_c3_rce_debug_capture_parse function, above, describes the key
 *    format.  The key data and mask here use that format.  This function will
 *    return an error if you try to make fields not available in the hardware
 *    important (such as the RCE internal result registers).
 *
 *    This will reset the capture status after it is done setting values.
 */
static int
_soc_c3_rce_debug_capture_set(_soc_c3_rce_unit_desc_int_t *unitData,
                              uint32 flags,
                              uint32 threshold,
                              const uint8 *keyData,
                              const uint8 *keyMask,
                              int programId)
{
    unsigned int index;
    unsigned int offset;
    int result;
    uint32 resDebug;
    uint32 traceCtrl;
    uint32 traceStat;
    uint32 traceIntr;
    uint32 traceMask;
    uint32 regTemp;

    /* Set up the results capture settings */
    result = soc_reg32_get(unitData->unit,
                           RC_RESULTS_DEBUGr,
                           REG_PORT_ANY,
                           0,
                           &resDebug);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d unable to read results debug: %d (%s)\n"),
                   unitData->unit,
                   result,
                   _SHR_ERRMSG(result)));
        return result;
    }
    result = soc_reg32_get(unitData->unit,
                           RC_TRACE_IF_LRP_CONTROLr,
                           REG_PORT_ANY,
                           0,
                           &traceCtrl);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d unable to read trace control: %d (%s)\n"),
                   unitData->unit,
                   result,
                   _SHR_ERRMSG(result)));
        return result;
    }
    result = soc_reg32_get(unitData->unit,
                           RC_TRACE_IF_STATUSr,
                           REG_PORT_ANY,
                           0,
                           &traceStat);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d unable to read trace state: %d (%s)\n"),
                   unitData->unit,
                   result,
                   _SHR_ERRMSG(result)));
        return result;
    }
    result = soc_reg32_get(unitData->unit,
                           RC_TRACE_IF_STATUS_MASKr,
                           REG_PORT_ANY,
                           0,
                           &traceIntr);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d unable to read trace state mask: %d (%s)\n"),
                   unitData->unit,
                   result,
                   _SHR_ERRMSG(result)));
        return result;
    }
    /* Set up result debug control according to the flags & program ID */
    soc_reg_field_set(unitData->unit,
                      RC_RESULTS_DEBUGr,
                      &resDebug,
                      CAPTURE_ENABLEf,
                      (flags & SOC_C3_RCE_RESULT_TRACE_ENABLE)?1:0);
    soc_reg_field_set(unitData->unit,
                      RC_RESULTS_DEBUGr,
                      &resDebug,
                      CAPTURE_TRACE_KEYf,
                      (flags & SOC_C3_RCE_RESULT_TRACE_FROM_KEY)?1:0);
    soc_reg_field_set(unitData->unit,
                      RC_RESULTS_DEBUGr,
                      &resDebug,
                      CAPTURE_STATUSf,
                      1);
    if ((flags & (SOC_C3_RCE_RESULT_TRACE_ENABLE &
                  SOC_C3_RCE_RESULT_TRACE_FROM_KEY)) ==
        (SOC_C3_RCE_RESULT_TRACE_ENABLE)) {
        /* result capture and not linked with key capture; set program */
        /* coverity[dead_error_line] */
        if ((0 > programId) || (SOC_C3_RCE_PROGRAM_COUNT <= programId)) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unit %d program %d is not valid\n"),
                       unitData->unit,
                       programId));
            return SOC_E_BADID;
        }
        soc_reg_field_set(unitData->unit,
                          RC_RESULTS_DEBUGr,
                          &resDebug,
                          CAPTURE_PROGRAM_NUMf,
                          programId);
    } /* if (result trace enabled but result trace from key disabled) */
    /* Set up trace control according to the flags */
    soc_reg_field_set(unitData->unit,
                      RC_TRACE_IF_LRP_CONTROLr,
                      &traceCtrl,
                      TP_ENABLEf,
                      (flags & SOC_C3_RCE_KEY_TRACE_ENABLE)?1:0);
    soc_reg_field_set(unitData->unit,
                      RC_TRACE_IF_LRP_CONTROLr,
                      &traceCtrl,
                      HALT_ENABLEf,
                      (flags & SOC_C3_RCE_KEY_TRACE_HALT)?1:0);
    if (flags & SOC_C3_RCE_KEY_TRACE_ENABLE) {
        if (0xFFFF < threshold) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unit %d trace threshold must be <= 0xFFFF\n"),
                       unitData->unit));
            return SOC_E_PARAM;
        }
        soc_reg_field_set(unitData->unit,
                          RC_TRACE_IF_LRP_CONTROLr,
                          &traceCtrl,
                          THRESHOLDf,
                          threshold);
    } /* if (key trace enabled) */
    /* Set up trace status according to the flags */
    soc_reg_field_set(unitData->unit,
                      RC_TRACE_IF_STATUSr,
                      &traceStat,
                      LRP_STATUSf,
                      1);
    /* Set up trace status mask according to the flags */
    soc_reg_field_set(unitData->unit,
                      RC_TRACE_IF_STATUS_MASKr,
                      &traceIntr,
                      LRP_STATUS_DISINTf,
                      (flags & SOC_C3_RCE_KEY_TRACE_INTERRUPT)?0:1);
    /* Set up the key data and mask for capture qualification */
    if (flags & SOC_C3_RCE_KEY_TRACE_ENABLE) {
        if (keyMask && keyData) {
            /* caller provided data+mask; check and then update both */
            for (offset = 54; offset < 64; offset++) {
                if (keyMask[offset]) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META("unit %d does not support key trace"
                               " qualified on key bits 432..511\n"),
                               unitData->unit));
                    return SOC_E_PARAM;
                }
            } /* for (offset = 54; offset < 64; offset++) */
            /* figure out the trace extras mask and verify it */
            traceMask = (keyMask[64] |
                         (keyMask[65] << 8) |
                         (keyMask[66] << 16) |
                         (keyMask[67] << 24));
            if (traceMask & (~0x0001FFFF)) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("unit %d does not support key trace extra"
                           " bits 17..31\n"),
                           unitData->unit));
                return SOC_E_PARAM;
            }
            traceMask = (~traceMask) & 0x0001FFFF;
            /* write the new key compare data and mask */
            for (index = 0, offset = 0; index < 14; index++) {
                if (index < 13) {
                    regTemp = (keyData[offset] |
                               (keyData[offset + 1] << 8) |
                               (keyData[offset + 2] << 16) |
                               (keyData[offset + 3] << 24));
                } else { /* if (index < 14) */
                    regTemp = (keyData[offset] |
                               (keyData[offset + 1] << 8));
                } /* if (index < 14) */
                result = soc_reg32_set(unitData->unit,
                                       _soc_c3_rce_debug_key_data[index],
                                       REG_PORT_ANY,
                                       0,
                                       regTemp);
                if (SOC_E_NONE != result) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META("unit %d unable to write trace key"
                               " data %u: %d (%s)\n"),
                               unitData->unit,
                               index,
                               result,
                               _SHR_ERRMSG(result)));
                    return result;
                }
                if (index < 13) {
                    regTemp = ~(keyMask[offset] |
                                (keyMask[offset + 1] << 8) |
                                (keyMask[offset + 2] << 16) |
                                (keyMask[offset + 3] << 24));
                    offset += 4;
                } else { /* if (index < 14) */
                    regTemp = ~(keyMask[offset] |
                                (keyMask[offset + 1] << 8));
                    regTemp &= 0x0000FFFF;
                    offset += 2;
                } /* if (index < 14) */
                result = soc_reg32_set(unitData->unit,
                                       _soc_c3_rce_debug_key_mask[index],
                                       REG_PORT_ANY,
                                       0,
                                       regTemp);
                if (SOC_E_NONE != result) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META("unit %d unable to write trace key"
                               " mask %u: %d (%s)\n"),
                               unitData->unit,
                               index,
                               result,
                               _SHR_ERRMSG(result)));
                    return result;
                }
            } /* for (index = 0, offset = 0; index < 15; index++) */
            /* skip the parts of the key that can not be compared  */
            offset = 64;
            /* now compute and write the trace key extra data */
            regTemp = (keyData[offset] |
                       (keyData[offset + 1] << 8) |
                       (keyData[offset + 2] << 16) |
                       (keyData[offset + 3] << 24));
            regTemp &= 0x0001FFFF;
            result = soc_reg32_set(unitData->unit,
                                   _soc_c3_rce_debug_key_data[index],
                                   REG_PORT_ANY,
                                   0,
                                   regTemp);
            if (SOC_E_NONE != result) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("unit %d unable to write trace key"
                           " data %u: %d (%s)\n"),
                           unitData->unit,
                           index,
                           result,
                           _SHR_ERRMSG(result)));
                return result;
            }
            /* write the trace key extra mask */
            result = soc_reg32_set(unitData->unit,
                                   _soc_c3_rce_debug_key_mask[index],
                                   REG_PORT_ANY,
                                   0,
                                   traceMask);
            if (SOC_E_NONE != result) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("unit %d unable to write trace key"
                           " mask %u: %d (%s)\n"),
                           unitData->unit,
                           index,
                           result,
                           _SHR_ERRMSG(result)));
                return result;
            }
        } else { /* if (keyMask && keyData) */
            /* caller did not provide data+mask; assume anything is allowed */
            for (index = 0; index < 15; index++) {
                result = soc_reg32_set(unitData->unit,
                                       _soc_c3_rce_debug_key_data[index],
                                       REG_PORT_ANY,
                                       0,
                                       0x00000000);
                if (SOC_E_NONE != result) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META("unit %d unable to write trace key"
                               " data %u: %d (%s)\n"),
                               unitData->unit,
                               index,
                               result,
                               _SHR_ERRMSG(result)));
                    return result;
                }
                result = soc_reg32_set(unitData->unit,
                                       _soc_c3_rce_debug_key_mask[index],
                                       REG_PORT_ANY,
                                       0,
                                       (index < 13)?0xFFFFFFFF:
                                       (index < 14)?0x0000FFFF:0x0001FFFF);
                if (SOC_E_NONE != result) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META("unit %d unable to write debug key"
                               " mask %u: %d (%s)\n"),
                               unitData->unit,
                               index,
                               result,
                               _SHR_ERRMSG(result)));
                    return result;
                }
            } /* for (index = 0; index < 15; index++) */
        } /* if (keyMask && keyData) */
    } /* if (flags & SOC_C3_RCE_KEY_TRACE_ENABLE) */
    /*
     *  Finally, set the trace control registers and reset the capture state.
     */
    result = soc_reg32_set(unitData->unit,
                           RC_TRACE_IF_STATUS_MASKr,
                           REG_PORT_ANY,
                           0,
                           traceIntr);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d unable to set trace state mask: %d (%s)\n"),
                   unitData->unit,
                   result,
                   _SHR_ERRMSG(result)));
        return result;
    }
    result = soc_reg32_set(unitData->unit,
                           RC_TRACE_IF_LRP_CONTROLr,
                           REG_PORT_ANY,
                           0,
                           traceCtrl);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d unable to set trace control: %d (%s)\n"),
                   unitData->unit,
                   result,
                   _SHR_ERRMSG(result)));
        return result;
    }
    result = soc_reg32_set(unitData->unit,
                           RC_RESULTS_DEBUGr,
                           REG_PORT_ANY,
                           0,
                           resDebug);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d unable to set results debug: %d (%s)\n"),
                   unitData->unit,
                   result,
                   _SHR_ERRMSG(result)));
        return result;
    }
    result = soc_reg32_set(unitData->unit,
                           RC_TRACE_IF_STATUSr,
                           REG_PORT_ANY,
                           0,
                           traceStat);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d unable to set trace state: %d (%s)\n"),
                   unitData->unit,
                   result,
                   _SHR_ERRMSG(result)));
        return result;
    }
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_debug_capture_get
 *  Purpose
 *    Get the debug capture configuration.
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (OUT) flags = where to put capture state flags
 *    (OUT) threshold = where to put key capture threshold value
 *    (OUT) threshCount = where to put current count toward threshold
 *    (OUT) keyData = where to put data values for key capture
 *    (OUT) keyMask = where to put mask values for key capture
 *    (OUT) programId = where to put program ID for result capture
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Gets the settings of the hardware assists for capturing results and keys.
 *
 *    See _soc_c3_rce_debug_capture_set for more notes and descriptions.
 *
 *    This does not reset the capture state, nor does it read it outside of the
 *    state that is reported by the flags.  Use _soc_c3_rce_debug_capture_parse
 *    to get the current capture information.
 */
static int
_soc_c3_rce_debug_capture_get(_soc_c3_rce_unit_desc_int_t *unitData,
                              uint32 *flags,
                              uint32 *threshold,
                              uint32 *threshCount,
                              uint8 *keyData,
                              uint8 *keyMask,
                              int *programId)
{
    unsigned int index;
    unsigned int offset;
    int result;
    uint32 resDebug;
    uint32 traceCtrl;
    uint32 traceStat;
    uint32 traceIntr;
    uint32 traceCnt;
    uint32 regTemp;

    /* Set up the results capture settings */
    result = soc_reg32_get(unitData->unit,
                           RC_RESULTS_DEBUGr,
                           REG_PORT_ANY,
                           0,
                           &resDebug);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d unable to read results debug: %d (%s)\n"),
                   unitData->unit,
                   result,
                   _SHR_ERRMSG(result)));
        return result;
    }
    result = soc_reg32_get(unitData->unit,
                           RC_TRACE_IF_LRP_CONTROLr,
                           REG_PORT_ANY,
                           0,
                           &traceCtrl);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d unable to read trace control: %d (%s)\n"),
                   unitData->unit,
                   result,
                   _SHR_ERRMSG(result)));
        return result;
    }
    result = soc_reg32_get(unitData->unit,
                           RC_TRACE_IF_STATUSr,
                           REG_PORT_ANY,
                           0,
                           &traceStat);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d unable to read trace state: %d (%s)\n"),
                   unitData->unit,
                   result,
                   _SHR_ERRMSG(result)));
        return result;
    }
    result = soc_reg32_get(unitData->unit,
                           RC_TRACE_IF_STATUS_MASKr,
                           REG_PORT_ANY,
                           0,
                           &traceIntr);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d unable to read trace state mask: %d (%s)\n"),
                   unitData->unit,
                   result,
                   _SHR_ERRMSG(result)));
        return result;
    }
    result = soc_reg32_get(unitData->unit,
                           RC_TRACE_IF_LRP_COUNTERr,
                           REG_PORT_ANY,
                           0,
                           &traceCnt);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d unable to read trace count: %d (%s)\n"),
                   unitData->unit,
                   result,
                   _SHR_ERRMSG(result)));
        return result;
    }
    *flags = 0;
    /* Parse result debug control flags & program ID */
    if (soc_reg_field_get(unitData->unit,
                          RC_RESULTS_DEBUGr,
                          resDebug,
                          CAPTURE_ENABLEf)) {
        (*flags) |= SOC_C3_RCE_RESULT_TRACE_ENABLE;
    }
    if (soc_reg_field_get(unitData->unit,
                          RC_RESULTS_DEBUGr,
                          resDebug,
                          CAPTURE_TRACE_KEYf)) {
        (*flags) |= SOC_C3_RCE_RESULT_TRACE_FROM_KEY;
    }
    if (soc_reg_field_get(unitData->unit,
                          RC_RESULTS_DEBUGr,
                          resDebug,
                          CAPTURE_STATUSf)) {
        (*flags) |= SOC_C3_RCE_RESULT_TRACE_CAPTURED;
    }
    *programId = soc_reg_field_get(unitData->unit,
                                   RC_RESULTS_DEBUGr,
                                   resDebug,
                                   CAPTURE_PROGRAM_NUMf);
    /* Parse trace control flags */
    if (soc_reg_field_get(unitData->unit,
                          RC_TRACE_IF_LRP_CONTROLr,
                          traceCtrl,
                          TP_ENABLEf)) {
        (*flags) |= SOC_C3_RCE_KEY_TRACE_ENABLE;
    }
    if (soc_reg_field_get(unitData->unit,
                          RC_TRACE_IF_LRP_CONTROLr,
                          traceCtrl,
                          HALT_ENABLEf)) {
        (*flags) |= SOC_C3_RCE_KEY_TRACE_HALT;
    }
    *threshold = soc_reg_field_get(unitData->unit,
                                   RC_TRACE_IF_LRP_CONTROLr,
                                   traceCtrl,
                                   THRESHOLDf);
    /* Parse trace status to the flags */
    if (soc_reg_field_get(unitData->unit,
                          RC_TRACE_IF_STATUSr,
                          traceStat,
                          LRP_STATUSf)) {
        (*flags) |= SOC_C3_RCE_KEY_TRACE_CAPTURED;
    }
    /* Parse trace status mask to the flags */
    if (0 == soc_reg_field_get(unitData->unit,
                               RC_TRACE_IF_STATUS_MASKr,
                               traceIntr,
                               LRP_STATUS_DISINTf)) {
        (*flags) |= SOC_C3_RCE_KEY_TRACE_INTERRUPT;
    }
    /* Parse trace count */
    *threshCount = soc_reg_field_get(unitData->unit,
                                     RC_TRACE_IF_LRP_COUNTERr,
                                     traceCnt,
                                     COUNTERf);
    for (offset = 0; offset < 68; offset++) {
        keyData[offset] = 0;
        keyMask[offset] = 0;
    }
    for (index = 0, offset = 0; index < 15; index++) {
        if (14 == index) {
            offset = 64;
        }
        result = soc_reg32_get(unitData->unit,
                               _soc_c3_rce_debug_key_data[index],
                               REG_PORT_ANY,
                               0,
                               &regTemp);
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unit %d unable to read trace key"
                       " data %u: %d (%s)\n"),
                       unitData->unit,
                       index,
                       result,
                       _SHR_ERRMSG(result)));
            return result;
        }
        keyData[offset++] = regTemp & 0xFF;
        regTemp >>= 8;
        keyData[offset++] = regTemp & 0xFF;
        if (index != 13) {
            regTemp >>= 8;
            keyData[offset++] = regTemp & 0xFF;
            regTemp >>= 8;
            keyData[offset++] = regTemp & 0xFF;
        } /* if (index < 13) */
        result = soc_reg32_get(unitData->unit,
                               _soc_c3_rce_debug_key_mask[index],
                               REG_PORT_ANY,
                               0,
                               &regTemp);
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("unit %d unable to read trace key"
                       " mask %u: %d (%s)\n"),
                       unitData->unit,
                       index,
                       result,
                       _SHR_ERRMSG(result)));
            return result;
        }
        keyMask[offset++] = regTemp & 0xFF;
        regTemp >>= 8;
        keyMask[offset++] = regTemp & 0xFF;
        if (index != 13) {
            regTemp >>= 8;
            keyMask[offset++] = regTemp & 0xFF;
            regTemp >>= 8;
            keyMask[offset++] = regTemp & 0xFF;
        } /* if (index < 13) */
    } /* for (index = 0, offset = 0; index < 14; index++) */
    return result;
}

/*
 *  Function
 *    _soc_c3_rce_result_hit_counter_read
 *  Purpose
 *    Read the value of one of the result hit counters
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) hitCounter = which hit counter to read
 *    (OUT) value = where to put the counter value
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Reads and resets the requested hit counter.
 *
 *    Hit counters 0..SOC_C3_RCE_RESULT_HIT_COUNTER_COUNT are the result range
 *    based hit counters.  Hit counter SOC_C3_RCE_RESULT_HIT_ANY_COUNTER is the
 *    'any hit' counter, and hit counter SOC_C3_RCE_RESULT_MISS_COUNTER is the
 *    'any miss' counter.
 *
 *    Note that the 'any hit' counter is incremented for each result that is
 *    not the default value, and the 'any miss' counter is incremented for each
 *    result that is the default value, and that there are *four* results
 *    possible for each search (so if a search normally returns one result on
 *    hit, the 'any hit' counter would go up one and the 'any miss' counter
 *    would go up three for such a hit (or would go up four for a miss).
 */
static int
_soc_c3_rce_result_hit_counter_read(_soc_c3_rce_unit_desc_int_t *unitData,
                                    int hitCounter,
                                    uint32 *value)
{
    if (SOC_C3_RCE_RESULT_MISS_COUNTER == hitCounter) {
        return soc_reg32_get(unitData->unit,
                             RC_RESULTS_NON_MATCH_CNTr,
                             REG_PORT_ANY,
                             0,
                             value);
    } else if (SOC_C3_RCE_RESULT_HIT_ANY_COUNTER == hitCounter) {
        return soc_reg32_get(unitData->unit,
                             RC_RESULTS_MATCH_CNTr,
                             REG_PORT_ANY,
                             0,
                             value);
    } else if ((0 <= hitCounter) &&
               (SOC_C3_RCE_RESULT_HIT_COUNTER_COUNT > hitCounter)) {
        return soc_reg32_get(unitData->unit,
                             RC_RESULTS_RULE_CNTr,
                             REG_PORT_ANY,
                             hitCounter,
                             value);
    } else {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d does not support hit counter %d\n"),
                   unitData->unit,
                   hitCounter));
        return SOC_E_PARAM;
    }
}

/*
 *  Function
 *    _soc_c3_rce_result_hit_counter_set
 *  Purpose
 *    Set the entries included by a particular hit counter
 *  Arguments
 *    (IN) unitData = pointer to unit data
 *    (IN) hitCounter = which hit counter to configure
 *    (IN) entryId0 = entry at one end of the set to include
 *    (IN) entryId1 = entry at the other end of the set to include
 *  Returns
 *    soc_result_t cast as int
 *      SOC_E_NONE if successful
 *      SOC_E_* appropriately otherwise
 *  Notes
 *    Sets the range of entries that will be considered by a particular hit
 *    counter.
 *
 *    The hardware actually uses the result value to trigger the hit counters.
 *    In order to have the behaviour make some reasonable kind of sense,
 *    therefore, the range of entries to be considered must be within the same
 *    filter set.  This is a little more strict than simply being in the same
 *    group, since (in theory) a group can span filter sets, but is required
 *    filter sets within a given group are not guaranteed to have contiguous
 *    blocks of result values.
 *
 *    Note the entries are considered sorted in priority order (the entry
 *    traverse API walks entries in this order) for the purposes of defining
 *    the range, so hits to all entries in the traversal from entryId0 through
 *    entryId1 (inclusive of both entryId0 and entryId1) will be counted.
 *
 *    The order for entryId0 and entryId1 does not matter here.  This function
 *    automatically sorts them so the range spans from the entry with the lower
 *    result value (higher priority) to the entry with the higher result value
 *    (lower priority).
 *
 *    WARNING: It is possible that any operation that adds/updates any entry to
 *    the hardware will invalidate the mapping between result and entry, since
 *    filter sets need to be moved around for certain updates.  If such an
 *    update occurs and the results are still important, this must be called
 *    again to update the internal state for the counter so it once again
 *    reflects the desired entries.
 *
 *    WARNING: Since the hardware matches based upon result (which is merely an
 *    index into an action table that is specific per program), it is entirely
 *    possible that entries in another program will also match.
 *
 *    WARNING: Not only does that apply to other programs, but it also applies
 *    to the program in question, if the program of interest offers multiple
 *    results.  It is possible that an entry will generate result 'x' on one
 *    result register and an entirely different entry will generate result 'x'
 *    on a different result register.  Apparently, these are indistinguishable
 *    for the purpose of this bit of hardware (but thankfully they are quite
 *    distinguishable to the LRP).
 *
 *    This does not allow setting of the 'all hit' or 'all miss' counters.
 *
 *    An error from this function may result in the requested counter's state
 *    being inconsistent.
 */
static int
_soc_c3_rce_result_hit_counter_set(_soc_c3_rce_unit_desc_int_t *unitData,
                                   int hitCounter,
                                   int entryId0,
                                   int entryId1)
{
    _soc_c3_rce_entry_desc_int_t *entry0;
    _soc_c3_rce_entry_desc_int_t *entry1;
    unsigned int index0;
    unsigned int index1;
    unsigned int prog0;
    unsigned int prog1;
    unsigned int fset0;
    unsigned int fset1;
    unsigned int temp;
    int result;
    uint8 lrpResult0;
    uint8 lrpResult1;

    if ((0 > hitCounter) ||
        (SOC_C3_RCE_RESULT_HIT_COUNTER_COUNT <= hitCounter)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d does not support hit counter %d\n"),
                   unitData->unit,
                   hitCounter));
        return SOC_E_PARAM;
    }
    entry0 = unitData->entryData[entryId0];
    entry1 = unitData->entryData[entryId1];
    if (entry0->entryGroup != entry1->entryGroup) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d entry %d group %d is not in the same group"
                   " as entry %d group %d\n"),
                   unitData->unit,
                   entryId0,
                   entry0->entryGroup,
                   entryId1,
                   entry1->entryGroup));
        return SOC_E_PARAM;
    }
    fset0 = entry0->entryPosition / C3_RCE_ENTRIES_PER_FILTER_SET;
    fset1 = entry1->entryPosition / C3_RCE_ENTRIES_PER_FILTER_SET;
    if (fset0 != fset1) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d entry %d is in filter set %u of group %d,"
                   " but entry %d is in filter set %u of group %d\n"),
                   unitData->unit,
                   entryId0,
                   fset0,
                   entry0->entryGroup,
                   entryId1,
                   fset1,
                   entry1->entryGroup));
        return SOC_E_PARAM;
    }
    result = _soc_c3_rce_entry_to_result(unitData,
                                         entryId0,
                                         &prog0,
                                         &index0,
                                         &lrpResult0);
    if (SOC_E_EMPTY == result) {
        LOG_WARN(BSL_LS_SOC_COMMON,
                 (BSL_META("unit %d entry %d is not installed\n"),
                  unitData->unit,
                  entryId0));
        result = SOC_E_NONE;
    }
    if (SOC_E_NONE != result) {
        /* called function displayed any other diagnostic */
        return result;
    }
    result = _soc_c3_rce_entry_to_result(unitData,
                                         entryId1,
                                         &prog1,
                                         &index1,
                                         &lrpResult1);
    if (SOC_E_EMPTY == result) {
        LOG_WARN(BSL_LS_SOC_COMMON,
                 (BSL_META("unit %d entry %d is not installed\n"),
                  unitData->unit,
                  entryId1));
        result = SOC_E_NONE;
    }
    if (SOC_E_NONE != result) {
        /* called function displayed any other diagnostic */
        return result;
    }
    if (index0 > index1) {
        temp = index0;
        index0 = index1;
        index1 = temp;
    }
    result = soc_reg32_set(unitData->unit,
                           RC_RESULTS_RULE_CNT_LO_CONFIGr,
                           REG_PORT_ANY,
                           hitCounter,
                           index0);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d unable to write hit counter %d low result"
                   " limit: %d (%s)\n"),
                   unitData->unit,
                   hitCounter,
                   result,
                   _SHR_ERRMSG(result)));
        return result;
    }
    result = soc_reg32_set(unitData->unit,
                           RC_RESULTS_RULE_CNT_HI_CONFIGr,
                           REG_PORT_ANY,
                           hitCounter,
                           index1);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META("unit %d unable to write hit counter %d high result"
                   " limit: %d (%s)\n"),
                   unitData->unit,
                   hitCounter,
                   result,
                   _SHR_ERRMSG(result)));
        return result;
    }
    return result;
}


/****************************************************************************
 *
 *  Exposed APIs implementation (see header file for explanations)
 */

int
soc_c3_rce_detach(int unit)
{
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,
                            "unit %d detach\n"),
                 unit));
    if ((0 > unit) || (unit >= SOC_MAX_NUM_DEVICES)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(_soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d not init\n"),
                   unit));
        /* accept valid unit detach quietly even if not initialised */
        return SOC_E_NONE;
    }
    return _soc_c3_rce_data_free(&(_soc_c3_rce[unit]));
}

int
soc_c3_rce_init(int unit)
{
    _soc_c3_rce_unit_desc_int_t *unitData = NULL;
    _soc_c3_rce_program_desc_int_t *progData;
    _soc_c3_rce_actions_desc_int_t *actionData;
    soc_sbx_caladan3_ucodemgr_t *ucodeMgr;
    const _soc_c3_rce_program_uc_desc_t *ucData = NULL;
    _soc_c3_rce_program_block_t *padInstr = NULL;
    _soc_c3_rce_instruction_t padSource;
    shr_mdb_elem_bank_index_t mdbfl[10];
    uint32 regData;
    uint32 instrData[3];
    uint8 *actionTemp = NULL;
    uint8 *ucp;
    unsigned int keyInstr[SOC_C3_RCE_PROGRAM_COUNT];
    unsigned int actionSize;
    unsigned int lrpEpochLength;
    unsigned int lrpClockDivide;
    unsigned int rceEpochLength;
    unsigned int rceClockDivide;
    unsigned int programCount;
    unsigned int groupLimit;
    unsigned int entryTotal;
    unsigned int index;
    unsigned int offset;
    unsigned int action;
    unsigned int allocSize;
    int lrpUsesSwitch2;
    int result = SOC_E_UNAVAIL;
    int auxRes;
    char resName[32];

    unsigned int entryLimit[(SOC_C3_RCE_PROGRAM_COUNT *
                             SOC_C3_RCE_RESULT_REGISTER_COUNT)];
    unsigned int actionLimit[(SOC_C3_RCE_PROGRAM_COUNT *
                              SOC_C3_RCE_RESULT_REGISTER_COUNT)];
    unsigned int entryBias[(SOC_C3_RCE_PROGRAM_COUNT *
                            SOC_C3_RCE_RESULT_REGISTER_COUNT)];
    uint8 actIndex[SOC_C3_RCE_PROGRAM_COUNT *
                   SOC_C3_RCE_RESULT_REGISTER_COUNT];
    const _soc_c3_rce_actions_uc_desc_t *actionTable[(SOC_C3_RCE_PROGRAM_COUNT *
                                                      SOC_C3_RCE_RESULT_REGISTER_COUNT)];
    _soc_c3_rce_actions_desc_int_t *actData;
    unsigned int actionTables;
    uint8 actValue[4];
    int actionSegment;


    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,
                            "unit %d init\n"),
                 unit));
    if ((0 > unit) || (unit >= SOC_MAX_NUM_DEVICES)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    actionSize = 0;
    if ((unitData = _soc_c3_rce[unit] /* assign intentional */)) {
        LOG_DEBUG(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d already init; detach first\n"),
                   unit));
        result = _soc_c3_rce_data_free(&unitData);
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unable to free existing unit %d resources\n"),
                       unit));
            unitData = NULL;
            goto error;
        }
    } /* if (the unit is already initialised) */
    LOG_DEBUG(BSL_LS_SOC_COMMON,
              (BSL_META_U(unit,
                          "unit %d retrieve LRP microcode info\n"),
               unit));
    /* retrieve microcode information via microcode manager */
    ucodeMgr = soc_sbx_caladan3_lr_ucodemgr_get(unit);
    if (!ucodeMgr) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unable to get unit %d microcode manager info\n"),
                   unit));
        result = SOC_E_INTERNAL;
        goto error;
    }
    result = C3Asm3__PkgInt__getTablePtr(unit, ucodeMgr->ucode,
                                         "RCE",
                                         (const void**)(&ucData));
    if (result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unable to get unit %d RCE data: %d\n"),
                   unit,
                   result));
        result = SOC_E_INTERNAL;
        goto error;
    }
    /* get LRP epoch length */
    result = soc_reg32_get(unit, LRA_CONFIG1r, REG_PORT_ANY, 0, &regData);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unable to get unit %d LRP epoch length\n"),
                   unit));
        goto error;
    }
    lrpEpochLength = soc_reg_field_get(unit,
                                       LRA_CONFIG1r,
                                       regData,
                                       EPOCH_LENGTHf);
    lrpEpochLength += C3_RCE_TIMING_LRP_EPOCH_BIAS;
    /* get LRP clock divide ratio */
    result = soc_reg32_get(unit,
                           CX_HPP_PLL_CHANNEL_0r,
                           REG_PORT_ANY,
                           0,
                           &regData);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unable to get unit %d LRP clock divide ratio\n"),
                   unit));
        goto error;
    }
    lrpClockDivide = soc_reg_field_get(unit,
                                       CX_HPP_PLL_CHANNEL_0r,
                                       regData,
                                       MDIVf);
    if (0 == lrpClockDivide) {
        /* this register does not seem to be set in the simulation; assume 3 */
        lrpClockDivide = 3;
    }
    /* get RCE clock divide ratio */
    result = soc_reg32_get(unit,
                           CX_HPP_PLL_CHANNEL_1r,
                           REG_PORT_ANY,
                           0,
                           &regData);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unable to get unit %d RCE clock divide ratio\n"),
                   unit));
        goto error;
    }
    rceClockDivide = soc_reg_field_get(unit,
                                       CX_HPP_PLL_CHANNEL_1r,
                                       regData,
                                       MDIVf);
    if (0 == rceClockDivide) {
        /* this register does not seem to be set in the simulation; assume 5 */
        rceClockDivide = 5;
    }
    /*
     *  Compute top-level clocks per LRP epoch by multiplying the LRP epoch
     *  length by the number of clocks per instruction (2) and then by the LRP
     *  clock divide ratio.  Then, convert top-level clocks into RCE clocks by
     *  dividing by the RCE clock divide ratio (truncating any remainder).
     */
    rceEpochLength = ((lrpEpochLength << 1) * lrpClockDivide) / rceClockDivide;
    /*
     *  Figure out how many programs we have, and also how many blocks are
     *  available in each program's action table (768 entries per block), and
     *  the total number of action blocks.
     */
    for (index = 0;
         index < (SOC_C3_RCE_PROGRAM_COUNT *
                  SOC_C3_RCE_RESULT_REGISTER_COUNT);
         index++) {
        actionTable[index] = NULL;
        entryLimit[index] = 0;
        actIndex[index] = ~0;
        entryBias[index] = 1;
    }
    for (index = 0, programCount = 0, actionTables = 0;
         index < SOC_C3_RCE_PROGRAM_COUNT;
         index++) {
        if (ucData[index].programFlags & _SOC_C3_RCE_PROGRAM_ENABLE) {
            /* account for this program being in use */
            programCount++;
            /* scan the action tables and copy/place them */
            for (action = 0;
                 action < SOC_C3_RCE_RESULT_REGISTER_COUNT;
                 action++) {
                /* this program uses this action */
                if (ucData[index].resTable[action]) {
                    /* see if this action table is already here */
                    for (offset = 0;
                         offset < actionTables;
                         offset++) {
                        if (actionTable[offset] ==
                            ucData[index].resTable[action]) {
                            /* points to same descriptor, so it is same */
                            
                            LOG_DEBUG(BSL_LS_SOC_COMMON,
                                      (BSL_META_U(unit,
                                                  "unit %d program %u result %u"
                                                   " refers to existing action"
                                                   " table %u (%s)\n"),
                                       unit,
                                       index,
                                       action,
                                       offset,
                                       ucData[index].resTable[action]->tableName));
                            break;
                        }
                    } /* for (all encountered action tables) */
                    if (offset >= actionTables) {
                        /* did not find it; use a new one */
                        offset = actionTables;
                        LOG_DEBUG(BSL_LS_SOC_COMMON,
                                  (BSL_META_U(unit,
                                              "unit %d program %u result %u"
                                               " refers to newly encountered"
                                               " action table %u (%s)\n"),
                                   unit,
                                   index,
                                   action,
                                   offset,
                                   ucData[index].resTable[action]->tableName));
                        actionTables++;
                        actionTable[offset] = ucData[index].resTable[action];
                        for (actionSegment = 0, allocSize = 0;
                             actionSegment < ucData[index].resTable[action]->ocmSegments;
                             actionSegment++) {
                            allocSize +=
                                ((ucData[index].resTable[action]->seg[actionSegment].bitsPerAction + 7) & (~7));
                        }
                        if (allocSize > actionSize) {
                            actionSize = allocSize;
                        }
                    } /* if (adding a new action table) */
                    /* keep track of which action table prog + result uses */
                    actIndex[(index *
                              SOC_C3_RCE_RESULT_REGISTER_COUNT) +
                             action] = offset;
                } /* if (this program uses this result register) */
            } /* for (all possible result registers) */
        } /* if (program is enabled) */
    } /* for (all RCE programs) */
    /*
     *  Compute initial entry bias to make access to the table more efficient.
     *  Specifically, since entry zero is reserved for 'miss' frames, ensure at
     *  least one OCM element is burned here, so that all blocks of entries
     *  will be aligned to an OCM element.  If an action table has a single
     *  entry taking more than one OCM element, it still needs to have an entry
     *  bias of at least one.
     */
    for (index = 0; index < actionTables; index++) {
        for (actionSegment = 0, entryBias[index] = 1;
             actionSegment < actionTable[index]->ocmSegments;
             actionSegment++) {
            if (entryBias[index] < actionTable[index]->seg[actionSegment].actionsPerElem) {
                entryBias[index] = actionTable[index]->seg[actionSegment].actionsPerElem;
            }
        }/* for (all OCM segments in this action table) */
    } /* for (all action tables) */
    /*
     *  Realign initial entry bias so every action table used by a particular
     *  program will be using the same initial bias.  Unhappily, it could take
     *  a few iterations for this to settle, but the worst result is that all
     *  action tables will have an initial bias of 64 entries, since this is
     *  the bit width of OCM.
     *
     *  Unless multiple programs share action tables, this should resolve in
     *  two iterations (one to adjust and one to check).  Even if all programs
     *  share all action tables, this should settle within a few iterations,
     *  with the largest bias value being 64 (assuming at least one action
     *  table is comprised of a single bit per entry).
     */
    do {
        result = FALSE; /* did not modify bias this pass */
        for (index = 0; index < programCount; index++) {
            auxRes = FALSE; /* did not modify bias yet */
            action = 0; /* but initial bias needs to be loaded */
            for (offset = 0;
                 offset < SOC_C3_RCE_RESULT_REGISTER_COUNT;
                 offset++) {
                if (((uint8)(~0)) !=
                    actIndex[(index *
                              SOC_C3_RCE_RESULT_REGISTER_COUNT) + offset]) {
                    if (action < entryBias[actIndex[(index *
                                                     SOC_C3_RCE_RESULT_REGISTER_COUNT) +
                                                    offset]]) {
                        result = auxRes;
                        auxRes = TRUE;
                        action = entryBias[actIndex[(index *
                                                     SOC_C3_RCE_RESULT_REGISTER_COUNT) +
                                                    offset]];
                    } /* if (this action table's bias is greater than temp) */
                } /* if (this program uses this action table) */
            } /* for (all possible result registers) */
            for (offset = 0;
                 result && (offset < SOC_C3_RCE_RESULT_REGISTER_COUNT);
                 offset++) {
                if (((uint8)(~0)) !=
                    actIndex[(index *
                              SOC_C3_RCE_RESULT_REGISTER_COUNT) + offset]) {
                    /* update this action table's bias to largest to far */
                    entryBias[actIndex[(index *
                                        SOC_C3_RCE_RESULT_REGISTER_COUNT) + offset]] = action;
                } /* if (this program uses this action table) */
            } /* for (all possible result registers) */
        } /* for (all active programs) */
    } while (result);
    /*
     *  Compute action table capacities, now considering the initial bias and
     *  the other configuration parameters for the table (such as whether the
     *  table uses action-indexed counters).
     */
    for (entryTotal = 0, offset = 0; offset < actionTables; offset++) {
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
        actionLimit[offset] -= entryBias[offset];
        if (actionTable[offset]->ctrRead) {
            /* action table uses action-indexed counters */
            allocSize = (actionTable[offset]->actionLimit - 1) /
                        (C3_RCE_ENTRIES_PER_FILTER_SET << 1);
            entryLimit[offset] = allocSize;
            if (entryLimit[offset] < 1) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "unit %d action table %u (%s) does not"
                                       " have enough space for at least one"
                                       " active filter set (has %u but needs"
                                       " %u (bias %u)\n"),
                           unit,
                           offset,
                           actionTable[offset]->tableName,
                           actionLimit[offset] + entryBias[offset],
                           entryBias[offset] +
                           (C3_RCE_ENTRIES_PER_FILTER_SET << 1),
                           entryBias[offset]));
                result = SOC_E_CONFIG;
                goto error;
            }
            actionLimit[offset] = allocSize;
            LOG_DEBUG(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unit %d action table %u (%s) uses"
                                   " action-indexed counters (%s), has an"
                                   " entry bias of %u, and has space for %u"
                                   " active filter sets (%u entries)\n"),
                       unit,
                       offset,
                       actionTable[offset]->tableName,
                       actionTable[offset]->ctrName,
                       entryBias[offset],
                       entryLimit[offset],
                       entryLimit[offset] *
                       C3_RCE_ENTRIES_PER_FILTER_SET));
        } else { /* if (action table uses action-indexed ctrs) */
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
            allocSize = (actionTable[offset]->actionLimit - 1) /
                        C3_RCE_ENTRIES_PER_FILTER_SET;
            entryLimit[offset] = allocSize;
            if (entryLimit[offset] < 2) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "unit %d action table %u (%s) does not"
                                       " have enough space for at least one"
                                       " active filter set and update (has %u"
                                       " but needs %u (bias %u)\n"),
                           unit,
                           offset,
                           actionTable[offset]->tableName,
                           actionLimit[offset] + entryBias[offset],
                           entryBias[offset] +
                           (C3_RCE_ENTRIES_PER_FILTER_SET << 1),
                           entryBias[offset]));
                result = SOC_E_CONFIG;
                goto error;
            }
            entryLimit[offset]--;
            actionLimit[offset] = allocSize;
            LOG_DEBUG(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unit %d action table %u (%s) does not use"
                                   " action-indexed counters, has an entry bias"
                                   " of %u, and has space for %u active filter"
                                   " sets (%u entries)\n"),
                       unit,
                       offset,
                       actionTable[offset]->tableName,
                       entryBias[offset],
                       entryLimit[offset],
                       entryLimit[offset] *
                       C3_RCE_ENTRIES_PER_FILTER_SET));
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
        } /* if (action table uses action-indexed ctrs) */
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
        /* update total entry blocks (updates by toggle) */
        entryTotal += entryLimit[offset];
    }
    /*
     *  It is possible that low line rates and other low-latency configuration
     *  settings will conspire to make the instruciton memory too small for
     *  the theoretical epoch length limit.  Try to deal with it in terms of
     *  the effective epoch length limit, but do so in a way that does not
     *  destroy the information about the other latencies we have.
     */
    if (rceEpochLength > (C3_RCE_IMEM_SIZE - C3_RCE_FILTER_SET_PADDING)) {
        LOG_WARN(BSL_LS_SOC_COMMON,
                 (BSL_META_U(unit,
                             "unit %d RCE epoch %u is longer than"
                              " instruction memory %u; reducing to fit\n"),
                  unit,
                  rceEpochLength,
                  C3_RCE_IMEM_SIZE - C3_RCE_FILTER_SET_PADDING));
        rceEpochLength = C3_RCE_IMEM_SIZE - C3_RCE_FILTER_SET_PADDING;
        LOG_WARN(BSL_LS_SOC_COMMON,
                 (BSL_META_U(unit,
                             "unit %d RCE adjusted effective epoch to %u\n"),
                  unit,
                  rceEpochLength));
    } /* if (epoch length > available program space) */
    /*
     *  It is surprisingly easy to try to set up a number of programs that
     *  will take longer to run than the epoch, particularly if the target
     *  line rate is 100Gb/s or if switch2 is not used, or both.
     *
     *  Make sure there is enough time in the epoch to run at least one
     *  expected-length filter set, plus the worst case padding, for each
     *  program.  All of this is configurable, to some degree, so some amount
     *  of cramming is possible, but much is rather unlikely.
     */
    index = (C3_RCE_FILTER_SET_PADDING +
             C3_RCE_FILTER_SET_LENGTH_PADDING +
             SOC_C3_RCE_GROUP_EXPECTED_LENGTH);
    offset = index * programCount;
    /*
     *  Since we can have no fewer than one filter set per group, and each
     *  block of entries amounts to a single filter set, we can have no more
     *  groups than there are available blocks of entries.
     */
    groupLimit = entryTotal;
#if defined(BROADCOM_DEBUG)
    /* display a bunch of basic information up front */
    for (index = 0; index < SOC_C3_RCE_PROGRAM_COUNT; index++) {
        if (ucData[index].programFlags & _SOC_C3_RCE_PROGRAM_ENABLE) {
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "RCE unit %d program %u (%s) mapped from LRP"
                                     " key set %08X\n"),
                         unit,
                         index,
                         ucData[index].programName,
                         ucData[index].tmuProg));
            for (offset = 0;
                 offset < SOC_C3_RCE_RESULT_REGISTER_COUNT;
                 offset++) {
                action = actIndex[(index *
                                   SOC_C3_RCE_RESULT_REGISTER_COUNT) |
                                  offset];
                if (action < (SOC_C3_RCE_PROGRAM_COUNT *
                              SOC_C3_RCE_RESULT_REGISTER_COUNT)) {
                    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                                (BSL_META_U(unit,
                                            "RCE unit %d program %u (%s) result"
                                             " register %u refers to action table"
                                             " %u (%s), %u blocks for %u entries\n"),
                                 unit,
                                 index,
                                 ucData[index].programName,
                                 offset,
                                 action,
                                 actionTable[action]->tableName,
                                 entryLimit[action],
                                 entryLimit[action] *
                                 C3_RCE_ENTRIES_PER_FILTER_SET));
                } /* if (index of action table is valid) */
            } /* for (all result registers) */
        } /* if (this program is enabled) */
    } /* for (all RCE programs) */
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,
                            "RCE unit %d maximum %u groups\n"),
                 unit,
                 groupLimit));
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,
                            "RCE unit %d action table capacity %u blocks"
                             " for %u entries\n"),
                 unit,
                 entryTotal,
                 entryTotal * C3_RCE_ENTRIES_PER_FILTER_SET));
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,
                            "RCE unit %d LRP epoch length %u instructions (%u"
                             " clocks) converts to RCE epoch length %u instructions"
                             " (%u clocks); clock ratio %u/%u\n"),
                 unit,
                 lrpEpochLength,
                 lrpEpochLength << 1,
                 rceEpochLength << 3,
                 rceEpochLength,
                 lrpClockDivide,
                 rceClockDivide));
#endif /* defined(BROADCOM_DEBUG) */
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,
                            "set up unit %d RCE resources and descriptions\n"),
                 unit));
    /* allocate unit descriptor */
    allocSize = ((sizeof(*unitData)) +
                 (sizeof(*(unitData->progData[0])) * programCount) +
                 (sizeof(*(unitData->actData[0])) * actionTables) +
                 (sizeof(*(unitData->groupData)) * groupLimit) +
                 (sizeof(*(unitData->rangeData)) * C3_RCE_RANGE_MAXIMUM) +
                 (sizeof(*(unitData->entryData)) * entryTotal *
                  C3_RCE_ENTRIES_PER_FILTER_SET));
    RCE_EVERB((RCE_MSG1("allocate %u bytes for unit %d description: %u base +"
                        " %u program * %u + %u action table * %u + %u group"
                        " * %u + %u range * %u + %u entry * %u\n"),
               allocSize,
               unit,
               (unsigned int)sizeof(*unitData),
               (unsigned int)sizeof(*(unitData->progData[0])),
               programCount,
               (unsigned int)sizeof(*(unitData->actData[0])),
               actionTables,
               (unsigned int)sizeof(*(unitData->groupData)),
               groupLimit,
               (unsigned int)sizeof(*(unitData->rangeData)),
               C3_RCE_RANGE_MAXIMUM,
               (unsigned int)sizeof(*(unitData->entryData)),
               entryTotal * C3_RCE_ENTRIES_PER_FILTER_SET));
    unitData = sal_alloc(allocSize, "RCE unit description");
    if (!unitData) {
        result = SOC_E_MEMORY;
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unable to allocate %u bytes for unit %d data\n"),
                   allocSize,
                   unit));
        goto error;
    }
    sal_memset(unitData, 0x00, allocSize);
    unitData->unit = unit;
    unitData->epochTime = (lrpEpochLength * (lrpClockDivide << 1));
    unitData->lrpClockDivide = lrpClockDivide;
    unitData->rceClockDivide = rceClockDivide;
    unitData->instrBlockCount = 0;
    unitData->groupLimit = groupLimit;
    unitData->groupData = (_soc_c3_rce_group_desc_int_t **)(&(unitData[1]));
    unitData->entryLimit = entryTotal * C3_RCE_ENTRIES_PER_FILTER_SET;
    unitData->rangeLimit = C3_RCE_RANGE_MAXIMUM;
    unitData->entryData = (_soc_c3_rce_entry_desc_int_t **)(&(unitData->groupData[groupLimit]));
    unitData->rangeData = (_soc_c3_rce_range_desc_int_t **)(&(unitData->entryData[unitData->entryLimit]));
    progData = (_soc_c3_rce_program_desc_int_t *)(&(unitData->rangeData[C3_RCE_RANGE_MAXIMUM]));
    for (index = 0, offset = 0; index < SOC_C3_RCE_PROGRAM_COUNT; index++) {
        if (ucData[index].programFlags & _SOC_C3_RCE_PROGRAM_ENABLE) {
            unitData->progData[index] = &(progData[offset]);
            offset++;
        }
    } /* for (each possible RCE program) */
    actionData = (_soc_c3_rce_actions_desc_int_t *)(&(progData[offset]));
    for (index = 0; index < actionTables; index++) {
        unitData->actData[index] = &(actionData[index]);
    }
    /*
     *  Instruction memory is managed by mdb because it allows some controls
     *  that should make defragmentation easier, can be expanded easily to keep
     *  a 'pending free' list if needed, and deals reasonably well with
     *  variable size blocks in 'best fit' placements.  Rather than using it
     *  through the resource manager (which is used for the action memory
     *  management), it is used directly so we gain access to its additonal
     *  features that are expected to be needed for such things as
     *  defragmentation of the instruction memory.
     */
    
    RCE_EVERB((RCE_MSG1("set up unit %d RCE instr mem block allocator\n"),
               unit));
    index = (C3_RCE_IMEM_SIZE - C3_RCE_FILTER_SET_PADDING) - 1;
    mdbfl[0] = 2;
    mdbfl[1] = 4;
    mdbfl[2] = 8;
    mdbfl[3] = 16;
    mdbfl[4] = 32;
    mdbfl[5] = 64;
    mdbfl[6] = 128;
    mdbfl[7] = 256;
    mdbfl[8] = 512;
    mdbfl[9] = 1024;
    result = shr_mdb_create(&unitData->imemRes,
                            2048 /* bank size */,
                            10 /* free lists */,
                            &(mdbfl[0]) /* list of free list sizes */,
                            0 /* user lists */,
                            0 /* low managed element number */,
                            index /* highest managed element number */,
                            FALSE /* caller will provide exclusion */);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unable to create unit %d RCE instruction memory"
                               " resource tracking: %d (%s)\n"),
                   unit,
                   result,
                   _SHR_ERRMSG(result)));
        goto error;
    }
    /* set up pointers to padding instruciton blocks */
    RCE_EVERB((RCE_MSG1("set up unit %d RCE padding instruction block list\n"),
               unit));
    for (index = C3_RCE_FILTER_SET_COUNT_PADDING - 1,
         offset = C3_RCE_IMEM_SIZE;
         index > 0;
         index--) {
        offset -= C3_RCE_FILTER_SET_LENGTH_PADDING;
        unitData->imemExtra[index] = offset;
    } /* for (all but index 0 of the padding filter sets) */
    offset -= C3_RCE_FILTER_SET_FIRST_PADDING;
    unitData->imemExtra[index] = offset;

    /* set up some space for initialising the 'default' actions */
    actionSize = ((actionSize + 31) & (~31)) >> 3;
    actionTemp = sal_alloc(actionSize, "default action init workspace");
    if (!actionTemp) {
        result = SOC_E_MEMORY;
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unable to allocate %u bytes for default action"
                               " init workspace\n"),
                   actionSize));
        goto error;
    }
    /* set up action memory block allocation management */
    unitData->actTableCount = actionTables;
    RCE_EVERB((RCE_MSG1("set up unit %d RCE action mem block allocator for"
                        " %u action tables\n"),
               unit,
               actionTables));
    result = shr_mres_create(&unitData->amemRes,
                             actionTables,
                             actionTables);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unable to create unit %d RCE action memory"
                               " resource tracking: %d (%s)\n"),
                   unit,
                   result,
                   _SHR_ERRMSG(result)));
        goto error;
    }
    /* set up details for each action table */
    for (index = 0; index < actionTables; index++) {
        actData = unitData->actData[index];
        actData->ucData = actionTable[index];
        actData->entryLimit = entryLimit[index];
        actData->firstEntryBias = entryBias[index];
        RCE_EVERB((RCE_MSG1("set up unit %d action table %u (%s) allocator,"
                            " %u blocks (%u available)\n"),
                   unit,
                   index,
                   actData->ucData->tableName,
                   actionLimit[index],
                   entryLimit[index]));
        sal_memset(&(resName[0]), 0x00, sizeof(resName));
        sal_snprintf(&(resName[0]),
                     31,
                     "RCE action table %u",
                     index);
        result = shr_mres_pool_set(unitData->amemRes,
                                   index,
                                   SHR_RES_ALLOCATOR_BITMAP,
                                   0 /* low element ID */,
                                   actionLimit[index],
                                   NULL /* extras */,
                                   &(resName[0]));
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unable to configure unit %d action memory"
                                   " resource pool for action table %u (%s):"
                                   " %d (%s)\n"),
                       unit,
                       index,
                       actData->ucData->tableName,
                       result,
                       _SHR_ERRMSG(result)));
            goto error;
        }
        result = shr_mres_type_set(unitData->amemRes,
                                   index /* which resource */,
                                   index /* which pool */,
                                   1 /* element size */,
                                   &(resName[0]));
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unable to configure unit %d action memory"
                                   " resource type for action table %u (%s):"
                                   " %d (%s)\n"),
                       unit,
                       index,
                       actData->ucData->tableName,
                       result,
                       _SHR_ERRMSG(result)));
            goto error;
        }

        actData->actionBytes = 0;
        for (actionSegment = 0; actionSegment < actionTable[index]->ocmSegments; actionSegment++) {
            actData->actionBytes += ((actionTable[index]->seg[actionSegment].bitsPerAction + 7) >> 3);
            if (actionTable[index]->seg[actionSegment].elemsPerAction) {
                if (1 < actionTable[index]->seg[actionSegment].actionsPerElem) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                                          "unit %d action table %u (%s) specifies"
                                           " nonzero OCM elements (%u) per action,"
                                           " but also specifies more than one"
                                           " action (%u) per OCM element.\n"),
                               unit,
                               index,
                               actionTable[index]->tableName,
                               actionTable[index]->seg[actionSegment].elemsPerAction,
                               actionTable[index]->seg[actionSegment].actionsPerElem));
                    result = SOC_E_CONFIG;
                    goto error;
                }
            } else if (0 == actionTable[index]->seg[actionSegment].actionsPerElem) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "unit %d action table %u (%s) specifies zero"
                                       " OCM elements per action but also specifies"
                                       " zero actions per OCM element\n"),
                           unit,
                           index,
                           actionTable[index]->tableName));
                result = SOC_E_CONFIG;
                goto error;
            }
        } /* for (all segments this action table) */

        for (action = 0;
             (socC3RceActionCount !=
              actionTable[index]->actions[action].action);
             action++) {
            if (action >= SOC_C3_RCE_PROGRAM_ACTION_MAX) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "unit %d action table %u (%s) specifies more"
                                       " than %u actions, but max is set to %u\n"),
                           unit,
                           index,
                           actionTable[index]->tableName,
                           SOC_C3_RCE_PROGRAM_ACTION_MAX,
                           SOC_C3_RCE_PROGRAM_ACTION_MAX));
                result = SOC_E_CONFIG;
                goto error;
            } /* if (action > SOC_C3_RCE_PROGRAM_ACTION_MAX) */
            actData->actionCount++;
#if (SOC_C3_RCE_MAX_SEG_PER_ACTION > 1)
            
#error "SOC_C3_RCE_MAX_SEG_PER_ACTION > 1 not yet supported"
#endif /* (SOC_C3_RCE_MAX_SEG_PER_ACTION > 1) */
            allocSize = (sizeof(soc_c3_rce_action_desc_t) +
                         (sizeof(int) * 2));
            RCE_EVERB((RCE_MSG1("set up unit %d action table %u (%s) action"
                                " %u information (alloc %u bytes first)\n"),
                       unit,
                       index,
                       actionTable[index]->tableName,
                       action,
                       allocSize));
            actData->actionData[action] = sal_alloc(allocSize,
                                                     "C3 RCE action info");
            if (!(actData->actionData[action])) {
                result = SOC_E_MEMORY;
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "unable to allocate %u bytes for action"
                                       " description\n"),
                           allocSize));
                goto error;
            }
            sal_memset(actData->actionData[action], 0x00, allocSize);
            actData->actionData[action]->actionType = socC3RCEActionType_bitfield;
            actData->actionData[action]->paramCount = 2;
            actData->actionData[action]->param = (int*)(&(actData->actionData[action][1]));
            actData->actionData[action]->param[0] = actionTable[index]->actions[action].loc[0].startBit;
            actData->actionData[action]->param[1] = actionTable[index]->actions[action].loc[0].startBit + actionTable[index]->actions[action].loc[0].numBits - 1;
        } /* for (each action in the actions list) */
        /* populate default action values for the action table */
        allocSize = actData->actionBytes;
        RCE_EVERB((RCE_MSG1("set up unit %d action table %u (%s) default"
                            " action values (alloc %u bytes first)\n"),
                   unit,
                   index,
                   actionTable[index]->tableName,
                   allocSize));
        actData->defaultActions = sal_alloc(allocSize,
                                            "C3 RCE default action values");
        if (!(actData->defaultActions)) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unable to allocate %u bytes for default"
                                   " action information\n"),
                       allocSize));
            result = SOC_E_MEMORY;
            goto error;
        }
        sal_memset(actData->defaultActions, 0x00, allocSize);
        for (action = 0; action < actData->actionCount; action++) {
            actValue[0] = actionTable[index]->actions[action].disableVal & 0xFF;
            actValue[1] = (actionTable[index]->actions[action].disableVal >>
                          8) & 0xFF;
            actValue[2] = (actionTable[index]->actions[action].disableVal >>
                          16) & 0xFF;
            actValue[3] = (actionTable[index]->actions[action].disableVal >>
                          24) & 0xFF;
            result = _soc_c3_rce_program_action_general_set(actData->actionData[action],
                                                            actValue,
                                                            actData->defaultActions);
            if (SOC_E_NONE != result) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "unable to set unit %d action table %u (%s)"
                                       " action %u default %u (%08X): %d (%s)\n"),
                           unit,
                           index,
                           actionTable[index]->tableName,
                           action,
                           actionTable[index]->actions[action].disableVal,
                           actionTable[index]->actions[action].disableVal,
                           result,
                           _SHR_ERRMSG(result)));
                goto error;
            }
        } /* for (each action in the actions list) */

        for (actionSegment = 0, offset = 0;
             actionSegment < actionTable[index]->ocmSegments;
             actionSegment++) {
            sal_memset(actionTemp, 0x00, actionSize);
#ifdef BCM_WARM_BOOT_SUPPORT
            if (!SOC_WARM_BOOT(unit)) {
#endif /* def BCM_WARM_BOOT_SUPPORT */
                /*
                 *  For a single entry, the OCM port write function expects the data to
                 *  be packed in the low byte(s) of a stream of quadbytes, with the
                 *  least significant quadbyte first, but the byte order seems to vary
                 *  according to the setting for the action table.
                 *
                 *  The 'miss' action is always zero since there is only one 'default'
                 *  value per program, and to put it elsewhere would require that all
                 *  of the action tables a program uses hold the actions for the same
                 *  number of entries.
                 */
                RCE_EVERB((RCE_MSG1("unit %d action table %u (%s) segment %u (%s) write"
                                    " default action values to 'miss' action %u:"),
                           unit,
                           index,
                           actionTable[index]->tableName,
                           actionSegment,
                           actionTable[index]->seg[actionSegment].segmentName,
                           0));

                for (allocSize = 0, action = 0;
                     allocSize < ((actionTable[index]->seg[actionSegment].bitsPerAction + 7) >> 3);
                     offset++, allocSize++) {
                    ((uint32*)actionTemp)[action] <<= 8;
                    ((uint32*)actionTemp)[action] |=
                        actData->defaultActions[offset ^
                            actData->ucData->seg[actionSegment].byteOrderMask];
                    RCE_EVERB((" %02X", actData->defaultActions[offset]));
                    if (3 == (allocSize & 3)) {
                        action++;
                    }
                }
                RCE_EVERB(("\n"));
                /*
                 *  Set default actions to the 'miss' entry in the table.  This is safe
                 *  to do whether running or not because these values are always what
                 *  should be in this table entry.
                 *
                 *  This must not be done when in warm boot mode.
                 */
                result = soc_sbx_caladan3_ocm_port_mem_write(unit,
                                 actionTable[index]->seg[actionSegment].ocmPort,
                                 actionTable[index]->seg[actionSegment].ocmSeg,
                                 0 /* first */,
                                 0 /* last */,
                                 (uint32*)actionTemp);
                if (SOC_E_NONE != result) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                                          "unable to set unit %d action"
                                          " table %u (%s) segment %u (%s)"
                                          " action table element %u:"
                                          " %d (%s)\n"),
                               unit,
                               index,
                               actionTable[index]->tableName,
                               actionSegment,
                               actionTable[index]->seg[actionSegment].segmentName,
                               0,
                               result,
                               _SHR_ERRMSG(result)));
                    goto error;
                }
#ifdef BCM_WARM_BOOT_SUPPORT
            } /* if (!SOC_WARM_BOOT(unit)) */
#endif /* def BCM_WARM_BOOT_SUPPORT */
            /*
             *  We also want to be sure about the table dimensions, but writing to
             *  other entries in the table is not always safe.  Instead, try to
             *  read the last entry from the table (we will overwrite it with the
             *  entry to be written to the next table, but we only want to be sure
             *  we can access what should be the last element of the table).
             */
            RCE_EVERB((RCE_MSG1("unit %d action table %u (%s) segment %u (%s)"
                                " verify access to action table element %u\n"),
                       unit,
                       index,
                       actionTable[index]->tableName,
                       actionSegment,
                       actionTable[index]->seg[actionSegment].segmentName,
                       actionTable[index]->actionLimit - 1));
            result = soc_sbx_caladan3_ocm_port_mem_read(unit,
                            actionTable[index]->seg[actionSegment].ocmPort,
                            actionTable[index]->seg[actionSegment].ocmSeg,
                            actionTable[index]->actionLimit - 1,
                            actionTable[index]->actionLimit - 1,
                            (uint32*)actionTemp);
            if (SOC_E_NONE != result) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "unable to read unit %d action table %u (%s)"
                                       " segment %u (%s) action table element %u:"
                                       " %d (%s)\n"),
                           unit,
                           index,
                           actionTable[index]->tableName,
                           actionSegment,
                           actionTable[index]->seg[actionSegment].segmentName,
                           actionTable[index]->actionLimit - 1,
                           result,
                           _SHR_ERRMSG(result)));
                goto error;
            }
        } /* for (all segments in this action table) */
    } /* for (index = 0; index < actionTables; index++) */
    /* set up details for each program */
    for (index = 0; index < SOC_C3_RCE_PROGRAM_COUNT; index++) {
        if (ucData[index].programFlags & _SOC_C3_RCE_PROGRAM_ENABLE) {
            progData = unitData->progData[index];
            progData->ucData = &(ucData[index]);
            progData->instrBlockAdded = C3_RCE_FILTER_SET_PADDING;
            progData->keyTime = ucodeMgr->ucode->m_inum + C3_LRP_KEY_DELAY_INSTRUCTIONS + 1;
            progData->switchTime = ucodeMgr->ucode->m_inum + 1;
            progData->keyToSwitch = ucodeMgr->ucode->m_inum + 1;
            unitData->instrBlockCount += C3_RCE_FILTER_SET_PADDING;
            for (offset = 0;
                 offset < SOC_C3_RCE_RESULT_REGISTER_COUNT;
                 offset++) {
                progData->actIndex[offset] = actIndex[((index *
                                                        SOC_C3_RCE_RESULT_REGISTER_COUNT) +
                                                       offset)];
            }
        } /* if (this RCE program is in use) */
    } /* for (each possible RCE program) */
    /*
     *  Since timing information requires knowledge of the LRP microcode, we
     *  need to read the LRP microcode and scan it for key instructions that
     *  would apply to the RCE and find corresponding switch instructions.
     *  We do that now because the RCE has been disabled at this point and we
     *  want to ensure any frames that might have used it will be passed before
     *  any other configuration changes are made.
     *
     *  This reads the entire microcode, not just the epoch length.  It is
     *  possible to extend the epoch, and so we need to scan everything.
     */
    
    lrpUsesSwitch2 = TRUE;
    for (index = 0; index < ucodeMgr->ucode->m_snum; index++) {
        /* reset all pending key/switch pairs */
        for (offset = 0; offset < SOC_C3_RCE_PROGRAM_COUNT; offset++) {
            keyInstr[offset] = ucodeMgr->ucode->m_inum + 1;
        }
        /* scan each instruction in this stream */
        action = ucodeMgr->ucode->m_inum * index * ucodeMgr->ucode->m_onum;
        for (offset = 0;
             offset < ucodeMgr->ucode->m_inum;
             offset++, action += ucodeMgr->ucode->m_onum) {
            /* get this instruction from the microcode information */
            ucp = &(ucodeMgr->ucode->m_code[action]);
            instrData[0] = PACK_INST(ucp[0], ucp[1], ucp[2], ucp[3]);
            instrData[1] = PACK_INST(ucp[4], ucp[5], ucp[6], ucp[7]);
            instrData[2] = PACK_INST(ucp[8], ucp[9], ucp[10], ucp[11]);
#if 0 
            RCE_EVERB(("LRP stream %d instr %03X = %08X %08X %08X",
                       index,
                       offset,
                       instrData[0],
                       instrData[1],
                       instrData[2]));
#endif 
            
            if ((0x07FC0000 == (instrData[0] & 0x1FFFFF00)) &&
                (0x00001F00 == (instrData[1] & 0x0007FF00)) &&
                (0x03E00000 == (instrData[2] & 0xFFE01CE0))) {
                /* this instruction is a 'key' instruction */
                regData = (instrData[2] & 0x1F);
#if 0 
                RCE_EVERB((" task %d key %d.%d \n",
                           (instrData[0] >> 29) & 0x7,
                           instrData[2] & 0x1F,
                           (instrData[2] >> 8) & 0x3));
#endif 
                if (0 == ((instrData[2] >> 8) & 0x3)) {
                    /* this instruction is the last of a key sequence */
                    for (allocSize = 0;
                         allocSize < SOC_C3_RCE_PROGRAM_COUNT;
                         allocSize++) {
                        if (unitData->progData[allocSize] &&
                            (unitData->progData[allocSize]->ucData->tmuProg & (1 << regData))) {
                            progData = unitData->progData[allocSize];
                            /* this key sequence points to this RCE program */
                            if (ucodeMgr->ucode->m_inum >= keyInstr[allocSize]) {
                                LOG_ERROR(BSL_LS_SOC_COMMON,
                                          (BSL_META_U(unit,
                                                      "Key at LRP stream %u"
                                                       " instruction %u refers to"
                                                       " pending RCE program %u\n"),
                                           index,
                                           offset,
                                           allocSize));
                                result = SOC_E_CONFIG;
                                goto error;
                            }
                            if ((progData->keyTime < ucodeMgr->ucode->m_inum) &&
                                (progData->keyTime != offset)) {
                                LOG_ERROR(BSL_LS_SOC_COMMON,
                                          (BSL_META_U(unit,
                                                      "unit %d program %u is"
                                                       " invoked multiple times\n"),
                                           unit,
                                           allocSize));
                                result = SOC_E_CONFIG;
                                goto error;
                            }
                            if (offset < progData->keyTime) {
                                /* this occurs earlier */
                                progData->keyTime = offset;
                            }
                            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                                        (BSL_META_U(unit,
                                                    "unit %d LRP stream %u"
                                                     " instruction %u refers to"
                                                     " RCE program %u\n"),
                                         unit,
                                         index,
                                         offset,
                                         allocSize));
                            /* key takes effect 3 instr later; mark it */
                            /* mark where key will take effect */
                            keyInstr[allocSize] = offset + 3;
                        } /* if (RCE program enabled an used by this key) */
                    } /* for (all possible RCE program) */
                } /* if (instruction is last of a key sequence) */
            } else if ((0x1C000000 == (instrData[0] & 0x1C3FFFFF)) &&
                       (0x00000000 == (instrData[1] & 0xFFFFFFFF)) &&
                       (0x00000000 == (instrData[2] & 0x00000000))) {
                /* this instruction is a 'switch' instruction */
#if 0 
                RCE_EVERB((" task %d switch\n",
                           (instrData[0] >> 29) & 0x7));
#endif 
                for (allocSize = 0;
                      allocSize < SOC_C3_RCE_PROGRAM_COUNT;
                      allocSize++) {
                    if (unitData->progData[allocSize] &&
                        (ucodeMgr->ucode->m_inum > keyInstr[allocSize])) {
                        progData = unitData->progData[allocSize];
                        /*
                         *  There is a pending reference to this program; if
                         *  the time between key and switch is smaller this
                         *  time than it has been before, use this time.
                         */
                        auxRes = offset - keyInstr[allocSize];
                        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                                    (BSL_META_U(unit,
                                                "unit %d LRP stream %u"
                                                 " instruction %u completes"
                                                 " RCE program %u reference"
                                                 " %d LRP instructions after"
                                                 " key instruction complete\n"),
                                     unit,
                                     index,
                                     offset,
                                     allocSize,
                                     auxRes));
                        if (auxRes < progData->keyToSwitch) {
                            progData->keyToSwitch = auxRes;
                            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                                        (BSL_META_U(unit,
                                                    "unit %d program %u new worst"
                                                     " case key to switch time %d\n"),
                                         unit,
                                         allocSize,
                                         auxRes));
                        } /* if (this interval is shorter than seen before) */
                        if (offset < progData->switchTime) {
                            /* this one is earlier */
                            progData->switchTime = offset;
                        }
                        keyInstr[allocSize] = ucodeMgr->ucode->m_inum + 1;
                        if (lrpUsesSwitch2 &&
                            (((instrData[0] >> 26) & 0xF) > 0xE)) {
                            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                                        (BSL_META_U(unit,
                                                    "unit %d has a switch for an"
                                                     " RCE program that is of the"
                                                     " switch-1 form; disabling"
                                                     " switch-2 mode\n"),
                                         unit));
                            lrpUsesSwitch2 = FALSE;
                        }
                    } /* if (RCE program enabled and pending key reference) */
                } /* for (all possible RCE program) */
#if 0 
            } else {
                RCE_EVERB(("\n"));
#endif 
            }
        } /* for (all instructions in this stream) */
    } /* for (all streams) */
    for (index = 0; index < SOC_C3_RCE_PROGRAM_COUNT; index++) {
        /*
         *  Multiply the 'instruction' numbers by the number of LRP clocks per
         *  instruction (2), times the LRP clock divide ratio, to adjust the
         *  instruction numbers to global clock numbers.
         */
        if (unitData->progData[index]) {
            progData = unitData->progData[index];
            if (progData->keyToSwitch < ((signed int)ucodeMgr->ucode->m_inum)) {
                /* adjust for global clocks */
                progData->keyToSwitch *= (lrpClockDivide << 1);
            } else {
                /* assume switch immediately follows key (global clocks) */
                progData->keyToSwitch = (-3 * (lrpClockDivide << 1));
            }
            if (progData->keyTime >= ucodeMgr->ucode->m_inum) {
                
                LOG_WARN(BSL_LS_SOC_COMMON,
                         (BSL_META_U(unit,
                                     "unit %d program %u not referenced by"
                                      " the LRP microcode; the program has no"
                                      " use and will be ignored for timing"
                                      " calculation (but it will still occupy"
                                      " physical resources)\n"),
                          unit,
                          index));
            }
            if (progData->switchTime >= ucodeMgr->ucode->m_inum) {
                
                LOG_WARN(BSL_LS_SOC_COMMON,
                         (BSL_META_U(unit,
                                     "unit %d program %u results not picked"
                                      " up by a switch during the epoch; implied"
                                      " result pickup will occur at first switch"
                                      " in following epoch\n"),
                          unit,
                          index));
            }
            /* correct timing for pipleine stages */
            progData->keyTime += C3_LRP_KEY_DELAY_INSTRUCTIONS;
            /* adjust other timing for global clocks */
            progData->keyTime *= (lrpClockDivide << 1);
            progData->switchTime *= (lrpClockDivide << 1);
        } /* if (program exists) */
        /* clear order list */
        unitData->progOrder[index] = 0xFF;
    } /* for (all possible programs) */
    if (lrpUsesSwitch2) {
        /*
         *  Using switch-2 does not help with epoch length, but it does help to
         *  hide key transfer and result transfer latencies, in particular if
         *  the LRP microcode does not have enough space between the key and
         *  switch instructions that apply to a particular program.
         *
         *  If the LRP is using switch-2, the timing calculations are modified
         *  to consider the additonal epoch as potential time during which the
         *  keys and results can be transferred.
         */
        unitData->unitFlags |= SOC_C3_RCE_UNIT_FLAGS_SWITCH2;
    }
    /* sort the programs by execution order */
    for (index = 0, regData = 0, allocSize = 0;
         index < SOC_C3_RCE_PROGRAM_COUNT;
         index++) {
        /* start at end of epoch */
        instrData[0] = ((ucodeMgr->ucode->m_inum + C3_LRP_KEY_DELAY_INSTRUCTIONS) *
                        (lrpClockDivide << 1));
        instrData[1] = ~0;
        /* scan unscanned programs for one that comes earlier */
        for (offset = 0; offset < SOC_C3_RCE_PROGRAM_COUNT; offset++) {
            if (unitData->progData[offset] &&
                (0 == (regData & (1 << offset)))) {
                /* this one has not been added to the order */
                if (unitData->progData[offset]->keyTime < instrData[0]) {
                    /* this one is earlier; track it instead */
                    instrData[0] = unitData->progData[offset]->keyTime;
                    instrData[1] = offset;
                } /* if (this program occurs earlier in the epoch) */
            } /* if (this program is not in the order yet) */
        } /* for (all possible programs) */
        if (~0 != instrData[1]) {
            /* found one; add to sequence and mark as found */
            unitData->progOrder[allocSize] = instrData[1];
            regData |= (1 << instrData[1]);
            allocSize++;
        } else {
            /* found no others; early out */
            break;
        }
    } /* for (all possible programs) */
    /* verify the baseline timing */
    result = _soc_c3_rce_program_length_check(unitData,
                                              0 /* flags */,
                                              ~0 /* program to adjust */,
                                              0 /* adjustment */,
                                              0 /* replacement padding */);
    if (SOC_E_NONE != result) {
        /* called function displayed diagnostics */
        goto error;
    }
#ifdef BCM_WARM_BOOT_SUPPORT
    /* we need the scache handle to be set */
    SOC_SCACHE_HANDLE_SET(unitData->scHandle,
                          unit,
                          SOC_SBX_WB_MODULE_RCE,
                          0);
    if (!SOC_WARM_BOOT(unit)) {
#endif /* def BCM_WARM_BOOT_SUPPORT */
        /*
         *  Now we know how much of everything we need and it's all set up.
         *  Initialise the hardware as the parameters suggest...
         */
        /* make sure we can safely reset the RCE hardware */
        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                                "ensure unit %d LRP is not using RCE\n"),
                     unit));
        result = _soc_c3_rce_lrp_program_configure(unitData, ~0, FALSE);
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unable to disable unit %d LRP use of RCE:"
                                  " %d (%s)\n"),
                       unit,
                       result,
                       _SHR_ERRMSG(result)));
            goto error;
        }
        /* wait for any remaining frames to pass */
        sal_sleep(1);
        /* put the RCE into reset */
        RCE_EVERB((RCE_MSG1("clear unit %d RCE soft_reset_n\n"), unit));
        result = soc_reg32_get(unit, RC_GLOBAL_CONFIGr, REG_PORT_ANY, 0, &regData);
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unable to get unit %d RC_GLOBAL_CONFIG state\n"),
                       unit));
            goto error;
        }
        soc_reg_field_set(unit, RC_GLOBAL_CONFIGr, &regData, SOFT_RESET_Nf, 0);
        result = soc_reg32_set(unit, RC_GLOBAL_CONFIGr, REG_PORT_ANY, 0, regData);
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unable to write unit %d"
                                  " RC_GLOBAL_CONFIG: %d (%s)\n"),
                       unit,
                       result,
                       _SHR_ERRMSG(result)));
        }
        RCE_EVERB((RCE_MSG1("wait for unit %d RCE soft_reset_n to clear\n"), unit));
        /* wait for up to 15 seconds for soft_reset_n bit to clear */
        sal_usleep(10000); /* but wait at least 10ms */
        for (index = 10; index < 15000; index++) {
            result = soc_reg32_get(unit,
                                   RC_GLOBAL_CONFIGr,
                                   REG_PORT_ANY,
                                   0,
                                   &regData);
            if (SOC_E_NONE != result) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "unable to get unit %d"
                                      " RC_GLOBAL_CONFIG: %d (%s)\n"),
                           unit,
                           result,
                           _SHR_ERRMSG(result)));
                goto error;
            }
            if (0 == soc_reg_field_get(unit,
                                       RC_GLOBAL_CONFIGr,
                                       regData,
                                       SOFT_RESET_Nf)) {
                RCE_EVERB((RCE_MSG1("unit %d RCE soft_reset_n clear after %d ms\n"),
                           unit,
                           index));
                break;
            }
            sal_usleep(1000);
        }
        RCE_EVERB((RCE_MSG1("set unit %d RCE soft_reset_n\n"), unit));
        result = soc_reg32_get(unit, RC_GLOBAL_CONFIGr, REG_PORT_ANY, 0, &regData);
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unable to get unit %d RC_GLOBAL_CONFIG state\n"),
                       unit));
            goto error;
        }
        soc_reg_field_set(unit, RC_GLOBAL_CONFIGr, &regData, SOFT_RESET_Nf, 1);
        result = soc_reg32_set(unit, RC_GLOBAL_CONFIGr, REG_PORT_ANY, 0, regData);
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unable to write unit %d"
                                  " RC_GLOBAL_CONFIG: %d (%s)\n"),
                       unit,
                       result,
                       _SHR_ERRMSG(result)));
        }
        RCE_EVERB((RCE_MSG1("wait for unit %d RCE soft_reset_n to set\n"), unit));
        /* wait for up to 15 seconds for soft_reset_n bit to set */
        for (index = 0; index < 15000; index++) {
            result = soc_reg32_get(unit,
                                   RC_GLOBAL_CONFIGr,
                                   REG_PORT_ANY,
                                   0,
                                   &regData);
            if (SOC_E_NONE != result) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "unable to get unit %d"
                                      " RC_GLOBAL_CONFIG state\n"),
                           unit));
                goto error;
            }
            if (0 != soc_reg_field_get(unit,
                                       RC_GLOBAL_CONFIGr,
                                       regData,
                                       SOFT_RESET_Nf)) {
                RCE_EVERB((RCE_MSG1("unit %d RCE soft_reset_n set after %u ms\n"),
                          unit,
                          index));
                break;
            }
            sal_usleep(1000);
        }
        if (0 == soc_reg_field_get(unit,
                                   RC_GLOBAL_CONFIGr,
                                   regData,
                                   SOFT_RESET_Nf)) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unit %d RCE soft_reset_n bit did not set\n"),
                       unit));
            result = SOC_E_FAIL;
            goto error;
        }
        RCE_EVERB((RCE_MSG1("initialise unit %d RCE memories\n"), unit));
        result = soc_reg32_get(unit,
                               RC_GLOBAL_DEBUGr,
                               REG_PORT_ANY,
                               0,
                               &regData);
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unable to get unit %d"
                                  " RC_GLOBAL_DEBUG state:\n"
                                  " %d (%s)\n"),
                       unit,
                       result,
                       _SHR_ERRMSG(result)));
            goto error;
        }
        soc_reg_field_set(unit,
                          RC_GLOBAL_DEBUGr,
                          &regData,
                          SBLK_CLK_GATING_DISABLEf,
                          1); /* CA3-2139 workaround requires this TRUE */
        soc_reg_field_set(unit, RC_GLOBAL_DEBUGr, &regData, MEM_INITf, 1);
        soc_reg_field_set(unit, RC_GLOBAL_DEBUGr, &regData, MEM_INIT_DONEf, 1);
        result = soc_reg32_set(unit,
                               RC_GLOBAL_DEBUGr,
                               REG_PORT_ANY,
                               0,
                               regData);
        if (SOC_E_NONE != result) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unable to set unit %d"
                                  " RC_GLOBAL_DEBUG state: %d (%s)\n"),
                       unit,
                       result,
                       _SHR_ERRMSG(result)));
            goto error;
        }
        RCE_EVERB((RCE_MSG1("wait for unit %d RCE mem init to finish\n"), unit));
        if (SAL_BOOT_PLISIM) {
            LOG_WARN(BSL_LS_SOC_COMMON,
                     (BSL_META_U(unit,
                                 "unit %d running in simulated environment;"
                                 " assume memory init complete\n"),
                      unit));
        } else { /* if (SAL_BOOT_PLISIM) */
            /* wait for up to 15 seconds for init_done bit to set */
            for (index = 0; index < 15000; index++) {
                result = soc_reg32_get(unit,
                                       RC_GLOBAL_DEBUGr,
                                       REG_PORT_ANY,
                                       0,
                                       &regData);
                if (SOC_E_NONE != result) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                                          "unable to get unit %d"
                                          " RC_GLOBAL_DEBUG: %d (%s)\n"),
                               unit,
                               result,
                               _SHR_ERRMSG(result)));
                    goto error;
                }
                if (0 != soc_reg_field_get(unit,
                                           RC_GLOBAL_DEBUGr,
                                           regData,
                                           MEM_INIT_DONEf)) {
                    RCE_EVERB((RCE_MSG1("unit %d RCE mem init done after %u ms\n"),
                               unit,
                               index));
                    break;
                }
                sal_usleep(1000);
            }
            if (0 == soc_reg_field_get(unit,
                                       RC_GLOBAL_DEBUGr,
                                       regData,
                                       MEM_INIT_DONEf)) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "unit %d RCE memry init failed"
                                      " to complete\n"),
                           unit));
                result = SOC_E_FAIL;
                goto error;
            }
        } /* if (SAL_BOOT_PLISIM) */
        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                                "configure unit %d RCE hardware\n"),
                     unit));
        /* set up 'padding' program blocks */
        allocSize = sizeof(*padInstr) * C3_RCE_FILTER_SET_FIRST_PADDING;
        RCE_EVERB((RCE_MSG1("allocate %u bytes for instr padding block space\n"),
                   allocSize));
        padInstr = soc_cm_salloc(unit,
                                 allocSize,
                                 "RCE instruction padding block workspace");
        if (!padInstr) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unable to allocate %u bytes"
                                  " imem/pattern space\n"),
                       allocSize));
            goto error;
        }
        COMPILER_64_SET(padSource, 0x000, 0x00000000); /* use no results */
        for (index = 0; index < C3_RCE_FILTER_SET_COUNT_PADDING; index++) {
            RCE_EVERB((RCE_MSG1("build unit %d RCE program padding %u\n"),
                       unit,
                       index));
            if (index) {
                offset = C3_RCE_FILTER_SET_LENGTH_PADDING - 1;
            } else {
                offset = C3_RCE_FILTER_SET_FIRST_PADDING - 1;
            }
            if (index < (C3_RCE_FILTER_SET_COUNT_PADDING - 1)) {
                action = unitData->imemExtra[index + 1];
            } else {
                action = ~0;
            }
            result = _soc_c3_rce_filter_set_build_instr(unitData,
                                                        1 /* num provided instrs */,
                                                        offset /* ending block */,
                                                        action /* next filter set */,
                                                        0xFFD00 /* action base */,
                                                        (0 == index),
                                                        &padSource,
                                                        NULL,
                                                        padInstr);
            if (SOC_E_NONE != result) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "unable to prepare unit %d RCE"
                                      " instruction padding block %u:"
                                      " %d (%s)\n"),
                           unit,
                           index,
                           result,
                           _SHR_ERRMSG(result)));
                goto error;
            }
            /* pattern is zeroed at this point and that is what we want */
            /* commit the new program segment to instruction memory */
            RCE_EVERB((RCE_MSG1("write unit %d RCE program padding %u (%u..%u;"
                                " %u..%u)\n"),
                        unit,
                        index,
                       unitData->imemExtra[index] << 5,
                       ((unitData->imemExtra[index] + offset) << 5) + 31,
                       unitData->imemExtra[index],
                       unitData->imemExtra[index] + offset));

            result = soc_cm_sflush(unitData->unit, padInstr, allocSize);
            if (SOC_E_NONE != result) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "unable to flush cache for"
                                      " instruction memory: %d (%s)\n"),
                           result,
                           _SHR_ERRMSG(result)));
                goto error;
            }
            result = soc_mem_write_range(unit,
                                         IMEM_PMEM_DMAm,
                                         MEM_BLOCK_ALL,
                                         unitData->imemExtra[index] << 5,
                                         ((unitData->imemExtra[index] + offset) << 5) + 31,
                                         padInstr);
            if (SOC_E_NONE != result) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "unable to write unit %d RCE"
                                      " instruction padding block %u:"
                                      " %d (%s)\n"),
                           unit,
                           index,
                           result,
                           _SHR_ERRMSG(result)));
                goto error;
            }
        } /*  for (index = 0; index < C3_RCE_FILTER_SET_COUNT_PADDING; index++) */
        /* configure active programs and set up any links to them */
        for (index = 0, programCount = 0;
             index < SOC_C3_RCE_PROGRAM_COUNT;
             index++) {
            regData = 0;
            progData = unitData->progData[index];
            if (ucData[index].programFlags & _SOC_C3_RCE_PROGRAM_ENABLE) {
                LOG_VERBOSE(BSL_LS_SOC_COMMON,
                            (BSL_META_U(unit,
                                        "unit %d RCE program %u"
                                        " (%s) enable\n"),
                             unit,
                             index,
                             ucData[index].programName));
                /* enable this program but point to padding for now */
                soc_reg_field_set(unit,
                                  RC_INSTCTRL_PROGRAM_CONFIGr,
                                  &regData,
                                  BASE_ADDRf,
                                  unitData->imemExtra[0]);
                soc_reg_field_set(unit,
                                  RC_INSTCTRL_PROGRAM_CONFIGr,
                                  &regData,
                                  ENf,
                                  1);
                soc_reg_field_set(unit,
                                  RC_INSTCTRL_PROGRAM_CONFIGr,
                                  &regData,
                                  MAX_LENGTHf,
                                  rceEpochLength);
            } else { /* if (this program is enabled) */
                /* don't enable this program */
                LOG_VERBOSE(BSL_LS_SOC_COMMON,
                            (BSL_META_U(unit,
                                        "unit %d RCE program %u disable\n"),
                             unit,
                             index));
                soc_reg_field_set(unit,
                                  RC_INSTCTRL_PROGRAM_CONFIGr,
                                  &regData,
                                  BASE_ADDRf,
                                  0x7FF);
                soc_reg_field_set(unit,
                                  RC_INSTCTRL_PROGRAM_CONFIGr,
                                  &regData,
                                  MAX_LENGTHf,
                                  1);
            } /* if (this program is enabled) */
            result = soc_reg32_set(unit,
                                   RC_INSTCTRL_PROGRAM_CONFIGr,
                                   REG_PORT_ANY,
                                   index,
                                   regData);
            if (SOC_E_NONE != result) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "unable to write unit %d RCE program"
                                      " %u config: %d (%s)\n"),
                           unit,
                           index,
                           result,
                           _SHR_ERRMSG(result)));
                goto error;
            }
            /*
             *  The default result for all programs is now zero.  This is
             *  because there is only one 'default result' per program, but it
             *  is possible that this result will be shared between action
             *  tables.  The only guaranteed common action table element (that
             *  all action tables will have) is zero.  Unhappily, this causes
             *  some minor complication in the code that determines the filter
             *  set ID from the position, but it is only a minor complication.
             *
             *  The default result must be set to all programs (even disabled
             *  programs) as part of CA3-2997 workaround.
             */
            allocSize = 0; /* always default to zero */
            regData = 0;
#if defined(BROADCOM_DEBUG)
            if (ucData[index].programFlags & _SOC_C3_RCE_PROGRAM_ENABLE) {
                LOG_VERBOSE(BSL_LS_SOC_COMMON,
                            (BSL_META_U(unit,
                                        "unit %d RCE program %u (%s) using"
                                        " LRP key set %08X, default result"
                                        " %u\n"),
                             unit,
                             index,
                             ucData[index].programName,
                             ucData[index].tmuProg,
                             allocSize));
            } else {
                LOG_VERBOSE(BSL_LS_SOC_COMMON,
                            (BSL_META_U(unit,
                                        "unit %d unused RCE program %u"
                                        " default result %u\n"),
                             unit,
                             index,
                             allocSize));
            }
#endif /* defined(BROADCOM_DEBUG) */
           soc_reg_field_set(unit,
                             RC_RESULTS_CONFIGr,
                             &regData,
                             DEFAULT_RULEf,
                             allocSize);
           result = soc_reg32_set(unit,
                                  RC_RESULTS_CONFIGr,
                                  REG_PORT_ANY,
                                  index,
                                  regData);
            if (SOC_E_NONE != result) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "unable to write unit %d RCE program %u"
                                      " result config: %d (%s)\n"),
                           unit,
                           index,
                           result,
                           _SHR_ERRMSG(result)));
                goto error;
            }
        } /* for (all RCE programs) */
        for (index = 0, programCount = 0;
             index < SOC_C3_RCE_PROGRAM_COUNT;
             index++) {
            if (ucData[index].programFlags & _SOC_C3_RCE_PROGRAM_ENABLE) {
                result = _soc_c3_rce_lrp_program_configure(unitData, index, TRUE);
                if (SOC_E_NONE != result) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                                          "unable to enable unit %d LRP"
                                          " program translation to point"
                                          " to RCE program %d: %d (%s)\n"),
                               unit,
                               index,
                               result,
                               _SHR_ERRMSG(result)));
                    goto error;
                }
            } /* if (this program is enabled) */
        } /* for (all RCE programs) */
#ifdef BCM_WARM_BOOT_SUPPORT
    } /* if (!SOC_WARM_BOOT(unit)) */
    /*
     *  Now deal with either setup of backing store or recovery of data from
     *  backing store (but do it in another file).
     */
    result = _soc_c3_rce_wb_init(unitData);
    if (SOC_E_NONE != result) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d unable to set up warm boot"
                              " backing store: %d (%s)\n"),
                   unit,
                   result,
                   _SHR_ERRMSG(result)));
        goto error;
    }
#endif /* def BCM_WARM_BOOT_SUPPORT */
    /* attach the unit information */
    _soc_c3_rce[unit] = unitData;
error:
    RCE_EVERB((RCE_MSG1("clean up init workspace\n")));
    if (SOC_E_NONE != result) {
        if (unitData) {
            auxRes = _soc_c3_rce_data_free(&unitData);
            if (SOC_E_NONE != auxRes) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "unable to free temporary unit %d"
                                       " descriptor: %d (%s)\n"),
                           unit,
                           auxRes,
                           _SHR_ERRMSG(auxRes)));
                /* but we already have an error, so don't return it */
            }
        } /* if (unitData) */
    } /* if (SOC_E_NONE != result) */
    if (padInstr) {
        soc_cm_sfree(unit, padInstr);
    }
    if (actionTemp) {
        sal_free(actionTemp);
    }
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,
                            "unit %d RCE init: %d (%s)\n"),
                 unit,
                 result,
                 _SHR_ERRMSG(result)));
    return result;
}


/*
 *  These macros are used to make soc_c3_rce_state_check easier to read
 */
#define SOC_C3_RCE_STATE_FAIL_CORRUPT \
    do { \
        if (SOC_E_NONE == result) { \
            /* replace non-err with invalid state err */ \
            result = SOC_E_INTERNAL; \
        } \
        if (flags & SOC_C3_RCE_STATE_CHECK_ABORT_CORRUPT) { \
            /* invalid states are fatal */ \
            goto error; \
        } \
    } while (0)
#define SOC_C3_RCE_STATE_FAIL_INVALID \
    do { \
        if (SOC_E_NONE == result) { \
            /* replace non-err with invalid state err */ \
            result = SOC_E_CONFIG; \
        } \
        if (flags & SOC_C3_RCE_STATE_CHECK_ABORT_INVALID) { \
            /* invalid states are fatal */ \
            goto error; \
        } \
    } while (0)
#define SOC_C3_RCE_STATE_FAIL_MISMATCH \
    do { \
        if (SOC_E_NONE == result) { \
            /* replace non-error state with mismatch error */ \
            result = SOC_E_FAIL; \
        } \
        if (flags & SOC_C3_RCE_STATE_CHECK_ABORT_MISMATCH) { \
            /* mismatches are fatal */ \
            goto error; \
        } \
    } while (0)
#define SOC_C3_RCE_STATE_FAIL_ERROR \
    do { \
        /* replace current status with error */ \
        result = auxRes; \
        if (flags & SOC_C3_RCE_STATE_CHECK_ABORT_ERRORS) { \
            /* hardware access errors are fatal */ \
            goto error; \
        } \
    } while (0)

int
soc_c3_rce_state_check(int unit, uint32 flags)
{
    shr_res_type_info_t mresInfo;       /* inormation for mres resources */
    shr_mdb_block_info_t mdbInfo;       /* MDB block information */
    uint8 *actData[SOC_C3_RCE_RESULT_REGISTER_COUNT][SOC_C3_RCE_MAX_OCM_SEG_PER_ACTION_TABLE];/* segmented action buffer */
    unsigned int actSize[SOC_C3_RCE_RESULT_REGISTER_COUNT][SOC_C3_RCE_MAX_OCM_SEG_PER_ACTION_TABLE];/* segment entry sizes */
    _soc_c3_rce_instruction_t rangeInstr; /* working range check instruction */
    _soc_c3_rce_instruction_t instrMask; /* working instruction mask */
    _soc_c3_rce_instruction_t instrTemp; /* working instruction */
    _soc_c3_rce_instruction_t instrEndf; /* end filter set bit for instr */
    _soc_c3_rce_unit_desc_int_t *unitData; /* working unit descriptor */
    _soc_c3_rce_program_desc_int_t *progData; /* working program descriptor */
    _soc_c3_rce_filterset_desc_int_t *fsetData; /* working fset descriptor */
    _soc_c3_rce_group_desc_int_t *groupData; /* working group descriptor */
    _soc_c3_rce_entry_desc_int_t *entryData; /* working entry descriptor */
    _soc_c3_rce_fset_range_info_t *rangeData; /* working range descriptor */
    _soc_c3_rce_entry_desc_int_t **entryList = NULL; /* work fset ent by pos */
    _soc_c3_rce_program_block_t *imemPmemTemp = NULL; /* working i+p mem blk */
    const _soc_c3_rce_actions_uc_desc_t *actTblData; /* action table data */
    uint32 *imemTemp = NULL;            /* imem reading buffer */
    uint8 *instrBlks = NULL;            /* bitmap of instruction blocks */
    uint8 *posEnable = NULL;            /* enable bits for each position */
    uint16 *rangeRefs = NULL;           /* range reference count space */
    uint8 *actBuffer = NULL;            /* action access buffer */
    unsigned int *actBlocksUsed = NULL; /* action table blocks in use */
    unsigned int actTableMaxSize;       /* max action table block size */
    unsigned int program;               /* current program */
    unsigned int groupId;               /* current group */
    unsigned int imemBlock;             /* current imem block */
    unsigned int imemFirst;             /* first imem block this filter set */
    unsigned int imemNext;              /* next filter set imem block */
    unsigned int imemTempSize;          /* size of imem temp cell */
    unsigned int filterSet;             /* current filter set in program */
    unsigned int filterSetLen;          /* current filter set length */
    unsigned int filterSetExpLen;       /* current fitler set expected len */
    unsigned int filterSetCnt;          /* filter sets in current program */
    unsigned int imemBlockCount;        /* number of imem blocks */
    unsigned int filterSetEntCount;     /* entries in this filter set */
    unsigned int filterSetLrpRegs;      /* filter set LRP registers bitmap */
    unsigned int filterSetRceRegs;      /* filter set RCE registers bitmap */
    unsigned int filterSetActBase;      /* filter set action table base */
    unsigned int groupEntryCount;       /* entry count for current group */
    unsigned int totGroupEntryCount;    /* total entry count by group */
    unsigned int totProgLength;         /* total program length for unit */
    unsigned int totEntryCount;         /* total active entry count for unit */
    unsigned int totGroupCount;         /* total groups in all programs */
    unsigned int progGroupCount;        /* total groups in program */
    unsigned int progEntryCount;        /* entries in program */
    unsigned int progMaxLen COMPILER_ATTRIBUTE((unused));            /* max instr blks for curr program */
    unsigned int progLength;            /* instr blks in current program */
    unsigned int progPadding;           /* instr blks in curr prog padding */
    unsigned int position;              /* position in filter set */
    unsigned int positionMax;           /* max position in filter set */
    unsigned int index;                 /* working index */
    unsigned int offset;                /* working offset */
    unsigned int rowOffset;             /* row offset in pattern memory */
    unsigned int byteOffset;            /* byte offset in pattern memory */
    unsigned int bitPosition;           /* position of bit within byte */
    int foundFsetEnd;                   /* flag indicating filter set ending */
    int foundProgEnd;                   /* flag indicating last filter set */
    int fsetIsPadding;                  /* which padding filter set if any */
    int auxRes;                         /* working result value */
    int prevGrpPrio;                    /* previous group priority */
    int prevEntPrio;                    /* previous entry priority */
    int result = SOC_E_NONE;            /* result to give caller */
    uint32 regValue;                    /* register temp space */
    uint32 regTemp;                     /* register temp space */
    uint8 data;                         /* temporary data workspace */
    uint8 mask;                         /* temporary mask workspace */

    if ((0 > unit) || (unit >= SOC_MAX_NUM_DEVICES)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        /* fatal */
        result = SOC_E_UNIT;
        goto error;
    }
    unitData = _soc_c3_rce[unit];
    if (!unitData) {
         LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        /* fatal */
        result = SOC_E_INIT;
        goto error;
    }

    /* allocate workspace */
    imemTempSize = sizeof(uint32) * soc_mem_entry_words(unitData->unit, IMEMm),
    imemTemp = sal_dma_alloc(imemTempSize, "instruction read buffer");
    if (!imemTemp) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d unable to allocate %u bytes for imem"
                              " read workspace\n"),
                   unit,
                   imemTempSize));
        /* fatal */
        result = SOC_E_MEMORY;
        goto error;
    }
    index = sizeof(*imemPmemTemp);
    imemPmemTemp = sal_dma_alloc(index, "instr+patt read buffer");
    if (!imemPmemTemp) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d unable to allocate %u bytes for"
                              " imem+pmem read workspace\n"),
                   unit,
                   index));
        /* fatal */
        result = SOC_E_MEMORY;
        goto error;
    }
    index = (C3_RCE_IMEM_SIZE + 7) >> 3;
    instrBlks = sal_alloc(index,  "bitmap for imem overlap checking");
    if (!instrBlks) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d unable to allocate %u bytes for imem"
                              " overlap checking\n"),
                   unit,
                   index));
        /* fatal */
        result = SOC_E_MEMORY;
        goto error;
    }
    sal_memset(instrBlks, 0x00, index);
    index = (2 * ((C3_RCE_ENTRIES_PER_FILTER_SET + 7) >> 3));
    posEnable = sal_alloc(index, "bitmap for tracking positional enables");
    if (!posEnable) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d unable to allocate %u bytes for"
                              " positional enables tracking\n"),
                   unit,
                   index));
        /* fatal */
        result = SOC_E_MEMORY;
        goto error;
    }
    index = sizeof(*entryList) * C3_RCE_ENTRIES_PER_FILTER_SET;
    entryList = sal_alloc(index, "pointer cache for entry references");
    if (!entryList) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d unable to allocate %u bytes for entry"
                              " pointer cache\n"),
                   unit,
                   index));
        /* fatal */
        result = SOC_E_MEMORY;
        goto error;
    }
    index = (sizeof(*rangeRefs) *
             C3_RCE_IMEM_SIZE *
             C3_RCE_IMEM_INSTR_PER_BLOCK *
             2);
    rangeRefs = sal_alloc(index, "range reference counting space");
    if (!rangeRefs) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d unable to allocate %u bytes for range"
                              " reference counting\n"),
                   unit,
                   index));
        /* fatal */
        result = SOC_E_MEMORY;
        goto error;
    }
    /* figure out how much we need for worst case action table reads */
    for (index = 0, actTableMaxSize = 0;
         index < unitData->actTableCount;
         index++) {
        actTableMaxSize += unitData->actData[index]->actionBytes;
    }
    actTableMaxSize *= C3_RCE_ENTRIES_PER_FILTER_SET;
    actBuffer = sal_alloc(actTableMaxSize, "action table read buffer");
    if (!actBuffer) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d unable to allocate %u bytes for action"
                              " table workspace\n"),
                   unit,
                   actTableMaxSize));
        /* fatal */
        result = SOC_E_MEMORY;
        goto error;
    }
    index = sizeof(*actBlocksUsed) * unitData->actTableCount;
    actBlocksUsed = sal_alloc(index, "Action table used block counts");
    if (!actBlocksUsed) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d unable to allcate %u bytes for action"
                              " table blocks used counters\n"),
                   unit,
                   index));
        result = SOC_E_MEMORY;
        goto error;
        /* fatal */
    }
    sal_memset(actBlocksUsed, 0x00, index);


    /* scan all programs */
    totProgLength = 0;
    totGroupCount = 0;
    totEntryCount = 0;
    imemBlockCount = 0;
    groupEntryCount = ~0; 
    prevEntPrio = (1 << ((sizeof(prevGrpPrio) * 8) - 1)); 
    for (program = 0;
         program < SOC_C3_RCE_PROGRAM_COUNT;
         program++) {
        auxRes = soc_reg32_get(unit,
                               RC_INSTCTRL_PROGRAM_CONFIGr,
                               REG_PORT_ANY,
                               program,
                               &regValue);
        if (SOC_E_NONE != auxRes) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unable to read program %u (%s) control"
                                  " register: %d (%s)\n"),
                       program,
                       unitData->progData[program]->ucData->programName,
                       auxRes,
                       _SHR_ERRMSG(auxRes)));
            SOC_C3_RCE_STATE_FAIL_ERROR;
            /* error reading from hardware, so skip this program */
            continue;
        }
        if (soc_reg_field_get(unit,
                              RC_INSTCTRL_PROGRAM_CONFIGr,
                              regValue,
                              ENf)) {
            /* this program is enabled in hardware */
            progData = unitData->progData[program];
            if (!progData) {
                /* ...but it is not enabled in software */
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "unit %d program %u is enabled in"
                                      " hardware but not in software\n"),
                           unit,
                           program));
                SOC_C3_RCE_STATE_FAIL_MISMATCH;
                /* program not enabled in driver, so nothing to compare */
                continue;
            }
            /* get first instruction block in program, and max length */
            imemNext = soc_reg_field_get(unit,
                                         RC_INSTCTRL_PROGRAM_CONFIGr,
                                         regValue,
                                         BASE_ADDRf);
            progMaxLen = soc_reg_field_get(unit,
                                           RC_INSTCTRL_PROGRAM_CONFIGr,
                                           regValue,
                                           MAX_LENGTHf);
            /* scan all filter sets for this program */
            filterSet = 0;
            filterSetCnt = 0;
            progLength = 0;
            progPadding = 0;
            progEntryCount = 0;
            progGroupCount = 0;
            prevGrpPrio = (int)((((unsigned int)1) << ((sizeof(int) * 8) - 1)) - 1);
            foundProgEnd = FALSE;
            do { /* while (!foundProgEnd) */
                imemBlock = imemNext;
                if (C3_RCE_IMEM_SIZE <= imemBlock) {
                    /* next block address is not valid */
                    if (0xFFF != imemBlock) {
                        /* but it must be 0xFFF to say end of program */
                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                  (BSL_META_U(unit,
                                              "unit %d program %u filter set"
                                              " %u HW invalid next filter set"
                                              " address of %03X\n"),
                                   unit,
                                   program,
                                   filterSet,
                                   imemBlock));
                        SOC_C3_RCE_STATE_FAIL_INVALID;
                    } /* if (0xFFF != imemBlock) */
                    /* nothing to parse here */
                    foundProgEnd = TRUE;
                    continue;
                } /* if (C3_RCE_IMEM_SIZE <= imemBlock) */
                /* this filter set exists at a valid place in hardware */
                for (index = 0, fsetIsPadding = 0;
                     index < C3_RCE_FILTER_SET_COUNT_PADDING;
                     index++) {
                    if (index) {
                        rowOffset = (unitData->imemExtra[index] +
                                     C3_RCE_FILTER_SET_LENGTH_PADDING);
                    } else {
                        rowOffset = (unitData->imemExtra[index] +
                                     C3_RCE_FILTER_SET_FIRST_PADDING);
                    }
                    if ((imemBlock >= unitData->imemExtra[index]) &&
                        (imemBlock < rowOffset)) {
                        /* this filter set is a padding filter set */
                        fsetIsPadding = index + 1;
                        break;
                    }
                } /* for (all padding filter set start instr blocks) */
                if (fsetIsPadding) {
                    /* this filter set is padding */
                    fsetData = NULL;
                    groupData = NULL;
                    if (filterSet < progData->filterSetCount) {
                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                  (BSL_META_U(unit,
                                              "unit %d program %u filter set"
                                              " %u should by SW be in a group"
                                              " but it is padding in HW\n"),
                                   unit,
                                   program,
                                   filterSet));
                        SOC_C3_RCE_STATE_FAIL_MISMATCH;
                    } /* if (filterSet < progData->filterSetCount) */
                    /* figure out how long filter set should be */
                    if (filterSet) {
                        filterSetExpLen = C3_RCE_FILTER_SET_LENGTH_PADDING;
                    } else {
                        filterSetExpLen = C3_RCE_FILTER_SET_FIRST_PADDING;
                    }
                } else { /* if (fsetIsPadding) */
                    if (filterSet < progData->filterSetCount) {
                        /* this filter set is valid */
                        fsetData = &(progData->fsetData[filterSet]);
                        groupData = unitData->groupData[fsetData->groupId];
                        filterSetCnt++;
                        imemBlockCount++;
                        if (imemBlock != fsetData->imemStart) {
                            LOG_ERROR(BSL_LS_SOC_COMMON,
                                      (BSL_META_U(unit,
                                                  "unit %d program %u filter"
                                                  " set %u HW start address"
                                                  " %03X disagrees with"
                                                  " SW %03X\n"),
                                       unit,
                                       program,
                                       filterSet,
                                       imemBlock,
                                       fsetData->imemStart));
                            SOC_C3_RCE_STATE_FAIL_MISMATCH;
                        }
                        if ((filterSet > 0) &&
                            (progData->fsetData[filterSet - 1].groupId ==
                             fsetData->groupId) &&
                            (progData->fsetData[filterSet - 1].filterIndex !=
                             (fsetData->filterIndex - 1))) {
                            LOG_ERROR(BSL_LS_SOC_COMMON,
                                      (BSL_META_U(unit,
                                                  "unit %d program %u filter"
                                                  " set %u (group %d filter"
                                                  " set %u) filter index does"
                                                  " not follow previous filter"
                                                  " set %d (group %d filter"
                                                  " set %u) correctly\n"),
                                       unit,
                                       program,
                                       filterSet,
                                       fsetData->groupId,
                                       fsetData->filterIndex,
                                       filterSet - 1,
                                       progData->fsetData[filterSet - 1].groupId,
                                       progData->fsetData[filterSet - 1].filterIndex));
                            SOC_C3_RCE_STATE_FAIL_CORRUPT;
                        }
                        if ((filterSet > 0) &&
                            (progData->fsetData[filterSet - 1].groupId !=
                             fsetData->groupId) &&
                            (fsetData->filterIndex != 0)) {
                            LOG_ERROR(BSL_LS_SOC_COMMON,
                                      (BSL_META_U(unit,
                                                  "unit %d program %u filter"
                                                  " set %u (group %d filter"
                                                  " set %u) filter index"
                                                  " should be zero\n"),
                                       unit,
                                       program,
                                       filterSet,
                                       fsetData->groupId,
                                       fsetData->filterIndex));
                            SOC_C3_RCE_STATE_FAIL_CORRUPT;
                        }
                        /* figure out how long filter set should be */
                        filterSetExpLen = groupData->instrBlocks;
                        if ((groupData->instrBlocks << 3) <
                            groupData->instrCount) {
                            LOG_ERROR(BSL_LS_SOC_COMMON,
                                      (BSL_META_U(unit,
                                                  "unit %d group %d claims %u"
                                                  " instructions but only has"
                                                  " space for %u instr\n"),
                                       unit,
                                       groupData->groupId,
                                       groupData->instrCount,
                                       groupData->instrBlocks << 3));
                            SOC_C3_RCE_STATE_FAIL_CORRUPT;
                        }
                        if ((groupData->instrBlocks << 3) >
                            groupData->instrCount) {
                            LOG_ERROR(BSL_LS_SOC_COMMON,
                                      (BSL_META_U(unit,
                                                  "unit %d group %d claims %u"
                                                  " instructions and yet has"
                                                  " space for %u instr\n"),
                                       unit,
                                       groupData->groupId,
                                       groupData->instrCount,
                                       groupData->instrBlocks << 3));
                            SOC_C3_RCE_STATE_FAIL_CORRUPT;
                        }
                        if (filterSet) {
                            if (filterSetExpLen <
                                C3_RCE_FILTER_SET_LENGTH_PADDING) {
                                filterSetExpLen = C3_RCE_FILTER_SET_LENGTH_PADDING;
                            }
                        } else {
                            if (filterSetExpLen <
                                C3_RCE_FILTER_SET_FIRST_PADDING) {
                                filterSetExpLen = C3_RCE_FILTER_SET_FIRST_PADDING;
                            }
                        }
                        /* will want to check range reference counts */
                        sal_memset(rangeRefs,
                                   0x00,
                                   sizeof(*rangeRefs) *
                                   ((groupData->rangesPerFilterSet + 1) << 1));
                        /* count entries for the group */
                        if (0 == fsetData->filterIndex) {
                            groupEntryCount = 0;
                            if (groupData->groupPriority > prevGrpPrio) {
                                LOG_ERROR(BSL_LS_SOC_COMMON,
                                          (BSL_META_U(unit,
                                                      "unit %d program %u"
                                                      " group %u priority %d"
                                                      " is greater than"
                                                      " previous group %u"
                                                      " priority %u in same"
                                                      " program\n"),
                                           unit,
                                           program,
                                           groupData->groupId,
                                           groupData->groupPriority,
                                           groupData->groupPrev?groupData->groupPrev->groupId:unitData->groupLimit,
                                           prevGrpPrio));
                                SOC_C3_RCE_STATE_FAIL_CORRUPT;
                            }
                            prevGrpPrio = groupData->groupPriority;
                            prevEntPrio = (int)((((unsigned int)1) << ((sizeof(int) * 8) - 1)) - 1);
                        }
                    } else { /* if (filterSet < progData->filterSetCount) */
                        /* this filter set should be but is not valid */
                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                  (BSL_META_U(unit,
                                              "unit %d program %u filter set"
                                              " %u at %03X is not in padding"
                                              " space, but is also not"
                                              " included in the program's"
                                              " filter sets (%u), so it will"
                                              " be treated as padding\n"),
                                   unit,
                                   program,
                                   filterSet,
                                   imemBlock,
                                   progData->filterSetCount));
                        /* force padding mode to avoid bad references */
                        fsetIsPadding = TRUE;
                        fsetData = NULL;
                        groupData = NULL;
                        /* figure out how long filter set should be */
                        if (filterSet) {
                            filterSetExpLen = C3_RCE_FILTER_SET_LENGTH_PADDING;
                        } else {
                            filterSetExpLen = C3_RCE_FILTER_SET_FIRST_PADDING;
                        }
                    } /* if (filterSet < progData->filterSetCount) */
                } /* if (fsetIsPadding) */
                imemFirst = imemBlock;
                filterSetLen = 0;
                foundFsetEnd = FALSE;
                imemNext = 0xFFF;
                filterSetLrpRegs = 0;
                filterSetRceRegs = 0;
                filterSetActBase = 0;
                filterSetEntCount = 0;
                /* scan through this filter set */
                do { /* while (!foundFsetEnd) */
                    /* check for unexpected cross-linking in imem/pmem */
                    if (0 == fsetIsPadding) {
                        if ((instrBlks[imemBlock >> 3]) &
                            (1 << (imemBlock & 0x7))) {
                            LOG_ERROR(BSL_LS_SOC_COMMON,
                                      (BSL_META_U(unit,
                                                  "unit %d program %u filter"
                                                  " set %u instruction block"
                                                  " %u uses already-used"
                                                  " instruction block %u\n"),
                                       unit,
                                       program,
                                       filterSet,
                                       filterSetLen,
                                       imemBlock));
                            SOC_C3_RCE_STATE_FAIL_INVALID;
                        }
                        instrBlks[imemBlock >> 3] |= (1 << (imemBlock & 0x7));
                    } /* if (0 == fsetIsPadding) */
                    /* read the instructions from imem */
                    sal_dma_flush(imemTemp, imemTempSize);
                    auxRes = soc_mem_read(unit,
                                          IMEMm,
                                          MEM_BLOCK_ANY,
                                          imemBlock,
                                          imemTemp);
                    if (SOC_E_NONE != auxRes) {
                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                  (BSL_META_U(unit,
                                              "unit %d program %u filter set"
                                              " %u unable to read instruction"
                                              " block %u at imem %u:"
                                              " %d (%s)\n"),
                                   unit,
                                   program,
                                   filterSet,
                                   filterSetLen,
                                   imemBlock,
                                   auxRes,
                                   _SHR_ERRMSG(auxRes)));
                        /* replace current status with error */
                        SOC_C3_RCE_STATE_FAIL_ERROR;
                        if (0 == filterSetLen) {
                            /*
                             *  Wanted to continue, but we can't read the first
                             *  instruction block of the filter set, and that
                             *  must contain the 'start' instruction, which
                             *  tells us where the next filter set begins.
                             *
                             *  We can try to scan the rest of this filter
                             *  set, but nothing more in this program.
                             */
                            LOG_ERROR(BSL_LS_SOC_COMMON,
                                      (BSL_META_U(unit,
                                                  "unit %d program %u filter"
                                                  " set %u unable to read"
                                                  " initial instruction"
                                                  " block\n"),
                                       unit,
                                       program,
                                       filterSet));
                            foundProgEnd = TRUE;
                            continue;
                        } else { /* if (0 == filterSetLen) */
                            /*
                             *  Not first instruction block, so we might be
                             *  able to skip it, but go ahead and treat this
                             *  block as if all zeroes for instructions.
                             */
                            sal_dma_inval(imemTemp, imemTempSize);
                            sal_memset(imemTemp,
                                       0x00,
                                       imemTempSize);
                            LOG_WARN(BSL_LS_SOC_COMMON,
                                     (BSL_META_U(unit,
                                                 "unit %d program %u filter"
                                                 " set %u instruction block"
                                                 " %u will be treated as all"
                                                 " zeroes for comparison\n"),
                                      unit,
                                      program,
                                      filterSet,
                                      filterSetLen));
                        } /* if (0 == filterSetLen) */
                        /*
                         *  Unhappily, even faking this can be a problem,
                         *  since we don't know whether to end here, so
                         *  assume it ends here if the state expects it to.
                         */
                        if ((filterSetLen + 1) >= fsetData->imemSize) {
                            LOG_WARN(BSL_LS_SOC_COMMON,
                                     (BSL_META_U(unit,
                                                 "unit %d program %u filter"
                                                 " set %u instruction block"
                                                 " %u expected in SW to have"
                                                 " end attribute, but unable"
                                                 " to read HW, so assuming"
                                                 " it does\n"),
                                      unit,
                                      program,
                                      filterSet,
                                      filterSetLen));
                            foundFsetEnd = TRUE;
                        }
                    } else { /* if (SOC_E_NONE != auxRes) */
                        sal_dma_inval(imemTemp, imemTempSize);
                    } /* if (SOC_E_NONE != auxRes) */
                    /* calculate start of this instr block in the filter set */
                    offset = filterSetLen * C3_RCE_IMEM_INSTR_PER_BLOCK;
                    /* scan the opcodes in this imem block */
                    for (index = 0;
                         index < C3_RCE_IMEM_INSTR_PER_BLOCK;
                         index++) {
                        /* get opcode */
                        soc_mem_field64_get(unitData->unit,
                                            IMEMm,
                                            imemTemp,
                                            _soc_c3_imem_fields[index],
                                            &instrTemp);
                        regValue = COMPILER_64_HI(instrTemp);
                        regTemp = (regValue >> 8) & 7;
                        if ((0 == (offset + index)) &&
                            (regTemp != _c3RCEOpcode_startFilter) &&
                            (regTemp != _c3RCEOpcode_startProgram)) {
                            LOG_ERROR(BSL_LS_SOC_COMMON,
                                      (BSL_META_U(unit,
                                                  "unit %d program %u filter"
                                                  " set %u HW instruction 0"
                                                  " %08X%08X is not a start"
                                                  " instruction\n"),
                                       unit,
                                       program,
                                       filterSet,
                                       COMPILER_64_HI(instrTemp),
                                       COMPILER_64_LO(instrTemp)));
                            SOC_C3_RCE_STATE_FAIL_INVALID;
                        }
                        /* check opcode */
                        switch (regTemp) {
                        case _c3RCEOpcode_prefix:
                            
                            /* nothing special to do for this opcode */
                            break;
                        case _c3RCEOpcode_nop:
                        case _c3RCEOpcode_data:
                        case _c3RCEOpcode_match0:
                        case _c3RCEOpcode_match1:
                            /* these opcodes can indicate end of filter set */
                            if (0 != (regValue & 0x80)) {
                                /* the EndF bit is set, so this is last blk */
                                foundFsetEnd = TRUE;
                            }
                            break;
                        case _c3RCEOpcode_startFilter:
                        case _c3RCEOpcode_startProgram:
                            /* these must always and only start filter sets */
                            if (0 != (offset + index)) {
                                LOG_ERROR(BSL_LS_SOC_COMMON,
                                          (BSL_META_U(unit,
                                                      "unit %d program %u"
                                                      " filter set %u HW instr"
                                                      " %u %08X%08X at %03X.%x"
                                                      " is misplaced start"
                                                      " instr\n"),
                                           unit,
                                           program,
                                           filterSet,
                                           offset + index,
                                           COMPILER_64_HI(instrTemp),
                                           COMPILER_64_LO(instrTemp),
                                           imemBlock,
                                           index));
                                SOC_C3_RCE_STATE_FAIL_INVALID;
                            }
                            if (0 == filterSet) {
                                /* initial filter set must use startProgram */
                                if (_c3RCEOpcode_startFilter == regTemp) {
                                    LOG_ERROR(BSL_LS_SOC_COMMON,
                                              (BSL_META_U(unit,
                                                          "unit %d program %u"
                                                          " filter set %u HW"
                                                          " has start filter"
                                                          " set instruction at"
                                                          " %03X.%X but should"
                                                          " have start"
                                                          " program\n"),
                                               unit,
                                               program,
                                               filterSet,
                                               imemBlock,
                                               index));
                                    SOC_C3_RCE_STATE_FAIL_INVALID;
                                }
                            } else { /* if (0 == filterSet) */
                                /* later filter set must use startFilter */
                                if (_c3RCEOpcode_startProgram == regTemp) {
                                    LOG_ERROR(BSL_LS_SOC_COMMON,
                                              (BSL_META_U(unit,
                                                          "unit %d program %u"
                                                          " filter set %u HW"
                                                          " has start program"
                                                          " instruction at"
                                                          " %03X.%X but should"
                                                          " have start"
                                                          " filter set\n"),
                                               unit,
                                               program,
                                               filterSet,
                                               imemBlock,
                                               index));
                                    SOC_C3_RCE_STATE_FAIL_INVALID;
                                }
                            } /* if (0 == filterSet) */
                            
                            regTemp = COMPILER_64_LO(instrTemp);
                            filterSetActBase = regTemp & 0xFFFFF;
                            filterSetLrpRegs = (regTemp >> 20) & 0xF;
                            filterSetRceRegs = (regTemp >>24) & 0xF;
                            imemNext = (((regValue & 0xFF) << 4) |
                                        ((regTemp >> 28) & 0xF));
                            if (C3_RCE_IMEM_SIZE <= imemNext) {
                                /* next block address is not valid */
                                if (0xFFF != imemNext) {
                                    /* but it must be 0xFFF to say end prog */
                                    LOG_ERROR(BSL_LS_SOC_COMMON,
                                              (BSL_META_U(unit,
                                                          "unit %d program %u"
                                                          " filter set %u HW"
                                                          " next filter set"
                                                          " address %03X is"
                                                          " invalid\n"),
                                               unit,
                                               program,
                                               filterSet,
                                               imemNext));
                                    SOC_C3_RCE_STATE_FAIL_INVALID;
                                } /* if (0xFFF != imemBlock) */
                                /*
                                 *  Even if the address is invalid rather than
                                 *  the specific end pointer value, end the
                                 *  program -- the hardware generates ECC
                                 *  faults if it falls off the end of memory
                                 *  and will abort anyway.
                                 */
                                foundProgEnd = TRUE;
                            } /* if (C3_RCE_IMEM_SIZE <= imemBlock) */
                            if ((filterSet + 1) < progData->filterSetCount) {
                                /* coverity[var_deref_op] */
                                if (imemNext != fsetData[1].imemStart) {
                                    /* next fset not at expected address */
                                    LOG_ERROR(BSL_LS_SOC_COMMON,
                                              (BSL_META_U(unit,
                                                          "unit %d program %u"
                                                          " filter set %u HW"
                                                          " next filter set ptr"
                                                          " %03X but SW has"
                                                          " %03X\n"),
                                               unit,
                                               program,
                                               filterSet,
                                               imemNext,
                                               fsetData[1].imemStart));
                                    SOC_C3_RCE_STATE_FAIL_MISMATCH;
                                }
                            } else { /* if (there are more filter sets) */
                                
                                if (0xFFF != imemNext) {
                                    for (rowOffset = 0;
                                         rowOffset < C3_RCE_FILTER_SET_COUNT_PADDING;
                                         rowOffset++) {
                                        if (imemNext ==
                                            unitData->imemExtra[rowOffset]) {
                                            break;
                                        }
                                    }
                                    if (C3_RCE_FILTER_SET_COUNT_PADDING <=
                                        rowOffset) {
                                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                                  (BSL_META_U(unit,
                                                              "unit %d program"
                                                              " %u final filter"
                                                              " set %u pointer"
                                                              " %03X indicates"
                                                              " more program"
                                                              " but does not"
                                                              " point to valid"
                                                              " padding\n"),
                                                   unit,
                                                   program,
                                                   filterSet,
                                                   imemNext));
                                        SOC_C3_RCE_STATE_FAIL_INVALID;
                                    }
                                } /* if (next fset pointer is not EOP) */
                            } /* if (there are more filter sets) */
                            if (groupData) {
                                /* in a group, check result registers */
                                if (filterSetLrpRegs !=
                                    groupData->resultLrp) {
                                    /* wrong LRP registers */
                                    LOG_ERROR(BSL_LS_SOC_COMMON,
                                              (BSL_META_U(unit,
                                                          "unit %d program %u"
                                                          " filter set %u"
                                                          " (group %d) HW LRP"
                                                          " result registers"
                                                          " %1X but SW"
                                                          " has %1X\n"),
                                               unit,
                                               program,
                                               filterSet,
                                               groupData->groupId,
                                               filterSetLrpRegs,
                                               groupData->resultLrp));
                                    SOC_C3_RCE_STATE_FAIL_MISMATCH;
                                } /* if (LRP result registers mismatch) */
                                if (filterSetRceRegs !=
                                    groupData->resultRce) {
                                    /* wrong RCE registers */
                                    LOG_ERROR(BSL_LS_SOC_COMMON,
                                              (BSL_META_U(unit,
                                                          "unit %d program %u"
                                                          " filter set %u"
                                                          " (group %d) HW RCE"
                                                          " result registers"
                                                          " %1X but SW"
                                                          " has %1X\n"),
                                               unit,
                                               program,
                                               filterSet,
                                               groupData->groupId,
                                               filterSetRceRegs,
                                               groupData->resultRce));
                                    SOC_C3_RCE_STATE_FAIL_MISMATCH;
                                } /* if (RCE result registers mismatch) */
                            } else { /* if (groupData) */
                                /* not in a group, should return no result */
                                if (filterSetLrpRegs) {
                                    LOG_ERROR(BSL_LS_SOC_COMMON,
                                              (BSL_META_U(unit,
                                                          "unit %d program %u"
                                                          " filter set %u"
                                                          " (padding) HW"
                                                          " returns results"
                                                          " in LRP regs %1X"
                                                          " but should not"
                                                          " return results\n"),
                                               unit,
                                               program,
                                               filterSet,
                                               filterSetLrpRegs));
                                    SOC_C3_RCE_STATE_FAIL_CORRUPT;
                                }
                                if (filterSetRceRegs) {
                                    LOG_ERROR(BSL_LS_SOC_COMMON,
                                              (BSL_META_U(unit,
                                                          "unit %d program %u"
                                                          " filter set %u"
                                                          " (padding) HW"
                                                          " returns results"
                                                          " in RCE regs %1X"
                                                          " but should not"
                                                          " return results\n"),
                                               unit,
                                               program,
                                               filterSet,
                                               filterSetLrpRegs));
                                    SOC_C3_RCE_STATE_FAIL_CORRUPT;
                                }
                                if (0xFFD00 != filterSetActBase) {
                                    LOG_ERROR(BSL_LS_SOC_COMMON,
                                              (BSL_META_U(unit,
                                                          "unit %d program %u"
                                                          " filter set %u"
                                                          " (padding) HW action"
                                                          " table base is %u"
                                                          " but should be"
                                                          " %u\n"),
                                               unit,
                                               program,
                                               filterSet,
                                               filterSetActBase,
                                               (unsigned int)0xFFD00));
                                    SOC_C3_RCE_STATE_FAIL_CORRUPT;
                                }
                            } /* if (groupData) */
                            break;
                        default:
                            /* there is one possible invalid opcode */
                            LOG_ERROR(BSL_LS_SOC_COMMON,
                                      (BSL_META_U(unit,
                                                  "unit %d program %u filter"
                                                  " set %u HW instruction %u"
                                                  " at imem %03X.%1X is"
                                                  " invalid\n"),
                                       unit,
                                       program,
                                       filterSet,
                                       offset + index,
                                       imemBlock,
                                       index));
                            SOC_C3_RCE_STATE_FAIL_INVALID;
                        } /* switch (regTemp) */
                        /* we already checked 'start' instr, so check others */
                        if (offset + index) {
                            if (groupData) {
                                /*
                                 *  We are looking at a filter set that should
                                 *  be in a group, and have already checked the
                                 *  first instruction.
                                 */
                                if ((offset + index) <=
                                    groupData->rangesPerFilterSet) {
                                    /*
                                     *  Ranges will vary per filter set, so the
                                     *  expected values need to be calculated,
                                     *  but we only have range information for
                                     *  filter sets in groups (no other filter
                                     *  sets should have range references,
                                     *  though).
                                     */
                                    rangeData = &(fsetData->rangeInfo[offset + index - 1]);
                                    if (rangeData->rangeId) {
                                        /*
                                         *  This range is in use and should
                                         *  have been committed to hardware.
                                         */
                                        if (rangeData->rangeFlags &
                                            _SOC_C3_RCE_RANGE_FLAG_MATCH_INVERTED) {
                                            /* range needs to be inverted */
                                            COMPILER_64_SET(rangeInstr,
                                                            (_c3RCEOpcode_match0 << 8) |
                                                            (_c3RCEPredicate_Range << 5) |
                                                            ((rangeData->rangeFlags >> 11) & 0x1F),
                                                            (rangeData->upperLimit << 16) |
                                                            rangeData->lowerLimit);
                                        } else {
                                            /* range needs to be normal */
                                            COMPILER_64_SET(rangeInstr,
                                                            (_c3RCEOpcode_match1 << 8) |
                                                            (_c3RCEPredicate_Range << 5) |
                                                            ((rangeData->rangeFlags >> 11) & 0x1F),
                                                            (rangeData->upperLimit << 16) |
                                                            rangeData->lowerLimit);
                                        }
                                    } else if ((offset + index) <
                                               groupData->instrCount) {
                                        /*
                                         *  Normally the instruction in the
                                         *  group template should be NOP, but
                                         *  get the actual instruction from the
                                         *  group template just to be sure.
                                         */
                                        rangeInstr = groupData->instr[(offset +
                                                                       index)];
                                    } else {
                                        /*
                                         *  Anything beyond the group template
                                         *  is padding because the group
                                         *  template was too short.
                                         */
                                        COMPILER_64_SET(rangeInstr,
                                                        (_c3RCEOpcode_nop << 8),
                                                        0x00000000);
                                    }
                                    if ((filterSetLen + 1) >= filterSetExpLen) {
                                        /*
                                         *  The last block of instructions in a
                                         *  filter set must have at least one
                                         *  instruction with the 'endf' bit
                                         *  set, but this bit can only be set
                                         *  for certain instructions.  Happily,
                                         *  most instructions can have it set,
                                         *  and we will set it for all such
                                         *  instructions in the last
                                         *  instruction block.
                                         */
                                        switch (COMPILER_64_HI(rangeInstr) >> 8 & 0x7) {
                                        case _c3RCEOpcode_nop:
                                        case _c3RCEOpcode_data:
                                        case _c3RCEOpcode_match0:
                                        case _c3RCEOpcode_match1:
                                            COMPILER_64_SET(instrMask,
                                                            0x000007FF,
                                                            0xFFFFFFFF);
                                            COMPILER_64_SET(instrEndf,
                                                            0x080,
                                                            0x00000000);
                                            break;
                                        default:
                                            COMPILER_64_SET(instrMask,
                                                            0x000007FF,
                                                            0xFFFFFFFF);
                                            COMPILER_64_SET(instrEndf,
                                                            0x000,
                                                            0x00000000);
                                        }
                                    } else {
                                        /*
                                         *  No block of instructions other than
                                         *  the last one of a filter set may
                                         *  have the 'endf' bit set for any
                                         *  instruction.
                                         */
                                        switch (COMPILER_64_HI(rangeInstr) >> 8 & 0x7) {
                                        case _c3RCEOpcode_nop:
                                        case _c3RCEOpcode_data:
                                        case _c3RCEOpcode_match0:
                                        case _c3RCEOpcode_match1:
                                            COMPILER_64_SET(instrMask,
                                                            0x0000077F,
                                                            0xFFFFFFFF);
                                            COMPILER_64_SET(instrEndf,
                                                            0x000,
                                                            0x00000000);
                                            break;
                                        default:
                                            COMPILER_64_SET(instrMask,
                                                            0x000007FF,
                                                            0xFFFFFFFF);
                                            COMPILER_64_SET(instrEndf,
                                                            0x000,
                                                            0x00000000);
                                        }
                                    }
                                    COMPILER_64_AND(rangeInstr, instrMask);
                                    COMPILER_64_OR(rangeInstr, instrEndf);
                                    if (rangeData->commitCount &&
                                        COMPILER_64_NE(instrTemp, rangeInstr)) {
                                        /*
                                         *  We only compare this if there are
                                         *  committed references.  It is
                                         *  possible that the instruction is in
                                         *  place from a former update that
                                         *  might have had a different range
                                         *  here, but removing references to it
                                         *  could have left it either the old
                                         *  range instruction or a NOP,
                                         *  depending upon the removal
                                         *  sequence.  It is also possible that
                                         *  newly added ranges are still NOP in
                                         *  the instructions until they are
                                         *  committed, but could also be valid
                                         *  range instructions even without
                                         *  committed references if there was
                                         *  an update to the filter set since
                                         *  the range reference was added.
                                         */
                                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                                  (BSL_META_U(unit,
                                                              "unit %d program"
                                                              " %u filter set"
                                                              " %u (group %d)"
                                                              " instr %u"
                                                              " (range %u, ref"
                                                              " count %u,"
                                                              " commit count"
                                                              " %u) at imem"
                                                              " %03X.%1X"
                                                              " mismatch: HW"
                                                              " has %08X%08X,"
                                                              " expected"
                                                              " %08X%08X\n"),
                                                   unit,
                                                   program,
                                                   filterSet,
                                                   groupData->groupId,
                                                   offset + index,
                                                   rangeData->rangeId,
                                                   rangeData->refCount,
                                                   rangeData->commitCount,
                                                   imemFirst + filterSetLen,
                                                   index,
                                                   COMPILER_64_HI(instrTemp),
                                                   COMPILER_64_LO(instrTemp),
                                                   COMPILER_64_HI(rangeInstr),
                                                   COMPILER_64_LO(rangeInstr)));
                                        SOC_C3_RCE_STATE_FAIL_MISMATCH;
                                    }
                                } else { /* if (in range refs) */
                                    /*
                                     *  Everything else in the filter set
                                     *  should match the group template
                                     *  exactly (except we need to set the
                                     *  end of filter set bit appropriately).
                                     */
                                    if ((offset + index) <
                                        groupData->instrCount) {
                                        rangeInstr = groupData->instr[(offset +
                                                                       index)];
                                    } else {
                                        COMPILER_64_SET(rangeInstr,
                                                        (_c3RCEOpcode_nop << 8),
                                                        0x00000000);
                                    }
                                    if ((filterSetLen + 1) >= filterSetExpLen) {
                                        /*
                                         *  The last block of instructions in a
                                         *  filter set must have at least one
                                         *  instruction with the 'endf' bit
                                         *  set, but this bit can only be set
                                         *  for certain instructions.  Happily,
                                         *  most instructions can have it set,
                                         *  and we will set it for all such
                                         *  instructions in the last
                                         *  instruction block.
                                         */
                                        switch (COMPILER_64_HI(rangeInstr) >> 8 & 0x7) {
                                        case _c3RCEOpcode_nop:
                                        case _c3RCEOpcode_data:
                                        case _c3RCEOpcode_match0:
                                        case _c3RCEOpcode_match1:
                                            COMPILER_64_SET(instrMask,
                                                            0x000007FF,
                                                            0xFFFFFFFF);
                                            COMPILER_64_SET(instrEndf,
                                                            0x080,
                                                            0x00000000);
                                            break;
                                        default:
                                            COMPILER_64_SET(instrMask,
                                                            0x000007FF,
                                                            0xFFFFFFFF);
                                            COMPILER_64_SET(instrEndf,
                                                            0x000,
                                                            0x00000000);
                                        }
                                    } else {
                                        /*
                                         *  No block of instructions other than
                                         *  the last one of a filter set may
                                         *  have the 'endf' bit set for any
                                         *  instruction.
                                         */
                                        switch (COMPILER_64_HI(rangeInstr) >> 8 & 0x7) {
                                        case _c3RCEOpcode_nop:
                                        case _c3RCEOpcode_data:
                                        case _c3RCEOpcode_match0:
                                        case _c3RCEOpcode_match1:
                                            COMPILER_64_SET(instrMask,
                                                            0x0000077F,
                                                            0xFFFFFFFF);
                                            COMPILER_64_SET(instrEndf,
                                                            0x000,
                                                            0x00000000);
                                            break;
                                        default:
                                            COMPILER_64_SET(instrMask,
                                                            0x000007FF,
                                                            0xFFFFFFFF);
                                            COMPILER_64_SET(instrEndf,
                                                            0x000,
                                                            0x00000000);
                                        }
                                    }
                                    COMPILER_64_AND(rangeInstr, instrMask);
                                    COMPILER_64_OR(rangeInstr, instrEndf);
                                    if (COMPILER_64_NE(instrTemp, rangeInstr)) {
                                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                                  (BSL_META_U(unit,
                                                              "unit %d program"
                                                              " %u filter set"
                                                              " %u (group %u)"
                                                              " instr %u at"
                                                              " imem %03X.%1X"
                                                              " mismatch:"
                                                              " HW %08X%08X,"
                                                              " SW %08X%08X\n"),
                                                   unit,
                                                   program,
                                                   filterSet,
                                                   fsetData->groupId,
                                                   offset + index,
                                                   imemFirst + filterSetLen,
                                                   index,
                                                   COMPILER_64_HI(instrTemp),
                                                   COMPILER_64_LO(instrTemp),
                                                   COMPILER_64_HI(rangeInstr),
                                                   COMPILER_64_LO(rangeInstr)));
                                        SOC_C3_RCE_STATE_FAIL_MISMATCH;
                                    } /* if (instruction not as expected) */
                                } /* if (in range refs) */
                            } else { /* if (groupData) */
                                /*
                                 *  Not in a group, so must be paddging.  The
                                 *  only instruction used in padding filter
                                 *  sets (other than appropriate 'start', which
                                 *  is checked above) is NOP.
                                 */
                                regTemp = 0;
                                if (imemFirst == unitData->imemExtra[0]) {
                                    if (filterSetLen >=
                                        (C3_RCE_FILTER_SET_FIRST_PADDING - 1)) {
                                        regTemp = (1 << 7);
                                    }
                                } else {
                                    if (filterSetLen >=
                                        (C3_RCE_FILTER_SET_LENGTH_PADDING -
                                         1)) {
                                        regTemp = (1 << 7);
                                    }
                                }
                                COMPILER_64_SET(rangeInstr,
                                                (_c3RCEOpcode_nop << 8) |
                                                regTemp,
                                                0);
                                if (COMPILER_64_NE(instrTemp, rangeInstr)) {
                                    LOG_ERROR(BSL_LS_SOC_COMMON,
                                              (BSL_META_U(unit,
                                                          "unit %d program %u"
                                                          " filter set %u"
                                                          " (padding) instr %u"
                                                          " at imem %03X.%1X"
                                                          " mismatch: %08X%08X"
                                                          " should be"
                                                          " %08X%08X\n"),
                                               unit,
                                               program,
                                               filterSet,
                                               offset + index,
                                               imemFirst + filterSetLen,
                                               index,
                                               COMPILER_64_HI(instrTemp),
                                               COMPILER_64_LO(instrTemp),
                                               COMPILER_64_HI(rangeInstr),
                                               COMPILER_64_LO(rangeInstr)));
                                    SOC_C3_RCE_STATE_FAIL_CORRUPT;
                                }
                            } /* if (groupData) */
                        } /* if (offset + index) */
                    } /* for (all instructions in this instruction block) */
                    /*
                     *  Read pattern block from pattern memory.  In order to
                     *  make this simpler and faster, we use the memory port
                     *  that combines imem with all blocks of pmem, instead of
                     *  the 24 individual pmem ports.  We don't use this for
                     *  instructions, though, to save work on decoding the
                     *  instructions (they are packed as 4 43b instructions
                     *  each of the pair of 32 byte rows in this view, instead
                     *  of one per octbyte as in the plain imem view).
                     */
                    sal_dma_flush(imemPmemTemp,
                                  sizeof(*imemPmemTemp));
                    auxRes = soc_mem_read_range(unit,
                                                IMEM_PMEM_DMAm,
                                                MEM_BLOCK_ANY,
                                                imemBlock << 5,
                                                (imemBlock << 5) + 0x1F,
                                                imemPmemTemp);
                    if (SOC_E_NONE != auxRes) {
                        /* failed to read the imem block */
                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                  (BSL_META_U(unit,
                                              "unit %d program %u filter set"
                                              " %u unable to read instr+pattern"
                                              " block %u at imem_pmem_dma %u:"
                                              " %d (%s)\n"),
                                   unit,
                                   program,
                                   filterSet,
                                   filterSetLen,
                                   imemBlock,
                                   auxRes,
                                   _SHR_ERRMSG(auxRes)));
                        SOC_C3_RCE_STATE_FAIL_ERROR;
                        /* assume everything is zeroes */
                        LOG_WARN(BSL_LS_SOC_COMMON,
                                 (BSL_META_U(unit,
                                             "unit %d program %u filter set"
                                             " %u HW instr+pattern block %u"
                                             " will be assumed to be all"
                                             " zeroes for comparison\n"),
                                  unit,
                                  program,
                                  filterSet,
                                  filterSetLen));
                        sal_dma_inval(imemPmemTemp,
                                      sizeof(*imemPmemTemp));
                        sal_memset(imemPmemTemp,
                                   0x00,
                                   sizeof(*imemPmemTemp));
                    } else {
                        sal_dma_inval(imemPmemTemp,
                                      sizeof(*imemPmemTemp));
                    }
                    /* compare pattern data */
                    if (fsetData) {
                        /*
                         *  This filter set is within a group, so it can have
                         *  entries and patterns associated with it.
                         */
                        /* Figure out the limits for this filter set */
                        position = (fsetData->filterIndex *
                                    C3_RCE_ENTRIES_PER_FILTER_SET);
                        positionMax = position + C3_RCE_ENTRIES_PER_FILTER_SET;
                        if (0 == filterSetLen) {
                            /*
                             *  For the first pattern block, we collect and
                             *  check information about entry positions, and
                             *  which positions are 'installed'.
                             */
                            offset = (C3_RCE_ENTRIES_PER_FILTER_SET + 7) >> 3;
                            sal_memset(posEnable,
                                       0x00,
                                       offset << 1);
                            sal_memset(entryList,
                                       0x00,
                                       sizeof(*entryList) *
                                       C3_RCE_ENTRIES_PER_FILTER_SET);
                            for (entryData = fsetData->entryHead;
                                 entryData &&
                                 (entryData->entryPosition < positionMax);
                                 entryData = entryData->entryNext) {
                                if ((entryData->pattData[0][0] & 0x01) !=
                                    (entryData->pattData[1][0] & 0x01)) {
                                    LOG_ERROR(BSL_LS_SOC_COMMON,
                                              (BSL_META_U(unit,
                                                          "unit %d program %u"
                                                          " filter set %u"
                                                          " (group %d) entry"
                                                          " %d position %u SW"
                                                          " state is not"
                                                          " consistent:"
                                                          " API side %s,"
                                                          " HW side %s\n"),
                                               unit,
                                               program,
                                               filterSet,
                                               fsetData->groupId,
                                               entryData->entryId,
                                               entryData->entryPosition,
                                               (entryData->pattData[0][0] & 0x01)?"installed":"removed",
                                               (entryData->pattData[1][0] & 0x01)?"installed":"removed"));
                                    SOC_C3_RCE_STATE_FAIL_CORRUPT;
                                }
                                index = entryData->entryPosition - position;
                                if (C3_RCE_ENTRIES_PER_FILTER_SET > index) {
                                    /* always count all entries */
                                    filterSetEntCount++;
                                }
                                index = entryData->entryPosition - position;
                                if (C3_RCE_ENTRIES_PER_FILTER_SET > index) {
                                    /* check to be sure no duplicate at pos */
                                    if (posEnable[offset + (index >> 3)] &
                                        (1 << (index & 0x7))) {
                                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                                  (BSL_META_U(unit,
                                                              "unit %d program"
                                                              " %u filter set"
                                                              " %u (group %d"
                                                              " filter set %u)"
                                                              " entry %d SW"
                                                              " position %u"
                                                              " (%d) is same"
                                                              " as another"
                                                              " entry\n"),
                                                   unit,
                                                   program,
                                                   filterSet,
                                                   fsetData->groupId,
                                                   fsetData->filterIndex,
                                                   entryData->entryId,
                                                   entryData->entryPosition,
                                                   index));
                                        SOC_C3_RCE_STATE_FAIL_CORRUPT;
                                    }
                                    /* mark position as in use */
                                    posEnable[offset + (index >> 3)] |=
                                        (1 << (index & 0x7));
                                    /* check priority ordering */
                                    if (entryData->entryPriority >
                                        prevEntPrio) {
                                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                                  (BSL_META_U(unit,
                                                              "unit %d program"
                                                              " %u filter set"
                                                              " %u (group %d"
                                                              " filter set %u)"
                                                              " entry %d"
                                                              " priority %d is"
                                                              " greater than"
                                                              " prev entry %d"
                                                              " prio %d\n"),
                                                   unit,
                                                   program,
                                                   filterSet,
                                                   fsetData->groupId,
                                                   fsetData->filterIndex,
                                                   entryData->entryId,
                                                   entryData->entryPriority,
                                                   entryData->entryPrev?entryData->entryPrev->entryId:unitData->entryLimit,
                                                   prevEntPrio));
                                        SOC_C3_RCE_STATE_FAIL_CORRUPT;
                                    }
                                    prevEntPrio = entryData->entryPriority;
                                    if (entryData->pattData[1][0] & 0x01) {
                                        /* mark position as installed */
                                        posEnable[index >> 3] |=
                                            (1 << (index & 0x7));
#if !C3_RCE_INCLUDE_NON_INSTALLED_DATA
                                        /*
                                         *  In this mode, we only want to cache
                                         *  pointers to entries that should be
                                         *  installed (and will only compare
                                         *  those later).  None of the bits
                                         *  other than the low bit of the
                                         *  initial byte of the pattern matter
                                         *  for entries that are not installed
                                         *  in this case, since they are
                                         *  disabled in hardware and will be
                                         *  omitted (zeroed) by some updates,
                                         *  but may be left in place (other
                                         *  than clearing the initial bit) by
                                         *  other updates.  We already checked
                                         *  that this bit is set as expected.
                                         */
                                        entryList[index] = entryData;
#endif /* !C3_RCE_INCLUDE_NON_INSTALLED_DATA */
                                    }
#if C3_RCE_INCLUDE_NON_INSTALLED_DATA
                                    /*
                                     *  In this mode, we write hardware pattern
                                     *  data even for entries that are not
                                     *  currently installed, so let's cache all
                                     *  entries and even verify inactive ones.
                                     */
                                    entryList[index] = entryData;
#endif /* C3_RCE_INCLUDE_NON_INSTALLED_DATA */
                                } /* if (position is in filter set) */
                                /* scan for API side range references */
                                for (byteOffset = 0, rowOffset = 1, mask = 2;
                                     rowOffset <= groupData->rangesPerFilterSet;
                                     rowOffset++) {
                                    if (entryData->pattData[0][byteOffset] &
                                        mask) {
                                        rangeRefs[rowOffset + groupData->rangesPerFilterSet - 1]++;
                                    }
                                    if (7 == (rowOffset & 7)) {
                                        byteOffset++;
                                        mask = 1;
                                    } else {
                                        mask <<= 1;
                                    }
                                } /* for (all pattern bytes in range space) */
                            } /* for (all entries in this filter set) */
                            for (index = 0;
                                 index < C3_RCE_ENTRIES_PER_FILTER_SET;
                                 index++) {
                                byteOffset = index;
                                rowOffset = byteOffset >> 5;
                                byteOffset &= 0x1F;
                                byteOffset = byteOffset ^ (C3_RCE_DMA_HOST_END_MASK ^
                                                           C3_RCE_DMA_CHIP_END_MASK_IMEM);
                                offset = index >> 3;
                                if (imemPmemTemp->pattern[rowOffset][byteOffset] & 0x01) {
                                    /* this position is enabled */
                                    if (0 == (posEnable[offset] & (1 << (index & 0x7)))) {
                                        /* but it should not be */
                                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                                  (BSL_META_U(unit,
                                                              "unit %d program"
                                                              " %u filter set"
                                                              " %u (group %d)"
                                                              " position %u is"
                                                              " enabled in HW"
                                                              " but disabled"
                                                              " in SW\n"),
                                                   unit,
                                                   program,
                                                   filterSet,
                                                   fsetData->groupId,
                                                   index +
                                                   (fsetData->filterIndex *
                                                    C3_RCE_ENTRIES_PER_FILTER_SET)));
                                        SOC_C3_RCE_STATE_FAIL_MISMATCH;
                                    }
                                } else { /* if (entry should be 'installed') */
                                    /* this position is disabled */
                                    if (posEnable[offset] & (1 << (index & 0x7))) {
                                        /* but it should not be */
                                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                                  (BSL_META_U(unit,
                                                              "unit %d program"
                                                              " %u filter set"
                                                              " %u (group %d)"
                                                              " position %u is"
                                                              " disabled in HW"
                                                              " but enabled"
                                                              " in SW\n"),
                                                   unit,
                                                   program,
                                                   filterSet,
                                                   fsetData->groupId,
                                                   index +
                                                   (fsetData->filterIndex *
                                                    C3_RCE_ENTRIES_PER_FILTER_SET)));
                                        SOC_C3_RCE_STATE_FAIL_MISMATCH;
                                    }
                                } /* if (entry should be 'installed') */
                            } /* for (all positions in this filter set) */
                        } /* if (first pattern block) */
                        /* compare pattern data to installed entries */
                        for (index = 0,
                             offset = (fsetData->filterIndex *
                                       C3_RCE_ENTRIES_PER_FILTER_SET);
                             index < C3_RCE_ENTRIES_PER_FILTER_SET;
                             index++) {
                            if (entryList[index]) {
                                /* we want to compare this entry's pattern */
                                entryData = entryList[index];
                                byteOffset = entryData->entryPosition - offset;
                                rowOffset = byteOffset >> 5;
                                byteOffset &= 0x1F;
                                byteOffset = (byteOffset ^
                                              (C3_RCE_DMA_HOST_END_MASK ^
                                               C3_RCE_DMA_CHIP_END_MASK_IMEM));
                                data = imemPmemTemp->pattern[rowOffset][byteOffset];
                                if (filterSetLen >= groupData->instrBlocks) {
                                    if (data) {
                                        /*
                                         *  Any instruction blocks added to a
                                         *  filter set to meet hardware minimum
                                         *  length should always have zero as
                                         *  the padding bytes in the pattern.
                                         */
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
                                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                                  (BSL_META_U(unit,
                                                              "unit %d program"
                                                              " %u filter set"
                                                              " %u (group %d)"
                                                              " entry %d"
                                                              " (position"
                                                              " %u:%u)"
                                                              " pattern byte"
                                                              " %u mismatch:"
                                                              " HW %02X,"
                                                              " SW %02X\n"),
                                                   unit,
                                                   program,
                                                   filterSet,
                                                   groupData->groupId,
                                                   entryData->entryId,
                                                   entryData->entryPosition,
                                                   entryData->entryPosPrev,
                                                   filterSetLen,
                                                   data,
                                                   0));
#else /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
                                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                                  (BSL_META_U(unit,
                                                              "unit %d program"
                                                              " %u filter set"
                                                              " %u (group %d)"
                                                              " entry %d"
                                                              " (position %u)"
                                                              " pattern byte"
                                                              " %u mismatch:"
                                                              " HW %02X,"
                                                              " SW %02X\n"),
                                                   unit,
                                                   program,
                                                   filterSet,
                                                   groupData->groupId,
                                                   entryData->entryId,
                                                   entryData->entryPosition,
                                                   filterSetLen,
                                                   data,
                                                   0));
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
                                        SOC_C3_RCE_STATE_FAIL_MISMATCH;
                                    }
                                } else if (entryData->pattData[1][filterSetLen] !=
                                           data) {
                                    LOG_ERROR(BSL_LS_SOC_COMMON,
                                              (BSL_META_U(unit,
                                                          "unit %d program %u"
                                                          " filter set %u"
                                                          " (group %d) entry"
                                                          " %d (position %u)"
                                                          " pattern byte %u"
                                                          " mismatch: HW %02X,"
                                                          " SW %02X\n"),
                                               unit,
                                               program,
                                               filterSet,
                                               groupData->groupId,
                                               entryData->entryId,
                                               entryData->entryPosition,
                                               filterSetLen,
                                               data,
                                               entryData->pattData[1][filterSetLen]));
                                    SOC_C3_RCE_STATE_FAIL_MISMATCH;
                                }
                                if ((regTemp = filterSetLen << 3) <=
                                    groupData->rangesPerFilterSet) {
                                    /* regTemp assignment intentional */
                                    /*
                                     *  The group's template range section
                                     *  includes at least one bit within
                                     *  this byte; scan ranges.
                                     */
#if C3_RCE_INCLUDE_NON_INSTALLED_DATA
                                    if (posEnable[index >> 3] &
                                        (1 << (index & 0x7))) {
                                        /*
                                         *  Only filter set references for enabled
                                         *  entries are counted as committed.
                                         */
#endif /* C3_RCE_INCLUDE_NON_INSTALLED_DATA */
                                        if (filterSetLen) {
                                            /* later bytes, do not skip bits */
                                            bitPosition = 0;
                                            mask = 0x01;
                                        } else {
                                            /* byte zero must skip 'enable' */
                                            bitPosition = 1;
                                            mask = 0x02;
                                            regTemp++;
                                        }
                                        for (/* init done above */;
                                             (bitPosition < 8) &&
                                             (regTemp <=
                                              groupData->rangesPerFilterSet);
                                             bitPosition++,
                                             regTemp++,
                                             mask <<= 1) {
                                            if (data & mask) {
                                                rangeRefs[regTemp - 1]++;
                                            }
                                        } /* for (all bit positions this byte) */
#if C3_RCE_INCLUDE_NON_INSTALLED_DATA
                                    } /* if (this entry is enabled in hardware) */
#endif /* C3_RCE_INCLUDE_NON_INSTALLED_DATA */
                                } /* if (within group template's ranges) */
                            } /* if (this entry should be compared) */
                        } /* for (all positions in this filter set) */
                    } else { /* if (fsetData) */
                        /*
                         *  This filter set is not in a group, so it should be
                         *  padding.  Padding filter sets should have no
                         *  pattern bits set at any point.
                         */
                        for (rowOffset = 0; rowOffset < 24; rowOffset++) {
                            for (byteOffset = 0;
                                 byteOffset < 32;
                                 byteOffset++) {
                                if (imemPmemTemp->pattern[rowOffset][byteOffset]) {
                                    /* should not be nonzero */
                                    index = ((rowOffset << 5) |
                                             (byteOffset ^
                                              (C3_RCE_DMA_HOST_END_MASK ^
                                               C3_RCE_DMA_CHIP_END_MASK_IMEM)));
                                    LOG_ERROR(BSL_LS_SOC_COMMON,
                                              (BSL_META_U(unit,
                                                          "unit %d program %u"
                                                          " filter set %u"
                                                          " (padding) position"
                                                          " %u pattern byte %u"
                                                          " in HW is %02X but"
                                                          " should be zero\n"),
                                               unit,
                                               program,
                                               filterSet,
                                               index,
                                               filterSetLen,
                                               imemPmemTemp->pattern[rowOffset][byteOffset]));
                                    SOC_C3_RCE_STATE_FAIL_CORRUPT;
                                }
                            } /* for (all bytes in a pattern row) */
                        } /* for (all pattern rows in a program block) */
                    } /* if (fsetData) */
                    /* look at next instruction block */
                    filterSetLen++;
                    imemBlock++;
                } while (!foundFsetEnd);
                if (filterSet) {
                    /* not the first filter set in the program */
                    if (filterSetLen < C3_RCE_FILTER_SET_LENGTH_LATER) {
                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                  (BSL_META_U(unit,
                                              "unit %d program %u HW filter"
                                              " set %u is too short -- should"
                                              " be %u instruction blocks,"
                                              " but is %u\n"),
                                   unit,
                                   program,
                                   filterSet,
                                   C3_RCE_FILTER_SET_LENGTH_LATER,
                                   filterSetLen));
                        SOC_C3_RCE_STATE_FAIL_INVALID;
                    }
                } else { /* if (filterSet) */
                    if (filterSetLen < C3_RCE_FILTER_SET_LENGTH_FIRST) {
                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                  (BSL_META_U(unit,
                                              "unit %d program %u HW filter"
                                              " set %u is too short -- should"
                                              " be %u instruction blocks,"
                                              " but is %u\n"),
                                   unit,
                                   program,
                                   filterSet,
                                   C3_RCE_FILTER_SET_LENGTH_FIRST,
                                   filterSetLen));
                        SOC_C3_RCE_STATE_FAIL_INVALID;
                    }
                } /* if (filterSet) */
                if (groupData) {
                    /* in a group, so check expected values there */
                    groupEntryCount += filterSetEntCount;
                    if (filterSetLen != filterSetExpLen) {
                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                  (BSL_META_U(unit,
                                              "unit %d program %u filter set"
                                              " %u (group %d) HW length %u,"
                                              " but expected length %u\n"),
                                   unit,
                                   program,
                                   filterSet,
                                   groupData->groupId,
                                   filterSetLen,
                                   filterSetExpLen));
                        SOC_C3_RCE_STATE_FAIL_CORRUPT;
                    }
                    if (fsetData->imemSize != filterSetExpLen) {
                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                  (BSL_META_U(unit,
                                              "unit %d program %u filter set"
                                              " %u (group %u) HW length %u,"
                                              " but has %u allocated\n"),
                                   unit,
                                   program,
                                   filterSet,
                                   groupData->groupId,
                                   filterSetLen,
                                   fsetData->imemSize));
                        SOC_C3_RCE_STATE_FAIL_CORRUPT;
                    }
                    if (((filterSet + 1) >= progData->filterSetCount) ||
                        (progData->fsetData[filterSet].groupId !=
                         progData->fsetData[filterSet + 1].groupId)) {
                        /* end of this group */
                        progGroupCount++;
                        if (groupEntryCount !=
                            groupData->entryCount) {
                            LOG_ERROR(BSL_LS_SOC_COMMON,
                                      (BSL_META_U(unit,
                                                  "unit %d group %u entry"
                                                  " count %u disagrees with"
                                                  " entry count %u from"
                                                  " scanning its filter"
                                                  " sets in program %u\n"),
                                       unit,
                                       groupData->groupId,
                                       groupData->entryCount,
                                       groupEntryCount,
                                       program));
                            SOC_C3_RCE_STATE_FAIL_CORRUPT;
                        }
                    }
                    /* keep track of total group filter set length */
                    progLength += filterSetLen;
                } else { /* if (groupData) */
                    /* must be padding if not in a group */
                    if (filterSetLen != filterSetExpLen) {
                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                  (BSL_META_U(unit,
                                              "unit %d program %u filter set"
                                              " %u (padding) HW length %u,"
                                              " but SW length %u\n"),
                                   unit,
                                   program,
                                   filterSet,
                                   filterSetLen,
                                   filterSetExpLen));
                        SOC_C3_RCE_STATE_FAIL_CORRUPT;
                    }
                    /* keep track of total padding filter set length */
                    progPadding += filterSetLen;
                } /* if (groupData) */
                if (fsetData) {
                    if (filterSetEntCount != fsetData->entryCount) {
                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                  (BSL_META_U(unit,
                                              "unit %d program %u filter set"
                                              " %u (group %d) SW expected %u"
                                              " entries but actually has"
                                              " %u entries\n"),
                                   unit,
                                   program,
                                   filterSet,
                                   fsetData->groupId,
                                   fsetData->entryCount,
                                   filterSetEntCount));
                        SOC_C3_RCE_STATE_FAIL_CORRUPT;
                    }
                    regTemp = unitData->groupData[fsetData->groupId]->rangesPerFilterSet;
                    for (rowOffset = 0;
                         rowOffset < regTemp;
                         rowOffset++) {
                        if (rangeRefs[rowOffset] !=
                            fsetData->rangeInfo[rowOffset].commitCount) {
                            LOG_ERROR(BSL_LS_SOC_COMMON,
                                      (BSL_META_U(unit,
                                                  "unit %d program %u filter"
                                                  " set %u (group %u filter"
                                                  " set %u) range reference"
                                                  " %u HW counted %u committed"
                                                  " refs but SW expected %u"
                                                  " committed refs\n"),
                                       unit,
                                       program,
                                       filterSet,
                                       fsetData->groupId,
                                       fsetData->filterIndex,
                                       rowOffset + 1,
                                       rangeRefs[rowOffset],
                                       fsetData->rangeInfo[rowOffset].commitCount));
                            SOC_C3_RCE_STATE_FAIL_CORRUPT;
                        }
                        if (rangeRefs[rowOffset + regTemp] !=
                            fsetData->rangeInfo[rowOffset].refCount) {
                            LOG_ERROR(BSL_LS_SOC_COMMON,
                                      (BSL_META_U(unit,
                                                  "unit %d program %u filter"
                                                  " set %u (group %u filter"
                                                  " set %u) range reference"
                                                  " %u HW counted %u refs but"
                                                  " SW expected %u refs\n"),
                                       unit,
                                       program,
                                       filterSet,
                                       fsetData->groupId,
                                       fsetData->filterIndex,
                                       rowOffset + 1,
                                       rangeRefs[rowOffset + regTemp],
                                       fsetData->rangeInfo[rowOffset].refCount));
                            SOC_C3_RCE_STATE_FAIL_CORRUPT;
                        }
                    } /* for (all range slots in this filter set) */
                    /* read action table data for this filter set */
                    sal_memset(&actData, 0x00, sizeof(actData));
                    sal_memset(&actSize, 0x00, sizeof(actSize));
                    sal_memset(actBuffer, 0x00, actTableMaxSize);
                    for (index = 0, byteOffset = 0;
                         index < SOC_C3_RCE_RESULT_REGISTER_COUNT;
                         index++) {
                        if (0 == (groupData->resultLrpUniq & (1 << index))) {
                            /* group does not use this result register */
                            continue;
                        }
                        /* account for a block of this table being in use */
                        actBlocksUsed[progData->actIndex[index]]++;
                        /* verify allocation of this action table block */
                        auxRes = shr_mres_check_all(unitData->amemRes,
                                                    progData->actIndex[index],
                                                    1,
                                                    fsetData->amemBlock);
                        if (SOC_E_FULL != auxRes) {
                            /*
                             *  If the result is not *_E_FULL, it means that
                             *  the block is not a contiguous single allocated
                             *  block, which would mismatch expectations.
                             */
                            LOG_ERROR(BSL_LS_SOC_COMMON,
                                      (BSL_META_U(unit,
                                                  "unit %d program %u filter"
                                                  " set %u result register %u"
                                                  " action table %u (%s) block"
                                                  " %u not allocated as"
                                                  " expected: %d (%s)\n"),
                                       unit,
                                       program,
                                       filterSet,
                                       index,
                                       progData->actIndex[index],
                                       unitData->actData[progData->actIndex[index]]->ucData->tableName,
                                       fsetData->amemBlock,
                                       auxRes,
                                       _SHR_ERRMSG(auxRes)));
                            SOC_C3_RCE_STATE_FAIL_CORRUPT;
                        }
                        actTblData = unitData->actData[progData->actIndex[index]]->ucData;
                        /* compute expected action table base */
                        regTemp = fsetData->amemBlock;
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
                        if (fsetData->fsetFlags & _SOC_C3_RCE_FSET_FLAGS_COUNTER) {
                            /* with action-indexed counters, blocks are double size */
                            regTemp <<= 1;
                            if (0 == (fsetData->fsetFlags & _SOC_C3_RCE_FSET_FLAGS_PHASE)) {
                                /* now phase one */
                                regTemp++;
                            }
                        }
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
                        regTemp *= C3_RCE_ENTRIES_PER_FILTER_SET;
                        regTemp += unitData->actData[progData->actIndex[index]]->firstEntryBias;
                        if (regTemp != filterSetActBase) {
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
                            LOG_ERROR(BSL_LS_SOC_COMMON,
                                      (BSL_META_U(unit,
                                                  "unit %d program %u filter"
                                                  " set %u (group %d) action"
                                                  " table %u (%s) HW base %u"
                                                  " but SW expects %u based"
                                                  " upon amemBase %u and"
                                                  " phase %s\n"),
                                     unit,
                                     program,
                                     filterSet,
                                     fsetData->groupId,
                                     progData->actIndex[index],
                                     actTblData->tableName,
                                     filterSetActBase,
                                     regTemp,
                                     fsetData->amemBlock,
                                     (fsetData->fsetFlags & _SOC_C3_RCE_FSET_FLAGS_PHASE)?"0":"1"));
#else /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
                            LOG_ERROR(BSL_LS_SOC_COMMON,
                                      (BSL_META_U(unit,
                                                  "unit %d program %u filter"
                                                  " set %u (group %d) action"
                                                  " table %u (%s) HW base %u"
                                                  " but SW expects %u based"
                                                  " upon amemBase %u\n"),
                                       unit,
                                       program,
                                       filterSet,
                                       fsetData->groupId,
                                       progData->actIndex[index],
                                       actTblData->tableName,
                                       filterSetActBase,
                                       regTemp,
                                       fsetData->amemBlock));
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
                            SOC_C3_RCE_STATE_FAIL_CORRUPT;
                        }
                        for (offset = 0;
                             offset < actTblData->ocmSegments;
                             offset++) {
                            /* point to where we will put this table block */
                            actData[index][offset] = &(actBuffer[byteOffset]);
                            /* keep track of how many bytes for this segment */
                            actSize[index][offset] = ((actTblData->seg[offset].bitsPerAction + 7) >> 3);
                            /* calculate size of this action table block */
                            if (actTblData->seg[offset].elemsPerAction) {
                                rowOffset = (C3_RCE_ENTRIES_PER_FILTER_SET *
                                             actTblData->seg[offset].elemsPerAction);
                            } else {
                                rowOffset = (C3_RCE_ENTRIES_PER_FILTER_SET /
                                             actTblData->seg[offset].actionsPerElem);
                            }
                            rowOffset <<= 3;
                            /* adjust next block start by size of this one */
                            byteOffset += rowOffset;
                            /* read this block of this segment of the table */
                            regTemp = (filterSetActBase +
                                       (C3_RCE_ENTRIES_PER_FILTER_SET - 1));
                            /* coverity[stack_use_overflow] */
                            auxRes = soc_sbx_caladan3_ocm_port_mem_read(unit,
                                                                        actTblData->seg[offset].ocmPort,
                                                                        actTblData->seg[offset].ocmSeg,
                                                                        filterSetActBase,
                                                                        regTemp,
                                                                        (uint32*)(actData[index][offset]));
                            if (SOC_E_NONE != auxRes) {
                                LOG_ERROR(BSL_LS_SOC_COMMON,
                                          (BSL_META_U(unit,
                                                      "unit %d program %u"
                                                      " filter set %u unable"
                                                      " to read HW action"
                                                      " table %u (%s) segment"
                                                      " %u (%s) entries %u"
                                                      " through %u: %d (%s)\n"),
                                           unit,
                                           program,
                                           filterSet,
                                           progData->actIndex[index],
                                           actTblData->tableName,
                                           offset,
                                           actTblData->seg[offset].segmentName,
                                           filterSetActBase,
                                           regTemp,
                                           auxRes,
                                           _SHR_ERRMSG(auxRes)));
                                SOC_C3_RCE_STATE_FAIL_ERROR;
                            }
                        } /* for (all OCM tables this action table) */
                    } /* for (all action tables used by this group) */
                    for (index = 0,
                         positionMax = fsetData->filterIndex *
                         C3_RCE_ENTRIES_PER_FILTER_SET;
                         index < C3_RCE_ENTRIES_PER_FILTER_SET;
                         index++) {
                        if (entryList[index]) {
                            /* we want to compare this entry's action data */
                            entryData = entryList[index];
                            position = entryData->entryPosition - positionMax;
                            for (rowOffset = 0, byteOffset = 0;
                                 rowOffset < SOC_C3_RCE_RESULT_REGISTER_COUNT;
                                 rowOffset++) {
                                for (offset = 0;
                                     offset < SOC_C3_RCE_MAX_OCM_SEG_PER_ACTION_TABLE;
                                     offset++) {
                                    if (!actData[rowOffset][offset]) {
                                        /* segment is not used */
                                        continue;
                                    }
                                    bitPosition = (actSize[rowOffset][offset] *
                                                   position);
                                    actTblData = unitData->actData[progData->actIndex[rowOffset]]->ucData;
                                    mask = actTblData->seg[offset].byteOrderMask;
                                    for (regValue = 0;
                                         regValue < actSize[rowOffset][offset];
                                         regValue++, byteOffset++) {
                                        if (actData[rowOffset][offset][bitPosition + (regValue ^ (C3_RCE_DMA_HOST_END_MASK ^ mask))] !=
                                            entryData->actData[1][rowOffset][byteOffset]) {
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
                                            LOG_ERROR(BSL_LS_SOC_COMMON,
                                                      (BSL_META_U(unit,
                                                                  "unit %d"
                                                                  " program %u"
                                                                  " filter set"
                                                                  " %u (group"
                                                                  " %d) entry"
                                                                  " %d"
                                                                  " (position"
                                                                  " %u:%u)"
                                                                  " action"
                                                                  " byte %u"
                                                                  " in HW is"
                                                                  " %02X, but"
                                                                  " SW is"
                                                                  " %02X\n"),
                                                       unit,
                                                       program,
                                                       filterSet,
                                                       fsetData->groupId,
                                                       entryData->entryId,
                                                       entryData->entryPosition,
                                                       entryData->entryPosPrev,
                                                       byteOffset,
                                                       actData[rowOffset][offset][bitPosition + (regValue ^ (C3_RCE_DMA_HOST_END_MASK ^ mask))],
                                                       entryData->actData[1][rowOffset][byteOffset]));
#else /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
                                           LOG_ERROR(BSL_LS_SOC_COMMON,
                                                      (BSL_META_U(unit,
                                                                  "unit %d"
                                                                  " program %u"
                                                                  " filter set"
                                                                  " %u (group"
                                                                  " %d) entry"
                                                                  " %d"
                                                                  " (position"
                                                                  " %u) action"
                                                                  " byte %u in"
                                                                  " HW is"
                                                                  " %02X, but"
                                                                  " SW is"
                                                                  " %02X\n"),
                                                       unit,
                                                       program,
                                                       filterSet,
                                                       fsetData->groupId,
                                                       entryData->entryId,
                                                       entryData->entryPosition,
                                                       byteOffset,
                                                       actData[rowOffset][offset][bitPosition + (regValue ^ (C3_RCE_DMA_HOST_END_MASK ^ mask))],
                                                       entryData->actData[1][rowOffset][byteOffset]));
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
                                            SOC_C3_RCE_STATE_FAIL_MISMATCH;
                                        }
                                    } /* for all bytes this segment */
                                } /* for (all segments this action table) */
                            } /* for (all used action tables) */
                        } /* if (this entry should be in hardware) */
                    } /* for (all entry positions in this filter set) */
                    /* check imem/pmem allocation */
                    auxRes = shr_mdb_block_check_all(unitData->imemRes,
                                                     imemFirst,
                                                     filterSetLen);
                    if (SOC_E_FULL != auxRes) {
                        /*
                         *  Anything other than *_E_FULL indicates that the
                         *  requested block is not all allocated as a single
                         *  contiguous block, which mismatches expected state.
                         */
                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                  (BSL_META_U(unit,
                                              "unit %d program %u filter set"
                                              " %u HW uses IMEM/PMEM"
                                              " %03X..%03X, but allocator"
                                              " indicates that is not a single"
                                              " contiguous allocated"
                                              " block: %d (%s)\n"),
                                   unit,
                                   program,
                                   filterSet,
                                   imemFirst,
                                   imemFirst + filterSetLen - 1,
                                   auxRes,
                                   _SHR_ERRMSG(auxRes)));
                        auxRes = shr_mdb_block_info(unitData->imemRes,
                                                    imemFirst,
                                                    &mdbInfo);
                        if (SOC_E_NONE == auxRes) {
                            LOG_ERROR(BSL_LS_SOC_COMMON,
                                      (BSL_META_U(unit,
                                                  "unit %d program %u filter"
                                                  " set %u imem allocator"
                                                  " block info including %03X"
                                                  " : %08X %08X %08X"
                                                  " (%03X..%03X, list %u)\n"),
                                       unit,
                                       program,
                                       filterSet,
                                       imemFirst,
                                       mdbInfo.head,
                                       mdbInfo.size,
                                       mdbInfo.list,
                                       mdbInfo.head,
                                       mdbInfo.head + mdbInfo.size - 1,
                                       mdbInfo.list));
                        }
                        SOC_C3_RCE_STATE_FAIL_CORRUPT;
                    }
                } else { /* if (fsetData) */
                    if (filterSetEntCount) {
                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                  (BSL_META_U(unit,
                                              "unit %d program %u filter set"
                                              " %u (padding) expected zero"
                                              " entries but HW counted %u\n"),
                                   unit,
                                   program,
                                   filterSet,
                                   filterSetEntCount));
                        SOC_C3_RCE_STATE_FAIL_CORRUPT;
                    }
                } /* if (fsetData) */


                /* check other per-filter-set data */


                /* next filter set */
                filterSet++;
                progEntryCount += filterSetEntCount;
            } while (!foundProgEnd);
            /* check per-progrma data */
            totProgLength += (progLength + progPadding);
            totEntryCount += progEntryCount;
            totGroupCount += progGroupCount;
            if (progLength != progData->instrBlockCount) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "unit %d program %u HW length %u,"
                                      " but SW expected %u\n"),
                           unit,
                           program,
                           progLength,
                           progData->instrBlockCount));
                SOC_C3_RCE_STATE_FAIL_CORRUPT;
            }
            if (progPadding != progData->instrBlockAdded) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "unit %d program %u HW padding length"
                                      " %u, but SW expected %u\n"),
                           unit,
                           program,
                           progPadding,
                           progData->instrBlockAdded));
                SOC_C3_RCE_STATE_FAIL_CORRUPT;
            }
            if (filterSetCnt != progData->filterSetCount) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "unit %d program %u HW filter set"
                                      " count %u, but SW expected %u\n"),
                           unit,
                           program,
                           filterSet,
                           progData->filterSetCount));
                SOC_C3_RCE_STATE_FAIL_CORRUPT;
            }
            if (progData->groupCount != progGroupCount) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "unit %d program %u scanned group count"
                                      " %u disagrees with expected group"
                                      " count %u\n"),
                           unit,
                           program,
                           progGroupCount,
                           progData->groupCount));
                SOC_C3_RCE_STATE_FAIL_CORRUPT;
            }
            for (groupData = progData->groupHead, groupId = 0;
                 groupData &&
                 (groupData != progData->groupTail);
                 groupData = groupData->groupNext) {
                groupId++;
            }
            if (groupData) {
                /* need to count the 'tail' group, too */
                groupId++;
            }
            if (groupData != progData->groupTail) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "unit %d program %u group chain tail"
                                      " link is not correct\n"),
                           unit,
                           program));
                SOC_C3_RCE_STATE_FAIL_CORRUPT;
            }
            if (groupId != progData->groupCount) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "unit %d program %u group count %u"
                                      " disagrees with counted groups %u\n"),
                           unit,
                           program,
                           progData->groupCount,
                           groupId));
                SOC_C3_RCE_STATE_FAIL_CORRUPT;
            }


            /* check other per-program data */


        } else { /* if (program_config.en is nonzero) */
            /* this program is disabled in hardware */
            if (unitData->progData[program]) {
                /* this program should be enabled in hardware */
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "unit %d program %u is disabled in"
                                      " hardware but enabled in software\n"),
                           unit,
                           program));
                SOC_C3_RCE_STATE_FAIL_MISMATCH;
            }
        } /* if (program_config.en is nonzero) */
    } /* for (all possible programs in hardware) */
    totGroupEntryCount = 0;
    for (groupId = 0; groupId < unitData->groupLimit; groupId++) {
        groupEntryCount = 0;
        if (!(groupData = unitData->groupData[groupId])) {
            /* assignment to groupData intentional */
            /* no group, so skip this one */
            continue;
        }
        for (entryData = groupData->entryHead;
             entryData &&
             (entryData != groupData->entryTail);
             entryData = entryData->entryNext) {
            groupEntryCount++;
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
            if (((~0) != entryData->entryPosPrev) &&
                (entryData->entryPosition != entryData->entryPosPrev)) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "unit %d entry %d previous position %u"
                                      " should be equal to position %u\n"),
                           unit,
                           entryData->entryId,
                           entryData->entryPosPrev,
                           entryData->entryPosition));
                SOC_C3_RCE_STATE_FAIL_CORRUPT;
            }
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
        }
        if (entryData) {
            /* need to count the last entry */
            groupEntryCount++;
        }
        if (entryData != groupData->entryTail) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unit %d group %d entry chain tail link"
                                  " is not correct\n"),
                       unit,
                       groupId));
            SOC_C3_RCE_STATE_FAIL_CORRUPT;
        }
        if (groupEntryCount != groupData->entryCount) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unit %d group %d entry count %u disagrees"
                                  " with counted entries %u in group\n"),
                       unit,
                       groupId,
                       groupData->entryCount,
                       groupEntryCount));
            SOC_C3_RCE_STATE_FAIL_CORRUPT;
        }
        totGroupEntryCount += groupEntryCount;
    }
    if (totGroupEntryCount != totEntryCount) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d counted %u entries by scanning filter"
                              " sets but counted %u entries by scanning"
                              " groups\n"),
                   unit,
                   totEntryCount,
                   totGroupEntryCount));
        SOC_C3_RCE_STATE_FAIL_CORRUPT;
    }
    if (totProgLength != unitData->instrBlockCount) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d all programs length %d"
                              " but expected %d\n"),
                   unit,
                   totProgLength,
                   unitData->instrBlockCount));
        SOC_C3_RCE_STATE_FAIL_CORRUPT;
    }
    if (imemBlockCount != unitData->imemBlockCount) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d filter set count %d for all programs,"
                              " but expected %d\n"),
                   unit,
                   imemBlockCount,
                   unitData->imemBlockCount));
        SOC_C3_RCE_STATE_FAIL_CORRUPT;
    }
    for (groupId = 0, index = 0; groupId < unitData->groupLimit; groupId++) {
        if (unitData->groupData[groupId]) {
            index++;
        }
    }
    if (totGroupCount != index) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d has %u active groups,"
                              " but program scan counted %u\n"),
                   unit,
                   index,
                   totGroupCount));
        SOC_C3_RCE_STATE_FAIL_CORRUPT;
    }
    for (index = 0; index < unitData->actTableCount; index++) {
        if (unitData->actData[index]->entryActive != actBlocksUsed[index]) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unit %d action table %u (%s) claims %u"
                                  " blocks in use, but expected %u\n"),
                       unit,
                       index,
                       unitData->actData[index]->ucData->tableName,
                       unitData->actData[index]->entryActive,
                       actBlocksUsed[index]));
            SOC_C3_RCE_STATE_FAIL_CORRUPT;
        }
        auxRes = shr_mres_type_info_get(unitData->amemRes,
                                        index,
                                        &mresInfo);
        if (SOC_E_NONE == auxRes) {
            if (mresInfo.used != actBlocksUsed[index]) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "unit %d action table %u (%s) resource"
                                      " manager claims %u blocks used, but"
                                      " expected %u\n"),
                           unit,
                           index,
                           unitData->actData[index]->ucData->tableName,
                           mresInfo.used,
                           actBlocksUsed[index]));
                SOC_C3_RCE_STATE_FAIL_CORRUPT;
            }
        } else {
            SOC_C3_RCE_STATE_FAIL_ERROR;
        }
    } /* for (all action tables) */
error:
    /* clean up workspace */
    if (actBuffer) {
        sal_free(actBuffer);
    }
    if (rangeRefs) {
        sal_free(rangeRefs);
    }
    if (entryList) {
        sal_free(entryList);
    }
    if (posEnable) {
        sal_free(posEnable);
    }
    if (instrBlks) {
        sal_free(instrBlks);
    }
    if (imemPmemTemp) {
        sal_dma_free(imemPmemTemp);
    }
    if (imemTemp) {
        sal_dma_free(imemTemp);
    }
    if (actBlocksUsed) {
        sal_free(actBlocksUsed);
    }
    return result;
}

int
soc_c3_rce_wb_immed_sync(int unit)
{
#ifdef BCM_WARM_BOOT_SUPPORT
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    /* called function will emit diagnostics */
    return _soc_c3_rce_wb_immed_sync(unitData);
#else /* def BCM_WARM_BOOT_SUPPORT */
    LOG_ERROR(BSL_LS_SOC_COMMON,
              (BSL_META_U(unit,
                          "warm boot support is not enabled\n")));
    return SOC_E_UNAVAIL;
#endif /* def BCM_WARM_BOOT_SUPPORT */
}

int
soc_c3_rce_info_get(int unit,
                    soc_c3_rce_unit_desc_t **unitInfo)
{
    _soc_c3_rce_unit_desc_int_t *unitData;
    soc_c3_rce_unit_desc_t *tempInfo;
    unsigned int index;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if (!unitInfo) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "obligatory OUT argument must not be NULL\n")));
        return SOC_E_PARAM;
    }
    tempInfo = sal_alloc(sizeof(*tempInfo), "C3 RCE unit information");
    if (!tempInfo) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unable to allocate %u bytes for unit %d info\n"),
                   (unsigned int)sizeof(*tempInfo),
                   unit));
        return SOC_E_MEMORY;
    }
    sal_memset(tempInfo, 0x00, sizeof(*tempInfo));
    tempInfo->rangeMaxCount = unitData->rangeLimit;
    tempInfo->actionTableCount = unitData->actTableCount;
    for (index = 0; index < unitData->actTableCount; index++) {
        tempInfo->entryMaxCount += (unitData->actData[index]->entryLimit *
                                    C3_RCE_ENTRIES_PER_FILTER_SET);
        tempInfo->groupMaxCount += unitData->actData[index]->entryLimit;
    }
    for (index = 0; index < SOC_C3_RCE_PROGRAM_COUNT; index++) {
        if (unitData->progData[index]) {
            tempInfo->programCount++;
            tempInfo->groupsInUse += unitData->progData[index]->groupCount;
        }
    }
    for (index = 0; index < unitData->groupLimit; index++) {
        if (unitData->groupData[index]) {
            tempInfo->entriesInUse += unitData->groupData[index]->entryCount;
        }
    }
    for (index = 0; index < unitData->rangeLimit; index++) {
        if (unitData->rangeData[index]) {
            tempInfo->rangesInUse++;
        }
    }
    *unitInfo = tempInfo;
    return SOC_E_NONE;
}

void
soc_c3_rce_info_free(int unit,
                     soc_c3_rce_unit_desc_t *unitInfo)
{
    /*
     *  For now, we don't really *need* unit, but it's pretty common to have
     *  the unit argument, and maybe we'll need it in the future, so it's here.
     */
    if (unitInfo) {
        sal_free(unitInfo);
    }
}

int
soc_c3_rce_dump(int unit,
                uint32 flags,
                const char *prefix)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
#if defined(BROADCOM_DEBUG)
    return _soc_c3_rce_unit_dump(unitData, flags, prefix);
#else /* defined(BROADCOM_DEBUG) */
    return SOC_E_NONE;
#endif /* defined(BROADCOM_DEBUG) */
}

int
soc_c3_rce_debug_capture_parse(int unit,
                               uint32 *flags,
                               uint8 *keyData,
                               int *programId,
                               int *entryIds)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if ((!flags) || (!keyData) || (!programId) || (!entryIds)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "obligatory OUT argument must not be NULL\n")));
        return SOC_E_PARAM;
    }
    return _soc_c3_rce_debug_capture_parse(unitData,
                                           flags,
                                           keyData,
                                           programId,
                                           entryIds);
}

int
soc_c3_rce_debug_capture_set(int unit,
                             uint32 flags,
                             uint32 threshold,
                             const uint8 *keyData,
                             const uint8 *keyMask,
                             int programId)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    return _soc_c3_rce_debug_capture_set(unitData,
                                         flags,
                                         threshold,
                                         keyData,
                                         keyMask,
                                         programId);
}

int
soc_c3_rce_debug_capture_get(int unit,
                             uint32 *flags,
                             uint32 *threshold,
                             uint32 *threshCount,
                             uint8 *keyData,
                             uint8 *keyMask,
                             int *programId)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if ((!flags) || (!threshold) || (!threshCount) ||
        (!keyData) || (!keyMask) || (!programId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "obligatory OUT argument must not be NULL\n")));
        return SOC_E_PARAM;
    }
    return _soc_c3_rce_debug_capture_get(unitData,
                                         flags,
                                         threshold,
                                         threshCount,
                                         keyData,
                                         keyMask,
                                         programId);
}

int
soc_c3_rce_result_hit_counter_read(int unit,
                                   int hitCounter,
                                   uint32 *value)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if (!value) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "obligatory OUT argument must not be NULL\n")));
        return SOC_E_PARAM;
    }
    return _soc_c3_rce_result_hit_counter_read(unitData, hitCounter, value);
}

int
soc_c3_rce_result_hit_counter_set(int unit,
                                  int hitCounter,
                                  int entryId0,
                                  int entryId1)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if ((0 > entryId0) || (unitData->entryLimit <= entryId0)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"),
                   unit, entryId0));
        return SOC_E_BADID;
    }
    if ((0 > entryId1) || (unitData->entryLimit <= entryId1)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"),
                   unit, entryId1));
        return SOC_E_BADID;
    }
    if (!(unitData->entryData[entryId0])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d does not exist \n"),
                   unit,
                   entryId0));
        return SOC_E_NOT_FOUND;
    }
    if (!(unitData->entryData[entryId1])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d does not exist \n"),
                   unit,
                   entryId1));
        return SOC_E_NOT_FOUND;
    }
    return _soc_c3_rce_result_hit_counter_set(unitData,
                                              hitCounter,
                                              entryId0,
                                              entryId1);
}

int
soc_c3_rce_program_next_existing(int unit,
                                 int currProgramId,
                                 int *nextProgramId)
{
    _soc_c3_rce_unit_desc_int_t *unitData;
    unsigned int index;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if (!nextProgramId) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "obligatory pointer argument must not be NULL\n")));
        return SOC_E_PARAM;
    }
    if ((0 > currProgramId) || (SOC_C3_RCE_PROGRAM_COUNT <= currProgramId)) {
        /* current program ID is invalid; start at zero */
        index = 0;
        if (unitData->progData[index]) {
            /* program zero exists; no need to scan */
            *nextProgramId = index;
            return SOC_E_NONE;
        }
    } else {
        index = currProgramId;
    }
    do {
        index++;
    } while ((index < SOC_C3_RCE_PROGRAM_COUNT) &&
             (!(unitData->progData[index])));
    if (index < SOC_C3_RCE_PROGRAM_COUNT) {
        /* found an active program before we fell off the end */
        *nextProgramId = index;
        return SOC_E_NONE;
    } else {
        /* did not find any more active programs */
        return SOC_E_NOT_FOUND;
    }
}

int
soc_c3_rce_program_info_get(int unit,
                            int programId,
                            soc_c3_rce_program_desc_t **programInfo)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if ((0 > programId) || (SOC_C3_RCE_PROGRAM_COUNT <= programId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d program %d is not valid\n"),
                   unit,
                   programId));
        return SOC_E_BADID;
    }
    if (!(unitData->progData[programId])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d program %d is not active\n"),
                   unit,
                   programId));
        return SOC_E_NOT_FOUND;
    }
    if (!programInfo) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "obligatory OUT argumnet must not be NULL\n")));
        return SOC_E_PARAM;
    }
    return _soc_c3_rce_program_info_get(unitData,
                                        programId,
                                        programInfo);
}

void
soc_c3_rce_program_info_free(int unit,
                             soc_c3_rce_program_desc_t *programInfo)
{
    /*
     *  For now, we don't really *need* unit, but it's pretty common to have
     *  the unit argument, and maybe we'll need it in the future, so it's here.
     */
    if (programInfo) {
        /* not NULL */
        if (programInfo->keyFields) {
            /* key fields are present */
            sal_free(programInfo->keyFields);
            programInfo->keyFields = NULL;
        }
        sal_free(programInfo);
    }
}

int
soc_c3_rce_program_traverse(int unit,
                            soc_c3_rce_program_traverse_cb_t callback,
                            void *extras)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if (!callback) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "must have callback function provided\n")));
        return SOC_E_PARAM;
    }
    return _soc_c3_rce_program_traverse(unitData, callback, extras);
}

int
soc_c3_rce_program_dump(int unit,
                        uint32 flags,
                        const char *prefix,
                        int programId)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if ((0 > programId) || (SOC_C3_RCE_PROGRAM_COUNT <= programId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d program %d is not valid\n"),
                   unit,
                   programId));
        return SOC_E_BADID;
    }
    if (!(unitData->progData[programId])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d program %d is not active\n"),
                   unit,
                   programId));
        return SOC_E_NOT_FOUND;
    }
#if defined(BROADCOM_DEBUG)
    return _soc_c3_rce_program_dump(unitData, flags, prefix, programId);
#else /* defined(BROADCOM_DEBUG) */
    return SOC_E_NONE;
#endif /* defined(BROADCOM_DEBUG) */
}

int
soc_c3_rce_program_qualifier_build(int unit,
                                   int programId,
                                   soc_c3_rce_header_field_info_t *headerField,
                                   soc_c3_rce_qual_type_t qualType,
                                   soc_c3_rce_qual_desc_t **qualDesc)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if ((0 > programId) || (SOC_C3_RCE_PROGRAM_COUNT <= programId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d program %d is not valid\n"),
                   unit,
                   programId));
        return SOC_E_BADID;
    }
    if (!(unitData->progData[programId])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d program %d is not active\n"),
                   unit,
                   programId));
        return SOC_E_NOT_FOUND;
    }
    if ((!headerField) || (!qualDesc)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "obligatory pointer argument must not be NULL\n")));
        return SOC_E_PARAM;
    }
    return _soc_c3_rce_program_qualifier_build(unitData,
                                               programId,
                                               headerField,
                                               qualType,
                                               qualDesc);
}

void
soc_c3_rce_program_qualifier_free(int unit,
                                  soc_c3_rce_qual_desc_t *qualDesc)
{
    /*
     *  For now, we don't really *need* unit, but it's pretty common to have
     *  the unit argument, and maybe we'll need it in the future, so it's here.
     */
    if (qualDesc) {
        if (qualDesc->param) {
            sal_free(qualDesc->param);
        }
        sal_free(qualDesc);
    }
}

int
soc_c3_rce_program_scan(int unit,
                        int programId,
                        const uint8 *keyData,
                        int *hitEntries)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if ((0 > programId) || (SOC_C3_RCE_PROGRAM_COUNT <= programId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d program %d is not valid\n"),
                   unit,
                   programId));
        return SOC_E_BADID;
    }
    if (!(unitData->progData[programId])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d program %d is not active\n"),
                   unit,
                   programId));
        return SOC_E_NOT_FOUND;
    }
    if (!keyData) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "obligatory argument must not be NULL\n")));
        return SOC_E_PARAM;
    }
    if (!hitEntries) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "obligatory OUT argument must not be NULL\n")));
        return SOC_E_PARAM;
    }
    return _soc_c3_rce_program_scan(unitData,
                                    1 /* scan hardware view */,
                                    programId,
                                    keyData,
                                    hitEntries);
}

int
soc_c3_rce_actiontable_info_get(int unit,
                                unsigned int actionTable,
                                soc_c3_rce_actiontable_desc_t **actionTableInfo)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if (unitData->actTableCount <= actionTable) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d action table %u is not valid\n"),
                   unit,
                   actionTable));
        return SOC_E_BADID;
    }
    if (!(unitData->actData[actionTable])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d action table %u is not active\n"),
                   unit,
                   actionTable));
        return SOC_E_NOT_FOUND;
    }
    if (!actionTableInfo) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "obligatory OUT argumnet must not be NULL\n")));
        return SOC_E_PARAM;
    }
    return _soc_c3_rce_actiontable_info_get(unitData,
                                            actionTable,
                                            actionTableInfo);
}

void
soc_c3_rce_actiontable_info_free(int unit,
                                 soc_c3_rce_actiontable_desc_t *actionTableInfo)
{
    /*
     *  For now, we don't really *need* unit, but it's pretty common to have
     *  the unit argument, and maybe we'll need it in the future, so it's here.
     */
    if (actionTableInfo) {
        /* not NULL */
        if (actionTableInfo->actFields) {
            /* action fields are present */
            sal_free(actionTableInfo->actFields);
            actionTableInfo->actFields = NULL;
        }
        sal_free(actionTableInfo);
    }
}

int
soc_c3_rce_group_first_avail(int unit,
                             int *firstAvailGroupId)
{
    _soc_c3_rce_unit_desc_int_t *unitData;
    unsigned int index;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if (!firstAvailGroupId) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "obligatory pointer argument must not be NULL\n")));
        return SOC_E_PARAM;
    }
    for (index = 0; index < unitData->groupLimit; index++) {
        if (!(unitData->groupData[index])) {
            /* this group does not yet exist; use it */
            *firstAvailGroupId = index;
            return SOC_E_NONE;
        }
    }
    LOG_ERROR(BSL_LS_SOC_COMMON,
              (BSL_META_U(unit,
                          "unit %d does not have any available group IDs\n"),
               unit));
    return SOC_E_RESOURCE;
}

int
soc_c3_rce_group_next_existing(int unit,
                               int currGroupId,
                               int *nextGroupId)
{
    _soc_c3_rce_unit_desc_int_t *unitData;
    unsigned int index;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if (!nextGroupId) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "obligatory pointer argument must not be NULL\n")));
        return SOC_E_PARAM;
    }
    if ((0 > currGroupId) || (unitData->groupLimit <= currGroupId)) {
        /* current group ID is invalid; start at zero */
        index = 0;
        if (unitData->groupData[index]) {
            /* group zero exists; no need to scan */
            *nextGroupId = index;
            return SOC_E_NONE;
        }
    } else {
        index = currGroupId;
    }
    do {
        index++;
    } while ((!(unitData->groupData[index])) &&
             (index < unitData->groupLimit));
    if (index < unitData->groupLimit) {
        /* found an active group before we fell off the end */
        *nextGroupId = index;
        return SOC_E_NONE;
    } else {
        /* did not find any more active groups */
        return SOC_E_NOT_FOUND;
    }
}

int
soc_c3_rce_group_info_get(int unit,
                          int groupId,
                          soc_c3_rce_group_desc_t **groupInfo)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if (!groupInfo) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "obligatory pointer argument must not be NULL\n")));
        return SOC_E_PARAM;
    }
    if ((0 > groupId) || (unitData->groupLimit < groupId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d group %d is not valid\n"),
                   unit, groupId));
        return SOC_E_BADID;
    }
    if (!(unitData->groupData[groupId])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d group %d does not exist \n"),
                   unit,
                   groupId));
        return SOC_E_NOT_FOUND;
    }
    return _soc_c3_rce_group_info_get(unitData, groupId, groupInfo);
}

extern void
soc_c3_rce_group_info_free(int unit,
                           soc_c3_rce_group_desc_t *groupInfo)
{
    unsigned int index;
    /*
     *  For now, we don't really *need* unit, but it's pretty common to have
     *  the unit argument, and maybe we'll need it in the future, so it's here.
     */
    if (groupInfo) {
        for (index = 0; index < SOC_C3_RCE_GROUP_QUAL_MAX; index++) {
            if (groupInfo->qualData[index]) {
                /* this qualifier is present */
                sal_free(groupInfo->qualData[index]);
                groupInfo->qualData[index] = NULL;
            }
        }
        sal_free(groupInfo);
    } /* if (groupInfo) */
}

int
soc_c3_rce_group_traverse(int unit,
                          int programId,
                          soc_c3_rce_group_traverse_cb_t callback,
                          void *extras)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if ((0 > programId) || (SOC_C3_RCE_PROGRAM_COUNT <= programId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d program %d is not valid\n"),
                   unit,
                   programId));
        return SOC_E_BADID;
    }
    if (!(unitData->progData[programId])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d program %d is not active\n"),
                   unit,
                   programId));
        return SOC_E_NOT_FOUND;
    }
    if (!callback) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "must have callback function provided\n")));
        return SOC_E_PARAM;
    }
    return _soc_c3_rce_group_traverse(unitData, programId, callback, extras);
}

int
soc_c3_rce_group_dump(int unit,
                      uint32 flags,
                      const char *prefix,
                      int groupId)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if ((0 > groupId) || (unitData->groupLimit <= groupId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d group %d is not valid\n"),
                   unit,
                   groupId));
        return SOC_E_BADID;
    }
    if (!(unitData->groupData[groupId])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d group %d is not active\n"),
                   unit,
                   groupId));
        return SOC_E_NOT_FOUND;
    }
#if defined(BROADCOM_DEBUG)
    return _soc_c3_rce_group_dump(unitData, flags, prefix, groupId);
#else /* defined(BROADCOM_DEBUG) */
    return SOC_E_NONE;
#endif /* defined(BROADCOM_DEBUG) */
}

int
soc_c3_rce_group_create(int unit,
                        int groupId,
                        const soc_c3_rce_group_desc_t *groupInfo)
{
    _soc_c3_rce_unit_desc_int_t *unitData;
    unsigned int index;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if ((0 > groupId) || (unitData->groupLimit <= groupId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d group %d is not valid\n"),
                   unit, groupId));
        return SOC_E_BADID;
    }
    if (unitData->groupData[groupId]) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d group %d already exists\n"),
                   unit, groupId));
        return SOC_E_EXISTS;
    }
    if (!groupInfo) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "obligatory pointer argument must not be NULL\n")));
        return SOC_E_PARAM;
    }
    if ((1 > groupInfo->qualCount) ||
        (SOC_C3_RCE_GROUP_QUAL_MAX <= groupInfo->qualCount)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d group %d qualifier count %u not valid;"
                               " must be 1..%d\n"),
                   unit,
                   groupId,
                   groupInfo->qualCount,
                   SOC_C3_RCE_GROUP_QUAL_MAX));
        return SOC_E_PARAM;
    }
    for (index = 0; index < groupInfo->qualCount; index++) {
        if (!(groupInfo->qualData[index])) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unit %d group %d qualifier data %u must not"
                                   " be NULL with qualifier count %u\n"),
                       unit,
                       groupId,
                       index,
                       groupInfo->qualCount));
            return SOC_E_PARAM;
        }
    }
    /* coverity[stack_use_overflow] */
    return _soc_c3_rce_group_create(unitData, groupId, groupInfo);
}

int
soc_c3_rce_group_destroy(int unit,
                         int groupId)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if ((0 > groupId) || (unitData->groupLimit <= groupId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d group %d is not valid\n"),
                   unit,
                   groupId));
        return SOC_E_BADID;
    }
    if (!(unitData->groupData[groupId])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d group %d is not active\n"),
                   unit,
                   groupId));
        return SOC_E_NOT_FOUND;
    }
    return _soc_c3_rce_group_destroy(unitData, groupId);
}

int
soc_c3_rce_group_install(int unit,
                         int groupId)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if ((0 > groupId) || (unitData->groupLimit <= groupId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d group %d is not valid\n"),
                   unit,
                   groupId));
        return SOC_E_BADID;
    }
    if (!(unitData->groupData[groupId])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d group %d is not active\n"),
                   unit,
                   groupId));
        return SOC_E_NOT_FOUND;
    }
    return _soc_c3_rce_group_install(unitData, groupId);
}

int
soc_c3_rce_group_remove(int unit,
                        int groupId)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if ((0 > groupId) || (unitData->groupLimit <= groupId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d group %d is not valid\n"),
                   unit,
                   groupId));
        return SOC_E_BADID;
    }
    if (!(unitData->groupData[groupId])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d group %d is not active\n"),
                   unit,
                   groupId));
        return SOC_E_NOT_FOUND;
    }
    return _soc_c3_rce_group_remove(unitData, groupId);
}

int
soc_c3_rce_group_compress(int unit,
                          int groupId)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if ((0 > groupId) || (unitData->groupLimit <= groupId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d group %d is not valid\n"),
                   unit,
                   groupId));
        return SOC_E_BADID;
    }
    if (!(unitData->groupData[groupId])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d group %d is not active\n"),
                   unit,
                   groupId));
        return SOC_E_NOT_FOUND;
    }
    return _soc_c3_rce_group_compress(unitData, groupId);
}

int
soc_c3_rce_entry_first_avail(int unit,
                             int *firstAvailEntryId)
{
    _soc_c3_rce_unit_desc_int_t *unitData;
    unsigned int index;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if (!firstAvailEntryId) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "obligatory pointer argument must not be NULL\n")));
        return SOC_E_PARAM;
    }
    for (index = unitData->entryAvailLast;
         index < unitData->entryLimit;
         index++) {
        if (!(unitData->entryData[index])) {
            /* this entry does not yet exist; use it */
            *firstAvailEntryId = index;
            unitData->entryAvailLast = index;
            return SOC_E_NONE;
        }
    }
    for (index = 0; index < unitData->entryAvailLast; index++) {
        if (!(unitData->entryData[index])) {
            /* this entry does not yet exist; use it */
            *firstAvailEntryId = index;
            unitData->entryAvailLast = index;
            return SOC_E_NONE;
        }
    }
    LOG_ERROR(BSL_LS_SOC_COMMON,
              (BSL_META_U(unit,
                          "unit %d does not have any available entry IDs\n"),
               unit));
    return SOC_E_RESOURCE;
}

int
soc_c3_rce_entry_next_existing(int unit,
                               int currEntryId,
                               int *nextEntryId)
{
    _soc_c3_rce_unit_desc_int_t *unitData;
    unsigned int index;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if (!nextEntryId) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "obligatory pointer argument must not be NULL\n")));
        return SOC_E_PARAM;
    }
    if ((0 > currEntryId) || (unitData->entryLimit <= currEntryId)) {
        /* current entry ID is invalid; start at zero */
        index = 0;
        if (unitData->entryData[index]) {
            /* entry zero exists; no need to scan */
            *nextEntryId = index;
            return SOC_E_NONE;
        }
    } else {
        index = currEntryId;
    }
    do {
        index++;
    } while ((!(unitData->entryData[index])) &&
             (index < unitData->entryLimit));
    if (index < unitData->entryLimit) {
        /* found an active entry before we fell off the end */
        *nextEntryId = index;
        return SOC_E_NONE;
    } else {
        /* did not find any more active entries */
        return SOC_E_NOT_FOUND;
    }
}

int
soc_c3_rce_entry_info_get(int unit,
                          int entryId,
                          soc_c3_rce_entry_desc_t **entryInfo)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if (!entryInfo) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "obligatory pointer argument must not be NULL\n")));
        return SOC_E_PARAM;
    }
    if ((0 > entryId) || (unitData->entryLimit < entryId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"),
                   unit, entryId));
        return SOC_E_BADID;
    }
    if (!(unitData->entryData[entryId])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d does not exist \n"),
                   unit,
                   entryId));
        return SOC_E_NOT_FOUND;
    }
    return _soc_c3_rce_entry_info_get(unitData, entryId, entryInfo);
}

void
soc_c3_rce_entry_info_free(int unit,
                           soc_c3_rce_entry_desc_t *entryInfo)
{
    /*
     *  For now, we don't really *need* unit, but it's pretty common to have
     *  the unit argument, and maybe we'll need it in the future, so it's here.
     */
    if (entryInfo) {
        sal_free(entryInfo);
    } /* if (entryInfo) */
}

int
soc_c3_rce_entry_traverse(int unit,
                          int groupId,
                          soc_c3_rce_entry_traverse_cb_t callback,
                          void *extras)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if ((0 > groupId) || (unitData->groupLimit <= groupId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d group %d is not valid\n"),
                   unit, groupId));
        return SOC_E_BADID;
    }
    if (!(unitData->groupData[groupId])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d group %d is not active\n"),
                   unit, groupId));
        return SOC_E_BADID;
    }
    if (!callback) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "must have callback function provided\n")));
        return SOC_E_PARAM;
    }
    return _soc_c3_rce_entry_traverse(unitData, groupId, callback, extras);
}

int
soc_c3_rce_entry_dump(int unit,
                      uint32 flags,
                      const char *prefix,
                      int entryId)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if ((0 > entryId) || (unitData->entryLimit <= entryId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"),
                   unit,
                   entryId));
        return SOC_E_BADID;
    }
    if (!(unitData->entryData[entryId])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not active\n"),
                   unit,
                   entryId));
        return SOC_E_NOT_FOUND;
    }
#if defined(BROADCOM_DEBUG)
    return _soc_c3_rce_entry_dump(unitData, flags, prefix, entryId);
#else /* defined(BROADCOM_DEBUG) */
    return SOC_E_NONE;
#endif /* defined(BROADCOM_DEBUG) */
}

int
soc_c3_rce_entry_create(int unit,
                        int entryId,
                        const soc_c3_rce_entry_desc_t *entryInfo)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if ((0 > entryId) || (unitData->entryLimit <= entryId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"),
                   unit, entryId));
        return SOC_E_BADID;
    }
    if (unitData->entryData[entryId]) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d already exists\n"),
                   unit, entryId));
        return SOC_E_EXISTS;
    }
    if (!entryInfo) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "obligatory pointer argument must not be NULL\n")));
        return SOC_E_PARAM;
    }
    if ((0 > entryInfo->groupId) ||
        (unitData->groupLimit <= entryInfo->groupId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d group %d is not valid\n"),
                   unit,
                   entryInfo->groupId));
        return SOC_E_BADID;
    }
    if (!(unitData->groupData[entryInfo->groupId])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d group %d does not exist\n"),
                   unit,
                   entryInfo->groupId));
        return SOC_E_NOT_FOUND;
    }
    return _soc_c3_rce_entry_create(unitData,
                                    0 /* flags */,
                                    entryInfo->groupId,
                                    entryId,
                                    entryInfo->entryPriority,
                                    ~0 /* source entry */);
}

int
soc_c3_rce_entry_copy(int unit,
                      uint32 copyFlags,
                      int entryId,
                      const soc_c3_rce_entry_desc_t *entryInfo,
                      int sourceEntryId)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if ((0 > entryId) || (unitData->entryLimit <= entryId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"),
                   unit, entryId));
        return SOC_E_BADID;
    }
    if (unitData->entryData[entryId]) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d already exists\n"),
                   unit, entryId));
        return SOC_E_EXISTS;
    }
    if (!entryInfo) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "obligatory pointer argument must not be NULL\n")));
        return SOC_E_PARAM;
    }
    if ((0 > sourceEntryId) || (unitData->entryLimit <= sourceEntryId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"),
                   unit,
                   sourceEntryId));
        return SOC_E_BADID;
    }
    if (!unitData->entryData[sourceEntryId]) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d does not exist\n"),
                   unit,
                   sourceEntryId));
        return SOC_E_NOT_FOUND;
    }
    if (unitData->entryData[sourceEntryId]->entryGroup != entryInfo->groupId) {
        LOG_WARN(BSL_LS_SOC_COMMON,
                 (BSL_META_U(unit,
                             "ignoring specified group %d since copy can only"
                              " be made to same group %d as source entry %d\n"),
                  entryInfo->groupId,
                  unitData->entryData[sourceEntryId]->entryGroup,
                  sourceEntryId));
    }
    if (!(unitData->groupData[entryInfo->groupId])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d group %d does not exist\n"),
                   unit,
                   entryInfo->groupId));
        return SOC_E_NOT_FOUND;
    }
    return _soc_c3_rce_entry_create(unitData,
                                    copyFlags,
                                    unitData->entryData[sourceEntryId]->entryGroup,
                                    entryId,
                                    entryInfo->entryPriority,
                                    sourceEntryId);
}

int
soc_c3_rce_entry_priority_set(int unit,
                              int entryId,
                              int entryPriority)
{
    _soc_c3_rce_unit_desc_int_t *unitData;
    int tempEntry;
    int result;
    int auxRes COMPILER_ATTRIBUTE((unused));

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if ((0 > entryId) || (unitData->entryLimit <= entryId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"),
                   unit, entryId));
        return SOC_E_BADID;
    }
    if (!unitData->entryData[entryId]) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d does not exist\n"),
                   unit, entryId));
        return SOC_E_NOT_FOUND;
    }
    /* get an available entry ID */
    result = soc_c3_rce_entry_first_avail(unit, &tempEntry);
    if (SOC_E_NONE == result) {
        /* create a copy at the new priority */
        result = _soc_c3_rce_entry_create(unitData,
                                          SOC_C3_RCE_ENTRY_COPY_SOURCE_ALL,
                                          unitData->entryData[entryId]->entryGroup,
                                          tempEntry,
                                          entryPriority,
                                          entryId);
    }
    if (SOC_E_NONE == result) {
        /* get rid of the original */
        result = _soc_c3_rce_entry_destroy(unitData, entryId);
        if (unitData->entryData[entryId]) {
            /* unable to get rid of the old one; destroy new one instead */
            auxRes = _soc_c3_rce_entry_destroy(unitData, tempEntry);
        } else {
            /* got rid of the old one; put the new one in its place */
            unitData->entryData[entryId] = unitData->entryData[tempEntry];
            unitData->entryData[entryId]->entryId = entryId;
            unitData->entryData[tempEntry] = NULL;
        }
    }
    return result;
}

int
soc_c3_rce_entry_destroy(int unit,
                         int entryId)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if ((0 > entryId) || (unitData->entryLimit < entryId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"),
                   unit, entryId));
        return SOC_E_BADID;
    }
    if (!(unitData->entryData[entryId])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d does not exist \n"),
                   unit,
                   entryId));
        return SOC_E_NOT_FOUND;
    }
    return _soc_c3_rce_entry_destroy(unitData, entryId);
}
int
soc_c3_rce_entry_qualify_set(int unit,
                             int entryId,
                             unsigned int qualIdx,
                             const uint8 *data,
                             const uint8 *mask)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if ((0 > entryId) || (unitData->entryLimit <= entryId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"),
                   unit, entryId));
        return SOC_E_BADID;
    }
    if (!unitData->entryData[entryId]) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d does not exist\n"),
                   unit, entryId));
        return SOC_E_NOT_FOUND;
    }
    if ((!data) || (!mask)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "obligatory pointer argument must not be NULL\n")));
        return SOC_E_PARAM;
    }
    return _soc_c3_rce_entry_qualify_set(unitData,
                                         entryId,
                                         qualIdx,
                                         data,
                                         mask);
}

int
soc_c3_rce_entry_qualify_get(int unit,
                             int entryId,
                             unsigned int qualIdx,
                             uint8 *data,
                             uint8 *mask)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if ((0 > entryId) || (unitData->entryLimit <= entryId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"),
                   unit, entryId));
        return SOC_E_BADID;
    }
    if (!unitData->entryData[entryId]) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d does not exist\n"),
                   unit, entryId));
        return SOC_E_NOT_FOUND;
    }
    if ((!data) || (!mask)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "obligatory pointer argument must not be NULL\n")));
        return SOC_E_PARAM;
    }
    return _soc_c3_rce_entry_qualify_get(unitData,
                                         entryId,
                                         qualIdx,
                                         data,
                                         mask);
}

int
soc_c3_rce_entry_qualify_range_traverse(int unit,
                                        int entryId,
                                        soc_c3_rce_entry_qualify_range_traverse_cb_t callback,
                                        void *extras)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if ((0 > entryId) || (unitData->entryLimit <= entryId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"),
                   unit, entryId));
        return SOC_E_BADID;
    }
    if (!unitData->entryData[entryId]) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d does not exist\n"),
                   unit, entryId));
        return SOC_E_NOT_FOUND;
    }
    if (!callback) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "callback must be specified\n")));
        return SOC_E_PARAM;
    }
    return _soc_c3_rce_entry_qualify_range_traverse(unitData,
                                                    entryId,
                                                    callback,
                                                    extras);
}

int
soc_c3_rce_entry_qualify_range_set(int unit,
                                   int entryId,
                                   int rangeId,
                                   int qualify)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if ((0 > entryId) || (unitData->entryLimit <= entryId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"),
                   unit, entryId));
        return SOC_E_BADID;
    }
    if (!unitData->entryData[entryId]) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d does not exist\n"),
                   unit, entryId));
        return SOC_E_NOT_FOUND;
    }
    if ((1 > rangeId) || (unitData->rangeLimit < rangeId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d range %d is not valid\n"),
                   unit, rangeId));
        return SOC_E_PARAM;
    }
    if (!unitData->rangeData[rangeId - 1]) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d range %d does not exist\n"),
                   unit, rangeId));
        return SOC_E_NOT_FOUND;
    }
    return _soc_c3_rce_entry_qualify_range_set(unitData,
                                               entryId,
                                               rangeId,
                                               qualify);
}

int
soc_c3_rce_entry_qualify_range_get(int unit,
                                   int entryId,
                                   int rangeId,
                                   int *qualify)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if ((0 > entryId) || (unitData->entryLimit <= entryId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"),
                   unit, entryId));
        return SOC_E_BADID;
    }
    if (!unitData->entryData[entryId]) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d does not exist\n"),
                   unit, entryId));
        return SOC_E_NOT_FOUND;
    }
    if ((1 > rangeId) || (unitData->rangeLimit < rangeId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d range %d is not valid\n"),
                   unit, rangeId));
        return SOC_E_PARAM;
    }
    if (!unitData->rangeData[rangeId - 1]) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d range %d does not exist\n"),
                   unit, rangeId));
        return SOC_E_NOT_FOUND;
    }
    if (!qualify) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "obligatory OUT argument must not be NULL\n")));
        return SOC_E_PARAM;
    }
    return _soc_c3_rce_entry_qualify_range_get(unitData,
                                               entryId,
                                               rangeId,
                                               qualify);
}

int
soc_c3_rce_entry_qualify_clear(int unit,
                               int entryId)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if ((0 > entryId) || (unitData->entryLimit <= entryId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"),
                   unit, entryId));
        return SOC_E_BADID;
    }
    if (!unitData->entryData[entryId]) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d does not exist\n"),
                   unit, entryId));
        return SOC_E_NOT_FOUND;
    }
    return _soc_c3_rce_entry_qualify_clear(unitData, entryId);
}

int
soc_c3_rce_entry_action_set(int unit,
                            int entryId,
                            unsigned int actIdx,
                            const uint8 *value)
{
    _soc_c3_rce_unit_desc_int_t *unitData;
    unsigned int resReg;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if ((0 > entryId) || (unitData->entryLimit <= entryId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"),
                   unit, entryId));
        return SOC_E_BADID;
    }
    if (!unitData->entryData[entryId]) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d does not exist\n"),
                   unit, entryId));
        return SOC_E_NOT_FOUND;
    }
    if (!value) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "obligatory pointer argument must not be NULL\n")));
        return SOC_E_PARAM;
    }
    for (resReg = 0; resReg < SOC_C3_RCE_RESULT_REGISTER_COUNT; resReg++) {
        if (unitData->groupData[unitData->entryData[entryId]->entryGroup]->resultLrp &
            (1 << resReg)) {
            /* using this result register */
            break;
        }
    }
    return _soc_c3_rce_entry_action_set(unitData,
                                        entryId,
                                        resReg,
                                        actIdx,
                                        value);
}

int
soc_c3_rce_entry_action_get(int unit,
                            int entryId,
                            unsigned int actIdx,
                            uint8 *value)
{
    _soc_c3_rce_unit_desc_int_t *unitData;
    unsigned int resReg;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if ((0 > entryId) || (unitData->entryLimit <= entryId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"),
                   unit, entryId));
        return SOC_E_BADID;
    }
    if (!unitData->entryData[entryId]) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d does not exist\n"),
                   unit, entryId));
        return SOC_E_NOT_FOUND;
    }
    if (!value) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "obligatory pointer argument must not be NULL\n")));
        return SOC_E_PARAM;
    }
    for (resReg = 0; resReg < SOC_C3_RCE_RESULT_REGISTER_COUNT; resReg++) {
        if (unitData->groupData[unitData->entryData[entryId]->entryGroup]->resultLrp &
            (1 << resReg)) {
            /* using this result register */
            break;
        }
    }
    return _soc_c3_rce_entry_action_get(unitData,
                                        entryId,
                                        resReg,
                                        actIdx,
                                        value);
}

int
soc_c3_rce_entry_action_clear(int unit,
                              int entryId)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if ((0 > entryId) || (unitData->entryLimit <= entryId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"),
                   unit, entryId));
        return SOC_E_BADID;
    }
    if (!unitData->entryData[entryId]) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d does not exist\n"),
                   unit, entryId));
        return SOC_E_NOT_FOUND;
    }
    return _soc_c3_rce_entry_action_clear(unitData, entryId);
}

int
soc_c3_rce_entry_install(int unit,
                         int entryId)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if ((0 > entryId) || (unitData->entryLimit <= entryId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"),
                   unit, entryId));
        return SOC_E_BADID;
    }
    if (!unitData->entryData[entryId]) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d does not exist\n"),
                   unit, entryId));
        return SOC_E_NOT_FOUND;
    }
    return _soc_c3_rce_entry_install(unitData, entryId);
}

int
soc_c3_rce_entry_remove(int unit,
                        int entryId)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if ((0 > entryId) || (unitData->entryLimit <= entryId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"),
                   unit, entryId));
        return SOC_E_BADID;
    }
    if (!unitData->entryData[entryId]) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d does not exist\n"),
                   unit, entryId));
        return SOC_E_NOT_FOUND;
    }
    return _soc_c3_rce_entry_remove(unitData, entryId);
}

int
soc_c3_rce_entry_counter_set(int unit,
                             int entryId,
                             const uint64 *counters)
{
    _soc_c3_rce_unit_desc_int_t *unitData;
    _soc_c3_rce_entry_desc_int_t *entryData;
    int result;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if ((0 > entryId) || (unitData->entryLimit <= entryId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"),
                   unit, entryId));
        return SOC_E_BADID;
    }
    entryData = unitData->entryData[entryId];
    if (!entryData) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d does not exist\n"),
                   unit, entryId));
        return SOC_E_NOT_FOUND;
    }
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
    /* force sync of counter state to hardware (so HW residual is zeroed) */
    result = _soc_c3_rce_entry_hw_counter_read(unitData,
                                               unitData->progData[unitData->groupData[entryData->entryGroup]->rceProgram],
                                               entryData);
    if (SOC_E_NONE == result) {
        /* then overwrite basis counts with new values */
        entryData->basisCounts[0] = counters[0];
        entryData->basisCounts[1] = counters[1];
    }
#else
    result = SOC_E_UNAVAIL;
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
    return result;
}

int
soc_c3_rce_entry_counter_get(int unit,
                             int entryId,
                             int clear,
                             uint64 *counters)
{
    _soc_c3_rce_unit_desc_int_t *unitData;
    _soc_c3_rce_entry_desc_int_t *entryData;
    int result;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if ((0 > entryId) || (unitData->entryLimit <= entryId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"),
                   unit, entryId));
        return SOC_E_BADID;
    }
    entryData = unitData->entryData[entryId];
    if (!entryData) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d entry %d does not exist\n"),
                   unit, entryId));
        return SOC_E_NOT_FOUND;
    }
#if C3_RCE_ENABLE_ACTION_INDEX_COUNTERS
    /* force sync of counter state to hardware */
    result = _soc_c3_rce_entry_hw_counter_read(unitData,
                                               unitData->progData[unitData->groupData[entryData->entryGroup]->rceProgram],
                                               entryData);
    if (SOC_E_NONE == result) {
        /* return the adjusted basis counts to the caller */
        counters[0] = entryData->basisCounts[0];
        counters[1] = entryData->basisCounts[1];
        if (clear) {
            /* clear the basis counts if the caller wanted them cleared */
            COMPILER_64_ZERO(entryData->basisCounts[0]);
            COMPILER_64_ZERO(entryData->basisCounts[1]);
        }
    }
#else /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
    result = SOC_E_UNAVAIL;
#endif /* C3_RCE_ENABLE_ACTION_INDEX_COUNTERS */
    return result;
}

int
soc_c3_rce_range_first_avail(int unit,
                             int *firstAvailRangeId)
{
    _soc_c3_rce_unit_desc_int_t *unitData;
    unsigned int index;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if (!firstAvailRangeId) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "obligatory pointer argument must not be NULL\n")));
        return SOC_E_PARAM;
    }
    for (index = 0; index < unitData->rangeLimit; index++) {
        if (!(unitData->rangeData[index])) {
            /* this group does not yet exist; use it */
            /* IDs are biased +1 because of a BCM layer quirk */
            *firstAvailRangeId = index + 1;
            return SOC_E_NONE;
        }
    }
    LOG_ERROR(BSL_LS_SOC_COMMON,
              (BSL_META_U(unit,
                          "unit %d does not have any available range IDs\n"),
               unit));
    return SOC_E_RESOURCE;
}

int
soc_c3_rce_range_next_existing(int unit,
                               int currRangeId,
                               int *nextRangeId)
{
    _soc_c3_rce_unit_desc_int_t *unitData;
    unsigned int index;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if (!nextRangeId) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "obligatory pointer argument must not be NULL\n")));
        return SOC_E_PARAM;
    }
    /* IDs are biased +1 because of a BCM layer quirk */
    currRangeId--;
    if ((0 > currRangeId) || (unitData->rangeLimit <= currRangeId)) {
        /* current range ID is invalid; start at zero */
        index = 0;
        if (unitData->rangeData[index]) {
            /* range one exists; no need to scan */
            /* IDs are biased +1 because of a BCM layer quirk */
            *nextRangeId = index + 1;
            return SOC_E_NONE;
        }
    } else {
        index = currRangeId;
    }
    do {
        index++;
    } while ((!(unitData->rangeData[index])) &&
             (index < unitData->rangeLimit));
    if (index < unitData->rangeLimit) {
        /* found an active entry before we fell off the end */
        /* IDs are biased +1 because of a BCM layer quirk */
        *nextRangeId = index + 1;
        return SOC_E_NONE;
    } else {
        /* did not find any more active entries */
        return SOC_E_NOT_FOUND;
    }
}

int
soc_c3_rce_range_info_get(int unit,
                          int rangeId,
                          soc_c3_rce_range_desc_t **rangeInfo)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if (!rangeInfo) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "obligatory pointer argument must not be NULL\n")));
        return SOC_E_PARAM;
    }
    if ((1 > rangeId) || (unitData->rangeLimit < rangeId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d range %d is not valid\n"),
                   unit, rangeId));
        return SOC_E_BADID;
    }
    if (!(unitData->rangeData[rangeId - 1])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d range %d does not exist \n"),
                   unit,
                   rangeId));
        return SOC_E_NOT_FOUND;
    }
    return _soc_c3_rce_range_info_get(unitData, rangeId, rangeInfo);
}

void
soc_c3_rce_range_info_free(int unit,
                           soc_c3_rce_range_desc_t *rangeInfo)
{
    /*
     *  For now, we don't really *need* unit, but it's pretty common to have
     *  the unit argument, and maybe we'll need it in the future, so it's here.
     */
    if (rangeInfo) {
        sal_free(rangeInfo);
    } /* if (rangeInfo) */
}

int
soc_c3_rce_range_traverse(int unit,
                          soc_c3_rce_range_traverse_cb_t callback,
                          void *extras)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if (!callback) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "must have callback function provided\n")));
        return SOC_E_PARAM;
    }
    return _soc_c3_rce_range_traverse(unitData, callback, extras);
}

int
soc_c3_rce_range_dump(int unit,
                      uint32 flags,
                      const char *prefix,
                      int rangeId)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if ((1 > rangeId) || (unitData->rangeLimit < rangeId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d range %d is not valid\n"),
                   unit,
                   rangeId));
        return SOC_E_BADID;
    }
    if (!(unitData->rangeData[rangeId - 1])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d range %d is not active\n"),
                   unit,
                   rangeId));
        return SOC_E_NOT_FOUND;
    }
#if defined(BROADCOM_DEBUG)
    return _soc_c3_rce_range_dump(unitData, flags, prefix, rangeId);
#else /* defined(BROADCOM_DEBUG) */
    return SOC_E_NONE;
#endif /* defined(BROADCOM_DEBUG) */
}

int
soc_c3_rce_range_create(int unit,
                        int rangeId,
                        const soc_c3_rce_range_desc_t *rangeInfo)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if (!rangeInfo) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "obligatory pointer argument must not be NULL\n")));
        return SOC_E_PARAM;
    }
    if ((1 > rangeId) || (unitData->rangeLimit < rangeId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d range %d is not valid\n"),
                   unit, rangeId));
        return SOC_E_BADID;
    }
    if (unitData->rangeData[rangeId - 1]) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d range %d already exists\n"),
                   unit,
                   rangeId));
        return SOC_E_EXISTS;
    }
    return _soc_c3_rce_range_create(unitData, rangeId, rangeInfo);
}

int
soc_c3_rce_range_destroy(int unit,
                         int rangeId)
{
    _soc_c3_rce_unit_desc_int_t *unitData;

    if ((0 > unit) || (SOC_MAX_NUM_DEVICES <= unit)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not valid\n"),
                   unit));
        return SOC_E_UNIT;
    }
    if (!(unitData = _soc_c3_rce[unit])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d is not initialised\n"),
                   unit));
        return SOC_E_INIT;
    }
    if ((1 > rangeId) || (unitData->rangeLimit < rangeId)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d range %d is not valid\n"),
                   unit, rangeId));
        return SOC_E_BADID;
    }
    if (!(unitData->rangeData[rangeId - 1])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d range %d does not exist\n"),
                   unit,
                   rangeId));
        return SOC_E_EXISTS;
    }
    return _soc_c3_rce_range_destroy(unitData, rangeId);
}


#endif /* def BCM_CALADAN3_SUPPORT */

