
/*
 * $Id: cmu_c.stg,v 1.15 Broadcom SDK $    
 * $Copyright: (c) 2016 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 *
 * g3p1_cmu.c: Guadalupe2k V1.3 CMU table manager & wrappers
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from sdk/caladan_ucode/g3p1/src/g3p1_cmu_cfg.lrp.
 * Edits to this file will be lost when it is regenerated.
 *
 */
#include <shared/bsl.h>

#include <soc/defs.h>

#if defined(BCM_CALADAN3_SUPPORT) && defined(BCM_CALADAN3_G3P1_SUPPORT) 

#include <sal/core/time.h>
#include <sal/core/alloc.h>
#include <sal/core/libc.h>
#include <sal/types.h>
#include <sal/appl/io.h>
#include <soc/types.h>
#include <soc/drv.h>
#include <sal/appl/sal.h>
#include <sal/core/time.h>
#include <appl/diag/test.h> 
#include <sal/core/thread.h>

#include <soc/sbx/caladan3/ocm.h>
#include <soc/sbx/caladan3/cmu.h>
#include <soc/error.h>
#include <soc/debug.h>

#include <soc/sbx/g3p1/g3p1_cmu.h>
#include <soc/sbx/g3p1/g3p1_cmu_sim.h>

typedef struct cmu_counter_group_s {
  int counter_start;
  int num_counters;
  int segment_id;
  soc_sbx_caladan3_cmu_segment_type_e_t segment_type;
} cmu_counter_group_t;

static cmu_counter_group_t *cmu_counter_groups;
static int next_group;


int g3p1_cmu_ocm_mem_size[2] = {98439, 72576}; /* Size in number of 64 bit entries. Actual number of entries [0]=98487, [1]=72576 */

 
   
static int pdctr_id = 0;
static int init_pdctr(int unit) {
  int rv;

  if (next_group == MAX_COUNTER_GROUPS) {
      return SOC_E_MEMORY;
  }

  cmu_counter_groups[next_group].num_counters = 55; 
  cmu_counter_groups[next_group].counter_start = (next_group == 0) ? 0 : (cmu_counter_groups[next_group-1].counter_start + cmu_counter_groups[next_group-1].num_counters);
  cmu_counter_groups[next_group].segment_type = SOC_SBX_CALADAN3_CMU_SEGMENT_TYPE_TURBO_64B;
  cmu_counter_groups[next_group].segment_id = 1;
  pdctr_id = next_group;
  next_group++;

  rv = soc_sbx_caladan3_cmu_counter_group_register(unit,
                  (uint32 *)&cmu_counter_groups[pdctr_id].segment_id,
                  55, 
                  SOC_SBX_CALADAN3_OCM_CMU0_PORT, 
                  SOC_SBX_CALADAN3_CMU_SEGMENT_TYPE_TURBO_64B);
  if (SOC_FAILURE(rv)) {
      LOG_ERROR(BSL_LS_SOC_COMMON,
              (BSL_META_U(unit,
                          "%s Failed to register CMU%d segment 1 on unit %d\n"),
               FUNCTION_NAME(), SOC_SBX_CALADAN3_OCM_CMU0_PORT, unit));
    return rv;
  }

  rv = soc_sbx_caladan3_cmu_segment_background_flush_enable(unit, cmu_counter_groups[pdctr_id].segment_id, TRUE);
  if (SOC_FAILURE(rv)) {
  	  LOG_CLI((BSL_META_U(unit,
                          "failed to disable background flush for on unit %d\n"), unit));
      return rv;
  }

  return SOC_E_NONE;

}
 
   
static int rtctr_id = 0;
static int init_rtctr(int unit) {
  int rv;

  if (next_group == MAX_COUNTER_GROUPS) {
      return SOC_E_MEMORY;
  }

  cmu_counter_groups[next_group].num_counters = 16384; 
  cmu_counter_groups[next_group].counter_start = (next_group == 0) ? 0 : (cmu_counter_groups[next_group-1].counter_start + cmu_counter_groups[next_group-1].num_counters);
  cmu_counter_groups[next_group].segment_type = SOC_SBX_CALADAN3_CMU_SEGMENT_TYPE_TURBO_64B;
  cmu_counter_groups[next_group].segment_id = 2;
  rtctr_id = next_group;
  next_group++;

  rv = soc_sbx_caladan3_cmu_counter_group_register(unit,
                  (uint32 *)&cmu_counter_groups[rtctr_id].segment_id,
                  16384, 
                  SOC_SBX_CALADAN3_OCM_CMU0_PORT, 
                  SOC_SBX_CALADAN3_CMU_SEGMENT_TYPE_TURBO_64B);
  if (SOC_FAILURE(rv)) {
      LOG_ERROR(BSL_LS_SOC_COMMON,
              (BSL_META_U(unit,
                          "%s Failed to register CMU%d segment 2 on unit %d\n"),
               FUNCTION_NAME(), SOC_SBX_CALADAN3_OCM_CMU0_PORT, unit));
    return rv;
  }

  rv = soc_sbx_caladan3_cmu_segment_background_flush_enable(unit, cmu_counter_groups[rtctr_id].segment_id, TRUE);
  if (SOC_FAILURE(rv)) {
  	  LOG_CLI((BSL_META_U(unit,
                          "failed to disable background flush for on unit %d\n"), unit));
      return rv;
  }

  return SOC_E_NONE;

}
 
   
static int ertctr_id = 0;
static int init_ertctr(int unit) {
  int rv;

  if (next_group == MAX_COUNTER_GROUPS) {
      return SOC_E_MEMORY;
  }

  cmu_counter_groups[next_group].num_counters = 16384; 
  cmu_counter_groups[next_group].counter_start = (next_group == 0) ? 0 : (cmu_counter_groups[next_group-1].counter_start + cmu_counter_groups[next_group-1].num_counters);
  cmu_counter_groups[next_group].segment_type = SOC_SBX_CALADAN3_CMU_SEGMENT_TYPE_TURBO_64B;
  cmu_counter_groups[next_group].segment_id = 3;
  ertctr_id = next_group;
  next_group++;

  rv = soc_sbx_caladan3_cmu_counter_group_register(unit,
                  (uint32 *)&cmu_counter_groups[ertctr_id].segment_id,
                  16384, 
                  SOC_SBX_CALADAN3_OCM_CMU0_PORT, 
                  SOC_SBX_CALADAN3_CMU_SEGMENT_TYPE_TURBO_64B);
  if (SOC_FAILURE(rv)) {
      LOG_ERROR(BSL_LS_SOC_COMMON,
              (BSL_META_U(unit,
                          "%s Failed to register CMU%d segment 3 on unit %d\n"),
               FUNCTION_NAME(), SOC_SBX_CALADAN3_OCM_CMU0_PORT, unit));
    return rv;
  }

  rv = soc_sbx_caladan3_cmu_segment_background_flush_enable(unit, cmu_counter_groups[ertctr_id].segment_id, TRUE);
  if (SOC_FAILURE(rv)) {
  	  LOG_CLI((BSL_META_U(unit,
                          "failed to disable background flush for on unit %d\n"), unit));
      return rv;
  }

  return SOC_E_NONE;

}
 
   
static int excctr_id = 0;
static int init_excctr(int unit) {
  int rv;

  if (next_group == MAX_COUNTER_GROUPS) {
      return SOC_E_MEMORY;
  }

  cmu_counter_groups[next_group].num_counters = 7040; 
  cmu_counter_groups[next_group].counter_start = (next_group == 0) ? 0 : (cmu_counter_groups[next_group-1].counter_start + cmu_counter_groups[next_group-1].num_counters);
  cmu_counter_groups[next_group].segment_type = SOC_SBX_CALADAN3_CMU_SEGMENT_TYPE_TURBO_64B;
  cmu_counter_groups[next_group].segment_id = 4;
  excctr_id = next_group;
  next_group++;

  rv = soc_sbx_caladan3_cmu_counter_group_register(unit,
                  (uint32 *)&cmu_counter_groups[excctr_id].segment_id,
                  7040, 
                  SOC_SBX_CALADAN3_OCM_CMU1_PORT, 
                  SOC_SBX_CALADAN3_CMU_SEGMENT_TYPE_TURBO_64B);
  if (SOC_FAILURE(rv)) {
      LOG_ERROR(BSL_LS_SOC_COMMON,
              (BSL_META_U(unit,
                          "%s Failed to register CMU%d segment 4 on unit %d\n"),
               FUNCTION_NAME(), SOC_SBX_CALADAN3_OCM_CMU1_PORT, unit));
    return rv;
  }

  rv = soc_sbx_caladan3_cmu_segment_background_flush_enable(unit, cmu_counter_groups[excctr_id].segment_id, TRUE);
  if (SOC_FAILURE(rv)) {
  	  LOG_CLI((BSL_META_U(unit,
                          "failed to disable background flush for on unit %d\n"), unit));
      return rv;
  }

  return SOC_E_NONE;

}
 
   
static int ingctr_id = 0;
static int init_ingctr(int unit) {
  int rv;

  if (next_group == MAX_COUNTER_GROUPS) {
      return SOC_E_MEMORY;
  }

  cmu_counter_groups[next_group].num_counters = 65536; 
  cmu_counter_groups[next_group].counter_start = (next_group == 0) ? 0 : (cmu_counter_groups[next_group-1].counter_start + cmu_counter_groups[next_group-1].num_counters);
  cmu_counter_groups[next_group].segment_type = SOC_SBX_CALADAN3_CMU_SEGMENT_TYPE_TURBO_64B;
  cmu_counter_groups[next_group].segment_id = 5;
  ingctr_id = next_group;
  next_group++;

  rv = soc_sbx_caladan3_cmu_counter_group_register(unit,
                  (uint32 *)&cmu_counter_groups[ingctr_id].segment_id,
                  65536, 
                  SOC_SBX_CALADAN3_OCM_CMU1_PORT, 
                  SOC_SBX_CALADAN3_CMU_SEGMENT_TYPE_TURBO_64B);
  if (SOC_FAILURE(rv)) {
      LOG_ERROR(BSL_LS_SOC_COMMON,
              (BSL_META_U(unit,
                          "%s Failed to register CMU%d segment 5 on unit %d\n"),
               FUNCTION_NAME(), SOC_SBX_CALADAN3_OCM_CMU1_PORT, unit));
    return rv;
  }

  rv = soc_sbx_caladan3_cmu_segment_background_flush_enable(unit, cmu_counter_groups[ingctr_id].segment_id, TRUE);
  if (SOC_FAILURE(rv)) {
  	  LOG_CLI((BSL_META_U(unit,
                          "failed to disable background flush for on unit %d\n"), unit));
      return rv;
  }

  return SOC_E_NONE;

}
 
   
static int egrctr_id = 0;
static int init_egrctr(int unit) {
  int rv;

  if (next_group == MAX_COUNTER_GROUPS) {
      return SOC_E_MEMORY;
  }

  cmu_counter_groups[next_group].num_counters = 65536; 
  cmu_counter_groups[next_group].counter_start = (next_group == 0) ? 0 : (cmu_counter_groups[next_group-1].counter_start + cmu_counter_groups[next_group-1].num_counters);
  cmu_counter_groups[next_group].segment_type = SOC_SBX_CALADAN3_CMU_SEGMENT_TYPE_TURBO_64B;
  cmu_counter_groups[next_group].segment_id = 6;
  egrctr_id = next_group;
  next_group++;

  rv = soc_sbx_caladan3_cmu_counter_group_register(unit,
                  (uint32 *)&cmu_counter_groups[egrctr_id].segment_id,
                  65536, 
                  SOC_SBX_CALADAN3_OCM_CMU0_PORT, 
                  SOC_SBX_CALADAN3_CMU_SEGMENT_TYPE_TURBO_64B);
  if (SOC_FAILURE(rv)) {
      LOG_ERROR(BSL_LS_SOC_COMMON,
              (BSL_META_U(unit,
                          "%s Failed to register CMU%d segment 6 on unit %d\n"),
               FUNCTION_NAME(), SOC_SBX_CALADAN3_OCM_CMU0_PORT, unit));
    return rv;
  }

  rv = soc_sbx_caladan3_cmu_segment_background_flush_enable(unit, cmu_counter_groups[egrctr_id].segment_id, TRUE);
  if (SOC_FAILURE(rv)) {
  	  LOG_CLI((BSL_META_U(unit,
                          "failed to disable background flush for on unit %d\n"), unit));
      return rv;
  }

  return SOC_E_NONE;

}

static int sample_simple32ctr_id = 0;
static int init_sample_simple32ctr(int unit) {
  int rv;

  if (next_group == MAX_COUNTER_GROUPS) {
      return SOC_E_MEMORY;
  }

  cmu_counter_groups[next_group].num_counters = 32; 
  cmu_counter_groups[next_group].counter_start = (next_group == 0) ? 0 : (cmu_counter_groups[next_group-1].counter_start + cmu_counter_groups[next_group-1].num_counters);
  cmu_counter_groups[next_group].segment_type = SOC_SBX_CALADAN3_CMU_SEGMENT_TYPE_SIMPLE_32B;
  cmu_counter_groups[next_group].segment_id = 7;
  sample_simple32ctr_id = next_group;
  next_group++;

  rv = soc_sbx_caladan3_cmu_counter_group_register(unit,
                  (uint32 *)&cmu_counter_groups[sample_simple32ctr_id].segment_id,
                  32, 
                  SOC_SBX_CALADAN3_OCM_CMU0_PORT, 
                  SOC_SBX_CALADAN3_CMU_SEGMENT_TYPE_SIMPLE_32B);
  if (SOC_FAILURE(rv)) {
  	LOG_ERROR(BSL_LS_SOC_COMMON,
              (BSL_META_U(unit,
                          "%s Failed to register CMU%d segment 7 on unit %d\n"),
               FUNCTION_NAME(), SOC_SBX_CALADAN3_OCM_CMU0_PORT, unit));
    return rv;
  }

  rv = soc_sbx_caladan3_cmu_segment_background_flush_enable(unit, cmu_counter_groups[sample_simple32ctr_id].segment_id, FALSE);
  
  if (SOC_FAILURE(rv)) {
  	  LOG_CLI((BSL_META_U(unit,
                          "failed to disable background flush for on unit %d\n"), unit));
      return rv;
  }        

  return SOC_E_NONE;
} 

static int sample_simple64ctr_id = 0;
static int init_sample_simple64ctr(int unit) {
  int rv;

  if (next_group == MAX_COUNTER_GROUPS) {
      return SOC_E_MEMORY;
  }

  cmu_counter_groups[next_group].num_counters = 32; 
  cmu_counter_groups[next_group].counter_start = (next_group == 0) ? 0 : (cmu_counter_groups[next_group-1].counter_start + cmu_counter_groups[next_group-1].num_counters);
  cmu_counter_groups[next_group].segment_type = SOC_SBX_CALADAN3_CMU_SEGMENT_TYPE_SIMPLE_64B;
  cmu_counter_groups[next_group].segment_id = 8;
  sample_simple64ctr_id = next_group;
  next_group++;

  rv = soc_sbx_caladan3_cmu_counter_group_register(unit,
                  (uint32 *)&cmu_counter_groups[sample_simple64ctr_id].segment_id,
                  32, 
                  SOC_SBX_CALADAN3_OCM_CMU0_PORT, 
                  SOC_SBX_CALADAN3_CMU_SEGMENT_TYPE_SIMPLE_64B);
  if (SOC_FAILURE(rv)) {
  	LOG_ERROR(BSL_LS_SOC_COMMON,
              (BSL_META_U(unit,
                          "%s Failed to register CMU%d segment 8 on unit %d\n"),
               FUNCTION_NAME(), SOC_SBX_CALADAN3_OCM_CMU0_PORT, unit));
    return rv;
  }

  rv = soc_sbx_caladan3_cmu_segment_background_flush_enable(unit, cmu_counter_groups[sample_simple64ctr_id].segment_id, FALSE);
  
  if (SOC_FAILURE(rv)) {
  	  LOG_CLI((BSL_META_U(unit,
                          "failed to disable background flush for on unit %d\n"), unit));
      return rv;
  }        

  return SOC_E_NONE;
} 
 
   
static int sample_turbo32ctr_id = 0;
static int init_sample_turbo32ctr(int unit) {
  int rv;

  if (next_group == MAX_COUNTER_GROUPS) {
      return SOC_E_MEMORY;
  }

  cmu_counter_groups[next_group].num_counters = 32; 
  cmu_counter_groups[next_group].counter_start = (next_group == 0) ? 0 : (cmu_counter_groups[next_group-1].counter_start + cmu_counter_groups[next_group-1].num_counters);
  cmu_counter_groups[next_group].segment_type = SOC_SBX_CALADAN3_CMU_SEGMENT_TYPE_TURBO_32B;
  cmu_counter_groups[next_group].segment_id = 9;
  sample_turbo32ctr_id = next_group;
  next_group++;

  rv = soc_sbx_caladan3_cmu_counter_group_register(unit,
                  (uint32 *)&cmu_counter_groups[sample_turbo32ctr_id].segment_id,
                  32, 
                  SOC_SBX_CALADAN3_OCM_CMU0_PORT, 
                  SOC_SBX_CALADAN3_CMU_SEGMENT_TYPE_TURBO_32B);
  if (SOC_FAILURE(rv)) {
      LOG_ERROR(BSL_LS_SOC_COMMON,
              (BSL_META_U(unit,
                          "%s Failed to register CMU%d segment 9 on unit %d\n"),
               FUNCTION_NAME(), SOC_SBX_CALADAN3_OCM_CMU0_PORT, unit));
    return rv;
  }

  rv = soc_sbx_caladan3_cmu_segment_background_flush_enable(unit, cmu_counter_groups[sample_turbo32ctr_id].segment_id, TRUE);
  if (SOC_FAILURE(rv)) {
  	  LOG_CLI((BSL_META_U(unit,
                          "failed to disable background flush for on unit %d\n"), unit));
      return rv;
  }

  return SOC_E_NONE;

}

static int sample_cmurangectr_id = 0;
static int init_sample_cmurangectr(int unit) {
  int rv;

  if (next_group == MAX_COUNTER_GROUPS) {
      return SOC_E_MEMORY;
  }

  cmu_counter_groups[next_group].num_counters = 32; 
  cmu_counter_groups[next_group].counter_start = (next_group == 0) ? 0 : (cmu_counter_groups[next_group-1].counter_start + cmu_counter_groups[next_group-1].num_counters);
  cmu_counter_groups[next_group].segment_type = SOC_SBX_CALADAN3_CMU_SEGMENT_TYPE_RANGE;
  cmu_counter_groups[next_group].segment_id = 10;
  sample_cmurangectr_id = next_group;
  next_group++;

  rv = soc_sbx_caladan3_cmu_counter_group_register(unit,
                  (uint32 *)&cmu_counter_groups[sample_cmurangectr_id].segment_id,
                  32, 
                  SOC_SBX_CALADAN3_OCM_CMU0_PORT, 
                  SOC_SBX_CALADAN3_CMU_SEGMENT_TYPE_RANGE);
  if (SOC_FAILURE(rv)) {
  	LOG_ERROR(BSL_LS_SOC_COMMON,
              (BSL_META_U(unit,
                          "%s Failed to register CMU%d segment 10 on unit %d\n"),
               FUNCTION_NAME(), SOC_SBX_CALADAN3_OCM_CMU0_PORT, unit));
    return rv;
  }

  rv = soc_sbx_caladan3_cmu_segment_background_flush_enable(unit, cmu_counter_groups[sample_cmurangectr_id].segment_id, FALSE);
  
  if (SOC_FAILURE(rv)) {
  	  LOG_CLI((BSL_META_U(unit,
                          "failed to disable background flush for on unit %d\n"), unit));
      return rv;
  }        

  return SOC_E_NONE;
} 


int soc_sbx_g3p1_pdctr_read( int unit, uint32 ulIndex, uint32 ulEntries, int clear, soc_sbx_g3p1_turbo64_count_t  *pCount) {
  cmu_counter_group_t *counter_group;
  int rv;
  counter_group = &cmu_counter_groups[pdctr_id];

  if (SAL_BOOT_BCMSIM) {
        rv = soc_sbx_g3p1_cmu_counter_read_ext(unit, counter_group->segment_id, ulIndex, 
                ulEntries, (uint64 *)pCount);
        return rv;
  }
  
  rv = soc_sbx_caladan3_cmu_counter_read(unit, counter_group->segment_id, ulIndex, 
                ulEntries, (uint64 *)pCount, TRUE, clear);
  if (SOC_FAILURE(rv)) {
  	LOG_CLI((BSL_META_U(unit,
                        "C3 %d pdctr read failed.\n"),unit));
    return rv;
  }

  return SOC_E_NONE;
}

int soc_sbx_g3p1_pdctr_clear( int unit) {
  cmu_counter_group_t *counter_group;
  int rv;
  counter_group = &cmu_counter_groups[pdctr_id];

  if (SAL_BOOT_BCMSIM) {
        rv = soc_sbx_g3p1_cmu_counter_clear_ext(unit, counter_group->segment_id);
        return rv;
  }
  
  rv = soc_sbx_caladan3_cmu_segment_clear(unit, counter_group->segment_id);
  if (SOC_FAILURE(rv)) {
  	LOG_CLI((BSL_META_U(unit,
                        "C3 %d pdctr read failed.\n"),unit));
    return rv;
  }

  return SOC_E_NONE;
}

int soc_sbx_g3p1_rtctr_read( int unit, uint32 ulIndex, uint32 ulEntries, int clear, soc_sbx_g3p1_turbo64_count_t  *pCount) {
  cmu_counter_group_t *counter_group;
  int rv;
  counter_group = &cmu_counter_groups[rtctr_id];

  if (SAL_BOOT_BCMSIM) {
        rv = soc_sbx_g3p1_cmu_counter_read_ext(unit, counter_group->segment_id, ulIndex, 
                ulEntries, (uint64 *)pCount);
        return rv;
  }
  
  rv = soc_sbx_caladan3_cmu_counter_read(unit, counter_group->segment_id, ulIndex, 
                ulEntries, (uint64 *)pCount, TRUE, clear);
  if (SOC_FAILURE(rv)) {
  	LOG_CLI((BSL_META_U(unit,
                        "C3 %d rtctr read failed.\n"),unit));
    return rv;
  }

  return SOC_E_NONE;
}

int soc_sbx_g3p1_rtctr_clear( int unit) {
  cmu_counter_group_t *counter_group;
  int rv;
  counter_group = &cmu_counter_groups[rtctr_id];

  if (SAL_BOOT_BCMSIM) {
        rv = soc_sbx_g3p1_cmu_counter_clear_ext(unit, counter_group->segment_id);
        return rv;
  }
  
  rv = soc_sbx_caladan3_cmu_segment_clear(unit, counter_group->segment_id);
  if (SOC_FAILURE(rv)) {
  	LOG_CLI((BSL_META_U(unit,
                        "C3 %d rtctr read failed.\n"),unit));
    return rv;
  }

  return SOC_E_NONE;
}

int soc_sbx_g3p1_ertctr_read( int unit, uint32 ulIndex, uint32 ulEntries, int clear, soc_sbx_g3p1_turbo64_count_t  *pCount) {
  cmu_counter_group_t *counter_group;
  int rv;
  counter_group = &cmu_counter_groups[ertctr_id];

  if (SAL_BOOT_BCMSIM) {
        rv = soc_sbx_g3p1_cmu_counter_read_ext(unit, counter_group->segment_id, ulIndex, 
                ulEntries, (uint64 *)pCount);
        return rv;
  }
  
  rv = soc_sbx_caladan3_cmu_counter_read(unit, counter_group->segment_id, ulIndex, 
                ulEntries, (uint64 *)pCount, TRUE, clear);
  if (SOC_FAILURE(rv)) {
  	LOG_CLI((BSL_META_U(unit,
                        "C3 %d ertctr read failed.\n"),unit));
    return rv;
  }

  return SOC_E_NONE;
}

int soc_sbx_g3p1_ertctr_clear( int unit) {
  cmu_counter_group_t *counter_group;
  int rv;
  counter_group = &cmu_counter_groups[ertctr_id];

  if (SAL_BOOT_BCMSIM) {
        rv = soc_sbx_g3p1_cmu_counter_clear_ext(unit, counter_group->segment_id);
        return rv;
  }
  
  rv = soc_sbx_caladan3_cmu_segment_clear(unit, counter_group->segment_id);
  if (SOC_FAILURE(rv)) {
  	LOG_CLI((BSL_META_U(unit,
                        "C3 %d ertctr read failed.\n"),unit));
    return rv;
  }

  return SOC_E_NONE;
}

int soc_sbx_g3p1_excctr_read( int unit, uint32 ulIndex, uint32 ulEntries, int clear, soc_sbx_g3p1_turbo64_count_t  *pCount) {
  cmu_counter_group_t *counter_group;
  int rv;
  counter_group = &cmu_counter_groups[excctr_id];

  if (SAL_BOOT_BCMSIM) {
        rv = soc_sbx_g3p1_cmu_counter_read_ext(unit, counter_group->segment_id, ulIndex, 
                ulEntries, (uint64 *)pCount);
        return rv;
  }
  
  rv = soc_sbx_caladan3_cmu_counter_read(unit, counter_group->segment_id, ulIndex, 
                ulEntries, (uint64 *)pCount, TRUE, clear);
  if (SOC_FAILURE(rv)) {
  	LOG_CLI((BSL_META_U(unit,
                        "C3 %d excctr read failed.\n"),unit));
    return rv;
  }

  return SOC_E_NONE;
}

int soc_sbx_g3p1_excctr_clear( int unit) {
  cmu_counter_group_t *counter_group;
  int rv;
  counter_group = &cmu_counter_groups[excctr_id];

  if (SAL_BOOT_BCMSIM) {
        rv = soc_sbx_g3p1_cmu_counter_clear_ext(unit, counter_group->segment_id);
        return rv;
  }
  
  rv = soc_sbx_caladan3_cmu_segment_clear(unit, counter_group->segment_id);
  if (SOC_FAILURE(rv)) {
  	LOG_CLI((BSL_META_U(unit,
                        "C3 %d excctr read failed.\n"),unit));
    return rv;
  }

  return SOC_E_NONE;
}

int soc_sbx_g3p1_ingctr_read( int unit, uint32 ulIndex, uint32 ulEntries, int clear, soc_sbx_g3p1_turbo64_count_t  *pCount) {
  cmu_counter_group_t *counter_group;
  int rv;
  counter_group = &cmu_counter_groups[ingctr_id];

  if (SAL_BOOT_BCMSIM) {
        rv = soc_sbx_g3p1_cmu_counter_read_ext(unit, counter_group->segment_id, ulIndex, 
                ulEntries, (uint64 *)pCount);
        return rv;
  }
  
  rv = soc_sbx_caladan3_cmu_counter_read(unit, counter_group->segment_id, ulIndex, 
                ulEntries, (uint64 *)pCount, TRUE, clear);
  if (SOC_FAILURE(rv)) {
  	LOG_CLI((BSL_META_U(unit,
                        "C3 %d ingctr read failed.\n"),unit));
    return rv;
  }

  return SOC_E_NONE;
}

int soc_sbx_g3p1_ingctr_clear( int unit) {
  cmu_counter_group_t *counter_group;
  int rv;
  counter_group = &cmu_counter_groups[ingctr_id];

  if (SAL_BOOT_BCMSIM) {
        rv = soc_sbx_g3p1_cmu_counter_clear_ext(unit, counter_group->segment_id);
        return rv;
  }
  
  rv = soc_sbx_caladan3_cmu_segment_clear(unit, counter_group->segment_id);
  if (SOC_FAILURE(rv)) {
  	LOG_CLI((BSL_META_U(unit,
                        "C3 %d ingctr read failed.\n"),unit));
    return rv;
  }

  return SOC_E_NONE;
}

int soc_sbx_g3p1_egrctr_read( int unit, uint32 ulIndex, uint32 ulEntries, int clear, soc_sbx_g3p1_turbo64_count_t  *pCount) {
  cmu_counter_group_t *counter_group;
  int rv;
  counter_group = &cmu_counter_groups[egrctr_id];

  if (SAL_BOOT_BCMSIM) {
        rv = soc_sbx_g3p1_cmu_counter_read_ext(unit, counter_group->segment_id, ulIndex, 
                ulEntries, (uint64 *)pCount);
        return rv;
  }
  
  rv = soc_sbx_caladan3_cmu_counter_read(unit, counter_group->segment_id, ulIndex, 
                ulEntries, (uint64 *)pCount, TRUE, clear);
  if (SOC_FAILURE(rv)) {
  	LOG_CLI((BSL_META_U(unit,
                        "C3 %d egrctr read failed.\n"),unit));
    return rv;
  }

  return SOC_E_NONE;
}

int soc_sbx_g3p1_egrctr_clear( int unit) {
  cmu_counter_group_t *counter_group;
  int rv;
  counter_group = &cmu_counter_groups[egrctr_id];

  if (SAL_BOOT_BCMSIM) {
        rv = soc_sbx_g3p1_cmu_counter_clear_ext(unit, counter_group->segment_id);
        return rv;
  }
  
  rv = soc_sbx_caladan3_cmu_segment_clear(unit, counter_group->segment_id);
  if (SOC_FAILURE(rv)) {
  	LOG_CLI((BSL_META_U(unit,
                        "C3 %d egrctr read failed.\n"),unit));
    return rv;
  }

  return SOC_E_NONE;
}

int soc_sbx_g3p1_sample_simple32ctr_read( int unit, uint32 ulIndex, uint32 ulEntries, int clear, soc_sbx_g3p1_simple32_count_t  *pCount) {
  cmu_counter_group_t *counter_group;
  int rv;
  counter_group = &cmu_counter_groups[sample_simple32ctr_id];

  if (SAL_BOOT_BCMSIM) {
        rv = soc_sbx_g3p1_cmu_counter_read_ext(unit, counter_group->segment_id, ulIndex, 
                ulEntries, (uint64 *)pCount);
        return rv;
  }
  
  rv = soc_sbx_caladan3_cmu_counter_read(unit, counter_group->segment_id, ulIndex, 
                ulEntries, (uint64 *)pCount, FALSE, clear);
  if (SOC_FAILURE(rv)) {
  	LOG_CLI((BSL_META_U(unit,
                        "C3 %d sample_simple32ctr read failed.\n"),unit));
    return rv;
  }

  return SOC_E_NONE;
}

int soc_sbx_g3p1_sample_simple32ctr_clear( int unit) {
  cmu_counter_group_t *counter_group;
  int rv;
  counter_group = &cmu_counter_groups[sample_simple32ctr_id];

  if (SAL_BOOT_BCMSIM) {
        rv = soc_sbx_g3p1_cmu_counter_clear_ext(unit, counter_group->segment_id);
        return rv;
  }
  
  rv = soc_sbx_caladan3_cmu_segment_clear(unit, counter_group->segment_id);
  if (SOC_FAILURE(rv)) {
  	LOG_CLI((BSL_META_U(unit,
                        "C3 %d sample_simple32ctr read failed.\n"),unit));
    return rv;
  }

  return SOC_E_NONE;
}

int soc_sbx_g3p1_sample_simple64ctr_read( int unit, uint32 ulIndex, uint32 ulEntries, int clear, soc_sbx_g3p1_simple64_count_t  *pCount) {
  cmu_counter_group_t *counter_group;
  int rv;
  counter_group = &cmu_counter_groups[sample_simple64ctr_id];

  if (SAL_BOOT_BCMSIM) {
        rv = soc_sbx_g3p1_cmu_counter_read_ext(unit, counter_group->segment_id, ulIndex, 
                ulEntries, (uint64 *)pCount);
        return rv;
  }
  
  rv = soc_sbx_caladan3_cmu_counter_read(unit, counter_group->segment_id, ulIndex, 
                ulEntries, (uint64 *)pCount, FALSE, clear);
  if (SOC_FAILURE(rv)) {
  	LOG_CLI((BSL_META_U(unit,
                        "C3 %d sample_simple64ctr read failed.\n"),unit));
    return rv;
  }

  return SOC_E_NONE;
}

int soc_sbx_g3p1_sample_simple64ctr_clear( int unit) {
  cmu_counter_group_t *counter_group;
  int rv;
  counter_group = &cmu_counter_groups[sample_simple64ctr_id];

  if (SAL_BOOT_BCMSIM) {
        rv = soc_sbx_g3p1_cmu_counter_clear_ext(unit, counter_group->segment_id);
        return rv;
  }
  
  rv = soc_sbx_caladan3_cmu_segment_clear(unit, counter_group->segment_id);
  if (SOC_FAILURE(rv)) {
  	LOG_CLI((BSL_META_U(unit,
                        "C3 %d sample_simple64ctr read failed.\n"),unit));
    return rv;
  }

  return SOC_E_NONE;
}

int soc_sbx_g3p1_sample_turbo32ctr_read( int unit, uint32 ulIndex, uint32 ulEntries, int clear, soc_sbx_g3p1_turbo32_count_t  *pCount) {
  cmu_counter_group_t *counter_group;
  int rv;
  counter_group = &cmu_counter_groups[sample_turbo32ctr_id];

  if (SAL_BOOT_BCMSIM) {
        rv = soc_sbx_g3p1_cmu_counter_read_ext(unit, counter_group->segment_id, ulIndex, 
                ulEntries, (uint64 *)pCount);
        return rv;
  }
  
  rv = soc_sbx_caladan3_cmu_counter_read(unit, counter_group->segment_id, ulIndex, 
                ulEntries, (uint64 *)pCount, FALSE, clear);
  if (SOC_FAILURE(rv)) {
  	LOG_CLI((BSL_META_U(unit,
                        "C3 %d sample_turbo32ctr read failed.\n"),unit));
    return rv;
  }

  return SOC_E_NONE;
}

int soc_sbx_g3p1_sample_turbo32ctr_clear( int unit) {
  cmu_counter_group_t *counter_group;
  int rv;
  counter_group = &cmu_counter_groups[sample_turbo32ctr_id];

  if (SAL_BOOT_BCMSIM) {
        rv = soc_sbx_g3p1_cmu_counter_clear_ext(unit, counter_group->segment_id);
        return rv;
  }
  
  rv = soc_sbx_caladan3_cmu_segment_clear(unit, counter_group->segment_id);
  if (SOC_FAILURE(rv)) {
  	LOG_CLI((BSL_META_U(unit,
                        "C3 %d sample_turbo32ctr read failed.\n"),unit));
    return rv;
  }

  return SOC_E_NONE;
}

int soc_sbx_g3p1_sample_cmurangectr_read( int unit, uint32 ulIndex, uint32 ulEntries, int clear, soc_sbx_g3p1_range_count_t  *pCount) {
  cmu_counter_group_t *counter_group;
  int rv;
  counter_group = &cmu_counter_groups[sample_cmurangectr_id];

  if (SAL_BOOT_BCMSIM) {
        rv = soc_sbx_g3p1_cmu_counter_read_ext(unit, counter_group->segment_id, ulIndex, 
                ulEntries, (uint64 *)pCount);
        return rv;
  }
  
  rv = soc_sbx_caladan3_cmu_counter_read(unit, counter_group->segment_id, ulIndex, 
                ulEntries, (uint64 *)pCount, FALSE, clear);
  if (SOC_FAILURE(rv)) {
  	LOG_CLI((BSL_META_U(unit,
                        "C3 %d sample_cmurangectr read failed.\n"),unit));
    return rv;
  }

  return SOC_E_NONE;
}

int soc_sbx_g3p1_sample_cmurangectr_clear( int unit) {
  cmu_counter_group_t *counter_group;
  int rv;
  counter_group = &cmu_counter_groups[sample_cmurangectr_id];

  if (SAL_BOOT_BCMSIM) {
        rv = soc_sbx_g3p1_cmu_counter_clear_ext(unit, counter_group->segment_id);
        return rv;
  }
  
  rv = soc_sbx_caladan3_cmu_segment_clear(unit, counter_group->segment_id);
  if (SOC_FAILURE(rv)) {
  	LOG_CLI((BSL_META_U(unit,
                        "C3 %d sample_cmurangectr read failed.\n"),unit));
    return rv;
  }

  return SOC_E_NONE;
}



static int init_cmu_ocm_ports(int unit) {
  sbx_caladan3_ocm_port_alloc_t desc;
  int rv, i;

  for (i=0; i<2; i++) {
    desc.port = (i == 0) ? SOC_SBX_CALADAN3_OCM_CMU0_PORT : SOC_SBX_CALADAN3_OCM_CMU1_PORT;
    desc.segment = -1;
    desc.size = g3p1_cmu_ocm_mem_size[i];
    desc.datum_size = SOC_SBX_CALADAN3_DATUM_SIZE_QUADWORD; /* Assume worst case: Turbo64 */

    /* allocate memory */
    rv = soc_sbx_caladan3_ocm_port_mem_alloc(unit, &desc);
    if (SOC_FAILURE(rv)) {
      LOG_CLI((BSL_META_U(unit,
                          "C3 %d CMU Allocation failed for port %d\n"),unit, desc.port));
      return rv;
    }

    /* set OCM memory size. */
    rv = soc_sbx_caladan3_cmu_ocm_memory_size_set(unit,
                desc.port,
                desc.size * sizeof(uint64));
    if (SOC_FAILURE(rv)) {
      LOG_ERROR(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,
                            "%s Failed to register OCM memory for CMU port %d on unit %d\n"),
                 FUNCTION_NAME(), desc.port, unit));
      return rv;
    }
  }

  return SOC_E_NONE;
}

int soc_sbx_g3p1_cmu_init(int unit){
  int rv = SOC_E_NONE;

  cmu_counter_groups = sal_alloc(MAX_COUNTER_GROUPS * sizeof(cmu_counter_group_t), "asm3_cmu_counters");
  if (!cmu_counter_groups) {
    return SOC_E_MEMORY;
  }
  next_group = 0;

  rv = init_cmu_ocm_ports(unit);
  if (rv != SOC_E_NONE) {
    return rv;
  }

  rv = init_pdctr(unit);
  if (rv != SOC_E_NONE) {
    return rv;
  }

  rv = init_rtctr(unit);
  if (rv != SOC_E_NONE) {
    return rv;
  }

  rv = init_ertctr(unit);
  if (rv != SOC_E_NONE) {
    return rv;
  }

  rv = init_excctr(unit);
  if (rv != SOC_E_NONE) {
    return rv;
  }

  rv = init_ingctr(unit);
  if (rv != SOC_E_NONE) {
    return rv;
  }

  rv = init_egrctr(unit);
  if (rv != SOC_E_NONE) {
    return rv;
  }

  rv = init_sample_simple32ctr(unit);
  if (rv != SOC_E_NONE) {
    return rv;
  }

  rv = init_sample_simple64ctr(unit);
  if (rv != SOC_E_NONE) {
    return rv;
  }

  rv = init_sample_turbo32ctr(unit);
  if (rv != SOC_E_NONE) {
    return rv;
  }

  rv = init_sample_cmurangectr(unit);
  if (rv != SOC_E_NONE) {
    return rv;
  }

  
  return SOC_E_NONE;

}

int soc_sbx_g3p1_cmu_uninit(int unit){
  sbx_caladan3_ocm_port_alloc_t desc;
  int i, rv;
        
  for (i=0; i<next_group; i++) {
    rv = soc_sbx_caladan3_cmu_counter_group_unregister(unit, cmu_counter_groups[i].segment_id);
    if (SOC_FAILURE(rv)) {
    	LOG_CLI((BSL_META_U(unit,
                            "C3 %d Unregister failed for segment %d [%d]\n"),unit, i, cmu_counter_groups[i].segment_id));
    } 
  }
            
  for (i=0; i<2; i++) {
    desc.port = (i == 0) ? SOC_SBX_CALADAN3_OCM_CMU0_PORT : SOC_SBX_CALADAN3_OCM_CMU1_PORT;
    desc.segment = -1;
    desc.size = g3p1_cmu_ocm_mem_size[i];
    desc.datum_size = SOC_SBX_CALADAN3_DATUM_SIZE_QUADWORD;

    rv = soc_sbx_caladan3_ocm_port_mem_free(unit, &desc);
    if (SOC_FAILURE(rv)) {
      LOG_CLI((BSL_META_U(unit,
                          "C3 %d Free failed for port %d\n"),unit, desc.port));
    }
  }

  sal_free(cmu_counter_groups);

  return SOC_E_NONE;
}



#endif
