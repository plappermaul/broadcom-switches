
/**
 *
 * $Id: ocm_c.stg,v 1.65 Broadcom SDK $ 	 
 * $Copyright: (c) 2016 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 *
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */
 

#include <shared/bsl.h>

#include <soc/types.h>
#include <soc/drv.h>

#if defined(BCM_CALADAN3_SUPPORT) && defined(BCM_CALADAN3_G3P1_SUPPORT)

#include <soc/sbx/g3p1/g3p1_int.h>
#include <soc/sbx/g3p1/g3p1_defs.h>

#define UTG_MALLOC(x) sal_alloc((x), "asm");
#define UTG_FREE(x) sal_free(x);

/* Static symbol name for initialization */
char soc_sbx_g3p1_sym[128];

/* Only for debugging */
char *soc_sbx_g3p1_errsym;
/* Parse an integer */
int soc_sbx_g3p1_read(char *a, int range, uint32 *vp)
{
    uint32 v;

    if (a[0] < '0' || '9' < a[0]) {
        return SOC_E_PARAM;
    }
    v = sal_ctoi(a, 0);
    if (0 < range && ((uint32) range) <= v) {
        return SOC_E_PARAM;
    }
    *vp = v;
    return SOC_E_NONE;
}

/* Read an arbitrarily large value from shell command arguments */
int soc_sbx_g3p1_big_value_read(uint8 *v,
        int width, int noarg0, int argc, char **argv)
{
    int i, rv, vwidth, n = 0;
    int bytes = (width + 7) / 8;
    char *s, *s0;
    uint8 c;
    uint8 b[6];
    uint32 v0, v1;
    int ishexmac=0;
    char  mac_data[13];
    char *mac;
    int j=1;
    int hexmac_size;

    mac = mac_data;
    sal_memset(v, 0, bytes);

    s = *argv;
    if (( s && (*s =='m'|| *s=='M') &&
            ((s+1)!= NULL) && (*(s+1)=='a'|| *(s+1)=='A') &&
            ((s+2)!= NULL) && (*(s+2)=='c'|| *(s+2)=='C') &&
            ((s+3)!= NULL) && (*(s+3)=='=') &&
            ((s+4)!= NULL) && (*(s+4)=='0') &&
            ((s+5)!= NULL) && (*(s+5)=='x'|| *(s+4)=='X' ))) {
        ishexmac=1;
        for(i=0;i<12;i++){
            c = (uint8) *(s+6+i);
            /* LOG_CLI((BSL_META("c=%d\n"),c)); */
            if(!('0'<= c && c <='9')) break;
        }
        hexmac_size=i;
        /* LOG_CLI((BSL_META("hexmac_size=%d\n"),hexmac_size)); */

        sal_memset(mac,0,12);

        for(i=12-hexmac_size;i<12;i++) {
            *(mac+i)=*(s+5+j);
            j++;
        }
    }

    if (noarg0) {
        s = *argv;
    } else {
        for(s = *argv; *s && *s != '='; s++);
        if (!*s) {
            if (argc < 2) {
                LOG_CLI((BSL_META("no value given for %s\n"), *argv));
                return -1;
            }
            argv++;
            argc--;
            s = *argv;
            n++;
        } else if (*s == '=') {
            s++;
        }
    }

    for(s0 = s; *s0 && *s0 != '.' && *s0 != '-' && *s0 != ':'; s0++);

    if (*s0 == '.') {
        v1 = 0;
        vwidth = 0;
        c = (uint8) *s++;
        for (i = 0; i < 4; i++) {
            if (!('0' <= c && c <= '9')) {
                LOG_CLI((BSL_META("illegal octet in IP address %s\n"), *argv));
                return -1;
            }
            v0 = 0;
            for (; '0' <= c && c <= '9'; c = (uint8) *s++) {
                v0 = v0 * 10 + (c - '0');
                if (v0 > 255) {
                    LOG_CLI((BSL_META("octet too large in IP address %s\n"), *argv));
                    return -1;
                }
            }
            v1 = (v1 << 8) + v0;
            if (c && (i == 3 || c != '.')) {
                LOG_CLI((BSL_META("illegal number %s\n"), *argv));
                return -1;
            }
            if (c) c = (uint8) *s++;
            if (vwidth) {
                vwidth += 8;
            } else {
                for (; ((uint32) (1 << vwidth)) <= v0; vwidth++);
            }
            if (vwidth > width) {
                LOG_CLI((BSL_META("number is too large %s\n"), *argv));
                return -1;
            }
        }

        for (i = 0; v1 && i < bytes; i++) {
            v[i] = v1;
            v1 >>= 8;
        }
        return n + 1;
    } else if (*s0 == '-' || *s0 == ':' ) {

        vwidth = 0;
        c = (uint8) *s++;
        for (i = 0; i < 6; i++) {
            if (i==5) {LOG_CLI((BSL_META("\n")));}
            if (!(('0' <= c && c <= '9')
                    || ('A' <= c && c <= 'F')
                    || ('a' <= c && c <= 'f'))) {
                LOG_CLI((BSL_META("illegal octet in MAC address %s\n"), *argv));
                return -1;
            }
            v0 = 0;
            for (;('0' <= c && c <= '9')
                    || ('A' <= c && c <= 'F')
                    || ('a' <= c && c <= 'f');
                    c = (uint8) *s++) {
                if ('0' <= c && c <= '9') {
                    c -= '0';
                } else if ('A' <= c && c <= 'F') {
                    c -= 'A' - 10;
                } else if ('a' <= c && c <= 'f') {
                    c -= 'a' - 10;
                }
                v0 = v0 * 16 + c;
                if (v0 > 255) {
                    LOG_CLI((BSL_META("octet too large in MAC address %s\n"), *argv));
                    return -1;
                }
            }
            if (c && (i == 5 || (c != ':' && c != '-'))) {
                LOG_CLI((BSL_META("illegal number %s\n"), *argv));
                return -1;
            }
            if (c) c = (uint8) *s++;
            if (vwidth) {
                vwidth += 8;
            } else {
                for (; ((uint32) (1 << vwidth)) <= v0; vwidth++);
            }
            if (vwidth > width) {
                LOG_CLI((BSL_META("number is too large %s\n"), *argv));
                return -1;
            }
            b[i] = v0;
        }
        for (i = 0; i < bytes; i++) {
            v[i] = b[i];
        }
        return n + 1;
    } else if (ishexmac){
        s=mac;
        /* LOG_CLI((BSL_META("%s: handle mac add\n"),__FUNCTION__)); */
        j=0;

        for (i = 0; i < 6; i++) {
            c = (uint8) *s++;
            v0 = 0;
            if (!(('0' <= c && c <= '9')
                    || ('A' <= c && c <= 'F')
                    || ('a' <= c && c <= 'f'))) {
                LOG_CLI((BSL_META("illegal octet in MAC address %s, c=%x\n"), *argv, c));
                return -1;
            }

            if ('0' <= c && c <= '9') {
                c -= '0';
            } else if ('A' <= c && c <= 'F') {
                c -= 'A' - 10;
            } else if ('a' <= c && c <= 'f') {
                c -= 'a' - 10;
            }
            v0=c;
            c = (uint8) *s++;
            if (!(('0' <= c && c <= '9')
                    || ('A' <= c && c <= 'F')
                    || ('a' <= c && c <= 'f'))) {
                LOG_CLI((BSL_META("illegal octet in MAC address %s, c=%x\n"), *argv, c));
                return -1;
            }

            if ('0' <= c && c <= '9') {
                c -= '0';
            } else if ('A' <= c && c <= 'F') {
                c -= 'A' - 10;
            } else if ('a' <= c && c <= 'f') {
                c -= 'a' - 10;
            }
            v0 = v0 * 16 + c;
            b[i] = v0;
        }

        for (i = 0; i < 6; i++) {
            v[i] = b[i];
        }
        return n + 1;
    }

    rv = soc_sbx_g3p1_read(s, -1, &v0);
    if (rv) {
        if (noarg0) {
            return 0;
        }
        LOG_CLI((BSL_META("illegal number %s\n"), *argv));
        return -1;
    }
    /* coverity[large_shift] */
    for (vwidth = 0;
            ((uint32) (1 << vwidth)) <= v0 && vwidth < 32;
            vwidth++);
    if (vwidth > width) {
        LOG_CLI((BSL_META("number is too large %s\n"), *argv));
        return -1;
    }
    if (vwidth > 8) {
        for (i = 0; v0; i++) {
            v[i] = v0;
            v0 >>= 8;
        }
        return n + 1;
    }

    for (i = 0; i < bytes; i++) {
        rv = soc_sbx_g3p1_read(s, 256, &v0);
        if (rv) {
            break;
        }
        if (v0) {
            for (vwidth = 0; ((uint32) (1 << vwidth)) <= v0; vwidth++);
            vwidth += i * 8;
        }
        if (vwidth > width) {
            LOG_CLI((BSL_META("number is too large %s\n"), *argv));
            return -1;
        }
        v[i] = v0;
        n++;
        argv++;
        argc--;
        if (!argc) {
            break;
        }
        s = *argv;
    }
    return n; 
}

/* Read a 32 bit value from shell command arguments */
int soc_sbx_g3p1_value_read(uint32 *v,
                int range, int noarg0, int argc, char **argv)
{
    uint8 b[6];
    uint32 v0;
    int rv;

    rv = soc_sbx_g3p1_big_value_read(b, 32, noarg0, argc, argv);
    if (rv > 0) {
        v0 = b[0] | (b[1] << 8) | (b[2] << 16) | (b[3] << 24);
        if (0 < range && ((uint32) range) <= v0) {
            LOG_CLI((BSL_META("value 0x%x too large in %s\n"), v0, *argv));
            return -1;
        }
        *v = v0;
    }
    return rv;
}

/* Print an integer */

int soc_sbx_g3p1_print(int range, uint32 v)
{
    int d = 8;

    if (0 < range) {
      for (d = 0; d < 8; d++) {
        if (range <= (1 << (d * 4))) break;
      }
    }
    LOG_CLI((BSL_META("0x%0*x"), d, v));
    return 2 + d;
}

/* Get a constant value */
int soc_sbx_g3p1_constant_get(int unit, char *sym, uint32 *vp)
{
    int s;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
  
    s = UTG_SYM_GET(fe->unit, fe->ucode, sym, vp);
    if (s != 0) {
      return SOC_E_NOT_FOUND;
    }
    return SOC_E_NONE;
}

/* Set a global value into the running microcode */
int soc_sbx_g3p1_global_set(int unit, char *sym, uint32 v)
{
    int s;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
  
    s = UTG_SYM_SET(fe->unit, fe->ucode, sym, v);
    if (s != 0) {
      return SOC_E_NOT_FOUND;
    }
    return SOC_E_NONE;
}

/* Get a global value */
int soc_sbx_g3p1_global_get(int unit, char *sym, uint32 *vp)
{
    int s;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
  
    s = UTG_SYM_GET(fe->unit, fe->ucode, sym, vp);
    if (s != 0) {
      return SOC_E_NOT_FOUND;
    }
    return SOC_E_NONE;
}

/* Insert a bit string into a buffer */
void soc_sbx_g3p1_insert(uint8 *b,
                int bbe, int pos, int width,
                uint8 *b0, int b0be, int swab)
{
    int c, m, binc, b0inc, off;
        
    if (bbe) {
        b -= pos / 8;
        binc = -1;
    } else {
        b += pos / 8;
        binc = 1;
    }
    if (b0be) {
        b0inc = -1;
    } else {
        b0inc = 1;
    }
    if (swab) {
        off = ((width + 7) / 8) - 1;
        if (b0be) off = -off;
        b0 += off;
        b0inc = -b0inc;
    }
    pos %= 8;

    for (c = *b0; 8 < width; c = *(b0 += b0inc), b += binc, width -= 8) {
        *b = (*b & (0xff >> (8 - pos))) | (c << pos);
        if (pos != 0)
            *(b + binc) = (*(b + binc) & (0xff << pos)) | (c >> (8 - pos));
    }

    m = ((0xff >> (8 - pos)) | (0xff << (pos + width)));
    *b = (*b & m) | ((c << pos) & ~m);
    width -= 8 - pos;
    if (width > 0)
        *(b + binc) = (*(b + binc) & (0xff << width)) 
            | ((c >> (8 - pos)) & (0xff >> (8 - width)));
}

/* OR a bit string into a buffer */
void soc_sbx_g3p1_insert_or(uint8 *b,
                int bbe, int pos, int width,
                uint8 *b0, int b0be, int swab)
{
    int c, m, binc, b0inc, off;
        
    if (bbe) {
        b -= pos / 8;
        binc = -1;
    } else {
        b += pos / 8;
        binc = 1;
    }
    if (b0be) {
        b0inc = -1;
    } else {
        b0inc = 1;
    }
    if (swab) {
        off = ((width + 7) / 8) - 1;
        if (b0be) off = -off;
        b0 += off;
        b0inc = -b0inc;
    }
    pos %= 8;

    for (c = *b0; 8 < width; c = *(b0 += b0inc), b += binc , width -= 8) {
        *b |= (c << pos);
        if (pos) *(b + binc) |= (c >> (8 - pos));
    }

    m = ((0xff >> (8 - pos)) | (0xff << (pos + width)));
    *b |= (c << pos) & ~m;
    width -= 8 - pos;
    if (width > 0) *(b + binc) |= (c >> (8 - pos)) & (0xff >> (8 - width));
}

/*
 * Extract a bit string into a buffer 
 *
 * b (source) and b0 (destination) can overlap as long as b >= b0 and
 * swab == 0.  This behavior is exploited by the entry_read_write function
 */
void soc_sbx_g3p1_extract(uint8 *b,
                int bbe, int pos, int width,
                uint8 *b0, int b0be, int swab)
{
    int c, binc, b0inc, off;
        
    if (bbe) {
        b -= pos / 8;
        binc = -1;
    } else {
        b += pos / 8;
        binc = 1;
    }
    if (b0be) {
        b0inc = -1;
    } else {
        b0inc = 1;
    }
    if (swab) {
        off = ((width + 7) / 8) - 1;
        if (b0be) off = -off;
        b0 += off;
        b0inc = -b0inc;
    }
    pos %= 8;

    for (;;b0 += b0inc, b += binc, width -= 8) {
        c = (((*b >> pos) & 0xff)
             | (pos != 0 && width > (8 - pos) ? *(b + binc) << (8 - pos) : 0));
        if (width <= 8) break;
        *b0 = c;
    }

    *b0 = c & ~(0xff << width);
}
/* Read or write an entry */
int soc_sbx_g3p1_entry_read_write(int unit, int read, int idx,
                 soc_sbx_g3p1_entry_desc_t *ed)
{
    int i, s, width, bytes, offset, rmw, opcode;
    int mwidth __attribute__((unused))= 0;
    /* int pos = 0; */
    int skipsize = 0, size = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_entry_bank_t *eb = NULL;
    soc_sbx_g3p1_table_bank_t *tb;
    soc_sbx_g3p1_memory_desc_t *md;
    sbx_caladan3_ocm_port_e_t ocmport;
    int segment;
#ifdef PACKED_WORD_FEATURE
    uint8 buf[4] = {0, 0, 0, 0};
#endif
    char entry[32];
    uint8 *dp;
    char *buffer;
    int interleaved_offset = 0;
    
    bytes = 0;
    i = 0;
    rmw = 0;
    opcode = read ? OPCODE_READ : OPCODE_WRITE;
    while (i < ed->nbanks) {
        eb = &ed->banks[i];
        width = eb->width;
        tb = &td->banks[eb->tablebank];
        md = &tm->memories[tb->memory];
        mwidth = md->width;

        dp = tm->entrydmabuf + bytes;
#ifdef PACKED_WORD_FEATURE
        if (eb->width < mwidth) {
            if (ed->nbanks > 1) {
                return SOC_E_INTERNAL;
            }
            if (opcode == OPCODE_WRITE) {
                buf[0] = dp[0];
                buf[1] = dp[1];
                buf[2] = dp[2];
                buf[3] = dp[3];
                opcode = OPCODE_READ;
                rmw = 1;
            } else if (rmw) {
                pos = eb->width * (idx % (mwidth / eb->width));
                soc_sbx_g3p1_insert(tm->entrydmabuf,
                       0, pos, eb->width, buf, 0, 0);
                opcode = OPCODE_WRITE;
                rmw = 0;
            }
            width = mwidth;
        }
#endif
         if (tb->segflags & 2) {
            LOG_INFO(BSL_LS_SOC_MEM,
                     (BSL_META_U(unit,
                                 "\n-- Interleaved 0x%08x stride:%d interleaved_offset:%d --\n"),
                      tb->segflags, eb->stridebits, interleaved_offset));
            offset = (uint32) 
                (tb->base + (((idx * eb->stridebits * ed->nbanks) + interleaved_offset) / width));
            interleaved_offset += eb->stridebits;
        } else {
            offset = (uint32) 
                (tb->base + ((idx * eb->stridebits) / width));
        }

        ocmport = tb->memory;
        segment = tb->segment;
        if (SAL_BOOT_BCMSIM) {
            buffer = tm->simbuffer;
            if (width < 8) {
                /* Pad up for sim */
                width = 8;
            }
            memset(buffer, 0, tm->simbuffersize);
            if (ed->nbanks > 1) {
               sal_snprintf(entry, 32, "%s%d", ed->name, i);
            } else {
               sal_snprintf(entry, 32, "%s", ed->name);
            }
            size = soc_sbx_caladan3_sim_block_encode(buffer, "ocm", entry,
                                 opcode == OPCODE_WRITE ? "set" : "get",
                                 offset);
            if (opcode == OPCODE_WRITE) {
                size += soc_sbx_caladan3_sim_field_encode(buffer+size, "data", dp, width/8);
            }
            s = soc_sbx_caladan3_sim_sendrcv(unit, buffer, &size);
            if (SOC_FAILURE(s)) {
                   LOG_ERROR(BSL_LS_SOC_COMMON,
                             (BSL_META_U(unit,
                                         "sim sendrcv failed (%d)\n"), s));
                   return s;
            }
            s = soc_sbx_caladan3_sim_status_decode(buffer, "status", &skipsize);
            if (SOC_SUCCESS(s)) {
                if (opcode == OPCODE_READ) {
                    size -= skipsize;
                    buffer += skipsize;
                    soc_sbx_caladan3_sim_field_decode(buffer, size, "data", dp, width/8);
                }
            } else {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "sim %s failed (%d)\n"), 
                           opcode == OPCODE_WRITE ? "set" : "get", s));
                return s;
            }
        } else {
            if (opcode == OPCODE_WRITE) {
                s = soc_sbx_caladan3_ocm_port_mem_write(unit, ocmport, segment,
                               offset, offset, (uint32 *)dp);
                LOG_INFO(BSL_LS_SOC_MEM,
                         (BSL_META_U(unit,
                                     "\nOCM Write port %d segment %d index %d data %x"),
                          ocmport, segment, offset, *(uint32*)dp));
            } else {
                s = soc_sbx_caladan3_ocm_port_mem_read(unit, ocmport, segment, 
                              offset, offset, (uint32 *)dp);
                LOG_INFO(BSL_LS_SOC_MEM,
                         (BSL_META_U(unit,
                                     "\nOCM Read port %d segment %d index %d data %x"),
                          ocmport, segment, offset, *(uint32*)dp));
            }
            if (SOC_FAILURE(s)) {
                  return s;
            }
        }
        if (!rmw) {
            bytes += width / 8;
            i++;
        }
    }

	/*
    if (eb->width < mwidth && read) {
        pos = eb->width * (idx % (mwidth / eb->width));
        soc_sbx_g3p1_extract(tm->entrydmabuf,
               0, pos, eb->width, tm->entrydmabuf, 0, 0);
    }
    */
    return SOC_E_NONE;
}

int soc_sbx_g3p1_entry_generic_fast_word_set(int unit,
                soc_sbx_g3p1_field_desc_t *fd,
                soc_sbx_g3p1_entry_desc_t *ed,
                int startvindex,
                int endvindex,
                int *sets,
                uint32 *vs)
{
    int s, i, posbase, shift, wordoff, words, /* addrshift, mwidth, offset, */
        v, v0, entries, wordsperentry;
    uint32 mask, *wp;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb;
    soc_sbx_g3p1_entry_bank_t *eb = NULL;
    soc_sbx_g3p1_memory_desc_t *md __attribute__((unused));
    sbx_caladan3_ocm_port_e_t ocmport;
    int segment;

    posbase = 0;
    for (i = 0; i < ed->nbanks; i++) {
        eb = &ed->banks[i];
        if (fd->pos < posbase + eb->width) {
            break;
        }
        posbase += eb->width;
    }
    tb = &td->banks[eb->tablebank];
    md = &tm->memories[tb->memory];
    shift = (fd->pos - posbase) % 32;
    wordoff = (fd->pos - posbase) / 32;
/*    mwidth = md->width;   */

/*    addrshift = md->width > 32 ? 1 : 0; */
    wordsperentry = (eb->width + 31) / 32;
    mask = fd->width == 32 ? 0xffffffff : (uint32) ((1 << fd->width) - 1);
    mask = ~(mask << shift);

    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
/*    offset = (uint32)
        (tb->base + ((startvindex * eb->stridebits) / mwidth)); */
    words = (endvindex - startvindex + 1) * wordsperentry;
    ocmport = tb->memory;
    segment = tb->segment;

    while (words) {
        if (words > tm->bufsize) {
                     /* Since OCM Read is range inclusive semantics we need -1*/
             endvindex = (startvindex + tm->bufsize / wordsperentry) - 1;
         } else {
             endvindex = startvindex + (words / wordsperentry) - 1;
         }
        
 
        s = soc_sbx_caladan3_ocm_port_mem_read(unit, ocmport, segment, 
                      startvindex, endvindex, (uint32 *)tm->entrydmabuf);
        if (s) {
            sal_mutex_give(tm->dmabufmutex);
            return SOC_E_FAIL;
        }
        wp = (((uint32 *) tm->entrydmabuf) + wordoff);
        /* Assumption here: OCM dma never returns less than requested */
        entries = (endvindex - startvindex + 1);
        while (entries) {
              v = *wp;
            if (!sets || *sets++) {
                  v0 = *vs << shift;
 
                  v = ((v & mask) | v0);
                  *wp = v;
              } 
              wp += wordsperentry;
              vs++;
              entries--;
        }
        s = soc_sbx_caladan3_ocm_port_mem_write(unit, ocmport, segment,
                       startvindex, endvindex, (uint32 *)tm->entrydmabuf);
        if (s) {
            sal_mutex_give(tm->dmabufmutex);
            return SOC_E_FAIL;
        }
        
        words -= (endvindex - startvindex + 1) * wordsperentry;
        startvindex = endvindex + 1;
    }

    sal_mutex_give(tm->dmabufmutex);
    return SOC_E_NONE;
}

int soc_sbx_g3p1_entry_generic_fast_small_set(int unit,
                soc_sbx_g3p1_field_desc_t *fd,
                soc_sbx_g3p1_entry_desc_t *ed,
                int startvindex,
                int endvindex,
                int *sets,
                uint32 *vs)
{
    int i, s, mwidth, entriesperword, /* offset, */ fieldshift, entryshift, shift;
    int dmawords, startfringe, endfringe, burstwords, windex;
    int maxword;
    uint32 fieldmask, mask, word;
    uint32 *wp, *lastvs;
    sbx_caladan3_ocm_port_e_t ocmport;
    int segment;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    soc_sbx_g3p1_memory_desc_t *md = &tm->memories[tb->memory];

    mwidth = md->width;
    entriesperword = 32 / eb->stridebits;

    windex = ((startvindex * eb->stridebits) / 32) % (mwidth / 32);
    dmawords = 
        ((endvindex * eb->stridebits / mwidth)
         - (startvindex * eb->stridebits / mwidth)
         + 1) * (mwidth / 32);
 /*   offset = (uint32)
        (tb->base + (startvindex * eb->stridebits / mwidth));  */
    wp = ((uint32 *) tm->entrydmabuf);

    fieldmask = (uint32) ((1 << fd->width) - 1);
    fieldshift = fd->pos % 32;
    entryshift = eb->stridebits;

    startfringe = startvindex % entriesperword;
    endfringe = 0;
    lastvs = &vs[endvindex - startvindex + 1];
    ocmport = tb->memory;
    segment = tb->segment;

    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    while (vs != lastvs) {
        burstwords = dmawords;
        if (burstwords > tm->bufsize) {
            burstwords = tm->bufsize;
            endvindex = startvindex + burstwords / eb->stridebits;
        }
        s = soc_sbx_caladan3_ocm_port_mem_read(unit, ocmport, segment, 
                      startvindex, endvindex, (uint32 *)tm->entrydmabuf);
        if (s) {
            sal_mutex_give(tm->dmabufmutex);
            return SOC_E_FAIL;
        }

        if (startfringe) {
            mask = 0;
            word = 0;
            shift = fieldshift + entryshift * startfringe;
            while (startfringe < entriesperword && vs != lastvs) {
                if (!sets || *sets++) {
                    word |= *vs << shift;
                    mask |= fieldmask << shift;
                }
                vs++;
                shift += entryshift;
                startfringe++;
            }
            mask = ~mask;
            if (tm->behost) {
                mask = _shr_swap32(mask);
                word = _shr_swap32(word);
            }
            wp[windex] = (wp[windex] & mask) | word;
            windex++;
            startfringe = 0;
        }

        maxword = burstwords;
        if (burstwords == dmawords) {
            endfringe = (endvindex + 1) % entriesperword;
            if (endfringe) {
                maxword--;
            }
        }

        for (; windex < maxword; windex++) {
            word = 0;
            mask = 0;
            shift = fieldshift;
            for (i = 0; i < entriesperword; i++) {
                if (!sets || *sets++) {
                    word |= *vs << shift;
                    mask |= fieldmask << shift;
                }
                vs++;
                shift += entryshift;
            }
            mask = ~mask;
            if (tm->behost) {
                word = _shr_swap32(word);
                mask = _shr_swap32(mask);
            }
            wp[windex] = (wp[windex] & mask) | word;
        }

        if (endfringe) {
            mask = 0;
            word = 0;
            shift = fieldshift;
            while (vs != lastvs) {
                if (!sets || *sets++) {
                    mask |= fieldmask << shift;
                    word |= (*vs << shift);
                }
                vs++;
                shift += entryshift;
            }
            mask = ~mask;
            if (tm->behost) {
                mask = _shr_swap32(mask);
                word = _shr_swap32(word);
            }
            wp[windex] = (wp[windex] & mask) | word;
        }

        s = soc_sbx_caladan3_ocm_port_mem_write(unit, ocmport, segment,
                       startvindex, endvindex, (uint32 *)tm->entrydmabuf);
        if (s) {
            sal_mutex_give(tm->dmabufmutex);
            return SOC_E_FAIL;
        }
        startvindex = endvindex;
        dmawords -= burstwords;
        windex = 0;
    }
    
    sal_mutex_give(tm->dmabufmutex);

    return SOC_E_NONE;
}
int soc_sbx_g3p1_entry_generic_fast_set(int unit,
                soc_sbx_g3p1_field_desc_t *fd,
                soc_sbx_g3p1_entry_desc_t *ed,
                int startvindex,
                int endvindex,
                int *sets,
                uint32 *vs)
{
    int s;

    if (endvindex < startvindex) {
        return SOC_E_PARAM;
    }

    if (ed->banks[0].width < 32) {
        s = soc_sbx_g3p1_entry_generic_fast_small_set(unit,
                       fd, ed, startvindex, endvindex, sets, vs);
    } else {
        s = soc_sbx_g3p1_entry_generic_fast_word_set(unit,
                       fd, ed, startvindex, endvindex, sets, vs);
    }

    return s;
}

int soc_sbx_g3p1_entry_generic_fast_word_get(int unit,
                soc_sbx_g3p1_field_desc_t *fd,
                soc_sbx_g3p1_entry_desc_t *ed,
                int startvindex,
                int endvindex,
                uint32 *vs)
{
    int s, i, posbase, shift, wordoff, words, /* addrshift,  mwidth, offset, */
        v, entries, wordsperentry;
    uint32 mask, *wp;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb;
    soc_sbx_g3p1_entry_bank_t *eb = NULL;
    soc_sbx_g3p1_memory_desc_t *md __attribute__((unused));
    sbx_caladan3_ocm_port_e_t ocmport;
    int segment;

    if (vs == NULL) {
        return SOC_E_PARAM;
    }

    posbase = 0;
    for (i = 0; i < ed->nbanks; i++) {
        eb = &ed->banks[i];
        if (fd->pos < posbase + eb->width) {
            break;
        }
        posbase += eb->width;
    }
    tb = &td->banks[eb->tablebank];
    md = &tm->memories[tb->memory];
    shift = (fd->pos - posbase) % 32;
    wordoff = (fd->pos - posbase) / 32;
/*    mwidth = md->width;  */
    ocmport = tb->memory;
    segment = tb->segment;

/*    addrshift = md->width > 32 ? 1 : 0;  */
    wordsperentry = (eb->width + 31) / 32;
    mask = fd->width == 32 ? 0xffffffff : (uint32) ((1 << fd->width) - 1);

    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
/*    offset = (uint32)
        (tb->base + ((startvindex * eb->stridebits) / mwidth)); */
    words = (endvindex - startvindex + 1) * wordsperentry;

    while (words) {
        if (words > tm->bufsize) {
            endvindex = (startvindex + tm->bufsize / wordsperentry ) - 1;
        } else {
             endvindex = startvindex + (words / wordsperentry) - 1;
        }
        
         
 
         /* This function works on inclusive range for indices.
          *
          * That is, last item retrieved should be startvindex == endvindex and every
          * iteration needs to get 1 less than current computation for endvindex!
          */
        
        s = soc_sbx_caladan3_ocm_port_mem_read(unit, ocmport, segment, 
                      startvindex, endvindex, (uint32 *)tm->entrydmabuf);
        if (s) {
            sal_mutex_give(tm->dmabufmutex);
            return SOC_E_FAIL;
        }

        wp = (((uint32 *) tm->entrydmabuf) + wordoff);
        /* Assumption here: OCM dma never returns less than requested */
        entries = (endvindex - startvindex + 1);

        while (entries) {
            v = *wp;       
            *vs = (v >> shift) & mask;
            wp += wordsperentry;
            vs++;
            entries--;
        }
        
        words -= (endvindex - startvindex + 1) * wordsperentry;
        startvindex = endvindex + 1;
    }

    sal_mutex_give(tm->dmabufmutex);
    return SOC_E_NONE;
}

int soc_sbx_g3p1_entry_generic_fast_small_get(int unit,
                soc_sbx_g3p1_field_desc_t *fd,
                soc_sbx_g3p1_entry_desc_t *ed,
                int startvindex,
                int endvindex,
                uint32 *vs)
{
    int i, s, mwidth, entriesperword, /*  offset, */ fieldshift, entryshift, shift;
    int dmawords, startfringe, endfringe, burstwords, windex;
    int maxword;
    uint32 fieldmask, word;
    uint32 *wp, *lastvs, tmp;
    sbx_caladan3_ocm_port_e_t ocmport;
    int segment;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    soc_sbx_g3p1_memory_desc_t *md = &tm->memories[tb->memory];

    if (vs == NULL) {
        return SOC_E_PARAM;
    }

    mwidth = md->width;
    entriesperword = 32 / eb->stridebits;
    ocmport = tb->memory;
    segment = tb->segment;

    windex = ((startvindex * eb->stridebits) / 32) % (mwidth / 32);
    dmawords = 
        ((endvindex * eb->stridebits / mwidth)
         - (startvindex * eb->stridebits / mwidth)
         + 1) * (mwidth / 32);
/*    offset = (uint32)
        (tb->base + (startvindex * eb->stridebits / mwidth)); */
    wp = ((uint32 *) tm->entrydmabuf);

    fieldmask = (uint32) ((1 << fd->width) - 1);
    fieldshift = fd->pos % 32;
    entryshift = eb->stridebits;

    startfringe = startvindex % entriesperword;
    endfringe = 0;
    lastvs = &vs[endvindex - startvindex + 1];

    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    while (vs != lastvs) {
        burstwords = dmawords;
        if (burstwords > tm->bufsize) {
            burstwords = tm->bufsize;
            endvindex = startvindex + burstwords / eb->stridebits;
        }
        s = soc_sbx_caladan3_ocm_port_mem_read(unit, ocmport, segment, 
                      startvindex, endvindex, (uint32 *)tm->entrydmabuf);
        if (s) {
            sal_mutex_give(tm->dmabufmutex);
            return SOC_E_FAIL;
        }

        if (startfringe) {
            word = wp[windex];
            windex++;
            if (tm->behost) {
                word = _shr_swap32(word);
            }
            shift = fieldshift + entryshift * startfringe;
            while (startfringe < entriesperword && vs != lastvs) {
                /* coverity[large_shift] */
                *vs = (word >> shift) & fieldmask;
                vs++;
                shift += entryshift;
                startfringe++;
            }
            startfringe = 0;
        }

        maxword = burstwords;
        if (burstwords == dmawords) {
            endfringe = (endvindex + 1) % entriesperword;
            if (endfringe) {
                maxword--;
            }
        }

        for (; windex < maxword; windex++) {

            word = wp[windex];
            if (tm->behost) {
                word = _shr_swap32(word);
            }
            shift = fieldshift;
            for (i = 0; i < entriesperword; i++) {
                if (entryshift <=8){
                  *vs = (word >> (( ( ((shift/8)*2)+1)*8)- entryshift -shift)) & fieldmask;
                } else {
                  tmp= (word >> shift) & fieldmask;
                  *vs = ((tmp&0xff00)>>8) + ((tmp&0xff)<<8) ;
                }
                vs++;
                shift += entryshift;
            }
        }

        if (endfringe) {
            word = wp[windex];
            if (tm->behost) {
                word = _shr_swap32(word);
            }
            shift = fieldshift;
            while (vs != lastvs) {
                *vs = (word >> shift) & fieldmask;
                vs++;
                shift += entryshift;
            }
        }
    }
    
    sal_mutex_give(tm->dmabufmutex);

    return SOC_E_NONE;
}

int soc_sbx_g3p1_entry_generic_fast_get(int unit,
                soc_sbx_g3p1_field_desc_t *fd,
                soc_sbx_g3p1_entry_desc_t *ed,
                int startvindex,
                int endvindex,
                uint32 *vs)
{
    int s;

    if (endvindex < startvindex) {
        return SOC_E_PARAM;
    }

    if (ed->banks[0].width < 32) {
        s = soc_sbx_g3p1_entry_generic_fast_small_get(unit,
                       fd, ed, startvindex, endvindex, vs);
    } else {
        s = soc_sbx_g3p1_entry_generic_fast_word_get(unit,
                       fd, ed, startvindex, endvindex, vs);
    }

    return s;
}
void soc_sbx_g3p1_ucode_symbol_format(
                char *sym, int symlen,
                char *s0, char *s1, int d, char *s2, char *s3)
{
    char *s;
    char c;

    if (d >= 0) {
        sal_snprintf(sym, symlen, "%s%s%s%d%s%s%s%s",
                     s0, *s0 ? "_" : s0,
                     s1, 
                     d,
                     *s2 ? "_" : s2, s2, 
                     *s3 ? "_" : s3, s3);
    } else {
        sal_snprintf(sym, symlen, "%s%s%s%s%s%s%s",
                     s0, *s0 ? "_" : s0,
                     s1, 
                     *s2 ? "_" : s2, s2, 
                     *s3 ? "_" : s3, s3);
    }

    for (s = sym; (c = *s); s++) {
        if ('a' <= c && c <= 'z') {
            *s = c - ('a' - 'A');
        }
    }
}
int soc_sbx_g3p1_ucode_get(int unit,
                char *sym, int symlen, int *v,
                char *s0, char *s1, int d, char *s2, char *s3)
{
    int rv;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;

    soc_sbx_g3p1_ucode_symbol_format(sym, symlen, s0, s1, d, s2, s3);

    rv = UTG_SYM_GET(fe->unit, fe->ucode, sym, (uint32 *) v);
    if (rv != 0 && rv != 6) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s: Cannot locate %s\n"), "soc_sbx_g3p1_ucode_get", sym));
        return SOC_E_NOT_FOUND;
    }
    return SOC_E_NONE;
}

/* Set a symbol from the microcode package */
int soc_sbx_g3p1_ucode_set(int unit,
                char *sym, int symlen, int v,
                char *s0, char *s1, int d, char *s2, char *s3)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;

    soc_sbx_g3p1_ucode_symbol_format(sym, symlen, s0, s1, d, s2, s3);

    if (UTG_SYM_SET(fe->unit, fe->ucode, sym, v)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s: Cannot locate %s\n"), "", sym));
        return SOC_E_NOT_FOUND;
    }
    return SOC_E_NONE;
}
int soc_sbx_g3p1_index_find(
                soc_sbx_g3p1_entry_desc_t *ed, char *a)
{
    int i, l;

    for (i = 0; i < ed->nindexes; i++) {
        if (!sal_strcasecmp(a, ed->indexes[i].name)) {
          return i;
        }
        l = sal_strlen(ed->indexes[i].name);
        if (!sal_strncasecmp(a, ed->indexes[i].name, l)
            && a[l] == '=') {
          return i;
      }
    }
    return -1;
}
/* Read a sequence of index arguments */
int soc_sbx_g3p1_indexes_read(void **idxs,
                soc_sbx_g3p1_entry_desc_t *ed, int argc, char **argv)
{
    int rv, i, noarg0, bytes, n = 0;
    
    for (i = 0; i < ed->nindexes; i++) {
        bytes = (ed->indexes[i].width + 7) / 8;
        if (bytes < 4) { bytes = 4; }
        sal_memset(idxs[i], 0, bytes);
    }

    while (argc) {
        i = soc_sbx_g3p1_index_find(ed, *argv);
        noarg0 = i < 0;
        if (noarg0) {
            i = 0;
            if (n != 0 || ed->nindexes != 1) {
                break;
            }
        }

        if (ed->indexes[i].width > 32) {
            rv = soc_sbx_g3p1_big_value_read(idxs[i],
                           ed->indexes[i].width, noarg0, argc, argv);
        } else {
            rv = soc_sbx_g3p1_value_read(idxs[i],
                          ed->indexes[i].range, noarg0, argc, argv);
        }
        if (rv < 0) {
            return -1;
        }
        if (rv == 0) {
            break;
        }
        n += rv;
        argc -= rv;
        argv += rv;
    }
    return n;
}
/* Print a sequence of indexes */
void soc_sbx_g3p1_indexes_print(void **indexpointers,
                soc_sbx_g3p1_entry_desc_t *ed)
{
    int i, j;
    int bytes;

    LOG_CLI((BSL_META("%s["), ed->name));
    for (i = 0; i < ed->nindexes; i++) {
        LOG_CLI((BSL_META("%s="), ed->indexes[i].name));
        bytes = (ed->indexes[i].width + 7) / 8;
        if (bytes > 4) {
            for (j = 0; j < bytes; j++) {
                LOG_CLI((BSL_META("0x%02x%s"),
                         ((uint8 *) indexpointers[i])[j],
                         j < bytes - 1 ? " " : ""));
            }
        } else {
            soc_sbx_g3p1_print(ed->indexes[i].range,
                   *((uint32 *) indexpointers[i]));
        }
        if (i + 1 < ed->nindexes) {
            LOG_CLI((BSL_META(" ")));
        }
    }
    LOG_CLI((BSL_META("]:\n")));
}
/* Parse range arguments with optional flags */
int soc_sbx_g3p1_range_parse(int argc, char **argv,
                int *lower, int *upper,
                int *f0, char *f0name,
                int *f1, char *f1name,
                int *f2, char *f2name)
{
    int max, rv;
    int num = 0;
    char *s;

    max = *upper + 1;
    while (argc) {
        s = argv[0];
        if (f0name && !sal_strcasecmp(s, f0name)) {
            *f0 = 1;
        } else if (f0name
                   && (s[0] == 'n' || s[0] == 'N')
                   && (s[1] == 'o' || s[1] == 'O')
                   && !sal_strcasecmp(&s[2], f0name)) {
            *f0 = 0;
        } else if (f1name && !sal_strcasecmp(s, f1name)) {
            *f1 = 1;
        } else if (f1name
                   && (s[0] == 'n' || s[0] == 'N')
                   && (s[1] == 'o' || s[1] == 'O')
                   && !sal_strcasecmp(&s[2], f1name)) {
            *f1 = 0;
        } else if (f2name && !sal_strcasecmp(s, f2name)) {
            *f2 = 1;
        } else if (f2name
                   && (s[0] == 'n' || s[0] == 'N')
                   && (s[1] == 'o' || s[1] == 'O')
                   && !sal_strcasecmp(&s[2], f2name)) {
            *f2 = 0;
        } else {
            rv = soc_sbx_g3p1_read(s, max, (uint32 *) lower);
            if (rv == SOC_E_NONE) {
                for(s = *argv; *s && *s != '-'; s++);
                if (*s) {
                    s++;
                    rv = soc_sbx_g3p1_read(s, max, (uint32 *) upper);
                    if (rv) {
                        LOG_CLI((BSL_META("illegal upper bound in range %s\n"), s));
                        return SOC_E_FAIL;
                    }
                } else if (argc > 1) {
                    rv = soc_sbx_g3p1_read(argv[1], max, (uint32 *) &num);
                    if (rv == SOC_E_NONE) {
                        *upper = *lower + num - 1;
                        if (*upper >= max) {
                            LOG_CLI((BSL_META("%s overflows the legal range\n"),
                                     argv[1]));
                            return SOC_E_NONE;
                        }
                        argv++;
                        argc--;
                    } else {
                        *upper = *lower;
                    }
                } else {
                    *upper = *lower;
                }
            } else {
                LOG_CLI((BSL_META("unexpected argument: %s\n"), s));
                return SOC_E_PARAM;
            }
        }
        argv++;
        argc--;
    }
    return SOC_E_NONE;
}
/* Find an entry field from a name */
int soc_sbx_g3p1_field_find(
                soc_sbx_g3p1_entry_desc_t *ed, char *a)
{
    int i, l;

    for (i = 0; i < ed->nfields; i++) {
        if (!sal_strcasecmp(a, ed->fields[i].name)) {
          return i;
        }
        l = sal_strlen(ed->fields[i].name);
        if (!sal_strncasecmp(a, ed->fields[i].name, l)
            && a[l] == '=') {
          return i;
      }
    }
    return -1;
}

/* Update the base of a table bank */
int soc_sbx_g3p1_table_bank_base_set(int unit,
                int tid, int bank, int base)
{
    int s;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[tid];
    char *e = "";

    td->banks[bank].base = base;

    s = soc_sbx_g3p1_ucode_set(unit, soc_sbx_g3p1_sym, 128,
                base, e, td->name, bank == 0 ? -1 : bank, e, "BASE");
    return s;
}

/* Get the table bank given a segment and address */
int soc_sbx_g3p1_table_bank_get(soc_sbx_g3p1_table_manager_t *tm, 
                   sbx_caladan3_ocm_port_e_t port, int segment, int addr,
                   soc_sbx_g3p1_table_bank_t **bank)

{
    int i, j;
    soc_sbx_g3p1_table_desc_t *td;
    soc_sbx_g3p1_table_bank_t *tb;

    if (bank) {
        for (i = 0; i < SOC_SBX_G3P1_TABLE_MAX_ID; i++) {
            td = &tm->tables[i];
            for (j = 0; j < td->nbanks; j++) {
                tb = &td->banks[j];
                if (tb->segment == segment && tb->memory == port) {
                    if ((addr >= tb->base) && (addr <= (tb->base + tb->size * tb->width))) {
                        /* table bank found */
                        *bank = tb;
                        return SOC_E_NONE;
                    }
                }
            }
        }
        *bank = NULL;
    }
    return SOC_E_NOT_FOUND;
}

/* Get the ocm port given a memory  */
void soc_sbx_g3p1_ocm_port_get(int mid, sbx_caladan3_ocm_port_e_t *ocmport)
{
    if (ocmport) {
        switch (mid) {
        case SOC_SBX_G3P1_LRP_PORT0_ID:
            *ocmport = 0;
        case SOC_SBX_G3P1_LRP_PORT1_ID:
            *ocmport = 1;
        case SOC_SBX_G3P1_LRP_PORT8_ID:
            *ocmport = 11;
        case SOC_SBX_G3P1_LRP_PORT2_ID:
            *ocmport = 2;
        case SOC_SBX_G3P1_LRP_PORT3_ID:
            *ocmport = 3;
        case SOC_SBX_G3P1_LRP_PORT4_ID:
            *ocmport = 4;
        case SOC_SBX_G3P1_CMU0_PORT_ID:
            *ocmport = 6;
        case SOC_SBX_G3P1_COP0_PORT_ID:
            *ocmport = 7;
        case SOC_SBX_G3P1_BUBBLE_PORT_ID:
            *ocmport = 8;
        case SOC_SBX_G3P1_LRP_PORT5_ID:
            *ocmport = 5;
        case SOC_SBX_G3P1_LRP_PORT9_ID:
            *ocmport = 12;
        case SOC_SBX_G3P1_LRP_PORT6_ID:
            *ocmport = 9;
        case SOC_SBX_G3P1_LRP_PORT7_ID:
            *ocmport = 10;
        case SOC_SBX_G3P1_CMU1_PORT_ID:
            *ocmport = 13;
        case SOC_SBX_G3P1_COP1_PORT_ID:
            *ocmport = 14;
        default:
            LOG_CLI((BSL_META("Invalid port or incomplete mapping, abort!")));
            assert(0);
        }
    }
}

/* Sets a memory bank base */
int soc_sbx_g3p1_memory_bank_base_set(int unit,
                soc_sbx_g3p1_memory_bank_desc_t *mb, int base)
{
    int s = SOC_E_INTERNAL;

    switch (mb->type) {
    case SOC_SBX_G3P1_TABLE_BANK_TYPE:
        s = soc_sbx_g3p1_table_bank_base_set(unit,
                      mb->number, mb->bank, base);
        break;
      default:
         break;
    }

    return s;
}

/* Get the base & size of a bank in a memory */
void soc_sbx_g3p1_memory_bank_params_get(int *base, int *size,
                soc_sbx_g3p1_memory_bank_desc_t *mb,
                soc_sbx_g3p1_table_manager_t *tm)
{
    soc_sbx_g3p1_table_bank_t *tb;

    switch (mb->type) {
    case SOC_SBX_G3P1_TABLE_BANK_TYPE:
        tb = &tm->tables[mb->number].banks[mb->bank];
        *base = tb->base;
        *size = tb->limit - tb->base;
        break;
      default:
        *base=0;
        *size=0;     
        break;

    }
}

/* Pack all memory banks based on current sizes */
int soc_sbx_g3p1_memory_banks_pack(int unit)
{
    int s = SOC_E_NONE;
    int i, j, base, size;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_memory_desc_t *md;
    soc_sbx_g3p1_memory_bank_desc_t *mb;

    for (i = 0; !s && i < SOC_SBX_G3P1_MEMORY_MAX_ID; i++) {
        md = &tm->memories[i];
        for (j = 0; !s && j < md->nbanks; j++) {
            mb = &md->banks[j];
            if (j) {
                soc_sbx_g3p1_memory_bank_params_get(&base, &size,
                          &md->banks[j - 1], tm);
            } else {
                base = 0;
                size = 0;
            }
            base = base + size;
            s = soc_sbx_g3p1_memory_bank_base_set(unit, mb, base);
        }
    }

    return s;
}

/* Slide the base of all banks from a starting bank in a memory */
int soc_sbx_g3p1_bank_slide(int unit,
                soc_sbx_g3p1_memory_desc_t *md,
                int mbank, int offset)
{
    int s = SOC_E_NONE;
    int i, base, size;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_memory_bank_desc_t *mb;

    for (i = mbank; !s && i < md->nbanks; i++) {
        mb = &md->banks[i];
        soc_sbx_g3p1_memory_bank_params_get(&base, &size, mb, tm);
        s = soc_sbx_g3p1_memory_bank_base_set(unit, mb, base + offset);
    }

    return SOC_E_NONE;
}

/* Realign aligned table banks */
int soc_sbx_g3p1_tables_realign(int unit)
{
    int s, tid, first, i, maxbase, mbank, base, size, offset;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td;
    soc_sbx_g3p1_table_bank_t *tb;
    soc_sbx_g3p1_memory_desc_t *md;

    for (tid = tm->alignedlist; tid != -1; tid = td->nextaligned) {
        td = &tm->tables[tid];
        if (td->banks[0].size == 0) continue;
        maxbase = 0;
        first = (td->type == SOC_SBX_G3P1_LPM_TABLE_TYPE
                 || td->type == SOC_SBX_G3P1_EML_TABLE_TYPE);
        for (i = first; i < td->nbanks; i++) {
            tb = &td->banks[i];
            mbank = tb->mbank;
            md = &tm->memories[tb->memory];
            if (mbank > 0) {
                soc_sbx_g3p1_memory_bank_params_get(&base, &size,
                          &md->banks[mbank - 1], tm);
                if (maxbase < base + size) {
                    maxbase = base + size;
                }
            }
        }
        for (i = first; i < td->nbanks; i++) {
            tb = &td->banks[i];
            offset = maxbase - tb->base;
            md = &tm->memories[tb->memory];
            s = soc_sbx_g3p1_bank_slide(unit, md, tb->mbank, offset);
            if (s) {
                return s;
            }
        }
    }

    return SOC_E_NONE;
}

/* Set an entry index range from a table size */
void soc_sbx_g3p1_entry_index_ranges_set(int unit,
                soc_sbx_g3p1_entry_id_t eid)
{
    int i, j, isize, max;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed = &tm->entries[eid];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    
    i = ed->nindexes - 1;
    if (ed->table != SOC_SBX_G3P1_TABLE_MAX_ID
        && ed->type != SOC_SBX_G3P1_EXT_ENTRY_TYPE
        && ed->type != SOC_SBX_G3P1_LPM_ENTRY_TYPE
        && ed->type != SOC_SBX_G3P1_EML_ENTRY_TYPE
        && ed->type != SOC_SBX_G3P1_EM32_ENTRY_TYPE) {

        isize = (tb->size * tb->width / eb->stridebits) - 1;
        for (; 0 <= i; i--) {
            max = isize >> ed->indexes[i].pos;
            if (max) {
                ed->indexes[i].range = max + 1;
                if (i == ed->nindexes - 1) {
                    for (j = 1; 1 << j < max; j++);
                    ed->indexes[i].width = j;
                    ed->indexeswidth =
                        ed->indexes[i].pos + ed->indexes[i].width;
                }
                i--;
                break;
            } else {
                ed->indexes[i].range = 1;
            }
        }
    }
    for (; 0 <= i; i--) {
        ed->indexes[i].range = ed->indexes[i].orange;
    }
}

/* Set the size of a table */
int soc_sbx_g3p1_generic_table_size_set(int unit,
                soc_sbx_g3p1_table_id_t tid, int size, int pack)
{
    int s, i, size0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[tid];
    soc_sbx_g3p1_table_bank_t *tb;
    soc_sbx_g3p1_entry_desc_t *ed;
    char *e = "";


    for (i = 0; i < td->nbanks; i++) {
        tb = &td->banks[i];
        size0 = (size && !i && td->b0size) ? td->b0size : size;
        tb->size = size0;
        s = soc_sbx_g3p1_ucode_set(unit,
                    soc_sbx_g3p1_sym, 128,
                    size0, e, td->name, i == 0 ? -1 : i, e,
                    "SIZE");
        if (s) {
            return s;
        }
    }

    if (pack) {
        s = soc_sbx_g3p1_memory_banks_pack(unit);
        if (s) {
            return s;
        }
        s = soc_sbx_g3p1_tables_realign(unit);
        if (s) {
            return s;
        }
    }

    for (i = 0; i < SOC_SBX_G3P1_ENTRY_MAX_ID; i++) {
        ed = &tm->entries[i];
        if (ed->table == tid) {
            soc_sbx_g3p1_entry_index_ranges_set(unit, i);
        }
    }

    return SOC_E_NONE;
}

void soc_sbx_g3p1_memory_bank_sort(int size,
                soc_sbx_g3p1_memory_bank_desc_t *mb,
                soc_sbx_g3p1_table_manager_t *tm)
{
    int i, j;
    int basea, sizea, baseb, sizeb;
    int t;

    for (i = 0; i < size; i++) {
        soc_sbx_g3p1_memory_bank_params_get(&basea, &sizea, &mb[i], tm);
        for (j = i + 1; j < size; j++) {
            soc_sbx_g3p1_memory_bank_params_get(&baseb, &sizeb, &mb[j], tm);
            if (baseb < basea) {
                t = mb[i].type;
                mb[i].type = mb[j].type;
                mb[j].type = t;
                t = mb[i].number;
                mb[i].number = mb[j].number;
                mb[j].number = t;
                t = mb[i].bank;
                mb[i].bank = mb[j].bank;
                mb[j].bank = t;
                basea = baseb;
                sizea = sizeb;
            }
        }
    }
}
void soc_sbx_g3p1_memory_banks_init(soc_sbx_g3p1_table_manager_t *tm)
{
    int i, j, k;
    int p = 0;
    soc_sbx_g3p1_memory_desc_t *md;
    soc_sbx_g3p1_memory_bank_desc_t *mb;

    for (i = 0; i < SOC_SBX_G3P1_MEMORY_MAX_ID; i++) {
        md = &tm->memories[i];
        md->banks = &tm->memorybanks[p];
        md->nbanks = 0;
        for (j = 0; j < SOC_SBX_G3P1_TABLE_MAX_ID; j++) {
            for (k = 0; k < tm->tables[j].nbanks; k++) {
                  /* coverity[mixed_enums] */
                if (tm->tables[j].banks[k].memory == i) {
                    tm->memorybanks[p].type =
                        SOC_SBX_G3P1_TABLE_BANK_TYPE;
                    tm->memorybanks[p].number = j;
                    tm->memorybanks[p].bank = k;
                    p++;
                    md->nbanks++;
                }
            }
        }
    }

    for (i = 0; i < SOC_SBX_G3P1_MEMORY_MAX_ID; i++) {
        md = &tm->memories[i];
        soc_sbx_g3p1_memory_bank_sort(md->nbanks, md->banks, tm);
        for (j = md->nbanks - 1; 0 <= j; j--) {
            mb = &md->banks[j];
            switch (mb->type) {
            case SOC_SBX_G3P1_TABLE_BANK_TYPE:
                tm->tables[mb->number].banks[mb->bank].mbank = j;
                if (tm->tables[mb->number].nextaligned) {
                    mb->nextaligned = md->alignedlist;
                    md->alignedlist = j;
                }
                break;
             default:
                 break;
            }
        }
    }
}

/* Find a memory bank member by address */
int soc_sbx_g3p1_memory_bank_find(
                soc_sbx_g3p1_table_manager_t *tm,
                soc_sbx_g3p1_memory_desc_t *md,
                int addr, char **name, int *offset, int *iscnt)
{
    /* no counters */
    return SOC_E_PARAM;
}




static int soc_sbx_g3p1_consts_init(int unit, soc_sbx_g3p1_table_manager_t *tm) {  
	
 	/*
     * Per-constant state initialization
     */
    tm->constants = UTG_MALLOC(sizeof(soc_sbx_g3p1_constant_desc_t)
                           * SOC_SBX_G3P1_CONSTANT_MAX_ID);
    if (!tm->constants) {
      	return SOC_E_MEMORY;
    }

	tm->constants[SOC_SBX_G3P1_MAX_PORTS_ID].name =
	        "max_ports";
	tm->constants[SOC_SBX_G3P1_IP_VRF_BITS_ID].name =
	        "ip_vrf_bits";
	tm->constants[SOC_SBX_G3P1_EXC_STP_BLOCKED_IDX_ID].name =
	        "exc_stp_blocked_idx";
	tm->constants[SOC_SBX_G3P1_EXC_SMAC_DROP_IDX_ID].name =
	        "exc_smac_drop_idx";
	tm->constants[SOC_SBX_G3P1_EXC_SMAC_UNKNOWN_IDX_ID].name =
	        "exc_smac_unknown_idx";
	tm->constants[SOC_SBX_G3P1_EXC_MAC_HAIRPIN_IDX_ID].name =
	        "exc_mac_hairpin_idx";
	tm->constants[SOC_SBX_G3P1_EXC_DMAC_DROP_IDX_ID].name =
	        "exc_dmac_drop_idx";
	tm->constants[SOC_SBX_G3P1_EXC_TTL_EXPIRED_IDX_ID].name =
	        "exc_ttl_expired_idx";
	tm->constants[SOC_SBX_G3P1_EXC_EGR_STP_BLOCKED_IDX_ID].name =
	        "exc_egr_stp_blocked_idx";
	tm->constants[SOC_SBX_G3P1_EXC_SPLIT_IDX_ID].name =
	        "exc_split_idx";
	tm->constants[SOC_SBX_G3P1_EXC_MTU_IDX_ID].name =
	        "exc_mtu_idx";
	tm->constants[SOC_SBX_G3P1_EXC_OAM_MISMATCH_IDX_ID].name =
	        "exc_oam_mismatch_idx";
	tm->constants[SOC_SBX_G3P1_EXC_OAM_PEER_NOT_FOUND_IDX_ID].name =
	        "exc_oam_peer_not_found_idx";
	tm->constants[SOC_SBX_G3P1_EXC_OAM_NO_ENDPOINT_IDX_ID].name =
	        "exc_oam_no_endpoint_idx";
	tm->constants[SOC_SBX_G3P1_EXC_OAM_UNK_TYPE_IDX_ID].name =
	        "exc_oam_unk_type_idx";
	tm->constants[SOC_SBX_G3P1_EXC_OAM_RDI_IDX_ID].name =
	        "exc_oam_rdi_idx";
	tm->constants[SOC_SBX_G3P1_EXC_VLAN_DROP_IDX_ID].name =
	        "exc_vlan_drop_idx";
	tm->constants[SOC_SBX_G3P1_EXC_V4MC_RPF_CHECK_IDX_ID].name =
	        "exc_v4mc_rpf_check_idx";
	tm->constants[SOC_SBX_G3P1_EXC_URPF_DROP_IDX_ID].name =
	        "exc_urpf_drop_idx";
	tm->constants[SOC_SBX_G3P1_EXC_IP_SA_DROP_IDX_ID].name =
	        "exc_ip_sa_drop_idx";
	tm->constants[SOC_SBX_G3P1_EXC_MIM_BAD_FORMAT_IDX_ID].name =
	        "exc_mim_bad_format_idx";
	tm->constants[SOC_SBX_G3P1_EXC_ISID2E_MISS_IDX_ID].name =
	        "exc_isid2e_miss_idx";
	tm->constants[SOC_SBX_G3P1_EXC_OAM_THRESHOLD_EXCEEDED_IDX_ID].name =
	        "exc_oam_threshold_exceeded_idx";
	tm->constants[SOC_SBX_G3P1_EXC_OAM_COPY_TO_HOST_IDX_ID].name =
	        "exc_oam_copy_to_host_idx";
	tm->constants[SOC_SBX_G3P1_EXC_OAM_PARAM_CHANGE_IDX_ID].name =
	        "exc_oam_param_change_idx";
	tm->constants[SOC_SBX_G3P1_EXC_BAD_OUTER_LABEL_IDX_ID].name =
	        "exc_bad_outer_label_idx";
	tm->constants[SOC_SBX_G3P1_EXC_BAD_INNER_LABEL_IDX_ID].name =
	        "exc_bad_inner_label_idx";
	tm->constants[SOC_SBX_G3P1_EXC_LSP_PING_IDX_ID].name =
	        "exc_lsp_ping_idx";
	tm->constants[SOC_SBX_G3P1_EXC_TOO_MANY_LABELS_IDX_ID].name =
	        "exc_too_many_labels_idx";
	tm->constants[SOC_SBX_G3P1_EXC_EGR_DROP_TAGGED_IDX_ID].name =
	        "exc_egr_drop_tagged_idx";
	tm->constants[SOC_SBX_G3P1_EXC_EGR_DROP_UNTAGGED_IDX_ID].name =
	        "exc_egr_drop_untagged_idx";
	tm->constants[SOC_SBX_G3P1_EXC_EGR_OAM_LINK_IDX_ID].name =
	        "exc_egr_oam_link_idx";
	tm->constants[SOC_SBX_G3P1_EXC_OAM_INTERNAL_ERROR_IDX_ID].name =
	        "exc_oam_internal_error_idx";
	tm->constants[SOC_SBX_G3P1_EXC_DCN_IDX_ID].name =
	        "exc_dcn_idx";
	tm->constants[SOC_SBX_G3P1_EXC_MPLS_FILTER_IDX_ID].name =
	        "exc_mpls_filter_idx";
	tm->constants[SOC_SBX_G3P1_MIN_FREE_EXCEPTION_ID].name =
	        "min_free_exception";
	tm->constants[SOC_SBX_G3P1_MAX_FREE_EXCEPTION_ID].name =
	        "max_free_exception";
	tm->constants[SOC_SBX_G3P1_EXC_SMAC_LEARN_IDX_ID].name =
	        "exc_smac_learn_idx";
	tm->constants[SOC_SBX_G3P1_EXC_PIM_IDX_ID].name =
	        "exc_pim_idx";
	tm->constants[SOC_SBX_G3P1_EXC_IGMP_IDX_ID].name =
	        "exc_igmp_idx";
	tm->constants[SOC_SBX_G3P1_EXC_RT_COPY_IDX_ID].name =
	        "exc_rt_copy_idx";
	tm->constants[SOC_SBX_G3P1_EXC_L2CP_COPY_IDX_ID].name =
	        "exc_l2cp_copy_idx";
	tm->constants[SOC_SBX_G3P1_EXC_DMAC_COPY_IDX_ID].name =
	        "exc_dmac_copy_idx";
	tm->constants[SOC_SBX_G3P1_EXC_IPREDIRECT_IDX_ID].name =
	        "exc_ipredirect_idx";
	tm->constants[SOC_SBX_G3P1_EXC_BMAC_LEARN_IDX_ID].name =
	        "exc_bmac_learn_idx";
	tm->constants[SOC_SBX_G3P1_EXC_COPY_MAX_IDX_ID].name =
	        "exc_copy_max_idx";
	tm->constants[SOC_SBX_G3P1_HTYPE_NULL_ID].name =
	        "htype_null";
	tm->constants[SOC_SBX_G3P1_HLEN_NULL_ID].name =
	        "hlen_null";
	tm->constants[SOC_SBX_G3P1_HTYPE_ETH_ID].name =
	        "htype_eth";
	tm->constants[SOC_SBX_G3P1_HLEN_ETH_ID].name =
	        "hlen_eth";
	tm->constants[SOC_SBX_G3P1_HTYPE_VTAG_ID].name =
	        "htype_vtag";
	tm->constants[SOC_SBX_G3P1_HLEN_VTAG_ID].name =
	        "hlen_vtag";
	tm->constants[SOC_SBX_G3P1_HTYPE_ETYPE_ID].name =
	        "htype_etype";
	tm->constants[SOC_SBX_G3P1_HLEN_ETYPE_ID].name =
	        "hlen_etype";
	tm->constants[SOC_SBX_G3P1_HTYPE_IPV4_ID].name =
	        "htype_ipv4";
	tm->constants[SOC_SBX_G3P1_HLEN_IPV4_ID].name =
	        "hlen_ipv4";
	tm->constants[SOC_SBX_G3P1_HTYPE_IPV6_ID].name =
	        "htype_ipv6";
	tm->constants[SOC_SBX_G3P1_HLEN_IPV6_ID].name =
	        "hlen_ipv6";
	tm->constants[SOC_SBX_G3P1_HTYPE_MPLS_ID].name =
	        "htype_mpls";
	tm->constants[SOC_SBX_G3P1_HLEN_MPLS_ID].name =
	        "hlen_mpls";
	tm->constants[SOC_SBX_G3P1_HTYPE_ACH_ID].name =
	        "htype_ach";
	tm->constants[SOC_SBX_G3P1_HLEN_ACH_ID].name =
	        "hlen_ach";
	tm->constants[SOC_SBX_G3P1_HTYPE_UDP_ID].name =
	        "htype_udp";
	tm->constants[SOC_SBX_G3P1_HLEN_UDP_ID].name =
	        "hlen_udp";
	tm->constants[SOC_SBX_G3P1_HTYPE_TCP_ID].name =
	        "htype_tcp";
	tm->constants[SOC_SBX_G3P1_HLEN_TCP_ID].name =
	        "hlen_tcp";
	tm->constants[SOC_SBX_G3P1_HTYPE_PTP_ID].name =
	        "htype_ptp";
	tm->constants[SOC_SBX_G3P1_HLEN_PTP_ID].name =
	        "hlen_ptp";
	tm->constants[SOC_SBX_G3P1_HTYPE_IETH_ID].name =
	        "htype_ieth";
	tm->constants[SOC_SBX_G3P1_HTYPE_LLC_ID].name =
	        "htype_llc";
	tm->constants[SOC_SBX_G3P1_HLEN_LLC_ID].name =
	        "hlen_llc";
	tm->constants[SOC_SBX_G3P1_HTYPE_SNAP_ID].name =
	        "htype_snap";
	tm->constants[SOC_SBX_G3P1_HLEN_SNAP_ID].name =
	        "hlen_snap";
	tm->constants[SOC_SBX_G3P1_HTYPE_DVTAG_ID].name =
	        "htype_dvtag";
	tm->constants[SOC_SBX_G3P1_HTYPE_MIM_ID].name =
	        "htype_mim";
	tm->constants[SOC_SBX_G3P1_HLEN_MIM_ID].name =
	        "hlen_mim";
	tm->constants[SOC_SBX_G3P1_HTYPE_BFD_ID].name =
	        "htype_bfd";
	tm->constants[SOC_SBX_G3P1_HLEN_BFD_ID].name =
	        "hlen_bfd";
	tm->constants[SOC_SBX_G3P1_HTYPE_EERH_ID].name =
	        "htype_eerh";
	tm->constants[SOC_SBX_G3P1_HLEN_EERH_ID].name =
	        "hlen_eerh";
	tm->constants[SOC_SBX_G3P1_HTYPE_ERH_ID].name =
	        "htype_erh";
	tm->constants[SOC_SBX_G3P1_HLEN_ERH_ID].name =
	        "hlen_erh";
	tm->constants[SOC_SBX_G3P1_HTYPE_TMH_ID].name =
	        "htype_tmh";
	tm->constants[SOC_SBX_G3P1_HLEN_TMH_ID].name =
	        "hlen_tmh";
	tm->constants[SOC_SBX_G3P1_HTYPE_KSOP_ID].name =
	        "htype_ksop";
	tm->constants[SOC_SBX_G3P1_HLEN_KSOP_ID].name =
	        "hlen_ksop";
	tm->constants[SOC_SBX_G3P1_HTYPE_CUSTOM_ID].name =
	        "htype_custom";
	tm->constants[SOC_SBX_G3P1_HLEN_CUSTOM_ID].name =
	        "hlen_custom";
	tm->constants[SOC_SBX_G3P1_HTYPE_ELEN_ID].name =
	        "htype_elen";
	tm->constants[SOC_SBX_G3P1_HLEN_ELEN_ID].name =
	        "hlen_elen";
	tm->constants[SOC_SBX_G3P1_HTYPE_UNKN_ID].name =
	        "htype_unkn";
	tm->constants[SOC_SBX_G3P1_LSMAC_TABLE_SIZE_ID].name =
	        "lsmac_table_size";
	tm->constants[SOC_SBX_G3P1_L2CPMAC_TABLE_SIZE_ID].name =
	        "l2cpmac_table_size";
	tm->constants[SOC_SBX_G3P1_OAMUPMAC_TABLE_SIZE_ID].name =
	        "oamupmac_table_size";
	tm->constants[SOC_SBX_G3P1_OAM_NUM_ENDPOINTS_ID].name =
	        "oam_num_endpoints";
	tm->constants[SOC_SBX_G3P1_PTYPE_UNKNOWN_UNICAST_ID].name =
	        "ptype_unknown_unicast";
	tm->constants[SOC_SBX_G3P1_PTYPE_KNOWN_UNICAST_ID].name =
	        "ptype_known_unicast";
	tm->constants[SOC_SBX_G3P1_PTYPE_MULTICAST_ID].name =
	        "ptype_multicast";
	tm->constants[SOC_SBX_G3P1_PTYPE_BROADCAST_ID].name =
	        "ptype_broadcast";
	tm->constants[SOC_SBX_G3P1_PTYPE_LAST_ID].name =
	        "ptype_last";
	tm->constants[SOC_SBX_G3P1_CUCKOO_TYPE_PVV_ID].name =
	        "cuckoo_type_pvv";
	tm->constants[SOC_SBX_G3P1_CUCKOO_TYPE_ISID_ID].name =
	        "cuckoo_type_isid";
	tm->constants[SOC_SBX_G3P1_CUCKOO_TYPE_PVD_ID].name =
	        "cuckoo_type_pvd";
	tm->constants[SOC_SBX_G3P1_CUCKOO_TYPE_MAIDMEP_ID].name =
	        "cuckoo_type_maidmep";
	tm->constants[SOC_SBX_G3P1_CUCKOO_TYPE_SHIFT_ID].name =
	        "cuckoo_type_shift";
	tm->constants[SOC_SBX_G3P1_MAX_QOS_PROFILE_INDEX_ID].name =
	        "max_qos_profile_index";
	tm->constants[SOC_SBX_G3P1_MAX_QOS_MAP_TABLE_ID].name =
	        "max_qos_map_table";
	tm->constants[SOC_SBX_G3P1_MAX_QOS_REMARK_TABLE_ID].name =
	        "max_qos_remark_table";
	tm->constants[SOC_SBX_G3P1_MAX_L2CP_TYPES_ID].name =
	        "max_l2cp_types";
	tm->constants[SOC_SBX_G3P1_MAX_L2CP_SUBTYPES_ID].name =
	        "max_l2cp_subtypes";
	tm->constants[SOC_SBX_G3P1_URPF_DEFAULT_PID_ID].name =
	        "urpf_default_pid";
	tm->constants[SOC_SBX_G3P1_STPSTATE_FORWARD_ID].name =
	        "stpstate_forward";
	tm->constants[SOC_SBX_G3P1_STPSTATE_BLOCK_ID].name =
	        "stpstate_block";
	tm->constants[SOC_SBX_G3P1_STPSTATE_LEARN_ID].name =
	        "stpstate_learn";
	tm->constants[SOC_SBX_G3P1_MPLSTP_LOOPBACK_OAM_ID].name =
	        "mplstp_loopback_oam";
	tm->constants[SOC_SBX_G3P1_MPLSTP_LOOPBACK_FULL_ID].name =
	        "mplstp_loopback_full";
	tm->constants[SOC_SBX_G3P1_MPLSTP_LOOPBACK_NONE_ID].name =
	        "mplstp_loopback_none";
	tm->constants[SOC_SBX_G3P1_LABEL_LSR_ID].name =
	        "label_lsr";
	tm->constants[SOC_SBX_G3P1_LABEL_ETH_PWE3_ID].name =
	        "label_eth_pwe3";
	tm->constants[SOC_SBX_G3P1_LABEL_LER_ID].name =
	        "label_ler";
	tm->constants[SOC_SBX_G3P1_LABEL_CES_PWE3_ID].name =
	        "label_ces_pwe3";
	
	return SOC_E_NONE;
}
	


static int soc_sbx_g3p1_globals_init(int unit, soc_sbx_g3p1_table_manager_t *tm) {  

	int i, s;
	char *e = "";
	
 	/*
     * Global value initialization
     */
    tm->globals = UTG_MALLOC(sizeof(soc_sbx_g3p1_memory_desc_t)
                         * SOC_SBX_G3P1_GLOBAL_MAX_ID);
    if (!tm->globals) {
        return SOC_E_MEMORY;
    }

	tm->globals[SOC_SBX_G3P1_CONTEXTS_ID].name =
	        "contexts";
	tm->globals[SOC_SBX_G3P1_TPID0_ID].name =
	        "tpid0";
	tm->globals[SOC_SBX_G3P1_TPID1_ID].name =
	        "tpid1";
	tm->globals[SOC_SBX_G3P1_TPID2_ID].name =
	        "tpid2";
	tm->globals[SOC_SBX_G3P1_DEFITAG_ID].name =
	        "defitag";
	tm->globals[SOC_SBX_G3P1_AGE_ID].name =
	        "age";
	tm->globals[SOC_SBX_G3P1_CUCKOO_ABSEED_ID].name =
	        "cuckoo_abseed";
	tm->globals[SOC_SBX_G3P1_LABELCUCKOO_ABSEED_ID].name =
	        "labelcuckoo_abseed";
	tm->globals[SOC_SBX_G3P1_NODE_ID].name =
	        "node";
	tm->globals[SOC_SBX_G3P1_VLAN_FT_BASE_ID].name =
	        "vlan_ft_base";
	tm->globals[SOC_SBX_G3P1_VPWS_VLAN_ID].name =
	        "vpws_vlan";
	tm->globals[SOC_SBX_G3P1_VPWS_FT_OFFSET_ID].name =
	        "vpws_ft_offset";
	tm->globals[SOC_SBX_G3P1_MAX_PIDS_ID].name =
	        "max_pids";
	tm->globals[SOC_SBX_G3P1_MC_FT_OFFSET_ID].name =
	        "mc_ft_offset";
	tm->globals[SOC_SBX_G3P1_OAM_DROP_BIT_ID].name =
	        "oam_drop_bit";
	tm->globals[SOC_SBX_G3P1_OAM_ENET_CONTINUE_BYTE_ID].name =
	        "oam_enet_continue_byte";
	tm->globals[SOC_SBX_G3P1_OAM_MPLS_CONTINUE_BYTE_ID].name =
	        "oam_mpls_continue_byte";
	tm->globals[SOC_SBX_G3P1_OAM_ENET_FRAME_LEN_ID].name =
	        "oam_enet_frame_len";
	tm->globals[SOC_SBX_G3P1_OAM_MPLS_FRAME_LEN_ID].name =
	        "oam_mpls_frame_len";
	tm->globals[SOC_SBX_G3P1_OAM_SOURCE_QUEUE_ID].name =
	        "oam_source_queue";
	tm->globals[SOC_SBX_G3P1_OAM_DEST_QUEUE_ID].name =
	        "oam_dest_queue";
	tm->globals[SOC_SBX_G3P1_OAM_SOURCE_BUFFER_ID].name =
	        "oam_source_buffer";
	tm->globals[SOC_SBX_G3P1_OAM_BUBBLE_TIMER_OFFSET_ID].name =
	        "oam_bubble_timer_offset";
	tm->globals[SOC_SBX_G3P1_OAM_SA_LM_ID].name =
	        "oam_sa_lm";
	tm->globals[SOC_SBX_G3P1_OAM_SA_DM_ID].name =
	        "oam_sa_dm";
	tm->globals[SOC_SBX_G3P1_OAM_MPLS_SA_LM_ID].name =
	        "oam_mpls_sa_lm";
	tm->globals[SOC_SBX_G3P1_OAM_MPLS_SA_DM_ID].name =
	        "oam_mpls_sa_dm";
	tm->globals[SOC_SBX_G3P1_OAM_PWE_IP_SA_ID].name =
	        "oam_pwe_ip_sa";
	tm->globals[SOC_SBX_G3P1_OAM_PWE_UDP_DEST_PORT_ID].name =
	        "oam_pwe_udp_dest_port";
	tm->globals[SOC_SBX_G3P1_OAM_LOOPBACK_QID_ID].name =
	        "oam_loopback_qid";
	tm->globals[SOC_SBX_G3P1_OAM_SA_4LO_ID].name =
	        "oam_sa_4lo";
	tm->globals[SOC_SBX_G3P1_OAM_SA_2HI_ID].name =
	        "oam_sa_2hi";
	tm->globals[SOC_SBX_G3P1_OAM_SA_4LO_AUX_ID].name =
	        "oam_sa_4lo_aux";
	tm->globals[SOC_SBX_G3P1_OAM_SA_2HI_AUX_ID].name =
	        "oam_sa_2hi_aux";
	tm->globals[SOC_SBX_G3P1_OAM_BFD_STATE_TABLE_ID].name =
	        "oam_bfd_state_table";
	tm->globals[SOC_SBX_G3P1_OAM_BFD_RDI_DIAG_CODE_ID].name =
	        "oam_bfd_rdi_diag_code";
	tm->globals[SOC_SBX_G3P1_OAM_TX_PACKETS_PER_BUBBLE_ID].name =
	        "oam_tx_packets_per_bubble";
	tm->globals[SOC_SBX_G3P1_OAM_TX_PACKETS_PER_BUBBLE_CA_ID].name =
	        "oam_tx_packets_per_bubble_ca";
	tm->globals[SOC_SBX_G3P1_OAM_PSC_RX_FILTER_ID].name =
	        "oam_psc_rx_filter";
	tm->globals[SOC_SBX_G3P1_OAM_LOCAL_FE_QID_ID].name =
	        "oam_local_fe_qid";
	tm->globals[SOC_SBX_G3P1_OAM_ETE_BASE_ID].name =
	        "oam_ete_base";
	tm->globals[SOC_SBX_G3P1_OAM_RSVD_OIP_ID].name =
	        "oam_rsvd_oip";
	tm->globals[SOC_SBX_G3P1_BLACKHOLE_VLAN_ID].name =
	        "blackhole_vlan";
	tm->globals[SOC_SBX_G3P1_IGMP_PROXY_MODE_ID].name =
	        "igmp_proxy_mode";
	tm->globals[SOC_SBX_G3P1_STATIC_LAG_ID].name =
	        "static_lag";
	tm->globals[SOC_SBX_G3P1_IPV4_CHECKSUM_MODE_ID].name =
	        "ipv4_checksum_mode";
	tm->globals[SOC_SBX_G3P1_EXIT_FILTER_ON_BTAG_ID].name =
	        "exit_filter_on_btag";
	tm->globals[SOC_SBX_G3P1_SWITCH_METER_ADJUST_ID].name =
	        "switch_meter_adjust";
	tm->globals[SOC_SBX_G3P1_RC1_RULE_STARTIDX_ID].name =
	        "rc1_rule_startidx";
	tm->globals[SOC_SBX_G3P1_IPV6_ACL_ENABLE_ID].name =
	        "ipv6_acl_enable";
	tm->globals[SOC_SBX_G3P1_OI2EOFF_ID].name =
	        "oi2eoff";
	tm->globals[SOC_SBX_G3P1_ETE_SEGMENT_NUM_ID].name =
	        "ete_segment_num";
	tm->globals[SOC_SBX_G3P1_OAM_EP_SEGMENT_NUM_ID].name =
	        "oam_ep_segment_num";
	tm->globals[SOC_SBX_G3P1_OAM_LOCAL_SEGMENT_NUM_ID].name =
	        "oam_local_segment_num";
	tm->globals[SOC_SBX_G3P1_OAM_PEER_SEGMENT_NUM_ID].name =
	        "oam_peer_segment_num";
	tm->globals[SOC_SBX_G3P1_SAMPLE_DM1_SEGMENT_NUM_ID].name =
	        "sample_dm1_segment_num";
	tm->globals[SOC_SBX_G3P1_ARAD_FWDACTION_ID].name =
	        "arad_fwdaction";
	tm->globals[SOC_SBX_G3P1_INTERLAKEN_OFFSET_ID].name =
	        "interlaken_offset";
	tm->globals[SOC_SBX_G3P1_HIGIG_LOOP_ENABLE_ID].name =
	        "higig_loop_enable";
	tm->globals[SOC_SBX_G3P1_MACLEARN_FILTER_ENABLE_ID].name =
	        "maclearn_filter_enable";
	tm->globals[SOC_SBX_G3P1_DEBUG_STREAM_ELEN_ID].name =
	        "debug_stream_elen";
	tm->globals[SOC_SBX_G3P1_C3_SWS_STATIC_PAGE_ID].name =
	        "c3_sws_static_page";
	tm->globals[SOC_SBX_G3P1_C3_SWS_INGRESS_BUBBLE_SQUEUE_ID].name =
	        "c3_sws_ingress_bubble_squeue";
	tm->globals[SOC_SBX_G3P1_C3_SWS_FAB_TO_LINE_REDIRECT_QID0_ID].name =
	        "c3_sws_fab_to_line_redirect_qid0";
	tm->globals[SOC_SBX_G3P1_C3_SWS_FAB_TO_LINE_REDIRECT_QID1_ID].name =
	        "c3_sws_fab_to_line_redirect_qid1";
	tm->globals[SOC_SBX_G3P1_C3_SWS_EGRESS_BUBBLE_SQUEUE_ID].name =
	        "c3_sws_egress_bubble_squeue";
	tm->globals[SOC_SBX_G3P1_C3_SWS_LINE_TO_FAB_REDIRECT_QID0_ID].name =
	        "c3_sws_line_to_fab_redirect_qid0";
	tm->globals[SOC_SBX_G3P1_C3_SWS_LINE_TO_FAB_REDIRECT_QID1_ID].name =
	        "c3_sws_line_to_fab_redirect_qid1";
	
	for (i = 0; i < SOC_SBX_G3P1_GLOBAL_MAX_ID; i++) {
        s = soc_sbx_g3p1_ucode_get(unit,
                  soc_sbx_g3p1_sym,
                  128,
                  &tm->globals[i].range,
                  e,
                  tm->globals[i].name,
                  -1,
                  e,
                  "RANGE");
        if (s) {
            soc_sbx_g3p1_uninit(unit);
            return s;
        }
        s = soc_sbx_g3p1_ucode_get(unit,
                  soc_sbx_g3p1_sym,
                  128,
                  &tm->globals[i].value,
                  e,
                  tm->globals[i].name,
                  -1,
                  e,
                  e);
        if (s) {
            soc_sbx_g3p1_uninit(unit);
            return s;
        }
    }
    
    return SOC_E_NONE;
}

int soc_sbx_g3p1_globals_reinit(int unit) {  
    int i, s __attribute__((unused));
    char *e = "";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;

    for (i = 0; i < SOC_SBX_G3P1_GLOBAL_MAX_ID; i++) {
        s = soc_sbx_g3p1_ucode_get(unit,
                  soc_sbx_g3p1_sym,
                  128,
                  &tm->globals[i].value,
                  e,
                  tm->globals[i].name,
                  -1,
                  e,
                  e);
    }
    
    return SOC_E_NONE;
}


/*
 * Shared constant accessors implementation
 */
int soc_sbx_g3p1_max_ports_get(int unit, uint32 *vp)
{
    char *s = "MAX_PORTS";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_ip_vrf_bits_get(int unit, uint32 *vp)
{
    char *s = "IP_VRF_BITS";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_stp_blocked_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_STP_BLOCKED_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_smac_drop_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_SMAC_DROP_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_smac_unknown_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_SMAC_UNKNOWN_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_mac_hairpin_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_MAC_HAIRPIN_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_dmac_drop_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_DMAC_DROP_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_ttl_expired_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_TTL_EXPIRED_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_egr_stp_blocked_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_EGR_STP_BLOCKED_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_split_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_SPLIT_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_mtu_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_MTU_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_oam_mismatch_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_OAM_MISMATCH_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_oam_peer_not_found_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_OAM_PEER_NOT_FOUND_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_oam_no_endpoint_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_OAM_NO_ENDPOINT_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_oam_unk_type_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_OAM_UNK_TYPE_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_oam_rdi_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_OAM_RDI_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_vlan_drop_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_VLAN_DROP_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_v4mc_rpf_check_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_V4MC_RPF_CHECK_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_urpf_drop_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_URPF_DROP_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_ip_sa_drop_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_IP_SA_DROP_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_mim_bad_format_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_MIM_BAD_FORMAT_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_isid2e_miss_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_ISID2E_MISS_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_oam_threshold_exceeded_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_OAM_THRESHOLD_EXCEEDED_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_oam_copy_to_host_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_OAM_COPY_TO_HOST_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_oam_param_change_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_OAM_PARAM_CHANGE_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_bad_outer_label_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_BAD_OUTER_LABEL_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_bad_inner_label_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_BAD_INNER_LABEL_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_lsp_ping_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_LSP_PING_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_too_many_labels_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_TOO_MANY_LABELS_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_egr_drop_tagged_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_EGR_DROP_TAGGED_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_egr_drop_untagged_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_EGR_DROP_UNTAGGED_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_egr_oam_link_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_EGR_OAM_LINK_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_oam_internal_error_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_OAM_INTERNAL_ERROR_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_dcn_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_DCN_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_mpls_filter_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_MPLS_FILTER_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_min_free_exception_get(int unit, uint32 *vp)
{
    char *s = "MIN_FREE_EXCEPTION";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_max_free_exception_get(int unit, uint32 *vp)
{
    char *s = "MAX_FREE_EXCEPTION";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_smac_learn_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_SMAC_LEARN_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_pim_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_PIM_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_igmp_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_IGMP_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_rt_copy_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_RT_COPY_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_l2cp_copy_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_L2CP_COPY_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_dmac_copy_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_DMAC_COPY_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_ipredirect_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_IPREDIRECT_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_bmac_learn_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_BMAC_LEARN_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_exc_copy_max_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_COPY_MAX_IDX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_htype_null_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_NULL";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_hlen_null_get(int unit, uint32 *vp)
{
    char *s = "HLEN_NULL";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_htype_eth_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_ETH";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_hlen_eth_get(int unit, uint32 *vp)
{
    char *s = "HLEN_ETH";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_htype_vtag_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_VTAG";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_hlen_vtag_get(int unit, uint32 *vp)
{
    char *s = "HLEN_VTAG";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_htype_etype_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_ETYPE";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_hlen_etype_get(int unit, uint32 *vp)
{
    char *s = "HLEN_ETYPE";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_htype_ipv4_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_IPV4";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_hlen_ipv4_get(int unit, uint32 *vp)
{
    char *s = "HLEN_IPV4";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_htype_ipv6_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_IPV6";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_hlen_ipv6_get(int unit, uint32 *vp)
{
    char *s = "HLEN_IPV6";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_htype_mpls_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_MPLS";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_hlen_mpls_get(int unit, uint32 *vp)
{
    char *s = "HLEN_MPLS";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_htype_ach_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_ACH";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_hlen_ach_get(int unit, uint32 *vp)
{
    char *s = "HLEN_ACH";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_htype_udp_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_UDP";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_hlen_udp_get(int unit, uint32 *vp)
{
    char *s = "HLEN_UDP";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_htype_tcp_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_TCP";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_hlen_tcp_get(int unit, uint32 *vp)
{
    char *s = "HLEN_TCP";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_htype_ptp_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_PTP";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_hlen_ptp_get(int unit, uint32 *vp)
{
    char *s = "HLEN_PTP";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_htype_ieth_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_IETH";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_htype_llc_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_LLC";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_hlen_llc_get(int unit, uint32 *vp)
{
    char *s = "HLEN_LLC";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_htype_snap_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_SNAP";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_hlen_snap_get(int unit, uint32 *vp)
{
    char *s = "HLEN_SNAP";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_htype_dvtag_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_DVTAG";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_htype_mim_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_MIM";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_hlen_mim_get(int unit, uint32 *vp)
{
    char *s = "HLEN_MIM";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_htype_bfd_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_BFD";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_hlen_bfd_get(int unit, uint32 *vp)
{
    char *s = "HLEN_BFD";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_htype_eerh_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_EERH";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_hlen_eerh_get(int unit, uint32 *vp)
{
    char *s = "HLEN_EERH";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_htype_erh_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_ERH";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_hlen_erh_get(int unit, uint32 *vp)
{
    char *s = "HLEN_ERH";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_htype_tmh_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_TMH";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_hlen_tmh_get(int unit, uint32 *vp)
{
    char *s = "HLEN_TMH";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_htype_ksop_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_KSOP";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_hlen_ksop_get(int unit, uint32 *vp)
{
    char *s = "HLEN_KSOP";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_htype_custom_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_CUSTOM";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_hlen_custom_get(int unit, uint32 *vp)
{
    char *s = "HLEN_CUSTOM";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_htype_elen_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_ELEN";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_hlen_elen_get(int unit, uint32 *vp)
{
    char *s = "HLEN_ELEN";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_htype_unkn_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_UNKN";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_lsmac_table_size_get(int unit, uint32 *vp)
{
    char *s = "LSMAC_TABLE_SIZE";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_l2cpmac_table_size_get(int unit, uint32 *vp)
{
    char *s = "L2CPMAC_TABLE_SIZE";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_oamupmac_table_size_get(int unit, uint32 *vp)
{
    char *s = "OAMUPMAC_TABLE_SIZE";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_oam_num_endpoints_get(int unit, uint32 *vp)
{
    char *s = "OAM_NUM_ENDPOINTS";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_ptype_unknown_unicast_get(int unit, uint32 *vp)
{
    char *s = "PTYPE_UNKNOWN_UNICAST";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_ptype_known_unicast_get(int unit, uint32 *vp)
{
    char *s = "PTYPE_KNOWN_UNICAST";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_ptype_multicast_get(int unit, uint32 *vp)
{
    char *s = "PTYPE_MULTICAST";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_ptype_broadcast_get(int unit, uint32 *vp)
{
    char *s = "PTYPE_BROADCAST";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_ptype_last_get(int unit, uint32 *vp)
{
    char *s = "PTYPE_LAST";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_cuckoo_type_pvv_get(int unit, uint32 *vp)
{
    char *s = "CUCKOO_TYPE_PVV";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_cuckoo_type_isid_get(int unit, uint32 *vp)
{
    char *s = "CUCKOO_TYPE_ISID";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_cuckoo_type_pvd_get(int unit, uint32 *vp)
{
    char *s = "CUCKOO_TYPE_PVD";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_cuckoo_type_maidmep_get(int unit, uint32 *vp)
{
    char *s = "CUCKOO_TYPE_MAIDMEP";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_cuckoo_type_shift_get(int unit, uint32 *vp)
{
    char *s = "CUCKOO_TYPE_SHIFT";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_max_qos_profile_index_get(int unit, uint32 *vp)
{
    char *s = "MAX_QOS_PROFILE_INDEX";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_max_qos_map_table_get(int unit, uint32 *vp)
{
    char *s = "MAX_QOS_MAP_TABLE";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_max_qos_remark_table_get(int unit, uint32 *vp)
{
    char *s = "MAX_QOS_REMARK_TABLE";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_max_l2cp_types_get(int unit, uint32 *vp)
{
    char *s = "MAX_L2CP_TYPES";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_max_l2cp_subtypes_get(int unit, uint32 *vp)
{
    char *s = "MAX_L2CP_SUBTYPES";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_urpf_default_pid_get(int unit, uint32 *vp)
{
    char *s = "URPF_DEFAULT_PID";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_stpstate_forward_get(int unit, uint32 *vp)
{
    char *s = "STPSTATE_FORWARD";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_stpstate_block_get(int unit, uint32 *vp)
{
    char *s = "STPSTATE_BLOCK";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_stpstate_learn_get(int unit, uint32 *vp)
{
    char *s = "STPSTATE_LEARN";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_mplstp_loopback_oam_get(int unit, uint32 *vp)
{
    char *s = "MPLSTP_LOOPBACK_OAM";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_mplstp_loopback_full_get(int unit, uint32 *vp)
{
    char *s = "MPLSTP_LOOPBACK_FULL";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_mplstp_loopback_none_get(int unit, uint32 *vp)
{
    char *s = "MPLSTP_LOOPBACK_NONE";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_label_lsr_get(int unit, uint32 *vp)
{
    char *s = "LABEL_LSR";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_label_eth_pwe3_get(int unit, uint32 *vp)
{
    char *s = "LABEL_ETH_PWE3";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_label_ler_get(int unit, uint32 *vp)
{
    char *s = "LABEL_LER";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}


int soc_sbx_g3p1_label_ces_pwe3_get(int unit, uint32 *vp)
{
    char *s = "LABEL_CES_PWE3";
    soc_sbx_g3p1_errsym = s;
    return soc_sbx_g3p1_constant_get(unit, s, vp);
}





int soc_sbx_g3p1_contexts_set(int unit, uint32 v)
{
    int s;
    char *sym = "CONTEXTS";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_CONTEXTS_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_CONTEXTS_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_contexts_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_CONTEXTS_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_tpid0_set(int unit, uint32 v)
{
    int s;
    char *sym = "TPID0";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_TPID0_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_TPID0_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_tpid0_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_TPID0_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_tpid1_set(int unit, uint32 v)
{
    int s;
    char *sym = "TPID1";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_TPID1_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_TPID1_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_tpid1_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_TPID1_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_tpid2_set(int unit, uint32 v)
{
    int s;
    char *sym = "TPID2";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_TPID2_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_TPID2_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_tpid2_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_TPID2_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_defitag_set(int unit, uint32 v)
{
    int s;
    char *sym = "DEFITAG";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_DEFITAG_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_DEFITAG_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_defitag_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_DEFITAG_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_age_set(int unit, uint32 v)
{
    int s;
    char *sym = "AGE";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_AGE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_AGE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_age_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_AGE_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_cuckoo_abseed_set(int unit, uint32 v)
{
    int s;
    char *sym = "CUCKOO_ABSEED";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_CUCKOO_ABSEED_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_CUCKOO_ABSEED_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_cuckoo_abseed_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_CUCKOO_ABSEED_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_labelcuckoo_abseed_set(int unit, uint32 v)
{
    int s;
    char *sym = "LABELCUCKOO_ABSEED";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_LABELCUCKOO_ABSEED_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_LABELCUCKOO_ABSEED_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_labelcuckoo_abseed_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_LABELCUCKOO_ABSEED_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_node_set(int unit, uint32 v)
{
    int s;
    char *sym = "NODE";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_NODE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_NODE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_node_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_NODE_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_vlan_ft_base_set(int unit, uint32 v)
{
    int s;
    char *sym = "VLAN_FT_BASE";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_VLAN_FT_BASE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_VLAN_FT_BASE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_vlan_ft_base_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_VLAN_FT_BASE_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_vpws_vlan_set(int unit, uint32 v)
{
    int s;
    char *sym = "VPWS_VLAN";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_VPWS_VLAN_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_VPWS_VLAN_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_vpws_vlan_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_VPWS_VLAN_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_vpws_ft_offset_set(int unit, uint32 v)
{
    int s;
    char *sym = "VPWS_FT_OFFSET";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_VPWS_FT_OFFSET_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_VPWS_FT_OFFSET_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_vpws_ft_offset_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_VPWS_FT_OFFSET_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_max_pids_set(int unit, uint32 v)
{
    int s;
    char *sym = "MAX_PIDS";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_MAX_PIDS_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_MAX_PIDS_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_max_pids_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_MAX_PIDS_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_mc_ft_offset_set(int unit, uint32 v)
{
    int s;
    char *sym = "MC_FT_OFFSET";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_MC_FT_OFFSET_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_MC_FT_OFFSET_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_mc_ft_offset_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_MC_FT_OFFSET_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_oam_drop_bit_set(int unit, uint32 v)
{
    int s;
    char *sym = "OAM_DROP_BIT";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_OAM_DROP_BIT_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_OAM_DROP_BIT_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_oam_drop_bit_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_OAM_DROP_BIT_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_oam_enet_continue_byte_set(int unit, uint32 v)
{
    int s;
    char *sym = "OAM_ENET_CONTINUE_BYTE";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_OAM_ENET_CONTINUE_BYTE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_OAM_ENET_CONTINUE_BYTE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_oam_enet_continue_byte_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_OAM_ENET_CONTINUE_BYTE_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_oam_mpls_continue_byte_set(int unit, uint32 v)
{
    int s;
    char *sym = "OAM_MPLS_CONTINUE_BYTE";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_OAM_MPLS_CONTINUE_BYTE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_OAM_MPLS_CONTINUE_BYTE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_oam_mpls_continue_byte_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_OAM_MPLS_CONTINUE_BYTE_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_oam_enet_frame_len_set(int unit, uint32 v)
{
    int s;
    char *sym = "OAM_ENET_FRAME_LEN";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_OAM_ENET_FRAME_LEN_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_OAM_ENET_FRAME_LEN_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_oam_enet_frame_len_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_OAM_ENET_FRAME_LEN_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_oam_mpls_frame_len_set(int unit, uint32 v)
{
    int s;
    char *sym = "OAM_MPLS_FRAME_LEN";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_OAM_MPLS_FRAME_LEN_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_OAM_MPLS_FRAME_LEN_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_oam_mpls_frame_len_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_OAM_MPLS_FRAME_LEN_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_oam_source_queue_set(int unit, uint32 v)
{
    int s;
    char *sym = "OAM_SOURCE_QUEUE";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_OAM_SOURCE_QUEUE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_OAM_SOURCE_QUEUE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_oam_source_queue_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_OAM_SOURCE_QUEUE_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_oam_dest_queue_set(int unit, uint32 v)
{
    int s;
    char *sym = "OAM_DEST_QUEUE";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_OAM_DEST_QUEUE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_OAM_DEST_QUEUE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_oam_dest_queue_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_OAM_DEST_QUEUE_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_oam_source_buffer_set(int unit, uint32 v)
{
    int s;
    char *sym = "OAM_SOURCE_BUFFER";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_OAM_SOURCE_BUFFER_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_OAM_SOURCE_BUFFER_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_oam_source_buffer_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_OAM_SOURCE_BUFFER_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_oam_bubble_timer_offset_set(int unit, uint32 v)
{
    int s;
    char *sym = "OAM_BUBBLE_TIMER_OFFSET";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_OAM_BUBBLE_TIMER_OFFSET_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_OAM_BUBBLE_TIMER_OFFSET_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_oam_bubble_timer_offset_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_OAM_BUBBLE_TIMER_OFFSET_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_oam_sa_lm_set(int unit, uint32 v)
{
    int s;
    char *sym = "OAM_SA_LM";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_OAM_SA_LM_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_OAM_SA_LM_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_oam_sa_lm_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_OAM_SA_LM_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_oam_sa_dm_set(int unit, uint32 v)
{
    int s;
    char *sym = "OAM_SA_DM";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_OAM_SA_DM_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_OAM_SA_DM_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_oam_sa_dm_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_OAM_SA_DM_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_oam_mpls_sa_lm_set(int unit, uint32 v)
{
    int s;
    char *sym = "OAM_MPLS_SA_LM";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_OAM_MPLS_SA_LM_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_OAM_MPLS_SA_LM_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_oam_mpls_sa_lm_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_OAM_MPLS_SA_LM_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_oam_mpls_sa_dm_set(int unit, uint32 v)
{
    int s;
    char *sym = "OAM_MPLS_SA_DM";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_OAM_MPLS_SA_DM_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_OAM_MPLS_SA_DM_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_oam_mpls_sa_dm_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_OAM_MPLS_SA_DM_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_oam_pwe_ip_sa_set(int unit, uint32 v)
{
    int s;
    char *sym = "OAM_PWE_IP_SA";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_OAM_PWE_IP_SA_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_OAM_PWE_IP_SA_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_oam_pwe_ip_sa_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_OAM_PWE_IP_SA_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_oam_pwe_udp_dest_port_set(int unit, uint32 v)
{
    int s;
    char *sym = "OAM_PWE_UDP_DEST_PORT";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_OAM_PWE_UDP_DEST_PORT_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_OAM_PWE_UDP_DEST_PORT_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_oam_pwe_udp_dest_port_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_OAM_PWE_UDP_DEST_PORT_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_oam_loopback_qid_set(int unit, uint32 v)
{
    int s;
    char *sym = "OAM_LOOPBACK_QID";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_OAM_LOOPBACK_QID_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_OAM_LOOPBACK_QID_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_oam_loopback_qid_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_OAM_LOOPBACK_QID_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_oam_sa_4lo_set(int unit, uint32 v)
{
    int s;
    char *sym = "OAM_SA_4LO";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_OAM_SA_4LO_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_OAM_SA_4LO_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_oam_sa_4lo_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_OAM_SA_4LO_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_oam_sa_2hi_set(int unit, uint32 v)
{
    int s;
    char *sym = "OAM_SA_2HI";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_OAM_SA_2HI_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_OAM_SA_2HI_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_oam_sa_2hi_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_OAM_SA_2HI_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_oam_sa_4lo_aux_set(int unit, uint32 v)
{
    int s;
    char *sym = "OAM_SA_4LO_AUX";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_OAM_SA_4LO_AUX_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_OAM_SA_4LO_AUX_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_oam_sa_4lo_aux_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_OAM_SA_4LO_AUX_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_oam_sa_2hi_aux_set(int unit, uint32 v)
{
    int s;
    char *sym = "OAM_SA_2HI_AUX";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_OAM_SA_2HI_AUX_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_OAM_SA_2HI_AUX_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_oam_sa_2hi_aux_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_OAM_SA_2HI_AUX_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_oam_bfd_state_table_set(int unit, uint32 v)
{
    int s;
    char *sym = "OAM_BFD_STATE_TABLE";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_OAM_BFD_STATE_TABLE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_OAM_BFD_STATE_TABLE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_oam_bfd_state_table_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_OAM_BFD_STATE_TABLE_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_oam_bfd_rdi_diag_code_set(int unit, uint32 v)
{
    int s;
    char *sym = "OAM_BFD_RDI_DIAG_CODE";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_OAM_BFD_RDI_DIAG_CODE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_OAM_BFD_RDI_DIAG_CODE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_oam_bfd_rdi_diag_code_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_OAM_BFD_RDI_DIAG_CODE_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_oam_tx_packets_per_bubble_set(int unit, uint32 v)
{
    int s;
    char *sym = "OAM_TX_PACKETS_PER_BUBBLE";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_OAM_TX_PACKETS_PER_BUBBLE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_OAM_TX_PACKETS_PER_BUBBLE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_oam_tx_packets_per_bubble_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_OAM_TX_PACKETS_PER_BUBBLE_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_oam_tx_packets_per_bubble_ca_set(int unit, uint32 v)
{
    int s;
    char *sym = "OAM_TX_PACKETS_PER_BUBBLE_CA";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_OAM_TX_PACKETS_PER_BUBBLE_CA_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_OAM_TX_PACKETS_PER_BUBBLE_CA_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_oam_tx_packets_per_bubble_ca_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_OAM_TX_PACKETS_PER_BUBBLE_CA_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_oam_psc_rx_filter_set(int unit, uint32 v)
{
    int s;
    char *sym = "OAM_PSC_RX_FILTER";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_OAM_PSC_RX_FILTER_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_OAM_PSC_RX_FILTER_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_oam_psc_rx_filter_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_OAM_PSC_RX_FILTER_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_oam_local_fe_qid_set(int unit, uint32 v)
{
    int s;
    char *sym = "OAM_LOCAL_FE_QID";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_OAM_LOCAL_FE_QID_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_OAM_LOCAL_FE_QID_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_oam_local_fe_qid_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_OAM_LOCAL_FE_QID_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_oam_ete_base_set(int unit, uint32 v)
{
    int s;
    char *sym = "OAM_ETE_BASE";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_OAM_ETE_BASE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_OAM_ETE_BASE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_oam_ete_base_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_OAM_ETE_BASE_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_oam_rsvd_oip_set(int unit, uint32 v)
{
    int s;
    char *sym = "OAM_RSVD_OIP";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_OAM_RSVD_OIP_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_OAM_RSVD_OIP_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_oam_rsvd_oip_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_OAM_RSVD_OIP_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_blackhole_vlan_set(int unit, uint32 v)
{
    int s;
    char *sym = "BLACKHOLE_VLAN";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_BLACKHOLE_VLAN_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_BLACKHOLE_VLAN_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_blackhole_vlan_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_BLACKHOLE_VLAN_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_igmp_proxy_mode_set(int unit, uint32 v)
{
    int s;
    char *sym = "IGMP_PROXY_MODE";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_IGMP_PROXY_MODE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_IGMP_PROXY_MODE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_igmp_proxy_mode_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_IGMP_PROXY_MODE_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_static_lag_set(int unit, uint32 v)
{
    int s;
    char *sym = "STATIC_LAG";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_STATIC_LAG_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_STATIC_LAG_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_static_lag_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_STATIC_LAG_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_ipv4_checksum_mode_set(int unit, uint32 v)
{
    int s;
    char *sym = "IPV4_CHECKSUM_MODE";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_IPV4_CHECKSUM_MODE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_IPV4_CHECKSUM_MODE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_ipv4_checksum_mode_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_IPV4_CHECKSUM_MODE_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_exit_filter_on_btag_set(int unit, uint32 v)
{
    int s;
    char *sym = "EXIT_FILTER_ON_BTAG";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_EXIT_FILTER_ON_BTAG_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_EXIT_FILTER_ON_BTAG_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_exit_filter_on_btag_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_EXIT_FILTER_ON_BTAG_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_switch_meter_adjust_set(int unit, uint32 v)
{
    int s;
    char *sym = "SWITCH_METER_ADJUST";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_SWITCH_METER_ADJUST_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_SWITCH_METER_ADJUST_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_switch_meter_adjust_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_SWITCH_METER_ADJUST_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_rc1_rule_startidx_set(int unit, uint32 v)
{
    int s;
    char *sym = "RC1_RULE_STARTIDX";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_RC1_RULE_STARTIDX_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_RC1_RULE_STARTIDX_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_rc1_rule_startidx_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_RC1_RULE_STARTIDX_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_ipv6_acl_enable_set(int unit, uint32 v)
{
    int s;
    char *sym = "IPV6_ACL_ENABLE";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_IPV6_ACL_ENABLE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_IPV6_ACL_ENABLE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_ipv6_acl_enable_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_IPV6_ACL_ENABLE_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_oi2eoff_set(int unit, uint32 v)
{
    int s;
    char *sym = "OI2EOFF";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_OI2EOFF_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_OI2EOFF_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_oi2eoff_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_OI2EOFF_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_ete_segment_num_set(int unit, uint32 v)
{
    int s;
    char *sym = "ETE_SEGMENT_NUM";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_ETE_SEGMENT_NUM_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_ETE_SEGMENT_NUM_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_ete_segment_num_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_ETE_SEGMENT_NUM_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_oam_ep_segment_num_set(int unit, uint32 v)
{
    int s;
    char *sym = "OAM_EP_SEGMENT_NUM";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_OAM_EP_SEGMENT_NUM_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_OAM_EP_SEGMENT_NUM_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_oam_ep_segment_num_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_OAM_EP_SEGMENT_NUM_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_oam_local_segment_num_set(int unit, uint32 v)
{
    int s;
    char *sym = "OAM_LOCAL_SEGMENT_NUM";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_OAM_LOCAL_SEGMENT_NUM_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_OAM_LOCAL_SEGMENT_NUM_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_oam_local_segment_num_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_OAM_LOCAL_SEGMENT_NUM_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_oam_peer_segment_num_set(int unit, uint32 v)
{
    int s;
    char *sym = "OAM_PEER_SEGMENT_NUM";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_OAM_PEER_SEGMENT_NUM_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_OAM_PEER_SEGMENT_NUM_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_oam_peer_segment_num_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_OAM_PEER_SEGMENT_NUM_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_sample_dm1_segment_num_set(int unit, uint32 v)
{
    int s;
    char *sym = "SAMPLE_DM1_SEGMENT_NUM";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_SAMPLE_DM1_SEGMENT_NUM_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_SAMPLE_DM1_SEGMENT_NUM_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_sample_dm1_segment_num_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_SAMPLE_DM1_SEGMENT_NUM_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_arad_fwdaction_set(int unit, uint32 v)
{
    int s;
    char *sym = "ARAD_FWDACTION";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_ARAD_FWDACTION_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_ARAD_FWDACTION_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_arad_fwdaction_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_ARAD_FWDACTION_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_interlaken_offset_set(int unit, uint32 v)
{
    int s;
    char *sym = "INTERLAKEN_OFFSET";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_INTERLAKEN_OFFSET_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_INTERLAKEN_OFFSET_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_interlaken_offset_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_INTERLAKEN_OFFSET_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_higig_loop_enable_set(int unit, uint32 v)
{
    int s;
    char *sym = "HIGIG_LOOP_ENABLE";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_HIGIG_LOOP_ENABLE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_HIGIG_LOOP_ENABLE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_higig_loop_enable_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_HIGIG_LOOP_ENABLE_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_maclearn_filter_enable_set(int unit, uint32 v)
{
    int s;
    char *sym = "MACLEARN_FILTER_ENABLE";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_MACLEARN_FILTER_ENABLE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_MACLEARN_FILTER_ENABLE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_maclearn_filter_enable_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_MACLEARN_FILTER_ENABLE_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_debug_stream_elen_set(int unit, uint32 v)
{
    int s;
    char *sym = "DEBUG_STREAM_ELEN";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_DEBUG_STREAM_ELEN_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_DEBUG_STREAM_ELEN_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_debug_stream_elen_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_DEBUG_STREAM_ELEN_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_c3_sws_static_page_set(int unit, uint32 v)
{
    int s;
    char *sym = "C3_SWS_STATIC_PAGE";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_C3_SWS_STATIC_PAGE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_C3_SWS_STATIC_PAGE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_c3_sws_static_page_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_C3_SWS_STATIC_PAGE_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_c3_sws_ingress_bubble_squeue_set(int unit, uint32 v)
{
    int s;
    char *sym = "C3_SWS_INGRESS_BUBBLE_SQUEUE";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_C3_SWS_INGRESS_BUBBLE_SQUEUE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_C3_SWS_INGRESS_BUBBLE_SQUEUE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_c3_sws_ingress_bubble_squeue_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_C3_SWS_INGRESS_BUBBLE_SQUEUE_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_c3_sws_fab_to_line_redirect_qid0_set(int unit, uint32 v)
{
    int s;
    char *sym = "C3_SWS_FAB_TO_LINE_REDIRECT_QID0";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_C3_SWS_FAB_TO_LINE_REDIRECT_QID0_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_C3_SWS_FAB_TO_LINE_REDIRECT_QID0_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_c3_sws_fab_to_line_redirect_qid0_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_C3_SWS_FAB_TO_LINE_REDIRECT_QID0_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_c3_sws_fab_to_line_redirect_qid1_set(int unit, uint32 v)
{
    int s;
    char *sym = "C3_SWS_FAB_TO_LINE_REDIRECT_QID1";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_C3_SWS_FAB_TO_LINE_REDIRECT_QID1_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_C3_SWS_FAB_TO_LINE_REDIRECT_QID1_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_c3_sws_fab_to_line_redirect_qid1_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_C3_SWS_FAB_TO_LINE_REDIRECT_QID1_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_c3_sws_egress_bubble_squeue_set(int unit, uint32 v)
{
    int s;
    char *sym = "C3_SWS_EGRESS_BUBBLE_SQUEUE";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_C3_SWS_EGRESS_BUBBLE_SQUEUE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_C3_SWS_EGRESS_BUBBLE_SQUEUE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_c3_sws_egress_bubble_squeue_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_C3_SWS_EGRESS_BUBBLE_SQUEUE_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_c3_sws_line_to_fab_redirect_qid0_set(int unit, uint32 v)
{
    int s;
    char *sym = "C3_SWS_LINE_TO_FAB_REDIRECT_QID0";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_C3_SWS_LINE_TO_FAB_REDIRECT_QID0_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_C3_SWS_LINE_TO_FAB_REDIRECT_QID0_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_c3_sws_line_to_fab_redirect_qid0_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_C3_SWS_LINE_TO_FAB_REDIRECT_QID0_ID].value;

    return SOC_E_NONE;
}



int soc_sbx_g3p1_c3_sws_line_to_fab_redirect_qid1_set(int unit, uint32 v)
{
    int s;
    char *sym = "C3_SWS_LINE_TO_FAB_REDIRECT_QID1";
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G3P1_C3_SWS_LINE_TO_FAB_REDIRECT_QID1_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g3p1_errsym = sym;
    s = soc_sbx_g3p1_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G3P1_C3_SWS_LINE_TO_FAB_REDIRECT_QID1_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_c3_sws_line_to_fab_redirect_qid1_get(int unit, uint32 *vp)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G3P1_C3_SWS_LINE_TO_FAB_REDIRECT_QID1_ID].value;

    return SOC_E_NONE;
}






static int soc_sbx_g3p1_tables_init(int unit, soc_sbx_g3p1_table_manager_t *tm) {  

	int i, s, j, m, p;
	char *e = "";
	int port_init[SOC_SBX_G3P1_MEMORY_MAX_ID] = {6,13,7,14,12,11,10,2,3,4,5,8,9,0,1};
	
	/*
     * Per-table state initialization
     */
    tm->tables = UTG_MALLOC(sizeof(soc_sbx_g3p1_table_desc_t)
                         * SOC_SBX_G3P1_TABLE_MAX_ID);
    if (!tm->tables) {
        soc_sbx_g3p1_uninit(unit);
        return SOC_E_MEMORY;
    }
    sal_memset(tm->tables, 0, sizeof(soc_sbx_g3p1_table_desc_t)
           * SOC_SBX_G3P1_TABLE_MAX_ID);
           
    tm->tables[SOC_SBX_G3P1_QOS_TABLE_ID].name =
            "qos";        
    tm->tables[SOC_SBX_G3P1_DSCPQOS_TABLE_ID].name =
            "dscpqos";        
    tm->tables[SOC_SBX_G3P1_IRT_TABLE_ID].name =
            "irt";        
    tm->tables[SOC_SBX_G3P1_LAG_TABLE_ID].name =
            "lag";        
    tm->tables[SOC_SBX_G3P1_RRT_TABLE_ID].name =
            "rrt";        
    tm->tables[SOC_SBX_G3P1_XT_TABLE_ID].name =
            "xt";        
    tm->tables[SOC_SBX_G3P1_MIRROR_TABLE_ID].name =
            "mirror";        
    tm->tables[SOC_SBX_G3P1_EMIRROR_TABLE_ID].name =
            "emirror";        
    tm->tables[SOC_SBX_G3P1_MACAGE_TABLE_ID].name =
            "macage";        
    tm->tables[SOC_SBX_G3P1_MST_TABLE_ID].name =
            "mst";        
    tm->tables[SOC_SBX_G3P1_PV2E_TABLE_ID].name =
            "pv2e";        
    tm->tables[SOC_SBX_G3P1_P2APPDATA_TABLE_ID].name =
            "p2appdata";        
    tm->tables[SOC_SBX_G3P1_PV2APPDATA_TABLE_ID].name =
            "pv2appdata";        
    tm->tables[SOC_SBX_G3P1_PVV2EDATA_TABLE_ID].name =
            "pvv2edata";        
    tm->tables[SOC_SBX_G3P1_V2E_TABLE_ID].name =
            "v2e";        
    tm->tables[SOC_SBX_G3P1_VRID2E_TABLE_ID].name =
            "vrid2e";        
    tm->tables[SOC_SBX_G3P1_LP_TABLE_ID].name =
            "lp";        
    tm->tables[SOC_SBX_G3P1_L2CP_TABLE_ID].name =
            "l2cp";        
    tm->tables[SOC_SBX_G3P1_L2CPSLOW_TABLE_ID].name =
            "l2cpslow";        
    tm->tables[SOC_SBX_G3P1_L2CPNOP_TABLE_ID].name =
            "l2cpnop";        
    tm->tables[SOC_SBX_G3P1_FT_TABLE_ID].name =
            "ft";        
    tm->tables[SOC_SBX_G3P1_EVP2E_TABLE_ID].name =
            "evp2e";        
    tm->tables[SOC_SBX_G3P1_OI2E_TABLE_ID].name =
            "oi2e";        
    tm->tables[SOC_SBX_G3P1_REMARK_TABLE_ID].name =
            "remark";        
    tm->tables[SOC_SBX_G3P1_EPV2E_TABLE_ID].name =
            "epv2e";        
    tm->tables[SOC_SBX_G3P1_ERT_TABLE_ID].name =
            "ert";        
    tm->tables[SOC_SBX_G3P1_OAM_BUBBLE_TABLE_ID].name =
            "oam_bubble";        
    tm->tables[SOC_SBX_G3P1_OAMRX_P2E_TABLE_ID].name =
            "oamrx_p2e";        
    tm->tables[SOC_SBX_G3P1_OAM_PEER_STATE_TABLE_ID].name =
            "oam_peer_state";        
    tm->tables[SOC_SBX_G3P1_PTP_COMPENSATION_TABLE_ID].name =
            "ptp_compensation";        
    tm->tables[SOC_SBX_G3P1_BFD_LD2EDATA_TABLE_ID].name =
            "bfd_ld2edata";        
    tm->tables[SOC_SBX_G3P1_BFD_LD2EDATAC_TABLE_ID].name =
            "bfd_ld2edatac";        
    tm->tables[SOC_SBX_G3P1_SAMPLE6_TABLE_ID].name =
            "sample6";        
    tm->tables[SOC_SBX_G3P1_SAMPLE8_TABLE_ID].name =
            "sample8";        
    tm->tables[SOC_SBX_G3P1_SAMPLE9_TABLE_ID].name =
            "sample9";        
    
    for (i = 0; i < SOC_SBX_G3P1_TABLE_MAX_ID; i++) {
        if (!tm->tables[i].name) {
            /* Caladan3 complex tables not supported yet, skipping */
            continue;
        }
        s = soc_sbx_g3p1_ucode_get(unit,
                  soc_sbx_g3p1_sym,
                  128,
                  &tm->tables[i].nbanks,
                  e,
                  tm->tables[i].name,
                  -1,
                  e,
                  "TABLE_BANKS");
        if (s) {
            soc_sbx_g3p1_uninit(unit);
            return s;
        }
        s = soc_sbx_g3p1_ucode_get(unit,
                  soc_sbx_g3p1_sym,
                  128,
                  &j,
                  e,
                  tm->tables[i].name,
                  -1,
                  e,
                  "TABLE_ALIGN");
        if (s) {
            soc_sbx_g3p1_uninit(unit);
            return s;
        }
        tm->tables[i].nextaligned = j ? -2 : 0;
        s = soc_sbx_g3p1_ucode_get(unit,
                  soc_sbx_g3p1_sym,
                  128,
                  &tm->tables[i].type,
                  e,
                  tm->tables[i].name,
                  -1,
                  e,
                  "TABLE_TYPE");
        if (s) {
            soc_sbx_g3p1_uninit(unit);
            return s;
        }
        for (j = 0; j < tm->tables[i].nbanks; j++) {

            int nb = tm->tables[i].nbanks;

            s = soc_sbx_g3p1_ucode_get(unit,
                      soc_sbx_g3p1_sym,
                      128,
                      &tm->tables[i].banks[j].memory,
                      e,
                      tm->tables[i].name,
                      nb == 1 ? -1 : j,
                      e,
                      "MEMORY");
            if (s) {
                soc_sbx_g3p1_uninit(unit);
                return s;
            }
            s = soc_sbx_g3p1_ucode_get(unit,
                      soc_sbx_g3p1_sym,
                      128,
                      &tm->tables[i].banks[j].base,
                      e,
                      tm->tables[i].name,
                      nb == 1 ? -1 : j,
                      e,
                      "BASE");
            if (s) {
                soc_sbx_g3p1_uninit(unit);
                return s;
            }
            s = soc_sbx_g3p1_ucode_get(unit,
                      soc_sbx_g3p1_sym,
                      128,
                      &tm->tables[i].banks[j].size,
                      e,
                      tm->tables[i].name,
                      nb == 1 ? -1 : j,
                      e,
                      "SIZE");
            if (s) {
                soc_sbx_g3p1_uninit(unit);
                return s;
            }
            s = soc_sbx_g3p1_ucode_get(unit,
                      soc_sbx_g3p1_sym,
                      128,
                      &tm->tables[i].banks[j].width,
                      e,
                      tm->tables[i].name,
                      nb == 1 ? -1 : j,
                      e,
                      "TABLE_WIDTH");
            if (s) {
                soc_sbx_g3p1_uninit(unit);
                return s;
            }
            s = soc_sbx_g3p1_ucode_get(unit,
                      soc_sbx_g3p1_sym,
                      128,
                      &tm->tables[i].banks[j].segment,
                      e,
                      tm->tables[i].name,
                      nb == 1 ? -1 : j,
                      e,
                      "SEGMENT");
            if (s) {
                soc_sbx_g3p1_uninit(unit);
                return s;
            }
            s = soc_sbx_g3p1_ucode_get(unit,
                      soc_sbx_g3p1_sym,
                      128,
                      &tm->tables[i].banks[j].segflags,
                      e,
                      tm->tables[i].name,
                      nb == 1 ? -1 : j,
                      e,
                      "SEGMENT_FLAGS");
            if (s) {
                soc_sbx_g3p1_uninit(unit);
                return s;
            }
            s = soc_sbx_g3p1_ucode_get(unit,
                      soc_sbx_g3p1_sym,
                      128,
                      &tm->tables[i].banks[j].limit,
                      e,
                      tm->tables[i].name,
                      nb == 1 ? -1 : j,
                      e,
                      "LIMIT");
            if (s) {
                soc_sbx_g3p1_uninit(unit);
                return s;
            }
        }
    }
    for (p = 0;p < SOC_SBX_G3P1_MEMORY_MAX_ID;p++) {
        m = port_init[p];
            
        for (i = 0; i < SOC_SBX_G3P1_TABLE_MAX_ID; i++) {
            if (!tm->tables[i].name) {
               /* Caladan3 complex tables not supported yet, skipping */
               continue;
            }
            for (j = 0; j < tm->tables[i].nbanks; j++) {
                sbx_caladan3_ocm_port_alloc_t segalloc = {0};
                if (tm->tables[i].banks[j].memory != m) {
                    /* Skipping reverse allocation scheme */
                    continue;
                }
                if (tm->tables[i].banks[j].segflags & 1 || tm->tables[i].banks[j].segflags & 8) {
                    /* Skipping Overlap or overlayed segments */
                    continue;
                }

                 /* Table Id ZERO is reserved per OCM API. Start our IDs "+1" */
                 segalloc.table_id = i + 1;
                 segalloc.bank_id = j + 1;

                segalloc.segment = tm->tables[i].banks[j].segment;
                segalloc.port = tm->tables[i].banks[j].memory;
                /*segalloc.size = tm->tables[i].banks[j].size;*/
                segalloc.size = tm->tables[i].banks[j].limit - tm->tables[i].banks[j].base;
                segalloc.datum_size = tm->tables[i].banks[j].width;
                LOG_INFO(BSL_LS_SOC_MEM,
                         (BSL_META_U(unit,
                                     "\nAttempting to allocate for table %s"), tm->tables[i].name));
                LOG_INFO(BSL_LS_SOC_MEM,
                         (BSL_META_U(unit,
                                     "\n    Port %d Segment %d Flags:0x%08x"), segalloc.port, segalloc.segment, tm->tables[i].banks[j].segflags));
                LOG_INFO(BSL_LS_SOC_MEM,
                         (BSL_META_U(unit,
                                     "\n    Base: %x Limit %x Size %d Width %d"),
                          tm->tables[i].banks[j].base, tm->tables[i].banks[j].limit,
                          segalloc.size, segalloc.datum_size));

                if (segalloc.segment >= 0) {            
	                if (!(tm->tables[i].banks[j].segflags & 2)) {
                        s = soc_sbx_caladan3_ocm_port_segment_alloc(unit, &segalloc);
              	 	 } else if ((tm->tables[i].banks[j].segflags & 2) && (tm->tables[i].banks[j].segflags & 4)) {
                        segalloc.size = (tm->tables[i].banks[j].limit - tm->tables[i].banks[j].base) * tm->tables[i].nbanks;
                        /*  LOG_CLI((BSL_META_U(unit,
                                                "%s: Allocating interleaved table size:%d\n"), __func__, segalloc.size)); */
                        s = soc_sbx_caladan3_ocm_port_segment_alloc(unit, &segalloc);
              	 	 } else {
                    	s = SOC_E_NONE;
              	  }                                  
                } else {
                    s = soc_sbx_caladan3_ocm_port_mem_alloc(unit, &segalloc);
                }

                if (SOC_FAILURE(s)) {
                    soc_sbx_g3p1_uninit(unit);
                    return s;
                }
            }
        }
    }

	return SOC_E_NONE;
}

static int soc_sbx_g3p1_entries_init(int unit, soc_sbx_g3p1_table_manager_t *tm) {  

	int i, s, j;
	char *e = "";
	
	/*
     * Per-entry state initialization
     */
    tm->entries = UTG_MALLOC(sizeof(soc_sbx_g3p1_entry_desc_t)
                         * SOC_SBX_G3P1_ENTRY_MAX_ID);
    if (!tm->entries) {
        return SOC_E_MEMORY;
    }
    

    tm->entries[SOC_SBX_G3P1_QOS_ID].name =
            "qos";
    tm->entries[SOC_SBX_G3P1_QOS_ID].table =
        SOC_SBX_G3P1_QOS_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_QOS_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_qos_pack;
    tm->entries[SOC_SBX_G3P1_QOS_ID].esize =
        sizeof(soc_sbx_g3p1_qos_t);
    tm->entries[SOC_SBX_G3P1_QOS_ID].nindexes = 3;
    tm->entries[SOC_SBX_G3P1_QOS_ID].nfields = 5;


    tm->entries[SOC_SBX_G3P1_DSCPQOS_ID].name =
            "dscpqos";
    tm->entries[SOC_SBX_G3P1_DSCPQOS_ID].table =
        SOC_SBX_G3P1_DSCPQOS_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_DSCPQOS_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_dscpqos_pack;
    tm->entries[SOC_SBX_G3P1_DSCPQOS_ID].esize =
        sizeof(soc_sbx_g3p1_dscpqos_t);
    tm->entries[SOC_SBX_G3P1_DSCPQOS_ID].nindexes = 2;
    tm->entries[SOC_SBX_G3P1_DSCPQOS_ID].nfields = 5;


    tm->entries[SOC_SBX_G3P1_IRT_ID].name =
            "irt";
    tm->entries[SOC_SBX_G3P1_IRT_ID].table =
        SOC_SBX_G3P1_IRT_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_IRT_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_irt_pack;
    tm->entries[SOC_SBX_G3P1_IRT_ID].esize =
        sizeof(soc_sbx_g3p1_irt_t);
    tm->entries[SOC_SBX_G3P1_IRT_ID].nindexes = 1;
    tm->entries[SOC_SBX_G3P1_IRT_ID].nfields = 15;


    tm->entries[SOC_SBX_G3P1_LAG_ID].name =
            "lag";
    tm->entries[SOC_SBX_G3P1_LAG_ID].table =
        SOC_SBX_G3P1_LAG_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_LAG_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_lag_pack;
    tm->entries[SOC_SBX_G3P1_LAG_ID].esize =
        sizeof(soc_sbx_g3p1_lag_t);
    tm->entries[SOC_SBX_G3P1_LAG_ID].nindexes = 1;
    tm->entries[SOC_SBX_G3P1_LAG_ID].nfields = 2;


    tm->entries[SOC_SBX_G3P1_RRT_ID].name =
            "rrt";
    tm->entries[SOC_SBX_G3P1_RRT_ID].table =
        SOC_SBX_G3P1_RRT_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_RRT_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_rrt_pack;
    tm->entries[SOC_SBX_G3P1_RRT_ID].esize =
        sizeof(soc_sbx_g3p1_rrt_t);
    tm->entries[SOC_SBX_G3P1_RRT_ID].nindexes = 1;
    tm->entries[SOC_SBX_G3P1_RRT_ID].nfields = 1;


    tm->entries[SOC_SBX_G3P1_XT_ID].name =
            "xt";
    tm->entries[SOC_SBX_G3P1_XT_ID].table =
        SOC_SBX_G3P1_XT_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_XT_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_xt_pack;
    tm->entries[SOC_SBX_G3P1_XT_ID].esize =
        sizeof(soc_sbx_g3p1_xt_t);
    tm->entries[SOC_SBX_G3P1_XT_ID].nindexes = 1;
    tm->entries[SOC_SBX_G3P1_XT_ID].nfields = 8;


    tm->entries[SOC_SBX_G3P1_MIRROR_ID].name =
            "mirror";
    tm->entries[SOC_SBX_G3P1_MIRROR_ID].table =
        SOC_SBX_G3P1_MIRROR_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_MIRROR_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_mirror_pack;
    tm->entries[SOC_SBX_G3P1_MIRROR_ID].esize =
        sizeof(soc_sbx_g3p1_mirror_t);
    tm->entries[SOC_SBX_G3P1_MIRROR_ID].nindexes = 1;
    tm->entries[SOC_SBX_G3P1_MIRROR_ID].nfields = 3;


    tm->entries[SOC_SBX_G3P1_EMIRROR_ID].name =
            "emirror";
    tm->entries[SOC_SBX_G3P1_EMIRROR_ID].table =
        SOC_SBX_G3P1_EMIRROR_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_EMIRROR_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_emirror_pack;
    tm->entries[SOC_SBX_G3P1_EMIRROR_ID].esize =
        sizeof(soc_sbx_g3p1_emirror_t);
    tm->entries[SOC_SBX_G3P1_EMIRROR_ID].nindexes = 1;
    tm->entries[SOC_SBX_G3P1_EMIRROR_ID].nfields = 5;


    tm->entries[SOC_SBX_G3P1_MACAGE_ID].name =
            "macage";
    tm->entries[SOC_SBX_G3P1_MACAGE_ID].table =
        SOC_SBX_G3P1_MACAGE_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_MACAGE_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_macage_pack;
    tm->entries[SOC_SBX_G3P1_MACAGE_ID].esize =
        sizeof(soc_sbx_g3p1_macage_t);
    tm->entries[SOC_SBX_G3P1_MACAGE_ID].nindexes = 1;
    tm->entries[SOC_SBX_G3P1_MACAGE_ID].nfields = 1;


    tm->entries[SOC_SBX_G3P1_MST_ID].name =
            "mst";
    tm->entries[SOC_SBX_G3P1_MST_ID].table =
        SOC_SBX_G3P1_MST_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_MST_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_mst_pack;
    tm->entries[SOC_SBX_G3P1_MST_ID].esize =
        sizeof(soc_sbx_g3p1_mst_t);
    tm->entries[SOC_SBX_G3P1_MST_ID].nindexes = 1;
    tm->entries[SOC_SBX_G3P1_MST_ID].nfields = 10;


    tm->entries[SOC_SBX_G3P1_PV2E_ID].name =
            "pv2e";
    tm->entries[SOC_SBX_G3P1_PV2E_ID].table =
        SOC_SBX_G3P1_PV2E_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_PV2E_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_pv2e_pack;
    tm->entries[SOC_SBX_G3P1_PV2E_ID].esize =
        sizeof(soc_sbx_g3p1_pv2e_t);
    tm->entries[SOC_SBX_G3P1_PV2E_ID].nindexes = 2;
    tm->entries[SOC_SBX_G3P1_PV2E_ID].nfields = 4;


    tm->entries[SOC_SBX_G3P1_P2APPDATA_ID].name =
            "p2appdata";
    tm->entries[SOC_SBX_G3P1_P2APPDATA_ID].table =
        SOC_SBX_G3P1_P2APPDATA_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_P2APPDATA_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_p2appdata_pack;
    tm->entries[SOC_SBX_G3P1_P2APPDATA_ID].esize =
        sizeof(soc_sbx_g3p1_p2appdata_t);
    tm->entries[SOC_SBX_G3P1_P2APPDATA_ID].nindexes = 1;
    tm->entries[SOC_SBX_G3P1_P2APPDATA_ID].nfields = 2;


    tm->entries[SOC_SBX_G3P1_PV2APPDATA_ID].name =
            "pv2appdata";
    tm->entries[SOC_SBX_G3P1_PV2APPDATA_ID].table =
        SOC_SBX_G3P1_PV2APPDATA_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_PV2APPDATA_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_pv2appdata_pack;
    tm->entries[SOC_SBX_G3P1_PV2APPDATA_ID].esize =
        sizeof(soc_sbx_g3p1_pv2appdata_t);
    tm->entries[SOC_SBX_G3P1_PV2APPDATA_ID].nindexes = 2;
    tm->entries[SOC_SBX_G3P1_PV2APPDATA_ID].nfields = 1;


    tm->entries[SOC_SBX_G3P1_PVV2EDATA_ID].name =
            "pvv2edata";
    tm->entries[SOC_SBX_G3P1_PVV2EDATA_ID].table =
        SOC_SBX_G3P1_PVV2EDATA_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_PVV2EDATA_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_pvv2edata_pack;
    tm->entries[SOC_SBX_G3P1_PVV2EDATA_ID].esize =
        sizeof(soc_sbx_g3p1_pvv2edata_t);
    tm->entries[SOC_SBX_G3P1_PVV2EDATA_ID].nindexes = 1;
    tm->entries[SOC_SBX_G3P1_PVV2EDATA_ID].nfields = 9;


    tm->entries[SOC_SBX_G3P1_V2E_ID].name =
            "v2e";
    tm->entries[SOC_SBX_G3P1_V2E_ID].table =
        SOC_SBX_G3P1_V2E_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_V2E_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_v2e_pack;
    tm->entries[SOC_SBX_G3P1_V2E_ID].esize =
        sizeof(soc_sbx_g3p1_v2e_t);
    tm->entries[SOC_SBX_G3P1_V2E_ID].nindexes = 1;
    tm->entries[SOC_SBX_G3P1_V2E_ID].nfields = 13;


    tm->entries[SOC_SBX_G3P1_VRID2E_ID].name =
            "vrid2e";
    tm->entries[SOC_SBX_G3P1_VRID2E_ID].table =
        SOC_SBX_G3P1_VRID2E_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_VRID2E_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_vrid2e_pack;
    tm->entries[SOC_SBX_G3P1_VRID2E_ID].esize =
        sizeof(soc_sbx_g3p1_vrid2e_t);
    tm->entries[SOC_SBX_G3P1_VRID2E_ID].nindexes = 1;
    tm->entries[SOC_SBX_G3P1_VRID2E_ID].nfields = 4;


    tm->entries[SOC_SBX_G3P1_LP_ID].name =
            "lp";
    tm->entries[SOC_SBX_G3P1_LP_ID].table =
        SOC_SBX_G3P1_LP_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_LP_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_lp_pack;
    tm->entries[SOC_SBX_G3P1_LP_ID].esize =
        sizeof(soc_sbx_g3p1_lp_t);
    tm->entries[SOC_SBX_G3P1_LP_ID].nindexes = 1;
    tm->entries[SOC_SBX_G3P1_LP_ID].nfields = 20;


    tm->entries[SOC_SBX_G3P1_L2CP_ID].name =
            "l2cp";
    tm->entries[SOC_SBX_G3P1_L2CP_ID].table =
        SOC_SBX_G3P1_L2CP_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_L2CP_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_l2cp_pack;
    tm->entries[SOC_SBX_G3P1_L2CP_ID].esize =
        sizeof(soc_sbx_g3p1_l2cp_t);
    tm->entries[SOC_SBX_G3P1_L2CP_ID].nindexes = 2;
    tm->entries[SOC_SBX_G3P1_L2CP_ID].nfields = 4;


    tm->entries[SOC_SBX_G3P1_L2CPSLOW_ID].name =
            "l2cpslow";
    tm->entries[SOC_SBX_G3P1_L2CPSLOW_ID].table =
        SOC_SBX_G3P1_L2CPSLOW_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_L2CPSLOW_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_l2cpslow_pack;
    tm->entries[SOC_SBX_G3P1_L2CPSLOW_ID].esize =
        sizeof(soc_sbx_g3p1_l2cpslow_t);
    tm->entries[SOC_SBX_G3P1_L2CPSLOW_ID].nindexes = 2;
    tm->entries[SOC_SBX_G3P1_L2CPSLOW_ID].nfields = 4;


    tm->entries[SOC_SBX_G3P1_L2CPNOP_ID].name =
            "l2cpnop";
    tm->entries[SOC_SBX_G3P1_L2CPNOP_ID].table =
        SOC_SBX_G3P1_L2CPNOP_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_L2CPNOP_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_l2cpnop_pack;
    tm->entries[SOC_SBX_G3P1_L2CPNOP_ID].esize =
        sizeof(soc_sbx_g3p1_l2cpnop_t);
    tm->entries[SOC_SBX_G3P1_L2CPNOP_ID].nindexes = 1;
    tm->entries[SOC_SBX_G3P1_L2CPNOP_ID].nfields = 4;


    tm->entries[SOC_SBX_G3P1_FT_ID].name =
            "ft";
    tm->entries[SOC_SBX_G3P1_FT_ID].table =
        SOC_SBX_G3P1_FT_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_FT_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_ft_pack;
    tm->entries[SOC_SBX_G3P1_FT_ID].esize =
        sizeof(soc_sbx_g3p1_ft_t);
    tm->entries[SOC_SBX_G3P1_FT_ID].nindexes = 1;
    tm->entries[SOC_SBX_G3P1_FT_ID].nfields = 16;


    tm->entries[SOC_SBX_G3P1_EVP2E_ID].name =
            "evp2e";
    tm->entries[SOC_SBX_G3P1_EVP2E_ID].table =
        SOC_SBX_G3P1_EVP2E_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_EVP2E_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_evp2e_pack;
    tm->entries[SOC_SBX_G3P1_EVP2E_ID].esize =
        sizeof(soc_sbx_g3p1_evp2e_t);
    tm->entries[SOC_SBX_G3P1_EVP2E_ID].nindexes = 2;
    tm->entries[SOC_SBX_G3P1_EVP2E_ID].nfields = 5;


    tm->entries[SOC_SBX_G3P1_OI2E_ID].name =
            "oi2e";
    tm->entries[SOC_SBX_G3P1_OI2E_ID].table =
        SOC_SBX_G3P1_OI2E_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_OI2E_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_oi2e_pack;
    tm->entries[SOC_SBX_G3P1_OI2E_ID].esize =
        sizeof(soc_sbx_g3p1_oi2e_t);
    tm->entries[SOC_SBX_G3P1_OI2E_ID].nindexes = 1;
    tm->entries[SOC_SBX_G3P1_OI2E_ID].nfields = 5;


    tm->entries[SOC_SBX_G3P1_REMARK_ID].name =
            "remark";
    tm->entries[SOC_SBX_G3P1_REMARK_ID].table =
        SOC_SBX_G3P1_REMARK_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_REMARK_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_remark_pack;
    tm->entries[SOC_SBX_G3P1_REMARK_ID].esize =
        sizeof(soc_sbx_g3p1_remark_t);
    tm->entries[SOC_SBX_G3P1_REMARK_ID].nindexes = 4;
    tm->entries[SOC_SBX_G3P1_REMARK_ID].nfields = 4;


    tm->entries[SOC_SBX_G3P1_EPV2E_ID].name =
            "epv2e";
    tm->entries[SOC_SBX_G3P1_EPV2E_ID].table =
        SOC_SBX_G3P1_EPV2E_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_EPV2E_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_epv2e_pack;
    tm->entries[SOC_SBX_G3P1_EPV2E_ID].esize =
        sizeof(soc_sbx_g3p1_epv2e_t);
    tm->entries[SOC_SBX_G3P1_EPV2E_ID].nindexes = 2;
    tm->entries[SOC_SBX_G3P1_EPV2E_ID].nfields = 2;


    tm->entries[SOC_SBX_G3P1_ERT_ID].name =
            "ert";
    tm->entries[SOC_SBX_G3P1_ERT_ID].table =
        SOC_SBX_G3P1_ERT_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_ERT_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_ert_pack;
    tm->entries[SOC_SBX_G3P1_ERT_ID].esize =
        sizeof(soc_sbx_g3p1_ert_t);
    tm->entries[SOC_SBX_G3P1_ERT_ID].nindexes = 1;
    tm->entries[SOC_SBX_G3P1_ERT_ID].nfields = 3;


    tm->entries[SOC_SBX_G3P1_OAM_BUBBLE_ID].name =
            "oam_bubble";
    tm->entries[SOC_SBX_G3P1_OAM_BUBBLE_ID].table =
        SOC_SBX_G3P1_OAM_BUBBLE_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_OAM_BUBBLE_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_oam_bubble_pack;
    tm->entries[SOC_SBX_G3P1_OAM_BUBBLE_ID].esize =
        sizeof(soc_sbx_g3p1_oam_bubble_t);
    tm->entries[SOC_SBX_G3P1_OAM_BUBBLE_ID].nindexes = 1;
    tm->entries[SOC_SBX_G3P1_OAM_BUBBLE_ID].nfields = 9;


    tm->entries[SOC_SBX_G3P1_OAMRX_P2E_ID].name =
            "oamrx_p2e";
    tm->entries[SOC_SBX_G3P1_OAMRX_P2E_ID].table =
        SOC_SBX_G3P1_OAMRX_P2E_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_OAMRX_P2E_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_oamrx_p2e_pack;
    tm->entries[SOC_SBX_G3P1_OAMRX_P2E_ID].esize =
        sizeof(soc_sbx_g3p1_oamrx_p2e_t);
    tm->entries[SOC_SBX_G3P1_OAMRX_P2E_ID].nindexes = 2;
    tm->entries[SOC_SBX_G3P1_OAMRX_P2E_ID].nfields = 34;


    tm->entries[SOC_SBX_G3P1_OAM_PEER_STATE_ID].name =
            "oam_peer_state";
    tm->entries[SOC_SBX_G3P1_OAM_PEER_STATE_ID].table =
        SOC_SBX_G3P1_OAM_PEER_STATE_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_OAM_PEER_STATE_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_oam_peer_state_pack;
    tm->entries[SOC_SBX_G3P1_OAM_PEER_STATE_ID].esize =
        sizeof(soc_sbx_g3p1_oam_peer_state_t);
    tm->entries[SOC_SBX_G3P1_OAM_PEER_STATE_ID].nindexes = 1;
    tm->entries[SOC_SBX_G3P1_OAM_PEER_STATE_ID].nfields = 2;


    tm->entries[SOC_SBX_G3P1_PTP_COMPENSATION_ID].name =
            "ptp_compensation";
    tm->entries[SOC_SBX_G3P1_PTP_COMPENSATION_ID].table =
        SOC_SBX_G3P1_PTP_COMPENSATION_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_PTP_COMPENSATION_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_ptp_compensation_pack;
    tm->entries[SOC_SBX_G3P1_PTP_COMPENSATION_ID].esize =
        sizeof(soc_sbx_g3p1_ptp_compensation_t);
    tm->entries[SOC_SBX_G3P1_PTP_COMPENSATION_ID].nindexes = 1;
    tm->entries[SOC_SBX_G3P1_PTP_COMPENSATION_ID].nfields = 1;


    tm->entries[SOC_SBX_G3P1_BFD_LD2EDATA_ID].name =
            "bfd_ld2edata";
    tm->entries[SOC_SBX_G3P1_BFD_LD2EDATA_ID].table =
        SOC_SBX_G3P1_BFD_LD2EDATA_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_BFD_LD2EDATA_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_bfd_ld2edata_pack;
    tm->entries[SOC_SBX_G3P1_BFD_LD2EDATA_ID].esize =
        sizeof(soc_sbx_g3p1_bfd_ld2edata_t);
    tm->entries[SOC_SBX_G3P1_BFD_LD2EDATA_ID].nindexes = 1;
    tm->entries[SOC_SBX_G3P1_BFD_LD2EDATA_ID].nfields = 10;


    tm->entries[SOC_SBX_G3P1_BFD_LD2EDATAC_ID].name =
            "bfd_ld2edatac";
    tm->entries[SOC_SBX_G3P1_BFD_LD2EDATAC_ID].table =
        SOC_SBX_G3P1_BFD_LD2EDATAC_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_BFD_LD2EDATAC_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_bfd_ld2edatac_pack;
    tm->entries[SOC_SBX_G3P1_BFD_LD2EDATAC_ID].esize =
        sizeof(soc_sbx_g3p1_bfd_ld2edatac_t);
    tm->entries[SOC_SBX_G3P1_BFD_LD2EDATAC_ID].nindexes = 1;
    tm->entries[SOC_SBX_G3P1_BFD_LD2EDATAC_ID].nfields = 1;


    tm->entries[SOC_SBX_G3P1_SAMPLE6_ID].name =
            "sample6";
    tm->entries[SOC_SBX_G3P1_SAMPLE6_ID].table =
        SOC_SBX_G3P1_SAMPLE6_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_SAMPLE6_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_sample6_pack;
    tm->entries[SOC_SBX_G3P1_SAMPLE6_ID].esize =
        sizeof(soc_sbx_g3p1_sample6_t);
    tm->entries[SOC_SBX_G3P1_SAMPLE6_ID].nindexes = 1;
    tm->entries[SOC_SBX_G3P1_SAMPLE6_ID].nfields = 2;


    tm->entries[SOC_SBX_G3P1_SAMPLE8_ID].name =
            "sample8";
    tm->entries[SOC_SBX_G3P1_SAMPLE8_ID].table =
        SOC_SBX_G3P1_SAMPLE8_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_SAMPLE8_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_sample8_pack;
    tm->entries[SOC_SBX_G3P1_SAMPLE8_ID].esize =
        sizeof(soc_sbx_g3p1_sample8_t);
    tm->entries[SOC_SBX_G3P1_SAMPLE8_ID].nindexes = 1;
    tm->entries[SOC_SBX_G3P1_SAMPLE8_ID].nfields = 2;


    tm->entries[SOC_SBX_G3P1_SAMPLE9_ID].name =
            "sample9";
    tm->entries[SOC_SBX_G3P1_SAMPLE9_ID].table =
        SOC_SBX_G3P1_SAMPLE9_TABLE_ID;
    tm->entries[SOC_SBX_G3P1_SAMPLE9_ID].pack =
        (soc_sbx_g3p1_complex_pack_f_t) soc_sbx_g3p1_sample9_pack;
    tm->entries[SOC_SBX_G3P1_SAMPLE9_ID].esize =
        sizeof(soc_sbx_g3p1_sample9_t);
    tm->entries[SOC_SBX_G3P1_SAMPLE9_ID].nindexes = 1;
    tm->entries[SOC_SBX_G3P1_SAMPLE9_ID].nfields = 2;

    
    for (i = 0; i < SOC_SBX_G3P1_ENTRY_MAX_ID; i++) {
        if (!tm->entries[i].name) {
            /* Caladan3 complex tables not supported yet, skipping */
            continue;
        }
        s = soc_sbx_g3p1_ucode_get(unit,
                    soc_sbx_g3p1_sym,
                    128,
                    &tm->entries[i].nbanks,
                    e,
                    tm->entries[i].name,
                    -1,
                    e,
                    "BANKS");
        if (s) {
            soc_sbx_g3p1_uninit(unit);
            return s;
        }
        s = soc_sbx_g3p1_ucode_get(unit,
                    soc_sbx_g3p1_sym,
                    128,
                    &tm->entries[i].type,
                    e,
                    tm->entries[i].name,
                    -1,
                    e,
                    "TYPE");
        if (s) {
            soc_sbx_g3p1_uninit(unit);
            return s;
        }
        tm->entries[i].epsize = 0;
        for (j = 0; j < tm->entries[i].nbanks; j++) {
            s = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[i].banks[j].tablebank,
                        e,
                        tm->entries[i].name,
                        j == 0 ? -1 : j,
                        e,
                        "BANK");
            if (s) {
                soc_sbx_g3p1_uninit(unit);
                return s;
            }
            s = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[i].banks[j].width,
                        e,
                        tm->entries[i].name,
                        j == 0 ? -1 : j,
                        e,
                        "WIDTH");
            if (s) {
                soc_sbx_g3p1_uninit(unit);
                return s;
            }
            tm->entries[i].epsize += tm->entries[i].banks[j].width;
            s = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[i].banks[j].stridebits,
                        e,
                        tm->entries[i].name,
                        j == 0 ? -1 : j,
                        e,
                        "STRIDE");
            if (s) {
                soc_sbx_g3p1_uninit(unit);
                return s;
            }
            tm->entries[i].totalwidth +=
                tm->entries[i].banks[j].width;
        }
    
    	/*
         * Per-index state initialization
         */
        if (tm->entries[i].nindexes) {
            tm->entries[i].indexes =
                UTG_MALLOC(sizeof(soc_sbx_g3p1_index_desc_t)
                       * tm->entries[i].nindexes);
            if (!tm->entries[i].indexes) {
                soc_sbx_g3p1_uninit(unit);
                return SOC_E_MEMORY;
            }
            sal_memset(tm->entries[i].indexes, 0, 
              (sizeof(soc_sbx_g3p1_index_desc_t) * tm->entries[i].nindexes));
        }
        
        switch(i) {
         case SOC_SBX_G3P1_QOS_ID:
            tm->entries[i].indexes[0].name = "de";	
            tm->entries[i].indexes[1].name = "pri";	
            tm->entries[i].indexes[2].name = "prof";	
        	break;	
        case SOC_SBX_G3P1_DSCPQOS_ID:
            tm->entries[i].indexes[0].name = "dscp";	
            tm->entries[i].indexes[1].name = "prof";	
        	break;	
        case SOC_SBX_G3P1_IRT_ID:
            tm->entries[i].indexes[0].name = "irule";	
        	break;	
        case SOC_SBX_G3P1_LAG_ID:
            tm->entries[i].indexes[0].name = "lagi";	
        	break;	
        case SOC_SBX_G3P1_RRT_ID:
            tm->entries[i].indexes[0].name = "rri";	
        	break;	
        case SOC_SBX_G3P1_XT_ID:
            tm->entries[i].indexes[0].name = "xi";	
        	break;	
        case SOC_SBX_G3P1_MIRROR_ID:
            tm->entries[i].indexes[0].name = "mi";	
        	break;	
        case SOC_SBX_G3P1_EMIRROR_ID:
            tm->entries[i].indexes[0].name = "mi";	
        	break;	
        case SOC_SBX_G3P1_MACAGE_ID:
            tm->entries[i].indexes[0].name = "macindex";	
        	break;	
        case SOC_SBX_G3P1_MST_ID:
            tm->entries[i].indexes[0].name = "msti";	
        	break;	
        case SOC_SBX_G3P1_PV2E_ID:
            tm->entries[i].indexes[0].name = "vid";	
            tm->entries[i].indexes[1].name = "port";	
        	break;	
        case SOC_SBX_G3P1_P2APPDATA_ID:
            tm->entries[i].indexes[0].name = "port";	
        	break;	
        case SOC_SBX_G3P1_PV2APPDATA_ID:
            tm->entries[i].indexes[0].name = "vid";	
            tm->entries[i].indexes[1].name = "port";	
        	break;	
        case SOC_SBX_G3P1_PVV2EDATA_ID:
            tm->entries[i].indexes[0].name = "pvv2eindex";	
        	break;	
        case SOC_SBX_G3P1_V2E_ID:
            tm->entries[i].indexes[0].name = "vlan";	
        	break;	
        case SOC_SBX_G3P1_VRID2E_ID:
            tm->entries[i].indexes[0].name = "vlan";	
        	break;	
        case SOC_SBX_G3P1_LP_ID:
            tm->entries[i].indexes[0].name = "lpi";	
        	break;	
        case SOC_SBX_G3P1_L2CP_ID:
            tm->entries[i].indexes[0].name = "lsb";	
            tm->entries[i].indexes[1].name = "port";	
        	break;	
        case SOC_SBX_G3P1_L2CPSLOW_ID:
            tm->entries[i].indexes[0].name = "subcode";	
            tm->entries[i].indexes[1].name = "port";	
        	break;	
        case SOC_SBX_G3P1_L2CPNOP_ID:
            tm->entries[i].indexes[0].name = "i";	
        	break;	
        case SOC_SBX_G3P1_FT_ID:
            tm->entries[i].indexes[0].name = "fti";	
        	break;	
        case SOC_SBX_G3P1_EVP2E_ID:
            tm->entries[i].indexes[0].name = "vlan";	
            tm->entries[i].indexes[1].name = "port";	
        	break;	
        case SOC_SBX_G3P1_OI2E_ID:
            tm->entries[i].indexes[0].name = "oi";	
        	break;	
        case SOC_SBX_G3P1_REMARK_ID:
            tm->entries[i].indexes[0].name = "e";	
            tm->entries[i].indexes[1].name = "dp";	
            tm->entries[i].indexes[2].name = "cos";	
            tm->entries[i].indexes[3].name = "prof";	
        	break;	
        case SOC_SBX_G3P1_EPV2E_ID:
            tm->entries[i].indexes[0].name = "vid";	
            tm->entries[i].indexes[1].name = "port";	
        	break;	
        case SOC_SBX_G3P1_ERT_ID:
            tm->entries[i].indexes[0].name = "irule";	
        	break;	
        case SOC_SBX_G3P1_OAM_BUBBLE_ID:
            tm->entries[i].indexes[0].name = "oamepi";	
        	break;	
        case SOC_SBX_G3P1_OAMRX_P2E_ID:
            tm->entries[i].indexes[0].name = "dir";	
            tm->entries[i].indexes[1].name = "port";	
        	break;	
        case SOC_SBX_G3P1_OAM_PEER_STATE_ID:
            tm->entries[i].indexes[0].name = "peer_idx";	
        	break;	
        case SOC_SBX_G3P1_PTP_COMPENSATION_ID:
            tm->entries[i].indexes[0].name = "port";	
        	break;	
        case SOC_SBX_G3P1_BFD_LD2EDATA_ID:
            tm->entries[i].indexes[0].name = "ptr";	
        	break;	
        case SOC_SBX_G3P1_BFD_LD2EDATAC_ID:
            tm->entries[i].indexes[0].name = "ptr";	
        	break;	
        case SOC_SBX_G3P1_SAMPLE6_ID:
            tm->entries[i].indexes[0].name = "test6i";	
        	break;	
        case SOC_SBX_G3P1_SAMPLE8_ID:
            tm->entries[i].indexes[0].name = "test8i";	
        	break;	
        case SOC_SBX_G3P1_SAMPLE9_ID:
            tm->entries[i].indexes[0].name = "test9i";	
        	break;	

        }
        
        for (j = 0; j < tm->entries[i].nindexes; j++) {
            s = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[i].indexes[j].pos,
                        e,
                        tm->entries[i].name,
                        -1,
                        tm->entries[i].indexes[j].name,
                        "INDEX_POSITION");
            if (s) {
                soc_sbx_g3p1_uninit(unit);
                return s;
            }
            s = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[i].indexes[j].orange,
                        e,
                        tm->entries[i].name,
                        -1,
                        tm->entries[i].indexes[j].name,
                        "INDEX_RANGE");
            if (s) {
                soc_sbx_g3p1_uninit(unit);
                return s;
            }
            tm->entries[i].indexes[j].range
                = tm->entries[i].indexes[j].orange;
            s = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[i].indexes[j].width,
                        e,
                        tm->entries[i].name,
                        -1,
                        tm->entries[i].indexes[j].name,
                        "INDEX_WIDTH");
            if (s) {
                soc_sbx_g3p1_uninit(unit);
                return s;
            }
            s = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[i].indexes[j].format,
                        e,
                        tm->entries[i].name,
                        -1,
                        tm->entries[i].indexes[j].name,
                        "FORMAT");
            if (s) {
                soc_sbx_g3p1_uninit(unit);
                return s;
            }
        }

        if (tm->entries[i].nindexes) {
            tm->entries[i].indexeswidth =
                ((tm->entries[i].indexes[tm->entries[i].nindexes - 1].pos
                  + tm->entries[i].indexes[tm->entries[i].nindexes - 1].width
                  + 7) / 8) * 8;
        }

        soc_sbx_g3p1_entry_index_ranges_set(unit, i);
        
        /*
         * Per-field state initialization
         */
        if (tm->entries[i].nfields) {
            tm->entries[i].fields =
                UTG_MALLOC(sizeof(soc_sbx_g3p1_field_desc_t)
                       * tm->entries[i].nfields);
            if (!tm->entries[i].fields) {
                return SOC_E_MEMORY;
            }
        }
        
        switch(i) {
         case SOC_SBX_G3P1_QOS_ID:
        	tm->entries[i].fields[0].name = "e";
        	tm->entries[i].fields[1].name = "dp";
        	tm->entries[i].fields[2].name = "cos";
        	tm->entries[i].fields[3].name = "fcos";
        	tm->entries[i].fields[4].name = "mefcos";
        	break;
        case SOC_SBX_G3P1_DSCPQOS_ID:
        	tm->entries[i].fields[0].name = "e";
        	tm->entries[i].fields[1].name = "dp";
        	tm->entries[i].fields[2].name = "cos";
        	tm->entries[i].fields[3].name = "fcos";
        	tm->entries[i].fields[4].name = "mefcos";
        	break;
        case SOC_SBX_G3P1_IRT_ID:
        	tm->entries[i].fields[0].name = "vlan";
        	tm->entries[i].fields[1].name = "ftidx";
        	tm->entries[i].fields[2].name = "mirror";
        	tm->entries[i].fields[3].name = "usevlan";
        	tm->entries[i].fields[4].name = "useftidx";
        	tm->entries[i].fields[5].name = "copy";
        	tm->entries[i].fields[6].name = "dp";
        	tm->entries[i].fields[7].name = "cos";
        	tm->entries[i].fields[8].name = "fcos";
        	tm->entries[i].fields[9].name = "usedp";
        	tm->entries[i].fields[10].name = "usecos";
        	tm->entries[i].fields[11].name = "policer";
        	tm->entries[i].fields[12].name = "typedpolice";
        	tm->entries[i].fields[13].name = "mefcos";
        	tm->entries[i].fields[14].name = "mef";
        	break;
        case SOC_SBX_G3P1_LAG_ID:
        	tm->entries[i].fields[0].name = "qid";
        	tm->entries[i].fields[1].name = "oi";
        	break;
        case SOC_SBX_G3P1_RRT_ID:
        	tm->entries[i].fields[0].name = "backup";
        	break;
        case SOC_SBX_G3P1_XT_ID:
        	tm->entries[i].fields[0].name = "forward";
        	tm->entries[i].fields[1].name = "dp";
        	tm->entries[i].fields[2].name = "qid";
        	tm->entries[i].fields[3].name = "fwdid";
        	tm->entries[i].fields[4].name = "trunc";
        	tm->entries[i].fields[5].name = "learn";
        	tm->entries[i].fields[6].name = "ppspolice";
        	tm->entries[i].fields[7].name = "policer";
        	break;
        case SOC_SBX_G3P1_MIRROR_ID:
        	tm->entries[i].fields[0].name = "yellow";
        	tm->entries[i].fields[1].name = "qid";
        	tm->entries[i].fields[2].name = "oi";
        	break;
        case SOC_SBX_G3P1_EMIRROR_ID:
        	tm->entries[i].fields[0].name = "yellow";
        	tm->entries[i].fields[1].name = "qid";
        	tm->entries[i].fields[2].name = "oi";
        	tm->entries[i].fields[3].name = "dqueue";
        	tm->entries[i].fields[4].name = "local";
        	break;
        case SOC_SBX_G3P1_MACAGE_ID:
        	tm->entries[i].fields[0].name = "age";
        	break;
        case SOC_SBX_G3P1_MST_ID:
        	tm->entries[i].fields[0].name = "learn";
        	tm->entries[i].fields[1].name = "pim";
        	tm->entries[i].fields[2].name = "igmp";
        	tm->entries[i].fields[3].name = "rtcopy";
        	tm->entries[i].fields[4].name = "l2cpcopy";
        	tm->entries[i].fields[5].name = "dcopy";
        	tm->entries[i].fields[6].name = "ipredirect";
        	tm->entries[i].fields[7].name = "learn_bmac";
        	tm->entries[i].fields[8].name = "mirroridx";
        	tm->entries[i].fields[9].name = "vsi";
        	break;
        case SOC_SBX_G3P1_PV2E_ID:
        	tm->entries[i].fields[0].name = "lpi";
        	tm->entries[i].fields[1].name = "vlan";
        	tm->entries[i].fields[2].name = "stpstate";
        	tm->entries[i].fields[3].name = "vpws";
        	break;
        case SOC_SBX_G3P1_P2APPDATA_ID:
        	tm->entries[i].fields[0].name = "ifilteren";
        	tm->entries[i].fields[1].name = "efilteren";
        	break;
        case SOC_SBX_G3P1_PV2APPDATA_ID:
        	tm->entries[i].fields[0].name = "member";
        	break;
        case SOC_SBX_G3P1_PVV2EDATA_ID:
        	tm->entries[i].fields[0].name = "vpws";
        	tm->entries[i].fields[1].name = "stpstate";
        	tm->entries[i].fields[2].name = "vlan";
        	tm->entries[i].fields[3].name = "lpi";
        	tm->entries[i].fields[4].name = "hit";
        	tm->entries[i].fields[5].name = "keeporstrip";
        	tm->entries[i].fields[6].name = "replace";
        	tm->entries[i].fields[7].name = "vid";
        	tm->entries[i].fields[8].name = "vidop";
        	break;
        case SOC_SBX_G3P1_V2E_ID:
        	tm->entries[i].fields[0].name = "pim";
        	tm->entries[i].fields[1].name = "igmp";
        	tm->entries[i].fields[2].name = "policerbypass";
        	tm->entries[i].fields[3].name = "forceflood";
        	tm->entries[i].fields[4].name = "dropunksmac";
        	tm->entries[i].fields[5].name = "dropunkucast";
        	tm->entries[i].fields[6].name = "dontlearn";
        	tm->entries[i].fields[7].name = "vrf";
        	tm->entries[i].fields[8].name = "v6mc";
        	tm->entries[i].fields[9].name = "v4mc";
        	tm->entries[i].fields[10].name = "laghash";
        	tm->entries[i].fields[11].name = "v4uc";
        	tm->entries[i].fields[12].name = "v6uc";
        	break;
        case SOC_SBX_G3P1_VRID2E_ID:
        	tm->entries[i].fields[0].name = "v4_vrid0";
        	tm->entries[i].fields[1].name = "v4_vrid1";
        	tm->entries[i].fields[2].name = "v6_vrid0";
        	tm->entries[i].fields[3].name = "v6_vrid1";
        	break;
        case SOC_SBX_G3P1_LP_ID:
        	tm->entries[i].fields[0].name = "pid";
        	tm->entries[i].fields[1].name = "qos";
        	tm->entries[i].fields[2].name = "useexp";
        	tm->entries[i].fields[3].name = "usedscp";
        	tm->entries[i].fields[4].name = "updatefdp";
        	tm->entries[i].fields[5].name = "mirror";
        	tm->entries[i].fields[6].name = "updaterdp";
        	tm->entries[i].fields[7].name = "policer";
        	tm->entries[i].fields[8].name = "typedpolice";
        	tm->entries[i].fields[9].name = "mefcos";
        	tm->entries[i].fields[10].name = "mef";
        	tm->entries[i].fields[11].name = "ccounter";
        	tm->entries[i].fields[12].name = "priclass";
        	tm->entries[i].fields[13].name = "allpri";
        	tm->entries[i].fields[14].name = "xtpolreplace";
        	tm->entries[i].fields[15].name = "counter";
        	tm->entries[i].fields[16].name = "typedcount";
        	tm->entries[i].fields[17].name = "color";
        	tm->entries[i].fields[18].name = "usecolor";
        	tm->entries[i].fields[19].name = "oamepi";
        	break;
        case SOC_SBX_G3P1_L2CP_ID:
        	tm->entries[i].fields[0].name = "ftidx";
        	tm->entries[i].fields[1].name = "forward";
        	tm->entries[i].fields[2].name = "passstp";
        	tm->entries[i].fields[3].name = "copy";
        	break;
        case SOC_SBX_G3P1_L2CPSLOW_ID:
        	tm->entries[i].fields[0].name = "ftidx";
        	tm->entries[i].fields[1].name = "forward";
        	tm->entries[i].fields[2].name = "passstp";
        	tm->entries[i].fields[3].name = "copy";
        	break;
        case SOC_SBX_G3P1_L2CPNOP_ID:
        	tm->entries[i].fields[0].name = "ftidx";
        	tm->entries[i].fields[1].name = "forward";
        	tm->entries[i].fields[2].name = "passstp";
        	tm->entries[i].fields[3].name = "copy";
        	break;
        case SOC_SBX_G3P1_FT_ID:
        	tm->entries[i].fields[0].name = "rridx";
        	tm->entries[i].fields[1].name = "excidx";
        	tm->entries[i].fields[2].name = "lenadj";
        	tm->entries[i].fields[3].name = "mc";
        	tm->entries[i].fields[4].name = "t";
        	tm->entries[i].fields[5].name = "hc";
        	tm->entries[i].fields[6].name = "oi";
        	tm->entries[i].fields[7].name = "qid";
        	tm->entries[i].fields[8].name = "lagbase";
        	tm->entries[i].fields[9].name = "lagsize";
        	tm->entries[i].fields[10].name = "lag";
        	tm->entries[i].fields[11].name = "oib";
        	tm->entries[i].fields[12].name = "qidb";
        	tm->entries[i].fields[13].name = "lagbaseb";
        	tm->entries[i].fields[14].name = "lagsizeb";
        	tm->entries[i].fields[15].name = "lagb";
        	break;
        case SOC_SBX_G3P1_EVP2E_ID:
        	tm->entries[i].fields[0].name = "eteptr";
        	tm->entries[i].fields[1].name = "counter";
        	tm->entries[i].fields[2].name = "ccounter";
        	tm->entries[i].fields[3].name = "priclass";
        	tm->entries[i].fields[4].name = "allpri";
        	break;
        case SOC_SBX_G3P1_OI2E_ID:
        	tm->entries[i].fields[0].name = "eteptr";
        	tm->entries[i].fields[1].name = "counter";
        	tm->entries[i].fields[2].name = "ccounter";
        	tm->entries[i].fields[3].name = "priclass";
        	tm->entries[i].fields[4].name = "allpri";
        	break;
        case SOC_SBX_G3P1_REMARK_ID:
        	tm->entries[i].fields[0].name = "cfi";
        	tm->entries[i].fields[1].name = "pri";
        	tm->entries[i].fields[2].name = "exp";
        	tm->entries[i].fields[3].name = "dscp";
        	break;
        case SOC_SBX_G3P1_EPV2E_ID:
        	tm->entries[i].fields[0].name = "drop";
        	tm->entries[i].fields[1].name = "strip";
        	break;
        case SOC_SBX_G3P1_ERT_ID:
        	tm->entries[i].fields[0].name = "mirror";
        	tm->entries[i].fields[1].name = "drop";
        	tm->entries[i].fields[2].name = "counter";
        	break;
        case SOC_SBX_G3P1_OAM_BUBBLE_ID:
        	tm->entries[i].fields[0].name = "bubble_mode";
        	tm->entries[i].fields[1].name = "je";
        	tm->entries[i].fields[2].name = "i";
        	tm->entries[i].fields[3].name = "bubble_stream";
        	tm->entries[i].fields[4].name = "t";
        	tm->entries[i].fields[5].name = "interval_index";
        	tm->entries[i].fields[6].name = "reserved";
        	tm->entries[i].fields[7].name = "count";
        	tm->entries[i].fields[8].name = "timeout";
        	break;
        case SOC_SBX_G3P1_OAMRX_P2E_ID:
        	tm->entries[i].fields[0].name = "svc_hdl";
        	tm->entries[i].fields[1].name = "not_used";
        	tm->entries[i].fields[2].name = "mdlvl_0_m";
        	tm->entries[i].fields[3].name = "mdlvl_0_p";
        	tm->entries[i].fields[4].name = "mdlvl_0_d";
        	tm->entries[i].fields[5].name = "mdlvl_0_f";
        	tm->entries[i].fields[6].name = "mdlvl_1_m";
        	tm->entries[i].fields[7].name = "mdlvl_1_p";
        	tm->entries[i].fields[8].name = "mdlvl_1_d";
        	tm->entries[i].fields[9].name = "mdlvl_1_f";
        	tm->entries[i].fields[10].name = "mdlvl_2_m";
        	tm->entries[i].fields[11].name = "mdlvl_2_p";
        	tm->entries[i].fields[12].name = "mdlvl_2_d";
        	tm->entries[i].fields[13].name = "mdlvl_2_f";
        	tm->entries[i].fields[14].name = "mdlvl_3_m";
        	tm->entries[i].fields[15].name = "mdlvl_3_p";
        	tm->entries[i].fields[16].name = "mdlvl_3_d";
        	tm->entries[i].fields[17].name = "mdlvl_3_f";
        	tm->entries[i].fields[18].name = "mdlvl_4_m";
        	tm->entries[i].fields[19].name = "mdlvl_4_p";
        	tm->entries[i].fields[20].name = "mdlvl_4_d";
        	tm->entries[i].fields[21].name = "mdlvl_4_f";
        	tm->entries[i].fields[22].name = "mdlvl_5_m";
        	tm->entries[i].fields[23].name = "mdlvl_5_p";
        	tm->entries[i].fields[24].name = "mdlvl_5_d";
        	tm->entries[i].fields[25].name = "mdlvl_5_f";
        	tm->entries[i].fields[26].name = "mdlvl_6_m";
        	tm->entries[i].fields[27].name = "mdlvl_6_p";
        	tm->entries[i].fields[28].name = "mdlvl_6_d";
        	tm->entries[i].fields[29].name = "mdlvl_6_f";
        	tm->entries[i].fields[30].name = "mdlvl_7_m";
        	tm->entries[i].fields[31].name = "mdlvl_7_p";
        	tm->entries[i].fields[32].name = "mdlvl_7_d";
        	tm->entries[i].fields[33].name = "mdlvl_7_f";
        	break;
        case SOC_SBX_G3P1_OAM_PEER_STATE_ID:
        	tm->entries[i].fields[0].name = "rdi_ack";
        	tm->entries[i].fields[1].name = "rdi_state";
        	break;
        case SOC_SBX_G3P1_PTP_COMPENSATION_ID:
        	tm->entries[i].fields[0].name = "compensation";
        	break;
        case SOC_SBX_G3P1_BFD_LD2EDATA_ID:
        	tm->entries[i].fields[0].name = "wdg_id";
        	tm->entries[i].fields[1].name = "slowstart";
        	tm->entries[i].fields[2].name = "rdmode";
        	tm->entries[i].fields[3].name = "rstate";
        	tm->entries[i].fields[4].name = "f";
        	tm->entries[i].fields[5].name = "poll";
        	tm->entries[i].fields[6].name = "sta";
        	tm->entries[i].fields[7].name = "ldiag";
        	tm->entries[i].fields[8].name = "version";
        	tm->entries[i].fields[9].name = "rdiscri";
        	break;
        case SOC_SBX_G3P1_BFD_LD2EDATAC_ID:
        	tm->entries[i].fields[0].name = "rMinRxInterval";
        	break;
        case SOC_SBX_G3P1_SAMPLE6_ID:
        	tm->entries[i].fields[0].name = "pad";
        	tm->entries[i].fields[1].name = "test6";
        	break;
        case SOC_SBX_G3P1_SAMPLE8_ID:
        	tm->entries[i].fields[0].name = "pad";
        	tm->entries[i].fields[1].name = "test8";
        	break;
        case SOC_SBX_G3P1_SAMPLE9_ID:
        	tm->entries[i].fields[0].name = "pad";
        	tm->entries[i].fields[1].name = "test9";
        	break;

        }
        
        for (j = 0; j < tm->entries[i].nfields; j++) {
            s = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[i].fields[j].pos,
                        e,
                        tm->entries[i].name,
                        -1,
                        tm->entries[i].fields[j].name,
                        "POSITION");
            if (s) {
                soc_sbx_g3p1_uninit(unit);
                return s;
            }
            s = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[i].fields[j].range,
                        e,
                        tm->entries[i].name,
                        -1,
                        tm->entries[i].fields[j].name,
                        "RANGE");
            if (s) {
                soc_sbx_g3p1_uninit(unit);
                return s;
            }
            s = soc_sbx_g3p1_ucode_get(unit,
                        soc_sbx_g3p1_sym,
                        128,
                        &tm->entries[i].fields[j].width,
                        e,
                        tm->entries[i].name,
                        -1,
                        tm->entries[i].fields[j].name,
                        "WIDTH");
            if (s) {
                soc_sbx_g3p1_uninit(unit);
                return s;
            }
        }
    }
    
    return SOC_E_NONE;
}

/*
 * Table state accessor implementations
 */

/* get table bank parameters for qos */
int soc_sbx_g3p1_qos_bank_params_get(int unit, int bank,
                soc_sbx_g3p1_table_bank_params_t *p)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_QOS_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for qos */
int soc_sbx_g3p1_qos_table_size_get(int unit)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_QOS_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for qos */
int soc_sbx_g3p1_qos_table_size_set(int unit, int size)
{
    return soc_sbx_g3p1_generic_table_size_set(unit,
                     SOC_SBX_G3P1_QOS_TABLE_ID, size, 1);
}

/* get table bank parameters for dscpqos */
int soc_sbx_g3p1_dscpqos_bank_params_get(int unit, int bank,
                soc_sbx_g3p1_table_bank_params_t *p)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_DSCPQOS_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for dscpqos */
int soc_sbx_g3p1_dscpqos_table_size_get(int unit)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_DSCPQOS_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for dscpqos */
int soc_sbx_g3p1_dscpqos_table_size_set(int unit, int size)
{
    return soc_sbx_g3p1_generic_table_size_set(unit,
                     SOC_SBX_G3P1_DSCPQOS_TABLE_ID, size, 1);
}

/* get table bank parameters for irt */
int soc_sbx_g3p1_irt_bank_params_get(int unit, int bank,
                soc_sbx_g3p1_table_bank_params_t *p)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_IRT_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for irt */
int soc_sbx_g3p1_irt_table_size_get(int unit)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_IRT_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for irt */
int soc_sbx_g3p1_irt_table_size_set(int unit, int size)
{
    return soc_sbx_g3p1_generic_table_size_set(unit,
                     SOC_SBX_G3P1_IRT_TABLE_ID, size, 1);
}

/* get table bank parameters for lag */
int soc_sbx_g3p1_lag_bank_params_get(int unit, int bank,
                soc_sbx_g3p1_table_bank_params_t *p)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_LAG_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for lag */
int soc_sbx_g3p1_lag_table_size_get(int unit)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_LAG_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for lag */
int soc_sbx_g3p1_lag_table_size_set(int unit, int size)
{
    return soc_sbx_g3p1_generic_table_size_set(unit,
                     SOC_SBX_G3P1_LAG_TABLE_ID, size, 1);
}

/* get table bank parameters for rrt */
int soc_sbx_g3p1_rrt_bank_params_get(int unit, int bank,
                soc_sbx_g3p1_table_bank_params_t *p)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_RRT_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for rrt */
int soc_sbx_g3p1_rrt_table_size_get(int unit)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_RRT_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for rrt */
int soc_sbx_g3p1_rrt_table_size_set(int unit, int size)
{
    return soc_sbx_g3p1_generic_table_size_set(unit,
                     SOC_SBX_G3P1_RRT_TABLE_ID, size, 1);
}

/* get table bank parameters for xt */
int soc_sbx_g3p1_xt_bank_params_get(int unit, int bank,
                soc_sbx_g3p1_table_bank_params_t *p)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_XT_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for xt */
int soc_sbx_g3p1_xt_table_size_get(int unit)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_XT_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for xt */
int soc_sbx_g3p1_xt_table_size_set(int unit, int size)
{
    return soc_sbx_g3p1_generic_table_size_set(unit,
                     SOC_SBX_G3P1_XT_TABLE_ID, size, 1);
}

/* get table bank parameters for mirror */
int soc_sbx_g3p1_mirror_bank_params_get(int unit, int bank,
                soc_sbx_g3p1_table_bank_params_t *p)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_MIRROR_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for mirror */
int soc_sbx_g3p1_mirror_table_size_get(int unit)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_MIRROR_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for mirror */
int soc_sbx_g3p1_mirror_table_size_set(int unit, int size)
{
    return soc_sbx_g3p1_generic_table_size_set(unit,
                     SOC_SBX_G3P1_MIRROR_TABLE_ID, size, 1);
}

/* get table bank parameters for emirror */
int soc_sbx_g3p1_emirror_bank_params_get(int unit, int bank,
                soc_sbx_g3p1_table_bank_params_t *p)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_EMIRROR_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for emirror */
int soc_sbx_g3p1_emirror_table_size_get(int unit)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_EMIRROR_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for emirror */
int soc_sbx_g3p1_emirror_table_size_set(int unit, int size)
{
    return soc_sbx_g3p1_generic_table_size_set(unit,
                     SOC_SBX_G3P1_EMIRROR_TABLE_ID, size, 1);
}

/* get table bank parameters for macage */
int soc_sbx_g3p1_macage_bank_params_get(int unit, int bank,
                soc_sbx_g3p1_table_bank_params_t *p)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_MACAGE_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for macage */
int soc_sbx_g3p1_macage_table_size_get(int unit)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_MACAGE_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for macage */
int soc_sbx_g3p1_macage_table_size_set(int unit, int size)
{
    return soc_sbx_g3p1_generic_table_size_set(unit,
                     SOC_SBX_G3P1_MACAGE_TABLE_ID, size, 1);
}

/* get table bank parameters for mst */
int soc_sbx_g3p1_mst_bank_params_get(int unit, int bank,
                soc_sbx_g3p1_table_bank_params_t *p)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_MST_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for mst */
int soc_sbx_g3p1_mst_table_size_get(int unit)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_MST_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for mst */
int soc_sbx_g3p1_mst_table_size_set(int unit, int size)
{
    return soc_sbx_g3p1_generic_table_size_set(unit,
                     SOC_SBX_G3P1_MST_TABLE_ID, size, 1);
}

/* get table bank parameters for pv2e */
int soc_sbx_g3p1_pv2e_bank_params_get(int unit, int bank,
                soc_sbx_g3p1_table_bank_params_t *p)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_PV2E_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for pv2e */
int soc_sbx_g3p1_pv2e_table_size_get(int unit)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_PV2E_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for pv2e */
int soc_sbx_g3p1_pv2e_table_size_set(int unit, int size)
{
    return soc_sbx_g3p1_generic_table_size_set(unit,
                     SOC_SBX_G3P1_PV2E_TABLE_ID, size, 1);
}

/* get table bank parameters for p2appdata */
int soc_sbx_g3p1_p2appdata_bank_params_get(int unit, int bank,
                soc_sbx_g3p1_table_bank_params_t *p)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_P2APPDATA_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for p2appdata */
int soc_sbx_g3p1_p2appdata_table_size_get(int unit)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_P2APPDATA_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for p2appdata */
int soc_sbx_g3p1_p2appdata_table_size_set(int unit, int size)
{
    return soc_sbx_g3p1_generic_table_size_set(unit,
                     SOC_SBX_G3P1_P2APPDATA_TABLE_ID, size, 1);
}

/* get table bank parameters for pv2appdata */
int soc_sbx_g3p1_pv2appdata_bank_params_get(int unit, int bank,
                soc_sbx_g3p1_table_bank_params_t *p)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_PV2APPDATA_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for pv2appdata */
int soc_sbx_g3p1_pv2appdata_table_size_get(int unit)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_PV2APPDATA_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for pv2appdata */
int soc_sbx_g3p1_pv2appdata_table_size_set(int unit, int size)
{
    return soc_sbx_g3p1_generic_table_size_set(unit,
                     SOC_SBX_G3P1_PV2APPDATA_TABLE_ID, size, 1);
}

/* get table bank parameters for pvv2edata */
int soc_sbx_g3p1_pvv2edata_bank_params_get(int unit, int bank,
                soc_sbx_g3p1_table_bank_params_t *p)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_PVV2EDATA_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for pvv2edata */
int soc_sbx_g3p1_pvv2edata_table_size_get(int unit)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_PVV2EDATA_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for pvv2edata */
int soc_sbx_g3p1_pvv2edata_table_size_set(int unit, int size)
{
    return soc_sbx_g3p1_generic_table_size_set(unit,
                     SOC_SBX_G3P1_PVV2EDATA_TABLE_ID, size, 1);
}

/* get table bank parameters for v2e */
int soc_sbx_g3p1_v2e_bank_params_get(int unit, int bank,
                soc_sbx_g3p1_table_bank_params_t *p)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_V2E_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for v2e */
int soc_sbx_g3p1_v2e_table_size_get(int unit)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_V2E_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for v2e */
int soc_sbx_g3p1_v2e_table_size_set(int unit, int size)
{
    return soc_sbx_g3p1_generic_table_size_set(unit,
                     SOC_SBX_G3P1_V2E_TABLE_ID, size, 1);
}

/* get table bank parameters for vrid2e */
int soc_sbx_g3p1_vrid2e_bank_params_get(int unit, int bank,
                soc_sbx_g3p1_table_bank_params_t *p)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_VRID2E_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for vrid2e */
int soc_sbx_g3p1_vrid2e_table_size_get(int unit)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_VRID2E_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for vrid2e */
int soc_sbx_g3p1_vrid2e_table_size_set(int unit, int size)
{
    return soc_sbx_g3p1_generic_table_size_set(unit,
                     SOC_SBX_G3P1_VRID2E_TABLE_ID, size, 1);
}

/* get table bank parameters for lp */
int soc_sbx_g3p1_lp_bank_params_get(int unit, int bank,
                soc_sbx_g3p1_table_bank_params_t *p)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_LP_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for lp */
int soc_sbx_g3p1_lp_table_size_get(int unit)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_LP_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for lp */
int soc_sbx_g3p1_lp_table_size_set(int unit, int size)
{
    return soc_sbx_g3p1_generic_table_size_set(unit,
                     SOC_SBX_G3P1_LP_TABLE_ID, size, 1);
}

/* get table bank parameters for l2cp */
int soc_sbx_g3p1_l2cp_bank_params_get(int unit, int bank,
                soc_sbx_g3p1_table_bank_params_t *p)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_L2CP_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for l2cp */
int soc_sbx_g3p1_l2cp_table_size_get(int unit)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_L2CP_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for l2cp */
int soc_sbx_g3p1_l2cp_table_size_set(int unit, int size)
{
    return soc_sbx_g3p1_generic_table_size_set(unit,
                     SOC_SBX_G3P1_L2CP_TABLE_ID, size, 1);
}

/* get table bank parameters for l2cpslow */
int soc_sbx_g3p1_l2cpslow_bank_params_get(int unit, int bank,
                soc_sbx_g3p1_table_bank_params_t *p)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_L2CPSLOW_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for l2cpslow */
int soc_sbx_g3p1_l2cpslow_table_size_get(int unit)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_L2CPSLOW_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for l2cpslow */
int soc_sbx_g3p1_l2cpslow_table_size_set(int unit, int size)
{
    return soc_sbx_g3p1_generic_table_size_set(unit,
                     SOC_SBX_G3P1_L2CPSLOW_TABLE_ID, size, 1);
}

/* get table bank parameters for l2cpnop */
int soc_sbx_g3p1_l2cpnop_bank_params_get(int unit, int bank,
                soc_sbx_g3p1_table_bank_params_t *p)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_L2CPNOP_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for l2cpnop */
int soc_sbx_g3p1_l2cpnop_table_size_get(int unit)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_L2CPNOP_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for l2cpnop */
int soc_sbx_g3p1_l2cpnop_table_size_set(int unit, int size)
{
    return soc_sbx_g3p1_generic_table_size_set(unit,
                     SOC_SBX_G3P1_L2CPNOP_TABLE_ID, size, 1);
}

/* get table bank parameters for ft */
int soc_sbx_g3p1_ft_bank_params_get(int unit, int bank,
                soc_sbx_g3p1_table_bank_params_t *p)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_FT_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for ft */
int soc_sbx_g3p1_ft_table_size_get(int unit)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_FT_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for ft */
int soc_sbx_g3p1_ft_table_size_set(int unit, int size)
{
    return soc_sbx_g3p1_generic_table_size_set(unit,
                     SOC_SBX_G3P1_FT_TABLE_ID, size, 1);
}

/* get table bank parameters for evp2e */
int soc_sbx_g3p1_evp2e_bank_params_get(int unit, int bank,
                soc_sbx_g3p1_table_bank_params_t *p)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_EVP2E_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for evp2e */
int soc_sbx_g3p1_evp2e_table_size_get(int unit)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_EVP2E_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for evp2e */
int soc_sbx_g3p1_evp2e_table_size_set(int unit, int size)
{
    return soc_sbx_g3p1_generic_table_size_set(unit,
                     SOC_SBX_G3P1_EVP2E_TABLE_ID, size, 1);
}

/* get table bank parameters for oi2e */
int soc_sbx_g3p1_oi2e_bank_params_get(int unit, int bank,
                soc_sbx_g3p1_table_bank_params_t *p)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_OI2E_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for oi2e */
int soc_sbx_g3p1_oi2e_table_size_get(int unit)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_OI2E_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for oi2e */
int soc_sbx_g3p1_oi2e_table_size_set(int unit, int size)
{
    return soc_sbx_g3p1_generic_table_size_set(unit,
                     SOC_SBX_G3P1_OI2E_TABLE_ID, size, 1);
}

/* get table bank parameters for remark */
int soc_sbx_g3p1_remark_bank_params_get(int unit, int bank,
                soc_sbx_g3p1_table_bank_params_t *p)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_REMARK_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for remark */
int soc_sbx_g3p1_remark_table_size_get(int unit)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_REMARK_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for remark */
int soc_sbx_g3p1_remark_table_size_set(int unit, int size)
{
    return soc_sbx_g3p1_generic_table_size_set(unit,
                     SOC_SBX_G3P1_REMARK_TABLE_ID, size, 1);
}

/* get table bank parameters for epv2e */
int soc_sbx_g3p1_epv2e_bank_params_get(int unit, int bank,
                soc_sbx_g3p1_table_bank_params_t *p)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_EPV2E_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for epv2e */
int soc_sbx_g3p1_epv2e_table_size_get(int unit)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_EPV2E_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for epv2e */
int soc_sbx_g3p1_epv2e_table_size_set(int unit, int size)
{
    return soc_sbx_g3p1_generic_table_size_set(unit,
                     SOC_SBX_G3P1_EPV2E_TABLE_ID, size, 1);
}

/* get table bank parameters for ert */
int soc_sbx_g3p1_ert_bank_params_get(int unit, int bank,
                soc_sbx_g3p1_table_bank_params_t *p)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_ERT_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for ert */
int soc_sbx_g3p1_ert_table_size_get(int unit)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_ERT_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for ert */
int soc_sbx_g3p1_ert_table_size_set(int unit, int size)
{
    return soc_sbx_g3p1_generic_table_size_set(unit,
                     SOC_SBX_G3P1_ERT_TABLE_ID, size, 1);
}

/* get table bank parameters for oam_bubble */
int soc_sbx_g3p1_oam_bubble_bank_params_get(int unit, int bank,
                soc_sbx_g3p1_table_bank_params_t *p)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_OAM_BUBBLE_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for oam_bubble */
int soc_sbx_g3p1_oam_bubble_table_size_get(int unit)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_OAM_BUBBLE_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for oam_bubble */
int soc_sbx_g3p1_oam_bubble_table_size_set(int unit, int size)
{
    return soc_sbx_g3p1_generic_table_size_set(unit,
                     SOC_SBX_G3P1_OAM_BUBBLE_TABLE_ID, size, 1);
}

/* get table bank parameters for oamrx_p2e */
int soc_sbx_g3p1_oamrx_p2e_bank_params_get(int unit, int bank,
                soc_sbx_g3p1_table_bank_params_t *p)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_OAMRX_P2E_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for oamrx_p2e */
int soc_sbx_g3p1_oamrx_p2e_table_size_get(int unit)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_OAMRX_P2E_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for oamrx_p2e */
int soc_sbx_g3p1_oamrx_p2e_table_size_set(int unit, int size)
{
    return soc_sbx_g3p1_generic_table_size_set(unit,
                     SOC_SBX_G3P1_OAMRX_P2E_TABLE_ID, size, 1);
}

/* get table bank parameters for oam_peer_state */
int soc_sbx_g3p1_oam_peer_state_bank_params_get(int unit, int bank,
                soc_sbx_g3p1_table_bank_params_t *p)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_OAM_PEER_STATE_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for oam_peer_state */
int soc_sbx_g3p1_oam_peer_state_table_size_get(int unit)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_OAM_PEER_STATE_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for oam_peer_state */
int soc_sbx_g3p1_oam_peer_state_table_size_set(int unit, int size)
{
    return soc_sbx_g3p1_generic_table_size_set(unit,
                     SOC_SBX_G3P1_OAM_PEER_STATE_TABLE_ID, size, 1);
}

/* get table bank parameters for ptp_compensation */
int soc_sbx_g3p1_ptp_compensation_bank_params_get(int unit, int bank,
                soc_sbx_g3p1_table_bank_params_t *p)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_PTP_COMPENSATION_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for ptp_compensation */
int soc_sbx_g3p1_ptp_compensation_table_size_get(int unit)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_PTP_COMPENSATION_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for ptp_compensation */
int soc_sbx_g3p1_ptp_compensation_table_size_set(int unit, int size)
{
    return soc_sbx_g3p1_generic_table_size_set(unit,
                     SOC_SBX_G3P1_PTP_COMPENSATION_TABLE_ID, size, 1);
}

/* get table bank parameters for bfd_ld2edata */
int soc_sbx_g3p1_bfd_ld2edata_bank_params_get(int unit, int bank,
                soc_sbx_g3p1_table_bank_params_t *p)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_BFD_LD2EDATA_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for bfd_ld2edata */
int soc_sbx_g3p1_bfd_ld2edata_table_size_get(int unit)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_BFD_LD2EDATA_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for bfd_ld2edata */
int soc_sbx_g3p1_bfd_ld2edata_table_size_set(int unit, int size)
{
    return soc_sbx_g3p1_generic_table_size_set(unit,
                     SOC_SBX_G3P1_BFD_LD2EDATA_TABLE_ID, size, 1);
}

/* get table bank parameters for bfd_ld2edatac */
int soc_sbx_g3p1_bfd_ld2edatac_bank_params_get(int unit, int bank,
                soc_sbx_g3p1_table_bank_params_t *p)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_BFD_LD2EDATAC_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for bfd_ld2edatac */
int soc_sbx_g3p1_bfd_ld2edatac_table_size_get(int unit)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_BFD_LD2EDATAC_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for bfd_ld2edatac */
int soc_sbx_g3p1_bfd_ld2edatac_table_size_set(int unit, int size)
{
    return soc_sbx_g3p1_generic_table_size_set(unit,
                     SOC_SBX_G3P1_BFD_LD2EDATAC_TABLE_ID, size, 1);
}

/* get table bank parameters for sample6 */
int soc_sbx_g3p1_sample6_bank_params_get(int unit, int bank,
                soc_sbx_g3p1_table_bank_params_t *p)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_SAMPLE6_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for sample6 */
int soc_sbx_g3p1_sample6_table_size_get(int unit)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_SAMPLE6_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for sample6 */
int soc_sbx_g3p1_sample6_table_size_set(int unit, int size)
{
    return soc_sbx_g3p1_generic_table_size_set(unit,
                     SOC_SBX_G3P1_SAMPLE6_TABLE_ID, size, 1);
}

/* get table bank parameters for sample8 */
int soc_sbx_g3p1_sample8_bank_params_get(int unit, int bank,
                soc_sbx_g3p1_table_bank_params_t *p)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_SAMPLE8_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for sample8 */
int soc_sbx_g3p1_sample8_table_size_get(int unit)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_SAMPLE8_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for sample8 */
int soc_sbx_g3p1_sample8_table_size_set(int unit, int size)
{
    return soc_sbx_g3p1_generic_table_size_set(unit,
                     SOC_SBX_G3P1_SAMPLE8_TABLE_ID, size, 1);
}

/* get table bank parameters for sample9 */
int soc_sbx_g3p1_sample9_bank_params_get(int unit, int bank,
                soc_sbx_g3p1_table_bank_params_t *p)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_SAMPLE9_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for sample9 */
int soc_sbx_g3p1_sample9_table_size_get(int unit)
{
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[SOC_SBX_G3P1_SAMPLE9_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for sample9 */
int soc_sbx_g3p1_sample9_table_size_set(int unit, int size)
{
    return soc_sbx_g3p1_generic_table_size_set(unit,
                     SOC_SBX_G3P1_SAMPLE9_TABLE_ID, size, 1);
}

 
/*
 * Table entry accessors
 */
/**
New entry set accessor implementation for qos
*/
int soc_sbx_g3p1_qos_data_set(int unit,
                    int ide ,  int ipri ,  int iprof  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_qos_t entry;

    soc_sbx_g3p1_qos_t_init(&entry);
    s = soc_sbx_g3p1_qos_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_qos_set(unit,   ide ,  ipri ,  iprof  , &entry);

    return s;
}

/**
New entry get accessor implementation for qos
*/
int soc_sbx_g3p1_qos_data_get(int unit,
                    int ide ,  int ipri ,  int iprof  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_qos_t entry;

    soc_sbx_g3p1_qos_t_init(&entry);
    s = soc_sbx_g3p1_qos_get(unit,   ide ,  ipri ,  iprof  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_qos_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for qos
 */

void soc_sbx_g3p1_qos_t_init(
    soc_sbx_g3p1_qos_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_qos_t));
}

/* entry pack accessor implementation for qos */
int soc_sbx_g3p1_qos_pack(int unit,
    soc_sbx_g3p1_qos_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_QOS_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->e; break;
        case 1: p = (uint8 *) &e->dp; break;
        case 2: p = (uint8 *) &e->cos; break;
        case 3: p = (uint8 *) &e->fcos; break;
        case 4: p = (uint8 *) &e->mefcos; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for qos */
int soc_sbx_g3p1_qos_unpack(int unit,
                soc_sbx_g3p1_qos_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_QOS_ID];
    int be = tm->behost;
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->e; break;
        case 1: p = (uint8 *) &e->dp; break;
        case 2: p = (uint8 *) &e->cos; break;
        case 3: p = (uint8 *) &e->fcos; break;
        case 4: p = (uint8 *) &e->mefcos; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for qos */
int soc_sbx_g3p1_qos_index_check(int unit,
                int *vindex,
                  int ide ,  int ipri ,  int iprof  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_QOS_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ide; break;
        case 1: p = (uint8 *) &ipri; break;
        case 2: p = (uint8 *) &iprof; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for qos */
int soc_sbx_g3p1_qos_entry_check(int unit,
                soc_sbx_g3p1_qos_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_QOS_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->e; break;
        case 1: ev = e->dp; break;
        case 2: ev = e->cos; break;
        case 3: ev = e->fcos; break;
        case 4: ev = e->mefcos; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* qos table size get */
int soc_sbx_g3p1_qos_entry_table_size_get(int unit,
                int *tsize,
                  int ide ,  int ipri ,  int iprof  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_QOS_ID];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ide; break;
        case 1: v = ipri; break;
        case 2: v = iprof; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for qos */
int soc_sbx_g3p1_qos_set(int unit,
                  int ide ,  int ipri ,  int iprof  ,
                soc_sbx_g3p1_qos_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_QOS_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_g3p1_qos_index_check(unit, key,
                  ide ,  ipri ,  iprof  );
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_qos_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g3p1_qos_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for qos */
int soc_sbx_g3p1_qos_get(int unit,
                  int ide ,  int ipri ,  int iprof  ,
                soc_sbx_g3p1_qos_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_QOS_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_g3p1_qos_index_check(unit, key,
                  ide ,  ipri ,  iprof  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g3p1_qos_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for dscpqos
*/
int soc_sbx_g3p1_dscpqos_data_set(int unit,
                    int idscp ,  int iprof  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_dscpqos_t entry;

    soc_sbx_g3p1_dscpqos_t_init(&entry);
    s = soc_sbx_g3p1_dscpqos_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_dscpqos_set(unit,   idscp ,  iprof  , &entry);

    return s;
}

/**
New entry get accessor implementation for dscpqos
*/
int soc_sbx_g3p1_dscpqos_data_get(int unit,
                    int idscp ,  int iprof  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_dscpqos_t entry;

    soc_sbx_g3p1_dscpqos_t_init(&entry);
    s = soc_sbx_g3p1_dscpqos_get(unit,   idscp ,  iprof  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_dscpqos_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for dscpqos
 */

void soc_sbx_g3p1_dscpqos_t_init(
    soc_sbx_g3p1_dscpqos_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_dscpqos_t));
}

/* entry pack accessor implementation for dscpqos */
int soc_sbx_g3p1_dscpqos_pack(int unit,
    soc_sbx_g3p1_dscpqos_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_DSCPQOS_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->e; break;
        case 1: p = (uint8 *) &e->dp; break;
        case 2: p = (uint8 *) &e->cos; break;
        case 3: p = (uint8 *) &e->fcos; break;
        case 4: p = (uint8 *) &e->mefcos; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for dscpqos */
int soc_sbx_g3p1_dscpqos_unpack(int unit,
                soc_sbx_g3p1_dscpqos_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_DSCPQOS_ID];
    int be = tm->behost;
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->e; break;
        case 1: p = (uint8 *) &e->dp; break;
        case 2: p = (uint8 *) &e->cos; break;
        case 3: p = (uint8 *) &e->fcos; break;
        case 4: p = (uint8 *) &e->mefcos; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for dscpqos */
int soc_sbx_g3p1_dscpqos_index_check(int unit,
                int *vindex,
                  int idscp ,  int iprof  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_DSCPQOS_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &idscp; break;
        case 1: p = (uint8 *) &iprof; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for dscpqos */
int soc_sbx_g3p1_dscpqos_entry_check(int unit,
                soc_sbx_g3p1_dscpqos_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_DSCPQOS_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->e; break;
        case 1: ev = e->dp; break;
        case 2: ev = e->cos; break;
        case 3: ev = e->fcos; break;
        case 4: ev = e->mefcos; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* dscpqos table size get */
int soc_sbx_g3p1_dscpqos_entry_table_size_get(int unit,
                int *tsize,
                  int idscp ,  int iprof  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_DSCPQOS_ID];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = idscp; break;
        case 1: v = iprof; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for dscpqos */
int soc_sbx_g3p1_dscpqos_set(int unit,
                  int idscp ,  int iprof  ,
                soc_sbx_g3p1_dscpqos_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_DSCPQOS_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_g3p1_dscpqos_index_check(unit, key,
                  idscp ,  iprof  );
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_dscpqos_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g3p1_dscpqos_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for dscpqos */
int soc_sbx_g3p1_dscpqos_get(int unit,
                  int idscp ,  int iprof  ,
                soc_sbx_g3p1_dscpqos_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_DSCPQOS_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_g3p1_dscpqos_index_check(unit, key,
                  idscp ,  iprof  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g3p1_dscpqos_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for irt
*/
int soc_sbx_g3p1_irt_data_set(int unit,
                    int iirule  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_irt_t entry;

    soc_sbx_g3p1_irt_t_init(&entry);
    s = soc_sbx_g3p1_irt_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_irt_set(unit,   iirule  , &entry);

    return s;
}

/**
New entry get accessor implementation for irt
*/
int soc_sbx_g3p1_irt_data_get(int unit,
                    int iirule  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_irt_t entry;

    soc_sbx_g3p1_irt_t_init(&entry);
    s = soc_sbx_g3p1_irt_get(unit,   iirule  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_irt_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for irt
 */

void soc_sbx_g3p1_irt_t_init(
    soc_sbx_g3p1_irt_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_irt_t));
}

/* entry pack accessor implementation for irt */
int soc_sbx_g3p1_irt_pack(int unit,
    soc_sbx_g3p1_irt_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_IRT_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->vlan; break;
        case 1: p = (uint8 *) &e->ftidx; break;
        case 2: p = (uint8 *) &e->mirror; break;
        case 3: p = (uint8 *) &e->usevlan; break;
        case 4: p = (uint8 *) &e->useftidx; break;
        case 5: p = (uint8 *) &e->copy; break;
        case 6: p = (uint8 *) &e->dp; break;
        case 7: p = (uint8 *) &e->cos; break;
        case 8: p = (uint8 *) &e->fcos; break;
        case 9: p = (uint8 *) &e->usedp; break;
        case 10: p = (uint8 *) &e->usecos; break;
        case 11: p = (uint8 *) &e->policer; break;
        case 12: p = (uint8 *) &e->typedpolice; break;
        case 13: p = (uint8 *) &e->mefcos; break;
        case 14: p = (uint8 *) &e->mef; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for irt */
int soc_sbx_g3p1_irt_unpack(int unit,
                soc_sbx_g3p1_irt_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_IRT_ID];
    int be = tm->behost;
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->vlan; break;
        case 1: p = (uint8 *) &e->ftidx; break;
        case 2: p = (uint8 *) &e->mirror; break;
        case 3: p = (uint8 *) &e->usevlan; break;
        case 4: p = (uint8 *) &e->useftidx; break;
        case 5: p = (uint8 *) &e->copy; break;
        case 6: p = (uint8 *) &e->dp; break;
        case 7: p = (uint8 *) &e->cos; break;
        case 8: p = (uint8 *) &e->fcos; break;
        case 9: p = (uint8 *) &e->usedp; break;
        case 10: p = (uint8 *) &e->usecos; break;
        case 11: p = (uint8 *) &e->policer; break;
        case 12: p = (uint8 *) &e->typedpolice; break;
        case 13: p = (uint8 *) &e->mefcos; break;
        case 14: p = (uint8 *) &e->mef; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for irt */
int soc_sbx_g3p1_irt_index_check(int unit,
                int *vindex,
                  int iirule  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_IRT_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iirule; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for irt */
int soc_sbx_g3p1_irt_entry_check(int unit,
                soc_sbx_g3p1_irt_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_IRT_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->vlan; break;
        case 1: ev = e->ftidx; break;
        case 2: ev = e->mirror; break;
        case 3: ev = e->usevlan; break;
        case 4: ev = e->useftidx; break;
        case 5: ev = e->copy; break;
        case 6: ev = e->dp; break;
        case 7: ev = e->cos; break;
        case 8: ev = e->fcos; break;
        case 9: ev = e->usedp; break;
        case 10: ev = e->usecos; break;
        case 11: ev = e->policer; break;
        case 12: ev = e->typedpolice; break;
        case 13: ev = e->mefcos; break;
        case 14: ev = e->mef; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* irt table size get */
int soc_sbx_g3p1_irt_entry_table_size_get(int unit,
                int *tsize,
                  int iirule  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_IRT_ID];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iirule; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for irt */
int soc_sbx_g3p1_irt_set(int unit,
                  int iirule  ,
                soc_sbx_g3p1_irt_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_IRT_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_g3p1_irt_index_check(unit, key,
                  iirule  );
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_irt_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g3p1_irt_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for irt */
int soc_sbx_g3p1_irt_get(int unit,
                  int iirule  ,
                soc_sbx_g3p1_irt_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_IRT_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_g3p1_irt_index_check(unit, key,
                  iirule  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g3p1_irt_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for lag
*/
int soc_sbx_g3p1_lag_data_set(int unit,
                    int ilagi  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_lag_t entry;

    soc_sbx_g3p1_lag_t_init(&entry);
    s = soc_sbx_g3p1_lag_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_lag_set(unit,   ilagi  , &entry);

    return s;
}

/**
New entry get accessor implementation for lag
*/
int soc_sbx_g3p1_lag_data_get(int unit,
                    int ilagi  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_lag_t entry;

    soc_sbx_g3p1_lag_t_init(&entry);
    s = soc_sbx_g3p1_lag_get(unit,   ilagi  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_lag_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for lag
 */

void soc_sbx_g3p1_lag_t_init(
    soc_sbx_g3p1_lag_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_lag_t));
}

/* entry pack accessor implementation for lag */
int soc_sbx_g3p1_lag_pack(int unit,
    soc_sbx_g3p1_lag_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_LAG_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->qid; break;
        case 1: p = (uint8 *) &e->oi; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for lag */
int soc_sbx_g3p1_lag_unpack(int unit,
                soc_sbx_g3p1_lag_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_LAG_ID];
    int be = tm->behost;
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->qid; break;
        case 1: p = (uint8 *) &e->oi; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for lag */
int soc_sbx_g3p1_lag_index_check(int unit,
                int *vindex,
                  int ilagi  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_LAG_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ilagi; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for lag */
int soc_sbx_g3p1_lag_entry_check(int unit,
                soc_sbx_g3p1_lag_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_LAG_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->qid; break;
        case 1: ev = e->oi; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* lag table size get */
int soc_sbx_g3p1_lag_entry_table_size_get(int unit,
                int *tsize,
                  int ilagi  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_LAG_ID];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ilagi; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for lag */
int soc_sbx_g3p1_lag_set(int unit,
                  int ilagi  ,
                soc_sbx_g3p1_lag_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_LAG_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_g3p1_lag_index_check(unit, key,
                  ilagi  );
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_lag_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g3p1_lag_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for lag */
int soc_sbx_g3p1_lag_get(int unit,
                  int ilagi  ,
                soc_sbx_g3p1_lag_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_LAG_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_g3p1_lag_index_check(unit, key,
                  ilagi  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g3p1_lag_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for rrt
*/
int soc_sbx_g3p1_rrt_data_set(int unit,
                    int irri  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_rrt_t entry;

    soc_sbx_g3p1_rrt_t_init(&entry);
    s = soc_sbx_g3p1_rrt_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_rrt_set(unit,   irri  , &entry);

    return s;
}

/**
New entry get accessor implementation for rrt
*/
int soc_sbx_g3p1_rrt_data_get(int unit,
                    int irri  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_rrt_t entry;

    soc_sbx_g3p1_rrt_t_init(&entry);
    s = soc_sbx_g3p1_rrt_get(unit,   irri  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_rrt_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for rrt
 */

void soc_sbx_g3p1_rrt_t_init(
    soc_sbx_g3p1_rrt_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_rrt_t));
}

/* entry pack accessor implementation for rrt */
int soc_sbx_g3p1_rrt_pack(int unit,
    soc_sbx_g3p1_rrt_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_RRT_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->backup; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for rrt */
int soc_sbx_g3p1_rrt_unpack(int unit,
                soc_sbx_g3p1_rrt_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_RRT_ID];
    int be = tm->behost;
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->backup; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for rrt */
int soc_sbx_g3p1_rrt_index_check(int unit,
                int *vindex,
                  int irri  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_RRT_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &irri; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for rrt */
int soc_sbx_g3p1_rrt_entry_check(int unit,
                soc_sbx_g3p1_rrt_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_RRT_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->backup; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* rrt table size get */
int soc_sbx_g3p1_rrt_entry_table_size_get(int unit,
                int *tsize,
                  int irri  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_RRT_ID];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = irri; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for rrt */
int soc_sbx_g3p1_rrt_set(int unit,
                  int irri  ,
                soc_sbx_g3p1_rrt_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_RRT_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_g3p1_rrt_index_check(unit, key,
                  irri  );
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_rrt_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g3p1_rrt_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for rrt */
int soc_sbx_g3p1_rrt_get(int unit,
                  int irri  ,
                soc_sbx_g3p1_rrt_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_RRT_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_g3p1_rrt_index_check(unit, key,
                  irri  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g3p1_rrt_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for xt
*/
int soc_sbx_g3p1_xt_data_set(int unit,
                    int ixi  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_xt_t entry;

    soc_sbx_g3p1_xt_t_init(&entry);
    s = soc_sbx_g3p1_xt_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_xt_set(unit,   ixi  , &entry);

    return s;
}

/**
New entry get accessor implementation for xt
*/
int soc_sbx_g3p1_xt_data_get(int unit,
                    int ixi  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_xt_t entry;

    soc_sbx_g3p1_xt_t_init(&entry);
    s = soc_sbx_g3p1_xt_get(unit,   ixi  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_xt_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for xt
 */

void soc_sbx_g3p1_xt_t_init(
    soc_sbx_g3p1_xt_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_xt_t));
}

/* entry pack accessor implementation for xt */
int soc_sbx_g3p1_xt_pack(int unit,
    soc_sbx_g3p1_xt_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_XT_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->forward; break;
        case 1: p = (uint8 *) &e->dp; break;
        case 2: p = (uint8 *) &e->qid; break;
        case 3: p = (uint8 *) &e->fwdid; break;
        case 4: p = (uint8 *) &e->trunc; break;
        case 5: p = (uint8 *) &e->learn; break;
        case 6: p = (uint8 *) &e->ppspolice; break;
        case 7: p = (uint8 *) &e->policer; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for xt */
int soc_sbx_g3p1_xt_unpack(int unit,
                soc_sbx_g3p1_xt_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_XT_ID];
    int be = tm->behost;
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->forward; break;
        case 1: p = (uint8 *) &e->dp; break;
        case 2: p = (uint8 *) &e->qid; break;
        case 3: p = (uint8 *) &e->fwdid; break;
        case 4: p = (uint8 *) &e->trunc; break;
        case 5: p = (uint8 *) &e->learn; break;
        case 6: p = (uint8 *) &e->ppspolice; break;
        case 7: p = (uint8 *) &e->policer; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for xt */
int soc_sbx_g3p1_xt_index_check(int unit,
                int *vindex,
                  int ixi  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_XT_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ixi; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for xt */
int soc_sbx_g3p1_xt_entry_check(int unit,
                soc_sbx_g3p1_xt_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_XT_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->forward; break;
        case 1: ev = e->dp; break;
        case 2: ev = e->qid; break;
        case 3: ev = e->fwdid; break;
        case 4: ev = e->trunc; break;
        case 5: ev = e->learn; break;
        case 6: ev = e->ppspolice; break;
        case 7: ev = e->policer; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* xt table size get */
int soc_sbx_g3p1_xt_entry_table_size_get(int unit,
                int *tsize,
                  int ixi  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_XT_ID];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ixi; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for xt */
int soc_sbx_g3p1_xt_set(int unit,
                  int ixi  ,
                soc_sbx_g3p1_xt_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_XT_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_g3p1_xt_index_check(unit, key,
                  ixi  );
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_xt_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g3p1_xt_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for xt */
int soc_sbx_g3p1_xt_get(int unit,
                  int ixi  ,
                soc_sbx_g3p1_xt_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_XT_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_g3p1_xt_index_check(unit, key,
                  ixi  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g3p1_xt_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for mirror
*/
int soc_sbx_g3p1_mirror_data_set(int unit,
                    int imi  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_mirror_t entry;

    soc_sbx_g3p1_mirror_t_init(&entry);
    s = soc_sbx_g3p1_mirror_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_mirror_set(unit,   imi  , &entry);

    return s;
}

/**
New entry get accessor implementation for mirror
*/
int soc_sbx_g3p1_mirror_data_get(int unit,
                    int imi  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_mirror_t entry;

    soc_sbx_g3p1_mirror_t_init(&entry);
    s = soc_sbx_g3p1_mirror_get(unit,   imi  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_mirror_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for mirror
 */

void soc_sbx_g3p1_mirror_t_init(
    soc_sbx_g3p1_mirror_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_mirror_t));
}

/* entry pack accessor implementation for mirror */
int soc_sbx_g3p1_mirror_pack(int unit,
    soc_sbx_g3p1_mirror_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_MIRROR_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->yellow; break;
        case 1: p = (uint8 *) &e->qid; break;
        case 2: p = (uint8 *) &e->oi; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for mirror */
int soc_sbx_g3p1_mirror_unpack(int unit,
                soc_sbx_g3p1_mirror_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_MIRROR_ID];
    int be = tm->behost;
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->yellow; break;
        case 1: p = (uint8 *) &e->qid; break;
        case 2: p = (uint8 *) &e->oi; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for mirror */
int soc_sbx_g3p1_mirror_index_check(int unit,
                int *vindex,
                  int imi  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_MIRROR_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &imi; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for mirror */
int soc_sbx_g3p1_mirror_entry_check(int unit,
                soc_sbx_g3p1_mirror_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_MIRROR_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->yellow; break;
        case 1: ev = e->qid; break;
        case 2: ev = e->oi; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* mirror table size get */
int soc_sbx_g3p1_mirror_entry_table_size_get(int unit,
                int *tsize,
                  int imi  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_MIRROR_ID];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = imi; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for mirror */
int soc_sbx_g3p1_mirror_set(int unit,
                  int imi  ,
                soc_sbx_g3p1_mirror_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_MIRROR_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_g3p1_mirror_index_check(unit, key,
                  imi  );
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_mirror_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g3p1_mirror_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for mirror */
int soc_sbx_g3p1_mirror_get(int unit,
                  int imi  ,
                soc_sbx_g3p1_mirror_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_MIRROR_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_g3p1_mirror_index_check(unit, key,
                  imi  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g3p1_mirror_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for emirror
*/
int soc_sbx_g3p1_emirror_data_set(int unit,
                    int imi  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_emirror_t entry;

    soc_sbx_g3p1_emirror_t_init(&entry);
    s = soc_sbx_g3p1_emirror_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_emirror_set(unit,   imi  , &entry);

    return s;
}

/**
New entry get accessor implementation for emirror
*/
int soc_sbx_g3p1_emirror_data_get(int unit,
                    int imi  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_emirror_t entry;

    soc_sbx_g3p1_emirror_t_init(&entry);
    s = soc_sbx_g3p1_emirror_get(unit,   imi  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_emirror_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for emirror
 */

void soc_sbx_g3p1_emirror_t_init(
    soc_sbx_g3p1_emirror_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_emirror_t));
}

/* entry pack accessor implementation for emirror */
int soc_sbx_g3p1_emirror_pack(int unit,
    soc_sbx_g3p1_emirror_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_EMIRROR_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->yellow; break;
        case 1: p = (uint8 *) &e->qid; break;
        case 2: p = (uint8 *) &e->oi; break;
        case 3: p = (uint8 *) &e->dqueue; break;
        case 4: p = (uint8 *) &e->local; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for emirror */
int soc_sbx_g3p1_emirror_unpack(int unit,
                soc_sbx_g3p1_emirror_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_EMIRROR_ID];
    int be = tm->behost;
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->yellow; break;
        case 1: p = (uint8 *) &e->qid; break;
        case 2: p = (uint8 *) &e->oi; break;
        case 3: p = (uint8 *) &e->dqueue; break;
        case 4: p = (uint8 *) &e->local; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for emirror */
int soc_sbx_g3p1_emirror_index_check(int unit,
                int *vindex,
                  int imi  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_EMIRROR_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &imi; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for emirror */
int soc_sbx_g3p1_emirror_entry_check(int unit,
                soc_sbx_g3p1_emirror_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_EMIRROR_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->yellow; break;
        case 1: ev = e->qid; break;
        case 2: ev = e->oi; break;
        case 3: ev = e->dqueue; break;
        case 4: ev = e->local; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* emirror table size get */
int soc_sbx_g3p1_emirror_entry_table_size_get(int unit,
                int *tsize,
                  int imi  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_EMIRROR_ID];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = imi; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for emirror */
int soc_sbx_g3p1_emirror_set(int unit,
                  int imi  ,
                soc_sbx_g3p1_emirror_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_EMIRROR_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_g3p1_emirror_index_check(unit, key,
                  imi  );
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_emirror_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g3p1_emirror_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for emirror */
int soc_sbx_g3p1_emirror_get(int unit,
                  int imi  ,
                soc_sbx_g3p1_emirror_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_EMIRROR_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_g3p1_emirror_index_check(unit, key,
                  imi  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g3p1_emirror_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for macage
*/
int soc_sbx_g3p1_macage_data_set(int unit,
                    int imacindex  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_macage_t entry;

    soc_sbx_g3p1_macage_t_init(&entry);
    s = soc_sbx_g3p1_macage_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_macage_set(unit,   imacindex  , &entry);

    return s;
}

/**
New entry get accessor implementation for macage
*/
int soc_sbx_g3p1_macage_data_get(int unit,
                    int imacindex  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_macage_t entry;

    soc_sbx_g3p1_macage_t_init(&entry);
    s = soc_sbx_g3p1_macage_get(unit,   imacindex  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_macage_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for macage
 */

void soc_sbx_g3p1_macage_t_init(
    soc_sbx_g3p1_macage_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_macage_t));
}

/* entry pack accessor implementation for macage */
int soc_sbx_g3p1_macage_pack(int unit,
    soc_sbx_g3p1_macage_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_MACAGE_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->age; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for macage */
int soc_sbx_g3p1_macage_unpack(int unit,
                soc_sbx_g3p1_macage_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_MACAGE_ID];
    int be = tm->behost;
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->age; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for macage */
int soc_sbx_g3p1_macage_index_check(int unit,
                int *vindex,
                  int imacindex  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_MACAGE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &imacindex; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for macage */
int soc_sbx_g3p1_macage_entry_check(int unit,
                soc_sbx_g3p1_macage_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_MACAGE_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->age; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* macage table size get */
int soc_sbx_g3p1_macage_entry_table_size_get(int unit,
                int *tsize,
                  int imacindex  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_MACAGE_ID];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = imacindex; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for macage */
int soc_sbx_g3p1_macage_set(int unit,
                  int imacindex  ,
                soc_sbx_g3p1_macage_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_MACAGE_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_g3p1_macage_index_check(unit, key,
                  imacindex  );
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_macage_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g3p1_macage_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for macage */
int soc_sbx_g3p1_macage_get(int unit,
                  int imacindex  ,
                soc_sbx_g3p1_macage_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_MACAGE_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_g3p1_macage_index_check(unit, key,
                  imacindex  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g3p1_macage_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for mst
*/
int soc_sbx_g3p1_mst_data_set(int unit,
                    int imsti  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_mst_t entry;

    soc_sbx_g3p1_mst_t_init(&entry);
    s = soc_sbx_g3p1_mst_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_mst_set(unit,   imsti  , &entry);

    return s;
}

/**
New entry get accessor implementation for mst
*/
int soc_sbx_g3p1_mst_data_get(int unit,
                    int imsti  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_mst_t entry;

    soc_sbx_g3p1_mst_t_init(&entry);
    s = soc_sbx_g3p1_mst_get(unit,   imsti  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_mst_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for mst
 */

void soc_sbx_g3p1_mst_t_init(
    soc_sbx_g3p1_mst_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_mst_t));
}

/* entry pack accessor implementation for mst */
int soc_sbx_g3p1_mst_pack(int unit,
    soc_sbx_g3p1_mst_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_MST_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->learn; break;
        case 1: p = (uint8 *) &e->pim; break;
        case 2: p = (uint8 *) &e->igmp; break;
        case 3: p = (uint8 *) &e->rtcopy; break;
        case 4: p = (uint8 *) &e->l2cpcopy; break;
        case 5: p = (uint8 *) &e->dcopy; break;
        case 6: p = (uint8 *) &e->ipredirect; break;
        case 7: p = (uint8 *) &e->learn_bmac; break;
        case 8: p = (uint8 *) &e->mirroridx; break;
        case 9: p = (uint8 *) &e->vsi; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for mst */
int soc_sbx_g3p1_mst_unpack(int unit,
                soc_sbx_g3p1_mst_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_MST_ID];
    int be = tm->behost;
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->learn; break;
        case 1: p = (uint8 *) &e->pim; break;
        case 2: p = (uint8 *) &e->igmp; break;
        case 3: p = (uint8 *) &e->rtcopy; break;
        case 4: p = (uint8 *) &e->l2cpcopy; break;
        case 5: p = (uint8 *) &e->dcopy; break;
        case 6: p = (uint8 *) &e->ipredirect; break;
        case 7: p = (uint8 *) &e->learn_bmac; break;
        case 8: p = (uint8 *) &e->mirroridx; break;
        case 9: p = (uint8 *) &e->vsi; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for mst */
int soc_sbx_g3p1_mst_index_check(int unit,
                int *vindex,
                  int imsti  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_MST_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &imsti; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for mst */
int soc_sbx_g3p1_mst_entry_check(int unit,
                soc_sbx_g3p1_mst_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_MST_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->learn; break;
        case 1: ev = e->pim; break;
        case 2: ev = e->igmp; break;
        case 3: ev = e->rtcopy; break;
        case 4: ev = e->l2cpcopy; break;
        case 5: ev = e->dcopy; break;
        case 6: ev = e->ipredirect; break;
        case 7: ev = e->learn_bmac; break;
        case 8: ev = e->mirroridx; break;
        case 9: ev = e->vsi; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* mst table size get */
int soc_sbx_g3p1_mst_entry_table_size_get(int unit,
                int *tsize,
                  int imsti  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_MST_ID];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = imsti; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for mst */
int soc_sbx_g3p1_mst_set(int unit,
                  int imsti  ,
                soc_sbx_g3p1_mst_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_MST_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_g3p1_mst_index_check(unit, key,
                  imsti  );
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_mst_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g3p1_mst_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for mst */
int soc_sbx_g3p1_mst_get(int unit,
                  int imsti  ,
                soc_sbx_g3p1_mst_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_MST_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_g3p1_mst_index_check(unit, key,
                  imsti  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g3p1_mst_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for pv2e
*/
int soc_sbx_g3p1_pv2e_data_set(int unit,
                    int ivid ,  int iport  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_pv2e_t entry;

    soc_sbx_g3p1_pv2e_t_init(&entry);
    s = soc_sbx_g3p1_pv2e_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_pv2e_set(unit,   ivid ,  iport  , &entry);

    return s;
}

/**
New entry get accessor implementation for pv2e
*/
int soc_sbx_g3p1_pv2e_data_get(int unit,
                    int ivid ,  int iport  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_pv2e_t entry;

    soc_sbx_g3p1_pv2e_t_init(&entry);
    s = soc_sbx_g3p1_pv2e_get(unit,   ivid ,  iport  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_pv2e_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for pv2e
 */

void soc_sbx_g3p1_pv2e_t_init(
    soc_sbx_g3p1_pv2e_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_pv2e_t));
}

/* entry pack accessor implementation for pv2e */
int soc_sbx_g3p1_pv2e_pack(int unit,
    soc_sbx_g3p1_pv2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PV2E_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->lpi; break;
        case 1: p = (uint8 *) &e->vlan; break;
        case 2: p = (uint8 *) &e->stpstate; break;
        case 3: p = (uint8 *) &e->vpws; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for pv2e */
int soc_sbx_g3p1_pv2e_unpack(int unit,
                soc_sbx_g3p1_pv2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PV2E_ID];
    int be = tm->behost;
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->lpi; break;
        case 1: p = (uint8 *) &e->vlan; break;
        case 2: p = (uint8 *) &e->stpstate; break;
        case 3: p = (uint8 *) &e->vpws; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for pv2e */
int soc_sbx_g3p1_pv2e_index_check(int unit,
                int *vindex,
                  int ivid ,  int iport  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PV2E_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ivid; break;
        case 1: p = (uint8 *) &iport; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for pv2e */
int soc_sbx_g3p1_pv2e_entry_check(int unit,
                soc_sbx_g3p1_pv2e_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PV2E_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->lpi; break;
        case 1: ev = e->vlan; break;
        case 2: ev = e->stpstate; break;
        case 3: ev = e->vpws; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* pv2e table size get */
int soc_sbx_g3p1_pv2e_entry_table_size_get(int unit,
                int *tsize,
                  int ivid ,  int iport  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PV2E_ID];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ivid; break;
        case 1: v = iport; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for pv2e */
int soc_sbx_g3p1_pv2e_set(int unit,
                  int ivid ,  int iport  ,
                soc_sbx_g3p1_pv2e_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PV2E_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_g3p1_pv2e_index_check(unit, key,
                  ivid ,  iport  );
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_pv2e_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g3p1_pv2e_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for pv2e */
int soc_sbx_g3p1_pv2e_get(int unit,
                  int ivid ,  int iport  ,
                soc_sbx_g3p1_pv2e_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PV2E_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_g3p1_pv2e_index_check(unit, key,
                  ivid ,  iport  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g3p1_pv2e_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for p2appdata
*/
int soc_sbx_g3p1_p2appdata_data_set(int unit,
                    int iport  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_p2appdata_t entry;

    soc_sbx_g3p1_p2appdata_t_init(&entry);
    s = soc_sbx_g3p1_p2appdata_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_p2appdata_set(unit,   iport  , &entry);

    return s;
}

/**
New entry get accessor implementation for p2appdata
*/
int soc_sbx_g3p1_p2appdata_data_get(int unit,
                    int iport  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_p2appdata_t entry;

    soc_sbx_g3p1_p2appdata_t_init(&entry);
    s = soc_sbx_g3p1_p2appdata_get(unit,   iport  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_p2appdata_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for p2appdata
 */

void soc_sbx_g3p1_p2appdata_t_init(
    soc_sbx_g3p1_p2appdata_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_p2appdata_t));
}

/* entry pack accessor implementation for p2appdata */
int soc_sbx_g3p1_p2appdata_pack(int unit,
    soc_sbx_g3p1_p2appdata_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_P2APPDATA_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ifilteren; break;
        case 1: p = (uint8 *) &e->efilteren; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for p2appdata */
int soc_sbx_g3p1_p2appdata_unpack(int unit,
                soc_sbx_g3p1_p2appdata_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_P2APPDATA_ID];
    int be = tm->behost;
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ifilteren; break;
        case 1: p = (uint8 *) &e->efilteren; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for p2appdata */
int soc_sbx_g3p1_p2appdata_index_check(int unit,
                int *vindex,
                  int iport  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_P2APPDATA_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iport; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for p2appdata */
int soc_sbx_g3p1_p2appdata_entry_check(int unit,
                soc_sbx_g3p1_p2appdata_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_P2APPDATA_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->ifilteren; break;
        case 1: ev = e->efilteren; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* p2appdata table size get */
int soc_sbx_g3p1_p2appdata_entry_table_size_get(int unit,
                int *tsize,
                  int iport  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_P2APPDATA_ID];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iport; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for p2appdata */
int soc_sbx_g3p1_p2appdata_set(int unit,
                  int iport  ,
                soc_sbx_g3p1_p2appdata_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_P2APPDATA_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_g3p1_p2appdata_index_check(unit, key,
                  iport  );
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_p2appdata_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g3p1_p2appdata_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for p2appdata */
int soc_sbx_g3p1_p2appdata_get(int unit,
                  int iport  ,
                soc_sbx_g3p1_p2appdata_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_P2APPDATA_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_g3p1_p2appdata_index_check(unit, key,
                  iport  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g3p1_p2appdata_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for pv2appdata
*/
int soc_sbx_g3p1_pv2appdata_data_set(int unit,
                    int ivid ,  int iport  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_pv2appdata_t entry;

    soc_sbx_g3p1_pv2appdata_t_init(&entry);
    s = soc_sbx_g3p1_pv2appdata_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_pv2appdata_set(unit,   ivid ,  iport  , &entry);

    return s;
}

/**
New entry get accessor implementation for pv2appdata
*/
int soc_sbx_g3p1_pv2appdata_data_get(int unit,
                    int ivid ,  int iport  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_pv2appdata_t entry;

    soc_sbx_g3p1_pv2appdata_t_init(&entry);
    s = soc_sbx_g3p1_pv2appdata_get(unit,   ivid ,  iport  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_pv2appdata_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for pv2appdata
 */

void soc_sbx_g3p1_pv2appdata_t_init(
    soc_sbx_g3p1_pv2appdata_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_pv2appdata_t));
}

/* entry pack accessor implementation for pv2appdata */
int soc_sbx_g3p1_pv2appdata_pack(int unit,
    soc_sbx_g3p1_pv2appdata_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PV2APPDATA_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->member; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for pv2appdata */
int soc_sbx_g3p1_pv2appdata_unpack(int unit,
                soc_sbx_g3p1_pv2appdata_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PV2APPDATA_ID];
    int be = tm->behost;
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->member; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for pv2appdata */
int soc_sbx_g3p1_pv2appdata_index_check(int unit,
                int *vindex,
                  int ivid ,  int iport  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PV2APPDATA_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ivid; break;
        case 1: p = (uint8 *) &iport; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for pv2appdata */
int soc_sbx_g3p1_pv2appdata_entry_check(int unit,
                soc_sbx_g3p1_pv2appdata_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PV2APPDATA_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->member; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* pv2appdata table size get */
int soc_sbx_g3p1_pv2appdata_entry_table_size_get(int unit,
                int *tsize,
                  int ivid ,  int iport  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PV2APPDATA_ID];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ivid; break;
        case 1: v = iport; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for pv2appdata */
int soc_sbx_g3p1_pv2appdata_set(int unit,
                  int ivid ,  int iport  ,
                soc_sbx_g3p1_pv2appdata_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PV2APPDATA_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_g3p1_pv2appdata_index_check(unit, key,
                  ivid ,  iport  );
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_pv2appdata_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g3p1_pv2appdata_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for pv2appdata */
int soc_sbx_g3p1_pv2appdata_get(int unit,
                  int ivid ,  int iport  ,
                soc_sbx_g3p1_pv2appdata_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PV2APPDATA_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_g3p1_pv2appdata_index_check(unit, key,
                  ivid ,  iport  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g3p1_pv2appdata_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for pvv2edata
*/
int soc_sbx_g3p1_pvv2edata_data_set(int unit,
                    int ipvv2eindex  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_pvv2edata_t entry;

    soc_sbx_g3p1_pvv2edata_t_init(&entry);
    s = soc_sbx_g3p1_pvv2edata_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_pvv2edata_set(unit,   ipvv2eindex  , &entry);

    return s;
}

/**
New entry get accessor implementation for pvv2edata
*/
int soc_sbx_g3p1_pvv2edata_data_get(int unit,
                    int ipvv2eindex  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_pvv2edata_t entry;

    soc_sbx_g3p1_pvv2edata_t_init(&entry);
    s = soc_sbx_g3p1_pvv2edata_get(unit,   ipvv2eindex  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_pvv2edata_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for pvv2edata
 */

void soc_sbx_g3p1_pvv2edata_t_init(
    soc_sbx_g3p1_pvv2edata_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_pvv2edata_t));
}

/* entry pack accessor implementation for pvv2edata */
int soc_sbx_g3p1_pvv2edata_pack(int unit,
    soc_sbx_g3p1_pvv2edata_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PVV2EDATA_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->vpws; break;
        case 1: p = (uint8 *) &e->stpstate; break;
        case 2: p = (uint8 *) &e->vlan; break;
        case 3: p = (uint8 *) &e->lpi; break;
        case 4: p = (uint8 *) &e->hit; break;
        case 5: p = (uint8 *) &e->keeporstrip; break;
        case 6: p = (uint8 *) &e->replace; break;
        case 7: p = (uint8 *) &e->vid; break;
        case 8: p = (uint8 *) &e->vidop; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for pvv2edata */
int soc_sbx_g3p1_pvv2edata_unpack(int unit,
                soc_sbx_g3p1_pvv2edata_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PVV2EDATA_ID];
    int be = tm->behost;
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->vpws; break;
        case 1: p = (uint8 *) &e->stpstate; break;
        case 2: p = (uint8 *) &e->vlan; break;
        case 3: p = (uint8 *) &e->lpi; break;
        case 4: p = (uint8 *) &e->hit; break;
        case 5: p = (uint8 *) &e->keeporstrip; break;
        case 6: p = (uint8 *) &e->replace; break;
        case 7: p = (uint8 *) &e->vid; break;
        case 8: p = (uint8 *) &e->vidop; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for pvv2edata */
int soc_sbx_g3p1_pvv2edata_index_check(int unit,
                int *vindex,
                  int ipvv2eindex  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PVV2EDATA_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ipvv2eindex; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for pvv2edata */
int soc_sbx_g3p1_pvv2edata_entry_check(int unit,
                soc_sbx_g3p1_pvv2edata_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PVV2EDATA_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->vpws; break;
        case 1: ev = e->stpstate; break;
        case 2: ev = e->vlan; break;
        case 3: ev = e->lpi; break;
        case 4: ev = e->hit; break;
        case 5: ev = e->keeporstrip; break;
        case 6: ev = e->replace; break;
        case 7: ev = e->vid; break;
        case 8: ev = e->vidop; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* pvv2edata table size get */
int soc_sbx_g3p1_pvv2edata_entry_table_size_get(int unit,
                int *tsize,
                  int ipvv2eindex  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PVV2EDATA_ID];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ipvv2eindex; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for pvv2edata */
int soc_sbx_g3p1_pvv2edata_set(int unit,
                  int ipvv2eindex  ,
                soc_sbx_g3p1_pvv2edata_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PVV2EDATA_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_g3p1_pvv2edata_index_check(unit, key,
                  ipvv2eindex  );
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_pvv2edata_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g3p1_pvv2edata_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for pvv2edata */
int soc_sbx_g3p1_pvv2edata_get(int unit,
                  int ipvv2eindex  ,
                soc_sbx_g3p1_pvv2edata_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PVV2EDATA_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_g3p1_pvv2edata_index_check(unit, key,
                  ipvv2eindex  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g3p1_pvv2edata_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for v2e
*/
int soc_sbx_g3p1_v2e_data_set(int unit,
                    int ivlan  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_v2e_t entry;

    soc_sbx_g3p1_v2e_t_init(&entry);
    s = soc_sbx_g3p1_v2e_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_v2e_set(unit,   ivlan  , &entry);

    return s;
}

/**
New entry get accessor implementation for v2e
*/
int soc_sbx_g3p1_v2e_data_get(int unit,
                    int ivlan  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_v2e_t entry;

    soc_sbx_g3p1_v2e_t_init(&entry);
    s = soc_sbx_g3p1_v2e_get(unit,   ivlan  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_v2e_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for v2e
 */

void soc_sbx_g3p1_v2e_t_init(
    soc_sbx_g3p1_v2e_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_v2e_t));
}

/* entry pack accessor implementation for v2e */
int soc_sbx_g3p1_v2e_pack(int unit,
    soc_sbx_g3p1_v2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_V2E_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pim; break;
        case 1: p = (uint8 *) &e->igmp; break;
        case 2: p = (uint8 *) &e->policerbypass; break;
        case 3: p = (uint8 *) &e->forceflood; break;
        case 4: p = (uint8 *) &e->dropunksmac; break;
        case 5: p = (uint8 *) &e->dropunkucast; break;
        case 6: p = (uint8 *) &e->dontlearn; break;
        case 7: p = (uint8 *) &e->vrf; break;
        case 8: p = (uint8 *) &e->v6mc; break;
        case 9: p = (uint8 *) &e->v4mc; break;
        case 10: p = (uint8 *) &e->laghash; break;
        case 11: p = (uint8 *) &e->v4uc; break;
        case 12: p = (uint8 *) &e->v6uc; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for v2e */
int soc_sbx_g3p1_v2e_unpack(int unit,
                soc_sbx_g3p1_v2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_V2E_ID];
    int be = tm->behost;
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pim; break;
        case 1: p = (uint8 *) &e->igmp; break;
        case 2: p = (uint8 *) &e->policerbypass; break;
        case 3: p = (uint8 *) &e->forceflood; break;
        case 4: p = (uint8 *) &e->dropunksmac; break;
        case 5: p = (uint8 *) &e->dropunkucast; break;
        case 6: p = (uint8 *) &e->dontlearn; break;
        case 7: p = (uint8 *) &e->vrf; break;
        case 8: p = (uint8 *) &e->v6mc; break;
        case 9: p = (uint8 *) &e->v4mc; break;
        case 10: p = (uint8 *) &e->laghash; break;
        case 11: p = (uint8 *) &e->v4uc; break;
        case 12: p = (uint8 *) &e->v6uc; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for v2e */
int soc_sbx_g3p1_v2e_index_check(int unit,
                int *vindex,
                  int ivlan  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_V2E_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ivlan; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for v2e */
int soc_sbx_g3p1_v2e_entry_check(int unit,
                soc_sbx_g3p1_v2e_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_V2E_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->pim; break;
        case 1: ev = e->igmp; break;
        case 2: ev = e->policerbypass; break;
        case 3: ev = e->forceflood; break;
        case 4: ev = e->dropunksmac; break;
        case 5: ev = e->dropunkucast; break;
        case 6: ev = e->dontlearn; break;
        case 7: ev = e->vrf; break;
        case 8: ev = e->v6mc; break;
        case 9: ev = e->v4mc; break;
        case 10: ev = e->laghash; break;
        case 11: ev = e->v4uc; break;
        case 12: ev = e->v6uc; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* v2e table size get */
int soc_sbx_g3p1_v2e_entry_table_size_get(int unit,
                int *tsize,
                  int ivlan  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_V2E_ID];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ivlan; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for v2e */
int soc_sbx_g3p1_v2e_set(int unit,
                  int ivlan  ,
                soc_sbx_g3p1_v2e_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_V2E_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_g3p1_v2e_index_check(unit, key,
                  ivlan  );
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_v2e_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g3p1_v2e_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for v2e */
int soc_sbx_g3p1_v2e_get(int unit,
                  int ivlan  ,
                soc_sbx_g3p1_v2e_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_V2E_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_g3p1_v2e_index_check(unit, key,
                  ivlan  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g3p1_v2e_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for vrid2e
*/
int soc_sbx_g3p1_vrid2e_data_set(int unit,
                    int ivlan  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_vrid2e_t entry;

    soc_sbx_g3p1_vrid2e_t_init(&entry);
    s = soc_sbx_g3p1_vrid2e_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_vrid2e_set(unit,   ivlan  , &entry);

    return s;
}

/**
New entry get accessor implementation for vrid2e
*/
int soc_sbx_g3p1_vrid2e_data_get(int unit,
                    int ivlan  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_vrid2e_t entry;

    soc_sbx_g3p1_vrid2e_t_init(&entry);
    s = soc_sbx_g3p1_vrid2e_get(unit,   ivlan  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_vrid2e_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for vrid2e
 */

void soc_sbx_g3p1_vrid2e_t_init(
    soc_sbx_g3p1_vrid2e_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_vrid2e_t));
}

/* entry pack accessor implementation for vrid2e */
int soc_sbx_g3p1_vrid2e_pack(int unit,
    soc_sbx_g3p1_vrid2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_VRID2E_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->v4_vrid0; break;
        case 1: p = (uint8 *) &e->v4_vrid1; break;
        case 2: p = (uint8 *) &e->v6_vrid0; break;
        case 3: p = (uint8 *) &e->v6_vrid1; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for vrid2e */
int soc_sbx_g3p1_vrid2e_unpack(int unit,
                soc_sbx_g3p1_vrid2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_VRID2E_ID];
    int be = tm->behost;
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->v4_vrid0; break;
        case 1: p = (uint8 *) &e->v4_vrid1; break;
        case 2: p = (uint8 *) &e->v6_vrid0; break;
        case 3: p = (uint8 *) &e->v6_vrid1; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for vrid2e */
int soc_sbx_g3p1_vrid2e_index_check(int unit,
                int *vindex,
                  int ivlan  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_VRID2E_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ivlan; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for vrid2e */
int soc_sbx_g3p1_vrid2e_entry_check(int unit,
                soc_sbx_g3p1_vrid2e_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_VRID2E_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->v4_vrid0; break;
        case 1: ev = e->v4_vrid1; break;
        case 2: ev = e->v6_vrid0; break;
        case 3: ev = e->v6_vrid1; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* vrid2e table size get */
int soc_sbx_g3p1_vrid2e_entry_table_size_get(int unit,
                int *tsize,
                  int ivlan  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_VRID2E_ID];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ivlan; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for vrid2e */
int soc_sbx_g3p1_vrid2e_set(int unit,
                  int ivlan  ,
                soc_sbx_g3p1_vrid2e_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_VRID2E_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_g3p1_vrid2e_index_check(unit, key,
                  ivlan  );
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_vrid2e_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g3p1_vrid2e_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for vrid2e */
int soc_sbx_g3p1_vrid2e_get(int unit,
                  int ivlan  ,
                soc_sbx_g3p1_vrid2e_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_VRID2E_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_g3p1_vrid2e_index_check(unit, key,
                  ivlan  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g3p1_vrid2e_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for lp
*/
int soc_sbx_g3p1_lp_data_set(int unit,
                    int ilpi  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_lp_t entry;

    soc_sbx_g3p1_lp_t_init(&entry);
    s = soc_sbx_g3p1_lp_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_lp_set(unit,   ilpi  , &entry);

    return s;
}

/**
New entry get accessor implementation for lp
*/
int soc_sbx_g3p1_lp_data_get(int unit,
                    int ilpi  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_lp_t entry;

    soc_sbx_g3p1_lp_t_init(&entry);
    s = soc_sbx_g3p1_lp_get(unit,   ilpi  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_lp_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for lp
 */

void soc_sbx_g3p1_lp_t_init(
    soc_sbx_g3p1_lp_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_lp_t));
}

/* entry pack accessor implementation for lp */
int soc_sbx_g3p1_lp_pack(int unit,
    soc_sbx_g3p1_lp_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_LP_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pid; break;
        case 1: p = (uint8 *) &e->qos; break;
        case 2: p = (uint8 *) &e->useexp; break;
        case 3: p = (uint8 *) &e->usedscp; break;
        case 4: p = (uint8 *) &e->updatefdp; break;
        case 5: p = (uint8 *) &e->mirror; break;
        case 6: p = (uint8 *) &e->updaterdp; break;
        case 7: p = (uint8 *) &e->policer; break;
        case 8: p = (uint8 *) &e->typedpolice; break;
        case 9: p = (uint8 *) &e->mefcos; break;
        case 10: p = (uint8 *) &e->mef; break;
        case 11: p = (uint8 *) &e->ccounter; break;
        case 12: p = (uint8 *) &e->priclass; break;
        case 13: p = (uint8 *) &e->allpri; break;
        case 14: p = (uint8 *) &e->xtpolreplace; break;
        case 15: p = (uint8 *) &e->counter; break;
        case 16: p = (uint8 *) &e->typedcount; break;
        case 17: p = (uint8 *) &e->color; break;
        case 18: p = (uint8 *) &e->usecolor; break;
        case 19: p = (uint8 *) &e->oamepi; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for lp */
int soc_sbx_g3p1_lp_unpack(int unit,
                soc_sbx_g3p1_lp_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_LP_ID];
    int be = tm->behost;
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pid; break;
        case 1: p = (uint8 *) &e->qos; break;
        case 2: p = (uint8 *) &e->useexp; break;
        case 3: p = (uint8 *) &e->usedscp; break;
        case 4: p = (uint8 *) &e->updatefdp; break;
        case 5: p = (uint8 *) &e->mirror; break;
        case 6: p = (uint8 *) &e->updaterdp; break;
        case 7: p = (uint8 *) &e->policer; break;
        case 8: p = (uint8 *) &e->typedpolice; break;
        case 9: p = (uint8 *) &e->mefcos; break;
        case 10: p = (uint8 *) &e->mef; break;
        case 11: p = (uint8 *) &e->ccounter; break;
        case 12: p = (uint8 *) &e->priclass; break;
        case 13: p = (uint8 *) &e->allpri; break;
        case 14: p = (uint8 *) &e->xtpolreplace; break;
        case 15: p = (uint8 *) &e->counter; break;
        case 16: p = (uint8 *) &e->typedcount; break;
        case 17: p = (uint8 *) &e->color; break;
        case 18: p = (uint8 *) &e->usecolor; break;
        case 19: p = (uint8 *) &e->oamepi; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for lp */
int soc_sbx_g3p1_lp_index_check(int unit,
                int *vindex,
                  int ilpi  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_LP_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ilpi; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for lp */
int soc_sbx_g3p1_lp_entry_check(int unit,
                soc_sbx_g3p1_lp_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_LP_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->pid; break;
        case 1: ev = e->qos; break;
        case 2: ev = e->useexp; break;
        case 3: ev = e->usedscp; break;
        case 4: ev = e->updatefdp; break;
        case 5: ev = e->mirror; break;
        case 6: ev = e->updaterdp; break;
        case 7: ev = e->policer; break;
        case 8: ev = e->typedpolice; break;
        case 9: ev = e->mefcos; break;
        case 10: ev = e->mef; break;
        case 11: ev = e->ccounter; break;
        case 12: ev = e->priclass; break;
        case 13: ev = e->allpri; break;
        case 14: ev = e->xtpolreplace; break;
        case 15: ev = e->counter; break;
        case 16: ev = e->typedcount; break;
        case 17: ev = e->color; break;
        case 18: ev = e->usecolor; break;
        case 19: ev = e->oamepi; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* lp table size get */
int soc_sbx_g3p1_lp_entry_table_size_get(int unit,
                int *tsize,
                  int ilpi  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_LP_ID];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ilpi; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for lp */
int soc_sbx_g3p1_lp_set(int unit,
                  int ilpi  ,
                soc_sbx_g3p1_lp_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_LP_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_g3p1_lp_index_check(unit, key,
                  ilpi  );
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_lp_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g3p1_lp_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for lp */
int soc_sbx_g3p1_lp_get(int unit,
                  int ilpi  ,
                soc_sbx_g3p1_lp_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_LP_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_g3p1_lp_index_check(unit, key,
                  ilpi  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g3p1_lp_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for l2cp
*/
int soc_sbx_g3p1_l2cp_data_set(int unit,
                    int ilsb ,  int iport  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_l2cp_t entry;

    soc_sbx_g3p1_l2cp_t_init(&entry);
    s = soc_sbx_g3p1_l2cp_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_l2cp_set(unit,   ilsb ,  iport  , &entry);

    return s;
}

/**
New entry get accessor implementation for l2cp
*/
int soc_sbx_g3p1_l2cp_data_get(int unit,
                    int ilsb ,  int iport  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_l2cp_t entry;

    soc_sbx_g3p1_l2cp_t_init(&entry);
    s = soc_sbx_g3p1_l2cp_get(unit,   ilsb ,  iport  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_l2cp_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for l2cp
 */

void soc_sbx_g3p1_l2cp_t_init(
    soc_sbx_g3p1_l2cp_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_l2cp_t));
}

/* entry pack accessor implementation for l2cp */
int soc_sbx_g3p1_l2cp_pack(int unit,
    soc_sbx_g3p1_l2cp_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_L2CP_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ftidx; break;
        case 1: p = (uint8 *) &e->forward; break;
        case 2: p = (uint8 *) &e->passstp; break;
        case 3: p = (uint8 *) &e->copy; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for l2cp */
int soc_sbx_g3p1_l2cp_unpack(int unit,
                soc_sbx_g3p1_l2cp_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_L2CP_ID];
    int be = tm->behost;
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ftidx; break;
        case 1: p = (uint8 *) &e->forward; break;
        case 2: p = (uint8 *) &e->passstp; break;
        case 3: p = (uint8 *) &e->copy; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for l2cp */
int soc_sbx_g3p1_l2cp_index_check(int unit,
                int *vindex,
                  int ilsb ,  int iport  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_L2CP_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ilsb; break;
        case 1: p = (uint8 *) &iport; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for l2cp */
int soc_sbx_g3p1_l2cp_entry_check(int unit,
                soc_sbx_g3p1_l2cp_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_L2CP_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->ftidx; break;
        case 1: ev = e->forward; break;
        case 2: ev = e->passstp; break;
        case 3: ev = e->copy; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* l2cp table size get */
int soc_sbx_g3p1_l2cp_entry_table_size_get(int unit,
                int *tsize,
                  int ilsb ,  int iport  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_L2CP_ID];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ilsb; break;
        case 1: v = iport; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for l2cp */
int soc_sbx_g3p1_l2cp_set(int unit,
                  int ilsb ,  int iport  ,
                soc_sbx_g3p1_l2cp_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_L2CP_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_g3p1_l2cp_index_check(unit, key,
                  ilsb ,  iport  );
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_l2cp_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g3p1_l2cp_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for l2cp */
int soc_sbx_g3p1_l2cp_get(int unit,
                  int ilsb ,  int iport  ,
                soc_sbx_g3p1_l2cp_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_L2CP_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_g3p1_l2cp_index_check(unit, key,
                  ilsb ,  iport  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g3p1_l2cp_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for l2cpslow
*/
int soc_sbx_g3p1_l2cpslow_data_set(int unit,
                    int isubcode ,  int iport  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_l2cpslow_t entry;

    soc_sbx_g3p1_l2cpslow_t_init(&entry);
    s = soc_sbx_g3p1_l2cpslow_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_l2cpslow_set(unit,   isubcode ,  iport  , &entry);

    return s;
}

/**
New entry get accessor implementation for l2cpslow
*/
int soc_sbx_g3p1_l2cpslow_data_get(int unit,
                    int isubcode ,  int iport  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_l2cpslow_t entry;

    soc_sbx_g3p1_l2cpslow_t_init(&entry);
    s = soc_sbx_g3p1_l2cpslow_get(unit,   isubcode ,  iport  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_l2cpslow_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for l2cpslow
 */

void soc_sbx_g3p1_l2cpslow_t_init(
    soc_sbx_g3p1_l2cpslow_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_l2cpslow_t));
}

/* entry pack accessor implementation for l2cpslow */
int soc_sbx_g3p1_l2cpslow_pack(int unit,
    soc_sbx_g3p1_l2cpslow_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_L2CPSLOW_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ftidx; break;
        case 1: p = (uint8 *) &e->forward; break;
        case 2: p = (uint8 *) &e->passstp; break;
        case 3: p = (uint8 *) &e->copy; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for l2cpslow */
int soc_sbx_g3p1_l2cpslow_unpack(int unit,
                soc_sbx_g3p1_l2cpslow_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_L2CPSLOW_ID];
    int be = tm->behost;
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ftidx; break;
        case 1: p = (uint8 *) &e->forward; break;
        case 2: p = (uint8 *) &e->passstp; break;
        case 3: p = (uint8 *) &e->copy; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for l2cpslow */
int soc_sbx_g3p1_l2cpslow_index_check(int unit,
                int *vindex,
                  int isubcode ,  int iport  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_L2CPSLOW_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &isubcode; break;
        case 1: p = (uint8 *) &iport; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for l2cpslow */
int soc_sbx_g3p1_l2cpslow_entry_check(int unit,
                soc_sbx_g3p1_l2cpslow_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_L2CPSLOW_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->ftidx; break;
        case 1: ev = e->forward; break;
        case 2: ev = e->passstp; break;
        case 3: ev = e->copy; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* l2cpslow table size get */
int soc_sbx_g3p1_l2cpslow_entry_table_size_get(int unit,
                int *tsize,
                  int isubcode ,  int iport  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_L2CPSLOW_ID];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = isubcode; break;
        case 1: v = iport; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for l2cpslow */
int soc_sbx_g3p1_l2cpslow_set(int unit,
                  int isubcode ,  int iport  ,
                soc_sbx_g3p1_l2cpslow_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_L2CPSLOW_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_g3p1_l2cpslow_index_check(unit, key,
                  isubcode ,  iport  );
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_l2cpslow_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g3p1_l2cpslow_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for l2cpslow */
int soc_sbx_g3p1_l2cpslow_get(int unit,
                  int isubcode ,  int iport  ,
                soc_sbx_g3p1_l2cpslow_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_L2CPSLOW_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_g3p1_l2cpslow_index_check(unit, key,
                  isubcode ,  iport  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g3p1_l2cpslow_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for l2cpnop
*/
int soc_sbx_g3p1_l2cpnop_data_set(int unit,
                    int ii  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_l2cpnop_t entry;

    soc_sbx_g3p1_l2cpnop_t_init(&entry);
    s = soc_sbx_g3p1_l2cpnop_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_l2cpnop_set(unit,   ii  , &entry);

    return s;
}

/**
New entry get accessor implementation for l2cpnop
*/
int soc_sbx_g3p1_l2cpnop_data_get(int unit,
                    int ii  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_l2cpnop_t entry;

    soc_sbx_g3p1_l2cpnop_t_init(&entry);
    s = soc_sbx_g3p1_l2cpnop_get(unit,   ii  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_l2cpnop_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for l2cpnop
 */

void soc_sbx_g3p1_l2cpnop_t_init(
    soc_sbx_g3p1_l2cpnop_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_l2cpnop_t));
}

/* entry pack accessor implementation for l2cpnop */
int soc_sbx_g3p1_l2cpnop_pack(int unit,
    soc_sbx_g3p1_l2cpnop_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_L2CPNOP_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ftidx; break;
        case 1: p = (uint8 *) &e->forward; break;
        case 2: p = (uint8 *) &e->passstp; break;
        case 3: p = (uint8 *) &e->copy; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for l2cpnop */
int soc_sbx_g3p1_l2cpnop_unpack(int unit,
                soc_sbx_g3p1_l2cpnop_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_L2CPNOP_ID];
    int be = tm->behost;
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ftidx; break;
        case 1: p = (uint8 *) &e->forward; break;
        case 2: p = (uint8 *) &e->passstp; break;
        case 3: p = (uint8 *) &e->copy; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for l2cpnop */
int soc_sbx_g3p1_l2cpnop_index_check(int unit,
                int *vindex,
                  int ii  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_L2CPNOP_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ii; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for l2cpnop */
int soc_sbx_g3p1_l2cpnop_entry_check(int unit,
                soc_sbx_g3p1_l2cpnop_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_L2CPNOP_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->ftidx; break;
        case 1: ev = e->forward; break;
        case 2: ev = e->passstp; break;
        case 3: ev = e->copy; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* l2cpnop table size get */
int soc_sbx_g3p1_l2cpnop_entry_table_size_get(int unit,
                int *tsize,
                  int ii  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_L2CPNOP_ID];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ii; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for l2cpnop */
int soc_sbx_g3p1_l2cpnop_set(int unit,
                  int ii  ,
                soc_sbx_g3p1_l2cpnop_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_L2CPNOP_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_g3p1_l2cpnop_index_check(unit, key,
                  ii  );
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_l2cpnop_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g3p1_l2cpnop_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for l2cpnop */
int soc_sbx_g3p1_l2cpnop_get(int unit,
                  int ii  ,
                soc_sbx_g3p1_l2cpnop_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_L2CPNOP_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_g3p1_l2cpnop_index_check(unit, key,
                  ii  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g3p1_l2cpnop_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for ft
*/
int soc_sbx_g3p1_ft_data_set(int unit,
                    int ifti  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_ft_t entry;

    soc_sbx_g3p1_ft_t_init(&entry);
    s = soc_sbx_g3p1_ft_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_ft_set(unit,   ifti  , &entry);

    return s;
}

/**
New entry get accessor implementation for ft
*/
int soc_sbx_g3p1_ft_data_get(int unit,
                    int ifti  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_ft_t entry;

    soc_sbx_g3p1_ft_t_init(&entry);
    s = soc_sbx_g3p1_ft_get(unit,   ifti  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_ft_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for ft
 */

void soc_sbx_g3p1_ft_t_init(
    soc_sbx_g3p1_ft_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_ft_t));
}

/* entry pack accessor implementation for ft */
int soc_sbx_g3p1_ft_pack(int unit,
    soc_sbx_g3p1_ft_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_FT_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->rridx; break;
        case 1: p = (uint8 *) &e->excidx; break;
        case 2: p = (uint8 *) &e->lenadj; break;
        case 3: p = (uint8 *) &e->mc; break;
        case 4: p = (uint8 *) &e->t; break;
        case 5: p = (uint8 *) &e->hc; break;
        case 6: p = (uint8 *) &e->oi; break;
        case 7: p = (uint8 *) &e->qid; break;
        case 8: p = (uint8 *) &e->lagbase; break;
        case 9: p = (uint8 *) &e->lagsize; break;
        case 10: p = (uint8 *) &e->lag; break;
        case 11: p = (uint8 *) &e->oib; break;
        case 12: p = (uint8 *) &e->qidb; break;
        case 13: p = (uint8 *) &e->lagbaseb; break;
        case 14: p = (uint8 *) &e->lagsizeb; break;
        case 15: p = (uint8 *) &e->lagb; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ft */
int soc_sbx_g3p1_ft_unpack(int unit,
                soc_sbx_g3p1_ft_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_FT_ID];
    int be = tm->behost;
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->rridx; break;
        case 1: p = (uint8 *) &e->excidx; break;
        case 2: p = (uint8 *) &e->lenadj; break;
        case 3: p = (uint8 *) &e->mc; break;
        case 4: p = (uint8 *) &e->t; break;
        case 5: p = (uint8 *) &e->hc; break;
        case 6: p = (uint8 *) &e->oi; break;
        case 7: p = (uint8 *) &e->qid; break;
        case 8: p = (uint8 *) &e->lagbase; break;
        case 9: p = (uint8 *) &e->lagsize; break;
        case 10: p = (uint8 *) &e->lag; break;
        case 11: p = (uint8 *) &e->oib; break;
        case 12: p = (uint8 *) &e->qidb; break;
        case 13: p = (uint8 *) &e->lagbaseb; break;
        case 14: p = (uint8 *) &e->lagsizeb; break;
        case 15: p = (uint8 *) &e->lagb; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ft */
int soc_sbx_g3p1_ft_index_check(int unit,
                int *vindex,
                  int ifti  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_FT_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ifti; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ft */
int soc_sbx_g3p1_ft_entry_check(int unit,
                soc_sbx_g3p1_ft_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_FT_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->rridx; break;
        case 1: ev = e->excidx; break;
        case 2: ev = e->lenadj; break;
        case 3: ev = e->mc; break;
        case 4: ev = e->t; break;
        case 5: ev = e->hc; break;
        case 6: ev = e->oi; break;
        case 7: ev = e->qid; break;
        case 8: ev = e->lagbase; break;
        case 9: ev = e->lagsize; break;
        case 10: ev = e->lag; break;
        case 11: ev = e->oib; break;
        case 12: ev = e->qidb; break;
        case 13: ev = e->lagbaseb; break;
        case 14: ev = e->lagsizeb; break;
        case 15: ev = e->lagb; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ft table size get */
int soc_sbx_g3p1_ft_entry_table_size_get(int unit,
                int *tsize,
                  int ifti  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_FT_ID];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ifti; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ft */
int soc_sbx_g3p1_ft_set(int unit,
                  int ifti  ,
                soc_sbx_g3p1_ft_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_FT_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_g3p1_ft_index_check(unit, key,
                  ifti  );
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_ft_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g3p1_ft_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ft */
int soc_sbx_g3p1_ft_get(int unit,
                  int ifti  ,
                soc_sbx_g3p1_ft_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_FT_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_g3p1_ft_index_check(unit, key,
                  ifti  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g3p1_ft_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for evp2e
*/
int soc_sbx_g3p1_evp2e_data_set(int unit,
                    int ivlan ,  int iport  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_evp2e_t entry;

    soc_sbx_g3p1_evp2e_t_init(&entry);
    s = soc_sbx_g3p1_evp2e_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_evp2e_set(unit,   ivlan ,  iport  , &entry);

    return s;
}

/**
New entry get accessor implementation for evp2e
*/
int soc_sbx_g3p1_evp2e_data_get(int unit,
                    int ivlan ,  int iport  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_evp2e_t entry;

    soc_sbx_g3p1_evp2e_t_init(&entry);
    s = soc_sbx_g3p1_evp2e_get(unit,   ivlan ,  iport  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_evp2e_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for evp2e
 */

void soc_sbx_g3p1_evp2e_t_init(
    soc_sbx_g3p1_evp2e_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_evp2e_t));
}

/* entry pack accessor implementation for evp2e */
int soc_sbx_g3p1_evp2e_pack(int unit,
    soc_sbx_g3p1_evp2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_EVP2E_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->eteptr; break;
        case 1: p = (uint8 *) &e->counter; break;
        case 2: p = (uint8 *) &e->ccounter; break;
        case 3: p = (uint8 *) &e->priclass; break;
        case 4: p = (uint8 *) &e->allpri; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for evp2e */
int soc_sbx_g3p1_evp2e_unpack(int unit,
                soc_sbx_g3p1_evp2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_EVP2E_ID];
    int be = tm->behost;
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->eteptr; break;
        case 1: p = (uint8 *) &e->counter; break;
        case 2: p = (uint8 *) &e->ccounter; break;
        case 3: p = (uint8 *) &e->priclass; break;
        case 4: p = (uint8 *) &e->allpri; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for evp2e */
int soc_sbx_g3p1_evp2e_index_check(int unit,
                int *vindex,
                  int ivlan ,  int iport  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_EVP2E_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ivlan; break;
        case 1: p = (uint8 *) &iport; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for evp2e */
int soc_sbx_g3p1_evp2e_entry_check(int unit,
                soc_sbx_g3p1_evp2e_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_EVP2E_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->eteptr; break;
        case 1: ev = e->counter; break;
        case 2: ev = e->ccounter; break;
        case 3: ev = e->priclass; break;
        case 4: ev = e->allpri; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* evp2e table size get */
int soc_sbx_g3p1_evp2e_entry_table_size_get(int unit,
                int *tsize,
                  int ivlan ,  int iport  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_EVP2E_ID];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ivlan; break;
        case 1: v = iport; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for evp2e */
int soc_sbx_g3p1_evp2e_set(int unit,
                  int ivlan ,  int iport  ,
                soc_sbx_g3p1_evp2e_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_EVP2E_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_g3p1_evp2e_index_check(unit, key,
                  ivlan ,  iport  );
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_evp2e_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g3p1_evp2e_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for evp2e */
int soc_sbx_g3p1_evp2e_get(int unit,
                  int ivlan ,  int iport  ,
                soc_sbx_g3p1_evp2e_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_EVP2E_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_g3p1_evp2e_index_check(unit, key,
                  ivlan ,  iport  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g3p1_evp2e_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for oi2e
*/
int soc_sbx_g3p1_oi2e_data_set(int unit,
                    int ioi  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_oi2e_t entry;

    soc_sbx_g3p1_oi2e_t_init(&entry);
    s = soc_sbx_g3p1_oi2e_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_oi2e_set(unit,   ioi  , &entry);

    return s;
}

/**
New entry get accessor implementation for oi2e
*/
int soc_sbx_g3p1_oi2e_data_get(int unit,
                    int ioi  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_oi2e_t entry;

    soc_sbx_g3p1_oi2e_t_init(&entry);
    s = soc_sbx_g3p1_oi2e_get(unit,   ioi  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_oi2e_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for oi2e
 */

void soc_sbx_g3p1_oi2e_t_init(
    soc_sbx_g3p1_oi2e_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_oi2e_t));
}

/* entry pack accessor implementation for oi2e */
int soc_sbx_g3p1_oi2e_pack(int unit,
    soc_sbx_g3p1_oi2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OI2E_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->eteptr; break;
        case 1: p = (uint8 *) &e->counter; break;
        case 2: p = (uint8 *) &e->ccounter; break;
        case 3: p = (uint8 *) &e->priclass; break;
        case 4: p = (uint8 *) &e->allpri; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for oi2e */
int soc_sbx_g3p1_oi2e_unpack(int unit,
                soc_sbx_g3p1_oi2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OI2E_ID];
    int be = tm->behost;
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->eteptr; break;
        case 1: p = (uint8 *) &e->counter; break;
        case 2: p = (uint8 *) &e->ccounter; break;
        case 3: p = (uint8 *) &e->priclass; break;
        case 4: p = (uint8 *) &e->allpri; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for oi2e */
int soc_sbx_g3p1_oi2e_index_check(int unit,
                int *vindex,
                  int ioi  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OI2E_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ioi; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for oi2e */
int soc_sbx_g3p1_oi2e_entry_check(int unit,
                soc_sbx_g3p1_oi2e_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OI2E_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->eteptr; break;
        case 1: ev = e->counter; break;
        case 2: ev = e->ccounter; break;
        case 3: ev = e->priclass; break;
        case 4: ev = e->allpri; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* oi2e table size get */
int soc_sbx_g3p1_oi2e_entry_table_size_get(int unit,
                int *tsize,
                  int ioi  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OI2E_ID];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ioi; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for oi2e */
int soc_sbx_g3p1_oi2e_set(int unit,
                  int ioi  ,
                soc_sbx_g3p1_oi2e_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OI2E_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_g3p1_oi2e_index_check(unit, key,
                  ioi  );
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_oi2e_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g3p1_oi2e_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for oi2e */
int soc_sbx_g3p1_oi2e_get(int unit,
                  int ioi  ,
                soc_sbx_g3p1_oi2e_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OI2E_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_g3p1_oi2e_index_check(unit, key,
                  ioi  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g3p1_oi2e_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for remark
*/
int soc_sbx_g3p1_remark_data_set(int unit,
                    int ie ,  int idp ,  int icos ,  int iprof  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_remark_t entry;

    soc_sbx_g3p1_remark_t_init(&entry);
    s = soc_sbx_g3p1_remark_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_remark_set(unit,   ie ,  idp ,  icos ,  iprof  , &entry);

    return s;
}

/**
New entry get accessor implementation for remark
*/
int soc_sbx_g3p1_remark_data_get(int unit,
                    int ie ,  int idp ,  int icos ,  int iprof  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_remark_t entry;

    soc_sbx_g3p1_remark_t_init(&entry);
    s = soc_sbx_g3p1_remark_get(unit,   ie ,  idp ,  icos ,  iprof  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_remark_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for remark
 */

void soc_sbx_g3p1_remark_t_init(
    soc_sbx_g3p1_remark_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_remark_t));
}

/* entry pack accessor implementation for remark */
int soc_sbx_g3p1_remark_pack(int unit,
    soc_sbx_g3p1_remark_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_REMARK_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->cfi; break;
        case 1: p = (uint8 *) &e->pri; break;
        case 2: p = (uint8 *) &e->exp; break;
        case 3: p = (uint8 *) &e->dscp; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for remark */
int soc_sbx_g3p1_remark_unpack(int unit,
                soc_sbx_g3p1_remark_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_REMARK_ID];
    int be = tm->behost;
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->cfi; break;
        case 1: p = (uint8 *) &e->pri; break;
        case 2: p = (uint8 *) &e->exp; break;
        case 3: p = (uint8 *) &e->dscp; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for remark */
int soc_sbx_g3p1_remark_index_check(int unit,
                int *vindex,
                  int ie ,  int idp ,  int icos ,  int iprof  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_REMARK_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ie; break;
        case 1: p = (uint8 *) &idp; break;
        case 2: p = (uint8 *) &icos; break;
        case 3: p = (uint8 *) &iprof; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for remark */
int soc_sbx_g3p1_remark_entry_check(int unit,
                soc_sbx_g3p1_remark_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_REMARK_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->cfi; break;
        case 1: ev = e->pri; break;
        case 2: ev = e->exp; break;
        case 3: ev = e->dscp; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* remark table size get */
int soc_sbx_g3p1_remark_entry_table_size_get(int unit,
                int *tsize,
                  int ie ,  int idp ,  int icos ,  int iprof  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_REMARK_ID];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ie; break;
        case 1: v = idp; break;
        case 2: v = icos; break;
        case 3: v = iprof; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for remark */
int soc_sbx_g3p1_remark_set(int unit,
                  int ie ,  int idp ,  int icos ,  int iprof  ,
                soc_sbx_g3p1_remark_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_REMARK_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_g3p1_remark_index_check(unit, key,
                  ie ,  idp ,  icos ,  iprof  );
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_remark_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g3p1_remark_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for remark */
int soc_sbx_g3p1_remark_get(int unit,
                  int ie ,  int idp ,  int icos ,  int iprof  ,
                soc_sbx_g3p1_remark_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_REMARK_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_g3p1_remark_index_check(unit, key,
                  ie ,  idp ,  icos ,  iprof  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g3p1_remark_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for epv2e
*/
int soc_sbx_g3p1_epv2e_data_set(int unit,
                    int ivid ,  int iport  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_epv2e_t entry;

    soc_sbx_g3p1_epv2e_t_init(&entry);
    s = soc_sbx_g3p1_epv2e_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_epv2e_set(unit,   ivid ,  iport  , &entry);

    return s;
}

/**
New entry get accessor implementation for epv2e
*/
int soc_sbx_g3p1_epv2e_data_get(int unit,
                    int ivid ,  int iport  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_epv2e_t entry;

    soc_sbx_g3p1_epv2e_t_init(&entry);
    s = soc_sbx_g3p1_epv2e_get(unit,   ivid ,  iport  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_epv2e_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for epv2e
 */

void soc_sbx_g3p1_epv2e_t_init(
    soc_sbx_g3p1_epv2e_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_epv2e_t));
}

/* entry pack accessor implementation for epv2e */
int soc_sbx_g3p1_epv2e_pack(int unit,
    soc_sbx_g3p1_epv2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_EPV2E_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->drop; break;
        case 1: p = (uint8 *) &e->strip; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for epv2e */
int soc_sbx_g3p1_epv2e_unpack(int unit,
                soc_sbx_g3p1_epv2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_EPV2E_ID];
    int be = tm->behost;
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->drop; break;
        case 1: p = (uint8 *) &e->strip; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for epv2e */
int soc_sbx_g3p1_epv2e_index_check(int unit,
                int *vindex,
                  int ivid ,  int iport  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_EPV2E_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ivid; break;
        case 1: p = (uint8 *) &iport; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for epv2e */
int soc_sbx_g3p1_epv2e_entry_check(int unit,
                soc_sbx_g3p1_epv2e_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_EPV2E_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->drop; break;
        case 1: ev = e->strip; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* epv2e table size get */
int soc_sbx_g3p1_epv2e_entry_table_size_get(int unit,
                int *tsize,
                  int ivid ,  int iport  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_EPV2E_ID];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ivid; break;
        case 1: v = iport; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for epv2e */
int soc_sbx_g3p1_epv2e_set(int unit,
                  int ivid ,  int iport  ,
                soc_sbx_g3p1_epv2e_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_EPV2E_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_g3p1_epv2e_index_check(unit, key,
                  ivid ,  iport  );
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_epv2e_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g3p1_epv2e_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for epv2e */
int soc_sbx_g3p1_epv2e_get(int unit,
                  int ivid ,  int iport  ,
                soc_sbx_g3p1_epv2e_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_EPV2E_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_g3p1_epv2e_index_check(unit, key,
                  ivid ,  iport  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g3p1_epv2e_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for ert
*/
int soc_sbx_g3p1_ert_data_set(int unit,
                    int iirule  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_ert_t entry;

    soc_sbx_g3p1_ert_t_init(&entry);
    s = soc_sbx_g3p1_ert_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_ert_set(unit,   iirule  , &entry);

    return s;
}

/**
New entry get accessor implementation for ert
*/
int soc_sbx_g3p1_ert_data_get(int unit,
                    int iirule  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_ert_t entry;

    soc_sbx_g3p1_ert_t_init(&entry);
    s = soc_sbx_g3p1_ert_get(unit,   iirule  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_ert_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for ert
 */

void soc_sbx_g3p1_ert_t_init(
    soc_sbx_g3p1_ert_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_ert_t));
}

/* entry pack accessor implementation for ert */
int soc_sbx_g3p1_ert_pack(int unit,
    soc_sbx_g3p1_ert_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_ERT_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->mirror; break;
        case 1: p = (uint8 *) &e->drop; break;
        case 2: p = (uint8 *) &e->counter; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ert */
int soc_sbx_g3p1_ert_unpack(int unit,
                soc_sbx_g3p1_ert_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_ERT_ID];
    int be = tm->behost;
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->mirror; break;
        case 1: p = (uint8 *) &e->drop; break;
        case 2: p = (uint8 *) &e->counter; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ert */
int soc_sbx_g3p1_ert_index_check(int unit,
                int *vindex,
                  int iirule  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_ERT_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iirule; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ert */
int soc_sbx_g3p1_ert_entry_check(int unit,
                soc_sbx_g3p1_ert_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_ERT_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->mirror; break;
        case 1: ev = e->drop; break;
        case 2: ev = e->counter; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ert table size get */
int soc_sbx_g3p1_ert_entry_table_size_get(int unit,
                int *tsize,
                  int iirule  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_ERT_ID];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iirule; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ert */
int soc_sbx_g3p1_ert_set(int unit,
                  int iirule  ,
                soc_sbx_g3p1_ert_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_ERT_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_g3p1_ert_index_check(unit, key,
                  iirule  );
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_ert_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g3p1_ert_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ert */
int soc_sbx_g3p1_ert_get(int unit,
                  int iirule  ,
                soc_sbx_g3p1_ert_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_ERT_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_g3p1_ert_index_check(unit, key,
                  iirule  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g3p1_ert_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for oam_bubble
*/
int soc_sbx_g3p1_oam_bubble_data_set(int unit,
                    int ioamepi  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_oam_bubble_t entry;

    soc_sbx_g3p1_oam_bubble_t_init(&entry);
    s = soc_sbx_g3p1_oam_bubble_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_oam_bubble_set(unit,   ioamepi  , &entry);

    return s;
}

/**
New entry get accessor implementation for oam_bubble
*/
int soc_sbx_g3p1_oam_bubble_data_get(int unit,
                    int ioamepi  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_oam_bubble_t entry;

    soc_sbx_g3p1_oam_bubble_t_init(&entry);
    s = soc_sbx_g3p1_oam_bubble_get(unit,   ioamepi  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_oam_bubble_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for oam_bubble
 */

void soc_sbx_g3p1_oam_bubble_t_init(
    soc_sbx_g3p1_oam_bubble_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_oam_bubble_t));
}

/* entry pack accessor implementation for oam_bubble */
int soc_sbx_g3p1_oam_bubble_pack(int unit,
    soc_sbx_g3p1_oam_bubble_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OAM_BUBBLE_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->bubble_mode; break;
        case 1: p = (uint8 *) &e->je; break;
        case 2: p = (uint8 *) &e->i; break;
        case 3: p = (uint8 *) &e->bubble_stream; break;
        case 4: p = (uint8 *) &e->t; break;
        case 5: p = (uint8 *) &e->interval_index; break;
        case 6: p = (uint8 *) &e->reserved; break;
        case 7: p = (uint8 *) &e->count; break;
        case 8: p = (uint8 *) &e->timeout; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for oam_bubble */
int soc_sbx_g3p1_oam_bubble_unpack(int unit,
                soc_sbx_g3p1_oam_bubble_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OAM_BUBBLE_ID];
    int be = tm->behost;
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->bubble_mode; break;
        case 1: p = (uint8 *) &e->je; break;
        case 2: p = (uint8 *) &e->i; break;
        case 3: p = (uint8 *) &e->bubble_stream; break;
        case 4: p = (uint8 *) &e->t; break;
        case 5: p = (uint8 *) &e->interval_index; break;
        case 6: p = (uint8 *) &e->reserved; break;
        case 7: p = (uint8 *) &e->count; break;
        case 8: p = (uint8 *) &e->timeout; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for oam_bubble */
int soc_sbx_g3p1_oam_bubble_index_check(int unit,
                int *vindex,
                  int ioamepi  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OAM_BUBBLE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ioamepi; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for oam_bubble */
int soc_sbx_g3p1_oam_bubble_entry_check(int unit,
                soc_sbx_g3p1_oam_bubble_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OAM_BUBBLE_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->bubble_mode; break;
        case 1: ev = e->je; break;
        case 2: ev = e->i; break;
        case 3: ev = e->bubble_stream; break;
        case 4: ev = e->t; break;
        case 5: ev = e->interval_index; break;
        case 6: ev = e->reserved; break;
        case 7: ev = e->count; break;
        case 8: ev = e->timeout; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* oam_bubble table size get */
int soc_sbx_g3p1_oam_bubble_entry_table_size_get(int unit,
                int *tsize,
                  int ioamepi  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OAM_BUBBLE_ID];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ioamepi; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for oam_bubble */
int soc_sbx_g3p1_oam_bubble_set(int unit,
                  int ioamepi  ,
                soc_sbx_g3p1_oam_bubble_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OAM_BUBBLE_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_g3p1_oam_bubble_index_check(unit, key,
                  ioamepi  );
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_oam_bubble_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g3p1_oam_bubble_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for oam_bubble */
int soc_sbx_g3p1_oam_bubble_get(int unit,
                  int ioamepi  ,
                soc_sbx_g3p1_oam_bubble_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OAM_BUBBLE_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_g3p1_oam_bubble_index_check(unit, key,
                  ioamepi  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g3p1_oam_bubble_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for oamrx_p2e
*/
int soc_sbx_g3p1_oamrx_p2e_data_set(int unit,
                    int idir ,  int iport  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_oamrx_p2e_t entry;

    soc_sbx_g3p1_oamrx_p2e_t_init(&entry);
    s = soc_sbx_g3p1_oamrx_p2e_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_oamrx_p2e_set(unit,   idir ,  iport  , &entry);

    return s;
}

/**
New entry get accessor implementation for oamrx_p2e
*/
int soc_sbx_g3p1_oamrx_p2e_data_get(int unit,
                    int idir ,  int iport  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_oamrx_p2e_t entry;

    soc_sbx_g3p1_oamrx_p2e_t_init(&entry);
    s = soc_sbx_g3p1_oamrx_p2e_get(unit,   idir ,  iport  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_oamrx_p2e_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for oamrx_p2e
 */

void soc_sbx_g3p1_oamrx_p2e_t_init(
    soc_sbx_g3p1_oamrx_p2e_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_oamrx_p2e_t));
}

/* entry pack accessor implementation for oamrx_p2e */
int soc_sbx_g3p1_oamrx_p2e_pack(int unit,
    soc_sbx_g3p1_oamrx_p2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OAMRX_P2E_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->svc_hdl; break;
        case 1: p = (uint8 *) &e->not_used; break;
        case 2: p = (uint8 *) &e->mdlvl_0_m; break;
        case 3: p = (uint8 *) &e->mdlvl_0_p; break;
        case 4: p = (uint8 *) &e->mdlvl_0_d; break;
        case 5: p = (uint8 *) &e->mdlvl_0_f; break;
        case 6: p = (uint8 *) &e->mdlvl_1_m; break;
        case 7: p = (uint8 *) &e->mdlvl_1_p; break;
        case 8: p = (uint8 *) &e->mdlvl_1_d; break;
        case 9: p = (uint8 *) &e->mdlvl_1_f; break;
        case 10: p = (uint8 *) &e->mdlvl_2_m; break;
        case 11: p = (uint8 *) &e->mdlvl_2_p; break;
        case 12: p = (uint8 *) &e->mdlvl_2_d; break;
        case 13: p = (uint8 *) &e->mdlvl_2_f; break;
        case 14: p = (uint8 *) &e->mdlvl_3_m; break;
        case 15: p = (uint8 *) &e->mdlvl_3_p; break;
        case 16: p = (uint8 *) &e->mdlvl_3_d; break;
        case 17: p = (uint8 *) &e->mdlvl_3_f; break;
        case 18: p = (uint8 *) &e->mdlvl_4_m; break;
        case 19: p = (uint8 *) &e->mdlvl_4_p; break;
        case 20: p = (uint8 *) &e->mdlvl_4_d; break;
        case 21: p = (uint8 *) &e->mdlvl_4_f; break;
        case 22: p = (uint8 *) &e->mdlvl_5_m; break;
        case 23: p = (uint8 *) &e->mdlvl_5_p; break;
        case 24: p = (uint8 *) &e->mdlvl_5_d; break;
        case 25: p = (uint8 *) &e->mdlvl_5_f; break;
        case 26: p = (uint8 *) &e->mdlvl_6_m; break;
        case 27: p = (uint8 *) &e->mdlvl_6_p; break;
        case 28: p = (uint8 *) &e->mdlvl_6_d; break;
        case 29: p = (uint8 *) &e->mdlvl_6_f; break;
        case 30: p = (uint8 *) &e->mdlvl_7_m; break;
        case 31: p = (uint8 *) &e->mdlvl_7_p; break;
        case 32: p = (uint8 *) &e->mdlvl_7_d; break;
        case 33: p = (uint8 *) &e->mdlvl_7_f; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for oamrx_p2e */
int soc_sbx_g3p1_oamrx_p2e_unpack(int unit,
                soc_sbx_g3p1_oamrx_p2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OAMRX_P2E_ID];
    int be = tm->behost;
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->svc_hdl; break;
        case 1: p = (uint8 *) &e->not_used; break;
        case 2: p = (uint8 *) &e->mdlvl_0_m; break;
        case 3: p = (uint8 *) &e->mdlvl_0_p; break;
        case 4: p = (uint8 *) &e->mdlvl_0_d; break;
        case 5: p = (uint8 *) &e->mdlvl_0_f; break;
        case 6: p = (uint8 *) &e->mdlvl_1_m; break;
        case 7: p = (uint8 *) &e->mdlvl_1_p; break;
        case 8: p = (uint8 *) &e->mdlvl_1_d; break;
        case 9: p = (uint8 *) &e->mdlvl_1_f; break;
        case 10: p = (uint8 *) &e->mdlvl_2_m; break;
        case 11: p = (uint8 *) &e->mdlvl_2_p; break;
        case 12: p = (uint8 *) &e->mdlvl_2_d; break;
        case 13: p = (uint8 *) &e->mdlvl_2_f; break;
        case 14: p = (uint8 *) &e->mdlvl_3_m; break;
        case 15: p = (uint8 *) &e->mdlvl_3_p; break;
        case 16: p = (uint8 *) &e->mdlvl_3_d; break;
        case 17: p = (uint8 *) &e->mdlvl_3_f; break;
        case 18: p = (uint8 *) &e->mdlvl_4_m; break;
        case 19: p = (uint8 *) &e->mdlvl_4_p; break;
        case 20: p = (uint8 *) &e->mdlvl_4_d; break;
        case 21: p = (uint8 *) &e->mdlvl_4_f; break;
        case 22: p = (uint8 *) &e->mdlvl_5_m; break;
        case 23: p = (uint8 *) &e->mdlvl_5_p; break;
        case 24: p = (uint8 *) &e->mdlvl_5_d; break;
        case 25: p = (uint8 *) &e->mdlvl_5_f; break;
        case 26: p = (uint8 *) &e->mdlvl_6_m; break;
        case 27: p = (uint8 *) &e->mdlvl_6_p; break;
        case 28: p = (uint8 *) &e->mdlvl_6_d; break;
        case 29: p = (uint8 *) &e->mdlvl_6_f; break;
        case 30: p = (uint8 *) &e->mdlvl_7_m; break;
        case 31: p = (uint8 *) &e->mdlvl_7_p; break;
        case 32: p = (uint8 *) &e->mdlvl_7_d; break;
        case 33: p = (uint8 *) &e->mdlvl_7_f; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for oamrx_p2e */
int soc_sbx_g3p1_oamrx_p2e_index_check(int unit,
                int *vindex,
                  int idir ,  int iport  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OAMRX_P2E_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &idir; break;
        case 1: p = (uint8 *) &iport; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for oamrx_p2e */
int soc_sbx_g3p1_oamrx_p2e_entry_check(int unit,
                soc_sbx_g3p1_oamrx_p2e_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OAMRX_P2E_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->svc_hdl; break;
        case 1: ev = e->not_used; break;
        case 2: ev = e->mdlvl_0_m; break;
        case 3: ev = e->mdlvl_0_p; break;
        case 4: ev = e->mdlvl_0_d; break;
        case 5: ev = e->mdlvl_0_f; break;
        case 6: ev = e->mdlvl_1_m; break;
        case 7: ev = e->mdlvl_1_p; break;
        case 8: ev = e->mdlvl_1_d; break;
        case 9: ev = e->mdlvl_1_f; break;
        case 10: ev = e->mdlvl_2_m; break;
        case 11: ev = e->mdlvl_2_p; break;
        case 12: ev = e->mdlvl_2_d; break;
        case 13: ev = e->mdlvl_2_f; break;
        case 14: ev = e->mdlvl_3_m; break;
        case 15: ev = e->mdlvl_3_p; break;
        case 16: ev = e->mdlvl_3_d; break;
        case 17: ev = e->mdlvl_3_f; break;
        case 18: ev = e->mdlvl_4_m; break;
        case 19: ev = e->mdlvl_4_p; break;
        case 20: ev = e->mdlvl_4_d; break;
        case 21: ev = e->mdlvl_4_f; break;
        case 22: ev = e->mdlvl_5_m; break;
        case 23: ev = e->mdlvl_5_p; break;
        case 24: ev = e->mdlvl_5_d; break;
        case 25: ev = e->mdlvl_5_f; break;
        case 26: ev = e->mdlvl_6_m; break;
        case 27: ev = e->mdlvl_6_p; break;
        case 28: ev = e->mdlvl_6_d; break;
        case 29: ev = e->mdlvl_6_f; break;
        case 30: ev = e->mdlvl_7_m; break;
        case 31: ev = e->mdlvl_7_p; break;
        case 32: ev = e->mdlvl_7_d; break;
        case 33: ev = e->mdlvl_7_f; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* oamrx_p2e table size get */
int soc_sbx_g3p1_oamrx_p2e_entry_table_size_get(int unit,
                int *tsize,
                  int idir ,  int iport  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OAMRX_P2E_ID];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = idir; break;
        case 1: v = iport; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for oamrx_p2e */
int soc_sbx_g3p1_oamrx_p2e_set(int unit,
                  int idir ,  int iport  ,
                soc_sbx_g3p1_oamrx_p2e_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OAMRX_P2E_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_g3p1_oamrx_p2e_index_check(unit, key,
                  idir ,  iport  );
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_oamrx_p2e_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g3p1_oamrx_p2e_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for oamrx_p2e */
int soc_sbx_g3p1_oamrx_p2e_get(int unit,
                  int idir ,  int iport  ,
                soc_sbx_g3p1_oamrx_p2e_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OAMRX_P2E_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_g3p1_oamrx_p2e_index_check(unit, key,
                  idir ,  iport  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g3p1_oamrx_p2e_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for oam_peer_state
*/
int soc_sbx_g3p1_oam_peer_state_data_set(int unit,
                    int ipeer_idx  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_oam_peer_state_t entry;

    soc_sbx_g3p1_oam_peer_state_t_init(&entry);
    s = soc_sbx_g3p1_oam_peer_state_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_oam_peer_state_set(unit,   ipeer_idx  , &entry);

    return s;
}

/**
New entry get accessor implementation for oam_peer_state
*/
int soc_sbx_g3p1_oam_peer_state_data_get(int unit,
                    int ipeer_idx  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_oam_peer_state_t entry;

    soc_sbx_g3p1_oam_peer_state_t_init(&entry);
    s = soc_sbx_g3p1_oam_peer_state_get(unit,   ipeer_idx  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_oam_peer_state_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for oam_peer_state
 */

void soc_sbx_g3p1_oam_peer_state_t_init(
    soc_sbx_g3p1_oam_peer_state_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_oam_peer_state_t));
}

/* entry pack accessor implementation for oam_peer_state */
int soc_sbx_g3p1_oam_peer_state_pack(int unit,
    soc_sbx_g3p1_oam_peer_state_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OAM_PEER_STATE_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->rdi_ack; break;
        case 1: p = (uint8 *) &e->rdi_state; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for oam_peer_state */
int soc_sbx_g3p1_oam_peer_state_unpack(int unit,
                soc_sbx_g3p1_oam_peer_state_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OAM_PEER_STATE_ID];
    int be = tm->behost;
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->rdi_ack; break;
        case 1: p = (uint8 *) &e->rdi_state; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for oam_peer_state */
int soc_sbx_g3p1_oam_peer_state_index_check(int unit,
                int *vindex,
                  int ipeer_idx  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OAM_PEER_STATE_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ipeer_idx; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for oam_peer_state */
int soc_sbx_g3p1_oam_peer_state_entry_check(int unit,
                soc_sbx_g3p1_oam_peer_state_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OAM_PEER_STATE_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->rdi_ack; break;
        case 1: ev = e->rdi_state; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* oam_peer_state table size get */
int soc_sbx_g3p1_oam_peer_state_entry_table_size_get(int unit,
                int *tsize,
                  int ipeer_idx  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OAM_PEER_STATE_ID];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ipeer_idx; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for oam_peer_state */
int soc_sbx_g3p1_oam_peer_state_set(int unit,
                  int ipeer_idx  ,
                soc_sbx_g3p1_oam_peer_state_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OAM_PEER_STATE_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_g3p1_oam_peer_state_index_check(unit, key,
                  ipeer_idx  );
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_oam_peer_state_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g3p1_oam_peer_state_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for oam_peer_state */
int soc_sbx_g3p1_oam_peer_state_get(int unit,
                  int ipeer_idx  ,
                soc_sbx_g3p1_oam_peer_state_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_OAM_PEER_STATE_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_g3p1_oam_peer_state_index_check(unit, key,
                  ipeer_idx  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g3p1_oam_peer_state_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for ptp_compensation
*/
int soc_sbx_g3p1_ptp_compensation_data_set(int unit,
                    int iport  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_ptp_compensation_t entry;

    soc_sbx_g3p1_ptp_compensation_t_init(&entry);
    s = soc_sbx_g3p1_ptp_compensation_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_ptp_compensation_set(unit,   iport  , &entry);

    return s;
}

/**
New entry get accessor implementation for ptp_compensation
*/
int soc_sbx_g3p1_ptp_compensation_data_get(int unit,
                    int iport  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_ptp_compensation_t entry;

    soc_sbx_g3p1_ptp_compensation_t_init(&entry);
    s = soc_sbx_g3p1_ptp_compensation_get(unit,   iport  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_ptp_compensation_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for ptp_compensation
 */

void soc_sbx_g3p1_ptp_compensation_t_init(
    soc_sbx_g3p1_ptp_compensation_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_ptp_compensation_t));
}

/* entry pack accessor implementation for ptp_compensation */
int soc_sbx_g3p1_ptp_compensation_pack(int unit,
    soc_sbx_g3p1_ptp_compensation_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PTP_COMPENSATION_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->compensation; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ptp_compensation */
int soc_sbx_g3p1_ptp_compensation_unpack(int unit,
                soc_sbx_g3p1_ptp_compensation_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PTP_COMPENSATION_ID];
    int be = tm->behost;
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->compensation; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ptp_compensation */
int soc_sbx_g3p1_ptp_compensation_index_check(int unit,
                int *vindex,
                  int iport  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PTP_COMPENSATION_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iport; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ptp_compensation */
int soc_sbx_g3p1_ptp_compensation_entry_check(int unit,
                soc_sbx_g3p1_ptp_compensation_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PTP_COMPENSATION_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->compensation; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ptp_compensation table size get */
int soc_sbx_g3p1_ptp_compensation_entry_table_size_get(int unit,
                int *tsize,
                  int iport  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PTP_COMPENSATION_ID];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iport; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ptp_compensation */
int soc_sbx_g3p1_ptp_compensation_set(int unit,
                  int iport  ,
                soc_sbx_g3p1_ptp_compensation_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PTP_COMPENSATION_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_g3p1_ptp_compensation_index_check(unit, key,
                  iport  );
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_ptp_compensation_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g3p1_ptp_compensation_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ptp_compensation */
int soc_sbx_g3p1_ptp_compensation_get(int unit,
                  int iport  ,
                soc_sbx_g3p1_ptp_compensation_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PTP_COMPENSATION_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_g3p1_ptp_compensation_index_check(unit, key,
                  iport  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g3p1_ptp_compensation_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for bfd_ld2edata
*/
int soc_sbx_g3p1_bfd_ld2edata_data_set(int unit,
                    int iptr  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_bfd_ld2edata_t entry;

    soc_sbx_g3p1_bfd_ld2edata_t_init(&entry);
    s = soc_sbx_g3p1_bfd_ld2edata_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_bfd_ld2edata_set(unit,   iptr  , &entry);

    return s;
}

/**
New entry get accessor implementation for bfd_ld2edata
*/
int soc_sbx_g3p1_bfd_ld2edata_data_get(int unit,
                    int iptr  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_bfd_ld2edata_t entry;

    soc_sbx_g3p1_bfd_ld2edata_t_init(&entry);
    s = soc_sbx_g3p1_bfd_ld2edata_get(unit,   iptr  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_bfd_ld2edata_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for bfd_ld2edata
 */

void soc_sbx_g3p1_bfd_ld2edata_t_init(
    soc_sbx_g3p1_bfd_ld2edata_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_bfd_ld2edata_t));
}

/* entry pack accessor implementation for bfd_ld2edata */
int soc_sbx_g3p1_bfd_ld2edata_pack(int unit,
    soc_sbx_g3p1_bfd_ld2edata_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_BFD_LD2EDATA_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->wdg_id; break;
        case 1: p = (uint8 *) &e->slowstart; break;
        case 2: p = (uint8 *) &e->rdmode; break;
        case 3: p = (uint8 *) &e->rstate; break;
        case 4: p = (uint8 *) &e->f; break;
        case 5: p = (uint8 *) &e->poll; break;
        case 6: p = (uint8 *) &e->sta; break;
        case 7: p = (uint8 *) &e->ldiag; break;
        case 8: p = (uint8 *) &e->version; break;
        case 9: p = (uint8 *) &e->rdiscri; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for bfd_ld2edata */
int soc_sbx_g3p1_bfd_ld2edata_unpack(int unit,
                soc_sbx_g3p1_bfd_ld2edata_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_BFD_LD2EDATA_ID];
    int be = tm->behost;
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->wdg_id; break;
        case 1: p = (uint8 *) &e->slowstart; break;
        case 2: p = (uint8 *) &e->rdmode; break;
        case 3: p = (uint8 *) &e->rstate; break;
        case 4: p = (uint8 *) &e->f; break;
        case 5: p = (uint8 *) &e->poll; break;
        case 6: p = (uint8 *) &e->sta; break;
        case 7: p = (uint8 *) &e->ldiag; break;
        case 8: p = (uint8 *) &e->version; break;
        case 9: p = (uint8 *) &e->rdiscri; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for bfd_ld2edata */
int soc_sbx_g3p1_bfd_ld2edata_index_check(int unit,
                int *vindex,
                  int iptr  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_BFD_LD2EDATA_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iptr; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for bfd_ld2edata */
int soc_sbx_g3p1_bfd_ld2edata_entry_check(int unit,
                soc_sbx_g3p1_bfd_ld2edata_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_BFD_LD2EDATA_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->wdg_id; break;
        case 1: ev = e->slowstart; break;
        case 2: ev = e->rdmode; break;
        case 3: ev = e->rstate; break;
        case 4: ev = e->f; break;
        case 5: ev = e->poll; break;
        case 6: ev = e->sta; break;
        case 7: ev = e->ldiag; break;
        case 8: ev = e->version; break;
        case 9: ev = e->rdiscri; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* bfd_ld2edata table size get */
int soc_sbx_g3p1_bfd_ld2edata_entry_table_size_get(int unit,
                int *tsize,
                  int iptr  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_BFD_LD2EDATA_ID];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iptr; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for bfd_ld2edata */
int soc_sbx_g3p1_bfd_ld2edata_set(int unit,
                  int iptr  ,
                soc_sbx_g3p1_bfd_ld2edata_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_BFD_LD2EDATA_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_g3p1_bfd_ld2edata_index_check(unit, key,
                  iptr  );
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_bfd_ld2edata_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g3p1_bfd_ld2edata_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for bfd_ld2edata */
int soc_sbx_g3p1_bfd_ld2edata_get(int unit,
                  int iptr  ,
                soc_sbx_g3p1_bfd_ld2edata_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_BFD_LD2EDATA_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_g3p1_bfd_ld2edata_index_check(unit, key,
                  iptr  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g3p1_bfd_ld2edata_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for bfd_ld2edatac
*/
int soc_sbx_g3p1_bfd_ld2edatac_data_set(int unit,
                    int iptr  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_bfd_ld2edatac_t entry;

    soc_sbx_g3p1_bfd_ld2edatac_t_init(&entry);
    s = soc_sbx_g3p1_bfd_ld2edatac_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_bfd_ld2edatac_set(unit,   iptr  , &entry);

    return s;
}

/**
New entry get accessor implementation for bfd_ld2edatac
*/
int soc_sbx_g3p1_bfd_ld2edatac_data_get(int unit,
                    int iptr  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_bfd_ld2edatac_t entry;

    soc_sbx_g3p1_bfd_ld2edatac_t_init(&entry);
    s = soc_sbx_g3p1_bfd_ld2edatac_get(unit,   iptr  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_bfd_ld2edatac_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for bfd_ld2edatac
 */

void soc_sbx_g3p1_bfd_ld2edatac_t_init(
    soc_sbx_g3p1_bfd_ld2edatac_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_bfd_ld2edatac_t));
}

/* entry pack accessor implementation for bfd_ld2edatac */
int soc_sbx_g3p1_bfd_ld2edatac_pack(int unit,
    soc_sbx_g3p1_bfd_ld2edatac_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_BFD_LD2EDATAC_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->rMinRxInterval; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for bfd_ld2edatac */
int soc_sbx_g3p1_bfd_ld2edatac_unpack(int unit,
                soc_sbx_g3p1_bfd_ld2edatac_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_BFD_LD2EDATAC_ID];
    int be = tm->behost;
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->rMinRxInterval; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for bfd_ld2edatac */
int soc_sbx_g3p1_bfd_ld2edatac_index_check(int unit,
                int *vindex,
                  int iptr  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_BFD_LD2EDATAC_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iptr; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for bfd_ld2edatac */
int soc_sbx_g3p1_bfd_ld2edatac_entry_check(int unit,
                soc_sbx_g3p1_bfd_ld2edatac_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_BFD_LD2EDATAC_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->rMinRxInterval; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* bfd_ld2edatac table size get */
int soc_sbx_g3p1_bfd_ld2edatac_entry_table_size_get(int unit,
                int *tsize,
                  int iptr  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_BFD_LD2EDATAC_ID];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iptr; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for bfd_ld2edatac */
int soc_sbx_g3p1_bfd_ld2edatac_set(int unit,
                  int iptr  ,
                soc_sbx_g3p1_bfd_ld2edatac_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_BFD_LD2EDATAC_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_g3p1_bfd_ld2edatac_index_check(unit, key,
                  iptr  );
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_bfd_ld2edatac_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g3p1_bfd_ld2edatac_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for bfd_ld2edatac */
int soc_sbx_g3p1_bfd_ld2edatac_get(int unit,
                  int iptr  ,
                soc_sbx_g3p1_bfd_ld2edatac_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_BFD_LD2EDATAC_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_g3p1_bfd_ld2edatac_index_check(unit, key,
                  iptr  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g3p1_bfd_ld2edatac_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for sample6
*/
int soc_sbx_g3p1_sample6_data_set(int unit,
                    int itest6i  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_sample6_t entry;

    soc_sbx_g3p1_sample6_t_init(&entry);
    s = soc_sbx_g3p1_sample6_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_sample6_set(unit,   itest6i  , &entry);

    return s;
}

/**
New entry get accessor implementation for sample6
*/
int soc_sbx_g3p1_sample6_data_get(int unit,
                    int itest6i  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_sample6_t entry;

    soc_sbx_g3p1_sample6_t_init(&entry);
    s = soc_sbx_g3p1_sample6_get(unit,   itest6i  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_sample6_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for sample6
 */

void soc_sbx_g3p1_sample6_t_init(
    soc_sbx_g3p1_sample6_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_sample6_t));
}

/* entry pack accessor implementation for sample6 */
int soc_sbx_g3p1_sample6_pack(int unit,
    soc_sbx_g3p1_sample6_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_SAMPLE6_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pad; break;
        case 1: p = (uint8 *) &e->test6; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for sample6 */
int soc_sbx_g3p1_sample6_unpack(int unit,
                soc_sbx_g3p1_sample6_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_SAMPLE6_ID];
    int be = tm->behost;
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pad; break;
        case 1: p = (uint8 *) &e->test6; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for sample6 */
int soc_sbx_g3p1_sample6_index_check(int unit,
                int *vindex,
                  int itest6i  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_SAMPLE6_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &itest6i; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for sample6 */
int soc_sbx_g3p1_sample6_entry_check(int unit,
                soc_sbx_g3p1_sample6_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_SAMPLE6_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->pad; break;
        case 1: ev = e->test6; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* sample6 table size get */
int soc_sbx_g3p1_sample6_entry_table_size_get(int unit,
                int *tsize,
                  int itest6i  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_SAMPLE6_ID];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = itest6i; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for sample6 */
int soc_sbx_g3p1_sample6_set(int unit,
                  int itest6i  ,
                soc_sbx_g3p1_sample6_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_SAMPLE6_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_g3p1_sample6_index_check(unit, key,
                  itest6i  );
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_sample6_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g3p1_sample6_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for sample6 */
int soc_sbx_g3p1_sample6_get(int unit,
                  int itest6i  ,
                soc_sbx_g3p1_sample6_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_SAMPLE6_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_g3p1_sample6_index_check(unit, key,
                  itest6i  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g3p1_sample6_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for sample8
*/
int soc_sbx_g3p1_sample8_data_set(int unit,
                    int itest8i  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_sample8_t entry;

    soc_sbx_g3p1_sample8_t_init(&entry);
    s = soc_sbx_g3p1_sample8_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_sample8_set(unit,   itest8i  , &entry);

    return s;
}

/**
New entry get accessor implementation for sample8
*/
int soc_sbx_g3p1_sample8_data_get(int unit,
                    int itest8i  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_sample8_t entry;

    soc_sbx_g3p1_sample8_t_init(&entry);
    s = soc_sbx_g3p1_sample8_get(unit,   itest8i  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_sample8_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for sample8
 */

void soc_sbx_g3p1_sample8_t_init(
    soc_sbx_g3p1_sample8_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_sample8_t));
}

/* entry pack accessor implementation for sample8 */
int soc_sbx_g3p1_sample8_pack(int unit,
    soc_sbx_g3p1_sample8_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_SAMPLE8_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pad; break;
        case 1: p = (uint8 *) &e->test8; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for sample8 */
int soc_sbx_g3p1_sample8_unpack(int unit,
                soc_sbx_g3p1_sample8_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_SAMPLE8_ID];
    int be = tm->behost;
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pad; break;
        case 1: p = (uint8 *) &e->test8; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for sample8 */
int soc_sbx_g3p1_sample8_index_check(int unit,
                int *vindex,
                  int itest8i  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_SAMPLE8_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &itest8i; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for sample8 */
int soc_sbx_g3p1_sample8_entry_check(int unit,
                soc_sbx_g3p1_sample8_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_SAMPLE8_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->pad; break;
        case 1: ev = e->test8; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* sample8 table size get */
int soc_sbx_g3p1_sample8_entry_table_size_get(int unit,
                int *tsize,
                  int itest8i  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_SAMPLE8_ID];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = itest8i; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for sample8 */
int soc_sbx_g3p1_sample8_set(int unit,
                  int itest8i  ,
                soc_sbx_g3p1_sample8_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_SAMPLE8_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_g3p1_sample8_index_check(unit, key,
                  itest8i  );
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_sample8_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g3p1_sample8_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for sample8 */
int soc_sbx_g3p1_sample8_get(int unit,
                  int itest8i  ,
                soc_sbx_g3p1_sample8_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_SAMPLE8_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_g3p1_sample8_index_check(unit, key,
                  itest8i  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g3p1_sample8_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          
/**
New entry set accessor implementation for sample9
*/
int soc_sbx_g3p1_sample9_data_set(int unit,
                    int itest9i  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_sample9_t entry;

    soc_sbx_g3p1_sample9_t_init(&entry);
    s = soc_sbx_g3p1_sample9_unpack(unit, &entry, buf, size*8);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_sample9_set(unit,   itest9i  , &entry);

    return s;
}

/**
New entry get accessor implementation for sample9
*/
int soc_sbx_g3p1_sample9_data_get(int unit,
                    int itest9i  ,
                  unsigned char *buf, unsigned char size)
{
    int s;
    soc_sbx_g3p1_sample9_t entry;

    soc_sbx_g3p1_sample9_t_init(&entry);
    s = soc_sbx_g3p1_sample9_get(unit,   itest9i  , &entry);
  	if (s) {
      return s;
  	}
    s = soc_sbx_g3p1_sample9_pack(unit, &entry, buf, size*8);

    return s;
}

/*
 * Entry accessor implementations for sample9
 */

void soc_sbx_g3p1_sample9_t_init(
    soc_sbx_g3p1_sample9_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g3p1_sample9_t));
}

/* entry pack accessor implementation for sample9 */
int soc_sbx_g3p1_sample9_pack(int unit,
    soc_sbx_g3p1_sample9_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p, *base;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_SAMPLE9_ID];
    int be = tm->behost;
	int bytes_to_clear = 0;
	
    base = b;        

    if (be) {
    	/* The data is packed right to left */
        if (bsz <= 32) {
            b += 3;
            bytes_to_clear = 4;
        }
        else if (bsz <= 64) {
            b += 7;
            bytes_to_clear = 8;
        }
		else if (bsz <= 96){
	    	b += 11;
	    	bytes_to_clear = 12;
		}
		else if (bsz <= 128){
	    	b += 15;
	    	bytes_to_clear = 16;
		}
		else if (bsz <= 160){
	    	b += 19;
	    	bytes_to_clear = 20;
		}
    } 
    else {
        bytes_to_clear = bsz / 8;
        if (bsz & 0x7) {
            bytes_to_clear++;
        }
    }

    sal_memset(base, 0, bytes_to_clear); 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pad; break;
        case 1: p = (uint8 *) &e->test9; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nPack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_insert_or(b,
                be, pos, width, p, fbe, 0);
    }
    if (be)  {
        soc_sbx_caladan3_cmic_endian(base, bsz/8);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for sample9 */
int soc_sbx_g3p1_sample9_unpack(int unit,
                soc_sbx_g3p1_sample9_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_SAMPLE9_ID];
    int be = tm->behost;
    sal_memset(e, 0, sizeof(*e));
    if (be) {
        soc_sbx_caladan3_cmic_endian(b, bsz/8);
    }

    if (be) {
    	/* The data is packed right to left */
       if (bsz <= 32) {
            b += 3;            
        }
        else if (bsz <= 64) {
            b += 7;            
        }
        else if (bsz <= 96){
            b += 11;	    	
        }
        else if (bsz <= 128){
            b += 15;	    	
        }
        else if (bsz <= 160){
            b += 19;	    	
        }
    } 

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pad; break;
        case 1: p = (uint8 *) &e->test9; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        /*
        LOG_INFO(BSL_LS_SOC_MEM,
                 (BSL_META_U(unit,
                             "\nUnpack: b:%p p:%p pos:%d width:%d\n"), b,p, pos, width));
        */
        soc_sbx_g3p1_extract(b,
               be, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for sample9 */
int soc_sbx_g3p1_sample9_index_check(int unit,
                int *vindex,
                  int itest9i  )
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_SAMPLE9_ID];
    soc_sbx_g3p1_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &itest9i; break;
        default: return SOC_E_INTERNAL;
        }

        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G3P1_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G3P1_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g3p1_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for sample9 */
int soc_sbx_g3p1_sample9_entry_check(int unit,
                soc_sbx_g3p1_sample9_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_SAMPLE9_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->pad; break;
        case 1: ev = e->test9; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g3p1_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* sample9 table size get */
int soc_sbx_g3p1_sample9_entry_table_size_get(int unit,
                int *tsize,
                  int itest9i  )
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_SAMPLE9_ID];
    soc_sbx_g3p1_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g3p1_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g3p1_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = itest9i; break;
        }

        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        /* coverity[dead_error_line] */
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g3p1_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for sample9 */
int soc_sbx_g3p1_sample9_set(int unit,
                  int itest9i  ,
                soc_sbx_g3p1_sample9_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_SAMPLE9_ID];
    int width_in_words = (ed->epsize + 31)/32;
     
    s = soc_sbx_g3p1_sample9_index_check(unit, key,
                  itest9i  );
    if (s) {
        return s;
    }

    s = soc_sbx_g3p1_sample9_entry_check(unit, e);

    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g3p1_sample9_pack(unit, 
                  e, tm->entrydmabuf, width_in_words * 32);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for sample9 */
int soc_sbx_g3p1_sample9_get(int unit,
                  int itest9i  ,
                soc_sbx_g3p1_sample9_t *e)
{
    int s, key[32];

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_SAMPLE9_ID];
    int width_in_words = (ed->epsize + 31)/32;

    s = soc_sbx_g3p1_sample9_index_check(unit, key,
                  itest9i  );
    if (s) {
        return s;
    }
       
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g3p1_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g3p1_sample9_unpack(unit,
                        e, tm->entrydmabuf, width_in_words * 32);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
          














int soc_sbx_g3p1_pv2e_lpi_fast_get(int unit,
               	  int ivid ,  int iport  ,  int eivid ,  int eiport  , uint32 *vs, int vcount)
{
    int startvindex, endvindex, s;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PV2E_ID];
    soc_sbx_g3p1_field_desc_t *fd =
        &ed->fields[0];

    s = soc_sbx_g3p1_pv2e_index_check(unit, &startvindex,
                  ivid ,  iport  );
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_pv2e_index_check(unit, &endvindex,
                  eivid ,  eiport  );
    if (s) {
        return s;
    }

    if (endvindex - startvindex >= vcount) {
        return SOC_E_PARAM;
    }

    s = soc_sbx_g3p1_entry_generic_fast_get(unit,
                  fd, ed, startvindex, endvindex, vs);

    return s;
}


int soc_sbx_g3p1_pv2e_vlan_fast_get(int unit,
               	  int ivid ,  int iport  ,  int eivid ,  int eiport  , uint32 *vs, int vcount)
{
    int startvindex, endvindex, s;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PV2E_ID];
    soc_sbx_g3p1_field_desc_t *fd =
        &ed->fields[1];

    s = soc_sbx_g3p1_pv2e_index_check(unit, &startvindex,
                  ivid ,  iport  );
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_pv2e_index_check(unit, &endvindex,
                  eivid ,  eiport  );
    if (s) {
        return s;
    }

    if (endvindex - startvindex >= vcount) {
        return SOC_E_PARAM;
    }

    s = soc_sbx_g3p1_entry_generic_fast_get(unit,
                  fd, ed, startvindex, endvindex, vs);

    return s;
}


int soc_sbx_g3p1_pv2e_stpstate_fast_get(int unit,
               	  int ivid ,  int iport  ,  int eivid ,  int eiport  , uint32 *vs, int vcount)
{
    int startvindex, endvindex, s;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PV2E_ID];
    soc_sbx_g3p1_field_desc_t *fd =
        &ed->fields[2];

    s = soc_sbx_g3p1_pv2e_index_check(unit, &startvindex,
                  ivid ,  iport  );
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_pv2e_index_check(unit, &endvindex,
                  eivid ,  eiport  );
    if (s) {
        return s;
    }

    if (endvindex - startvindex >= vcount) {
        return SOC_E_PARAM;
    }

    s = soc_sbx_g3p1_entry_generic_fast_get(unit,
                  fd, ed, startvindex, endvindex, vs);

    return s;
}



int soc_sbx_g3p1_pv2e_lpi_fast_set(int unit,
                  int ivid ,  int iport  ,  int eivid ,  int eiport  ,
                int *sets,
                uint32 *vs,
                int vcount)
{
    int startvindex, endvindex, s;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PV2E_ID];
    soc_sbx_g3p1_field_desc_t *fd =
        &ed->fields[0];

    s = soc_sbx_g3p1_pv2e_index_check(unit, &startvindex,
                  ivid ,  iport  );
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_pv2e_index_check(unit, &endvindex,
                  eivid ,  eiport  );
    if (s) {
        return s;
    }
    if (endvindex - startvindex >= vcount) {
        return SOC_E_PARAM;
    }

    s = soc_sbx_g3p1_entry_generic_fast_set(unit,
                  fd, ed, startvindex, endvindex, sets, vs);

    return s;
}


int soc_sbx_g3p1_pv2e_vlan_fast_set(int unit,
                  int ivid ,  int iport  ,  int eivid ,  int eiport  ,
                int *sets,
                uint32 *vs,
                int vcount)
{
    int startvindex, endvindex, s;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PV2E_ID];
    soc_sbx_g3p1_field_desc_t *fd =
        &ed->fields[1];

    s = soc_sbx_g3p1_pv2e_index_check(unit, &startvindex,
                  ivid ,  iport  );
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_pv2e_index_check(unit, &endvindex,
                  eivid ,  eiport  );
    if (s) {
        return s;
    }
    if (endvindex - startvindex >= vcount) {
        return SOC_E_PARAM;
    }

    s = soc_sbx_g3p1_entry_generic_fast_set(unit,
                  fd, ed, startvindex, endvindex, sets, vs);

    return s;
}


int soc_sbx_g3p1_pv2e_stpstate_fast_set(int unit,
                  int ivid ,  int iport  ,  int eivid ,  int eiport  ,
                int *sets,
                uint32 *vs,
                int vcount)
{
    int startvindex, endvindex, s;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PV2E_ID];
    soc_sbx_g3p1_field_desc_t *fd =
        &ed->fields[2];

    s = soc_sbx_g3p1_pv2e_index_check(unit, &startvindex,
                  ivid ,  iport  );
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_pv2e_index_check(unit, &endvindex,
                  eivid ,  eiport  );
    if (s) {
        return s;
    }
    if (endvindex - startvindex >= vcount) {
        return SOC_E_PARAM;
    }

    s = soc_sbx_g3p1_entry_generic_fast_set(unit,
                  fd, ed, startvindex, endvindex, sets, vs);

    return s;
}





int soc_sbx_g3p1_pv2appdata_member_fast_get(int unit,
               	  int ivid ,  int iport  ,  int eivid ,  int eiport  , uint32 *vs, int vcount)
{
    int startvindex, endvindex, s;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_PV2APPDATA_ID];
    soc_sbx_g3p1_field_desc_t *fd =
        &ed->fields[0];

    s = soc_sbx_g3p1_pv2appdata_index_check(unit, &startvindex,
                  ivid ,  iport  );
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_pv2appdata_index_check(unit, &endvindex,
                  eivid ,  eiport  );
    if (s) {
        return s;
    }

    if (endvindex - startvindex >= vcount) {
        return SOC_E_PARAM;
    }

    s = soc_sbx_g3p1_entry_generic_fast_get(unit,
                  fd, ed, startvindex, endvindex, vs);

    return s;
}





int soc_sbx_g3p1_v2e_policerbypass_fast_set(int unit,
                  int ivlan  ,  int eivlan  ,
                int *sets,
                uint32 *vs,
                int vcount)
{
    int startvindex, endvindex, s;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_V2E_ID];
    soc_sbx_g3p1_field_desc_t *fd =
        &ed->fields[2];

    s = soc_sbx_g3p1_v2e_index_check(unit, &startvindex,
                  ivlan  );
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_v2e_index_check(unit, &endvindex,
                  eivlan  );
    if (s) {
        return s;
    }
    if (endvindex - startvindex >= vcount) {
        return SOC_E_PARAM;
    }

    s = soc_sbx_g3p1_entry_generic_fast_set(unit,
                  fd, ed, startvindex, endvindex, sets, vs);

    return s;
}


int soc_sbx_g3p1_v2e_forceflood_fast_set(int unit,
                  int ivlan  ,  int eivlan  ,
                int *sets,
                uint32 *vs,
                int vcount)
{
    int startvindex, endvindex, s;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_V2E_ID];
    soc_sbx_g3p1_field_desc_t *fd =
        &ed->fields[3];

    s = soc_sbx_g3p1_v2e_index_check(unit, &startvindex,
                  ivlan  );
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_v2e_index_check(unit, &endvindex,
                  eivlan  );
    if (s) {
        return s;
    }
    if (endvindex - startvindex >= vcount) {
        return SOC_E_PARAM;
    }

    s = soc_sbx_g3p1_entry_generic_fast_set(unit,
                  fd, ed, startvindex, endvindex, sets, vs);

    return s;
}


int soc_sbx_g3p1_v2e_dropunkucast_fast_set(int unit,
                  int ivlan  ,  int eivlan  ,
                int *sets,
                uint32 *vs,
                int vcount)
{
    int startvindex, endvindex, s;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_V2E_ID];
    soc_sbx_g3p1_field_desc_t *fd =
        &ed->fields[5];

    s = soc_sbx_g3p1_v2e_index_check(unit, &startvindex,
                  ivlan  );
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_v2e_index_check(unit, &endvindex,
                  eivlan  );
    if (s) {
        return s;
    }
    if (endvindex - startvindex >= vcount) {
        return SOC_E_PARAM;
    }

    s = soc_sbx_g3p1_entry_generic_fast_set(unit,
                  fd, ed, startvindex, endvindex, sets, vs);

    return s;
}


int soc_sbx_g3p1_v2e_dontlearn_fast_set(int unit,
                  int ivlan  ,  int eivlan  ,
                int *sets,
                uint32 *vs,
                int vcount)
{
    int startvindex, endvindex, s;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_V2E_ID];
    soc_sbx_g3p1_field_desc_t *fd =
        &ed->fields[6];

    s = soc_sbx_g3p1_v2e_index_check(unit, &startvindex,
                  ivlan  );
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_v2e_index_check(unit, &endvindex,
                  eivlan  );
    if (s) {
        return s;
    }
    if (endvindex - startvindex >= vcount) {
        return SOC_E_PARAM;
    }

    s = soc_sbx_g3p1_entry_generic_fast_set(unit,
                  fd, ed, startvindex, endvindex, sets, vs);

    return s;
}





int soc_sbx_g3p1_lp_policer_fast_get(int unit,
               	  int ilpi  ,  int eilpi  , uint32 *vs, int vcount)
{
    int startvindex, endvindex, s;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_LP_ID];
    soc_sbx_g3p1_field_desc_t *fd =
        &ed->fields[7];

    s = soc_sbx_g3p1_lp_index_check(unit, &startvindex,
                  ilpi  );
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_lp_index_check(unit, &endvindex,
                  eilpi  );
    if (s) {
        return s;
    }

    if (endvindex - startvindex >= vcount) {
        return SOC_E_PARAM;
    }

    s = soc_sbx_g3p1_entry_generic_fast_get(unit,
                  fd, ed, startvindex, endvindex, vs);

    return s;
}


int soc_sbx_g3p1_lp_counter_fast_get(int unit,
               	  int ilpi  ,  int eilpi  , uint32 *vs, int vcount)
{
    int startvindex, endvindex, s;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_LP_ID];
    soc_sbx_g3p1_field_desc_t *fd =
        &ed->fields[15];

    s = soc_sbx_g3p1_lp_index_check(unit, &startvindex,
                  ilpi  );
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_lp_index_check(unit, &endvindex,
                  eilpi  );
    if (s) {
        return s;
    }

    if (endvindex - startvindex >= vcount) {
        return SOC_E_PARAM;
    }

    s = soc_sbx_g3p1_entry_generic_fast_get(unit,
                  fd, ed, startvindex, endvindex, vs);

    return s;
}



int soc_sbx_g3p1_lp_policer_fast_set(int unit,
                  int ilpi  ,  int eilpi  ,
                int *sets,
                uint32 *vs,
                int vcount)
{
    int startvindex, endvindex, s;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_LP_ID];
    soc_sbx_g3p1_field_desc_t *fd =
        &ed->fields[7];

    s = soc_sbx_g3p1_lp_index_check(unit, &startvindex,
                  ilpi  );
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_lp_index_check(unit, &endvindex,
                  eilpi  );
    if (s) {
        return s;
    }
    if (endvindex - startvindex >= vcount) {
        return SOC_E_PARAM;
    }

    s = soc_sbx_g3p1_entry_generic_fast_set(unit,
                  fd, ed, startvindex, endvindex, sets, vs);

    return s;
}


int soc_sbx_g3p1_lp_counter_fast_set(int unit,
                  int ilpi  ,  int eilpi  ,
                int *sets,
                uint32 *vs,
                int vcount)
{
    int startvindex, endvindex, s;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_LP_ID];
    soc_sbx_g3p1_field_desc_t *fd =
        &ed->fields[15];

    s = soc_sbx_g3p1_lp_index_check(unit, &startvindex,
                  ilpi  );
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_lp_index_check(unit, &endvindex,
                  eilpi  );
    if (s) {
        return s;
    }
    if (endvindex - startvindex >= vcount) {
        return SOC_E_PARAM;
    }

    s = soc_sbx_g3p1_entry_generic_fast_set(unit,
                  fd, ed, startvindex, endvindex, sets, vs);

    return s;
}











int soc_sbx_g3p1_epv2e_drop_fast_set(int unit,
                  int ivid ,  int iport  ,  int eivid ,  int eiport  ,
                int *sets,
                uint32 *vs,
                int vcount)
{
    int startvindex, endvindex, s;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_EPV2E_ID];
    soc_sbx_g3p1_field_desc_t *fd =
        &ed->fields[0];

    s = soc_sbx_g3p1_epv2e_index_check(unit, &startvindex,
                  ivid ,  iport  );
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_epv2e_index_check(unit, &endvindex,
                  eivid ,  eiport  );
    if (s) {
        return s;
    }
    if (endvindex - startvindex >= vcount) {
        return SOC_E_PARAM;
    }

    s = soc_sbx_g3p1_entry_generic_fast_set(unit,
                  fd, ed, startvindex, endvindex, sets, vs);

    return s;
}


int soc_sbx_g3p1_epv2e_strip_fast_set(int unit,
                  int ivid ,  int iport  ,  int eivid ,  int eiport  ,
                int *sets,
                uint32 *vs,
                int vcount)
{
    int startvindex, endvindex, s;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G3P1_EPV2E_ID];
    soc_sbx_g3p1_field_desc_t *fd =
        &ed->fields[1];

    s = soc_sbx_g3p1_epv2e_index_check(unit, &startvindex,
                  ivid ,  iport  );
    if (s) {
        return s;
    }
    s = soc_sbx_g3p1_epv2e_index_check(unit, &endvindex,
                  eivid ,  eiport  );
    if (s) {
        return s;
    }
    if (endvindex - startvindex >= vcount) {
        return SOC_E_PARAM;
    }

    s = soc_sbx_g3p1_entry_generic_fast_set(unit,
                  fd, ed, startvindex, endvindex, sets, vs);

    return s;
}
















static int soc_sbx_g3p1_memory_init(int unit, soc_sbx_g3p1_table_manager_t *tm) {  
	int i, j, s;
	char *e="";
	
	/*
     * Per-memory state initialization
     */
    tm->memories = UTG_MALLOC(sizeof(soc_sbx_g3p1_memory_desc_t)
                              * SOC_SBX_G3P1_MEMORY_MAX_ID);
    if (!tm->memories) {
        soc_sbx_g3p1_uninit(unit);
        return SOC_E_MEMORY;
    }

    tm->memories[SOC_SBX_G3P1_LRP_PORT0_ID]
        .name = "lrp_port0";
    tm->memories[SOC_SBX_G3P1_LRP_PORT0_ID]
        .ocmport = 0;
    tm->memories[SOC_SBX_G3P1_LRP_PORT0_ID]
        .dma = 1;
    tm->memories[SOC_SBX_G3P1_LRP_PORT0_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G3P1_LRP_PORT0_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G3P1_LRP_PORT1_ID]
        .name = "lrp_port1";
    tm->memories[SOC_SBX_G3P1_LRP_PORT1_ID]
        .ocmport = 1;
    tm->memories[SOC_SBX_G3P1_LRP_PORT1_ID]
        .dma = 1;
    tm->memories[SOC_SBX_G3P1_LRP_PORT1_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G3P1_LRP_PORT1_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G3P1_LRP_PORT8_ID]
        .name = "lrp_port8";
    tm->memories[SOC_SBX_G3P1_LRP_PORT8_ID]
        .ocmport = 11;
    tm->memories[SOC_SBX_G3P1_LRP_PORT8_ID]
        .dma = 1;
    tm->memories[SOC_SBX_G3P1_LRP_PORT8_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G3P1_LRP_PORT8_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G3P1_LRP_PORT2_ID]
        .name = "lrp_port2";
    tm->memories[SOC_SBX_G3P1_LRP_PORT2_ID]
        .ocmport = 2;
    tm->memories[SOC_SBX_G3P1_LRP_PORT2_ID]
        .dma = 1;
    tm->memories[SOC_SBX_G3P1_LRP_PORT2_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G3P1_LRP_PORT2_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G3P1_LRP_PORT3_ID]
        .name = "lrp_port3";
    tm->memories[SOC_SBX_G3P1_LRP_PORT3_ID]
        .ocmport = 3;
    tm->memories[SOC_SBX_G3P1_LRP_PORT3_ID]
        .dma = 1;
    tm->memories[SOC_SBX_G3P1_LRP_PORT3_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G3P1_LRP_PORT3_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G3P1_LRP_PORT4_ID]
        .name = "lrp_port4";
    tm->memories[SOC_SBX_G3P1_LRP_PORT4_ID]
        .ocmport = 4;
    tm->memories[SOC_SBX_G3P1_LRP_PORT4_ID]
        .dma = 1;
    tm->memories[SOC_SBX_G3P1_LRP_PORT4_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G3P1_LRP_PORT4_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G3P1_CMU0_PORT_ID]
        .name = "cmu0_port";
    tm->memories[SOC_SBX_G3P1_CMU0_PORT_ID]
        .ocmport = 6;
    tm->memories[SOC_SBX_G3P1_CMU0_PORT_ID]
        .dma = 1;
    tm->memories[SOC_SBX_G3P1_CMU0_PORT_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G3P1_CMU0_PORT_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G3P1_COP0_PORT_ID]
        .name = "cop0_port";
    tm->memories[SOC_SBX_G3P1_COP0_PORT_ID]
        .ocmport = 7;
    tm->memories[SOC_SBX_G3P1_COP0_PORT_ID]
        .dma = 1;
    tm->memories[SOC_SBX_G3P1_COP0_PORT_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G3P1_COP0_PORT_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G3P1_BUBBLE_PORT_ID]
        .name = "bubble_port";
    tm->memories[SOC_SBX_G3P1_BUBBLE_PORT_ID]
        .ocmport = 8;
    tm->memories[SOC_SBX_G3P1_BUBBLE_PORT_ID]
        .dma = 1;
    tm->memories[SOC_SBX_G3P1_BUBBLE_PORT_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G3P1_BUBBLE_PORT_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G3P1_LRP_PORT5_ID]
        .name = "lrp_port5";
    tm->memories[SOC_SBX_G3P1_LRP_PORT5_ID]
        .ocmport = 5;
    tm->memories[SOC_SBX_G3P1_LRP_PORT5_ID]
        .dma = 1;
    tm->memories[SOC_SBX_G3P1_LRP_PORT5_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G3P1_LRP_PORT5_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G3P1_LRP_PORT9_ID]
        .name = "lrp_port9";
    tm->memories[SOC_SBX_G3P1_LRP_PORT9_ID]
        .ocmport = 12;
    tm->memories[SOC_SBX_G3P1_LRP_PORT9_ID]
        .dma = 1;
    tm->memories[SOC_SBX_G3P1_LRP_PORT9_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G3P1_LRP_PORT9_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G3P1_LRP_PORT6_ID]
        .name = "lrp_port6";
    tm->memories[SOC_SBX_G3P1_LRP_PORT6_ID]
        .ocmport = 9;
    tm->memories[SOC_SBX_G3P1_LRP_PORT6_ID]
        .dma = 1;
    tm->memories[SOC_SBX_G3P1_LRP_PORT6_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G3P1_LRP_PORT6_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G3P1_LRP_PORT7_ID]
        .name = "lrp_port7";
    tm->memories[SOC_SBX_G3P1_LRP_PORT7_ID]
        .ocmport = 10;
    tm->memories[SOC_SBX_G3P1_LRP_PORT7_ID]
        .dma = 1;
    tm->memories[SOC_SBX_G3P1_LRP_PORT7_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G3P1_LRP_PORT7_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G3P1_CMU1_PORT_ID]
        .name = "cmu1_port";
    tm->memories[SOC_SBX_G3P1_CMU1_PORT_ID]
        .ocmport = 13;
    tm->memories[SOC_SBX_G3P1_CMU1_PORT_ID]
        .dma = 1;
    tm->memories[SOC_SBX_G3P1_CMU1_PORT_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G3P1_CMU1_PORT_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G3P1_COP1_PORT_ID]
        .name = "cop1_port";
    tm->memories[SOC_SBX_G3P1_COP1_PORT_ID]
        .ocmport = 14;
    tm->memories[SOC_SBX_G3P1_COP1_PORT_ID]
        .dma = 1;
    tm->memories[SOC_SBX_G3P1_COP1_PORT_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G3P1_COP1_PORT_ID].alignedlist = -1;

    for (i = 0; i < SOC_SBX_G3P1_MEMORY_MAX_ID; i++) {
        s = soc_sbx_g3p1_ucode_get(unit,
                  soc_sbx_g3p1_sym,
                  128,
                  &tm->memories[i].width,
                  e,
                  tm->memories[i].name, 
                  -1,
                  e,
                  "WIDTH");
        if (s) {
            soc_sbx_g3p1_uninit(unit);
            return s;
        }
        s = soc_sbx_g3p1_ucode_get(unit,
                  soc_sbx_g3p1_sym,
                  128,
                  &tm->memories[i].size,
                  e,
                  tm->memories[i].name, 
                  -1,
                  e,
                  "SIZE");
        if (s) {
            soc_sbx_g3p1_uninit(unit);
            return s;
        }
    }

    j = 0;

    for (i = 0; i < SOC_SBX_G3P1_TABLE_MAX_ID; i++){
        j += tm->tables[i].nbanks;
    }

    tm->memorybanks = UTG_MALLOC(sizeof(soc_sbx_g3p1_memory_bank_desc_t) * j);
    if (!tm->memorybanks) {
        soc_sbx_g3p1_uninit(unit);
        return SOC_E_MEMORY;
    }

    soc_sbx_g3p1_memory_banks_init(tm);
    /* soc_sbx_g3p1_tables_aligned_topo_sort(unit); */

    tm->bufsize = 1024;
    tm->entrydmabuf = soc_cm_salloc(unit, tm->bufsize * sizeof(uint32),
                             "entry dma");
    if (!tm->entrydmabuf) {
        return SOC_E_MEMORY;
    }

    tm->dmabufmutex = sal_mutex_create("dma mutex");
    if (!tm->dmabufmutex) {
        return SOC_E_RESOURCE;
    }

    /* Sim support */
    tm->simbuffer = UTG_MALLOC(1024);
    if (!tm->simbuffer) {
        return SOC_E_MEMORY;
    }
    tm->simbuffersize = 1024;

    return SOC_E_NONE;
}

/*
 * Microcode definitions subsystem initializer implementation
 */
int soc_sbx_g3p1_init(int unit, void *ucode)
{    
    int rv;
    uint32 v;
    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm;

    soc_sbx_g3p1_errsym = soc_sbx_g3p1_sym;

    if (fe->tableinfo) {
        /* Free old info */
        soc_sbx_g3p1_uninit(unit);
    }

    tm = UTG_MALLOC(sizeof(soc_sbx_g3p1_table_manager_t));
    if (!tm) {
      return SOC_E_MEMORY;
    }
    sal_memset(tm, 0, sizeof(soc_sbx_g3p1_table_manager_t));
    fe->tableinfo = tm;
    fe->regSet = (void*)unit;
    fe->unit = unit;
    fe->ucode = ucode;
   
    v = 0x1;
    tm->behost = !*((uint8 *) &v);
    
    rv = soc_sbx_g3p1_consts_init(unit, tm);
    if (rv != SOC_E_NONE) {
    	soc_sbx_g3p1_uninit(unit);
    	return rv;
    }
    
    rv = soc_sbx_g3p1_globals_init(unit, tm);
    if (rv != SOC_E_NONE) {
    	soc_sbx_g3p1_uninit(unit);
    	return rv;
    }
    
    rv = soc_sbx_g3p1_tables_init(unit, tm);
    if (rv != SOC_E_NONE) {
    	soc_sbx_g3p1_uninit(unit);
    	return rv;
    }
    
    rv = soc_sbx_g3p1_entries_init(unit, tm);
    if (rv != SOC_E_NONE) {
    	soc_sbx_g3p1_uninit(unit);
    	return rv;
    }
    
    rv = soc_sbx_g3p1_memory_init(unit, tm);
    if (rv != SOC_E_NONE) {
    	soc_sbx_g3p1_uninit(unit);
    	return rv;
    }
    
    return SOC_E_NONE;
}

/* Uninitialization function implementation */
int soc_sbx_g3p1_uninit(int unit)
{
    int i;
    int s = SOC_E_NONE;

    soc_sbx_g3p1_state_t *fe =
        (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm;

    if (!fe->tableinfo) return s;
    tm = fe->tableinfo;
    if (tm->entrydmabuf) soc_cm_sfree(unit, tm->entrydmabuf);
    if (tm->dmabufmutex) sal_mutex_destroy(tm->dmabufmutex);
    if (tm->memorybanks) UTG_FREE(tm->memorybanks);
    if (tm->memories)    UTG_FREE(tm->memories);
    if (tm->entries) {
        for (i = 0; i < SOC_SBX_G3P1_ENTRY_MAX_ID; i++) {
            if (tm->entries[i].fields) {
                UTG_FREE(tm->entries[i].fields);
            }
            if (tm->entries[i].indexes) {
                UTG_FREE(tm->entries[i].indexes);
            }
        }
        UTG_FREE(tm->entries);
    }
    if (tm->tables) {
        UTG_FREE(tm->tables);
    }
    if (tm->globals)     UTG_FREE(tm->globals);
    if (tm->constants)   UTG_FREE(tm->constants);
    if (tm->simbuffer)   UTG_FREE(tm->simbuffer);
    UTG_FREE(tm);
    fe->tableinfo = NULL;

    return s;
}

/*
 * Memory accessor implementation
 */
int soc_sbx_g3p1_memory_params_get(int unit, int mid,
                soc_sbx_g3p1_memory_params_t *mp)
{
    soc_sbx_g3p1_state_t *fe =
      (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_memory_desc_t *md;

    if (mid > SOC_SBX_G3P1_MEMORY_MAX_ID) {
        return SOC_E_PARAM;
    }
    md = &tm->memories[mid];
    if (!md->dma) {
        return SOC_E_PARAM;
    }
    
    mp->width = md->width;
    mp->size = md->size;

    return SOC_E_NONE;
}

int soc_sbx_g3p1_memory_size_set(int unit, int mid, int size)

{
    soc_sbx_g3p1_state_t *fe =
      (soc_sbx_g3p1_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g3p1_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g3p1_memory_desc_t *md;

    if (mid > SOC_SBX_G3P1_MEMORY_MAX_ID) {
        return SOC_E_PARAM;
    }
    md = &tm->memories[mid];
    if (!md->dma) {
        return SOC_E_PARAM;
    }
    
    md->size = size;

    return SOC_E_NONE;
}

#endif

